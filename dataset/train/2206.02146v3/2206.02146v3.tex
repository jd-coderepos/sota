\documentclass{article}



\PassOptionsToPackage{numbers, compress}{natbib}



\usepackage[final]{neurips_2022}








\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{capt-of}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{multirow}
\usepackage{amsmath}


\usepackage{amsmath}
\usepackage{ overpic}
\usepackage{multirow, makecell}
\newcommand{\R}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\B}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\definecolor{shadecolor}{rgb}{0.92,0.92,0.92}
\newcommand{\MC}[1]{\multicolumn{2}{c} {#1}}
\newcommand{\ie}{\textit{i}.\textit{e}.}
\newcommand{\eg}{\textit{e}.\textit{g}.}
\newcommand{\vs}{\textit{v}.\textit{s}.}
\newcommand{\etc}{\textit{etc}}
\newcommand{\etal}{\textit{et al}.}
\newcommand{\cmark}{\text{\ding{51}}}\newcommand{\xmark}{\text{\ding{55}}}\def\comp{\ensuremath\mathop{\scalebox{.6}{}}}
\newcommand{\RT}[1]{\textcolor{blue}{\textbf{[RT:} \textit{#1}\textbf{]}}}
\newcommand{\EI}[1]{\textcolor{orange}{\textbf{[EI:} \textit{#1}\textbf{]}}}
\usepackage{adjustbox}
\makeatletter \@namedef{ver@everyshi.sty}{}
\makeatother
\newcommand{\widthscale}{0.10}
\newcommand{\widthscalefive}{0.105}
\newcommand{\name}{0}
\newcommand{\h}{0}
\newcommand{\w}{0.15}
\newcommand{\wa}{0.15}
\newlength \g
\usepackage{subcaption}
\usepackage{wrapfig}

\usepackage{enumitem}
\setlist[itemize]{align=parleft,left=0pt..1em}



\title{Recurrent Video Restoration Transformer with Guided Deformable Attention}




\author{
  \makecell{Jingyun Liang, \hspace{3pt}
  Yuchen Fan, \hspace{3pt}
  Xiaoyu Xiang, \hspace{3pt}
  Rakesh Ranjan, \hspace{3pt}
  Eddy Ilg \\
  Simon Green, \hspace{3pt}
  Jiezhang Cao, \hspace{3pt}
  Kai Zhang\thanks{Corresponding Author}, \hspace{3pt}
  Radu Timofte, \hspace{3pt}
  Luc Van Gool \hspace{3pt}}\\
  \\
  \hspace{-0.4cm}Computer Vision Lab, ETH Zurich, Switzerland \hspace{0pt}
  Meta Inc. \hspace{0pt}
  University of Wurzburg, Germany\\
}



\begin{document}


\maketitle

\begin{abstract}
Video restoration aims at restoring multiple high-quality frames from multiple low-quality frames. Existing video restoration methods generally fall into two extreme cases, \ie, they either restore all frames in parallel or restore the video frame by frame in a recurrent way, which would result in different merits and drawbacks. Typically, the former has the advantage of temporal information fusion. However, it suffers from large model size and intensive memory consumption; the latter has a relatively small model size as it shares parameters across frames; however, it lacks long-range dependency modeling ability and parallelizability. In this paper, we attempt to integrate the advantages of the two cases by proposing a recurrent video restoration transformer, namely RVRT. RVRT processes local neighboring frames in parallel within a globally recurrent framework which can achieve a good trade-off between model size, effectiveness, and efficiency. Specifically, RVRT divides the video into multiple clips and uses the previously inferred clip feature to estimate the subsequent clip feature. Within each clip, different frame features are jointly updated with implicit feature aggregation. Across different clips, the guided deformable attention is designed for clip-to-clip alignment, which predicts multiple relevant locations from the whole inferred clip and aggregates their features by the attention mechanism. Extensive experiments on video super-resolution, deblurring, and denoising show that the proposed RVRT achieves state-of-the-art performance on benchmark datasets with balanced model size, testing memory and runtime. The codes are available at \url{https://github.com/JingyunLiang/RVRT}.
\end{abstract}




\section{Introduction}
Video restoration, such as video super-resolution, deblurring, and denoising, has become a hot topic in recent years. It aims to restore a clear and sharp high-quality video from a degraded (\eg, downsampled, blurred, or noisy) low-quality video~\cite{wang2019edvr, chan2021basicvsr++, cao2021videosr, liang2022vrt}. It has wide applications in live streaming~\cite{zhang2020improving}, video surveillance~\cite{liu2022video}, old film restoration~\cite{wan2022bringing}, and more.

Parallel methods and recurrent methods have been dominant strategies for solving various video restoration problems. Typically, those two kinds of methods have their respective merits and demerits. Parallel methods~\cite{caballero2017VESPCN,huang2017video,wang2019edvr,tian2020tdan,li2020mucan,su2017dvddeblur,zhou2019spatio,isobe2020tga,li2021arvo,cao2021videosr, liang2022vrt} support distributed deployment and achieve good performance by directly fusing information from multiple frames, but they often have a large model size and consume enormous memory for long-sequence videos. In the meanwhile, recurrent models~\cite{huang2015bidirectional,sajjadi2018FRVSR,fuoli2019rlsp,haris2019RBPN,isobe2020rsdn,isobe2020rrn,chan2021basicvsr,chan2021basicvsr++,lin2021fdan,nah2019recurrent,zhong2020efficient,son2021recurrent} reuse the same network block to save parameters and predict the new frame feature based on the previously refined frame feature, but the sequential processing strategy inevitably leads to information loss and noise amplification~\cite{chu2020learning} for long-range dependency modelling and makes it hard to be parallelized.

Considering the advantages and disadvantages of parallel and recurrent methods, in this paper, we propose a recurrent video restoration transformer (RVRT) that takes {the best of both worlds}. On the one hand, RVRT introduces the recurrent design into transformer-based models to reduce model parameters and memory usage. On the other hand, it processes neighboring frames together as a clip to reduce video sequence length and alleviate information loss. To be specific, we first divide the video into fixed-length video clips. Then, starting from the first clip, we refine the subsequent clip feature based on the previously inferred clip feature and the old features of the current clip from shallower layers. Within each clip, different frame features are jointly extracted, implicitly aligned and effectively fused by the self-attention mechanism~\cite{vaswani2017transformer, liu2021swin, liang21swinir}. Across different clips, information is accumulated clip by clip with a larger hidden state than previous recurrent methods.

To implement the above RVRT model, one big challenge is how to align different video clips when using the previous clip for feature refinement. Most existing alignment techniques~\cite{ranjan2017spynet, sun2018pwc, sajjadi2018FRVSR, xue2019TOFlow-Vimeo-90K, chan2021basicvsr, dai2017deformable, tian2020tdan, wang2019edvr, chan2021basicvsr++, liang2022vrt} are designed for frame-to-frame alignment. One possible way to apply them to clip-to-clip alignment is by introducing an extra feature fusion stage after aligning all frame pairs. Instead, we propose an one-stage {video-to-video alignment} method named guided deformable attention (GDA). More specifically, for a reference location in the target clip, we first estimate the coordinates of multiple relevant locations from different frames in the supporting clip under the guidance of optical flow, and then aggregate features of all locations dynamically by the attention mechanism.

GDA has several advantages over previous alignment methods: 1) Compared with optical flow-based warping that only samples one point from one frame~\cite{sajjadi2018FRVSR, xue2019TOFlow-Vimeo-90K, chan2021basicvsr}, GDA benefits from multiple relevant locations sampled from the video clip. 2) Unlike mutual attention~\cite{liang2022vrt}, GDA utilizes features from arbitrary locations without suffering from the small receptive field in local attention or the huge computation burden in global attention. Besides, GDA allows direct attention on non-integer locations with bilinear interpolation. 3) In contrast to deformable convolution~\cite{dai2017deformable, zhu2019deformable, tian2020tdan, wang2019edvr, chan2021basicvsr++, chan2021understanding} that uses a fixed weight in feature aggregation, GDA generates dynamic weights to aggregate features from different locations. It also supports arbitrary location numbers and allows for both frame-to-frame and video-to-video alignment without any modification.

Our contributions can be summarized as follows:
\begin{itemize}
\item We propose the recurrent video restoration transformer (RVRT) that extracts features of local neighboring frames from one clip in a joint and parallel way, and refines clip features by accumulating information from previous clips and previous layers. By reducing the video sequence length and transmitting information with a larger hidden state, RVRT alleviates information loss and noise amplification in recurrent networks, and also makes it possible to partially parallelize the model.
\item We propose the guided deformable attention (GDA) for one-stage video clip-to-clip alignment. It dynamically aggregates information of relevant locations from the supporting clip.
\item Extensive experiments on eight benchmark datasets show that the proposed model achieves state-of-the-art performance in three challenging video restoration tasks: video super-resolution, video deblurring, and video denoising, with balanced model size, memory usage and runtime.
\end{itemize}



\section{Related Work}

\subsection{Video Restoration}
\paragraph{Parallel vs. recurrent methods.} Most existing video restoration methods can be classified as parallel or recurrent methods according to their parallelizability. Parallel methods estimate all frames simultaneously, as the refinement of one frame feature is not dependent on the update of other frame features. They can be further divided as sliding window-based methods~\cite{caballero2017VESPCN,huang2017video,wang2019edvr,tassano2019dvdnet,tian2020tdan,wang2020deep,li2020mucan,su2017dvddeblur,zhou2019spatio,zhou2019spatio,isobe2020tga,tassano2020fastdvdnet,sheth2021unsupervised,li2021arvo} and transformer-based methods~\cite{cao2021videosr,liang2022vrt}. The former kind of methods typically restore merely the center frame from the neighboring frames and are often tested in a sliding window fashion rather than in parallel. These methods generally consist of four stages: feature extraction, feature alignment, feature fusion, and frame reconstruction. Particularly, in the feature alignment stage, they often align all frames towards the center frame, which leads to quadratic complexity with respect to video length and is hard to be extended for long-sequence videos. Instead, the latter kind of method reconstructs all frames at a time based on the transformer architectures. They jointly extract, align, and fuse features for all frames, achieving significant performance improvements against previous methods. However, current transformer-based methods are laid up with a huge model size and large memory consumption. Different from above parallel methods, recurrent methods~\cite{huang2015bidirectional,sajjadi2018FRVSR,fuoli2019rlsp,haris2019RBPN,xiang2020zooming,isobe2020rsdn,isobe2020rrn,chan2021basicvsr,chan2021basicvsr++,lin2021fdan,nah2019recurrent,zhong2020efficient,son2021recurrent,lin2022flow,cao2022towards} propagate latent features from one frame to the next frame sequentially, where information of previous frames is accumulated for the restoration of later frames. Basically, they are composed of three stages: feature extraction, feature propagation and frame reconstruction. Due to the recurrent nature of feature propagation, recurrent methods suffer from information loss and the inapplicability of distributed deployment. 
 
\vspace{-3mm}
\paragraph{Alignment in video restoration.}
Unlike image restoration that mainly focuses on feature extraction~\cite{dong2014srcnn, zhang2017DnCNN, zhang2018srmd, zhang2018rcan, liang2021fkp, liang21hcflow, liang21manet, sun2021mefnet, kai2021bsrgan, zhang2022practical}, how to align multiple highly-related but misaligned frames is another key problem in video restoration. Traditionally, many methods~\cite{liao2015video,kappeler2016video,caballero2017VESPCN,liu2017robust,tao2017detail, caballero2017real, xue2019TOFlow-Vimeo-90K, chan2021basicvsr} first estimate the optical flow between neighbouring frames~\cite{dosovitskiy2015flownet,ranjan2017spynet,sun2018pwc} and then conduct image warping for alignment. Other techniques, such as deformable convolution~\cite{dai2017deformable, zhu2019deformable,tian2020tdan, wang2019edvr, chan2021basicvsr++, cao2021videosr}, dynamic filter~\cite{jo2018DUF} and mutual attention~\cite{liang2022vrt}, have also been exploited for implicit feature alignment. 


\subsection{Vision Transformer}
Transformer~\cite{vaswani2017transformer} is the de-facto standard architecture in natural language processing. Recently, it has been used in dealing with vision problems by viewing pixels or image patches as tokens~\cite{carion2020DETR, dosovitskiy2020ViT}, achieving remarkable performance gains in various computer vision tasks, including image classification~\cite{dosovitskiy2020ViT, li2021localvit, liu2021swin, tu2022maxvit}, object detection~\cite{vaswani2021SAhaloing, liu2020deep, xia2022vision}, semantic segmentation~\cite{wu2020visual, dong2021cswin, sun2021boosting}, \etc. It also achieves promising results in restoration tasks~\cite{chen2021IPT, liang21swinir, wang2021uformer, lin2022flow, cao2021videosr, liang2022vrt, fuoli2022fast, geng2022rstt, cao2022vdtr, yun2022coarse, liu2022learning, tu2022maxim, cao2022practical}. In particular, for video restoration, Cao~\etal~\cite{cao2021videosr} propose the first transformer model for video SR, while Liang~\etal~\cite{liang2022vrt} propose an unified framework for video SR, deblurring and denoising.

We note that some transformer-based works~\cite{zhu2020deformable, xia2022vision} have tried to combine the concept of deformation~\cite{dai2017deformable, zhu2019deformable} with the attention mechanism~\cite{vaswani2017transformer}. Zhu~\etal~\cite{zhu2020deformable} directly predicts the attention weight from the query feature without considering its feature interaction with supporting locations. Xia~\etal~\cite{xia2022vision} place the supporting points uniformly on the image to make use of global information. Both above two methods are proposed for recognition tasks such as object detection, which is fundamentally different from video alignment in video restoration. Lin~\etal~\cite{lin2022flow} use pixel-level or patch-level attention to aggregate information from neighbouring frames under the guidance of optical flow, but it only samples one supporting pixel or patch from one frame, restricting the model from attending to multiple distant locations. 


\begin{figure*}[!tbp]
\captionsetup{font=small}\scriptsize
\begin{center}
\begin{overpic}[width=14cm]{figures/arch.pdf}





\end{overpic}
\end{center}\vspace{-0.2cm}
\caption{The architecture of recurrent video restoration transformer (RVRT). From left to right, it consists of shallow feature extraction, recurrent feature refinement and HQ frame reconstruction. In recurrent feature refinement (RFR, see more details in Fig.~\ref{fig:rfr}), we divide the video into -frame clips ( in this figure) and process frames in one clip in parallel within a globally recurrent framework in time. Multiple refinement layers are stacked for better performance.}
\label{fig:framework}
\end{figure*}

\section{Methodology}
\subsection{Overall Architecture}
Given a low-quality video sequence , where , ,  and  are the video length, height, width and channel, respectively, the goal of video restoration is to reconstruct the high-quality video , where  is the scale factor. To reach this goal, we propose a recurrent video restoration transformer, as illustrated in Fig.~\ref{fig:framework}. The model consists of three parts: shallow feature extraction, recurrent feature refinement and HQ frame reconstruction. More specifically, in shallow feature extraction, we first use a convolution layer to extract features from the LQ video. For deblurring and denoising (\ie, ), we additionally add two strided convolution layers to downsample the feature and reduce computation burden in the next layers. After that, several Residual Swin Transformer Blocks (RSTBs)~\cite{liang21swinir} are used to extract the shallow feature. Then, we use recurrent feature refinement modules for temporal correspondence modeling and guided deformable attention for video alignment, which are detailed in Sec.~\ref{sec:rtfp} and Sec.~\ref{sec:gda}, respectively. Lastly, we add several RSTBs to generate the final feature and reconstruct the HQ video  by pixel shuffle layer~\cite{shi2016subpixel}. For training, the Charbonnier loss~\cite{charbonnier1994Charbonnier}  () is used for all tasks.


\begin{wrapfigure}{r}{5.7cm}
\captionsetup{font=small}\scriptsize
\begin{center}
\vspace{-0.9cm}
\begin{overpic}[width=5.3cm]{figures/rfr.pdf}
\put(12,84.5){\color{black}{\tiny }}
\put(30,84.5){\color{black}{\tiny }}
\put(48,84.5){\color{black}{\tiny }}
\put(12,52){\color{black}{\tiny }}
\put(30,52){\color{black}{\tiny }}
\put(48,52){\color{black}{\tiny }}
\put(39,14){\color{black}{\tiny }}


\end{overpic}
\end{center}\vspace{-1cm}
\caption{The illustrations of recurrent feature refinement (RFR). The -th clip feature  from the -th layer is aligned towards the -th clip as  by guided deformable attention (GDA, see more details in Fig.~\ref{fig:gda}).  and  are then refined as  by several modified residual swin transformer blocks (MRSTBs), in which different frames are jointly processed in a parallel way.}
\label{fig:rfr}
\end{wrapfigure}


\subsection{Recurrent Feature Refinement}
\label{sec:rtfp}
We stack  recurrent feature refinement modules to refine the video feature by exploiting the temporal correspondence between different frames. To make a trade-off between recurrent and transformer-based methods, we process  frames locally in parallel on the basis of a globally recurrent framework.

Formally, given the video feature  from the -th layer, we first reshape it as a 5-dimensional tensor  by dividing it into  video clip features: . Each clip feature  () has  neighbouring frame features: . To utilize information from neighbouring clips, we align the -th clip feature  towards the -th clip based on the optical flow , clip feature  and clip feature . This is formulated as follows:

where  is the guided deformable attention and  is the aligned clip feature. The details of GDA will be described in Sec.~\ref{sec:gda}.

Similar to recurrent neural networks~\cite{sajjadi2018FRVSR, chan2021basicvsr, chan2021basicvsr++}, as shown in Fig.~\ref{fig:rfr}, we update the clip feature of each time step as follows:

where  is the output of the shallow feature extraction module and  are from previous recurrent feature refinement modules.  is the recurrent feature refinement module that consists of a convolution layer for feature fusion and several modified residual Swin Transformer blocks () for feature refinement. In , we upgrade the original 2D  attention window to the 3D  attention window, so that every frame in the clip can attend to itself and other frames simultaneously, allowing implicit feature aggregation. In addition, in order to accumulate information forward and backward in time, we reverse the video sequence for all even recurrent feature refinement modules~\cite{huang2015bidirectional, chan2021basicvsr++}.

The above recurrent feature refinement module is the key component of the proposed RVRT model. Globally, features of different video clips are propagated in a recurrent way. Locally, features of different frames are updated jointly in parallel. For an arbitrary single frame, it can make full use of global information accumulated in time and local information extracted together by the self-attention mechanism. As we can see, RVRT is a generalization of both recurrent and transformer models. It becomes a recurrent model when  or a transformer model when . This is fundamentally different from previous methods that adopt transformer blocks to replace CNN blocks within a recurrent architecture~\cite{wan2022bringing, lin2022flow}. It is also different from existing attempts in natural language processing~\cite{wang2019r, lei2020mart}.


\begin{figure*}[!tbp]
\captionsetup{font=small}\scriptsize
\begin{center}
\begin{overpic}[height=8.5cm]{figures/gda.pdf}
\put(66,62){\color{black}{\tiny }}
\put(66,15){\color{black}{\tiny }}
\put(92,62){\color{black}{\tiny }}
\put(96,15){\color{black}{\tiny }}
\put(5,5){\color{black}{\tiny }}

\put(30,62){\color{black}{\tiny }}
\put(44,28){\color{black}{\tiny }}
\put(65,25){\color{black}{\tiny }}
\put(66.5,40){\color{black}{\tiny }}
\put(74,40){\color{black}{\tiny }}

\end{overpic}
\end{center}\vspace{-0.2cm}
\caption{The illustrations of guided deformable attention (GDA). We estimate offsets of multiple relevant locations from different frames based on the warped clip, and then aggregate features of different locations dynamically by the attention mechanism.  is the -th clip feature from the -th layer, while  and  are the pre-aligned and aligned features of .  and  denote optical flows and offsets, respectively.}
\label{fig:gda}
\end{figure*}

\subsection{Guided Deformable Attention for Video Alignment}
\label{sec:gda}
Different from previous frameworks, the proposed RVRT needs to align neighboring related but misaligned video clips, as indicated in Eq.~\eqref{eq:fda}. In this subsection, we propose the guided deformation attention (GDA) for video clip-to-clip alignment.

Given the -th clip feature  from the -th layer, our goal is to align  towards the -th clip as a list of features , where  denotes the aligned clip feature towards the -th frame feature  of the -th clip, and  is the aligned frame feature from the -th frame in the -th clip to the -th frame in the -th clip. Inspired by optical flow estimation designs~\cite{dosovitskiy2015flownet, pytorch-spynet, sun2018pwc, chan2021basicvsr++, lin2022flow}, we first pre-align  with the optical flow  as , where  denotes the warping operation. For convenience, we summarize the pre-alignments of all ``-to-'' () frame pairs between the -th and -th video clips as follows:


After that, we predict the optical flow offsets  from the concatenation of ,  and  along the channel dimension. A small convolutional neural network (CNN) with several convolutional layers and ReLU layers is used for prediction. This is formulated as

where the current misalignment between the -th clip feature and the warped -th clip features can reflect the offset required for further alignment. In practice, we initialize  as the optical flows estimated from the LQ input video via SpyNet~\cite{ranjan2017spynet}, and predict  offsets for each frame ( offsets in total). The optical flows are updated layer by layer as follows:

where  denotes the -th offset in  predictions from the -th frame to the -th frame.

Then, for the -th frame of the -th clip, we sample its relevant features from the -th clip feature  according the predicted locations, which are indicated by the sum of optical flow and offsets, \ie, , according to the chain relationship ~\cite{chan2021basicvsr++, ranjan2017spynet}. For simplicity, we define the queries , keys  and values  as follows:

where  is the projected feature from the -th frame of -th clip.  and  are the projected features that are bilinearly sampled from  locations of  and , respectively. ,  and  are the projection matrices. Note that we first project the feature and then do sampling to reduce redundant computation.

Next, similar to the attention mechanism~\cite{vaswani2017transformer}, we calculate the attention weights based on the  and  from the -th layer and then compute the aligned feature  as a weighted sum of  from the same -th layer as follows: 

where \textit{SoftMax} is the softmax operation along the row direction and  is a scaling factor.

Lastly, since Eq.~\eqref{eq:attn} only aggregates information spatially, we add a multi-layer perception () with two fully-connected layers and a  activation function between them to enable channel interaction as follows:

where a residual connection is used to stabilize training. The hidden and output channel numbers of the  are  ( is the ratio) and , respectively. 

\vspace{-0.3cm}
\paragraph{Multi-group multi-head guided deformable attention.}
We can divide the channel into several deformable groups and perform the deformable sampling for different groups in parallel. Besides, in the attention mechanism, we can further divide one deformable group into several attention heads and perform the attention operation separately for different heads. All groups and heads are concatenated together before channel interaction. 

\vspace{-0.3cm}
\paragraph{Connection to deformable convolution.} Deformable convolution~\cite{dai2017deformable, zhu2019deformable} uses a learned weight for feature aggregation, which can be seen as a special case of GDA, \ie, using different projection matrix  for different locations and then directly averaging the resulting features. Its parameter number and computation complexity are  and , respectively. In contrast, GDA uses the same projection matrix for all locations but generates dynamic weights to aggregate them. Its parameter number and computation complexity are  and , which are similar to deformable convolution when choosing proper  and .



\section{Experiments}
\subsection{Experimental Setup}
\label{sec:exp_setup}
For shallow feature extraction and HQ frame reconstruction, we use 1 RSTB that has 2 swin transformer layers. For recurrent feature refinement, we use 4 refinement modules with a clip size of 2, each of which has 2 MRSTBs with 2 modified swin transformer layers. For both RSTB and MRSTB, spatial attention window size and head number are  and 6, respectively. We use 144 channels for video SR and 192 channels for deblurring and denoising. In GDA, we use 12 deformable groups and 12 deformable heads with 9 candidate locations. We empirically project the query to a higher-dimensional space (\eg, ) because we found it can improve the performance slightly and the parameter number of GDA is not a bottleneck. In training, we randomly crop  HQ patches and use different video lengths for different datasets: 30 frames for REDS~\cite{nah2019ntireREDS}, 14 frames for Vimeo-90K~\cite{xue2019TOFlow-Vimeo-90K}, and 16 frames for DVD~\cite{su2017dvddeblur}, GoPro~\cite{nah2017Gopro} as well as DAVIS~\cite{khoreva2018davis}. Adam optimizer~\cite{kingma2014adam} with default setting is used to train the model for 600,000 iterations when the batch size is 8. The learning rate is initialized as  and deceased with the Cosine Annealing scheme~\cite{loshchilov2016sgdrConsine}. To stabilize training, we initialize SpyNet~\cite{ranjan2017spynet, pytorch-spynet} with pretrained weights, fix it for the first 30,000 iterations and reduce its learning rate by 75\%.








\subsection{Ablation Study}
To explore the effectiveness of different components, we conduct ablation studies on REDS~\cite{nah2019ntireREDS} for video SR. For efficiency, we reduce the MRSTB blocks by half and use 12 frames in training.

\vspace{-0.3cm}
\paragraph{The impact of clip length.}
In RVRT, we divide the video into -frame clips. As shown in Table~\ref{tab:ablation_clip_length}, the performance rises when clip length is increased from 1 to 2. However, the performance saturates when , possibly due to large within-clip motions and inaccurate optical flow derivation. When we directly estimate all optical flows (marked by ), the PSNR hits 32.21dB. Besides, to compare the temporal modelling ability, we hack the input LQ video (Clip 000 from REDS, 100 frames in total) by manually setting all pixels of the 50-th frame as zeros. As indicated in Fig.~\ref{fig:ablation_clip_hacked}, on the one hand,  has a smaller performance drop and all its frames still have higher PSNR than  (equals to a recurrent model) after the attack, showing that RVRT can mitigate the noise amplification from the hacked frame to the rest frames. One the other hand, the hacked frame of  has an impact on more neighbouring frames than , which means that RVRT can alleviate information loss and utilize more frames than  for restoration.


\vspace{-0.3cm}
\paragraph{The impact of video alignment.}
The alignment of video clips plays a key role in our framework. We compare the proposed clip-to-clip guided deformable attention (GDA) with existing frame-to-frame alignment techniques by performing them frame by frame, followed by concatenation and channel reduction. As we can see from Table~\ref{tab:ablation_align}, GDA outperforms all existing methods when it is used for frame-to-frame alignment (denoted as GDA), and leads a further improvement when we aggregate features directly from the whole clip.

\vspace{-0.3cm}
\paragraph{The impact of different components in GDA.}
We further conduct an ablation study on GDA in Table~\ref{tab:ablation_GDA}. As we can see, the optical flow guidance is critical for the model, leading to a PSNR gain of 1.11dB. The update of optical flow in different layers can further improve the result. The channel interaction in MLP also plays an important role, since the attention mechanism only aggregates information spatially. 

\vspace{-0.3cm}
\paragraph{The impact of deformable group and attention head.}
We also conduct experiments on different group and head numbers in GDA. As shown in Table~\ref{tab:ablation_deform_group}, when the deformable group rises, the PSNR first rises and then keeps almost unchanged. Besides, double attention heads lead to slightly better results at the expense of higher computation, but using too many heads has an adverse impact as the head dimension may be too small.




\begin{table}[h]\scriptsize
\captionsetup{font=small}\center
\begin{minipage}{0.34\textwidth}
\caption{Ablation study on clip length.}
\label{tab:ablation_clip_length}
\begin{center}
\scalebox{1}{
\begin{tabular}{c|c|c|c|c}
\hline
Clip
& 1
& 2
& 3
& 3
\\\hline
PSNR 
& 31.98
& 32.10
& 32.07
& 32.21
\\
\hline
\end{tabular}
}
\end{center}
\end{minipage}
\hfill
\begin{minipage}{0.655\textwidth}
\caption{Ablation study on different video alignment techniques.}
\label{tab:ablation_align}
\begin{center}
\scalebox{1}{
\begin{tabular}{c|c|c|c|c|c}
\hline
Alignment
& Warping~\cite{xue2019TOFlow-Vimeo-90K}
& TMSA~\cite{liang2022vrt}
& DCN~\cite{tian2020tdan}
& GDA
& GDA
\\\hline
PSNR 
& 28.88
& 30.45
& 31.93
& 32.00
& 32.10
\\
\hline
\end{tabular}
}
\end{center}
\end{minipage}
\vspace{-0.2cm}
\end{table}

\begin{minipage}[h]{\textwidth}
\begin{minipage}[b]{0.36\textwidth}
\captionsetup{font=small}
\centering
\begin{overpic}[height=3.15cm]{figures/ablation_clip_hacked.pdf}
\end{overpic}
\vspace{-0.6cm}
\captionof{figure}{Per-frame PSNR drop when pixels of the 50-th frame is hacked to be all zeros.  is clip length.}
\label{fig:ablation_clip_hacked}
\end{minipage}
\hfill
\begin{minipage}[b]{0.6\textwidth}
\scriptsize
\centering
\begin{minipage}[b]{1\textwidth}
\captionsetup{font=small}
\centering
\begin{tabular}{c|c|c|c|c}
\hline
Optical Flow Guidance
& 
& \checkmark
& \checkmark
& \checkmark
\\
Optical Flow Update
& 
& 
& \checkmark
& \checkmark
\\
MLP 
& \checkmark
& \checkmark
& 
& \checkmark
\\
\hline
PSNR 
& 30.99
& 32.03
& 31.83
& 32.10
\\\hline
\end{tabular}
\captionof{table}{Ablation study on different GDA components.}
\label{tab:ablation_GDA}
\end{minipage}
\vfill\vspace{6mm}
\begin{minipage}[b]{1\textwidth}
\centering
\begin{tabular}{c|c|c|c|c|c|c}
\hline
Deformable Group
& 1
& 6
& 12
& 12
& 12
& 24
\\
Attention Head
& 1
& 6
& 12
& 24
& 36
& 24
\\\hline
PSNR 
& 31.63
& 32.03
& 32.10
& 32.13
& 32.03
& 32.11
\\
\hline
\end{tabular}
\captionsetup{font=small}
\captionof{table}{Ablation study on deformable groups and attention heads.}
\label{tab:ablation_deform_group}
\end{minipage}
\end{minipage}
\end{minipage}



\subsection{Video Super-Resolution}
For video SR, we consider two settings: bicubic (BI) and blur-downsampling (BD) degradation. For BI degradation, we train the model on two different datasets: REDS~\cite{nah2019ntireREDS} and Vimeo-90K~\cite{xue2019TOFlow-Vimeo-90K}, and then test the model on their corresponding testsets: REDS4 and Vimeo-90K-T. We additionally test Vid4~\cite{liu2013bayesianVid4} along with Vimeo-90K. For BD degradation, we train it on Vimeo-90K and test it on Vimeo-90K-T, Vid4, and UDM10~\cite{yi2019pfnl_udm}. The comparisons with existing methods are shown in Table~\ref{tab:vsr_quan}. As we can see, RVRT achieves the best performance on REDS4 and Vid4 for both degradations. Compared with the representative recurrent model BasicVSR++~\cite{chan2021basicvsr++}, RVRT improves the PSNR by significant margins of \textbf{0.20.5dB}. Compared with the recent transformer-based model VRT~\cite{liang2022vrt}, RVRT outperforms VRT on REDS4 and Vid4 by \textbf{up to 0.36dB}. The visual comparisons of different methods are shown in Fig.~\ref{fig:sr_quali}. It is clear that RVRT generates sharp and clear HQ frames, while other methods fail to restore fine textures and details. 


\begin{table*}[!t]\scriptsize
\captionsetup{font=small}\caption{Quantitative comparison (average PSNR/SSIM) with state-of-the-art methods for \textbf{video super-resolution ()} on \textbf{REDS4}~\cite{nah2019ntireREDS}, \textbf{Vimeo-90K-T}~\cite{xue2019TOFlow-Vimeo-90K}, \textbf{Vid4}~\cite{liu2013bayesianVid4} and \textbf{UDM10}~\cite{yi2019pfnl_udm}.}\label{tab:vsr_quan}
    \vspace{-0.2cm}
    \begin{center}\scalebox{1}{
            \tabcolsep=0.1cm
            \begin{tabular}{c|c|c|c|c|c|c}
                \hline
                \multirow{2}{*}{\makecell{\vspace{-0.5cm}Method}}          & \multicolumn{3}{c|}{BI degradation} & \multicolumn{3}{c}{BD degradation}                     
                
                \\ \cline{2-7}                     & \makecell{REDS4~\cite{nah2019ntireREDS}\Y channel)}  & \makecell{Vid4~\cite{liu2013bayesianVid4}\Y channel)} & \makecell{\scalebox{1}{Vimeo-90K-T}~\cite{xue2019TOFlow-Vimeo-90K}\Y channel)} \\ \hline
                Bicubic                                     & 26.14/0.7292                         & 31.32/0.8684                       & 23.78/0.6347                & 28.47/0.8253                   & 31.30/0.8687                    & 21.80/0.5246                \\
                SwinIR~\cite{liang21swinir}            &         29.05/0.8269                &           35.67/0.9287             &       25.68/0.7491          &      35.42/0.9380              &     34.12/0.9167                &        25.25/0.7262         \\ 
                SwinIR-ft~\cite{liang21swinir}                &         29.24/0.8319               &           35.89/0.9301             &      25.69/0.7488           &          36.76/0.9467          &        35.70/0.9293             &        25.62/0.7498         \\ \hline
                TOFlow~\cite{xue2019TOFlow-Vimeo-90K}              & 27.98/0.7990                         & 33.08/0.9054                       & 25.89/0.7651                & 36.26/0.9438                   & 34.62/0.9212                    & 25.85/0.7659                           \\
                FRVSR~\cite{sajjadi2018FRVSR}               & -                                    & -                                  & -                           & 37.09/0.9522                   & 35.64/0.9319                    & 26.69/0.8103                \\
                DUF~\cite{jo2018DUF}                    & 28.63/0.8251                         & -                                  & 27.33/0.8319                           & 38.48/0.9605                   & 36.87/0.9447                    & 27.38/0.8329                \\
                PFNL~\cite{yi2019pfnl_udm}                & 29.63/0.8502                         & 36.14/0.9363                       & 26.73/0.8029                & 38.74/0.9627                   & -                               & 27.16/0.8355                \\
                RBPN~\cite{haris2019RBPN}             & 30.09/0.8590                         & 37.07/0.9435                       & 27.12/0.8180                & 38.66/0.9596                   & 37.20/0.9458                    & 27.17/0.8205                           \\
                
                MuCAN~\cite{li2020mucan}              & 30.88/0.8750                         & 37.32/0.9465                       & -                           & -                              & -                               & -                           \\
                RLSP~\cite{fuoli2019rlsp}             & -                                    & -                                  & -                           & 38.48/0.9606                   & 36.49/0.9403                    & 27.48/0.8388                \\
                TGA~\cite{isobe2020tga}                  & -                                    & -                                  & -                           & 38.74/0.9627                              & 37.59/0.9516                    & 27.63/0.8423                \\
                RSDN~\cite{isobe2020rsdn}              & -                                    & -                                  & -                           & 39.35/0.9653                   & 37.23/0.9471                    & 27.92/0.8505                \\
                 RRN~\cite{isobe2020rrn}          & -                                    & -                                  & -                           & 38.96/0.9644                   & -                               & 27.69/0.8488                \\
                FDAN~\cite{lin2021fdan}                 & -                                    & -                                  & -                           & 39.91/0.9686                  & 37.75/0.9522                   & 27.88/0.8508                \\
               EDVR~\cite{wang2019edvr}              & 31.09/0.8800                         & {37.61}/{0.9489}             & 27.35/0.8264                & 39.89/0.9686                   & 37.81/0.9523                    & 27.85/0.8503                \\
                 GOVSR~\cite{yi2021omniscient}            & -                                    & -                                  &      -                    &       40.14/0.9713               &          37.63/0.9503           & 28.41/0.8724               \\
                VSRT~\cite{cao2021videosr}        & {31.19/0.8815}                         & 37.71/0.9494             & 27.36/0.8258                & -                   & -                    & -               \\
                \mbox{BasicVSR}~\cite{chan2021basicvsr}     & 31.42/0.8909                         & 37.18/0.9450                       & 27.24/0.8251                & 39.96/{0.9694}              & 37.53/0.9498                    & 27.96/0.8553                \\
                \mbox{IconVSR}~\cite{chan2021basicvsr}       & {{31.67}/{0.8948}}               & 37.47/0.9476                       & {27.39}/{0.8279}      & {40.03}/{0.9694}         & {37.84}/{0.9524}          & {28.04}/{0.8570}      \\ 
                {VRT}~\cite{liang2022vrt}                        &     {32.19/0.9006}         &   \B{38.20/0.9530}    &    \B{27.93/0.8425}      &    \B{41.05/0.9737}       &   \B{38.72/0.9584}        &  \B{29.42/0.8795}   \\{BasicVSR++}~\cite{chan2021basicvsr++}           & \B{32.39/0.9069}             & {{37.79}/{0.9500}}        & {{27.79}/{0.8400}}      & {{40.72}/{0.9722}}         & {{38.21}/{0.9550}}          & {{29.04}/{0.8753}}      \\ 
               \textbf{RVRT} (ours)                  &     \R{32.75/0.9113}         &   \R{38.15/0.9527}    &    \R{27.99/0.8462}      &    \R{40.90/0.9729}       &   \R{38.59/0.9576}        &  \R{29.54/0.8810}   \\
                \hline
            \end{tabular}}
        \vspace{-0.1cm}
    \end{center}
\end{table*}

\begin{table}[!t]
\scriptsize
\captionsetup{font=small}\center
\caption{Comparison of model size, testing memory and runtime for an LQ input of .}\vspace{2mm}
\label{tab:vsr_runtime}
\begin{center}\scalebox{1}{
\begin{tabular}{c|c|c|c|c}
\hline
Method &
\makecell{\#Param (M)} &
\makecell{Memory (M)} &
\makecell{Runtime (ms)} &
\makecell{PSNR (dB)}
\\
\hline
BasicVSR++~\cite{chan2021basicvsr++}
& 7.3
& 223
& 77
& 32.39
\\
BasicVSR++~\cite{chan2021basicvsr++}+RSTB~\cite{liang21swinir}
& 9.3
& 1021
& 201
& 32.61
\\
EDVR~\cite{wang2019edvr}
& 20.6
& 3535
& 378
& 31.09
\\
VSRT~\cite{cao2021videosr}
& 32.6
& 27487
& 328
& 31.19
\\
VRT~\cite{liang2022vrt}
& 35.6
& 2149
& 243
& 32.19
\\
\textbf{RVRT} (ours)
& 10.8
& 1056
& 183
& 32.75
\\
\hline
\end{tabular}
}
\end{center}
\end{table}


We compare the model size, testing memory consumption and runtime of different models in Table~\ref{tab:vsr_runtime}. Compared with representative parallel methods EDVR~\cite{wang2019edvr}, VSRT~\cite{cao2021videosr} and  VST~\cite{liang2022vrt}, RVRT achieves significant performance gains with less than \textbf{at least 50\%} of model parameters and testing memory usage. It also reduces the runtime by \textbf{at least 25\%}. Compared the recurrent model BasicVSR++~\cite{chan2021basicvsr++}, RVRT brings a PSNR improvement of 0.26dB. As for the inferiority of testing memory and runtime, we argue that it is mainly because the CNN layers are highly optimized on existing deep learning frameworks. To prove it, we use the transformer-based RSTB blocks in RVRT to replace the CNN blocks in BasicVSR++, in which case it has similar memory usage and more runtime than our model.

In addition, to better understand how guided deformable attention works, we visualize the predicted offsets on the LQ frames and show the attention weight in Fig.~\ref{fig:visual_attn_dga}. As we can see, multiple offsets are predicted to select multiple sampled locations in the neighbourhood of the corresponding pixel. According to the feature similarity between the query feature and the sampled features, features of different locations are aggregated by calculating a dynamic attention weight.


\begin{figure*}[!t]
	\captionsetup{font=small}
	
	\centering
	\scriptsize
	
	\renewcommand{\h}{0.105}
	\renewcommand{\wa}{0.12}
	\newcommand{\wb}{0.16}
	\renewcommand{\g}{-0.7mm}
	\renewcommand{\tabcolsep}{1.8pt}
	\renewcommand{\arraystretch}{1}
	\resizebox{1.00\linewidth}{!} {
		\begin{tabular}{cc}
			
			\renewcommand{\name}{figures/sr/00000024_}
			\renewcommand{\h}{0.12}
			\renewcommand{\w}{0.2}
			\begin{tabular}{cc}
				\begin{adjustbox}{valign=t}
					\begin{tabular}{c}\includegraphics[trim={84 0 0 0 },clip, width=0.354\textwidth,height=0.276\textwidth]{\name LQ.jpeg}
						\\
					 Frame 024, Clip 011, REDS~\cite{nah2019ntireREDS} 
					\end{tabular}
				\end{adjustbox}
				\begin{adjustbox}{valign=t}
					\begin{tabular}{cccccc}
						\includegraphics[trim={231 130 71 37 },clip,height=\h \textwidth, width=\w \textwidth]{\name LQ.jpeg} \hspace{\g} &
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name EDVR.jpeg} \hspace{\g} &
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name VSRT.jpeg} &
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name BasicVSR.jpeg} \hspace{\g} 
						\\
						LQ () &
						EDVR~\cite{wang2019edvr} & VSRT~\cite{cao2021videosr} &
						BasicVSR~\cite{chan2021basicvsr} 
						\\
						\vspace{-1.5mm}
						\\
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name BasicVSR++.jpeg} \hspace{\g} &
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name VRT.jpeg}
						\hspace{\g} &	
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name RVRT.jpeg} \hspace{\g} &
						\includegraphics[trim={925 535 285 145},clip,height=\h \textwidth, width=\w \textwidth]{\name GT.jpeg} 
						\\ 
						BasicVSR++~\cite{chan2021basicvsr++} \hspace{\g} &
						{VRT}~\cite{liang2022vrt}  & 	\textbf{RVRT} (ours)   \hspace{\g} &
						GT
						\\
					\end{tabular}
				\end{adjustbox}
			\end{tabular}
			
		\end{tabular}
	}
	\\ \vspace{1mm}
	\resizebox{1.00\linewidth}{!} {
	\begin{tabular}{cc}
			
			\renewcommand{\name}{figures/sr/00000012_}
			\renewcommand{\h}{0.12}
			\renewcommand{\w}{0.2}
			\begin{tabular}{cc}
				\begin{adjustbox}{valign=t}
					\begin{tabular}{c}\includegraphics[trim={0 10 0 0 },clip, width=0.354\textwidth, height=0.276\textwidth]{\name LQ.jpeg}
						\\
						 Frame 012, Clip city, Vid4~\cite{liu2013bayesianVid4}
					\end{tabular}
				\end{adjustbox}
				\begin{adjustbox}{valign=t}
					\begin{tabular}{cccccc}
						\includegraphics[trim={116 47 39 74},clip,height=\h \textwidth, width=\w \textwidth]{\name LQ.jpeg} \hspace{\g} &
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name EDVR.jpeg} \hspace{\g} &
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name VSRT.jpeg} & 
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name BasicVSR.jpeg} \hspace{\g} 
						\\
						LQ () &
						EDVR~\cite{wang2019edvr} & VSRT~\cite{cao2021videosr} &
						BasicVSR~\cite{chan2021basicvsr} 
						\\
						\vspace{-1.5mm}
						\\
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name BasicVSR++.jpeg} \hspace{\g} &
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name VRT.jpeg}
						\hspace{\g} &	\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name RVRT.jpeg} \hspace{\g} &
						\includegraphics[trim={465 190 155 300},clip,height=\h \textwidth, width=\w \textwidth]{\name GT.jpeg} 
						\\ 
						BasicVSR++~\cite{chan2021basicvsr++} \hspace{\g} &
						{VRT}~\cite{liang2022vrt}  & 	\textbf{RVRT} (ours)   \hspace{\g} &
						GT
						\\
					\end{tabular}
				\end{adjustbox}
			\end{tabular}
			
				\vspace{1mm}
		\end{tabular}
	}
	
	\caption{Visual comparison of \textbf{{video super-resolution}} () methods on REDS~\cite{nah2019ntireREDS} and Vid4~\cite{liu2013bayesianVid4}.}
	\label{fig:sr_quali}
\end{figure*}


\begin{figure}[!t]
\captionsetup{font=small}\scriptsize
\begin{center}
\begin{overpic}[width=13cm]{figures/visual_attn_dga.pdf}

\end{overpic}
\end{center}\vspace{-0.2cm}
\caption{The visualization of predicted offsets and attention weight predicted in guided deformable attention. Although guided deformable attention is conducted on features, we plot illustrations on LQ input frames for better understanding. Best viewed by zooming.}
\label{fig:visual_attn_dga}
\end{figure}



\subsection{Video Deblurring}
For video deblurring, the model is trained and tested on two different datasets, DVD~\cite{su2017dvddeblur} and GoPro~\cite{nah2017Gopro}, with their official training/testing splits. As shown in Table~\ref{tab:deblur_dvd} and~\ref{tab:deblur_gopro}, RVRT shows its superiority over most methods with huge improvements of \textbf{1.402.27dB} on two datasets. Even though the performance gain over VRT is relatively small, RVRT has a smaller model size and much less runtime. In detail, the model size and runtime of RVRT are 13.6M and 0.3s, while VRT has 18.3M parameters and the runtime of 2.2s on a  LQ input. The visual comparison is provided in the supplementary material due to the space limit.



\subsection{Video Denoising}
For video denoising, we train the model on the training set of DAVIS~\cite{khoreva2018davis} and test it on its corresponding testset and Set8~\cite{tassano2019dvdnet}. For fairness of comparison, following~\cite{tassano2019dvdnet, tassano2020fastdvdnet}, we train a non-blind additive white Gaussian denoising model for noise level . Similar to the case of video deblurring, there is a huge gap (\textbf{0.602.37dB}) between RVRT and most methods. Compared with VRT, RVRT has slightly better performance on large noise levels, with a smaller model size (12.8M \vs 18.4M) and less runtime (0.2s \vs 1.5s) on a  LQ input. The visual comparison is provided in the supplementary material due to the space limit.








\begin{table*}[!t]\scriptsize
\captionsetup{font=small}\center
\begin{minipage}{1\textwidth}
\caption{Quantitative comparison (average RGB channel PSNR/SSIM) with state-of-the-art methods for \textbf{{video deblurring}} on \textbf{DVD}~\cite{su2017dvddeblur}.}\vspace{-2mm}
\label{tab:deblur_dvd}
\begin{center}
\scalebox{1}{
\begin{tabular}{c|c|c|c|c|c|c}
\hline
Method & 

\makecell{\scalebox{1}{DBN}~\cite{su2017dvddeblur}} &  \makecell{STFAN~\cite{zhou2019spatio}} & 
\makecell{\scalebox{1}{STTN}~\cite{kim2018spatio}} & 
\makecell{\scalebox{1}{SFE}~\cite{xiang2020deep}} &
\makecell{\scalebox{1}{EDVR}~\cite{wang2019edvr}} &
\makecell{\scalebox{1}{TSP}~\cite{pan2020tspdeblur}} 
\\
\hline
PSNR 
& 30.01 
& 31.24 & 31.61
& 31.71 
& 31.82 & 32.13 
\\
SSIM 
& 0.8877 
& 0.9340 & 0.9160
& 0.9160 
& 0.9160 & 0.9268 
\\
\hline
Method & 

\makecell{\scalebox{1}{PVDNet}~\cite{son2021recurrent}} & 
\makecell{\scalebox{1}{GSTA}~\cite{suin2021gated}}&
\makecell{\scalebox{1}{ARVo}~\cite{li2021arvo}} &
\makecell{\scalebox{1}{FGST}~\cite{lin2022flow}} &
\makecell{\scalebox{1}{VRT}~\cite{liang2022vrt}} &
\makecell{\textbf{\scalebox{1}{RVRT}}~(ours)}
\\
\hline
PSNR
& 32.31
& 32.53
& {32.80}
& 33.36
& \B{34.24} 
& 34.30 \\
SSIM

& 0.9260
& 0.9468 & {0.9352}
& 0.9500
& \B{0.9651} & \R{0.9655}
\\
\hline             
\end{tabular}
}
\end{center}
\end{minipage}
\vfill\vspace{6mm} 
\begin{minipage}{1\textwidth}
\caption{Quantitative comparison (average RGB channel PSNR/SSIM) with state-of-the-art methods for \textbf{{video deblurring}} on \textbf{GoPro}~\cite{nah2017Gopro}.} \vspace{-2mm}
\label{tab:deblur_gopro}
\begin{center}
\scalebox{1}{
\begin{tabular}{c|c|c|c|c|c|c}
\hline
Method & 
\makecell{\scalebox{1}{SRN}~\cite{tao2018scale}} &
\makecell{\scalebox{1}{MPRNet}~\cite{zamir2021MPRNet}} &
\makecell{\scalebox{1}{MAXIM}~\cite{tu2022maxim}} &
\makecell{\scalebox{1}{IFI-RNN}~\cite{nah2019recurrent}} & 
\makecell{\scalebox{1}{ESTRNN}~\cite{zhong2020efficient}} &
\makecell{\scalebox{1}{EDVR}~\cite{wang2019edvr}} 
\\
\hline
PSNR 
& 30.26
& {32.66}
& 32.86
& 31.05
& 31.07 & 31.54 \\ SSIM 
& 0.9342
& {0.9590}
& 0.9610
& 0.9110
& 0.9023 & 0.9260 \\
\hline  
Method & 
\makecell{\scalebox{1}{TSP}~\cite{pan2020tspdeblur}} & 
\makecell{\scalebox{1}{PVDNet}~\cite{son2021recurrent}} & 
\makecell{\scalebox{1}{GSTA}~\cite{suin2021gated}}&
\makecell{\scalebox{1}{FGST}~\cite{lin2022flow}} &
\makecell{\scalebox{1}{VRT}~\cite{liang2022vrt}}&
\makecell{\textbf{\scalebox{1}{RVRT}}~\scalebox{1}{(ours)}} \\
\hline
PSNR 
& 31.67
& 31.98
& 32.10
& 32.90
& \B{34.81}
& 34.92
\\
SSIM 
& 0.9279
& 0.9280
& {0.9600} & 0.9610
& \B{0.9724} & 0.9738
\\
\hline
\end{tabular}
}
\end{center}
\end{minipage}
\vspace{-2mm}
\end{table*}



\begin{table}[!t]
\scriptsize
\captionsetup{font=small}\center
\caption{Quantitative comparison (average RGB channel PSNR) with state-of-the-art methods for \textbf{{video denoising}} on \textbf{DAVIS}~\cite{khoreva2018davis} and \textbf{Set8}~\cite{tassano2019dvdnet}.}\vspace{2mm}
\label{tab:denoising_davis_set8}
\begin{center}\scalebox{1}{
\begin{tabular}{c|c|c|c|c|c|c|c}
\hline
Dataset &  &
\makecell{\scalebox{1}{VLNB}~\cite{arias2018video}} &
\makecell{\scalebox{1}{DVDNet}~\cite{tassano2019dvdnet}} &
\makecell{\scalebox{1}{FastDVDNet}~\cite{tassano2020fastdvdnet}} &
\makecell{\scalebox{1}{PaCNet}~\cite{vaksman2021patch}} & \makecell{\scalebox{1}{VRT}~\cite{liang2022vrt}} &
\makecell{\textbf{\scalebox{1}{RVRT}}~\scalebox{1}{ (ours)}}
\\
\hline
\multirow{5}{*}{DAVIS}  
& 10
& 38.85
& 38.13
& 38.71
& 39.97 & \B{40.82}
& \R{40.57}
\\
& 20
& 35.68
& 35.70
& 35.77
& 36.82
& \B{38.15}
& \R{38.05}
\\
& 30
& 33.73
& 34.08
& 34.04
& 34.79
& \B{36.52}
& \R{36.57}
\\
& 40
& 32.32
& 32.86
& 32.82
& 33.34
& \B{35.32}
& \R{35.47}
\\
& 50
& 31.13
& 31.85
& 31.86
& 32.20
& \B{34.36}
& \R{34.57}
\\\hline
\multirow{5}{*}{Set8}  
& 10
& 37.26
& 36.08
& 36.44
& 37.06
& \B{37.88}
& \R{37.53}
\\
& 20
& 33.72
& 33.49
& 33.43
& 33.94
& \B{35.02}
& \R{34.83}
\\
& 30
& 31.74
& 31.79
& 31.68
& 32.05
& \B{33.35}
& \R{33.30}
\\
& 40
& 30.39
& 30.55
& 30.46
& 30.70
& \B{32.15}
& \R{32.21}
\\
& 50
& 29.24
& 29.56
& 29.53
& 29.66
& \B{31.22}
& \R{31.33}
\\
\hline             
\end{tabular}
}
\end{center}
\end{table}






\section{Conclusion}
In this paper, we proposed a recurrent video restoration transformer with guided deformable attention. It is a globally recurrent model with locally parallel designs, which benefits from the advantages of both parallel methods and recurrent methods. We also propose the guided deformable attention module for our special case of video clip-to-clip alignment. Under the guidance of optical flow, it aggregates information from multiple neighboring locations adaptively with the attention mechanism. Extensive experiments on video super-resolution, video deblurring, and video denoising demonstrated the effectiveness of the proposed method.


\section{Limitations and Societal Impacts}
\label{sec:limitation}
Although RVRT achieves state-of-the-art performance in video restoration, it still has some limitations. For example, the complexity of pre-alignment by optical flow increases quadratically with respect to the clip length. One possible solution is to develop a video-to-video optical flow estimation model that directly predicts all optical flows. As for societal impacts, similar to other restoration methods, RVRT may bring privacy concerns after restoring blurry videos and lead to misjudgments if used for medical diagnosis. One possible solution to mitigate this risk is to limit the usage of the model for sensitive or critical videos.























\begin{ack}
Jingyun Liang, Jiezhang Cao, Kaizhang, Radu Timofte, Luc Van Good were partially supported by the ETH Zurich Fund (OK), a Huawei Technologies Oy (Finland) project, the China Scholarship Council and an Amazon AWS grant. Yuchen Fan, Xiaoyu Xiang, Rakesh Ranjan, Eddy Ilg and Simon Green from Meta did not receive above fundings.
\end{ack}


\bibliographystyle{ieee_fullname}
\bibliography{superresolution}


\end{document}