\documentclass[a4paper,11pt,twoside]{report} \pdfoutput=1
\usepackage{etoolbox} \newtoggle{print-version}
\togglefalse{print-version}
\nottoggle{print-version}{
  \usepackage[top=30mm, bottom=30mm, outer=40mm, inner=40mm]{geometry} }{
  \usepackage[top=30mm, bottom=30mm, outer=55mm, inner=25mm]{geometry} }
\usepackage{sty/main}

\begin{document}

\title{Distributed Graph Automata}
\author{Fabian Reiter}

\pagenumbering{alph}
\begin{titlepage}
  \nottoggle{print-version}{
    \newgeometry{top=3cm, bottom=1cm, left=3.25cm, right=3.25cm} }{
    \newgeometry{top=3cm, bottom=1cm, left=3.5cm, right=3cm} }
  \begin{flushleft}
    {\LARGE\fontfamily{iwona}\selectfont \hspace{-.13cm} Fabian Reiter}\.5cm] Graph Automata}}\1.5cm]
  \end{flushleft}
  \begin{center}
    \newsavebox\automatonbox
\begin{lrbox}{\automatonbox}\begin{tikzpicture}[automaton, half row sep]
  \matrix[states] {
        &[4ex]&[7ex] \node[permanent] (q_ap) {}; \\
    \node[existential] (q_a) {}; & \node[universal] (q_a2) {};  \\
        &     & \node[permanent] (q_ah) {}; \\
        & \node[universal] (q_bkr) {}; \\
    \node[existential] (q_b) {}; &     & \node[permanent] (q_yes) {}; \\
        & \node[universal] (q_bk) {}; \\
        \\
    \node[existential] (q_c) {}; &     & \node[permanent] (q_no) {}; \\
  };
  \matrix[symbols] { 
        \\
    \node (a) {}; \\
        \\
        \\
    \node (b) {}; \\
        \\
        \\
    \node (c) {}; \\
  };
  \matrix[accepting sets] {
    \x &    \\
       &    \\
       & \x \\
       &    \\
    \x & \x \\
       &    \\
       &    \\
       &    \\
  };
  \DrawColumnBackground{1}{8}{2}
\path (a)        edge (q_a)
        (b)        edge (q_b)
        (c)        edge (q_c)
        (q_a)      edge (q_a2)
        (q_b.25)   edge node[above] {} (q_bkr)
        (q_b.0)    edge node[above,xshift=.2ex] {} (q_bk)
        (q_b.330)  edge[bend right=20] node[above=4.2ex,xshift=-9.2ex] {} (q_no) 
        (q_c.0)    edge[bend right=25] node[above=-.5ex,xshift=-12ex] {} (q_yes)
        (q_c.330)  edge[bend right=22] node[above=.2ex] {} (q_no)
        (q_a2.22)  edge[bend left=8] node[above=.3ex,xshift=.1ex] {} (q_ap)
        (q_a2)     edge node[above=.1ex,xshift=.4ex] {} (q_ah)
        (q_a2.320) edge[bend right=9] node[above=4.5ex,xshift=1.3ex] {} (q_no)
        (q_bkr)    edge (q_yes)
        (q_bk)     edge (q_yes);
\end{tikzpicture} \end{lrbox}
\newsavebox\graphbox
\begin{lrbox}{\graphbox}\pentagraphPic{input graph}{\lnodedistIG}{}{}{}{}{}{} \end{lrbox}
\newsavebox\runbox
\begin{lrbox}{\runbox}\begin{tikzpicture}[run or game]
  \matrix {
      & & \node[config,pacc] (c3a)
           {\pentagraphPic{configuration}{\lnodedistC}{}{}{}{}{}{}}; \\
    \node[config,exis] (c1)
     {\pentagraphPic{configuration}{\lnodedistC}{}{}{}{}{}{}}; 
      & \node[config,univ] (c2)
         {\pentagraphPic{configuration}{\lnodedistC}{}{}{}{}{}{}}; \\
      & & \node[config,pacc] (c3b)
           {\pentagraphPic{configuration}{\lnodedistC}{}{}{}{}{}{}}; \\
  };
  \path (c1) edge (c2)
        (c2) edge (c3a)
             edge (c3b);
\end{tikzpicture} \end{lrbox}
\begin{tikzpicture}
  \node (automaton) {\usebox\automatonbox};
  \node[below=1ex of automaton,xshift=-2ex] (Alabel) {\large\fontfamily{iwona}\selectfont \fade{Automaton}};

  \node[right=9ex of automaton] (graph) {\usebox\graphbox};
  \node[below=1ex of graph] (Glabel) {\large\fontfamily{iwona}\selectfont \fade{Input Graph}};

  \node[below=16ex of automaton,xshift=20ex] (run) {\usebox\runbox};
  \node[above=-9ex of run,xshift=0ex] (Rlabel) {\large\fontfamily{iwona}\selectfont \fade{Run}};

  \begin{scope}[->,>=stealth,line width=2ex,lightgray,line cap=round]
    \draw ([xshift=2ex,yshift=-1ex]Alabel.south east) to [out=-30,in=110] ([xshift=0ex,yshift=2ex]Rlabel.north west);
    \draw ([xshift=-2ex,yshift=-1ex]Glabel.south west) to [out=-150,in=70] ([xshift=0ex,yshift=2ex]Rlabel.north east);
  \end{scope}
\end{tikzpicture}   \end{center}
  \vspace{.5cm}
  \begin{flushright}
    \advance\rightskip -1.5cm
    {\Large\fontfamily{iwona}\selectfont University of Freiburg}\hspace{2ex}\begin{tikzpicture}[baseline={([yshift=.8ex]b.south)}]
  \matrix[row sep=.75ex,
          nodes={minimum height=2.9ex, minimum width=.75ex,
                 inner sep=0ex, text height=0ex}]
  {
    \node[fill=unired]  {}; \\
    \node[fill=uniblue] {}; \\
    \node[fill=uniblue] (b) {}; \\
    \node[fill=unired]  {}; \\
  };
  \pgfresetboundingbox
\end{tikzpicture}   \end{flushright}
  \restoregeometry
\end{titlepage}

\clearpage
\thispagestyle{empty}
{\Large\fontfamily{iwona}\selectfont Master's Thesis in Computer Science}
\vfill
\begin{description}[style=nextline]
\item[Supervisors]
  \begin{tabular}{ll}
    Prof. Dr. Fabian Kuhn & (Chair of Algorithms and Complexity) \\
    Prof. Dr. Andreas Podelski & (Chair of Software Engineering)
  \end{tabular}
\item[Institution\vphantom{p}]
  \begin{tabular}{ll}
    Albert Ludwig University of Freiburg & (Germany) \\
    Faculty of Engineering \\
    Department of Computer Science
  \end{tabular}
\item[Date of Submission\quad\textnormal{(original version)}]
  \begin{tabular}{l}
    January 20\textsuperscript{th}, 2014
  \end{tabular}
\item[Date of Revision\quad\textnormal{(this version)}]
  \begin{tabular}{l}
    April 25\textsuperscript{th}, 2014
  \end{tabular}
\item[Author and Contact Address]
  \begin{tabular}{l}
    Fabian Reiter \quad \href{mailto:fabian.reiter@gmail.com}{\nolinkurl{fabian.reiter@gmail.com}}
  \end{tabular}
\end{description}
\vspace{1cm}

\clearpage
\pagenumbering{roman}

\thispagestyle{empty}
\section*{Abstract}
Inspired by distributed algorithms, we introduce a new class of finite
graph automata that recognize precisely the graph languages definable
in monadic second-order logic. For the cases of words and trees, it
has been long known that the regular languages are precisely those
definable in monadic second-order logic. In this regard, the automata
proposed in the present work can be seen, to some extent, as a
generalization of finite automata to graphs.

Furthermore, we show that, unlike for finite automata on words and
trees, the deterministic, nondeterministic and alternating variants of
our automata form a strict hierarchy with respect to their expressive
power. For the weaker variants, the emptiness problem is decidable.

\vspace{.5cm}
\section*{\it\fontfamily{iwona}\selectfont Zusammenfassung}
{\it
  Inspiriert durch verteilte Algorithmen führen wir eine neue Klasse
  von endlichen Graph-Automaten ein, die genau die Graph-Sprachen
  erkennen, die in mo\-na\-di\-scher Prädikatenlogik zweiter Stufe
  definierbar sind. Für Worte und Bäume ist seit langem bekannt, dass
  die regulären Sprachen genau jene sind, die in mo\-na\-di\-scher
  Prädikatenlogik zweiter Stufe definierbar sind. In dieser Hinsicht
  können die in vorliegender Arbeit vorgestellten Automaten gewissermaßen 
  als eine Verallgemeinerung von endlichen Automaten auf Graphen
  betrachtet werden.

  Ferner zeigen wir, dass im Gegensatz zu endlichen Automaten auf
  Worten und Bäumen die de\-ter\-mi\-nis\-tisch\-en,
  nichtdeterministischen und alternierenden Varianten unserer
  Automaten eine strikte Hierarchie bezüglich ihrer Ausdrucksstärke
  bilden. Für die schwächeren Varianten ist das Leerheitsproblem
  entscheidbar.  }

\clearpage
\thispagestyle{empty}
\section*{Acknowledgments}
I would like to thank my supervisors, Fabian Kuhn and Andreas
Podelski, for many helpful and pleasant discussions, and their
continuous support of a project whose outcome was unpredictable in its
early stages. Furthermore, I am very grateful to Jan Leike, who kindly
read and commented on drafts of this thesis.

\tableofcontents

\cleardoublepage
\pagenumbering{arabic}


\chapter{Introduction}
The research for this thesis started with an open-ended (and perhaps
naive) question: \emph{what can we obtain by connecting finite
  automata in a synchronous distributed setting?} As it turns out, a
possible answer is: a new class of automata that can be seen, to some
extent, as a generalization of finite automata to graphs. In order to
substantiate this claim, we begin by reviewing a fundamental result of
formal language theory, and then use that result as a guide within the
less well-explored world of graph languages.

\section{Background and Related Work}
In the early 1960s, a beautiful connection between automata theory and
formal logic was discovered. Independently of each other, Büchi
\cite{Buc60}, Elgot \cite{Elg61} and Trakhtenbrot \cite{Tra61} showed
that the regular languages, recognized by finite automata, are
precisely the languages defined by a certain class of logical
formulas. This idea might be best understood through a simple
example. The following one is borrowed from Thomas \cite{Tho91}.

\begin{example} \label{ex:NFA-MSO}
  Consider the nondeterministic finite automaton 
  specified in \cref{fig:NFA}. If we exclude the empty word, this
  automaton accepts a finite word  over the alphabet 
  \Iff  does not contain the segment  and the last symbol
  of  is an . We can define the same language by the following
  first-order formula:
  
  The idea is that we identify each word with a labeled directed graph
  that consists of a single path. For instance, 
  corresponds to \begin{tikzpicture}[lgraph,baseline=(u.text)]
  \node[lnode] (u) {};
  \node[lnode] (v) at ([shift={(0:\lnodedistIG)}]u) {};
  \node[lnode] (w) at ([shift={(0:\lnodedistIG)}]v) {};
  \path (u) edge (v)
        (v) edge (w);
\end{tikzpicture} \!\!. Such a graph is
  a relational structure over which we can evaluate the truth of the
  formula . Variables like  and
   range over the nodes of the graph, 
  represents the edge relation, and the symbols  and
   are to be interpreted as unary relations
  indicating that a node is labeled by an  and a ,
  respectively.

  The first conjunct of  specifies that no two
  consecutive nodes are both labeled by a , while the second
  conjunct ensures that the last node is labeled by an .
\end{example}

\begin{SCfigure}[1.4][h!]
  \alignpic
  \begin{tikzpicture}[automaton]
  \matrix[states] {
    \node[NFA state,initial,accepting] (q_a) {}; & \node[NFA state] (q_b) {}; \\
  };
  \path (q_a) edge[loop above] node {} (q_a)
              edge[bend left] node {} (q_b)
        (q_b) edge[bend left] node {} (q_a);
\end{tikzpicture}   \caption{, a nondeterministic finite automaton whose
    language, when restricted to nonempty words, consists of all the
    finite words over the alphabet  that do not contain
    the segment  and that end with an .}
  \label{fig:NFA}
\end{SCfigure}

In the formula  of the preceding example, we only
used quantifiers that range over the nodes of a graph. By additionally
allowing quantification over sets of nodes, we reach the full extent
of \emph{monadic second-order} (MSO) logic. The famous result
established by Büchi, Elgot and Trakhtenbrot states that we can
effectively translate every finite automaton to an equivalent
MSO-formula (with relation symbols fixed as in \cref{ex:NFA-MSO}), and
vice versa. (For a proof, see, e.g., \cite[Thm~3.1]{Tho96}.) An
important consequence of this equivalence is that the satisfiability
and validity problems of MSO-logic on words are decidable, because so
are the corresponding problems for finite automata. This application
was the original motivation for establishing a connection between the
two worlds. Nowadays, this and similar connections also play a central
role in model checking, where one needs to decide whether a system,
represented by an automaton, satisfies a given specification,
expressed as a logical formula.

About a decade later, the result was generalized from words to labeled
trees by Thatcher, Wright \cite{TW68} and Doner \cite{Don70} (see,
e.g., \cite[Thm~3.8]{Tho96}). The corresponding tree automata
(which we shall not consider here) can be seen as a natural extension
of finite automata to labeled trees. As far as MSO-logic is concerned,
the generalization to (ordered, directed) labeled trees is
straightforward, since, just like words, these can be regarded as
labeled graphs. We only need to introduce additional edge relation
symbols of the form , in order to
be able to express that some node is the -th child of another node.

In view of these results, it seems natural to ask whether the bridge
between automata theory and logic persists if we expand our field of
interest from words or trees to arbitrary node labeled graphs
(possibly with multiple edge relations, as for trees). However, the
trouble is that this question is not well-defined. While we can easily
specify what we mean by MSO-logic on graphs, it is not obvious at all
how finite automata should be canonically generalized to graphs that
go beyond trees.

\begin{quote}
  \emph{A result similar to those \emph{[for word and tree languages]}
    does not exist for graph languages, for the trivial reason that
    there is no agreement on what would be the class of “regular graph
    languages”, and, in particular, that there is no accepted notion
    of “finite graph automaton”.} \\
  \hspace*{\fill} (Joost Engelfriet, 1991 \cite[p.~139]{Eng91})
\end{quote}

Nevertheless, graph languages have been an active area of research for
nearly fifty years. In large part, this has been driven by
investigations of generative devices known as \emph{graph grammars}.
The theory of graph grammars is by now well-developed, as can be seen
from the “Handbook of Graph Grammars and Computing by Graph
Transformation” \cite{HGG97-99}, a comprehensive reference consisting
of several volumes. Within this branch of research, MSO-logic has
raised considerable interest. Especially through the work of
Courcelle, MSO-formulas have proven to be particularly useful tools
for obtaining decidability results about graph languages.

\begin{quote}
  \emph{The deep reason why \emph{[monadic second-order]} logic is so
    crucial is that it replaces for graphs \emph{[…\!]} the notion of
    a finite automaton which is very important in the theory of formal
    languages. It “replaces” because no convenient notion of finite
    automaton is known for graphs.} \\
  \hspace*{\fill} (Bruno Courcelle, 1997 \cite[p.~315]{Cou97})
\end{quote}

Supported by the equivalence of regularity and MSO-definability on
words and labeled trees, one might even go as far as referring to the
sets of graphs that can be defined by MSO-formulas as the “regular
graph languages”. Hence, one way to cope with the lack of a canonical
generalization of finite automata to graphs is to search for a model
of computation on graphs that has the same expressive power as
MSO-logic. This is the approach pursued in this thesis.

It must be emphasized that the present work is not, by any means, the
first to investigate graph automata. The definitions suggested in the
literature over the last decades are far too numerous to survey here,
but let us at least mention a small selection. Already in the early
days of graph grammars, mostly in the 1970s, the notion of
graph-accepting machines was explored in parallel to generative
devices. Some examples, among many others, are the models proposed by
Shah, Milgram, Wu and Rosenfeld in \cite{SMR73}, \cite{Mil75} and
\cite{WR79}. However, none of those studies were concerned with
equivalence to MSO-logic, and few of them were pursued much
further. It seems that graph grammars received much more interest than
graph automata. Later, in the early 1990s, Thomas introduced his
\emph{graph acceptors} in \cite{Tho91}, with the explicit goal of an
automata-theoretic investigation of MSO-definable graph properties. It
turned out that Thomas' graph acceptors recognize precisely the graph
languages of bounded degree definable in the existential
fragment\footnote{The existential fragment of MSO-logic consists of
  formulas of the form , where
   are set variables, and  is a
  first-order formula (i.e.,  does not contain any set
  quantifiers).} of MSO-logic (see \cite[Thm~3]{Tho97}). This makes
them less expressive than full MSO-logic, and, in particular, their
class of recognizable languages is not closed under
complementation. Also, about a year earlier, Courcelle had introduced
in \cite{Cou90} an algebraic notion of \emph{recognizability}, without
defining any notion of graph automaton. Every MSO-definable graph
language is recognizable in Courcelle's sense, but not vice versa.

The expressiveness of MSO-logic on graphs has thus been approximated
“from below”, by Thomas, and “from above”, by Courcelle, but, to the
author's best knowledge, a perfectly matching automaton model has been
missing so far. Relatively recent remarks by Courcelle and Engelfriet
in \cite{CE12}, as well as the following explicit statement, support
this assumption.

\begin{quote}
  \emph{No existing notion of graph automaton gives an equivalence
    with monadic second-order logic.} \\
  \hspace*{\fill} (Bruno Courcelle, 2008 \cite[p.~8]{Cou08})
\end{quote}

The present work is an attempt to close this gap in the theory of
graph languages. It is successful in the sense that it provides a
class of graph automata equivalent to MSO-logic. However, it must also
be conceded that, up to now, no new results have been inferred from
this alternative characterization. Whether it will prove as fruitful
as classical automata on words and trees remains to be seen.

\section{Structure of this Thesis}
The presentation is organized as follows: After some preliminaries on
graphs in \cref{chap:graphs}, we introduce the alternating variant of
our distributed graph automata (ADGAs) in \cref{chap:adga}, and
discuss some of their properties. Since the capabilities of ADGAs
might not be obvious at first sight, a substantial part of the chapter
is devoted to examples. Then, in \cref{chap:msol}, we review MSO-logic
on graphs, and prove our main result, the equivalence of MSO-logic and
ADGAs. This immediately entails some negative results on ADGAs. We
finish by considering nondeterministic and deterministic variants of
our automata in \cref{chap:ndga_ddga}. Both turn out to be strictly
weaker than ADGAs, and they also form a hierarchy among themselves.
The loss of expressive power is however rewarded by a decidable
emptiness problem.
 

\chapter{Preliminaries on Graphs} \label{chap:graphs}
Graphs play a central role in this work. On the one hand, they will
serve as input for automata, and as models for logical formulas. On
the other hand, we will use them to describe the behaviour of
automata, and to represent two-player games. In this chapter, we
provide formal definitions, review some common graph properties, and
discuss the notion of graph minors.

\section{Basic Definitions}
As our most general concept, we consider directed graphs with nodes
labeled by an alphabet , and multiple edge relations indexed by an
alphabet . While node labels are auxiliary, we regard edge labels
as an integral part of the graph structure.

\begin{definition}[-Graph]
  Let  be a nonempty finite alphabet (i.e., a set of symbols). A
  \defd{-graph}  is a structure
  , where
  \begin{itemize}
  \item  is a nonempty finite set of \defd{nodes}, and
  \item each  is a set of directed \defd{edges}
    labeled by .
  \end{itemize}
\end{definition}

If  is understood or irrelevant, we refer to  simply as a
\defd{graph}. Note that self-loops are allowed, and that there can be
multiple edges from one node to another, but at most one for every
edge label . If there are no self-loops, i.e., if 
does not hold for any  and , then we say that  is
\defd{loop-free}. Furthermore, if there is only a single edge
relation, we call  a \defd{simple} graph. In such a case, we set
 (singleton consisting of a blank symbol), and omit the
superfluous edge labels.
  
\begin{definition}[-Labeled -Graph]
  Let  and  be two nonempty finite alphabets. A
  \defd{-labeled -graph} is a tuple , denoted as
  , where
  \begin{itemize}
  \item  is a -graph (referred to as the underlying graph),
    and
  \item  is a node \defd{labeling} (function).
  \end{itemize}
\end{definition}

Again, we will often relax our terminology, and refer to  simply
as a \defd{labeled graph}, or even as a graph, if the meaning is clear
from the context.

At this point, it is important to mention that we are only interested
in (labeled) graphs \emph{up to isomorphism}. That is, we consider two
-labeled -graphs  and  to be \defd{equal} if there
is a bijection , such that , and
 \Iff , for all  and
. The reason for this is that our automata and logical formulas
cannot distinguish between isomorphic graphs.

In order to draw an analogy to formal language theory on words, we
introduce an extension to graphs of the well-known notation employing
alphabet exponentiation and the Kleene star. In the context of words,
 designates the set of all words of length  over the alphabet
, and  the set of all words of arbitrary (finite) length over
. Now, a word over  can be viewed as a -labeled linear graph
with a single edge relation. For example, we can identify
 with \begin{tikzpicture}[lgraph,baseline=(u.text)]
  \node[lnode] (u) {};
  \node[lnode] (v) at ([shift={(0:\lnodedistIG)}]u) {};
  \node[lnode] (w) at ([shift={(0:\lnodedistIG)}]v) {};
  \node[lnode] (x) at ([shift={(0:\lnodedistIG)}]w) {};
  \path (u) edge (v)
        (v) edge (w)
        (w) edge (x);
\end{tikzpicture} \!\!. From this
point of view, the number  in the expression  refers to the
underlying linear graph of length , and the Kleene star  in
 can be seen as a placeholder for any linear graph. We can
generalize this notation to arbitrary finite graphs by replacing 
with a -graph , and  with the symbol  (“clouded
”), which serves as a placeholder for any -graph.

\begin{definition}[Cloud Notation]
  For any nonempty finite alphabets  and , and any -graph
  , we denote by  the set of all -labeled graphs with
  underlying graph , and by ~the set of all
  -labeled -graphs, i.e.,
   \
  \swl{\defd{⟨Σ_1,Σ_2⟩^G}}{⟨Σ_1,Σ_2⟩^{\clouded{Γ}}} &\coloneqq (Σ_1∪Σ_2)^G\setminus (Σ_2)^G,
  \quad \text{and} \\
  \defd{⟨Σ_1,Σ_2⟩^{\clouded{Γ}}} &\coloneqq (Σ_1∪Σ_2)^{\clouded{Γ}}\setminus (Σ_2)^{\clouded{Γ}}.

        \lA(q)=
        \begin{cases}
          0 & \text{\parbox[t]{.55\textwidth}{if for all  and
              \!,
              it holds that ,}} \.3ex]
        ∃a∈Σ\colon σ(a)=q \quad \text{implies} \quad \lA(q)=0,
      
        \lA(q)=
        \begin{cases}
          0                          & \text{if\; }, \\
          \max\{\lA(q)\mid q∈Q_\N\}+1 & \text{otherwise},
        \end{cases} \\
        δ(q,\S)=\{q\} \quad \text{for every }\!,
      
    δ^\cloud \colon Q^{\clouded{Γ}} &→ 2^{(Q^{\clouded{Γ}})} \\
    G_κ &↦ \biggl\{G_μ \biggm|
    \bigwedge_{v∈\VG} μ(v)∈ δ\Bigl(κ(v),\,\bigl\langle\{κ(u)\mid u\arrG{γ} v\}\bigr\rangle_{γ∈Γ}\Bigr)\biggr\}.
  
    \defd{\L(\A)} \coloneqq \bigl\{ G_λ∈Σ^{\clouded{Γ}} \bigm| \text{ accepts } \bigr\}.
  
  \defd{\L_\conn(\A)}\coloneqq\L(\A)∩\L\bigl(\A_\conn(Σ,Γ)\bigr).

  \defd{\L_\undir(\A)}\coloneqq\L(\A)∩\L\bigl(\A_\undir(Σ,Γ)\bigr).
2ex]
&     &     & \node[permanent] (q_p2r) {}; \\
        &     & \node[existential] (q_p2) {}; & \node[permanent] (q_p2n) {}; \\
    \node[initial,existential] (q_ini) {}; & \node[universal] (q_2) {}; & & \node[permanent redundant] (q_acc2) {}; \\
        &     & \node[existential] (q_h2) {}; & \node[permanent] (q_h2r) {}; \\
        &     &     & \node[permanent] (q_h2n) {}; \2ex]
&     &     & \node[permanent] (q_out) {}; \\
  };
  \node[accepting formula] {
    
  };
  \path[every node/.style={sloped}]
      (q_ini)    edge (q_1)
                 edge (q_2)
                 edge (q_3)
                 edge[bend right=56] (q_out)
      (q_1.15)   edge (q_p1)
      (q_1)      edge (q_h1)
      (q_2.15)   edge (q_p2)
      (q_2)      edge (q_h2)
      (q_3.15)   edge (q_p3)
      (q_3)      edge (q_h3)
(q_p1.40)  edge node[above=.2ex] {} (q_p1r)
      (q_p1)     edge node[above=.2ex,xshift=.8ex] {} (q_p1n)
      (q_p1.320) edge node[above=.2ex,sloped=false] {} (q_acc1)
      (q_h1.40)  edge node[above=.4ex,sloped=false] {} (q_acc1)
      (q_h1)     edge node[above=.2ex] {} (q_h1r)
      (q_h1.320) edge node[above=.2ex,xshift=.5ex] {} (q_h1n)
(q_p2.40)  edge node[above=.2ex] {} (q_p2r)
      (q_p2)     edge node[above=.2ex,xshift=.8ex] {} (q_p2n)
      (q_p2.320) edge node[above=.2ex,sloped=false] {} (q_acc2)
      (q_h2.40)  edge node[above=.4ex,sloped=false] {} (q_acc2)
      (q_h2)     edge node[above=.2ex] {} (q_h2r)
      (q_h2.320) edge node[above=.2ex,xshift=.5ex] {} (q_h2n)
(q_p3.40)  edge node[above=.2ex] {} (q_p3r)
      (q_p3)     edge node[above=.2ex,xshift=.8ex] {} (q_p3n)
      (q_p3.320) edge node[above=.2ex,sloped=false] {} (q_acc3)
      (q_h3.40)  edge node[above=.4ex,sloped=false] {} (q_acc3)
      (q_h3)     edge node[above=.2ex] {} (q_h3r)
      (q_h3.320) edge node[above=.2ex,xshift=.5ex] {} (q_h3n);
\end{tikzpicture}   \caption{\!, an ADGA over
     whose
    \emph{undirected} graph language 
    consists of the graphs that contain  as a minor, or in
    other words, the graphs that contain at least one cycle of three
    or more nodes.}
  \label{fig:ADGA_K3_minor}
\end{figure}

\begin{example}[Recognizing Graphs with a Cycle]
  The ADGA  is specified in
  \cref{fig:ADGA_K3_minor}. Since it has too many accepting sets to
  represent them with a barcode, its acceptance condition is given as
  a set formula. Also, for the sake of better readability, there are
  three occurrences of  in the state diagram, but they all
  represent the same state.

  Let ,  and  be three sets corresponding to the three
  nodes of . In the first round, each node of the input graph
  nondeterministically decides whether to participate and join one of
  those sets (states , , ), or not to interfere at all
  and terminate right away (state ). Then, in the second
  round, there is a universal branching in which each participating
  node simultaneously picks the markers  and . In the
  third and last round, in every universal branch, each participating
  node checks whether it has any neighbor that is in the same set as
  itself but has chosen a different marker. If this is the case, it
  goes to  to signalize that the affected branch of the run
  contains a discordance and must be treated accordingly by the
  automaton. (This is analogous to the behaviour of the ADGA from
  \cref{ex:ADGA_weakly_connected}.) Otherwise, the node assumes that
  the subgraph  to which it belongs is connected, and it
  checks whether any of its neighbors is part of the subgraph
  . If so, it switches to a state with a
  superscript “”, otherwise to a state with a
  “”. Finally, the automaton decides on acceptance as
  follows: Branches in which a discordance has been signalized (by the
  state ) are inconclusive, and thus the configurations
  reached in such branches are considered to be accepting. In all the
  other branches, the automaton expects that in each subgraph
  , the nodes agree on one of the markers  and ,
  and at least one of them signalizes that it is connected to a node
  in the “next” subgraph .
\end{example}

We can proceed similarly to construct the automaton 
for any other loop-free graph . Levels~0, 1 and 2 are completely
analogous and depend only on the number of nodes of . Level~4, on
the other hand, must be adapted to the structure of the graph. For
each edge in  between two nodes  and , it must be
verified that there is a corresponding edge in the input graph ,
connecting  and . Either the nodes in  or the
nodes in  must perform this verification. However, the number of
permanent states required by the nodes in each set  grows
exponentially with the number of edges for which those nodes are
responsible. This is because a single node in  might have
neighbors in several other sets, and each combination must be encoded
in a separate state. Hence, if we want to keep the total number of
states low, we have to balance the load among the sets as evenly as
possible. The exact specification of  can thus be
optimized for each graph , but the construction principle is always
the same as for .

The possibility to check for arbitrary minors is a powerful tool. As
another application example, we outline how to recognize the language
of planar graphs.

\begin{example}[Recognizing Planar Graphs]
  By the Kuratowski-Wagner Theorem (\cref{thm:kuratowski-wagner}), a
  graph is planar \Iff it contains neither the complete graph 
  nor the complete bipartite graph  as a minor. Moreover, as
  we will see in \cref{sec:closure-properties}, ADGA-recognizable
  graph languages are effectively closed under boolean set
  operations. Thus, by constructing the union automaton of
   and  and then complementing
  it, we obtain an ADGA  over
   whose undirected
  graph language is precisely the set of all simple undirected planar
  graphs.
\end{example}

\section{Normal Forms} \label{sec:normal-forms}
In this section, we establish some normal forms of ADGAs, which will
prove helpful for the closure constructions in
\cref{sec:closure-properties}.

The notion of a nonblocking ADGA is analogous to that of a nonblocking
finite automaton on words: it guarantees that the automaton cannot
“get stuck” during execution, which for an ADGA means that all of its
runs eventually reach a permanent configuration in each universal
branch.

\begin{definition}[Nonblocking ADGA]
  An ADGA  is called \defd{nonblocking} \Iff every
  configuration  that is reachable by  has at
  least one successor configuration, i.e., .
\end{definition}

A sufficient (but not necessary) condition for  to be nonblocking
is that its transition function is complete, i.e.,  for
every  and \!. This gives us an effective way of
transforming any given ADGA into an equivalent nonblocking one.

\begin{remark} \label{rem:nonblocking}
  For every ADGA , we can effectively construct an equivalent ADGA
   that is nonblocking. Moreover, \,
  and \,.
\end{remark}

\begin{proof}
  \newcommand{\qstop}[1]{q_{\,#1}^{\scriptscriptstyle\textnormal{stop}}}
  \newcommand{\Qstop}{Q_{\scriptscriptstyle\textnormal{stop}}}
  Let . We extend  such that its transition
  function becomes complete, giving us an equivalent ADGA that is
  guaranteed to be nonblocking. To this end, we introduce an
  additional permanent state  for every nonpermanent level
  . If a node was blocked at level , it now simply moves to
  state , and waits there for the other nodes to
  terminate. A permanent configuration is then accepting if it already
  was so previously, or if it contains states indicating that the
  lowest level at which some node would have been blocked, is
  universal. Formally, we fix the set , and construct , with
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item , \quad , \quad
    ,
   \item
    \S∈(2^Q)^Γδ(q,\S)≠∅ \\
    for every  and \!,\, and 
  \item \min\{i\mid \qstop{i}∈F\}\A.
  \end{itemize}
  As a slight optimization, if  or , the states in
   can be merged into a single state .
\end{proof}

Next, again in analogy to finite automata on words, we say that an
ADGA is trim if it does not have any states that are obviously
useless. In the case of (nondeterministic) finite automata on words,
a state is considered useless if it is not reachable from any initial
state or if no accepting state is reachable from it. However, for
ADGAs the notion of reachability of states is more involved, since it
is subject to the reachability of configurations. For our purposes, it
will be enough to consider a necessary condition for reachability,
which can be easily checked for every state: reachability within the
state diagram, ignoring the requirements on the transition
arrows. States that do not satisfy this condition are obviously
useless, since they cannot occur in any run. We can thus safely remove
them from the automaton, without affecting the graph language it
recognizes.

\begin{definition}[Trim ADGA]
  Let  be an ADGA. We consider a state 
  to be \defd{potentially reachable} if
  \begin{itemize}[topsep=1ex,itemsep=0ex]
    \item  for some , or
    \item  for some  and \!,
      such that  and every state  are
      potentially reachable.
  \end{itemize}
  The automaton  is said to be \defd{trim} if all of its states
  are potentially reachable.
\end{definition}

\begin{remark} \label{rem:trim}
  For every ADGA , we obtain an equivalent ADGA  that is
  trim, by removing all states from  that are not potentially
  reachable (and adapting the transition function and acceptance
  condition accordingly). Moreover, if  is nonblocking, then so is
  .
\end{remark}

Last, we introduce the notion of alternating normal form, which
requires that successive nonpermanent levels of an ADGA are
alternately existential and universal. Every ADGA can be transformed
into an equivalent automaton in alternating normal form by inserting
“dummy” levels between any two consecutive levels that are of the same
type.

\begin{definition}[Alternating Normal Form]
  An ADGA  is in \defd{alternating
    normal form} if for every level ,
  
\end{definition}

\begin{remark} \label{rem:ANF}
  For every ADGA , we can effectively construct an equivalent ADGA
   that is in alternating normal form. If  is nonblocking or
  trim, then these properties carry over to . Moreover,
  \, and \,.
\end{remark}

\begin{proof}
  Let .  We construct  as
  an extended version of , with ,\, ,
  and .

  Suppose that there is some level , with , such
  that both  and  are existential levels in . We remedy
  this in  by inserting a disjoint copy  of
  \:\!\! “between”  and ,
  and defining the states in  to be universal, i.e.,
  . Then, we redirect the outgoing transitions of
  states in , such that, instead of going to states in
  , they go to the corresponding copies in
  . Turning to these copies, we direct all their outgoing
  transitions to the matching original states in .

  More formally, for every state , we denote by  the
  state in  to which it corresponds (i.e.,  is the
  copy of ). Now, for every  and \!, we
  define
  
  and for every  and \!, we set
  

  In the dual case, where the levels  and  are both universal
  in , we proceed analogously. By doing so for every level in 
  that is directly followed by a level of the same type, and otherwise
  retaining the original transitions of , we achieve that  is
  in alternating normal form. Each level  is
  duplicated at most once, thus  cannot exceed twice the size and
  length of .

  Since the additional levels that we have introduced merely cause the
  runs of  to be longer than those of , without affecting
  which permanent configurations are eventually reached,  is
  obviously equivalent to . It is also easy to see that if  is
  trim, so is . Finally, we observe that a configuration can only
  be reachable by  if it is also reachable by , or if it
  comprises only states from  (i.e., states from the
  additional levels that we have introduced). By construction, any
  reachable configuration of  has as many successor configurations
  in  as in . Furthermore, every configuration comprising
  only states from  has precisely one successor
  configuration in . Hence, if  is nonblocking, so is .
\end{proof}

\section{Game-Theoretic Characterization} \label{sec:game-theo}
In this section, we give an alternative characterization of the
acceptance behaviour of ADGAs, using a game-theoretic approach. This
different point of view will be useful on two occasions: in
\cref{sec:closure-properties}, where we will show that ADGAs can be
easily complemented, and in \cref{sec:adga=mso}, where we will encode
the behaviour of a given ADGA into a logical formula.

The entire approach is heavily inspired by the work of Löding and
Thomas in \cite{LT00}, where they investigated the complementation of
finite automata on infinite words. A simplified variant for automata
on finite words can be found in \cite{Kum06}.

We consider games with two players: the \emph{automaton}
(player~), and the \emph{pathfinder} (player~).\footnote{The
  custom of calling the players “automaton” and “pathfinder” was
  introduced by Gurevich and Harrington in \cite{GH82}.} Given an ADGA
 and a labeled graph , the goal of the automaton is to accept
, while the pathfinder tries to reject it. In a way, the
automaton wants to come up with an accepting run of  on , and
the pathfinder seeks to refute any possible run, by finding (a path
to) a rejecting configuration. Thus, the automaton is responsible for
the nondeterministic (existential) choices, whereas the pathfinder
picks among the universal branches.

The game associated with  and  is represented by a directed
acyclic graph whose nodes are configurations of  on . This
graph can be thought of as a superposition of all possible runs of
 on . We refer to its nodes as (game) \defd{positions}, but
keep the terminology used for configurations (e.g., “existential”,
“permanent”, etc.). The nonpermanent positions are divided among the
two players: existential ones belong to the automaton, universal ones
to the pathfinder. Starting at the initial configuration of  on
, the two players move through the graph together. At each
position, the player owning that position has to choose the next move
along one of the outgoing edges. This continues until some permanent
position is reached. If that position is accepting, the automaton
wins, otherwise the pathfinder wins. Also, if a nonpermanent position
is reached from which no move is possible, the owner of that position
loses. (This cannot happen if  is nonblocking.)

\begin{definition}[Game]
  Let  be an ADGA and  a -labeled
  -graph. The \defd{game}  associated with 
  and  is the tuple  defined as follows:
  \begin{itemize}
  \item , where
    \begin{itemize}
    \item  and  are the
      sets of existential and universal configurations, respectively,
      reachable by  on ,
    \item  are the sets of accepting and rejecting
      configurations, respectively, reachable by  on .
    \end{itemize}
    We use the abbreviation .
  \item  is the \defd{starting position} of the game.
  \item  is the set of directed edges for which 
    constitutes a directed acyclic graph, such that
    \begin{itemize}
    \item  is the only source,
    \item every node  with
       has exactly  outgoing
      neighbors ,\, and
    \item every node  is a sink.
    \end{itemize}
  \end{itemize}
\end{definition}

If  and  are not relevant in a given context, we refer to
 simply as \emph{a} game . For
convenience, we will apply graph-theoretic notions directly to ,
referring implicitly to its underlying graph , e.g., by “a
path in ” we mean “a path in ”.

\newpage

\begin{example}[Game associated with ]
  \Cref{fig:game} represents the game
   associated with the ADGA
  from \cref{fig:ADGA_concentric_circles} and the labeled graph from
  \cref{fig:graph_labeled_square}. The green configuration is the
  starting position and belongs to the automaton, whereas the red
  positions belong to the pathfinder. Just as for runs, the blue
  positions with a double circle are accepting, and the other blue
  positions rejecting.

  The game is a superposition of all possible runs of 
  on , in the sense that it contains all of these runs as
  subgraphs. For instance, we obtain the run from
  \cref{fig:run_rejecting} as the subgraph induced by the green
  position, the third red position from the top, and the four
  bottommost blue positions.
\end{example}

\begin{figure}[htb]
  \alignpic
  \begin{tikzpicture}[run or game, small configs]
  \matrix {
      & \node[config,univ] (c2a) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}};
        & \node[config,prej] (c3a) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\ \\
      & \node[config,univ] (c2b) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}};
        & \node[config,pacc] (c3b) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\
    \node[config,exis] (c1) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\
      & \node[config,univ] (c2c) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}};
        & \node[config,prej] (c3c) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\ \\
      & \node[config,univ] (c2d) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}};
        & \node[config,prej] (c3d) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\ \\
      & & \node[config,pacc] (c3e) {\squaregraphPic{configuration}{\lnodedistC}{}{}{}{}}; \\
  };
  \coordinate (init) at ([xshift=-3ex,yshift=3ex]c1.north west);
  \path (init) edge (c1)
        (c1)   edge (c2a)
               edge (c2b)
               edge (c2c)
               edge (c2d)
        (c2a)  edge[pathfinder strat] (c3a)
        (c2b)  edge[pathfinder strat] (c3a)
        (c2c)  edge (c3b)
               edge (c3c)
               edge[pathfinder strat,bend left=5] (c3d)
               edge[bend left=5] (c3e)
        (c2d)  edge[bend right=5] (c3b)
               edge[pathfinder strat,bend right=5] (c3c)
               edge (c3d)
               edge (c3e);
\end{tikzpicture}   \caption{The game associated with the ADGA  from
    \cref{fig:ADGA_concentric_circles} and the labeled graph
     from \cref{fig:graph_labeled_square}. The edges
    highlighted in red represent a winning strategy for the
    pathfinder.}
  \label{fig:game}
\end{figure}

It remains to formalize how a game is played, and how the winner is
determined.

\begin{definition}[Play]
  A \defd{play}  in a game  is a path from the starting position
  to some sink (i.e., a maximal path). The \defd{winner} of the play
   (with respect to ) is
  \begin{itemize}
  \item the automaton, if  is either accepting or universal,
  \item the pathfinder, if  is either rejecting or
    existential.
  \end{itemize}
\end{definition}

We will refer to  as a \defd{goal position} of the automaton
or the pathfinder, depending on which player wins when reaching that
position.

The moves chosen by the two players in a play  are determined by
their respective strategies.

\begin{definition}[Strategy]
  A (memoryless or positional) \defd{strategy} for player
   in a game  is a partial
  function , such that  is an outgoing
  neighbor of , for every position  in  that belongs to
  player~ and is not a sink. A play  is
  \defd{played according} to  \Iff 
  for every node  on  that belongs to player~, where
  .

  We say that  is a \defd{winning strategy} for player~ \Iff
  that player wins every play  in  played according to .
\end{definition}

\begin{example}[Winning Strategy for the Pathfinder]
  We consider again the game 
  from \cref{fig:game}. No matter which position the automaton chooses
  in the first round, the pathfinder can always move to a rejecting
  position in the second round. One possible winning strategy for the
  pathfinder is represented by the edges highlighted in red.

  The fact that the pathfinder has a winning strategy in this game is
  essentially a restatement of the observation made in
  \cref{ex:A_centric_language}: every run of  on
   is rejecting.
\end{example}

The previous example already suggests a strong relationship between
the acceptance behaviour of ADGAs and the winning strategies of the
two players. To no great surprise, both concepts turn out to be
equivalent.

\begin{lemma}[Acceptance and Winning Strategy] \label{lem:acc-win}
  Let  be an ADGA and  a labeled graph. Then  accepts
   \Iff the automaton has a winning strategy in the game
  .
\end{lemma}

\begin{proof} We give a very simple proof, for the sake of
  completeness.
  \begin{itemize}
  \item[()] If  accepts , there is an accepting run  of
     on , from which we construct the following strategy
     for the automaton in : For every position
     in  that belongs to the automaton and is not a sink,
     is the unique outgoing neighbor of  in ,
    provided that  occurs in . Otherwise  is some
    arbitrary outgoing neighbor of  in . Hence, any play
     in  played according to 
    corresponds to a maximal path in  (starting at
    ). Since  is a run and  has no outgoing
    neighbors,  is either universal or permanent. Furthermore,
    since  is accepting, if  is permanent, then it is also
    accepting. In any case, the automaton wins the play , i.e., it
    wins every play in  played according to , which means
    that  is a winning strategy for that player.
  \item[()] If the automaton has a winning strategy  in
    , we can construct the following run  of  on
    : Starting at , for every node  in , if
     belongs to the automaton, then its unique outgoing neighbor
    in  is \;\!\footnote{The value of 
      cannot be undefined, because otherwise any path in  from
       to  would be a play played according to 
      that is lost by the automaton (since  is existential),
      which would contradict the assumption that  is a winning
      strategy for the automaton.}, and if  belongs to the
    pathfinder, then its outgoing neighbors in  are given by
    . Hence, every maximal path 
    in  corresponds to a play in  played according to
    . Since permanent configurations do not have any outgoing
    neighbors, the only node on  that might be permanent is
    . Furthermore, since  is a winning strategy for the
    automaton, the configuration  is either accepting or
    universal. Thus every permanent configuration occurring on some
    (maximal) path in  is accepting, which implies that  is an
    accepting run, from which follows that  accepts .
    \qedhere
  \end{itemize}
\end{proof}

Dually to \cref{lem:acc-win}, an ADGA rejects a labeled graph \Iff the
pathfinder has a winning strategy in the associated game. Instead of
proving this directly, we can infer it from the following determinacy
result.

\begin{lemma}[Determinacy] \label{lem:either-win}
  In every game , either the automaton or the pathfinder has a
  winning strategy.
\end{lemma}

\begin{proof}
  We consider every position  of the game
   as the starting position of a subgame
   which is obtained by restricting  to the subgraph induced
  by  and all its descendant configurations. Note that this
  implies that . We show by induction on the structure of
  the game, that for every position  in , either the automaton
  or the pathfinder has a winning strategy in the induced subgame
  .
  \begin{itemize}
  \item[(\texttt{BC})] If  is a sink, then  consists only of
    the single position , and the only possible play in  is
    . The automaton wins that play if  is either accepting
    or universal, otherwise the pathfinder wins. In any case, one of
    the two players has a (trivial) winning strategy.
  \item[(\texttt{IS})] Now consider the case that  has 
    outgoing neighbors . Let
    player~ be the player who has to make a move at
    position , i.e., , and let player~ be the
    opponent. By induction hypothesis, we know that for each of the
    subgames , either player~ or player~
    has a winning strategy. There are two possible cases:
    \begin{itemize}
    \item If player~ has a winning strategy  in some subgame
       (), this strategy can be extended to a winning
      strategy  in , where for every node  in 
      that belongs to player~ and has at least one outgoing
      neighbor,
      
    \item Otherwise, player~ has winning strategies  for each of the subgames ,
      respectively. These can be combined into a winning strategy
       in , such that for every node  in  that
      belongs to player~ and has at least one outgoing neighbor,
      , where  is the
      smallest\footnote{The subgames  are not
        necessarily disjoint. If a position occurs in several
        subgames, player~ can arbitrarily choose which winning
        strategy to follow at that position, since any choice will
        lead the play one step closer to some goal position of
        player~.} index for which the corresponding subgame
       contains .
    \end{itemize}
    In both cases, either the automaton or the pathfinder has a
    winning strategy in .
    \qedhere
  \end{itemize}
\end{proof}

\section{Closure Properties} \label{sec:closure-properties}
Building on the results from \cref{sec:normal-forms,sec:game-theo}, we
can now establish some closure properties of the class of
ADGA-recognizable graph languages.

Complementation can be achieved by a simple dualization construction,
which does not involve any blow-up. We have already used this
implicitly in the examples of \cref{sec:adga-preview}, where the ADGA
 from \cref{fig:ADGA_3_colorable} was complemented by
changing its existential states to universal ones and complementing
its acceptance condition. This resulted in the ADGA 
from \cref{fig:ADGA_not_3_colorable}. The following definition
generalizes this construction for arbitrary ADGAs.

\begin{definition}[Dual Automaton]
  Let  be
  an ADGA. Its \defd{dual automaton}  is obtained by swapping the
  existential and universal states, and complementing the set of
  accepting states, i.e.,
  
\end{definition}

To show that the dual automaton is always a complement automaton, we
first look at this construction from the game-theoretic point of view.

\begin{lemma*} \label{lem:dualization}
  Consider an ADGA  over  and a labeled graph
  . Then the automaton has a winning strategy in
  the game  \Iff the pathfinder has a winning strategy in
  the dual game .
\end{lemma*}

\begin{proof}
  Let
  .
  We observe that the dual game  has the same
  underlying graph and starting position as , only the roles and
  winning conditions of the two players have been interchanged, i.e.,
  . Hence,
  every play  in  is also a play in , and vice versa. Due
  to the complementarity of the winning conditions,
  player~ wins  in  \Iff its opponent,
  player~, wins  in . Moreover, the reversal of roles
  ensures that a strategy  for player~ in the one game is a
  strategy for player~ in the other game. Thus, player~ wins
  every play played according  in  \Iff player~ wins every
  play played according  in .
\end{proof}

It is now straightforward to prove the desired result.

\begin{lemma}[Complementation] \label{lem:complementation}
  For every ADGA  over , the dual automaton 
  recognizes the complement language of , i.e.,
  
\end{lemma}

\begin{proof}
  Let . By \cref{lem:acc-win},  accepts 
  \Iff the automaton has a winning strategy in the game
  . By Lemma~\ref{lem:dualization}, this is equivalent to
  the pathfinder having a winning strategy in the dual game
  .  By \cref{lem:either-win}, this is the case \Iff the
  automaton does not have a winning strategy in . Again
  by \cref{lem:acc-win}, this is equivalent to saying that  does
  not accept . Hence,  accepts  \Iff  does not
  accept .
\end{proof}

Next, we prove closure under union and intersection. The following
constructions exploit the power of nondeterminism and universal
branching, and are, in principle, very similar to the corresponding
constructions for alternating automata on words. However, because of
the distributed nature of ADGAs, they are slightly more technical
(local choices must be coordinated).

\begin{lemma}[Union and Intersection] \label{lem:union-intersect}
  For every two ADGAs  and  over , we can
  effectively construct ADGAs  and  that recognize the
  union language and intersection language, respectively, of 
  and , i.e.,
  
  Moreover, \vspace{-1.5ex}
  
\end{lemma}

\begin{proof}
  Let  and . Without loss of generality, we may assume that
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item both automata are nonblocking and trim (see
    \cref{rem:nonblocking,rem:trim}), and
  \item they agree on the sequence of quantifiers, i.e., for\,
    , the state sets
     and  are either both existential or
    both universal, in the respective automata. By \cref{rem:ANF}, a
    simple way to ensure this is to transform both automata into
    alternating normal form, and possibly inserting an additional
    “dummy” level into one of them.
  \end{itemize}
  Further, let  be a set of states with the same cardinality as
  , where  denotes the state corresponding to , and
  let  and  be two additional states. We assume that
  , ,  and  are pairwise disjoint.

  First, we construct the union automaton. The idea is that, in the
  first round, each node in the input graph nondeterministically and
  independently decides whether to behave like in  or in
  . If there is a consensus, then the run continues as it would
  in the unanimously chosen automaton , and it is accepting \Iff
  it corresponds to an accepting run of . Otherwise, a conflict
  is detected, either locally by adjacent nodes, or at the latest,
  when acceptance is checked globally, and in either case the run is
  rejecting. Formally, we define ,
  where
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item ,
  \item ,
  \item ,
  \item a∈Σ,
  \item
    q=q_a∈Q_Σ\S∈(2^{Q_Σ})^Γq∈Q_1\S∈(2^{Q_1})^Γq∈Q_2\S∈(2^{Q_2})^Γ \\
    for every  and \!,
  \item .
  \end{itemize}
  Note that  satisfies the properties required by the definition
  of an ADGA, in particular, that states on the same level are in the
  same component of , which is guaranteed by the assumptions
  that  and  are both trim and agree on the sequence of
  quantifiers.

  Next, we verify that, for any ,\:\! 
  accepts  \Iff  or  accepts .
  \begin{itemize}
  \item[()] Let one of the two automata, say ,\, ,
    have an accepting run  on . By construction, the
    initial configuration of  on  is existential, and there
    is a global transition to the initial configuration of  on
    , i.e., . Moreover, any
    transition of  is also a transition of , and
    configurations common to  and  have the same type
    (e.g., existential, etc.) in both automata. Thus,
    
    is a run of  on , and since , any permanent
    configuration occurring in  is accepting, which entails that
     is also accepting.
  \item[()] Now let  have an accepting run  on
    . Since the initial configuration of  on  is
    existential, it must have exactly one outgoing neighbor  in
    . By construction of , every state occurring in 
    belongs to either  or , i.e., .

    Assume that states of both automata occur in . We generalize
    this property by calling any configuration  of 
    \emph{impure} if
    .
    \begin{itemize}[topsep=0ex,itemsep=0ex]
    \item Any successor configuration of an impure configuration is
      also impure, because there are no local transitions from
       to , or from  to .
    \item Further, any impure permanent configuration  is
      rejecting, because  being impure means that , and consequently the acceptance
      condition given by  cannot be fulfilled.
    \end{itemize}
    Hence, the above assumption implies that all the permanent
    configurations among  and its descendant configurations under
     are rejecting. Since we required  and 
    to be nonblocking, such permanent configurations must exist (every
    nonpermanent configuration has at least one successor
    configuration). It follows that  is not accepting, which is a
    contradiction.

    We conclude that only states of one automaton, say ,\,
    , can occur in . More precisely,  is the
    initial configuration of  on , i.e.,
    . Since  behaves like  on
    configurations of , this means that  is exactly of the
    same form as the run constructed in the previous part of this
    proof, i.e.,
    
    where  and . By removing the initial
    configuration (and its outgoing edge), we get a run 
    of  on , which is accepting because
    .
  \end{itemize}
  Finally, we turn our attention to the intersection automaton. By De
  Morgan's law, ,\:\! hence we can simply
  combine the available constructions for complementation and union,
  which leads to the intersection automaton
  , where
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item ,
  \item ,
  \item ,
  \item a∈Σ,
  \item
    q=q_a∈Q_Σ\S∈(2^{Q_Σ})^Γq∈Q_1\S∈(2^{Q_1})^Γq∈Q_2\S∈(2^{Q_2})^Γ \\
    for every  and \!,
  \item .
    \qedhere
  \end{itemize}
\end{proof}

As a last type of operation on graph languages, we consider uniform
relabelings of nodes, which we call node projections and formally
define as follows.

\begin{definition}[Projection]
  Let  and  be two nonempty node alphabets and  an edge
  alphabet. A (node) \defd{projection} from  to  is a mapping
  . With a slight abuse of notation, this mapping is
  extended to labeled graphs by applying it to each node label, and to
  graph languages by applying it to each labeled graph. More
  precisely, for every  and ,
  
\end{definition}

Again exploiting the power of nondeterminism, we can easily show that
ADGA-recognizable graph languages are closed under arbitrary
projections.

\begin{lemma}[Projection] \label{lem:projection}
  For every ADGA  over  and projection\, ,
  we can effectively construct an ADGA  that recognizes the
  projected language of  through , i.e.,
  
  Moreover, \vspace{-1.5ex}
  
\end{lemma}

\begin{proof}
  The idea is simple: For every , each node labeled with 
  nondeterministically chooses a new label , such that
  . Then the automaton  is simulated on that new input.

  Without loss of generality, we may assume that  is trim (see
  \cref{rem:trim}). Let , and let  be a
  set of states with the same cardinality as  and disjoint from
  , where  denotes the state corresponding to
  . We construct the projection automaton , where
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item ,
  \item b∈Σ',
  \item
    q=q_b∈Q'_{Σ'}\S∈(2^{Q'_{Σ'}})^Γq∈Q\S∈(2^Q)^Γ \\
    for every  and \!.
  \end{itemize}
  Note that, as required, states on the same level of  are of the
  same type (e.g., existential, etc.), because we have assumed that
   is trim. Consider any . The
  initial configuration  of  on  is
  existential. Its successor configurations are the initial
  configurations of  on the -labeled -graphs that are mapped
  to  by , i.e.,
  
  Moreover, the behaviours of  and  on configurations of 
  are the same. Hence, arguing similarly as for the union construction
  (\cref{lem:union-intersect}), we can show that  accepts
   \Iff  accepts some  such that .
\end{proof}

The following theorem summarizes the closure properties stated in
\cref{lem:complementation,lem:union-intersect,lem:projection}.

\begin{theorem}[Closure Properties] \label{thm:closure}
  The class  of ADGA-recognizable graph languages is
  effectively closed under boolean set operations and under
  projection.
\end{theorem}
 

\chapter{Monadic Second-Order Logic on Graphs} \label{chap:msol}
In this chapter, we review monadic second-order (MSO) logic on labeled
graphs. Then, building on the results of \cref{chap:adga}, we prove
our main result: the ADGA-recognizable graph languages are precisely
the MSO-definable ones. This, in turn, allows us to infer some
negative properties of ADGAs.

\section{Basic Definitions}
Throughout this work, we fix two disjoint, countably infinite sets of
(object language) variables: the supply of node variables
, and the supply of
set variables . Node
variables will always be represented by lower-case letters, and set
variables by upper-case ones (sometimes with
subscripts).\footnote{Concrete instances of such object language
  variables will be typeset in a bright blue sans-serif font, to
  better distinguish them from meta-language variables, which can
  refer (amongst others) to arbitrary object language variables.}

\begin{definition}[MSO-Logic: Syntax] \label{def:mso-syntax}
  Let  be a node alphabet and  an edge alphabet. The set
  \defd{} of \defd{monadic second-order formulas} (on
  graphs) over  is built up from the \defd{atomic} formulas
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item 
    \quad (“ has label ”),
  \item 
    \quad (“ has a -edge to ”),
  \item 
    \quad (“ is equal to ”),
  \item 
    \quad (“ is an element of ”),
  \end{itemize}
  for all\, ,\, ,\, ,\, and
  , using the usual propositional connectives and
  quantifiers, which can be applied to both node and set
  variables. More precisely, if  and  are -formulas,
  then so are \noheight{\mbox{,\,
      ,\, ,\,
      ,\, ,\,
      ,\, ,\,
      , and }}, \\
  for all  and .
\end{definition}

We will consistently represent MSO-formulas in the typographic style
used above, to distinguish object language from
meta-language.\footnote{ In order to make a clear distinction between
  MSO-formulas and formal statements at the meta-level (where some of
  the same symbols are used), the former will always be represented on
  a light blue background, using a bright blue font for symbols that
  directly occur in the considered formula. In contrast to this, other
  symbols must be interpreted at the meta-level to get the intended
  MSO-formulas. As usual, notations like
   and
   are used
  to represent  and
  ,
  respectively.}

An occurrence of a variable  or  in a formula 
is said to be \defd{free} if it is not within the scope of a
quantifier. We denote by  the set of variables that
occur freely in . If  has no free occurrences of variables,
i.e., if\, , we say that  is a
\defd{sentence}. Moreover, we will use the notation
\defd{} to indicate that at most the variables
given in brackets occur freely in , i.e.,
. This notation will also
occasionally be abused to instantiate a formula (schema) with concrete
variables.\footnote{Strictly speaking, if  and  are
  unspecified, an object like  is a
  formula schema. We can instantiate it with concrete object language
  variables, for instance  and , to obtain the
  formula , which (by slight abuse of notation) will be
  denoted by . To simplify matters, we shall
  henceforth not explicitly distinguish formula schemata from
  formulas.}

\begin{definition}[MSO-Logic: Semantics]
  The truth of an -formula  is evaluated with respect to
  a labeled graph  and a variable assignment\,
   that assigns a node  to each
  node variable in , and a set of nodes  to each set
  variable in . We write  to denote that
   and  \defd{satisfy} . If  is a sentence, the variable
  assignment is superfluous, and we simply write  if
   satisfies . The meaning of the atomic formulas is as hinted
  informally in \cref{def:mso-syntax}, i.e.,
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item
    ,
  \item ,
  \item
    ,
  \item
    .
  \end{itemize}
  for all\, ,\, ,\, ,\, and
  . Composed formulas are interpreted according to the usual
  semantics of second-order logic, i.e.,
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item ⟨G_λ,α⟩⊭φ,
  \item ⟨G_λ,α⟩⊨φ⟨G_λ,α⟩⊨ψ,
  \item ⟨G_λ,α⟩⊨φ⟨G_λ,α⟩⊨ψ,
  \item ⟨G_λ,α⟩⊭φ⟨G_λ,α⟩⊨ψ,
  \item ⟨G_λ,α⟩⊨\logic{\meta{φ}⇒\meta{ψ}}⟨G_λ,α⟩⊨\logic{\meta{ψ}⇒\meta{φ}},
  \item ⟨G_λ,α[x\!↦\!v]⟩⊨φv∈\VG,
  \item ⟨G_λ,α[x\!↦\!v]⟩⊨φv∈\VG,
  \item ⟨G_λ,α[X\!↦\!U]⟩⊨φU⊆\VG,
  \item ⟨G_λ,α[X\!↦\!U]⟩⊨φU⊆\VG,
  \end{itemize}
  for all\, ,  and . Here,
   designates the variable assignment that coincides with
   except for , which is mapped to , and analogously,
   coincides with  except for , which is mapped to
  .
\end{definition}

We will omit some unnecessary parentheses by following some of the
usual precedence rules for propositional connectives: 
binds stronger than  and , which in turn bind
stronger than  and .

\begin{definition}[MSO-Definability]
  The graph language  \defd{defined} by an
  -sentence , with respect to , is the set of all
  -labeled -graphs for which the sentence is satisfied, i.e.,
  
  Every graph language that is defined by some MSO-sentence is called
  \defd{MSO-definable}. We denote by \defd{} the class of
  all such graph languages.
\end{definition}

An -sentence  is \defd{equivalent} to an ADGA  over
 if it defines the same graph language as  recognizes,
i.e., .

We now revisit two of the graph languages considered in
\cref{chap:adga}, and define them by MSO-sentences.

\begin{example}[Translation of  to MSO-Logic] \label{ex:A_centric_MSO}
  We fix  and . The following
  -sentence  is equivalent to the ADGA
   from \cref{fig:ADGA_concentric_circles} (see
  \cref{ex:A_centric_language} for a discussion of the recognized
  graph language).
  \newcommand{\va}{v_{\hspace{-.2ex}\meta{\a}}}
  -.9ex]
    &\logic{∃\va\biggl( ∀u\Bigl(\bigl(\lab{\a}u \:\!⇔\:\! u\!=\!\va\bigr)
      \,∧\,\bigl(u\!\arr\!\va ∨ \va\!\arr\!u \,⇒\, \lab{\b}u\bigr) \Bigr) \;∧} \
  The first line ensures that no two adjacent nodes are both
  -labeled or both -labeled. The other two lines specify the
  existence of the “center”, a node  such that
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item  is the only -labeled node in the graph and has only
    -labeled nodes in its undirected neighborhood (second line),
    and
  \item  has at least two distinct incoming neighbors (third
    line).
  \end{itemize}
\end{example}

In the preceding example, we did not exploit the possibility of
quantifying over set variables. This makes  a
\emph{first}-order formula. The next example (slightly adapted from
\cite{CE12}) shows an application that requires second-order
quantification.

\begin{example}[3-Colorability] \label{ex:MSO_3_colorable}
  Let . The following -sentence
   defines (with respect to ) the language of
  3-colorable graphs. It is thus equivalent to the ADGA
   from \cref{fig:ADGA_3_colorable}.
  -1.5ex]
    &\hspace{5ex}\logic{¬\bigl(u∈U_\mpik ∧ u∈U_\mkreuz\bigr)
      \,∧\, ¬\bigl(u∈U_\mherz ∧ u∈U_\mkreuz\bigr)\:\!\Big) \;∧} \-1.5ex]
    &\hspace{11.2ex}\logic{¬\bigl(u∈U_\mherz∧v∈U_\mherz\bigr)
      \,∧\, ¬\bigl(u∈U_\mkreuz∧v∈U_\mkreuz\bigr)\:\!\Bigr)\,\biggr)} \hspace{-5ex}
  
    \Lf{Σ,Γ}(\phiA)=\L(\A).
  -1.5ex]
  4ex]
      \logic{\:\meta{x}∈U_{\meta{i},\meta{q}} \hspace{2.95ex}} & \text{if\, }.
    \end{cases}
  
    \Fneigh{i}{q,\ShiddenhatScr}[\lsymb{v},\wh{X}_i] \;\coloneqq\;\;
    &\logic{\meta{\Fstate{i}{q}[\lsymb{v},\wh{X}_i]} \;\,
      ∧\; \smashoperator{\bigwedge_{\meta{γ∈Γ,\:p∈S_γ}}}\, ∃u\Bigl(\meta{\Fstate{i}{p}[\lsymb{u},\wh{X}_i]}
      \,∧\, u\xarr{\meta{γ}}v\Bigr) \vphantom{\biggr)} } \

  With building blocks for these local properties at our disposal, we
  can now proceed to more global statements.  For the remainder of
  this proof, we set , and for , we refer by
   to the configuration represented by some given assignment
  to the set variables in . 

  The meaning of the subformula  is
  that  is a legal successor configuration of
  . Two properties have to be checked: On the one hand,
  it must hold that , or equivalently,
  that for every node , if  receives the information
   in round , then it is in some state
   in round . On the other hand, the given
  assignment to the set variables in  must indeed represent
  a valid configuration, which in particular means that a node cannot
  be in several states at once. This leads to the definition
  \newcommand{\PossibleNeighborhoods}{ \hspace{3ex}
    \begin{subarray}{l}
      \swr{\scriptstyle p\:\!}{\S}∈Q_{i-\one}\:\!, \\
      \S∈(\two^{Q_{i-\one}})^Γ
    \end{subarray}
  }
  -1.3ex]
    \hspace{31ex}
    \logic{\,\,∧\;\, \smashoperator{\bigwedge_{\meta{q,r∈Q_i\colon q≠r}}}
      ¬\Bigl(\meta{\Fstate{i}{q}[\lsymb{v},\wh{X}_i]}\,∧\,\meta{\Fstate{i}{r}[\lsymb{v},\wh{X}_i]} \Bigr)\; \Biggr)}.
  
    \Fwin{n}[\wh{X}_n] \;\coloneqq\; \logic{\displaystyle \bigvee_{\meta{F∈\F}}\! \Biggl( \, \smashoperator[r]{\bigwedge_{\meta{q∈F}}}
      ∃v\Bigl(\meta{\Fstate{n}{q}[\lsymb{v},\wh{X}_n]}\Bigr)
      \:∧\; ∀v\Bigl(\smashoperator[r]{\bigvee_{\meta{q∈F}}}\meta{\Fstate{n}{q}[\lsymb{v},\wh{X}_n]} \Bigr) \Biggr)}.
  
    \Fwin{i-1}\:\![\wh{X}_{i-\one}] \;\coloneqq\; \logic{\displaystyle\bigexists \meta{\wh{X}_i}
      \biggl(\meta{\Flegal{i}[\wh{X}_{i-\one},\wh{X}_i]}
      \;∧\; \meta{\Fwin{i}[\wh{X}_i]} \biggr)}.
  
    \Fwin{i-1}\:\![\wh{X}_{i-\one}] \;\coloneqq\; \logic{\displaystyle\bigforall \meta{\wh{X}_i}
      \biggl(\meta{\Flegal{i}[\wh{X}_{i-\one},\wh{X}_i]}
      \:⇒\: \meta{\Fwin{i}[\wh{X}_i]} \biggr)}.
  
    \phiA \coloneqq\, \Fwin{0}[\wh{X}_0] = \Fwin{0}[\:].
    \qedhere
  
    \L(\A_φ)=\Lf{Σ,Γ}(φ).
  
    α^{-1} \colon\: \VG &→ 2^{\free(φ)} \\
    v &↦ \bigl\{x∈\Vnode \bigm| v=α(x)\bigr\} ∪ \bigl\{X∈\Vset \bigm| v∈α(X)\bigr\}.
  
    λ\!×\!α^{-1} \colon\: \VG &→ Σ×2^{\free(φ)} \\
    v &↦ \bigl\langle λ(v),\:α^{-1}(v) \bigr\rangle.
  
    G_{λ×α^{-1}}∈\L(\A_φ) \quad \text{\Iff} \quad\! ⟨G_λ,α⟩ ⊨ φ.
  
      Q_\EE=∅, \quad Q_\AA=∅ \quad \text{and} \quad Q_\P=\{\qyes,\qno,\qmaybe\}.
    
      \F = \bigl\{\{\qyes\},\{\qyes,\qmaybe\}\bigr\}.
    -.4ex]
            or  and ,}} \
      h\colon Σ×2^{\free(ψ)} &→ Σ×2^{\free(φ)\:\!\setminus\:\!\{X\}} \\
      ⟨a,M⟩ &↦ ⟨a,M\!\setminus\!\{X\}⟩.
    
    \defd{R|_v} \coloneqq ⟨q_0,\S_0⟩\cdots⟨q_n,\S_n⟩,
  .5ex]
    for every ,
  \item \, for every ,\; and \, for
    every .
  \end{itemize}
  We call  a \defd{mirroring bijection} between  and  in
  , and  a \defd{mirror image} of  in , for
  every node .
\end{definition}

Note that graph mirroring is well-defined because we consider graphs
only up to isomorphism.

\newpage

\begin{example}
  Let  and . Mirroring  in
  the graph  from \cref{fig:graph_1_before_mirroring}
  yields the graph  depicted in
  \cref{fig:graph_1_after_mirroring}. The function  indicated in
  that figure is the only possible mirroring bijection between
   and  in . We can obtain the same graph
   by mirroring  in the graph  from
  \cref{fig:graph_2_before_mirroring}, as shown in
  \cref{fig:graph_2_after_mirroring}. The function  is one of two
  possible mirroring bijections between  and  in
   (for the other one, the images of  and  are
  swapped). Since there are several ways of obtaining  through
  mirroring, some of the nodes have several mirror images in
  . For instance,  has three of them: ,  and .
\end{example}

\begin{figure}
  \alignpic
  \begin{subfigure}{0.38\textwidth}
    \centering
    \begin{tikzpicture}[lgraph]
  \node[lnode,label=left:] (s) {};
  \node[lnode,label=above:] (t) at ([shift={(30:\lnodedistIG)}]s) {};
  \node[lnode,label=below:] (u) at ([shift={(330:\lnodedistIG)}]s) {};
  \node[lnode] (v) at ([shift={(30:\lnodedistIG)}]t) {};
  \node[lnode] (noname) at ([shift={(330:\lnodedistIG)}]t) {};
  \node[lnode] (w) at ([shift={(330:\lnodedistIG)}]u) {};
  \path[use as bounding box]
    (s)      edge[loop above] (s)
    (t)      edge (v)
    (u)      edge (w)
    (v)      edge[bend left=20] (noname)
    (noname) edge (t)
             edge (u)
             edge[bend left=20] (v)
             edge[bend right=20] (w)
    (w)      edge[bend right=20] (noname);
  \begin{scope}[on background layer, every path/.style={fill=lightblue}]
    \fill[rounded corners=8ex]
      ([xshift=-8.2ex]s.center) -- ([xshift=3.2ex,yshift=7.5ex]t.center) --
      ([xshift=3.2ex,yshift=-7.5ex]u.center) -- cycle;
  \end{scope}
\end{tikzpicture}     \caption{\;}
    \label{fig:graph_1_before_mirroring}
  \end{subfigure}
  \begin{subfigure}{0.51\textwidth}
    \centering
    \begin{tikzpicture}[lgraph, trim right=(z)]
  \node[lnode,label=left:] (s) {};
  \node[lnode,label=above:] (t) at ([shift={(30:\lnodedistIG)}]s) {};
  \node[lnode,label=below:] (u) at ([shift={(330:\lnodedistIG)}]s) {};
  \node[lnode] (v) at ([shift={(30:\lnodedistIG)}]t) {};
  \node[lnode] (noname) at ([shift={(330:\lnodedistIG)}]t) {};
  \node[lnode] (w) at ([shift={(330:\lnodedistIG)}]u) {};
  \node[lnode,label={[yshift=-.65ex]above:}] (x) at ([shift={(330:\lnodedistIG)}]v) {};
  \node[lnode,label={[yshift=.8ex]below:}] (y) at ([shift={(330:\lnodedistIG)}]noname) {};
  \node[lnode,label={right:}] (z) at ([shift={(330:\lnodedistIG)}]x) {};
  \path[use as bounding box]
     (s)      edge[loop above] (s)
     (t)      edge (v)
     (u)      edge (w)
     (v)      edge[bend left=20] (noname)
     (noname) edge (t)
              edge (x)
              edge (u)
              edge (y)
              edge[bend left=20] (v)
              edge[bend right=20] (w)
     (w)      edge[bend right=20] (noname)
     (z)      edge[loop above, counter clockwise] (z)
     (x)      edge (v)
     (y)      edge (w);
  \begin{scope}[on background layer, every path/.style={fill=lightblue}]
    \fill[rounded corners=8ex]
      ([xshift=-8.2ex]s.center) -- ([xshift=3.2ex,yshift=7.5ex]t.center) --
      ([xshift=3.2ex,yshift=-7.5ex]u.center) -- cycle;
    \fill[rounded corners=8ex]
      ([xshift=8.2ex]z.center) -- ([xshift=-3.2ex,yshift=7.5ex]x.center) --
      ([xshift=-3.2ex,yshift=-7.5ex]y.center) -- cycle;
  \end{scope}
\end{tikzpicture}     \caption{\;}
    \label{fig:graph_1_after_mirroring}
  \end{subfigure}

  \vspace{4ex}

  \begin{subfigure}{0.38\textwidth}
    \centering
    \vspace{-9.7ex}
    \begin{tikzpicture}[lgraph]
  \node[lnode] (s) {};
  \node[lnode,label=above:] (t) at ([shift={(30:\lnodedistIG)}]s) {};
  \node[lnode,label=above:] (v) at ([shift={(30:\lnodedistIG)}]t) {};
  \node[lnode] (noname) at ([shift={(330:\lnodedistIG)}]t) {};
  \node[lnode,label=above:] (x) at ([shift={(330:\lnodedistIG)}]v) {};
  \node[lnode] (z) at ([shift={(330:\lnodedistIG)}]x) {};
  \path[use as bounding box]
     (s)      edge[loop above] (s)
     (t)      edge (v)
     (v)      edge[bend left=20] (noname)
     (noname) edge (t)
              edge (x)
              edge[bend left=20] (v)
     (z)      edge[loop above, counter clockwise] (z)
     (x)      edge (v);
  \begin{scope}[on background layer, every path/.style={fill=lightblue}]
    \fill[rounded corners=8ex]
      ([yshift=7.5ex]v.center) -- ([xshift=-7.2ex,yshift=-2.3ex]t.center) --
      ([xshift=7.2ex,yshift=-2.3ex]x.center) -- cycle;
  \end{scope}
\end{tikzpicture}     \caption{\;}
    \label{fig:graph_2_before_mirroring}
  \end{subfigure}
  \begin{subfigure}{0.51\textwidth}
    \centering
    \begin{tikzpicture}[lgraph, trim right=(z)]
  \node[lnode,label=left:\phantom{}] (s) {};
  \node[lnode,label=above:] (t) at ([shift={(30:\lnodedistIG)}]s) {};
  \node[lnode,label={[yshift=.8ex]below:}] (u) at ([shift={(330:\lnodedistIG)}]s) {};
  \node[lnode,label=above:] (v) at ([shift={(30:\lnodedistIG)}]t) {};
  \node[lnode] (noname) at ([shift={(330:\lnodedistIG)}]t) {};
  \node[lnode,label={[yshift=.8ex]below:}] (w) at ([shift={(330:\lnodedistIG)}]u) {};
  \node[lnode,label=above:] (x) at ([shift={(330:\lnodedistIG)}]v) {};
  \node[lnode,label={[yshift=.8ex]below:}] (y) at ([shift={(330:\lnodedistIG)}]noname) {};
  \node[lnode,label=right:\phantom{}] (z) at ([shift={(330:\lnodedistIG)}]x) {};
  \path[use as bounding box]
     (s)      edge[loop above] (s)
     (t)      edge (v)
     (u)      edge (w)
     (v)      edge[bend left=20] (noname)
     (noname) edge (t)
              edge (x)
              edge (u)
              edge (y)
              edge[bend left=20] (v)
              edge[bend right=20] (w)
     (w)      edge[bend right=20] (noname)
     (z)      edge[loop above, counter clockwise] (z)
     (x)      edge (v)
     (y)      edge (w);
  \begin{scope}[on background layer, every path/.style={fill=lightblue}]
    \fill[rounded corners=8ex]
      ([yshift=7.5ex]v.center) -- ([xshift=-7.2ex,yshift=-2.3ex]t.center) --
      ([xshift=7.2ex,yshift=-2.3ex]x.center) -- cycle;
    \fill[rounded corners=8ex]
      ([yshift=-7.5ex]w.center) -- ([xshift=-7.2ex,yshift=2.3ex]u.center) --
      ([xshift=7.2ex,yshift=2.3ex]y.center) -- cycle;
  \end{scope}
\end{tikzpicture}     \vspace{.5ex}
    \caption{\;}
    \label{fig:graph_2_after_mirroring}
  \end{subfigure}
  \caption{Mirroring in -labeled -graphs.}
\end{figure}

We can now use the notion of graph mirroring to establish a necessary
condition for NDGA-recognizability.

\begin{lemma}[Mirroring Lemma] \label{lem:weak-mirroring}
  Every NDGA-recognizable graph language  is closed under
  mirroring, i.e., for every labeled graph  and subset of nodes
  ,
  
\end{lemma}

\begin{proof}
  Let  be an NDGA. Consider any
   and . We set , and
  fix a mirroring bijection  in
  . If , then there must be an accepting run
   of  on . By
  \cref{rem:local_view}, we can derive from it an accepting run
   of  on , in which the
  behaviour of every node  remains the same, i.e.,
  , for , and every node  is imitated by
  its mirror image under , i.e., , for
  . (The local view of the nodes in  does not
  change because they cannot distinguish between nodes that are in the
  same state.) Consequently, .
\end{proof}

\Cref{lem:weak-mirroring} directly yields the following corollary.

\begin{corollary} \label{cor:ndga_infinite}
  Every nonempty NDGA-recognizable graph language is (countably)
  infinite.
\end{corollary}

This implies that we have lost some expressive power by forbidding
universal branchings.

\begin{lemma}[] \label{lem:ndga<adga}
  There are (infinitely many) ADGA-recognizable graph languages that
  are not NDGA-recognizable.
\end{lemma}

\begin{proof}
  Let . We consider the language  of all
  graphs that have at most two nodes, i.e.,
  . This language is nonempty and finite, which by
  \cref{cor:ndga_infinite} implies that it is not
  NDGA-recognizable. On the other hand, it is clearly
  ADGA-recognizable, since it is recognized by the ADGA ,
  specified in \cref{fig:ADGA_max_two}. (The accepting configurations
  of that automaton are those that comprise at most two different
  states.)

  We can apply the same reasoning to any graph language
   in which the number of nodes is
  limited by a constant .
\end{proof}

\begin{figure}[h!]
  \alignpic
  \begin{subfigure}{0.5\textwidth}
    \centering
    \begin{tikzpicture}[automaton]
  \matrix[states] {
                                                  &  \node[permanent] (q_1) {}; \\
    \node[initial,universal] (q_ini) {}; &  \node[permanent] (q_2) {}; \\
                                                  &  \node[permanent] (q_3) {}; \\
  };
  \matrix[accepting sets] {
    \x &    &    & \x & \x &    \\
       & \x &    & \x &    & \x \\
       &    & \x &    & \x & \x \\
  };
  \DrawColumnBackground{1}{3}{6}
\path (q_ini.15) edge (q_1)
        (q_ini)    edge (q_2)
                   edge (q_3);
\end{tikzpicture}     \caption{}
    \label{fig:ADGA_max_two}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[automaton]
  \matrix[states] {
                                                    &  \node[permanent] (q_1) {}; \\
    \node[initial,existential] (q_ini) {}; &  \node[permanent] (q_2) {}; \\
                                                    &  \node[permanent] (q_3) {}; \\
  };
  \matrix[accepting sets] {
    \x \\
    \x \\
    \x \\
  };
  \DrawColumnBackground{1}{3}{1}
\path (q_ini) edge (q_1)
                edge (q_2)
                edge (q_3);
\end{tikzpicture}     \caption{}
    \label{fig:ADGA_min_three}
  \end{subfigure}
  \caption{ and \!, two ADGAs over
     whose graph
    languages consist of the graphs that have at most two nodes, and
    at least three nodes, respectively.}
  \label{fig:ADGA_max_and_min}
\end{figure}

Following this line of thought, we also get that NDGAs cannot, in
general, be complemented.

\begin{lemma}[Complementation] \label{lem:ndga-complementation}
  The class  of NDGA-recognizable graph languages is
  \emph{not} closed under complementation.
\end{lemma}

\begin{proof}
  As mentioned in the proof of \cref{lem:ndga<adga}, the language
   of all -labeled -graphs that
  have at most two nodes is not NDGA-recognizable. However, its
  complement, the language  of all graphs that have at
  least three nodes, is recognized by the NDGA  specified
  in \cref{fig:ADGA_min_three}.
\end{proof}

However, all the other closure properties of ADGAs mentioned in
\cref{sec:closure-properties} are preserved.

\begin{lemma}[Closure Properties] \label{lem:ndga-closure}
  The class  of NDGA-recognizable graph languages is
  effectively closed under union, intersection and projection.
\end{lemma}

\begin{proof}
  The union construction from \cref{lem:union-intersect} and the
  projection construction from \cref{lem:projection} do not introduce
  any universal states, and thus yield NDGAs when applied on
  NDGAs.\footnote{Note that those constructions require the input
    NDGAs to satisfy certain properties. Fortunately, they can be
    assumed to hold without loss of generality: The constructions for
    nonblocking and trim ADGAs (see \cref{rem:nonblocking,rem:trim})
    remain valid when restricted to NDGAs. Furthermore, the
    requirement that two automata agree on the sequence of quantifiers
    is trivially fulfilled for NDGAs.}

  It remains to show closure under intersection. This can be done
  using a simple product construction, similar to the one for finite
  automata on words. Consider two NDGAs
   and . Without loss of generality, we may assume that they
  share the same node and edge alphabets, and that they are both
  nonblocking (see \cref{rem:nonblocking}). For any set ,
  we define the projection on the first component as
  
  and analogously for the projection  on the second
  component. With this, we construct the product NDGA
  , where
  \begin{itemize}
  \item , \quad ,
  \item
    a∈Σ,
  \item
    , \\
    for every  and \!,
  \item .
  \end{itemize}
  It is easy to see that  recognizes .

  Additionally, we also get an alternative construction for the union
  by changing the definition of  to
  
  While this is significantly less efficient than the union
  construction from \cref{lem:union-intersect}, in terms of number of
  states, it has the advantage of not relying on nondeterminism. It
  thus remains applicable when we restrict ourselves to deterministic
  automata in the next section.
\end{proof}

As we have already seen in the Mirroring Lemma
(\cref{lem:weak-mirroring}), all NDGAs have some runs containing
redundancies that prevent them from distinguishing between some nodes
of the input graph. In fact, we can show that \emph{every} run on a
sufficiently large input graph will contain such redundancies. In
order to formally express this idea, we first define two node merging
operations.

Given a graph and two of its nodes  and , asymmetrically
merging  into  means to remove , together with its adjacent
edges, and add outgoing edges from  to all of the former
\emph{outgoing} neighbors of . If we additionally replicate the
incoming edges of , the merging is called symmetric.

\begin{definition}[Node Merging]
  Consider a labeled graph  and two nodes
  . We say that a labeled graph  is obtained by
  \defd{asymmetric merging} of  into  in , and denote it
  by , if
  \begin{itemize}[topsep=1ex,itemsep=0ex]
  \item ,
  \item , \quad for every ,
  \item , \quad for every .
  \end{itemize}
  Similarly, if instead of the second condition it holds that
  
  for every , then  is said to be obtained by
  \defd{symmetric merging} of  and  in , and is denoted by
  .
\end{definition}

With the notation defined, we can now derive another necessary
condition for NDGA-recognizability. The following result reminds
strongly of the Pumping Lemma for regular word languages, and its
proof is somewhat similar in spirit (also based on the Pigeonhole
Principle).

\begin{lemma}[Merging Lemma] \label{lem:merging}
  For every NDGA-recognizable graph language  there exist natural
  numbers  and  (with ) such that every labeled graph 
  satisfies the following node merging properties:
  \begin{itemize}
  \item If  has at least  nodes, then there exist nodes
     such that \
      G_λ∈L \quad \text{implies} \quad \amrg(G_λ,w,w')∈L.
    -2ex]
    
  \end{itemize}
  Moreover, if  is an NDGA that recognizes
  , then we have ,\, and\, .
\end{lemma}

\begin{proof}
  We fix an NDGA  that recognizes  and use
  the abbreviations ,\, , and .

  Note that there cannot be more than  different local
  sequences of states in a run of . Consider a labeled graph
   that has more than  nodes, and
  some run  of  on , where
  . By the Pigeonhole Principle, there must be two distinct nodes
   that have the same local sequence of states in . If we
  asymmetrically merge  into , i.e., if we construct
  , the remaining nodes in  will not
  see the difference if they maintain their behaviour from , since
  their local views will remain the same. More formally, by
  \cref{rem:local_view}, we can derive from  a run
   of  on , such that
   for every node  and . If  is
  accepting, so is , hence  implies .

  If we want to symmetrically merge two nodes, the reasoning is very
  similar, but slightly more involved because the merged node inherits
  the unified incoming neighborhood of the original nodes, and
  consequently would get a new local view if the two local views of
  the original nodes were different. A simple solution is to require a
  larger minimum number of nodes. Altogether, there cannot be more
  than  different local views in any run of
  . Again by the Pigeonhole Principle, if a graph has more than
   nodes, there must be two distinct nodes that
  have the same local view. The rest of the argument is analogous to
  the previous scenario.
\end{proof}

While the previously seen Mirroring Lemma (\cref{lem:weak-mirroring})
allows us to enlarge (“pump up”) graphs without leaving a given
NDGA-recognizable graph language, the Merging Lemma allows us to
shrink (“pump down”) some of them. The combination of both could thus
be considered as some sort of “graph pumping lemma”.

The Merging Lemma provides further evidence of the expressive weakness
of NDGAs, but, perhaps more importantly, it also tells us that their
emptiness problem is decidable. The daunting time complexities
indicated in the following lemma are only rough upper bounds. Better
estimates and algorithms can hopefully be found through further
investigation.

\begin{lemma}[Emptiness Problem] \label{lem:ndga-emptiness}
  The emptiness problem of NDGAs is decidable in doubly-exponential
  time. More precisely, for every NDGA ,
  \begin{itemize}
  \item whether its recognized graph language  is empty or not
    can be decided in time \!, where ,\, and
  \item whether its undirected graph language  is empty
    or not can be decided in time \!\!, where
    .
  \end{itemize}
\end{lemma}

\begin{proof}
  We use again the abbreviations ,\, , and
  . By applying the first part of the Merging Lemma
  (\cref{lem:merging}) recursively, we conclude that if  is
  not empty, then it contains a labeled graph that has at most
   nodes. Similarly, by the second part of the Merging Lemma,
  if  is not empty, then it contains an undirected
  labeled graph that has at most  nodes. (For
  undirected graphs, asymmetric merging is, in general, not
  applicable.) Hence, the emptiness problem is decidable because the
  search space is finite.

  We now derive a rough asymptotic upper bound on the time
  complexities of the naive approaches that check every (directed)
  graph that has at most  nodes, and every undirected graph
  that has at most  nodes, respectively.
  \begin{itemize}
  \item The maximum numbers of nodes can be over-approximated by
     and , respectively.
  \item Given a natural number , there are 
    -graphs with precisely  nodes. (This is only an upper bound
    because we consider isomorphic graphs to be equal.)
  \item Given a -graph  with  nodes, we can decide whether
     for some labeling , by checking every
    possible run of  that starts with a configuration
    . This can be done in time
    .
  \end{itemize}
  Hence, the total time complexities are bounded by
  
  respectively.
\end{proof}

\section{Deterministic Distributed Graph Automata}
As a further restriction, we now forbid nondeterministic choices.

\begin{definition}[Deterministic Distributed Graph Automaton]
  A \defd{deterministic distributed graph automaton} (DDGA) is a
  \emph{nonblocking} NDGA  in which every
  state  has at most one outgoing transition for every
  \!, i.e., . We denote by
   the class of all \defd{DDGA-recognizable} graph
  languages.
\end{definition}

The transition function being deterministic forces every node of an
input graph to behave like its mirror images. This allows us to state
a stronger Mirroring Lemma for DDGAs.

\begin{lemma}[Strong Mirroring Lemma] \label{lem:strong-mirroring}
  Every DDGA-recognizable graph language  is closed under both
  mirroring and the reversal of mirroring, i.e., for every labeled
  graph  and subset of nodes ,
  
\end{lemma}

\begin{proof}~
  \vspace{-1ex}
  \begin{itemize}
  \item[()] The “only if” direction is a specialization of the
    weaker Mirroring Lemma (\cref{lem:weak-mirroring}) to DDGAs.
  \item[()] Let  be a DDGA. Consider any
     and . We set ,
    and fix a mirroring bijection  in
    . If , then the (unique) run
     of  on  is
    accepting. Since  is deterministic, it can be shown
    inductively that every node  behaves like its mirror image
    , i.e., , for . If we remove
     for every , we do not change the local view of any
    node in . Hence, by \cref{rem:local_view}, we can derive from
     the accepting run  of  on
    , where , for every  and
    . Consequently, .  \qedhere
  \end{itemize}
\end{proof}

The Strong Mirroring Lemma implies that DDGAs are utterly incapable of
breaking symmetry. This makes them strictly weaker than NDGAs.

\begin{lemma}[] \label{lem:ddga<ndga}
  There are (infinitely many) NDGA-recognizable graph languages that
  are not DDGA-recognizable.
\end{lemma}

\begin{proof}
  Let . We consider again the language
  
  of all graphs that have at least three nodes. As already mentioned
  in the proof of \cref{lem:ndga-complementation}, this language is
  NDGA-recognizable because it is recognized by the NDGA 
  from \cref{fig:ADGA_min_three}. Now, assume that  is
  also DDGA-recognizable and consider the graphs  and
   from
  \cref{fig:graphs_two_and_three_nodes}. Clearly , and
  by \cref{lem:strong-mirroring}, it follows that ,
  which is a contradiction. Hence,  is not
  DDGA-recognizable.

  We can apply a similar reasoning to any graph language
   in which the number of nodes is
  bounded from below by a constant .
\end{proof}

\begin{figure}[h!]
  \alignpic
  \begin{subfigure}{0.35\textwidth}
    \centering
    \begin{tikzpicture}[lgraph]
  \node[lnode,label=below:] (u) {};
  \node[lnode,label=below:\phantom{}] (v) at ([shift={(0:\lnodedistIG)}]u) {};
  \path (u) edge (v);
\end{tikzpicture}     \caption{}
    \label{fig:graph_two_nodes}
  \end{subfigure}
  \begin{subfigure}{0.35\textwidth}
    \centering
    \begin{tikzpicture}[lgraph]
  \node[lnode,label=below:] (u) {};
  \node[lnode] (v) at ([shift={(0:\lnodedistIG)}]u) {};
  \node[lnode,label=below:] (w) at ([shift={(0:\lnodedistIG)}]v) {};
  \path (u) edge (v)
        (w) edge (v);
\end{tikzpicture}     \caption{}
    \label{fig:graph_three_nodes}
  \end{subfigure}
  \caption{Two -labeled -graphs related by
    mirroring.}
  \label{fig:graphs_two_and_three_nodes}
\end{figure}

Instead of expecting the automaton to break symmetry through
nondeterminism, we could also rely on additional information provided
by the node labels of the input graph. Well-chosen labels can make the
structure of the input graph visible to a deterministic
automaton. This strong dependence on the node labeling implies the
following negative result.

\begin{lemma}[Projection] \label{lem:ddga-projection}
  The class  of DDGA-recognizable graph languages is
  \emph{not} closed under projection.
\end{lemma}

\begin{proof}
  Let  and . We consider the language
   of all -labeled graphs in which every node
  label occurs at least once, i.e.,
  
  This language is recognized by the DDGA 
  specified in \cref{fig:ADGA_occur_abc}. Now, consider the projection
   with . Clearly,
   is equal to the language  of
  all -labeled graphs that have at least three nodes. As
  shown in the proof of \cref{lem:ddga<ndga}, this language is not
  DDGA-recognizable.
\end{proof}

\begin{SCfigure}[1.8][h!]
  \alignpic
  \begin{tikzpicture}[automaton]
  \matrix[states] {
    \node[permanent] (q_a) {}; \\
    \node[permanent] (q_b) {}; \\
    \node[permanent] (q_c) {}; \\
  };
  \matrix[symbols] { 
    \node (a) {}; \\
    \node (b) {}; \\
    \node (c) {}; \\
  };
  \matrix[accepting sets] {
    \x \\
    \x \\
    \x \\
  };
  \DrawColumnBackground{1}{3}{1}
\path (a) edge (q_a)
        (b) edge (q_b)
        (c) edge (q_c);
\end{tikzpicture}   \caption{, a DDGA over
     whose graph
    language consists of the labeled graphs in which each of the three
    node labels occurs at least once.}
  \label{fig:ADGA_occur_abc}
\end{SCfigure}

On the positive side, the union and intersection constructions for
NDGAs remain valid, and complementation becomes trivial.

\begin{lemma}[Closure Properties] \label{lem:ddga-closure}
  The class  of DDGA-recognizable graph languages is
  effectively closed under boolean set operations.
\end{lemma}

\begin{proof}
  The product constructions for union and intersection specified in
  the proof of \cref{lem:ndga-closure} yield DDGAs when applied on
  DDGAs.

  It remains to show closure under complementation. Consider any DDGA
  . Since its transition function is
  deterministic,  has precisely one run on each labeled graph
  . Hence, we obtain a complement automaton 
  by simply complementing the acceptance condition, i.e.,
  .
\end{proof}
 

\chapter{Conclusion}
We first summarize and comment upon the results obtained in this work,
and then conclude with a small selection of open questions that seem
worth pursuing.

\section{Commented Summary}
We have introduced ADGAs, a new class of finite graph
automata. Although many graph automaton models have been defined over
the last decades, ADGAs are probably the first automata to be
equivalent to MSO-logic on graphs. In this regard, it seems remarkable
that the individual ingredients of this model of computation are not
spectacular at all, and, for the most part, well-established.

To a certain extent, ADGAs can be considered as synchronous
distributed algorithms, where each node is limited to a finite-state
machine. The model is further restricted by a constant running time
and the fact that nodes see only an abstract representation of their
neighborhood, in the form of sets of states, which drastically limits
their ability to distinguish between different neighbors. The latter
restriction allows ADGAs to operate on graphs of unbounded degree, a
feature that sets them apart from many other types of finite graph
automata defined in the literature (for instance in \cite{WR79} and
\cite{Tho91}).

Besides this distributed character, there is also a centralized aspect
to ADGAs, which contributes greatly to their expressive power. On the
one hand, acceptance is decided on a global level, based on the set of
states reached by the local processors. This combines and generalizes
two decision-making approaches that may appear more natural in a
distributed setting: decision by a unique leader and decision by
unanimous agreement of all the nodes. On the other hand, ADGAs
implement the powerful concept of alternation, a kind of
parallelization, which is also expressed in terms of the global
configuration of the entire system.

As already mentioned above, taken in isolation these concepts
represent nothing new. The contribution of the present thesis is
mainly to combine them into a model of computation that balances
between distribution and centralization in a way that matches
precisely MSO-logic.

For finite automata on words and (bottom-up) tree automata,
alternation and nondeterminism do not increase expressiveness (see
\cite[Thm~5.2]{CKS81} and \cite[Thm~7.4.1]{TATA08}). For our graph
automata, on the other hand, they are essential ingredients that
cannot be eliminated without losing expressive power. We have seen
that the deterministic, nondeterministic and alternating variants of
distributed graph automata form a strict hierarchy, i.e.,

On an intuitive level, this is not very surprising, since
nondeterministic choices and universal branchings are closely related
to existential and universal quantification in MSO-logic, and removing
one type of quantifier (without allowing to negate the other)
drastically diminishes expressiveness.

Another way to look at this is from the perspective of the closure
properties of the three variants of automata, which are summarized in
\cref{tab:closure-decidability}. As already mentioned
\hyperlink{engelfriet-charact}{in-between} the two proofs of
\cref{sec:adga=mso}, Engelfriet has characterized the class of
MSO-definable graph languages as the smallest class that contains
certain elementary graph languages and is closed under boolean set
operations and under projection. To achieve closure under projection
with our distributed automata, we need nondeterminism so that the
nodes can guess which label they might have had without application of
the projection function. But if the additional expressive power
introduced by nondeterministic choices is not matched by the
corresponding dual, namely universal branchings, then there is an
asymmetry that makes us lose closure under complementation.

\begin{table}[h!]
  \alignpic
  \begin{tabular}{lccccc}
    \toprule
         & \multicolumn{4}{c}{Closure Properties} & Decidability \\
    \cmidrule(rl){2-5} \cmidrule(rl){6-6}
         & Complement & Union & Intersection & Projection & Emptiness \\
    \addlinespace
    ADGA & \hyperref[lem:complementation]{\cmark} & \hyperref[lem:union-intersect]{\cmark}
         & \hyperref[lem:union-intersect]{\cmark} & \hyperref[lem:projection]{\cmark} 
         & \hyperref[cor:adga-emptiness]{\xmark} \\
    \addlinespace
    NDGA & \hyperref[lem:ndga-complementation]{\xmark} & \hyperref[lem:ndga-closure]{\cmark}
         & \hyperref[lem:ndga-closure]{\cmark} & \hyperref[lem:ndga-closure]{\cmark}
         & \hyperref[lem:ndga-emptiness]{\cmark} \\
    \addlinespace
    DDGA & \hyperref[lem:ddga-closure]{\cmark} & \hyperref[lem:ddga-closure]{\cmark}
         & \hyperref[lem:ddga-closure]{\cmark} & \hyperref[lem:ddga-projection]{\xmark}
         & \hyperref[lem:ndga-emptiness]{\cmark} \\
    \bottomrule
  \end{tabular}
  \caption{Closure and decidability properties of alternating,
    nondeterministic, and deterministic distributed graph automata.}
  \label{tab:closure-decidability}
\end{table}

However, as also indicated in \cref{tab:closure-decidability}, if we
do not enable universal branchings, it has the positive effect that
emptiness remains decidable, which is not possible anymore once we
have reached the expressive power of MSO-logic on graphs. The reason
for this positive decidability result is that, for NDGAs, any run on a
sufficiently large input graph contains redundancies. This allows us
to narrow down the search space to a finite number of graphs.

\section{Open Questions}
In the present work, we have not gone much further than introducing
new definitions. Whether these definitions are sensible largely
depends on the insights that we might gain through them. In this
regard, it would be very interesting to obtain answers to the
following questions.

\begin{description}[style=nextline]
\item[Logics Equivalent to NDGAs and DDGAs.] Although we have been
  mostly concerned with ADGAs here, the fact that emptiness is
  decidable for NDGAs and DDGAs might make their corresponding classes
  of graph languages attractive, despite their less robust closure
  properties. As mentioned in \cref{sec:neg-impl-adga}, Trakhtenbrot’s
  Theorem states that, even when restricting formulas to first-order
  logic, satisfiability is undecidable on graphs. This tells us that
  alternation in our graph automata is required to even cover the
  expressiveness of first-order logic, but also arouses curiosity
  regarding the logical equivalent of the weaker variants. \emph{What
    would be logical formalisms on graphs that precisely define the
    NDGA- and DDGA-recognizable graph languages?}
\item[Alternative Definitions of ADGAs.] The definition of ADGAs given
  in this thesis (\cref{def:adga}) seems quite involved, and to
  loosely paraphrase a famous French aviator, as long as there remains
  something nonessential to remove, there is also room for
  improvement. On some classes of graphs, the necessary running time
  of ADGAs can be bounded by a fixed constant. For instance, if we
  only consider (graphs representing) words, simulating the classical
  finite automata shows us that every regular language is recognizable
  by some ADGA of length~2. (Nondeterministically guess a run of the
  word automaton in the first round, then check that it is legal and
  accepting in the second round.) But on general graphs, there is no
  such fixed constant, as can be easily inferred from the infinity of
  the MSO quantifier alternation hierarchy investigated by Matz and
  Thomas in \cite{MT97}. The question remains: \emph{can we impose
    simplifications or restrictions on the definition of ADGAs without
    sacrificing expressive power?}
\item[Impact on other Research.] Since ADGAs arose from an open-ended
  question, it seems only fitting to conclude this thesis with other
  questions of that type.
  \begin{itemize}
  \item On words and trees, the equivalence between finite automata
    and MSO-logic led to the decidability of the satisfiability and
    validity problems of MSO-logic. Unfortunately, this is not
    extendable to graphs. But maybe ADGAs can help us finding
    necessary conditions for MSO-definability, similar to what we got
    for NDGA-recognizability in the Mirroring Lemma
    (\cref{lem:weak-mirroring}). More generally, we might ask:
    \emph{what can ADGAs tell us about the class of MSO-definable
      graph languages?}
  \item Conversely, we could also use MSO-logic as a means to an
    end. As already mentioned, ADGAs can be considered, to some
    extent, as distributed algorithms. \emph{What can the connection
      to MSO-logic tell us about distributed algorithms?}
  \end{itemize}
\end{description} 
\begin{thebibliography}{9}
\bibitem[Büc60]{Buc60}
  J.R. Büchi (1960) \\
  \emph{Weak second-order arithmetic and finite automata.} Zeitschrift
  für Mathematische Logik und Grundlagen der Mathematik 6, pages
  66--92.
\bibitem[CE12]{CE12}
  B. Courcelle, J. Engelfriet (2012) \\
  \emph{Graph Structure and Monadic Second-Order Logic: A
    Language-Theoretic Approach.} Cambridge University Press.
\bibitem[CKS81]{CKS81}
  A.K. Chandra, D.C. Kozen, L.J. Stockmeyer (1981) \\
  \emph{Alternation.} Journal of the ACM, 28, pages 114--133.
\bibitem[Cou90]{Cou90}
  B. Courcelle (1990) \\
  \emph{The monadic second-order logic of graphs. I. Recognizable sets
    of finite graphs.} Information and computation 85, pages 12--75.
\bibitem[Cou97]{Cou97}
  B. Courcelle (1997) \\
  \emph{The Expression of Graph Properties and Graph Transformations
    in Monadic Second-Order Logic.} In Handbook of Graph Grammars,
  Volume 1: Foundations. G. Rozenberg ed., pages 313--400, World
  Scientific.
\bibitem[Cou08]{Cou08}
  B. Courcelle (2008) \\
  \emph{Graph structure and monadic second-order logic: Language
    theoretical aspects.} In Automata, Languages and Programming,
  pages 1--13, Springer.
\bibitem[Die10]{Die10}
  R. Diestel (2010) \\
  \emph{Graph Theory.} Fourth Edition, Springer.
\bibitem[Don70]{Don70}
  J. Doner (1970) \\
  \emph{Tree acceptors and some of their applications.} Journal of
  Computer and System Sciences 4, pages 406--451.
\bibitem[Elg61]{Elg61}
  C.C. Elgot (1961) \\
  \emph{Decision problems of finite automata design and related
    arithmetics}, Transactions of the American Mathematical Society
  98, pages 21--51.
\bibitem[Eng91]{Eng91}
  J. Engelfriet (1991) \\
  \emph{A Regular Characterization of Graph Languages Definable in
    Monadic Second-Order Logic.} Theoretical Computer Science 88,
  pages 139--150, Elsevier.
\bibitem[GH82]{GH82}
  Y. Gurevich, L. Harrington (1982) \\
  \emph{Trees, Automata and Games.} Proceedings of the fourteenth
  annual ACM symposium on Theory of computing, pages 60--65.
\bibitem[HGG97-99]{HGG97-99}
  G.~Rozenberg, H.~Ehrig, G.~Engels, H.J.~Kreowski, U.~Montanari, eds. (1997--1999) \\
  \emph{Handbook of Graph Grammars and Computing by Graph
    Transformation.} Volumes 1--3, World Scientific.
\bibitem[Kum06]{Kum06}
  K.N. Kumar (2006) \\
  \emph{Alternating Automata.} Notes on Automata, Logics, Games and
  Algebra, Lecture 6. \url{http://www.cmi.ac.in/~kumar/words}
\bibitem[Kur30]{Kur30}
  K. Kuratowski (1930) \\
  \emph{Sur le problème des courbes gauches en topologie.} Fundamenta
  Mathematicae 15, pages 271--283 (in French).
\bibitem[Lib04]{Lib04}
  L. Libkin (2004) \\
  \emph{Elements of Finite Model Theory.} Springer.
\bibitem[LT00]{LT00}
  C. Löding, W. Thomas (2000) \\
  \emph{Alternating Automata and Logics over Infinite Words.}
  Theoretical Computer Science: Exploring New Frontiers of Theoretical
  Informatics, pages 521--535, Springer.
\bibitem[Mil75]{Mil75}
  D.L. Milgram (1975) \\
  \emph{Web Automata.} Information and Control 29, pages 162--184.
\bibitem[MT97]{MT97}
  O. Matz, W. Thomas (1997) \\
  \emph{The Monadic Quantifier Alternation Hierarchy over Graphs is
    Infinite.} In Proceedings of 12th Annual IEEE Symposium on Logic
  in Computer Science (LICS’97), pages 236--244.
\bibitem[SMR73]{SMR73}
  A.N. Shah, D.L. Milgram, A. Rosenfeld (1973) \\
  \emph{Parallel Web Automata.} Technical Report 231, University of
  Maryland.
\bibitem[TATA08]{TATA08}
  H.~Comon, M.~Dauchet, R.~Gilleron,  C.~Löding, F.~Jacquemard, D.~Lugiez, S.~Tison, M.~Tommasi (2008) \\
  \emph{Tree Automata Techniques and Applications.} \\
  \url{http://tata.gforge.inria.fr} or \\
  \url{http://www.grappa.univ-lille3.fr/tata}
\bibitem[Tho91]{Tho91}
  W. Thomas (1991) \\
  \emph{On Logics, Tilings, and Automata.} In J.L.~Albert, B.~Monien,
  M.~Rodríguez-Artalejo, eds., ICALP, volume 510 of Lecture Notes in
  Computer Science, pages 441--454, Springer.
\bibitem[Tho96]{Tho96}
  W. Thomas (1996) \\
  \emph{Languages, Automata, and Logic.} Bericht 9607, Institut für
  Informatik und Praktische Mathematik der
  Christian-Albrechts-Universität zu Kiel. \\
  Also published in Handbook of Formal Languages, Volume 3: Beyond
  Words, G. Rozenberg and A. Salomaa, eds., pages 389--455, Springer
  1997.
\bibitem[Tho97]{Tho97}
  W. Thomas (1997) \\
  \emph{Automata Theory on Trees and Partial Orders.} TAPSOFT'97:
  Theory and Practice of Software Development, Lecture Notes in
  Computer Science Volume 1214, pages 20--38, Springer.
\bibitem[Tra50]{Tra50}
  B.A. Trakhtenbrot (1950) \\
  \emph{The Impossibility of an Algorithm for the Decidability Problem
    on Finite Classes.} Doklady Akademii Nauk SSSR 70, pages 569--572
  (in Russian).
\bibitem[Tra61]{Tra61}
  B.A. Trakhtenbrot (1961) \\
  \emph{Finite automata and the logic of monadic predicates.} Doklady
  Akademii Nauk SSSR 140, pages 326--329 (in Russian).
\bibitem[TW68]{TW68}
  J.W. Thatcher, J.B. Wright (1968) \\
  \emph{Generalized finite automata theory with an application to a
    decision problem of second-order logic.} Mathematical Systems
  Theory 2, pages 57--82.
\bibitem[Wag37]{Wag37}
  K. Wagner (1937) \\
  \emph{Über eine Eigenschaft der ebenen Komplexe.} Mathematische
  Annalen 114, pages 570--590 (in German).
\bibitem[WR79]{WR79}
  A. Wu, A. Rosenfeld (1979) \\
  \emph{Cellular Graph Automata. I. Basic Concepts, Graph Property
    Measurement, Closure Properties.} Information and Control 42,
  pages 305--329.
\end{thebibliography}





\end{document}
