\documentclass[11pt,english]{article}
\usepackage{amsmath,latexsym,amssymb,amsthm,color}
\usepackage{fullpage}
\usepackage{ifthen,graphics,epsfig}
\bibliographystyle{plain}
\usepackage{times}
\usepackage{graphicx,url}
\usepackage{babel}
\usepackage{graphicx} 
\usepackage{float}
\usepackage{epstopdf}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{graphicx}         \newtheorem{defn}{Definition}[section]                           
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{babel}
\usepackage{epstopdf}
\usepackage[mathscr]{euscript}
\usepackage{amsmath,amsfonts,mathrsfs}
\usepackage{amsmath,amssymb}
\usepackage{calligra}
\usepackage{calrsfs}
\usepackage{here}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{diagbox}
\usepackage{makecell}
\usepackage{xspace}
\newcommand{\REG}{\mathit{REG}}
\newcommand{\Xomit}[1]{}

\newcommand{\neighbors}{\mathit{neighbors}}
\newcommand{\palette}{\mathit{palette}}
\newcommand{\dtwocol}{\mathit{d2colors}}
\newcommand{\donecol}{\mathit{d1colors}}
\newcommand{\CLOCK}{\mathit{CLOCK}}

\newcommand{\df}[1]{}\newcommand{\ccolor}{{\sc color}\xspace}
\newcommand{\term}{{\sc term}\xspace}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{property}{Property}
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}
\newenvironment{proofL}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}
\newenvironment{proofC}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}
\newenvironment{proofP}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}


\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 9\else 0\fi \arabic{linecounter}}

\newfloat{algorithm}{th}{lop}
\floatname{algorithm}{Algorithm}





\title{\bf  Optimal Collision/Conflict-free Distance-2 Coloring \\
            in  Synchronous  Broadcast/Receive  Tree Networks}


\author{Davide Frey~~  
        Hicham Lakhlef~~ 
        Michel Raynal
~\\~\\
  INRIA Bretagne Atlantique, Rennes,  France \\
  IRISA, Universit\'e de Rennes,  France \\
  Institut Universitaire de France\\
{\small{\tt hicham.lakhlef@irisa.fr ~ raynal@irisa.fr}}
~\\~\\~\\
\centerline{Tech Report \# 2030 (19 pages), December 2015}\\
~\\
\centerline{IRISA, University of Rennes 1 (France)}
}
\date{}

\newpage 


\begin{document}

\maketitle

\begin{abstract}
  This article is on message-passing systems where communication is
  (a) synchronous and (b) based on the ``broadcast/receive'' pair of
  communication operations.  ``Synchronous'' means that time is
  discrete and appears as a sequence of time slots (or rounds) such
  that each message is received in the very same round in which it is
  sent.  ``Broadcast/receive'' means that during a round a process can
  either broadcast a message to its neighbors or receive a message
  from one of them.  In such a communication model, no two neighbors
  of the same process, nor a process and any of its neighbors, must be
  allowed to broadcast during the same time slot (thereby preventing
  message collisions in the first case, and message conflicts in the
  second case).  From a graph theory point of view, the allocation of
  slots to processes is know as the distance-2 coloring problem: a
  color must be associated with each process (defining the time slots
  in which it will be allowed to broadcast) in such a way that any two
  processes at distance at most  obtain different colors, while the
  total number of colors is ``as small as possible''.


  The paper presents a parallel message-passing distance-2 coloring
  algorithm suited to trees, whose roots are dynamically defined. This
  algorithm, which is itself collision-free and conflict-free, uses
   colors where  is the maximal degree of the graph
  (hence the algorithm is color-optimal).  It does not require all
  processes to have different initial identities, and its time
  complexity is , where  is the depth of the tree.  As
  far as we know, this is the first distributed distance-2 coloring
  algorithm designed for the broadcast/receive round-based
  communication model, which owns all the previous properties.

~\\~\\{\bf Keywords}: 
Broadcast/receive communication, Collision, Conflict, 
Distance-2 graph coloring, Message-passing, 
Network traversal, Synchronous system, Time slot assignment,
Tree network, Wireless network. 
\end{abstract}



\thispagestyle{empty}
\newpage
\setcounter{page}{1}


\section{Introduction}
Graph coloring is an important problem related to (optimal) resource
allocation, mainly used to establish an optimal order in which
resources have to be allocated to processes~\cite{DKR82,L81}.  The
distance- coloring problem consists in assigning colors to the
vertices of the graph such that no two vertices at distance at most
 have the same color. Let us remember that minimum distance-
vertex coloring is an NP-complete problem~\cite{GJ79}.



Coloring is (with leader election~\cite{A81} and
renaming~\cite{ABDPR90,CRR11}) one of the most important {\it symmetry
  breaking} problems encountered in distributed
computing~\cite{IRR10}. Solving such problems requires\df{I removed
  ``a seed''. It struck me as odd. But add it back if it's commonly
  used with this meaning.}  a pre-existing initial asymmetry from which
the problem can be solved. In a lot of cases, this initial asymmetry
is given by the assumption that no two processes have the same
identity.\footnote{Let us notice that one of the oldest
  symmetry-breaking problems is mutual exclusion, where the problem
  has not to be solved once for all, but repeatedly in a fair
  way~\cite{R86}.  See also the monograph~\cite{AE14} for
  impossibility results in distributed computing due to
  symmetry/indisguishability arguments.}




\paragraph{Distributed distance-1 coloring in the classical point-to-point
synchronous message-passing model}
Let us consider a distributed computing setting, where the processes
constitute the vertices of a graph, and the communication channels its
edges. The distributed distance-1 vertex coloring problem consists in
associating a color with each process such that (a) no two neighbors
have the same color, and (b) the total number of colors is as small as
possible. This process-coloring problem has essentially been
investigated in reliable synchronous networks where any two
neighboring processes are connected by a bi-directional channel on
which each of them can send and receive messages
(e.g.~\cite{P00,R10,R13,S07}).  The main results are described in the
monograph~\cite{BE14}.  

In these reliable point-to-point synchronous systems, processes
proceed in synchronized steps, usually called rounds. Each round
consists of three phases: during the first phase, each process sends
messages to its neighbors; during the second phase, each process
receives messages; and during the last phase, each process executes
local computation.  The fundamental synchrony property is that a
message is received in the very same round in which it is sent. Hence,
when solving a problem in this synchronous computation model, a
crucial attribute of a problem is the minimal number or rounds needed
to solve it.  As far as the distance-1 coloring problem is concerned,
it has been shown that, if the communication graph can be logically
oriented such that each process has only one predecessor (e.g., a tree
or a ring),  rounds are necessary and sufficient to color
the processes with three colors~\cite{CV86,L92} ( being the total
number of processes\footnote{ is the number of times the
  function  needs to be iteratively applied in  to obtain a value .  As an example, if 
  is the number of atoms in the universe, .}).
Other d1-coloring algorithms are described in several articles
(e.g.~\cite{BE11,BEK14,GPS88,KW06}).  They differ in the number of
rounds they need and in the number of colors they use to implement
d1-coloring. Both the algorithms in~\cite{BE11,BEK14} color the
vertices with  colors; the first one requires
 rounds, while the second one uses  rounds.  An algorithm described in~\cite{GPS88} is for tree
graphs or graphs where each vertex has two neighbors; it uses three
colors and  rounds. Another algorithm presented in the
same paper addresses constant-degree graphs; it uses 
colors and  rounds. The algorithm presented
in~\cite{KW06} requires  rounds.
These algorithms assume that the processes (vertices) have distinct
identities, which are their initial colors. They proceed iteratively,
each round reducing the total number of colors.

\paragraph{Distance-2 and distance-3 coloring in shared memory and
  message-passing  models}
A first class of algorithms addresses the distance-2 vertex coloring
problems in systems where communication is through shared memory,
message-passing, or a mix of the
two~\cite{BCGMBO05,BGMBC08,GMP02}. These algorithms find their
motivation in the application of distance-2 coloring to scientific
computing. As a result, they do not fit well the characteristics of
wireless networks.

On the other hand, wireless protocols apply or require distance-2 and
distance-3 coloring algorithms to prevent packet
collisions~\cite{chipara11:conflict}. To this end, they build a TDMA
(Time Division Multiple Access) schedule~\cite{R97} from the result of
the coloring process.  TDMA allows processes to share the same
frequency channel by dividing the signal into different time slots,
one per color. Hence, protocols based on distance-2 coloring guarantee
that nodes can transmit messages undisturbed during their time
slots. Those based on distance-3 coloring additionally allow receiving
nodes to acknowledge unicast messages in the sender's slot.



With this motivation, some authors have proposed self-stabilizing
algorithms to solve the distance-2
problem~\cite{BM09,gairing-distanceTwo} For example,~\cite{BM09}
presents a self-stabilizing distance-2 algorithm that uses a constant
number of variables on each node and that stabilizes in  moves and uses at most  colors, where  is the number
of edges. But these algorithms do not take the broadcast nature of the
wireless medium into account, and their operation may thus results in
significant packet collisions. 

Differently, CADCA~\cite{jemili13:collision} is a distributed distance-2
coloring algorithm that takes into account the risk of collisions
during the coloring process. To limit this risk, CADCA organizes the
nodes to be colored in concentric layers around a sink node. The
coloring process proceeds in three phases: the first colors layers 1,
4, 7, ...; the second colors layers 2, 5, 8, ...., and the third
colors layers 3, 6, 9. Each such phase uses a specific color palette
to avoid conflicts between nodes in different layers and exploits five
stages in which the nodes in a layer select colors and resolve the
conflicts that arise during the process. However, the algorithm
requires nodes to know their position with respect to the sink node,
and most importantly it does not entirely eliminate packet collisions,
it only reduces their number. 


With respect to the distance-3 version of a problem,~\cite{HT04}
proposes a self-stabilizing algorithm. Processes compute a maximal
independent set and then use it to assign themselves colors. The
self-stabilizing part of the algorithm gathers information about each
process's 3-hop neighborhood, and does generate collisions. However,
the protocol uses a special TDMA slot to continuously run the
self-stabilizing protocol without interfering with colored slots.
Serena~\cite{serena} uses a similar approach and also presents a
distance-3 coloring algorithm in a broadcast-receive model. However,
it does not  use a special time-slot to limit the impact of the
collisions occurring during the coloring process.  The protocols we
present in this paper, on the other hand, do not lead to any conflict
or collision and do not need any special time slots.









\paragraph{Content of the paper}
Differently from the previous articles, we propose a collision- and
conflict-free algorithm that solves the distance-2 (d2) coloring problem in
synchronous networks where (a) processes communicate by broadcasting
and receiving messages, and (b) collisions and conflicts are not
prevented by the communication model.  A collision occurs when a
process receives messages from two or more neighbors in the same
round. A conflict occurs when, during the same round, two neighbors
send a message to each other.

In this broadcast/receive communication model (which covers practical
system deployments), there is not a dedicated communication medium for
each pair of processes, but a single shared communication medium for
each pair composed of a process and all its neighbors.  Examples of
such communication media are encountered in wireless networks such as
sensor networks. In such networks, collision-freedom and
conflict-freedom do not come for free, and the algorithms built on top
of them must be collision/conflict-free to ensure the consistency of
the messages that are exchanged, and consequently the progress of
upper-layer applications.

This paper is on collision/conflict-free d2-coloring for the
synchronous broadcast/receive communication model, where the processes
are connected by a tree network.  Considering such a context, it
presents an algorithm which uses  colors, and is
consequently optimal with respect to the number of colors. This
algorithm relies on two assumptions to break symmetry: (a) it assumes
that a process (not predetermined in advance) receives an external
message that defines it as the root of the tree; (b) it assumes that
any two processes at distance less than or equal to  have distinct identities\footnote{Let us notice
  that this assumption states nothing more than the fact that a
  process is able to distinguish its neighbors based on their
  identities.} (hence, depending on the structure of the tree, lots of
processes can have the same identity). Its round complexity is
 where  is the depth of the tree. Moreover, no process
needs to know , , or the depth of the tree. Hence a process
has no information on the global structure of the tree.  Its initial
knowledge is purely local: it is restricted to its identity, and the
identities of its neighbors.





\paragraph{Roadmap}
The paper consists of~\ref{sec:conclusion} sections.
Section~\ref{sec:model} presents the synchronous broadcast/receive
model, and Section~\ref{sec:D2-coloring} introduces the distance-2
coloring problem.  Then, two distributed (message-passing) distance-2
coloring algorithms suited to trees are presented.  The presentation
is incremental.  Section~\ref{sec:sequential-d2-tree-algorithm}
presents first a simple distributed distance-2 coloring algorithm
which exploits a sequential tree traversal algorithm as a skeleton, on
which are appropriately grafted statements implementing distance-2 the
coloring.  Then, Section~\ref{sec:parallel-d2-tree-algorithm} presents
a distributed distance-2 coloring algorithm based on a parallel
traversal of the tree.  This second algorithm extends the basic
coloring principles introduced in the first algorithm.



\section{Synchronous Broadcast/Receive Model}
\label{sec:model}



\paragraph{Processes, initial knowledge, and the communication graph}
The system model consists of  sequential processes denoted 
, ..., , connected by a tree communication network. 

Each process  has an identity , which is known only by
itself and its neighbors (processes at distance  from it).  The
constant  is a local set, known only by , including
the identities of its neighbors (and only them).  As noticed in the
Introduction, in order for a process  not to confuse its
neighbors, it is assumed that no two processes at distance less
than or equal to  have distinct identities.  Hence, any two
processes at distance greater than  may have the same
identity. When computing bit complexities, we will assume that any
process identity is encoded in  bits.

Let  denote the degree of a process 
(i.e. ) and let  denote the maximal degree of
the process graph ().  While each
process  knows , no process knows  (a process
 such that  does not know that  is
).


When considering a process , , the integer  
is called its index. Indexes are not known by the processes. 
They are only a notation convenience used as a subscript 
to distinguish processes and their local variables. 


\paragraph{Timing model}
We assume that processing durations are equal to . This is
justified by the following observations: (a) the duration of the local
computations of a process is negligible with respect to message
transfer delays, and (b) the processing duration of a message may be
considered as a part of its transfer delay.

Communication is synchronous in the sense that there is an upper bound
 on message transfer delays, and this bound is known by all the
processes (global knowledge). From an algorithm design point of view,
we consider that there is a global clock, denoted , which is
increased by , after each period of  physical time units. 
Each value of  defines what is usually called a {\it time slot}
or a {\it round}.



\paragraph{Communication operations}
The processes are provided with two operations denoted  and .  A process  invokes  {\sc tag} to send the message , whose type is
{\sc tag}, to all its neighbors.  It is assumed that a process invokes
 only at a beginning of a time slot.  When a
message {\sc tag} arrives at a process , this process is
immediately warned of it, which triggers the execution of operation
 to obtain the message. Hence, a message is always
received and processed during the time slot --round-- in which it was
broadcast.

From a linguistic point of of view, we use the two following
{\bf when} notations when writing algorithms, where  
is a predicate involving  and possibly local variables of the
concerned process.  
\begin{tabbing} 

{\bf  when} {\sc  tag} {\bf  is received do} processing of the message. \\

{\bf  when}  
                         {\bf do} code entailing at most one 
invocation. 
\end{tabbing}


\paragraph{Message collision and message conflict}
Traditional wired round-based synchronous systems assume a dedicated a
communication medium for each pair of processes (i.e., this medium is
not accessible to the other processes).  Hence, in these systems a
process  obeys the following sequential pattern during each
round: (a) first  sends a message to all or a subset of its
neighbors, (b) then  receives the messages sent to it by its
neighbors during the current round, and (c) finally executes a local
computation which depends on its local state at the beginning of the
round and the messages it has received during the current round.

The situation is different in systems such as wireless networks (e.g.,
sensor networks), which lack a dedicated communication medium per pair
of processes.  A process  shares a single communication medium
with all its neighbors, and ``message clash'' problems can occur,
each message corrupting the other ones, and being corrupted by
them. Consider a process , these problems are the following.
\begin{itemize}
\vspace{-0.1cm}
\item 
If two  neighbors of  invoke the operation   
during the same time slot (round), a message {\it collision} occurs.  
\vspace{-0.2cm}
\item 
If  and one  of its neighbors 
invoke   during the same time slot 
(round), a message {\it conflict} occurs.  
\end{itemize}
As already indicated, this paper considers this broadcast/receive
communication model. This implies that protocols must prevent
collisions and conflicts to ensure both message consistency and
computation progress.




\section{The Distance-2 Tree Coloring Problem}
\label{sec:D2-coloring}

\paragraph{Solving the collision/conflict problem}
To prevent collisions and conflicts involving a process , only a
single process in the set  can obtain the
right to communicate during a given round. To this end, we associate
each process with time slots (rounds) in which it can broadcast a
message, while none of its 2-hop neighbors can broadcast during these
time slots. When considering the whole set of processes, this
assignment must be optimal in terms of numbers of colors (ideally
allowing as many processes as possible to broadcast during the same
round).


This problem is a well-known graph coloring problem called 
{\it distance-2} coloring. The aim is to design distributed algorithms
associating a color with each process (which will define the 
time-slots during which it  will be allowed to broadcast) such 
that the following properties are satisfied. 


\paragraph{Definition}
\begin{itemize}
\vspace{-0.2cm}
\item Validity: 
The final color of each process belongs to . 
\vspace{-0.2cm}
\item Consistency: 
No two processes at distance  have the same color.  
\vspace{-0.2cm}
\item Termination: Each process obtains a color and one process knows that 
this occurred. 
\end{itemize}
Let us observe that, as at least one process has  neighbors, 
 different  colors are necessary.  The Validity property
states that we are looking for {\it distributed} algorithms which ensure
that  is also a tight upper bound. As we will see such algorithms 
exist for tree networks.  

\paragraph{Using the colors to define the time slots}
The colors obtained by the processes are used as follows, where
 is the color obtained by process .  The time slots
(rounds) during which  is allowed to broadcast a message to its
neighbors correspond to the values of  such that .  As we will see, these time
slots are different from the time slots used during the (sequential
and parallel) distributed distance-2 algorithms which are presented
below. It follows that these algorithms must provide each process with
the (initially unknown) value of .



\section{Sequential Distance-2  Coloring of a Tree}
\label{sec:sequential-d2-tree-algorithm}
This section presents a distributed distance-2 coloring algorithm in
which there are neither message collisions, nor message conflicts.
This algorithm is sequential in the sense that its skeleton is a
depth-first tree traversal in which the control flow (implemented by
appropriate messages) moves sequentially from a process to another one. 



\subsection{A  sequential algorithm}
Algorithm~\ref{fig:DFTree-traversal-algorithm} assumes that a single
process receives a message, {\sc start}, which defines it as the
root of the tree. (As noticed in the Introduction, this introduces the
initial asymmetry\df{removed 'seed' from here too} needed to solve the
symmetry-breaking problem we are interested in.)  This external
message causes the receiving process, , to simulate the reception
of a fictitious message, {\sc color}.  This
message initiates a depth-first traversal of the tree.


\paragraph{Messages}
The algorithm uses two types of messages: {\sc color} and {\sc
  term}.  As each message is broadcast by its sender and received
by all its neighbors, it carries the identity of its destination
process.  Hence, when a process receives a message , it discards
 if it is not the destination of  (predicate  at
line~\ref{Seq-04} and line~\ref{Seq-19}).

These messages implement a depth-first traversal of the tree
network~\cite{R13}. Each carries the identity of its destination
, the identity of its sender , and the color of its
sender . A message {\sc color} additionally carries
the colors of the already colored neighbors of the sender
.


\paragraph{Local variables}
Each process  manages the following local variables. 
\begin{itemize}
\vspace{-0.1cm}
\item  (initialized to ) is used by  to manage the
  progress of the tree traversal.  Each process traverses five
  different states during the execution of the algorithm. States 
  and  are active: a process in state  sends a \ccolor message to
  a child, while a process in state  sends a \term  message to its
  parent.  States  and  are waiting states. Nodes listen on
  the broadcast channel but cannot send any message. Finally, state
   identifies local termination. 
\vspace{-0.2cm}
\item  saves the identity of the process  from which
   received the message {\sc color};  receives
  exactly one such  message.  This process, , defines the parent
  of  in the tree.  The root  of the tree, defined by the
  reception of the external message {\sc start}, is the only
  process such that .
\vspace{-0.2cm}
\item  records the color of the parent of .  
  receives this information in the parent's \ccolor message.\df{This
    was collapsed into the previous one. I found it nicer to split
    them since they are two different variables albeit related.}
\vspace{-0.2cm}
\item  is a set containing the colors of the neighbors of ,
that have  already obtained their color. 
\vspace{-0.2cm}
\item  (initialized to ) is a set
  containing the identities of the neighbors of  not yet
  colored. 
\vspace{-0.2cm}
\item   contains the color of . \df{Same as above. This
    was collapsed into the previous but I preferred to split them.}
\end{itemize}


\begin{algorithm}
\centering{
\fbox{
\begin{minipage}[h]{150mm}
\footnotesize
\renewcommand{\baselinestretch}{2.5}
\resetline
\begin{tabbing}
aaaaA\=aA\=aaA\=aaA\=aaA\=aaA\kill

{\bf  Initialization:}
    ; .\\~\\


\line{Seq-01}  \> 
{\bf  when} {\sc  start} {\bf  is received do} 
\%  a single process   receives this external message  \% \\

\line{Seq-02}  
\> \>  executes the lines~\ref{Seq-04}-\ref{Seq-09} as if it received 
      the message    {\sc color}.\\~\\



\line{Seq-03}  
{\bf when} {\sc color} 
     {\bf  is received  do} \\


\line{Seq-04}  \>\> 
{\bf if}      ( 
     {\bf then} discard the message
           (do not execute lines~\ref{Seq-05}-\ref{Seq-09}) {\bf end if};\\

\line{Seq-05}  \>\>  
;
;
;\\

\line{Seq-06}  \>\>  
 sequence  
without the colors in  ;\\

\line{Seq-07}  \>\> 
 first color in ;\\

\line{Seq-08}  \>\>  
;\\

\line{Seq-09}  \>\> 
{\bf if}  
{\bf then}  {\bf else}  
{\bf end if}.\\~\\


\line{Seq-10}  \> {\bf when} 
( increases  {\bf do}\\

\line{Seq-11}  \>\> {\bf if} \=  \\

\line{Seq-12}  \>\>\> {\bf then} \=   
   any ;\\

\line{Seq-13}  \>\>\>\>
    {\sc color};
    \\


\line{Seq-14}  \>\>\> {\bf else} \>
{\bf if} \=   \= {\bf then} \=
the root  claims termination \\

\line{Seq-15}  \>\>\>\>\>\>{\bf else} \>
  {\sc term}\\

\line{Seq-16}  \>\>\>\> {\bf end if};  \\


\line{Seq-17} \>\>  {\bf end if}. \\~\\



\line{Seq-18} \>
{\bf when} {\sc term} {\bf is received} {\bf do} \\
 \> \% the tree rooted at process  is properly colored \% \\

\line{Seq-19} \>\>
{\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{Seq-20}-\ref{Seq-21}) {\bf end if};\\

\line{Seq-20} \>\> 
;
;\\

\line{Seq-21}  \>\> 
{\bf if}  
 {\bf then}  
 {\bf else}  
{\bf end if}.

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Distributed depth-first-based distance-2 coloring of a tree  
(code for )}
\label{fig:DFTree-traversal-algorithm}
}
\end{algorithm}


\paragraph{Description of the algorithm}
Nodes start the algorithm in state , waiting for a {\sc
  color} message.  A process, , receives such a
message exactly once.  When it receives it, it is visited for the
first time by the depth-first tree traversal.  It consequently assigns
the values of the message parameters to its local variables
,  and  (line~\ref{Seq-05}).
Then, it computes its color, which is different from the color of the
sender of the message and from the colors of the sender's already
colored neighbors (lines~\ref{Seq-06}-\ref{Seq-07}). Finally, 
updates , and transitions to a new state:  if it has
any children, or  if it is a leaf node. This prepares the progress
of the tree traversal, which will take place at the next time slot
(round) (lines~\ref{Seq-08}-\ref{Seq-09}).




















When  enters the new time slot with 
(line~\ref{Seq-10}), it operates as follows to ensure the progress
of the tree traversal.
\begin{itemize}
\vspace{-0.1cm}
\item If , it means that  has neighbors that have not
  yet been colored. In this case,  selects one of them, and makes
  the tree traversal progress by broadcasting a message, {\sc
    color}, which will be processed
  only by  (line~\ref{Seq-13}).  Then,  moves into
   and waits until it receive a \term message, {\sc
    term}.

\vspace{-0.1cm}
\item If , it means that all the neighbors of  have
  been colored. In this case, if  is the root, the distance-2
  coloring has terminated (line~\ref{Seq-14}). Otherwise, if  is
  not the root, it broadcasts the message {\sc
    term} to inform its parent that the
  sub-tree of which it is the root has been colored
  (line~\ref{Seq-15}).  In both cases,  transitions to
  , thereby indicating that the algorithm is terminated as
  far as  is concerned (local termination).
\end{itemize}


Finally, when  receives the message {\sc
  term}, it first updates its local variables
 and  according to the received values
(line~\ref{Seq-20}). Then, it updates  according to the value
of  (indicating whether it has colored all its neighbors,
line~\ref{Seq-21}). In the first case, it moves to state  and
continues traversing another sub-tree. Otherwise it moves to state
, which will then evolve into state  (signaling local
termination) as indicated above.


\paragraph{How a process learns the value of }
A process maintains a local variable  initialized to
, and each message {\sc term} now carries this value.
When a process  receives a message {\sc term}
it executes the update statement .  
Finally, when the root process  claims termination, it launches a second 
traversal of the tree to inform the other processes.  We do not describe such 
a propagation of the value of  here. This will be done in
Section~\ref{sec:inform-others}  in the context of a parallel tree traversal.



\subsection{Proof and cost of the algorithm}


\begin{lemma}
\label{collision-conflict-freedom}
Algorithm~{\em\ref{fig:DFTree-traversal-algorithm}} is 
both collision-free and conflict-free. 
\end{lemma}


\begin{proofL}
Let us first observe that, due to the assignment of the variable 
 at line~\ref{Seq-09} (in the processing of a message 
{\sc color}),  or line~\ref{Seq-21}  (in the processing of a message 
{\sc term}), a process  is allowed to  broadcast one and only 
one message  when it executes line~\ref{Seq-13} or~\ref{Seq-15}.
It follows from the associated assignment of the control value  or  to 
 (line~\ref{Seq-13} or~\ref{Seq-15}), that   cannot broadcast 
other messages {\sc color} or {\sc term}  before executing
line~\ref{Seq-21} (i.e., before it receives a message {\sc term}).

Let us now observe that, due to line~\ref{Seq-04}, a message 
{\sc color} broadcast by a process at line~\ref{Seq-13}
is processed by a single destination  process. 
Hence, the control flow generated by these messages remains sequential, moving 
sequentially from a parent process to a child process. 
Similarly, the  control flow generated by the messages {\sc term} 
(broadcast at line~\ref{Seq-15}) moves sequentially from a child  process 
to its  parent process (whose identity is saved in ). 


The collision-freedom and conflict-freedom properties of the algorithm follow
directly from the sequentiality of the control flow realized by the messages
{\sc color} and {\sc term}.
\renewcommand{\toto}{collision-conflict-freedom}
\end{proofL}

\begin{lemma}
\label{lemma-three-properties}
Algorithm~{\em\ref{fig:DFTree-traversal-algorithm}} satisfies the 
Validity, Consistency, and Termination properties. 
\end{lemma}


\begin{proofL}
  Let us first prove the following claim. \\
  Claim. For any  and  at any time, . \\
  Proof of the claim.  Let us consider the local variable 
  of a process .  This variable is initialized at
  line~\ref{Seq-05}, when  receives a message {\sc color} for
  the first time. It then contains the color of its parent in the
  tree. When the algorithm progresses, the color of a child  of
   is added to  (line~\ref{Seq-20}) when 
  receives from  a message {\sc term} carrying 's color.
  It follows that, when  issues its last broadcast of {\sc
    color},  is the identity of its
  only child without a color, and  contains the colors of
  all the other neighbors of . hence, . End
  of the proof of the claim.


The Validity property follows from the following observation.
When a process  selects its color, it follows from the previous claim
and   lines~\ref{Seq-06}-\ref{Seq-07} that
. Consequently, 
there is at least one free color in the set . 

To prove the Proper-Coloring property let us first observe that, due
to (a) the initialization of  done when a process 
receives a message {\sc color} from its parent
(line~\ref{Seq-05}), and (b) the updates that follow when it receives
messages {\sc term} from its children (line~\ref{Seq-20}), it
follows that  contains the colors of the already colored
neighbors of .  Hence, when a process  selects a color
(lines~\ref{Seq-06}-\ref{Seq-07}), the colors of the already colored
processes at distance 2 from it are in the set  carried by
the message {\sc color} entailing 's coloring.  Due to
line~\ref{Seq-06},  does not select any of these colors.

The Termination property follows from the termination of the sequential 
traversal, at the end of which the root learns the algorithm has terminated. 
\renewcommand{\toto}{lemma-three-properties}
\end{proofL}

\noindent
The following theorem is an immediate consequence of the previous lemmas. 
\begin{theorem}
\label{theo:seq-traversal-coloring}
Algorithm~{\em\ref{fig:DFTree-traversal-algorithm}} 
is a collision-free and conflict-free distance-2 coloring algorithm for trees. 
\end{theorem}




\paragraph{Cost of the algorithm}
(Let us recall that a process identity can be encoded with  bits.)
There are two message types. A message {\sc term} carries two 
process identities and a color. 
A message {\sc color} carries two process identities, 
a color, and set of at most  colors. 
It follows that a message carries at most  bits. 



A tree of maximal degree  has at least  leaves.  
Let us first count the number of broadcasts of a message  {\sc color}. 
The root issues at most   broadcasts; 
a process, which is neither the root nor a leaf, issues
at most   broadcasts; and a leaf  issues no broadcast
of such a message. It follows that there are 
  broadcasts of a message  
{\sc color}. As , the number of broadcasts of 
a message {\sc color}  is upper bounded by .  
 
Each process which is not the root of the tree  issues exactly one 
broadcast  of a message {\sc term}. It follows that there are 
broadcasts  of such a message. 


\section{Parallel Distance-2  Coloring of a Tree}
\label{sec:parallel-d2-tree-algorithm}


This section presents a distributed distance-2 coloring for trees,
which based on a parallel traversal of the tree network, with feedback
(i.e., the dynamically defined root process that launches the network
traversal learns of the end of the traversal).  This algorithm can be
seen as improvement of the previous algorithm in terms of time
efficiency.



\subsection{A parallel algorithm}
\paragraph{Underlying principle}
Let us first observe that any two children of a process must be prevented 
from  broadcasting simultaneously a message to their neighbors. 
This is because, being issued by processes at  distance at most two, 
such simultaneous broadcasts will create a collision at least at the
parent process. 


The idea to prevent this vicinity/concurrency problem is first to
direct a parent process to compute the colors of its children, and
then, as soon as a process has obtained a color, to allow it to broadcast 
a message ({\sc color} or {\sc term}) only during the time slots
(rounds) associated with its color.  To this end, each process uses
the values provided by the global clock ().


\paragraph{Messages and local variables}
The message types implementing the parallel tree traversal are the
same as in Algorithm~\ref{fig:DFTree-traversal-algorithm}.  Similarly,
the local variables , , ,
, and the constant , have the same meaning
as in Algorithm~\ref{fig:DFTree-traversal-algorithm}.

Each process  manages an additional variable ,
initially , which will contain the number of colors needed to color
its parent  and its neighbors (processes of ). This
value is known to  when it receives its first message {\sc
  color} (which defines its sender  as 's parent). Each
process has also a constant  which represents the
number of colors needed to color itself and its neighbors.


\begin{algorithm}[ht]
\centering{
\fbox{
\begin{minipage}[t]{150mm}
\footnotesize
\renewcommand{\baselinestretch}{2.5}
\resetline
\begin{tabbing}
aaaA\=aaaA\=aaA\=aaA\=aaA\=aaA\kill

{\bf  Initialization:} ; 
    ; .\\~\\

\line{P-01}  \> 
{\bf  w}\={\bf hen} {\sc  start} {\bf  is received do} 
      \%  a single process  receives this external message  \% \\

\line{P-02}  \> \> 
 executes lines~\ref{P-04}-\ref{P-08} as if it received the message 
   {\sc color} \\
\>\>  where .\\~\\


\line{P-03}  \> 
{\bf  when} {\sc  color} 
{\bf  is received} {\bf do} \\

\line{P-04}  \>\> 
{\bf if}  ({\sc color} already received) 
     {\bf then} discard the message,
           do not execute lines~\ref{P-05}-\ref{P-08}) {\bf end if};\\    
      
\line{P-05}  \>\> 
       ;
       ;
       ;\\


\line{P-06}  \>\> 
 such that  
       ;\\
       


\line{P-07}  \>\> ;   \\    

\line{P-08}  \>\> {\bf if} 
  
   {\bf then}   {\bf else}   
   {\bf end if}.\\~\\


\line{P-09}  \> {\bf when} 
 {\bf do}\\

\line{P-10}  \>\>
 {\bf if} \=  \\

\line{P-11}  \>\>\> {\bf then} \= 
 empty set of pairs;\\

\line{P-12}  \>\>\>\>
 sequence  
without the colors   and ;\\

\line{P-13}  \>\>\>\>
{\bf for} \={\bf each} \=  {\bf do}  \\

\line{P-14}  \>\>\>\>\>\>
 first color in ; \\

\line{P-15}  \>\>\>\>\>\>
suppress  from 
and add  to  \\

\line{P-16}  \>\>\>\> {\bf end for};\\

\line{P-17}  \>\>\>\>
  
{\sc color}; 
      \\

\line{P-18} \>\>\> {\bf else} \> 

  {\sc term};     \%  and its neighbors are colored \% \\

\line{P-19} \>\>  {\bf end if}. \\~\\

\line{P-20}  \>
{\bf when}  {\sc term} {\bf is received} {\bf do} \\

\line{P-21} \>\> {\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{P-22}-\ref{P-25}) {\bf end if};\\

\line{P-22} \>\> ;  \\

  
\line{P-23}   \>\> {\bf if} \= ()  \\

\line{P-24}  \>\>\> {\bf then if}  () 
 {\bf then}  the root  claims termination 
 {\bf else}     {\bf end if} \\

\line{P-25}  \>\> {\bf end if}.

 
\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Parallel distributed distance-2 coloring of a tree  (code for )}
\label{fig:tree-parallel-coloring-algorithm}
}
\end{algorithm}


\paragraph{Description of the algorithm}

To simplify the presentation, we assume that the initial value of
 is .  As in the sequential version, a single process 
receives the external message {\sc start}, that defines it as the
root of the tree. Moreover, this reception entails the fictitious sending 
of the message {\sc color}
where  (line~\ref{P-02}).
Similarly to Algorithm~\ref{fig:DFTree-traversal-algorithm}, 
according to the values carried by the message {\sc color}, 
 initializes its local variables and obtains the color 
(lines~\ref{P-05}-\ref{P-07}).  It finally updates .

Then, when ,  executes lines~\ref{P-10}-\ref{P-19}.
More generally, these lines are executed by any process  as soon
as, after it received its first message {\sc color}, the color it
obtained () is such that  (line~\ref{P-09}). Hence, as the algorithm (a)
allows a process to broadcast only at a round corresponding to its
color, (b) allows only colored processes to broadcast {\sc color}
or {\sc term} messages, and (c) ensures the distance-2 coloring
property (see the proof) without any message collision or message
conflict during its execution.


Let us consider a process  such that the predicate of line~\ref{P-09} 
is satisfied. There are two cases. 
\begin{itemize}
\vspace{-0.1cm}
\item If , the neighbors of  are not colored. 
Process  computes then a color for each of its children 
(lines~\ref{P-11}-\ref{P-16}), and broadcasts a message {\sc color} 
to inform them of it (line~\ref{P-17}). It is easy to see that the messages 
{\sc color} implements a parallel traversal of the tree from the 
root to the leaves. Then,   enters a waiting period by 
setting  to . 
\vspace{-0.2cm}
\item If , all neighbors of  (and all processes in their 
sub-trees) are colored. In this case,  forwards this information to 
its parent. As its local participation to the algorithm is terminated,  
 sets  to . 
\end{itemize}

Finally, when a process  receives a message {\sc term} from
one of its children, it first updates   accordingly
(line~\ref{P-22}). If this set is empty, it claims termination if it
is the root. Otherwise, it assigns  to , so that it will
inform its parent of its local termination at the first time slot
(round) at which its color satisfies the predicate of line~\ref{P-09}.


\subsection{Proof  and cost of the algorithm}

\begin{lemma}
\label{lemma:par-noCollision-noConflict}
Algorithm~{\em\ref{fig:tree-parallel-coloring-algorithm}}
is collision-free and conflict free. 
\end{lemma}

\begin{proofL}
Let us observe that a process  is allowed to broadcast a message 
{\sc color} (line~\ref{P-16}) only if 
. 
As such a sending entails the assignment 
 (and  never decreases), 
it follows that  issues at most one such broadcast.  
The same occurs for the broadcast of a message {\sc term}. 

Due to the initialization of its local variable , 
no process  can broadcast a message until one of them receives the message 
. Let  us assume that (without loss of generality) that 
 when a process a process  receives this message. 
It follows from the text of lines~\ref{P-01}-\ref{P-08} that, before
 increases, we have 
 and  (if the graph is not a singleton), or 
 and  (if the graph is a singleton).  

Hence, when ,   executes lines~\ref{P-09}-\ref{P-19}
and broadcasts a message {\sc color} (line~\ref{P-17}), or a message
{\sc term} (line~\ref{P-18}),
while no other process can broadcast a message. Moreover, 
due to the color assignment done by  at lines~\ref{P-12}-\ref{P-16}, 
its neighbors obtain different colors  
when they receive the message {\sc color} from  at time . 

Due to the color computation done by  at line~\ref{P-12}-\ref{P-16} 
(when  ), no two of its neighbors have the same color, and none
of them has the same color as . It follows from the time predicate 
of line~\ref{P-09} that no two processes of the set   
can broadcast during the same time slot. 

Let  be a neighbor of the root process . 
It follows from line\ref{P-12} that, when  selects colors for 
its neighbors, it assigns them colors which are different among themselves
and different from its own color and the color of . 
Hence, due the  time predicate of line~\ref{P-09}, it follows 
that no two processes  of the set  can broadcast 
during the same time slot.   
The same  reasoning applies to the neighbors of , etc., which completes 
the proof of the lemma. 
\renewcommand{\toto}{lemma:par-noCollision-noConflict}
\end{proofL}


\begin{lemma}
\label{lemma:color-size}
Let  and   be two processes such that such  . 
The color of  belong to the set . 
\end{lemma}

\begin{proofL}
  Let  be any children pf .  The color of  is defined
  by  when it executes the lines~\ref{P-12}-\ref{P-16}.  The
  local palette of  is then the sequence , from which
  its own color () and the color of its neighbor which is
  parent () are suppressed (line~\ref{P-12}).  Hence, at
  most two integers (one in case of the root) are suppressed from the
  first  non-negative integers from which the palette is
  built.  Hence,  can color its neighbors with up to 
  ( if  is the root) colors with values less than
   and different from that of its parent.
  \renewcommand{\toto}{lemma:color-size}
\end{proofL}

\begin{lemma}
\label{lemma:par-proper-color-bound}
Algorithm~{\em\ref{fig:tree-parallel-coloring-algorithm}} 
uses at most  different colors to the processes, and no
two processes at distance  have the same color.
\end{lemma}

\begin{proofL}
Let us consider a process . It has at most  neighbors. 
It follows from lines~\ref{P-12}-\ref{P-16}, that all its  
neighbors (including the process from which it received the message 
{\sc color}) are  assigned different colors, and those are 
different from its color . Hence no two processes at distance 
 have the same color. As , 
it follows from  Lemma~\ref{lemma:color-size} that at most 
 colors are used by the algorithm. 
\renewcommand{\toto}{lemma:par-proper-color-bound}
\end{proofL}




\begin{lemma}
\label{lemma:par-termination}
Any process is colored, and (only after all processes are colored) 
this is known by the root process. 
\end{lemma}

\begin{proofL}
Once a process received an external message {\sc start}, 
it becomes the root of the tree, it takes a color, 
and broadcasts a message {\sc color}
to its neighbors at line~\ref{P-17} as soon as the
predicate of line~\ref{P-09}  becomes satisfied. 
Then, each of these neighbor processes  broadcasts a 
message {\sc color} to their neighbors, etc. 

As soon as its neighbors are  colored, a process  is such 
that , and consequently it broadcasts a message 
{\sc term}  at line~\ref{P-18}. 
Let   be the parent process that  broadcasts the message {\sc color} 
received by . When  has received message {\sc term} 
from all its children, it will proceed to  (line~\ref{P-24}) 
and will broadcast {\sc term}  at line~\ref{P-18} as soon as the 
time predicate of line~\ref{P-09} becomes satisfied. 

It follows from the previous observations that the process that received 
the message {\sc start} eventually claims termination at line~\ref{P-24}. 
\renewcommand{\toto}{lemma:par-termination}
\end{proofL}


\noindent
The following theorem is an immediate consequence of the previous lemmas. 
\begin{theorem}
\label{theo:parallel-coloring}
Algorithm~{\em\ref{fig:tree-parallel-coloring-algorithm}}
is a collision-free and conflict-free distance-2 coloring 
parallel algorithm for trees. 
\end{theorem}

\paragraph{Cost of the algorithm}
Each process which is not a leaf issues one broadcast of a message 
{\sc color}, and each process which is not the root issues one 
broadcast of a message {\sc term}. Let  be the number of leaves.
There are consequently  broadcasts.  As , 
the number of broadcasts is upper bounded by .


As far as time complexity is concerned, we have the following.  Let
 be the depth of the tree, and assume  when a process
 receives the message {\sc start}, which defines it as the 
root of the tree. It follows from their color assignment 
(lines~\ref{P-12}-\ref{P-16}) that 's 
children start one after the other at times , , ..., .
Let  be the child of  that obtains the color .
It broadcasts a message  {\sc color} to its own children at time 
 , and its child with the highest color will 
do the same at time  . Etc. 
As this worst pattern can repeat along a path of the tree, 
it follows than  process does not receive a message {\sc color} 
before time  . 

An analogous reasoning applies to the ``return'' messages {\sc term} 
starting from the leaves to the root. Hence, the time complexity is 
. (Let us remind that 
when the tree is well-balanced.

\subsection{Informing  processes of termination}
\label{sec:inform-others}

\paragraph{Global vs local termination}
Algorithm~\ref{fig:tree-parallel-coloring-algorithm} implements a
parallel distance-2 coloring, but only the root learns that the
algorithm has terminated (global termination). A non-root process
 knows only that the sub-tree of which it is the root has terminated
(local termination).  This section, enriches this algorithm so that any
process learns about global termination. 


\paragraph{The extended algorithm}
This extended algorithm is made up of
Algorithm~\ref{fig:tree-parallel-coloring-algorithm} where 
line~\ref{P-18} is modified, and the
statement ``{\bf when} {\sc term} {\bf is received do} ...''
(lines~\ref{P-20}-\ref{P-24}) is replaced by the statements described in 
Algorithm~\ref{fig:-tree-parallel-coloring-termination}.  Moreover,
each process  manages an additional local variable denoted
, which is initialized to .


When considering base Algorithm~\ref{fig:tree-parallel-coloring-algorithm} 
and its extension Algorithm~\ref{fig:-tree-parallel-coloring-termination}, 
the lines with the same number are the same in both algorithms, 
the lines suffixed by a ``prime'' are modified lines, and the lines 
N1-N7 are new lines. 

\begin{algorithm}[ht]
\centering{
\fbox{
\begin{minipage}[t]{150mm}
\footnotesize
\renewcommand{\baselinestretch}{2.5}
\begin{tabbing}
aaaaA\=A\=aaA\=aaA\=aaA\=aaA\kill




(\ref{P-20}')  \>
{\bf when}  {\sc term} {\bf is received} {\bf do}\\

(\ref{P-21}) \>\> {\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{P-22}-\ref{P-25}) {\bf end if};\\

(\ref{P-22}) \>\> ;\\


(N1) \>\> 
      \\
  
(\ref{P-23})   \>\> {\bf if} \= ()  \\

(\ref{P-24}')  \>\>\> {\bf then if}  () 
 {\bf then}   
 {\bf else}     {\bf end if} \\

(\ref{P-25})  \>\> {\bf end if}.\\~\\



(N2) \> {\bf when}  
 {\bf do}\\

(N3)  \>\>

 {\bf if}    {\bf then} 
  {\sc end} {\bf end if}; 
 .\\~\\



(N4) \> {\bf when}  {\sc end} {\bf is received} {\bf do} \\

(N5)  \>\> 
  {\bf if}   \\

(N6)  \>\>\> 
 {\bf then} ;
   \\

(N7) \> \> {\bf end if}. 
 
\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Parallel distance-2 coloring of a tree: propagation of the termination}
\label{fig:-tree-parallel-coloring-termination}
}
\end{algorithm}


The message {\sc term} broadcast by a process  at
line~\ref{P-18} must now carry the current value of ,
i.e.,  broadcasts {\sc term}.  The local
variable  of a process  is updated at line N1. In this way,
starting from the leaves, these local variables allow the root to know
the value  (upper bound on the number of colors needed by
a process to color itself and its neighbors).

When the root learns about global termination, it proceeds to
 (line~\ref{P-24}'). At this point, the value of its local
variable  is . Moreover, its new local state
 allows it to inform its children about global termination by
broadcasting the message {\sc end} carrying the value 
(lines~N2-N3).

Finally, when a process , which is not the root (hence
) receives an {\sc end}  message, from
its parent, it updates  and proceeds to 
(lines N4-N7), which allows it to forward the {\sc end} message to its
children, if any (lines N2-N3).  Let us notice that, as the children
of a process  do not broadcast {\sc end} messages during the
same time slot (round), there is no collision of these messages at
their parent. But since the parent simply discards these messages, a
trivial optimization may consist in relaxing the collision-freedom
constraint. Specifically, the children could send their {\sc end}()
messages in parallel as their parent does not need to receive
them. Independently of the optimization, it follows from the
propagation of the {\sc end} messages that, eventually, all the
processes are such that . When this occurs, they learn about
global termination.

\paragraph{Remark}
Let us consider the situation where, while the coloring algorithm has 
terminated (i.e., each  process has obtained a color and knows ),  
a new process  wants to enter the tree and obtains a color. 
Let  be the process  chosen to be 's parent. 
If ,  cannot accept  as a child
(this would require an additional color).  Differently, 
if , it is easy to dynamically add  as a child of . 
To this end,  takes the first color  in , , ..., , 
which is different from its own color and the colors of its neighbors.  
Then, during its next time slot,   broadcasts the  message 
{\sc new}, which, when received by , gives it a proper 
color. Let us notice that this ``join'' does not require  to have an 
identity.  It is consequently possible for  to also assign to   an 
identity not belonging to . 


\subsection{Merging two trees with the same maximal degree}
Considering two trees  and , which have the same maximal 
degree , let    be a process of  and  
 a process of ,  both having a degree less than . 

It is easy to see that, if , the trees  and  can be ``added'' to  
compose a single tree made  up of  and  connected by the
additional edge , This composition preserves the colors
previously assigned by two  independent executions of the algorithm, the 
one which assigned colors to  and the one which assigned colors to .



\section{Conclusion}
\label{sec:conclusion}
Synchronous networks where the time is decomposed in a sequence of
time slots (rounds) and the communication operations are ``broadcast a
message to neighbors'' and ``receive a message a neighbor'', are prone
to message collisions (which occur when two neighbors of a process
send it a message during the same time slot), and message conflicts
((which occur when a process and one of its neighbors broadcast during
the same time slot).  Distance-2 coloring solves this problem by
assigning a color to each process such that there is a matching of
time slots with colors which prevents message collisions/conflicts
from occurring.

This paper has presented a distributed algorithm which solves the
distance-2 coloring problem in tree networks.  This algorithm is based
on a parallel tree traversal algorithm skeleton on which are grafted
appropriate coloring assignments.  It is itself
collision/conflict-free. It uses only  colors (
being the maximal degree of the network), which is optimal. Its time
complexity is  (where  is the depth of the tree). This
algorithm does not require a process to initially know more than its
identity and the ones of its neighbors. Moreover, any two processes at
distance greater than  are not prevented from having the same
identity (which is important for scalability issues).  Let us also
notice that this algorithm is  relatively simple (a first-class property).


A very challenging issue is now the design of a parallel 
collision/conflict-free distance-2 coloring algorithm for synchronous
broadcast/receive systems whose communication graph is more general
than a tree. As, when considering sequential computing, 
distance-2 coloring is an NP-complete problem, the design of such a
distributed algorithm using a ``reasonable'' number of colors does not seem
to be a  ``trivial''  challenge. (A sequential algorithm suited to an 
arbitrary graph is presented in Appendix~\ref{sec:seq-arbitrary-graph}.) 



\section*{Acknowledgments}
This work has been partially supported by the Franco-Hong Kong ANR-RGC
Joint Research Programme 12-IS02-004-02 CO2Dim, the Franco-German
DFG-ANR Project 40300781 DISCMAT (devoted to connections between
mathematics and distributed computing), the French ANR project
SocioPlug (ANR-13-INFR-0003), and the Labex CominLabs excellence
laboratory (ANR-10-LABX-07-01) through the DeSceNt project.  






\begin{thebibliography}{99}
\footnotesize{

\vspace{-0.1cm}
\bibitem{A81}
Angluin D.,
Local and global properties in networks of processors.
{\it  Proc. 12th ACM Symposium on Theory of Computation (STOC'81)}, ACM Press,
pp.~82--93, 1981.


\vspace{-0.1cm}
\bibitem{ABDPR90}
Attiya H., Bar-Noy A., Dolev D., Peleg D., and Reischuk R., 
Renaming in an asynchronous environment.
{\it Journal of the ACM}, 37(3):524-548, 1990. 

\vspace{-0.1cm}
\bibitem{AE14}
Attiya H. and Ellen F., 
{\it Impossibility results in distributed computing.}
Morgan \& Claypool Publishers,  140  pages, 2014
(ISBN 978-1-60845-525-6). 


\vspace{-0.1cm}
\bibitem{BE11}
Barenboim L. and  Elkin M.,
Deterministic distributed vertex coloring in polylogarithmic time. 
{\it Journal of the ACM},  58(5):23, 2011.

\vspace{-0.1cm}
\bibitem{BE14}
Barenboim L. and  Elkin M.,
{\it Distributed graph coloring, fundamental and recent developments}, 
Morgan \& Claypool Publishers,  155 pages, 2014. 

\vspace{-0.1cm}
\bibitem{BEK14}
Barenboim L.,  Elkin M., and  Kuhn F., 
Distributed (Delta+1)-coloring in linear (in Delta) time. 
{\it SIAM Journal of  Computing},  43(1):72-95, 2014. 


\vspace{-0.1cm}
\bibitem{BM09}
Blair J. and Manne F.,
An efficient self-stabilizing distance-2 coloring algorithm.
{\it Proc.  16th  Colloquium on  Structural Information and Communication
Complexity  (SIROCCO'10)},  Springer LNCS 5869, pp.~237-251, 2009.


\vspace{-0.1cm}
\bibitem{BCGMBO05}
Bozdag D.,  \c{C}ataly\"urek U.V.,  Gebremedhin A.H.,   Manne F., 
 Boman E.G., and  \"Ouzg\"uner F., 
A Parallel distance-2 graph coloring algorithm for
distributed memory computers. 
{\it Proc. Int'l Conference on High Performance Computing and Communications
 (HPCC'05)},  Springer LNCS 3726,  pp.~796-806, 2005. 


\vspace{-0.1cm}
\bibitem{BGMBC08}
Bozdag D.,  Gebremedhin A.S.,  Manne F., Boman G. and \c{C}ataly\"urek U.V.,
A framework for scalable greedy coloring on distributed-memory parallel 
computers.
{\it Journal of Parallel and Distributed  Computing},  68(4):515-535, 2008. 

\vspace{-0.1cm}
\bibitem{CRR11}
Casta\~neda A.,  Rajsbaum S., and  Raynal M., 
The renaming problem in shared memory systems: an introduction.
{\it Elsevier Computer Science Review}, 5:229-251, 2011. 

\vspace{-0.1cm}
\bibitem{chipara11:conflict}
Chipara O., Lu C., Stankovic J., and Roman. G.-C.,
Dynamic conflict-free transmission scheduling for sensor network
  queries.
{\it  IEEE Transactions on Mobile Computing}, 10(5):734-748, 2011.


\vspace{-0.1cm}
\bibitem{CV86}
Cole R. and  Vishkin U., 
Deterministic coin tossing  with applications to optimal parallel list ranking.
{\it Information and Control}, 70(1):32-53, 1986.

\vspace{-0.1cm}
\bibitem{DKR82}
Dolev D., Klawe M.,  and Rodeh M.,
An  unidirectional distributed algorirthm for extrema finding 
in a circle.
{\it Journal of Algorithms}, 3:245--260, 1982. 

\vspace{-0.1cm}
\bibitem{EV05}
Ergen S.C. and  Varaiya P., 
PEDAMACS: Power efficient and delay aware medium access protocol
for sensor networks. 
{\it IEEE Transaction on Mobile Computing}, 5(7):920-930, 2005.

\vspace{-0.1cm}
\bibitem{gairing-distanceTwo}
Gairing M., Goddard W, Hedetniemi S.~T., Kristiansen P., and McRae
A. A.,
Distance-two information in self-stabilizing algorithms.
{\it Parallel Processing Letters}, 14(03-04):387--398, 2004.

\vspace{-0.1cm}
\bibitem{GJ79}
Garey M.R. and Johnson D.S.,
{\it Computers and intractability: a guide to the theory of  NP-completeness}. 
Freeman W.H. \& Co, New York, 340 pages, 1979.


\vspace{-0.1cm}
\bibitem{GMP02}
Gebremedhin A.H.,   Manne F., and  Pothen A., 
Parallel distance-k coloring algorithms for numerical optimization.
{\it Proc. Euro-Par  Parallel Processing}, 
Springer LNCS 2400,  pp.~912-921, 2002.  


\vspace{-0.1cm}
\bibitem{GPS88}
Goldberg A.,  Plotkin S.,  and Shannon G., 
Parallel symmetry-breaking in sparse graphs.
{\it SIAM Journal on Discrete Mathematics}, 1(4):434-446, 1988.

\vspace{-0.1cm}
\bibitem{HT04}
Herman T., Tixeuil S., 
A distributed TDMA slot assignment algorithm for wireless sensor networks.
{\it Proc. Int'l Workshop on Algorithmic Aspects of Wireless Sensor Networks
(ALGOSENSORS'04)}, Springer LNCS 3121, pp.~45-58, 2004. 

\vspace{-0.1cm}
\bibitem{IRR10}
Imbs D., Rajsbaum S., and Raynal M., 
The universe of symmetry breaking tasks. 
{\it Proc.  18th  Colloquium on  Structural Information and Communication
Complexity  (SIROCCO'11)},  Springer LNCS 6796, pp.~66-77, 2011.

\vspace{-0.1cm}
\bibitem{jemili13:collision}
Jemili I., Ghrab D., Belghith A., Derbel B., and Dhraief A., 
Collision aware coloring algorithm for wireless sensor networks.
In {\it  Proc. 9th Int' lWireless Communications and Mobile Computing 
Conference  (IWCMC'13)}, pages 1546-1553,  2013.




\vspace{-0.1cm}
\bibitem{KW06}
Kuhn F.  and  Wattenhofer R., 
On the complexity of distributed graph coloring.
{\it  Proc. 25th ACM Symposium  Principles of Distributed Computing (PODC'06)},
ACM Press, pp.~7-15, 2006.


\vspace{-0.1cm}
\bibitem{L92}
Linial N.,
Locality in distributed graph algorithms.
{\it SIAM Journal on Computing}, 21(1):193-201, 1992. 

\vspace{-0.1cm}
\bibitem{L81}
Lynch N.A. 
Upper bounds for static resource allocation in a distributed system.
{\it Journal of Computer and System Sciences},
23(2):254-278, 1981.





\bibitem{serena}
Mahfoudh S., Chalhoub G., Minet P., Misson M., and Amdouni  I.,
Node coloring and color conflict detection in wireless sensor networks. 
{\it Future Internet}, 2(4):469, 2010.


\vspace{-0.1cm}
\bibitem{P00}
Peleg D.,
{\it Distributed computing, a locally sensitive approach}.
 SIAM Monographs on Discrete Mathematics and Applications, 
343 pages, 2000 (ISBN  0-89871-464-8). 

\vspace{-0.1cm}
\bibitem{PUE02}
Prabhakar B., Uysal-Biyikoglu, E., and  El Gamal A.,
Energy-efficient packet transmission over awireless link.
{\it  IEEE/ACM Transactions on Networking}, 10(4):487–499,  2002.


\vspace{-0.1cm}
\bibitem{R97}
Ramanathan S.,
A unified framework and algorithms for (T/F/C)DMA channel assignment in 
wireless networks.
{\it Proc. 16th IEEE INFOCOM Conference}, IEEE Press, pp.~900-907, 1997.



\vspace{-0.1cm}
\bibitem{R86}
Raynal M., 
{\it Algorithms for mutual exclusion}. 
The MIT press, 107 pages, 1986 (ISBN 0-262-18119-3). 

\vspace{-0.1cm}
\bibitem{R10}
Raynal M., 
{\it Fault-tolerant agreement  in synchronous message-passing  systems.}
Morgan \& Claypool Publishers,  165  pages, 2010
(ISBN 978-1-60845-525-6). 

\vspace{-0.1cm}
\bibitem{R13}
Raynal M., 
{\it Distributed algorithms for message-passing systems}.
Springer, 500 pages, 2013, ISBN 978-3-642-38122-5.


\vspace{-0.1cm}
\bibitem{S07} 
Santoro N., 
{\it Design and analysis of distributed algorithms}. 
Wiley, 589 pages, 2007. 

}
\end{thebibliography}



\appendix 
\section{A sequential distributed algorithm for an arbitrary graph}
\label{sec:seq-arbitrary-graph}

Algorithm~\ref{fig:coloring-of-an-arbitrary-graph} is a sequential 
distance-2 coloring algorithm 
for an  arbitrary (connected) graph. The design of this algorithm 
is the same the one of  Algorithm~\ref{fig:DFTree-traversal-algorithm}.
It added complexity comes from the fact it allows the sequential control flow
(implemented by the messages {\sc color} and {\sc term}
in Algorithm~\ref{fig:DFTree-traversal-algorithm})
to back track when a process discovers  a  coloring conflict.  
This backtracking is implemented by the messages  {\sc correct},
{\sc corrected\_color}, and {\sc resume\_coloring}.


\begin{algorithm}[t]
\centering{
\fbox{
\begin{minipage}[t]{150mm}
\footnotesize
\renewcommand{\baselinestretch}{2.5}
\resetline
\begin{tabbing}
aaaaA\=aA\=aaA\=aaA\=aaA\=aaA\kill

{\bf  init}: ; ; 
             ; ; 
             .\\~\\

{\bf  when} {\sc  start} {\bf  is received do} \\ 

\line{AG-01}  
\>  the reception of this message 
    defines its receiver   as the root of the tree;\\
\>  this process  simulates then  the sending of   
    {\sc color} to itself.\\~\\



{\bf when} {\sc color} 
     {\bf  is received  do} \\


\line{AG-02} \> 
;

 ;\\

\line{AG-03} \> {\bf if} \= 
  \\

\line{AG-04} \>\> {\bf then} \= 
  ; ;\\


     
\line{AG-05}  \>\> {\bf else}  \> 
{\bf if} \=   \\



\line{AG-06} \>\>\>\> {\bf then} \=  ; 
;  ; 
;\\

     

\line{AG-07}  \>\>\>\> {\bf else} \> 
{\bf if} \=   

 {\bf then} \= ;  ; 
  {\bf end if} \\

\line{AG-08} \>\>\>   {\bf end if} \\


\line{AG-9} \>   {\bf end if};\\


\line{AG-10} \>
{\bf if}  
   {\bf then} ;
    {\bf end if}. \\~\\
  
  


{\bf when} increases  \\
  
\line{AG-11} \> {\bf if} \=   

 {\bf then} \=   
 the first color in  which is not in
  ;\\


\line{AG-13}\>\>\>
 {\sc correct};  
  \\
  
  
\line{AG-14}\>{\bf end if}; \\
  
\line{AG-15} \> {\bf if} \=   

 {\bf then} \=    

  the first color in   which is not in
  ;\\

\line{AG-17}  \>\>\>\>\>\>
  any ;\\

\line{AG-18}  \>\>\>\>\>\>
         
  {\sc color} \\
  
  
\line{AG-19}\>{\bf end if}; \\
  
\line{AG-20} \> {\bf if}   {\bf then} \= 
         
{\sc term};   {\bf end if}; \\

  
   \line{AG-21} \> {\bf if}   {\bf then} \=
 {\sc corrected\_color };
    {\bf end if}; \\
  
 \line{AG-22} \> {\bf if}   {\bf then} \= 
        {\sc resume\_coloring }; 
        {\bf end if};   \\
  
  \line{AG-23} \> {\bf if}   {\bf then} \= 

 {\sc corrected\_color } ;
  {\bf end if}.    \\~\\



{\bf when} 
{\sc term} {\bf is received} {\bf do} \\

\line{AG-24} \>
{\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{AG-25}-\ref{AG-30}) {\bf end if};\\

\line{AG-25}  \> 
;\\


\line{AG-26}  \> 
{\bf if}  
  \% the neighbors of   are properly colored \% \\


\line{AG-27}  \>  \> {\bf then} \= 
{\bf if}  \= {\bf then}  
                 \= the root claims the graph is colored  {\bf else}    
     
 {\bf end if}\\
    

\line{AG-28}  \>\> {\bf else} \>
; 


  any ;\\

\line{AG-29}  \>\>\> 
  the first color in   which is not in
  ;  \\

\line{AG-30}  \>  {\bf end if}. \\~\\


{\bf when} 
{\sc correct} {\bf is received} {\bf do} \\

\line{AG-31} \>
{\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{AG-32}-\ref{AG-33}) {\bf end if.}\\

\line{AG-32}  \>   
;  
;\\

\line{AG-33}  \>  \  
 the first  color in  which is not in
  ; ; 
.
 
\\~\\



{\bf when} 
{\sc corrected\_color}
 {\bf is received} {\bf do} \\

\line{AG-34} \> {\bf if}    

 {\bf then} \=   the last color added to ; 
  {\bf end if}; \\
 
 
\line{AG-35} \> {\bf if}    

 {\bf then} \=   the last color added to ; 
  {\bf end if}; \\ 
 

\line{AG-36} \> 

{\bf if}    

 {\bf then} \=  ;   
{\bf end if};\\


\line{AG-37} \> {\bf if} \=  
{\bf then} \=   {\bf end if}. \\~\\





{\bf when} 
{\sc resume\_coloring} {\bf is received} {\bf do} \\

\line{AG-38} \>
{\bf if}  
   {\bf then} discard the message
      (do not execute lines~\ref{AG-39}-\ref{AG-40}) {\bf end if};\\


 \line{AG-39} \> ;\\
  
  
\line{AG-40} \> {\bf if} \=    {\bf then} \=  
  
   {\bf else}    {\bf end if}. 
     

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Sequential distance-2 coloring for an arbitrary graph  
(code for )}
\label{fig:coloring-of-an-arbitrary-graph}
}
\end{algorithm}


\begin{figure}[ht]
{\centering\includegraphics[height=5cm]{ex.eps} 
\caption{A 5-process arbitrary network}
\label{arbitrary-graph}
}
\end{figure}

Considering the network of Figure~\ref{arbitrary-graph}, An example of
execution of Algorithm~\ref{fig:coloring-of-an-arbitrary-graph} is
depicted in Table~\ref{fig:table-example}. Due to space restriction we
abbreviate the following: \\

\begin{itemize}


\item br =    operation,

\item  = ,
\item  = ,
\item CL(,,c,z,S) = \ccolor(,,c,z,S),
\item  CRL(,,c,S) = {\sc correct}(,,c,z,S),
\item  CR\_CL(,,c,S) =  {\sc corrected\_cl}(,,c,S), 
\item   RSM\_CL(,) = {\sc resume\_cl}(,),
\item .

\end{itemize}


Process  receives the message {\sc start} at round . It
broadcasts the message \ccolor(, , -1, 0, ) to
itself. It receives this message at round .  It updates its local
variables  at line 02 (abbreviated as L2), ,  and
 at line 06 (abbreviated as L6). This appears in the first
row of the table where the value of  is . Then, when
 progresses to ,  has , therefore, it
broadcasts the message {\sc color} with appropriate parameters,
where it proposes a color that is not in  to each of
its neighbors, and subsequently enters  (L16). This
appears in the second row of the table where the value of  is
.  When  and  receive this message at round , they
execute the associated processing at L2 and L6 for  and at L10
for  . So, in this round  updates its local variables 
at L2, ,  and  at L6.   updates its local
variables  at L2, , at L10. This appears in the third row
of the table where  is . In round 3,  has ,
so it broadcasts the message {\sc color} with appropriate
parameters (L16) and gets  (L16), Etc.

In round 6,  finds that the color proposed by its neighbor 
(color 0 proposed in round 5) is in , so it ''refuses'' this
color and gets  (L4).  In round 7,  gets a color
which is not in  (L11) and broadcasts the message
{\sc correct}(, , 2, 0, ). In round 8, 
updates  and  and gets a new color (L31). Its state will
allow it to broadcast the message {\sc corrected\_cl} (round 11). The
broadcast of this message will trigger the broadcast of the message
{\sc resume\_cl} (round 15) to resume the coloring as described before.





\begin{table}[h]
\scriptsize
  \begin{tabular}{|p{0.66cm}|p{2.7cm}|p{3.4cm}|p{2.95 cm}|p{2.46cm}|p{1.93cm}|}\hline
\theadfont\diagbox[width= 3.3em]{ \hspace{-5 pt}clock}{}
&     \hspace{-5 pt}     &  &  &  &    \\\hline
0 &\hspace{-12.5 pt}\,\,=\,\,\,(L2),\hspace{ 0pt}\,=\,\, & & & & \\
&\hspace{-7 pt} ,  (L6) &  & & &
\\\hline 
 1& \hspace{-8 pt} br CL(,,0,1,)& & & & \\
&\hspace{-5 pt} (L16) &  & & & \\\hline
 
  2& & \hspace{-4 pt}   (L2), ,  (L6)& & \hspace{-8 pt} , (L10)& \\\hline
   3& & br CL(,, 1, 2, ) & & &  \\
& &  (L16) & & &\\\hline

    4&\hspace{-5 pt} , & &  (L2), & &  \\
&\hspace{-5 pt} (L10) &  & ,  (L6) & & \hspace{-5 pt}  (L10) \\\hline

 5&  & & br CL(,, 2, 0, ) & & \\
& &  &   (L16) & &  \\\hline 

 6 &  & \,=\,\,, \hspace{25 pt}  (L10)   & &  (L2), \hspace{20 pt} (L4) &   \\\hline 

 7 & & & &   (L11), \hspace{8 pt} br CR(,,2,) & \\
& &  &   &  (L12)&  \\\hline 

8 & &  & \,=\,\,, \hspace{25 pt} \,=\,\, (L30) &   & \\
& &  &   (L31) &  &  \\\hline 

9 & &  & \hspace{-4 pt} br CR\_CL(,,,3) &   & \\
& &  &  (L19) &  &  \\\hline 

10 & & \,=\,\,\,(L32), \hspace{20 pt} (L34) &  &   &  \\\hline 

11 & &  br CR\_CL(,,,3) &  &   & \\
& &  (L21) &   &  &  \\\hline

12 &  (L33) & &  &    &    \\\hline

13 & & &  (l35)  &    & \hspace{-7.9 pt}\,=\,\, (L32) 
 \\\hline

14 & & & br RSM\_CL(,  )  &    &  \\
& & &  (L20)   &  &  \\\hline

15 & & &  &   (L38)   &   \\\hline

16 & & &  & br TERM(,  )  &  \\
& & &   &  (L18) &  \\\hline

17 & & &  (L38) &    &   \\\hline


18 & & & br TERM(,  ) &   &  \\
& & &   (L18) &  &  \\\hline

19 & &   (L27)  &  &   &  \\
& &  (L26) & &  &  \\\hline

20 & &  br\,CL(,,1,2,)\,(L16)  &  &   &  \\
& &  (L16) & &  &  \\\hline

21 & \,=\,\,,  (L10) &  & \,=\,\,\,,\, \hspace{20 pt}  (L10) &   & \hspace{-5 pt}\,=\,\, \hspace{-1 pt}  (L07)  \\\hline


22 & &  &  &   & \hspace{-0.27 cm }  br\,TERM(,) \\
& & & &  & \hspace{-8 pt}  (L18) \\\hline

23 & &   (L25) &  &   &  \\
& & & &  & \\\hline

24 & &  br TERM(,  )  &  &   &  \\
& &  (L18) & &  & \\\hline

25 & end algorithm (L25) &    &  &   &  \\
& & & &  & \\\hline

\end{tabular}
\caption{An execution of Algorithm~\ref{fig:coloring-of-an-arbitrary-graph}
on the network of Figure~\ref{arbitrary-graph}}
\label{fig:table-example}
\end{table}




\end{document}
