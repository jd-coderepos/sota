
\documentclass{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{natbib} 
\usepackage{booktabs} 
\usepackage{multirow,array}

\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\T}{^\intercal}
\newcommand{\xx}{\mathbf{x}}
\newcommand{\ww}{\mathbf{w}}
\newcommand{\ts}{\mathcal{D}}
\newcommand{\qq}{\mathbf{Q}}
\newcommand{\xp}{\mathbb{E}}
\newcommand{\todo}[1]{\textcolor{green}{TODO: #1}}
\newcommand{\tr}[1]{\textcolor{blue}{TR: #1}}
\newcommand{\jf}[1]{\textcolor{red}{JF: #1}}
\newcommand{\sw}[1]{\textcolor{red}{SW: #1}}
\newcommand{\gf}[1]{\textcolor{magenta}{GF: #1}}
\newcommand{\ms}[1]{\textcolor[rgb]{0.25,0,0.5}{MS:#1}}
\newcommand{\cs}[1]{\textcolor[rgb]{0.5,0.0,0.0}{CS:#1}}

\usepackage{xcolor}
\definecolor{myblue}{HTML}{0000B5}
\definecolor{crimson}{HTML}{B30000}
\newcommand{\bb}[1]{\textcolor{myblue}{#1}}
\newcommand{\cc}[1]{\textcolor{crimson}{#1}}

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}
\interfootnotelinepenalty=10000

\usepackage[accepted]{include/icml2018}

\icmltitlerunning{QMIX: Monotonic Value Function Factorisation for
	Deep Multi-Agent Reinforcement Learning}

\begin{document}

\twocolumn[
\icmltitle{QMIX: Monotonic Value Function Factorisation for\\
	Deep Multi-Agent Reinforcement Learning}




\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Tabish Rashid}{equal,ox}
\icmlauthor{Mikayel Samvelyan}{equal,rau}
\icmlauthor{Christian Schroeder de Witt}{ox}\\
\icmlauthor{Gregory Farquhar}{ox}
\icmlauthor{Jakob Foerster}{ox}
\icmlauthor{Shimon Whiteson}{ox}
\end{icmlauthorlist}


\icmlaffiliation{ox}{University of Oxford, Oxford, United Kingdom}
\icmlaffiliation{rau}{Russian-Armenian University, Yerevan, Armenia}

\icmlcorrespondingauthor{Tabish Rashid}{tabish.rashid@cs.ox.ac.uk}
\icmlcorrespondingauthor{Mikayel Samvelyan}{mikayel@samvelyan.com}

\icmlkeywords{Machine Learning, ICML}

\vskip 0.3in
]



\printAffiliationsAndNotice{\icmlEqualContribution} 


\begin{abstract}
\label{sec:abstract}

In many real-world settings, a team of agents must coordinate their behaviour  
while acting in a decentralised way. At the same time, it is often possible to 
train the agents in a centralised fashion in a simulated or laboratory setting, 
where global state information is available and communication constraints are lifted. 
Learning joint action-values conditioned on extra state information is 
an attractive way to exploit centralised learning, but the best strategy for 
then extracting decentralised policies is unclear.
Our solution is QMIX, a novel value-based method that can train decentralised policies in a centralised end-to-end fashion. QMIX employs a network that estimates joint action-values as a complex non-linear combination of per-agent values that condition only on local observations. 
We structurally enforce that the joint-action value is monotonic in the 
per-agent values, which allows tractable maximisation of the joint action-value in off-policy learning, and guarantees consistency between the 
centralised and decentralised policies.
We evaluate QMIX on a challenging set of StarCraft II micromanagement tasks, 
and show that QMIX significantly outperforms existing 
value-based multi-agent reinforcement learning methods.

\end{abstract} \section{Introduction}
\label{sec:intro}

Reinforcement learning (RL) holds considerable promise to help address a variety of cooperative multi-agent problems, such as coordination of robot swarms \cite{huttenrauch_guided_2017} and autonomous cars \cite{cao_overview_2012}. 

In many such settings, partial observability and/or communication constraints necessitate the learning of \textit{decentralised policies}, which condition only on the local action-observation history of each agent. Decentralised policies also naturally attenuate the problem that joint action spaces grow exponentially with the number of agents, often rendering the application of traditional single-agent RL methods impractical.

Fortunately, decentralised policies can often be learned in a centralised fashion in a simulated or laboratory setting. This often grants access to additional state information, otherwise hidden from agents, and removes inter-agent communication constraints. 
The paradigm of \textit{centralised training with decentralised execution} \cite{oliehoek_optimal_2008,kraemer_multi-agent_2016} has recently attracted attention in the RL community \cite{jorge_learning_2016,foerster_counterfactual_2017}. 
However, many challenges surrounding how to best exploit centralised training remain open.

One of these challenges is how to represent and use the action-value function that most RL methods learn.  On the one hand, properly capturing the effects of the agents' actions requires a centralised action-value function  that conditions on the global state and the joint action.  On the other hand, such a function is difficult to learn when there are many agents and, even if it can be learned, offers no obvious way to extract decentralised policies that allow each agent to select only an individual action based on an individual observation.

\begin{figure}[t!]
	\centering
		\subfigure[5 Marines map]{
		\includegraphics[width=0.4842\columnwidth]{figures/5m}}
			\subfigure[2 Stalkers \& 3 Zealots map]{
	\includegraphics[width=0.4842\columnwidth]{figures/2s_3z}}
	\caption{\textit{Decentralised unit micromanagement} in StarCraft II, where each learning agent controls an individual unit. The goal is to coordinate behaviour across agents to defeat all enemy units.}
	\label{fig:starcraft_screenshots}
\end{figure}

The simplest option is to forgo a centralised action-value function and let each agent  learn an individual action-value function  independently, as in \emph{independent Q-learning} (IQL) \cite{tan_multi-agent_1993}.  However, this approach cannot explicitly represent interactions between the agents and may not converge, as each agent's learning is confounded by the learning and exploration of others.

At the other extreme, we can learn a fully centralised state-action value function  and then use it to guide the optimisation of decentralised policies in an actor-critic framework, an approach taken by \emph{counterfactual multi-agent} (COMA) policy gradients \cite{foerster_counterfactual_2017}, as well as work by \citet{gupta_cooperative_2017}. However, this requires on-policy learning, which can be sample-inefficient, and training the fully centralised critic becomes impractical when there are more than a handful of agents.

In between these two extremes, we can learn a centralised but factored , an approach taken by \emph{value decomposition networks} (VDN) \cite{sunehag_value-decomposition_2017}. By representing  as a sum of individual value functions  that condition only on individual observations and actions, a decentralised policy arises simply from each agent selecting actions greedily with respect to its . However, VDN severely limits the complexity of centralised action-value functions that can be represented and ignores any extra state information available during training.

In this paper, we propose a new approach called QMIX which, like VDN, lies between the extremes of IQL and COMA, but can represent a much richer class of action-value functions. Key to our method is the insight that the full factorisation of VDN is not necessary to extract decentralised policies.  Instead, we only need to ensure that a global  performed on  yields the same result as a set of individual  operations performed on each .  To this end, it suffices to enforce a monotonicity constraint on the relationship between  and each :


QMIX consists of \textit{agent networks} representing each , and a \emph{mixing network} that combines them into , not as a simple sum as in VDN, but in a complex non-linear way that ensures consistency between the centralised and decentralised policies. At the same time, it enforces the constraint of \eqref{eq:monotonicity_constraint} by restricting the mixing network to have positive weights.  
As a result, QMIX can represent complex centralised action-value functions with a factored representation that scales well in the number of agents and allows decentralised policies to be easily extracted via linear-time individual argmax operations.

We evaluate QMIX on a range of unit micromanagement tasks built in StarCraft II\footnote{StarCraft and StarCraft II are trademarks of Blizzard Entertainment\textsuperscript{TM}.}. \cite{vinyals_starcraft_2017}. Our experiments show that QMIX outperforms IQL and VDN, both in terms of absolute performance and learning speed.
In particular, our method shows considerable performance gains on a task with heterogeneous agents. Moreover, our ablations show both the necessity of conditioning on the state information and the non-linear mixing of agent -values in order to achieve consistent performance across tasks. 




 \section{Related Work}
\label{sec:related}

Recent work in multi-agent RL has started moving from 
tabular methods \cite{yang_multiagent_2004, busoniu_comprehensive_2008} to deep learning methods that can tackle
high-dimensional state and action spaces \cite{tampuu_multiagent_2015,foerster_counterfactual_2017,peng_multiagent_2017}. In this paper, we 
focus on cooperative settings.

On the one hand, a natural approach to finding policies for a multi-agent system 
is to directly learn decentralised value functions or policies. 
\emph{Independent Q-learning} \cite{tan_multi-agent_1993} trains independent
action-value functions for each agent using -learning \cite{watkins_learning_1989}. \cite{tampuu_multiagent_2015} extend this approach to 
deep neural networks using DQN \cite{mnih_human-level_2015}.
While trivially achieving decentralisation, these approaches are prone to instability arising from the non-stationarity of the environment 
induced by simultaneously learning and exploring agents. 
\citet{omidshafiei_deep_2017} and \citet{foerster_stabilising_2017} address 
learning stabilisation to some extent, but still learn decentralised value 
functions and do not allow for the inclusion of extra state information during training.

On the other hand, centralised learning of joint actions can naturally handle 
coordination problems and avoids non-stationarity, but is hard to scale, as the joint action space grows exponentially in the 
number of agents.
Classical approaches to scalable centralised learning include 
\textit{coordination graphs} \cite{guestrin_multiagent_2002}, which exploit conditional independencies between agents by decomposing a global reward function 
into a sum of agent-local terms.
\textit{Sparse cooperative Q-learning} \cite{kok_collaborative_2006} is a tabular -learning 
algorithm that learns to coordinate the actions of a group of cooperative 
agents only in the states in which such coordination is necessary, encoding
those dependencies in a coordination graph. 
These methods require the dependencies between agents to be pre-supplied, whereas we do not require such prior knowledge. 
Instead, we assume that each agent always contributes to the global reward, and learns the magnitude of its contribution in each state.

More recent approaches for centralised learning require even more 
communication during execution: CommNet 
\cite{sukhbaatar_learning_2016} uses a centralised network architecture to exchange information between agents. BicNet 
\cite{peng_multiagent_2017} uses bidirectional RNNs to exchange 
information between agents in an actor-critic setting. This approach 
additionally requires estimating individual agent rewards.

Some work has developed hybrid approaches that exploit the setting of 
centralised learning with fully decentralised execution. COMA 
\cite{foerster_counterfactual_2017} uses a centralised critic to train 
decentralised actors, estimating a counterfactual advantage function for each 
agent in order to address multi-agent credit assignment. Similarly, 
\citet{gupta_cooperative_2017} present a centralised actor-critic algorithm 
with per-agent critics, which scales better with the number of agents but mitigates the
advantages of centralisation. \citet{lowe_multi-agent_2017} learn a 
centralised critic for each agent and apply this to competitive games with 
continuous action spaces. These approaches use on-policy policy gradient 
learning, which can have poor sample efficiency and is prone to getting stuck 
in sub-optimal local minima.

\citet{sunehag_value-decomposition_2017} propose \emph{value decomposition 
networks} (VDN), which allow for centralised value-function learning with 
decentralised execution. Their algorithm decomposes a central 
state-action value function into a sum of individual agent terms. This corresponds to 
the use of a degenerate fully disconnected coordination graph. VDN does not make 
use of additional state information during training and can represent only a
 limited class of centralised action-value functions.
 
A number of papers have established unit micromanagement in StarCraft as a benchmark for deep multi-agent RL. 
\citet{usunier_episodic_2016} present an algorithm using a centralised \textit{greedy MDP} and first-order optimisation. \citet{peng_multiagent_2017} also evaluate their methods on StarCraft. However, neither requires decentralised execution. 
Similar to our setup is the work of \citet{foerster_stabilising_2017}, who evaluate replay stabilisation methods for IQL on combat scenarios with up to five agents. \citet{foerster_counterfactual_2017} also uses this setting. 
In this paper, we construct unit micromanagement tasks in the \textit{StarCraft 
II Learning Environment} (SC2LE) \cite{vinyals_starcraft_2017} as opposed to 
StarCraft, because it is actively supported by the game developers and SC2LE offers a more stable testing environment. 

QMIX relies on a neural network to transform the centralised state into the 
weights of another neural network, in a manner reminiscent of 
\emph{hypernetworks} \citep{ha_hypernetworks_2016}. This second neural network 
is constrained to be monotonic with respect to its inputs by keeping its 
weights positive. \citet{Dugas_2009} investigate such functional restrictions 
for neural networks.






 \section{Background}
\label{sec:background}


A \textit{fully cooperative multi-agent task} can be described as a Dec-POMDP \cite{oliehoek_concise_2016} consisting of a tuple . 
 describes the true state of the environment.
At each time step, each agent  chooses an action , forming a joint action . 
This causes a transition on the environment according to the state transition function . 
All agents share the same reward function  and  is a discount factor. 

We consider a \textit{partially observable} scenario in which each agent draws individual observations  according to observation function . 
Each agent has an action-observation history , on which it conditions a stochastic policy . The joint policy  has a joint \textit{action-value function}: , where  is the \textit{discounted return}.


Although training is centralised, execution is decentralised, i.e., the 
learning algorithm has access to all local action-observation histories 
 and global state , but each agent's learnt policy can 
condition only on its own action-observation history .

\subsection{Deep -Learning}

Deep -learning represents the action-value function with a deep neural network parameterised by . \textit{Deep Q-networks} (DQNs) \cite{mnih_human-level_2015} use a  \textit{replay memory} to store the transition tuple , where the state    is observed after taking the action  in state  and receiving reward .  is learnt by sampling batches of  transitions from the replay memory and minimising the squared \textit{TD error}:
 
where .  are the parameters of a \textit{target network} that are periodically copied from  and kept constant for a number of iterations.  

\subsection{Deep Recurrent -Learning}

In partially observable settings, agents can benefit from conditioning on their entire action-observation history. \citet{hausknecht_deep_2015} propose \textit{Deep Recurrent Q-networks} (DRQN) that make use of recurrent neural networks. Typically, gated architectures such as LSTM \cite{hochreiter_long_1997} or GRU \cite{chung_empirical_2014} are used to facilitate learning over longer timescales.

\subsection{Independent -Learning}

Perhaps the most commonly applied method in multi-agent learning is \textit{independent Q-learning} (IQL) \cite{tan_multi-agent_1993}, which decomposes a multi-agent problem into a collection of simultaneous single-agent problems that share the same environment. This approach does not address the non-stationarity introduced due to the changing policies of the learning agents, and thus, unlike -learning, has no convergence guarantees even in the limit of infinite exploration. In practice, nevertheless, IQL commonly serves as a surprisingly strong benchmark even in mixed and competitive games \cite{tampuu_multiagent_2015, leibo_multi-agent_2017}.


\subsection{Value Decomposition Networks}

By contrast, \textit{value decomposition networks} (VDNs) \citep{sunehag_value-decomposition_2017} aim to learn a joint action-value function , where  is a joint action-observation history and  is a joint action.  It represents  as a sum of individual value functions , one for each agent , that condition only on individual action-observation histories:

Strictly speaking, each  is a \textit{utility function} \cite{guestrin_multiagent_2002} and not a value function since by itself it does not estimate an expected return.  However, for terminological simplicity we refer to both  and  as value functions.

The loss function for VDN is equivalent to \eqref{eq:dqn}, where  is replaced by .  An advantage of this representation is that a decentralised policy arises simply from each agent performing greedy action selection with respect to its . 
\section{QMIX}

\begin{figure*}[h!tb]
	\centering
	\includegraphics[width=\textwidth]{figures/QMIX.png}
	\text{~~~~~~~~~~~~~~~~~~~~~~~}(a) \hfill (b) \hfill (c) \text{~~~~~~~~~~~~~~~~~~~~}
	\caption{(a) Mixing network structure. In red are the hypernetworks that produce the weights and biases for mixing network layers shown in blue. (b) The overall QMIX architecture. (c) Agent network structure. Best viewed in colour.}
	\label{fig:QMIX}
\end{figure*}

\label{sec:methods}

In this section, we propose a new approach called QMIX which, like VDN, lies 
between the extremes of IQL and centralised -learning, but can represent a much richer class of action-value functions. 

Key to our method is the insight that the full factorisation of VDN is not necessary in order to be able to extract decentralised policies that are fully consistent with their centralised counterpart. Instead, for consistency we only need to ensure that a global  performed on  yields the same result as a set of individual  operations performed on each :

This allows each agent  to participate in a decentralised execution solely by choosing greedy actions with respect to its . As a side effect, if \eqref{eq:argmax_constist} is satisfied, then taking the  of , required by off-policy learning updates, is trivially tractable. 

VDN's representation is sufficient to satisfy \eqref{eq:argmax_constist}. However, QMIX is based on the observation that this representation can be generalised to the larger family of monotonic functions that are also sufficient but not necessary to satisfy \eqref{eq:argmax_constist}.   
Monotonicity can be enforced through a constraint on the relationship between  and each :

To enforce \eqref{eq:deriv-constr}, QMIX represents  using an architecture consisting of \textit{agent networks}, a \textit{mixing network}, and a set of \emph{hypernetworks} \cite{ha_hypernetworks_2016}. Figure \ref{fig:QMIX} illustrates the overall setup. 

For each agent , there is one agent network that represents its individual value function . We represent agent networks as DRQNs that receive the current individual observation  and the last action  as input at each time step, as shown in Figure \ref{fig:QMIX}c. 

The mixing network is a feed-forward neural network that takes the agent network outputs as input and mixes them monotonically, producing the values of , as shown in Figure \ref{fig:QMIX}a. To enforce the monotonicity constraint of \eqref{eq:deriv-constr}, the weights (but not the biases) of the mixing network are restricted to be non-negative. This allows the mixing network to approximate any monotonic function arbitrarily closely \citep{Dugas_2009}.


The weights of the mixing network are produced by separate hypernetworks. Each hypernetwork takes the state  as input and generates the weights of one layer of the mixing network. Each hypernetwork consists of a single linear layer, followed by an absolute activation function, to ensure that the mixing network weights are non-negative. The output of the hypernetwork is then a vector, which is reshaped into a matrix of appropriate size. The biases are produced in the same manner but are not restricted to being non-negative. The final bias is produced by a 2 layer hypernetwork with a ReLU non-linearity. Figure \ref{fig:QMIX}a illustrates the mixing network and the hypernetworks.

The state is used by the hypernetworks rather than being passed directly into the mixing network because  is allowed to depend on the extra state 
information in non-monotonic ways. Thus, it would be overly constraining to pass some function of  through the monotonic network alongside the 
per-agent values.
Instead, the use of hypernetworks makes it possible to condition the 
weights of the monotonic network on  in an arbitrary way, thus 
integrating the full state  into the joint action-value estimates as 
flexibly as possible.


QMIX is trained end-to-end to minimise the following loss:
 
where  is the batch size of transitions sampled from the replay buffer,  and  are the parameters of a target network as in DQN. 
\eqref{eq:qmix_loss} is analogous to the standard DQN loss of \eqref{eq:dqn}. Since \eqref{eq:argmax_constist} holds, we can perform the maximisation of  in time linear in the number of agents (as opposed to scaling exponentially in the worst case). 

\subsection{Representational Complexity}

The value function class representable with QMIX includes any value function that can be factored into a non-linear monotonic combination of the agents' individual value functions in the fully observable setting. 
This expands upon the linear monotonic value functions that are representable by VDN. 
However, the constraint in \eqref{eq:deriv-constr} prevents QMIX from representing value functions that do not factorise in such a manner. 




Intuitively, any value function for which an agent's best action depends on the actions of the other agents \emph{at the same time step} will not factorise appropriately, and hence cannot be represented perfectly by QMIX. However, QMIX can approximate such value functions more accurately than VDN. Furthermore, it can take advantage of the extra state information available during training, which we show empirically. A more detailed discussion on the representation complexity is available in the supplementary materials.


 \section{Two-Step Game}
\label{sec:two_step_game}


To illustrate the effects of representational complexity of VDN and QMIX, we devise a simple two-step cooperative matrix game for two agents. 

At the first step, Agent  chooses which of the two matrix games to play in the next timestep. For the first time step, the actions of Agent  have no effect. In the second step, both agents choose an action and receive a global reward according to the payoff matrices depicted in Table \ref{tab:2step_game}.

We train VDN and QMIX on this task for  episodes and examine the final learned value functions in the limit of full exploration (). Full exploration ensures that each method is guaranteed to eventually explore all available game states, such that the representational capacity of the state-action value function approximation remains the only limitation.
The full details of the architecture and hyperparameters used are provided in the supplementary material.


\begin{table}
	\setlength{\extrarowheight}{3pt}
	\centering
	\begin{tabular}{cc|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
		& \multicolumn{1}{c}{} & \multicolumn{2}{c}{\bb{Agent }} \\
		& \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ 
		\cline{3-4}
        \multirow{2}{*}{\rotatebox[origin=c]{90}{\cc{Agent }}} & \cc{} & 7 & 7 \\ \cline{3-4}
        & \cc{} & 7 & 7  \\\cline{3-4}
        & \multicolumn{1}{c}{}  & \multicolumn{2}{c}{State A} \\
    \end {tabular}~~~~~~~
    \begin{tabular}{cc|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
    	& \multicolumn{1}{c}{} & \multicolumn{2}{c}{\bb{Agent }} \\
        & \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ 
        \cline{3-4}
		\multirow{2}{*}{\rotatebox[origin=c]{90}{\cc{Agent }}} & \cc{} & 0 & 1 \\ \cline{3-4}
		& \cc{} & 1 & 8  \\\cline{3-4}
		& \multicolumn{1}{c}{} & \multicolumn{2}{c}{State B} \\
	\end{tabular}
    \caption{Payoff matrices of the two-step game after the Agent 1 chose the first action. Action A takes the agents to State A and action B takes them to State B.}
    \label{tab:2step_game}
\end{table}


\begin{table}[h]
	\setlength{\extrarowheight}{3pt}
	\centering
	(a)
	\begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{1}{c}{} & \multicolumn{2}{c}{State } \\
		\multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
		\cc{} & 6.94 & 6.94 \\ \cline{2-3}
		\cc{} & 6.35 & 6.36  \\\cline{2-3}
	\end{tabular}~
	\begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{2}{c}{State A} \\
		\multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
		6.99 & 7.02 \\\cline{1-2}
		6.99 & 7.02  \\\cline{1-2}
	\end{tabular}~
	\begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{2}{c}{State B} \\
		\multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
		\text{-1.87} & 2.31 \\\cline{1-2}
		2.33 & 6.51  \\\cline{1-2}
	\end{tabular}\\\bigskip

	(b)
	\begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
		\cc{} & 6.93 & 6.93  \\ \cline{2-3}
		\cc{} & 7.92 & 7.92  \\\cline{2-3}
	\end{tabular}~
	\begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
		7.00 & 7.00 \\ \cline{1-2}
		7.00 & 7.00  \\\cline{1-2}
	\end{tabular}~
	\begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.08\linewidth}|}}
		\multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
		0.00 & 1.00 \\\cline{1-2}
		1.00 & 8.00 \\\cline{1-2}
	\end{tabular}\\
    \caption{ on the two-step game for (a) VDN and (b) QMIX.}
    \label{qmix_2step_game_main}
\end{table}

Table \ref{qmix_2step_game_main}, which shows the learned values for , demonstrates that QMIX's higher representational capacity allows it to accurately represent the joint-action value function whereas VDN cannot. This directly translates into VDN learning the suboptimal strategy of selecting Action A at the first step and receiving a reward of 7, whereas QMIX recovers the optimal strategy from its learnt joint-action values and receives a reward of 8. 

\begin{figure*}[htb!]
    \centering
    \includegraphics[height=0.3cm]{figures/plots/base_legend}
    \vfill
    \subfigure[3m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3m_3m/base}
    }
    \subfigure[5m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/5m_5m/base}
    }
    \subfigure[8m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/8m_8m/base}
    }
    \\
    \subfigure[2s\_3z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/2d_3z/base}
    }
    \subfigure[3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3d_5z/base}
    }
    \subfigure[1c\_3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/1c_3s_5z/base}
    }
    \caption{Win rates for IQL, VDN, and QMIX on six different combat maps. The performance of the heuristic-based algorithm is shown as a dashed line.}
    \label{fig:starcraft_res}
\end{figure*}

\section{Experimental Setup}
\label{sec:setting}

In this section, we describe the decentralised StarCraft II micromanagement problems to which we apply QMIX and the ablations we consider.

\subsection{Decentralised StarCraft II Micromanagement} 
Real-time strategy (RTS) games have recently emerged as challenging benchmarks for the RL community. 
StarCraft, in particular, offers a great opportunity to tackle competitive and cooperative multi-agent problems.
Units in StarCraft have a rich set of complex micro-actions that allow the learning of complex interactions between collaborating agents. 
Previous work \cite{usunier_episodic_2016, foerster_counterfactual_2017, peng_multiagent_2017} applied RL to the original version of StarCraft: BW, which made use of the standard API or related wrappers \cite{synnaeve_torchcraft_2016}. 
We perform our experiments on the StarCraft II Learning Environment (SC2LE) \cite{vinyals_starcraft_2017}, which is based on the second version of the game. 
Because it is supported by the developers of the game, SC2LE mitigates many of the practical difficulties in using StarCraft as an RL platform, such as the dependence on complicated APIs and external emulation software.

In this work, we focus on the \textit{decentralised micromanagement} problem in StarCraft II, in which each of the learning agents controls an individual army unit. 
We consider combat scenarios where two groups of identical units are placed symmetrically on the map. 
The units of the first, allied, group are controlled by the decentralised agents.  
The enemy units are controlled by a built-in StarCraft II AI, which makes use of handcrafted heuristics. 
The initial placement of units within the groups varies across episodes.  
The difficulty of the computer AI controlling the enemy units is set to \texttt{medium}.
At the beginning of each episode, the enemy units are ordered to attack the allies.
We compare our results on a set of maps where each unit group consists of 3 Marines (3m), 5 Marines (5m), 8 Marines (8m), 2 Stalkers and 3 Zealots (2s\_3z), 3 Stalkers and 5 Zealots (3s\_5z), or 1 Colossus, 3 Stalkers and 5 Zealots (1c\_3s\_5z).

Similar to the work of \citet{foerster_counterfactual_2017}, the action space of agents consists of the following set of discrete actions: \texttt{move[direction]}, \texttt{attack[enemy\_id]}, \texttt{stop}, and
\texttt{noop}. 
Agents can only move in four directions: north, south, east, or west.
A unit is allowed to perform the \texttt{attack[enemy\_id]} action only if the 
enemy is within its \textit{shooting range}. 
This facilitates the decentralisation of the problem and prohibits the usage of the \emph{attack-move} macro-actions that are integrated into the game. 
Furthermore, we disable the following unit behaviour when idle: responding to enemy fire and attacking enemies if they are in range. 
By doing so, we force the agents to explore in order to find the optimal combat strategy themselves, rather than relying on built-in StarCraft II utilities.

Partial observability is achieved by the introduction of unit \textit{sight range}, which restricts the agents from receiving information about allied or enemy units that are out of range. 
Moreover, agents can only observe others if they are alive and cannot distinguish between units that are dead or out of range.



At each time step, the agents receive a joint reward equal to the total damage dealt on the enemy units. 
In addition, agents receive a bonus of  points after killing each opponent, and  points after killing all opponents. These rewards are all normalised to ensure the maximum cumulative reward achievable in an episode is .

The full details of the environmental setup, architecture and training are available in the supplementary material.
 





\subsection{Ablations} 
\label{sub:abl}

We perform ablation experiments in order to investigate the influence of the inclusion of extra state information and the necessity of non-linear transformations in the mixing network. 

First, we analyse the significance of extra state information on the mixing network by comparing against QMIX without hypernetworks. Thus, the weights and biases of the mixing network are learned in the standard way, without conditioning on the state. We refer to this method as QMIX-NS. We take the absolute value of the weights in order to enforce the monotonicity constraint.

Second, we investigate the necessity of non-linear mixing by removing the hidden layer of the mixing network. This method can be thought of as an extension of VDN that uses the state  to perform a weighted sum over  values. We call this method QMIX-Lin.

Third, we investigate the significance of utilising the state  in comparison to the non-linear mixing. To do this we extend VDN by adding a state-dependent term to the sum of the agent's -Values. This state-dependent term is produced by a network with a single hidden layer of  units and a ReLU non-linearity, taking in the state  as input (the same as the hypernetwork producing the final bias in QMIX). We refer to this method as VDN-S.

We also show the performance of a non-learning heuristic-based algorithm with full observability, where each agent attacks the closest enemy and continues attacking the same target until the unit dies. Afterwards, the agent starts attacking the nearest enemy and so forth. 



 \section{Results}
\label{sec:results}

\begin{figure*}[htb!]
    \centering
    \includegraphics[height=0.3cm]{figures/plots/ablations_legend}
    \vfill
    \subfigure[3m]{
        \includegraphics[width=0.31\textwidth]{figures/plots/3m_3m/ablations_vdns}
    }
    \subfigure[2s\_3z]{
        \includegraphics[width=0.31\textwidth]{figures/plots/2d_3z/ablations_vdns}
    }
    \subfigure[3s\_5z]{
        \includegraphics[width=0.31\textwidth]{figures/plots/3d_5z/ablations_vdns}
    }
    \caption{Win rates for QMIX and ablations on 3m, 2s\_3z and 3s\_5z maps.}
    \label{fig:starcraft_ablations}
\end{figure*}




In order to evaluate each method's performance, we adopt the following evaluation procedure: for each run of a method, we pause training every 100 episodes and run 20 independent episodes with each agent performing greedy decentralised action selection. The percentage of these episodes in which the method defeats all enemy units within the time limit is referred to as the \emph{test win rate}. 

Figures \ref{fig:starcraft_res} and \ref{fig:starcraft_ablations} plot the mean test win rate across 20 runs for each method on selected maps, together with 95 confidence intervals. The graphs for all methods on all maps are available in the supplementary material.

\subsection{Main Results}
In all scenarios, IQL fails to learn a policy that consistently defeats the enemy. In addition, the training is highly unstable due to the non-stationarity of the environment which arises due to the other agents changing their behaviour during training. 

The benefits of learning the joint action-value function can be demonstrated by VDN's superior performance over IQL in all scenarios. VDN is able to more consistently learn basic coordinated behaviour, in the form of \textit{focus firing} which allows it to win the majority of its encounters on the 5m and 8m maps. On the 8m map, this simple strategy is sufficient for good performance, as evidenced by the extremely high win rate of the heuristic-based algorithm, and explains the performance parity with QMIX. However, on the 3m task, which requires more fine-grained control, it is unable to learn to consistently defeat the enemy.

QMIX is noticeably the strongest performer on all of the maps, in particular on the maps with hetergenous agent types. The largest performance gap can be seen in the 3s\_5z and 1c\_3s\_5z maps, where VDN is unable to reach the performance of the simple heuristic. The superior representational capacity of QMIX combined with the state information presents a clear benefit over a more restricted linear decomposition. 

\subsection{Ablation Results}

Our additional ablation experiments reveal that QMIX outperforms, or is competitive with, all of its ablations discussed in Section \ref{sub:abl}. Figure \ref{fig:starcraft_ablations}a shows that non-linear value function factorisation is not always required on a map with homogeneous agent types. However, the additional complexity introduced through the extra hidden layer does not slow down learning. In contrast, Figures \ref{fig:starcraft_ablations}b and \ref{fig:starcraft_ablations}c show that on a map with heterogeneous agent types a combination of both central state information and non-linear value function factorisation is required to achieve good performance. QMIX-NS performs on par or slightly better than VDN in both scenarios, which suggests that a non-linear decomposition is not always beneficial when not conditioning on the central state in complex scenarios. Additionally, the performance of VDN-S compared to QMIX-Lin shows the necessity of allowing a non-linear mixing in order to fully leverage central state information.



\subsection{Learned Policies}

We examine the learned behaviours of the policies in order to better understand the differences between the strategies learnt by the different methods. 
On the 8m scenario, both QMIX and VDN learn the particularly sophisticated strategy of first positioning the units into a semicircle in order to fire at the incoming enemy units from the sides (as opposed to just head on).
On the 2s\_3z scenario, VDN first runs left and then attacks the enemy once they are in range with no regards to positioning or unit match-ups. QMIX, on the other hand learns to position the Stalkers so that the enemy Zealots cannot attack them. This is especially important since Zealots \emph{counter} Stalkers. QMIX achieves this by having the allied Zealots first block off and then attack the enemy Zealots (whilst the Stalkers fire from a safe distance), before moving on to the enemy Stalkers. The same behaviour is observed in the 3s\_5z scenario for QMIX. VDN-S does not learn to protect the Stalkers from the Zealots, and first positions the units around their starting location and then attacks the enemy as they move in.

The initial hump in the performance of both VDN and IQL is due to both methods initially learning the simple strategy of just attacking the first visible enemy (which is quite successful as shown by the heuristic). However, due to exploratory learning behaviour, they also attempt to move around (instead of just firing), which results in the rapid decline in performance. IQL is unable to then recover the initial strategy, whereas VDN  learns how to combine small movements and firing together. \section{Conclusion}

This paper presented QMIX, a deep multi-agent RL method that allows end-to-end learning of decentralised policies in a centralised setting and makes efficient use of extra state information. QMIX allows the learning of a rich joint action-value function, which admits tractable decompositions into per-agent action-value functions. This is achieved by imposing a monotonicity constraint on the mixing network.

Our results in decentralised unit micromanagement tasks in StarCraft II show that QMIX improves the final performance over other value-based multi-agent methods that employ less sophisticated joint state-value function factorisation, as well as independent -learning. 

In the near future, we aim to conduct additional experiments to compare the methods across tasks with a larger number and greater diversity of units. In the longer term, we aim to complement QMIX with more coordinated exploration schemes for settings with many learning agents. 
\section*{Acknowledgements} 

This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement number 637713). 
It was also supported by the Oxford-Google DeepMind Graduate Scholarship, the UK EPSRC CDT in Autonomous Intelligent Machines and Systems, Chevening Scholarship, Luys Scholarship and an EPSRC grant (EP/M508111/1, EP/N509711/1). This work is linked to and partly funded by the project Free the Drones (FreeD) under the Innovation Fund Denmark and Microsoft. The experiments were made possible by a generous equipment grant from NVIDIA.

We would like to thank Frans Oliehoek and Wendelin Boehmer for helpful comments and discussion. 
We also thank Oriol Vinyals, Kevin Calderone, and the rest of the SC2LE team at DeepMind and Blizzard for their work on the interface.

 



\bibliography{final}
\bibliographystyle{include/icml2018}

\onecolumn
\newpage
\appendix
\section{QMIX}

\subsection{Representational Complexity}

The value function class representable with QMIX includes any value function that can be factored into a non-linear monotonic combination of the agents' individual value functions in the fully observable setting. 

This follows since the mixing network is a universal function approximator of monotonic functions \cite{Dugas_2009}, and hence can represent any value function that factors into a non-linear monotonic combination of the agent's individual value functions. Additionally, we require that the agent's individual value functions order the values of the actions appropriately. By this we mean that  is such that , i.e., they can represent a function that respects the ordering of the agent's actions in the joint-action value function. Since the agents' networks are universal function approximators \cite{pinkus1999approximation}, they can represent such a . Hence QMIX is able to represent any value function that factors into a non-linear monotonic combination of the agent's individual value functions. 

In a Dec-POMDP, QMIX cannot necessarily represent the value function. This is because each agent's observations are no longer the full state, and thus they might not be able to distinguish the true state given their local observations. If the agent's value function ordering is then wrong, i.e.,  when , then the mixing network would be unable to correctly represent  given the monotonicity constraints. 

QMIX expands upon the linear monotonic value functions that are representable by VDN. Table \ref{table_matrix_examples}a gives an example of a monotonic value function for the simple case of a two-agent matrix game. Note that VDN is unable to represent this simple monotonic value function.

\begin{table}[h]
    \centering
    \setlength{\extrarowheight}{3pt}
    \begin{tabular}{cc|*{2}{>{\centering\arraybackslash}p{.025\linewidth}|}}
        & \multicolumn{1}{c}{} & \multicolumn{2}{c}{Agent } \\
        & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{3-4} 
        \multirow{2}{*}{\rotatebox[origin=c]{90}{Agent }}  &  & 0 & 1 \\ \cline{3-4}
        &  & 1 & 8  \\\cline{3-4}
        & \multicolumn{1}{c}{} & \multicolumn{2}{c}{(a)} \\
    \end{tabular}~~~~~~~
    \begin{tabular}{cc|*{2}{>{\centering\arraybackslash}p{.025\linewidth}|}}
        & \multicolumn{1}{c}{} & \multicolumn{2}{c}{Agent } \\
        & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{3-4}
        \multirow{2}{*}{\rotatebox[origin=c]{90}{Agent }}  &  & 2 & 1 \\ \cline{3-4}
        &  & 1 & 8  \\\cline{3-4}
        & \multicolumn{1}{c}{} & \multicolumn{2}{c}{(b)} \\
    \end{tabular}
    \caption{(a) An example of a monotonic payoff matrix, (b) a non-monotonic payoff matrix.}
    \label{table_matrix_examples}
\end{table}

However, the constraint in \eqref{eq:deriv-constr} prevents QMIX from representing value functions that do not factorise in such a manner. A simple example of such a value function for a two-agent matrix game is given in Table \ref{table_matrix_examples}b. Intuitively, any value function for which an agent's best action depends on the actions of the other agents \emph{at the same time step} will not factorise appropriately, and hence cannot be represented perfectly by QMIX.  \section{Two Step Game}

\subsection{Architecture and Training}

The architecture of all agent networks is a DQN with a single hidden layer comprised of  units with a ReLU nonlinearity. Each agent performs independent  greedy action selection, with . We set . The replay buffer consists of the last 500 episodes, from which we uniformly sample a batch of size 32 for training. The target network is updated every 100 episodes. The learning rate for RMSprop is set to . We train for  timesteps. The size of the mixing network is  units. All agent networks share parameters, thus the agent id is concatenated onto each agent's observations. We do not pass the last action taken to the agent as input. Each agent receives the full state as input.

Each state is one-hot encoded. The starting state for the first timestep is State . If Agent  takes Action A, it transitions to State  (whose payoff matrix is all s). If agent  takes Action B in the first timestep, it transitions to State . 

\subsection{Learned Value Functions}

The learned value functions for the different methods on the Two Step Game are shown in Tables \ref{qmix_2step_game_all} and \ref{tab:iql_qvals}. 

\begin{table}[h]
    \setlength{\extrarowheight}{3pt}{}
    \centering
    (a)
    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{2}{c}{State } \\
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
        \cc{} & 6.94 & 6.94 \\ \cline{2-3}
        \cc{} & 6.35 & 6.36  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{2}{c}{State A} \\
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
        6.99 & 7.02 \\\cline{1-2}
        6.99 & 7.02  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{2}{c}{State B} \\
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
        \text{-1.87} & 2.31 \\\cline{1-2}
        2.33 & 6.51  \\\cline{1-2}
    \end{tabular}\\\bigskip

    (b)
    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
        \cc{} & 6.93 & 6.93  \\ \cline{2-3}
        \cc{} & 7.92 & 7.92  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
        7.00 & 7.00 \\ \cline{1-2}
        7.00 & 7.00  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
        0.00 & 1.00 \\\cline{1-2}
        1.00 & 8.00 \\\cline{1-2}
    \end{tabular}\\\bigskip

    (c)
    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
        \cc{} & 6.94 & 6.93  \\ \cline{2-3}
        \cc{} & 7.93 & 7.92  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
        7.03 & 7.02 \\ \cline{1-2}
        7.02 & 7.01  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
        0.00 & 1.01 \\\cline{1-2}
        1.01 & 8.02 \\\cline{1-2}
    \end{tabular}\\\bigskip

    (d)
    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
        \cc{} & 6.98 & 6.97  \\ \cline{2-3}
        \cc{} & 6.37 & 6.36  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
        7.01 & 7.02 \\ \cline{1-2}
        7.02 & 7.04  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
        -1.39 & 2.57 \\\cline{1-2}
        2.67 & 6.58 \\\cline{1-2}
    \end{tabular}\\\bigskip

    (e)
    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{2-3}
        \cc{} & 6.95 & 6.99  \\ \cline{2-3}
        \cc{} & 6.18 & 6.22  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\ \cline{1-2}
        6.99 & 7.06 \\ \cline{1-2}
        7.01 & 7.09  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{\bb{}}  & \multicolumn{1}{c}{\bb{}} \\\cline{1-2}
        -1.21 & 2.73 \\\cline{1-2}
        2.46 & 6.40 \\\cline{1-2}
    \end{tabular}\\\bigskip

    \caption{ on the 2 step game for (a) VDN, (b) QMIX, (c) QMIX-NS, (d) QMIX-Lin and (e) VDN-S}
    \label{qmix_2step_game_all}
\end{table}

\begin{table}[h]
    \setlength{\extrarowheight}{3pt}
    \centering

    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{2-3}
        Agent  & 6.96 & 4.47  \\ \cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{1-2}
        6.98 & 7.00 \\ \cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\\cline{1-2}
        0.50 & 4.50 \\\cline{1-2}
    \end{tabular}\\\bigskip

    \begin{tabular}{c|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{2-3}
        Agent  & 5.70 & 5.78  \\\cline{2-3}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\ \cline{1-2}
        7.00 & 7.02  \\\cline{1-2}
    \end{tabular}~
    \begin{tabular}{|*{2}{>{\centering\arraybackslash}p{.05\linewidth}|}}
        \multicolumn{1}{c}{}  & \multicolumn{1}{c}{} \\\cline{1-2}
        0.50 & 4.47 \\\cline{1-2}
    \end{tabular}

    \caption{ for IQL on the 2 step game}
    \label{tab:iql_qvals}
\end{table}

\subsection{Results}

Figure \ref{fig:two_step_loss} shows the loss for the different methods. Table \ref{table:final_test_two_step} shows the final testing reward for each method.

\begin{figure*}[htb!]
    \centering
    \includegraphics[width=0.39\textwidth]{figures/plots/2stepgame/2stepgame_loss}
    \caption{Loss for all six methods on the Two Step Game. The mean and 95\% confidence interval is shown across 30 independent runs.}
    \label{fig:two_step_loss}
\end{figure*}

\begin{table}[h]
	\setlength{\extrarowheight}{3pt}
	\centering
    \begin{center}
        \begin{tabular}{|c| c | c | c | c | c |}
        \hline
        \textbf{IQL} & \textbf{VDN} & \textbf{VDN-S} & \textbf{QMIX} & \textbf{QMIX-Lin} & \textbf{QMIX-NS} \\
        \hline
        7 & 7 & 7 & 8 & 7 & 8 \\
        \hline
        \end{tabular}
    \end{center}
    \caption{The final Test Reward acheived.}
    \label{table:final_test_two_step}
\end{table}
 \section{StarCraft II Setup}

\subsection{Environment Features}
The local observations of individual agents are drawn within their field of view, which encompasses the circular area of the map surrounding units and has a radius equal to the sight range. Each agent receives as input a vector consisting of the following features for all units in its field of view (both allied and enemy): \texttt{distance}, \texttt{relative x}, \texttt{relative y} and \texttt{unit\_type}.\footnote{\texttt{unit\_type} is only included in the 2s\_3z, 3s\_5z and 1c\_3s\_5z maps.} 

The global state, which is hidden from agents, is a vector comprised of features of units from the entire map. It does not contain the absolute distances between agents and stores only the coordinates of units relative to the centre of the map. In addition, the global state includes the \texttt{health}, \texttt{shield} and \texttt{cooldown} of all units.\footnote{A unit's \texttt{cooldown} is the time it must wait before firing again. Shields act as additional forms of hit points and are lost first. In contrast to health, shields regenerate over time after absorbing damage.} In addition, the global state contains the last actions taken by all allied agents. Marines, Stalkers, Zealots, and Colossi have , , , and  hit points, respectively. In addition, Stalkers, Zealots, and Colossi have , , and  shield points, respectively. All features, whether in local observations or global state, are normalised by their maximum values. For all unit types, the agent sight range and shooting ranges are set to 9 and 6, respectively.


\subsection{Architecture and Training}

The architecture of all agent networks is a DRQN with a recurrent layer 
comprised of a GRU with a 64-dimensional hidden state, with a fully-connected 
layer before and after.
Exploration is performed during training using independent -greedy action selection, where each agent  performs -greedy action selection over its own . 
Throughout the training, we anneal  linearly from  to  over  time steps and keep it constant for the rest of the learning. 
We set  for all experiments.
The replay buffer contains the most recent  episodes.  
We sample batches of 32 episodes uniformly from the replay buffer and train on fully unrolled episodes.
The target networks are updated after every  training episodes.

To speed up the learning, we share the parameters of the agent networks across all agents. 
Because of this, a one-hot encoding of the \texttt{agent\_id} is concatenated onto each agent's observations. 
All neural networks are trained using RMSprop\footnote{We set  and do not use weight decay or momentum.} with learning rate . 

During training and testing, we restrict each episode to have a length of  time steps for 3m and 5m maps,  time steps for 8m and 2s\_3z maps,  for 3s\_5z and  for 1c\_3s\_5z. If both armies are alive at the end of the episode, we count it as a loss. The episode terminates after one army has been defeated, or the time limit has been reached. 

The mixing network consists of a single hidden layer of  units, utilising an ELU non-linearity. The hypernetworks are then sized to produce weights of appropriate size. The hypernetwork producing the final bias of the mixing network consists of a single hidden layer of  units with a ReLU non-linearity.
 \section{StarCraft II Results}

The results for all six methods and the heuristic-based algorithm on the six maps.

\begin{table}[h]
	\setlength{\extrarowheight}{3pt}
	\centering
    \begin{center}
        \begin{tabular}{| c | c | c | c | c | c |}
        \hline
        \textbf{3m} & \textbf{5m} & \textbf{8m} & \textbf{2s\_3z} & \textbf{3s\_5z} & \textbf{1c\_3s\_5z} \\
        \hline
        76 & 60 & 95 & 82 & 45 & 70 \\ 
        \hline
        \end{tabular}
    \end{center}
    \caption{The Test Win Rate \% of the heuristic-based algorithm on the six maps.}
\end{table}

\begin{figure*}[htb!]
    \centering
    \includegraphics[height=0.4cm]{figures/plots/base_legend}
    \vfill
    \subfigure[3m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3m_3m/base}
    }
    \subfigure[5m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/5m_5m/base}
    }
    \subfigure[8m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/8m_8m/base}
    }
    \\
    \subfigure[2s\_3z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/2d_3z/base}
    }
    \subfigure[3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3d_5z/base}
    }
    \subfigure[1c\_3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/1c_3s_5z/base}
    }
    \caption{Win rates for IQL, VDN, and QMIX on six different combat maps. The performance of the heuristic-based algorithm is shown as a dashed line.}
\end{figure*}

\begin{figure*}[htb!]
    \centering
    \includegraphics[height=0.4cm]{figures/plots/ablations_legend}
    \vfill
    \subfigure[3m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3m_3m/ablations_vdns}
    }
    \subfigure[5m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/5m_5m/ablations_vdns}
    }
    \subfigure[8m]{
        \includegraphics[width=0.315\textwidth]{figures/plots/8m_8m/ablations_vdns}
    }
    \\
    \subfigure[2s\_3z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/2d_3z/ablations_vdns}
    }
    \subfigure[3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/3d_5z/ablations_vdns}
    }
    \subfigure[1c\_3s\_5z]{
        \includegraphics[width=0.315\textwidth]{figures/plots/1c_3s_5z/ablations_vdns}
    }
    \caption{Win rates for QMIX and ablations on six different combat maps. The performance of the heuristic-based algorithm is shown as a dashed line.}
\end{figure*}




\end{document}
