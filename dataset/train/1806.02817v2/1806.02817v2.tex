\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}


\usepackage[final]{neurips_2018}

\pdfoutput=1








\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsmath}
\usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{bm}
\usepackage{varwidth}
\usepackage[toc,page]{appendix} 

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}



\title{Probabilistic Model-Agnostic Meta-Learning}



\author{
  Chelsea Finn\thanks{First two authors contributed equally.}~, Kelvin Xu\!, Sergey Levine \\
  UC Berkeley\\
  \texttt{\{cbfinn,kelvinxu,svlevine\}@eecs.berkeley.edu} \\
}

\begin{document}


\maketitle

\begin{abstract}
Meta-learning for few-shot learning entails acquiring a prior over previous tasks and experiences, such that new tasks be learned from small amounts of data. However, a critical challenge in few-shot learning is task ambiguity: even when a powerful prior can be meta-learned from a large number of prior tasks, a small dataset for a new task can simply be too ambiguous to acquire a single model (e.g., a classifier) for that task that is accurate. In this paper, we propose a probabilistic meta-learning algorithm that can sample models for a new task from a model distribution. Our approach extends model-agnostic meta-learning, which adapts to new tasks via gradient descent, to incorporate a parameter distribution that is trained via a variational lower bound. At meta-test time, our algorithm adapts via a simple procedure that injects noise into gradient descent, and at meta-training time, the model is trained such that this stochastic adaptation procedure produces samples from the approximate model posterior. Our experimental results show that our method can sample plausible classifiers and regressors in ambiguous few-shot learning problems. We also show how reasoning about ambiguity can also be used for downstream active learning problems.
\end{abstract}

\newcommand{\cmt}[1]{{\footnotesize\textcolor{red}{#1}}}
\newcommand{\note}[1]{\cmt{Note: #1}}
\newcommand{\todo}[1]{\cmt{TO-DO: #1}}
\newcommand{\sergey}[1]{\cmt{Sergey: #1}}
\newcommand{\chelsea}[1]{\cmt{Chelsea: #1}}
\newcommand{\kelvin}[1]{\cmt{Kelvin: #1}}
\newcommand{\review}[1]{\noindent\textcolor{red}{ #1}}
\newcommand{\response}[1]{\noindent{#1}}

\newcommand{\diff}[1]{\textcolor{red}{#1}}

\long\def\ignorethis#1{}

\newcommand{\data}{\mathcal{D}}
\newcommand{\task}{\mathcal{T}}

\newcommand{\etal}{{et~al.}\ }
\newcommand{\eg}{e.g.\ }
\newcommand{\ie}{i.e.\ }
\newcommand{\nth}{\text{th}}
\newcommand{\pr}{^\prime}
\newcommand{\tr}{^\mathrm{T}}
\newcommand{\inv}{^{-1}}
\newcommand{\pinv}{^{\dagger}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\gauss}{\mathcal{N}}
\newcommand{\norm}[1]{\left|#1\right|}
\newcommand{\trace}{\text{tr}}
\newcommand{\expectation}[2]{\mathbb{E}_{#1}\left[ #2 \right]}

\newcommand{\figtodo}[1]{\framebox[0.8\columnwidth]{\rule{0pt}{1in}#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}

\newcommand{\secpaperlin}{5.1}
\newcommand{\eqnpapergradmul}{3}
\newcommand{\eqnpapergrads}{4}
\newcommand{\applinhess}{A}
\newcommand{\applqr}{B}
\newcommand{\appfastgrad}{C}

\newcommand{\vnorm}[1]{\|#1\|}
\newcommand{\lscnorm}[1]{\ell_{12}(#1)}
\newcommand{\costnorm}{r_\ell}

\newcommand{\badmmtraj}{\phi^{\trajdist}}
\newcommand{\badmmpol}{\phi^{\params}}
\newcommand{\lagtraj}{\mathcal{L}_{\trajdist}}
\newcommand{\lagpol}{\mathcal{L}_{\params}}

\newcommand{\energy}{\mathcal{E}}

\newcommand{\admmrate}{\alpha}
\newcommand{\cluster}{c}
\newcommand{\dualstep}{\eta}
\newcommand{\polwt}{\lambda}
\newcommand{\lgmult}{\lambda}
\newcommand{\lgmultt}{\lambda_t}
\newcommand{\lgmu}{\lambda_\mu}
\newcommand{\lgmut}{\lambda_{\mu t}}
\newcommand{\admmrho}{\nu}
\newcommand{\lagrangian}{\mathcal{L}_{\text{traj}}}
\newcommand{\lagrangiangps}{\mathcal{L}_{\text{GPS}}}
\newcommand{\trajdist}{p}
\newcommand{\policy}{\pi}
\newcommand{\policytraj}{\pi_{\traj}}
\newcommand{\return}{J}
\newcommand{\params}{\theta}
\newcommand{\reward}{R}
\newcommand{\cost}{\ell}
\newcommand{\state}{\mathbf{x}}
\newcommand{\action}{\mathbf{a}}
\newcommand{\obs}{\mathbf{o}}
\newcommand{\opt}{\mathcal{R}}
\newcommand{\hstate}{\hat{\mathbf{x}}}
\newcommand{\haction}{\hat{\mathbf{u}}}
\newcommand{\states}{\mathcal{X}}
\newcommand{\actions}{\mathcal{A}}
\newcommand{\traj}{\tau}
\newcommand{\covar}{\Sigma}
\newcommand{\trajmu}{\mu^\trajdist}
\newcommand{\trajmut}{\mu^\trajdist_t}
\newcommand{\polmu}{\mu^\policy}
\newcommand{\polsig}{\Sigma^\policy}
\newcommand{\polmut}{\mu^\policy_t}
\newcommand{\polmudiffavgt}{\hat{\mu}^\policy_t}
\newcommand{\polsigt}{\Sigma^\policy_t}
\newcommand{\polgrad}{\polmu_\state}
\newcommand{\polgradt}{\polmu_{\state t}}
\newcommand{\polgradavgt}{\hat{\mu}^\policy_{\state t}}
\newcommand{\ucovar}{\mathbf{C}}
\newcommand{\xcovar}{\mathbf{S}}
\newcommand{\ucovart}{\mathbf{C}_t}
\newcommand{\xcovart}{\mathbf{S}_t}
\newcommand{\hxcovart}{\hat{\mathbf{S}}_t}
\newcommand{\xcovartp}{\mathbf{S}_{t+1}}
\newcommand{\xucovar}{\Sigma}
\newcommand{\xucovart}{\Sigma_t}
\newcommand{\xcovarchol}{\mathbf{L}}
\newcommand{\xcovarcholt}{\xcovarchol_t}
\newcommand{\samp}{\mathbf{s}}
\newcommand{\sampti}{\samp_{ti}}
\newcommand{\sampdist}{q}
\newcommand{\obj}{\mathcal{L}}
\newcommand{\objut}{\obj_{\action t}}
\newcommand{\objuut}{\obj_{\action,\action t}}
\newcommand{\objxt}{\obj_{\state t}}
\newcommand{\objxxt}{\obj_{\state,\state t}}
\newcommand{\objucovart}{\obj_{\ucovar t}}
\newcommand{\objxcovart}{\obj_{\xcovar t}}
\newcommand{\objxcovartp}{\obj_{\xcovar t+1}}
\newcommand{\feedback}{\mathbf{K}}
\newcommand{\detpolicy}{g}
\newcommand{\wtreg}{w_r}
\newcommand{\velx}{v_x}
\newcommand{\posy}{p_y}
\newcommand{\pos}{\mathbf{p}}
\newcommand{\torquepen}{w_\action}
\newcommand{\pospen}{w_\pos}
\newcommand{\velpen}{w_v}
\newcommand{\heightpen}{w_h}
\newcommand{\all}{{1..T}}

\newcommand{\channel}{c}
\newcommand{\softmax}{\mathbf{s}}
\newcommand{\softmaxpix}{s_{cij}}
\newcommand{\responsemap}{\mathbf{a}}
\newcommand{\responsepix}{a_{cij}}
\newcommand{\responsepixprime}{a_{ci'j'}}

\newcommand{\innerterm}{\xi}

\newcommand{\second}{\text{s}}
\newcommand{\ms}{\text{m/s}}
\newcommand{\meter}{\text{m}}

\newcommand{\kl}{D_\text{KL}}
\newcommand{\tv}{D_\text{TV}}
\newcommand{\ent}{\mathcal{H}}
\newcommand{\rdist}{\rho}

\newcommand{\fc}{f_c}
\newcommand{\fx}{f_\state}
\newcommand{\fu}{f_\action}
\newcommand{\fct}{f_{c t}}
\newcommand{\fxt}{f_{\state t}}
\newcommand{\fut}{f_{\action t}}
\newcommand{\fy}{f_{\state\action}}
\newcommand{\fyt}{f_{\state\action t}}
\newcommand{\rx}{\reward_\state}
\newcommand{\ru}{\reward_\action}
\newcommand{\rxx}{\reward_{\state,\state}}
\newcommand{\ruu}{\reward_{\action,\action}}
\newcommand{\rux}{\reward_{\action,\state}}
\newcommand{\rxt}{\reward_{\state t}}
\newcommand{\rut}{\reward_{\action t}}
\newcommand{\rxxt}{\reward_{\state,\state t}}
\newcommand{\ruut}{\reward_{\action,\action t}}
\newcommand{\ruxt}{\reward_{\action,\state t}}
\newcommand{\Qx}{Q_\state}
\newcommand{\Qu}{Q_\action}
\newcommand{\Qy}{Q_{\state\action}}
\newcommand{\Qxx}{Q_{\state,\state}}
\newcommand{\Quu}{Q_{\action,\action}}
\newcommand{\Qux}{Q_{\action,\state}}
\newcommand{\Qxu}{Q_{\state,\action}}
\newcommand{\Qyy}{Q_{\state\action,\state\action}}
\newcommand{\Qxt}{Q_{\state t}}
\newcommand{\Qut}{Q_{\action t}}
\newcommand{\Qyt}{Q_{\state\action t}}
\newcommand{\Qxxt}{Q_{\state,\state t}}
\newcommand{\Quut}{Q_{\action,\action t}}
\newcommand{\Quxt}{Q_{\action,\state t}}
\newcommand{\Qxut}{Q_{\state,\action t}}
\newcommand{\Qyyt}{Q_{\state\action,\state\action t}}
\newcommand{\Vx}{V_\state}
\newcommand{\Vxx}{V_{\state,\state}}
\newcommand{\Vxt}{V_{\state t}}
\newcommand{\Vxxt}{V_{\state,\state t}}
\newcommand{\Vxtp}{V_{\state t+1}}
\newcommand{\Vxxtp}{V_{\state,\state t+1}}
\newcommand{\kpol}{\mathbf{k}}
\newcommand{\Kpol}{\mathbf{K}}
\newcommand{\passivedyn}{p}
\newcommand{\lmdp}{\mathcal{G}}
\newcommand{\samples}{\mathcal{S}}
\newcommand{\ft}{f_t}
\newcommand{\noise}{\mathbf{F}}
\newcommand{\siglinmatt}{\mathbf{M}}


\newcommand{\objKt}{\obj_{\Kpol t}}
\newcommand{\objKht}{\obj_{\hat{\Kpol} t}}
\newcommand{\polsampcovar}{\mathbf{C}_t}
\newcommand{\cholin}{\mathbf{D}_t}

\newcommand{\costgrad}{\cost_{\state\action}}
\newcommand{\costhess}{\cost_{\state\action,\state\action}}
\newcommand{\tcostgrad}{\tilde{\cost}_{\state\action}}
\newcommand{\tcosthess}{\tilde{\cost}_{\state\action,\state\action}}
\newcommand{\costxx}{\cost_{\state,\state}}
\newcommand{\costuu}{\cost_{\action,\action}}
\newcommand{\costxu}{\cost_{\state,\action}}
\newcommand{\costux}{\cost_{\action,\state}}
\newcommand{\costxxt}{\cost_{\state,\state t}}
\newcommand{\costuut}{\cost_{\action,\action t}}
\newcommand{\costxut}{\cost_{\state,\action t}}
\newcommand{\costuxt}{\cost_{\action,\state t}}
\newcommand{\costxt}{\cost_{\state t}}
\newcommand{\costut}{\cost_{\action t}}
\newcommand{\costgradu}{\cost_\action}
\newcommand{\costhessu}{\cost_{\action,\action}}

\newcommand{\costgradt}{\cost_{\state\action t}}
\newcommand{\costhesst}{\cost_{\state\action,\state\action t}}
\newcommand{\tcostgradt}{\tilde{\cost}_{\state\action t}}
\newcommand{\tcosthesst}{\tilde{\cost}_{\state\action,\state\action t}}
\newcommand{\costgradut}{\cost_{\action t}}
\newcommand{\costhessut}{\cost_{\action,\action t}}


\newcommand{\tcgradt}{\tilde{c}_{\state\action t}}
\newcommand{\tchesst}{\tilde{c}_{\state\action,\state\action t}}

\newcommand{\choldiff}{\text{choldiff}}

\newcommand{\st}{\state_t}
\newcommand{\at}{\action_t}
\newcommand{\ot}{\obs_t}
\newcommand{\sti}{\state_{ti}}
\newcommand{\ati}{\action_{ti}}
\newcommand{\sth}{\hstate_t}
\newcommand{\ath}{\haction_t}

\newcommand{\points}{\mathbf{p}}
\newcommand{\Cost}{\langle\ell\rangle}
\newcommand{\Penalty}{a}
\newcommand{\Rate}{b}

\newcommand{\empsig}{\hat{\Sigma}}
\newcommand{\empmu}{\hat{\mu}}
\newcommand{\empn}{N}
\newcommand{\priorphi}{\mathbf{\Phi}}
\newcommand{\priormu}{\mu_0}
\newcommand{\priormut}{\mu_{0t}}
\newcommand{\priorm}{m}
\newcommand{\priorn}{n_0}
\newcommand{\datapt}{\mathbf{p}}
\newcommand{\ddpdiscount}{\gamma}
\newcommand{\onlinediscount}{\beta}
\newcommand{\xxt}{\Delta}
\newcommand{\net}{\bar{f}}
\newcommand{\sigt}{\bar{\Sigma}_{\state\action,\state\action}}
\newcommand{\sigp}{\bar{\Sigma}_{\state\pr,\state\pr}}

\newcommand{\loss}{\mathcal{L}}
\newcommand{\target}{\mathbf{y}}
\newcommand{\inp}{\mathbf{x}}
\newcommand{\lossi}{\loss_{\task_i}}
\newcommand{\learner}{f}

\newcommand{\trainset}{\ytrain, \xtrain}
\newcommand{\metatrain}{\mathcal{D}^\text{tr}}
\newcommand{\metaval}{\mathcal{D}^\text{test}}


\newcommand{\ytrain}{\mathbf{y}^{\text{tr}}}
\newcommand{\xtrain}{\mathbf{x}^{\text{tr}}}
\newcommand{\ytest}{\mathbf{y}^{\text{test}}}
\newcommand{\xtest}{\mathbf{x}^{\text{test}}}
\newcommand{\priormean}{\bm{\mu}_\theta}
\newcommand{\priorvar}{\bm{\sigma}_\theta^2}\newcommand{\qvar}{\mathbf{v}_q}
\newcommand{\qmult}{\bm{\gamma}_q}
\newcommand{\pmult}{\bm{\gamma}_p}


\newcommand{\indep}{\rotatebox[origin=c]{90}{}}

\newcommand{\website}{https://sites.google.com/view/probabilistic-maml/} 
\vspace{-0.3cm}
\section{Introduction}
\label{sec:intro}
\vspace{-0.2cm}

Learning from a few examples is a key aspect of human intelligence. One way to make it possible to acquire solutions to complex tasks from only a few examples is to leverage past experience to learn a prior over tasks. The process of learning this prior entails discovering the shared structure across different tasks from the same family, such as commonly occurring visual features or semantic cues.
Structure is useful insofar as it yields efficient learning of new tasks -- a mechanism known as learning-to-learn, or meta-learning~\citep{structure_learning_in_action}.
However, when the end goal of few-shot meta-learning is to learn solutions to new tasks from small amounts of data, a critical issue that must be dealt with is task \emph{ambiguity}: even with the best possible prior, there might simply not be enough information in the examples for a new task to resolve that task with high certainty. It is therefore quite desireable to develop few-shot meta-learning methods that can propose multiple potential solutions to an ambiguous few-shot learning problem. Such a method could be used to evaluate uncertainty (by measuring agreement between the samples), perform active learning, or elicit direct human supervision about which sample is preferable. For example, in safety-critical applications, such as few-shot medical image classification, uncertainty is crucial for determining if the learned classifier should be trusted. When learning from such small amounts of data, uncertainty estimation can also help predict if additional data would be beneficial for learning and improving the estimate of the rewards. Finally, while we do not experiment with this in this paper, we expect that modeling this ambiguity will be helpful for reinforcement learning problems, where it can be used to aid in exploration.


While recognizing and accounting for ambiguity is an important aspect of the few-shot learning problem, it is challenging to model
when scaling to high-dimensional data, large function approximators, and multimodal task structure. 
Representing distributions over functions is relatively straightforward when using simple function approximators, such as linear functions, and has been done extensively in early few-shot learning approaches using Bayesian models~\citep{tenenbaum1999bayesian,fei2003bayesian}. 
But this problem becomes substantially more challenging when reasoning over high-dimensional function approximators such as deep neural networks, since explicitly representing expressive distributions over thousands or millions of parameters if often intractable.
As a result, recent more scalable approaches to few-shot learning have focused on acquiring deterministic learning algorithms that disregard ambiguity over the underlying function.
Can we develop an approach that has the benefits of both classes of few-shot learning methods -- scalability and uncertainty awareness?
To do so, we build upon tools in amortized variational inference for developing a probabilistic meta-learning approach.

In particular, our method builds on model-agnostic meta-learning (MAML)~\cite{finn2017model}, a few shot meta-learning algorithm that uses gradient descent to adapt the model at meta-test time to a new few-shot task, and trains the model parameters at meta-training time to enable rapid adaptation, essentially optimizing for a neural network initialization that is well-suited for few shot learning. MAML can be shown to retain the generality of black-box meta-learners such as RNNs~\cite{finn2017meta}, while being applicable to standard neural network architectures. Our approach extends MAML to model a distribution over prior model parameters, which leads to an appealing simple stochastic adaptation procedure that simply injects noise into gradient descent at meta-test time. The meta-training procedure then optimizes for this simple inference process to produce samples from an approximate model posterior.

The primary contribution of this paper is a reframing of MAML as a graphical model inference problem, where variational inference can provide us with a principled and natural mechanism for modeling uncertainty. Our approach enables sampling multiple potential solutions to a few-shot learning problem at meta-test time, and our experiments show that this ability can be used to sample multiple possible regressors for an ambiguous regression problem, as well as multiple possible classifiers for ambiguous few-shot attribute classification tasks. We further show how this capability to represent uncertainty can be used to inform data acquisition in a few-shot active learning problem.





 
\vspace{-0.4cm}
\section{Related Work}
\label{sec:related}
\vspace{-0.3cm}

Hierarchical Bayesian models are a long-standing approach for few-shot learning that naturally allow for the ability to reason about uncertainty over functions~\citep{tenenbaum1999bayesian,fei2003bayesian,lawrence2004learning,yu2005learning,gao2008knowledge,daume2009bayesian,wan2012sparse}. While these approaches have been demonstrated on simple few-shot image classification datasets~\cite{lake2015human}, they have yet to scale to the more complex problems, such as the experiments in this paper. A number of works have approached the problem of few-shot learning from a meta-learning perspective~\cite{schmidhuber1987evolutionary,hochreiter2001learning}, including black-box~\cite{santoro2016meta,duan2016rl,wang2016learning} and optimization-based approaches~\cite{ravi2017optimization,finn2017model}. While these approaches scale to large-scale image datasets~\cite{vinyals2016matching} and visual reinforcement learning problems~\cite{mishra2018a}, they typically lack the ability to reason about uncertainty.

Our work is most related to methods that combine deep networks and probabilistic methods for few-shot learning~\cite{edwards2017towards,grant2018recasting,lacoste2017deep}. One approach that considers hierarchical Bayesian models for few-shot learning is the neural statistician~\cite{edwards2017towards}, which uses an explicit task variable to model task distributions. Our method is fully model agnostic, and directly samples model weights for each task for any network architecture. Our experiments show that our approach improves on MAML~\cite{finn2017model}, which  outperforms the model by~\citet{edwards2017towards}.
Other work that considers model uncertainty in the few-shot learning setting is the LLAMA method~\citep{grant2018recasting}, which also builds on the MAML algorithm. LLAMA makes use of a local Laplace approximation for modeling the task parameters (post-update parameters), which introduces the need to approximate a high dimensional covariance matrix.
We instead propose a method that approximately infers the pre-update parameters, which we make tractable through a choice of approximate posterior parameterized by gradient operations. 

\emph{Bayesian neural networks}~\cite{mackay1992practical,hinton1993keeping,neal1995bayesian,barber1998ensemble} have been studied extensively as a way to incorporate uncertainty into deep networks. Although exact inference in Bayesian neural networks is impractical, approximations based on backpropagation and sampling~\cite{graves2011practical,rezende2014stochastic, hoffman2013stochastic, blundell2015weight} have been effective in incorporating uncertainty into the weights of generic networks. Our approach differs from these methods in that we explicitly train a hierarchical Bayesian model over weights, where a posterior task-specific parameter distribution is inferred at meta-test time conditioned on a learned weight prior and a (few-shot) training set, while conventional Bayesian neural networks directly learn only the posterior weight distribution for a single task. Our method draws on amortized variational inference methods~\cite{kingma2013auto,johnson2016composing,shu2018amortized} to make this possible, but the key modification is that the model and inference networks share the same parameters. The resulting method corresponds structurally to a Bayesian version of model-agnostic meta-learning~\cite{finn2017model}.


 
\vspace{-0.4cm}
\section{Preliminaries}
\label{sec:prelim}
\vspace{-0.3cm}



In the meta-learning problem setting that we consider, the goal is to learn models that can learn new tasks from small amounts of data. To do so, meta-learning algorithms require a set
of meta-training and meta-testing tasks drawn from some distribution . The key assumption of learning-to-learn is that the tasks in this distribution share common structure that can be exploited for faster learning of new tasks. Thus, the goal of the meta-learning process is to discover that structure.
In this section, we will introduce notation and overview the model-agnostic meta-learning (MAML) algorithm~\cite{finn2017model}. 

Meta-learning algorithms proceed by sampling data from a given task, and splitting the sampled data into a set of a few datapoints,  used for training the model and a set of datapoints for measuring whether or not training was effective, . This second dataset is used to measure few-shot generalization drive meta-training of the learning procedure. The MAML algorithm trains for few-shot generalization by optimizing for a set of initial parameters  such that one or a few steps of gradient descent on  achieves good performance on . Specifically, MAML performs the following optimization:

where  is used to denote the parameters updated by gradient descent and where the loss corresponds to negative log likelihood of the data. In particular, in the case of supervised classification with inputs , their corresponding labels , and a classifier , we will denote the negative log likelihood of the data under the classifier as 

This corresponds to the cross entropy loss function.

 
\vspace{-0.3cm}
\section{Method}
\label{sec:method}
\vspace{-0.2cm}



\iffalse
\begingroup
\setlength{\columnsep}{0.1cm}\begin{wrapfigure}{R}{0.6\columnwidth}
    \vspace{-0.4cm}
    \includegraphics[width=0.6\columnwidth]{figures/promaml_both_v2.png}
    \vspace{-0.4cm}
    \caption{\label{fig:promaml} .}
\end{wrapfigure}
\begingroup
\fi


\begin{figure*}[t] \centering
    \includegraphics[width=0.99\columnwidth]{figures/promaml_threec.png}
    \vspace{-0.3cm}
    \caption{\label{fig:promaml} \small Graphical models corresponding to our approach. The original graphical model (left) is transformed into the center model after performing inference over . We find it beneficial to introduce additional dependencies of the prior on the training data to compensate for using the MAP estimate to approximate , as shown on the right.}
    \vspace{-0.2cm}
\end{figure*}
Our goal is to build a meta-learning method that can handle the uncertainty and ambiguity that occurs when learning from small amounts of data, while scaling to highly-expressive function approximators such as neural networks. To do so, we set up a graphical model for the few-shot learning problem. In particular, we want a hierarchical Bayesian model that includes random variables for the prior distribution over function parameters, , the distribution over parameters for a particular task, , and the task training and test datapoints.  This graphical model is illustrated in Figure~\ref{fig:promaml} (left), where tasks are indexed over  and datapoints are indexed over .
We will use the shorthand  to denote the sets of datapoints  and  to denote  and .


\vspace{-0.2cm}
\subsection{Gradient-Based Meta-Learning with Variational Inference}
\vspace{-0.2cm}

In the graphical model in Figure~\ref{fig:promaml}, the predictions for each task are determined by the task-specific model parameters . At meta-test time, these parameters are influenced by the prior , as well as by the observed training data . The test inputs  are also observed, but the test outputs , which need to be predicted, are not observed. Note that  is thus independent of , but not of . Therefore, posterior inference over  must take into account both the evidence (training set) and the prior imposed by  and . Conventional MAML can be interpreted as approximating maximum a posteriori inference under a simplified model where  is a delta function, and inference is performed by running gradient descent on  for a fixed number of iterations starting from ~\cite{grant2018recasting}. The corresponding distribution  is approximately Gaussian, with a mean that depends on the step size and number of gradient steps. When  is not deterministic, we must make a further approximation to account for the random variable .

One way we can do this is by using structured variational inference. In structured variational inference, we approximate the distribution over the hidden variables  and  for each task with some approximate distribution . There are two reasonable choices we can make for . First, we can approximate it as a product of independent marginals, according to . However, this approximation does not permit uncertainty to propagate effectively from  to . A more expressive approximation is the structured variational approximation . We can further avoid storing a separate variational distribution  and  for each task  by employing an amortized variational inference technique~\cite{kingma2013auto,johnson2016composing,shu2018amortized}, where we instead set , where  is defined by some function approximator with parameters  that takes  as input, and the same  is used for all tasks. Similarly, we can define  as . 
We can now write down the variational lower bound on the log-likelihood as

The likelihood terms on the first line can be evaluated efficiently: given a sample \mbox{}, the training and test likelihoods simply correspond to the loss of the network with parameters .
The prior  can be chosen to be Gaussian, with a learned mean and (diagonal) covariance to provide for flexibility to choose the prior parameters. This corresponds to a Bayesian version of the MAML algorithm.
We will define these parameters as  and . 
Lastly,  must be chosen. This choice is more delicate. One way to ensure a tractable likelihood is to use a Gaussian with mean . This choice is reasonable, because it encourages  to stay close to the prior parameters , 
but we will see in the next section how a more expressive implicit conditional can be obtained using gradient descent, resulting in a procedure that more closely resembles the original MAML algorithm while still modeling the uncertainty. Lastly, we must choose a form for the inference networks  and . They must be chosen so that their entropies on the second line of the above equation are tractable. Furthermore, note that both of these distributions model very high-dimensional random variables: a deep neural network can have hundreds of thousands or millions of parameters. So while we can use an arbitrary function approximator, we would like to find a scalable solution.

One convenient solution is to allow  to reuse the learned mean of the prior . We observe that adapting the parameters with gradient descent is a good way to update them to a given training set  and test set , a design decision similar to one made by~\citet{bayesianrnn}. We propose an inference network of the form

where  is a learned (diagonal) covariance, and the mean has an additional parameter beyond , which is a ``learning rate'' vector  that is pointwise multiplied with the gradient.
While this choice may at first seem arbitrary, there is a simple intuition: the inference network should produce a sample of  that is close to the posterior . A reasonable way to arrive at a value of  close to this posterior is to adapt it to \emph{both} the training set and test set.\footnote{In practice, we can use multiple gradient steps for the mean, but we omit this for notational simplicity.} Note that this is only done during meta-training.
It remains to choose , which can also be formulated as a conditional Gaussian with mean given by applying gradient descent.

Although this variational distribution is substantially more compact in terms of parameters than a separate neural network, it only provides estimates of the posterior during meta-training. At meta-test time, we must obtain the posterior , without access to . We can train a separate set of inference networks to perform this operation, potentially also using gradient descent within the inference network. However, these networks do not receive any gradient information during meta-training, and may not work well in practice.
In the next section we propose an even simpler and more practical approach that uses only a single inference network during meta-training, and none during meta-testing.

\subsection{Probabilistic Model-Agnostic Meta-Learning Approach with Hybrid Inference}
\vspace{-0.2cm}


\iffalse
\begin{algorithm}[h]
    \caption{Model-Agnostic Meta-Learning~\cite{finn2017model}}
    \small
    \label{alg:maml}
    \begin{algorithmic}[1]
    \Require : distribution over tasks
    \Require : step size hyperparameter
    \State randomly initialize 
    \While{not done}
    \State Sample batch of tasks 
      \ForAll{}
    \State 
     \State Evaluate 
     \State Compute adapted parameters with gradient descent: 
     \EndFor
     \State Compute 
     \State Update  using Adam
    \EndWhile
\end{algorithmic}
\end{algorithm}
\fi


\iffalse
\begin{algorithm}[h]
    \caption{ProMAML, Meta-training; differences from MAML shown in red}
    \small
    \label{alg:promaml}
    \begin{algorithmic}[1]
    \Require : distribution over tasks
\State \diff{initialize }
    \While{not done}
    \State Sample batch of tasks 
      \ForAll{}
     \State 
     \State \diff{Evaluate }
\State \diff{Sample }
\State Evaluate 
\State Compute adapted parameters with gradient descent: 
     \EndFor
\State \diff{Let }
     \State Compute 
     \State Update  using Adam
    \EndWhile
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
    \caption{PLATIPUS, Meta-testing}
    \small
    \label{alg:promamltest}
    \begin{algorithmic}[1]
    \Require training data  new task 
    \Require \diff{learned }
    \State \diff{Sample  from the prior }
     \State Evaluate 
     \State Compute adapted parameters with gradient descent: 
\end{algorithmic}
\end{algorithm}
\fi






\begin{figure*}[ttt!]
\begin{minipage}[t]{0.6\textwidth}
\begin{algorithm}[H]
    \caption{Meta-training, differences from MAML in red}
    \small
    \label{alg:promaml}
    \begin{algorithmic}[1]
    \Require : distribution over tasks
    \State \diff{initialize }
    \While{not done}
    \State Sample batch of tasks 
      \ForAll{}
     \State 
     \State \diff{Evaluate }
\State \diff{Sample }
\State Evaluate 
\State \begin{varwidth}[t]{\linewidth}
     Compute adapted parameters with gradient descent: \\
     
     \end{varwidth}
     \EndFor
\State \diff{Let }
     \State \begin{varwidth}[t]{\linewidth} Compute \\ 
     
     \end{varwidth}
     \State Update  using Adam
    \EndWhile
\end{algorithmic}
\end{algorithm}
\end{minipage}
\begin{minipage}[t]{0.39\textwidth}
\vspace{1.5cm}
\begin{algorithm}[H]
    \caption{Meta-testing}
    \small
    \label{alg:promamltest}
    \begin{algorithmic}[1]
    \Require training data  for new task 
    \Require \diff{learned }
    \State \diff{Sample  from the prior }
     \State Evaluate 
     \State \begin{varwidth}[t]{\linewidth} Compute adapted parameters with gradient descent: \\ 
     \end{varwidth}
    \end{algorithmic}
\end{algorithm}
\end{minipage}
\vspace{-0.3cm}
\end{figure*} 
To formulate a simpler variational meta-learning procedure, we recall the probabilistic interpretation of MAML: as discussed by~\citet{grant2018recasting}, MAML can be interpreted as approximate inference for the posterior  according to

where we use the maximum a posteriori (MAP) value . It can be shown that, for likelihoods that are Gaussian in , gradient descent for a fixed number of iterations using ,  corresponds exactly to maximum a posteriori inference under a Gaussian prior ~\cite{santos}. In the case of non-Gaussian likelihoods, the equivalence is only locally approximate, and the exact form of the prior  is intractable. However, in practice this implicit prior can actually be preferable to an explicit (and simple) Gaussian prior, since it incorporates the rich nonlinear structure of the neural network parameter manifold, and produces good performance in practice~\cite{finn2017model,grant2018recasting}.
We can interpret this MAP approximation as inferring an approximate posterior on  of the form

where  is obtained via gradient descent on the training set  starting from . Incorporating this approximate inference procedure transforms the graphical model in Figure~\ref{fig:promaml} (a) into the one in Figure~\ref{fig:promaml} (b), where there is now a factor over .
While this is a crude approximation to the likelihood, it provides us with an empirically effective and simple tool that greatly simplifies the variational inference procedure described in the previous section, in the case where we aim to model a distribution over the global parameters .
After using gradient descent to estimate , 
the graphical model is transformed into the model shown in the center of Figure~\ref{fig:promaml}.
Note that, in this new graphical model, the global parameters  are independent of  and  and are independent of  when  is not observed.
Thus, we can now write down a variational lower bound for the logarithm of the \emph{approximate} likelihood, which is given by

In this bound, we essentially perform approximate inference via MAP on  to obtain , and use the variational distribution for  only. 
Note that  is not conditioned on the training set  since  is independent of it in the transformed graphical model.
Analogously to the previous section, the inference network is given by

To evaluate the variational lower bound during training, we can use the following procedure: first, we evaluate the mean by starting from  and taking one (or more) gradient steps on , where  starts at . We then add noise with variance , which is made differentiable via the reparameterization trick~\cite{kingma2013auto}. We then take additional gradient steps on the training likelihood . This accounts for the MAP inference procedure on . Training of , , and  is performed by backpropagating gradients through this entire procedure with respect to the variational lower bound, which includes a term for the likelihood  and the KL-divergence between the sample  and the prior . This meta-training procedure is detailed in Algorithm~\ref{alg:promaml}.

At meta-test time, the inference procedure is much simpler. The test labels are not available, so we simply sample  and perform MAP inference on  using the training set, which corresponds to gradient steps on , where  starts at the sampled . This meta-testing procedure is detailed in Algorithm~\ref{alg:promamltest}.




\vspace{-0.3cm}
\subsection{Adding Additional Dependencies}
\vspace{-0.2cm}

In the transformed graphical model, the training data  and the prior  are conditionally independent. However, since we have only a crude approximation to , this independence often doesn't actually hold. We can allow the model to compensate for this approximation by additionally conditioning the learned prior  on the training data. In this case, the learned ``prior'' has the form , where  is now task-specific, but with global parameters  and . We thus obtain the modified graphical model in Figure~\ref{fig:promaml} (c). Similarly to the inference network , we parameterize the learned prior as follows:


With this new form for distribution over , the variational training objective uses the likelihood term  in place of , but otherwise is left unchanged. At test time, we sample from  by first taking gradient steps on , where  is initialized at , and then adding noise with variance . Then, we proceed as before, performing MAP inference on  by taking additional gradient steps on  initialized at the sample .
In our experiments, we find that this more expressive distribution often leads to better performance.



 
\vspace{-0.4cm}
\section{Experiments}
\label{sec:experiments}
\vspace{-0.3cm}

The goal of our experimental evaluation is to answer the following questions: (1) can our approach enable sampling from the distribution over potential functions underlying the training data?, (2) does our approach improve upon the MAML algorithm when there is ambiguity over the class of functions?, and (3) can our approach scale to deep convolutional networks? We study two illustrative toy examples and a realistic ambiguous few-shot image classification problem.
For the both experimental domains, we compare MAML to our probabilistic approach. We will refer to our version of MAML as a PLATIPUS (Probabilistic LATent model for Incorporating Priors and Uncertainty in few-Shot learning), due to its unusual combination of two approximate inference methods: amortized inference and MAP.
Both PLATIPUS and MAML use the same neural network architecture and the same number of inner gradient steps.
We additionally provide a comparison on the MiniImagenet benchmark and specify the hyperparameters in the supplementary appendix.


\vspace{-0.1in}
\paragraph{Illustrative 5-shot regression.}
In this 1D regression problem, different tasks correspond to different underlying functions. Half of the functions are sinusoids, and half are lines, such that the task distribution is clearly multimodal. The sinusoids have amplitude and phase uniformly sampled from the range  and , and the lines have the slope and intercept sampled in the range . The input domain is uniform on , and Gaussian noise with a standard deviation of  is added to the labels.
We trained both MAML and PLATIPUS for 5-shot regression.
In Figure~\ref{fig:sine_linear}, we show the qualitative performance of both methods, where the ground truth underlying function is shown in gray and the datapoints in  are shown as purple triangles. We show the function  learned by MAML in black.
For PLATIPUS, we sample  sets of parameters from  and plot the resulting functions in different colors. In the top row, we can see that PLATIPUS allows the model to effectively reason over the set of functions underlying the provided datapoints, with increased variance in parts of the function where there is more uncertainty. Further, we see that PLATIPUS is able to capture the multimodal structure, as the curves are all linear or sinusoidal.

\begin{figure*}[t] \centering
\includegraphics[width=0.17\columnwidth]{figures/plat_5_6.png}
    \includegraphics[width=0.17\columnwidth]{figures/plat_5_5.png}
    \includegraphics[width=0.17\columnwidth]{figures/plat_5_8.png}
    \includegraphics[width=0.17\columnwidth]{figures/plat_5_7.png}
    \includegraphics[width=0.17\columnwidth]{figures/plat_5_9.png}
    \includegraphics[width=0.17\columnwidth]{figures/progression_figs/mamlsineplot_5_1.png}
    \includegraphics[width=0.17\columnwidth]{figures/progression_figs/mamlsineplot_6_1.png}
    \includegraphics[width=0.17\columnwidth]{figures/progression_figs/mamlsineplot_7_1.png}
    \includegraphics[width=0.17\columnwidth]{figures/progression_figs/mamlsineplot_8_1.png}
    \includegraphics[width=0.17\columnwidth]{figures/progression_figs/mamlsineplot_9_1.png}
    \vspace{-0.2cm}
    \caption{\small Samples from PLATIPUS trained for 5-shot regression, shown as colored dotted lines. The tasks consist of regressing to sinusoid and linear functions, shown in gray. MAML, shown in black, is a deterministic procedure and hence learns a single function, rather than reasoning about the distribution over potential functions. As seen on the bottom row, even though PLATIPUS is trained for 5-shot regression, it can effectively reason over its uncertainty when provided variable numbers of datapoints at test time (left vs. right).
    \label{fig:sine_linear} }
    \vspace{-0.4cm}
\end{figure*}

A particularly useful application of uncertainty estimates in few-shot learning is estimating when more data would be helpful. In particular, seeing a large variance in a particular part of the input space suggests that more data would be helpful for learning the function in that part of the input space. On the bottom of Figure~\ref{fig:sine_linear}, we show the results for a single task at meta-test time with increasing numbers of training datapoints. Even though the model was only trained on training set sizes of  datapoints, we observe that PLATIPUS is able to effectively reduce its uncertainty as more and more datapoints are available. This suggests that the uncertainty provided by PLATIPUS can be used for approximately gauging when more data would be helpful for learning a new task. 

\begin{figure*}[t] \centering
\includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_1_6pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_1_7pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_1_8pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_1_9pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_1_10pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_4_6pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_4_7pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_4_8pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_4_9pts.png}
    \includegraphics[width=0.18\columnwidth]{figures/platipus_plot_5_4_10pts.png}
\vspace{-0.2cm}
    \caption{\small Qualitative examples from active learning experiment where the 5 provided datapoints are from a small region of the input space (shown as purple triangles), and the model actively asks for labels for new datapoints (shown as blue circles) by choosing datapoints with the largest variance across samples. The model is able to effectively choose points that leads to accurate predictions with only a few extra datapoints.
    \label{fig:active_qual} }
    \vspace{-0.45cm}
\end{figure*}


\begin{wrapfigure}{h}{0.44\textwidth}
    \centering
    \vspace{-0.85cm}
    \hspace{-0.2cm}
    \includegraphics[width=0.44\textwidth]{figures/active_platipus.png}
    \vspace{-0.2cm}
    \caption{\footnotesize Active learning performance on regression after up to 5 selected datapoints. PLATIPUS can use it's uncertainty estimation to quickly decrease the error, while selecting datapoints randomly and using MAML leads to slower learning.}
    \label{fig:active}
\vspace{-0.4cm}
\end{wrapfigure}
\paragraph{Active learning with regression.} To further evaluate the benefit of modeling
ambiguity, we now consider an active learning experiment.
In particular, the model can choose the datapoints that it wants labels for, with the goal of reaching good performance with a minimal number of additional datapoints. We performed this evaluation in the simple regression setting described previously. Models were given five initial datapoints within a constrained region of the input space. Then, each model selects up to 5 additional datapoints to be labeled. PLATIPUS chose each datapoint sequentially, choosing the point with maximal variance across the sampled regressors; MAML selected datapoints randomly, as it has no mechanism to model ambiguity. As seen in Figure~\ref{fig:active}, PLATIPUS is able to reduce its regression error to a much greater extent when given one to three additional queries, compared to MAML. We show qualitative results in Figure~\ref{fig:active_qual}.





\vspace{-0.1in}
\paragraph{Illustrative 1-Shot 2D classification.}
Next, we study a simple binary classification task, where there is a particularly large amount of ambiguity surrounding the underlying function: learning to learn from a single positive example. Here, the tasks consist of classifying datapoints in 2D within the range  with a circular decision boundary, where points inside the decision boundary are positive and points outside are negative. Different tasks correspond to different locations and radii of the decision boundary, sampled at uniformly at random from the ranges  and  respectively.
Following~\citet{grant2017workshop}, we train both MAML and PLATIPUS with  consisting of a single positive example and  consisting of both positive and negative examples.
We plot the results using the same scheme as before, except that we plot the decision boundary (rather than the regression function) and visualize the single positive datapoint with a green plus. As seen in Figure~\ref{fig:2dclass}, we see that PLATIPUS captures a broad distribution over possible decision boundaries, all of which are roughly circular. MAML provides a single decision boundary of average size.

\begin{figure*}[t] \centering
\includegraphics[width=0.17\columnwidth]{figures/maml2dplot_1_8.png}
    \includegraphics[width=0.17\columnwidth]{figures/maml2dplot_1_4.png}
    \includegraphics[width=0.17\columnwidth]{figures/maml2dplot_1_7_notitle.png}
    \includegraphics[width=0.17\columnwidth]{figures/maml2dplot_1_1.png}
    \includegraphics[width=0.17\columnwidth]{figures/maml2dplot_1_2.png}
    \vspace{-0.2cm}
    \caption{\small Samples from PLATIPUS for 1-shot classification, shown as colored dotted lines. The 2D classification tasks all involve circular decision boundaries of varying size and center, shown in gray. MAML, shown in black, is a deterministic procedure and hence learns a single function, rather than reasoning about the distribution over potential functions. 
    \label{fig:2dclass} }
    \vspace{-0.5cm}
\end{figure*}

\vspace{-0.1in}
\paragraph{Ambiguous image classification.}
The ambiguity illustrated in the previous settings is common in real world tasks where images can share multiple attributes. We study an ambiguous extension to the celebA attribute classification task. Our meta-training dataset is formed by sampling two attributes at random to form a positive class and taking the same number of random examples without either attribute to from the negative classes. 
To evaluate the ability to capture multiple decision boundaries while simultaneously obtaining good performance, we evaluate our method as follows: We sample from a test set of three attributes and a corresponding set of images with those attributes. Since the tasks involve classifying images that have two attributes, this task is ambiguous, and there are three possible combinations of two attributes that explain the training set. We sample models from our prior as described in Section~\ref{sec:method} and assign each of the sampled models to one of the three possible tasks based on its log-likelihood. If each of the three possible tasks is assigned a nonzero number of samples, this means that the model effectively covers all three possible modes that explain the ambiguous training set. We can measure coverage and accuracy from this protocol. The coverage score indicates the average number of tasks (between 1 and 3) that receive at least one sample for each ambiguous training set, and the accuracy score is the average number of correct classifications on these tasks (according to the sampled models assigned to them). A highly random method will achieve good coverage but poor accuracy, while a deterministic method will have a coverage of 1. We additionally compute the log-likelihood across the ambiguous tasks which compares each method's ability to model all of the ``modes''. As is standard in amortized variational inference (e.g., with VAEs), we put a multiplier  in front of the KL-divergence against the prior~\cite{higgins2017early} in Algorithm~\ref{alg:promaml}. We find that larger values result in more diverse samples, at a modest cost in performance, and therefore report two different values of  to illustrate this tradeoff.

Our results are summarized in Table~\ref{tbl:celeba} and Fig.~\ref{fig:celeb_a}. Our method attains better log-likelihood, and a comparable accuracy compared to standard MAML. More importantly, deterministic MAML only ever captures one mode for each ambiguous task, where the maximum is three. Our method on average captures closer to two modes on average. The qualitative analysis in Figure~\ref{fig:celeb_a} illustrates\footnote{Additional qualitative results and code can be found at \hyperlink{\website}{\website}} an example ambiguous training set, example images for the three possible two-attribute pairs that can correspond to this training set, and the classifications made by different sampled classifiers trained on the ambiguous training set. Note that the different samples each pay attention to different attributes, indicating that PLATIPUS is effective at capturing the different modes of the task.

\begin{figure*}[t] \centering
\includegraphics[width=0.53\columnwidth]{figures/new_drawing.pdf}
    \vspace{-0.2cm}
    \caption{\small Sampled classifiers for an ambiguous meta-test task. In the meta-test training set (a), PLATIPUS observes five positives that share three attributes, and five negatives. A classifier that uses \emph{any} two attributes can correctly classify the training set. On the right (b), we show the three possible two-attribute tasks that the training set can correspond to, and illustrate the labels (positive indicated by purple border) predicted by the best sampled classifier for that task. We see that different samples can effectively capture the three possible explanations, with some samples paying attention to hats  (2nd and 3rd column) and others not (1st column).
\label{fig:celeb_a}
    \vspace{-0.1in}
    }
\end{figure*}


\begin{table*}[!h]
\label{tbl:celeba}
\begin{center}
{\footnotesize
\begin{tabular}{|l|c|c|c|}
\hline
\multicolumn{4}{|c|}{Ambiguous celebA (5-shot)} 
\\
\hline
&  Accuracy & Coverage (max=3) & Average NLL \\
\hline
MAML  & \textbf{89.00  1.78}\%  & 1.00  0.0 & 0.73  0.06\\
\hline
MAML + noise &   \%  & 1.89  0.04  &   \\
\hline
\textbf{PLATIPUS (ours)} (KL weight = 0.05)& \textbf{88.34  1.06} \% & 1.59   0.03 & 0.67 0.05 \\
\hline
\textbf{PLATIPUS (ours)} (KL weight = 0.15) & \textbf{87.8  1.03} \% & \textbf{1.94   0.04} & \textbf{0.56  0.04}\\
\hline
\end{tabular}
}
\end{center}
\vspace{-0.35cm}
\caption{ Our method covers almost twice as many modes compared to MAML, with comparable accuracy. 
MAML + noise is a method that adds noise to the gradient, but does not perform variational inference. This improves coverage, but results in lower accuracy average log likelihood. We bold results above the highest confidence interval lowerbound.
}
\vspace{-0.5cm}
\end{table*}
 
\vspace{-0.4cm}
\section{Discussion and Future Work}
\label{sec:conclusion}
\vspace{-0.3cm}

We introduced an algorithm for few-shot meta-learning that enables simple and effective sampling of models for new tasks at meta-test time. Our algorithm, PLATIPUS, adapts to new tasks by running gradient descent with injected noise. During meta-training, the model parameters are optimized with respect to a variational lower bound on the likelihood for the meta-training tasks, so as to enable this simple adaptation procedure to produce approximate samples from the model posterior when conditioned on a few-shot training set. This approach has a number of benefits. The adaptation procedure is exceedingly simple, and the method can be applied to any standard model architecture. The algorithm introduces a modest number of additional parameters: besides the initial model weights, we must learn a variance on each parameter for the inference network and prior, and the number of parameters scales only linearly with the number of model weights. Our experimental results show that our method can be used to effectively sample diverse solutions to both regression and classification tasks at meta-test time, including with task families that have multi-modal task distributions. We additionally showed how our approach can be applied in settings where uncertainty can directly guide data acquisition, leading to better few-shot active learning.

Although our approach is simple and broadly applicable, it has potential limitations that could be addressed in future work. First, the current form of the method provides a relatively impoverished estimator of posterior variance, which might be less effective at gauging uncertainty in settings where different tasks have different degrees of ambiguity. In such settings, making the variance estimator dependent on the few-shot training set might produce better results, and investigating how to do this in a parameter efficient manner would be an interesting direction for future work.
Another exciting direction for future research would be to study how our approach could be applied in RL settings for acquiring structured, uncertainty-guided exploration strategies in meta-RL problems.



 

\vspace{-0.1cm}
\subsubsection*{Acknowledgments}
\vspace{-0.1cm}
We thank Marvin Zhang and Dibya Ghosh for feedback on an early draft of this paper. This research was supported by an NSF Graduate Research Fellowship, NSF IIS-1651843, the Office of Naval Research, and NVIDIA.


\bibliography{references}
\bibliographystyle{abbrvnat}

\appendix
\newpage
\part*{Appendix}
\label{appendix}

\section{Ambiguous CelebA Details}

We construct our ambiguous few-shot variant of CelebA using the canonical splits to form the meta-train/val/test set. This gives us a split of  images respectively. We additionally randomly partition the  available attributes and into a split of , which we use to construct the tasks below.
 
During training, each task is constructed by randomly sampling 2 attributes as Boolean variables and constructing tasks where one class shares the setting of these attributes and the other is the converse. For example, a valid constructed tasks is classifying \texttt{not Smiling, Pale Skin} versus \texttt{Smiling, not Pale Skin}. During testing, we sample 3 attributes from the test set to form the training task, and sample the 3 corresponding 2-uples to form the test task. After removing combinations that have insufficient examples to form a single tasks, this scheme produces  tasks for meta-train/val/test respectively. Each sampled image is pre-processed by first obtaining an approximately  center crop of each image following by downsampling to . This crop is captures regions of the image necessary to classify the non-facial attributes (e.g. Wearing Necklace).

Meta-training attributes: \\
{ \small \texttt{Oval Face, Attractive, Mustache, Male, Pointy Nose, Bushy Eyebrows, Blond Hair, Rosy Cheeks, Receding Hairline, Eyeglasses, Goatee, Brown Hair, Narrow Eyes, Chubby, Big Lips, Wavy Hair, Bags Under Eyes, Arched Eyebrows, Wearing Earrings, High Cheekbones, Black Hair, Bangs, Wearing Lipstick, Sideburns, Bald}}

Meta-validation attributes:\\
{\small \texttt{Wearing Necklace, Smiling, Pale Skin, Wearing Necktie, Big Nose}}

Meta-testing attributes:\\
{ \small \texttt{Straight Hair, 5 o'Clock Shadow, Wearing Hat, Gray Hair, Heavy Makeup, Young, Blurry, Double Chin, Mouth Slightly Open, No Beard}}.

\section{Experimental Details}
In the illustrative experiments, we use a fully connected network with 3 ReLU layers of size . Following~\citet{finn2017one}, we additionally use a bias transformation variable, concatenated to the input, with size . Both methods use  inner gradient steps on  with step size  for regression and  for classification. The inference network and prior for PLATIPUS both use one gradient step. For PLATIPUS, we weight the KL term in the objective by  for 1D regression and  for 2D classification.

For CelebA, we adapt the base convolutional architecture described in~\citet{finn2017model} which we refer the readers to for more detail. Our approximate posterior and prior have dimensionality matching the underlying model.
We tune our approach over the inner learning rate , a weight on the , the scale of the initialization of , , and a weight on the KL objective  which we anneal towards during training. All models are trained for a maximum of 60,000 iterations.

At meta-test time, we evaluate our approach by taking 15 samples from the prior before determining the assignments. The assignments are made based on the likelihood of the testing examples. We average our results over  test tasks. In order to compute the marginal log-likelihood, we average over  samples from the prior. 

\section{MiniImagenet Comparison}

We provide an additional comparison on the MiniImagenet dataset.
Since this benchmark does not contain a large amount of ambiguity, we do not aim to show state-of-the-art performance. Instead, our goal with this experiment is to compare our approach on to MAML and prior methods that build upon MAML on this standard benchmark. Since our goal is to compare algorithms, rather than achieving maximal performance, we decouple the effect of the meta-learning algorithm and the architecture used by using the standard 4-block convolutional architecture used by~\citet{vinyals2016matching,ravi2017optimization,finn2017model} and others. We note that better performance can likely be achieved by tuning the architecture. The results, in Table~\ref{tbl:miniimagenet} indicate that our method slightly outperforms MAML and achieves comparable performance to a number of other prior methods.


\begin{table*}
\centering
\begin{tabular}{|l|c|}
\hline
MiniImagenet  &  5-way, 1-shot Accuracy \\
\hline
MAML~\cite{finn2017meta}  &   \\
\hline
LLAMA~\cite{grant2018recasting}  &   \\
\hline
Reptile~\cite{nichol2018reptile} &   \\
\hline
PLATIPUS (ours) &   \\
\hline
Meta-SGD~\cite{li2017meta} &   \\
\hline
& \vspace{-0.3cm} \\
\hline
matching nets~\cite{vinyals2016matching} &  \\
\hline
meta-learner LSTM~\cite{ravi2017optimization} &   \\
\hline
SNAIL~\cite{mishra2018a}* &   \\
\hline
prototypical networks~\cite{snell2017prototypical} &   \\
\hline
mAP-DLM~\cite{snell2017prototypical} &   \\
\hline
GNN~\cite{garcia2017few} &   \\
\hline
Relation Net~\cite{sung2017learning} &   \\
\hline
\end{tabular}
\vspace{-0.2cm}
\caption{Comparison between our approach and prior MAML-based methods (top), and other prior few-shot learning techniques on the 5-way, 1-shot MiniImagenet benchmark. Our approach gives a small boost over MAML, and is comparable to other approaches. We bold the approaches that are above the highest confidence interval lower-bound. *Accuracy using comparable network architecture.
\label{tbl:miniimagenet}
}
\end{table*} 

\end{document}
