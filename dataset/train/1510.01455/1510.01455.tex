\documentclass{article}
\pagestyle{plain}
\usepackage{cite}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{url}
\usepackage{fullpage, times}
\usepackage{amsfonts,color,float,verbatim}
\usepackage{amssymb, url, bbm}

\usepackage{algorithm, algorithmic}

\newcommand{\xn}{X^{n_A}}
\newcommand{\xnstar}{X^{n_{A^*}}}
\newcommand{\xnml}{X^{n_A}_{-\ell}}
\newcommand{\xnmlstar}{X^{n_{A^*}}_{-\ell}}
\newcommand{\xnmlxl}{X^{n_A}_{-\ell},x_\ell}
\newcommand{\xnmltwo}{X^{n_A}_{-\ell_1, -\ell_2}}
\newcommand{\xnmlxltwo}{X^{n_A}_{-\ell_1, -\ell_2}, x_{\ell_1}, x_{\ell_2}}

\newcommand{\txn}{\mathrm{T_\ell}[X^{n_A}_{-\ell}](x_\ell)}
\newcommand{\txntwo}{\mathrm{T_{\ell_1, \ell_2}}[X^{n_A}_{-\ell_1, -\ell_2}](x_{\ell_1}, x_{\ell_2})}
\newcommand{\fxn}{\mathrm{F_\ell}[X^{n_A}_{-\ell}]}

\newcommand{\tuxn}{\mathrm{T^U_\ell}[X^{n_U}_{-\ell}](x_\ell)}
\newcommand{\tjxn}{\mathrm{T^{(j)}_\ell}[X^{n_{A_j}}_{-\ell}](x_\ell)}
\newcommand{\fuxn}{\mathrm{F^U_\ell}[X^{n_U}_{-\ell}]}
\newcommand{\fjxn}{\mathrm{F^j_\ell}[X^{n_{A_j}}_{-\ell}]}

\newcommand{\atxn}{\mathrm{T_\ell}(x_\ell)}
\newcommand{\afxn}{\mathrm{F_\ell}}

\newcommand{\xhat}{F}
\newcommand{\xhatl}{F_\ell}
\newcommand{\xhatfull}{F_\ell[X^{n_A}_{-\ell}]}

\newcommand{\xnj}{X^{n_{A_j}}}
\newcommand{\xnjml}{X^{n_{A_j}}_{-\ell}}
\newcommand{\xnjmlxl}{X^{n_{A_j}}_{-\ell},x_\ell}

\newcommand{\xon}{X^{n_{U}}}
\newcommand{\xonml}{X^{n_{U}}_{-\ell}}
\newcommand{\xonmlxl}{X^{n_{U}}_{-\ell},x_\ell}

\newcommand{\xnu}{X^{n_U}}
\newcommand{\xnuml}{X^{n_{U}}_{-\ell}}

\newcommand{\xhatjl}{F^j_\ell}
\newcommand{\xhatul}{F^U_\ell}

\newcommand{\xhatfullj}{F^j_\ell [X^{n_{A_j}}_{-\ell}]}
\newcommand{\altxhatfullj}{F^j_\ell [X^{\ovn}_{-\ell}]}

\newcommand{\xhatfullo}{F^{U}_{l}[X^{\ovn}_{-\ell}]}

\newcommand{\jin}{J^{\mathrm{in}}}
\newcommand{\jout}{J^{\mathrm{out}}}

\newcommand{\ovm}{A_U}
\newcommand{\ovn}{n_U}

\newcommand{\atuxn}{\mathrm{T^U_\ell}[X^{n_U}_{-\ell}](x_\ell)}
\newcommand{\atjxn}{\mathrm{T^{(j)}_\ell}[X^{n_{A_j}}_{-\ell}](x_\ell)}
\newcommand{\afuxn}{\mathrm{F^U_\ell}[X^{n_U}_{-\ell}]}
\newcommand{\afjxn}{\mathrm{F^j_\ell}[X^{n_{A_j}}_{-\ell}]}

\newcommand{\ept}{\operatornamewithlimits{E}}
\newcommand{\sdev}{\operatornamewithlimits{\sigma}}
\newcommand{\vari}{\operatornamewithlimits{\sigma^2}}
\newcommand{\eat}[1]{}
\newcommand{\edit}[1]{{#1}}
\newcommand{\kedit}[1]{{#1}}




\newenvironment{tighterdescription}{\begin{description}\setlength{\itemsep}{1pt}\setlength{\parskip}{1pt}}{\end{description}}

\newenvironment{tighterenumerate}{\begin{enumerate}\setlength{\itemsep}{1pt}\setlength{\parskip}{1pt}}{\end{enumerate}}

\newenvironment{tighteritemize}{\begin{itemize}\setlength{\itemsep}{1pt}\setlength{\parskip}{1pt}}{\end{itemize}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{corollaries}[theorem]{Corollaries}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{property}[theorem]{Property}
\newtheorem{technicalcondition}[theorem]{Technical Condition}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\romJAAdapt}{\mathrm{\scalebox{0.9}{JA}}\mathrm{Adapt}}
\newcommand{\romJAkMV}{\mathrm{\scalebox{0.9}{JA}}\mathrm{kMV}}
\newcommand{\romJAKMV}{\mathrm{\scalebox{0.9}{JA}}\mathrm{KMV}}
\newcommand{\romJAEST}{\mathrm{\scalebox{0.9}{JA}}\mathrm{EST}}
\newcommand{\romIEEST}{\mathrm{\scalebox{0.9}{IE}}\mathrm{EST}}

\newcommand{\romTS}{\hat{n}}
\newcommand{\romEST}{\mathrm{EST}}
\newcommand{\romHLL}{\mathrm{HLL}}
\newcommand{\romkMV}{\mathrm{kMV}}
\newcommand{\pIKMV}{\mathrm{pKMV}}
\newcommand{\romKMV}{\mathrm{KMV}}
\newcommand{\romAdapt}{\mathrm{Adapt}}
\newcommand{\romIAdapt}{\mathrm{multiAdapt}}
\newcommand{\romAlpha}{\mathrm{Alpha}}

\newcommand{\romESTC}{\mathrm{ESTC}}
\newcommand{\romHLLC}{\mathrm{HLLC}}
\newcommand{\romkMVC}{\mathrm{kMVC}}
\newcommand{\romKMVC}{\mathrm{KMVC}}
\newcommand{\romAdaptC}{\mathrm{AdaptC}}
\newcommand{\romAlphaC}{\mathrm{AlphaC}}

\newcommand{\romESTG}{\mathrm{ESTG}}
\newcommand{\romHLLG}{\mathrm{HLLG}}
\newcommand{\romkMVG}{\mathrm{kMVG}}
\newcommand{\romKMVG}{\mathrm{KMVG}}
\newcommand{\romAdaptG}{\mathrm{AdaptG}}
\newcommand{\romAlphaG}{\mathrm{AlphaG}}
\newcommand{\romIKMV}{\mathrm{multiKMV}}
\newcommand{\IKMV}{multiKMV}
\newcommand{\romIHLL}{\textrm{multiHLL}}
\newcommand{\rommultiKMV}{\textrm{multiKMV}}

\newcommand{\estonsub}{\mathrm{EstimateOnSubPopulation}}
\newcommand{\thetaunion}{\mathrm{ThetaUnion}}



\newcommand{\samp}{\mathrm{samp}}


\newlength\myindent
\setlength\myindent{2em}
\newcommand\bindent{\begingroup
  \setlength{\itemindent}{\myindent}
  \addtolength{\algorithmicindent}{\myindent}
}
\newcommand\eindent{\endgroup}








\usepackage{acronym}
\newcommand{\distinctsub}{\textsc{DistinctOnSubPopulation}}
\newcommand{\distinctsubP}{\textsc{DistinctOnSubPopulation}}
\newcommand{\distinctP}{\textsc{Distinct}}
\newcommand{\distinctelements}{\textsc{Distinct Elements}}
\newcommand{\distinct}{\textsc{Distinct}}
\newcommand{\distinctA}{\textsc{Distinct}}
\newcommand{\DistinctElements}{\textsc{DistinctElements}}


\title{A Framework for Estimating Stream Expression Cardinalities} 




\author{Anirban Dasgupta\thanks{Indian Institute of Technology, Gandhinagar} \and Kevin Lang\thanks{Yahoo Labs} \and Lee Rhodes\thanks{Yahoo! Inc} \and Justin Thaler\thanks{Yahoo Labs}}

\date{}


\begin{document}

\maketitle

\begin{abstract}
Given  distributed data streams , we consider the problem 
of estimating the number of unique identifiers in streams defined by set expressions over .
We identify a broad class of algorithms for solving this problem, and show that the estimators output by any algorithm in this class 
are perfectly unbiased and satisfy strong variance bounds. Our analysis unifies and generalizes a variety of earlier results in the literature. 
To demonstrate its generality, we describe several novel sampling algorithms in our class, and show that they
achieve a novel tradeoff between accuracy, space usage, update speed, and applicability. \end{abstract}

\section{Introduction} 
Consider an internet company that monitors the traffic flowing over its network by placing 
a sensor at each ingress and egress point. Because the volume of traffic is large,
each sensor stores only a small \emph{sample} of the observed traffic, using some simple sampling procedure. 
At some later point, the company
decides that it wishes to estimate the number of unique users who satisfy a certain property  and have communicated over its network.
We refer to this as the \distinctsubP\ problem, or \distinct for short.
How can the company combine the samples computed by each sensor, in order to accurately estimate the answer to this query?
 
In the case that  is the trivial property that is satisfied by all users, the answer to the query is simply the 
number of \DistinctElements\ in the traffic stream, or \distinct\ for short. The problem of designing streaming algorithms and sampling procedures
for estimating \DistinctElements\ has been the subject of intense study. In general, however,  may be significantly more complicated than the trivial property, and may not be known until query time. 
For example, the company may want to estimate the number of (unique) men in a certain age range,
 from a specified country, who accessed a certain set of websites during a designated time period, while excluding IP addresses belonging to a 
 designated blacklist.  
This more general setting, where  is a nontrivial ad hoc property, has received somewhat less attention than the basic \distinct\ problem.

In this paper, our goal is to identify a simple method for combining the samples from each sensor, so that the following holds.
As long as each sensor is using a sampling procedure that satisfies a certain mild technical condition, then for any property , the combining procedure outputs an estimate for
the \distinctP\ problem that is unbiased. Moreover, its variance should be bounded by that of the individual sensors' sampling procedures.\footnote{More precisely,
we are interested in showing that
the variance of the returned estimate is at most that of the (hypothetical) estimator obtained by running each individual sensor's sampling algorithm on the concatenated stream .
We refer to the latter estimator as ``hypothetical'' because it is typically infeasible to materialize the concatenated stream in distributed environments.} 


For reasons that will become clear later, we refer to our proposed combining procedure as the \emph{Theta-Sketch Framework}, and we refer to the mild technical condition
that each sampling procedure must satisfy to guarantee unbiasedness as \emph{-Goodness}. If the sampling procedures
satisfy an additional property that we refer to as \emph{monotonicity}, then the variance of the estimate output by the combining procedure is guaranteed to satisfy the desired variance bound. The Theta-Sketch Framework, and our analysis of it, unifies and generalizes a variety of results in the literature (see Section \ref{sec:contributions} for details). 

\medskip
\noindent \textbf{The Importance of Generality.} As we will see, there is a huge array of sampling procedures that the sensors could use. Each procedure comes with a unique tradeoff between 
accuracy, space requirements, update speed, and simplicity. Moreover, some of these procedures come with additional desirable properties, while others do not. We would like to support as many sampling procedures as possible, because the best one to use in any given given setting
will depend on the relative importance of each resource in that setting. 

\eat{In addition, there are realistic scenarios where different sensors may use different sampling procedures, or may use the same sampling procedure but with different settings of parameters. 
For example, if different sensors have different amounts of available memory (say, because some sensors are newer than others), then the sensors with less memory will have to downsample 
more aggressively than the others. 
The guarantees of the Theta-Sketch Framework continue to hold when different sensors use different sampling procedures, as long as all of the sampling procedures used satisfy 1-Goodness. }

\medskip
\noindent \textbf{Handling Set Expressions.}
\label{sec:setexpressions}
The scenario described above can be modeled as follows. Each sensor observes a stream of identifiers  from a data universe of size , and the goal
is to estimate the number of distinct identifiers that satisfy property  in the combined stream . In full generality, we may wish to handle more complicated set expressions applied to the constituent streams, other than set-union. For example, we may have  streams of identifiers , and wish to estimate 
the number of distinct identifiers satisfying property  that appear in \emph{all streams}. The Theta-Sketch Framework can be naturally extended to provide estimates for such queries. Our analysis applies to any sequence of set operations on the 's, but we restrict our attention to set-union and set-intersection throughout the paper for simplicity. 

\section{Preliminaries, Background, and Contributions}
\subsection{Notation and Assumptions}
\noindent \textbf{Streams and Set Operations.}
Throughout,  denotes a stream of identifiers from a data universe . We view any \emph{property}  on identifiers
as a subset of , and let  denote the number of distinct identifiers that appear in  and satisfy .
For brevity, we let  denote . When working in a multi-stream setting,  denote  streams of identifiers from ,  will denote the concatenation of the  input streams,
while  denotes the set of identifiers that appear at least once in all  streams. Because we are interested only in \emph{distinct} counts, 
it does not matter for definitional purposes whether we view  and  as sets, or as multisets. 
For any property ,  and , while  and .

\medskip
\noindent \textbf{Hash Functions.} \label{sec:hashprelims}
For simplicity and clarity, and following prior work (e.g. \cite{beyer2009distinct, cohen2009leveraging}), we assume throughout that the sketching and sampling algorithms make use of a perfectly random hash function 
mapping the data universe  to the open interval . That is, for each ,  is a uniform random number in . Given a subset of hash values  computed from a stream , and a property ,
 denotes the subset of hash values in  whose corresponding identifiers in  satisfy .
Finally, given a stream , the notation  refers to the set of hash values obtained by mapping 
a hash function  over the  distinct identifiers in .

\eat{\medskip
\noindent \textbf{Additional Notation.} Throughout, we will use the following strategy for simplifying the
presentation of our results. Let  be an arbitrary stream that is allowed to contain multiple
occurrences of the various identifiers. Let  be the stream derived from  by deleting all
occurrences of each label except for the one that would be encountered first during 
a linear scan through . Then every sketching algorithm that we consider
produces exactly the same sketch and exactly the same estimate whether it is applied to
 or to . 
Therefore, without loss of generality, all of our proofs concerning the contents of sketches and the values
of estimates will be written in terms of the ``uniquified'' stream . 
Finally, the notation  will always refer to the sequence of hash values obtained by mapping 
a hash function  over a length- uniquified stream .}

\subsection{Prior Art: Sketching Procedures for \distinct\ Queries}
\label{sec:priorwork}
There is a sizeable literature on streaming algorithms for estimating the number of distinct elements in a single data stream. Some, but not all,
of these algorithms can be modified to solve the \distinctP\ problem for general properties . 
Depending on which functionality is required, systems based on HyperLogLog Sketches, 
K'th Minimum Value (KMV) Sketches, and Adaptive Sampling represent the
state of the art for practical systems \cite{heule2013hll}.\footnote{Algorithms with better asymptotic bit-complexity are known \cite{kane2010optimal}, but they do not match the practical
performance of the algorithms discussed here. See Section \ref{sec:related}.}
For clarity of exposition, we defer a thorough overview of these algorithms to Section \ref{app:priorwork}. Here, we briefly review the main concepts
and relevant properties of each. 

\medskip
\noindent \textbf{HLL: HyperLogLog Sketches}. HLL is a sketching algorithm for the vanilla \distinct\ problem. Its accuracy per bit is superior to the KMV and Adaptive Sampling algorithms described below.
However, unlike KMV and Adaptive Sampling, it is not known how to extend the HLL sketch to estimate  for general properties  (unless, of course,  is known prior to stream
processing). 


\medskip
\noindent \textbf{KMV: K'th Minimum Value Sketches.} The KMV sketching procedure for estimating \distinctA\ works as follows. While processing an input stream , KMV keeps track of the set  of the  smallest unique hashed values of stream elements.
The update time of a heap-based implementation of KMV is .
The KMV estimator for \distinctA\ is: 
, where 
 denotes the  smallest unique 
hash value.\footnote{Some works use the estimate , 
{\em e.g.} 
\cite{bar2002counting}. 
We use  
because it is unbiased, and
for consistency with the work of Cohen and Kaplan \cite{cohen2009leveraging} described below.}
It has been proved by \cite{beyer2009distinct}, \cite{giroire2009order}, and others, that , and

Duffield et al. \cite{DuffieldLT07} proposed to change 
the heap-based implementation of the KMV sketching algorithm
to an implementation based on quickselect \cite{quickselect61}. 
This reduces the sketch update cost from  to amortized . However, this  hides a larger constant than
competing methods.
At the cost of storing the sampled identifiers, and not just their hash values, the KMV sketching procedure can be extended to estimate  for any property  (Section \ref{app:priorwork} has details).

\medskip
\noindent \textbf{Adaptive Sampling.} Adaptive Sampling maintains a sampling level , and the set 
of all hash values less than ; whenever  exceeds a pre-specified
size limit,  is incremented and  is scanned discarding any hash value
that is now too big. Because a simple scan is cheaper than running
quickselect, an implementation of this scheme is typically faster than
KMV. The estimator of  is . It has been proved by \cite{flajolet1990adaptive} that this
estimator is unbiased, and that , where the approximation sign hides oscillations caused
by the periodic culling of .  
Like KMV, Adaptive Sampling can be extended to estimate  for any property . Although the stream processing speed of Adaptive Sampling is excellent,
the fact that its accuracy oscillates as  increases is a shortcoming.

\medskip
\noindent \textbf{HLL for set operations on streams.} HLL can be directly adapted to handle set-union (see Section \ref{app:priorwork} for details). For set-intersection, the relevant adaptation uses the inclusion/exclusion principle. 
However, the variance of this estimate is approximately a factor of  worse than the variance achieved by
the  algorithm described below. When , this penalty
factor overwhelms HLL's fundamentally good accuracy per bit.

\medskip
\noindent \textbf{KMV for set operations on streams.} 
\edit{Given streams , let  denote the KMV sketch computed from stream .
A trivial way to use these sketches to estimate the number of distinct items  in the union stream 
is to let  denote the  smallest value in the union of the sketches, and let .
Then  is identical to the sketch that would have been obtained by running KMV directly on the concatenated stream ,
and hence  is an unbiased estimator for , by the same analysis as in the single-stream setting. 
We refer to this procedure as the ``non-growing union rule.''}

\edit{Intuitively, the non-growing union rule does not use all of the information available to it. The sets  contain up to 
distinct samples in total, but  ignores all but the  smallest samples. 
With this in mind, Cohen and Kaplan \cite{cohen2009leveraging} proposed the following 
adaptation of KMV to handle unions of multiple streams. We denote their algorithm by , and also refer to it as the
``growing union rule''.}

For each KMV  sketch  computed from stream , let  denote that sketch's value of . 
Define , and .
Then  is estimated by , 
and   is estimated by . 

\edit{At first glance, it may seem obvious that the growing union rule yields an estimator that is 
``at least as good'' as the non-growing union, since the growing union rule makes use of at least as many samples
as the non-growing rule. However, it is by no means trivial to prove that  is unbiased,
nor that its variance is dominated by that of the non-growing union rule.}
\kedit{Nonetheless, \cite{cohen2009leveraging} managed to prove this: they showed that  is unbiased and has
variance that is dominated by the variance of :}

As observed in \cite{cohen2009leveraging}, multiKMV can be adapted in a similar manner to handle set-intersections 
\edit{(see Section \ref{sec:intersections} for details).}




\medskip
\noindent \textbf{Adaptive Sampling for set operations on streams.} 
Adaptive Sampling can handle set unions and intersections with a \edit{similar ``growing union rule''} in which ``'' . Here,  denotes the threshold for discarding hash values that was computed by the th Adaptive Sampling sketch.
We refer to this algorithm as . 
\cite{gibbons2001estimating} proved epsilon-delta bounds on the error of , but did not derive expressions for mean or variance. 
However,  and  are both special cases
of our Theta-Sketch Framework, and in Section~\ref{sec:framework}
we will prove (apparently for the first time) that  is unbiased, and satisfies strong variance bounds.
\edit{These results have the following two advantages over the epsilon-delta bounds of \cite{gibbons2001estimating}. 
First, proving unbiasedness is crucial for obtaining estimators for distinct counts over subpopulations: these estimators are analyzed as a sum of a huge number of per-item estimates (see Theorem \ref{thm:unbiased} for details), and biases add up. Second, variance bounds enable derivation of confidence intervals that an epsilon-delta guarantee cannot provide, unless the guarantee holds for many values of delta simultaneously.
}


\subsection{Overview of the Theta-Sketch Framework}
In this overview, we describe the Theta-Sketch Framework in the multi-stream setting where the goal is to output , where  (we define the framework formally in Section \ref{app:framework}).
That is, the goal is to identify a very large class of sampling algorithms that can run on each constituent stream ,
as well as a ``universal'' method for combining the samples from each  to obtain a good estimator for .
We clarify that the Theta-Sketch Framework, and our analysis of it, yields unbiased estimators that are interesting even in the single-stream case, where .

 We begin by noting the striking similarities between the  and
 algorithms outlined in Section~\ref{sec:priorwork}. 
In both cases, a sketch can be viewed as pair  where  is a certain
threshold that depends on the stream, and  is a set of hash values which are all strictly less than .  
In this view, both schemes use the same estimator , and also the same growing
union rule for combining samples from multiple streams.  The only difference lies in their respective rules for
mapping streams to thresholds . 
The Theta-Sketch Framework
formalizes this pattern of similarities and differences.

\medskip
\noindent \textbf{The assumed form of the single-stream sampling algorithms.}
The Theta-Sketch Framework demands that each constituent stream  be processed by 
a sampling algorithm  of the following form. While processing , 
evaluates a ``threshold choosing function'' (TCF) . The final state of  must be of the form
, where  is the set of all hash values strictly less than  that were observed while processing . If we want to estimate  for non-trivial properties , then 
must also store the corresponding identifier that hashed to each value in .
Note that the framework itself does not specify the threshold-choosing functions . Rather, any specification of the TCFs
 defines a particular instantiation of the framework.

{\small
\begin{algorithm}[t]
{\small
\caption{\small{Theta Sketch Framework for estimating . The framework is parameterized by 
choice of TCF's (,,), one for each input stream.}}\label{code:framework}
\begin{algorithmic}[1]{\footnotesize
\vspace{0.5em}
\STATE \textbf{Definition:} Function samp[](, , )
\bindent
\STATE  
\STATE . \label{code:framework-line-3}
\RETURN .
\eindent
\vspace{0.5em}
\STATE \textbf{Definition:} Function ThetaUnion(Theta Sketches )
\bindent
 \STATE  . 
 \STATE . \label{code:framework-line-7}
 \RETURN .
 \eindent
\vspace{0.5em}
\STATE \textbf{Definition:} Function EstimateOnSubPopulation(Theta Sketch  produced from stream , Property  mapping identifiers to )
\bindent \RETURN  .
\eindent
}\end{algorithmic}
}
\end{algorithm}
}

\medskip
\noindent \textbf{Remark.} It might appear from Algorithm~\ref{code:framework} that for any TCF , the function  makes two passes over the input stream: one to compute , and another to compute .  However, in all of the instantiations we consider, both operations can be performed in a single pass.

\medskip
\noindent \textbf{The universal combining rule.} Given the states  of each of the  sampling algorithms when run on the streams ,
define , and  (see the function  in Algorithm \ref{code:framework}). 
Then  is estimated by , and  as 

(see the function  in Algorithm \ref{code:framework}).

\medskip
\noindent \textbf{The analysis.} Our analysis shows that, so long as each threshold-choosing function  satisfies a mild technical condition that we 
call \emph{1-Goodness}, then  is unbiased. We also show that if each  satisfies a certain additional condition that we call \emph{monotonicity}, then 
 satisfies strong variance bounds (analogous to the bound of Equation \eqref{growing-variance-dominates} for ).  
Our analysis is arguably surprising, because -Goodness does not imply certain properties that have
traditionally been considered important, such as permutation invariance, or  being a uniform
random sample of the hashed unique items of the input stream.

\medskip
\noindent \textbf{Applicability.}  To demonstrate the generality of our analysis, we identify several valid instantiations of the Theta-Sketch Framework. 
First, we show that the TCF's used in KMV and Adaptive Sampling both satisfy -Goodness and monotonicity, implying that  and  are both unbiased and 
satisfy the aforementioned variance bounds. For , this is a reproof
of Cohen and Kaplan's results \cite{cohen2009leveraging}, but for  the results are new.
Second, we identify a variant of KMV that we call ,  which is useful in multi-stream settings where the lengths of constituent streams are highly skewed.
We show that  satisfies both -Goodness and monotonicity. Third, we introduce a new sampling procedure that we call the \emph{Alpha Algorithm}. Unlike earlier algorithms, the Alpha Algorithm's
 final state actually depends on the stream order, yet we  
 show that it satisfies -Goodness, and hence
is unbiased in both the single- and multi-stream settings.
We also establish variance bounds on the Alpha Algorithm in the single-stream setting.
We show experimentally that the Alpha Algorithm, in both the single- and multi-stream settings, 
achieves a novel tradeoff between accuracy, space usage, update speed, and applicability. 

Unlike KMV and Adaptive Sampling, the Alpha Algorithm does not satisfy monotonicity in general. In fact, we have identified contrived examples
in the multi-stream setting on which the aforementioned variance bounds are (weakly) violated.
The Alpha Algorithm does, however, satisfy monotonicity under the promise that the  are pairwise disjoint, implying variance bounds in this case. 
Our experiments suggest that, in practice, the \edit{normalized} variance in the multi-stream setting is not much larger than in the pairwise disjoint case.
\edit{\subparagraph*{Deployment of Algorithms.}  Within Yahoo, the pKMV and Alpha algorithms are used widely. In particular,
stream cardinalities in Yahoo empirically satisfy a power law, with some very large streams and many short ones, and pKMV is an attractive option for such settings. 
We have released an optimized open-source implementation of our algorithms at \texttt{http://datasketches.github.io/}.}


\subsection{Formal Definition of Theta-Sketch Framework}
\label{app:framework}
The Theta-Sketch Framework is defined as follows. This definition is specific to the multi-stream setting where the goal is to output , where  is the union of constituent streams .
\begin{definition} \label{def:tsf}
The Theta-Sketch Framework consists of the following components:
 \begin{itemize}
  \item The data type , where  is a 
   threshold, and  is the set of all unique hashed stream items
    that are less than . We will generically use the term ``theta-sketch'' to refer to an instance
   of this data type.
  \item The universal ``combining function'' , defined in Algorithm~\ref{code:framework}, that takes as input a 
  collection of theta-sketches (purportedly obtained by running () on constituent streams ),
  and returns a single theta-sketch (purportedly of the union stream ).
  \item The function , defined in Algorithm~\ref{code:framework},
  that takes as input a theta-sketch  (purportedly obtained from some stream ) and a property 
  and returns an estimate of .
\end{itemize}
  Any instantiation of the Theta-Sketch Framework must specify a ``threshold choosing function'' (TCF), denoted ,
   that maps a target sketch size, a stream, and a hash function  to a threshold . 
   Any TCF  implies a ``base'' sampling procedure () that maps a target size, a stream , and a hash function to a theta-sketch
  using the pseudocode shown in Algorithm~\ref{code:framework}. One can obtain an estimate  for  by feeding the resulting theta-sketch
  into ().
  
  Given constituent streams , the instantiation obtains an estimate  of  by running () 
  on each constituent stream , feeding the resulting theta-sketches to () to obtain a ``combined'' theta-sketch for , and then running
  ()  on this combined sketch. 
\end{definition}

\medskip \noindent \textbf{Remark.}
Definition \ref{def:tsf} assumes for simplicity that the same TCF  is used in the base sampling algorithms run 
on each of the constituent streams. However, all of our results that depend only on -Goodness ({\em e.g.} unbiasedness
of estimates and non-correlation of ``per-item estimates'') hold even if different -Good
TCF's are used on each stream, and even if different values of  are employed.

\subsection{Summary of Contributions}
\label{sec:contributions}
In summary, our contributions are: (1) Formulating the Theta-Sketch Framework. (2) Identifying a mild technical condition (-Goodness) on TCF's ensuring that the framework's estimators 
are unbiased. If each TCF also satisfies a monotonicity condition, the framework's estimators come with strong variance bounds analogous to Equation \eqref{growing-variance-dominates}. 
(3) Proving , , and  all satisfy -Goodness and monotonicity, implying unbiasedness and variance bounds for each.
(4) Introducing the Alpha Algorithm, proving that it is unbiased, 
and establishing quantitative bounds on its variance in the single-stream setting.
(5) Experimental results showing that the Alpha Algorithm instantiation achieves a novel tradeoff between accuracy, space usage, update speed, and applicability.



\section{Analysis of the Theta-Sketch Framework}
\label{sec:framework}
\noindent \textbf{Section Outline.} 
Section~\ref{sec:exampleinstantiations} shows that KMV and Adaptive Sampling are both instantiations of the Theta-Sketch Framework.
Section~\ref{sec:sufficient-condition} defines -Goodness.
Sections~\ref{sec:kmv-sat} and~\ref{sec:adapt-sat} prove that the TCF's 
that instantiate behavior identical to  and  both satisfy -Goodness.
Section~\ref{sec:union-sat} proves that if a framework instantiation's
TCF satisfies -Goodness, then so does the TCF that is implicitly applied to the union stream via the composition of the 
instantiation's base algorithm and the function (). 
Section~\ref{sec:subpop-unbiased} proves that the estimator  for  returned by ()
is unbiased when applied to any theta-sketch produced by a TCF
satisfying -Goodness. Section~\ref{sec:variance} defines monotonicity and shows that -Goodness and monotonicity together imply variance bounds on . Section \ref{sec:intersections} explains how to tweak the Theta-Sketch Framework
to handle set intersections and other set operations on streams.
Finally, Section \ref{sec:pkmv} describes the  variant of KMV. 

\subsection{Example Instantiations}
\label{sec:exampleinstantiations} 
Define  to be the  smallest unique hash value in 
 (the hashed version of the input stream).
The following is an easy observation. 
\begin{observation}
\label{obs:kmv}
When the Theta-Sketch Framework is instantiated with the TCF , 
the resulting instantiation is equivalent to the 
algorithm outlined in  
Section~\ref{sec:priorwork}.
\end{observation}
Let  be any real value in . For any , define  to be the 
largest value of  (with  a
non-negative integer) that is less than . 
\begin{observation} 
\label{obs:adapt}
When the Theta-Sketch Framework is instantiated with the TCF 
the resulting instantiation is equivalent to , which 
combines Adaptive Sampling with a growing union rule (cf. Section~\ref{sec:priorwork}).\footnote{ 
Section~\ref{sec:priorwork} assumed that the parameter  was set to the most common value: .}
\end{observation}

\subsection{Definition of -Goodness}\label{sec:sufficient-condition}


The following circularity is a main source of technical difficulty in analyzing theta
sketches:
for any given identifier  in a stream , whether its hashed value 
will end up in a sketch's sample set  depends on a comparison of  versus a threshold  that
depends on  itself.
Adapting a technique from \cite{cohen2009leveraging}, we partially break this circularity by analyzing 
the following infinite family of projections of a given threshold choosing function . 

\begin{definition}[Definition of Fix-All-But-One Projection]\label{def:fabo-projection}
Let  be a threshold choosing function.
Let  be one of the  unique identifiers in a stream . Let  be a fixed assignment of 
hash values to all unique identifiers in  {\em except} for . 
Then the fix-all-but-one projection  of 
is the function that maps values of  to theta-sketch thresholds via the definition
 where  is the obvious combination of  and .
\end{definition}
\cite{cohen2009leveraging} analyzed similar projections under the assumption
that the base algorithm is specifically (a weighted version of) KMV; we will instead 
impose the weaker condition that every fix-all-but-one projection satisfies -Goodness, defined below.\footnote{We chose the name -Goodness due to the reference to Fix-All-But-\emph{One} Projections.}

\begin{definition}[Definition of -Goodness for Univariate Functions]\label{def:good-shape}
A function  satisfies -Goodness iff there exists a fixed threshold  such that:

\end{definition}


\noindent Figure~\ref{fig:six-shape-plots}  contains six examples of hypothetical projections of TCF's. 
Four of them satisfy -Goodness; the other two do not. 

\label{app:figures}
\begin{figure}
\begin{center}
\includegraphics[width=.5\linewidth]{resized-6-diagrams.pdf}
\end{center}
\caption{Six examples of hypothetical projections of TCF's. Four of them satisfy -Goodness; the other two do not.}
\label{fig:six-shape-plots}
\end{figure}






\begin{condition}[Definition of -Goodness for TCF's]\label{key-condition}
A TCF  satisfies -Goodness iff for every stream 
containing  unique identifiers, every label , and every fixed 
assignment  of hash values to the identifiers in ,
the fix-all-but-one projection  satisfies Definition~\ref{def:good-shape}.
\end{condition}


\subsection{TCF of  Satisfies -Goodness}\label{sec:kmv-sat}
The following theorem shows that the TCF used in KMV satisfies -Goodness. \begin{theorem}\label{thm:kmv-sat}
If , then every fix-all-but-one projection  of  satisfies -Goodness.
\end{theorem}
\begin{proof}
Let  be any specific fix-all-but-one-projection of .
We will exhibit the fixed value  that causes (\ref{shape-condition-a}) and (\ref{shape-condition-b})
to be true for this projection.
Let  and  respectively be the 'th and 
smallest hash values in . 
Then Subconditions (\ref{shape-condition-a}) and (\ref{shape-condition-b}) hold for
. There are three cases:
\begin{tighterdescription}
\item[Case ] 
In this case, 
. 
Since , 
(\ref{shape-condition-a}) holds because , and (\ref{shape-condition-b}) holds vacuously.
\item[Case ] 
In this case, 
. 
Since , 
(\ref{shape-condition-b}) holds because  , and (\ref{shape-condition-a}) holds vacuously.
\item[Case ] 
In this case, 
. 
Since , 
(\ref{shape-condition-b}) holds because  , and (\ref{shape-condition-a}) holds vacuously.
\end{tighterdescription}
\end{proof}




\subsection{TCF of  Satisfies -Goodness}\label{sec:adapt-sat}
The following theorem shows that the TCF used in Adaptive Sampling satisfies -Goodness.
\begin{theorem}\label{thm:adapt-sat}
If , 
then every fix-all-but-one projection  of  satisfies -Goodness.
\end{theorem}
\begin{proof}
Let  be any specific fix-all-but-one-projection of .
We will exhibit the fixed value  that causes (\ref{shape-condition-a}) and (\ref{shape-condition-b})
to be true for this projection.
Let  and  respectively be the 'th and 
smallest hash values in . 
Then Subconditions (\ref{shape-condition-a}) and (\ref{shape-condition-b}) hold for
. There are four cases:

\begin{tighterdescription}
\item[Case ]
, so .
Since , (\ref{shape-condition-a}) holds because  ,
and (\ref{shape-condition-b}) holds vacuously.

\item[Case ]
, so .
Since , (\ref{shape-condition-b}) holds because  , 
and (\ref{shape-condition-a}) holds vacuously.

\item[Case ]
, so .
Since , (\ref{shape-condition-b}) holds because ,
and (\ref{shape-condition-a}) holds vacuously.

\item[Case ]
, so .
Since , (\ref{shape-condition-b}) holds because  ,
and (\ref{shape-condition-a}) holds vacuously.
\end{tighterdescription}
\end{proof}


\subsection{-Goodness Is Preserved by the Function }\label{sec:union-sat}
Next, we show that if a framework instantiation's TCF  satisfies -Goodness, 
then so does the TCF  that is implicitly being used by the theta-sketch construction 
algorithm defined by the composition of the instantiation's base sampling algorithms and the function ().
We begin by formally extending the definition of a fix-all-but-one projection to cover 
the degenerate case where the label  isn't actually a member of the given stream .

\begin{definition}\label{def:extended-projection}
Let  be a stream containing  identifiers. Let  be a label that is {\em not} a member of . 
Let the notation  refer to an assignment of hash value to {\em all} identifiers in .
For any hash value  of the non-member label ,
define the value of the ``fix-all-but-one'' projection
 to be the constant .
\end{definition}


\begin{theorem}\label{thm-union-preserves-condition} \label{thm:preserved}
If the threshold choosing functions  of the base algorithms used to create sketches 
of  streams  all satisfy Condition~\ref{key-condition},
then so does the TCF:

that is implicitly applied to the union stream via the composition of those base
algorithms and the procedure ().
\end{theorem}
\begin{proof}
Let  be any specific fix-all-but-one projection of the threshold choosing function 
 defined by Equation (\ref{eqn-define-tcfu}). We will exhibit the fixed value  that
causes (\ref{shape-condition-a}) and (\ref{shape-condition-b}) to be true for .

The projection  is specified by a label , and a set  
of fixed hash values for the identifiers in 
\mbox{}.
For each , those fixed hash values  induce a set  of 
fixed hash values for the identifiers in . 
The combination of  and  then specifies
a projection  of . 
Now, if , this is a fix-all-but-one projection according to the original Definition \ref{def:fabo-projection},
and according to the current theorem's pre-condition, this projection must satisfy -Goodness for univariate functions.
On the other hand, if , this is a fix-all-but-one projection according to the extended Definition 
\ref{def:extended-projection}, and is therefore a constant function, and therefore 
satisfies -Goodness.
Because the projection  
satisfies -Goodness
either way, there must exist a fixed value 
such that Subconditions (\ref{shape-condition-a}) and (\ref{shape-condition-b}) are true for . 

\noindent We now show that the value 
causes Subconditions (\ref{shape-condition-a}) and (\ref{shape-condition-b}) to be true for the projection
, thus proving that this projection
satisfies -Goodness.


\medskip 
\noindent {\bf To show:} 
. 
The condition  implies
that  for all , . Then, for all ,  
by Subcondition (\ref{shape-condition-a}) for the various . Therefore,
,
where the last step is by Eqn~(\ref{eqn-define-tcfu}).
This establishes Subcondition (\ref{shape-condition-a}) for the projection . 

\medskip
\noindent {\bf To show:} 
. Because ,
there exists a . 
By Subcondition (\ref{shape-condition-b}) for this , we have . By
Eqn~(\ref{eqn-define-tcfu}), we then have , thus establishing
Subcondition (\ref{shape-condition-b}) for . 

Finally, because the above argument applies to every
projection  of , we have proved the desired 
result that  satisfies condition~\ref{key-condition}.
\end{proof}



\subsection{Unbiasedness of ()}\label{sec:subpop-unbiased}
We now show that -Goodness of a TCF implies that the corresponding instantiation 
of the Theta-Sketch Framework provides unbiased estimates of the number of unique identifiers
on a stream or on the union of multiple streams.
\begin{theorem}\label{thm-key-property-implies-unbiased-for-single-streams} \label{thm:unbiased}
Let  be a stream containing  unique identifiers, and let  be a property evaluating to  on an arbitrary subset of the identifiers.
Let  denote a random hash function.
Let  be a threshold choosing function that satisfies Condition~\ref{key-condition}. 
Let  denote a sketch of  created by ,
and as usual let  denote the subset of hash values in  whose corresponding identifiers satisfy .
Then 
\end{theorem}


\noindent Theorems \ref{thm-union-preserves-condition} and \ref{thm-key-property-implies-unbiased-for-single-streams}  together
imply that, in the multi-stream setting, the estimate  for  output by the Theta-Sketch Framework is unbiased,
assuming the base sampling schemes () each use a TCF  satisfying -Goodness.

\begin{proof}
Let  be a stream, and let  be a Threshold Choosing Function that satisfies -Goodness. Fix any . For any assignment  of hash values to identifiers in ,
define the ``per-identifier estimate''  as follows:



\noindent Because  satisfies -Goodness, there exists a fixed threshold  for which it is
a straightforward exercise to verify that:



\noindent Now, conditioning on  and taking the expectation with respect to :



\noindent Since Equation \eqref{expectedeq} establishes that  when conditioned on each , we also have
 when the expectation is taken over all .
By linearity of expectation, we conclude that

\end{proof}


\noindent{\textbf{Is -Goodness Necessary for Unbiasedness?}}\label{section:negative-example}
Here we give an example showing
that -Goodness cannot be substantially weakened while still guaranteeing unbiasedness of the estimate 
 
returned by the Theta-Sketch Framework. 
By construction, the following threshold choosing function causes the 
estimator of the Theta-Sketch Framework to be biased upwards. 

Therefore, by the contrapositive of Theorem~\ref{thm:unbiased},
it cannot satisfy Condition \ref{key-condition}. 
It is an interesting exercise to try to 
establish this fact directly. It can be done by exhibiting a specific
target size , stream , and partial assignment of hash values  
such that no fixed threshold  exists that would satisfy
(\ref{shape-condition-a}) and (\ref{shape-condition-b}). Here is one such 
example: , . 
\begin{center}
\includegraphics[width=0.35\linewidth]{neg-tcf-plot.pdf}
\end{center}
The non-existence of the required fixed threshold is proved
by the above plot of . The only
value of  that would satisfy subcondition (\ref{shape-condition-a}) is 0.2.
However, that value does {\em not} satisfy (\ref{shape-condition-b}), 
because  for .


\subsection{-Goodness and Monotonicity Imply Variance Bound}
\label{sec:variance}

As usual, let  be the union of  data streams. 
Our goal in this section is to identify conditions on a threshold choosing function which guarantee the following: whenever the Theta-Sketch Framework is instantiated with a TCF  satisfying the conditions,
then for any property , the variance  of the estimator obtained from the Theta-Sketch Framework
is bounded above by 
the variance of the estimator obtained by running () on the stream  obtained by concatenating . 

It is easy to see that -Goodness alone is not sufficient to ensure such a variance bound.
Consider, for example, a TCF  that runs KMV 
on a stream  unless it determines that , for some fixed value , at which point it sets  to  (thereby causing () to sample all elements from ). 
Note that such a base sampling algorithm is not implementable by a sublinear space streaming algorithm, but  nonetheless satisfies -Goodness.
It is easy to see that such a base sampling algorithm will fail to satisfy our desired comparative variance result when run on constituent streams  satisfying  for all , and . 
In this case, the variance of 
 will be positive, while the variance of the estimator obtained by running  directly on  will be 0. 


Thus, for our comparative variance result to hold, we assume that  satisfies both -Goodness and the following additional monotonicity condition.


\begin{condition}[Monotonicity Condition] \label{mildcondition}
Let  be any three streams, and let  denote their concatenation. Fix any hash function  and parameter . Let , and . Then . 
\end{condition}
\begin{theorem} \label{thm:variance}
Suppose that the Theta-Sketch Framework is instantiated with a TCF  that satisfies Condition~\ref{key-condition} (-Goodness), as well as Condition \ref{mildcondition} (monotonicity). Fix a property , and
 let ,
\ldots , be  input streams.  Let  denote the union of the distinct labels in the input streams.
Let  denote the concatenation of the input streams.
Let , and let   denote the 
estimate of  obtained by 
evaluating .
Let , and 
let  
denote the estimate of  obtained by 
evaluating .
Then, with the randomness being over the choice of hash function ,

\end{theorem}
The proof of Theorem \ref{thm:variance} is somewhat involved, and is deferred to Appendix \ref{app:variance}. 

\medskip
\noindent \textbf{On the applicability of Theorem \ref{thm:variance}.}
\label{sec:applicability}
It is easy to see that Condition \ref{mildcondition} holds for any TCF that is (1) order-insensitive and (2)
has the property that adding another distinct item to the stream cannot increase the resulting threshold .
The TCF  used in  (namely, ), satisfies these properties, as does
the TCF used in Adaptive Sampling. Since we already showed that both of these TCF's satisfy -Goodness, Theorem \ref{thm:variance} applies
to  and .
In Section \ref{sec:pkmv}, we introduce the  algorithm, which is useful in multi-stream settings where the distribution of stream lengths is highly skewed, and we
show that Theorem \ref{thm:variance} applies to this algorithm as well. 



In Section \ref{sec:alpha},
we introduce the Alpha Algorithm and show that it satisfies -Goodness. Unfortunately, the Alpha Algorithm 
does not satisfy monotonicity in general. 
The algorithm does, however, satisfy monotonicity under the promise that  are pairwise disjoint, and Theorem \ref{thm:variance} applies in this case. 
Our experiments (Section \ref{app:webscope-experiment}) suggest that, in practice, the \edit{normalized} 
variance in the multi-stream setting is not much larger than in the pairwise disjoint case.
\subsection{Handling Set Intersections}\label{sec:intersections}
The Theta-Sketch Framework can be tweaked in a natural way to handle set intersection and other set operations, just as was the case
for  (cf. Section \ref{sec:IKMV}).
Specifically, define , and .
The estimator for  is . 

It is not difficult to see that  is exactly equal to , where  is the property that evaluates to 1 on an identifier if and only if
the identifier satisfies  and is also in . Since the latter estimator was already shown to be unbiased with variance bounded as per Theorem \ref{thm:variance},
 satisfies the same properties. 


\eat{\subsection{Practical Notes}\label{sec:practical-notes}

It might appear from Algorithm~\ref{code:framework} that the Theta-Sketch Framework makes two passes over the 
input stream: one to compute , and another one to compute .  Actual instantiations of the framework (such as when
the base algorithms are KMV, Adaptive Sampling, pKMV, or the Alpha Algorithm) can
perform both operations in a single pass. 

Also, it is highly advantageous for real systems to be able to compute and save the results of 
sub-expressions of larger set expressions as soon as the necessary data becomes available. Because 
theta-sketches remember the sampling level via , it is possible to simply drop
samples from  that don't satisfy a set expression.\footnote{By contrast, the AKMV system
of \cite{beyer2009distinct} must keep those ``non-satisfying samples'' as placeholders, so it marks them using a
extra vector of  bits that is included in each sketch.} An implementation of the
Theta-Sketch Framework can enable this ``sketches from set expressions''
feature by providing the following function SetOp2(). 
Arbitrary set expressions can then be handled in the obvious way using evaluation trees.

\begin{algorithmic}[1]{\small
\STATE Function SetOp2 (, , {\bf op}  )
\STATE .
\STATE .
\RETURN .}
\end{algorithmic}
}
\subsection{The pKMV Variant of KMV}
\label{sec:pkmv}


\label{app:pkmv}
\noindent \textbf{Motivation.}
An internet company involved in online advertising typically faces
some version of the following problem: there is a huge stream of
events representing visits of users to web pages, and a huge
number of relevant ``profiles'', each defined by the combination of a predicate
on users and a predicate on web pages. On behalf of advertisers, the
internet company must keep track of the count of distinct users
who generate events that match each profile. The distribution (over profiles)
of these counts typically is highly skewed and covers a huge dynamic
range, from hundreds of millions down to just a few.

Because the summed cardinalities of all profiles is huge, the brute
force technique (of maintaining, for each profile, a hash table of distinct user ids) would use an impractical amount of space.  
A more sophisticated approach would be to run ,
treating each profile as separate stream . This effectively replaces each hash table in the brute force approach with a KMV sketch.
The problem with  in this setting is that, while KMV does avoid storing the entire data stream for streams containing more than  distinct identifiers, KMV
produces no space savings for streams shorter than . 
Because the vast majority of profiles contain only a few users, replacing the hash tables in the brute force approach by KMV
sketches might still use an impractical amount of space.


On the other hand, fixed-threshold sampling with  for a suitable sampling rate , would
always result in an expected factor  saving in space, relative to storing the entire input stream. 
However, this method may result in too large a sample rate for long streams (i.e., for profiles satisfied by many users), also resulting in an impractical amount of space.


\noindent \textbf{The  algorithm.} In this scenario, the hybrid Threshold Choosing Function  can be a useful compromise, as it ensures that even short streams get downsampled by a factor of ,
while long streams produce at most  samples. 
While it is possible to
prove that this TCF satisfies -Goodness via a direct case analysis, the property
can also established by an easier argument: Consider a hypothetical
computation in which the  procedure is used to combine two
sketches of the same input stream: one constructed by KMV with
parameter , and one constructed by fixed-threshold sampling with
parameter .  Clearly, this computation outputs . Also, since KMV and fixed-threshold sampling both
satisfy -Goodness, and  preserves -Goodness (cf. Theorem \ref{thm:unbiased}),  also satisfies -Goodness.

It is easy to see that Condition \ref{mildcondition} applies to  as well. Indeed,
 is clearly order-insensitive, so it suffices to show that adding an additional identifier to the stream cannot
increase the resulting threshold. Since  never changes,
the only way that adding another distinct item to the stream could increase the threshold would be
by increasing . However, that cannot happen.






\section{Alpha Algorithm}
\label{sec:alpha}
\subsection{Motivation and Comparison to Prior Art}
Section \ref{sec:framework}'s
theoretical results 
are strong because they cover such a wide class of base sampling algorithms. In fact, -Goodness even 
covers base algorithms that lack certain traditional properties such as invariance to permutations of the 
input, and uniform random sampling of the input. We are now going to take advantage of these strong
theoretical results for the Theta Sketch Framework by devising a novel base sampling algorithm that lacks those traditional
properties, but still satisfies -Goodness. Our main purpose for describing our Alpha Algorithm in detail
is to exhibit the generality of the Theta-Sketch Framework. Nonetheless the Alpha Algorithm does have the following advantages relative to HLL, KMV, and Adaptive Sampling.

\medskip
\noindent \textbf{Advantages over HLL.} Unlike HLL,
the Alpha Algorithm provides unbiased estimates for
 queries for non-trivial predicates . Also, when instantiating the Theta-Sketch Framework
via the Alpha Algorithm in the multi-stream setting, the error behavior scales better than HLL for general set operations (cf. Section \ref{sec:priorwork}). Finally,
because the Alpha Algorithm computes a sample, its output is human-interpretable and amenable to post-processing. 

\medskip
\noindent \textbf{Advantages over KMV.} Implementations of KMV must either use a heap data structure or quickselect \cite{quickselect61} to give quick access to the 

smallest unique
hash value seen so far. The heap-based implementation yields  update time, and quickselect, while achieving  update time, hides a large constant factor in the Big-Oh notation
(cf. Section \ref{sec:priorwork}).  
The Alpha Algorithm avoids the need for a heap or quickselect, yielding superior practical performance. 


\medskip
\noindent \textbf{Advantages over Adaptive Sampling.} The accuracy of Adaptive Sampling oscillates as  increases. The Alpha Algorithm avoids this
behavior. 

\medskip
The remainder of this section provides a detailed analysis of the Alpha Algorithm. In particular, we show that it satisfies -Goodness, and 
we give quantitative bounds on its variance in the single-stream setting. 
Later (see Section \ref{app:experiments}), we describe experiments showing that, in both the single- and multi-stream settings, the Alpha Algorithm
achieves a novel tradeoff between accuracy, space usage, update speed, and applicability. 

\paragraph{Detailed Section Roadmap.} Section \ref{sec:alpha-tcf} describes the 
threshold choosing function AlphaTCF that creates the instantiation
of the Theta Sketch Framework whose base algorithm we refer to as the Alpha Algorithm.
Section~\ref{sec:alpha-sat} establishes that AlphaTCF satisfies -Goodness, implying, via 
Theorem~\ref{thm-key-property-implies-unbiased-for-single-streams}
that EstimateOnSubPopulation() is unbiased on single streams and on unions and intersections of streams in the framework
instantiation created by plugging in AlphaTCF.
 Section~\ref{sec:alpha-space} bounds the space usage of the Alpha Algorithm, as well as its variance in
 the single-stream setting. Section \ref{multistream} discusses
the algorithm's variance in the multistream setting. Finally, 
Section \ref{sec:hipsec} describes the HIP estimator derived from the Alpha Algorithm (see Section \ref{app:priorwork} for an introduction to HIP estimators).


\label{app:alpha}

\subsection{AlphaTCF}\label{sec:alpha-tcf}

Algorithm~\ref{code:alpha-tcf} describes the threshold choosing function AlphaTCF. AlphaTCF can be
viewed as a tightly interleaved combination of two different processes. One process uses the set  to remove
duplicate items from the raw input stream; the other process uses \edit{uses a technique similar to} Approximate Counting \cite{morris1978counting}
to estimate the number of items in the de-duped stream created by the first process. In addition, the second
process maintains and frequently reduces a threshold  that is used by the first process to identify 
hash values that {\em cannot} be members of , and therefore don't need to be placed in the de-duping set ,
thus limiting the growth of that set.

If the set  is implemented using a standard dynamically-resized
hash table, then well-known results imply that the amortized cost\footnote{Recent
theoretical results imply that the update time can be made worst-case  \cite{deamortizedcuckoo1, deamortizedcuckoo2}.}
of processing each stream element is , and the space occupied by
the hash table is , which grows logarithmically with .

However, there is a simple optimized implementation of the Alpha
Algorithm, based on Cuckoo Hashing, that implicitly, and at zero cost,
deletes all members of  that are not less that , and therefore
are not members of  (see Section \ref{sec:experiments}). This does not affect correctness, because those 
deleted members will not be needed for future de-duping tests of hash
values that will all be less than . Furthermore, in Theorem~\ref{space-theorem} below, it
is proved that  is tightly concentrated around . Hence, the
space usage of this optimized implementation is  with probability .


\begin{algorithm}[t]
\caption{The Alpha Algorithm's Threshold Choosing Function}\label{code:alpha-tcf}
\begin{algorithmic}[1]{\footnotesize
\STATE Function AlphaTCF (target size , stream , hash function )
\STATE .
\STATE prefix shortest prefix of  containing exactly
        unique hash values.
\STATE suffix the corresponding suffix.
\STATE  the set of unique hash values in prefix.  \STATE .
\FORALL{}
\IF{}  \label{code:alpha-tcf-line-8}
\IF{}  \label{code:alpha-tcf-line-9}
\STATE . \label{code:alpha-tcf-line-10}
\STATE .
\ENDIF
\ENDIF
\ENDFOR
\RETURN . \label{code:alpha-tcf-line-15}
}\end{algorithmic}
\end{algorithm}



\subsection{AlphaTCF Satisfies -Goodness}\label{sec:alpha-sat}

We will now prove that AlphaTCF satisfies -Goodness.

\begin{theorem}\label{thm:alpha-sat}
If  AlphaTCF, then every fix-all-but-one projection  of  satisfies -Goodness.
\end{theorem}
\begin{proof}
Fix the number of distinct identifiers  in . Consider any identifier  appearing in the stream,
and let  be its hash value. Fix the hash values of all other elements of the sequence of values .
We need to exhibit a threshold  such that  implies  and  implies .

First, if  lies in one of the first  positions in the stream, then  is a constant independent of ; in
this case,  can be set to that constant.






Now for the main case, suppose that  does not lie in one of the first  positions of the stream.
Consider a subdivision of the hashed stream into the initial segment preceding , 
then  itself, then the final segment that follows . Because all hash values besides  are fixed in ,
during the initial segment, there is a specific number  of times that 
 is decreased. When  is processed,  is decreased either zero or one times,
depending on whether .
Then, during the final segment,  will be decreased a certain number of additional times, where 
this number depends on whether . Let  denote the number of additional times 
is decreased if , and  the number of additional times  is decreased otherwise.
This analysis is summarized in the following table:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Rule & Condition on  & Final value of  \\
\hline
\edit{L} &  &  \\
\hline
\edit{G} &  &  \\
\hline
\end{tabular}
\end{center}


We prove the theorem using the threshold . We note that
, so  and  divide the range of 
into three disjoint intervals, creating three cases that need to be considered.

Case 1: . In this case, because , we need to show that .
By Rule \edit{L}, .

Case 2: . Because , we need to show that . 
By Rule \edit{L}, .

Case 3: . Because , we need to show that . 
By Rule \edit{G}, .
\end{proof}

\subsection{Analysis of Alpha Algorithm on Single Streams}\label{sec:alpha-space}
The following two theorems show that the Alpha Algorithm's space usage
and single-stream estimation accuracy are quite similar to those of KMV.
That means that it is safe to use the Alpha Algorithm as a drop-in replacement
for KMV in a sketching-based big-data system, which then allows the system to benefit 
from the Alpha Algorithm's low update cost. See the Experiments in Section~\ref{app:experiments}.

\noindent \textbf{Random Variables.} When Line~\ref{code:alpha-tcf-line-15} of
Algorithm~\ref{code:alpha-tcf} is reached after processing a randomly hashed
stream, the program variable  is governed by a random variable .
Similarly, when Line~\ref{code:framework-line-3} of Algorithm~\ref{code:framework}
is subsequently reached, the cardinality of the set  is governed by a random 
variable . The following two theorems characterize the distributions
of  and of the Theta Sketch Framework's estimator .
Specifically, Theorem \ref{space-theorem} shows that the number of elements sampled by the Alpha Algorithm is tightly concentrated around ,
and hence its space usage is concentrated around that of KMV.
Theorem \ref{thm:alpha-basic-variance} shows that the variance of the estimate returned by the Alpha Algorithm
is very close to that of KMV.
Their proofs are rather involved, and are deferred to Appendices \ref{appendix-proof-of-space-theorem} and
\ref{appendix-proof-of-alpha-basic-variance} respectively.

\begin{theorem}\label{space-theorem}
Let  denote the cardinality of the set  computed by the Alpha Algorithm's Threshold Choosing Function (Algorithm~\ref{code:alpha-tcf}). Then:

\end{theorem}



\begin{theorem}\label{thm:alpha-basic-variance}
Let  denote the cardinality of the set  computed by the Alpha Algorithm's Threshold Choosing Function (Algorithm~\ref{code:alpha-tcf}). Then:

\end{theorem}

\subsection{Variance of the Alpha Algorithm in the Multi-Stream Setting}
\label{multistream}
Unfortunately, the Alpha Algorithm does not satisfies monotonicity (Condition \ref{mildcondition}) in general,
and hence Theorem \ref{thm:variance} does not immediately imply variance bounds
in the multi-stream setting. In fact, we have identified contrived examples
in the multi-stream setting on which the variance of the Theta-Sketch Framework when instantiated with the TCF of the Alpha Algorithm
is slightly larger than the hypothetical estimator obtained by running the Alpha Algorithm on the concatenated stream  (the worst-case
setting appears to be when  are all permutations of each other). 

However, we show in this section that the Alpha Algorithm does satisfy monotonicity under the promise that all constituent streams are pairwise disjoint.
This implies the variance guarantees of Theorem \ref{thm:variance} do apply to the Alpha Algorithm under the promise that  are pairwise disjoint.
Our experiments in Section~\ref{app:webscope-experiment} suggest that, in practice, the \edit{normalized} variance of the Alpha Algorithm in the multi-stream setting is not much larger than in the pairwise disjoint case.

\begin{theorem}
The TCF computed by the Alpha Algorithm satisfies Condition \ref{mildcondition} under the promise that the streams  appearing
in Condition \ref{mildcondition} are pairwise disjoint.
\end{theorem}
\begin{proof}
Inspection of Algorithm~\ref{code:alpha-tcf} shows that the Alpha Algorithm never increases  while processing a stream.
Therefore, processing  after  cannot increase  above the value that it had at the end of processing
. Hence, it will suffice to prove that . Referring to Line~\ref{code:alpha-tcf-line-15} of the pseudocode, we see
that , where  is the final value of the program variable , so it suffices to
prove that . 

We will compare two execution paths of the Alpha Algorithm. The first path results from processing
 by itself. The second path results from processing . We will now
index the sequence of hash values of  in a special way:  will be the
first hash value that reaches Line~\ref{code:alpha-tcf-line-8} of the pseudocode during the first execution path (where  is
processed by itself). Elements of  that follow  will be numbered , while elements
of  that precede  will be numbered . We remark that
the boundary between negative and positive indices does not coincide with the boundary between  and .

For , let
 denote the value of the program variable  immediately before processing the hash value
 on the first execution path ( alone), and let  denote the same quantity for the second
execution path (). We will prove by induction that for all , .
The base case is trivial: by construction of our indexing scheme, at position , execution
path one has had no opportunities yet to increment , while execution path two might have had some opportunities to increment .
Hence  while . 

Now for the induction step. At position , , and the two values of 
are both integers, so the only possible way for  to occur would be for , and for the
tests at
Line~\ref{code:alpha-tcf-line-8}
and
Line~\ref{code:alpha-tcf-line-9} of the pseudocode to both {\em pass} on the first execution path, while at least one of them
{\em fails} on the second execution path. However, the test in Line~\ref{code:alpha-tcf-line-8} must have the same outcome for both paths,
since they are comparing the same hash value  against the same threshold . Also, given the
assumption that  and  are disjoint, the ``novelty test'' in Line~\ref{code:alpha-tcf-line-9} is
determined solely by novelty within
. Hence, it must have the same outcome on both paths. We conclude that it is impossible for  to be incremented on the
first path but not on the second path, so  is impossible.
\end{proof}

\subsection{HIP estimator} 
\label{sec:hipsec} 
For single streams, the HIP estimator (see Section \ref{app:priorwork} for an introduction to HIP estimators) derived from the Alpha 
Algorithm turns out to equal .
This estimator does not involve the size of the sample set , and is therefore not the same thing
as the estimator  derived by instantiating the Theta-Sketch Framework with 
the Alpha Algorithm.
The following theorem shows that the variance bound of the HIP estimator guaranteed by
Theorem \ref{thm:hip} is smaller than the variance bound for the
vanilla Alpha Algorithm (cf. Theorem \ref{thm:alpha-basic-variance}) by a
factor of 2. It 
can be proved by using the analysis of Approximate Counting
of \cite{morris1978counting,flajolet1985approximate},
or by using the analysis of HIP estimators of \cite{cohennew, ting}. To 
keep the paper self-contained, Appendix \ref{app:hip} contains
a proof of this result that utilizes several immediate results developed in the proof of
Theorem \ref{thm:alpha-basic-variance}.


\begin{theorem} \label{thm:hip} Let  denote the number of distinct elements in stream .
If , then: 

\end{theorem}

\eat{\subsection{Per-Position Sampling Probabilities}\label{sec:alpha-unconventional}

Let  be a pre-uniquified stream of length . 
When the Alpha Algorithm is used to map this stream to a theta-sketch 
using a randomly chosen hash function, then the hash value of the label located in each position of the stream has
a specific probability of ending up in the set . These ``per-position sampling probabilities'' are not equal,
and whatever formula they obey does not appear to be simple. However, it is possible
to carve up the full probability space into equivalence classes that enable an exhaustive combinatorial calculation
yielding the exact rational values of these sampling probabilities for specific values of  and .
For example, when  and :

\begin{center}
{\begin{tabular}{|c|c|}
\hline
pos & SamplingProbability(pos) \\
\hline
1-4 & 423681879 / 1073741824 \\
5   & 405084276 / 1073741824 \\
6   & 388441584 / 1073741824 \\
7   & 373366080 / 1073741824 \\
8   & 359606016 / 1073741824 \\
\hline
\end{tabular}}
\end{center}



Observe that the first  probabilities are equal, and are all greater than .
After that, the probabilities decrease monotonically to a final probability that is less than .
We conjecture that this same pattern occurs for any  and . 

Also, observe that Probability(first position) / Probability(last position) = 
. The following theorem states that this is true for any  and .



\begin{theorem}
The ratio between the Alpha Algorithm's sampling probabilities for the first and last positions of a pre-uniquified
stream does not exceed .
\end{theorem}
\begin{proof}
See extended version of this paper.
\end{proof}
 
}

\section{Experiments}
\subsection{Single-Stream Experiments Using Synthetic Data}
\label{sec:experiments}
\label{app:experiments}



In this section we describe experiments using synthetic data
showing that implementations of KMV, Adaptive Sampling, and the Alpha Algorithm can provide different tradeoffs
between time, space, and accuracy in the single-stream setting.
All three implementations take advantage of a version of cuckoo hashing
that treats as empty all slots containing hash values that are not
less than the current value of .

The code for our streaming implementation of the Alpha Algorithm
closely resembles the pseudocode presented as Algorithm~\ref{code:alpha-tcf}.
The de-duping set  is stored in a cuckoo hash table that uses the just-mentioned self-cleaning
trick. Hence  is in fact {\em always} equal to , with no extra
work needed in the form of table rebuilds or explicit delete operations.

Our implementation of Adaptive Sampling uses the same self-cleaning
hash tables, but has a different rule for reducing : multiply by 1/2
each time  reaches a pre-specified limit. Again, no delete operations
or table rebuilds are needed, but this program needs to scan the table
after each reduction in  to discover the current size of .

Finally, our implementation of KMV again uses the same self-cleaning
hash tables, but it also uses a heap to keep track of the current
value of . Hence it either uses more space than
the other two algorithms, or it suffers from a reduction in
accuracy due to sharing the space budget between the hash table
and the heap. Also, it is slower than the other two algorithms
because it performs heap operations in addition to hash table
operations.

Our experiments compare the speed and accuracy on single streams
of these implementations of the three algorithms. 
Accuracy was evaluated using the metric ,
measured during the course of 1 million runs of each algorithm.
We employed two different sets of experimental conditions. 

First, we compare under ``equal-'' conditions, in which all three
algorithms aim for , where  denotes the size of
the hash table. Adaptive Sampling is configured to oscillate between
roughly  and .  We remark that KMV
consumes more space than the other two algorithms under these
conditions because of its heap.

Second, we compare under ``equal-space'' conditions reflective of a
live streaming system that needs to limit the amount of memory
consumed by each sketch data structure. Under these conditions, KMV is
forced to devote half of its space budget to the heap, while both
Adaptive Sampling and the Alpha Algorithm are free to employ
parameters that cause their hash tables to run at occupancy levels
well over 1/2.  In detail, for KMV , for the Alpha
Algorithm , while Adaptive Sampling oscillates between
roughly  and .

Experimental results are plotted in Figure~\ref{fig:base-algo-tradeoffs}. Two things
are obvious. First, the heap-based implementation of KMV
is much slower than the other two algorithms. Second, the error curves
of Adaptive Sampling have a strongly oscillating shape that can be 
undesirable in practice.

Under the equal- conditions, the error curves of KMV and the Alpha
Algorithm are so similar that they cannot be distinguished from each
other in the plot. However, under the equal space conditions, the
Alpha Algorithm's ability to operate at a high, steady occupancy level (of
the hash table) causes its error to be the lowest of the three
algorithms. This high, steady occupancy level also causes the Alpha Algorithm
to be slightly slower than Adaptive sampling under these conditions,
even though the latter needs to re-scan the table periodically, 
while the Alpha Algorithm does not.

\begin{figure}
\begin{center}
\includegraphics[width=0.45\linewidth]{time-esa-equal-k.pdf}\quad
\includegraphics[width=0.45\linewidth]{faster-error-esa-equal-k.pdf} \\
\includegraphics[width=0.45\linewidth]{time-esa-equal-space.pdf}\quad
\includegraphics[width=0.45\linewidth]{faster-error-esa-equal-space.pdf} \\
\end{center}
\caption{These plots illustrate the low stream processing cost and non-oscillating
error curves of the Alpha Algorithm.}
\label{fig:base-algo-tradeoffs}
\end{figure}





\subsection{A Multi-Stream Experiment Using Real Data}
\label{sec:webscope-experiment}
\label{app:webscope-experiment}
As discussed in Section \ref{sec:applicability}, Theorem~\ref{thm:variance}'s comparative
variance result does not apply to the Alpha Algorithm in general. However, 
we proved in Section \ref{app:alpha} that Theorem \ref{thm:variance} does apply to the Alpha Algorithm when the
input streams are disjoint. In this section we present empirical
evidence suggesting that the Alpha Algorithm ``almost'' satisfies the variance bound of Theorem \ref{thm:variance} on real
data. Recall that Theorem \ref{thm:variance} asserted that  when the estimates are computed using TCFs satisfying -Goodness and monotonicity. 
Simplifying notation, and switching
from variance to relative error, we will exhibit a scatter plot
comparing  versus ,
for numerous pairs  of sets from a naturally occurring
dataset, using the TCF defined by the Alpha Algorithm. This scatter plot will show that only a tiny fraction of the
pairs violates the bound asserted in the theorem.

\begin{figure}
\begin{center}
\includegraphics[width=0.8\linewidth]{redone-webscope-plot.pdf}
\end{center}
\caption{Most points are below the red line, showing that the
comparative variance bound of Theorem~\ref{thm:variance} is ``nearly true'' for the Alpha Algorithm on the Webscope
Dataset.}
\label{fig:webscope-groups-scatter}
\end{figure}

\noindent \textbf{WebScope ``Groups'' Dataset.}
This experiment is based on
ydata-ygroups-user-group-membership-graph-v1\_0, a dataset that is
available from the Yahoo Research Alliance Webscope program.  It
contains anonymized and downsampled membership lists for about 640000
Yahoo Groups, circa 2005. Because of the downsampling, there are only
about 1 million members in all. We restricted our attention to the
roughly 10000 groups whose membership lists contained between 201 and
5429 members. Hence there were about 50 million pairs of groups to
consider.  Recalling that the comparative variance theorem applies to the Alpha Algorithm
under the promise that groups are disjoint, we trimmed this set of 50 million
pairs down to 5000 pairs that seemed most likely to violate the 
theorem because they had the highest overlaps as measured by the similarity score 
.
We also examined another 13000 pairs of groups to fill out the 
scatter plot.                                                                                      

For each of these roughly 18000 pairs of groups, we empirically
measured, by means of 100000 trials with  set to 128,
the values of  and
, and plotted them in the scatter plot
appearing as Figure~\ref{fig:webscope-groups-scatter}.
The 5000 high-overlap pairs are plotted in blue, while the other 13000
pairs are plotted in green.  Strikingly, all but 2 of the roughly
18000 points lie on or below below the red line, thus indicating an
outcome that is consistent with the comparative variance result.
Because we included every pair of sets that had large overlap
(as measured by ) we conjecture that all of the
other roughly 50 million pairs of sets also conform to the theorem.





Figure~\ref{fig:webscope-groups-scatter} also includes a heuristic
``bounding box'' plotted as a black quadrilateral.
This bounding box was computed numerically from
several ingredients.  For the  side of the
computation, we exploited the fact that for any given values of 
and , the Alpha Algorithm's exact distribution over  values
can be computed by dynamic programming using recurrences similar to
the ones described in \cite{flajolet1985approximate}.  
We also made
the (counter-factual) assumption that three different hash functions are
used to process the input sets  and , and the output set
. This breaks the dependencies which complicate the analysis of the actual
multi-stream instantiation of the Alpha Algorithm, in which only a single hash
function is used during any given run. However, this counter-factual
assumption also means that the resulting bounding
box is not quite accurate. Finally, we did a grid search over
all possible set-size pairs
 and all
possible amounts of overlap, and traced out the boundary of the
resulting combinations of computed relative errors.
This boundary (see Figure~\ref{fig:webscope-groups-scatter}) suggests
that the comparative variance theorem is true for nearly all {\em possible} triples
 where  and
. Moreover, in those relatively few
cases where the theorem is violated, the magnitude of the
violation is small.



\section{Detailed Overview of Prior Work}
\label{app:priorwork}
\subsection{Algorithms for Single Streams}
\noindent \textbf{HLL: HyperLogLog Sketches.}\label{subsubHLL}
HLL is a sketching algorithm for the vanilla \distinct\ problem. It uses a hash function to randomly distribute the elements of a stream  amongst  buckets.
For each bucket , there is a register , whose length is  bits, that essentially
contains the largest number of leading zeros in the hashed value of any stream element sent to that bucket.
For each stream element, this data structure can clearly be updated in  time.
The HLL estimator for  which we denote , is a certain non-linear function of the  bucket values ; 
see \cite{flajolet2008hyperloglog}. It has been proved by \cite{flajolet2008hyperloglog} that, as ,
, and . 

Unlike the KMV and Adaptive Sampling algorithms described below, it is not known how to extend the HLL sketch to estimate  for general properties  (unless, of course,  is known prior to stream
processing). 
Qualitatively, the reason that HLL cannot estimate 
is that, unlike the other algorithms, HLL does not maintain any kind of sample of identifiers from the stream.

\medskip
\noindent \textbf{KMV: K'th Minimum Value Sketches.}\label{subsubBKMV}
\label{sec:KMV}
The KMV sketching procedure for estimating \distinctA\ works as follows. While processing an input stream , KMV keeps track of the set  of the  smallest unique hashed values of stream elements.
The update time of a heap-based implementation of KMV is .
The KMV estimator for \distinctA\ is
 where  denotes the 'th smallest hash value.
It has been proved by \cite{beyer2009distinct}, \cite{giroire2009order}, and others, that , and


Duffield et al. \cite{DuffieldLT07} proposed to change 
the heap-based implementation of priority sampling
to an implementation based on quickselect \cite{quickselect61}. 
The same idea applies to KMV, which is a special case of priority sampling,
and it reduces the sketch update cost from  to amortized . 
However, this  has a larger constant factor than
that of competing methods.

The KMV sketching procedure can be extended to estimate  for any property , as explained below.
To accomplish this, the KMV sketch must keep not just the  smallest unique hash values that have been observed in the stream, but also 
the actual item identifiers corresponding to the hash values.\footnote{Technically, the sketch need not store the hash values if it stores the corresponding identifiers. 
Nonetheless, storing the hash values is often desirable in practice, to avoid the need to repeatedly evaluate the hash function.}
This allows the algorithm to determine which of the items in the sample
satisfy the property , even when  is not known until query time.

Motivated by the identity , the quantity  is a plausible
estimate of , for any sufficiently accurate estimate   of .
Let  denote the  smallest unique hashed values in , and recall (cf. Section \ref{sec:hashprelims}) that  denotes
the subset of hash values in  whose corresponding identifiers in  satisfy the predicate  (the reason we require
the sketch to store the actual identifiers that hashed to each value is to allow  to be determined from the sketch). 
Then the fraction  can serve as the desired estimate of the fraction . 
Essentially because  is a uniform random sample of , it can be proved
that the estimate  of  
is unbiased, and has the following variance:\footnote{\cite{beyer2009distinct} analyzed the closely related estimator
, where ,
proving unbiasedness and 
deriving the variance .}






\medskip \noindent \textbf{Adaptive Sampling.}\label{subsubAdapt}
Adaptive Sampling maintains a sampling level , and the set 
of all hash values less than ; whenever  exceeds a pre-specified
size limit,  is incremented and  is scanned discarding any hash value
that is now too big. Because a simple scan is cheaper than running
quickselect, an implementation of this scheme can be cheaper than
KMV. The estimator of  is . It has been proved by \cite{flajolet1990adaptive} that this
estimator is unbiased, and that , where the approximation sign hides oscillations caused
by the periodic culling of .  
Like KMV, Adaptive Sampling can be extended to estimate  for any property , via 
. Note that, just as for KMV, this extension requires storing not just the hash values in ,
but also the actual identifiers corresponding to each hash value.

Although the stream processing speed of Adaptive Sampling is excellent, the fact that its accuracy oscillates as  increases is a shortcoming of the method. 

\subsection{Algorithms for Set Operations on Multiple Streams}
\noindent \textbf{HLL Sketches for Multiple Streams.}\label{subsubHLL2}
 \begin{itemize}
 \item \textbf{Set Union.} A sketch of  can be constructed from  HLL sketches of the 's by taking
the maximum of the  register values for each of the  buckets. 
The resulting sketch is identical to an HLL sketch constructed directly from , so
, and
.

\item \textbf{Set Intersection.} Given constituent streams , the HLL scheme can be extended via the Inclusion/Exclusion (IE) rule to estimate \distinct\ 
for various additional set-expressions other than set-union applied to . 
This approach is awkward for
complicated expressions, but is straightforward for simple expressions. For example, if , then
the HLL+IE estimate of  is .

Unfortunately, the variance of this estimate is approximately
. This is a factor of  larger than the variance
of roughly  if one could somehow run HLL directly on , and a factor of  worse than the variance achieved by
the  algorithm described below. When , this penalty
factor overwhelms HLL's fundamentally good accuracy per bit.
\end{itemize}
In summary, the main limitations of HLL are its bad error scaling behavior when dealing with set operations other than set-union, 
as well as the inability to estimate \distinctP\ queries for general properties , even for a single stream . \\

\medskip \noindent \textbf{\IKMV: KMV for Multiple Streams.}\label{subsubBKMV2} \label{sec:IKMV}
 \begin{itemize}
 \item \textbf{Set Union.} 
For any property , there are two natural ways to extend KMV to estimate , 
given a KMV sketch  containing the  smallest unique hash values for each constituent stream . 
The first is to use a ``non-growing'' union rule, and the second is to use a ``growing'' union rule (our term). 

With the non-growing union rule, the sketch 
of  is simply defined to be the set of  smallest unique hash values in .
The resulting sketch is identical to a KMV sketch constructed directly from , so , and
. 
Just as the KMV sketch for a single stream  can be adapted to estimate  for any property , 
this multi-stream variant of KMV can be adapted to provide an estimate  of
.

The growing union rule
was introduced by Cohen and Kaplan \cite{cohen2009leveraging}.
This rule decreases the variance of estimates
for unions and for other set expressions, but also increases the space
cost of computing those estimates. Throughout, we refer to Cohen and Kaplan's algorithm as .
\label{subsubIKMV}
For each KMV input sketch , let  denote that sketch's value of . 
Define , and .
Then  is estimated by , 
and   is estimated by .
\cite{cohen2009leveraging} proved that  is unbiased and has
variance that 
dominates the variance of the ``non-growing'' estimator :



\item \textbf{Set Intersection.}  can be tweaked in a natural way to handle set intersection and other set operations.
Specifically, as in the set-union case, define , and . In addition, define .
The estimator for  is .
It is not difficult to see that  is exactly equal to , 
where  is the property that evaluates to 1 on an identifier if and only if
the identifier satisfies  and is also in . 
Since the latter estimator was already shown to be unbiased with variance bounded as per Equation \eqref{growing-variance-dominates},
 satisfies the same properties. 
\end{itemize}




\medskip \noindent \textbf{multiAdapt: Adaptive Sampling for Multiple Streams.}\label{subsubAdapt2}
\begin{itemize}
\item \textbf{Set Union.}
Just as with KMV, for any property , there are two natural ways to extend Adaptive Sampling 
to estimate , given an Adaptive Sampling sketch  for each constituent stream . 
The first is to use a non-growing union rule, and the second is to use a growing union rule. 
 For brevity, we will
only discuss the growing union rule, as proposed by
\cite{gibbons2001estimating}. We refer to this algorithm as . 
Let  be the sketch of the
'th input stream .  The union sketch constructed from these
sketches is ,\; .  
Then  is estimated by ,
and  is estimated by .  
\cite{gibbons2001estimating} proved epsilon-delta bounds on the error of the estimator
, but did not
derive expressions for mean or variance. However,  and  are in fact both special cases
of our Theta-Sketch Framework, and in Section~\ref{sec:framework}
of this paper we will prove (apparently for the first time) that  is unbiased.

\item \textbf{Set Intersection.} To our knowledge, prior work has not considered extending 
to handle set operations other than set-union on constituent streams. However, it is possible to tweak 
in a manner similar to  to handle these operations.
\end{itemize}


\subsection{Other Related Work}
\label{sec:related}
Estimating the number of distinct values for data streams is a well studied problem. The problem of estimating result sizes of set expressions over multiple streams 
was concretely formulated by Ganguly et al. \cite{ganguly2003processing}. 
Motivated by the question of handling streams containing both insertions and deletions, their construction
involves a 2-level hash function that essentially stores a set of counters for each bit-position of an HLL-type hash, 
and hence is inherently more resource intensive, both in terms of the space and update times. 

K'th Minimum Value sketches were introduced by Bar-Yossef et al. \cite{bar2002counting}, and developed into
an unbiased scheme that handles set expressions by Beyer et al. \cite{beyer2009distinct}.
Our own scheme is closely related to the schemes
proposed and analyzed in Cohen and Kaplan~\cite{cohen2009leveraging}, 
and in Gibbons and Tirthapura~\cite{gibbons2001estimating}.
Chen, Cao and Bu~\cite{chen2007simple} propose a somewhat different
scheme for estimating unique counts with set expressions
that is based on a data-structure related to the ``probabilistic counting'' sketches of \cite{flajolet1985probabilistic},
and also to the multi-bucket KMV sketches of \cite{giroire2009order} (with ).
However, the guarantees proved by \cite{chen2007simple} are asymptotic in nature,
and their system's union sketches are the same size as base sketches, and therefore do not provide the increased
accuracy that is possible with a ``growing'' union rule as in \cite{cohen2009leveraging}, in \cite{gibbons2001estimating},
and in this paper's scheme.

Bottom-k sketches~\cite{cohen2007summarizing,cohen2009leveraging} are a weighted generalization
of KMV that provides unbiased estimates of the weights of arbitrary subpopulations of identifiers.
They have small errors even under 2-independent hashing~\cite{thorup2013bottomk}. A closely 
related method for estimating subpopulation weights is priority sampling~\cite{DuffieldLT07}.
Although this paper's Theta-Sketch Framework offers a broad generalization of KMV, 
it is not clear that it can support the entire generality of bottom-k sketches for weighted sets. 



This paper's ``Alpha Algorithm'' is inspired by the elegant {\em Approximate Counting} 
method of Morris~\cite{morris1978counting}, that has previously been
applied to the estimation of the frequency moments , for . 
By contrast, {\em our} task is to estimate . The Alpha Algorithm is
able to do this because its Approximate Counting process is tightly
interleaved with another process that removes duplicates from the
input stream while maintaining a small memory footprint by using
feedback from the approximate counter.

Kane et al. \cite{kane2010optimal} gave a streaming algorithm for the \DistinctElements\ problem
that outputs a -approximation with constant probability, using
 bits of space. 
This improves over the bit-complexity of HLL by roughly a  factor (and avoids the assumption of truly random hash functions). 
Like HLL, it is not known how to extend the algorithm to handle  queries for non-trivial properties , and the algorithm does not appear to 
have been implemented \cite{heule2013hll}. 

Tirthapura and Woodruff \cite{finalcite} give sketching algorithms for estimating  queries
for a special class of properties . Specifically, they consider streams that contain tuples of the form , where 
is a numerical parameter, and the subpopulation  is specified via a lower or upper bound on . 

In very recent work, Cohen \cite{cohennew} and Ting \cite{ting} have proposed new estimators for \DistinctElements\ (called "Historical Inverse Probabililty" (HIP) estimators in \cite{cohennew}).
Any sketch which is generated by hashing of each element in the data stream and
is not affected by duplicate elements (such as HLL, KMV, Adaptive Sampling, and our Alpha Algorithm) has a corresponding HIP estimator, and \cite{cohennew, ting} show that the HIP estimator reduces the
variance of the original sketching algorithm by a factor of 2. However, HIP estimators, in general, can only be computed when processing the stream, and this applies
in particular to the HIP estimators of KMV and Adaptive Sampling. Hence, they do not satisfy the mergeablity properties necessary to apply to multi-stream settings. 











\begin{thebibliography}{10}

\bibitem{AMS99}
N.~Alon, Y.~Matias, and M.~Szegedy.
\newblock The space complexity of approximating the frequency moments.
\newblock {\em J. Comput. Syst. Sci.}, 58(1):137--147, 1999.

\bibitem{deamortizedcuckoo1}
Y.~Arbitman, M.~Naor, and G.~Segev.
\newblock De-amortized cuckoo hashing: Provable worst-case performance and
  experimental results.
\newblock In S.~Albers, A.~Marchetti{-}Spaccamela, Y.~Matias, S.~E.
  Nikoletseas, and W.~Thomas, editors, {\em Automata, Languages and
  Programming, 36th International Colloquium, {ICALP} 2009, Rhodes, Greece,
  July 5-12, 2009, Proceedings, Part {I}}, volume 5555 of {\em Lecture Notes in
  Computer Science}, pages 107--118. Springer, 2009.

\bibitem{deamortizedcuckoo2}
Y.~Arbitman, M.~Naor, and G.~Segev.
\newblock Backyard cuckoo hashing: Constant worst-case operations with a
  succinct representation.
\newblock In {\em 51th Annual {IEEE} Symposium on Foundations of Computer
  Science, {FOCS} 2010, October 23-26, 2010, Las Vegas, Nevada, {USA}}, pages
  787--796. {IEEE} Computer Society, 2010.

\bibitem{bar2002counting}
Z.~Bar-Yossef, T.~Jayram, R.~Kumar, D.~Sivakumar, and L.~Trevisan.
\newblock Counting distinct elements in a data stream.
\newblock In {\em Randomization and Approximation Techniques in Computer
  Science}, pages 1--10. Springer, 2002.

\bibitem{beyer2009distinct}
K.~Beyer, R.~Gemulla, P.~J. Haas, B.~Reinwald, and Y.~Sismanis.
\newblock Distinct-value synopses for multiset operations.
\newblock {\em Communications of the ACM}, 52(10):87--95, 2009.

\bibitem{chen2007simple}
A.~Chen, J.~Cao, and T.~Bu.
\newblock A simple and efficient estimation method for stream expression
  cardinalities.
\newblock In {\em Proceedings of the 33rd international conference on Very
  large data bases}, pages 171--182. VLDB Endowment, 2007.

\bibitem{cohennew}
E.~Cohen.
\newblock All-distances sketches, revisited: {HIP} estimators for massive
  graphs analysis.
\newblock In R.~Hull and M.~Grohe, editors, {\em Proceedings of the 33rd {ACM}
  {SIGMOD-SIGACT-SIGART} Symposium on Principles of Database Systems, PODS'14,
  Snowbird, UT, USA, June 22-27, 2014}, pages 88--99. {ACM}, 2014.

\bibitem{cohen2007summarizing}
E.~Cohen and H.~Kaplan.
\newblock Summarizing data using bottom-k sketches.
\newblock In {\em Proceedings of the Twenty-sixth Annual ACM Symposium on
  Principles of Distributed Computing}, PODC '07, pages 225--234, New York, NY,
  USA, 2007. ACM.

\bibitem{cohen2009leveraging}
E.~Cohen and H.~Kaplan.
\newblock Leveraging discarded samples for tighter estimation of multiple-set
  aggregates.
\newblock In {\em Proceedings of the eleventh international joint conference on
  Measurement and modeling of computer systems}, pages 251--262. ACM, 2009.

\bibitem{Cormode11sketch}
G.~Cormode.
\newblock Sketch techniques for massive data.
\newblock In G.~Cormode, M.~Garofalakis, P.~Haas, and C.~Jermaine, editors,
  {\em Synposes for Massive Data: Samples, Histograms, Wavelets and Sketches},
  Foundations and Trends in Databases. NOW publishers, 2011.

\bibitem{DuffieldLT07}
N.~G. Duffield, C.~Lund, and M.~Thorup.
\newblock Priority sampling for estimation of arbitrary subset sums.
\newblock {\em Journal of the ACM}, 54(6), 2007.

\bibitem{flajolet1985approximate}
P.~Flajolet.
\newblock Approximate counting: a detailed analysis.
\newblock {\em BIT Numerical Mathematics}, 25(1):113--134, 1985.

\bibitem{flajolet1990adaptive}
P.~Flajolet.
\newblock On adaptive sampling.
\newblock {\em Computing}, 43(4):391--400, 1990.

\bibitem{flajolet2008hyperloglog}
P.~Flajolet, {\'E}.~Fusy, O.~Gandouet, and F.~Meunier.
\newblock Hyperloglog: the analysis of a near-optimal cardinality estimation
  algorithm.
\newblock {\em DMTCS Proceedings}, 0(1), 2008.

\bibitem{flajolet1985probabilistic}
P.~Flajolet and G.~Nigel~Martin.
\newblock Probabilistic counting algorithms for data base applications.
\newblock {\em Journal of computer and system sciences}, 31(2):182--209, 1985.

\bibitem{ganguly2003processing}
S.~Ganguly, M.~Garofalakis, and R.~Rastogi.
\newblock Processing set expressions over continuous update streams.
\newblock In {\em Proceedings of the 2003 ACM SIGMOD international conference
  on Management of data}, pages 265--276. ACM, 2003.

\bibitem{gibbons2007distinct}
P.~B. Gibbons.
\newblock Distinct-values estimation over data streams.
\newblock {\em Data Stream Management: Processing High-Speed Data Streams, M.
  Garofalakis, J. Gehrke, and R. Rastogi, Eds. Springer, New York, NY, USA},
  2007.

\bibitem{gibbons2001estimating}
P.~B. Gibbons and S.~Tirthapura.
\newblock Estimating simple functions on the union of data streams.
\newblock In {\em Proceedings of the thirteenth annual ACM symposium on
  Parallel algorithms and architectures}, pages 281--291. ACM, 2001.

\bibitem{giroire2009order}
F.~Giroire.
\newblock Order statistics and estimating cardinalities of massive data sets.
\newblock {\em Discrete Applied Mathematics}, 157(2):406--427, 2009.

\bibitem{gronemeier2009applying}
A.~Gronemeier and M.~Sauerhoff.
\newblock Applying approximate counting for computing the frequency moments of
  long data streams.
\newblock {\em Theory of Computing Systems}, 44(3):332--348, 2009.

\bibitem{heule2013hll}
S.~Heule, M.~Nunkesser, and A.~Hall.
\newblock Hyperloglog in practice: Algorithmic engineering of a state of the
  art cardinality estimation algorithm.
\newblock In {\em EDBT '13}, pages 683--692, New York, NY, USA, 2013. ACM.

\bibitem{quickselect61}
C.~A.~R. Hoare.
\newblock Algorithm 65: Find.
\newblock {\em Communications of the ACM}, 4(7):321--322, July 1961.

\bibitem{kane2010optimal}
D.~M. Kane, J.~Nelson, and D.~P. Woodruff.
\newblock An optimal algorithm for the distinct elements problem.
\newblock In {\em Proceedings of the twenty-ninth ACM SIGMOD-SIGACT-SIGART
  symposium on Principles of database systems}, pages 41--52. ACM, 2010.

\bibitem{KnuthVol3Ed2}
D.~E. Knuth.
\newblock {\em The Art of Computer Programming, Volume 3: (2Nd Ed.) Sorting and
  Searching}.
\newblock Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA,
  1998.

\bibitem{morris1978counting}
R.~Morris.
\newblock Counting large numbers of events in small registers.
\newblock {\em Communications of the ACM}, 21(10):840--842, 1978.

\bibitem{muthukrishnan2005data}
S.~Muthukrishnan.
\newblock {\em Data streams: Algorithms and applications}.
\newblock Now Publishers Inc, 2005.

\bibitem{thorup2013bottomk}
M.~Thorup.
\newblock Bottom-k and priority sampling, set similarity and subset sums with
  minimal independence.
\newblock In {\em Proceedings of the Forty-fifth Annual ACM Symposium on Theory
  of Computing}, STOC '13, pages 371--380, New York, NY, USA, 2013. ACM.

\bibitem{ting}
D.~Ting.
\newblock Streamed approximate counting of distinct elements: Beating optimal
  batch methods.
\newblock In {\em Proceedings of the 20th ACM SIGKDD International Conference
  on Knowledge Discovery and Data Mining}, KDD '14, pages 442--451, New York,
  NY, USA, 2014. ACM.
  
  \bibitem{finalcite}
 S.~Tirthapura and D. P. Woodruff.
\newblock A General Method for Estimating Correlated Aggregates over a Data Stream. 
In \emph{Proceedings of ICDE}, pages 162-173, 2012.

\end{thebibliography}
 \appendix
\section{Proof of Theorem \ref{thm:variance}}
\label{app:variance}
\subsection{Proof Overview} 
The proof introduces the notion of the \emph{fix-all-but-two projection}
of a threshold choosing function . We then introduce 
a new condition on TCF's that
we call -Goodness (cf. Appendix \ref{sec:twogood}). On its face, -Goodness may appear to be a stronger requirement than -Goodness. However,
we show in Section \ref{1implies2} that this is not the case: -Goodness in fact implies -Goodness.\footnote{In fact, the two properties can
be shown to be equivalent. We omit the reverse implication, since we will not require it to establish our variance bounds.}
We show in Appendix \ref{sec:zerocovariance} that -Goodness implies that ``per-identifier estimates'' output by the Theta-Sketch Framework
are uncorrelated. Finally, in Section \ref{sec:finalvariance}, we use this result to complete the proof of Theorem \ref{thm:variance}.

\subsection{Definition of Fix-All-But-Two Projections and -Goodness}
\label{sec:twogood} 
We begin by defining the Fix-All-But-Two Projection of a TCF.

\begin{definition}\label{def:fabt-projection}
Let  be a threshold choosing function and fix a stream .
Let  be two of the  unique identifiers in . Let  be a fixed assignment of 
hash values to all unique identifiers in  {\em except} for  and . 
Then the fix-all-but-two projection  of 
is the function that maps values of  to theta-sketch thresholds via the definition
 where  is the obvious combination of , , and .
\end{definition}

Next, we define the notion of -Goodness for bivariate functions. 
\begin{definition}\label{def:bivariate2goodness}
Let  be a bivariate function. We say that  satisfies -Goodness if
there exists an  such that

\begin{itemize}
\item .
\item .
\end{itemize}
\end{definition}


Finally we are ready to define -Goodness for TCF's.

\begin{condition}\label{key-condition2}
A threshold choosing function  satisfies -Goodness iff for every stream 
containing  unique identifiers, every pair of identifiers , and every fixed 
assignment  of hash values to the identifiers in ,
the fix-all-but-two projection  satisfies Definition~\ref{def:bivariate2goodness}.
\end{condition}


\subsection{-Goodness Implies -Goodness}
\label{1implies2}
We are ready to show the (arguably surprising) result that if  satisfies -Goodness, then it also satisfies -Goodness. 

\begin{theorem} \label{thm:1implies2}
Let  be a threshold choosing function that satisfies -Goodness. Then  also satisfies -Goodness.
\end{theorem}
\begin{proof}
Let  be any fix-all-but-two projection of . Notice that
for any ,  is a fix-all-but-one projection of .
Similarly for any ,  is a fix-all-but-one-projection of . Hence, -Goodness of 
implies the following conditions hold:

\medskip \noindent \textbf{Property 1.} For each , there exists a  such that:
\begin{itemize}
\item .
\item .
\end{itemize}

\medskip \noindent \textbf{Property 2.} For each , there exists a  such that:
\begin{itemize}
\item .
\item .
\end{itemize}


To establish that  satisfies -Goodness, we want to prove that  there exists an  such that

\begin{itemize}
\item .
\item .
\end{itemize}

\noindent We will break the proof down into two lemmas.

\begin{lemma}\label{lemma1}
There exists an  such that
.
\end{lemma}
\begin{proof}

\noindent By Property 1 above, there exists a  such that 


\noindent Now consider any  in .
By Property 2 above, there exists a  such that:


\noindent Plugging  into Equation~\eqref{eqn2} gives
, while Equation~\eqref{eqn1} guarantees that
, so . Substituting 
into Equation~\eqref{eqn2} yields 


\noindent Because  was any value in the interval ), the lemma is proved with .
\end{proof}

\begin{lemma}\label{lemma2}
The threshold  whose existence was proved in Lemma~\ref{lemma1} also has the
property that if , then .

\end{lemma}
\begin{proof}
\noindent We start by assuming that , so at least one of the following must be true: 
() or (). 
Without loss of generality we will assume that . 
\noindent By Property 2 above, there exists an  such that
\begin{itemize}
\item .
\item .
\end{itemize}

\noindent Our proof will have two cases, determined by whether 
 or .

\noindent First case: . In this case, because , . Also, .
But , so . Putting this all together gives:


\noindent Second case: . In this case,
because ,

\end{proof}
\end{proof}

\begin{figure*}
\begin{center}
\includegraphics[width=0.5\linewidth]{two-lemmas-fig-maybe-cropped.pdf}
\end{center}
\caption{Some diagrams for Lemmas \ref{lemma1} and \ref{lemma2}}
\end{figure*}

\noindent \textbf{-Goodness Implies Per-Identifier Estimates Are Uncorrelated}
 \label{sec:zerocovariance}


\begin{lemma} \label{lemma:zerocovariances} Fix any stream , threshold choosing function , and pair  in . Define the ``per-identifier estimates''  and  as in Equation~\eqref{define-v-ell}. Then
if  satisfies -Goodness, the covariance of  and  is 0. In symbols,

\end{lemma}
\begin{proof}
Because  satisfies -Goodness, it also satisfies -Goodness (cf. Theorem \ref{thm:1implies2}), and hence there exists a threshold  for which it is a straightforward 
exercise to verify that:



\noindent Now, conditioning on  and taking the expectation with respect to pairs (, ):



\noindent Since 

when conditioned on each 
, 
we also have

when the expectation is taken over all .
Meanwhile, since  satisfies -Goodness, 
 (cf. Theorem \ref{thm:unbiased}).
Hence, .
\end{proof}

As a corollary of Lemma \ref{lemma:zerocovariances}, we obtain the following result, establishing that the variance 
of  is equal to the sum of the variances of the per-identifier estimates for all identifiers in  satisfying property .

\begin{lemma} \label{the_corollary} Suppose that  satisfies -Goodness. Fix any stream , and let 
denote the estimate for  obtained by running  on  and feeding the resulting theta-sketch into ().
Then

\end{lemma}
\begin{proof}
Note that . The claim then follows from Lemma \ref{lemma:zerocovariances} combined with the fact
that the variance of the sum of random variables equals the sum of the variances, provided that the variables appearing in the sum are uncorrelated. 


\end{proof}


\subsection{Completing the Proof of Theorem \ref{thm:variance}}
\label{sec:twoimpliesvariance}
\label{sec:finalvariance} 
\begin{proof}
For every  that appears in the concatenated stream , and for all ,
we define the ``per-identifier estimate''  as in Equation~\eqref{define-v-ell} with , and relate it to the threshold
 as in Equation~\eqref{v-in-terms-of-f}, also with . It is then straightforward to verify that



\noindent Let  be the TCF that was (implicitly) used to construct  from the  sketches of the individual streams .
By Theorem \ref{thm:preserved},  satisfies -Goodness, so let  denote the corresponding threshold value for  as in Equation~\eqref{v-in-terms-of-f}. 
We claim that  satisfies the following property:
 

\noindent \textbf{Finishing the proof, assuming  satisfies Property \ref{importantprop}.}
By Equation~\eqref{var-v-from-f}:



\noindent Because this inequality holds for every specific , it also holds for any convex combination over 
's, so 



Combining this with Lemma \ref{the_corollary},
we conclude that 


\noindent \textbf{Proving that  satisfies Property \ref{importantprop}.}
Fix any hash function , which determines , and also fixes hashed versions of
the streams  and . We will overload the symbols  and  to denote these hashed streams
as well as the original streams.
We need to prove that . 
This can be done in three steps. First, from the proof of Theorem~\ref{thm-union-preserves-condition}
we know that there exists a  such that .
Second, because  satisfies -Goodness, 
 and , where  is a function that 
makes a copy of a hashed stream in which  has been artificially set to zero.
Third,  can be rewritten as the concatenation of 3 streams as follows: , where , and . 
Because  was assumed to satisfy the monotonicity condition, Condition \ref{mildcondition}, we then have


\end{proof}

\section{Details of the Analysis of the Alpha Algorithm for Single Streams}

\subsection{Proof of Theorem~\ref{space-theorem}}\label{appendix-proof-of-space-theorem}

Let  be the set produced by 
Line~\ref{code:framework-line-3}
of
Algorithm~\ref{code:framework}
when AlphaTCF is plugged
into the Theta Sketch Framework, 
and let  be the random variable corresponding to .
In this section we compute  and bound . 

We prove the top-level theorem using a lemma. The proofs of the theorem and lemma
both involve two levels of conditioning. First we condition on the value  of  when 
Line \ref{code:alpha-tcf-line-15} of 
Algorithm~\ref{code:alpha-tcf} is reached.
Then we further condition on , which we define to be the
particular set of  stream positions on which increments occurred in 
Line~\ref{code:alpha-tcf-line-10} of Algorithm~\ref{code:alpha-tcf}.

\subparagraph*{Restatement of Theorem~\ref{space-theorem}.}




\begin{proof}
Using standard laws of probability, we perform the following decompositions:

In Lemma~\ref{space-lemma}, we prove that for all  and ,

Because this answer does not depend on , the RHS of 
Equation~\eqref{s-eqn-2} is a convex combination of equal values, so

Because this answer does not depend on , the RHS of 
Equation~\eqref{s-eqn-1} is a convex combination of equal values, so

In Lemma~\ref{space-lemma}, we also prove that

Because this answer does not depend on , the RHS of 
Equation~\eqref{s-eqn-4} is a convex combination of equal values, so

This answer {\em does} depend on , so we cannot use the exact same argument for a fourth time.
However, with a little bit of algebra, one can go from Equation~\eqref{s-eqn-5} to the inequality

whose RHS does not depend on . Then the RHS of Equation~\eqref{s-eqn-3}
is a convex combination of values that are all less than 
. So:

\end{proof}

\noindent Now we will prove the lemma that was used above:

\begin{lemma}\label{space-lemma}
For all  and ,

\end{lemma}
\begin{proof}
Because Line \ref{code:alpha-tcf-line-9} 
of Algorithm~\ref{code:alpha-tcf} causes the algorithm to ignore duplicate labels,
it will suffice to analyze a stream  of length  that doesn't contain any
duplicates.
Let  be a hash function that is
chosen randomly. Let  be a sequence of  {\em iid}
random variables, one per stream position, each drawn from the distribution Uniform(0,1). 
Let  be the cross product of the 's; this random variable is our model of .
 is distributed as a random variable generated by first choosing a random , then running Algorithm~\ref{code:alpha-tcf} on ,
and then setting  to be the value of the program variable  when Line~\ref{code:alpha-tcf-line-15} is reached.
Define a set of  Bernoulli random variables , one
per stream position, derived from the variable  and the variables
 by the rule  iff .
Note that the 's are {\em not} independent of each other. However, as we will see, they become 
independent after conditioning on the event ( and ).

Now we will describe the effect of conditioning on both  and ,
by first describing how the original variables  are transformed
into modified variables  that are drawn from specific
subintervals of .  We will then introduce new Bernoulli
variables  defined by the rule  iff , and finally compute the expected value and variance of
.


We are fixing a specific value  of  and  of ; the latter is a size- subset of the set of 
 non-initial stream positions .
The set of  non-initial stream positions that are not in  will be 
referred to as .
Let  be the function that maps any non-initial position
 to the number of non-initial positions before  that are members of .
We note that for , , and the
mapping is one-to-one.
For , , and the mapping is not necessarily one-to-one.

Now we are ready to characterize the 's and the 's. 

First let  be one of the  initial positions in the stream.
In this case, conditioning on  and  does not tell us anything about the value of ,
so  is drawn from the full interval , so ;
, and .

Next, let  be one of the  positions in . 
For this position, the test in 
Line \ref{code:alpha-tcf-line-8} of Algorithm \ref{code:alpha-tcf}
failed, so we know that ,
so  is drawn uniformly from the interval . Because ,
, so , 
so , , and .

Finally, let  be one of the  positions that are in . For this position,
the test in 
Line \ref{code:alpha-tcf-line-8} of Algorithm \ref{code:alpha-tcf}
succeeded, so we know that ,
so  is drawn uniformly from the interval , so
.
Now, because  assumes each value in  as
 is varied over the contents of ,  assumes each value in 
.
Similarly,  assumes each value in
. 
Note that the above analysis implies that the 's are independent of each other after conditioning on the 
event ( and ).

Putting together all of the above, and remembering that the random variables
 are independent due to the conditioning on  and :

Here, we have used the fact that .
In addition:

\end{proof}

\subsection{Proof of Theorem~\ref{thm:alpha-basic-variance}}\label{appendix-proof-of-alpha-basic-variance}



\noindent {\bf Preliminaries and Notation:} Because Line~\ref{code:alpha-tcf-line-9} 
of Algorithm~\ref{code:alpha-tcf} causes the algorithm to ignore duplicate labels,
it will suffice to analyze streams that do not contain any duplicates.
 and  are random variables giving
the final values of  and  when Line~\ref{code:alpha-tcf-line-15} of Algorithm
\ref{code:alpha-tcf} is
reached. Let  denote the
random variable for the estimate produced by the Theta Sketch
framework when the Alpha Algorithm's TCF is used. 
It will be convenient to introduce a new variable 
representing the number of stream items that are processed by the 
Alpha Algorithm {\em after}  initial items have been processed to
initialize the set .  Recall that . 










\subparagraph*{Restatement of Theorem~\ref{thm:alpha-basic-variance}.}

\begin{proof}
Due the 1-goodness of the Alpha Algorithm's TCF, we already 
know that  is an unbiased estimator for , i.e., that . Hence,


Lemma~\ref{lemma:e-z-sq} (stated and proved below) gives a formula for . This allows us to complete the 
the analysis of  as follows:

\end{proof}

\begin{lemma}\label{lemma:e-z-sq}

\end{lemma}
\begin{proof}


Above, we use the somewhat onerous notation  to emphasize that the distribution
of  depends on the fixed quantity  (i.e., on the number of distinct elements in the stream, minus ). Making this dependence explicit
will be useful later, when we analyze this distribution by establishing recurrences involving .

A formula for  appeared in Equation~\eqref{s-eqn-5}. 
Substituting this formula and continuing:


 

Define the function



\noindent where  is the probability distribution 
governing the random variable .
In Section~\ref{gqku-section} we prove Lemma~\ref{lemma:gqku-formulas}, which includes the following 
formula for :



By the definition of , we have that Expression \eqref{bigexpression} equals:
 

\noindent Finally, substituting Equation~\eqref{eqn:g-2-k-u}'s formula for  and performing
elementary algebra manipulations yields the result:


\end{proof}




\subsection{Analysis of the function }\label{gqku-section}

Recall from the proof of Lemma \ref{lemma:e-z-sq} that  is the probability distribution
governing the final value of the Alpha Algorithm's variable . The analysis
of approximate counting in \cite{flajolet1985approximate} includes an explanation
of why the following base cases and
recurrence define the distribution .



Recall that , and define the function  as in Equation \eqref{gdef}:



We will now prove two lemmas that partially characterize the function .
In Lemma~\ref{lemma:gqku-recurrences},  
we will prove that  satisfies a certain recurrence. In Lemma~\ref{lemma:gqku-formulas}
we will use that recurrence to prove the correctness of explicit formulas for 
, , and .

\begin{lemma}\label{lemma:gqku-recurrences}
 satisfies the following base cases and recurrence:

\end{lemma}
\begin{proof}
The base cases can be verified by inspection. The recurrence can be derived from the
recurrence for  as follows:
 
\noindent Now we will consider the two bracketed sums. For the first one:

\noindent For the second one (performing the change of variables ):

\noindent Adding (\ref{first-bracketed-sum}) and (\ref{second-bracketed-sum})
yields the claimed result:

\end{proof}

\begin{lemma}\label{lemma:gqku-formulas}
For all integers : 

\end{lemma}
\begin{proof}
 can be verified by inspection.

\vspace{0.5em}
\noindent The result for  can be proved by noting that
 satisfies the same base cases and recurrence as .
The base cases can be verified by inspection. The recurrence (\ref{eqn:gqku-recurrence})
can be verified as follows:


\vspace{0.5em}
\noindent The result for  can be proved by noting that
 satisfies the same base cases and recurrence as .
The base cases can be verified by inspection. The recurrence (\ref{eqn:gqku-recurrence})
can be verified as follows:

\end{proof}

\subsection{Analysis of the Alpha Algorithm's HIP Estimator: Proof of Theorem \ref{thm:hip}}
\label{app:hip}

\begin{proof}
As in Appendix~\ref{appendix-proof-of-alpha-basic-variance}, let
 , and let  denote the random variable
for the final value of the Alpha algorithm's variable .

\end{proof}






\end{document}
