
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amsmath}
\usepackage{amssymb}
\usepackage{adjustbox}
\usepackage{xspace}
\usepackage{float}
\usepackage{svg}
\usepackage{wrapfig}
\usepackage{CJKutf8}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\tiny\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}

\usepackage[colorinlistoftodos,prependcaption]{todonotes}
\newcommand{\todocomment}[1]{#1} \newcommand{\seb}[1]{\textcolor{magenta}{\todocomment{~Seb: #1}}}

\DeclareMathOperator{\concat}{concat}

\newcommand{\charformer}{\textsc{Charformer}\xspace}
\newcommand{\charformersmall}{\textsc{Charformer}\xspace}
\newcommand{\charformerbase}{\textsc{Charformer}\xspace}
\newcommand{\charformertall}{\textsc{Charformer}\xspace}
\newcommand{\charformertalllong}{\textsc{Charformer}\xspace}
\newcommand{\byte}{Byte-level T5\xspace}
\newcommand{\bytesmall}{Byte-level T5\xspace}
\newcommand{\bytebase}{Byte-level T5\xspace}
\newcommand{\canine}{Byte-level T5+LASC\xspace}
\newcommand{\caninesmall}{Byte-level T5+LASC\xspace}
\newcommand{\caninebase}{Byte-level T5+LASC\xspace}
\newcommand{\convbase}{Byte-level T5+Conv\xspace}


\title{Charformer: Fast Character Transformers via Gradient-based Subword Tokenization}



\author{Yi Tay, Vinh Q. Tran, Sebastian Ruder, Jai Gupta, Hyung Won Chung, Dara Bahri \\ \textbf{Zhen Qin, Simon Baumgartner, Cong Yu, Donald Metzler}\\ 
 Google Research and DeepMind\\
\texttt{yitay@google.com, vqtran@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
State-of-the-art models in natural language processing rely on separate rigid subword tokenization algorithms, which limit their generalization ability and adaptation to new settings. In this paper, we propose a new model inductive bias that learns a subword tokenization end-to-end as part of the model. To this end, we introduce a soft gradient-based subword tokenization module (GBST) that automatically learns latent subword representations from characters in a data-driven fashion. Concretely, GBST enumerates candidate subword blocks and learns to score them in a position-wise fashion using a block scoring network. We additionally introduce \charformer, a deep Transformer model that integrates GBST and operates on the byte level. Via extensive experiments on English GLUE, multilingual, and noisy text datasets, we show that \charformer outperforms a series of competitive byte-level baselines while generally performing on par and sometimes outperforming subword-based models. Additionally, \charformer is fast, improving the speed of both vanilla byte-level and subword-level Transformers by 28-100\% while maintaining competitive quality. We believe this work paves the way for highly performant token-free models that are trained completely end-to-end. 
\end{abstract}

\section{Introduction}

Neural networks have achieved tremendous success in natural language processing (NLP) by replacing feature-engineered models with stacks of functions that are learned end-to-end from vast amounts of data \citep{Mikolov2013word2vec,Peters2018elmo,Howard2018ulmfit}. The single component of the traditional NLP pipeline \citep{manning1999foundations} that has so far resisted gradient-based learning is tokenization, which is commonly applied as a pre-processing step. State-of-the-art pre-trained language models \citep{Devlin2019bert} generally rely on data-driven subword-based tokenization algorithms \citep{schuster2012japanese,sennrich-etal-2016-neural,Wu2016nmt,kudo-richardson-2018-sentencepiece}
while expert-crafted segmentation algorithms are still common for languages without whitespace separation such as Chinese, Thai, and Korean \citep[cf.][]{Lample2019xlm}.

This reliance on rigid tokenization methods introduces a bottleneck into current NLP systems that limits their capabilities. Subword segmentation algorithms split tokens into subwords solely based on frequency, without taking into account lexical or semantic similarity. As a result, models are brittle to rare words \citep{Gong2018frage} and perturbations, both natural and adversarial \citep{Belinkov2018,pruthi-etal-2019-combating,sun2020adv}. In multilingual models, tokens in low-resource languages are split into many subwords, which impacts performance on those languages and deteriorates cross-lingual transfer \citep{Hu2020xtreme,Wang2021multi-view}. Finally, a separate tokenization algorithm leads to a mismatch between the pre-training and downstream distribution of words when adapting pre-trained language models to new settings, which requires significant engineering effort to overcome.

The direct application of character-level modelling into pre-trained language models in turn results in severely increased computational and memory complexity due to an increased sequence length and generally lower performance. 

\begin{minipage}{0.51\linewidth}
To address this problem, we propose gradient-based subword tokenization (GBST), a new method that combines the compositionality of character-level representations with the efficiency of subword tokenization while enabling end-to-end learning. Our method learns latent subword representations from characters using large amounts of unlabeled data. Specifically, GBST learns a position-wise soft selection over candidate subword blocks by scoring them with a scoring network. In contrast to prior tokenization-free methods \citep{clark2021canine}, GBST learns interpretable latent subwords, which enables easy inspection of lexical representations and is more efficient than other byte-based models \citep{Xue2021byt5}. Given that simply applying a standard Transformer on a sequence of characters and bytes is computationally prohibitive, GBST paves the way for usable, practical and highly performant character-level models. A high level overview of how the GBST module is applied can be found at Figure \ref{overview}. \newline

We furthermore introduce \charformer, a Transformer encoder-decoder model that uses GBST to operate directly on the byte level. In addition, we experiment with a re-scaled variant of \charformer, which allocates additional capacity to the encoder to make up for the lack of discrete subword embeddings.
\end{minipage}
\hspace{0.04\linewidth}
\begin{minipage}{0.45\linewidth}
\begin{figure}[H]
  \vspace{-2em}
  \centering
  \includegraphics[height=200pt, keepaspectratio]{charformer-overview.png}
  \caption{High-level differences between traditional subword Transformer models and Charformer which uses gradient-based subword tokenization.} 
  \label{overview}
\end{figure}
\end{minipage}


We evaluate our model on a range of standard and non-standard English, and multilingual downstream tasks. On English GLUE and long document classification tasks, \charformer outperforms strong byte-level baselines and overall achieves performance on par with subword-based models such as BERT \citep{Devlin2019bert} and T5 \citep{Raffel2020t5}. On toxicity detection in social media datasets \citep{DBLP:journals/corr/abs-1903-04561,10.1145/3038912.3052591}, \charformer outperforms byte-level baselines as well as subword-based models, demonstrating robustness to spelling variation and non-standard language. Finally, a multilingually pre-trained \charformer performs on par or outperforms strong subword-based multilingual baselines on standard cross-lingual datasets.

We additionally demonstrate \charformer is more efficient compared to byte-level and subword-based models with similar numbers of parameters. On a comparable setup, \charformer out-performs a baseline similar to the recent state-of-the-art byte-level model ByT5 \citep{Xue2021byt5} while being  more memory efficient and 10--93\% faster. \charformer also trains 28\% faster than the subword-level mT5 model \citep{xue2020mt5}, has  fewer parameters and achieves comparable quality on well-established benchmarks. Finally, we demonstrate via visualization that the latent subwords learned by \charformer are interpretable to some extent.

\section{\charformer}

This section introduces our efficient character-level architecture, \charformer. \charformer is comprised of a Gradient-Based Subword Tokenization (GBST) module, followed by deep Transformer layers. The input to the GBST module is a sequence of characters or bytes\footnote{We choose bytes rather than characters (Unicode code points) as this allows us to use a vocabulary of 256 possible byte values for all settings. We note that for languages with a Latin alphabet, many characters correspond to a single byte. For other languages, each character corresponds to 2--3 bytes in general. For simplicity and to align with prior work, we will generally talk about characters unless stated otherwise.}, which is then downsampled to construct \emph{latent subwords}.  

\subsection{Gradient-Based Subword Tokenization (GBST)}
The input to GBST is a tensor of shape  where  is the number of input characters and  is the character embedding dimension. The key idea behind GBST is for the model to learn to perform a latent subword segmentation of the input by selecting the most suitable subword block at every character position. A block is a contiguous span of characters  of length  for .


\subsubsection{Constructing Candidate Latent Subword Blocks}  \label{sec:constructing_subword_blocks}

We first enumerate all possible subword blocks of size  up to a maximum block size . In order to learn subword block embeddings, we use a non-parameterized strided pooling function  that projects a subword block consisting of a sequence of character embeddings  to a single subword block representation  for block size  at position . We compute subword blocks  with a stride :

In practice we set , thus . The construction of latent subword blocks creates a shorter overall sequence length by downsampling. We construct  for , which can be seen in Figure \ref{fig:subword_blocks} for .

\noindent \textbf{Considering Offsets}  A limitation of a strided implementation is that it is unable to model all possible subword windows. For instance, for the character sequence  we would only be able to allocate  and  as subword blocks of length  and would ignore the subword block . Offsets can be used to model sliding windows of all possible subword blocks. We consider enumerating all possible strided blocks by additionally shifting sequences up until the offset . As this increases computation, we instead propose to first apply a 1D convolution to , prior to enumerating subword blocks. This effectively ``smoothes'' over the subword blocks. We use the variant with 1D convolutions in our main experiments and provide additional ablations in \textsection \ref{sec:ablations}.


\noindent \textbf{Considering Intra-block Positions}  It is important to preserve the ordering of the characters within the block . E.g., the output of  should differ for the blocks  and . For certain choices of  it may be valuable to add a positional embedding \citep{NIPS2017_3f5ee243} to  before applying . Note that this positional embedding would only be for individual blocks, and is not global to the entire input sequence. That is, only positional embedding values for positions  would be used. However, in practice we apply a 1D convolution before the GBST layer and use the mean-pooling function for . We find this to be sufficient to distinguish between same sized blocks with different character orders.

\subsubsection{Block Scoring Network}
In order to allow the model to learn which block to select for every character position, we introduce a block scoring network. The block scoring network is simply a parameterized function  that produces a score for each candidate block. Given a subword candidate block , we compute a score  associated with the block using a simple linear transformation :

We perform ranking of subword blocks with regard to each character position in the original sequence. At every position , the model learns to select the most suitable subword block  among all block sizes . As each sequence of subword blocks  is downsampled, we realign the representations of the subword blocks by upsampling each  to its original sequence length . Specifically, for a block size of , we replicate each block representation   times. We then score each candidate block at each position  using the softmax function:

which computes a relative score of each candidate block at each position and .  We show the scoring of realigned blocks in Figure \ref{fig:subword_blocks}.

\begin{figure}[t]
  \adjustbox{valign=t}{\minipage{0.55\linewidth}
    \includegraphics[height=80pt, keepaspectratio]{diagram.png}
    \newline
    \small{(a) Formation of subword blocks to be scored by . \newline Offsets and/or pre-GBST convolutions not shown.} 
  \endminipage}\hfill
  \adjustbox{valign=t}{\minipage{0.45\linewidth}
    \includegraphics[height=70pt, keepaspectratio]{diagram2.png}
    \newline\newline
    \small{(b) Block scores that have been expanded back to length . Softmax is taken over block scores at each position  to form block weights for constructing latent subword representations.} \label{fig:block_scoring}
  \endminipage}\hfill
  \caption{Illustration of subword block formation and scoring.}
  \label{fig:subword_blocks}
\end{figure}

\subsubsection{Forming Latent Subwords} \label{sec:latent_subwords}

We then sum the representations of all subword blocks  at each position  multiplied by their learned probability  to form a latent subword representation :

Intuitively, the model learns an ideal subword block for each position. In contrast to standard deterministic subword tokenization algorithms, this selection is \emph{soft} and can thus consider different possible segmentations at every position . In general, however, this formulation still assumes that subwords are contiguous sequences of characters. While additional context can be considered via the convolutions in \textsection \ref{sec:constructing_subword_blocks}, non-concatenative morphology where morphemes are discontinuous may be harder for the method to model.\footnote{Future work could explicitly seek to model discontinuous morphological processes by considering skip-grams in addition to character n-grams, although this would increase computational costs.}



\subsubsection{Position-wise Score Calibration}
In the above approach, the scoring of each position is independent of other positions. We hypothesize that it may be beneficial for block scores at each position to be aware of each other. To this end, we introduce an optional module that enables learning a consensus among block scores by calculating dot products across the scores  across all positions . This can be viewed as a form of self-attention across block scores, albeit without any projections for computational efficiency. To learn the new scores , we compute 

\subsubsection{Downsampling}
After learning a candidate block or mixture of blocks for each position, we use a downsampling function  that downsamples the sequence of latent subwords  to , reducing its sequence length by a factor of .
We choose  to be a non-parameterized mean pooling operation. Notably, such simple stride-based pooling removes potential redundancies caused by adjacent positions selecting similar blocks as the mean pool of two identical block embeddings produces the same outcome. Intuitively, as the downsampling operation is fixed, the parameterized components preceding it should learn an optimal subword tokenization given the downsampling.

\subsection{Transformer Stack} \label{sec:transformer-stack}

The remainder of the \charformer model remains identical to a regular Transformer encoder-decoder model. The Transformer stack operates on the downsampled latent subwords  instead of subword embeddings. 

\noindent \textbf{Re-scaling of the Transformer Stack}  While subword-based models allocate much of their capacity to subword embeddings---up to 71\% of all parameters for contemporary multilingual models \citep{Chung2021rembert}---, the character vocabulary of character-level models is much smaller and thus less expressive. Similar to \citet{Xue2021byt5}, we hypothesize that character-level models require deeper encoder stacks than subword-based models to make up for their smaller embedding capacity. 
Consequently, we explore a scaling variant of \charformer that puts more parameters at the encoder at the expense of the decoder while preferring a deep narrow model over a larger wide model. Specifically, we re-configure the Base model size to be similar to the T5 Small model size, with an expanded  layers in the encoder. The resulting \charformertall (Scaled Base) has  parameters, which is about 67\% the parameter footprint of the standard base T5 model \citep[200M parameters;][]{Raffel2020t5}. Moreover, this particular \charformer model is approximately 50-100\% faster than the T5 base model (see \textsection \ref{sec:speed}).\footnote{The benefits of such re-scaling have also been observed for subword-based encoder-decoder neural machine translation models \citep{devlin2017sharp,Kasai2021}.} For the re-scaled variant, we also used the GLU variant described in \citep{shazeer2020glu} which is commonly referred to as the V variant in the T5 library.



\noindent \textbf{A Note on Comparing Character-level and Subword-based Methods}  Prior work on efficient methods generally compares models with the same number of parameters \citep{Chung2021rembert}. However, whereas embedding look-up even with large vocabularies in subword-based methods is , re-distributing the subword embedding parameters in character-level models such as ByT5 \citep{Xue2021byt5} to dense layers incurs much higher computational costs---a 25\% penalty in training speed.
We believe that a fair re-scaling of character-level models should not only aim to match the number of parameters but also the compute and inference costs of subword-based models under the assumption that char/byte-level models will require longer sequences (see \textsection \ref{sec:speed} for a comparison).



\noindent \textbf{Span-based Pre-training}  Our pre-training scheme follows T5 quite closely. We mask  contiguous characters and train to predict them in a sequence-to-sequence architecture following \citet{Xue2021byt5}. The model optimizes the cross-entropy loss and is trained with teacher forcing.

\section{Experiments} \label{sec:experiments}

We evaluate our method both in English as well as in a multilingual setting on relevant benchmarks and compare against state-of-the-art character-level and subword-based methods.



\subsection{Experiments on monolingual English datasets} \label{sec:english-experiments}


\noindent \textbf{Data}  To showcase the effectiveness of the proposed method, we evaluate on a diverse set of standard English tasks from GLUE covering sentiment classification \citep[SST-2;][]{socher-etal-2013-recursive}, natural language inference \citep[MNLI, QNLI;][]{williams-etal-2018-broad,rajpurkar-etal-2016-squad}, paraphrase detection \citep[MRPC, QQP]{dolan2005automatically} and sentence similarity \citep{cer2017semeval}.  In addition, we evaluate on tasks that require dealing with long documents, both for sentiment analysis \citep[IMDb;][]{maas2011learning} and news classification \citep[AGNews;][]{Zhang2015character}.


\noindent \textbf{Baselines}  We compare \charformer against the following state-of-the-art subword-based models: BERT \citep{Devlin2019bert}, an encoder-only pre-trained masked language model; and T5 \citep{Raffel2020t5}, an encoder-decoder model. We also compare against \byte \citep{Xue2021byt5}, a T5 model that is directly applied to bytes. We additionally evaluate the impact of the downsampling in \charformer by comparing it to the downsampling used by the character-level CANINE \citep{clark2021canine} model in our framework. CANINE downsamples a character sequence using local attention and pooling via strided convolutions. As the original CANINE uses an encoder-only model and was only trained on multilingual data, we integrate CANINE-style downsampling into \byte, which we refer to as \canine (local attention–strided convolution).\footnote{Compared to CANINE, \canine does not operate on Unicode codepoints and has a decoder. It thus forgoes character hash embeddings and upsampling procedures respectively.} As an ablation for the GBST inductive bias, we compare against \convbase a convolutional baseline of Byte-level T5 with a 1D convolution of filter size 5 placed before the encoder. Note that in all the baselines and for \charformer base models, in the spirit of fair comparison, we compare them at an equal parameterization (size). Our scaling experiments are reserved for our  models, which is intended to only be compared with subword T5 models, and not to unscaled byte-level baselines. Finally, we include an  scaled version of \byte for comparison.



\noindent \textbf{Setup}  We evaluate Base and SBase configurations of \charformer with 203M and 134M parameters respectively. We compare to Base configurations of BERT and T5 that have a similar number of parameters. We pre-train all models on the C4 corpus for 1M steps using a batch size of  and sequence length of . All non-subword models use a vocabulary of 256 bytes.\footnote{Following \citet{Xue2021byt5} we discard illegal UTF-8 sequences and reuse the final 100 byte IDs as sentinel tokens.}
Our pre-training scheme corrupts spans with a mean length of  bytes. Each model is pre-trained on 16 TPU V3 chips. We pre-train our models with the Adafactor optimizer with an inverse square root learning rate. We then fine-tune on each individual task separately using a constant learning rate of . More details can be found in the Appendix.

\begin{table}
    \caption{Comparison of \charformer against other subword and character-level models with different parameter sizes on diverse standard English datasets.}
    \label{tab:glue}
    \begin{adjustbox}{width=\columnwidth,center}
    \centering
    \begin{tabular}{l c c ccccc cc cc}
    \toprule
        Model &  & &SST-2 & MNLI & QNLI & MRPC & QQP &
        STSB & COLA & AVG  \\
        \midrule
        BERT & 110M & & \underline{92.7} & \underline{84.4}/- & 88.4 & 86.7/- & - & - & - & -\\
T5 & 220M & & \underline{92.7}  & 84.2/84.6 & \underline{90.5} & \underline{88.9}/92.1 & 91.6/88.7  & 88.0 &53.8 & 84.3\\
        \cmidrule{1-11}


 
\bytebase & 200M&  & \underline{91.6} & 82.5/\underline{82.7} & 88.7 & \underline{87.3}/91.0 & 90.9/87.7 & 84.3 & 45.1 & \underline{81.5}\\ 
        \convbase & 205M  & & 89.8 & 81.1/82.5 & \underline{89.2} & 83.6/89.2 & 90.7/87.7 & 85.0 & \underline{47.1} & 81.2 \\
        \caninebase & 205M& & 90.0 & 80.0/80.8 & 87.1 & 82.8/88.1& 89.0/85.4 & 83.7 & 25.3 & 77.0\\
        \charformerbase &203M&  & \underline{91.6} & \underline{82.6}/\underline{82.7} & 89.0 & \underline{87.3}/\underline{91.1} & \underline{91.2}/\underline{88.1} & \underline{85.3}  & 42.6 & 81.4 \\
        \cmidrule{1-11}
        Byte-level T5 & 133M & &91.2 & \underline{83.9}/83.7 & 90.9 & 85.5/89.2 &91.1/88.1 & 85.7 & 49.3 & 82.6\\
        \charformertall & 134M &  & \underline{91.5} & {83.7}/\underline{84.4} & \underline{91.0}  & 
        \underline{87.5}/\underline{91.4} & \underline{91.4}/\underline{88.5} & \underline{87.3} & \underline{51.8} & \underline{83.6}\\
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\end{table}
\begin{minipage}{0.57\linewidth}
\begin{table}[H]
    \centering
    \caption{Results on comment classification on Civil Comments and Wiki Comments. Metrics are accuracy and AUC-PR. T5 baseline results are from \citep{tay2021pre}.}
    \label{tab:noisy-text}
    \resizebox{\textwidth}{!}{\begin{tabular}{l cc}
    \toprule
    Model & Civil Comments & Wiki Comments \\ 
    \midrule
    T5& 81.2 / -  &  91.5 / - \\
    \cmidrule{1-3}
\bytebase   & 82.8 / 78.7 & \underline{93.2} / 75.4 \\
    \caninebase & 82.9 / 78.2 &93.0 / 75.0 \\
    \charformerbase & \underline{83.0} / \underline{78.8}  & 92.7 / \underline{79.7}\\
    \midrule
    \charformertall & {83.0} / {78.9} & {93.5} / 75.5 \\
    \bottomrule
    \end{tabular}
    }
\end{table}
\end{minipage}
\hspace{0.03\linewidth}
\begin{minipage}{0.40\linewidth}
\vspace{1pt}
\begin{table}[H]
    \centering
    \caption{Results on text classification on long documents.}
    \label{tab:long-docs}
    \resizebox{\textwidth}{!}{\begin{tabular}{l cc}
    \toprule
    Model & IMDb & News \\ 
    \midrule
    T5&  94.2  & 93.5   \\
    \cmidrule{1-3}
\bytebase   & \underline{91.5} & 93.6 \\
    \caninebase & 91.1 & 93.5\\
    \charformerbase & \underline{91.5}  & \underline{94.0} \\
    \midrule
    \charformertall & {94.4}& 
    {94.1} \\
    \bottomrule
    \end{tabular}
    }
\end{table}
\end{minipage}
\vspace{0.25cm}

\noindent \textbf{Results}   For all result tables, we divide the table into three sections: subword baseline(s), un-scaled byte-level baselines, and scaled \charformer results. If a section and task combination has more than one model result, we underline the best result. We show result for GLUE in Table \ref{tab:glue}. \charformer outperforms other character-level baselines trained under the same conditions with the same number of parameters across all tasks, while being considerably faster and requiring less compute than T5-style models that are directly applied to bytes or characters (see \textsection \ref{sec:speed}). \charformertall performs even better despite having a smaller number of parameters compared to the Base configuration, demonstrating the usefulness of rescaling the transformer stack for character-level models. \charformertall furthermore is the only model that performs on par or even outperforms the standard subword-based models on some tasks in standard English. In Table \ref{tab:long-docs} we provide results for text classification of long documents. Here, \charformertall is the only byte-level model to outperform T5 on the IMDb classification task, and both \charformer models outperform byte and subword level baselines on AGNews.

\subsection{Experiments on non-standard English datasets}

The previous set of experiments demonstrated the ability of \charformer to perform well on clean datasets consisting of standard English. However, character-level models are particularly suited to data that is noisy, containing spelling variations, typos, and other non-standard language. 

\noindent \textbf{Data}  To demonstrate \charformer's ability to perform well on such data, we evaluate on toxicity detection using the Civil Comments \citep{DBLP:journals/corr/abs-1903-04561} and the Wikipedia Comments \citep{10.1145/3038912.3052591} datasets. Both are standard benchmarks that require estimating the toxicity of user-generated content. We use the same setup as for the standard English datasets.

\noindent \textbf{Results}  We show results in Table \ref{tab:noisy-text}. Character-level models outperform the subword-based T5 model on both datasets, demonstrating their suitability to deal with such noisy, user-generated data. \charformer achieves performs on par or outperforms other character-level methods on both datasets across the different model sizes.

\subsection{Multilingual Experiments} \label{sec:multilingual}



\noindent \textbf{Data}  To evaluate the effectiveness of character-level models on multilingual data, we evaluate on standard cross-lingual question answering and classification tasks. In particular, we evaluate on the question answering tasks TyDiQA-GoldP \citep{Clark2020tydiqa}, XQuAD \citep{Artetxe2020crosslingual}, and MLQA \citep{Lewis2020mlqa} as well as the natural language inference task XNLI \citep{Conneau2018xnli} and the paraphrase detection task PAWS-X \citep{Yang2019paws-x} from XTREME \citep{Hu2020xtreme}. We evaluate on the in-language multi-task setting for TyDiQA-GoldP \citep{Clark2020tydiqa} where models are fine-tuned on the combined gold data in all target languages and the translate-train-all setting where models are fine-tuned on English training data plus translations in all target languages for the other datasets. Both are the best-performing settings for the respective tasks in \citep{Hu2020xtreme}. In addition, we evaluate on zero-shot cross-lingual transfer from English on XNLI and PAWS-X.

\noindent \textbf{Baselines}  We compare to strong multilingual subword-based baselines including multilingual BERT \citep{Devlin2019bert} and multilingual T5 \citep{xue2020mt5}. In addition, we compare to the byte-level models from \textsection \ref{sec:english-experiments}, which we pre-train on multilingual data.

\begin{table} \centering
    \caption{Multilingual comparison of \charformer against subword and byte-level models on in-language multi-task, translate-train multi-task, and cross-lingual zero-shot (training on English) settings. Model sizes are the same as those in Table \ref{tab:glue}. mBERT and mT5 baseline results are from \citep{xue2020mt5}.}
    \label{tab:mc4}
    \resizebox{\textwidth}{!}{\begin{tabular}{l cc cc cccc ccc}
    \toprule
    & & & \multicolumn{1}{c}{In-Language} & & \multicolumn{4}{c}{Translate-Train-All} & & \multicolumn{2}{c}{Zero-Shot} \\
    \midrule
    Model &  & & TyDiQA-GoldP & & XQuAD & MLQA & XNLI & PAWS-X & & XNLI & PAWS-X \\
    \cmidrule{1-12}
    mBERT (Subword) & 179M & & 77.6/68.0 & & -/- & -/- & - & - & & 65.4 & 81.9\\
mT5 (Subword) & 582M & & \underline{80.8}/\underline{70.0} & & 75.3/59.7 & 67.6/48.5 & 75.9 & 89.3 & & \underline{75.4} & \underline{86.4}\\
    \cmidrule{1-12}
\bytebase & 200M & & 75.6/65.4 & & 68.6/54.3 & 61.8/44.4 & 69.4 & 87.1 & & 57.4 & 80.9 \\ 
    \caninebase & 205M & & 70.6/59.7 & & 66.8/52.1 & 58.8/41.1 & 67.9 & 84.8 & & 55.2 & 79.0\\
    \charformerbase & 203M & & \underline{75.9}/\underline{65.6} & & \underline{70.2}/\underline{55.9} & \underline{62.6}/\underline{44.9} & \underline{71.1} & \underline{87.2} & & \underline{57.6} & \underline{81.6} \\
    \midrule
    \charformertall & 134M & & 79.1/68.8 & & 73.6/59.0 & 66.3/48.5 & 72.2 & 88.2 & & 66.6 & \underline{85.2} \\
    \charformertalllong & 134M & & \underline{81.2}/\underline{71.3} & & \underline{74.2}/\underline{59.8} & \underline{67.2}/\underline{49.4} & \underline{72.8} & \underline{88.6} & & \underline{67.8} & 83.7 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\noindent \textbf{Setup}  We pre-train \charformer as well as the \byte and \canine baselines on multilingual mC4 Common Crawl \citep{xue2020mt5} in 101 languages. Base size models were trained for 1M steps using a batch size of 64 and sequence length of 2048, with the exception of \bytebase, which was trained with a sequence length of 1024, as training speed was prohibitively slow (see Table \ref{tab:perf-mc4}). \charformertall and \charformertalllong (longer pre-training) are trained with larger batch sizes for fair comparison with mT5. In particular, \charformertall pre-trains on the same amount of tokens after downsampling as mT5, while \charformertalllong pre-trains on roughly the same amount of raw text as mT5, given that a SentencePiece subword token is about 4.1 bytes on average \citep{Xue2021byt5}; see Table \ref{tab:perfmc4} for further details. All models were fine-tuned with an input sequence length of 4096 for question-answering tasks and 2048 for inference tasks. Score calibration was not used for these experiments, as it did not benefit the model in the multilingual setting. For XNLI and PAWS-X (both translate-train and zero-shot settings), we also observed that performance improved if the GBST layer was not updated during fine-tuning; the reported \charformer numbers reflect this configuration. Otherwise, all other hyper-parameters and model sizes are unchanged from the English experimental setup.

\begin{table} \small
    \centering
    \caption{Comparison of pre-training compute metrics for mT5 (Subword) versus comparable quality \charformer models on the mC4 dataset. 64 TPUv3 chips were used for this experiment. \charformertall sees the same number of tokens after downsampling as mT5, while \charformertalllong roughly sees the same amount of raw text as mT5, given that a SentencePiece subword token is about 4.1 bytes on average \citep{Xue2021byt5}. \charformertall is ~28\% faster than mT5, while using ~33\% of the FLOPS.}
    \label{tab:perfmc4}
    \begin{tabular}{l c c c ccc}
    \toprule 
     Model & Batch Size &  &  &   & Speed (steps/s) & FLOPS \\
     \midrule
     mT5 (Subword) & 1024 & 1024 & - & 582M & 1.54 &  \\
      \charformertall & 1024 & 2048 & 2 & 134M & 1.98 & \\
      \charformertalllong & 2048 & 2048 & 2 & 134M & 1.01 & \\
      \bottomrule
    \end{tabular}
\end{table}

\noindent \textbf{Results}  We show in-language multi-task, translate-train, and cross-lingual zero-shot results in Table \ref{tab:mc4}. \charformertall is competitive with standard subword-based models and \charformertalllong outperforms subword-based models on TyDiQA-GoldP (in-language multi-task). Additionally, in the translate-train setting \charformertalllong is on par with subword models on XQuAD and MLQA, and close to parity on PAWS-X. Furthermore, \charformer outperforms other character-level models in the zero-shot setting. However, we observe that this setting still remains a challenge for token-free models in general. We hypothesize that model size may be a major factor here. Finally, we provide additional comparison between GBST and LASC at a fixed down-sampling rate in Section \ref{sec:downsampling}, showing that GBST significantly outperforms LASC on TyDiQA.  



\begin{table} \small
    \centering
    \caption{Pre-training compute metrics of models at different input lengths, downsampling rates, and model sizes on the English C4 dataset. 16 TPUv3 chips were used for this experiment. These numbers reflect a batch size of 64. Memory refers to per-device peak memory usage on TPUv3 chips. }
    \label{tab:perf}
    \begin{tabular}{l c c cccc}
    \toprule 
     Model &  &  &   & Speed (steps/s) & FLOPS & Peak Mem.\\
     \midrule
T5 (Subword) & 512 & - & 220M & 9.3 &  & - \\
\cmidrule{1-7}
\bytebase & 1024 & 1 & 200M& 8.2 &  &  3.09GB \\
      \caninebase & 1024 & 4 & 205M& 15 &  & 1.62GB\\
      \charformerbase & 1024  & 2 & 206M & 11  &  & 1.95GB\\
      \charformerbase & 1024  & 3 & 203M & 15 &  & 1.63GB\\
      \charformertall & 1024 & 2 & 134M & 14 &  &  1.73GB\\
       \charformertall & 1024 & 3 & 134M & 20 &  & 1.34GB
\\
      \bottomrule
\end{tabular}
\end{table}

\section{Analyses}
\subsection{Speed, Memory and Parameters} \label{sec:speed}
Table \ref{tab:perf} reports the speed (global training steps per second), parameter sizes and number of floating point operations (FLOPS) for each forward pass of the models used in our experiments. All experiments were run on 16 TPU-v3 chips and speed is benchmarked on English C4 pre-training at the 1K input length (). \charformer models are generally more efficient both in terms of speed and FLOPS compared to other character-level models at different parameter sizes. With a low down-sampling rate  for \charformer, \canine is more efficient due to using a higher down-sampling rate. Directly consuming the character sequence with a Transformer model is slow and requires a large number of FLOPS, which is exacerbated with longer sequence lengths where \byte is more than 2 slower than the fastest \charformer. This difference is even larger at longer input sequence lengths, which we report in the Appendix. \charformertall achieves better performance (see \textsection \ref{sec:experiments}) with fewer parameters but more FLOPS by using a deep thin encoder and is twice as fast as the subword-based model with similar performance, T5.

\subsection{Visualizing Latent Subwords}

One benefit of \charformer compared to other character-level methods is that the subwords it learns are directly interpretable and may give some indications to the behaviour of the underlying model. We visualize the scores the multilingual \charformer has learned to assign to subword blocks of different sizes for the string `on subword tokenization' in Figure \ref{fig:viz}. We observe that the model learns to allocate single-character subword blocks predominantly to vowels and whitespace in English. Moreover, in English the model allocates larger subword blocks to the beginning and end consonants of a subword. Together, we believe this suggests that the model has learned a meaningful segmentation of the input, and that it is able to dynamically mix between byte-level and subword-level features. Such behaviour could also parallel the relative importance attributed to consonants for word identification observed during reading in humans \citep{lee2001relative,carreiras2008vowels}.

\begin{figure}[t] \centering
\includegraphics[height=75pt, keepaspectratio]{viz_en.png}
\caption{Visualization of block scores (softmax weights) for every byte position from multilingual \mbox{\charformertall} on an example English input.}
\label{fig:viz}
\end{figure}

\subsection{Comparing Downsampling Approaches} \label{sec:downsampling}
In Table \ref{tab:tydids}, we compare GBST downsampling with LASC downsampling \citep{clark2021canine} on TyDiQA-GoldP. For this experiment we use the same hyperparameters as in Section \ref{sec:multilingual}, except the pre-training input length is 1024 instead of 2048. Note that this difference is negligible (0.1 F1) for \charformerbase,  which also appears in Table \ref{tab:mc4}. All hyperparameters are fixed between \charformer and \canine. Following \citep{clark2021canine} we set  for LASC, and we compare \charformer at the same downsampling rate. We additionally include  and  for \charformer for comparison. With the same hyperparameters and downsampling rate, \charformer outperforms \canine on TyDiQA-GoldP.

\begin{table}[t]
\small
    \centering
    \caption{Effect of  on TyDiQA-GoldP (in-language multi-task).}
    \begin{tabular}{l c c c}
    \toprule
     Model &  & TyDiQA-GoldP F1 \\
     \midrule
     \charformersmall & 2 & 69.6 \\
     \charformersmall & 3 & 68.1 \\
     \charformersmall & 4 & 66.6 \\
     \caninesmall & 4 & 64.9 \\
     \midrule
     \charformerbase & 2 & 75.8 \\
     \charformerbase & 3 & 74.3 \\
     \charformerbase & 4 & 73.2 \\
     \caninebase & 4 & 70.6 \\
     \bottomrule
    \end{tabular}
    \label{tab:tydids}
\end{table}


\subsection{Ablation Study}

\label{sec:ablations}
This section presents our ablation experiments for both English and multilingual tasks. We analyze the impact of various hyper-parameters and modeling choices such as using offsets vs 1D convolutions. Across experiments, we find that pre-GBST convolutions are preferred to enumerating offset blocks, as it results in similar (or better) quality but a more efficient implementation. For English tasks, block score calibration (BC) improves performance. We note that in the multilingual setting, block score calibration has little effect. The impact of different downsampling rates varies across tasks and model sizes. We also experimented with different convolution filter sizes in English and found that they did not significantly impact performance. Likewise, using a different character span corruption rate during pre-training did not significantly impact performance. Adding feed-forward layers to the \charformer module in similar fashion to a Transformer block was also not obviously helpful.

\begin{table}[H]
\small
    \centering
    \caption{Ablation studies with \charformersmall on English tasks.}
    \begin{tabular}{l|c|c|ccc}
    \toprule
     Ablation    &  &Size &   SST-2 & MNLI & IMDb\\
     \midrule
     Offsets & 2 & S & 89.11 & 79.50 & 90.49 \\
     Conv  & 2 & S & 89.11 & 79.65 &  \textbf{90.63}\\ 
     Conv + BC & 2 & S &89.56 & \textbf{80.15} & 90.60\\
Conv + Offsets + BC &2 & S &  89.11 & 79.68 &90.48 \\
\midrule
      Conv & 3 & S &89.45 & 80.07  & 90.15\\
Conv & 4 & S & 89.11 & 79.82 &90.21 \\
      \midrule
      Conv & 2 & B & 90.60 & 82.92 & 91.46 \\ 
      Conv & 3 & B & 91.40 & 82.74 & 91.46\\
      Conv & 4 & B & 91.40 & 82.67 & 92.33\\
      \bottomrule
    \end{tabular}
    \label{tab:my_label}
\end{table}




\section{Related Work} \label{sec:related_work}

\noindent \textbf{Subword tokenization}  Standard algorithms for \emph{deterministic} subword tokenization are Byte Pair Encoding \citep[BPE;][]{sennrich-etal-2016-neural}, Wordpiece \citep{Wu2016nmt}, and SentencePiece \citep{kudo-richardson-2018-sentencepiece}. Prior work has highlighted issues with some of these algorithms \citep{Bostrom2020} and has generally observed that models learned with such rigid tokenization do not cope well with variation in language \citep{sun2020adv}. To make a model more robust to morphological and compositional generalization, \emph{probabilistic} segmentation algorithms such as subword regularization \citep{kudo-2018-subword} and BPE-dropout \citep{provilkov-etal-2020-bpe} have been proposed, which sample different segmentations during training. Recent methods propose to make models more robust for downstream tasks by enforcing prediction consistency between deterministic and probabilistic segmentations \citep{Wang2021multi-view} and propose to update the tokenizer based on the downstream loss under different segmentations \citep{hiraoka-etal-2020-optimizing,Hiraoka2021joint}. \citet{he-etal-2020-dynamic} proposed DPE (dynamic programming encoding), a segmentation-based tokenization algorithm based on dynamic programming. Such methods, however, incur large computation costs due multiple forward passes needing to be performed for each segmentation of an example or due to the expensive DP computation, which make them unsuitable for pre-training. 

\noindent \textbf{Character-level models}  For recurrent neural networks, pure character-level models that take a sequence of characters as input \citep{graves2013generating,Zhang2015character,hwang2017character} have mostly been superseded by \emph{character-aware} methods that compute a token-level representation using a CNN over characters \citep{kim2016character,jozefowicz2016exploring,Peters2018elmo} due to poor performance when learning directly from characters. Such character-aware representations have lately been applied to deep Transformer models \citep{el-boukkouri-etal-2020-characterbert,ma-etal-2020-charbert}. These methods, however, still require tokenization for pre-processing and cannot be directly applied to languages without whitespace separation. Prior work also learned segmentation as part of the model but did not scale very well \citep{wang2017sequence,kreutzer2018learning, kawakami-etal-2019-learning}. One notable exception is \citep{lee-etal-2017-fully}, which enabled fully character-level neural machine translation, using stacked convolutions, max pooling, and highway networks. Building on this, recent \emph{tokenization-free} approaches such as CANINE \citep{clark2021canine} 
revisit the original character-level setting in the context of large pre-trained language models with a focus on multilingual models. Our method outperforms CANINE-style downsampling (local attention, strided convolutions) and also leads to improvements in the monolingual setting, while using less compute and parameters to down-sample than both \citet{lee-etal-2017-fully} and \citet{clark2021canine}.  Recently, ByT5 \citep{Xue2021byt5} set new start-of-the-art results for tokenization-free models, by operating on the byte-level. This work performs on par with or outperforms ByT5, with significant gains in speed and compute efficiency. 

\noindent \textbf{Multilingual models}  Current multilingual models are generally analogues to successful monolingual Transformer models \citep{ruder2021xtreme-r}. Consequently, models such as multilingual BERT \citep{Devlin2019bert} and XLM-R \citep{conneau-etal-2020-unsupervised} employ the same subword tokenization algorithms as monolingual models, now applied to a massively multilingual corpus. In the multilingual setting, the problems of subword-based tokenization are exacerbated as tokens in languages with few data are over-segmented while high-frequency tokens are under-segmented, which limits cross-lingual transfer \citep{Wang2021multi-view}. This motivates our work as well as recent work on character-level models.

\noindent \textbf{Efficient Transformers} 
Moving from subwords to characters significantly increases the sequence length, which is an issue for Transformers due to the quadratic complexity of self-attention. Many efficient self-attention models have been proposed \citep{choromanski2020rethinking,wang2020linformer,zaheer2020big} to tackle this problem; see \citep{tay2020efficient,tay2020long} for a comprehensive overview. Notably, the CANINE model uses local attention \citep{parmar2018image}, which could also be swapped with another efficient Transformer variant. We note that the problem of efficiency is important but not the only challenge towards developing performant tokenization-free models. While applying an efficient attention mechanism might solve the fundamental computational costs of employing character-level models, there is no guarantee that these models will learn locally meaningful compositions.

\section{Conclusion}

We have proposed \charformer, a re-scaled Transformer architecture that integrates gradient-based subword tokenization, a novel lightweight tokenization method that enables efficient end-to-end learning of latent subwords directly from characters. We have demonstrated that English and multilingual variants of \charformer outperform strong character-level baselines across various datasets while being more efficient. \charformer achieves performance on par with subword-based models on standard English tasks and outperforms subword-based models on noisy social media data. On multilingual data, \charformer generally performs on par with subword-based models, while being faster than both byte-level and subword-level baselines. Finally, we provide a method to inspect the inner workings of the GBST module. Overall, we believe that the strong results presented in this paper pave the way for highly effective and powerful token-free models.

\section*{Ethics Statement}



Standard subword tokenization algorithms produce segmentations that do not equally represents words and phrases in different languages. Instead, they are biased towards languages that already have many resources available, which leads to multilingual models performing worse on under-represented languages \citep{Wang2021multi-view}. Tokenization-free approaches such as the one proposed in this paper may help to ameliorate this to some extent. Another challenge to using large multilingual models in practice is their relative computational inefficiency, which makes them unsuitable in resource-constrained settings common in scenarios where under-represented languages are spoken. \charformer trains 28\% faster than mT5 and has  fewer parameters, so may be a more suitable choice in such settings compared to state-of-the-art multilingual models.

\section*{Reproducibility Statement}
All code to train the core byte-level Transformer encoder-decoder for \charformer its variants is already open-sourced as a part of the Mesh Tensorflow\footnote{\url{https://github.com/tensorflow/mesh}} \citep{shazeer2018mesh},  T5\footnote{\url{https://github.com/google-research/text-to-text-transfer-transformer}} \citep{Raffel2020t5}, and ByT5\footnote{\url{https://github.com/google-research/byt5}} \citep{Xue2021byt5} libraries. 
Additionally, an implementation of Charformer GBST compatible with existing open-source models has been open-sourced\footnote{\url{https://github.com/google-research/google-research/tree/master/charformer}}. All detailed experiment and hyperparameter settings required to reproduce our experiments can be found in Section \ref{sec:hyperparams} of the Appendix.







\bibliographystyle{plainnat}
\bibliography{iclr2022_conference}



















\newpage 

\section{Appendix}

\subsection{Hyperparameters}
\label{sec:hyperparams}
This section describes the hyperparameters that we use in our experiments.
\paragraph{Monolingual English Datasets} Our small model follows the T5 small model size with  encoder layers and  decoder layers, hidden size  of 512,  heads,  of  and  of . This corresponds to \textit{bi\_v1\_small.gin} in the T5 codebase. The base model (corresponding to \textit{bi\_v1.gin}) has  encoder layers,  decoder layers,  of ,  of  and  heads. The SBase model has  encoder layers and  decoder layers, while the remainder of its hyperparameters remain identical to the small model. All Transformer stacks use relative attention over positional encodings as per \citep{Raffel2020t5}. For pre-training, we run our models for  steps on C4 with a batch size of 64. The maximum sequence length for all tasks is set to .  TPU packing is not activated for Charformer. For Charformer, the filter size of the pre-GBST convolution is set to  by default. For \charformer, the downsampling rate is tuned in the range of . For smaller models, the rate of  seems to work consistently the best. For base models, the best models used a downsampling rate of either  or . For the SBase models, the optimal downsampling rate was often .

\paragraph{Multilingual Datasets} Hyperparameters are kept constant between English and multilingual tasks except for the following differences. For pre-training, we run our models for 1M steps with a batch size of 64, except for \charformertall which uses a batch size of 1024 and \charformertalllong which usees a batch size of 2048. Models were pre-trained with a maximum sequence length of 2048 and fine-tuned with a maximum sequence length of 4096 for TyDiQA, XQuAD, and MLQA, and 2048 for XNLI and PAWS-X. \bytebase was the only model to be pre-trained with a maximum sequence length of 1024, as it was prohibitively slow, see Table \ref{tab:perf-mc4}. Fine-tuning and inference for this model, however still used 4096 and 2048 input lengths identical to other models. For all tasks, \charformer models used a downsampling rate of 2, while \canine models used a downsampling rate of 4 \citep{clark2021canine}. The downsampling rate of 2 was picked by ablating the downsampling rate on the TyDiQA-GoldP validation set. \charformer models for XNLI and PAWS-X additionally did not back-propagate into the GBST layer during fine-tuning. Checkpoints were picked based on the dev set metrics, and then evaluated on test set. Reported metrics represent the macro-average of all languages in the task. 

\subsection{Large-scale Experiments}

In this section we report preliminary results for scaling Charformer using the same number of parameters as mT5 and ByT5 (1.23B). We follow a model scaling configuration identical to ByT5 in these experiments, and use the same hyperparameter settings as our main multilingual results.
\begin{table}[H]
\small
    \centering
    \caption{Comparison on TyDiQA at 1.23B parameters. *Due to resource constraints, the Charformer result below uses 100K less pretraining steps than ByT5 and mT5.}
    \begin{tabular}{l c}
    \toprule
     Model & TyDiQA-GoldP F1 / EM\\
     \midrule
     mT5 & 85.3 / 75.3 \\
     ByT5 & 87.7 / 79.2 \\
     \textsc{Charformer}* & 86.3 / 77.3 \\
     \bottomrule
    \end{tabular}
    \label{tab:tydids}
\end{table}

\noindent \textbf{Results}  The \charformer model under the same scaling as ByT5 was able to outperform mT5, a very strong baseline. Our preliminary results at this scale shows that \charformer is competitive with, but is 1.4 F1 behind ByT5. However, we point out two important notes. First, the \charformer result is undertrained compared to ByT5 since 10\% of the pretraining has not finished. Second, the \charformer model is also twice as fast as ByT5, as seen from Table \ref{tab:perf-mc4}.

\subsection{Multilingual Experiments}
This section contains detailed results for our multilingual experiments.

\begin{table}[H]
    \small
    \centering
    \caption{Compute metrics of base models at longer (2K) input length on the mC4 pre-training corpus, using a batch size of 64 on 16 TPU-v3 chips.}
    \label{tab:perf-mc4}
    \begin{tabular}{l c c ccc}
    \toprule 
    Model &  &  &   & Speed (steps/s) & FLOPS \\
    \midrule
    \bytebase & 2048 & 1 & 200M& 2.7 &   \\
    \caninebase & 2048 & 4 & 205M& 11 & \\
    \charformerbase & 2048  & 2 & 203M & 6.1  & \\
    \charformerbase & 2048  & 3 & 203M & 10 & \\
    \charformertall & 2048 & 2 & 134M & 6.1 & \\
    \bottomrule
    \end{tabular}
\end{table}

\begin{table}[H]
    \centering
    \caption{Per-language breakdown of in-language multi-task TyDiQA-GoldP results.}
    \label{tab:mc4tydi}
    \resizebox{\textwidth}{!}{\begin{tabular}{l c ccccccccc c}
    \toprule
    Model &  & ar & bn & en & fi & id & ko & ru & sw & te & Avg. \\
    \cmidrule{1-12}
    mBERT (Subword) & 179M  & -/- & -/- & -/- & -/- & -/- & -/- & -/- & -/- & -/- & 77.6/68.0 \\
    mT5 (Subword) & 582M & 84.2/71.8 & 80.0/69.0 & 76.6/65.2 & 80.1/69.3 & 85.5/75.0 & 70.3/61.6 & 77.5/64.4 & 83.6/74.9 & 88.2/78.0 & 80.8 / 70.0 \\
\cmidrule{1-12}
    \bytebase & 200M & 81.4/67.0 & 66.8/56.6 & 69.8/59.5 & 75.6/63.0 & 81.6/72.4 & 64.6/58.7 & 74.1/60.8 & 81.8/74.3 & 85.0/76.1 & 75.6/65.4\\ 
    \caninebase & 205M & 78.1/62.3 & 61.1/50.4 & 66.7/55.2 & 72.5/60.4 & 79.9/68.3 & 51.5/43.5 & 70.4/58.7 & 74.7/67.5 & 80.2/71.2 & 70.6/59.7\\
    \charformerbase & 203M & 81.8/67.9 & 69.1/60.2 & 71.4/60.5 & 76.3/64.2 & 83.0/73.1 & 62.7/54.3 & 74.7/61.7 & 80.2/73.3 & 83.6/75.0 & 75.9/65.6\\
    \midrule
    \charformertall & 134M & 82.4/68.1 & 78.1/67.3 & 75.4/64.3 & 79.5/68.2 & 85.0/75.9 & 66.6/58.0 & 77.0/64.3 & 81.5/74.1 & 86.5/78.6 & 79.1/68.8 \\
    \charformertalllong & 134M & 85.7/74.5 & 78.7/67.3 & 76.8/65.9 & 81.9/70.6 & 86.7/79.1 & 69.4/61.6 & 79.2/67.1 & 83.7/75.2 & 88.8/80.6 & 81.2/71.3\\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[H]
    \centering
    \caption{Per-language breakdown of translate-train-all XQuAD results.}
    \label{tab:mc4xquad}
    \resizebox{\textwidth}{!}{\begin{tabular}{l c ccccccccccc c}
    \toprule
    Model &  & ar & de & el & en & es & hi & ru & th & tr & vi & zh & Avg. \\
    \midrule
    mT5 (Subword) & 582M & 72.4/55.2 & 76.9/59.7 & 76.8/58.8 & 83.1/70.3 & 79.0/61.2 & 71.4/53.4 & 76.1/58.5 & 67.9/62.0 & 72.5/51.4 & 75.9/56.3 & 76.9/69.7 & 75.3/59.7\\
    \midrule
\bytebase & 200M & 64.8/47.9 & 74.3/58.3 & 69.2/51.8 & 81.5/70.4 & 77.2/60.4 & 67.0/51.5 & 72.3/55.5 & 48.3/41.9 & 69.6/51.7 & 73.3/54.4 & 57.3/53.3 & 68.6/54.3\\ 
    \caninebase & 205M & 62.9/45.5 & 70.6/54.2 & 68.3/52.3 & 80.1/68.4 & 74.8/57.9 & 63.1/46.2 & 68.2/52.2 & 50.0/43.4 & 67.1/48.2 & 71.7/51.8 & 57.7/52.7 & 66.8/52.1\\
    \charformerbase & 203M & 65.7/49.8 & 74.2/58.0 & 71.1/53.1 & 82.2/70.5 & 77.8/61.0 & 67.0/51.3 & 73.4/57.6 & 54.3/48.0 & 70.3/53.0 & 74.6/55.6 & 62.0/56.6 & 70.2/55.9\\
    \midrule
    \charformertall & 134M & 70.3/53.7 & 78.6/61.4 & 74.4/55.1 & 85.1/73.7 & 79.8/63.6 & 69.1/52.7 & 76.7/61.3 & 57.6/51.2 & 73.9/55.8 & 76.8/57.6 & 67.4/62.4 & 73.6/59.0 \\
    \charformertalllong & 134M & 72.6/55.0 & 79.0/62.3 & 74.9/56.1 & 85.4/74.5 & 80.4/63.4 & 70.6/56.1 & 77.8/62.2 & 56.1/49.2 & 76.1/58.2 & 77.7/59.4 & 66.0/61.8 & 74.2/59.8\\
    \bottomrule
    \end{tabular}
    }
\end{table}


\begin{table}[H]
    \centering
    \caption{Per-language breakdown of translate-train-all MLQA results.}
    \label{tab:mc4mlqa}
    \resizebox{\textwidth}{!}{\begin{tabular}{l c ccccccc c}
    \toprule
    Model &  & ar & de & en & es & hi & vi & zh & Avg. \\
    \midrule
    mT5 (Subword) & 582M & 61.1/40.7 & 65.5/49.2 & 80.7/66.3 & 70.7/52.1 & 63.6/44.3 & 68.0/47.6 & 63.5/39.4 & 67.6/48.5 \\
    \midrule
\bytebase & 200M & 52.6/34.2 & 60.5/46.1 & 77.7/64.8 & 67.1/49.2 & 52.9/36.5 & 63.6/43.8 & 58.3/36.4 & 61.8/44.4 \\
    \caninebase & 205M & 50.8/32.0 & 58.1/43.5 & 75.8/62.2 & 64.7/46.7 & 49.2/32.6 & 60.4/40.4 & 52.6/30.6 & 58.8/41.1 \\
    \charformerbase & 203M & 53.5/34.5 & 61.3/46.8 & 78.5/65.4 & 67.2/49.3 & 54.5/37.6 & 64.3/43.9 & 58.8/36.6 & 62.6/44.9 \\
    \midrule
    \charformertall & 134M & 58.3/39.1 & 65.7/50.5 & 81.8/68.7 & 71.0/53.1 & 57.7/40.8 & 67.3/46.8 & 62.7/40.8 & 66.3/48.5 \\
    \charformertalllong & 134M & 59.6/40.0 & 66.6/51.3 & 82.2/69.0 & 72.1/54.5 & 59.7/42.9 & 68.2/47.4 & 62.4/40.7 & 67.2/49.4 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[H]
    \centering
    \caption{Per-language breakdown of translate-train-all and cross-lingual zero-shot XNLI results.}
    \label{tab:mc4xnli}
    \resizebox{\textwidth}{!}{\begin{tabular}{l c ccccccccccccccc c}
    \toprule
    Model &  & ar & bg & de & el & en & es & fr & hi & ru & sw & th & tr & ur & vi & zh & Avg. \\
    \midrule
    \multicolumn{18}{c}{\textit{Translate-Train-All}} \\
    \midrule
    mT5 (Subword) & 582M & 74.4 & 78.5 & 77.7 & 78.1 & 82.0 & 79.1 & 77.9 & 72.2 & 76.5 & 71.5 & 75.0 & 74.8 & 70.4 & 74.5 & 76.0 & 75.9 \\
    \midrule
\bytebase & 200M & 67.1 & 72.0 & 71.0 & 70.6 & 76.9 & 74.0 & 73.4 & 63.7 & 69.2 & 66.2 & 65.7 & 69.4 & 62.8 & 69.6 & 69.0 & 69.4\\
    \caninebase & 205M & 65.6 & 72.1 & 70.5 & 67.9 & 75.6 & 73.4 & 72.2 & 63.5 & 68.6 & 65.4 & 64.5 & 67.4 & 62.4 & 68.3 & 61.0 & 67.9\\
    \charformerbase & 203M & 69.5 & 72.9 & 72.7 & 72.6 & 78.2 & 74.5 & 73.6 & 67.0 & 71.7 & 67.9 & 68.1 & 70.8 & 65.0 & 70.7 & 71.5 & 71.1\\
    \midrule
    \charformertall & 134M & 70.8 & 75.7 & 75.9 & 73.1 & 80.9 & 76.9 & 76.8 & 65.6 & 74.7 & 65.7 & 67.7 & 72.0 & 63.1 & 72.9 & 71.5 & 72.2 \\
    \charformertalllong & 134M & 71.1 & 75.9 & 73.6 & 74.2 & 80.8 & 76.6 & 76.8 & 69.2 & 72.2 & 68.2 & 71.0 & 71.2 & 65.7 & 72.9 & 73.0 & 72.8\\
    \midrule
    \multicolumn{18}{c}{\textit{Cross-Lingual Zero-Shot}} \\
    \midrule
    mBERT (Subword) & 179M & 64.3 & 68.0 & 70.0 & 65.3 & 80.8 & 73.5 & 73.4 & 58.9 & 67.8 & 49.7 & 54.1 & 60.9 & 57.2 & 69.3 & 67.8 & 65.4 \\
    mT5 (Subword) & 582M & 73.3 & 78.6 & 77.4 & 77.1 & 84.7 & 80.3 & 79.1 & 70.8 & 77.1 & 69.4 & 73.2 & 72.8 & 68.3 & 74.2 & 74.1 & 75.4 \\
    \midrule
\bytebase & 200M & 56.7 & 61.2 & 63.0 & 60.9 & 79.2 & 70.1 & 65.3 & 43.9 & 61.0 & 45.5 & 43.5 & 52.0 & 44.3 & 58.3 & 55.6 & 57.4\\
    \caninebase & 205M & 53.3 & 58.8 & 62.2 & 54.9 & 77.1 & 68.6 & 65.4 & 44.7 & 58.4 & 46.1 & 43.6 & 50.4 & 42.8 & 55.9 & 46.1 & 55.2\\
    \charformerbase & 203M & 55.7 & 61.1 & 64.8 & 60.1 & 77.3 & 69.9 & 67.9 & 44.4 & 60.2 & 45.3 & 47.9 & 54.0 & 43.5 & 59.1 & 53.4 & 57.6\\
    \midrule
    \charformertall & 134M & 66.4 & 71.0 & 72.7 & 68.6 & 82.4 & 77.1 & 75.4 & 57.6 & 70.6 & 48.7 & 61.4 & 61.8 & 54.1 & 68.9 & 62.8 & 66.6 \\
    \charformertalllong & 134M & 68.4 & 70.9 & 74.3 & 70.2 & 82.4 & 77.0 & 76.6 & 59.9 & 71.0 & 42.6 & 64.0 & 65.5 & 56.5 & 71.2 & 66.0 & 67.8 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[H]
    \centering
    \caption{Per-language breakdown of translate-train-all and cross-lingual zero-shot PAWS-X results.}
    \label{tab:mc4paws}
    \resizebox{0.75\textwidth}{!}{\begin{tabular}{l c ccccccc c}
    \toprule
    Model &  & de & en & es & fr & ja & ko & zh & Avg. \\
    \midrule
    \multicolumn{10}{c}{\textit{Translate-Train-All}} \\
    \midrule
    mT5 (Subword) & 582M & 90.9 & 95.5 & 91.4 & 92.5 & 83.6 & 84.8 & 86.4 & 89.3  \\
    \midrule
\bytebase & 200M & 89.3 & 94.6 & 90.1 & 90.3 & 81.4 & 81.1 & 82.3 & 87.0 \\
    \caninebase & 205M & 87.3 & 93.1 & 89.2 & 89.2 & 81.0 & 72.9 & 80.8 & 84.8 \\
    \charformerbase & 203M & 89.9 & 94.6 & 89.8 & 91.4 & 82.7 & 78.4 & 83.3 & 87.2 \\
    \midrule
    \charformertall & 134M & 89.9 & 95.9 & 91.8 & 92.2 & 83.9 & 78.9 & 84.4 & 88.2 \\
    \charformertalllong & 134M & 90.7 & 95.1 & 92.2 & 92.2 & 84.1 & 81.6 & 84.6 & 88.6 \\
    \midrule
    \multicolumn{10}{c}{\textit{Cross-Lingual Zero-Shot}} \\
    \midrule
    mBERT (Subword) & 179M & 85.7 & 94.0 & 87.4 & 87.0 & 73.0 & 69.6 & 77.0 & 81.9  \\
    mT5 (Subword) & 582M & 89.4 & 95.4 & 89.6 & 91.2 & 79.8 & 78.5 & 81.1 & 86.4  \\
    \midrule
\bytebase & 200M & 84.7 & 93.8 & 85.8 & 86.4 & 72.2 & 67.9 & 75.2 & 80.9  \\
    \caninebase & 205M & 83.2 & 93.2 & 84.1 & 85.0 & 67.9 & 66.4 & 73.4 & 79.0  \\
    \charformerbase & 203M & 86.1 & 94.8 & 87.2 & 88.0 & 70.1 & 69.7 & 75.5 & 81.6 \\
    \midrule
    \charformertall & 134M & 89.6 & 95.2 & 90.7 & 90.7 & 77.1 & 74.4 & 78.9 & 85.2 \\
    \charformertalllong & 134M & 89.8 & 95.3 & 88.7 & 89.7 & 74.5 & 68.9 & 78.9 & 83.7 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[H]
\small
    \centering
    \caption{Effect of freezing the GBST layer for XNLI and PAWS-X.}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{l cc ccccc}
    \toprule
     Model &  & Freeze GBST & XNLI (Zero) & XNLI (Translate) & PAWS-X (Zero) & PAWS-X (Translate) \\
     \midrule
     \charformersmall & 2 & No & 44.5 & 62.7 & 27.9 & 37.5 \\
     \charformersmall & 2 & Yes & 50.9 & 68.7	& 77.1 & 84.8 \\
     \charformersmall & 3 & No & 47.9 & 67.9 & 29.5 & 36.8 \\
     \charformersmall & 3 & Yes & 43.2	& 68.6	& 77.8	& 83.7 \\
     \charformersmall & 4 & No & 47.5 & 47.5 & 30.9 & 36.9 \\
     \charformersmall & 4 & Yes & 43.6 & 43.6 & 77.9	& 83.5 \\
     \bottomrule
    \end{tabular}
    \label{tab:freezing}
    }
\end{table}


\subsection{Example Implementation} \label{sec:code}
For additional clarity, we include a simplified implementation of the GBST module in Tensorflow below. Default hyper-parameters here match those used in the paper.

\begin{lstlisting}
from typing import Optional

import tensorflow as tf

keras_layers = tf.keras.layers


class GBSTLayer(keras_layers.Layer):
  """Performs Charformer GBST on a sequence.

  Attributes:
    input_shape: Shape [len, embedding_size] of input tensor in future calls,
      without batch dimension.
    downsample_rate: Integer of how much to downsample by.
    max_subword_block_width: Integer of max block size to use for enumeration.
    block_attention: Hhether to use block score calibration.
    block_scoring_network: module for parameterized block scoring.
    conv_kernel_size: Integer of the size of the pre-GBST convolution kernel.
  """

  def __init__(self,
               input_shape: tf.Tensor,
               downsample_rate: int = 2,
               max_subword_block_width: int = 4,
               block_attention: bool = False,
               conv_kernel_size: Optional[int] = 5):
    super(GBSTLayer, self).__init__()
    self.downsample_rate = downsample_rate
    self.max_subword_block_width = max_subword_block_width
    self.conv_kernel_size = conv_kernel_size
    self.conv_layer = keras_layers.Conv1D(
        input_shape[-1], self.conv_kernel_size, input_shape=input_shape)
    self.block_attention = block_attention
    self.block_scoring_network = keras_layers.Dense(1, use_bias=False)

  def call(self, inputs):
    """Performs downsampling on the character-scale input representation.

    Args:
      inputs: float Tensor of shape [batch_size, seq_length,
        embedding_size].

    Returns:
      <float>[batch_size, seq_length / downsample_rate , embedding_size].
        Downsampled sequences.
    """
    length = inputs.shape[1]

    if self.conv_kernel_size:
      inputs = self.conv_layer(inputs)

    all_block_scores = []
    all_sequences = []
    for subword_len in range(1, self.max_subword_block_width):
      padded_input = inputs
      # Pad the sequence length if needed.
      if length pad_amt = subword_len - int(length padding = tf.constant([[0, 0], [0, pad_amt], [0, 0]])
        padded_input = tf.pad(inputs, padding)

      # For this block size, form candidate block embeddings and scores.
      # candidates shape: [batch, seq_len/subword_len, dim]
      # block_scores shape: [batch, seq_len/subword_len, 1]
      candidates = tf.nn.avg_pool(
          padded_input, [subword_len], strides=[subword_len], padding="VALID")
      block_scores = self.block_scoring_network(candidates)

      # Upsample it back to the original sequence length.
      retiled_seq = tf.repeat(candidates, subword_len, axis=1)
      retiled_block_scores = tf.repeat(block_scores, subword_len, axis=1)

      # Repad the upsampled sequence if needed.
      if retiled_block_scores.shape[1] < length:
        repad_amt = length - retiled_block_scores.shape[1]
        repadding = tf.constant([[0, 0], [0, repad_amt], [0, 0]])
        retiled_seq = tf.pad(retiled_seq, repadding)
        retiled_block_scores = tf.pad(retiled_block_scores, repadding)

      # Make sure everything is the right length and add new dimension to concat
      # candidate blocks on.
      retiled_block_scores = retiled_block_scores[:, :length, :, None]
      retiled_seq = retiled_seq[:, :length, :, None]
      all_block_scores.append(retiled_block_scores)
      all_sequences.append(retiled_seq)

    block_scores = tf.concat(all_block_scores, axis=-1)
    block_scores = tf.nn.softmax(block_scores, axis=-1)
    candidates = tf.concat(all_sequences, axis=-1)

    # TODO: Block score calibration / block-by-block attention is omitted in this implementation.
    # batch_size x num_candidates x length x dim
    candidates = candidates * block_scores
    output = tf.reduce_sum(candidates, axis=-1)  # bsz x length x dim

    # Downsample by mean pooling.
    if self.downsample_rate > 1:
      output = tf.nn.avg_pool(
          output, (self.downsample_rate,),
          strides=(self.downsample_rate,),
          padding="VALID")
    return output
\end{lstlisting}
\end{document}
