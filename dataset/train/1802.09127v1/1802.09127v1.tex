\documentclass{article} \usepackage{iclr2018_conference,times}
\usepackage{hyperref}
\usepackage{url}
\usepackage{todonotes}

\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{subcaption}
\usepackage[compact]{titlesec}
\usepackage{todonotes}
\usepackage{bm}
\titlespacing{\section}{0pt}{2ex}{1ex}
\titlespacing{\subsection}{0pt}{1ex}{0ex}
\titlespacing{\subsubsection}{0pt}{0.5ex}{0ex}
    


\usepackage{blindtext}
\usepackage{pdflscape}
\usepackage{adjustbox}
\usepackage{morefloats}
\setlength{\abovedisplayskip}{4pt}
\setlength{\belowdisplayskip}{4pt}
\DeclareUnicodeCharacter{00A0}{~}

\title{Deep Bayesian Bandits Showdown \\\normalsize An Empirical Comparison of Bayesian Deep Networks for Thompson Sampling}


\author{Carlos Riquelme\thanks{Google AI Resident} \\
Google Brain\\
\texttt{rikel@google.com} \\
\And
George Tucker \\
Google Brain\\
\texttt{gjt@google.com} \\
\And
Jasper Snoek  \\
Google Brain \\
\texttt{jsnoek@google.com}}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy 

\begin{document}


\maketitle
\begin{abstract}
Recent advances in deep reinforcement learning have made significant strides in performance on applications such as Go and Atari games. However, developing practical methods to balance exploration and exploitation in complex domains remains largely unsolved. Thompson Sampling and its extension to reinforcement learning provide an elegant approach to exploration that only requires access to posterior samples of the model. At the same time, advances in approximate Bayesian methods have made posterior approximation for flexible neural network models practical. Thus, it is attractive to consider approximate Bayesian neural networks in a Thompson Sampling framework. To understand the impact of using an approximate posterior on Thompson Sampling, we benchmark well-established and recently developed methods for approximate posterior sampling combined with Thompson Sampling over a series of contextual bandit problems. We found that many approaches that have been successful in the supervised learning setting underperformed in the sequential decision-making scenario. In particular, we highlight the challenge of adapting slowly converging uncertainty estimates to the online setting.
\end{abstract}
 
\section{Introduction}
\label{s:intro}Recent advances in reinforcement learning have sparked renewed interest in sequential decision making with deep neural networks. Neural networks have proven to be powerful and flexible function approximators, allowing one to learn mappings directly from complex states (e.g.,~pixels) to estimates of expected return.  While such models can be accurate on data they have been trained on, quantifying model uncertainty on new data remains challenging.  However, having an understanding of what is not yet known or well understood is critical to some central tasks of machine intelligence, such as effective exploration for decision making.

A fundamental aspect of sequential decision making is the exploration-exploitation dilemma: in order to maximize cumulative reward, agents need to trade-off what is expected to be best at the moment, (i.e., exploitation), with potentially sub-optimal exploratory actions. Solving this trade-off in an efficient manner to maximize cumulative reward is a significant challenge as it requires uncertainty estimates.  Furthermore, exploratory actions should be coordinated throughout the entire decision making process, known as deep exploration, rather than performed independently at each state.

Thompson Sampling \citep{thompson1933likelihood} and its extension to reinforcement learning, known as Posterior Sampling, provide an elegant approach that tackles the exploration-exploitation dilemma by maintaining a posterior over models and choosing actions in proportion to the probability that they are optimal. Unfortunately, maintaining such a posterior is intractable for all but the simplest models.
As such, significant effort has been dedicated to approximate Bayesian methods for deep neural networks.  These range from variational methods~\citep{graves2011practical,blundell2015weight,kingma2015variational} to stochastic minibatch Markov Chain Monte Carlo~\citep{Neal1994,WellingTeh2011,Li2016,Ahn2013,Mandt2016}, among others.  Because the exact posterior is intractable, evaluating these approaches is hard. Furthermore, these methods are rarely compared on benchmarks that measure the quality of their estimates of uncertainty for downstream tasks.  

To address this challenge, we develop a benchmark for exploration methods using deep neural networks.  We compare a variety of well-established and recent Bayesian approximations under the lens of Thompson Sampling for contextual bandits, a classical task in sequential decision making. All code and implementations to reproduce the experiments will be available open-source, to provide a reproducible benchmark for future development.~\footnote{Available in Python and Tensorflow at https://sites.google.com/site/deepbayesianbandits/.}



Exploration in the context of reinforcement learning is a highly active area of research. Simple strategies such as epsilon-greedy remain extremely competitive~\citep{mnih2015,Schaul2016}.  However, a number of promising techniques have recently emerged that encourage exploration though carefully adding random noise to the parameters~\citep{Plappert17, Fortunato2017, gal2016dropout} or bootstrap sampling~\citep{osband2016deep} before making decisions.  These methods rely explicitly or implicitly on posterior sampling for exploration. 







In this paper, we investigate how different posterior approximations affect the performance of Thompson Sampling from an empirical standpoint.
For simplicity, we restrict ourselves to one of the most basic sequential decision making scenarios: that of contextual bandits.

No single algorithm bested the others in every bandit problem, however, we observed some general trends. We found that dropout, injecting random noise, and bootstrapping did provide a strong boost in performance on some tasks, but was not able to solve challenging synthetic exploration tasks. Other algorithms, like Variational Inference, Black Box -divergence, and minibatch Markov Chain Monte Carlo approaches, strongly couple their complex representation and uncertainty estimates. This proves problematic when decisions are made based on partial optimization of both, as online scenarios usually require. On the other hand, making decisions according to a Bayesian linear regression on the representation provided by the last layer of a deep network offers a robust and easy-to-tune approach. It would be interesting to try this approach on more complex reinforcement learning domains.

In Section~\ref{s:problem} we discuss Thompson Sampling, and present the contextual bandit problem. The different algorithmic approaches that approximate the posterior distribution fed to Thompson Sampling are introduced in Section~\ref{s:algorithms}, while the linear case is described in Section~\ref{s:linear}. The main experimental results are presented in Section~\ref{s:experiments}, and discussed in Section~\ref{s:discussion}. Finally, Section~\ref{s:conclusions} concludes. \section{Decision-Making via Thompson Sampling}\label{s:problem}
The contextual bandit problem works as follows.  At time  a new context  arrives and is presented to algorithm .  The algorithm ---based on its internal model and --- selects one of the  available actions, .  Some reward  is then generated and returned to the algorithm, that may update its internal model with the new data.
At the end of the process, the reward for the algorithm is given by , and cumulative regret is defined as , where  is the cumulative reward of the optimal policy (i.e., the policy that always selects the action with highest expected reward given the context).
The goal is to minimize .

The main research question we address in this paper is how approximated model posteriors affect the performance of decision making via Thompson Sampling (Algorithm~\ref{algo:ts}) in contextual bandits.
We study a variety of algorithmic approaches to approximate a posterior distribution, together with different empirical and synthetic data problems that highlight several aspects of decision making.
We consider distributions  over the space of parameters that completely define a problem instance .
For example,  could encode the reward distributions of a set of arms in the multi-armed bandit scenario, or --more generally-- all the parameters of an MDP in reinforcement learning.

Thompson Sampling is a classic algorithm~\citep{thompson1933likelihood} which requires only that one can sample from the posterior distribution over plausible problem instances (for example, values or rewards).  At each round, it draws a sample and takes a greedy action under the optimal policy for the sample.  The posterior distribution is then updated after the result of the action is observed.  Thompson Sampling has been shown to be extremely effective for bandit problems both in practice~\citep{chappelle2011, granmo2010} and theory~\citep{agrawal2012}.  It is especially appealing for deep neural networks as one rarely has access to the full posterior but can often approximately sample from it. 

In the following sections we rely on the idea that, if we had access to the actual posterior  given the observed data at all times , then choosing actions using Thompson Sampling would lead to near-optimal cumulative regret or, more informally, to good performance.
It is important to remark that in some problems this is not necessarily the case; for example, when actions that have no chance of being optimal still convey useful information about other actions.
Thompson Sampling (or UCB approaches) would never select such actions, even if they are worth their cost \citep{russo2014learning}.
In addition, Thompson Sampling does \emph{not} take into account the time horizon where the process ends, and if known, exploration efforts should be tuned accordingly \citep{russo2017time}.
Nonetheless, under the assumption that very accurate posterior approximations lead to efficient decisions, the question is: what happens when the approximations are not so accurate?
In some cases, the mismatch in posteriors may not hurt in terms of decision making, and we will still end up with good decisions.
Unfortunately, in other cases, this mismatch together with its induced feedback loop will degenerate in a significant loss of performance.
We would like to understand the main aspects that determine which way it goes.
This is an important practical question as, in large and complex systems, computational sacrifices and statistical assumptions are made to favor simplicity and tractability. But, what is their impact?
\begin{algorithm}[t]
\caption{Thompson Sampling}\label{algo:ts}
\begin{algorithmic}[1]
\State \emph{Input:} Prior distribution over models, .
\For{time }
\State Observe context .
\State Sample model .
\State Compute .
\State Select action  and observe reward .
\State Update posterior distribution  with .
\EndFor
\end{algorithmic}
\end{algorithm}

%
 \section{Algorithms}\label{s:algorithms}

In this section, we describe the different algorithmic design principles that we considered in our simulations of Section~\ref{s:experiments}.
These algorithms include linear methods, Neural Linear and Neural Greedy, variational inference, expectation-propagation, dropout, Monte Carlo methods, bootstrapping, direct noise injection, and Gaussian Processes. 
In Figure~\ref{fig:qualitative_plots} in the appendix, we visualize the posteriors of the nonlinear algorithms on a synthetic one dimensional problem.

\textbf{Linear Methods} We apply well-known closed-form updates for Bayesian linear regression for exact posterior inference in linear models~\citep{bishop2006pattern}.
We provide the specific formulas below, and note that they admit a computationally-efficient online version.  We consider exact linear posteriors as a baseline; i.e., these formulas compute the posterior when the data was generated according to  where , and  represents the reward.
Importantly, we model the \emph{joint} distribution of  and  for each action.
Sequentially estimating the noise level  for each action allows the algorithm to adaptively improve its understanding of the volume of the hyperellipsoid of plausible 's; in general, this leads to a more aggressive initial exploration phase (in both  and ).

The posterior at time  for action , after observing  , is , where we assume , and , an Inverse Gamma and Gaussian distribution, respectively.
Their parameters are given by

We set the prior hyperparameters to , and , while .
It follows that initially, for , we have the prior , where .
Note that we independently model and regress each action's parameters,  for .

We consider two approximations to \eqref{eq:bayesian_linear_regression} motivated by function approximators where  is large. While posterior distributions or confidence ellipsoids should capture dependencies across parameters as shown above (say, a dense ), in practice, computing the correlations across all pairs of parameters is too expensive, and diagonal covariance approximations are common.
For linear models it may still be feasible to exactly compute \eqref{eq:bayesian_linear_regression}, whereas in the case of Bayesian neural networks, unfortunately, this may no longer be possible.
Accordingly, we study two linear approximations where  is diagonal. 
Our goal is to understand the impact of such approximations in the simplest case, to properly set our expectations for the loss in performance of equivalent approximations in more complex approaches, like mean-field variational inference or Stochastic Gradient Langevin Dynamics.

Assume for simplicity the noise standard deviation is known.
In Figure~\ref{fig:figure4}, for , we see the posterior distribution  of a linear model based on \eqref{eq:bayesian_linear_regression}, in green, together with two diagonal approximations.
Each approximation tries to minimize a different objective.
In blue, the \emph{PrecisionDiag} posterior approximation finds the diagonal  minimizing , like in mean-field variational inference. In particular, .
On the other hand, in orange, the \emph{Diag} posterior approximation finds the diagonal matrix  minimizing  instead.
In this case, the solution is simply .

We add linear baselines that do \emph{not} model the uncertainty in the action noise .
In addition, we also consider simple greedy and epsilon greedy linear baselines (i.e., not based on Thompson Sampling).

\textbf{Neural Linear}
The main problem linear algorithms face is their lack of representational power, which they complement with accurate uncertainty estimates.
A natural attempt at getting the best of both worlds consists in performing a Bayesian linear regression on top of the representation of the last layer of a neural network, similarly to~\cite{snoek2015}.
The predicted value  for each action  is given by , where  is the output of the last hidden layer of the network for context .
While linear methods directly try to regress values  on , we can independently train a deep net to learn a representation , and then use a Bayesian linear regression to regress  on , obtain uncertainty estimates on the 's, and make decisions accordingly via Thompson Sampling.
Note that we do not explicitly consider the weights of the linear output layer of the network to make decisions; further, the network is \emph{only} used to find good representations .
In addition, we can update the network and the linear regression at different time-scales.
It makes sense to keep an exact linear regression (as in \eqref{eq:bayesian_linear_regression} and \eqref{eq:bayesian_linear_regression2}) at all times, adding each new data point as soon as it arrives.
However, we only update the network after a number of points have been collected.
In our experiments, after updating the network, we perform a forward pass on all the training data to obtain , which is then fed to the Bayesian regression.
In practice this may be too expensive, and  could be updated periodically with online updates on the regression.
We call this algorithm \emph{Neural Linear}.

\textbf{Neural Greedy}
We refer to the algorithm that simply trains a neural network and acts greedily (i.e., takes the action whose predicted score for the current context is highest) as \textbf{RMS}, as we train it using the RMSProp optimizer.
This is our non-linear baseline, and we tested several versions of it (based on whether the training step was decayed, reset to its initial value for each re-training or not, and how long the network was trained for).
We also tried the -greedy version of the algorithm, where a random action was selected with probability  for some decaying schedule of .


\textbf{Variational Inference}
Variational approaches approximate the posterior by finding a distribution within a tractable family that minimizes the KL divergence to the posterior \citep{hinton1993keeping}.
These approaches formulate and solve an optimization problem, as opposed, for example, to sampling methods like MCMC \citep{jordan1999introduction, wainwright2008graphical}.
Typically (and in our experiments), the posterior is approximated by a mean-field or factorized distribution where strong independence assumptions are made.
For instance, each neural network weight can be modeled via a --conditionally independent-- Gaussian distribution whose mean and variance are estimated from data.
Recent advances have scaled these approaches to estimate the posterior of neural networks with millions of parameters \citep{blundell2015weight}.
A common criticism of variational inference is that it underestimates uncertainty (e.g., \citep{bishop2006pattern}), which could lead to under-exploration.

\textbf{Expectation-Propagation} The family of expectation-propagation algorithms \citep{opper2000gaussian, minka2001family, minka2001expectation} is based on the message passing framework \citep{pearl1986fusion}. They iteratively approximate the posterior by updating a single approximation factor (or \emph{site}) at a time, which usually corresponds to the likelihood of one data point.
The algorithm sequentially minimizes a set of local KL divergences, one for each site.
Most often, and for computational reasons, likelihoods are chosen to lie in the exponential family.
In this case, the minimization corresponds to moment matching.
See \cite{gelman2014expectation} for further details.
We focus on methods that directly optimize the \emph{global} EP objective via stochastic gradient descent, as, for instance, Power EP \citep{minka2004power}.
In particular, in this work, we implement the black-box -divergence minimization algorithm \citep{Hernandez-Lobato2016}, where local parameter sharing is applied to the Power EP energy function.
Note that different values of  correspond to common algorithms:  to EP, and  to Variational Bayes.
The optimal  value is problem-dependent \citep{Hernandez-Lobato2016}.

\textbf{Dropout} Dropout is a training technique where the output of each neuron is independently zeroed out with probability  at each forward pass \citep{srivastava2014dropout}.
Once the network has been trained, dropout can still be used to obtain a distribution of predictions for a specific input.
Following the best action with respect to the \emph{random} dropout prediction can be interpreted as an implicit form of Thompson sampling.
Dropout can be seen as optimizing a variational objective \citep{kingma2015variational, gal2016dropout, hron2017variational}.

\textbf{Monte Carlo} Monte Carlo sampling remains one of the simplest and reliable tools in the Bayesian toolbox.  Rather than parameterizing the full posterior, Monte Carlo methods estimate the posterior through drawing samples.  This is naturally appealing for highly parameterized deep neural networks for which the posterior is intractable in general and even simple approximations such as multivariate Gaussian are too expensive (i.e. require computing and inverting a covariance matrix over all parameters).  Among Monte Carlo methods, Hamiltonian Monte Carlo~\citep{Neal1994} (HMC) is often regarded as a gold standard algorithm for neural networks as it takes advantage of gradient information and momentum to more effectively draw samples.  However, it remains unfeasible for larger datasets as it involves a Metropolis accept-reject step that requires computing the log likelihood over the whole data set.  A variety of methods have been developed to approximate HMC using mini-batch stochastic gradients.  These Stochastic Gradient Langevin Dynamics (SGLD) methods~\citep{Neal1994,WellingTeh2011} add Gaussian noise to the model gradients during stochastic gradient updates in such a manner that each update results in an approximate sample from the posterior. Different strategies have been developed for augmenting the gradients and noise according to a preconditioning matrix.  \cite{Li2016} show that a preconditioner based on the RMSprop algorithm performs well on deep neural networks.  \cite{Patterson2013} suggested using the Fisher information matrix as a preconditioner in SGLD.  Unfortunately the approximations of SGLD hold only if the learning rate is asymptotically annealed to zero. \cite{Ahn2013} introduced Stochastic Gradient Fisher Scoring to elegantly remove this requirement by preconditioning according to the Fisher information (or a diagonal approximation thereof).  \cite{Mandt2016} develop methods for approximately sampling from the posterior using a constant learning rate in stochastic gradient descent and develop a prescription for a stable version of SGFS.  We evaluate the diagonal-SGFS and constant-SGD algorithms from~\cite{Mandt2016} in this work.  Specifically for constant-SGD we use a constant learning rate for stochastic gradient descent, where the learning rate  is given by  where  is the batch size,  the number of data points and  is an online average of the diagonal empirical Fisher information matrix.  For Stochastic Gradient Fisher Scoring we use the following stochastic gradient update for the model parameters  at step :

where we take the noise covariance  to also be  and .


\textbf{Bootstrap} A simple empirical approach to approximate the sampling distribution of any estimator is the Bootstrap \citep{efron1982jackknife}.
The main idea is to simultaneously train  models, where each model  is based on a different dataset .
When all the data  is available in advance,  is typically created by sampling  elements from  at random with replacement.
In our case, however, the data grows one example at a time.
Accordingly, we set a parameter , and append the new datapoint to each  independently at random with probability .
In order to emulate Thompson Sampling, we sample a model uniformly at random (i.e., with probability .) and take the action predicted to be best by the sampled model.
We mainly tested cases  and , with neural network models.
Note that even when  and the datasets are identical, the random initialization of each network, together with the randomness from SGD, lead to different predictions.


\textbf{Direct Noise Injection}
Parameter-Noise \citep{Plappert17} is a recently proposed approach for exploration in deep RL that has shown promising results. The training updates for the network are unchanged, but when selecting actions, the network weights  are perturbed with isotropic Gaussian noise. Crucially, the network uses layer normalization \citep{ba2016layer}, which ensures that all weights are on the same scale. The magnitude of the Gaussian noise is adjusted so that the overall effect of the perturbations is similar in scale to -greedy with a linearly decaying schedule (see \citep{Plappert17} for details). Because the perturbations are done on the model parameters, we might hope that the actions produced by the perturbations are more sensible than -greedy.

\textbf{Bayesian Non-parametric} Gaussian processes~\citep{Rasmussen2005} are a gold-standard method for modeling distributions over non-linear continuous functions.  It can be shown that, in the limit of infinite hidden units and under a Gaussian prior, a Bayesian neural network converges to a Gaussian process~\citep{Neal1994}.  As such, GPs would appear to be a natural baseline.  Unfortunately, standard GPs computationally scale cubically in the number of observations, limiting their applicability to relatively small datasets.  There are a wide variety of methods to approximate Gaussian processes using, for example, pseudo-observations~\citep{snelson-ghahramani2006} or variational inference~\citep{titsias2009}.  We implemented both standard and sparse GPs but only report the former due to similar performance.  For the standard GP, due to the scaling issue, we stop adding inputs to the GP after 1000 observations.  This performed significantly better than randomly sampling inputs.  Our implementation is a multi-task Gaussian process~\citep{Bonilla2008} with a linear and Matern  product kernel over the inputs and an exponentiated quadratic kernel over latent vectors for the different tasks.  The hyperparameters of this model and the latent task vectors are optimized over the GP marginal likelihood. This allows the model to learn correlations between the outputs of the model.
Specifically, the covariance function  of the GP is given by:
\newcommand{\brmx}{\mathrm{\mathbf{x}}}
\newcommand{\blambda}{\mathbf{\lambda}}
\newcommand{\brmxhat}{\mathrm{\mathbf{\hat{x}}}}
\newcommand{\brmv}{\mathrm{\mathbf{v}}}
\newcommand{\brmvhat}{\mathrm{\mathbf{\hat{v}}}}

and the task kernel between tasks  and  are  where  indexes the latent vector for task  and . The length-scales,  and , and amplitude parameters ,  are optimized via the log marginal likelihood. For the sparse version we used a Sparse Variational GP~\citep{hensman2014} with the same kernel and with 300 inducing points, trained via minibatch stochastic gradient descent~\citep{GPflow2017}.



 \section{Feedback Loop in the Linear Case}\label{s:linear}
In this section, we illustrate some of the subtleties that arise when uncertainty estimates drive sequential decision-making using simple linear examples.


There is a fundamental difference between \emph{static} and \emph{dynamic} scenarios.
In a static scenario, e.g.\ supervised learning, we are given a model family  (like the set of linear models, trees, or neural networks with specific dimensions), a prior distribution  over , and some observed data  that ---importantly--- is assumed i.i.d.
Our goal is to return an approximate posterior distribution: .\,
We define the quality of our approximation by means of some distance .

\begin{figure}[t]
\begin{subfigure}[c]{0.95\textwidth}\includegraphics[width=1\linewidth]{images/linear_vs_linear_each_own_data_3.png}
  \caption{Two independent instances of Thompson Sampling with the true linear posterior.}
  \label{fig:lin1a}
\end{subfigure}
\begin{subfigure}[c]{0.95\textwidth}\includegraphics[width=1\linewidth]{images/linear_vs_diag_each_own_data_3.png}
  \caption{Thompson Sampling with the true linear posterior (green), and the diagonalized version (red).}
  \label{fig:lin1b}
\end{subfigure}
\begin{subfigure}[c]{0.95\textwidth}\includegraphics[width=1\linewidth]{images/linear_vs_diag_each_linear_data_3.png}
  \caption{Linear posterior versus diagonal posterior fitted to the data collected by the former.}
  \label{fig:lin1c}
\end{subfigure}
\caption{Visualizations of the posterior approximations in a linear example.}
\label{fig:lin1}
\end{figure}

\begin{figure}[t]
\begin{subfigure}[c]{0.31\textwidth}\includegraphics[width=1\linewidth]{images/linear_posterior_approxs.png}
  \caption{Posterior Approximations.}
  \label{fig:figure4}
\end{subfigure}
\begin{subfigure}[c]{0.31\textwidth}\includegraphics[width=1\linewidth]{images/d_15_regret_linear.png}
  \caption{Case .}
  \label{fig:figure5}
\end{subfigure}
\begin{subfigure}[c]{0.31\textwidth}\includegraphics[width=1\linewidth]{images/d_30_regret_linear.png}
  \caption{Case .}
  \label{fig:figure6}
\end{subfigure}
\caption{The impact on regret of different approximated posteriors. We show (green) the actual linear posterior, (orange) the diagonal posterior approximation and (blue) the precision approximation in~\ref{fig:figure4}.  In~\ref{fig:figure5} and~\ref{fig:figure6} we visualize the impact of the approximations on cumulative regret.}
\label{fig:lin2}
\end{figure}

On the other hand, in \emph{dynamic} settings, our estimate at time , say , will be used via some mechanism , in this case Thompson sampling, to collect the next data-point, which is then appended to . In this case, the data-points in  are no longer independent.
 will now determine two distributions: the posterior given the data that was actually observed, , and our new estimate~.
When the goal is to make good sequential decisions in terms of cumulative regret, the distance  is in general no longer a definitive proxy for performance.
For instance, a poorly-approximated decision boundary could lead an algorithm, based on , to get stuck repeatedly selecting a single sub-optimal action .
After collecting lots of data for that action,  and  could start to agree (to their capacity) on the models that explain what was observed for , while both would stick to something close to the prior regarding the other actions.
At that point,  may show relatively little disagreement, but the regret would already be terrible.

Let  be the posterior distribution  under Thompson Sampling's assumption, that is, data was always collected according to  for .
We follow the idea that  being close to  for all  leads to strong performance.
However, this concept is difficult to formalize: once different decisions are made, data for different actions is collected and it is hard to compare posterior distributions.

We illustrate the previous points with a simple example, see Figure 1.
Data is generated according to a bandit with  arms.
For a given context , the reward obtained by pulling arm  follows a linear model  with .
The posterior distribution over  can be exactly computed using the standard Bayesian linear regression formulas presented in Section~\ref{s:algorithms}.
We set the contextual dimension , and the prior to be , for  .

In Figure~\ref{fig:lin1}, we show the posterior distribution for two dimensions of  for each arm  after  pulls.
In particular, in Figure~\ref{fig:lin1a}, two independent runs of Thompson Sampling with their posterior distribution are displayed in red and green.
While strongly aligned, the estimates for some arms disagree (especially for arms that are best only for a \emph{small} fraction of the contexts, like Arm 2 and 3, where fewer data-points are available).
In Figure~\ref{fig:lin1b}, we also consider Thompson Sampling with an approximate posterior with diagonal covariance matrix, \emph{Diag} in red, as defined in Section~\ref{s:algorithms}.
Each algorithm collects its own data based on its current posterior (or approximation).
In this case, the posterior disagreement after  decisions is certainly stronger.
However, as shown in Figure~\ref{fig:lin1c}, if we computed the approximate posterior with a diagonal covariance matrix based on the data collected \emph{by the actual posterior}, the disagreement would be reduced as much as possible within the approximation capacity (i.e., it still cannot capture correlations in this case).
Figure~\ref{fig:lin1b} shows then the effect of the feedback loop.
We look next at the impact that this mismatch has on regret.



We illustrate with a similar example how inaccurate posteriors sometimes lead to quite different behaviors in terms of regret.
In Figure~\ref{fig:figure4}, we see the posterior distribution  of a linear model in green, together with the two diagonal linear approximations introduced in Section~\ref{s:algorithms}: the Diag (in orange) and the PrecisionDiag (in blue) approximations, respectively.
We now assume there are  linear arms,  for , and decisions are made according to the posteriors in Figure~\ref{fig:figure4}.
In Figures \ref{fig:figure5} and \ref{fig:figure6} we plot the regret of Thompson Sampling when there are  arms, for both  and .
We see that, while the PrecisionDiag approximation does even outperform the actual posterior, the diagonal covariance approximation truly suffers poor regret when we increase the dimension , as it is heavily penalized by \emph{simultaneously} over-exploring in a large number of dimensions and repeateadly acting according to implausible models.


 \section{Empirical Evaluation}\label{s:experiments}

In this section, we present the simulations and outcomes of several synthetic and real-world data bandit problems with each of the algorithms introduced in Section~\ref{s:algorithms}.
In particular, we first explain how the simulations were set up and run, and the metrics we report.
We then split the experiments according to how data was generated, and the underlying models fit by the algorithms from Section~\ref{s:algorithms}.






\subsection{The Experimental Framework}
We run the contextual bandit experiments as described at the beginning of Section~\ref{s:problem}, and discuss below some implementation details of both experiments and algorithms.
A detailed summary of the key parameters used for each algorithm can be found in Table~\ref{tab:algo_description_main} in the appendix.



\textbf{Neural Network Architectures}
All algorithms based on neural networks as function approximators share the same architecture.
In particular, we fit a simple fully-connected feedforward network with two hidden layers with 100 units each and ReLu activations.
The input of the network has dimension  (same as the contexts), and there are  outputs, one per action.
Note that for each training point  only one action was observed (and algorithms usually only take into account the loss corresponding to the prediction for the observed action).

\textbf{Updating Models}
A key question is how often and for how long models are updated.
Ideally, we would like to train after each new observation and for as long as possible.
However, this may limit the applicability of our algorithms in online scenarios where decisions must be made immediately.
We update linear algorithms after each time-step by means of \eqref{eq:bayesian_linear_regression} and \eqref{eq:bayesian_linear_regression2}.
For neural networks, the default behavior was to train for  or  mini-batches every  timesteps.~\footnote{For reference, the standard strategy for Deep Q-Networks on Atari is to make one model update after every 4 actions performed~\citep{mnih2015,osband2016deep,Plappert17,Fortunato2017}.}
The size of each mini-batch was 512.
We experimented with increasing values of , and it proved essential for some algorithms like variational inference approaches.
See the details in Table~\ref{tab:algo_description_main}.

\textbf{Metrics}  We report two metrics: cumulative regret and simple regret.
We approximate the latter as the mean cumulative regret in the last 500 time-steps, a proxy for the quality of the final policy (see further discussion on pure exploration settings, \cite{bubeck2009pure}).
Cumulative regret is computed based on the best expected reward, as is standard.
For most real datasets (Statlog, Covertype, Jester, Adult, Census, and Song), the rewards were deterministic, in which case, the definition of regret also corresponds to the highest \emph{realized} reward (i.e., possibly leading to a hard task, which helps to understand why in some cases all regrets look linear).
We reshuffle the order of the contexts, and rerun the experiment 50 times to obtain the cumulative regret distribution and report its statistics.


\textbf{Hyper-Parameter Tuning} Deep learning methods are known to be very sensitive to the selection of a wide variety of hyperparameters, and many of the algorithms presented are no exception.  Moreover, that choice is known to be highly dataset dependent.  Unfortunately, in the bandits scenario, we commonly do not have access to each problem a-priori to perform tuning.
For the vast majority of algorithms, we report the outcome for \emph{three} versions of the algorithm defined as follows.
First, we use one version where hyper-parameters take values we guessed to be reasonable a-priori.
Then, we add two additional instances whose hyper-parameters were optimized on two different datasets via Bayesian Optimization.
For example, in the case of Dropout, the former version is named Dropout, while the optimized versions are named Dropout-MR (using the Mushroom dataset) and Dropout-SL (using the Statlog dataset) respectively.
Some algorithms truly benefit from hyper-parameter optimization, while others do not show remarkable differences in performance; the latter are more appropriate in settings where access to the real environment for tuning is not possible in advance.


\textbf{Buffer} After some experimentation, we decided not to use a data buffer as evidence of catastrophic forgetting was observed, and datasets are relatively small.
Accordingly, all observations are sampled with equal probability to be part of a mini-batch.
In addition, as is standard in bandit algorithms, each action was initially selected  times using round-robin independently of the context.

\subsection{Real-World Data Problems with Non-Linear Models} 
We evaluated the algorithms on a range of bandit problems created from real-world data. In particular, we test on the Mushroom, Statlog, Covertype, Financial, Jester, Adult, Census, and Song datasets (see Appendix Section~\ref{s:datasets} for details on each dataset and bandit problem). They exhibit a broad range of properties: small and large sizes, one dominating action versus more homogeneous optimality, learnable or little signal, stochastic or deterministic rewards, etc. 
For space reasons, the outcome of some simulations are presented in the Appendix.
The Statlog, Covertype, Adult, and Census datasets were originally tested in \cite{elmachtoub2017practical}. We summarize the final cumulative regret for Mushroom, Statlog, Covertype, Financial, and Jester datasets in Table~\ref{tab:nonlinear_cum_regret_main}.  In Figure~\ref{fig:boxplot_results} at the appendix, we show a box plot of the ranks achieved by each algorithm across the suite of bandit problems (see Appendix Table~\ref{tab:nonlinear_cum_regret_appendix} and \ref{tab:nonlinear_simple_regret_appendix} for the full results). 

\begin{table}[ht]
  \caption{Cumulative regret incurred by the algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Results are relative to the cumulative regret of the Uniform algorithm. We report the mean and standard error of the mean over 50 trials.}
  \label{tab:nonlinear_cum_regret_main}
  \centering
  \footnotesize
  \tiny
  \begin{tabular}{lllllll}
& Mean Rank & Mushroom & Statlog & Covertype & Financial & Jester \\
\midrule
AlphaDivergence (1) & 47& & & & &  \\
AlphaDivergence & 46.6& & & & &  \\
AlphaDivergence-SL & 44.3& & & & &  \\
BBB & 39.8& & & & &  \\
BBB-MR & 37.5& & & & &  \\
BBB-SL & 34.4& & & & &  \\
BootstrappedNN & 22.4& & & & &  \\
BootstrappedNN-MR & 22.6& & & & &  \\
BootstrappedNN-SL & 22.9& & & & &  \\
Dropout & 30.5& & & & &  \\
Dropout-MR & 20.3& & & & &  \\
Dropout-SL & 26.4& & & & &  \\
GP & 31.75& & & & &  \\
NeuralLinear & 22& & & & &  \\
NeuralLinear-MR & 22.4& \bm{}& & & &  \\
NeuralLinear-SL & 17.4& & \bm{}& & &  \\
RMS & 28.7& & & & &  \\
RMS-MR & 29.8& & & & &  \\
RMS-SL & 30.7& & & & &  \\
SGFS & 30.8& & & & &  \\
SGFS-MR & 21.8& & & & &  \\
SGFS-SL & 30.9& & & & &  \\
ConstSGD & 36.9& & & \bm{}& &  \\
ConstSGD-MR & 29.9& & & & &  \\
ConstSGD-SL & 35.1& & & \bm{}& &  \\
EpsGreedyRMS & 23.6& & & & &  \\
EpsGreedyRMS-SL & 23.2& & & & &  \\
EpsGreedyRMS-MR & 24.4& & & & &  \\
LinDiagPost & 30.6& & & & & \bm{} \\
LinDiagPost-MR & 37.3& & & & &  \\
LinDiagPost-SL & 31.5& & & & &  \\
LinDiagPrecPost & 15.8& & & & & \bm{} \\
LinDiagPrecPost-MR & 26.1& & & & & \bm{} \\
LinDiagPrecPost-SL & 16.9& & & & \bm{}& \bm{} \\
LinGreedy & 25.3& & & & & \bm{} \\
LinGreedy () & 18.1& & & & &  \\
LinGreedy () & 19.6& & & & &  \\
LinPost & 16.4& & & & & \bm{} \\
LinPost-MR & 28.3& & & & & \bm{} \\
LinPost-SL & 18.9& & & & &  \\
LinFullDiagPost & 33.1& & & & &  \\
LinFullDiagPost-MR & 28.2& & & & &  \\
LinFullDiagPost-SL & 27.9& & & & &  \\
LinFullDiagPrecPost & 14.3& & & & &  \\
LinFullDiagPrecPost-MR & 15.6& & & & &  \\
LinFullDiagPrecPost-SL & 17.7& & & & &  \\
LinFullPost & 13.9& & & & &  \\
LinFullPost-MR & 16.8& \bm{}& & & &  \\
LinFullPost-SL & 18.1& & & & &  \\
ParamNoise & 27.4& & & & &  \\
ParamNoise-MR & 23& & & & &  \\
ParamNoise-SL & 20.9& & & & &  \\
Uniform & 51& & & & &  \\
\bottomrule
\end{tabular}
 \end{table}


\subsection{Real-World Data Problems with Linear Models}
As most of the algorithms from Section~\ref{s:algorithms} can be implemented for any model architecture, in this subsection we use linear models as a baseline comparison across algorithms (i.e., neural networks that contain a single linear layer). This allows us to directly compare the approximate methods against methods that can compute the exact posterior. The specific hyper-parameter configurations used in the experiments are described in Table~\ref{tab:algo_linear_description} in the appendix. Datasets are the same as in the previous subsection. The cumulative and simple regret results are provided in appendix Tables~\ref{tab:linear_cum_regret_appendix} and \ref{tab:linear_simple_regret_appendix}.


\subsection{The Wheel Bandit}
Some of the real-data problems presented above do not require significant exploration.
We design an artificial problem where the need for exploration is smoothly parameterized.
The \emph{wheel} bandit is defined as follows (see Figure~\ref{fig:cb}).
Set , and , the exploration parameter.
Contexts are sampled uniformly at random in the unit circle in , .
There are  possible actions.
The first action  always offers reward , independently of the context.
On the other hand, for contexts such that , i.e.\ inside the blue circle in Figure~\ref{fig:cb}, the other four actions are equally distributed and sub-optimal, with  for .
When , we are outside the blue circle, and only one of the actions  is optimal depending on the sign of context components .
If , action 2 is optimal.
If , action 3 is optimal, and so on.
Non-optimal actions still deliver  in this region, except  whose mean reward is always , while the optimal action provides , with .
We set , and .
Note that the probability of a context randomly falling in the high-reward region is  (not blue).
The difficulty of the problem increases with , and we expect algorithms to get stuck repeatedly selecting action  for large .
The problem can be easily generalized for .
Results are shown in Table~\ref{tb:wheel-cumregret}. 

\begin{figure}[t]
\begin{subfigure}[t]{0.18\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/chrome_05.png}
  \caption{}
  \label{fig:cb05}
\end{subfigure}\begin{subfigure}[t]{0.18\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/chrome_07.png}
  \caption{}
  \label{fig:cb07}
\end{subfigure}\begin{subfigure}[t]{0.18\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/chrome_09.png}
  \caption{}
  \label{fig:cb09}
\end{subfigure}\begin{subfigure}[t]{0.18\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/chrome_095.png}
  \caption{}
  \label{fig:cb095}
\end{subfigure}\begin{subfigure}[t]{0.18\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/chrome_099.png}
  \caption{}
  \label{fig:cb099}
\end{subfigure}
\caption{Wheel bandits for increasing values of . Optimal action for blue, red, green, black, and yellow regions, are actions 1, 2, 3, 4, and 5, respectively.}
\label{fig:cb}
\end{figure}


\begin{figure}[t]
\begin{subfigure}[t]{0.48\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/plot_linear_BBB_linear_data3.pdf}
  \caption{Linear data,  input size, and  actions.}
  \label{fig:linbbb1}
\end{subfigure}\begin{subfigure}[t]{0.48\textwidth}
  \centering
  \includegraphics[width=\linewidth]{images/plot_linear_BBB_statlog2.pdf}
  \caption{Statlog data.}
  \label{fig:linbbb2}
\end{subfigure}\caption{Cumulative regret for Bayes By Backprop (Variational Inference, fixed noise ) applied to a linear model and an exact mean field solution, denoted PrecisionDiag, with a linear bandit (left) and with the Statlog bandit (right). The suffix of the BBB legend label indicates the number of training epochs in each training step. We emphasize that in this evaluation, all algorithms use the same family of models (i.e., linear). While PrecisionDiag exactly solves the mean field problem, BBB relies on partial optimization via SGD. As the number of training epochs increases, BBB improves performance, but is always outperformed by PrecisionDiag.} \label{fig:linbbb}
\end{figure}

































 \section{Discussion}\label{s:discussion}
Overall, we found that there is significant room for improvement in uncertainty estimation for neural networks in sequential decision-making problems. First, unlike in supervised learning, sequential decision-making requires the model to be frequently updated as data is accumulated. As a result, methods that converge slowly are at a disadvantage because we must truncate optimization to make the method practical for the online setting. In these cases, we found that \emph{partially} optimized uncertainty estimates can lead to catastrophic decisions and poor performance.
Second, and while it deserves further investigation, it seems that \emph{decoupling} representation learning and uncertainty estimation improves performance. The NeuralLinear algorithm is an example of this decoupling. With such a model, the uncertainty estimates can be solved for in closed form (but may be erroneous due to the simplistic model), so there is no issue with partial optimization. We suspect that this may be the reason for the improved performance. In addition, we observed that many algorithms are sensitive to their hyperparameters, so that best configurations are problem-dependent.

Finally, we found that in many cases, the inherit randomness in Stochastic Gradient Descent provided sufficient exploration. Accordingly, in some scenarios it may be hard to justify the use of complicated (and less transparent) variations of simple methods.
However, Stochastic Gradient Descent is by no means always enough: in our synthetic exploration-oriented problem (the Wheel bandit) additional exploration was necessary.

Next, we discuss our main findings for each class of algorithms.

\textbf{Linear Methods.} Linear methods offer a reasonable baseline, surprisingly strong in many cases. While their representation power is certainly a limiting factor, their ability to compute informative uncertainty measures seems to payoff and balance their initial disadvantage.
They do well in several datasets, and are able to react fast to unexpected or extreme rewards (maybe as single points can have a heavy impact in fitted models, and their updates are immediate, deterministic, and exact).
Some datasets clearly need more complex non-linear representations, and linear methods are unable to efficiently solve those.
In addition, linear methods obviously offer computational advantages, and it would be interesting to investigate how their performance degrades when a finite data buffer feeds the estimates as various real-world online applications may require (instead of all collected data).

In terms of the diagonal linear approximations described in Section~\ref{s:algorithms}, we found that diagonalizing the precision matrix (as in mean-field Variational Inference) performs dramatically better than diagonalizing the covariance matrix.

\textbf{NeuralLinear.} The NeuralLinear algorithm sits near a sweet spot that is worth further studying. In general it seems to improve the RMS neural network it is based on, suggesting its exploration mechanisms add concrete value. We believe its main strength is that it is able to \emph{simultaneously} learn a data representation that greatly simplifies the task at hand, and to accurately quantify the uncertainty over linear models that explain the observed rewards in terms of the proposed representation. While the former process may be noisier and heavily dependent on the amount of training steps that were taken and available data, the latter always offers the exact solution to its approximate parent problem. This, together with the partial success of linear methods with poor representations, may explain its promising results. In some sense, it knows what it knows.
In the Wheel problem, which requires increasingly good exploration mechanisms, NeuralLinear is probably the best algorithm.
Its performance is almost an order of magnitude better than any RMS algorithm (and its spinoffs, like Bootstrapped NN, Dropout, or Parameter Noise), and all greedy linear approaches.
On the other hand, it is able to successfully solve problems that require non-linear representations (as Statlog or Covertype) where linear approaches fail. 
In addition, the algorithm is remarkably easy to tune, and robust in terms of hyper-parameter configurations. 
While conceptually simple, its deployment to large scale systems may involve some technical difficulties; mainly, to update the Bayesian estimates when the network is re-trained. We believe, however, standard solutions to similar problems (like running averages) could greatly mitigate these issues.
In our experiments and compared to other algorithms, as shown in Table~\ref{tab:nonlinear_time_appendix}, NeuralLinear is fast from a computational standpoint.

\textbf{Variational Inference.}
Overall, Bayes By Backprop performed poorly, ranking in the bottom half of algorithms across datasets (Table~\ref{tab:nonlinear_cum_regret_main}). To investigate if this was due to underestimating uncertainty (as variational methods are known to \citep{bishop2006pattern}), to the mean field approximation, or to stochastic optimization, we applied BBB to a linear model, where the mean field optimization problem can be solved in closed form (Figure~\ref{fig:linbbb}). We found that the performance of BBB slowly improved as the number of training epochs increased, but underperformed compared to the exact mean field solution. Moreover, the difference in performance due to the number of training steps dwarfed the difference between the mean field solution and the exact posterior. This suggests that it is not sufficient to partially optimize the variational parameters when the uncertainty estimates directly affect the data being collected. In supervised learning, optimizing to convergence is acceptable, however in the online setting, optimizing to convergence at every step incurs unreasonable computational cost.

\textbf{Expectation-Propagation.}
The performance of Black Box -divergence algorithms was poor. Because this class of algorithms is similar to BBB (in fact, as , it converges to the BBB objective), we suspect that partial convergence was also the cause of their poor performance. We found these algorithms to be sensitive to the number of training steps between actions, requiring a large number to achieve marginal performance. Their terrible performance in the Mushroom bandit is remarkable, while in the other datasets they perform slightly worse than their variational inference counterpart. Given the successes of Black Box -divergence in other domains~\citep{Hernandez-Lobato2016}, investigating approaches to sidestep the slow convergence of the uncertainty estimates is a promising direction for future work.

\textbf{Monte Carlo.}  Constant-SGD comes out as the winner on Covertype, which requires non-linearity and exploration as evidenced by performance of the linear baseline approaches (Table~\ref{tab:nonlinear_cum_regret_main}).  The method is especially appealing as it does not require tuning learning rates or exploration parameters. SGFS, however, performs better on average.  The additional injected noise in SGFS may cause the model to explore more and thus perform better, as shown in the Wheel Bandit problem where SGFS strongly outperforms Constant-SGD.

\textbf{Bootstrap.}
The bootstrap offers significant gains with respect to its parent algorithm (RMS) in several datasets.
Note that in Statlog one of the actions is optimal around 80\% of the time, and the bootstrapped predictions may help to avoid getting stuck, something from which RMS methods may suffer.
In other scenarios, the randomness from SGD may be enough for exploration, and the bootstrap may not offer important benefits.
In those cases, it might not justify the heavy computational overhead of the method.
We found it surprising that the optimized versions of BootstrappedNN decided to use \emph{only}  and  networks respectively (while we set its value to  in the manually tuned version, and the extra networks did not improve performance significantly).
Unfortunately, Bootstrapped NNs were not able to solve the Wheel problem, and its performance was fairly similar to that of RMS.
One possible explanation is that ---given the sparsity of the reward--- all the bootstrapped networks agreed for the most part, and the algorithm simply got stuck selecting action . As opposed to linear models, reacting to unusual rewards could take Bootstrapped NNs some time as good predictions could be randomly overlooked (and useful data discarded if ).

\textbf{Direct Noise Injection.} When properly tuned, Parameter-Noise provided an important boost in performance across datasets over the learner that it was based on (RMS), average rank of ParamNoise-SL is  compared to RMS at  (Table~\ref{tab:nonlinear_cum_regret_main}). However, we found the algorithm hard to tune and sensitive to the heuristic controlling the injected noise-level. On the synthetic Wheel problem ---where exploration is necessary--- both parameter-noise and RMS suffer from underexploration and perform similarly, except ParamNoise-MR which does a good job. In addition, developing an intuition for the heuristic is not straightforward as it lacks transparency and a principled grounding, and thus may require repeated access to the decision-making process for tuning.

\textbf{Dropout.} We initially experimented with two dropout versions: fixed , and . The latter consistently delivered better results, and it is the one we manually picked.
The optimized versions of the algorithm provided decent improvements over its base RMS (specially Dropout-MR).
In the Wheel problem, dropout performance is somewhat poor: Dropout is outperformed by RMS, while Dropout-MR offers gains with respect to all versions of RMS but it is not competitive with the best algorithms.
Overall, the algorithm seems to heavily depend on its hyper-parameters (see cum-regret performance of the raw Dropout, for example).
Dropout was used both for training and for decision-making; unfortunately, we did not add a baseline where dropout only applies during training. Consequently, it is not obvious how to disentangle the contribution of better training from that of better exploration. This remains as future work.

\textbf{Bayesian Non-parametrics.} Perhaps unsurprisingly, Gaussian processes perform reasonably well on problems with little data but struggle on larger problems. While this motivated the use of sparse GP, the latter was not able to perform similarly to stronger (and definitively simpler) methods.
 \section{Conclusions and Future Work}\label{s:conclusions}

In this work, we empirically studied the impact on performance of approximate model posteriors for decision making via Thompson Sampling in contextual bandits.
We found that the most robust methods exactly measured uncertainty (possibly under the wrong model assumptions) on top of complex representations learned in parallel.
More complicated approaches that learn the representation and its uncertainty together seemed to require heavier training, an important drawback in online scenarios, and exhibited stronger hyper-parameter dependence.
Further exploring and developing the promising approaches is an exciting avenue for future work.
 



\newcommand*\rot{\rotatebox{90}}








\subsubsection*{Acknowledgments}
We are extremely grateful to Dan Moldovan, Sven Schmit, Matt Hoffman, Matt Johnson, Ramon Iglesias, and Rif Saurous for their valuable feedback and comments.
We also thank the anonymous reviewers, whose suggestions truly helped improve the current work.

\bibliography{iclr2016_conference}
\bibliographystyle{iclr2016_conference}


\clearpage
\appendix
\section*{Appendix}

\begin{figure}[ht]
 \includegraphics[width=\linewidth]{images/rank_boxplot}
 \caption{A boxplot of the ranks achieved by each algorithm across the suite of benchmarks.  The red and black solid lines respectively indicate the median and mean rank across problems.}
 \label{fig:boxplot_results}
 \end{figure}

\begin{table}[ht]
  \caption{Detailed description of the algorithms in the experiments. Unless otherwise stated, algorithms use  (mini-batches per training period), and  (one training period every  contexts).}
  \label{tab:algo_description_main}
  \centering
  \footnotesize
  \tiny
\begin{adjustbox}{center}
  \begin{tabular}{ll}
  Algorithm  & Description \\
    \midrule
AlphaDivergence (1) & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ).  \\
AlphaDivergence & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ). \\
AlphaDivergence-SL & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ).  \\
BBB & BayesByBackprop with noise . (, first 100 times linear decay from ). \\
BBB-MR & BayesByBackprop with noise , and prior . (, first 100 times linear decay from ). \\
BBB-SL & BayesByBackprop with noise , and prior . (, first 100 times linear decay from ). \\
BootstrappedNN & Bootstrapped with  models, and . Based on RMS3 net. \\
BootstrappedNN-MR & Bootstrapped with  models, , . Based on RMS2 net. \\
BootstrappedNN-SL & Bootstrapped with  models, , . Based on RMS3 net. \\
Dropout & Dropout with probability . Based on RMS2 net. \\
Dropout-MR & Dropout with probability . Based on RMS2 net. \\
Dropout-SL & Dropout with probability . Based on RMS3 net. \\
GP & For computational reasons, it only uses the first 1000 data points. \\
NeuralLinear & Noise prior . Ridge prior . Based on RMS2 net. Trained for .  \\
NeuralLinear-MR & Noise prior . Ridge prior . Based on RMS2 net. Trained for .  \\
NeuralLinear-SL & Noise prior . Ridge prior . Based on RMS2 net. Trained for .  \\
RMS1 & Greedy NN approach, fixed learning rate . \\
RMS2 & Learning rate decays, and it is reset every training period. \\
RMS3 & Learning rate decays, and it is not reset at all. It starts at . \\
RMS & Based on RMS3 net. Learning decay rate is , initial learning rate is . Trained for . \\
RMS-MR & Based on RMS3 net. Learning decay rate is , initial learning rate is . Trained for . \\
RMS-SL & Based on RMS3 net. Learning decay rate is , initial learning rate is . Trained for . \\
SGFS & Burning , learning rate , EMA decay , noise . \\
SGFS-MR & Burning , learning rate , EMA decay , noise . \\
SGFS-SL & Burning , learning rate , EMA decay , noise . \\
ConstSGD & Burning , EMA decay , noise . \\
ConstSGD-MR & Burning , EMA decay , noise . Trained for . \\
ConstSGD-SL & Burning , EMA decay , noise . Trained for . \\
EpsGreedyRMS & Initial , multiplied by  after every context. Based on RMS3 net. \\
EpsGreedyRMS-MR & Initial , multiplied by  after every context. Based on RMS3 net. Trained for . \\
EpsGreedyRMS-SL & Initial , multiplied by  after every context. Based on RMS2 net. Trained for . \\
LinPost & Ridge prior . Assumed noise level . \\
LinPost-MR & Ridge prior . Assumed noise level . \\
LinPost-SL & Ridge prior . Assumed noise level . \\
LinDiagPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPost-MR &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPost-SL &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPrecPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPrecPost-MR &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPrecPost-SL &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinGreedy & Takes action with highest predicted reward for Ridge regression, . Noise level . \\
LinGreedy (eps = 0.01) & linGreedy that selects action uniformly at random with prob . \\
LinGreedy (eps = 0.05) & linGreedy that selects action uniformly at random with prob . \\
LinFullPost & Noise prior . Ridge prior . \\
LinFullPost-MR & Noise prior . Ridge prior . \\
LinFullPost-SL & Noise prior . Ridge prior . \\
LinFullDiagPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPost-MR &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPost-SL &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPrecPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPrecPost-MR &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPrecPost-SL &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
ParamNoise & Layer normalization. Initial noise , and level . Based on RMS2 net.  \\
ParamNoise-MR & Layer normalization. Initial noise , and level . Based on RMS3 net, .  \\
ParamNoise-SL & Layer normalization. Initial noise , and level . Based on RMS2 net, . \\
Uniform & Takes each action at random with equal probability. \\
    \bottomrule
  \end{tabular}
\end{adjustbox}
\end{table}







\begin{table}[ht]
  \caption{Detailed description of the algorithms in the \emph{linear} experiments. Unless otherwise stated, algorithms use  (mini-batches per training period), and  (one training period every  contexts).}
  \label{tab:algo_linear_description}
  \centering
  \footnotesize
  \tiny
  \begin{tabular}{ll}
  Algorithm  & Description \\
    \midrule
Alpha Divergences & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ). \\
Alpha Divergences (1) & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ).  \\
Alpha Divergences (2) & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ).  \\
Alpha Divergences (3) & BB -divergence with , noise , , prior var . (, first 100 times linear decay from ).  \\
BBBN & BayesByBackprop with noise . (, first 100 times linear decay from ). \\
BBBN2 & BayesByBackprop with noise . (, first 100 times linear decay from ). \\
BBBN3 & BayesByBackprop with noise . (, first 100 times linear decay from ). \\
BBBN4 & BayesByBackprop with noise . (, first 100 times linear decay from ). \\
Bootstrapped NN & Bootstrapped with  models, and . Based on RMS3 net. \\
Bootstrapped NN2 & Bootstrapped with  models, and . Based on RMS3 net. \\
Bootstrapped NN3 & Bootstrapped with  models, and . Based on RMS3 net. \\
Dropout (RMS3) & Dropout with probability . Based on RMS3 net. \\
Dropout (RMS2) & Dropout with probability . Based on RMS2 net. \\
RMS1 & Greedy NN approach, fixed learning rate . \\
RMS2 & Learning rate decays, and it is reset every training period. \\
RMS2b & Similar to RMS2, but training for longer (). \\
RMS3 & Learning rate decays, and it is not reset at all. Starts at . \\
SGFS & Burning , learning rate , EMA decay , noise . \\
ConstSGD & Burning , EMA decay , noise . \\
EpsGreedy (RMS1) & Initial . Multiplied by  after every context. Based on RMS1 net. \\
EpsGreedy (RMS2) & Initial . Multiplied by  after every context. Based on RMS2 net. \\
EpsGreedy (RMS3) & Initial . Multiplied by  after every context. Based on RMS3 net. \\
LinDiagPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinDiagPrecPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized.  Ridge prior . Assumed noise level . \\
LinGreedy & Takes action with highest predicted reward for Ridge regression, . Noise level . \\
LinGreedy (eps = 0.01) & linGreedy that selects action uniformly at random with prob . \\
LinGreedy (eps = 0.05) & linGreedy that selects action uniformly at random with prob . \\
LinPost & Ridge prior . Assumed noise level . \\
LinFullDiagPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullDiagPrecPost &  in Eq.~\ref{eq:bayesian_linear_regression} is diagonalized. Noise prior . Ridge prior . \\
LinFullPost & Noise prior . Ridge prior . \\
Param-Noise & Initial noise , and level . Based on RMS3 net.  \\
Param-Noise2 & Initial noise , and level . Based on RMS3 net. Trained for longer: . \\
Uniform & Takes each action at random with equal probability. \\
    \bottomrule
  \end{tabular}
\end{table}














\begin{landscape}
\begin{table}[ht]
  \caption{Cumulative regret incurred by \emph{linear} models using algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Values reported are the mean over 50 independent trials with standard error of the mean.}
  \label{tab:linear_cum_regret_appendix}
  \centering
  \footnotesize
  \tiny
  \begin{tabular}{lllllll}
    & Mushroom & Statlog & Covertype & Financial & Jester & Adult \\
    \midrule
\textbf{Cumulative regret} & & & & & &  \\
    \midrule
Alpha Divergences & & & & & &  \\
Alpha Divergences (1) & & & & & &  \\
Alpha Divergences (2) & & & & & &  \\
Alpha Divergences (3) & & & & & &  \\
BBBN & & \bm{}& \bm{}& & \bm{}& \bm{} \\
BBBN2 & & & & & \bm{}&  \\
BBBN3 & & & & & &  \\
BBBN4 & & & & & \bm{}&  \\
Bootstrapped NN & & & & & &  \\
Bootstrapped NN2 & & & & & &  \\
Bootstrapped NN3 & & \bm{}& & \bm{}& &  \\
Dropout (RMS3) & & & & \bm{}& \bm{}&  \\
Dropout (RMS2) & & & & & &  \\
RMS1 & & & & & &  \\
RMS2 & & & & & \bm{}&  \\
RMS2b & & & & & \bm{}&  \\
RMS3 & & & & \bm{}& &  \\
SGFS & & & & & &  \\
ConstSGD & & & & & &  \\
EpsGreedy (RMS1) & & & & & &  \\
EpsGreedy (RMS2) & & & & & \bm{}&  \\
EpsGreedy (RMS3) & & & & & \bm{}&  \\
LinDiagPost & & & & & \bm{}&  \\
LinDiagPrecPost & & & & & \bm{}&  \\
LinGreedy & & & & \bm{}& \bm{}&  \\
LinGreedy (eps=0.01) & & & & & &  \\
LinGreedy (eps=0.05) & & & & & &  \\
LinPost & & & & & &  \\
LinfullDiagPost & & & & & &  \\
LinfullDiagPrecPost & & & \bm{}& & &  \\
LinfullPost & \bm{}& & \bm{}& & &  \\
Param-Noise & & & & & &  \\
Param-Noise2 & & & & \bm{}& &  \\
Uniform & & & & & &  \\
    \bottomrule
  \end{tabular}

 \end{table}
\end{landscape}

\begin{landscape}
\begin{table}[ht]
  \caption{Simple regret incurred by \emph{linear} models using algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Simple regret was approximated by averaging the regret over the final 500 steps. Values reported are the mean over 50 independent trials with standard error of the mean.}
  \label{tab:linear_simple_regret_appendix}
  \centering
  \footnotesize
  \tiny
  \begin{tabular}{lllllll}
    & Mushroom & Statlog & Covertype & Financial & Jester & Adult \\
    \midrule
\textbf{Simple regret } & & & & & &  \\
    \midrule
Alpha Divergences & & & & \bm{}& &  \\
Alpha Divergences (1) & & & & \bm{}& &  \\
Alpha Divergences (2) & & & & & &  \\
Alpha Divergences (3) & & & & \bm{}& &  \\
BBBN & & & \bm{}& & \bm{}& \bm{} \\
BBBN2 & & & \bm{}& & \bm{}&  \\
BBBN3 & & & & & \bm{}&  \\
BBBN4 & & & & & \bm{}&  \\
Bootstrapped NN & & \bm{}& & & & \bm{} \\
Bootstrapped NN2 & & \bm{}& & & \bm{}& \bm{} \\
Bootstrapped NN3 & & \bm{}& & & &  \\
Dropout (RMS3) & & & & & \bm{}&  \\
Dropout (RMS2) & & & & & &  \\
RMS1 & & & & & &  \\
RMS2 & & & & & \bm{}&  \\
RMS2b & & & & & \bm{}&  \\
RMS3 & & & & & &  \\
SGFS & & & & & &  \\
ConstSGD & & & & & &  \\
EpsGreedy (RMS1) & \bm{}& & & & &  \\
EpsGreedy (RMS2) & & & & & \bm{}&  \\
EpsGreedy (RMS3) & & \bm{}& & & \bm{}&  \\
LinDiagPost & & & & & \bm{}&  \\
LinDiagPrecPost & & & \bm{}& & \bm{}&  \\
LinGreedy & & & & & \bm{}&  \\
LinGreedy (eps=0.01) & \bm{}& & & & & \bm{} \\
LinGreedy (eps=0.05) & & & & & &  \\
LinPost & & & \bm{}& & \bm{}&  \\
LinfullDiagPost & & & & & &  \\
LinfullDiagPrecPost & & & \bm{}& & & \bm{} \\
LinfullPost & \bm{}& & \bm{}& & & \bm{} \\
Param-Noise & & \bm{}& & & &  \\
Param-Noise2 & & \bm{}& & & &  \\
Uniform & & & & & &  \\
    \bottomrule
  \end{tabular}

 \end{table}
\end{landscape}

\begin{landscape}
\begin{table}[ht]
  \caption{Cumulative regret incurred by models using algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Values reported are the mean over 50 independent trials with standard error of the mean. Normalized with respect to the performance of Uniform.}
  \label{tab:nonlinear_cum_regret_appendix}
  \centering
  \footnotesize
  \tiny
	\vspace*{\fill}
	\begin{adjustbox}{center}
	\begin{tabular}{lllllllll}
 & Mushroom & Statlog & Covertype & Financial & Jester & Adult & Song & Census \\
\midrule
AlphaDivergence (1) & & & & & & & &  \\
AlphaDivergence & & & & & & & &  \\
AlphaDivergence-SL & & & & & & & &  \\
BBB & & & & & & & &  \\
BBB-MR & & & & & & & &  \\
BBB-SL & & & & & & & &  \\
BootstrappedNN & & & & & & & &  \\
BootstrappedNN-MR & & & & & & & &  \\
BootstrappedNN-SL & & & & & & & &  \\
Dropout & & & & & & & &  \\
Dropout-MR & & & & & & & &  \\
Dropout-SL & & & & & & & &  \\
GP & & & & & & & &  \\
NeuralLinear & & & & & & & &  \\
NeuralLinear-MR & \bm{}& & & & & & &  \\
NeuralLinear-SL & & \bm{}& & & & & &  \\
RMS & & & & & & & &  \\
RMS-MR & & & & & & & &  \\
RMS-SL & & & & & & & &  \\
SGFS & & & & & & & &  \\
SGFS-MR & & & & & & & &  \\
SGFS-SL & & & & & & & &  \\
ConstSGD & & & \bm{}& & & & &  \\
ConstSGD-MR & & & & & & & &  \\
ConstSGD-SL & & & \bm{}& & & & &  \\
EpsGreedyRMS & & & & & & & &  \\
EpsGreedyRMS-SL & & & & & & & &  \\
EpsGreedyRMS-MR & & & & & & & &  \\
LinDiagPost & & & & & \bm{}& & &  \\
LinDiagPost-MR & & & & & & & &  \\
LinDiagPost-SL & & & & & & & &  \\
LinDiagPrecPost & & & & & \bm{}& & &  \\
LinDiagPrecPost-MR & & & & & \bm{}& & &  \\
LinDiagPrecPost-SL & & & & \bm{}& \bm{}& \bm{}& &  \\
LinGreedy & & & & & \bm{}& & \bm{}& \bm{} \\
LinGreedy () & & & & & & & &  \\
LinGreedy () & & & & & & & &  \\
LinPost & & & & & \bm{}& & &  \\
LinPost-MR & & & & & \bm{}& & &  \\
LinPost-SL & & & & & & & &  \\
LinFullDiagPost & & & & & & & &  \\
LinFullDiagPost-MR & & & & & & & &  \\
LinFullDiagPost-SL & & & & & & & &  \\
LinFullDiagPrecPost & & & & & & & &  \\
LinFullDiagPrecPost-MR & & & & & & & &  \\
LinFullDiagPrecPost-SL & & & & & & & &  \\
LinFullPost & & & & & & & &  \\
LinFullPost-MR & \bm{}& & & & & & &  \\
LinFullPost-SL & & & & & & & &  \\
ParamNoise & & & & & & & &  \\
ParamNoise-MR & & & & & & & &  \\
ParamNoise-SL & & & & & & & &  \\
Uniform & & & & & & & &  \\
\bottomrule
\end{tabular}
 	\end{adjustbox}
	\vspace*{\fill}
\end{table}
\end{landscape}

\begin{landscape}
\begin{table}[ht]
  \caption{Simple regret incurred by models using algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Simple regret was approximated by averaging the regret over the final 500 steps. Values reported are the mean over 50 independent trials with standard error of the mean. Normalized with respect to the performance of Uniform.}
  \label{tab:nonlinear_simple_regret_appendix}
  \centering
  \footnotesize
  \tiny
	\vspace*{\fill}
	\begin{adjustbox}{center}
	\begin{tabular}{lllllllll}
 & Mushroom & Statlog & Covertype & Financial & Jester & Adult & Song & Census \\
\midrule
AlphaDivergence (1) & & & & & & & &  \\
AlphaDivergence & & & & & & & &  \\
AlphaDivergence-SL & & & & & & & &  \\
BBB & \bm{}& & & & & & &  \\
BBB-MR & & & & & & & &  \\
BBB-SL & & & & & & & &  \\
BootstrappedNN & & & & & & & &  \\
BootstrappedNN-MR & & & & & & & &  \\
BootstrappedNN-SL & & \bm{}& & & & & &  \\
Dropout & & & & & & & &  \\
Dropout-MR & \bm{}& & & & & & &  \\
Dropout-SL & & & & & & & &  \\
GP & & & & \bm{}& & & &  \\
NeuralLinear & \bm{}& & & & & & &  \\
NeuralLinear-MR & & & & & & & &  \\
NeuralLinear-SL & & \bm{}& & & & & &  \\
RMS & & & & & & & &  \\
RMS-MR & & & & & & & &  \\
RMS-SL & & & & & & & &  \\
SGFS & & & & & & & &  \\
SGFS-MR & & & & & & & &  \\
SGFS-SL & & & & & & & &  \\
ConstSGD & & & \bm{}& & & & &  \\
ConstSGD-MR & & & & & & & &  \\
ConstSGD-SL & & & \bm{}& & & & &  \\
EpsGreedyRMS & & & & & & & &  \\
EpsGreedyRMS-SL & & & & & & & &  \\
EpsGreedyRMS-MR & & & & & & & &  \\
LinDiagPost & & & & & \bm{}& & &  \\
LinDiagPost-MR & & & & & & & &  \\
LinDiagPost-SL & & & & \bm{}& & & &  \\
LinDiagPrecPost & & & & & \bm{}& & &  \\
LinDiagPrecPost-MR & & & & & & & &  \\
LinDiagPrecPost-SL & & & & \bm{}& \bm{}& \bm{}& \bm{}& \bm{} \\
LinGreedy & & & & & & & \bm{}& \bm{} \\
LinGreedy () & & & & & & & \bm{}&  \\
LinGreedy () & & & & & & & &  \\
LinPost & & & & & \bm{}& & & \bm{} \\
LinPost-MR & & & & & & & &  \\
LinPost-SL & & & & & & \bm{}& \bm{}& \bm{} \\
LinFullDiagPost & & & & & & & &  \\
LinFullDiagPost-MR & & & & & & & &  \\
LinFullDiagPost-SL & & & & & & & &  \\
LinFullDiagPrecPost & & & & \bm{}& & & & \bm{} \\
LinFullDiagPrecPost-MR & & & & & & & \bm{}&  \\
LinFullDiagPrecPost-SL & & & & & & & \bm{}&  \\
LinFullPost & & & & & & & & \bm{} \\
LinFullPost-MR & & & & & & & & \bm{} \\
LinFullPost-SL & & & & & & & & \bm{} \\
ParamNoise & & & & & & & &  \\
ParamNoise-MR & & & & & & & &  \\
ParamNoise-SL & \bm{}& & & & & & &  \\
Uniform & & & & & & & &  \\
\bottomrule
\end{tabular}
 	\end{adjustbox}
	\vspace*{\fill}
\end{table}
\end{landscape}

\begin{landscape}
\begin{table}[ht]
  \caption{Elapsed time for algorithms in Section~\ref{s:algorithms} on the bandits described in Section~\ref{s:datasets}. Values reported are the mean over 50 independent trials with standard error of the mean. Normalized with respect to the elapsed time required by RMS (which uses  and ).}
  \label{tab:nonlinear_time_appendix}
  \centering
  \footnotesize
  \tiny
	\vspace*{\fill}
	\begin{adjustbox}{center}
	\begin{tabular}{lllllllll}
 & Mushroom & Statlog & Covertype & Financial & Jester & Adult & Song & Census \\
\midrule
AlphaDivergence (1) & & & & & & & &  \\
AlphaDivergence & & & & & & & &  \\
AlphaDivergence-SL & & & & & & & &  \\
BBB & & & & & & & &  \\
BBB-MR & & & & & & & &  \\
BBB-SL & & & & & & & &  \\
BootstrappedNN & & & & & & & &  \\
BootstrappedNN-MR & & & & & & & &  \\
BootstrappedNN-SL & & & & & & & &  \\
Dropout & & & & & & & &  \\
Dropout-MR & & & & & & & &  \\
Dropout-SL & & & & & & & &  \\
GP & & & & & & & &  \\
NeuralLinear & & & & & & & &  \\
NeuralLinear-MR & & & & & & & &  \\
NeuralLinear-SL & & & & & & & &  \\
RMS & & & & & & & &  \\
RMS-MR & & & & & & & &  \\
RMS-SL & & & & & & & &  \\
SGFS & & & & & & & &  \\
SGFS-MR & & & & & & & &  \\
SGFS-SL & & & & & & & &  \\
ConstSGD & & & & & & & &  \\
ConstSGD-MR & & & & & & & &  \\
ConstSGD-SL & & & & & & & &  \\
EpsGreedyRMS & & & & & & & &  \\
EpsGreedyRMS-SL & & & & & & & &  \\
EpsGreedyRMS-MR & & & & & & & &  \\
LinDiagPost & & & & & & & &  \\
LinDiagPost-MR & & & & & & & &  \\
LinDiagPost-SL & & & & & & & &  \\
LinDiagPrecPost & & & & & & & &  \\
LinDiagPrecPost-MR & & & & & & & &  \\
LinDiagPrecPost-SL & & & & & & & &  \\
LinGreedy & & & & & & & &  \\
LinGreedy () & & & & & & & &  \\
LinGreedy () & & & & & & & &  \\
LinPost & & & & & & & &  \\
LinPost-MR & & & & & & & &  \\
LinPost-SL & & & & & & & &  \\
LinFullDiagPost & & & & & & & &  \\
LinFullDiagPost-MR & & & & & & & &  \\
LinFullDiagPost-SL & & & & & & & &  \\
LinFullDiagPrecPost & & & & & & & &  \\
LinFullDiagPrecPost-MR & & & & & & & &  \\
LinFullDiagPrecPost-SL & & & & & & & &  \\
LinFullPost & & & & & & & &  \\
LinFullPost-MR & & & & & & & &  \\
LinFullPost-SL & & & & & & & &  \\
ParamNoise & & & & & & & &  \\
ParamNoise-MR & & & & & & & &  \\
ParamNoise-SL & & & & & & & &  \\
Uniform & \bm{}& \bm{}& \bm{}& \bm{}& \bm{}& \bm{}& \bm{}& \bm{} \\
\bottomrule
\end{tabular}
 	\end{adjustbox}
	\vspace*{\fill}
\end{table}
\end{landscape}




\begin{landscape}
\begin{table}[ht]
  \caption{Cumulative regret incurred on the Wheel Bandit problem with increasing values of . Values reported are the mean over 50 independent trials with standard error of the mean. Normalized with respect to the performance of Uniform.}
  \label{tb:wheel-cumregret}
  \centering
  \footnotesize
  \tiny
\begin{tabular}{llllll}
 &  &  &  &  &  \\
\midrule
AlphaDivergence (1) & & & & &  \\
AlphaDivergence & & & & &  \\
AlphaDivergence-SL & & & & &  \\
BBB & & & & &  \\
BBB-MR & & & & &  \\
BBB-SL & & & & &  \\
BootstrappedNN & & & & &  \\
BootstrappedNN-MR & & & & &  \\
BootstrappedNN-SL & & & & &  \\
Dropout & & & & &  \\
Dropout-MR & & & & &  \\
Dropout-SL & & & & &  \\
GP & & & & &  \\
NeuralLinear & & & \bm{}& &  \\
NeuralLinear-MR & \bm{}& \bm{}& & \bm{}&  \\
NeuralLinear-SL & & & & &  \\
RMS & & & & &  \\
RMS-MR & & & & &  \\
RMS-SL & & & & &  \\
SGFS & & & & &  \\
SGFS-MR & & & & &  \\
SGFS-SL & & & & &  \\
ConstSGD & & & & &  \\
ConstSGD-MR & & & & &  \\
ConstSGD-SL & & & & &  \\
EpsGreedyRMS & & & & &  \\
EpsGreedyRMS-SL & & & & &  \\
EpsGreedyRMS-MR & & & & &  \\
LinDiagPost & & & & \bm{}& \bm{} \\
LinDiagPost-MR & & & & &  \\
LinDiagPost-SL & & & & &  \\
LinDiagPrecPost & & & & & \bm{} \\
LinDiagPrecPost-MR & & & & &  \\
LinDiagPrecPost-SL & & & & &  \\
LinGreedy & & & & &  \\
LinGreedy () & & & & &  \\
LinGreedy () & & & & &  \\
LinPost & & & & &  \\
LinPost-MR & & & & &  \\
LinPost-SL & & & & &  \\
LinFullDiagPost & & & & &  \\
LinFullDiagPost-MR & & & & &  \\
LinFullDiagPost-SL & & & & &  \\
LinFullDiagPrecPost & & & & &  \\
LinFullDiagPrecPost-MR & & & & \bm{}&  \\
LinFullDiagPrecPost-SL & & & & &  \\
LinFullPost & & & & &  \\
LinFullPost-MR & & & & &  \\
LinFullPost-SL & & & & &  \\
ParamNoise & & & & &  \\
ParamNoise-MR & & & & &  \\
ParamNoise-SL & & & & &  \\
Uniform & & & & &  \\
\bottomrule
\end{tabular}
 \end{table}
\end{landscape}


\begin{landscape}
\begin{table}[ht]
  \caption{Simple regret incurred on the Wheel Bandit problem with increasing values of . Simple regret was approximated by averaging the regret over the final 500 steps. Values reported are the mean over 50 independent trials with standard error of the mean. Normalized with respect to the performance of Uniform.}
  \label{tb:wheel-simpleregret}
  \centering
  \footnotesize
  \tiny
\begin{tabular}{llllll}
 &  &  &  &  &  \\
\midrule
AlphaDivergence (1) & & & & &  \\
AlphaDivergence & & & & &  \\
AlphaDivergence-SL & & & & &  \\
BBB & & & & &  \\
BBB-MR & & & & &  \\
BBB-SL & & & & &  \\
BootstrappedNN & & & & &  \\
BootstrappedNN-MR & & & & &  \\
BootstrappedNN-SL & & & & &  \\
Dropout & & & & &  \\
Dropout-MR & & & & &  \\
Dropout-SL & & & & &  \\
GP & & & & &  \\
NeuralLinear & \bm{}& \bm{}& \bm{}& &  \\
NeuralLinear-MR & \bm{}& \bm{}& \bm{}& \bm{}&  \\
NeuralLinear-SL & & & & &  \\
RMS & & & & &  \\
RMS-MR & & & & &  \\
RMS-SL & & & & &  \\
SGFS & & & & &  \\
SGFS-MR & & & & &  \\
SGFS-SL & & & & &  \\
ConstSGD & & & & &  \\
ConstSGD-MR & & & & &  \\
ConstSGD-SL & & & & &  \\
EpsGreedyRMS & & & & &  \\
EpsGreedyRMS-SL & & & & &  \\
EpsGreedyRMS-MR & & & & &  \\
LinDiagPost & & & & & \bm{} \\
LinDiagPost-MR & & & & &  \\
LinDiagPost-SL & & & & &  \\
LinDiagPrecPost & & & & & \bm{} \\
LinDiagPrecPost-MR & & & & &  \\
LinDiagPrecPost-SL & & & & &  \\
LinGreedy & & & & &  \\
LinGreedy () & & & & &  \\
LinGreedy () & & & & &  \\
LinPost & & & & &  \\
LinPost-MR & & & & & \bm{} \\
LinPost-SL & & & & &  \\
LinFullDiagPost & & & & &  \\
LinFullDiagPost-MR & & & & &  \\
LinFullDiagPost-SL & & & & &  \\
LinFullDiagPrecPost & & & & \bm{}&  \\
LinFullDiagPrecPost-MR & & & & & \bm{} \\
LinFullDiagPrecPost-SL & & & & &  \\
LinFullPost & & & & \bm{}&  \\
LinFullPost-MR & & & & &  \\
LinFullPost-SL & & & & &  \\
ParamNoise & & & & &  \\
ParamNoise-MR & & & & &  \\
ParamNoise-SL & & & & &  \\
Uniform & & & & &  \\
\bottomrule
\end{tabular}
 \end{table}
\end{landscape}


\begin{figure}[ht]
\advance\leftskip-1.6cm
\begin{subfigure}[t]{0.40\textwidth}\centering
 \includegraphics[width=\linewidth]{images/multitask_MultiTaskGP}
 \caption{Gaussian Process}
 \label{fig:gp}
\end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_SparseGP}
 \caption{Sparse Gaussian Process}
 \end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_RMS2}
 \caption{RMSProp}
 \label{fig:rmsprop}
\end{subfigure}
\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_ConstantSGDBayesianNN}
 \caption{ConstantSGD}
 \label{fig:constsgd}
\end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_SGFSdBayesianNN}
 \caption{SGFS}
 \label{fig:sgfs}
\end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_BBBN}
 \caption{BBB}
 \label{fig:sgfs}
\end{subfigure}
\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_AlphaDiv}
 \caption{Alpha Divergence}
 \end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_NeuralLinear}
 \caption{NeuralLinear}
 \label{fig:sgfs}
\end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_BootstrappedBNNs}
 \caption{Bootstrap}
 \label{fig:sgfs}
\end{subfigure}
\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_DropoutRMS}
 \caption{Dropout}
 \label{fig:sgfs}
\end{subfigure}\begin{subfigure}[t]{.40\textwidth}
 \centering
 \includegraphics[width=\linewidth]{images/multitask_pNoise}
 \caption{Parameter Noise}
 \label{fig:sgfs}
\end{subfigure}\caption{We qualitatively compare plots of the sample distribution from various methods, similarly to~\cite{Hernandez-Lobato2016}.  We plot the mean and standard deviation of 100 samples drawn from each method conditioned on a small set of observations with three outputs (two are from the same underlying function and thus strongly correlated while the third (bottom) is independent).  The true underlying functions are plotted in red.}
\label{fig:qualitative_plots}
\end{figure}




\clearpage

\section{Real-World Datasets}\label{s:datasets}

\textbf{Mushroom.} The Mushroom Dataset \citep{schlimmer1981mushroom} contains 22 attributes per mushroom, and two classes: poisonous and safe. As in \cite{blundell2015weight}, we create a bandit problem where the agent must decide whether to eat or not a given mushroom.
Eating a safe mushroom provides reward +5.
Eating a poisonous mushroom delivers reward +5 with probability 1/2 and reward -35 otherwise.
If the agent does not eat a mushroom, then the reward is 0.
We set .


\textbf{Statlog.} The Shuttle Statlog Dataset \citep{asuncion2007uci} provides the value of  indicators during a space shuttle flight, and the goal is to predict the state of the radiator subsystem of the shuttle.
There are  possible states, and if the agent selects the right state, then reward 1 is generated.
Otherwise, the agent obtains no reward ().
The most interesting aspect of the dataset is that one action is the optimal one in 80\% of the cases, and some algorithms may commit to this action instead of further exploring.
In this case, .


\textbf{Covertype.} The Covertype Dataset \citep{asuncion2007uci} classifies the cover type of northern Colorado forest areas in  classes, based on  features, including elevation, slope, aspect, and soil type.
Again, the agent obtains reward 1 if the correct class is selected, and 0 otherwise.
We run the bandit for .

\textbf{Financial.} We created the Financial Dataset by pulling the stock prices of  publicly traded companies in NYSE and Nasdaq, for the last 14 years .
For each day, the context was the price difference between the beginning and end of the session for each stock.
We synthetically created the arms, to be a linear combination of the contexts, representing  different potential portfolios.
By far, this was the smallest dataset, and many algorithms over-explored at the beginning with no time to amortize their investment (Thompson Sampling does not account for the horizon).

\textbf{Jester.} We create a recommendation system bandit problem as follows.
The Jester Dataset \citep{goldberg2001eigentaste} provides continuous ratings in  for 100 jokes from 73421 users.
We find a complete subset of  users rating all 40 jokes. Following \cite{pmlr-v70-riquelme17a}, we take  of the ratings as the context of the user, and  as the arms. The agent recommends one joke, and obtains the reward corresponding to the rating of the user for the selected joke.

\textbf{Adult.} The Adult Dataset \citep{kohavi1996scaling, asuncion2007uci} comprises personal information from the US Census Bureau database, and the standard prediction task is to determine if a person makes over \k = 14d = 94n = 45222d = 389k = 9n = 250000d = 90k = 10n = 250000$ songs at random from the training set.

The Statlog, Covertype, Adult, and Census datasets were tested in \cite{elmachtoub2017practical}.
 
\end{document}
