\documentclass[10pt,onecolumn,draftclsnofoot,journal]{IEEEtran}
\IEEEoverridecommandlockouts
\makeatletter
\def\ps@headings{\def\@oddhead{\mbox{}\scriptsize\rightmark \hfil \thepage}\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}\def\@oddfoot{}\def\@evenfoot{}}
\makeatother
\pagestyle{headings}

\usepackage{url}
\usepackage{nomencl}
\usepackage{graphics,latexsym, graphicx}
\usepackage{amsmath,amssymb,amsthm, amstext}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{epsf}
\usepackage{subfigure}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{url}
\usepackage{color}


\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{proposition}{Proposition}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}


\newcommand{\bQ}{\mbox{\boldmath}}
\newcommand{\brho}{\mbox{\boldmath}}
\newcommand{\CoR}{\mbox{Co}(\mathcal{R})}
\newcommand{\mD} {\mathcal{D}}
\newcommand{\mW} {\mathcal{W}}
\newcommand{\enter}{i:(i,n) \in \mathcal{L}}
\newcommand{\exit}{j:(n,j) \in \mathcal{L}}
\newcommand{\mS}{\mathcal{S}}
\newcommand{\bxi}{\mbox{\boldmath}}

\newcommand{\hA}{\hat{A}_{nf}^{(d)}(t)}
\newcommand{\hD}{\hat{D}_{nf}^{(d)}(t)}

\newcommand{\be}{}
\newcommand{\ben}{}
\newcommand{\dref}[1]{(\ref{#1})}
\newcommand{\expect}[1]{{\mathbb E} \Bigl[ #1\Bigr]}
\newcommand{\expectS}[1]{{\mathbb E_{\mathcal{S}(t)}} \Bigl[ #1\Bigr]}
\newcommand{\prob}[1]{{\mathbb P} \left( #1\right)}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\qi} {q_i^{(d)}(t)}
\newcommand{\qj} {q_j^{(d)}(t)}

\begin{document}
\title{Flow-Level Stability of Wireless Networks: Separation of Congestion Control and Packet Scheduling}
\author{\IEEEauthorblockN{Javad Ghaderi, Tianxiong Ji, R. Srikant\\}
\IEEEauthorblockA{Department of ECE and Coordinated Science Lab.\\ University of Illinois at Urbana-Champaign
\thanks{The research was supported in part by ARO MURIs W911NF-07-1-0287 and W911NF-08-1-0233 and AFOSR MURI FA 9550-10-1-0573.}
}}

\maketitle
\begin{abstract}
It is by now well-known that wireless networks with file arrivals and departures are stable if one uses -fair congestion control and back-pressure based scheduling and routing. In this paper, we examine whether -fair congestion control is necessary for flow-level stability. We show that stability can be ensured even with very simple congestion control mechanisms, such as a fixed window size scheme which limits the maximum number of packets that are allowed into the ingress queue of a flow. A key ingredient of our result is the use of the difference between the logarithms of queue lengths as the link weights. This result is reminiscent of results in the context of CSMA algorithms, but for entirely different reasons.
\end{abstract}

\section{Introduction}\label{sec:intro}
In order to operate wireless systems efficiently, scheduling algorithms are needed to facilitate simultaneous transmissions of different users.
Scheduling algorithms for wireless networks have been widely studied since Tassiulas and Ephremides \cite{eph}
proposed the \textit{max weight} algorithm for single-hop wireless networks and its extension to multihop networks using the notion of \textit{back-pressure} or \textit{differential backlog}. The back-pressure algorithm (and hence, the max weight algorithm)
is throughput optimal in the sense that it can stabilize
the queues of the network for the largest set of arrival rates possible without knowing the actual arrival rates. The back-pressure algorithm works under very general
conditions but it does not consider \textit{flow-level dynamics}. It considers \textit{packet-level dynamics} assuming that there is a fixed set of
users/flows and packets are generated by each flow according to some stochastic process. In real networks, flows arrive randomly to the network, have only a finite amount of data, and
depart the network after the data transfer is completed.
Moreover, there is no notion of congestion control in the back-pressure algorithm while most modern
communication networks use some congestion control mechanism for fairness purposes or to avoid excessive congestion inside the network \cite{LNS08}.

There is a rich body of literature on the packet-level stability of scheduling algorithms, e.g., \cite{eph}, \cite{Neely}, \cite{KM01}, \cite{srikant}. Stability of wireless networks under flow-level dynamics
has been studied in, e.g., \cite{LNS08}, \cite{LPYCP07}, \cite{MS10}. Here, by stability, we mean
that the number of flows in the network and the queue sizes
at each node in the network remain finite. To achieve flow-level stability, these works use a specific form of congestion control based on \textit{-fair policies}; specifically, (a) the rates at which flows/files
generate packets into their ingress queues maximize the sum-utility where each user has a utility function of the form  for some  where  is the flow rate, and (b) the scheduling of packets in the network
is performed based on the max wight/back-pressure algorithm.


When there are file/flow arrivals and departures,
if the scheduler has access to the total queue length information at nodes, then it can use max weight/back-pressure algorithm to achieve throughput optimality, but this information is not typically available to the scheduler because it is implemented as part of the MAC layer. Moreover, without congestion control, queue sizes at different nodes could be widely different. This could lead to long periods of unfairness among flows.


Therefore, we need to use congestion control to provide better QoS. With congestion control, only a few packets from each file are released to the MAC layer at each time instant, and scheduling is done based on these MAC layer packets. However, prior work requires that a specific form of congestion control (namely, ingress queue-length based rate adaptation based on -fair utility functions) has to be used. \textit{Here we show that, in fact, very general window flow-control mechanisms are sufficient to ensure flow-level stability. The result suggests that ingress queue-based congestion control is more important than -fairness to ensure network stability}, when congestion control is used in conjunction with max weight scheduling/routing.


In establishing the above result, we have used the max weight algorithm with link weights which are \textit{log-differentials} of MAC-layer queue lengths, i.e., the weight of a link ) is chosen to be in the form of  where  and  are MAC-layer queue lengths at nodes  and .
Shorter versions of the results presented here appeared earlier in \cite{GTS12, javad, tianxiong}.


The use of logarithmic functions of queue lengths naturally suggests the use of a CSMA-type algorithm to implement the scheduling algorithm in a distributed fashion \cite{shah, shah2,ghaderi}. The main difference here is that the weights are -differential of queue lengths rather than  of queue lengths themselves. We show that the stability results for CSMA without time-scale separation can be extended to the model in this paper with log-differential of queue lengths as weights, and the type of congestion control mechanisms considered here.

At this point, we comment on the differences between our paper and a related model considered in \cite{bonfeu10}. In \cite{bonfeu10}, throughput-optimal scheduling algorithms have been derived for a connection-level model of a wireless network assuming that each link has access to the number of files waiting at the link. Here, we only use MAC-layer queue information which is readily available. Further, \cite{bonfeu10} assumes a time-scale separation between CSMA and the file arrival-departure process. Such an assumption is not made in this paper.

The rest of the paper is organized as follows.
In Section \ref{sec:system}, we describe our models for the wireless network, file arrivals, and Transport and MAC layers.
We propose our scheduling algorithm in Section \ref{sec:algorithm}. Section \ref{sec:proof} is devoted to the formal statement about the throughput-optimality of the algorithm and its proof. In Section \ref{sec: distributed}, we consider the distributed implementation of our algorithm and Section \ref{conclusion} contains conclusions. The appendices at the end of the paper contain some of the proofs.

\section{System Model}\label{sec:system}
\subsection*{Model of wireless network}
Consider a multihop wireless network consisting of a set of nodes  and a set of links  between the nodes. There is a link from  to , i.e.,
, if transmission from  to  is allowed. Let  be the rates according to which
links can transmit packets. Let  denote the set of available rate vectors (or transmission schedules) .
Note that each transmission schedule  corresponds to a set of node power assignments chosen by the network. Also let  denote the
convex hall of  which corresponds to time-sharing between different rate vectors. Hence, in general, .

There are a set of users/source nodes  and each user/source transfers data to a destination over a fixed route in the network\footnote{The final results can be extended to case when each source has multiple destinations or to the cases of multi-path routing and adaptive routing. Here, to expose the main features, we have considered a simpler model.}. For a user/source , we use  to denote its destination. Let  denote the set of destinations.

We consider a time-slotted system. At each time slot ,
new files can arrive at the source nodes and scheduling decisions must be made to deliver the files to destinations in multihop fashion along fixed routes.
We use  to denote the number of files that arrive at source  at time  and assume that the process  is iid over time and independent across users with rate  and has bounded second moments.
Moreover, we assume that there are  possible file types where the files of type  are geometrically distributed with mean  packets. The file arrived at source  can belong to type  with probability , . Our motivation for selecting such a model is due to the \textit{large variance distribution} of file sizes in the Internet. It is believed that, see e.g.,~\cite{self}, that most of bytes are generated by long files while most of the flows are short flows. By controlling the probabilities , for the same average file size, we can obtain distributions with very large variance.
Let  denote the mean file size at node , and define the work load at source  by . Let  be the vector of loads.
\subsection*{Model of Transport and MAC layers}
Upon arrival of a file at a source Transport layer, a TCP-connection is
established that regulates the injection of packets into the
MAC layer. Once transmission of
a file ends, the file departs and the corresponding TCP-connection
will be closed. The MAC-layer is responsible for making the scheduling decisions to deliver the MAC-layer packets to their destinations over their corresponding routes. Each node has a fixed routing table that determines the next hop for each destination.

At each source node, we index the files according to their arriving order such that the index 1 is given to the earliest file. This
means that once transmission of a file ends, the indices of the remaining files are updated such that indices again start from 1
and are consecutive. Note that the indexing rule \textit{is not} part of the algorithm implementation and it is used here only for the
purpose of analysis. We use  to denote the TCP congestion window size for file  at source  at time . Hence,  is a time-varying sequence which changes as
a result of TCP congestion control. If the congestion window
of file  is not full, TCP will continue injecting packets from
the remainder of file  to the congestion window until file 
has no packets remaining at the Transport layer or the congestion window becomes full.
We consider \textit{ingress queue-based congestion control} meaning that when a packet of congestion window
departs the ingress queue, it is replaced with a new packet from its corresponding file at the Transport layer.
It is important to note that the MAC layer does not know
the number of remaining packets at the Transport layer, so scheduling decisions have to be made based on the MAC-layers information only.
It is reasonable to assume that , i.e., each file has at least one packet waiting to be transferred and all congestion window sizes are bounded from above by a constant .
\subsection*{Routing and queue dynamics}
At the MAC layer of each node , we consider separate queues for the packets of different destinations. Let , , denote the packets of destination  at the MAC-layer of . Also let  be the routing matrix corresponding to packets of destination  where  if the next hop of node  for destination  is node , for some  such that , and  otherwise. Routes are acyclic meaning that each packet eventually reaches its destination and leaves the network. A packet of destination  that is transmitted from  to  is removed from  and added to . Packet that reaches its destination is removed from the network. Note that packets in  could be generated at node  itself (if  is a source with destination ) or belong to other sources that use  as an intermediate relay along their routes to their destinations.

For the analysis, we also use  (\textit{with capital }) to denote the total per-destination queues, i.e.,  represents the packets of destination  at node , in its MAC or Transport layer.

For each node , the MAC (or total) per-destination queues  (or ) fall into three cases: (i)  is source and  is its destination, (ii)  is a source but , and (iii)  is not a source. In the case (i), it is important to distinguish between the MAC-layer queue and the total queue associated with , i.e., , because of the existing packets of destination  at the Transport layer of . However,  holds for all  in case (ii), and for all destinations in case (iii).

Let  denote the number of packets transmitted over link  at time . Then, the total-queue dynamics for a destination , at each node , is given by
\ben \label{eq:queue dynamics}
Q_n^{(d)}(t+1)& =& Q_n^{(d)}(t)-\sum_{j=1}^N R^{(d)}_{nj}z_{nj}^{(d)}(t) +\sum_{i=1}^N R^{(d)}_{in}z_{in}^{(d)}(t)+A^{(d)}_n(t),
\een
where  is the total number of packets for destination  that new files bring to node  at time slot . To express one formula for the queue dynamics in all three cases, (i), (ii), and (iii), we can write , where  in case (i) and  otherwise.

Let  denote the scheduling variable
that shows the rate at which the packets of destination  can be forwarded over the link . Note that 
because  cannot send more than its queue content at each time.


The capacity region of the network  is defined as the set of all load vectors 
that under which the total-queues in the network can be stabilized. Note that under our connection-level model, stability of total-queues will imply that the number of files in the network is also stable.
It is well-known \cite{Neely} that a vector  belongs to  if and only if there exits a transmission rate vector  such that


\section{Description of Scheduling Algorithm}\label{sec:algorithm}
The algorithm is essentially the back-pressure algorithm \cite{eph} but it only uses the MAC-layer information.
The key step in establishing the optimality of such an algorithm is using an appropriate weight function of the MAC-layer queues instead of using the total queues. In particular,
consider a \textit{log-type} function
\be \label{function}
g(x):=\frac{\log(1+x)}{h(x)},
\ee
where  is an arbitrary increasing function which makes
 an increasing concave function. Assume that 
and  is continuously differentiable on : For example,  or  for some .
For each link  with , define
\be \label{diff log}
w_{ij}^{(d)}(t):=g(q_i^{(d)}(t))-g(q_j^{(d)}(t)).
\ee
Note that if , then we can remove the link  from the network without reducing the capacity region since no packets are forwarded over it. So without loss of generality, we assume that , for every .
Then the scheduling algorithm is as follows:

At each time :
\begin{itemize}
\item Each node  observes the MAC-layer queue sizes of itself and its next hop, i.e., for each , it observes  and  for a  such that .

\item For each link , define a weight
\be \label{eq: link weight}
w_{ij}(t):= \max_{d\in \mD :R^{(d)}_{ij}=1} w_{ij}^{(d)}(t),
\ee
and
\be \label{eq: dtilde}
\tilde{d}^*_{ij}(t)=\argmax_{d\in \mD :R^{(d)}_{ij}=1} w_{ij}^{d}(t).
\ee

\item The network needs to find the optimal rate vector  that solves
\be \label{eq: xstartilde}
\tilde{x}^*(t)=\argmax_{r \in \mathcal{R}} \sum _{(i,j) \in \mathcal{L}}r_{ij}w_{ij}(t).
\ee
\item Finally, assign  if , and zero otherwise (break ties at random).
\end{itemize}

\section{System Stability} \label{sec:proof}
In this section, we analyze the system and prove its stability under the algorithm described in Section \ref{sec:algorithm}. The following theorem states our main result.
\begin{theorem}\label{theorem}
For any  strictly inside , the scheduling algorithm in Section \ref{sec:algorithm},
can stabilize the network independent
of transport-layer ingress queue-based congestion control mechanism (as long as the minimum window
size is one and the window sizes are bounded) and the (nonidling)
service discipline used to transmit packets from active
nodes.
\end{theorem}
\begin{remark}
Theorem \ref{theorem} holds even when  in (\ref{function}), however, for the distributed implementation of the algorithm in Section \ref{sec: distributed}, we need  to grow slightly slower than .
\end{remark}
Theorem \ref{theorem} shows that it is possible to design the ingress queue-based congestion controller regardless of the scheduling algorithm implemented in the core network. This will allow using different congestion control mechanisms at the edge of the network for different fairness or QoS considerations without need to change the scheduling algorithm implemented at internal routers of the network. As we will see, a key ingredient of such decomposition is to use difference between the logarithms of queue lengths, as in (\ref{diff log}), for the link weights in the scheduling algorithm. The rest of this section is devoted to the proof of Theorem \ref{theorem}.
\subsection*{Order of events}
Since we use a discrete-time model, we have to specify the order in which files/packets arrive and depart, which we do below:
\begin{enumerate}

\item At the beginning of each time slot, a scheduling decision is made by the scheduling algorithm. Packets depart from the MAC layers of scheduled links.

\item File arrivals occur next. Once a file arrives, a new TCP connection is set up for that file with an initial pre-determined congestion window size.

\item For each TCP connection, if the congestion window is not full, packets are injected into the MAC layer from the Transport layer until the window size is fully used or there is no more packets at the Transport layer.
\end{enumerate}
We re-index the files at the beginning of each time slot because some files might have been departed during the last time
slot.
\subsection*{State of the system}
Define the state of node  as
\ben
\mS_n(t)&=&\bigl\{(q_n^{(d)}(t),\mathcal{I}_n^{(d)}(t)): d \in \mD, (\xi_{nf}(t), \mathcal{W}_{nf}(t),\sigma_{nf}(t)): 1 \leq f \leq N_n(t)\bigr\},
\een
where  is the number of existing files at node  at the beginning of time slot ,  is its mean size (or type), and  is its corresponding congestion window size. Note that  is a function of time only because of re-indexing
since a file might change its index from slot to slot.  is an indicator function of whether file  has still packets in the Transport layer, i.e., if  is the number of remaining packets of file  at node , then

 thus , if the last packet of file  has not been injected to the MAC layer of node , and , if there is no remaining packets of file  at the Transport layer of node . Obviously, if  is not a source node, then we can remove  from the description of .  denotes the information required about  to serve the MAC-layer packets which depends on the specific service discipline implemented in MAC-layer queues. In the rest of the paper, we consider the case of FIFO (\textit{First In-First Out}) service discipline in MAC-layer queues. In this case,  is simply the ordering of packets in  according to their entrance times. As it will turn out from the proof, the system stability will hold for any none-idling service discipline.
Define the state of the system to be . Now, given the scheduling algorithm in section \ref{sec:algorithm}, and our traffic model,  evolves as a discrete-time Markov chain.

\begin{remark}
We only require that the congestion window dynamics could be described as a function
of queue lengths of the network so that the network Markov
chain is well-defined. Even in the case that the congestion
window is a function of the delayed queue lengths of the
network up to T time slots before, due to the feedback
delay of at most T from destination to source, the network
state could be modified, to include the queues up to T time
slots before, so that the same proof technique still applies.
\end{remark}
Next, we analyze the \textit{Lyapunov drift} to show that the network Markov chain is positive recurrent and, as a result, the number of files in the system and queue sizes are stable.


\subsection*{Lyapunov analysis}
Define  to be the expected total queue length at node  given the state . Then, if  is a source, and  is its destination,

Otherwise, if  or  is not a source, then . Note that given the state ,  is known.

The dynamics of  involves the dynamics of , , and , and, thus, it consists of:

\begin{itemize}
\item [(i)]departure of MAC-layer packets
\item[(ii)]new file arrivals (if  is a source)
\item[(iii)]arrival of packets from previous hops that use  as an intermediate relay to forward packets to their destinations
\item[(iv)]injection of packets into the MAC layer (if  is a source), and
\item [(v)] departure of files from the Transport layer (if  is a source).
\end{itemize}
 Hence,
\be \label{eq:expect_q_dynamics}
\bar{Q}^{(d)}_n(t+1) & = & \bar{Q}^{(d)}_n(t) - \sum_{j=1}^NR^{(d)}_{nj} z_{nj}^{(d)}(t) + \bar{A}^{(d)}_n(t) \nonumber \\
& +& \sum_{i=1}^NR^{(d)}_{in} z_{in}^{(d)}(t) + \hat{A}^{(d)}_n(t) -\hat{D}^{(d)}_n(t),
\ee
where  is the expected number of packet arrivals due to new files,
 is the total number of packets injected into the MAC layer to fill up the congestion window after scheduling and new file arrivals, and  is the Transport-layer  ``expected packet departure'' because of the MAC-layer injections.
Here,  indicates that the last packet of file  \textit{leaves the Transport layer during time slot } otherwise, . To notice the difference between the indicators  and , consider a specific file and assume that its last packet enters the Transport layer at time slot , departs the Transport layer during time slot  and departs the MAC layer during time slot , then its corresponding indicator  is  at time  and is  for  and , while its indicator  is  for all time , and  for .

Note that  is the mean packet arrival rate at node  for destination .
Let , and
define . It should be clear that when  is a source but , or when  is not a source, . Let  denote the maximum link capacity over all the links in the network. Then Lemma~\ref{lemma:B_l} characterizes the first and second moments of .
\begin{lemma} \label{lemma:B_l}
For the process ,
\begin{itemize}
\item [(i)].
\item [(ii)] Let , then 
\end{itemize}
\end{lemma}
Therefore, we can write
\ben \label{eq: queue dynamics}
\bar{Q}^{(d)}_n(t+1)&=& \bar{Q}^{(d)}_n(t) - \sum_{j=1}^N R^{(d)}_{nj} z_{nj}^{(d)}(t) + \tilde{A}_n^{(d)}(t) +\sum_{i=1}^NR^{(d)}_{in} z_{in}^{(d)}(t),
\een
where . Note that  has mean  and finite second moment.

Let  for the function  defined in (\ref{function}). Then  is a strictly convex function. Consider a Lyapunov function

Let ,
then, using convexity of , we get
\ben
\Delta V(t)\leq \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t+1))\left(\bar{Q}_n^{(d)}(t+1)-\bar{Q}_n^{(d)}(t)\right).
\een
Using the concavity of  and the fact that , we have
\ben
|g(\bar{Q}_n^{(d)}(t+1))-g(\bar{Q}_n^{(d)}(t))| \leq |\bar{Q}_n^{(d)}(t+1)-\bar{Q}_n^{(d)}(t)|.
\een
Furthermore, observe that, based on (\ref{eq: queue dynamics}),
\ben \label{eq:Qdiff}
|\bar{Q}_n^{(d)}(t+1)-\bar{Q}_n^{(d)}| \leq  \tilde{A}_n^{(d)}(t)+N r_{max}.
\een
Hence,
\ben
\Delta V(t)\leq  \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))(\bar{Q}_n^{(d)}(t+1)-\bar{Q}_n^{(d)}(t))+\sum_{n=1}^N\sum_{d \in \mD}(\tilde{A}_n^{(d)}(t)+N r_{max})^2.
\een
Define,  to be the wasted service for packets of destination , i.e., when  is included in the schedule but it does not have enough packets of destination  to transmit. Then, we have
\ben
 \Delta V(t) & \leq & \sum_{n=1}^N\sum_{d \in \mD}\Big\{g(\bar{Q}_n^{(d)}(t))\Big[\sum_{i=1}^N R^{(d)}_{in} x_{in}^{(d)}(t)+\tilde{A}_n^{(d)}(t)-\sum_{j=1}^NR^{(d)}_{nj} x_{nj}^{(d)}(t)\Big]\Big\}\\
 &+& \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))u_n^{(d)}(t)+ \sum_{n=1}^N\sum_{d \in \mD}(\tilde{A}_n^{(d)}(t)+N r_{max})^2.
\een

Taking the expectation of both sides, given the state at time  is known, yields
\ben
\expectS{\Delta V(t)} &\leq& \sum_{n=1}^N\sum_{d \in \mD}\Bigl\{g(\bar{Q}_n^{(d)}(t))\mathbb{E}_{\mS(t)}[\rho_n^{(d)} +\sum_{i=1}^NR^{(d)}_{in} x_{in}^{(d)}(t)-\sum_{j=1}^NR^{(d)}_{nj} x_{nj}^{(d)}(t)] \Bigr\}\\
& + & \expectS{\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))u_n^{(d)}(t)}+C_1,
\een
where

because .
\begin{lemma}
\label{lemma:bound_third_term_geo}
There exists a positive constant  such that, for all ,

\end{lemma}
Using Lemma \ref{lemma:bound_third_term_geo} and changing the order of summations, we have
\ben \label{eq: drift1}
\expectS{\Delta V(t)} &\leq&  \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\rho_n^{(d)} - \expectS{\sum_{(i,j) \in \mathcal{L}}\sum_{d \in \mD} x_{ij}^{(d)}(t)(g(\bar{Q}_i^{(d)}(t))-g(\bar{Q}_j^{(d)}(t)))}+C_1+C_2.
\een
Recall that the link weight that is actually used in the algorithm is based on the MAC-layer queues as in (\ref{diff log})-(\ref{eq: link weight}).
For the analysis, we also define a new link weight based on the state as
\be \label{state weight}
W_{ij}(t)=\max_{d \in \mD: R^{(d)}_{ij}=1} W_{ij}^{(d)}(t),
 \ee
where, for a link  with ,
 \be \label{state weight d}
 W_{ij}^{(d)}(t):=g(\bar{Q}_i^{d}(t))- g(\bar{Q}_j^{d}(t)).
 \ee
Then, the two types of link weights only differ by a constant as stated by the following lemma.
\begin{lemma} \label{lemma}
Let  and , , be the link weights defined by (\ref{state weight})-(\ref{state weight d}) and (\ref{diff log})-(\ref{eq: link weight}) respectively. Then at all times

\end{lemma}
\begin{proof}
Recall that, at each node , for all destinations , we have . If  is the destination of , then  consists of:
(i) packets of  received from upstream flows that use  as an intermediate relay, and
(ii) MAC-layer packets received from the files generated at  itself. Since , the number of files with destination  that are generated at node  or have packets at node  as an intermediate relay, is at most . Therefore, it is clear that

Hence, for all  and , using a log-type function, as the function  in (\ref{function}), yields
\be \label{ineq 1}
g(q_n^{d}) \leq g(\bar{Q}_n^{d}) &\leq & g\left(q_n^{d} (1+1/{\eta_{min}})\right) \nonumber \\
 & \leq & \frac{\log\left((1+q_n^{d}) (1+1/{\eta_{min}})\right)}{h(q_n^{d} (1+1/{\eta_{min}}))}  \nonumber \\
 & \leq & g(q_n^{d})+\frac{\log(1+1/\eta_{min})}{h(0)}.
\ee

It then follows that, , and  with ,
\be \label{ineq 2}
|W_{ij}^{(d)}-w_{ij}^{(d)}|\leq \log(1+1/\eta_{min})/h(0).
\ee
Let  and  as in (\ref{eq: dtilde}).
Then, using (\ref{ineq 2}), we have that

and,  This concludes the proof.
\end{proof}
Let  be the max weight schedule based on weights , i.e.,
\be \label{eq: xstar}
x^*(t)=\argmax_{x \in \mathcal{R}} \sum _{(i,j) \in \mathcal{L}}x_{ij}W_{ij}(t).
\ee
Note the distinction between  and  as we used  in (\ref{eq: xstartilde}) to denote the Max Weight schedule based on MAC-layer queues.
Then, the weights of the schedules  and  differ only by a constant for all queue values as we show next.
First note that, from definition of ,
\be
\sum_{(i,j) \in \mathcal{L}}x^*_{ij}W_{ij}(t)-\sum _{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}W_{ij}(t) \geq 0.
\ee
Next, we have
\be
\sum_{(i,j) \in \mathcal{L}}x^*_{ij}W_{ij}(t)-\sum _{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}W_{ij}(t)&=& \sum _{(i,j) \in \mathcal{L}}x^*_{ij}W_{ij}(t)-\sum_{(i,j) \in \mathcal{L}}x^*_{ij}w_{ij}(t) \label{first1}\\
&&+  \sum_{(i,j) \in \mathcal{L}}x^*_{ij}w_{ij}(t)-\sum _{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}w_{ij}(t) \label{second2}\\
&&+ \sum _{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}w_{ij}(t) -\sum _{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}W_{ij}(t) \label{third3}\\
& \leq&  2 N^2r_{max} \log(1+1/\eta_{min})/h(0), \nonumber
\ee
because, by Lemma \ref{lemma}, (\ref{first1}) and (\ref{third3}) are less than  each, and (\ref{second2}) is negative by definition of .
Hence, \textit{under MAC scheduling }, the Lyapunov drift is bounded as follows.
\ben
\expectS{\Delta V(t)} &\leq&  \sum_{n=1}^N\sum_{d \in \mD}\left\{g(\bar{Q}_n^{(d)}(t))\rho_n^{(d)}\right\}- \expectS{\sum_{(i,j) \in \mathcal{L}}x_{ij}^*(t)W_{ij}} + C,
\een
where .

Accordingly, using (\ref{state weight})-(\ref{state weight d}), and changing the order of summations in the right hand side of the above inequality yields
\ben
\expectS{\Delta V(t)}  &\leq& \sum_{n=1}^N\sum_{d \in \mD} \left\{g(\bar{Q}_n^{(d)}(t))\mathbb{E}_{\mS(t)}\bigl[\rho_n^{(d)}+\sum_{i=1}^NR^{(d)}_{in} {x^*}_{in}^{(d)}(t)-\sum_{j=1}^NR^{(d)}_{nj} {x^*}_{nj}^{(d)}(t)\bigr]\right\} + C,
\een
where  for  (break ties at random) and is zero otherwise.
The rest of the proof is standard. Since load  is strictly inside the capacity region, there must exist a  and a  such that
\be
\rho_n^{(d)}+\epsilon \leq \sum_{j=1}^NR^{(d)}_{nj} {\mu}_{nj}^{(d)}-\sum_{i=1}^N R^{(d)}_{in}{\mu}_{in}^{(d)}\ ; \forall n \in \mathcal{N} ,\forall d \in \mD.
\ee
Hence, for any ,
\ben
\expectS{\Delta V(t)} &\leq& \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\left[\sum_{i=1}^NR^{(d)}_{in} {x^*}_{in}^{(d)}(t)-\sum_{j=1}^N R^{(d)}_{nj} {x^*}_{nj}^{(d)}(t)\right]\\
&& -  \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\left[\sum_{i=1}^NR^{(d)}_{in} {\mu}_{in}^{(d)}(t)-\sum_{j=1}^N R^{(d)}_{in}{\mu}_{nj}^{(d)}(t)\right]\\
&& - \epsilon\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t)) + C .
\een
But , , hence,
\ben
\expectS{\Delta V(t)} &\leq&  -\epsilon \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t)) + C
\leq - \delta,
\een
whenever  or, as a sufficient condition, whenever . Therefore, it follows that the system is stable by an extension of the Foster-Lyapunov criteria \cite{asm} (Theorem 3.1 in \cite{eph}). In particular, queue sizes and the number of files in the system are stable.
\begin{remark}
Although we have assumed that file sizes follow a mixture of geometric distributions, our results also hold for the case of bounded file sizes with general distribution. The proof argument for the latter case is obtained by minor modifications of the proof presented in this paper (see \cite{javad}) and, hence, has been omitted for brevity.
\end{remark}

\section{Distributed Implementation}\label{sec: distributed}
The optimal scheduling algorithm in Section \ref{sec:algorithm} requires us to find a maximum weight-type schedule at each time, i.e., needs to solve (\ref{eq: xstartilde}) at each time . This is a formidable task, hence, in this section, we design a distributed version of the algorithm based on \textit{Glauber Dynamics}.

For simplicity, we consider the following criterion for successful packet reception: Packet transmission over link  is successful if none of the neighbors of node  are transmitting. Furthermore, we assume that every node can transmit to at most one node at each time, receive from at most one node at each time, and cannot transmit and receive simultaneously (over the same frequency band). This especially models the packet reception in the case that the set of neighbors of node , i.e., , is the set of nodes that are within the transmission range of node  and the interference caused by node  at all other nodes, except its neighbors, is negligible. Moreover, the packet transmission over  is usually followed by an ACK transmission from receiver to sender, over . Hence, for a \textit{synchronized data/ACK system}, we can define a \textit{Conflict Set} (CS) for link  as
\be
\mathrm{CS}_{(i,j)} &= & \Big\{(a,b) \in \mathcal{L}:a \in C(j) \mbox{, or } b \in C(i),  \mbox{or }a \in \{i,j\} \mbox{, or } b \in \{i,j\} \Big\}.
\ee
This ensures that when the links in  are inactive, the data/ACK transmission over /  is successful.

Furthermore, for simplicity, assume that for each link , , i.e, its service rate is one packet per time slot.
We can capture the interference constraints by using a \textit{conflict graph} , where each vertex in  is a communication link in the wireless network. There is an edge  between vertices  and  if simultaneous transmissions over communication links  and  are not successful. Therefore, at each time slot, the active links should form an independent set of , i.e., no two scheduled vertices can share an edge in . Let  be the set of all such feasible schedules and  denote the number of communication links in the wireless network.





We say that a node is active if it is a sender or a receiver for some active link. Inactive nodes can \textit{sense the wireless medium} and know if there is an active node in their neighborhood. This is possible because we use a synchronized data/ACK system and detecting active nodes can be performed by sensing the data transmission of active senders and sensing the ACK transmission of active receivers. Hence, using such carrier sensing, nodes  and  know if the channel is idle, i.e.,  or if the channel is busy, i.e., .
\begin{remark}
For the case of single hop networks, the link weight (\ref{eq: link weight}) is reduced to  where  is the source and  is the destination of flow over . Such a weight function is exactly the one that under which throughput optimality of CSMA has been established in \cite{ghaderi}.
Next, we will propose a version of CSMA that is suitable for the general case of multihop flows and will prove its throughput optimality. The proof uses techniques originally developed in \cite{shah, shah2} for continuous-time CSMA algorithms, and adapted in \cite{ghaderi} for the discrete-time model considered here.
\end{remark}
\subsection{Basic CSMA Algorithm for Multihop Networks }
For our algorithm, based on the MAC layer information, we define a modified weight for each link  as
\be \label{eq: link weight modified}
\tilde{w}_{ij}(t) = \max_{d:R_{ij}^{(d)}=1} \tilde{w}^{(d)}_{ij}(t),
\ee
where
\be
\tilde{w}^{(d)}_{ij}(t)=\tilde{g}\left(q_i^{(d)}(t)\right)-\tilde{g}\left(q_j^{(d)}(t)\right),
\ee
and,
\be
\tilde{g}\left(q_i^{(d)}(t)\right)=\max \left\{g\left(q_i^{(d)}(t)\right),g^*(t)\right\}
\ee
where the function  is the same as (\ref{function}) defined for the centralized algorithm, and
\be \label{eq: gstar}
g^*(t):=\frac{\epsilon}{4N^3} g(q_{max}(t)),
\ee
where  is the maximum MAC-layer queue length in the network at time  and assumed to be known, and  is an arbitrary small but fixed positive number.
Note that if we remove  from the above definition, then  is equal to  in (\ref{diff log})-(\ref{eq: link weight}).


Consider the conflict graph  of the network as defined earlier. At each time slot , a link  is chosen uniformly at random, with probability , then
\begin{itemize}
\item [(i)] If  for all links , then
 with probability , and  with probability  .\\
Otherwise, =0.
\item[(ii)]  for all .
\item [(iii)]  if  (break ties at random), and zero otherwise.
\end{itemize}
We choose  to be
\be
p_{ij}(t)=\frac{\exp(\widetilde{w}_{ij}(t))}{1+\exp(\widetilde{w}_{ij}(t))}.
\ee
It turns out that the choice of function  is crucial in establishing the throughput optimality of the algorithm for general networks. The following Theorem states the main result regarding the throughput optimality of the basic CSMA algorithm.
\begin{theorem}\label{th1}
Consider any . Under the function  specified in (\ref{function}), the basic CSMA algorithm can stabilize the network for any , independent of Transport-layer ingress queue-based congestion control (as long as the minimum window
size is one and the window sizes are bounded) and the (nonidling)
service discipline used to serve packets of active
queues.
\end{theorem}
\subsection{Distributed Implementation}
The basic algorithm is based on Glauber-Dynamics with one site update at each time. For distributed implementation, we need a randomized mechanism to select a link uniformly at each time slot. We use the Q-CSMA idea \cite{srikant2} to perform the link selection: Each time slot is divided into a control slot and a data slot. In the control slot, nodes exchange short control messages, similar to RTS/CTS packets in IEEE 802.11 protocol, to come up with a collision-free \textit{decision schedule} . In the data slot, each link  that is included in the decision schedule performs the basic CSMA algorithm.
The control message sent from node  to  in time slot , contains the carrier sense information of node  at time , and the vector of MAC layer queue sizes of node  at time , i.e, , to determine the weight of link .

Next, we describe the mechanisms for generation of decision schedules and data transmission schedules in more detail.

\subsection*{Generation of decision schedule}
As in \cite{srikant2}, we divide the control slot into two mini slots. In the first mini slot, each node  chooses one of its neighbors  uniformly at random, then it transmits a RTD (\textit{Request-To-Decide}) packet, containing the ID(index) of node , with probability . If RTD is received successfully by  (i.e.,  and none of the neighbors of  transmit RTD messages), in the second mini-slot,  sends a CTD (\textit{Clear-To-Decide}) packet back to , containing the ID of node . The CTD message is received successfully at  if there is no collision with other CTD messages. Given a successful RTD/CTD exchange over the link , the link  will be included in the decision schedule  and no link from  will be included in . Hence,  is a valid schedule.
So each node  needs to maintain the following memories:
\begin{itemize}
\item /: node  is included in  as a sender/receiver for some link.
\item : the index of the node which is paired with  as a its sender (when ) or its receiver (when ).
\item : Carrier sense by node , i.e., node  has an active receiver/sender in it neighborhood during data slot .
\end{itemize}
\begin{algorithm}\label{alg dec}
\caption{Decision schedule at control slot  }
\begin{algorithmic}[1]
\STATE For every node , set .
\STATE In the first mini-slot:

-  with probability ; otherwise .

-If , choose a node  uniformly at random and send a RTD to  and set ; otherwise listen for RTD messages.
\STATE In the second mini-slot:

-If received a RTD from  in the first mini-slot, send a CTD to  and set  and ; nodes with  listen for CTD messages.

-If  and CTD received successfully from , include  in , otherwise .

\end{algorithmic}
\end{algorithm}
CTD message sent back from a node  to  also contains the carrier sense information of node , i.e.,  and , and the vector of MAC layer queue sizes of node  at time , i.e, 
\subsection*{Generation of data transmission schedule}
After the control slot, every node  knows if it is included in the decision schedule , as a sender, and also knows its corresponding receiver . The data transmission schedule at time , i.e., , is generated based on  and . Only those links that are in  can change their states and the state of other links remain unchanged. A link  that is included in , can start a packet transmission with probability  only if its conflict set has been silent during the previous time slot, as in the basic CSMA algorithm.
\begin{algorithm}\label{alg}
\caption{Data transmission schedule at slot }
\begin{algorithmic}[1]
\STATE
-   with  and receiver ,

If no links in  were active in the previous data slot, i.e.,  or ,
\begin{itemize}
\item  with probability ,
\item   with probability .
\end{itemize}
Else
 .


- : .

\STATE In the data slot, use  as the transmission schedule.
\end{algorithmic}
\end{algorithm}
\subsection*{Data transmission and carrier sensing}
In the data slot, we use  for the data transmission. In this slot, every node  will perform of the following.

: Node  will send a data packet to node .

: Node  will send an ACK to node  after receiving a data packet from .

All other nodes are inactive and perform carrier sensing. Since the data/ACK transmissions are synchronized in our system, every inactive node  will set  is it does not sense any transmission during the data transmission period and set  otherwise. Similarly, node  will set  if it senses
no signal during the ACK transmission period and set  otherwise.
\begin{remark}
In IEEE 802.11 DCF, the RTS/CTS exchange is used
to reduce the Hidden Terminal Problem. However, even with
RTS/CTS, the hidden terminal problem can still occur, see \cite{srikant2}. Since, in our synchronized system, RTD and CTD messages are sent in two different mini-slots, this completely eliminates the hidden terminal problem.
\end{remark}
\begin{remark}
To determine the weight at each link,  is also needed. Instead, each node can maintain an estimate of  similar to the procedure suggested in \cite{shah}. In fact, it is easy to incorporate such a procedure in our algorithm because, in the control slot, each node can include its estimate of  in the control messages and update its estimate based on the received control messages. Then we can use Lemma  of \cite{shah} to complete the stability proof. So we do not pursue this issue here. In practical networks  is small and we can use the weight function  directly, and thus, there may not be any need to know .
\end{remark}
\begin{corollary}\label{dis}
Under the weight function  specified in Theorem \ref{th1}, the distributed algorithm can stabilize the network for any .
\end{corollary}
\subsection{Proof of Throughput Optimality}\label{sec:csma_proofs}
Consider the basic CSMA algorithm over a graph . Assume that the weights are constants, i.e., the basic algorithm uses a weight vector  at all times. Then, the basic algorithm is essentially an irreducible, aperiodic, and reversible Markov chain (called Glauber Dynamics) to generate the independent sets of . So, the state space  consists of all independent sets of . The stationary distribution of the chain is given by

where  is the normalizing constant.

We start with the following lemma that relates the modified link weight and the original link weight.
\begin{lemma}\label{relate1}
For all links , the link weights (\ref{eq: link weight modified}) and (\ref{eq: link weight}) differ at most by , i.e.,
\be
|\tilde{w}_{ij}(t) - w_{ij}(t)| \leq g^*(t).
\ee
\end{lemma}
Proof is included in the appendix.
The basic algorithm uses a time-varying version of the Glauber dynamics, where the weights change with time. This yields a time-inhomogeneous Markov chain but we will see that, for the choice of function  in (\ref{function}), it behaves similarly to the Glauber dynamics.
\subsection*{Mixing time of Glauber dynamics}
For simplicity, we index the elements of  by , where .
Then, the eigenvalues of the corresponding transition matrix are ordered in such a way that

The convergence to steady state distribution is geometric with a rate equal to the \textit{second largest eigenvalue modulus} (SLEM) of the transition matrix \cite{pier}. In fact, for any initial probability distribution  on , and for all ,

where  is the SLEM.
Note that, by definition,


The following Lemma gives an upper bound on the SLEM  of Glauber dynamics.
\begin{lemma}\label{mixing2}
For the Glauber Dynamics with the weight vector  on a graph ,

where .
\end{lemma}
See \cite{ghaderi} for the proof. We define the \textit{mixing time} as , so

Simple calculation, based on (\ref{mixing1}), reveals that the amount of time needed to get close to the stationary distribution is \textit{approximately} proportional to .
\subsection*{A key proposition}
At any time slot , given the weight vector , the MaxWeight-type algorithm, Section \ref{sec:algorithm}, should solve 
instead, the distributed algorithm tries to simulate a distribution

i.e., the stationary distribution of Glauber dynamics with the weight vector  at time .

Let  denote the transition probability matrix of Glauber dynamics with the weight vector .
Also let  be the true probability distribution of the inhomogeneous-time chain, over the set of schedules , at time  .
Therefore, we have . Let  denote the stationary distribution of the time-homogenous Markov chain with  as in (\ref{stationary}).
By choosing proper  and , we aim to ensure that  and  are close enough, i.e.,

for some  arbitrary small, where

Note that 
Next, we characterize the amount of change in the stationary distribution as a result of queue evolutions.
\begin{lemma} \label{alpha ratio}
For any schedule ,

where,

and  is the maximum congestion window size.
\end{lemma}
Now, equipped with Lemmas \ref{mixing2} and \ref{alpha ratio}, we make use of the results in \cite{shah, shah2} and \cite{ghaderi} in the final proof. Specifically, we will use the following key Proposition from \cite{ghaderi} which we have included a proof for it in the appendix for completeness.
\begin{proposition}\label{drift}
Given any ,  holds when , if there exists a  such that

where
\begin{itemize}
\item[(i)] 
\item [(ii)]  is the smallest  such that
\be\label{t*}
\frac{1}{\sqrt{\min_s \pi_{t_1}(s)}} \exp(-\sum_{k=t_1}^{t_1+t^*}\frac{1}{T^2_k}) \leq \delta/4,
\ee
where .
\end{itemize}
\end{proposition}
In other words, Proposition \ref{drift} states that when queue lengths are large, the observed distribution of the schedules is close to the desired stationary distribution. The key idea in the proof is that the weights change at the rate  while the system responds to these changes at the rate . Condition (\ref{alphaT}) is to ensure that the weight dynamics are slow enough compared to response time of the chain such that it remains close to its equilibrium (stationary distribution).


We will also use the following lemma that relates the maximum queue length and the maximum weight in the network. Hence, when one grows, the other one increases as well.
\begin{lemma} \label{relate}
Let . Then

\end{lemma}
\subsection*{Some useful results for the basic CSMA algorithm}
Roughly speaking, since the mixing time  is exponential in ,  must be in the form of ;
otherwise it will be impossible to satisfy  in Proposition \ref{drift} for any arbitrarily small  as .
The only function with such a property is the  function. In fact,  must grow slightly slower than  to satisfy (\ref{alphaT}), and to ensure the existence of a finite  in Lemma \ref{drift}. For example, by choosing functions that grow much slower than , like , we can make  behave approximately like  for large ranges of  (correspondingly, for the range of practical queue lengthes). More accurately, we state the result as the following lemma whose proof can be found in the appendix.
\begin{lemma}\label{lemma: adiabatic}
The Basic CSMA algorithm, with function  as in (\ref{function}), satisfies the requirements of Proposition \ref{drift}.
\end{lemma}

Next, the following Lemma states that, with high probability, the basic CSMA algorithm chooses schedules that their weights are close to the Max Wight schedule.
\begin{lemma}\label{property}
The basic CSMA algorithm has the following property: Given any  and , there exists a  such that whenever , with probability larger than , it chooses a schedule  that satisfies

\end{lemma}
\begin{proof}
Let  and define

Therefore, we need to show that , for  large enough. For our choice of  and , it follows from Proposition \ref{drift} that, whenever , ,
and consequently, 
Thus,

Therefore, to ensure that , it suffices to have 
But, by Lemma \ref{relate1}, ,
so,

and
\ben
Z_t &=& \sum_{s \in \mathcal{R}}e^{\sum_{(i,j) \in s}\widetilde{w}_{ij}(t)} > \sum_{s \in \mathcal{R}}e^{\sum_{(i,j) \in s}(w_{ij}(t)-g^*(t))}
> e^{w^*(t)-|\mathcal{L}|g^*(t)}.
\een
Therefore,
\ben
\sum_{s \in \mathcal{\chi}_t} \pi_t(s) &\leq & 2^{|\mathcal{L}|}e^{2|\mathcal{L}|g^*(t)-\varepsilon w^*(t)},
\een
when . Note that , and , so

whenever , where
\ben
B(\delta,\epsilon)=\max\left\{q_{th}+t^*, g^{-1}\Big(\frac{2{N}}{\epsilon}(N^2 \log{2}+\log{\frac{2}{\delta}})\Big)\right\}.
\een
\end{proof}
\subsection*{Throughput optimality}
Now we are ready to prove the throughput optimality for the basic CSMA algorithm. Let  and  be the optimal schedules based on total queues and MAC queues respectively, given by (\ref{eq: xstar}) and (\ref{eq: xstartilde}), and  be the schedule generated by the basic CSMA algorithm. The proof is parallel to the argument for the throughput optimality of the centralized algorithm. Especially, the inequality (\ref{eq: drift1}) still holds, i.e.,
\be \label{drift1}
\expectS{\Delta V(t)} & \leq &  C_1+C_2+\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\rho_n^{(d)} -  \expectS{\sum_{(i,j) \in \mathcal{L}}\sum_{d \in \mD} {x}_{ij}^{(d)}(t)W_{ij}^{(d)}} \nonumber\\
& = &  C_1+C_2+\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\rho_n^{(d)} -  \expectS{\sum_{(i,j) \in \mathcal{L}}{\tilde{x}}_{ij}(t)W_{ij}(t)}.
\ee
Next, observe that
\be
\sum_{(i,j) \in \mathcal{L}}x^*_{ij}W_{ij}(t)-\expectS{\sum _{(i,j) \in \mathcal{L}}\tilde{x}_{ij}W_{ij}(t)}&=& \expectS{\sum _{(i,j) \in \mathcal{L}}x^*_{ij}W_{ij}(t)-\sum_{(i,j) \in \mathcal{L}}{x}^*_{ij}w_{ij}(t)} \label{first}\\
&+&  \expectS{\sum_{(i,j) \in \mathcal{L}}x^*_{ij}w_{ij}(t)-\sum _{(i,j) \in \mathcal{L}}\tilde{x}_{ij}w_{ij}(t)} \label{second}\\
&+& \expectS{\sum _{(i,j) \in \mathcal{L}}\tilde{x}_{ij}w_{ij}(t) -\sum _{(i,j) \in \mathcal{L}}\tilde{x}_{ij}W_{ij}(t)} \label{third}
\ee
Now note that each of the terms (\ref{first}) and (\ref{third}) is less than  by Lemma (\ref{lemma}). The term (\ref{second}) is bounded from above, by using Lemma \ref{property}, as follows.
\ben \label{forth}
\mbox{(\ref{second})} & \leq &   \sum_{(i,j) \in \mathcal{L}}x^*_{ij}w_{ij}(t) -(1-\delta)(1-\epsilon)\sum_{(i,j) \in \mathcal{L}}\tilde{x}^*_{ij}w_{ij}(t) \nonumber \\
& \leq &\sum_{(i,j) \in \mathcal{L}}x^*_{ij}w_{ij}(t) -(1-\delta)(1-\epsilon)\sum_{(i,j) \in \mathcal{L}}{x}^*_{ij}w_{ij}(t) \nonumber \\
& \leq &(1-(1-\delta)(1-\epsilon)) \sum_{(i,j) \in \mathcal{L}} {x}^*_{ij}W_{ij}(t) + |\mathcal{L}| \log(1+1/\eta_{min})/h(0),
\een
whenever , for any .
Thus, using the above bounds for terms (\ref{first}), (\ref{second}) and (\ref{third}), we get
\be \label{fifth}
\expectS{\sum _{(i,j) \in \mathcal{L}}\tilde{x}_{ij}W_{ij}(t)} &\geq & (1-\delta)(1-\epsilon)\sum_{(i,j) \in \mathcal{L}} {x}^*_{ij}W_{ij}(t) -  3|\mathcal{L}|  \log(1+1/\eta_{min})/h(0).
\ee
Using (\ref{fifth}) in (\ref{drift1}) yields
\be \label{drift2}
\expectS{\Delta V(t)} & \leq &  \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\rho_n^{(d)} - (1-\delta)(1-\epsilon)\sum_{(i,j) \in \mathcal{L}} {x}^*_{ij}W_{ij}(t)+C_3,
\ee
where .
Using (\ref{state weight}) and rewriting the right-hand-side of (\ref{drift2}) by changing the order of summations yields
\be \label{drift3}
\expectS{\Delta V(t)}  \leq   \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\Bigl[\rho_n^{(d)}  +(1-\delta)(1-\epsilon) \Bigl(\sum_{i=1}^NR^{(d)}_{in}{{x}^*}^{(d)}_{in}(t)-\sum_{j=1}^NR^{(d)}_{nj}{{x}^*}^{(d)}_{nj}(t)\Bigr)\Bigr]+ C_3.\nonumber
\ee
whenever .
The rest of the proof is standard. For any load   strictly inside , there must exist a  such that for all , and all ,
\be \label{capacity 1}
\rho^{(d)}_n < (1-3 \epsilon) \Big(\sum_{j=1}^NR^{(d)}_{nj} {\mu}_{nj}^{(d)}-\sum_{i=1}^N R^{(d)}_{in}{\mu}_{in}^{(d)}\Big).
\ee
Let

for some positive . Hence,
\ben
\expectS{\Delta V(t)} &\leq&  (1-\delta)(1-\epsilon)\sum_{n=1}^N\sum_{d \in \mD} \Bigl\{g(\bar{Q}_n^{(d)}(t)) \Bigl[\sum_{i=1}^NR^{(d)}_{in}{{x}^*}^{(d)}_{in}(t)-\sum_{j=1}^NR^{(d)}_{nj}{{x}^*}^{(d)}_{nj}(t)\Bigr] \Bigr\}\\
& + & (1-3 \epsilon) \sum_{n=1}^N\sum_{d \in \mD}\Bigl\{g(\bar{Q}_n^{(d)}(t)) \Bigl[\sum_{j=1}^N R^{(d)}_{nj}{\mu}_{nj}^{(d)}-\sum_{i=1}^N R^{(d)}_{in}{\mu}_{in}^{(d)}\Bigr] \Bigr\}+ C_3 .
\een
For any fixed small , we can choose  to ensure . Moreover, from definition of  and convexity of , it follows that
\be
\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\Bigl[\sum_{j=1}^N R^{(d)}_{nj}{x^*}_{nj}^{(d)}(t)-\sum_{i=1}^NR^{(d)}_{in} {x^*}_{in}^{(d)}(t)\Bigr] \geq \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t)) \Bigl[\sum_{j=1}^NR^{(d)}_{nj} {\mu}_{nj}^{(d)}-\sum_{i=1}^NR^{(d)}_{in} {\mu}_{in}^{(d)}\Bigr],
\ee
for any . Hence,
\ben
\expectS{\Delta V(t)} &\leq& -\epsilon \sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))\Bigl[\sum_{j=1}^N {R^{(d)}_{nj}\mu}_{nj}^{(d)}-\sum_{i=1}^NR^{(d)}_{in} {\mu}_{in}^{(d)}\Bigr] + C_3 \\
& \leq& - \rho^* \frac{\epsilon}{1-3 \epsilon}\sum_{n=1}^N\sum_{d \in \mD}g(\bar{Q}_n^{(d)}(t))+C_3 \leq - \epsilon',
\een
whenever  and  or, as a sufficient condition, whenever

In particular, to get negative drift, , for some positive constant , it suffices that
 
  because , and  is an increasing function. This concludes the proof of the main theorem.

\subsection*{Extension of the proof to the distributed implementation}
The distributed algorithm is based on multiple site-update (or parallel operating) Glauber dynamics as defined next. Consider the graph  as before and a constant weight vector . At each time , a decision schedule  is selected at random with positive probability . Then, for all , we perform the regular Glauber dynamics.
Then, it can be shown that the Markov chain is reversible, it has the same stationary distribution as the regular Glauber dynamics in (\ref{stationary}), and its mixing time is almost the same as (\ref{mixing3}). In fact, the mixing time of the chain is characterized by the following Lemma.
\begin{lemma}\label{multiple}
For the multiple site-update Glauber Dynamics with the weight vector  on a graph ,

where .
\end{lemma}
See \cite{ghaderi} for the proof. The rest of the analysis is the same as the argument for the basic algorithm.
The distributed algorithm uses a time-varying version of the multiple-site update Glauber dynamics, where the weights change with time. Although the upperbound of Lemma \ref{multiple} is loose, it is sufficient to prove the optimality of the algorithm.

Finally, let  and  denote the lengths of the data slot and the control slot. Thus, the distributed algorithm can achieve a fraction  of the capacity region. In particular, in our algorithm, it suffices to allocate two short mini-slots at the beginning of the slot for the purpose of control. By choosing the data slot to be much larger than the control slot, the algorithm can approach the full capacity.

\section{Conclusions}\label{conclusion}
Design of efficient scheduling and congestion control algorithms can be decoupled by using MAC-layer queues for the scheduling of packets and using window-based congestion control mechanisms for controlling the rate at which packets injected into the network. This separation result is very appealing to the network designer. It is also important from the practical perspective because, typically, only the MAC-layer information is available to the scheduler since it is implemented as part of the MAC layer. Moreover, window-based congestion control is also more consistent with practical implementations like TCP.
\begin{thebibliography}{99}

\bibitem{eph}L. Tassiulas and A. Ephremides, Stability properties of constrained
queueing systems and scheduling algorithms for maximal throughput in
multihop radio networks, \emph{IEEE Transactions on Automatic Control}, vol. 37, no. 12, pp. 1936-1948, 1992.

\bibitem{LNS08}X. Lin, N. Shroff, and R. Srikant, On the connection-level stability of congestion-controlled communication networks, \emph{IEEE Transactions on Information Theory}, vol. 54, no. 5, pp. 2317-2338, 2008.



\bibitem {LPYCP07} J. Liu, A. Proutiere, Y. Yi, M. Chiang, and V. Poor, flow-level stability of
data networks with non-convex and time-varying rate regions, \emph{Proc. ACM SIGMETRICS}, 2007.

\bibitem {MS10} C. Moallemi and D. Shah, On the flow-level dynamics of a packet-switched network, \emph{Proc. ACM SIGMETRICS}, pp. 83-94, June 2010.





\bibitem{bonfeu10}T. Bonald and M. Feuillet, On the stability of flow-aware CSMA, \emph{Performance Evaluation}, vol. 67, no. 11, pp. 1219-1229, 2010.

\bibitem{LSR06} X. Lin, N. Shroff and R. Srikant, A tutorial on cross-layer optimization in wireless networks, \emph{IEEE Journal on Selected Areas in Communications}, August 2006, pp. 1452-1463.

\bibitem{Neely} M. J. Neely, E. Modiano, and C. E. Rohrs, Dynamic power allocation and routing for time varying wireless networks, \emph{IEEE Journal on Selected Areas in Communications}, vol. 23, no. 1, pp. 89-103, January 2005.

\bibitem{KM01} I. Keslassy and N. McKeown, Analysis of scheduling algorithms that provide 100 throughput
in input-queued switches, \emph{Proc. Allerton Conference on Communication, Control, and Computing}, 2001.





\bibitem{srikant}A. Eryilmaz, R. Srikant, and J. R. Perkins, Stable scheduling algorithms
for fading wireless channels. \emph{IEEE/ACM Transactions on Networking}, vol. 13, no. 2, pp. 411-424, April 2005.

\bibitem{ghaderi}J. Ghaderi and R. Srikant, On the design of efficient CSMA algorithms for wireless networks, \emph{IEEE Conference on Decision and Control}, 2010.
\bibitem{srikant2} J. Ni, B. Tan, R. Srikant, Q-CSMA: Queue-length based CSMA/CA algorithms for achieving maximum throughput and low delay in wireless networks, \emph{Proc. IEEE INFOCOM Mini-Conference}, 2010.

\bibitem{shah}S. Rajagopalan, D. Shah and J. Shin, Network adiabatic theorem: an efficient randomized protocol for contention resolution, \emph{ACM SIGMETRICS/Performance}, pp. 133-144, 2009.
\bibitem{shah2}D. Shah and J. Shin, Randomized scheduling algorithm for queueing networks, \emph{Annals of Applied Probability}, vol. 22, no. 1, pp. 128-171, 2011.


\bibitem{pier}P. Bremaud, Markov chains, Gibbs fields, Monte Carlo simulation, and queues, \emph{Springer-Verlag}, New York 1999, 2nd edition, 2001.

\bibitem{self}M. Crovella and A. Bestavros, Self-Similarity in World Wide Web traffic: evidence and possible causes, \emph{IEEE/ACM Transactions on Networking}, Vol. 5, No. 6, pp. 835-846, 1997.

\bibitem{asm} S. Asmussen, Applied probability and queues, Springer, 2003.






\bibitem{libing}L. Jiang and J. Walrand, A distributed CSMA algorithm for throughput and utility maximization in wireless networks, \emph{46th Annual Allerton Conference on Communication, Control and Computing}, 2008.

\bibitem{libing2}L. Jiang and J. Walrand, Convergence and stability of a distributed CSMA algorithm for maximal network throughput, \emph{IEEE Conference on Decision and Control}, 2009.

\bibitem{chiang}A. Proutiere, Y. Yi, and M. Chiang, Throughput of random access without message passing, \emph{Proc. CISS}, Princeton, 2008.

\bibitem{GTS12} J. Ghaderi, T. Ji, and R. Srikant, Connection-level scheduling in wireless networks using only MAC-layer information, \emph{Proc. IEEE INFOCOM 2012 Mini-Conference}.
\bibitem{data} D. P. Bertsekas and R. G. Gallager, Data Networks, \emph{Prentice Hall}, 2nd edition, 1992
\bibitem{javad}J. Ghaderi and R. Srikant, Flow-level stability of multihop wireless networks using only MAC-layer information, \emph{Proc. WiOpt 2012}.
\bibitem{tianxiong}T. Ji and R. Srikant, Scheduling in wireless networks with connection arrivals and departures, \emph{Information Theory
and Applications Workshop}, 2011.
\end{thebibliography}
\appendices
\section{Proof of Lemma \ref{lemma:B_l}}
Let  denote the number of packets of file  injected into the MAC layer of node , and  denote the expected ``packet departure'' of file  from the transport layer. Let  for file .
\begin{proof}[Part (i)]
It suffices to show that for each individual file ,

We only need to focus on files  with , i.e., existing files in the Transport layer, or new files, i.e, , because the  if file  has no packets in the Transport layer.

Let  be the remaining window size of file  at node  after MAC-layer departure but before the MAC-layer injection. We want to show that, for any ,

then (\ref{eq:inner_transfer2}) implies .

Because the number of remaining packets at the Transport layer at each time is geometrically distributed with mean size , the transport layer will continue to inject packets into the MAC layer with probability  as long as all previous packets are successfully injected and the window size is not full.

Clearly, if  no packet can be injected into the MAC layer. Therefore,  and , and (\ref{eq:inner_transfer2}) is satisfied. Next, we consider the case when .
Let  denote the probability that  and  given that . Because transport-layer packets are injected into the MAC layer as long as the window is not full, we have  Obviously, 

The probability that  where  directly follows the geometric distribution of the remaining packets of file , i.e.,

for .
Note that from the definition of  we have


Now we calculate the left-hand side of (\ref{eq:inner_transfer2}).

\end{proof}
\begin{proof}[Part (ii)]
 From the definition of  we have 
Using the fact that new arriving files are mutually independent, and are also independent of current network state, we have
\be \label{eq:bound_B_l}
\expectS{ B_n(t)^2 } &=& \expectS{ \Bigl(\sum_{f=1}^{N_n(t)} B_{nf}(t) \Bigr)^2 }  + \expectS{\sum_{f=N_n(t)+1}^{N_n(t)+ a_n(t)}   B_{nf}(t)^2},
\ee
where we have also used the fact that 
Note that  So, based on the assumption that the congestion window size is bounded by  and the mean file size is bounded by  we have

Therefore, the second term in (\ref{eq:bound_B_l}) is bounded by

Next, we bound the first term in (\ref{eq:bound_B_l}). Let  denote the set of files at node  that are served at time . Because  if the existing file is not served, we have


Note that  because the number of existing files that are served cannot exceed the sum of outgoing link capacities. Thus,

Substituting (\ref{eq:bound_B_l_new}) and (\ref{eq:bound_B_l_existing}) into (\ref{eq:bound_B_l}) completes the proof.

\end{proof}
\section{Proof of Lemma \ref{lemma:bound_third_term_geo}}
Note that  if , and  if . In the latter case, since the congestion window size for every file is at least one, we know that there are at most  files in transport layer of node  intended for destination . Hence, based on the definition of , . So,

Therefore, the result follows by choosing 
\section{Proof of Lemma \ref{relate1}}
It is sufficient to prove that for all ,  as we do now.
\ben
\tilde{w}^{(d)}_{ij} &\leq& \max \left\{g\left(q_i^{(d)}(t)\right),g^*(t)\right\}-g\left(q_j^{(d)}(t)\right)\\
&\leq & g\left(q_i^{(d)}(t)\right)+ g^*(t) -g\left(q_j^{(d)}(t)\right)\\
& = & w_{ij}^{(d)}(t)+g^*(t).
\een
Similarly,
\ben
\tilde{w}^{(d)}_{ij} &\geq& g\left(q_i^{(d)}(t)\right)-\max \left\{g\left(q_j^{(d)}(t)\right),g^*(t)\right\}\\
&\geq & g\left(q_i^{(d)}(t)\right)- g^*(t) -g\left(q_j^{(d)}(t)\right)\\
& = & w_{ij}^{(d)}(t)-g^*(t).
\een
\section{Proof of Lemma \ref{alpha ratio}}
Note that

where

Let  denote , and define .
Hence, 
where the last inequality follows from the fact that  is a concave and increasing function. If we assume that link service rate is at most one and the congestion window sizes are at most , then for all  and for all ,

Hence,

and thus,
\ben
\frac{\pi_{t+1}(s)}{\pi_t(s)} \leq e^{2(1+\mW_{cong})|\mathcal{L}| g^\prime({q}^*(t+1)-1-\mW_{cong})}.
\een
Similarly,
\ben
\frac{\pi_{t}(s)}{\pi_{t+1}(s)} \leq e^{2(1+\mW_{cong})|\mathcal{L}| g^\prime({q}^*(t+1)-1-\mW_{cong})}.
\een
This concludes the proof.
\section{Proof of Lemma \ref{relate}}
The second inequality immediately follows from definition of . To prove the first inequality, consider a destination , with routing matrix , and let , then, based on (\ref{diff log}), we have
\ben
\mathbf{w}^{(d)}=(\mathbf{I}-\mathbf{R}^{(d)})g(\mathbf{q}^{(d)}),
\een
where  Note that every row of  has exactly one ''1`` entry except the row corresponding to  which is all zero, so . Therefore,  exists and  is nonsingular (Similar to the argument in page 222 of \cite{data}). So . Let  denote the -norm. Then we have
\ben
\|(\mathbf{I}-\mathbf{R}^{(d)})^{-1}\|_{\infty} &=&  \|\sum_{k=0}^N (\mathbf{R}^{(d)})^k\|_{\infty}
 \leq  \sum_{k=0}^N \|(\mathbf{R}^{(d)})^k\|_{\infty}
\leq  \sum_{k=0}^N \|\mathbf{R}^{(d)}\|_{\infty}^k
 \leq  N
\een
where we have used the basic properties of the matrix norm, and the fact that . Therefore,

for every . Taking the maximum over all , and noting that  is a strictly increasing function, yields the result.
\section{Proof of Lemma \ref{lemma: adiabatic}}
 is strictly increasing so  for all . So

The inverse of  cannot be expressed explicitly, however, it satisfies

Therefore,

for .

Next, note that
\be
T_{t+1} &\leq& 16^{|\mathcal{L}|}e^{4 |\mathcal{L}|(w_{max}+g^*)} \nonumber \\
& \leq & 16^{|\mathcal{L}|}e^{4 |\mathcal{L}|(g(q_{max})+\frac{\epsilon}{4|\mathcal{L}| N }g(q_{max}))} \nonumber \\
& \leq & 16^{|\mathcal{L}|}e^{8 |\mathcal{L}| g(q_{max})} \label{help22}.
\ee
Consider the product of (\ref{help1}) and (\ref{help22}) and let .
Using (\ref{g-1}) and (\ref{eq: gstar}), the condition (\ref{alphaT}) is satisfied if

Consider fixed, but arbitrary, ,  and . As , , and consequently  and . Therefore, the exponent  is negative for  large enough, and thus, there is a threshold  such that for all , the condition (\ref{cond1}) is satisfied.


The last step of the proof is to determine . Let  be the first time that  hits , then

and

Therefore, by Proposition \ref{drift}, it suffices to find the smallest  that satisfies
\ben
16^{-2N^2} t (1+q_{th}+t)^{-\frac{16N^2 }{g(q_{th})}} &\geq& \log(4/ \delta) + N^2  \log(2(1+q_{th}))
\een
for a threshold  large enough. Recall that  is an increasing function, therefore, by choosing  large enough,  can be made arbitrary small.
Then a finite  always exists since





\section{Proof of Proposition \ref{drift}}
The drift in  is given by

for  where  is given by (\ref{eq: alpha}). Thus, 
for .
The distance between the true distribution and the stationary distribution at time  can be bounded as follows.
First, by triangle inequality,

On the other hand,

Therefore, for ,

Suppose , then  holds for , if

for all . Define . Then

where  is the SLEM of .
Therefore,

Suppose . Defining , we have

Thus, , if

or equivalently if 
But

so, it is sufficient to have
\be \label{eq: alphaT2}
\alpha_t T_{t+1} \leq \delta/16.
\ee
Therefore, if there exists a time  such that , then  for all .
To find , note that  for all . So, for , we have

Thus, 
 where
 
Finally, assume that (\ref{eq: alphaT2}) holds only when  for a constant . Let  be the first time that  hits .
Then, after that, it takes  time slots for the chain to get close to  if  remains above  for .
Alternatively, we can say that  if  since at each time slot at most one departure can happen and this guarantees that  for, at least, the past  time slots. This immediately implies the final result in the proposition.
\end{document}
