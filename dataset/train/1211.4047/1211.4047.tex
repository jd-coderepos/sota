\documentclass[prodmode,acmtoms]{acmsmall}
\acmVolume{V}
\acmNumber{N}
\acmArticle{A}
\acmYear{YYYY}
\acmMonth{0}
\markboth{}{}
\usepackage{url}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{array}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{a4wide}
\usepackage{stmaryrd}
\usepackage[numbers,square,sort&compress]{natbib}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{anslistings}
\usepackage{rotating}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{sidecap}

\usepackage{commath}
\DeclareMathOperator{\Div}{div}
\DeclareMathOperator{\Curl}{curl}
\DeclareMathOperator{\Grad}{grad}

\newcommand{\uflc}[1]{\texttt{#1}}

\newcommand{\jump}[1]{\llbracket #1 \rrbracket}
\newcommand{\avg}[1]{\langle #1 \rangle}
\newcommand{\operator}[1]{\mathrm{#1}\, }
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\nedelec}{N\'ed\'elec}
\newcommand{\Gateaux}{G\^ateaux}
\newcommand{\foralls}{\forall\,}
\newcommand{\dx}{\dif{}x}
\newcommand{\ds}{\dif{}s}
\newcommand{\dS}{\dif{}S}
\newcommand{\GammaD}{\Gamma_{\mathrm{D}}}
\newcommand{\GammaN}{\Gamma_{\mathrm{N}}}
\newcommand{\type}{\operatorname{type}}

\newcommand{\compten}[2]{\left\{{#1}\right\}_{#2}}

\newcommand{\suchthat}{\quad | \quad}

\let\ifbolditem\iffalse
\def\bolditemtrue{\global\let\ifbolditem\iftrue}
\def\bolditemfalse{\global\let\ifbolditem\iffalse}

\newenvironment{benumerate}
  {\def\bolditem{\bolditemtrue\item}\enumerate
   \renewcommand\makelabel[1]{\hss\llap{\ifbolditem\bfseries\fi##1\bolditemfalse}}}
  {\endenumerate}

\title{Unified Form Language: A domain-specific language for weak
formulations of partial differential equations}
\author{MARTIN S. ALN{\AE}S \affil{Simula Research Laboratory}
        ANDERS LOGG \affil{Simula Research Laboratory and University of Oslo}
        KRISTIAN B. {\O}LGAARD \affil{Aalborg University}
        MARIE E. ROGNES \affil{Simula Research Laboratory}
        GARTH N. WELLS \affil{University of Cambridge}}
\begin{abstract}
We present the Unified Form Language (UFL), which is a domain-specific
language for representing weak formulations of partial differential
equations with a view to numerical approximation.  Features of UFL
include support for variational forms and functionals, automatic
differentiation of forms and expressions, arbitrary function space
hierarchies for multi-field problems, general differential operators
and flexible tensor algebra. With these features, UFL has been used to
effortlessly express finite element methods for complex systems of
partial differential equations in near-mathematical notation,
resulting in compact, intuitive and readable programs. We present in
this work the language and its construction. An implementation of UFL
is freely available as an open-source software library. The library
generates abstract syntax tree representations of variational
problems, which are used by other software libraries to generate
concrete low-level implementations. Some application examples are
presented and libraries that support UFL are highlighted.
\end{abstract}

\category{D.2.1}{Software Engineering}{Requirements/Specifications}[Languages]
\category{D.2.13}{Software Engineering}{Reusable Software}[Domain engineering]
\category{D.3.2}{Programming Languages}{Language Classifications}[Very high-level languages]
\category{I.1.1}{Symbolic and Algebraic Manipulation}{Expressions and Their Representation}[Representations (general and polynomial)]
\category{G.1.8}{Partial Differential Equations}{Finite element methods}
\category{G.1.4}{Quadrature and Numerical Differentiation}{Automatic differentiation}
\terms{Algorithms, Design, Languages}
\keywords{
AD,
algorithmic differentiation,
automatic functional differentiation,
discretization,
domain specific language,
DSEL,
DSL,
einstein notation,
embedded language,
FEM,
finite element method,
functional,
implicit summation,
index notation,
mixed element,
partial differential equation,
PDE,
symbolic differentiation,
tensor algebra,
weak form,
weak formulation,
}
\acmformat{}
\begin{document}
\begin{bottomstuff}
This research is partially supported by Research Council of Norway
through grant no.~209951 and a Center of Excellence grant awarded to
the Center for Biomedical Computing at Simula Research Laboratory.
Author's addresses:
M. S. Aln{\ae}s ({\tt martinal@simula.no}) and
A. Logg ({\tt logg@simula.no}) and
M. E. Rognes ({\tt meg@simula.no}),
Center for Biomedical Computing, Simula Research Laboratory,
P.O.~Box 134, 1325 Lysaker, Norway;
K. B. {\O}lgaard ({\tt kbo@civil.aau.dk}),
Department of Civil Engineering, Aalborg University,
Niels Bohrs Vej 8, 6700 Esbjerg, Denmark;
G. N. Wells ({\tt gnw20@cam.ac.uk})
Department of Engineering, University of Cambridge,
Trumpington Street, Cambridge CB2 1PZ, United Kingdom.
\end{bottomstuff}
\maketitle

\section{Introduction}
\label{sec:introduction}

We present a language for expressing variational forms of partial
differential equations (PDEs) in near-mathematical notation.  The
language, known as the Unified Form Language (UFL), inherits the
typical mathematical operations that are performed on variational
forms, thereby permitting compact and expressive computer input of
mathematical problems. The complexity of the input syntax is
comparable to the complexity of the classical mathematical
presentation of the problem. The language is expressive in the sense
that it provides basic, abstract building blocks which can be used to
construct representations of complicated problems; it offers a mostly
dimension-independent interface for defining differential equations;
and it can be used to define problems that involve an arbitrary number
of coupled fields. The language is developed with finite element
methods in mind, but most of the design is not restricted to a
specific numerical method.

UFL is a \emph{language} for expressing variational statements of
partial differential equations and does not provide a problem solving
environment. Instead, it generates abstract representations of
problems that can be used by \emph{form compilers} to create concrete
code implementations in general programming languages. There exist a
number of form compilers that generate low-level code from UFL. These
include the FEniCS Form Compiler
(FFC)~\citep{kirby:2006,RognesKirbyEtAl2009a,oelgaard:2010,logg:2012},
the SyFi Form Compiler (SFC)~\citep{alnaes:2010,alnaes:2012} and the
Manycore Form Compiler~\citep{markall:2010,MarkallEtAl2012}. From a
common UFL input, these compilers differ in the strategies used to
create and optimize a low-level implementation, and in the target
low-level language. The code generated by these form compilers can be
used in a problem solving environment, linked at compile time or
dynamically at runtime.

An example of a problem solving environment that uses code generated from
UFL input is DOLFIN~\citep{logg:2010,logg:2012b}, which is developed
as part of the FEniCS Project~\citep{fenics:book}. Users of DOLFIN
may describe a finite element discretization of a partial differential
equation in UFL, and call a form compiler such as FFC or SFC to generate
low-level code. In the case of FFC and SFC, this low-level code conforms
to the UFC specification~\citep{AlnaesLoggEtAl2009a,AlnaesLoggEtAl2012a},
which is a C++ interface for functionality related to evaluation of local
stiffness matrices, finite element basis functions and local-to-global
mappings of degrees of freedom. The UFC code may then be used by DOLFIN
to assemble and solve the linear or nonlinear system corresponding to
the finite element discretization described in UFL.

UFL is implemented as a domain-specific embedded language (DSEL) in
Python. The distinction between a DSEL and a high-level software
component lies in the level of expressiveness; UFL expressions can be
composed and combined in arbitrary ways within the language design
limits.
Paraphrasing P. Hudak~\citep{hudak1996building}, a DSEL is the ultimate
abstraction, allowing the user to reason about the program within the
domain semantics, rather than within the semantics of the
programming language.
As an embedded language, UFL relies on the parser and grammar of the
host language, Python. While it would be possible to select a
subset of the Python grammar and write a UFL parser for that
subset, we make no such restrictions in practice.
UFL is implemented as a Python module which defines
types (classes) and operators that together form an
expressive language for representing weak formulations of partial
differential equations. In addition, UFL provides a collection of
algorithms for operating on UFL expressions. By implementing UFL as a
DSEL in Python, we sacrifice some control over the syntax, but believe
that this is overwhelmingly outweighed by the advantages. First,
parsing is inherited and users may rely on all features of the Python
programming language when writing UFL code, for example to define new
operators. Second, it also permits the seamless integration of UFL
into Python-based problem solving environments. The Python interface
of the library DOLFIN is an example of this. In particular, the use of
just-in-time (JIT) compilation facilitates the incorporation of UFL in
a scripted environment without compromising the performance of a
compiled language. This is discussed in detail in~\citet{logg:2010}.

There have been a number of efforts to create domain-specific
languages for scientific computing applications. Examples include
SPL~\citep{xiong:2001} for signal processing and the Tensor
Contraction Engine~\citep{baumgartner:2005} for quantum chemistry
applications.  In the context of partial differential equations, there
have been a number of efforts to combine symbolic computing, code
generation and numerical methods. In some cases the code generation is
explicit, while in other cases, such as when employing templates,
implicit. Early examples include FINGER~\citep{wang:1986}, the
Symbolic Mechanics System~\citep{korelc:1997}, and
Archimedes~\citep{ShewchukGhattas1993}. Analysa~\citep{bagheri:2004}
is an abstract finite element framework of limited scope built upon
Scheme.  Feel++~\citep{prudhomme:www,prudhomme:2006} uses C++
templates to create an embedded language for solving partial
differential equations using finite element methods. Another example
of a domain-specific language embedded in C++ is
Sundance~\citep{long:2010}. Sundance relies heavily on automatic
differentiation to provide a problem solving environment targeted at
PDE-constrained optimization. UFL also provides automated
differentiation of functionals and variational forms, but the approach
differs in some respects from Sundance. This is discussed later in
this work.  UFL is distinguished from the aforementioned efforts by
its combination of a high level of expressiveness,
mathematically-driven abstractions, extensibility, breadth of
supported mathematical operations and embedding in a modern,
widely-used and freely available language (Python). Moreover, it is
deliberately decoupled from a code generator and problem solving
environment. This provides modularity and scope to pursue different
code generation and/or solution strategies from a common description
of a variational problem. This is highlighted by the existence of the
different form compilers that support UFL, with each targeting a
specific code generation strategy or architecture. Unlike some of the
efforts listed above, UFL is freely available under a GNU public
license (LGPLv3+).

The syntax used in UFL has its roots in FFC which was first released
in 2005. At the time, FFC filled the roles of both form language and
form compiler for the FEniCS Project. Much of the UFL syntax is
inherited from early versions of FFC, but has since been
re-implemented, generalized and extended to provide a more consistent
mathematical environment, to cover a richer class of nonlinear forms
and to provide a range of abstract algorithms, including
differentiation. FFC no longer provides an input syntax, rather it
generates code from a UFL representation. The UFL form language was
first released in 2009~\citep{Alnaes2009} and has since then been
tested on a wide range of applications. A rich and varied selection of
applications that use UFL are presented in~\citet{fenics:book}.

The remainder of this work is structured as
follows. Section~\ref{sec:concepts} summarizes the main mathematical
concepts on which UFL is based. A detailed presentation of the UFL
language is then given in Section~\ref{sec:language}. This is followed
in Section~\ref{sec:examples} by a number of examples that demonstrate
the use of UFL for a variety of partial differential equations. The
subsequent sections focus on the technical aspects of the UFL design. In
Sections~\ref{sec:representation} and~\ref{sec:algorithms}, we describe
the internal representation of UFL expressions and provide an overview
of the algorithms provided by UFL, respectively. Particular emphasis
is placed on differentiation.  Section~\ref{sec:validation} provides a
brief discussion of validation and code correctness. Some conclusions
are then drawn in Section~\ref{sec:conclusions}.

The implementation of UFL is available at
\url{https://launchpad.net/ufl}. The examples presented
in this work, including the UFL code used, are archived at
\url{http://www.dspace.cam.ac.uk/handle/1810/243981}.

\section{Mathematical concepts and scope}
\label{sec:concepts}

To clarify the notation, conventions, scope and assumptions of UFL and
this paper, we begin by defining some key concepts in mathematical
terms. We assume familiarity with variational formulations of PDEs and
finite element methods.
These variational formulations are assumed to be expressed as sums of
integrals over geometric domains. Each integrand is an expression
composed from a set of valid functions and geometric quantities, with
various operators applied. Each such function is an element of a
function space, typically, but not necessarily, a finite element
space, while the set of permitted operators include differential
operators and operators from tensor algebra. The central mathematical
abstractions, including multi-linear variational forms, tensor algebra
conventions and the finite element construction, are formally
introduced in the subsections below.

When enumerating  objects, we count from  to , inclusive, in
the mathematical notation, while we count from  to ,
inclusive, in computer code.

\subsection{Variational forms}
\label{sec:variationalforms}

UFL is centered around expressing finite element variational forms,
and in particular real-valued \emph{multi-linear forms}. A real-valued
multi-linear form  is a map from the product of a given sequence
 of function spaces:

that is linear in each argument. The spaces  are labeled
\emph{argument spaces}. For the case ,  is referred
to as the \emph{test} space and  as the \emph{trial} space.  The
\emph{arity} of a form  is the number of argument spaces. Forms
with arity , , or  are named \emph{functionals},
\emph{linear forms} and \emph{bilinear forms}, respectively. Such
forms can be assembled on a finite element mesh to produce a scalar, a
vector and a matrix, respectively.  Note that the \emph{argument
  functions}  are enumerated backwards
such that their numbering matches the corresponding axis in the
assembled tensor.

If the form  is parametrized over one or more \emph{coefficient
  functions}, we express the form as the mapping from a product of a
sequence  of \emph{coefficient spaces} and the
argument spaces:

Note that  is assumed to be (possibly) non-linear in the
coefficient functions  and linear in the argument
functions~. For a detailed exposition on finite element
variational forms and assembly, we refer to~\citep{KirbyLogg2012} and
references therein. To make matters concrete, we here list examples of
some forms with different arity~ and number of coefficients~:

where  is the geometric domain of interest.

\subsubsection{Geometric domains and integrals}
\label{subsubsec:geometric_domains_and_integrals}

UFL supports multi-linear forms defined via integration over geometric
domains in the following manner. Let  be a domain
with boundary  and let  be
a suitable tessellation such that . We denote the induced tessellation of  by
, and let  denote the set of
internal facets of . Each of the three sets, the
\emph{cells} in , the \emph{exterior facets} in
 and the \emph{interior facets} in , is
assumed to be partitioned into one or more disjoint subsets:

where ,  and  denote the number of subsets of
cells, exterior facets and interior facets, respectively. Given these
definitions, it is assumed that the multi-linear form can be expressed
in the following canonical form:

where  and  denote appropriate measures. The integrand
 is integrated over the th subset  of
cells, the integrand  is integrated over the th subset
 of exterior facets and the integrand 
is integrated over the th subset  of interior
facets.

UFL in its current form does not model geometrical domains, but allows
integrals to be defined over subdomains associated with an integer
index~. It is then the task of the user, or the problem-solving
environment, to associate the integral defined over the subdomain 
with a concrete representation of the geometrical subdomain.

\subsubsection{Differentiation of forms}

Differentiation of variational forms is useful in a number of
contexts, such as the formulation of minimization problems and
computing Jacobians of nonlinear forms. In UFL, the derivative of a
form is based on the \Gateaux{} derivative as detailed below.

Let  and  be coefficient and argument functions, respectively,
with compatible domain and range. Considering a functional , the
\Gateaux{} derivative of  with respect to  in the direction  is
defined by

Given a linear form  (which could be the result of the above
derivation) and another compatible argument function , we can
continue by computing the bilinear form ; that
is, the derivative of  with respect to  in the direction ,
defined by

In general, this process can be applied to forms of general arity  to produce forms of arity~. Note that if the form to
be differentiated involves an integral, we assume that the integration
domain does not depend on the differentiation variable. To express
the differentiation of a general form, consider the following compact
representation of the canonical form~\eqref{eq:canonical}:

where  and  are the
geometric domains and corresponding integration measures, and
 are the integrand expressions. We can then write
the derivative of the general form~\eqref{eq:generalform2} with
respect to, for instance,  in the direction  as


\subsection{Tensors and tensor algebra}

A core feature of UFL is its tensor algebra support. We summarize here
some elementary tensor algebra definitions, notation and operations that
will be used throughout this paper.

First, an \emph{index} is either a fixed positive\footnote{Indices are
  positive in the mathematical base 1 notation used here and
  non-negative in the base 0 notation used in the computer code.}
integer value, in which case it is labeled a \emph{fixed-index}, or a
symbolic index with no value assigned, in which case it is called a
\emph{free-index}. A \emph{multi-index} is an ordered tuple of
indices, each of which can be free or fixed. Moreover, a
\emph{dimension} is a strictly positive integer value. A \emph{shape}  is an
ordered tuple of zero or more dimensions: ; the
corresponding rank  equals the length of the shape
tuple.

Any tensor can be represented either as a mathematical object with a
(tensor) shape or in terms of its scalar
components with reference to a given basis. More precisely, the
following notation and bases are used. Scalars are considered rank
zero tensors. We denote by  the standard
orthonormal Euclidean basis for  of dimension . A basis
 for , where 
is a shape, is naturally defined via outer products of the vector
basis:

where the range of the multi-index  is such that  for . In general, whenever a multi-index  is used to
index a tensor of shape , it is assumed that  for . Then, the scalar
component of index  of a vector  defined relative to the basis
 is denoted . More generally, for a tensor  of
shape ,  denotes its scalar component of multi-index
 with respect to the basis  of
. Moreover, whenever we write , we imply
, where  is the dimension of
. Correspondingly, for sums over multi-indices,  implies  with
the deduced ranges.

Whenever one or more free-indices appear twice in a monomial term,
summation over the free-indices is implied. Tensors ,  and 
of rank 1, 2 and , respectively, can be expressed using the summation
convention as:


We will also consider general tensor-valued functions , , where the shape  in this
context is termed the \emph{value shape}. Indexing of tensor-valued
functions follows the same notation and assumptions as for
tensors. Furthermore, derivatives with respect to spatial coordinates
may be compactly expressed in index notation with the comma convention
in subscripts. For example, for coordinates  and a function , a vector function
 or a tensor function , we write for indices  and , and multi-indices
 and , with the length of  denoted by~:

\subsection{Finite element functions and spaces}
\label{sec:finite_element}

A finite element space  is a linear space of piecewise
polynomial fields defined relative to a tessellation  of a domain . Such spaces are typically defined
locally; that is, each field in the space is defined by its
restriction to each cell of the tessellation. More precisely, for a
finite element space  of tensor-valued functions of value
shape , we assume that

where the space  indicates the global regularity and
where  is a specified (sub-)space of
polynomials of degree  defined over~. In other
words, the global finite element space  is defined by patching
together local finite element spaces  over the
tessellation . Note that the polynomial spaces may vary
over the tessellation; however, this dependency is usually omitted for
the sake of notational brevity.

The above definition may be extended to mixed finite element spaces.
For given local finite element spaces  of
respective value shapes , we define the mixed local
finite element space  by:

The extension to global mixed finite element spaces follows as
in~\eqref{eq:finiteelement}.  Note that all element factors in a mixed
element are assumed to be defined over the same cell~. The
generalization to nested hierarchies of mixed finite elements follows
immediately, and hence such hierarchies are also admitted

Any  has the representation , with a suitable shape tuple~, and the value components of
 must be mapped to components of . Let 
be the corresponding rank of the value shape , and denote by
 the corresponding \emph{value size};
i.e, the number of scalar components. In the general case, we choose a
rank~ shape , and map the flattened
components of each  to components of the vector-valued ; that
is,

This mapping permits arbitrary combinations of value shapes . In
the case where  coincide for all , we refer to
the resulting specialized mixed element as a vector element of
dimension , and choose . As a
generalization of vector elements, we allow tensor
elements\footnote{Tensor-valued elements, not to be confused with
  tensor product elements.} of shape  with rank~, which gives
the value shape . Tensor elements built from scalar subelements may have
symmetries, represented by a symmetry mapping from component to
component.  The number of subelements then equals
, where  is the number of
value components that are mapped to another.

For some finite element discretizations, it is helpful to represent
the local approximation space as the \emph{enrichment} of one element
with another. More precisely, for local finite element spaces
 defined over a
common cell  and of common value shape , we define the space

Again, the extension to global enriched finite element spaces follows
as in~\eqref{eq:finiteelement}. The MINI
element~\citep{ArnoldBrezziFortin1984} for the Stokes equations is an
example of an enriched element.

\section{Overview of the language}
\label{sec:language}

UFL can be partitioned into sublanguages for finite elements, expressions,
and forms. We will address each separately below. Overall, UFL has a
declarative nature similar to functional programming languages. Side
effects, sequences of statements, subroutines and explicit loops
found in imperative programming languages are all absent from UFL. The
only branching instructions are inline conditional expressions, which
will be further detailed in Section~\ref{sec:conditionaloperators}.

\subsection{Finite elements}
\label{sec:function_spaces}

The UFL finite element sublanguage provides syntax for finite
elements and operations over finite elements, including mixed and
enriched finite elements, as established in
Section~\ref{sec:finite_element}.

\subsubsection{Finite element abstractions and classes}

UFL provides four main finite element abstractions: primitive finite
elements, mixed finite elements, enriched finite elements and
restricted finite elements. Each of these abstractions provides
information on the value shape, the cell and the embedding polynomial
degree of the element (see~\eqref{eq:finiteelement}), and each is
further detailed below. We remark that UFL is primarily concerned with
properties of local finite element spaces: the global continuity
requirement and the specific implementation of the element degrees of
freedom or basis functions are not covered by UFL. For an overview of
finite element abstractions with initialization arguments,
see~Table~\ref{tab:finiteelementclasses}. Example usage will be
presented in Section~\ref{sec:examples}.

\begin{table}
  \tbl{
  Overview of element classes defined in UFL.
}{
  \begin{tabular}{l}
    \toprule
    Finite element class specification\\
    \midrule
    \uflc{FiniteElement(family, cell, degree)} \\
    \uflc{VectorElement(family, cell, degree, (dim))} \\
    \uflc{TensorElement(family, cell, degree, (shape), (symmetry))} \\
    \midrule
    \uflc{MixedElement(elements)} \\
    \uflc{EnrichedElement(elements)} \\
    \uflc{RestrictedElement(element, domain)} \\
    \bottomrule
  \end{tabular}
}
\tabnote{In addition to
    the arguments given here, a specific quadrature scheme can be
    given for the primitive finite elements (those defined by family
    name). Arguments in parentheses are optional.}
  \label{tab:finiteelementclasses}
\end{table}

In the literature, it is common to refer to finite elements by their
family parametrized by cell type and order: for instance, the
``\nedelec{} face elements of the second kind over tetrahedra of second
order''~\citep{Nedelec1986}. The global continuity requirements are
typically implied by the family: for instance, it is
generally assumed that the aforementioned \nedelec{} face element
functions indeed do have continuous normal components across
faces. Moreover, finite elements may be known by different family
names, for instance the aforementioned \nedelec{} face elements
coincide with the Brezzi--Douglas--Marini elements on
tetrahedra~\citep{BrezziDouglasMarini1985}, which again coincide with
the  family on
tetrahedra~\citep{ArnoldFalkWinther2006}.

UFL mimics the literature in the sense that primitive finite
elements are defined in terms of a family, a cell and a
polynomial degree via the \uflc{FiniteElement} class (see
Table~\ref{tab:finiteelementclasses}). Additionally, a quadrature
scheme label can be given as an optional argument. The family must be
an identifying string, while the cell is a description of the cell
type of the geometric domain.
The UFL documentation contains the comprehensive list of
preregistered families and cells. Multiple names in the literature for
the same finite element are handled via family aliases. UFL supports
finite element exterior calculus notation for simplices in one, two or
three dimensions via such aliases. By convention, elements of a finite
element family are numbered in terms of their polynomial degree~
such that their fields are indeed included in the complete polynomial
space of degree~. This facilitates internal consistency, although
it might conflict with some notation in the literature. For instance,
the lowest order Raviart--Thomas elements have degree~ in UFL.

Syntax is provided for defining vector elements. The \uflc{VectorElement}
class accepts a family, a cell, a degree and the dimension of the
vector element. The dimension defaults to the geometric dimension 
of the cell. The value shape of a vector element is then 
where  is the value shape of the corresponding finite element
of the same family. This corresponding element may be vector-valued,
e.g. a \uflc{VectorElement("BDM", triangle, p)} has value shape
. Moreover, further structure can be imposed for
(higher-dimensional) vector elements with a rank two tensor structure. The
\uflc{TensorElement} class accepts a family, a cell and a degree, and in
addition a shape and a symmetry argument. The shape argument defaults
to the tuple  and the value shape of the tensor element is
then~. The symmetry argument may be boolean true to define
the symmetry  if the value rank is two. It may also
be a mapping between the component tuples that should be equal, such
as \uflc{\{(0,0):(0,1),
  (1,0):(1,1)\}} to define the symmetries ,
.  The vector and tensor element classes can be viewed
as optimized, special cases of mixed finite elements.

In general, mixed finite elements in UFL are created from a tuple of
subelements through the \uflc{MixedElement} class. Each subelement can
be a finite, vector, or tensor element as described above, or in turn
a general mixed element. The latter can lead to nested mixed finite
elements of arbitrary, though finite, depth. All subelements must be
defined over the same geometric cell and utilize the same quadrature
scheme (if prescribed). The degree of a mixed finite element is
defined to be the maximal degree of the subelements. Note that mixed
finite elements are recursively flattened. Their value shape is  where  is the total number of scalar components.

Enriched elements can be defined via the \uflc{EnrichedElement} class,
given a tuple of finite, vector, tensor, or mixed subelements. The
subelements must be defined on the same cell and have the same value
shape. These then define the cell and value shape of the enriched
element. The degree is inferred as the maximal degree of the
subelements.

Finally, UFL also offers a restricted element abstraction via the
\uflc{RestrictedElement} class, taking as arguments any of the element
classes described above and a cell or the string \uflc{"facet"}.
The term restricted in this
setting refers to the elimination of element functions that vanish on
the given cell entities; \citet{labeur:2012} provide an example utilizing
elements restricted to cell facets. The value shape, cell and degree
of a restricted element are directly deduced from the defining
element.

\subsubsection{Operators over finite elements}

For readability and to reflect mathematical notation, UFL provides
some operators over the finite element classes defined in the previous
section. These operators include the binary operators
multiplication~(\uflc{*}) and addition~(\uflc{+}), and an indexing
operator (\uflc{[]}). These operators and their long-hand equivalents
are presented in Table~\ref{tab:finiteelementoperations}. The
multiplication operator acts on two elements to produce a mixed
element with the two elements as subelements in the given order. Note
that the multiplication operator (in Python) is binary, so
multiplication of three or more elements produces a nested mixed
element. Similarly, the addition operator acts on two elements to
yield an enriched element with the two given elements as
subelements. Finally, the indexing operator restricts an element to
the cell entity given by the argument to \uflc{[]}, thus returning a restricted
element.

\begin{table}
  \tbl{
    An overview of UFL operators over elements: examples of
    operator usage matched with the equivalent verbose syntax.
}{
  \begin{tabular}{ll}
    \toprule
    Operation & Equivalent syntax \\
    \midrule
    \uflc{M = U * V}     & \uflc{M = MixedElement(U, V)} \\
    \uflc{M = U * V * W} & \uflc{M = MixedElement((U, V), W)} \\
    \uflc{M = U + V}     & \uflc{M = EnrichedElement(U, V)} \\
    \uflc{M = V['facet']}& \uflc{M = RestrictedElement(V, 'facet')} \\
    \bottomrule
  \end{tabular}
}
  \label{tab:finiteelementoperations}
\end{table}

\subsection{Expressions}
\label{sec:expressions}

The language for declaring expressions consists of a set of terminal
expression types and a set of operators acting on other expressions.
Each expression is represented by an object of a subclass of \uflc{Expr}.
Each operator acts on one or more expressions and produces a new
expression. An operator result is uniquely defined by its operator
type and its operand expressions, and cannot have non-expression data
associated with it. A terminal expression does not depend on any other
expressions and typically has non-expression data associated with it,
such as a finite element, geometry data or the values of literal
constants. Terminal expression types are subclasses of \uflc{Terminal} and
operator results are represented by subclasses of \uflc{Operator}, both of
which are subclasses of \uflc{Expr}. Any UFL expression object is the root of
a self-contained expression tree in which each tree node is an \uflc{Expr}
object. The references from objects of \uflc{Operator} subtypes to the
operand expressions represent directed edges in the tree and objects
of \uflc{Terminal} subtypes terminate the tree.

As an embedded language, UFL allows the use of Python variables to
store subexpression references for reuse. However, UFL itself does not
have the concept of mutable variables. In fact, a key property of all
UFL expressions, including terminal types, is their immutable
state.\footnote{In the PyDOLFIN library, UFL function types are
  subclassed to carry additional mutable state which does
  not affect their symbolic meaning. UFL algorithms carefully
  preserve this information.}
Immutable state is a prerequisite for
the reuse of subexpression objects in expression trees by reference
instead of by copying. This aspect is critical for an efficient
symbolic software implementation.

The dependency set of an expression is the set of non-literal terminal
expressions that can be reached from the expression root.  An expression
with an empty dependency set can be evaluated symbolically, but in
general the evaluation of a UFL expression can only be carried out when
the values of its dependencies are known. Numerical evaluation of the
symbolic expression without code generation is possible when such values
are provided, but this is an expensive operation and not suitable for
large scale numerical computations.

Every expression is considered to be tensor-valued and its shape
must always be defined. Furthermore, every expression has a set of
free-indices.  Note that the free-index set of any particular expression
object is not associated with its shape; for instance, if  is a rank
two tensor with shape  (and no free indices), then  is
a rank zero tensor expression; in other words, scalar-valued and with
the associated free-indices  and~.  Mathematically one could
see  and  as being the same, but represented as objects
in software they are distinct.  While  represents a matrix-valued
expression,  represents any scalar value of~. Because the
tensor properties of all subexpressions are known, dimension errors and
inconsistent use of free-indices can be detected early. The following
sections describe terminal expressions, the index notation and various
operators in more detail.

\subsubsection{Terminal expressions}

Terminal expressions in UFL include literal constants, geometric
quantities and functions. In particular, UFL provides a
domain-specific set of types within these three fairly generic groups.
Tables~\ref{tab:literalexpr} and~\ref{tab:terminalexpr} provide an overview of the literal
constants, geometric quantities and functions available.

Literal constants include integer and real-valued constants, the
identity matrix, the Levi--Civita permutation symbol and unit
tensors. Geometric quantities include spatial coordinates and cell
derived quantities, such as the facet normal, facet area, cell volume,
cell surface area and cell circumradius. Some of these are only well
defined when restricted to facets, so appropriate errors are emitted
if used elsewhere.

Functions are cell-wise or spatially varying expressions. These are
central to the flexibility of UFL. However, in contrast to other UFL
expressions, functions are merely symbols or placeholders. Their values
must generally be determined outside of UFL. All functions are defined
over function spaces, introduced in Section~\ref{sec:function_spaces},
such that their tensor properties, including their shape, can be derived
from the function space. Functions are further grouped into coefficient
functions and argument functions. Expressions must depend linearly on
any argument functions; see Section~\ref{sec:variationalforms}. No
such limitations apply to dependencies on geometric quantities or
coefficient functions. Functions are counted, or assigned a count,
as they are constructed, and so the order of construction matters. In
particular, different functions are assumed to have different counts.
The ordering of the arguments to a form of rank 2 (or higher) is
determined by the ordering of these counts.
For convenience, UFL provides constructors for argument functions called
\uflc{TestFunction} and \uflc{TrialFunction} which apply a fixed
ordering to avoid accidentally transposing bilinear forms.

\begin{table}
  \tbl{
Tables of literal tensor constants.
}{
\begin{tabular}{ll}
\toprule
Mathematical notation  & UFL notation \\
\midrule
                                  & \uflc{I = Identity(2)} \\
                           & \uflc{eps = PermutationSymbol(3)} \\
                            & \uflc{ex, ey = unit\_vectors(2)} \\
   & \uflc{exx, exy, eyx, eyy = unit\_matrices(2)} \\
\bottomrule \\
\end{tabular}
}
  \label{tab:literalexpr}
\end{table}

\begin{table}
  \tbl{
Tables of non-literal terminal expressions.
}{
\begin{tabular}{ll|ll}
\toprule
\multicolumn{2}{c}{\emph{Geometric quantities}}
& \multicolumn{2}{c}{\emph{Functions}} \\
\midrule
Math. & UFL notation & Math. & UFL notation \\
\midrule
                          & \uflc{x = cell.x} &
                   & \uflc{c = Constant(cell)} \\
                          & \uflc{n = cell.n} &
                    & \uflc{g = Coefficient(element)} \\
                        & \uflc{h = cell.volume} &
                    & \uflc{w = Argument(element)} \\
                       & \uflc{r = cell.circumradius} &
                    & \uflc{u = TrialFunction(element)} \\
                        & \uflc{fa = cell.facetarea} &
                    & \uflc{v = TestFunction(element)} \\
        & \uflc{ca = cell.cellsurfacearea} &
 {} & {} \\
\bottomrule
\end{tabular}
}
\tabnote{The examples are given with
  reference to a predefined cell  denoted \uflc{cell},
  with coordinates , facets  and facet normal ,
  and a predefined local finite element space
   of some finite element denoted
  \uflc{element}.  denotes the volume, while  denotes
  the circumradius of the cell ; that is, the radius of the
  circumscribed sphere of the cell.}
  \label{tab:terminalexpr}
\end{table}

In the FEniCS pipeline, functions are evaluated as part of the form
compilation or the assembly process. Argument functions are
interpreted by the form compiler as placeholders for each basis
function in their corresponding local finite element spaces, which are
looped over when computing the local element tensor.
Moreover, the ordering of the argument functions (defined by
their counts) determines which global tensor axis each argument is
associated with when assembling the global tensor (such as a sparse
matrix) from a form. Form compilers typically specialize the evaluation of
the basis functions during compilation, but may theoretically keep the
choice of element space open until runtime.
On the other hand, coefficient functions are
used to represent global constants, finite element fields or any
function that can be evaluated at spatial coordinates during finite
element assembly. The limitation to functions of spatial coordinates
is necessary for the integration of forms to be a cell-wise operation.

\subsubsection{Index notation}
\label{subsubsec:index_notation}

UFL mirrors conventional index notation by providing syntax for
defining fixed and free-indices and for indexing objects. For
convenience, free-index objects with the names
\uflc{i, j, k, l, p, q, r, s} are predefined. However, these can be
redefined and new ones created. A single free-index object is created
with \uflc{i = Index()}, while multiple indices are created with
\uflc{j, k, l = indices(3)}.

The main indexing functionality of UFL is summarized in
Table~\ref{tab:indexingoperators}. The indexing operator \uflc{[]}
applied to an expression yields a component-wise representation. For
instance, for a rank two tensor  (\uflc{A}) and free-indices
\uflc{i}, \uflc{j}, \uflc{A[i, j]} yields the component-wise
representation~. The mapping from a scalar-valued expression
with components identified by free-indices to a tensor-valued
expression is performed via \uflc{as\_tensor(A[i, j], (i, j))}.  The
\uflc{as\_vector}, \uflc{as\_matrix}, \uflc{as\_tensor}
functions can also be used to construct tensor-valued expressions from
explicit tuples of scalar components. Note how the combination of
indexing and \uflc{as\_tensor} allows the reordering of the tensor
axes in the expression~. Finally, we remark that
fixed and free-indices can be mixed during indexing and that standard
slicing notation is available.
\begin{table}
  \tbl{
Table of indexing operators:
  \uflc{i}, \uflc{j}, \uflc{k}, \uflc{l} are free-indices, while
  \uflc{a}, \uflc{b}, \uflc{c} are other expressions.
}{
\begin{tabular}{ll}
\toprule
Mathematical notation & UFL notation \\
\midrule
 
& \uflc{A[i]} \\
 
& \uflc{B[i,j,k,l]} \\
 
& \uflc{as\_vector((a, b, c))} \\
 
& \uflc{as\_vector(B[i], i)} \\
 
& \uflc{as\_matrix(B[j,i], (i,j))} \\
 
& \uflc{as\_tensor(B[k,l,i,j], (i,j,k,l))} \\
\bottomrule
\end{tabular}
}
 \label{tab:indexingoperators}
\end{table}

\subsubsection{Arithmetic and tensor algebraic operators}

UFL defines arithmetic operators such as addition, multiplication,
 inner, outer and cross products and tensor algebraic operators
such as the transpose, the determinant and the inverse. An overview of
common operators of this kind is presented in
Table~\ref{tab:tensoroperators}. These operators will be familiar to
many readers and we therefore make only a few comments below.

\begin{table}
  \tbl{
Table of tensor algebraic operators
}{
\begin{tabular}{ll}
\toprule
Math. notation & UFL notation \\
\midrule
          & \uflc{A + B} \\
          & \uflc{dot(A, B)} \\
              & \uflc{inner(A, B)} \\
        & \uflc{outer(A, B)} \\
         & \uflc{cross(A, B)} \\
\midrule
                          & \uflc{transpose(A)} \\
             & \uflc{sym(A)} \\
            & \uflc{skew(A)} \\
             & \uflc{dev(A)} \\
   & \uflc{tr(A)} \0.14em]
    \bottomrule
  \end{tabular}
}
  \label{tab:elementarytrigfunctions}
\end{table}
\begin{table}
\tbl{
(Left) Table of special functions. (Right) Table of
    element-wise operators.
}{
  \begin{tabular}{ll}
    \toprule
    Math. notation & UFL notation \\
    \midrule
            & \uflc{erf(f)} \\
        & \uflc{bessel\_J(nu, f)} \\
        & \uflc{bessel\_Y(nu, f)} \\
        & \uflc{bessel\_I(nu, f)} \\
        & \uflc{bessel\_K(nu, f)} \0.1em]
    \bottomrule
  \end{tabular}}
  \label{tab:dgoperators}
  \label{tab:integrals}
\end{table}

Since UFL is an embedded language, a user can easily implement custom
operators for discontinuous Galerkin methods from the basic
restriction building blocks. The reader is referred
to~\citet{oelgaard:2008} for more details on discontinuous Galerkin
methods in the context of a variational form language, developed for
FFC, and automated code generation.

\subsection{Integrals and variational forms}
\label{sec:forms}

In addition to expressions, UFL provides concepts and syntax for
defining integrals over facets and cells and, via integrals, for
defining variational forms. Variational forms can further be
manipulated and transformed via form operations. This sublanguage is
described in the sections below.

\subsubsection{Integrals and forms}

The integral functionality provided by UFL is centered around the
integrals featuring in variational forms as summarized by the
canonical expression~\eqref{eq:canonical}. An integral is generally
defined by an integration domain, an integrand and a measure. UFL
admits integrands defined in terms of terminal expressions and
operators as described in the previous section. The mathematical
concept of an integration domain together with a corresponding measure
is however embodied in a single abstraction in UFL, namely the
\uflc{Measure} class. This abstraction was inherited from the
original FFC form language.

A UFL measure (for simplicity just a measure from here onwards) is
defined in terms of a domain type, a domain identifier and,
optionally, additional domain meta-data. The allowed domain types
include \uflc{"cell"}, \uflc{"exterior\_facet"} and
\uflc{"interior\_facet"}. These domain types correspond to Lebesgue
integration over (a subset of) cells, (a subset of) exterior facets or
(a subset of) interior facets.  The domain identifier must be a
non-negative integer (the index~ in~\eqref{eq:canonical}). For
convenience, three measures are predefined by UFL: \uflc{dx},
\uflc{ds} and \uflc{dS} corresponding to measures over cells,
exterior facets and interior facets, respectively, each with the
default domain identifier~. However, new measures can be created
directly, or by calling a measure with an integer  yielding a new
measure with domain identifier~. Several other, less common, domain
types are allowed, such as \uflc{"surface"}, \uflc{"point"} and
\uflc{"macro\_cell"}, and new measures are easily added. We refer to
the UFL documentation for the complete description of these.

A UFL integral is then defined via an expression, acting as the
integrand, and a measure object. In particular, multiplying an
expression with a measure yields an integral. This is illustrated in
Table~\ref{tab:integrals} (right), with \uflc{k} denoting the domain
identifier. We remark that all integrand expressions featuring in an
integral over interior facets must be restricted for the integral to
be admissible. The integrand expression will depend on a number of
distinct argument functions: the number of such is labeled the arity
of the integral.

Finally, a UFL form is defined as the sum of one or more integrals. A
form may have integral terms of different arities. However, if all
terms have the same arity  we term this  the arity of the
form.  Forms are labeled according to their arity: forms of arity 
are called functionals, forms of arity  are called linear forms, and
forms of arity  are called bilinear forms. We emphasize that the
number of coefficient functions does not affect the arity of an
integral or a form. Table~\ref{tab:forms} shows simple examples of
functionals, linear forms and bilinear forms, while more complete
examples are given in Section~\ref{sec:examples}.

\begin{table}
\tbl{
Table of various form examples.
}{
  \begin{tabular}{lll}
    \toprule
    Mathematical notation & UFL notation & Form type \0.5em]

     &
    \uflc{M = dot(grad(f), grad(g)) * dx} &
    Functional \0.5em]

     &
    \uflc{L = Dn(g)*v * ds} &
    Linear form \0.5em]

     &
    \uflc{a = u*v * dx(0) + f*u*v * ds(1)} &
    Bilinear form \0.5em]

     &
    \uflc{a = A[i,j]*u.dx(i)*v.dx(j) * dx} &
    Bilinear form \
  \label{eq:poisson}
  - \Div (\kappa \Grad u) = f \quad  \text{in } \Omega,
  \qquad
  u = u_0 \quad \text{on } \GammaD,
  \qquad
  -\kappa \partial_n u = g \quad \text{on } \GammaN,

  \label{eq:poisson,H1}
  a(u, v) \equiv \int_{\Omega} \kappa \Grad u \cdot \Grad v \dx
  =
  \int_{\Omega} f v \dx - \int_{\GammaN} gv \ds \equiv L(v)

  \label{eq:poisson,L2}
  \begin{split}
     \int_\Omega \kappa \Grad u &\cdot \Grad v \dx
     - \int_{\GammaD} \kappa \partial_n u v \ds
     - \int_{\GammaD} \kappa \partial_n v u \ds
     + \int_{\GammaD} \frac{\gamma\kappa}{h} uv \ds \\
     + \sum_{F\in\mathcal{F}^0} \Bigg(
    &- \int_F \avg{\kappa \Grad u} \cdot \jump{v}_n \ds
     - \int_F \avg{\kappa \Grad v} \cdot \jump{u}_n \ds
     + \int_F \frac{\gamma \avg{\kappa}}{\avg{h}}\jump{u}\jump{v} \ds \Bigg) \\
    &\quad
     = \int_{\Omega} fv \dx
     - \int_{\GammaN} gv \ds
     - \int_{\GammaD} \partial_n u_0 v \ds
     - \int_{\GammaD} \partial_n v u_0 \ds
     + \int_{\GammaD} \frac{\gamma\kappa}{h} u_0 v \ds
  \end{split}

  \label{eq:mxpoisson}
              \Div \sigma = f     \quad \text{in } \Omega,  \qquad
  \sigma + \kappa \Grad u = 0     \quad \text{in } \Omega,  \qquad
                        u = u_0   \quad \text{on } \GammaD, \qquad
           \sigma \cdot n = g     \quad \text{on } \GammaN.

  \int_{\Omega} (\Div \sigma) v \dx +
  \int_{\Omega} \sigma \cdot \tau \dx -
  \int_{\Omega} u \Div (\kappa\tau) \dx
  =
  \int_{\Omega} fv \dx -
  \int_{\Gamma_D} \kappa u_0 \tau \cdot n \ds

  -\Delta u + \Grad p = f \quad \text{in } \Omega, \qquad
               \Div u = 0 \quad \text{in } \Omega,

  \int_{\Omega} \Grad u \cdot \Grad v \dx -
  \int_{\Omega} (\Div v) p \dx +
  \int_{\Omega} (\Div u) q \dx
  =
  \int_{\Omega} fv \dx.

  \Pi(v) = \int_{\Omega} \psi(v) \dx - \int_{\Omega} B \cdot v \dx
  - \int_{\Gamma} T \cdot  v \ds,
\label{eqn:potential_energy}

  \psi(v) =
  \frac{\mu}{2}(I_c - 3) - \mu\ln J + \frac{\lambda}{2}(\ln J)^2,
 \label{eq:minproblem}
  u = \underset{v \in V}{\operatorname{argmin}} \, \Pi(v).

  J(u, p) =
  \int_\Omega \frac{1}{2}(u - \bar{u})^2 \dx +
  \int_\Omega\frac{1}{2}\alpha p^2 \dx,

  \label{eq:optimization,varproblem}
  a(u, v) \equiv \int_\Omega u v + \Grad u \cdot \Grad v \dx
  = \int_\Omega p v \dx \equiv b(p; v),

  \mathcal{L}(u, p, v) = J(u, p) + a(u, v) - b(p; v).
{2}
  D_u &\mathcal{L}(u, p, v)[\delta u] &= 0 \qquad & \forall \ \delta u, \\
  D_p &\mathcal{L}(u, p, v)[\delta p] &= 0 \qquad & \forall \ \delta p, \\
  D_v &\mathcal{L}(u, p, v)[\delta v] &= 0 \qquad & \forall \ \delta v,

  t &= [i | l | g | c | a], \\
  o &= [I | A | F | T | D | R | B | C], \\
  e &= [t | o(e_1, \ldots, e_n)].

  \frac{d(fg)}{df}
      = \frac{df}{df} g + f \frac{dg}{df}
      = 1 g + f 0 \rightarrow g + 0 \rightarrow g.

  I^i_j < i, \qquad j = 1, \ldots, p_i, \qquad i = 1,
  \ldots, m+n.

  \label{eq:recursiveevaluateoperator}
  E_R(e_i) &= \begin{cases}
    E_T(e_i),
    \qquad & \text{if} \, \type(e_i) \in T_T, \\
    E_O\left(e_i, \langle E_R(e_{I^i_j}) \rangle_{j=1}^{p_i}\right),
    \qquad & \text{if} \, \type(e_i) \in T_O.
  \end{cases}

  \label{eq:flexibleevaluateoperator}
  \tilde{E}_R(e_i) &= \begin{cases}
    E_T(e_i),
    \qquad & \text{if} \, \type(e_i) \in T_T, \\
    E_V\left(e_i, \langle \tilde{E}_R(e_{I^i_j}) \rangle_{j=1}^{p_i}\right),
    \qquad & \text{if} \, \type(e_i) \in T_V, \\
    E_C\left(e_i, \langle e_{I^i_j} \rangle_{j=1}^{p_i}\right),
    \qquad & \text{if} \, \type(e_i) \in T_C.
  \end{cases}

  \label{eq:evaluaterecursive}
  v = \tilde{E}_R(e) \equiv \tilde{E}_R(e_{m+n}).

  \label{eq:reusetransformer}
  E_{\mathrm{reuse}}\left(e_i\right)
  &= \begin{cases}
    e_i,
    \qquad & \text{if} \, \type(e_i) \in T_T, \\
    \type(e_i)\left(\langle E_{\mathrm{self}}(e_{I_j^i}) \rangle_{j=1}^{p_i}\right),
    \qquad & \text{if} \, \type(e_i) \in T_O,
  \end{cases}

  \label{eq:replacer}
  E_{\mathrm{replace}}\left(e_i\right)
  &= \begin{cases}
    \operatorname{map}(e_i),
    \qquad & \text{if} \, \type(e_i) \in T_T, \\
    \text{delegate to} \, E_{\mathrm{reuse}}(e_i),
    \qquad & \text{otherwise},
  \end{cases}

E_{\mathrm{AD}}(e_i) & =
\begin{cases}
0,
  \qquad & \text{if} \ \type(e_i) \in T_T, \\
\sum_{j=1}^{p_i} \frac{\partial e_i}{\partial e_{I_j^i}} E_{\mathrm{AD}}(e_{I_j^i}),
  \qquad & \text{if} \ \type(e_i) \in T_O.
\end{cases}

E_{\mathrm{XD}}(e) & =
\begin{cases}
 I,             \qquad & \text{if }e\text{ is the spatial coordinate vector}, \\
 0,             \qquad & \text{if }e\text{ is a piecewise constant function}, \\
 \Grad e,       \qquad & \text{if }e\text{ is a non-constant function}, \\
 \Grad \Grad f, \qquad & \text{if }e\text{ is} \, \Grad f, \\
\text{delegate to} \, E_{\mathrm{AD}}(e),           \qquad & \text{otherwise}.
\end{cases}

E_{\mathrm{VD}}(e) & =
  \begin{cases}
   1,                        \qquad & \text{if }e\text{ is the variable instance} \, u, \\
   E_{\mathrm{VD}}(f),       \qquad & \text{if }e\text{ \small is another variable instance annotating the expression } f, \\
  \text{delegate to} \, E_{\mathrm{AD}}(e),                    \qquad & \text{otherwise}.
  \end{cases}

  E_{\mathrm{DD}}(e) & =
  \begin{cases}
    v,             \qquad & \text{if }e\text{ is the function} \, u, \\
    \Grad E_{\mathrm{DD}}(f),  \qquad & \text{if }e\text{ is} \, \Grad f, \\
    h v,           \qquad & \text{if }e\text{ is the function} \, g, \\
    \text{delegate to} \, E_{\mathrm{AD}}(e),           \qquad & \text{otherwise}.
  \end{cases}

  u: X \rightarrow \R^3, \qquad \hat{u}=(u_1, u_3), \qquad \hat{v}: X \rightarrow \R^2.

D_{\hat{u}} M(u) \left[\hat{v}\right]
  = \frac{d}{d\tau} \left[
     M((u_1+\tau \hat{v}_1, u_2+0 \tau, u_3+\tau \hat{v}_2))
     \right]_{\tau=0}
  = D_{u} M(u) \left[v\right].

  \int_a^b f^\prime(x) \dx = \left[f(x)\right]_a^b, \quad
  \int_\Omega \Div v \dx = \int_{\partial\Omega} v \cdot n \ds.
\label{eq:greens}

This identity is ideal for combined testing of symbolic
differentiation, numerical differentiation, and symbolic evaluation,
or even higher order derivatives by setting 
in~\eqref{eq:greens}. Exploiting such mathematical identities is key
to robust testing of mathematical software, and combining the symbolic
and numerical paradigms provides good opportunities for discovering
errors.

A software stack such as that provided in the FEniCS Project with (i)
a DSL and symbolic framework in UFL, (ii) automated code generation in
the form compiler FFC~\citep{logg:2012}, and (iii) library code in the
problem solving environment DOLFIN~\citep{logg:2012b}, naturally
introduces additional complexity to the debugging process if something
goes wrong. However, the high abstraction level allows us to check the
correctness of end-user programs in various ways. Automated validation
of expressions and forms by UFL allows consistency checks and catching
of user errors at various levels of abstraction.  Last, but not least,
UFL has been tested in active use by researchers for more than three
years as part of the FEniCS Project.

\section{Conclusions}
\label{sec:conclusions}

We have presented the Unified Form Language and shown how the language
and its associated algorithms allow compact, readable and efficient
specification of mathematical expressions related to variational
formulations of partial differential equations. We have presented both
high-level and detailed views of UFL to communicate its practical use
and to provide developers and technical users a firm grounding in the
design principles of UFL for understanding and building upon UFL.

UFL is a stand-alone Python module that has been extensively used as part
of the FEniCS software pipeline since 2009. The UFL functionality has been
crucial in enabling advanced automated finite element algorithms in the
FEniCS context, especially for complicated coupled systems of equations
and for problems for which automatic differentiation dramatically
reduced the burden on the application developer.  UFL has also proven
to be extensible beyond the core implementation, as exemplified by
\citet{NikbakhtWells2009} and \citet{MassingEtAl2012} in the context
of extended finite element methods, and \citet{MarkallEtAl2012} in
relation to code generation for different architectures.  UFL is an
actively developed project and continues to further extend the power
and expressiveness of the language.

\begin{acks}The authors wish to thank Kent-Andre Mardal and Johannes Ring for
their contributions to UFL, and Pearu Peterson for discussions about
symbolic representations during the initial design phase.
\end{acks}
\bibliographystyle{abbrvnat}
\bibliography{references}
\end{document}
