\documentclass{entcs} 



\usepackage[utf8]{inputenc}

\usepackage{entcsmacro} \usepackage{array}
\usepackage{semantic,stmaryrd,tikz,multirow}

\usepackage{listings}
\usepackage{lstjava}
\lstset{language=Java,basicstyle={\tt{}}}


\newcolumntype{M}[1]{>{}}
\newcolumntype{C}[1]{>{}}
\newcolumntype{L}[1]{>{}}
\newcolumntype{R}[1]{>{}}

\newcommand{\clinit}{\ensuremath{\texttt{<clinit>}}}
\newcommand{\implies}{\textnormal{}}
\newcommand{\may}{\ensuremath{\mathit{May}}}
\newcommand{\must}{\ensuremath{\mathit{Must}}}
\newcommand{\wf}{\ensuremath{\mathit{Wf}}}

\newcommand{\getstatic}{\texttt{getstatic C.f}}
\newcommand{\invokestatic}{\texttt{invokestatic C.m}}
\newcommand{\staticC}{\texttt{\dots{}C\dots}}
\newcommand{\flow}{\mathit{flow}}
\newcommand{\intraflow}{\flow_{\rm intra}}
\newcommand{\interflow}{\flow_{\rm inter}}
\newcommand{\clinitflow}{\flow_{\rm clinit}}

\def\lastname{Hubert and Pichardie}

\def\tm{\leavevmode\hbox{}}


\begin{document}

\begin{frontmatter}
\title{Soundly Handling Static Fields:\\
    Issues, Semantics and Analysis}

  \author[CnrsIrisa]{Laurent
    Hubert\thanksref{email}\thanksref{regionbretagne}}
  \author[InriaIrisa]{David Pichardie\thanksref{email}}

  \address[CnrsIrisa]{CNRS, IRISA, Campus Beaulieu , F-35042 Rennes
    Cedex, France}\address[InriaIrisa]{INRIA, Centre Rennes --- Bretagne Atlantique\\
    IRISA, Campus Beaulieu , F-35042 Rennes Cedex, France}


  \thanks[email]{Email:\texttt{first.last@irisa.fr}}
  \thanks[regionbretagne]{This work was supported in part by the
    Région Bretagne}

  \begin{abstract}
Although in most cases class initialization works as expected,
    some static fields may be read before being initialized, despite
    being initialized in their corresponding class initializer.
We propose an analysis which compute, for each program point, the
    set of static fields that must have been initialized and discuss
    its soundness.
We show that such an analysis can be directly applied to identify
    the static fields that may be read before being initialized and to
    improve the precision while preserving the soundness of a
    null-pointer analysis.
  \end{abstract}

  \begin{keyword}
    static analysis, Java, semantics, class initialization, control
    flow, verification.
  \end{keyword}
\end{frontmatter}


\section{Introduction}
\label{sec:introduction}

Program analyses often rely on the data manipulated by programs and
can therefore depend on their static fields.  Unlike instance fields,
static fields are unique to each class and one would like to benefit
from this uniqueness to infer precise information about their content.

When reading a variable, be it a local variable or a field, being sure
it has been initialized beforehand is a nice property.  Although the
Java bytecode ensures this property for local variables, it is not
ensured for static and instance fields which have default values.

Instance fields and static fields are not initialized the same way:
instance fields are usually initialized in a constructor which is
explicitly called whereas static fields are initialized in class
initializers which are implicitly and lazily invoked.  This makes the
control flow graph much less intuitive.



The contributions of this work are the followings.
\begin{itemize}
\item We recall that implicit lazy static field initialization makes
  the control flow graph hard to compute.
\item We identify some code examples that would need to be ruled out
  and some other examples that would need \emph{not} to be ruled out.
\item We propose a language to study the initialization of static
  fields.
\item We propose a formal analysis to infer an under-approximation of
  the set of static fields that have already been initialized for each
  program point.
\item We propose two possible applications for this analysis: a direct
  application is to identify potential bugs and another one is to
  improve the precision while keeping the correctness of a
  null-pointer analysis.
\end{itemize}

The rest of this paper is organized as follows.  We recall in
Sect.~\ref{sec:why-difficult} that the actual control flow graph which
includes the calls the class initializers it not intuitive and give
some examples.  We present in Sect.~\ref{sec:language} the syntax and
semantics of the language we have chosen to formalize our analysis.
Section~\ref{sec:analysis} then presents the analysis, first giving an
informal description and then its formal definition.  We then explain
in Sect.~\ref{sec:extensions} how the analysis can be extended to
handle other features of the Java bytecode language.  In
Sect.~\ref{sec:two-possible-uses}, we give two possible applications
of this analysis.  Finally, we discuss the related work in
Sect.~\ref{sec:related-work} and conclude in
Sect.~\ref{sec:conclusion}.


\section{Why Static Analysis of Static Fields is Difficult?}
\label{sec:why-difficult}


The analysis we herein present works at the bytecode level but, for
sake of simplicity, code examples are given in Java.  As this paper is
focused on static fields, all fields are assumed to be static unless
otherwise stated.

In Java, a field declaration may include its initial value, such as
\texttt{A.f} in Fig.~\ref{fig:depend_on_main}.  A field can also be
initialized in a special method called a \emph{class initializer},
which is identified in the Java source code with the \texttt{static}
keyword followed by no signature and a method body, such as in class
\texttt{B} in the same figure.
If a field is initialized with a compile-time constant expression, the
compiler from Java to bytecode may translate the initialization into a
\emph{field initializer} (cf.~\cite{lindholm99:jvm_spec},
Sect.~4.7.2), which is an attribute of the field.  At run time, the
field should be set to this value before running the class
initializer.
In-line initializations that have not been compiled as field
initializers are prepended in textual order to the class initializer,
named \clinit{} at the bytecode level.
For this analysis, we do not consider field initializers but focus on
class initializers as they introduce the main challenges.  Although
this simplification is sound, it is less precise and we explain how to
extend our analysis to handle field initializers in
Sect.~\ref{sec:initialization-order}.

The class initialization process is not explicitly handled by the
user: it is forbidden to explicitly called a \clinit{} method.
Instead, every access (read or write) to a field of a particular class
or the creation of an instance of that same class requires that the
JVM (Java Virtual Machine) has \emph{invoked} the class initializer
of that class.  This method can contain arbitrary code and may trigger
the initialization of other classes and so on.

The JVM specification~\cite{lindholm99:jvm_spec} requires class
initializers to be invoked \emph{lazily}.
This implies that the order in which classes are initialized depends
on the \emph{execution path}, it is therefore not decidable in
general.

\begin{figure}
  \begin{center}
\begin{lstlisting}
class A extends Object{static B f = new B();}
class B extends Object{
  static B g;
  static {
    g = A.f;
  }
}
\end{lstlisting}
  \end{center}
  \caption{Initial values can depend on foreign code: in this example,
    the main program should first use \texttt{B} for the
    initialization to start from \texttt{B} to avoid \texttt{B.g} to
    be \texttt{null}.}
  \label{fig:depend_on_main}
\end{figure}

The JVM specification also requires class initializers to be invoked
at most once.
This avoids infinite recursions in the case of circular dependencies
between classes, but it also implies that when reading a field it may
not contain yet its ``initial'' value.  For example, in
Fig.~\ref{fig:depend_on_main}, the class initializer of \texttt{A}
creates an instance of \texttt{B} and therefore requires that the
class initializer of \texttt{B} has been invoked.  The class
initializer of \texttt{B} reads a field of \texttt{A} and therefore
requires that the class initializer of \texttt{A} has been invoked.
\begin{itemize}
\item If \texttt{B.\clinit} is invoked before \texttt{A.\clinit}, then
  the read access to the field \texttt{A.f} triggers the invocation of
  \texttt{A.\clinit}.  Then, as \texttt{B.\clinit} has already been
  invoked, \texttt{A.\clinit} carries on normally and creates an
  instance of class \texttt{B}, store its reference to the field
  \texttt{A.f} and returns.  Back in \texttt{B.\clinit}, the field
  \texttt{A.f} is read and the reference to the new object is also
  affected to \texttt{B.g}.
\item If \texttt{A.\clinit} is invoked before \texttt{B.\clinit}, then
  before allocating a new instance of \texttt{B}, the JVM has to
  initialize the class \texttt{B} by calling \texttt{B.\clinit}.  In
  \texttt{B.\clinit}, the read access to \texttt{A.f} does not trigger
  the initializer of \texttt{A} because \texttt{A.\clinit} has already
  been started.  \texttt{B.\clinit} then reads \texttt{A.f}, which has
  not been initialized yet, \texttt{B.g} is therefore set to the
  default value of \texttt{A.f} which is the \texttt{null} constant.
\end{itemize}
This example shows that the order in which classes are initialized
modifies the semantics.
The issue shown in Fig.~\ref{fig:depend_on_main} is not limited to
reference fields.  In the example in
Fig.~\ref{fig:integer_depend_on_main}, depending on the initialization
order, \texttt{A.CST} will be either 0 or 5, while \texttt{B.SIZE}
will always be 5.
\begin{figure}
  \centering
\begin{lstlisting}
class A extends Object{
  public static int CST= B.SIZE;}
class B extends Object{
  public static int SIZE = A.CST+5;
}
\end{lstlisting}
  \caption{Integer initial values can also depend on foreign code}
  \label{fig:integer_depend_on_main}
\end{figure}



One could notice that those problems are related to the notion of
circular dependencies between classes and may think that circular
dependencies should be avoided.
Figure~\ref{fig:one-class} shows an example with a single class.  In
(a), \texttt{A.ALL} is read in the constructor before it has been
initialized and it leads to a \texttt{NullPointerException}. (b) is
the correct version, where the initializations of \texttt{ALL} and
\texttt{EMPTY} have been switched.  This example is an extract of
\texttt{java.lang.Character\\ppt\fields\class\methodmm.\firstmm.\lastCC.\clinitC\putS(f)f\in\fields\invoke\interflow\return\any(m_0,\,\instrAt,\,\intraflow,\,\interflow,\,\clinitflow)m_0\in\method\instrAt\in\ppt\pto\{\putS(f),~\invoke,\return,\any\}\intraflow\subseteq \ppt\times\ppt\interflow\subseteq \ppt\times\method\clinitflow\in \ppt\pto\class\instrAt\intraflowml\in\pptm.\first\intraflow\instrAt(l)=\return(l,m.\last)\intraflow\clinitflow(l,C)l\mathtt{new}~C\mathtt{putstatic}~C.f\mathtt{getstatic}~C.f\mathtt{invokestatic}~C.mm_0m\mathtt{A}\mathtt{B}\mathtt{A}\mathtt{B}\mathtt{A}.\clinit88\mathtt{A}.\clinit\undefh\in\History\st{l,\cs,s,\hist}l\css\undef\histll\marked{l}{l}\step \subseteq \State\times\State(m_0,\instrAt,\intraflow,\interflow,\clinitflow)\NeedInit\subseteq\ppt\times\class\times\HistoryCl\clinitflowC.\clinitC\not\in\hist\toCC.\clinit\marked{\cdot}C\hist\stepi\subseteq\State\times\State\stepi\putS(f)vf\any\return\stepilm_0\undefp=(m_0,\instrAt,\intraflow,\interflow,\clinitflow)\wfllC\clinitflow(l)=CC.\clinitC.\clinitC.\clinitC.\clinitC.\clinit\clinitflow\mayC\may\may\may\mathtt{C}\mathtt{B}\mathtt{B}\{\mathtt{B},\mathtt{C}\}\{\mathtt{A.f}\}\mathtt{A}\mathtt{A}\mathtt{B}\mathtt{C}\{\mathtt{A},\mathtt{B},\mathtt{C}\}\must\mathtt{C}\mathtt{C}\must\mathtt{C}.\clinit\mathtt{C}\in\must\mathtt{C}\mathtt{C}.\clinit\mathtt{C}.\clinit\may\must\wf\may\must\clinitflow\wfp=
(m_0,\instrAt,\intraflow,\interflow,\clinitflow)\Pow_p(\class)\Pow_p(\fields)pl\in\ppt(\may,\must,\wf)\in\Pow_p(\class)\times\Pow_p(\class)\times\Pow_p(\fields)\may\must\wf(A^\sharp,\sqsubseteq,\sqcup,\sqcap,\bot,\top)A^\sharp =
    \Pow_p(\class)\times\Pow_p(\class)\times\Pow_p(\fields)\bot=(\emptyset,\Pow_p(\class),\Pow_p(\fields))\top=(\Pow_p(\class),\emptyset,\emptyset)(\may_1,\must_1,\wf_1)(\may_2,\must_2,\wf_2)A^\sharpA^\sharp(\may,\must,\wf)(s,\hist)\in\Static\times\History(\may,\must,\wf)\sim(s,\hist)\may\must\wfA_\inA,A_\outA\in\ppt\to A^\sharplp\left\{
          \begin{array}[c]{ll}
            F_\callA\left(F^\init(l,A_\inA(l)),\bigsqcup \{A_\inA(m.\last)\mid \interflow(l,m)\}\right) & \mathrm{if}~ \instrAt(l) = \invoke \\
            F_{\instrAt(l)} (F^\init(l,A_\inA(l))) & \mathrm{otherwise}
          \end{array}\right.F_{\return}F_{\any}F_{\putS(f)}\in A^\sharp\to A^\sharpF_\callA\in A^\sharp\times A^\sharp\to A^\sharpF^\init_\callA\in \class\times A^\sharp\to A^\sharpF^\init\in \ppt\times A^\sharp\to A^\sharpA_\inA(l)A_0(l)lm_0A_\first(l)lmmCF_\callA^\init\mustC\may\mustF^\initA_\outA(l)\instrAt(l)F_\callAF^\init(l,A_\inA(l))A_\inA(l)F^\initF_{\instrAt(l)}F^\initF_{\instrAt(l)}\instrAt(l)F^\initC.\clinitC.\clinitaF_\callACC.\clinitF_\callA\must\wf(\must,\wf)lll\instrAt(l)A.\clinit1776A.\clinit\must2mA_\outA(2)A_\inA(m.\last)A\in\mustA_\inA(2)A_\inA(m.\last)F_\callA\must\wf\sqsubseteqp(A^\sharp,\sqsubseteq,\sqcup,\sqcap)(A_\inA,A_\outA)\st{i,\cs,s,\hist}\in\ia{p}A_\inA(i)\sim(s,\hist)\leadsto\tolml\leadsto\leadsto\leadsto\siml\clinitflow(l)=\textit{super}(C)\mustm_o.\firstl$, we need to check that
\texttt{C.f} is in the set of written field at this particular program
point.

\subsection{Nullness Analysis of Static Fields}
\label{sec:nullness-analysis}

While in our previous
work~\cite{hubert08-1:nonnull_annotations_inference} we choose to
assume no information about static fields, several tools have targeted
the analysis of static fields as part of their analysis but missed the
issue of the initialization herein discussed.

To safely handle static fields while improving the precision, we can
abstract every field by the abstraction of the values that may be
written to it and, if the static field may be read before being
initialized, then we add the abstraction of the \texttt{null} constant
to the abstraction of the field.  It is a straightforward extension of
the analysis presented
in~\cite{hubert08-1:nonnull_annotations_inference}.


\section{Related work}
\label{sec:related-work}

Kozen and Stillerman studied
in~\cite{kozen02:_eager_class_initial_for_java} eager class
initialization for Java bytecode and proposed a static analysis based
on fine grained circular dependencies to find an initialization order
for classes.  If their analysis finds an initialization order, then
our analysis will be able to prove all fields are initialized before
being read.  If their analysis finds a circular dependency, it fails
to find an initialization order and issues an error while our analysis
considers the initialization order implied by the main program and may
prove that all fields are written before being read.

Instance field initialization have been studied for different
purposes.  Some works are focused on null-ability properties such as
Fähndrich and Leino in~\cite{fahndrich03:_declar_and_check_non_null},
our work in~\cite{hubert08-1:nonnull_annotations_inference} or
Fähndrich and Xia
in~\cite{fahndrich07:object_invariants_delayed_types}.  Other work
have been focused on different properties such as Unkel and
Lam~\cite{unkel08:infererence_stationary_fields} who studied
stationary fields.  Instance field initialization offers different
challenges from the one of static fields: the initialization method is
explicitly called soon after the object allocation.

Several formalizations of the Java bytecode have been proposed that,
among other features, handled class initialization such as the work of
Debbabi \emph{et al.} in~\cite{FormalJVM} or Belblidia and Debbabi
in~\cite{FormalJVM2}.  Their work is focused on the dynamic semantics
of the Java bytecode while our work is focused on its analysis.

Böerger and Schulte~\cite{Borger98aprogrammer} propose another dynamic
semantics of Java.  They consider a subset of Java including
initialization, exceptions and threads.  They have
exhibited~\cite{borger00initialization} some weaknesses in the
initialization process as far as the threads are used.  They pointed
out that deadlocks could occur in such a situation.

Harrold and Soffa~\cite{harrold94:interprocedural_def_use} propose an
analysis to compute inter-procedural definition-use chains.  They have
not targeted the Java bytecode language and therefore neither the
class initialization problems we have faced but then, our analysis can
be seen as a lightweight inter-procedural definition-use analysis
where all definitions except the default one are merged.

Hirzel \emph{et
  al.}~\cite{hirzel04:pointer_analysis_dynamic_class_loading} propose
a pointer analysis that target dynamic class loading and lazy class
initialization.  There approach is to analyse the program at run time,
when the actual classes have been loaded and to update the data when a
new class is loaded and initialized.  Although it is not practical to
statically certify programs, a similar approach could certainly be
adapted to implement a checker in PCC architecture such as the one
evoked in Sect.~\ref{sec:reflection}.


\section{Conclusion and Future Work}
\label{sec:conclusion}
We have shown that class initialization is a complex mechanism and
that, although in most cases it works as excepted, in some more
complicated examples it can be complex to understand in which
order the code will be executed.  More specifically, some fields may
be read before being initialized, despite being initialized in their
corresponding class initialization methods.
A sound analysis may need to address this problem to infer precise and
correct information about the content of static fields.
We have proposed an analysis to identify the static fields that may be
read before being initialized and shown how this analysis can be used
to infer more precise information about static fields in a sound
null-pointer analysis.

We expect the analysis to be very precise if the control flow graph is
\emph{accurate enough}, but we would need to implement this analysis
to evaluate the precision needed for the control flow graph.


\bibliographystyle{entcs} \bibliography{biblio}
\end{document}
