\documentclass{article}[12pt]
\usepackage{amsmath,amstext,amssymb,amsfonts}
\usepackage{color,graphicx}
\usepackage{tabularx}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{ifdraft}




\usepackage{nicefrac}

\newcommand{\flatfrac}[2]{#1/#2}
\newcommand{\ffrac}{\flatfrac}
\newcommand{\nfrac}{\nicefrac}

\usepackage{microtype}

\newtheorem{theorem}{Theorem}[section]
\newtheorem*{theorem*}{Theorem}

\newtheorem{Claim}[theorem]{Claim}
\newtheorem*{claim*}{Claim}
\newtheorem{subclaim}{Claim}[theorem]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{lemma*}{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem*{conjecture*}{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\newtheorem*{fact*}{Fact}
\newtheorem{hypothesis}[theorem]{Hypothesis}
\newtheorem*{hypothesis*}{Hypothesis}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{construction}[theorem]{Construction}
\newtheorem{reduction}[theorem]{Reduction}
\newtheorem{example}[theorem]{Example}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{SDP}[theorem]{SDP}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{protocol}[theorem]{Protocol}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{assumption}[theorem]{Assumption}



\usepackage{prettyref}
\newcommand{\savehyperref}[2]{\texorpdfstring{\hyperref[#1]{#2}}{#2}}

\newrefformat{eq}{\savehyperref{#1}{\textup{(\ref*{#1})}}}
\newrefformat{lem}{\savehyperref{#1}{Lemma~\ref*{#1}}}
\newrefformat{def}{\savehyperref{#1}{Definition~\ref*{#1}}}
\newrefformat{thm}{\savehyperref{#1}{Theorem~\ref*{#1}}}
\newrefformat{cor}{\savehyperref{#1}{Corollary~\ref*{#1}}}
\newrefformat{cha}{\savehyperref{#1}{Chapter~\ref*{#1}}}
\newrefformat{sec}{\savehyperref{#1}{Section~\ref*{#1}}}
\newrefformat{app}{\savehyperref{#1}{Appendix~\ref*{#1}}}
\newrefformat{tab}{\savehyperref{#1}{Table~\ref*{#1}}}
\newrefformat{fig}{\savehyperref{#1}{Figure~\ref*{#1}}}
\newrefformat{hyp}{\savehyperref{#1}{Hypothesis~\ref*{#1}}}
\newrefformat{alg}{\savehyperref{#1}{Algorithm~\ref*{#1}}}
\newrefformat{sdp}{\savehyperref{#1}{SDP~\ref*{#1}}}
\newrefformat{rem}{\savehyperref{#1}{Remark~\ref*{#1}}}
\newrefformat{item}{\savehyperref{#1}{Item~\ref*{#1}}}
\newrefformat{step}{\savehyperref{#1}{step~\ref*{#1}}}
\newrefformat{conj}{\savehyperref{#1}{Conjecture~\ref*{#1}}}
\newrefformat{fact}{\savehyperref{#1}{Fact~\ref*{#1}}}
\newrefformat{prop}{\savehyperref{#1}{Proposition~\ref*{#1}}}
\newrefformat{claim}{\savehyperref{#1}{Claim~\ref*{#1}}}
\newrefformat{relax}{\savehyperref{#1}{Relaxation~\ref*{#1}}}
\newrefformat{red}{\savehyperref{#1}{Reduction~\ref*{#1}}}
\newrefformat{part}{\savehyperref{#1}{Part~\ref*{#1}}}
\newrefformat{prob}{\savehyperref{#1}{Problem~\ref*{#1}}}
\newrefformat{ass}{\savehyperref{#1}{Assumption~\ref*{#1}}}





\newcommand{\Sref}[1]{\hyperref[#1]{\S\ref*{#1}}}


\usepackage[varg]{txfonts}    

\renewcommand{\mathbb}{\varmathbb} 



\renewcommand{\leq}{\leqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\ge}{\geqslant}



\usepackage{bm}

\usepackage{xspace}

\usepackage[pdftex,pagebackref,colorlinks,linkcolor=blue,filecolor = blue, citecolor = blue, urlcolor  = blue]{hyperref}




\usepackage{boxedminipage}

\newenvironment{mybox}
{\center \noindent\begin{boxedminipage}{1.0\linewidth}}
{\end{boxedminipage}
\noindent
}


\newcommand{\mper}{\,.}
\newcommand{\mcom}{\,,}


\renewcommand{\vec}[1]{{\bm{#1}}}

\newcommand{\pvec}[1]{\vec{#1}'}
\newcommand{\ppvec}[1]{\vec{#1}''}
\newcommand{\tvec}[1]{{\tilde{\vec{#1}}}}

\newcommand{\paren}[1]{\left(#1 \right )}
\newcommand{\Paren}[1]{\left(#1 \right )}

\newcommand{\brac}[1]{[#1 ]}
\newcommand{\Brac}[1]{\left[#1\right]}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\Set}[1]{\left\{#1\right\}}


\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
\newcommand{\Abs}[1]{\left\lvert#1\right\rvert}

\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}

\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\Norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\fnorm}[1]{\norm{#1}_F}


\newcommand{\defeq}{\stackrel{\textup{def}}{=}}
\newcommand{\iseq}{\stackrel{\textup{?}}{=}}
\newcommand{\isgeq}{\stackrel{\textup{?}}{\geq}}
\newcommand{\isleq}{\stackrel{\textup{?}}{\leq}}
\newcommand{\vbig}{\vphantom{\bigoplus}}

\newcommand{\inprod}[1]{\left\langle #1\right\rangle}

\newcommand{\snorm}[1]{\norm{#1}^2}

\newcommand{\normt}[1]{\norm{#1}_{\scriptstyle 2}}
\newcommand{\snormt}[1]{\norm{#1}^2_2}

\newcommand{\projsymb}{\Pi}
\newcommand{\proj}[2]{\projsymb_{#1}\paren{#2}}
\newcommand{\projperp}[2]{\projsymb_{#1}^{\perp}\paren{#2}}
\newcommand{\projpar}[2]{\projsymb_{#1}^{\parallel}\paren{#2}}

\newcommand{\normo}[1]{\norm{#1}_{\scriptstyle 1}}
\newcommand{\normi}[1]{\norm{#1}_{\scriptstyle \infty}}
\newcommand{\normb}[1]{\norm{#1}_{\scriptstyle \square}}

\newcommand{\Z}{{\mathbb Z}}
\newcommand{\N}{{\mathbb Z}_{\geq 0}}
\newcommand{\R}{\mathbb R}
\newcommand{\Q}{\mathbb Q}
\newcommand{\Rnn}{\R_+}


\newcommand{\Inf}{\ensuremath{\sf{Inf}}}
\newcommand{\sdp}{{\sf SDP }}
\newcommand{\las}{\ensuremath{\sf{Lasserre}}}
\newcommand{\qp}{\mathrm{qp}}
\newcommand{\opt}{{\sf OPT}}
\newcommand{\OPT}{{\sf OPT}}
\newcommand{\lp}{{\sf LP}}
\newcommand{\LP}{{\sf LP}}
\newcommand{\val}{{\sf VAL}}
\newcommand{\cost}{{\sf cost}}
\newcommand{\csp}{{\sf CSP}}
\newcommand{\sse}{{\sf SSE}}

\newcommand{\seteq}{\mathrel{\mathop:}=}
\newcommand{\subjectto}{\text{subject to}}
\newcommand{\card}{\abs}
\newcommand{\Card}{\Abs}
\newcommand{\half}{\nfrac{1}{2}}





\newcommand{\Esymb}{\mathbb{E}}
\newcommand{\Psymb}{\mathbb{P}}
\newcommand{\Vsymb}{\mathbb{V}}
\newcommand{\Isymb}{\mathbb{I}}
\DeclareMathOperator*{\E}{\Esymb}
\DeclareMathOperator*{\Var}{{\sf Var}}
\DeclareMathOperator*{\ProbOp}{\Psymb}
\newcommand{\var}[1]{\Var \left[#1\right]}

\newcommand{\given}{\mathrel{}\middle|\mathrel{}}
\newcommand{\Given}{\given}

\newcommand{\prob}[1]{\ProbOp\Brac{#1}}
\newcommand{\Prob}[1]{\ProbOp\Brac{#1}}

\newcommand{\ex}[1]{\E\brac{#1}}
\newcommand{\Ex}[1]{\E\Brac{#1}}

\renewcommand{\Pr}[1]{\ProbOp\Brac{#1}}
\newcommand{\pr}[2]{\ProbOp_{#1}\Brac{#2}}


\newcommand{\ind}[2]{\Isymb_{#1}\brac{#2}}
\newcommand{\Ind}[1]{\Isymb\Brac{#1}}

\newcommand{\varex}[1]{\E\paren{#1}}
\newcommand{\varEx}[1]{\E\Paren{#1}}
\newcommand{\eset}{\emptyset}
\newcommand{\e}{\epsilon}

\newcommand{\super}[2]{#1^{\paren{#2}}}

\newcommand{\bits}{\{0,1\}}


\definecolor{DSgray}{cmyk}{0,0,0,0.7}
\newcommand{\Authornote}[2]{{\small\textcolor{red}{\sf{  #1: #2 }}}}
\newcommand{\Authormarginnote}[2]{\marginpar{\parbox{2cm}{\raggedright\tiny \textcolor{DSgray}{#1: #2}}}}




\newcommand{\Anote}{\Authornote{Anand}}




\let\e\varepsilon

\newcommand{\problemmacro}[1]{\texorpdfstring{\textsc{#1}}{#1}\xspace}

\newcommand{\mla}{\problemmacro{Minimum Linear Arrangement}}
\newcommand{\BalancedSeparator}{\problemmacro{Balanced Separator}}
\newcommand{\UGCexpand}{\problemmacro{Expanding Unique Games}}
\newcommand{\sparsestcut}{\problemmacro{Sparsest Cut}}
\newcommand{\smallsetexpansion}{\problemmacro{Small Set Expansion}}
\newcommand{\uniquegames}{\problemmacro{Unique Games}}






\newcommand{\cA}{\mathcal A}
\newcommand{\cB}{\mathcal B}
\newcommand{\cC}{\mathcal C}
\newcommand{\cD}{\mathcal D}
\newcommand{\cE}{\mathcal E}
\newcommand{\cF}{\mathcal F}
\newcommand{\cG}{\mathcal G} 
\newcommand{\cH}{\mathcal H} 
\newcommand{\cI}{\mathcal I} 
\newcommand{\cJ}{\mathcal J} 
\newcommand{\cK}{\mathcal K}
\newcommand{\cL}{\mathcal L}
\newcommand{\cM}{\mathcal M}
\newcommand{\cN}{\mathcal N}
\newcommand{\cO}{\mathcal O}
\newcommand{\cP}{\mathcal P}
\newcommand{\cQ}{\mathcal Q}
\newcommand{\cR}{\mathcal R}
\newcommand{\cS}{\mathcal S}
\newcommand{\cT}{\mathcal T}
\newcommand{\cU}{\mathcal U}
\newcommand{\cV}{\mathcal V}
\newcommand{\cW}{\mathcal W}
\newcommand{\cX}{\mathcal X}
\newcommand{\cY}{\mathcal Y}
\newcommand{\cZ}{\mathcal Z}

\newcommand{\bbB}{\mathbb B}
\newcommand{\bbS}{\mathbb S}
\newcommand{\bbR}{\mathbb R}
\newcommand{\bbZ}{\mathbb Z}
\newcommand{\bbI}{\mathbb I}
\newcommand{\bbQ}{\mathbb Q}
\newcommand{\bbP}{\mathbb P}
\newcommand{\bbE}{\mathbb E}

\newcommand{\sfE}{\mathsf E}


\newcommand{\Erdos}{Erd\H{o}s\xspace}
\newcommand{\Renyi}{R\'enyi\xspace}
\newcommand{\Lovasz}{Lov\'asz\xspace}
\newcommand{\Juhasz}{Juh\'asz\xspace}
\newcommand{\Bollobas}{Bollob\'as\xspace}
\newcommand{\Furedi}{F\"uredi\xspace}
\newcommand{\Komlos}{Koml\'os\xspace}
\newcommand{\Luczak}{\L uczak\xspace}
\newcommand{\Kucera}{Ku\v{c}era\xspace}
\newcommand{\Szemeredi}{Szemer\'edi\xspace}
\newcommand{\Hastad}{H{\aa}stad\xspace}







\newcommand{\etal}{et. al.}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\bigo}[1]{\bigO\left(#1\right)}
\newcommand{\tbigO}{\tilde{\mathcal{O}}}
\newcommand{\tbigo}[1]{\tbigO\left(#1\right)}
\newcommand{\tensor}{\otimes}
\newcommand{\eigvec}{{\sf v}}


\newcommand{\argmax}{{\sf argmax}}
\newcommand{\argmin}{{\sf argmin}}
\newcommand{\poly}{{\sf poly}}
\newcommand{\polylog}{{\sf polylog}}
\newcommand{\supp}{{\sf supp}}

\newcommand{\U}{\bar{u}}
\newcommand{\V}{\bar{v}}
\newcommand{\W}{\bar{w}}

\newcommand{\rank}{{\sf rank}}
\newcommand{\tk}{t_{1/k}} 

\newcommand{\yes}{\textsc{Yes}\xspace}    \newcommand{\no}{\textsc{No}\xspace}	


 \usepackage{fullpage}
\usepackage[mathscr]{euscript}

\renewcommand{\defeq}{:=}

\title{Accelerated Newton Iteration:
 Roots of Black Box Polynomials\\ and Matrix Eigenvalues}

\author{Anand Louis\thanks{Supported by the Simons Collaboration on Algorithms and Geometry.}
\\Princeton University \\alouis@princeton.edu \and 
	Santosh S. Vempala\thanks{Supported in part by NSF awards CCF-1217793 and EAGER-1555447.}
 \\ Georgia Tech \\ vempala@gatech.edu}

\newcommand{\charp}{f} 
\newcommand{\mom}{g}  

\newcommand*\diff{\mathop{}\!\mathrm{d}}
\newcommand{\dx}{{\sf dx}}
\newcommand{\tg}{\tilde{g}}
\newcommand{\ut}{u^t}
\newcommand{\tut}{\tilde{u}^t}
\newcommand{\ralsymb}{\mathscr{R}}
\newcommand{\eprime}{\e'}
\def\eps{\epsilon}

\newcommand{\ftime}[1]{\cT_{\charp}\paren{#1}}
\newcommand{\bitcomp}[1]{\cB\paren{#1}}

\date{}

\begin{document}

\begin{titlepage}

\maketitle


\begin{abstract}
We study the problem of computing the largest root of a real rooted polynomial  to within error  given only 
black box access to it, i.e., for any , the algorithm can query an oracle for the
value of , but the algorithm is not allowed access to the coefficients of . 
A folklore result for this problem is that the largest root of a polynomial can be
computed in  polynomial queries 
using the Newton iteration.
We give a simple algorithm that queries the oracle at only  points,
where  is the degree of the polynomial.
Our algorithm is based on a novel approach for accelerating the Newton method by using higher derivatives.

As a special case, we consider the problem of computing the top eigenvalue of a symmetric matrix  in  to within error  in time polynomial in the input description, i.e., the number of bits to describe the matrix and . Well-known methods such as the power iteration and Lanczos iteration incur running time  
polynomial in , while Gaussian elimination takes  bit operations.
As a corollary of our main result, 
we obtain a   bit complexity algorithm to compute
the top eigenvalue of the matrix  or to check if it is approximately PSD ().
\end{abstract}

\end{titlepage}


\section{Introduction}

Computing the roots of a polynomial is a fundamental algorithmic 
problem. 
According to the folklore Abel-Ruffini theorem,
polynomials of degree five or higher do not have any algebraic solution in general,
and the roots of polynomials can be irrational. Therefore, the roots of a polynomial
can only be computed only to some desired precision. 
The classical Newton's method (also known as the Newton-Raphson method) is an 
iterative method to compute the roots of a real rooted polynomial.
Starting with an initial upper bound  on the largest root of a polynomial
 of degree , the Newton's method recursively computes better estimates
to the largest root as follows
 
A folklore result is that after  iterations, 
 will be -close to the the largest root of the polynomial.


We study the problem of computing the largest root of a real rooted polynomial  given only 
blackbox access to it, i.e., for any , the algorithm can query an oracle for the
value of , but the algorithm is not allowed access to the coefficients of . 
This model is useful when the polynomial is represented implicitly, and each evaluation
of the polynomial is computationally expensive. An important example is the characteristic polynomial,
say , of a matrix, say ; each evaluation of  amounts to computing
the determinant of the matrix . More generally,   
equations involving determinants of polynomial matrices  fall into this category.
A slightly modified Newton's method can be used to compute the largest root of a polynomial 
using  black box queries; we review this in \prettyref{sec:Newton}.

\paragraph{Computational Model.}
The two most common ways of measuring the time complexity of an algorithm are its 
{\em arithmetic} complexity, and its {\em boolean} or {\em bit} complexity.
Arithmetic complexity counts the number of basic arithmetic operations (i.e. addition, subtraction,
multiplication, division) required to execute an algorithm, whereas boolean/bit complexity
counts the number of bit operations required to execute the algorithm.
For most algorithms for combinatorial optimization problems, these two notions of time complexity are 
roughly the same with arithmetic operations being done on -bit numbers.
However, for many numerical algorithms, they can differ vastly.
For example, 
Gaussian elimination is usually said to take  time, but this usually refers to the number of 
arithmatic operations, and if done naively, the intermediate bit complexity can be exponential in 
\cite{b66,f77}.
However, using a more careful variant of 
Gaussian elimination due to Edmonds \cite{e67}, the bit complexity is known to be  
(see also \cite{bar68,dix82,s98}). 
In this paper, we will be bounding the bit complexity of our algorithms.  


\paragraph{Matrix Eigenvalues.}
The eigenvalues of a matrix are also the roots of its characteristic polynomial.
For a matrix , with eigenvalues  let 
 denote its characteristic polynomial, i.e.,
 
We note that the algorithms for computing the roots of a polynomial are not directly useful 
for computing the eigenvalues of a matrix, as
computing the characteristic polynomial of a matrix is a computationally non-trivial task; 
the current best algorithm to compute the characteristic polynomial of a matrix 
is due to Kaltofen and Villard \cite{kv05b} achieving bit complexity . 


It is well-known that the top eigenvalue can be approximated to any desired accuracy 
 in polynomial time; indeed all  eigenvalues of an  matrix or all singular values 
of an  matrix can be 
computed; for the latter, it is common to state that the asymptotic 
time complexity is . However, this 
bound does not reflect the dependence on . Standard iterative methods for SVD 
can take time that grows polynomially with , which is undesirable.
The most popular algorithm for computing the top eigenvalue of a matrix is the 
{\em Power Iteration} algorithm \cite{mp29} having a running time
bound of , and this bound is tight when the matrix has its top few 
eigenvalues close to each other.


We seek algorithms for computing the top eigenvalue of a matrix whose running time is polynomial  
in the input description, i.e., the number of bits to describe the matrix  and 
the parameter , the latter being  bits.


\subsection{Our results}
In this paper
 we study an alternative approach, inspired by the classical Newton iteration for finding roots of polynomials. 
Applying the Newton iteration (see \prettyref{sec:Newton}), we see that the iterates converge 
within  iterations.  
Can we do better than this? Our main idea is to accelerate the Newton iteration using higher derivatives 
of the polynomial. The standard generalization 
to Householder methods via higher derivatives \cite{h70,or70} does not give any significant benefit. In \prettyref{sec:algo}, 
we give an new iteration based on higher derivatives that converges faster, 
yielding our following main result.
The complete algorithm is described in \prettyref{fig:accnewton}.
\begin{theorem}
\label{thm:poly-blackbox}
Given black-box access to a monic real rooted polynomial  of degree , an upper bound  
on the absolute value of its roots,
and an error parameter , there exists a deterministic algorithm that queries 
at  locations, 
each having precision  bits, 
and outputs an  satisfying
,
where  is the largest root of . 
\end{theorem}

Computing the determinant of an integer matrix has asymptotic bit complexity 
 for any integer matrix  \cite{s05}. 
Using this determinant algorithm as a black box,
we get the following result for computing the eigenvalues of matrices.
\begin{theorem}
\label{thm:main}
Given a symmetric matrix , and a
parameter , there exists a Las Vegas algorithm having bit complexity 
 
that outputs an  satisfying
,
where  is the largest eigenvalue of . 
\end{theorem}
A closely related problem is that of determining whether a given matrix is PSD. This 
problem arises naturally in the context of solving SDPs. \prettyref{thm:main} yields
an algorithm to check if a matrix is PSD.
\begin{corollary}[Corollary to \prettyref{thm:main}]
Given a symmetric matrix , and a
parameter , there exists a Las Vegas algorithm having bit complexity 
 
to check if .
\end{corollary}



\subsection{Related work}
A folklore result about the Newton's iteration is that it has quadratic local convergence, i.e.,
 if the initial estimate  is ``close'' to a root  of the function , 
then  is roughly .  
Kou \etal \cite{klw06} gave a modification to the Newton's method that has local cubic convergence.
Gerlach \cite{g94} (see also \cite{fp96,kkz97,kg00}) gave a way to modify the function  
to obtain a function  (where  is a parameter) such that 
the Newton's Method applied to  will yield local convergence of order 
(the complexity of the computation of  increases with ).
Ezquerro and Hern\'{a}ndez \cite{eh99}, and 
Guti{\'e}rrez and Hern\'{a}ndez \cite{gh01} gave an acceleration of the Newton's method 
based on the convexity of the function.
Many other modifications of the Newton's method have been explored in the literature,
for e.g. see \cite{ow08,lr08}, etc. None of these improve the asymptotic worst-case complexity of root-finding.


\paragraph{Explicit polynomials.} A related problem is to compute the roots of an explicit polynomial of degree , say , to within error .
Pan \cite{p96} gave an algorithm to compute all the roots of an explicit polynomial
using  arithmetic operations;
the bit complexity of this algorithm is bounded by .  
We refer the reader to a survey by Pan \cite{p97} for a comprehensive discussion on 
algorithmic results for this problem.
We note that this model is different from the blackbox model that we study;
in the blackbox model of a polynomial , the algorithm can query an oracle for the
value of  for any , but the algorithm is not allowed access to the coefficients of . 

\paragraph{Other Iterations.}
The most popular algorithm for computing the top eigenvalue of a matrix is the 
{\em Power Iteration} algorithm \cite{mp29}, where for a symmetric matrix ,
we start with a random vector  and recursively define  as
 
It is easy to show that  converges to the eigenvector corresponding the , the largest 
eigenvalue of , and after  iterations, the Raleigh 
quotient\footnote{The Rayleigh quotient of a vector  w.r.t. a matrix  is defined as 
 } 
of   is an -approximation to . Therefore, this gives a running time
bound of , and this bound is tight when the matrix has its top few 
eigenvalues close to each other. 
Other methods such as the the Jacobi Method \cite{r71}, the Householder method \cite{h70}, etc. 
have worst case running time , whereas methods such as 
{\em Lanczos} algorithm \cite{l50}, the {\em Arnoldi iteration} \cite{a51}, etc.
have a polynomial dependance on  in the running time.
We refer the reader to \cite{ptvf92} for a comprehensive discussion.

\paragraph{Matrix Eigenvalues.}
An algorithm for computing the largest eigenvalue of a matrix 
can be obtained by checking {\em PSDness} of a sequence of matrices, namely, a binary search 
for  s.t.  is PSD. Checking whether a matrix is PSD can be done using Gaussian elimination 
in  bit operations \cite{e67}.

Algorithms due to \cite{pc99} (see also \cite{nh13}) compute all the eigenvalues of a matrix
in  arithmetic operations. \cite{ddh07} gave an algorithm to compute the eigenvalues
in  arithmetic operations.
Independently and concurrently, Ben-Or and Eldar \cite{be15} gave an algorithm
having boolean complexity  for any ,  
to compute all the eigenvalues of a matrix.
Faster methods are known for special matrices 
such as diagonally dominant matrices (of which Laplacians are an important special case), but their dependence 
on  is again polynomial \cite{v13}. 





\subsection{Preliminaries}
\label{sec:simpleass}
\begin{assumption}
\label{ass:root1}
Given a real rooted polynomial  of degree  and an upper bound  on the absolute value of its roots, 
the roots of the polynomial  lie in 
and the roots of the polynomial  lie in . 
Therefore, we can assume without loss of generality that the given polynomial has all its roots in the 
range .
Similarly, for a symmetric matrix , . 
Note that in both these cases, we will need to scale the error parameter  accordingly;
since our algorithms will only have a logarithmic dependance on , this scaling
will not be a problem.
\end{assumption}




\paragraph{Notation.}
We will use  to denote the characteristic polynomial of a matrix ;
we will drop the subscript  whenever the matrix is clear from the context.
For an , we use  to denote the bit complexity of , i.e., the number of 
bits need to represent . 
For a function , we use  to denote  for absolute constants .
For a function , we use  to denote its  derivative w.r.t. . 

\section{The basic Newton iteration}
\label{sec:Newton}
For finding the root of a polynomial function , the basic Newton iteration is the following:
initialize , 
and then

If , then this iteration maintains  and 
reduces  by a factor of at least  from the following observation.
\begin{proposition}
For any , the Newton iterate  satisfies  and 

\end{proposition}
\begin{proof}
Since  we have

\end{proof}
Along with the next elementary lemma, we get a bound of  on the number of iterations
needed for  to be  close to . 
\begin{lemma}
\label{lem:noofits1}
Let  be iterates satisfying  and  

Then for all , we have 

\end{lemma}

\begin{proof}
Suppose the condition is satisfied. Then, 

Therefore,

Hence, for all , we have  

\end{proof}

This leaves the task of computing . We can simply use the 
approximation  for a suitably small
. Thus the modified iteration which only needs evaluation of  (i.e., determinant computations
when  is the characteristic polynomial of a matrix), 
is the following: initialize , and then 

with .
 
When  is the characteristic polynomial of a matrix , 
evaluation of  reduces to computing  which can be done 
using \prettyref{thm:fast-determinant}. This gives an 
overall bit complexity of  for computing the top eigenvalue.


\section{Accelerating the Newton iteration}
\label{sec:algo}

To see the main idea, consider the following family of functions.
For any , define 

We define the 'th order iteration to be 
\begin{mybox}

\end{mybox}

Note that  and for  we get the Newton iteration, as .
Viewing the  as the 'th moment of the vector 
, we can use the following basic norm inequality.

\begin{lemma}
\label{lem:knorm}
For any vector ,

\end{lemma}
\begin{proof}
Using Holder's Inequality, we get 

By the monotonicity of norms, we have
. 
Therefore,

Next,

\end{proof}

The lemma implies that the distance to  shrinks by a factor of  in 
each iteration, thereby needing only  iterations in total. 

This brings us to question of how to implement the iteration, i.e., how to 
compute ? We first note that these can be rewritten in terms of higher
 derivatives of the polynomial. Let  be the 'th derivative of .
\begin{lemma}
\label{lem:momprime}
For any ,

 
\end{lemma}

\begin{proof}

The second part is similar.
\end{proof}

Therefore the iteration \prettyref{eq:kth-order} is simply a ratio of higher derivatives of the polynomial. 
In the complete algorithm below (\prettyref{fig:accnewton}), which only needs evaluations of , 
we approximate  using finite differences. The folklore finite difference method says that for any
function , its  derivative can be estimated using  

for small enough .
We prove this rigorously in our setting in \prettyref{lem:approx-der}.




\begin{figure}[ht]
\begin{tabularx}{\columnwidth}{|X|}
\hline
\begin{algorithm}[Higher-order Newton Iteration]
\label{alg:faster-newton}~

{\bf Input:}  
A real rooted monic polynomial  of degree  such that all its roots lie in  (\prettyref{ass:root1}),
error parameter , iteration depth . 

{\bf Output:} A real number  satisfying , 
	where  is the largest root of .

\begin{enumerate}
\item 
\label{step:deltainit}
Initialize , 


\item Repeat for  to  iterations:
	\begin{enumerate}
		\item Compute  as follows.
		
		and
		
		\item 
		\label{step:faster-newton-update}
		Compute the update
		
				
		\item  \label{step:stop}
		If  , then {\sf Stop} and output .
		\item \label{step:update} 
		If , then round down  to an accuracy of  to get  and
		set .
	\end{enumerate}
\item Output . \label{step:endofalg}
\end{enumerate}

\end{algorithm}
\\
\hline 
\end{tabularx}
\caption{The Accelerated Newton Algorithm}
\label{fig:accnewton}
\end{figure}

\paragraph{Discussion.}
While it is desirable for  to be very close to , 
for  to be a good approximation of , we need  and  to be
sufficiently smaller than . Equivalently, we need a way to detect when  
 gets ``very close'' to ; \prettyref{step:stop} does this for us 
(\prettyref{lem:noofits2}). 
We also want to keep the bit complexity of  bounded; 
\prettyref{step:update} ensures this by retaining only a small number of the most significant bits
of .


The analysis of the algorithm can be summarised as follows. 
\begin{theorem}
\label{thm:analysis}
Given a monic real rooted polynomial  of degree , having all its roots in
, \prettyref{alg:faster-newton}
outputs a  satisfying

while evaluating  at  locations on .
Moreover, given access to a blackbox subroutine to evaluate  which runs in 
time \footnote{We assume that  for absolute constants , and that
  if .}
 ,
\prettyref{alg:faster-newton} has overall time complexity
.
\end{theorem}



\subsection{Analysis}

We start with a simple fact about the derivaties of polynomials.
\begin{fact}
\label{fact:charpderivative}
For a degree  polynomial , and for , 
, we have

\end{fact}

\begin{proof}
We prove this by induction on . 
For , this is true.  
We assume that this statement holds for  (), and show that it holds for .

\end{proof}

Next, we analyze .
\begin{lemma}
\label{lem:tg1}
For , 
 defined in \prettyref{alg:faster-newton} satisfies 
.
\end{lemma}

\begin{proof}


Using  for brevity,

Since all the roots of  are in  and , 
we have. Therefore,  

Next, since ,  

Therefore,  .

\end{proof}



The crux of the analysis is to show that  is ``close'' to .
This is summarised by the following lemma. 
\begin{lemma}[Main Technical Lemma]
\label{lem:approx-der}
For , 
 defined in \prettyref{alg:faster-newton} satisfies
 
\end{lemma}


\begin{proof}
We first bound the quantity  defined as follows.

Using  for brevity,  

Next, using \prettyref{lem:tg1} and \prettyref{eq:tgdef}, we have 







\end{proof}

\begin{fact}
\label{fact:sjseries}
For ,   

\end{fact}

\begin{proof}
Define the polynomial  to be

Then,

Now, for ,  will be a factor of the polynomial in \prettyref{eq:Sjdifferentiation}.
Therefore,   for .
For , out of the  terms of  in \prettyref{eq:Sjdifferentiation}, the only term that does not have
a multiple of  is . Therefore, .
\end{proof}

Next we show that the update step in \prettyref{alg:faster-newton} (\prettyref{step:faster-newton-update})
makes sufficient progress in each iteration.

\begin{lemma}
\label{lem:noofits2}
For ,

\end{lemma}


\begin{proof}
We first prove the upper bound.

Here, the first inequality uses \prettyref{lem:approx-der}  
and the second inequality uses \prettyref{lem:knorm}
with the vector .
Next,

Here again, the first inequality uses \prettyref{lem:approx-der} 
and the second inequality uses \prettyref{lem:knorm}
with the vector .

\end{proof}


\paragraph{Putting it together.}
We now have all the ingredients to prove \prettyref{thm:analysis}. \prettyref{thm:main}
follows from \prettyref{thm:analysis} by picking .
\begin{proof}[Proof of \prettyref{thm:analysis}]
We first analyze the output guarantees of \prettyref{alg:faster-newton}, and then we bound its bit complexity. 

\paragraph{Invariants and Output Guarantees.}
W.l.o.g., we may assume that .
We will assume that , and show that if the algorithm does not
stop in this iteration, then , thereby justifying our assumption.

Since we do \prettyref{step:update} only when , we get using \prettyref{lem:noofits2} 
that 

Using \prettyref{lem:noofits1},  we get that for some iteration 
 of \prettyref{alg:faster-newton}, 
we will have .
Therefore, if the algorithm does not stop at \prettyref{step:stop}, and 
terminates at \prettyref{step:endofalg}, the  output by the algorithm
will satisfy .
If the algorithm does stop at \prettyref{step:stop}, i.e., 
, then from \prettyref{lem:noofits2} we get

Therefore, in both these cases, the algorithm outputs a  satisfying 
.

Next, if the algorithm does not stop in \prettyref{step:stop}, then we get from
\prettyref{lem:noofits2} that  

and since ,  

Therefore, if we do not stop in interation , then we ensure that  
.

\paragraph{Bit Complexity.}
We now bound the number of bit operations performed by the algorithm. 
We will show by induction on  that the bit complexity of each  is 

We will assume that . We use this to
bound the number of bit operations performed in each step of \prettyref{alg:faster-newton} 
and to show that .


Each computation of  involves two computations of 
and one division by . The bit complexity of the locations at which 
 is computed can be upper bounded by 

From our assumption that , 
and that , 
we get that 
the bit complexity of each of these  computations can be bounded by
.
Since, division can be done in nearly linear time \cite{ss71},
the bit complexity of the computation of  is 
.

The computation of the  involves  computations of  and
one division by ,
and therefore can be done using  bit operations.
Next, the computation of  involves computing the ratio of  and ,  
both of which have bit complexity . 
Therefore,  can be computed in 
bit operations \cite{ss71}.
Finally, since , we get that 
.
For our choice of parameters


Finally, since the number of iterations in the algorithm is at most ,
the overall query complexity of the algorithm is , 
and the overall bit complexity (running time) is 

\end{proof}






\subsection{Computing the top eigenvalue of a matrix}
\label{sec:matrix}

Our algorithm (\prettyref{thm:main}) uses an algorithm the compute the determinant of a matrix as a
subroutine.
Computing the determinant of a matrix has many applications in theoretical computer science
and is a well studied problem. We refer the reader to \cite{kv04} for a survey.
The algorithm for computing the determinant of a matrix with the current fastest asymptotic running time 
is due to Storjohann \cite{s05}.
\begin{theorem}[\cite{s05}]
\label{thm:fast-determinant}
Let . There exists a Las Vegas algorithm that computes 
using an expected number of  bit operations.
\end{theorem}

\begin{proof}[Proof of \prettyref{thm:main}]
Using \prettyref{thm:fast-determinant}, each computation of  can be done in time  

Using \prettyref{thm:analysis} with , the overall bit complexity (running time) of \prettyref{alg:faster-newton} is 

\end{proof}

\paragraph{Acknowledgement.} We are grateful to Ryan O' Donnell for helpful discussions, 
and to Yin Tat Lee, Prasad Raghavendra, Aaron Schild and Aaron Sidford for pointing us to the 
finite difference method for approximating higher derivatives efficiently. 

\bibliography{bibfile,bibfileacm}
\bibliographystyle{amsalpha}
\end{document}
