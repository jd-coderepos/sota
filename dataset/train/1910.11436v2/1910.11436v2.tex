\documentclass[journal]{IEEEtran}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{amssymb,amsmath,amsthm,array,amsfonts}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{underoverlap}
\usepackage{subfigure}
\usepackage{multirow} 
\usepackage[rightcaption]{sidecap}
\sidecaptionvpos{figure}{c}
\usepackage{balance}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}




\def\x{{\mathbf x}}
\def\y{{\mathbf y}}
\def\z{{\mathbf z}}
\def\c{{\mathbf c}}
\def\v{{\mathbf v}}
\def\u{{\mathbf u}}
\def\m{{\mathbf m}}
\def\X{{\mathbf X}}
\def\Y{{\mathbf Y}}
\def\W{{\mathbf W}}
\def\Z{{\mathbf Z}}
\def\F{{\mathbf F}}
\def\P{{\mathbf P}}
\def\Q{{\mathbf Q}}
\def\U{{\mathbf U}}
\def\C{{\mathbf C}}
\def\M{{\mathbf M}}
\def\A{{\mathbf A}}
\def\L{{\mathbf L}}
\def\D{{\mathbf D}}
\def\S{{\mathbf S}}
\def\I{{\mathbf I}}
\def\R{{\mathbb R}}

\newtheorem{theorem}{Theorem}
\newcommand{\maxcut}{\texttt{\small{MAXCUT}}}
\renewcommand{\t}[1]{\tiny{#1}}
\newcommand{\argmax}{\operatornamewithlimits{arg\ max}}
\newcommand{\argmin}{\operatornamewithlimits{arg\ min}}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcommand{\filippo}[1]{\textbf{\textcolor{blue}{Filippo: #1}}}
\newcommand{\cesare}[1]{\textbf{\textcolor{red}{Cesare: #1}}}
\newcommand{\daniele}[1]{\textbf{\textcolor{orange}{Daniele: #1}}}
\newcommand{\lorenzo}[1]{\textbf{\textcolor{magenta}{Lorenzo: #1}}}

\title{Hierarchical Representation Learning in Graph Neural Networks with Node Decimation Pooling}

\author{Filippo Maria Bianchi, Daniele Grattarola, Lorenzo Livi, Cesare Alippi \thanks{*filippombianchi@gmail.com}\thanks{F. M. Bianchi is with the Dept. of Mathematics and Statistics, UiT the Arctic University of Norway and with NORCE, Norwegian Research Centre}\thanks{D. Grattarola is with the Faculty of Informatics, Universit\`a della Svizzera italiana, Switzerland}\thanks{L. Livi is with Dept.s. of Computer Science and Mathematics, University of Manitoba, Canada, and Dept. of Computer Science, University of Exeter, United Kingdom}\thanks{C. Alippi is with Faculty of Informatics, Universit\`a della Svizzera italiana, Switzerland, and Dept. of Electronics, Information, and Bioengineering, Politecnico di Milano, Italy}}

\markboth{}{Bianchi \MakeLowercase{\textit{et al.}}: Hierarchical Representation Learning in Graph Neural Networks with Node Decimation Pooling}

\begin{document}

\maketitle

\begin{abstract}
In graph neural networks (GNNs), pooling operators compute local summaries of input graphs to capture their global properties, and they are fundamental for building deep GNNs that learn hierarchical representations. 
In this work, we propose the Node Decimation Pooling (NDP), a pooling operator for GNNs that generates coarser graphs while preserving the overall graph topology. 
During training, the GNN learns new node representations and fits them to a pyramid of coarsened graphs, which is computed offline in a pre-processing stage.

NDP consists of three steps. 
First, a node decimation procedure selects the nodes belonging to one side of the partition identified by a spectral algorithm that approximates the \maxcut{} solution.
Afterwards, the selected nodes are connected with Kron reduction to form the coarsened graph.
Finally, since the resulting graph is very dense, we apply a sparsification procedure that prunes the adjacency matrix of the coarsened graph to reduce the computational cost in the GNN.
Notably, we show that it is possible to remove many edges without significantly altering the graph structure.

Experimental results show that NDP is more efficient compared to state-of-the-art graph pooling operators while reaching, at the same time, competitive performance on a significant variety of graph classification tasks. 
\end{abstract}
\begin{IEEEkeywords}
Graph neural networks; Graph pooling; Maxcut optimization; Kron reduction; Graph classification.
\end{IEEEkeywords}

\section{Introduction}

Generating hierarchical representations across the layers of a neural network is key to deep learning methods. This hierarchical representation is usually achieved through pooling operations, which progressively reduce the dimensionality of the inputs encouraging the network to learn high-level data descriptors.
Graph Neural Networks (GNNs) are machine learning models that learn abstract representations of graph-structured data to solve a large variety of inference tasks~\cite{7974879, zhang2019depth, bai2019learning, bai2019deep, zhang2018end}.
Differently from neural networks that process vectors, images, or sequences, the graphs processed by GNNs have an arbitrary topology. 
As a consequence, standard pooling operations that leverage on the regular structure of the data and physical locality principles cannot be immediately applied to GNNs. 

Graph pooling aggregates vertex features while reducing, at the same time, the underlying structure in order to maintain a meaningful connectivity in the coarsened graph. 
By alternating graph pooling and message-passing (MP) operations~\cite{gilmer2017neural}, a GNN can gradually distill global properties from the graph, which are then used in tasks such as graph classification.


In this paper, we propose \textit{Node Decimation Pooling} (NDP), a pooling operator for GNNs. 
NDP is based on node decimation, a procedure developed in the field of graph signal processing for the design of multi-scale graph filters~\cite{tremblay2018design}.
In particular, we build upon the \textit{multi-resolution} framework~\cite{shuman2016multiscale} that consists of removing some nodes from a graph and then building a coarsened graph from the remaining ones.
The NDP procedure that we propose pre-computes off-line (\textit{i.e.}, before training) a \textit{pyramid} of coarsened graphs, which are then used as support for the node representations computed at different levels of the GNN architecture.

The contributions of our work are the following.

\begin{enumerate}
    \item We introduce the NDP operator that allows to implement deep GNNs that have a low complexity (in terms of execution time and memory requirements) and achieve high accuracy on several downstream tasks.
    \item We propose a simple and efficient spectral algorithm that partitions the graph nodes in two sets by maximizing a \maxcut{} objective. Such a partition is exploited to select the nodes to be discarded when coarsening the graph.
    \item We propose a graph sparsification procedure that reduces the computational cost of MP operations applied after pooling and has a small impact on the representations learned by the GNN. 
    In particular, we show both analytically and empirically that many edges can be removed without significantly altering the graph structure.
\end{enumerate}

When compared to other methods for graph pooling, NDP performs significantly better than other techniques that pre-compute the topology of the coarsened graphs, while it achieves a comparable performance with respect to state-of-the-art \textit{feature-based} pooling methods.
The latter, learn both the topology and the features of the coarsened graphs end-to-end via gradient descent, at the cost of a larger model complexity and higher training time.
The efficiency of NDP brings a significant advantage when GNNs are deployed in real-world scenarios subject to computational constraints, like in embedded devices and sensor networks.

The paper is organized as follows: in Sect.~\ref{sec:preliminaries}, we formalize the problem and introduce the nomenclature; in Sect.~\ref{sec:method}, we present the proposed method; Sect.~\ref{sec:analysis} provides formal analyses and implementation details; related works are discussed in Sect.~\ref{sec:related_work}, and Sect.~\ref{sec:experiments} reports experimental results.
Further results and analyses are deferred to the supplementary material.

\section{Preliminaries}
\label{sec:preliminaries}
Let  be a graph with node set , , and edge set  described by a symmetric adjacency matrix . 
Define as \textit{graph signal}  the matrix containing the features of the nodes in the graph (the -th row of  corresponds with the features  of the -th node).
For simplicity, we will only consider undirected graphs without edge annotations. 

Let  be the Laplacian of the graph, where  is a diagonal degree matrix s.t.\  is the degree of node .
We also define the symmetric Laplacian as .
The Laplacian characterizes the dynamics of a diffusion process on the graph and plays a fundamental role in the proposed graph reduction procedure. 
We note that in the presence of directed edges it is still possible to obtain a symmetric and positive-semidefinite Laplacian~\cite{chung2005laplacians, sandryhaila2013discrete} for which the derivations presented in this paper hold.

We consider a GNN composed of a stack of MP layers, each one followed by a graph pooling operation.
The -th pooling operation reduces  nodes to , producing a pooled version of the node features  and adjacency matrix  (see Fig.~\ref{fig:lap_pyramid}).
To implement the MP layer, we consider a simple formulation that operates on the first-order neighbourhood of each node and accounts for the original node features through a separate set of weights acting as a layer-wise skip connection. 
The computation carried out by the -th MP layer is given by

where  are the trainable weights relative to the mixing and skip component of the layer, respectively. 
Several other types of MP (\textit{e.g.}, those proposed in \cite{defferrard2016convolutional, kipf2016semi, velickovic2017graph, bianchi2019graph, xu2018powerful, hamilton2017inductive}) can seamlessly be used in conjunction with NDP pooling.
In the presence of annotated edges, the MP operation can be extended by following \cite{simonovsky2017dynamic} and \cite{schlichtkrull2018modeling}.

\section{Graph coarsening with Node Decimation Pooling}
\label{sec:method}

In this section, we describe the proposed NDP operation that consists of the three steps depicted in Fig.~\ref{fig:schema}: 
(a) decimate the nodes by dropping one of the two sides of the \maxcut{} partition; 
(b) connect the remaining nodes with a \textit{link construction} procedure; 
(c) sparsify the adjacency matrix resulting from the coarsened Laplacian, so that only \textit{strong} connections are kept, \textit{i.e.}, those edges whose weight is associated to an entry of the adjacency matrix above a given threshold .
\begin{figure*}[!ht]
    \centering
    \includegraphics[keepaspectratio,width=\textwidth]{figs/decimation_pooling_schema.pdf}    
    \caption{Depiction of the proposed graph coarsening procedure. 
    First, the nodes are partitioned in two sets according to a \maxcut{} objective and then are decimated by dropping one of the two sets (). Then, a coarsened Laplacian is built by connecting the remaining nodes with a graph reduction procedure. 
    Finally, the edges with low weights in the new adjacency matrix obtained from the coarsened Laplacian are dropped to make the resulting graph sparser.}
    \label{fig:schema}
\end{figure*}
The proposed method is completely unsupervised and the coarsened graphs are pre-computed before training the GNN.


\subsection{Node decimation with MAXCUT spectral partitioning}
\label{sec:maxcut}

Similarly to pooling operations in Convolutional Neural Networks (CNNs) that compute local summaries of neighboring pixels, we propose a pooling procedure that provides an effective coverage of the whole graph and reduces the number of nodes approximately by a factor of 2.
This can be achieved by partitioning nodes in two sets, so that nodes in one set are strongly connected to the complement nodes of the partition, and then dropping one of the two sets.
The rationale is that strongly connected nodes exchange a lot of information after a MP operation and, as a result, they are highly dependent and their features become similar.
Therefore, one set alone can represent the whole graph sufficiently well.
This is similar to pooling in CNNs, where the maximum or the average is extracted from a small patch of neighboring pixels, which are assumed to be highly correlated and contain similar information.
In the following, we formalize the problem of finding the optimal subset of vertices that can be used to represent the whole graph.

The partition of the vertices (a cut) that maximizes the volume of edges whose endpoints are on opposite sides of the partition is the solution of the \maxcut{} problem~\cite{palagi2012computational}.
The \maxcut{} objective is expressed by the integer quadratic problem

where  is the vector containing the optimization variables  for  indicating to which side of the bi-partition the node  is assigned to;  is the entry at row  and column  of .
Problem \eqref{eq:maxcut} is NP-hard and heuristics must be considered to solve it.
The heuristic that gives the best-known \maxcut{} approximation in polynomial time is the Goemans-Williamson algorithm, which is based on the Semi-Definite Programming (SDP) relaxation~\cite{goemans1995improved}.
Solving SDP is cumbersome and requires specific optimization programs that scale poorly on large graphs.
Therefore, we hereby propose a simple algorithm based on the Laplacian spectrum.

First, we rewrite the objective function in \eqref{eq:maxcut} as a quadratic form of the graph Laplacian:


Then, we consider a continuous relaxation of the integer problem \eqref{eq:maxcut} by letting the discrete partition vector  assume continuous values, contained in a vector :


Eq.~\ref{eq:relaxed} can be solved by considering the Lagrangian  to find the maximum of  under constraint . 
By setting the gradient of the Lagrangian to zero, we recover the eigenvalue equation .
All the eigenvalues of  are non-negative and, by restricting the space of feasible solutions to vectors of unitary norm, the trivial solution  is excluded.
In particular, if ,  is a Rayleigh quotient and reaches its maximum  (the largest eigenvalue of ) when  corresponds to , the eigenvector associated with .

Since the components of  are real, we apply a rounding procedure to find a discrete solution.
Specifically, we are looking for a partition , where  is the set of all feasible cuts, so that  is the closest (in a least-square sense) to .
This amounts to solving the problem

with the optimum given by




By means of the rounding procedure in \eqref{eq:partition_vec}, the nodes in  are partitioned in two sets,  and , such that

In the NDP algorithm we always drop the nodes in , \textit{i.e.}, the nodes associated with a negative value in . 
However, it would be equivalent to drop the nodes in .
The node decimation procedure offers two important advantages: 
i) it removes approximately half of the nodes when applied, \textit{i.e.}, ; 
ii) the eigenvector  can be quickly computed with the power method~\cite{bianchi2017agent}.

There exists an analogy between the proposed spectral algorithm for partitioning the graph nodes and spectral clustering~\cite{von2007tutorial}.
However, spectral clustering solves a \texttt{\small{minCUT}} problem~\cite{shi2000normalized, icml2020_1614}, which is somehow orthogonal to the \maxcut{} problem considered here.
In particular, spectral clustering identifies  clusters of densely connected nodes by cutting the smallest volume of edges in the graph, while our algorithm cuts the largest volume of edges yielding two sets of nodes,  and , that cover the original graph in a similar way.
Moreover, spectral clustering partitions the nodes in  clusters based on the values of the eigenvectors associated with the  smallest eigenvalues, while our algorithm partitions the nodes in two sets based only on the last eigenvector .

\subsection{Links construction on the coarsened graph}
\label{sec:links_construction}
After dropping nodes in  and all their incident edges, the resulting graph is likely to be disconnected.
Therefore, we use a link construction procedure to obtain a connected graph supported by the nodes in .
Specifically, we adopt the Kron reduction~\cite{kron_red} to generate a new Laplacian , which is computed as the Schur complement of  with respect to the nodes in .
In detail, the reduced Laplacian  is

where  identifies a sub-matrix of  with rows (columns) corresponding to the nodes in  ().

It is possible to show that  is always invertible if the associated adjacency matrix  is \textit{irreducible}.
We note that  is irreducible when the graph is not disconnected (\textit{i.e.}, has a single component), a property that holds when the algebraic multiplicity of the eigenvalue  is 1.

Let us consider the case where  has no self loops.
The Laplacian is by definition a weakly diagonally dominant matrix, since  for all . 
If  is irreducible, then  is also irreducible. 
This implies that the strict inequality  holds for at least one vertex . 
It follows that the Kron-reduced Laplacian  is also irreducible, diagonally dominant, and has at least one row with a strictly positive row sum. Hence,  is invertible, as proven by~\cite{horn2012matrix} in Corollary 6.2.27.
When  contains self-loops, the existence of the inverse of  is still guaranteed through a small work-around, which is discussed in App.~\ref{sec:kron_loops}.
Finally, if the graph is disconnected then  is reducible (\textit{i.e.}, it can be expressed in an upper-triangular block form by simultaneous row/column permutations); in this case, the Kron reduction can be computed by means of the generalized inverse  and the solution corresponds to a generalized Schur complement of .

 in \eqref{eq:kron} is a well-defined Laplacian where two nodes are connected if and only if there is a path between them in  (connectivity preservation property). 
Also,  does not introduce self-loops and guarantees the preservation of resistance distance~\cite{shuman2016multiscale}.
Finally, Kron reduction guarantees spectral interlacing between the original Laplacian  and the new coarsened one , with .
Specifically, we have , , where  and  are the eigenvalues of  and , respectively.

The adjacency matrix of the new coarsened graph is recovered from the coarsened Laplacian: 


We note that  does not contain self-loops;
we refer to App.~\ref{sec:kron_loops} for a discussion on how to handle the case with self-loops in the original adjacency matrix.

A pyramid of coarsened Laplacians is generated by recursively applying node decimation followed by Kron reduction. 
At the end of the procedure, the adjacency matrices  of the coarsened graphs are derived from the associated coarsened Laplacians.
Note that we interchangeably refer with  or  to the original adjacency matrix.
The adjacency matrices in  are used to implement hierarchical pooling in deep GNN architectures.



\subsection{Graph sparsification}
\label{sec:sparsify}

To implement multiple pooling operations the graph must be coarsened several times.
Due to the connectivity preservation property, by repeatedly applying Kron reduction the graph eventually becomes fully-connected.
This implies a high computational burden in deeper layers of the network, since the complexity of MP operations scales with the number of edges.

To address this issue, it is possible to apply the spectral sparsification algorithm proposed in~\cite{batson2013spectral} to obtain a sparser graph. However, we found that this procedure leads to numerical instability and poor convergence during the learning phase.
Therefore, to limit the number of edges with non-zero weights we propose a sparsification procedure that removes from the adjacency matrix of the coarsened graph the edges whose weight is below a small user-defined threshold :




\subsection{Pooling with decimation matrices.}
\label{sec:pooling_matrices}

To pool the node features with a differentiable operation that can be applied while training the GNN, we multiply the graph signal  with a \textit{decimation matrix} .
 is obtained by selecting from the identity matrix  the rows corresponding to the vertices in :


As discussed in Sec.~\ref{sec:maxcut}, NDP approximately halves the the nodes of the current graph at each pooling stage.
This is a consequence of the \maxcut{} objective that splits the nodes in two sets so that the volume of edges crossing the partition, \textit{i.e.}, the edges to be cut, is maximized.
Intuitively, if one of the two sets is much smaller than the other, more edges are cut by moving some nodes to the smaller set.
For this reason, the application of a single decimation matrix  shares similarities with a classic pooling with stride 2 in CNNs.

It follows that a down-sampling ratio of  can be obtained in NDP by applying  decimation matrices in cascade.
This enables moving from level  to level  () in the pyramid of coarsened graphs.
Fig.~\ref{fig:lap_pyramid} shows an example of pooling with downsampling ratio , where the GNN performs message-passing on  right after .
\begin{figure}[!ht]
    \centering
    \includegraphics[keepaspectratio,width=.75\columnwidth]{figs/Laplacian_pyramid.pdf}    
    \caption{This example shows how it is possible to skip some MP operations on intermediate levels of the pyramid of coarsened graphs. 
    Such a procedure shares analogies with pooling with a larger stride in traditional CNNs and can be considered as a higher-order graph pooling.
    After the first MP operation on , the node features are pooled by applying in cascade 3 decimation matrices, , , and .
    Afterwards, it is possible to directly perform a MP operation on , skipping the MP operations on  and .}
    \label{fig:lap_pyramid}
\end{figure}

\section{Analysis of the graph coarsening procedure and implementation details}
\label{sec:analysis}

\subsection{Numerical precision in eigendecomposition}
\begin{figure}[!ht]
    \centering
    \includegraphics[keepaspectratio,width=\columnwidth]{figs/sbm_vmax.pdf}    
    \caption{(Left) distribution and values assumed by . (Right) distribution and values assumed by . The entries of the eigenvectors are sorted by node degree. A Stochastic Block Model graph was used in this example.}
    \label{fig:v_max}
\end{figure}
The entries of  associated with low-degree nodes assume very small values and their signs may be flipped due to numerical errors.
The partition obtained by using , i.e., the eigenvector of the symmetric Laplacian , in \eqref{eq:partition} is analytically the same.
Indeed, since , the values of the two eigenvectors are rescaled by positive numbers and, therefore, the sign of their components is the same.
However, a positive effect of the degree normalization is that the values in  associated to nodes with a low degree are amplified.

Fig.~\ref{fig:v_max} compares the values in the eigenvectors  and , computed on the same graph.
Since many values in  are concentrated around zero, partitioning the nodes according to the sign of the entries in  gives numerically unstable results.
On the other hand, since the values in  are distributed more evenly the nodes can be partitioned more precisely. 

Note that, even if the indexes of  are identified from the eigenvector of , the Kron reduction is still performed on the Laplacian .
In the supplementary material we report numerical differences in the size of the cut obtained on random graphs when using  or .

\subsection{Evaluation of the approximate \maxcut{} solution}
\label{sec:maxcut_eval}
Since computing the optimal \maxcut{} solution is NP-hard, it is generally not possible to evaluate the quality of the cut found by the proposed spectral method (Sect.~\ref{sec:maxcut}) in terms of discrepancy from the \maxcut{}.
Therefore, to assess the quality of a solution we consider the following bounds

The value  is an upper-bound of , where  is the largest eigenvalue of  and .
The lower-bound  is given by the \textit{random cut}, which uniformly assigns the nodes to the two sides of the partition.\footnote{\label{note_rc}A random cut  is, on average, at least 0.5 of the optimal cut : } 
The derivation of the upper-bound is in App.~\ref{sec:upperbound_derivation}.

To quantify the size of a cut induced by a partition vector , such as the one in \eqref{eq:partition_vec}, we introduce the function

which measures the proportion of edges cut by .
Note that  depends also on , but we keep it implicit to simplify the notation.

Let us now consider the best- and worst-case scenarios.
The best case is the bipartite graph, where the \maxcut{} is known and it cuts all the graph edges.
The partition  found by our spectral algorithm on bipartite graphs is optimal, \textit{i.e.}, .
In graphs that are close to be bipartite or, in general, that have a very sparse and regular connectivity, a large percentage of edges can be cut if the nodes are partitioned correctly.
Indeed, for these graphs the \maxcut{} is usually large and is closer to the upper-bound in \eqref{eq:inequality}.
On the other hand, in very dense graphs the \maxcut{} is smaller, as well as the gap between the upper- and lower-bound in \eqref{eq:inequality}. 
Notably, the worst-case scenario is a complete graph where is not possible to cut more than half of the edges, \textit{i.e.}, .
We note that in graphs made of a sparse regular part that is weakly connected to a large dense part, the gaps in \eqref{eq:inequality} can be arbitrarily large.

The proposed spectral algorithm is not designed to handle very dense graphs; an intuitive explanation is that  can be interpreted as the graph signal with the highest frequency, since its sign oscillates as much as possible when transiting from a node to one of its neighbors. 
While such oscillation in the sign is clearly possible on bipartite graphs, in complete graphs it is not possible to find a signal that assumes an opposite sign on neighboring nodes, because all nodes are connected with each other.
Remarkably, the solution \eqref{eq:partition_vec} found by the spectral algorithm on very dense graphs can be worse than the random cut.
A theoretical result found by Trevisan~\cite{trevisan2012max} states that a spectral algorithm, like the one we propose, is guaranteed to yield a cut larger than the random partition only when  (see App.~\ref{sec:trevisan} for details).

To illustrate how the size of the cut found by the spectral algorithm changes between the best- and worst-case scenarios, we randomly add edges to a bipartite graph until it becomes complete.
Fig.~\ref{fig:adding_edges} illustrates how the size of the cut  induced by the spectral partition  changes as more edges are added and the original structure of the graph is corrupted (blue line). The figure also reports the size of the random cut (orange line) and the \maxcut{} upper bound from Eq.~\eqref{eq:cut_size} (green line). The black line indicates the threshold from \cite{trevisan2012max}, i.e., the value of  below which the spectral cut is no longer guaranteed to be larger than the random cut.
The graph used to generate the figure is a regular grid; however, similar results hold also for other families of random graphs and are reported in the supplementary material.
\begin{figure}[!ht]
    \centering
    \includegraphics[keepaspectratio,width=.9\columnwidth]{figs_r1/grid.pdf}    
    \caption{
    Blue line: fraction of edges cut by the partition yield by the spectral algorithm. 
    Orange line: fraction of edges removed by a random cut. 
    Green line: the \maxcut{} upper bound as a function of the largest eigenvalue  of the symmetric Laplacian. 
    Black line: the threshold from \cite{trevisan2012max} indicating the value of  below which one should switch to the random cut to obtain a solution guaranteed to be \maxcut{}. 
    The x-axis indicates the density of the graph connectivity, which increases by randomly adding edges.}
    \label{fig:adding_edges}
\end{figure}


Fig.~\ref{fig:adding_edges} shows that the spectral algorithm finds a better-than-random cut even when  (i.e., when the result from \cite{trevisan2012max} does not hold), and only approaches the size of the random cut when the edge density is very high (70\%-80\%). 

Importantly, when the size of the spectral partition becomes smaller than the random partition, the upper-bound , meaning that the random cut is very close to the \maxcut{}.
To obtain a cut that is always at least as good as the random cut, we first compute the partition  as in \eqref{eq:partition_vec} and evaluate its size : if , we return a random partition instead.


We conclude by noticing that, due to the smoothing effect of MP operations, the nodes belonging to densely connected graph components are likely to have very similar representations computed by the GNN; it is, therefore, not important which of these nodes are dropped by a random cut.
The random cut in these cases not only is optimal in terms of the \maxcut{} objective, but it also introduces stochasticity that provides robustness when training the GNN model.

\subsection{Pseudocode}
\label{sec:pseudocode}

The procedure for generating the pyramid of coarsened adjacency matrices and the pooling matrices used for decimation is reported in Alg.~\ref{alg:coarsening}.
 is a list of positive integers indicating the levels in the pyramid of coarsened Laplacians that we want to compute. For instance, given levels  for a graph of  nodes, the algorithm will return the coarsened graphs with approximately , , and  nodes (in general,  for each  in ). 
Matrix  is a buffer that accumulates decimation matrices when one or more coarsening levels are skipped. 
This happens when the GNN implements high order pooling, as discussed in Sect~\ref{sec:pooling_matrices}.

\begin{algorithm}\footnotesize
\caption{Graph coarsening}
\label{alg:coarsening}
\begin{algorithmic}[1]
\REQUIRE adjacency matrix , coarsening levels , sparsification threshold 
\ENSURE coarsened adjacency matrices , decimation matrices 
\STATE , , , , 
\WHILE{}
\STATE  \label{line:pool}
\IF{}
\STATE , 
\STATE 
\ELSE
\STATE 
\ENDIF
\STATE 
\ENDWHILE
\STATE  if  and  otherwise,  
\end{algorithmic}
\end{algorithm}


Alg.~\ref{alg:pooling} shows the details of the pooling function, used in line~\ref{line:pool} of Alg.~\ref{alg:coarsening}.

\begin{algorithm}\footnotesize
\caption{ function}
\label{alg:pooling}
\begin{algorithmic}[1]
\REQUIRE adjacency matrix 
\ENSURE coarsened adjacency matrix , decimation matrix 
\STATE get   and  
\STATE compute the eigenvector  of 
\STATE partition vector  s.t.  if ,   if 
\IF{}
\STATE random sample  (random cut)
\ENDIF
\STATE , 
\STATE  (Kron reduction)
\STATE 
\STATE 
\end{algorithmic}
\end{algorithm}


\subsection{Computational cost analysis}
The most expensive operations in the NDP algorithm are i) the cost of computing the eigenvector , and ii) the cost of inverting the submatrix  within the Kron reduction.

Computing all eigenvectors has a cost , where  is the number of nodes. However, computing only the eigenvector corresponding to the largest eigenvalue is fast when using the power method \cite{watkins2004fundamentals}, which requires only few iterations (usually 5-10), each one of complexity .
The cost of inverting  is , where  is the number of nodes that are dropped. 


We notice that the coarsened graphs are pre-computed before training the GNN.
Therefore, the computational time of graph coarsening is much lower compared to training the GNN for several epochs, since each MP operation in the GNN has a cost .


\subsection{Structure of the sparsified graphs}
When applying the sparsification, the spectrum of the resulting adjacency matrix  is preserved, up to a small factor that depends on , with respect to the spectrum of .

\begin{theorem}
Let  be a matrix used to remove small values in the adjacency matrix , which is defined as

Each eigenvalue  of the sparsified adjacency matrix  is bounded by 

where  and  are eigenvalue-eigenvector pairs of .
\end{theorem}

\begin{proof}
Let  be a matrix with elements  and consider the perturbation , which modifies the eigenvalue problem  in 

where  is a small number and  a small vector, which are unknown and indicate a  perturbation on  and , respectively.
By expanding \eqref{eq:eigen_prob}, then canceling the equation  and the high order terms , one obtains



Since  is symmetric, its eigenvectors can be used as a basis to express the small vector 

where  are (small) unknown coefficients. 
Substituting \eqref{eq:basis} in \eqref{eq:expansion1} and bringing  inside the summation, gives


By considering the original eigenvalue problem that gives  and by left-multiplying each term with , \eqref{eq:expansion2} becomes

Since eigenvectors are orthogonal,  and , for , Eq. \eqref{eq:expansion3} becomes

which, in turn, gives 

as .
\end{proof}

A common way to measure the similarity of two graphs is to compare the spectrum of their Laplacians.
To extend the results of Theorem 1 to the spectra of the Laplacians  and , respectively associated with the original and sparsified adjacency matrices  and , it is necessary to consider the relationships between the eigenvalues of  and .
For a -regular graph, the relationship  links the -th eigenvalue  of  to the -th eigenvalue  of ~\cite{lutzeyer2017comparing}.
However, for a general graph it is only possible to derive a loose bound, , that depends on the maximum degree  of the graph~\cite[Lemma 2.21]{zumstein2005comparison}.

Therefore, we numerically compare the spectra of the Laplacians associated with the matrices in  and . 
In particular, Fig.~\ref{fig:spectra_diff}(\textit{top-left}) depicts the spectrum of the Laplacian associated to the original graph  (black dotted line) and the spectra , ,  of the Laplacians associated with , , and .
Fig.~\ref{fig:spectra_diff}(\textit{top-right}) depicts the spectra of the Laplacians , ,  associated with the sparsified matrices , , and .
It is possible to observe that the spectra of  and  are almost identical and therefore, to better visualize the differences, we show in Fig.~\ref{fig:spectra_diff}(\textit{bottom}) the absolute differences .
The graph used in Fig.~\ref{fig:spectra_diff} is a random sensor network and the sparsification threshold is , which is the one adopted in all our experiments.
\begin{figure}[!ht]
    \centering
    \subfigure{
        \includegraphics[width=0.48\columnwidth]{figs/spectrum_ndp_sensor.pdf}
    }\hspace{-.6cm}~
    \subfigure{
        \includegraphics[width=0.48\columnwidth]{figs/spectrum_ndp_sparsify_sensor.pdf}
    }
    \subfigure{
        \includegraphics[width=.7\columnwidth]{figs/spectrum_ndp_diff_sensor.pdf}
    }

    \caption{
    \textit{Top-left}: Spectrum of the Laplacians associated with the original adjacency  and the coarsened versions , , and  obtained with the NDP algorithm. 
    \textit{Top-right}: Spectrum of the Laplacians associated with the sparsified adjacency matrices , , and .
    \textit{Bottom}: Absolute difference between the spectra of the Laplacians.
    }
    \label{fig:spectra_diff}
\end{figure}

To quantify how much the coarsened graph changes as a function of , we consider the \emph{spectral distance} that measures a dissimilarity between the spectra of the Laplacians associated with  and ~\cite{loukas2019graph}. 
The spectral distance is computed as 

where  and  are, respectively, the  smallest non-zero eigenvalues of  and .

\begin{figure}[!ht]
	    \centering
        \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/sensor_eps.pdf}
	    \caption{In blue, the variation of spectral distance between the Laplacian  and the Laplacian , associated with the adjacency matrix  sparsified with threshold . In red, the number of edges that remain in .}
	    \label{fig:varying_eps}
\end{figure}
Fig.~\ref{fig:varying_eps} depicts in blue the variation of spectral distance between  and , as we increase the threshold  used to compute . 
The red line indicates the number of edges that remain in  after sparsification.
It is possible to see that for small increments of  the spectral distance increases linearly, while the number of edges in the graph drops exponentially.
Therefore, with a small  it is possible to discard a large amount of edges with minimal changes in the graph spectrum.

The graph used to generate Fig.~\ref{fig:varying_eps} is a sensor network; results for other types of graph are in the supplementary material.

\section{Related work on graph pooling}
\label{sec:related_work}

We discuss related work on GNN pooling by distinguishing between \textit{topological} and \textit{feature-based} pooling methods.

\paragraph{Topological pooling methods}
similarly to NDP, topological pooling methods pre-compute coarsened graphs before training based on their topology.
Topological pooling methods are usually unsupervised, as they define how to coarsen the graph outside of the learning procedure. 
The GNN is then trained to fit its node representations to these pre-determined structures.
Pre-computing graph coarsening not only makes the training much faster by avoiding to perform graph reduction at every forward pass, but it also provides a strong inductive bias that prevents degenerate solutions, such as entire graphs collapsing into a single node or entire graph sections being discarded.
This is important when dealing with small datasets or, as we show in the following section, in tasks such as graph signal classification.

The approach that is most related to NDP and that has been adopted in several GNN architectures to perform pooling~\cite{bruna2013spectral, defferrard2016convolutional, monti2017geometric, fey2018splinecnn, levie2017cayleynets}, consists of coarsening the graph with GRACLUS, a hierarchical spectral clustering algorithm~\cite{dhillon2004kernel}. 
At each level , two vertices  and  are clustered together in a new vertex .
Then, a standard pooling operation (average or max pool) is applied to compute the node feature  from  and .
This approach has several drawbacks.
First, the connectivity of the original graph is not preserved in the coarsened graphs and the spectrum of their associated Laplacians is usually not contained in the spectrum of the original Laplacian.
Second, GRACLUS pooling adds ``fake'' nodes so that they can be exactly halved at each pooling step; this not only injects noisy information in the graph signal, but also increases the computational complexity in the GNN. Finally, clustering depends on the initial ordering of the nodes, which hampers stability and reproducibility.



An alternative approach is to directly cluster the rows (or the columns) of the adjacency matrix, as done by approach proposed in~\cite{bacciu2019non}, which decomposes  in two matrices  and  using the Non-negative Matrix Factorization (NMF) .
The NMF inherently clusters the columns of  since the minimization of the NMF objective is equivalent to the objective in -means clustering~\cite{ding2005equivalence}.
In particular,  is interpreted as the cluster representatives matrix and  as a soft-cluster assignment matrix of the columns in . 
Therefore, the pooled node features and the coarsened graph can be obtained as  and , respectively.
The main drawback is that NMF does not scale well to large graphs.



\paragraph{Feature-based pooling methods}
these methods compute a coarsened version of the graph through differentiable functions, which are parametrized by weights that are optimized for the task at hand.
Differently from topological pooling, these methods account for the node features, which change as the GNN is trained.
While this gives more flexibility in adapting the coarsening on the data and the task at hand, GNNs with feature-based pooling have more parameters; as such, training is slower and more difficult.

\textit{DiffPool}~\cite{ying2018hierarchical} is a pooling method that learns differentiable soft assignments to cluster the nodes at each layer. 
DiffPool uses two MP layers in parallel: one to update the node features, and one to generate soft cluster assignments.
The original adjacency matrix acts as a prior when learning the cluster assignments, while an entropy-based regularization encourages sparsity in the cluster assignments.
The application of this method to large graphs is not practical, as the cluster assignment matrix is dense and its size is , where  is the number of nodes of the coarsened graph.

A second approach, dubbed \textit{Top-} pooling~\cite{graphunet, cangea2018towards}, learns a projection vector that is applied to each node feature to obtain a score. 
The nodes with the  highest scores are retained, while the remaining ones are dropped.
Since the top- selection is not differentiable, the scores are also used as a gating for the node features, allowing gradients to flow through the projection vector during backpropagation.
Top- is more memory efficient than DiffPool as it avoids generating cluster assignments. 
A variant proposed in~\cite{knyazev2019understanding} introduces in Top- pooling a soft attention mechanism for selecting the nodes to retain.
Another variant of Top-, called SAGPool, processes the node features with an additional MP layer before using them to compute the scores~\cite{pmlr-v97-lee19c}.



\section{Experiments}
\label{sec:experiments}

We consider two tasks on graph-structured data: graph classification and graph signal classification.
The code used in all experiments is based on the Spektral library \cite{grattarola2020graph}, and the code to replicate all experiments of this paper is publicly available at GitHub.\footnote{\url{github.com/danielegrattarola/decimation-pooling}}

\subsection{Graph classification}
In this task, the -th sample is a graph represented by the pair  which must be classified with a label .
We consider 2 synthetic datasets (\textit{Bench-easy} and \textit{Bench-hard})\footnote{\url{https://github.com/FilippoMB/Benchmark_dataset_for_graph_classification}} and 8 datasets of real-world graphs: \textit{Proteins}, \textit{Enzymes}, \textit{NCI1}, \textit{MUTAG}, \textit{Mutagenicity}, \textit{D\&D}, \textit{COLLAB}, and \textit{Reddit-Binary}.\footnote{\url{http://graphlearning.io}}
When node features  are not available, we use node degrees and clustering coefficients as a surrogate.
Moreover, we also use node labels as node features whenever they are available.

In the following, we compare NDP with GRACLUS~\cite{defferrard2016convolutional}, NMF~\cite{bacciu2019non}, DiffPool~\cite{ying2018hierarchical}, and Top-~\cite{graphunet}.
In each experiment we adopt a fixed network architecture, MP(32)-P(2)-MP(32)-P(2)-MP(32)-AvgPool-Softmax, where MP(32) stands for a MP layer as described in \eqref{eq:mp} configured with 32 hidden units and ReLU activations, P(2) is a pooling operation with stride 2, AvgPool is a global average pooling operation on all the remaining graph nodes, and Softmax indicates a dense layer with Softmax activation.
As training algorithm, we use Adam~\cite{kingma2014adam} with initial learning rate 5e-4 and L\textsubscript{2} regularization with weight 5e-4.
As an exception, for the Enzymes dataset we used MP(64). 

Additional baselines are the Weisfeiler-Lehman (WL) graph kernel~\cite{shervashidze2011weisfeiler}, a GNN with only MP layers (\textit{Flat}), and a network with only dense layers (\textit{Dense}).
The comparison with \textit{Flat} helps to understand whether pooling operations are useful for a given task.
The results obtained by \textit{Dense}, instead, help to quantify how much additional information is brought by the graph structure compared to considering the node features alone.
While recent graph kernels~\cite{yanardag2015deep, martino2019hyper, togninalli2019wasserstein} and GNN architectures~\cite{bai2020learning, jiang2019walk} could be considered as further baselines for graph classification, the focus of our analysis and discussion is on graph pooling operators and, therefore, we point the interested reader towards the referenced papers. 

To train the GNN on mini-batches of graphs with a variable number of nodes, we consider the disjoint union of the graphs in each mini-batch and train the GNN on the combined Laplacians and graph signals.
See the supplementary material for an illustration.


\bgroup
\def\arraystretch{1} \setlength\tabcolsep{1em} \begin{table*}[!ht]
\footnotesize
\centering
\caption{Graph classification accuracy. Significantly better results () are in bold.} 
\label{tab:graph_class}
\begin{tabular}{lcccccccc}
\cmidrule[1.5pt]{1-9}
\textbf{Dataset} & \textbf{WL} & \textbf{Dense} & \textbf{Flat} & \textbf{Diffpool} & \textbf{Top-}  & \textbf{GRACLUS} & \textbf{NMF} & \textbf{NDP}\\
\cmidrule[.5pt]{1-9}
Bench-easy    & 92.6 & 29.3\t{0.3} & 98.5\t{0.3} & \textbf{98.6\t{0.4}} & 82.4\t{8.9} & 97.5\t{0.5} & 97.4\t{0.8} & 97.4\t{0.9}\\ Bench-hard    & 60.0 & 29.4\t{0.3} & 67.6\t{2.8} & 69.9\t{1.9} & 42.7\t{15.2}  & 69.0\t{1.5} & 68.6\t{1.6} & \textbf{71.9\t{0.8}}\\  Proteins      & 71.2\t{2.6}  & 68.7\t{3.3} & 72.6\t{4.8} & 72.8\t{3.5} & 69.6\t{3.3} & 70.3\t{2.6} & 71.6\t{4.1} & \textbf{73.4\t{3.1}}\\ Enzymes       & 33.6\t{4.1}  & 45.7\t{9.9} & \textbf{52.0\t{12.3}} & 24.6\t{5.3} & 31.4\t{6.8} & 42.0\t{6.7} & 39.9\t{3.6} & 44.5\t{7.4}\\ NCI1          & \textbf{81.1\t{1.6}}  & 53.7\t{3.0} & 74.4\t{2.5} & 76.5\t{2.2} & 71.8\t{2.6} & 69.5\t{1.7} & 68.2\t{2.2} & 74.2\t{1.7}\\ MUTAG         & 78.9\t{13.1} & \textbf{91.1\t{7.1}} & 87.1\t{6.6} & 90.5\t{3.9} & 85.5\t{11.0} & 84.9\t{8.1} & 76.7\t{14.4} & 87.9\t{5.7}\\ Mutagenicity  & \textbf{81.7\t{1.1}}  & 68.4\t{0.3} & 78.0\t{1.3} & 77.6\t{2.7} & 71.9\t{3.7} & 74.4\t{1.8} & 75.5\t{1.7} & 77.9\t{1.4}\\ D\&D          & 78.6\t{2.7}  & 70.6\t{5.2} & 76.8\t{1.5} & \textbf{79.3\t{2.4}} & 69.4\t{7.8} & 70.5\t{4.8} & 70.6\t{4.1} & 72.8\t{5.4}\\ COLLAB        & 74.8\t{1.3}  & 79.3\t{1.6} & \textbf{82.1\t{1.8}} & 81.8\t{1.4} & 79.3\t{1.8} & 77.1\t{2.1} & 78.5\t{1.8} & 79.1\t{1.3} \\ Reddit-Binary & 68.2\t{1.7}  & 48.5\t{2.6} & 80.3\t{2.6} & 86.8\t{2.1} & 74.7\t{4.5} & 79.2\t{0.4} & 52.0\t{2.1} & \textbf{88.0\t{1.4}} \\ \cmidrule[1.5pt]{1-9}
\end{tabular}
\end{table*}
\egroup

We evaluate the model's performance by splitting the dataset in 10 folds. 
Each fold is, in turn, selected as the test set, while the remaining 9 folds become the training set.
For each different train/test split, we set aside 10\% of the training data as validation set, which is used for early stopping, i.e., we interrupt the training procedure after the loss on the validation set does not decrease for 50 epochs.

We report in Table~\ref{tab:graph_class} the test accuracy averaged over the 10 folds.
We note that no architecture outperforms every other in all tasks.
The WL kernel achieves the best results on NCI1 and Mutagenicity, but it does not perform well on the other datasets.
Interestingly, the \textit{Dense} architecture achieves the best performance on MUTAG, indicating that in this case, the connectivity of the graps does not carry useful information for the classification task.
The performance of the \textit{Flat} baseline indicates that in Enzymes and COLLAB pooling operations are not necessary to improve the classification accuracy.

NDP consistently achieves a higher accuracy compared to GRACLUS and NMF, which are also topological pooling methods.
We argue that the lower performance of GRACLUS is due to the fake nodes, which introduce noise in the graphs.
Among the two feature-based pooling methods, DiffPool always outperforms Top-.
The reason is arguably that Top- drops entire parts of the graphs, thus discarding important information for the classification~\cite{knyazev2019understanding, icml2020_1614}.

In Fig.~\ref{fig:train_time}, we report the training time for the five different pooling methods.
As expected, GNNs configured with GRACLUS, NMF, and NDP are much faster to train compared to those based on DiffPool and Top, with NDP being slightly faster than the other two topological methods.
\begin{figure*}
    \centering
    \includegraphics[keepaspectratio, width=0.9\textwidth]{figs/train_time.pdf}    
\caption{Average training time per epoch (in seconds) for different pooling methods. The bars height is in logarithmic scale. Simulations were performed with an Nvidia RTX 2080 Ti.}
    \label{fig:train_time}
\end{figure*}
In Fig.~\ref{fig:acc_vs_time}, we plot the average training time per epoch against the average accuracy obtained by each pooling method on the 10 datasets taken into account. 
The scatter plot is obtained from the data reported in Tab.~\ref{tab:graph_class} and Fig.~\ref{fig:train_time}.
On average, NDP obtains the highest classification accuracy, slightly outperforming even Diffpool, while being, at the same time, the fastest among all pooling methods.
\begin{figure}
    \centering
    \includegraphics[keepaspectratio, width=0.5\columnwidth]{figs/acc_vs_time.pdf}    
\caption{Average training time per epoch against average accuracy, computed for each pooling method over the 10 graph classification tasks.}
    \label{fig:acc_vs_time}
\end{figure}

\begin{figure}[!ht]
    \centering
    \subfigure[Original graph.]{
        \includegraphics[width=0.5\columnwidth]{figs/original.pdf}
    }\vspace{-.3cm}
    
    \subfigure[GRACLUS coarsening.]{
        \includegraphics[width=\columnwidth]{figs/graclus_coarsening.pdf}
    }\vspace{-.3cm}
    
    \subfigure[NMF coarsening.]{
        \includegraphics[width=\columnwidth]{figs/nmf_coarsening.pdf}
    }\vspace{-.3cm}
    
    \subfigure[NDP coarsening.]{
        \includegraphics[width=\columnwidth]{figs/decim_coarsening.pdf}
    }
    \caption{\footnotesize Example of coarsening on one graph from the Proteins dataset. In (a), the original adjacency matrix of the graph. In (b), (c), and (d) the edges of the Laplacians at coarsening level 0, 1, and 2, as obtained by the 3 different pooling methods GRACLUS, NMF, and the proposed NDP.}
    \label{fig:coarsening_enzymes}
\end{figure}

To understand the differences between the topological pooling methods, we randomly selected one graph from the Proteins dataset and show in Fig.~\ref{fig:coarsening_enzymes} the coarsened graphs computed by GRACLUS, NMF, and NDP.
From Fig.~\ref{fig:coarsening_enzymes}(b) we notice that the graphs  and  in GRACLUS have additional nodes that are disconnected.
As discussed in Sect.~\ref{sec:related_work}, these are the fake nodes that are added to the graph so that its size can be halved at every pooling operation.
Fig.~\ref{fig:coarsening_enzymes}(c) shows that NMF produces graphs that are very dense, as a consequence of the multiplication with the dense soft-assignment matrix to construct the coarsened graph.
Finally, Fig.~\ref{fig:coarsening_enzymes}(d) shows that NDP produces coarsened graphs that are sparse and preserve well the topology of the original graph.


\subsection{Graph signal classification}
In this task, different graph signals , defined on the same adjacency matrix , must be classified with a label .
We use the same architecture adopted for graph classification, with the only difference that each pooling operation is now implemented with stride 4: MP(32)-P(4)-MP(32)-P(4)-MP(32)-AvgPool-Softmax.
We recall that when using NDP a stride of 4 is obtained by applying two decimation matrices in cascade,  and  (\textit{cf.} Sec.~\ref{sec:pooling_matrices}).
We perform two graph signal classification experiments: image classification on MNIST and sentiment analysis on IMDB dataset.
\newline

\textbf{MNIST.} 
For this experiment, we adopt the same settings described in \cite{defferrard2016convolutional}.
To emulate a typical convolutional network operating on a regular 2D grid, an 8-NN graph is defined on the  pixels of the MNIST images, using as edge weights the following similarity score between nodes:

where  and  are the 2D coordinates of pixel  and .
The graph signal  is the -th vectorized image.

\begin{table}
\setlength\tabcolsep{.7em} \small
\bgroup
\def\arraystretch{1.25} \centering
\caption{Graph signal classification accuracy on MNIST.}
\begin{tabular}{ccccc}
\cmidrule[1.5pt]{1-5}
\textbf{DiffPool} & \textbf{Top-} & \textbf{GRACLUS} & \textbf{NMF} & \textbf{NDP} \\
\cmidrule[.5pt]{1-5}
24.00 {\tiny 0.0} & 11.00 {\tiny 0.0} & 96.21 {\tiny 0.18} & 94.15{\tiny 0.17} & \textbf{97.09 {\tiny 0.01}} \\
\cmidrule[1.5pt]{1-5}
\end{tabular}
\label{tab:mnist_res}
\egroup
\end{table}


Tab.~\ref{tab:mnist_res} reports the average results achieved over 10 independent runs by a GNN implemented with different pooling operators.
Contrarily to graph classification, DiffPool and Top fail to solve this task and achieve an accuracy comparable to random guessing. 
On the contrary, the topological pooling methods obtain an accuracy close to a classical CNN, with NDP significantly outperforming the other two techniques. 

We argue that the poor performance of the two feature-based pooling methods is attributable to 1) the low information content in the node features, and 2) a graph that has a regular structure and is connected only locally. 
This means that the graph has a very large diameter (maximum shortest path), where information propagates slowly through MP layers.
Therefore, even after MP, nodes in very different parts of the graph will end up having similar (if not identical) features, which leads feature-based pooling methods to assign them to the same cluster.
As a result the graph collapses, becoming densely connected and losing its original structure.
On the other hand, topological pooling methods can preserve the graph structure by operating on the whole adjacency matrix at once to compute the coarsened graphs and are not affected by uninformative node features.


\begin{table*}
\centering
\setlength\tabcolsep{1em} \small
\bgroup
\def\arraystretch{1.25} \caption{Graph signal classification accuracy on IMDB sentiment analysis dataset.}
\begin{tabular}{lcccccccc}
\cmidrule[1.5pt]{1-9}
\textbf{\# Words} & \textbf{Dense} & \textbf{LSTM} & \textbf{TCN} & \textbf{DiffPool} & \textbf{Top-} & \textbf{GRACLUS} & \textbf{NMF} & \textbf{NDP} \\
\cmidrule[.5pt]{1-9}
1k  & 82.65{\tiny0.01} & 86.58{\tiny0.03} & 85.61{\tiny0.14} & 50.00{\tiny0.0} & 50.00{\tiny0.0} & 85.03{\tiny0.10} & 82.51{\tiny0.11} & \textbf{85.77{\tiny0.03}} \\ 5k  & 86.26{\tiny0.03} & 86.59{\tiny0.06} & 87.42{\tiny0.09} & 50.00{\tiny0.0} & 50.00{\tiny0.0} & 87.55{\tiny0.15} & 85.66{\tiny0.11} & \textbf{87.79{\tiny0.02}}\\ 10k & 83.75{\tiny0.02} & 85.98{\tiny0.04} & 87.38{\tiny0.07} & 50.00{\tiny0.0} & 50.00{\tiny0.0} & 87.29{\tiny0.07} & OOM & \textbf{87.82{\tiny0.02}} \\ \cmidrule[1.5pt]{1-9}
\end{tabular}
\label{tab:imdb_res}
\egroup
\end{table*}


\textbf{IMDB.} 
We consider the IMDB sentiment analysis dataset of movies reviews, which must be classified as positive or negative.
We use a graph that encodes the similarity of all words in the vocabulary. 
Each graph signal represents a review and consists of a binary vector with size equal to the vocabulary, which assumes value 1 in correspondence of a word that appears at least once in the review, and 0 otherwise.

The graph is built as follows.
First, we extract a vocabulary from the most common words in the reviews.
For each review, we consider at most 256 words, padding with a special token the reviews that are shorter and truncating those that are longer.
Then, we train a simple classifier consisting of a word embedding layer~\cite{mikolov2013distributed} of size 200, followed by a dense layer with a ReLU activation, a dropout layer~\cite{srivastava2014dropout} with probability 0.5, and a dense layer with sigmoid activation. 
After training, we extract the embedding vector of each word in the vocabulary and construct a -NN graph, according to the Euclidean similarity between the embedding vectors.

As baselines, we consider the network used to generate the word embeddings (\textit{Dense}) and two more advanced architectures.
The first (\textit{LSTM}), is a network where the dense hidden layer is replaced by an LSTM layer~\cite{hochreiter1997long}, which allows capturing the temporal dependencies in the sequence of words in the review.
The other baseline (\textit{TCN}) is a network where the hidden layers are 1D convolutions with different dilation rates~\cite{oord2016wavenet}.
In particular, we used a Temporal Convolution Network~\cite{bai2018empirical} with 7 residual blocks with dilations , kernel size 6, causal padding, and dropout probability 0.3.
The results averaged over 10 runs for vocabularies of different sizes (\# Words) are reported in Tab.~\ref{tab:imdb_res}.

Similarly to the MNIST experiment, we notice that neither DiffPool nor Top are able to solve this graph signal classification task.
The reason can be once again attributed to the low information content of the individual node features and in the sparsity of the graph signal (most node features are 0), which makes it difficult for the feature-based pooling methods to infer global properties of the graph by looking at local sub-structures. 

On the other hand, NDP consistently outperforms the baselines, GRACLUS, and NMF. 
The coarsened graphs generated by NMF when the vocabulary has 10k words are too dense to fit in the memory of the GPU (Nvidia GeForce RTX 2080).
Interestingly, the GNNs configured with GRACLUS and NDP always achieve better results than the \textit{Dense} network, even if the latter generates the word embeddings used to build the graph on which the GNN operates. This can be explained by the fact that the \textit{Dense} network immediately overfits the dataset, whereas the graph structure provides a strong regularization, as the GNN combines only words that are neighboring on the vocabulary graph.  

The \textit{LSTM} baseline generally achieves a better accuracy than \textit{Dense}, since it captures the sequential ordering of the words in the reviews, which also helps to prevent overfitting on training data.
Finally, the \textit{TCN} baseline always outperforms \textit{LSTM}, both in terms of accuracy and computational costs. 
This substantiates recent findings showing that convolutional architectures may be more suitable than recurrent ones for tasks involving sequential data~\cite{bai2018empirical}.

\section{Conclusions}
\label{sec:conclusion}

We proposed Node Decimation Pooling (NDP), a pooling strategy for Graph Neural Networks that reduces a graph based on properties of its Laplacian. 
NDP partitions the nodes into two disjoint sets by optimizing a \maxcut{} objective. 
The nodes of one set are dropped, while the others are connected with Kron reduction to form a new smaller graph. 
Since Kron reduction yields dense graphs, a sparsification procedure is used to remove the weaker connections.

The algorithm we proposed to approximate the \maxcut{} solution is theoretically grounded on graph spectral theory and achieves good results while being, at the same time, simple and efficient to implement.
To evaluate the \maxcut{} solution, we considered theoretical bounds and we introduced an experimental framework to empirically assess the quality of the solution.

We demonstrated that the graph sparsification procedure proposed in this work preserves the spectrum of the graph up to an arbitrarily small constant.
In particular, we first derived an analytical relationship between the eigenvalues of the adjacency matrix of the original and sparsified graphs.
Then, we performed numerical experiments to study how much the spectrum of the graph Laplacian varies, in practice, after sparsification.

We compared NDP with two main families of pooling methods for GNNs: topological (to which NDP belongs) and feature-based methods.
NDP has advantages compared to both types of pooling. 
In particular, experimental results showed that NDP is computationally cheaper (in terms of both time and memory) than feature-based methods, while it achieves competitive performance on all the downstream tasks taken into account. 
An important finding in our results indicates that topological methods are the only viable approach in graph signal classification tasks.

\subsection*{Acknowledgments}
We are grateful to the anonymous reviewers for critically reading our manuscript and for giving us important suggestions, which allowed us to significantly improve our work.

\appendix

\subsection{Kron reduction in graph with self-loops}
\label{sec:kron_loops}
If  contains self loops, the existence of the strict inequality condition  discussed in Sec.~\ref{sec:links_construction} is no more guaranteed.
However, it is sufficient to consider the loopy-Laplacian , where  is the diagonal of , defined as .
 is now an irreducible matrix and  holds for at least least one vertex .
We notice that the adjacency matrix can be univocally recovered: .
Therefore, from the Kron reduction  of  we can first recover  and then compute the reduced Laplacian as .

\subsection{Derivation of the \maxcut{} upperbound}
\label{sec:upperbound_derivation}
Let us consider the Rayleigh quotient

which assumes its maximum value  when  is the largest eigenvector of the Laplacian .
When  is the partition vector in \eqref{eq:partition_vec}, we have .
As shown in Sect.~\ref{sec:maxcut}, the numerator in \eqref{eq:rayleigh} can be rewritten as 
, since  if  and  if  according to \eqref{eq:partition_vec}, and where  is the volume of edges crossing the partition induced by .
From \eqref{eq:partition_vec} also follows that the denominator in \eqref{eq:rayleigh} is , since .
By combining the results we obtain


When considering the symmetric Laplacian , we multiply \eqref{eq:rayleigh} on both sides by , changing the denominator into .
Replacing in \eqref{eq:N_bound}  with  and  with , we get the bound .

\subsection{Relationship with Trevisan \cite{trevisan2012max} spectral algorithm}
\label{sec:trevisan}
The main result in \cite{trevisan2012max} states that if , then there exist a set of vertices  and a partition  of  so that , where  and  are the edges with one endpoint in  and the other in . 
In cases where an optimal solution cuts  fraction of the edges, a partition found by a recursive spectral algorithm will remove  of the edges. 
The optimal  is value 0.0549 for which  reaches its minimum 0.5311. 
When the largest eigenvalue  is too small, the expected random cut is larger than the solution found by the spectral algorithm.
The analysis in \cite{trevisan2012max} shows that the spectral cut is guaranteed to be larger than the random cut only when , \textit{i.e.}, when  given the optimal value .
Therefore, an algorithm that recursively cuts a fraction of edges according to the values in  until  and then performs a random cut, finds a solution that is always  \maxcut{}. 


\bibliographystyle{IEEEtran}
\bibliography{references}

\clearpage

\onecolumn



\section*{Supplementary material}
\setcounter{subsection}{0}

\subsection{Cut size on regular and random graphs}

In the following, we consider two different types of bipartite graphs, a regular grid and a ring graph, and four classes of random graphs, which are the Stochastic Block Model (SBM), a sensor network, the Erdos-Renyi graph, and a community graph. 
A graphical representation in the node space and the adjacency matrix of one instance of each graph type is depicted in Fig.~\ref{fig:graph_types}.

\begin{figure*}[!ht]
    \centering
    \includegraphics[keepaspectratio, width=.75\textwidth]{figs_r1/graph_types.pdf} 
    \caption{Graphical representation and adjacency matrix of 2 regular graphs (\textit{Regular grid} and \textit{Ring}) and an instance of 4 random graphs (\textit{Stochastic Block Model (SBM)}, \textit{Sensor network}, \textit{Erdos-Renyi graph}, and \textit{Community graph}).}
    \label{fig:graph_types}
\end{figure*}

In Tab.~\ref{tab:cut_size} we report the size of the cut  induced by the partition , which is obtained with the proposed spectral algorithm.
We consider both the partitions obtained from the eigenvectors  and , associated with the largest eigenvalue of the Laplacian  and the symmetric Laplacian , respectively.
The values in Tab.~\ref{tab:cut_size} are the mean and standard deviation of  obtained on 50 different instances of each class.
We also report the \maxcut{} upperbound,  and the size of the cut induced by a random partition. 
\begin{table*}[!ht]
    \footnotesize
    \centering
    \caption{Size of the cut obtained with our spectral algorithm on different types of graph. Reported is the mean and standard deviation of the cut obtained from  and  on 50 instances of each graph type and the \maxcut{} upperbound, . For completeness, we show also the results obtained by the random cut.} 
    \label{tab:cut_size}
    \begin{tabular}{lcccccc}
    \cmidrule[1.5pt]{1-7}
                                & \textbf{Grid} & \textbf{Ring} & \textbf{SBM}      & \textbf{Sensor}   & \textbf{Erdos-Renyi}  & \textbf{Community} \\
    \cmidrule[.5pt]{1-7}
    \maxcut{} upperbound        & 1.0           & 1.0           & 0.630.0      & 0.770.05     & 0.670.0          & 0.890.06 \\
    Cut with     & 1.0           & 1.0           & 0.510.03     & 0.530.03     & 0.550.02         & 0.50.05 \\
    Cut with   & 1.0           & 1.0           & 0.580.01     & 0.580.02     & 0.610.0          & 0.540.04 \\
    Random cut                  & 0.50.03  & 0.50.05  & 0.50.01      & 0.510.02     & 0.50.0           & 0.50.01 \\
    \cmidrule[1.5pt]{1-7}
    \end{tabular}
\end{table*}
Consistently better performance are obtained when the partition is based on  rather than ; as discussed in Sect. IV-A, this is because many entries in  have small values that cannot be partitioned precisely according to the sign, due to numerical errors.
The results show that on the two regular graphs, which are bipartite, the cut obtained with the spectral algorithm coincides with the \maxcut{} upper bound and, therefore, also with the optimal solution.  
For every other graph, the cut yielded by the spectral algorithm is always larger than the random cut. 
We recall that in those cases the \maxcut{} is unknown and the gaps between the lower bound (0.5) and the upper bound () can be arbitrarily large.
    
    
\subsection{Spectral and random cut as a function of edge density}

\begin{figure}[!ht]
    \centering
    
    \subfigure[\footnotesize Regular grid]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/grid.pdf}
    }
    \subfigure[\footnotesize Ring graph]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/ring.pdf}
    }
    \subfigure[\footnotesize Stochastic Block Model]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/sbm.pdf}
    }

    \subfigure[\footnotesize Erdos-Renyi]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/erdos.pdf}
    }
    \subfigure[\footnotesize Sensor network]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/sensor.pdf}
    }
    \subfigure[\footnotesize Community graph]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/comm.pdf}
    }
    \caption{Blue line: fraction of edges cut by the partition yielded by the spectral algorithm. 
    Orange line: fraction of edges removed by a random cut. 
    Green line: the \maxcut{} upper bound . 
    Black line: the threshold from \cite{trevisan2012max} indicating the value of  below which one should switch to the random cut to obtain a solution  \maxcut{}. 
    The x-axis indicates the density of the graph connectivity, which increases by randomly adding edges.}
    \label{fig:adding_edges2}
\end{figure}

We replicate for each graph type the experiment in Sect. IV-B, which illustrates how the size of the cut obtained with the proposed algorithm changes as we randomly add edges.
Fig.~\ref{fig:adding_edges2} reports in blue the size of the cut associated with the partition yielded by the spectral algorithm; in orange the size of the cut yielded by the random partition; in green the \maxcut{} upper bound; in black the theoretical threshold that indicates when to switch to the random partition to obtain a cut with size  \maxcut{}.

The examples encompass the two extreme cases where the \maxcut{} solution is known: a bipartite graph where \maxcut{} is 1 and the complete graph where \maxcut{} is 0.5.
In every example, when  becomes lower than  the solution of the spectral algorithm is still larger than the cut induced by the random partition.
In fact, the spectral cut remains larger than the random cut until when the density is approximately 70-80\%.
Importantly, when the solution of the spectral algorithm become worse than the random cut, the \maxcut{} upper bound is close to 0.5.
Therefore, when the spectral cut is lower than 0.5 it is possible to return the random partition instead, which yields a nearly-optimal solution.

\subsection{Visual examples of coarsening with NDP pooling}

\begin{figure}[!pt]
    \centering
    \subfigure[\footnotesize Regular grid]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_grid.pdf}
    }
    \subfigure[\footnotesize Ring graph]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_ring.pdf}
    }
    
    \subfigure[\footnotesize Stochastic Block Model]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_sbm.pdf}
    }
    \subfigure[\footnotesize Sensor network]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_sensor.pdf}
    }
    
    \subfigure[\footnotesize Erdos-Renyi]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_erdos.pdf}
    }
    \subfigure[\footnotesize Community graph]{
    \includegraphics[keepaspectratio,width=0.47\textwidth]{figs/visualization_comm.pdf}
    }
    
    \caption{Coarsened graphs obtained with the NDP algorithm. The 3rd and 4th column show graphs sparsified with different threshold .}
    \label{fig:visualization_grid}
\end{figure}

Fig.~\ref{fig:visualization_grid} shows for the result of the NDP coarsening procedure on the 6 types of graphs.
The first column shows the subset of nodes of the original graph that are selected (, in red) and discarded (, in blue) after each pooling step.
The second column shows the coarsened graph obtained after each pooling operation.
Finally, columns 3 and 4 show the coarsened graphs after applying sparsification with different thresholds .





\subsection{Spectral similarity in sparsified graphs}

In Sec. IV-E we introduced the spectral similarity distance to quantify how much the spectrum of the Laplacian associated with the sparsified adjacency matrix changes when edges smaller than  are dropped.
In Fig.~\ref{fig:varying_eps2} we show how the graph structure (in terms of spectral similarity) varies, when the value of  increases and more edges are dropped.
In every example, for small values of  the structure of the graphs changes only slightly while a large amount of edges is dropped.
Notably, the spectral similarity increases almost linearly with , while the edge density decreases exponentially.

\begin{figure}
    \centering
    \subfigure[\footnotesize Regular grid]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/grid_eps.pdf}
    }
    ~
    \subfigure[\footnotesize Community graph]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/comm_eps.pdf}
    }
    ~
    \subfigure[\footnotesize Sensor network graph]{
    \includegraphics[keepaspectratio,width=0.3\textwidth]{figs_r1/sensor_eps.pdf}
    }
    \caption{In blue, the variation of spectral distance between the Laplacian  associated with  and the Laplacian  associated with the adjacency matrix  sparsified with a varying threshold . In red, the number of edges that remain in .}
    \label{fig:varying_eps2}
\end{figure}
	

\subsection{Mini-batch training}
Problems such as graph classification and graph regression are characterized by samples of graphs that, generally, have a variable number of vertices.
In order to apply MP and pooling operations when training a GNN on mini-batches, one solution is to perform zero-padding and obtain all graphs with  vertices, where  is the number of vertices in the largest graph of the dataset.
However, this solution is particularly inefficient in terms of memory cost, especially when there are many graphs with less than  vertices.
A more efficient solution is to build the disjoint union of the graphs in each mini-batch and train the GNN on the combined Laplacian and graph signal.
This is the solution adopted in our experiments; Fig.~\ref{fig:graph_class} reports a visualization of the procedure.

\begin{figure*}[!ht]
    \centering
    \includegraphics[keepaspectratio, width=.75\textwidth]{figs/graph_class.pdf}    
    \caption{Example of the implementation used in the graph classification task, where the GNN is fed with a disjoint union of the graphs in mini-batch. The illustration shows an example for a mini-batch of size three.}
    \label{fig:graph_class}
\end{figure*}

\subsection{Training curves}
Fig.~\ref{fig:learning} reports the evolution of the loss during training for 4 different graph classification datasets.
Notice that in our experiments we used early stopping. 
However, to provide a more extended profile of the training procedure, we show the training curves obtained when the GNN is trained for 1000 epochs on different datasets.

\begin{figure}[!ht]
    \centering
\subfigure[Bench Hard]{\includegraphics[keepaspectratio,width=0.23\textwidth]{figs_r1/bench_hard_acc.pdf}}
    ~
\subfigure[NCI1]{\includegraphics[keepaspectratio,width=0.23\textwidth]{figs_r1/NC1_acc.pdf}}
    ~
\subfigure[MUTAG]{\includegraphics[keepaspectratio,width=0.23\textwidth]{figs_r1/MUTAG_acc.pdf}}
    ~
\subfigure[Mutagenicity]{\includegraphics[keepaspectratio,width=0.23\textwidth]{figs_r1/Mutagenicity_acc.pdf}}
    
    \caption{Accuracy in training and validation over 1000 epochs on 4 different datasets. The curves are averaged over 10 runs per method and per dataset.}
    \label{fig:learning}
\end{figure}
 
\end{document}
