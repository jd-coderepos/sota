



\documentclass[11pt,a4paper]{article}
\usepackage{times,latexsym}
\usepackage{url}
\usepackage[T1]{fontenc}

\usepackage{amsmath,bm,graphicx}
\usepackage[ruled,vlined]{algorithm2e}

\def\figref#1{Fig.~\ref{#1}}
\def\tabref#1{Table~\ref{#1}}
\def\equref#1{Eq.~\ref{#1}}




\usepackage[acceptedWithA]{tacl2018v2}





\usepackage{xspace,mfirstuc,tabulary}
\newcommand{\dateOfLastUpdate}{Sept. 20, 2018}
\newcommand{\styleFileVersion}{tacl2018v2}

\newcommand{\ex}[1]{{\sf #1}}

\newif\iftaclinstructions
\taclinstructionsfalse \iftaclinstructions
\renewcommand{\confidential}{}
\renewcommand{\anonsubtext}{(No author info supplied here, for consistency with
TACL-submission anonymization requirements)}
\newcommand{\instr}
\fi

\iftaclpubformat \newcommand{\taclpaper}{final version\xspace}
\newcommand{\taclpapers}{final versions\xspace}
\newcommand{\Taclpaper}{Final version\xspace}
\newcommand{\Taclpapers}{Final versions\xspace}
\newcommand{\TaclPapers}{Final Versions\xspace}
\else
\newcommand{\taclpaper}{submission\xspace}
\newcommand{\taclpapers}{{\taclpaper}s\xspace}
\newcommand{\Taclpaper}{Submission\xspace}
\newcommand{\Taclpapers}{{\Taclpaper}s\xspace}
\newcommand{\TaclPapers}{Submissions\xspace}
\fi



\title{Nested Named Entity Recognition via \\ Second-best Sequence Learning and Decoding}


\author{\bf{Takashi Shibuya} \quad \bf{Eduard Hovy} \\
   Carnegie Mellon University, Pittsburgh, PA 15213, U.S.A. \\
   Sony Corporation, Tokyo 141-8610, Japan \\ 
  {\tt shibuyat@jp.sony.com} \quad {\tt hovy@cmu.edu} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
  When an entity name contains other names within it, the identification of all combinations of names can become difficult and expensive.   
  We propose a new method to recognize not only outermost named entities but also inner nested ones.
  We design an objective function for training a neural model that treats the tag sequence for nested entities as the second best path within the span of their parent entity.
  In addition, we provide the decoding method for inference that extracts entities iteratively from outermost ones to inner ones in an outside-to-inside way.
  Our method has no additional hyperparameters to the conditional random field based model widely used for flat named entity recognition tasks.
  Experiments demonstrate that our method performs better than or at least as well as existing methods capable of handling nested entities, achieving the F1-scores of , , and  on ACE-2004, ACE-2005, and GENIA datasets, respectively.
\end{abstract}

\section{Introduction}

Named entity recognition (NER) is the task of identifying text spans associated with proper names and classifying them according to their semantic class such as person or organization.
NER, or in general the task of recognizing entity mentions, is one of the first stages in deep language understanding, and its importance has been well recognized in the NLP community~\cite{Nadeau:2007}.

One popular approach to the NER task is to regard it as a sequence labeling problem.
In this case, it is implicitly assumed that mentions are not nested in texts.
However, names often contain entities nested within themselves, as illustrated in \figref{fig:example}, which contains 3 mentions of the same type (PROTEIN) in the span ``{\it ... in Ca2+ -dependent PKC isoforms in ...}'', taken from the GENIA dataset~\cite{Kim:2003}.
Name nesting is common, especially in technical domains~\cite{alex-etal-2007-recognising,byrne2007,wang-2009-annotating}.
The assumption of no nesting leads to loss of potentially important information and may negatively impact subsequent downstream tasks.
For instance, a downstream entity linking system that relies on NER may fail to link the correct entity if the entity mention is nested.

\begin{figure}[t]
\centering
\includegraphics[width=.85\hsize]{example.png}
\caption{Example of nested entities.}
\label{fig:example}
\end{figure}

\begin{figure*}[t]
\centering
\includegraphics[width=.85\hsize]{concept.png}
\caption{Overview of our second-best path decoding algorithm to iteratively find nested entities.}
\label{fig:decoding}
\end{figure*}

Various approaches to recognizing nested entities have been proposed.
Many of them rely on producing and rating all possible (sub)spans, which can be computationally expensive.  
\citet{wang-lu-2018-neural} provided a hypergraph-based approach to consider all possible spans.
\citet{sohrab-miwa-2018-deep} proposed a neural exhaustive model that enumerates and classifies all possible spans.
These methods, however, achieve high performance at the cost of time complexity.
To reduce the running time, they set a threshold to discard longer entity mentions.
If the hyperparameter is set low, running time is reduced but longer mentions are missed.
In contrast, \citet{muis-lu-2017-labeling} proposed a sequence labeling approach that assigns tags to gaps between words, which efficiently handles sequences using Viterbi decoding.
However, this approach suffers from structural ambiguity issues during inference as explained by \citet{wang-lu-2018-neural}.
\citet{katiyar-cardie-2018-nested} proposed another hypergraph-based approach that learns the structure in a greedy manner.
However, their method uses an additional hyperparameter as the threshold for selecting multiple mention candidates.
This hyperparameter affects the trade-off between recall and precision. 

In this paper, we propose new learning and decoding methods to extract nested entities without any additional hyperparameters.
We summarize our contributions as follows:
\begin{itemize}
\item We describe a decoding method that iteratively recognizes entities from outermost ones to inner ones without structural ambiguity.
It recursively searches a span of each extracted entity for inner nested entities using the Viterbi algorithm.
This algorithm does not require hyperparameters for the maximal length or number of mentions considered.
\item We also provide a novel learning method that ensures the aforementioned decoding.
Models are optimized based on an objective function designed according to the decoding procedure.
\item Empirically, we demonstrate that our method performs better than or at least as well as the current state-of-the-art methods with , , and  in F1-score on three standard datasets: ACE-2004\footnote{\url{https://catalog.ldc.upenn.edu/LDC2005T09}}, ACE-2005\footnote{\url{https://catalog.ldc.upenn.edu/LDC2006T06}}, and GENIA.
\end{itemize}

\begin{algorithm*}[t]
\small
\SetKwProg{Fn}{Function}{}{}
\SetKwFunction{Fmain}{main}
\SetKwFunction{Fnest}{detectNestedMentions}
 = the set of entity types;\\
\Fn{\Fmain{}}{
  ;\ \ \# the set of detected mentions. Each element of  is a tuple (, , ) regarding a mention. \\
  \ \ \ \ \ \ \ \ \# , , and  are the start position, the end position, and the entity type of the mention, respectively. \\
  \ForEach{}{
    calculate CRF scores  for entity type  with the score function \;
    find the best path of the span from position  to position  based on the scores \;
     = the set of the mentions detected in the best path\;
    \;
    \ForEach{}{
      \Fnest{, , , , }\;
    }
  }
  \KwRet \;
}
\Fn{\Fnest{, , , , }}{
  \If{}{
    find the 2nd best path of the span from position  to position  based on the scores \;
     = the set of the mentions detected in the 2nd best path\;
    \;
    \ForEach{}{
      \Fnest{, , , , }\;
    }
  }
  \KwRet\;
}
\caption{Nested NER via 2nd-best sequence decoding}\label{alg:pseudo-code}
\end{algorithm*}

\section{Method}

We propose applying conditional random field (CRF)~\cite{lafferty2001}, which is commonly used for flat NER~\cite{lample-etal-2016-neural,ma-hovy-2016-end,chiu-nichols-2016-named,reimers-gurevych-2017-reporting,strubell-etal-2017-fast,akbik-etal-2018-contextual}, to nested NER in this study.
We first explain our usage of CRF, which is the base of our decoding and training methods.
Then, we introduce our decoding and training methods.
Our decoding and training methods focus on the output layer of neural architectures and therefore can be combined with any neural model.

\subsection{Usage of CRF}
\label{ssec:usage}

Our decoding and training methods are based on two key points about our usage of CRF.
The first key point is that we prepare a separate CRF for each named entity type.
This enables our method to handle the situation where the same mention span is assigned multiple entity types.
The GENIA dataset indeed has such mention spans.
In the literature, \citet{muis-lu-2017-labeling} demonstrated that this approach of multiple CRFs would perform better on nested NER datasets and even a flat NER dataset than the standard approach of a single CRF for all entity types.
The second key point is that each element of the transition matrix of each CRF has a fixed value according to whether it corresponds to a legal transition ({\em e.g.}, {\tt B-X} to {\tt I-X} in IOBES tagging scheme, where {\tt X} is the name of entity type) or an illegal one ({\em e.g.}, {\tt O} to {\tt I-X}).
This is helpful for keeping the scores for tag sequences including outer entities higher than those of tag sequences including inner entities.

Formally, we use  to represent a sequence output from the last hidden layer of a neural model, where  is the vector for the -th word, and  is the number of tokens.
 represents a sequence of IOBES tags of entity type  for . Here, we define the score function to be


 and  denote the weight matrix and the bias vector corresponding to , respectively.
 stands for the transition matrix from the previous token to the current token, and  is the transition scores from  to .
 is shared between all of the multiple CRFs as their input.

\subsection{Decoding}

We employ three strategies for decoding.
First, we consider each entity type separately using multiple CRFs in decoding, which makes it possible to handle the situation that the same mention span is assigned multiple entity types.
Second, our decoder searches nested entities in an outside-to-inside way\footnote{Our usage of {\it inside}/{\it outside} is different from the inside-outside algorithm in dynamic programming.}, which realizes efficient processing by eliminating the spans of non-entity at an early stage.
More specifically, our method recursively narrows down the spans to Viterbi-decode.
The spans to Viterbi-decode are dynamically decided according to the preceding Viterbi-decoding result.
Only the spans that have just been recognized as entity mentions are Viterbi-decoded again.
Third, we use the same scores  of \equref{eq:score} to extract outermost entities and even inner entities without re-encoding, which makes inference more efficient and faster.
These three strategies are deployed and completed only in the output layer of neural architectures.

We describe the pseudo-code of our decoding method in Algorithm \ref{alg:pseudo-code}.
Also, we depict the overview of our decoding method with an example in \figref{fig:decoding} .
We use the term {\it level} in the sense of the depth of entity nesting.
{\tt [S]} and {\tt [E]} in \figref{fig:decoding} stand for the START and END tags respectively. 
We always attach these tags to both ends of every sequence of IOBES tags in Viterbi-decoding.

We explain the decoding procedure and mechanism in detail below.
We consider each entity type separately and iterate the same decoding process regarding distinct entity types as described in Algorithm \ref{alg:pseudo-code}.
In the decoding process for each entity type , we first calculate the CRF scores  over the entire sentence.
Next, we decode a sequence with the standard -best Viterbi decoding as with the conventional linear-chain CRF.
``{\it Ca2+ -dependent PKC isoforms}'' is extracted at the 1st level with regard to the example of \figref{fig:decoding}.

Then, we start our recursive decoding to extract nested entities within previously extracted entity spans by finding the 2nd best path.
In \figref{fig:decoding}, the span ``{\it Ca2+ -dependent PKC isoforms}'' is processed at the 2nd level.
Here, if we search for the best path within each span, the same tag sequence will be obtained, even though the processed span is different.
This is because we continue using the same scores  and because all the values of  corresponding to legal transitions are equal to .
Regarding the example of \figref{fig:decoding}, the score of the transition from {\tt [S]} to {\tt B-P} at the 2nd level is equal to the score of the transition from {\tt O} to {\tt B-P} at the 1st level.
This is true for the transition from {\tt E-P} to {\tt [E]} at the 2nd level and the one from {\tt E-P} to {\tt O} at the 1st level.
The best path between the {\tt [S]} and {\tt [E]} tags is identical to the best path between the two {\tt O} tags under our restriction about the transition matrix of CRF.
Therefore, we search for the 2nd best path within the span by utilizing the -best Viterbi A* algorithm~\cite{Seshadri:1994,huang-etal-2012-iterative}.\footnote{Without our restriction about the transition matrix of CRF, we would have to watch both the best path and the 2nd best path. Besides, if a single CRF was used for all entity types, the decoder could not always narrow down spans with the 2nd best path. The 2nd best path in a single CRF could result in the same span tagged a different entity type. We would have to watch lower-ranked paths.}
Note that our situation is different from normal situations where -best decoding is needed.
We already know the best path within the span and want to find only the 2nd best path.
Thus, we can extract nested entities by finding the 2nd best path within each extracted entity.
Regarding the example of \figref{fig:decoding}, ``{\it PKC isoforms}'' is extracted from the span ``{\it Ca2+ -dependent PKC isoforms}'' at the 2nd level.

We continue this recursive decoding until no multi-token entities are detected within a span.
In \figref{fig:decoding}, the span ``{\it PKC isoforms}'' is processed at the 3rd level.
At the 3rd or deeper levels, the tag sequence of its grandparent level is no longer either the best path or the 2nd best path because the start or end position of the current span is in the middle of the entity mention span at the grandparent level.
As for the example shown in \figref{fig:decoding}, the word ``{\it PKC}'' is tagged {\tt I-P} at the 1st level, and the transition from {\tt [S]} to {\tt I-P} is illegal.
The scores of the paths that includes illegal transitions cannot be larger than those of the paths that consist of only legal transitions because the elements of the transition matrix  corresponding to illegal transitions are set to .
That is why at all levels below the 1st level we only need to find the 2nd best path.

This recursive processing is stopped when no entities are predicted or when only single-token entities are detected within a span.\footnote{We do not need to recursively decode the span of each extracted single-token entity because a single-token entity cannot contain another entity of the same entity type.}
In \figref{fig:decoding}, the span ``{\it PKC}'' is not processed any more because it is a single-token entity.

Only one nested entity is extracted within each decoded span in \figref{fig:decoding}, but there can be cases where multiple multi-token entities are detected within a decoded span.
In such cases, our algorithm Viterbi-decodes each of their spans in the way of the depth-first search algorithm.
The aforementioned processing is executed on all entity types, and all detected entities are returned as an output result.

\subsection{Training}

To extract entities from outside to inside successfully, a model has to be trained in a way that the scores for the paths including outer entities will be higher than those for the paths including inner entities.
We propose a new objective function to achieve this requirement.

We maximize the log-likelihood of the correct tag sequence as with the conventional CRF-based model.
Considering that our model has a separate CRF for each entity type, the log-likelihood for one training data, , is as follows:

where  is the set of parameters of a neural model, and  denotes the collection of the gold IOBES tags for all levels regarding the entity type .
As we mentioned in Section \ref{ssec:usage},  is a sequence output from the last hidden layer of a neural model and is shared between all of the multiple CRFs.
Therefore,  is updated through a backpropagation process so that  can represent information about all entity types.

In the following, we decompose the log-likelihood for all levels into the ones for each level.
Let  and  denote the start and end positions of the -th span at the -th level.
With regard to the 1st level,  and  because we consider the whole span of a sentence.
The spans considered at each deeper level, , are determined according to the spans of multi-token entities at its immediate parent level.
As for the example of \figref{fig:decoding}, only the span of ``{\it Ca2+ -dependent PKC isoforms}'' is considered at the 2nd level.
Here, the log-likelihood for each entity type can be expressed as follows:

where  and  are the log-likelihoods of the (1st) best and 2nd best paths for each span, respectively.
 denotes the correct IOBES tag of the position  of the -th level of the entity type .

\begin{algorithm}[t]
\small
\;
;\ \ \# the start position \\
;\ \ \# the end position \\
\ForEach{}{
  \;
}
\For{; ; }{
  \ForEach{}{
    \ForEach{}{
      \;
    }
  }
  \ForEach{}{
    \;
  }
}
\ForEach{}{
  \;
}
\KwRet \;
\caption{LogSumExp of the scores of all possible paths}\label{alg:1st}
\end{algorithm}

\noindent {\bf Best path.}  can be calculated in the same manner as the conventional linear-chain CRF:

 denotes the set of all possible tag sequences from position  to position  of the entity type .
The first term of \equref{eq:log-likelihood-1st} is the score of the gold tag sequence, and the second term is the logarithm of the summation of the exponential scores of all possible tag sequences.
It is well known that the second term of \equref{eq:log-likelihood-1st} can be efficiently calculated by the algorithm shown in Algorithm \ref{alg:1st}.

\begin{figure}[t]
\centering
\includegraphics[width=.58\hsize]{lattice.png}
\caption{Lattice and best path.}
\label{fig:best-path}
\end{figure}

\begin{figure*}[t]
\centering
\includegraphics[width=.85\hsize]{divided_paths.png}
\caption{Divided search spaces.}
\label{fig:devided-paths}
\end{figure*}

\begin{figure}[t]
\centering
\includegraphics[width=.95\hsize]{merge_paths.png}
\caption{Merge of search spaces.}
\label{fig:merged-paths}
\end{figure}

\begin{algorithm}[t]
\small
\;
;\ \ \# the start position \\
;\ \ \# the end position \\
;\ \ \# the best path \\
\For{; ; }{
  \;
}
\;
\ForEach{}{
  \;
}
\;
\For{; ; }{
  \ForEach{}{
    \ForEach{}{
      \;
    }
    \If{}{
      \ForEach{}{
        \;
      }
      \;
    }
  }
  \ForEach{}{
    \;
  }
  \;
}
\ForEach{}{
  \;
}
\;
\KwRet \;
\caption{LogSumExp of the scores of all possible paths except the best path}\label{alg:2nd}
\end{algorithm}

\noindent {\bf 2nd best path.}  given the best path can be calculated by excluding the best path from all possible paths.
This concept is also adopted by ListNet~\cite{cao2007}, which is used for ranking tasks such as document retrieval or recommendation.
 can be expressed by the following equation:

where  denotes the set of all possible tag sequences except the best path within the span from position  to position  of the entity type .

However, to the best of our knowledge, the way of efficiently computing the second term of \equref{eq:log-likelihood-2nd} has not been proposed yet in the literature.
Simply subtracting the exponential score of the best path from the summation of the exponential scores of all possible paths causes underflow, overflow, or loss of significant digits.
We introduce the way of accurately computing it with the same time complexity as Algorithm \ref{alg:1st} for \equref{eq:log-likelihood-1st}.
For explanation, we use the simplified example of the lattice depicted in \figref{fig:best-path}, in which the span length is  and the number of states is .
The special nodes for start and end states are attached to the both ends of the span.
There are  paths in this lattice.
We assume that the path that consists of top nodes of all time steps are the best path as shown in \figref{fig:best-path}.
No generality is lost by making this assumption.
To calculate the second term of \equref{eq:log-likelihood-2nd}, we have to consider the exponential scores for all the possible paths except the best path,  paths.

We first give a way of thinking, which is not our algorithm itself but helpful to understand it.
In the example, we can further group these 80 paths according to the steps where the best path is not taken.
In this way, we have  spaces in total as illustrated in \figref{fig:devided-paths}.
In Space , the top node of time step  is excluded from consideration.
 paths are taken into account here.
Since this space covers all paths that do not go through the top node of time step , we only have to consider the paths that go through this node in other spaces.
In Space , this node is always passed through, and instead the top node of time step  is excluded. 
 paths are considered in this space.
Similarly,  paths and  paths are taken into consideration in Space  and Space , respectively.
Thus, we can consider all the possible paths except the best path,  paths.
However, this is not our algorithm itself as we mentioned.

We introduce two tricks for making the calculation more efficient.
We explain them with \figref{fig:merged-paths}, in which Spaces  and  are picked up.
The first trick is that the separated two spaces can be merged at time step  because the paths later than time step  are identical.
When we reach time step  in the forward iteration in each of the two spaces, we can merge them using the calculation results at time step , as shown with the red edges in \figref{fig:merged-paths}.
The second trick is that the blue nodes in \figref{fig:merged-paths} can be copied from Space  to Space  at time step  since the considered paths until that time step are also the same.
These two tricks can be applied to other pairs of two adjacent spaces, which relieves the need to separately calculate the summation of the exponential scores for each space.
Therefore, the second term of \equref{eq:log-likelihood-2nd} can be calculated as shown in Algorithm \ref{alg:2nd}.

Thus, we can train a model using the objective function of Eqs.~\ref{eq:log-likelihood}, \ref{eq:log-likelihood-each}, \ref{eq:log-likelihood-1st}, and \ref{eq:log-likelihood-2nd}.

\subsection{Characteristics}

\noindent {\bf Time complexity.} 
Regarding the time complexity of decoder, the worst case for our method is when our decoder narrows down the spans one by one, from  tokens (a whole sentence) to  tokens.
The time complexity for the worst case is therefore  for each entity type,  in total, where  denotes the number of entity types.
However, this rarely happens.
The ideal average processing time in the case where our decoding method narrows down spans successfully according to gold labels is , where  is the average number of gold IOBES tags of each entity type assigned to a word.
The average numbers calculated from the gold labels of ACE-2004, ACE-2005, and GENIA are , , and , respectively.

\noindent {\bf Usability.}
Some existing methods have hyperparameters, such as the maximal length of considered entities or the threshold that affects the number of detected entities, beyond those of the conventional CRF-based model used for flat NER tasks.
These hyperparameters must be tuned depending on datasets. 
On the other hand, our method does not have such hyperparameters and is easy to use from this viewpoint.
In addition, our method focuses on the output layer of neural architectures; therefore our method can be combined with any neural model.

We verify the empirical performances of our methods in the successive sections.

\section{Experimental Settings}

\subsection{Datasets}

\begin{table*}[t!]
\centering
\small
\resizebox{\textwidth}{!}{
\begin{tabular}{l|rr|rr|rr|rr|rr|rr}
  & \multicolumn{6}{c|}{\bf ACE-2005} & \multicolumn{6}{c}{\bf GENIA} \\
  &
  Train & () & Dev & () & Test & () &
  Train & () & Dev & () & Test & () \\
  \hline
  \# documents & 370 & & 43 & & 51 & & - & & - & & - & \\ \hline
  \# sentences &
  (7,285) & & (968) & & (1,058) & & 15,022 & & 1,669 & & 1,855 & \\ \hline
  \# mentions &
  24,827 & & 3,234 & & 3,041 & & 47,027 & & 4,469 & & 5,600 & \\
  \ \ \ - 1st level &
  21,966 & (88) & 2,900 & (90) & 2,686 & (88) & 44,611 & (95) & 4,239 & (95) & 5,273 & (94) \\
  \ \ \ - 2nd level &
  2,635 & (11) & 316 & (10) & 323 & (11) & 2393 & (5) & 230 & (5) & 327 & (6) \\
  \ \ \ - 3rd level &
  215 & (1) & 18 & (1) & 30 & (1) & 23 & (0) & 0 & (0) & 0 & (0) \\
  \ \ \ - 4th level &
  9 & (0) & 0 & (0) & 2 & (0) & 0 & (0) & 0 & (0) & 0 & (0) \\ \hline
  \# labels per token () & 1.06 & & 1.05 & & 1.05 & & 1.05 & & 1.05 & & 1.05 & \\
\end{tabular}
}
\caption{Statistics of the datasets used in the experiments. Note that in ACE-2005, sentences are not originally split. We report the numbers of sentences based on the preprocessing with the Stanford CoreNLP~\cite{manning-etal-2014-stanford}.}\label{tab:stats-datasets}
\end{table*}

We perform nested entity extraction experiments intensively on ACE-2005~\cite{doddington-etal-2004-automatic} and GENIA~\cite{Kim:2003}.
For ACE-2005, we use the same splits of documents as \citet{lu-roth-2015-joint}, published on their website\footnote{\url{http://www.statnlp.org/research/ie}}.
For GENIA, we use GENIAcorpus3.02p\footnote{\url{http://www.geniaproject.org/genia-corpus/pos-annotation}} in which sentences are already tokenized~\cite{tateisi-tsujii-2004-part}.
Following previous works~\cite{finkel-manning-2009-nested,lu-roth-2015-joint}, we first split the last  of sentences as the test set.
Next, we use the first  and the subsequent  for training and development sets, respectively.
We make the same modifications as described by \citet{finkel-manning-2009-nested} by collapsing all DNA, RNA, and protein subtypes into DNA, RNA, and protein, keeping cell line and cell type, and removing other entity types, resulting in 5 entity types.
The statistics of each dataset are shown in \tabref{tab:stats-datasets}.

\subsection{Model and Training}

\begin{table}[t!]
\centering
\small
\begin{tabular}{l|ccc}
  {\bf Hyperparameter} & {\bf Value} \\
  \hline
  word dropout rate &  \\
  character embedding dimension &  \\
  CNN window size &  \\
  CNN filter number &  \\
  \hline
  batch size &  \\
  LSTM hidden size &  \\
  LSTM dropout rate &  (w/o BERT) \\
   &  (w/ BERT) \\
  gradient clipping &  \\
\end{tabular}
\caption{Hyperparameters in our experiments.}\label{tab:hyperparameters}
\end{table}

In this study, we adopt as baseline a BiLSTM-CRF model, which is widely used for NER tasks~\cite{lample-etal-2016-neural,ma-hovy-2016-end,chiu-nichols-2016-named,reimers-gurevych-2017-reporting}.
We apply our usage of CRF to this baseline.
We prepare three types of models for fair comparisons with existing methods.
The first one is the model to which is fed conventional word embeddings and CNN-based character-level representation~\cite{ma-hovy-2016-end,chiu-nichols-2016-named,reimers-gurevych-2017-reporting}.\footnote{\url{https://github.com/yahshibu/nested-ner-tacl2020}}
We initialize word embeddings with the pretrained embeddings GloVe~\cite{pennington-etal-2014-glove} of dimension 100 in ACE-2005.
For GENIA, we adopt the pretrained embeddings trained on MEDLINE abstracts~\cite{chiu-etal-2016-train} instead.
The initialized word embeddings are fixed during training.
The vectors of the word embeddings and the character-level representation are concatenated and then input into the BiLSTM layer.
The second model is the model combined with the pretrained BERT model~\cite{devlin-etal-2019-bert}.\footnote{\url{https://github.com/yahshibu/nested-ner-tacl2020-transformers}}
We use the uncased version of BERT large model as a contextual word embeddings generator without fine-tuning and stack the BiLSTM layers on top of the BERT model.
The third model is the BiLSTM-CRF model to which is fed word embeddings, character-level representation, BERT embeddings, and FLAIR embeddings~\cite{akbik-etal-2018-contextual} using FLAIR framework~\cite{akbik-etal-2019-flair}.\footnote{\url{https://github.com/yahshibu/nested-ner-tacl2020-flair}}
All our models have 2 BiLSTM hidden layers, and the dimensionality of each hidden unit is 256 in all our experiments.
\tabref{tab:hyperparameters} lists the hyperparameters used for our experimental evaluations.
We adopt AdaBound~\cite{luo2019} as an optimizer.
Early stopping is used based on the performance of development set.
We repeat the experiment 5 times with different random seeds and report average and standard deviation of F1-scores on a test set as the final performance.

\section{Experimental Results}

\subsection{Comparison with Existing Methods}

\begin{table*}[t!]
\centering
\small
\resizebox{\textwidth}{!}{
\begin{tabular}{l|lll|lll}
   & \multicolumn{3}{c|}{\bf ACE-2005} & \multicolumn{3}{c}{\bf GENIA} \\
  {\bf Method} &
  Precision () & Recall () & F1 () &
  Precision () & Recall () & F1 () \\
  \hline
  \citet{katiyar-cardie-2018-nested} &
   &  &  &
   &  &  \\
  \citet{ju-etal-2018-neural}\footnotemark &
   &  &  &
   &  &  \\
  \citet{wang-etal-2018-neural-transition}\footnotemark &
   &  &  &
   &  &  \\
  \citet{wang-lu-2018-neural}&
   &  &  &
   &  &  \\
  \citet{sohrab-miwa-2018-deep} &
  - & - & - &
   &  &  \\
  \citet{zheng-etal-2019-boundary} &
  - & - & - &
   &  &  \\
  \citet{fisher-vlachos-2019-merge} &
   &  &  &
  - & - & - \\
  \citet{lin-etal-2019-sequence}&
   &  &  &
   &  &  \\
  \citet{strakova-etal-2019-neural}\footnotemark &
   &  &  &
   &  &  \\
  {\bf This work} &
   &  &  &
   &  &  \\ \hline
  \citet{fisher-vlachos-2019-merge} [BERT] &
   &  &  &
  - & - & - \\
  \citet{strakova-etal-2019-neural} [BERT] &
   &  &  &
   &  &  \\
  {\bf This work} [BERT] &
   &  &  &
   &  &  \\ \hline
  \citet{strakova-etal-2019-neural} [BERT+FLAIR] &
   &  &  &
   &  &  \\
  {\bf This work} [BERT+FLAIR] &
   &  &  &
   &  &  \\
\end{tabular}
}
\caption{Main results. We group methods into three types. The first group consists of the methods that do not use any contextual word embeddings. The second group consists of the methods that use BERT but do not use any other contextual word embeddings. The third group consists of the methods that use both BERT and FLAIR. ``'' indicates the methods using POS tags.}\label{tab:main-results}
\end{table*}

\tabref{tab:main-results} presents comparisons of our model with existing methods.
Note that some existing methods use embeddings of POS tags as an additional input feature whereas our method does not.
Our method outperforms the existing methods with  and  in terms of F1-score when using only word embeddings and character-level representation.
Especially, our method brings much higher recall values than the other methods.
The recall scores are improved by  and  on ACE-2005 and GENIA datasets, respectively.
These results demonstrate that our training and decoding algorithms are quite effective for extracting nested entities.
Moreover, when we use BERT and FLAIR as contextual word embeddings, we achieve an F1-score of  with BERT and  with BERT and FLAIR on ACE-2005.
On the other hand, BERT does not perform well on GENIA.
We assume that this is because the domain of GENIA is quite different from that of the corpus used for training the BERT model.
Regardless, it is demonstrated that our method performs better than or at least as well as existing methods.

\addtocounter{footnote}{-2}
\footnotetext{Note that in ACE-2005, \citet{ju-etal-2018-neural} did their experiments with a different split from \citet{lu-roth-2015-joint} that we follow.}
\stepcounter{footnote}
\footnotetext{\citet{wang-etal-2018-neural-transition} did not report precision and recall scores. Instead of \citet{wang-etal-2018-neural-transition}, \citet{wang-lu-2018-neural} reported the scores for the model of \citet{wang-etal-2018-neural-transition}.}
\stepcounter{footnote}
\footnotetext{\citet{strakova-etal-2019-neural} did not report precision and recall scores in their paper. We asked the authors the scores, and they let us know.}

\subsection{Ablation Study}
\label{ssec:ablation}

\begin{table*}[t!]
\centering
\small
\resizebox{0.9\textwidth}{!}{
\begin{tabular}{l|lll|lll}
   & \multicolumn{3}{c|}{\bf ACE-2005} & \multicolumn{3}{c}{\bf GENIA} \\
   &
  Precision () & Recall () & F1 () &
  Precision () & Recall () & F1 () \\
  \hline
  {\bf This work} &
   &  &  &
   &  &  \\
  \ \ \  L &
   &  &  &
   &  &  \\
  \ \ \  L\&D &
   &  &  &
   &  &  \\
\end{tabular}
}
\caption{Results when ablating away the learning (L) and decoding (D) components of our proposed method.}\label{tab:ablation}
\end{table*}

We conduct an ablation study to verify the effectiveness of our learning and decoding methods.
We first replace our objective function for training with the standard objective function of the liner-chain CRF.
The methods for decoding -best paths have been well studied because such algorithms have been required in many domains~\cite{soong-huang-1990-tree,kaji-etal-2010-efficient,huang-etal-2012-iterative}.
However, we hypothesize that our learning method, as well as our decoding method, helps to improve performance.
That is why we first remove only our learning method.
Then, we also replace our decoding algorithm with the standard decoding algorithm of the linear-chain CRF.
It is equivalent to preparing the conventional CRF for each entity type separately.

The results are shown in \tabref{tab:ablation}.
They demonstrate that introducing only our decoding algorithm surely brings high recall scores but hurts precision.
This suggests that our learning method should be necessary for achieving high precision. 
Besides, removing the decoding algorithm results in lower recall.
This is natural because it does not intend to find any nested entity after extracting outermost entities.
Thus, it is demonstrated that both our learning and decoding algorithms contribute much to good performance.

\subsection{Analysis of Behavior}

\begin{table}[t!]
\centering
\small
\resizebox{\columnwidth}{!}{
\begin{tabular}{c|cr|cr}
   & \multicolumn{2}{c|}{\bf ACE-2005} & \multicolumn{2}{c}{\bf GENIA} \\
  {\bf Level} & Recall () & Num. & Rcall () & Num. \\ \hline
  1st &  & 2,686 &  & 5,273 \\
  2nd &  & 323 &  & 327 \\
  3rd &  & 30 & - & 0 \\
  4th &  & 2 & - & 0 \\
\end{tabular}
}
\caption{Recall scores for gold annotations of each level.}\label{tab:level-wise-recall}
\end{table}

\begin{table}[t!]
\centering
\small
\resizebox{\columnwidth}{!}{
\begin{tabular}{c|cr|cr}
   & \multicolumn{2}{c}{\bf ACE-2005} & \multicolumn{2}{c}{\bf GENIA} \\
  {\bf Level} & Precision () & Num. & Precision () & Num. \\ \hline
  1st &  & 2,500 &  & 5,038 \\
  2nd &  & 311 &  & 326 \\
  3rd &  & 43 &  & 3 \\
  4th &  & 9 & - & 0 \\
  5th &  & 6 & - & 0 \\
\end{tabular}
}
\caption{Precision scores for predictions of each level of one trial.}\label{tab:level-wise-precision}
\end{table}

To further understand how our method handles nested entities, we investigate the performances for entities of each level.
\tabref{tab:level-wise-recall} shows the recall scores for gold entities of each level when using conventional word embeddings.
Among all levels, our model results in the best performance at the 1st level that consists of only gold outermost entities.
The deeper a level, the lower recall scores.
On the other hard, \tabref{tab:level-wise-precision} shows the precision scores for predicted entities in each level of one trial on each dataset.
Because the number of levels in the predictions vary between trials, taking macro average of precision scores over multiple trials is not representative.
Therefore, we show only the precision scores from one trial in \tabref{tab:level-wise-precision}.
The precision score for the 5th level on ACE-2005 is as high as or higher than those of other levels.
Precision scores are less dependent on level.
This tendency is also shown in other trials.

In addition, we compare the tendency of our method with that of an existing method.
We select \citet{wang-lu-2018-neural}'s method for comparison.\footnote{We do not use POS tags as one of input features for a fair comparison with our method.}
We train their model with the ACE-2005 dataset using their original implementation and repeat that 5 times.
The recall scores from the 1st level to the 4th level are , , , and , respectively.
The tendency about the difference across levels is common to \citet{wang-lu-2018-neural}'s method and our method, and the scores from our method (\tabref{tab:level-wise-recall}) are entirely higher than those from their method.
It is demonstrated that our method can extract both outer and inner entities better.
On the other hand, their method can extract crossing entities (two entities overlap but neither is contained in the other), although our method cannot.
Actually, their model outputs some crossing spans in our experiments.
In this case, we cannot analyze the results regarding precision scores in the same manner as \tabref{tab:level-wise-precision}.
There are cases where one cannot uniquely decide the level of an span nested within multiple crossing spans.
Regardless, our method cannot handle crossing entities.
However, crossing entities are very rare~\cite{lu-roth-2015-joint,wang-etal-2018-neural-transition}.
The test sets of ACE-2005 and GENIA have no crossing entities.
This property of our method does not have a negative impact the performance at least on the ACE-2005 and GENIA datasets.

\subsection{Error Analysis}

We manually scan the test set predictions on ACE-2005.
We find out that many of the errors can be classified into two types.

The first type is partial prediction error.
Given the following sentence: ``{\it Let me set aside the hypocrisy of a man who became president because of a lawsuit trying to eliminate everybody else's lawsuits, but instead focus on his own experience}''.
The annotation marks ``{\it a man who became president because of a lawsuit}'', but our model extracts a shorter or longer span. 
It is difficult to extract the proper spans of clauses that contain numerous modifiers.

The second type is error derived from pronominal mention.
Consider the following example: ``{\it They roar, they screech.}''.
These ``{\it They}''s refer to ``{\it tanks}'' in another sentence of the same document and are indeed annotated as VEH (Vehicle).
Our model fails to detect these pronominal mentions or wrongly labels them as PER (Person).
Document context should be taken into consideration to solve this problem.

These types of errors have been reported by \citet{katiyar-cardie-2018-nested,ju-etal-2018-neural,lin-etal-2019-sequence} and are still remaining as challenges.

\subsection{Running Time}

\begin{table}[t!]
\centering
\small
\resizebox{0.8\columnwidth}{!}{
\begin{tabular}{c|r}
  {\bf Maximal depth} & {\bf \# tokens per second} \\ \hline
   & 6,083 \\
   & 3,761 \\
   & 3,655 \\
   & 3,742 \\
   & 3,723 \\
   (no restriction) & 3,701 \\
\end{tabular}
}
\caption{Decoding speed on ACE-2005.}\label{tab:speed}
\end{table}

We investigate how our recursive decoding method impacts on the decoding speed in terms of the number of words processed per second.
We use the model trained with ACE-2005 used for \tabref{tab:level-wise-precision} and change the maximal depth of decoding to , , , , , and . 
When the maximal depth is , our decoder Viterbi-decodes only from the 1st level to the -th level.
Note that, when the maximal depth is , the decoding process is completely the same as the Viterbi decoding of the standard CRF.
We run them on an Intel i7 (2.7 GHz) CPU.

Results are listed in \tabref{tab:speed}.
The processed words per second decrease by  when the maximal depth varies from  to .
There are two main reasons for this phenomenon.
First, our decoder needs the processing for moving across different levels.
That processing is not necessary when the maximal depth is .
Second, the number of the extracted spans at the 2nd level is large and not negligible ( of that of the extracted spans at the 1st level as shown in \tabref{tab:level-wise-precision}).
The numbers of the extracted spans at the 3rd and lower levels are small, and then the processed words do not largely decrease when the maximal depth increases over .
Regardless, our decoder does not take twice as long as the standard CRF on ACE-2005.

\begin{table}[t!]
\centering
\small
\resizebox{\columnwidth}{!}{
\begin{tabular}{l|lll}
  {\bf Method} &
  P () & R () & F1 () \\
  \hline
  \citet{katiyar-cardie-2018-nested} &
   &  &  \\
  \citet{wang-etal-2018-neural-transition}\footnotemark &
   &  &  \\
  \citet{wang-lu-2018-neural} &
   &  &  \\
  \citet{strakova-etal-2019-neural}\footnotemark &
   &  &  \\
  {\bf This work} &
   &  &  \\ \hline
  \citet{strakova-etal-2019-neural} [BERT] &
   &  &  \\
  {\bf This work} [BERT] &
   &  &  \\ \hline
  \citet{strakova-etal-2019-neural} [BERT+FLAIR] &
   &  &  \\
  {\bf This work} [BERT+FLAIR] &
   &  &  \\
\end{tabular}
}
\caption{Comparison on ACE-2004. ``'' indicates the methods using POS tags.}\label{tab:main-results-ace-2004}
\end{table}
\addtocounter{footnote}{-1}
\footnotetext{\citet{wang-etal-2018-neural-transition} did not report precision and recall scores. Instead of \citet{wang-etal-2018-neural-transition}, \citet{wang-lu-2018-neural} reported the scores for the model of \citet{wang-etal-2018-neural-transition}.}
\stepcounter{footnote}
\footnotetext{\citet{strakova-etal-2019-neural} did not report precision and recall scores in their paper. We asked the authors the scores, and they let us know.}

\subsection{Comparison on ACE-2004}

We compare our method with existing methods also on the ACE-2004 dataset.
We use the same splits as \citet{lu-roth-2015-joint}.
The setups are the same as those of our experiment on ACE-2005.
\tabref{tab:main-results-ace-2004} shows the results.
As shown, our method significantly outperforms existing methods.
Note that most of them use POS tags as an additional input feature whereas our method does not.

\subsection{Flat NER}

\begin{table}[t!]
\centering
\small
\resizebox{0.7\columnwidth}{!}{
\begin{tabular}{l|l}
  {\bf Method} &
  F1 () \\
  \hline \hline
  \citet{wang-lu-2018-neural} &
   \\
  \citet{strakova-etal-2019-neural} &
   \\
  {\bf This work} &
   \\ \hline
  \citet{lample-etal-2016-neural}  &
   \\
  \citet{ma-hovy-2016-end}  &
   \\
  \citet{liu-etal-2019-gcdt}  &
   \\
  {\bf This work}  L\&D &
   \\ \hline \hline
  \citet{devlin-etal-2019-bert} &
   \\
  \citet{akbik-etal-2018-contextual} &
   \\
  \citet{liu-etal-2019-gcdt} &
   \\
  \citet{jiang-etal-2019-improved} &
   \\
  \citet{baevski-etal-2019-cloze} &
   \\
\end{tabular}
}
\caption{Comparison on CoNLL-2003. We group methods into two types. The first group consists of the methods that do not use any contextual word embeddings. The second one consists of the methods that use contextual word embeddings such as BERT and FLAIR. ``'' indicates the methods using POS tags. ``'' indicates the methods not designed to extract nested entities.}\label{tab:main-results-conll-2003}
\end{table}

To assess how our model works on flat NER task, we additionally evaluate our model on CoNLL-2003 \cite{tjong-kim-sang-de-meulder-2003-introduction}, which are annotated with outermost entities only.
The setups here are the same as those of our experiment on ACE-2005.
We not only prepare our proposed model but also the ablated model without our training nor decoding method, as in Section \ref{ssec:ablation}.
The former model can extract spans nested within other extracted spans regardless of the property of the dataset, but the latter model never extracts spans within other extracted spans.
We use the 100-dimensional GloVe embeddings for both models as in our previous experiments.

The results are in \tabref{tab:main-results-conll-2003}.
We compare our method with existing methods that do not adopt any contextual word embeddings (the upside of \tabref{tab:main-results-conll-2003}) here, although we also show results from recent work with contextual word embeddings for reference.
First, in comparison with the methods designed for nested NER~\cite{wang-lu-2018-neural,strakova-etal-2019-neural}, our method performs better even on CoNLL-2003.
This means that our method works well on not only nested NER but also flat NER.
Next, we compare to methods that can handle only flat NER.
\tabref{tab:main-results-conll-2003} shows that our method is comparable to the standard BiLSTM-CRF models~\cite{lample-etal-2016-neural,ma-hovy-2016-end} on CoNLL-2003.
However, note that there are some differences between the experiments of the previous studies~\cite{lample-etal-2016-neural,ma-hovy-2016-end} and our experiment.
For example, different word embeddings are used, or the hidden size of LSTM is not aligned.
Nevertheless, we can compare our proposed model to the ablated model.
As shown in \tabref{tab:main-results-conll-2003}, there is a significant gap ( with the permutation test) between the two scores,  and .
We analyze this gap in detail and then find out that our proposed model performs well especially in the cases where it is difficult to decide which is suitable, an inner span or an outer span.
Given the following sentence: ``{\it An assessment group made up of the State Council 's Port Office , the Civil Aviation Administration of China , the General Administration of Customs and other authorities had granted the airport permission to handle foreign aircraft , Xinhua said .}''.
In the CoNLL-2003 dataset, the four spans ``{\it State Council}'', ``{\it Civil Aviation Administration of China}'', ``{\it General Administration of Customs}'', and ``{\it Xinhua}'' are annotated as ORG (Organization).
The both models correctly detect the latter three entities in most trials, but the ablated model tends to extract ``{\it State Council 's Port Office}'' instead of ``{\it State Council}''.
On the other hand, our proposed model tends to extract both ``{\it State Council 's Port Office}'' and ``{\it State Council}''.
``{\it State Council 's Port Office}'' is indeed a false-positive, but our model can detect the correct entity span ``{\it State Council}'' more steadily than the ablated model.
Thus, our proposed model achieves the higher F1-score.

Recently, \citet{liu-etal-2019-gcdt} proposed a new architecture for sequence labeling, which can capture global information at the sentence level better than BiLSTM, and reported an F1-score of  when using conventional word embeddings ( when using BERT).
It is true that our model based on BiLSTM does not perform as well as their model, but our decoder can be combined with their proposed encoder.
We leave it for future work.

\section{Related Work}

\citet{alex-etal-2007-recognising} proposed several ways to combine multiple CRFs for such tasks.
They found out that, when they cascaded separate CRFs of each entity type by using the output from the previous CRF as the input features of the current CRF, best performance was yielded.
However, their method could not handle nested entities of the same entity type.
In contrast, \citet{ju-etal-2018-neural} dynamically stacked multiple layers that recognize entities sequentially from innermost ones to outermost ones.
Their method can deal with nested entities of the same entity type.

\citet{finkel-manning-2009-nested} proposed a CRF-based constituency parser for this task such that
each named entity is a node in the parse tree.
However, its time complexity is the cube of the length of a given sentence, making it not scalable to large datasets involving long sentences.
Later on, \citet{wang-etal-2018-neural-transition} proposed a scalable transition-based approach, a constituency forest (a collection of constituency trees).
Its time complexity is linear in the sentence length.

\citet{lu-roth-2015-joint} introduced a mention hypergraph representation for capturing nested entities as well as crossing entities (two entities overlap but neither is contained in the other).
One issue in their approach is the spurious structures of the representation.
\citet{muis-lu-2017-labeling} incorporated mention separators to address the spurious structures issue, but it still suffers from the structural ambiguity issue.
\citet{wang-lu-2018-neural} proposed a hypergraph representation free of structural ambiguity.
However, they introduced a hyperparameter, the maximal length of an entity, to reduce the time complexity.
Setting the hyperparameter to a small number results in speeding up but ignoring longer entity segments.

\citet{katiyar-cardie-2018-nested} proposed another hypergraph-based approach that learns the structure using an LSTM network in a greedy manner.
However, their method has a hyperparameter that sets a threshold for selecting multiple candidate mentions.
It must be carefully tuned for adjusting the trade-off between recall and precision.

\citet{sohrab-miwa-2018-deep} proposed a neural exhaustive model that enumerates all possible spans as potential entity mentions and classifies them.
However, they also use the maximal-length hyperparameter to reduce time complexity.

\citet{fisher-vlachos-2019-merge} proposed a novel neural network architecture that merges tokens or entities into entities forming nested structures and then labels each of them.
Their architecture, however, needs the maximal nesting level hyperparameter.
\citet{lin-etal-2019-sequence} proposed a sequence-to-nuggets architecture that first identify anchor words of all mentions and then recognize the mention boundaries for each anchor word.
Their method also use the maximal-length hyperparameter to reduce time complexity.

\citet{strakova-etal-2019-neural} proposed an encoding algorithm to allow the modeling of multiple named entity labels in a linearized scheme and proposed a neural model that predicts sequential labels for each token.
\citet{zheng-etal-2019-boundary} proposed a method that can detect entities boundaries with sequence labeling models.
These two methods do not require special hyperparameters.
They can also deal with crossing entities as well as nested entities in contrast to our method, but our experiments demonstrate that our method can perform well because crossing entities are very rare~\cite{lu-roth-2015-joint,wang-etal-2018-neural-transition}.

\section{Conclusion}

We propose learning and decoding methods for extracting nested entities.
Our decoding method iteratively recognizes entities from outermost ones to inner ones in an outside-to-inside way.
It recursively searches a span of each extracted entity for nested entities with second-best sequence decoding.
We also design an objective function for training that ensures our decoding algorithm.
Our method has no hyperparameters beyond those of conventional CRF-based models.
Our method achieves , , and  F1-scores on ACE-2004, ACE-2005, and GENIA datasets, respectively.

For future work, one interesting direction is joint modeling of NER with entity linking or coreference resolution.
Previous studies \cite{durrett-klein-2014-joint,luo-etal-2015-joint,nguyen-etal-2016-j,martins-etal-2019-joint} demonstrated that leveraging mutual dependency of the NER, linking, and coreference tasks could boost each performance.
We would like to address this issue while taking nested entities into account.

\section*{Acknowledgements}
We thank Aldrian Obaja Muis for helpful comments, and many anonymous reviewers and the action editor for helpful feedback on various drafts of the paper. We are also grateful to Jana Strakov{\'a} for sharing experimental results. Eduard Hovy was supported in part by DARPA grant FA8750-18-2-0018 funded under the AIDA program.

\bibliography{tacl2018}
\bibliographystyle{acl_natbib}

\end{document}
