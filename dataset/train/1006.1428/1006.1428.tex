\documentclass{eptcs}
\providecommand{\event}{DCM 2010} \usepackage{breakurl}             \usepackage{latexsym} 
\usepackage{graphicx} 
\newcommand{\uj}{\newcommand} 
\uj{\vsp}{\vspace{1ex}} 
\uj{\vspp}{\vspace{.5ex}}
\uj{\vspe}{\vsp \newline} 
\uj{\vspm}{\vspace*{-.7cm}} 
\uj{\vspmm}{\vspace*{-.6cm}} 
\uj{\vspmmm}{\vspace*{-2mm}} 
\uj{\vspmini}{\vspace*{-1mm}}
\uj{\vspminni}{\vspace*{-.6mm}}
\uj{\nyil}{\rightarrow} 
\uj{\nnyil}{\Rightarrow}
\uj{\paral}{\parallel} 
\uj{\set}{\mbox{\bf Set}} 
\uj{\rel}{\mbox{\bf Rel}}
\uj{\egy}{\mbox {{\bf 1}}}
\uj{\eps}{\epsilon }
\uj{\calm}{\mathcal{M}}
\uj{\kapo}{\updownarrow}
\uj{\calp}{\mathcal{P}}
\uj{\calt}{\mathcal{T}}
\uj{\calc}{\mathcal{C}}
\uj{\calg}{\mathcal{G}}
\uj{\calf}{\mathcal{F}}
\uj{\cala}{\mathcal{A}}
\uj{\calgsig}{\calg (\Sigma )}
\uj{\tot}{{\bf T}}
\uj{\ibf}{{\bf i}}
\uj{\jbf}{{\bf j}}
\uj{\wbf}{{\bf w}}
\uj{\robf}{\rho }
\uj{\biset}{\mbox {\bf Bset}}
\uj{\ima}{\mbox {\bf IMA}}
\uj{\sdcc}{\mbox {\bf SDCC}}
\uj{\bmc}{{\bf c}}
\uj{\imm}{\mathcal {I}}
\uj{\alp}{\mathcal {A}}
\uj{\sdc}{\mathcal {S}}
\uj{\dil}{{\em -dil}}
\uj{\bind}{\mbox{\bf Ind}}
\uj{\cali}{\mathcal{I}}
\uj{\vege}{\hspace{1em} \raisebox{-.5ex}{{\large }}} 
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\title{Turing Automata and Graph Machines\thanks{Work partially supported by Natural
Science and Engineering Research Council of Canada, Discovery Grant \#170493-03.}}
\author{Mikl\'os Bartha
\institute{Deprtment of Computer Science\\
Memorial University of Newfoundland\\
St.\ John's, NL, Canada}
\email{bartha@mun.ca}
}
\def\titlerunning{Turing Automata}
\def\authorrunning{M. Bartha}
\begin{document}
\maketitle

\begin{abstract}
Indexed monoidal algebras are introduced as an equivalent structure for
self-dual compact closed categories, and a coherence theorem is proved
for the category of such algebras. Turing automata and Turing graph machines 
are defined by generalizing the classical Turing machine concept, so that
the collection of such machines becomes an indexed monoidal algebra. 
On the analogy of the von Neumann data-flow computer architecture,
Turing graph machines are proposed as potentially reversible
low-level universal computational devices, and a truly reversible molecular 
size hardware model is presented as an example.
\end{abstract}
\section{Introduction}
The importance of reversibility in computation has been argued at several
platforms in connection with the speed and efficiency of modern-day computers.
As stated originally by Landauer \cite{landa} and re-emphasized by Abramsky \cite{abr}:
``it is only the logically irreversible operations in a physical computer that
necessarily dissipate energy by generating a corresponding amount of entropy
for every bit of information that gets irreversibly erased''. Abramsky's
remedy for this situation in \cite{abr} is to translate high level functional
programs in a syntax directed way into a simple kind of automata which are
immediately seen to be reversible. The concept strong compact closed 
category \cite{abst} has been introduced and advocated as a theoretical 
foundation for this type of reversibility.

The problem of reversibility, however, does not manifest itself at the software
level. Even if we manage to perform our programs in reverse, it is not
guaranteed that information will not be lost during the concrete physical
computation process. To the contrary, it may get lost twice, once in each
direction. The solution must therefore be found at the lowest hardware level.
Our model of Turing graph machines is being presented as a possible hardware
solution for the problem of reversibility, but follows Abramsky's structural
approach. We even go one step further by showing how computations can be done
in a virtually undirected fashion under the theoretical umbrella of self-dual
compact closed categories. In practical terms we mean that, unlike in 
synchronous systems (e.g.\ sequential circuits), where the information is
propagated through the interconnections (wires) between the functional
elements (logical gates) always in the same direction, in a Turing graph
machine the flow of information along these interconnections takes a 
direction that is determined dynamically by the current input and state of the machine.  
We are going to reconsider self-dual compact closed categories as
indexed monoidal algebras and prove a coherence theorem to establish undirected
graphs -- constituting the basic underlying structure for Turing graph machines -- as
free indexed monoidal algebras generated by the ranked alphabet consisting of
the star graphs.

Different parts of this paper need not be read in a strict sequential order. 
In-depth knowledge of algebra and category theory is only required in Section~2
and Section~3. The reader less familiar with categories could still understand
the concept of Turing automata and Turing graph machines in Section~5, and appreciate the 
main contribution of this work. The paper, being a short summary of rather
complex theoretical results, admittedly elaborates only on those
connections to these results that are directly related to their presentation.
One may, however, recognize structures familiar from linear logic,
game semantics, communicating concurrent processes, iteration theories, interaction nets, 
and the Geometry of Interaction program in general. These connections will be spelled
out in a future extended version of the present summary.
\section{Self-dual compact closed categories}
In this section we shall assume familiarity with the concept of {\em
symmetric monoidal categories\/} \cite{mcl}. Even though our main concern is with
strict monoidal categories, the algebraic constructions presented in Section~3
can easily be adjusted to cover the general case. From this point on,
unless otherwise stated, by a monoidal category we shall always mean a strict 
symmetric one. 

Let  be a monoidal category with tensor  and unit object .
Recall from \cite{cc,tra} that  is {\em compact closed\/} if every
object  has a left adjoint  in the sense that there exist morphisms
 (the unit map) and  (the
counit map) for which the two composites below result in the identity
morphisms  and , respectively.
 

By virtue of the adjunctions  there is a natural isomorphism between the 
hom-sets  and  for every objects ,
hence the name ``compact closed'' category. Category  is {\em
self-dual\/} compact closed (SDCC, for short) if  for each object .
The category  has as objects all locally small \cite{mcl}
SDCC categories, and as
morphisms monoidal functors preserving the given self-adjunctions.

A well-known SDCC category (not strict, though) is the category  of 
small sets and
relations with tensor being the cartesian product .
We shall only use this category as an example to explain the idea of indexing on it.
Recall from \cite {bur,hel} that an {\em indexed family of sets\/} is simply a functor
, where  is the index category.  In our example,
 is the monoidal category  as a subcategory of 
and  is the covariant powerset functor , which is of course not
monoidal. Relations  are, however, still subsets of , and as 
such they can be indexed by morphisms (functions)  in .
For any two objects (sets) one can then consider the binary operation , and the unary operation
trace,  for which 
iff . The concept indexed monoidal algebra arises from
observing the equational algebraic laws satisfied by these operations and their 
relationship to indexing. 

  Regarding the index monoidal category , one would like to have it as narrow as possible.
The best choice would be the collection of permutations in , which, unfortunately,
fails to be a subcategory in general. To get around this 
problem we shall introduce so called permutation symbols as unary operations,
which will be responsible for the task of indexing in a coherent way.
\section{Indexed monoidal algebras}
In this section we introduce the category  of indexed monoidal algebras
along the lines of the pioneer work \cite{hel}, and establish 
an equivalence between the categories  and .

Let  be a set of abstract sorts, and consider the free monoid 
generated by .  For a word (string) ,  will denote the
length of  and () will stand for the empty string. By an 
-{\em permutation\/} we mean a pair , where  is
a string with , and  is a permutation . We shall
use the notation  for , and say that  is an
-permutation , where  is the string .  If  and  are strings of length  and ,
respectively, then   will denote the -permutation  in which  is the block transposition .

The collection of -permutations can naturally be equipped with the operations
composition () and tensor (), which structure, together with the 
identities  and symmetries , defines a monoidal 
category  over the set of
objects . See e.g.\ \cite [Definition~1]{acta} covering the single-sorted
case. The category  is -initial in the sense that, for every monoidal category
 and mapping  from  to the objects of , there exists a unique monoidal
functor  extending  on objects. See again \cite
[Corollary 1]{acta}  for a proof in the single-sorted case. 

Now let  be a cancellative monoid, fixed for the rest of the paper.
Since the elements of  are meant to be objects in an appropriate monoidal
category, they will be denoted by capital letters. With a slight abuse of the
notation,  will no longer mean the free monoid generated by , rather, its
quotient by the equation . Accordingly, by  we mean the monoidal
category of -permutation symbols, rather than that of ordinary -permutations.
We do so in order to accommodate the assumption that our monoidal categories
are strict. Permutations over  in this new sense will then be called 
-permutation {\em symbols\/} to restore unambiguity. Let 
be the unique homomorphism (counit map) determined by the identity function on .
Again, this time with a heavier abuse of the terminology and coherence, the -permutation
symbol  will also be called one with ``domain'' 
and ``codomain'' . As an escape, however, we shall use the distinctive
notation  and say that permutation symbols 
and  are {\em composable\/} if they are such as proper morphisms
in the category . 

Let  be an -permutation symbol with , where . In the monoidal category
,  defines an -permutation symbol
.
On the other hand,  also gives rise naturally to the -permutation
symbol , where . Clearly, 
 and  define the same permutation
 in every monoidal category
having  as its object structure. Therefore we say that these
two -permutation symbols 
are {\em equivalent\/} and write  . As a trivial, but representative example:
.

 We shall be dealing with -sorted algebras  having
the following operations and constants.
\vsp \newline 
  -- For each -permutation symbol , a unary operation 
    .
\newline
  -- For each , a binary operation sum, .
\newline
  -- For each , a constant .
\newline
  -- For each , a unary operation trace, .
\vsp

To emphasize the categorical nature of such algebras we call the elements 
morphisms and write . We also write  as an alternative
for .   
Note that cancellativity of  is required in order to make the trace operation sound.
Moreover, the accurate notation for trace would be , but the intended object 
 will always be clear from the context.
Also notice the boldface notation  as opposed to .
For better readability we shall write  for , that is, for indexing
 by permutation symbol .

Composition () and tensor () are introduced in 
as derived operations in the following way.      
\vsp\newline
  -- For  and , . 
\newline
  -- For  and , .
\vsp\newline
See Fig.\ 1. Again, the accurate notation for  and  would use the 
objects  as subscripts, but these objects will always be clear 
from the context. Observe that the above definition of composition and tensor
is in line with the traced monoidal category axioms in \cite{tra,concur}. 
Regarding composition, see also \cite[Identity ]{acta}. As we shall point out
in Theorem~1 below, our trace operation models the so called 
``canonical'' trace concept (cf.\ \cite{tra}) in SDCC categories. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.8]{turf1.eps}
\end{center}
\vspmm
\caption{Composition (a) and tensor (b) in }
\vspmmm \vspmini
\end{figure}
\begin{definition}
{\em An {\em indexed monoidal algebra\/} over  is an -sorted algebra  equipped with the operations and constants listed above,
which satisfies the following equational axioms.
\vsp\newline
  I1.\ {\em Functoriality of indexing}

    for  and
   composable , ;

    for .
\newline
 I2.\ {\em Naturality of indexing}

   
    for , , , ;

   
    for , .
\newline
I3.\ {\em Coherence}

     for , whenever .
\newline
 I4.\ {\em Associativity and commutativity of sum}

     for , , ;

     for , .
\newline
 I5.\ {\em Right identity}

     and  for .
\newline
 I6.\ {\em Symmetry of identity}

    .
\newline
 I7.\ {\em Vanishing} 

     for ;

    
     for .
\newline
 I8.\ {\em Superposing}

     for , .
\newline
 I9.\ {\em Trace swapping}

    
    for .
}
\end{definition}
The algebra  is called {\em small\/} if  is a small monoid 
in the sense of \cite{mcl} and the
sets  are also small for every .

  Let  and  be indexed monoidal algebras. An {\em indexed monoidal 
homomorphism\/}  is a pair , where
 is a monoid homomorphism 
and  are mappings
that determine a homomorphism in the usual algebraic sense. With respect to indexing
we mean that for every  and , , where  is the unique monoidal functor  determined
by . The category  then consists of all small indexed monoidal
algebras as objects and indexed monoidal homomorphisms as morphisms.
\begin{theorem}
The categories  and  are equivalent.
\end{theorem}
{\em Proof.\ \ }
Let  be a small indexed monoidal algebra over , and define the monoidal category
 over the objects  as follows.
Morphisms  and identities in  are exactly those in , while
composition and tensor are adopted from  as derived operations.
Symmetries  in  are the morphisms 
.
In general, every permutation symbol  is represented in 
as . 
For each self-adjunction , the unit
map  and the counit map  are both the 
identity . It is essentially routine to check that 
is a locally small SDCC category. Below we present the justification of some milestone
equations, which can easily be developed into a complete rigorous proof.
\vspe
1.\ \ {\em Symmetry of trace, and canonical trace}
\vsp

     for .
\vspp\newline
See Fig.\ 2.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{turf44.eps}
\end{center}
\vspmini
\caption{Symmetry of trace, and canonical trace (read from right to left, bottom-up)}
\end{figure}
\newline
2.\ \ {\em Left identity}
\vsp
 
      for 
\vspp\newline
See Fig.\ 3.
\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{turf5.eps}
\end{center}
\vspmini
\caption{Left identity}
\end{figure}
\newline
Notice that the symmetry of trace and that of  have both been used in
the proof.
\vspe
3.\ \ {\em Tensor of identity}
\vsp

   
\vspp\newline
See Fig.\ 4.
\begin{figure}
\begin{center}
\includegraphics[scale=0.53]{turf6.eps}
\end{center}
\vspmini
\caption{Tensor of identity, take }
\vspmini 
\end{figure}
\vspe
The definition of functor  on (homo-)morphisms is evident, and left to the reader.

Conversely, let  be a locally small SDCC category over  as objects, and define the indexed
monoidal algebra  as follows. For each , , the (small) set of morphisms  in . Since 
is symmetric, every permutation symbol  determines a permutation
 in . Then, for ,
define . Notice that indexing
indeed becomes the restriction of the covariant  functor to permutations, as intended.
For  and ,  and
. For ,  is 
defined as the canonical trace of the morphism  in
 that corresponds to  according to compact closure. That is,
 is the morphism  in
.

In the light of this translation, each of
the equations I1-I9 is either a standard monoidal category axiom or has been observed
in \cite{tra,cc} for traced monoidal or compact closed categories.
Thus,  is an indexed monoidal algebra. The specification of
functor  on morphisms (monoidal functors) is again straightforward.

By definition, . On the other hand, the only difference
between the monoidal categories  and  is that the hom-sets 
 in the latter are identified with the ones  of the former,
using the natural isomorphisms given by the self-adjunctions . 
In other words, morphisms  in  -- as provided for by compact
closure -- are simply renamed as they appear in . Thus,
there exists a natural isomorphism between the functors  and ,
so that the categories  and  are equivalent as stated. 
\vege 
\section{Coherence in indexed monoidal algebras}
In general, a coherence result for some type  of monoidal categories is about
establishing a left-adjoint for a forgetful functor from the category  of
-monoidal categories into an appropriate syntactical category, and providing a graphical
characterization of the free monoidal -categories so obtained. For some typical
examples, see \cite{mcl,cc,acta,tcs}. In this section we present such a 
coherence result for SDCC categories, but phrase it in terms of indexed monoidal algebras.
The graphical language arising from this result will justify our efforts in the previous
section to reconsider SDCC categories in the given algebraic context.

For a set  of sorts, an -{\em ranked alphabet} (signature) is a set 
, where 
if . A morphism  between ranked alphabets of sort
 and , respectively, is an {\em alphabet mapping\/} consisting of a function
 and a family of mappings .
(The unique extension of  to strings is denoted by  as well.)
Every indexed monoidal algebra  can be considered
as an -ranked alphabet  in such a way that  for every . (The identification
 is still in effect for .) We use a subscript to distinguish
between instances of  belonging to different ranks. If  is a homomorphism, then  is 
the alphabet mapping  for which .
Our aim is to provide a left adjoint for the functor . In algebraic terms this 
amounts to constructing the indexed monoidal algebra freely generated by a given 
-ranked alphabet .

Let  be an -ranked alphabet. By a -{\em graph\/} we mean a
finite undirected and labeled multigraph  with vertices (nodes) , edges , and
labeling , where  and
 are special symbols not in  with rank  and (), respectively.
Vertices labeled by  () will be called {\em interface\/} (respectively,
{\em loop\/}) vertices. All other vertices, as well as the edges connecting them will be 
called {\em internal\/}. It is required that the label of each node  be consistent 
with its degree , so that if , then . Each point at which 
an edge impinges on  is assigned a serial number  and a sort
 in such a way that . Adopting a terminology from \cite
{tcs,mil}, such points will be referred to as {\em ports}. Edges, too,
must be consistent with the labeling in the sense that each edge connects two
ports of the same sort, and each port is  an endpoint of exactly one edge. The
interface nodes themselves are assigned a serial number, so that one can speak
of a -graph  with  being the string of sorts assigned to (the
unique ports of) the interface vertices in the given order. See Fig.~5a for an
example   graph , where  with  and . Symbols in
 are represented as {\em atomic\/} -graphs in the way
depicted by Fig.~5b. 
\begin{figure}[h]
\begin{center} 
\includegraphics[scale=0.7]{turf2.eps}
\end{center}
\vspmini
\caption{-graphs}
\vspmini
\end{figure}


An {\em isomorphism\/} between -graphs  is a graph isomorphism that
preserves the labeling information of the vertices. We shall not distinguish between
isomorphic graphs. Let  denote the set of -graphs
of rank . The family  is
equipped with the indexed monoidal algebra operations (over the monoid ) 
as follows.
\vsp\newline
-- For a graph , each permutation symbol  is interpreted as
the relabeling of the interfaces according to the -permutation (not symbol!)
, where  is the counit map.
\newline
-- For graphs  and ,  is the disjoint union of
 and  with the serial number of each interface vertex in  incremented by
.
\newline
-- The identity graph  for  is shown in Fig.~5c. The graph
 is empty.
\newline
-- For a graph  with , the trace operation  is defined by gluing 
together the pairs of edges incident with the interface vertices having serial numbers 
 and  for each , leaving out the interface vertices themselves. 
Whenever this procedure results in a loop of an even number of edges
(but no internal vertices) glued together,
a new loop vertex labeled by  is created and added to the graph, where
 is the common sort of the interface ports involved in the loop. 
\vsp

See \cite{hel} for
a more detailed description of  through examples. See also \cite{elg,blo,acta,tcs}
for the corresponding standard definition of feedback/iterarion in (directed) flow\-charts. 
Interestingly,
in all of these works, graphs (flowcharts) are equipped with a single loop vertex, so that
loops do not multiply when taking the feedback. On the other hand, the loop vertex is present in the 
graph  as well. Regarding the single-sorted case
this amounts to imposing the additional axiom  (rather, its
directed version, e.g.\ \cite[Axiom S5: ]{acta}), which is not
a standard traced monoidal category axiom. From the point of view of axiomatization this is a 
minor issue. Another issue, however, namely the assignment of an
individual monoid to each object  is extremely important and interesting.
In terms of flowcharts,
this allows one to erase begin vertices and join two incoming edges at any given port. 
See e.g.\ the constants  and  in \cite {acta,tcs}. 
These constants (morphisms) were naturally incorporated in the axiomatization of schemes,
both flowchart and synchronous. Concerning undirected
graphs, the presence of such morphisms with a ``circularly symmetric'' interface allows for
an upgrade of ordinary edges to hyperedges, exactly the way it is described in
\cite{mil} for bigraphs. The axiomatization of undirected hypergraphs as SDCC categories 
will be presented in a forthcoming paper.

It is easy to check that the above interpretation of the indexed monoidal operations on
 satisfies the axioms I1-I9. Thus,  is an indexed
monoidal algebra over the monoid . It is also clear that  is
generated by , that is, by the collection of the atomic -graphs.
(See again Fig.~5b.) Indeed, every undirected graph can be reconstructed from
its vertices as star graphs by adding internal edges one by one using the
trace operation. 
\begin{theorem}
The algebra  is freely generated by . 
\end{theorem}
{\em Proof.\ \ }
Without essential loss of generality, we restrict our attention to the
single-sorted case. One way to prove the statement is to copy the normal form construction
for flowchart schemes as presented in \cite{acta}. Each step in this construction
\cite [Theorem 3.3]{mun} is completely analogous, except that one relies on undirected trace 
rather than directed feedback to create internal edges. 
Another idea that uses the corresponding result \cite[Corollary 2]{acta} 
directly
is the following. For each symbol  (), consider the set of 
doubly ranked symbols  of rank  such that  and  are disjoint 
subsets of  with cardinality  and  respectively, and
. (Split the degrees into in-degrees and out-degrees in all possible ways.) Denote by
 the doubly ranked alphabet consisting of these new symbols. Construct
the free traced monoidal category   of -flowchart schemes
\cite{acta}, and consider the rank-preserving mapping  from
 into the SDCC category . Now let  be an
arbitrary indexed monoidal algebra over monoid  and specify  arbitrarily 
together with a mapping , where 
 is an arbitrary morphism in .
Since  is freely generated by , there are unique
traced monoidal functors  and   from  into 
 and  extending  and ,
respectively. One can then easily prove by induction that the desired unique SDCC functor
from  into  extending  factors through an
arbitrary inverse of , and . Hence, the statement of the theorem
follows from Theorem~1.

A really elegant third proof, however, would use the  construction in \cite{tra}
-- alternatively, the -construction in \cite{concur} -- by duplicating each
degree into an in-degree and a corresponding dual out-degree. The reader
familiar with either of these constructions will instantly recognize the point in this
argument. The statement of the theorem is, however, not an immediate consequence
of applying the construction to an appropriate traced monoidal category,
which is why we have chosen the above short and simple direct proof here.
\vege


Let  be an arbitrary indexed monoidal algebra over . An {\em interpretation\/}
of  in  is an alphabet mapping .
By Theorem~2, every interpration  can be extended in a unique way to a 
homomorphism . Thus,  is indeed a
left adjoint for the functor .
\section{Turing automata and Turing graph machines}
As an important example of indexed monoidal algebras, in this section we introduce the
algebra of Turing automata and Turing graph machines. We shall use the monoidal 
category  (small sets and bijections with disjoint union as tensor) as the
index category. Unfortunately, this category is not
strict, therefore the reader is asked to be lenient about the finer details. The only
``shaky'' ground will be the interpretation of set-permutation symbols as bijections
in the category , which is quite natural.
For a set , let ,
where  is a fixed symbol, called the {\em anchor}. 
\vspmini
\begin{definition}
{\em A {\em Turing automaton\/}  is a triple , where  is a set of
{\em interfaces},  is a nonempty set of {\em states}, and 
is the {\em transition relation}.}\vspmini
\end{definition}


The role of the anchor as a distinguished interface will be explained later.
The transition relation  can either be considered as a function
 or as a function , giving rise to a Mealy or Medvedev type automaton,
respectively. We shall favor the latter interpretation, and define  to be
{\em deterministic\/} if  is a partial function in this sense. Thus,
an input to automaton  is a pair  of interfaces. Nevertheless, we
still say that  has a transition from  to  in state , resulting in
state , if . By way of duality, one can also
consider  as an automaton with states  and inputs . We
shall reflect on this duality shortly. If  is finite and , then
 can be viewed as an  matrix, where each entry is a
relation over . 
\vspp \newline 
{\bf Example}\ \ The
{\em -ary atomic switch\/} is the Turing automaton  () 
having states , so that  
\vspmmm


For better readability, states, indicating a selected edge in an -star graph,
 are written in boldface. In addition, if , then
. 

  Heuristically, the -ary atomic switch captures the behavior of an atom in a molecule
having  chemical bonds to neighboring atoms. Among these bonds exactly one is double,
and referred to as the {\em positive\/} edge in the underlying star graph. 
The mechanism of switching is then clear by the definition above. The active ingredient
(control) in this process is called the {\em soliton\/}, which is a form of energy traveling
in small packets through chains of alternating single and double bonds within the molecule,
causing the affected bonds to be flipped from single to double and vice versa.
See \cite{dav} for the physico-chemical details, and \cite {das,tcss,det} for the corresponding
mathematical model. Note that, by our definition above, whenever the soliton enters
an atom with a unique chemical bond (which must be double since ), it bounces
back immediately, producing no state change.
\vspp
 
  We now turn to defining the indexed monoidal algebra  of Turing automata.
In this algebra, morphisms are Turing automata
. A permutation symbol  is interpreted as a relabeling of the
interfaces according to the unique bijection  determined by  in .
(Elaboration of details regarding the transition relation is left to the reader.)
The sum of  and  having states  and , respectively, is the automaton
, where  is defined by 

 (Notice the ambiguity in writing just
 rather than  or .) The definition, however, applies to
the case  and/or , too, so that taking the sum of  and  amounts to
a selective performance of  or  on . 
The identity Turing automaton  has a single state, in which there is a
transition from  to  and back for every
.

The definition of  for a Turing automaton  is complicated but
natural, and it holds the key to understanding the Turing-machine-like behavior of
this automaton. Intuitively, the definition models the behavior of loops in
flowchart algorithms \cite{elg} when implemented in an undirected environment.
That is, control enters  at an interface , then, after alternating
between corresponding interfaces in  any number of times, it leaves at another
(or the same) interface . State changes are traced interactively during
this process. For technical reasons we shall restrict the formal definition of
trace to finitary Turing automata, whereby the number of interfaces is finite. This
will allow us to set up an analogy with the well-known Kleene construction
for converting a finite state automaton into a regular expression. 

Let  be a Turing automaton and  be arbitrary 
such that . Following the Kleene construction, concentrate on the relations 
 () as transitions of the automata
 from interface  to interface . Our goal is to satisfy the
Kleene formula
\vspmini

for every proper subset  and . In this
formula,  denotes alternating matrix product in the sense
\vspmini

and  is Kleene star of  matrices based on , that is,
, where  is the alternate identity matrix 
 and 
. The underlying semiring  is that of binary relations
over  with union as sum, composition as product,  as unit and 
as zero. Notice the immediate relationship between our  and the star
operation in star theories as defined in \cite{iter}, e.g.\ in Conway matrix
theories. See also the Example in \cite{tra}, which originates from
\cite{iter}, too. As well, note the 
duality between states and input in comparison with the original Kleene formula.
The alternating matrix product is another hidden allusion to the  construction
\cite{tra} mentionned earlier, suggesting that the compact closed category resulting
from that construction be restricted to its ``self-dual'' objects .

We are using the above formula as a recursive definition for , starting
from the basis step 

The transition relation  of  is then set 
in such a way that  iff .
In order to use this definition, one must prove that the specification of
 does not depend on the order in which the elements 
are left out. This statement is essentially equivalent to axiom I9 (trace swapping).
\begin{theorem}
The algebra  of Turing automata is indexed monoidal.
\end{theorem}
{\em Proof.\ \ }
At this point we can capitalize to a great extent on the simplicity of the indexed
monoidal algebra axioms. Indeed, each of these axioms, except for vanishing (I7)
and trace swapping (I9), holds naturally true in . The vanishing axiom
expresses the fact that choosing the Kleene formula to define trace in 
is right, and trace
swapping ensures that the definition is correct. The proof of these two axioms
is left to the reader as an exercise. 
\vege


Finally, we explain the role of the anchor . We did not want all Turing automata
of sort  to have no transitions at all, like the automata , which all coincide, having a unique state. The
anchor is a fixed interface that is not supposed to be interconnected with any
other, so that automata in  might still have transitions from  to .
The index category itself, however, need not be
that of pointed sets, because the anchor is not affected by any of the operations.

Let  be a non-empty set of data. The indexed monoidal algebra \dil  of
-{\em flow\/} Turing automata is defined in the following way.
\vsp\newline
-- Morphisms of sort  are Turing automata .
\newline
-- Each permutation symbol  is interpreted as a bijection (relabeling)
, which is basically  performed on blocks
of size  in parallel.
\newline
-- The operations sum and trace are adopted from  (assuming the identification
of  with ), and
the identities  are the identities  in .
\vsp

  The notation \dil\ originates from \cite{arnold}, where the magmoid
(single-sorted monoidal category) \dil  was introduced for integer
 and magmoid  along these lines. Intuitively, a -flow Turing
automaton is a data-flow machine in which data in  are passed along with
each transition. Notice that the anchor does not emit or receive any data. As
an immediate corollary to Theorem~3, the structure \dil  of
-flow Turing automata is an indexed monoidal algebra. 
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{turf3.eps}
\end{center}
\vspmini
\caption{The von Neumann machine}
\vspmini
\end{figure}


Consider, for
example, the scheme  of the classical von Neumann computer in Fig.~6 as a data-flow
architecture. It consists of two interconnected single-sorted -flow Turing automata: 
the processor , and the memory . The processor is a real finite state
automaton, having state components like registers, the instruction counter, the PSW, etc. 
The transitions of  are very complex. On the other hand,  has (practically) infinite states, 
but its transitions are straightforward. The set  consists of all pieces of 
information (data, control, and/or address) that can be transmitted along the bus
line between  and  in either direction. The operation of  need not be explained, 
and it is clearly that of a -flow Turing automaton. It is a very
important observation, however, that the machine can do as much as we want in one
step, that is, from the time control enters port  of  until it leaves at
the same port. For example, it can execute one machine instruction stored in the
memory, or even a whole program stored there. In other words, semantics
is delay-free. In present-day digital computers this semantics is achieved by limiting
the scope of what the machine can do in one step through introducing clock
cycles and delay, which turn the computer into a synchronous system \cite{tcs}.
Theoretically speaking, undirected trace is turned into directed feedback with
delay (or, using an everyday language, recursion is transformed into a loop),
and  computations become inevitably directed in a rigid way. According to the original
scheme , however, they need not be, yet they could be universal.
\vspp\newline
{\bf Example} (Continued)\ \ The -ary atomic {\em alternating\/} switch 
 augments 
the ordinary -ary atomic switch by the passing of a digital information in the following
way. Control from a negative interface (i.e., one not covered by the unique positive edge)
can only take 0 for input and emits 1 for output. (Remember that in the meantime the
positive edge is switched from the output side to the input side.) Conversely, control
from a positive interface can only take 1 for input and emits 0 for output. 
Transitions from and to the anchor are as in the corresponding -ary switch.

For the rest of the paper, the alphabet  will be single-sorted, that is,
.
\begin{definition} {\em A {\em -flow Turing graph machine\/} 
over  is a triple
, where  is a -graph and  is an interpretation of 
in  under which the single sort of  is mapped into the {\em finite\/} set .
Equivalently,  is an interpretation in \dil  that maps sort
``1'' to object .} 
\end{definition}


Intuitively, machine  comes with an underlying graph  that has a -flow Turing 
automaton sitting in each of its internal vertices. The operation of  as a complex
Turing automaton is uniquely determined by the given interpretation according to the homomorphism
. The classical Turing machine concept is recaptured by taking , where  stands for ``tape cell''. A Turing machine  is 
transformed into a -flow Turing graph machine  whose underlying graph is a linear
array of cell vertices with the following interpretation  of . The states of  are
the tape symbols of , and, by way of duality, elements of  are the states of .
The transition relation of  translates directly and naturally into that of ,
using duality. The only shortcoming of this
analogy is the finiteness of the underlying graph , which can be ``compensated'' by
making the set of states  infinite, e.g., taking the colimit of finite approximation
automata in an appropriate extension of  to a 2-category, whereby the
vertical structure is determined by homomorphisms of (Medvedev type) automata
in the standard sense.  Universality is then guaranteed either by the von Neumann machine
 or by the universal Turing machine, as special Turing automata.

Returning to our dilemma of reversible vs.\ irreversible computations, we define the
``reverse'' of a Turing automaton  simply as .
Although this definition is quite natural, one cannot expect that, for every computation
process represented by some Turing automaton , both  and  be deterministic.
Indeed, this restriction would directly undermine universality. Eventually,
the point is not to actually perform the reverse of a given computation,
rather, being able to carry it out on a device that is in principle 
reversible. Turing graph machines do have this capability by definition.
Still, the effective construction of a universal Turing graph
machine remains an enormous challenge. The soliton automaton model described
below is an interesting try, but unfortunately it falls short of being universal
even in terms of designing individual ad-hoc machines.
To introduce this model as a Turing graph machine, let  be the
ranked alphabet consisting of a single symbol  for each rank .
\vspp\newline
{\bf Example} (Continued)\ \   A {\em pre-soliton automaton\/} is a Turing graph
machine , where  is the fixed interpretation
that sends each symbol  into the -ary atomic alternating 
switch . 
Since the interpretation is fixed, we shall
identify each pre-soliton automaton with its underlying graph. Moreover, since
 is circularly symmetric, we do not need to
order the ports (degrees) of the internal vertices. Thus,  is an ordinary undirected
graph (with its interface vertices still ordered, though). 
\vsp

Let  be a state of graph . By definition, each internal edge  is either {\em consistent\/}
with respect to , meaning that  has the same sign (positive or negative) viewed from its two
internal endpoints, or {\em inconsistent\/} if this is not the case. 
(Notice that a looping edge is always negative if consistent.) A {\em soliton walk\/}
from interface  to interface  () is a transition of  from  to 
in state  according to the standard behavior of  as a Turing automaton. The 
reader can now easily verify that this definition of soliton walks coincides with the
original one given in \cite{das}, provided that  is a {\em perfect internal matching\/} 
\cite {lov,tcss}
of , that is, a state in which every edge of  is consistent and the positive edges
determine a matching by which the internal vertices are all covered. Indeed, the definition
of  implies that the soliton can only traverse consistent
edges in an alternating positive-negative fashion.  A new feature of this model is a soliton
walk from the anchor, which must return to the anchor if  is a perfect internal matching,
and in that case it defines a closed alternating walk (e.g.\ an alternating
cycle).

At this point we stop elaborating on soliton automata, leaving them as a subject for future
work. The key observation that allows one to restrict the states of pre-soliton automata to
perfect internal matchings is the Gallai-Edmonds Structure Theorem \cite{lov}, well-known in
matching theory. On the basis of this theorem, the Gallai-Edmonds algebra of graphs having
a perfect internal matching has been worked out in \cite{mun} as the homomorphic image of
the indexed monoidal algebra of graphs. The algebra (SDCC category) of soliton automata then turns out 
to be the quotient of  determined by the pushout of the Gallai-Edmonds algebra homomorphism 
and  in the category . This result will be presented in a 
forthcoming paper. 
\bibliographystyle{eptcs} \begin{thebibliography}{11}

\bibitem{concur} S.\ Abramsky (1996):
\newblock {\em Retracing some paths in process algebras}.
In
\newblock {\sl Proceedings of CONCUR 1996},
\newblock {\sl Springer Lecture Notes in Computer Science} 
1119, pp.\ 1--17.
\bibitem{abr} S.\ Abramsky (2005): 
\newblock {\em A structural approach to reversible computation}.
\newblock {\sl Thoret.\ Comput.\ Sci.} 347, pp.\ 441--464.
\bibitem{abst}S.\ Abramsky (2005):
\newblock {\em Abstract Scalars, Loops, and Free Traced and Strongly Compact Closed
Categories}.
In
\newblock {\sl Proceedings of CALCO 2005},
\newblock {\sl Springer Lecture Notes in Computer Science} 3629 pp.\ 1--31.
\bibitem{arnold} A.\ Arnold \& M.\ Dauchet (1978-79):
\newblock {\em Th\'eorie des magmo\"{\i}des}. 
\newblock {\sl RAIRO Inform.\ 
Th\'eor.\ Appl.} 12, pp.\ 235--257, and 13, pp.\ 135--154.
\bibitem{acta} M.\ Bartha (1987):
\newblock {\em A finite axiomatization of flowchart schemes}.
\newblock {\sl Acta Cybernet.} 
8, pp.\ 203--217. 
\newblock Available at \url{http://www.mun.ca/~bartha}.
\bibitem{tcs} M.\ Bartha (1987): 
\newblock {\em An equational axiomatization of systolic systems}.
\newblock {\sl Theoret. Comput. Sci.} 55, pp.\ 265--289.
\bibitem{hel} M.\ Bartha \& H.\ J\"urgensen (1989):
\newblock {\em Characterizing finite undirected multigraphs as indexed algebras}.
\newblock {\sl Department of Computer Science, The University of Western Ontario,
Technical Report} No.\ 252, pp.\ 1--23. 
\newblock Available at \url{http://www.mun.ca/~bartha}.
\bibitem{mun} M.\ Bartha \& E.\ Gomb\'as (1991):
\newblock {\em The Gallai-Edmonds algebra of graphs}.
\newblock {\sl Department
of Computer Science, Memorial University of Newfoundland, Technical Report}
No.\ 9105, pp.\ 1--23.
\newblock Available at \url{http://www.mun.ca/~bartha}.
\bibitem{tcss} M.\ Bartha \& M.\ Kr\'esz (2003):
\newblock {\em Structuring the elementary components of
graphs having a perfect internal matching}. 
\newblock {\sl Theoret.\ Comput.\ Sci.} 299, pp.\ 179--210.
\bibitem{det} M.\ Bartha \& M.\ Kr\'esz (2006):
\newblock {\em Deterministic soliton graphs}.
\newblock {\sl Informatica} 30, pp.\ 281--288.
\bibitem{blo} S.\ L.\ Bloom \& Z.\ \'Esik (1985):
\newblock {\em Axiomatizing schemes and their behaviors}.
\newblock {\sl J.\ Comput.\ System Sci.} 31, pp.\ 375--393.
\bibitem{iter} S.\ L.\ Bloom \& Z.\ \'Esik (1993):
\newblock {\sl Iteration Theories: The
Equational Logic of Iterative Processes},
Springer Verlag, Berlin.
\bibitem{bur} R.\ M.\ Burstall, J.\ A.\ Goguen \& A.\ Tarlecki (1989):
\newblock {\em Some fundamental tools
for the semantics of computation. Part 3: Indexed categories}.
\newblock {\sl Laboratory for Foundations of Computer Science, University of Edinburgh}
Report ECS-LFCS-89-90.
\bibitem{das} J.\ Dassow \& H.\ J\"{u}rgensen (1990):
\newblock {\em Soliton automata}.
\newblock {\sl J.\ Comput.\ System Sci.} 40, pp.\ 154-181.
\bibitem{dav} A.\ S.\ Davidov (1985):
\newblock {\sl Solitons in Molecular Systems}, Reidel, Dordrecht.
\bibitem{elg} C.\ C.\ Elgot (1975):
\newblock {\em Monadic computations and iterative algebraic theories}.
In 
\newblock {\sl Proceedings of Logic Colloquium 1973}, 
\newblock {\sl North Holland Studies in Logic and the Foundations of Mathematics}
80, pp.\ 175--230.
\bibitem{tra} A.\ Joyal, R.\ Street \& D.\ Verity (1996):
\newblock {\em Traced monoidal categories}. 
\newblock {\sl Math.\ Proc.\ Camb.\ Phil.\ Soc.} 119, pp.\ 447--468.
\bibitem{cc} G.\ M.\ Kelly \& M.\ L.\ Laplaza (1980):
\newblock {\em Coherence for compact closed categories}.
\newblock {\sl J.\ Pure Appl.\ Algebra} 19, pp.\ 193--213.
\bibitem{landa} R.\ Landauer (1961):
\newblock {\em Irreversibility and heat generation in the computing process}. 
\newblock {\sl IBM J.\ Res.\ Development} 5, pp.\ 183--191.
\bibitem{lov} L.\ Lov\'asz \& M.\ D.\ Plummer (1986):
\newblock {\sl Matching Theory}, North Holland, Amsterdam.
\bibitem{mcl} S.\ MacLane (1971):
\newblock {\sl Categories for the Working Mathematician}, Springer, Berlin.
\bibitem{mil} R.\ Milner (2009):  
\newblock {\sl The Space and Motion of Communicating Agents}, 
Cambridge University Press, Cambridge.
\end{thebibliography}
\end{document}
