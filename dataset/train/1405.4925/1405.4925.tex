\documentclass[english]{amsart}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amssymb}

\providecommand{\tabularnewline}{\\}

\numberwithin{equation}{section}
\numberwithin{figure}{section}
\newtheorem{thm}{Theorem}
  \newtheorem{example}[thm]{Example}
  \newtheorem{defn}[thm]{Definition}
  \newtheorem{lem}[thm]{Lemma}
  \newtheorem{notation}[thm]{Notation}
  \newtheorem{prop}[thm]{Proposition}
  \newtheorem{rem}[thm]{Remark}
  \newtheorem{algorithm}[thm]{Algorithm}
  \newtheorem{cor}[thm]{Corollary}

\makeatother

\begin{document}

\title{Cylindrical Algebraic Decomposition Using Local Projections}

\author{Adam Strzebo\'nski}

\address{Wolfram Research Inc., 100 Trade Centre Drive, Champaign, IL 61820,
U.S.A. }

\email{adams@wolfram.com}


\maketitle

\begin{abstract}
We present an algorithm which computes a cylindrical algebraic decomposition
of a semialgebraic set using projection sets computed for each cell
separately. Such local projection sets can be significantly smaller
than the global projection set used by the Cylindrical Algebraic Decomposition
(CAD) algorithm. This leads to reduction in the number of cells the
algorithm needs to construct. We give an empirical comparison of our
algorithm and the classical CAD algorithm.
\end{abstract}

\section{Introduction}

A semialgebraic set is a subset of  which is a solution
set of a system of polynomial equations and inequalities. Computation
with semialgebraic sets is one of the core subjects in computer algebra
and real algebraic geometry. A variety of algorithms have been developed
for real system solving, satisfiability checking, quantifier elimination,
optimization and other basic problems concerning semialgebraic sets
\cite{C,BPR,CJ,CMXY,DSW,GV,HS,LW,R,T,W1}. Every semialgebraic set
can be represented as a finite union of disjoint cells bounded by
graphs of algebraic functions. The Cylindrical Algebraic Decomposition
(CAD) algorithm \cite{C,CJ,S7} can be used to compute a cell decomposition
of any semialgebraic set presented by a quantified system of polynomial
equations and inequalities. An alternative method of computing cell
decompositions is given in \cite{CMXY}. Cell decompositions computed
by the CAD algorithm can be represented directly \cite{S7,S8,B2}
as cylindrical algebraic formulas (CAF; see the next section for a
precise definition). A CAF representation of a semialgebraic set 
can be used to decide whether  is nonempty, to find the minimal
and maximal values of the first coordinate of elements of , to
generate an arbitrary element of , to find a graphical representation
of , to compute the volume of , or to compute multidimensional
integrals over  (see \cite{S4}). 

The CAD algorithm takes a system of polynomial equations and inequalities
and constructs a cell decomposition of its solution set. The algorithm
consists of two phases. The projection phase finds a set of polynomials
whose roots are sufficient to describe the cell boundaries. The lifting
phase constructs a cell decomposition, one dimension at a time, subdividing
cells at all roots of the projection polynomials. However, some of
these subdivisions may be unnecessary, either because of the geometry
of the roots or because of the Boolean structure of the input system.
In this paper we propose an algorithm which combines the two phases.
It starts with a sample point and constructs a cell containing the
point on which the input system has a constant truth value. Projection
polynomials used to construct the cell are selected based on the structure
of the system at the sample point. Such a local projection set can
often be much smaller than the global projection set used by the CAD
algorithm. The idea to use such locally valid projections was first
introduced in \cite{JM}, in an algorithm to decide the satisfiability
of systems of real polynomial equations and inequalities. It was also
used in \cite{B4}, in an algorithm to construct a single open cell
from a cylindrical algebraic decomposition. 
\begin{example}
\label{exa:MainExample}Find a cylindrical algebraic decomposition
of the solution set of ,
where , , and .

\includegraphics[width=0.65\columnwidth, trim = -50mm 3mm 20mm 5mm, clip]{Example}

The solution set of  is equal to the union of the open ellipse
 and the intersection of the closed disk  and
the set  bounded by a Lissajous curve. As can be seen
in the picture, the set is equal to the open ellipse . The
CAD algorithm uses a projection set consisting of the discriminants
and the pairwise resultants of , , and . It
computes a cell decomposition of the solution set of  by constructing
 cells such that all , , and  have a
constant sign on each cell. Note however, that a cell decomposition
of the solution set of  can be obtained by considering the following
 cells. On each cell only some of , , and 
have a constant sign, but those signs are sufficient to determine
the truth value of .
\begin{enumerate}
\item  is  on 
because .
\item  is  on  and on 
because .
\item  is  on  and on 
because .
\item  is  on  and on  because .
\item  is  on  and on  because
.
\item  is  on  because .
\item  is  on  and on  because
.
\item  is  on  because .
\end{enumerate}
Determining the cell bounds for the cell stack - requires
computation of roots of , , and
 in  and roots of  and 
in . Determining the cell bounds for the cells  requires
computation of roots of  and  in
 and roots of , ,  and
 in . Determining the cell bounds for the cell stacks
- and - requires computation of roots of ,
, , ,  and 
in . Polynomial  is not used to compute any of the projections
and its roots in  are computed only for two values of . The
algorithm we propose in this paper computes a cell decomposition of
the solution set of  by constructing the  cells given in
-. Details of the computation for this example are given
in Section \ref{sub:Example}.
\end{example}

\begin{example}
Find a cylindrical algebraic decomposition of the solution set of
 in the variable order .

In this example the system is not well-oriented, hence the CAD algorithm
needs to use Hong's projection operator for the first three projections.
However, the additional projection polynomials are necessary only
for the cells on which a McCallum's projection polynomial vanishes
identically. For most cells local projection can be computed using
McCallum's projection operator, and for the few cells on which a McCallum's
projection polynomial vanishes identically local projection needs
to use some, but usually not all, polynomials from Hong's projection
operator. The algorithm LPCAD we propose in this paper computes a
cell decomposition of the solution set of  by constructing 
cells in  seconds of CPU time. The CAD algorithm did not finish
the computation in  hours. A version of LPCAD using only local
projections based on Hong's projection operator constructs 
cells and takes  seconds of CPU time. 
\end{example}

\section{Preliminaries}

A \emph{system of polynomial equations and inequalities} in variables
 is a formula
where , and each 
is one of  or . 

A subset of  is \emph{semialgebraic} if it is a solution
set of a system of polynomial equations and inequalities. 

A \emph{quantified system of real polynomial equations and inequalities}
in free variables  and quantified variables 
is a formula 
 Where  is  or , and  is a system
of real polynomial equations and inequalities in .

By Tarski's theorem (see \cite{T}), solution sets of quantified systems
of real polynomial equations and inequalities are semialgebraic.
\begin{notation}
For , let  denote a -tuple 
of real numbers and let  denote a -tuple 
of variables.
\end{notation}
Every semialgebraic set can be represented as a finite union of disjoint
\emph{cells} (see \cite{L}), defined recursively as follows.
\begin{enumerate}
\item A cell in  is a point or an open interval.
\item A cell in  has one of the two forms
where  is a cell in ,  is a continuous
algebraic function, and  and  are continuous algebraic
functions, , or , and  on . 
\end{enumerate}
A finite collection  of cells in  is \emph{cylindrically
arranged} if for any  and  the projections
of  and  on  are either disjoint
or identical. 

Given a semialgebraic set presented by a quantified system of polynomial
equations and inequalities, the CAD algorithm can be used to decompose
the set into a cylindrically arranged finite collection of cells.
The collection of cells is represented by a cylindrical algebraic
formula (CAF). A CAF describes each cell by giving explicit algebraic
function bounds and the Boolean structure of a CAF reflects the cylindrical
arrangement of cells. Before we give a formal definition of a CAF,
let us first introduce some terminology.

Let  and let , where .
A \emph{real algebraic function} given by the \emph{defining polynomial}
 and a \emph{root number}  is the function
where  is the -th real root of .
The function is defined for those values of  for which
 has at least  real roots. The real roots
are ordered by the increasing value and counted with multiplicities.
A real algebraic number  given by a \emph{defining
polynomial}  and a \emph{root number}  is
the -th real root of . See \cite{S2,S4} for more details
on how algebraic numbers and functions can be implemented in a computer
algebra system.

Let  be a connected subset of . 
is\emph{ regular} on \emph{} if it is continuous on , 
for all , and there exist\emph{ }
such that for any  
is a root of  of multiplicity . 

 is \emph{degree-invariant} on  if there exist\emph{ }
such that if 
for all . 

A set  of polynomials is \emph{delineable}
on  if all elements of  are degree-invariant on  and for

where  are disjoint regular real algebraic
functions and for   and 
are either disjoint or equal. Functions  are \emph{root
functions of  over }.

A set  of polynomials is \emph{analytic
delineable} on a connected analytic submanifold  of 
if  is delineable on  and the root functions of elements of
 over  are analytic.

Let  be delineable on , let  be all root
functions of elements of  over , and let 
and . For , the -th \emph{-section
over } is the set
For , the -th \emph{-sector over } is
the set


A formula  is an \emph{algebraic constraint} with \emph{bounds}
 if it is a level- equational or inequality constraint
with  defined as follows.\emph{ }
\begin{enumerate}
\item \emph{A level}- \emph{equational constraint} has the form ,
where  is a real algebraic number, and .
\item \emph{A level}- \emph{inequality constraint} has the form ,
where  and  are real algebraic numbers, ,
or , and . 
\item \emph{A level}- \emph{equational constraint} has the form ,
where  is a real algebraic function, and .
\item \emph{A level}- \emph{inequality constraint} has the form ,
where  and  are real algebraic functions, ,
or , and . 
\end{enumerate}
A level- algebraic constraint  is \emph{regular} on a connected
set  if all elements of  are regular
on  and, if  is an inequality constraint,  on
.
\begin{defn}
An \emph{atomic cylindrical algebraic formula (CAF)}  in 
has the form , where  is a
level- algebraic constraint for  and 
is regular on the solution set of 
for . 

\emph{Level- cylindrical subformulas} are defined recursively
as follows
\begin{enumerate}
\item A level- cylindrical subformula is a disjunction of level-
algebraic constraints.
\item A level- cylindrical subformula, with , has the form
where  are level- algebraic constraints and  are
level- cylindrical subformulas.
\end{enumerate}
A \emph{cylindrical algebraic formula (CAF)} is a level- cylindrical
subformula  such that distributing conjunction over disjunction
in  gives 
where each  is an atomic CAF. 
\end{defn}
Given a quantified system of real polynomial equations and inequalities
the CAD algorithm \cite{S7} returns a CAF representation of its solution
set. 
\begin{example}
The following formula  is a CAF representation of the closed
unit ball.
where 

\end{example}

\section{CAD construction using local projections}

In this section we describe an algorithm for computing a CAF representation
of the solution set of a system of polynomial equations and inequalities.
The algorithm uses local projections computed separately for each
cell. For simplicity we assume that the system is not quantified.
The algorithm can be extended to quantified systems following the
ideas of \cite{CH}. The algorithm in its version given here does
not take advantage of equational constraints. The use of equational
constraints will be described in the full version of the paper.

The main, recursive, algorithm used for CAD construction is Algorithm
\ref{alg:LPCAD}. Let us sketch the algorithm here, a detailed description
is given later in this section. The input is\emph{ }a system \emph{
}of polynomial equations and inequalities and a point 
with . The algorithm finds a level- cylindrical
subformula  and a set of polynomials \emph{}
such that for any cell  containing 
on which all elements of  have constant signs\emph{ }
The formula  can be interpreted as a description of the solution
set of  as a finite collection of cylindrically arranged cells
in , parametrized by the values of .
The description is valid locally to , where the meaning
of {}``locally'' is determined by . The approach is to find
algebraic constraints 
 and cylindrical subformulas  such that the solution
sets of 
form a decomposition of  and  describes the solution
set of  locally to .
To find 's, 's, and  we start with a stack containing
the interval  and until the stack is emptied execute
the following steps. We take an interval  off stack and pick .
If evaluating the -variate polynomials in  at 
suffices to establish the truth value of , let  be a set of
-variate polynomials in  sufficient to establish the truth
value of  and let  be the truth value. Otherwise, let 
and  be, respectively, the formula and the set of polynomials
returned by Algorithm \ref{alg:LPCAD} applied to  and .
We use projection to compute a set \emph{}
such that  is delineable on any cell containing 
on which all elements of  have constant signs and we add the elements
of  to . Let  be the interval containing  bounded
by the nearest roots of elements of  and let  be the constraint
on  whose bounds are the corresponding algebraic functions.
Note that if  is delineable on a cell  containing 
then the elements of  have constant signs on 
and hence  is equivalent to  on . We add  and 
to the list of 's, 's, and, if  is nonempty,
we add the components of  to stack. When the stack
is empty we use projection to compute a set \emph{}
such the set of polynomials whose roots appear as bounds in 's
are delineable on any cell containing  on which all
elements of  have constant signs and we add the elements of 
to . As required, the formula 
is equivalent to  on any cell containing  on which
all elements of  have constant signs. 

To compute a CAF representation of the solution set of  we call
Algorithm \ref{alg:LPCAD} with .
\begin{notation}
We will use the following notations.
\begin{enumerate}
\item For a finite set of polynomials , let  denote the
set of irreducible factors of the elements of . 
\item Let  denote the irreducible elements of .
\item For a set  and  let 
denote the projection of  on .
\end{enumerate}
\end{notation}
In this section we assume that all polynomials have coefficients in
a fixed computable subfield , irreducibility
is understood to be in the ring of polynomials with coefficients in
, irreducible factors are always content-free and chosen in a
canonical way, and finite sets of polynomials are always ordered according
to a fixed linear ordering in the set of all polynomials with coefficients
in . In our implementation .

Whenever we write \emph{}
with  we include the possibility of , the only element
of . 


\subsection{Local projection}
\begin{defn}
Let  be a finite set of
polynomials and let ,
where . Let  be such that 
is a finite subset of  and 
for .  is a \emph{local projection sequence} for
 at  iff, for any  and any cell ,
if  and all elements of  for 
have constant signs on  then the set of elements of 
that are not identically zero on  is delineable
over . 
\end{defn}
To compute local projections we use the following two projection procedures,
derived, respectively, from McCallum's projection operator \cite{MC1,MC2,B}
and Hong's projection operator \cite{H}.
\begin{algorithm}
\label{alg:LProjMC}(LProjMC)\\
Input:\emph{ } \emph{and
}\emph{, where
.}\textup{}\\
\textup{\emph{Output:}}\textup{ A }\emph{finite set }.
\begin{enumerate}
\item Put  and compute .
\item For  do

\begin{enumerate}
\item Let . Put .
\item If  and 
put 
 and continue the loop.
\item If , , and none of 
is a nonzero constant, put , where  is maximal
such that .
\item Put .
\item If  then put 

\end{enumerate}
\item Return .
\end{enumerate}
\end{algorithm}
In the next algorithm we use the following notation.
\begin{notation}
Let , ,
and 
If for some , 
and , then .
Otherwise 
\end{notation}
\begin{algorithm}
\label{alg:LProjH}(LProjH)\\
Input:\emph{ } \emph{and
}\emph{, where
.}\textup{}\\
\textup{\emph{Output:}}\textup{ A }\emph{finite set }. 
\begin{enumerate}
\item Put  and compute .
\item For  do

\begin{enumerate}
\item Let . Put 
and .
\item If  put 
and continue the loop.
\item If , put 
and , where  is maximal
such that .
\item Put .
\item If  then for  if  put .
\end{enumerate}
\item Return .
\end{enumerate}
\end{algorithm}
The following algorithm computes a local projection for given 
and . 
\begin{algorithm}
\label{alg:LocalProj}(LocalProjection)\\
Input:\emph{ A finite set }
\emph{and }\emph{, where
.}\textup{}\\
\textup{\emph{Output:}}\textup{ A local projection sequence} 
\emph{for  at .}\textup{ }
\begin{enumerate}
\item Set , , .
\item While  do

\begin{enumerate}
\item Let  and compute ,
.
\item If , , and an element of  is identically
zero at , then set , ,  and
continue the loop.
\item If  or  set 
else set .
\item Set .
\end{enumerate}
\item Set .
\item Return .
\end{enumerate}
\end{algorithm}

\subsection{The CAD construction algorithm}

Let us first introduce an algorithm for evaluation of polynomial systems
at {}``partial'' sample points.
\begin{algorithm}
\label{alg:PEVAL}(PEval)\\
Input:\emph{ A system }\emph{ of polynomial
equations and inequalities and 
with .}\textup{}\\
\textup{\emph{Output:}}\textup{  or a pair ,
where , ,
and for any  if 
 for all  then the value of  is . }
\begin{enumerate}
\item If  or  then return .
\item If , where  is one of  or .

\begin{enumerate}
\item If there exists a factor  of  such that 
and  then return .
\item If  return .
\item Return .
\end{enumerate}
\item If 

\begin{enumerate}
\item For  compute .
\item If for some   then return .
\item If for all   then return .
\item Return .
\end{enumerate}
\item If 

\begin{enumerate}
\item For  compute .
\item If for some   then return .
\item If for all   then return .
\item Return .
\end{enumerate}
\end{enumerate}
\end{algorithm}
We can now present a recursive algorithm computing cylindrical algebraic
decomposition using local projections.
\begin{algorithm}
\label{alg:LPCAD}(LPCAD)\\
Input:\emph{ A system } \emph{of polynomial
equations and inequalities and 
with .}\textup{}\\
\textup{\emph{Output:}}\textup{ }\emph{A pair , where 
is a level- cylindrical subformula, }\textup{}\emph{,
}\textup{}\emph{ for
, and for any cell  if
 and for  all elements of 
have constant signs on  then}\textup{\emph{ }}\textup{
}
\begin{enumerate}
\item Compute a disjunctive normal form  and a conjunctive normal
form  of .
\item Set  and .
\item While  do

\begin{enumerate}
\item Remove a tuple  from
.  are algebraic functions of ,
, or , , ,
, and the tuple represents the interval
,
\item If  set  and set , where ,
else pick a rational number  and set .
Set .
\item Compute . If 
then set  and ,
and go to .
\item Compute . If 
then set  and ,
and go to .
\item Compute . For  set .
Compute .
\item For  set .
\item If  then set  and go to .
\item Find and  such that 

\begin{enumerate}
\item  and  or , 
\item  and  or , 
\item  and , 
\item either  or  and there
are no roots of elements of  in . 
\end{enumerate}
\item Set .
\item If  then set , add 
 and 
 to , and go to .
\item If  then set  and .
Else set  and , and if 
or  add 
 to . 
\item If  then set  and .
Else set  and , and if 
or  add 
 to . 
\item Set .
\item Set 
\end{enumerate}
\item Sort A by increasing values of the first element, obtaining .
Set .
\item Compute .
\item For  set .
\item Return\emph{ .}
\end{enumerate}
\end{algorithm}
\begin{cor}
 returns 
where  is a cylindrical algebraic formula
equivalent to .
\end{cor}
The formula returned by Algorithm \ref{alg:LPCAD} may involve weak
inequalities, but it can be easily converted to the CAF format by
replacing weak inequalities with disjunctions of equations and strict
inequalities.


\subsection{Proofs}

To prove correctness of Algorithm \ref{alg:LocalProj} we use the
following lemmata.
\begin{lem}
\label{lem:LProjMC}Let\emph{ }\textup{\emph{,}} \emph{,
}\emph{, }\textup{\emph{and
. If  is}} a connected analytic submanifold
of  such that  and all elements
of  are order-invariant in  then the set  of all elements
of  that are not identically zero on  is analytic
delineable over  and the elements of  are order-invariant
in each -section over . \end{lem}
\begin{proof}
Suppose that . Step  of Algorithm \ref{alg:LProjMC}
guarantees that  has a sign-invariant leading coefficient in .
 does not vanish identically at any point in  (for 
it is ensured by step ; for  it follows from irreducibility
of ). By Theorem 3.1 of \cite{B},  is degree-invariant on
. Since , by Theorem 2 of \cite{MC2},
 is analytic delineable over  and is order-invariant in
each -section over . Suppose that  and .
If either  or  has no real
roots then  is delineable on . Otherwise 
and hence, by Theorem 2 of \cite{MC2},  is analytic delineable
over . Therefore,  is analytic delineable over  and
the elements of  are order-invariant in each -section
over . \end{proof}
\begin{lem}
\label{lem:LProjH}Let\emph{ }\textup{\emph{,}} \emph{,
}\emph{, }\textup{\emph{and
. If  is}} a connected subset of 
such that  and all elements of  are sign-invariant
in  then the set  of all elements of  that are not
identically zero on  is delineable over . \end{lem}
\begin{proof}
Suppose that . Let 
be maximal such that , and let .
Steps  and  of Algorithm \ref{alg:LProjH} guarantee
that  in . By step  and Theorems
1-3 of \cite{C},  is delineable over , and hence
 is delineable over . Suppose that  and .
If either  or  has no real
roots then  is delineable on . Otherwise without loss
of generality we may assume that due to step   contains
all factors of . By Lemma 1 of \cite{H}
and Theorem 2 of \cite{C}, the degree of 
is constant for . Since  and  are degree-invariant
in , by Lemma 12 of \cite{S9},  is delineable over
. Therefore  is delineable over . \end{proof}
\begin{prop}
\label{pro:LocalProj}Algorithm \ref{alg:LocalProj} terminates and
returns a local projection sequence for  at .\textup{\emph{ }}\end{prop}
\begin{proof}
To show that the algorithm terminates note that the body of the loop
in step  is executed at most  times.

Let  be the returned sequence. Steps 
and  ensure that  is a finite subset of  and
 for . We
will recursively construct a cell  such
that  is the maximal connected set containing 
such that all elements of  for  have constant
signs on . Moreover, for , the set 
of elements of  that are not identically zero on 
is delineable over . This is sufficient to prove that 
is a local projection sequence for  at , because for any cell
 if  and all
elements of  for  have constant signs on 
then , by maximality of .

We will consider two cases depending on the value of  when the
algorithm terminated. Suppose first that when the algorithm terminated
 was . In this case we will additionally prove that for
  is an analytic submanifold of ,
all elements of  are order-invariant in , and if 
then none of the elements of  vanishes identically at any
point in ,  is analytic delineable on ,
and the elements of  are order-invariant in each -section
over . If  is a root of an element of  let
 else let , where 
and  are roots of elements of , , or ,
, and there are no roots of  in .
 is a connected analytic submanifold of 
and all elements of  are order-invariant in . Since
the elements of  are irreducible, none of the elements of
 vanishes identically at any point in . Since all
irreducible factors of elements of  belong
to , by Lemma \ref{lem:LProjMC},  is analytic delineable
over  and the elements of  are order-invariant in
each -section over . Suppose that, for some ,
we have constructed  satisfying the required conditions.
The conditions imply that  is analytic delineable on .
Let  be the -section or -sector over 
which contains .  is an analytic submanifold
of . The elements of  are order-invariant
in , because they are order-invariant in each -section
over  and nonzero in each -sector over .
Since all irreducible factors of elements of 
belong to  , by Lemma \ref{lem:LProjMC},
 is analytic delineable over  and the elements
of  are order-invariant in each -section
over . Step  guarantees that if  then .

Suppose now that when the algorithm terminated  was .
Let  be as in the first part of the proof. As before, 
is analytic delineable over  and the elements of 
are order-invariant in each -section over . Let 
be the -section or -sector over  which contains
.  is an analytic submanifold of .
The elements of  are order-invariant in , because
they are order-invariant in each -section over  and
nonzero in each -sector over . Since all irreducible
factors of elements of  belong to ,
by Lemma \ref{lem:LProjMC},  is analytic delineable over
. Suppose that, for some , we have constructed 
satisfying the required conditions. The conditions on  imply
that  is delineable on . Let  be the
-section or -sector over  which
contains . All elements of  are sign-invariant
in . Since all irreducible factors of elements of 
belong to  , by Lemma \ref{lem:LProjH},
 is delineable over .

Since for ,  is the -section or -sector
over  which contains ,  is the maximal
connected set containing  such that all elements of 
for  have constant signs on . 
\end{proof}
Correctness and termination of Algorithm \ref{alg:PEVAL} is obvious.
\begin{prop}
Algorithm \ref{alg:LPCAD} terminates and the returned pair 
satisfies the required conditions.\end{prop}
\begin{proof}
Let  be the set of all polynomials that appear in  and
let  be the Hong's projection sequence
\cite{H} for  (the variant of given in Proposition 7 of \cite{S9}).
Suppose that 
and , where . Let .
Since we assume that finite sets of polynomials are consistently ordered
according to a fixed linear order in the set of all polynomials, 
for . Hence all polynomials that appear during execution
of  are elements of . In particular,
 and  that appear in the elements of  are
roots of elements of , , or . Therefore,
the number of possible elements of  is finite, and hence the
loop in step  terminates. Recursive calls to  increment
. When  then either step  yields  or
step  yields , and hence step  containing the
recursive call to  is never executed. Therefore the value
of  is bounded by , and hence the recursion terminates.

Let  be the pair returned by  and suppose that 
is a cell such that  and for 
all elements of  have constant signs on . We
need to show that\emph{ }
Let  and .
We need to show that . Let ,
as computed in step . All elements of  have constant
signs on on , for . Since none of the
elements of  vanishes identically at ,  is
delineable over . Hence the -sections and the -sectors
over  form a partition of . 

For a tuple 
that appears on  in any iteration of the loop in step 
put
For each  put 
Note that each  and  is a union of
-sections and -sectors over . Put 
and . We will show
that in each instance of the loop in step  
is a partition of . In the first instance of the
loop in step   and ,
and hence  is a partition of .
We will show that this property is preserved in each instance of the
loop. In each instance a tuple 
is removed from  and  is added
to . If  in step  then 
and the property is preserved. If  in step  then
 and tuples 
and  are added to
. Since 
is a partition of , the property is preserved. Otherwise
steps - are executed. If in step  
or  and  then put ,
where  is the
tuple added to , else put . If in step
  or  and  then
put , where 
is the tuple added to , else put . Since
 is a partition of ,
the property is preserved. 

After the loop in step  is finished  is empty, ,
and hence  is a partition of . Let
 be such that .
Let us analyze the instance of the loop in step  which resulted
in adding  to . Let . 

Suppose first that  or  was found in step 
or . Let , as computed
in step  or . For , ,
and hence all elements of  have constant signs on on .
Therefore the set  of elements of  that are
not identically zero on  is delineable over .
By definition of ,  is a -section or a -sector
over . Hence all elements of  have constant signs on
. In particular, all elements of  have constant signs on ,
and so . 

Now suppose that  was computed in step
. Let 
For , , and hence all elements
of  have constant signs on on . As before, 
is delineable over ,  is a -section or a -sector
over , and all elements of  have constant signs on .
In particular, all elements of  have constant signs on .
Since for  , all elements of
 have constant signs on on . Hence
and so .
\end{proof}

\subsection{Implementation remarks}
\begin{rem}
\label{rem:Zdim}The following somewhat technical improvements have
been observed to improve practical performance of Algorithm \ref{alg:LPCAD}.
\begin{enumerate}
\item In step  of Algorithm \ref{alg:LProjMC} in  may be
chosen arbitrarily as long as , hence an
implementation may choose the simplest .
\item If in a recursive call to  the initial
coordinates  correspond to single-point intervals,
that is  in step  of the currently evaluated
iteration of loop  in all parent computations of 
 for , then 
does not need to compute the last  levels of projection. Instead
it can return  with .
\item Computations involved in finding projections are repeated multiple
times. A practical implementation needs to make extensive use of caching.
\end{enumerate}
\end{rem}

\subsection{\label{sub:Example}Example}

In this section we apply  to solve the problem stated in Example
\ref{exa:MainExample}.

In step  of  we compute 
and . In the first
iteration of loop  we remove a tuple representing 
from  and pick . The calls to  in steps
 and  yield . Step  makes a recursive
call to .

In the first iteration of loop  in  we remove
a tuple representing  from  and pick .
 in step  yields .
We continue on to step  where  yields
. We set  and compute 
where  is the set of factors of .
We go to step  and set .
In step  we find ,
, , and .
In step  we set . In steps 
and  we add tuples representing  and 
to . In step  we obtain .

In the second iteration of loop  in  we remove
a tuple representing  from  and pick .
 in step  yields .
We set  and compute 
where  is the set of factors of ,
, and .
We go to step  and set .
In step  we find , ,
and . In step  we set .
In step  we add a tuple representing  to . In
step  we obtain .

In the third iteration of loop  in  we remove
a tuple representing  from  and set . 
in step  yields 
We set  and compute 
where . We go to step  and set .
In step  we set . In step 
we obtain .

The remaining two iterations of loop  look very similar to the
last two. In step  we obtain .
In step  we compute 
 and in step  we set . The
returned value is .

In step  of  we obtain 
and . 
 yields . In step  we find ,
, , and . In steps
 and  we add tuples representing  and
 to . In step  we obtain .

In the second iteration of loop  in  we remove
a tuple representing  from  and pick .
The calls to  in steps  and  yield .
Step  makes a recursive call to .

In the first iteration of loop  in  we remove
a tuple representing  from  and pick .
 in step  yields 
We set  and compute 
where  is the set of factors of 
and  ( is not a part of the
projection because  and  have no real
roots). We go to step  and set .
In step  we find  and .
In step   remains empty. In step  we obtain .
The loop ends after one iteration and the returned value is .

In step  of  we obtain  and .

yields . In step  we find,
, and . In step  we add
a tuple representing  to . In step  we obtain
.

In the third iteration of loop  in  we remove
a tuple representing  from  and pick . The
calls to  in steps  and  yield .
Step  makes a recursive call to .

In the first iteration of loop  in  we remove
a tuple representing  from  and pick .
 in step  yields 
We set  and compute 
where, by Remark \ref{rem:Zdim}, we can take .
We go to step  and the set  remains empty. In step
 we find  and .
In step  we set . In step 
we add tuples representing  and  to .
In step  we obtain . 

In the second iteration of loop  in  we remove
a tuple representing  from  and pick .
 in step  yields .
We set  and compute ,
where, by Remark \ref{rem:Zdim}, we can take .
We go to step  and the set  remains empty. In step
 we find ,  and
. In step  we set .
In step  we obtain . 

The remaining iteration of loop  look very similar to the last
one. In step  we obtain . In step  we compute

by Remark \ref{rem:Zdim}. The returned value is .

In step  of  we obtain  and .
 yields . In step 
we set . In step  we obtain .

The remaining two iterations of loop  look very similar to the
last two. In step  we obtain 
and the returned value is .


\section{Empirical Results}

Algorithm \ref{alg:LPCAD} () and the cylindrical algebraic
decomposition () algorithm have been implemented in C, as a
part of the kernel of \emph{Mathematica}. The experiments have been
conducted on a Linux server with a -core  GHz Intel Xeon
processor and  GB of RAM available for all processes. The reported
CPU time is a total from all cores used. Since we do not describe
the use of equational constraints in the current paper, we have selected
examples that do not involve equations.


\subsection{Benchmark examples}

We compare the performance of  and  for the following
three problems and for the  examples from Wilson's benchmark set
\cite{W2} (version 4) that do not contain equations. 
\begin{example}
\label{exa:Two-quadratics}(Two quadratics) Find a cylindrical algebraic
decomposition of the solution set of 
with the variables ordered .
\end{example}

\begin{example}
\label{exa:Ellipse in a square}(Ellipse in a square) Find conditions
for ellipse  to be contained
in the square . We compute a cylindrical algebraic
decomposition of the solution set of
with the free variables ordered .
\end{example}

\begin{example}
\label{exa:Distance to three squares}(Distance to three squares)
Find the distance of a point on the parabola shown in the picture
to the union of three squares.

\includegraphics[width=0.65\columnwidth, trim = -50mm 3mm 10mm 5mm, clip]{Example2}

We compute a cylindrical algebraic decomposition of the solution set
of
with the free variables ordered .
\end{example}
Results of experiments are given in Table \ref{tab:Benchmark-examples}.
Examples from \cite{W2} are marked with W and the original number.
The columns marked Time give the CPU time, in seconds, used by each
algorithm. The columns marked Cells give the number of cells constructed
by each algorithm. The column marked WO tells whether the system is
well-oriented.

\begin{table}


\caption{\label{tab:Benchmark-examples}Benchmark examples}
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Example & \multicolumn{2}{c|}{Time} & \multicolumn{2}{c|}{Cells} & WO\tabularnewline
\cline{2-5} 
 &  &  &  &  & \tabularnewline
\hline 
\ref{exa:Two-quadratics} &  &  &  &  & N\tabularnewline
\hline 
\ref{exa:Ellipse in a square} &  &  &  &  & N\tabularnewline
\hline 
\ref{exa:Distance to three squares} &  &  &  &  & Y\tabularnewline
\hline 
W 2.3 &  &  &  &  & Y\tabularnewline
\hline 
W 2.8 &  &  &  &  & Y\tabularnewline
\hline 
W 2.9 &  &  &  &  & Y\tabularnewline
\hline 
W 2.10 &  &  &  &  & Y\tabularnewline
\hline 
W 2.11 &  &  &  &  & N\tabularnewline
\hline 
W 2.16 &  &  &  &  & Y\tabularnewline
\hline 
W 6.5 &  &  &  &  & Y\tabularnewline
\hline
\end{tabular}


\end{table}



\subsection{Randomly generated examples}

For this experiment we used randomly generated systems with ,
, and  variables,  systems with each number of variables.
The systems had the form  or , with a quadratic polynomial
 with  to  terms and -bit integer coefficients.
We selected systems for which at least one of the algorithms finished
in  seconds. Results of experiments are given in Table \ref{tab:Random}.
The columns marked Time give the ratio of  timing divided by
 timing. The columns marked Cells give the ratio of the numbers
of cells constructed by  and by . The ratios are computed
for the examples for which both algorithms finished in  seconds.
The columns marked Mean give geometric means. The column marked TO
gives the number of examples for which  did not finish in 
seconds.  finished in  seconds for all examples. The
column marked WO gives the number of systems that were well-oriented.

\begin{table}
\caption{\label{tab:Random}Randomly generated examples}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline 
Var & \multicolumn{3}{c|}{Time} & \multicolumn{3}{c|}{Cells} & \multicolumn{1}{c|}{TO} & WO\tabularnewline
No. & \multicolumn{3}{c|}{} & \multicolumn{3}{c|}{} &  & \tabularnewline
\cline{2-7} 
 & Mean & \multicolumn{1}{c|}{Min} & \multicolumn{1}{c|}{Max} & Mean & Min & Max &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  & \tabularnewline
\hline
\end{tabular} 
\end{table}



\subsection{Conclusions}

Experiments suggest that for systems that are not well-oriented LPCAD
performs better than CAD. For well oriented-systems LPCAD usually
construct less cells than CAD, but this does not necessarily translate
to a faster timing, due to overhead from re-constructing projection
for every cell. However, for some of the well-oriented systems, for
instance Example \ref{exa:Distance to three squares}, LPCAD is significantly
faster than CAD, due to its ability to exploit the Boolean structure
of the problem. Unfortunately we do not have a precise characterisation
of such problems. Nevertheless LPCAD may be useful for well-oriented
problems that prove hard for the CAD algorithm or may be tried in
parallel with the CAD algorithm.

\bibliographystyle{abbrv}


\begin{thebibliography}{10}

\bibitem{BPR}
S.~Basu, R.~Pollack, and M.~Roy.
\newblock {\em Algorithms in real algebraic geometry}, volume~10.
\newblock Springer-Verlag New York Inc, 2006.

\bibitem{B}
C.~W. Brown.
\newblock Improved projection for cylindrical algebraic decomposition.
\newblock {\em J. Symbolic Comp.}, 32:447--465, 2001.

\bibitem{B2}
C.~W. Brown.
\newblock Qepcad b - a program for computing with semi-algebraic sets using
  cads.
\newblock {\em ACM SIGSAM Bulletin}, 37:97--108, 2003.

\bibitem{B4}
C.~W. Brown.
\newblock Constructing a single open cell in a cylindrical algebraic
  decomposition.
\newblock In {\em Proceedings of the International Symposium on Symbolic and
  Algebraic Computation, ISSAC 2013}, pages 133--140. ACM, 2013.

\bibitem{CJ}
B.~Caviness and J.~Johnson, editors.
\newblock {\em Quantifier Elimination and Cylindrical Algebraic Decomposition},
  New York, 1998. Springer Verlag.

\bibitem{CMXY}
C.~Chen, M.~M. Maza, B.~Xia, and L.~Yang.
\newblock Computing cylindrical algebraic decomposition via triangular
  decomposition.
\newblock In {\em Proceedings of the International Symposium on Symbolic and
  Algebraic Computation, ISSAC 2009}, pages 95--102. ACM, 2009.

\bibitem{C}
G.~E. Collins.
\newblock Quantifier elimination for the elementary theory of real closed
  fields by cylindrical algebraic decomposition.
\newblock {\em Lect. Notes Comput. Sci.}, 33:134--183, 1975.

\bibitem{CH}
G.~E. Collins and H.~Hong.
\newblock Partial cylindrical algebraic decomposition for quantifier
  elimination.
\newblock {\em J. Symbolic Comp.}, 12:299--328, 1991.

\bibitem{DSW}
A.~Dolzmann, T.~Sturm, and V.~Weispfenning.
\newblock Real quantifier elimination in practice.
\newblock In {\em Algorithmic Algebra and Number Theory}, pages 221--247.
  Springer, 1998.

\bibitem{GV}
D.~Grigoriev and N.~Vorobjov.
\newblock Solving systems of polynomial inequalities in subexponential time.
\newblock {\em J. Symb. Comput.}, 5(1/2):37--64, 1988.

\bibitem{H}
H.~Hong.
\newblock An improvement of the projection operator in cylindrical algebraic
  decomposition.
\newblock In {\em Proceedings of the International Symposium on Symbolic and
  Algebraic Computation, ISSAC 1990}, pages 261--264. ACM, 1990.

\bibitem{HS}
H.~Hong and M.~S.~E. Din.
\newblock Variant quantifier elimination.
\newblock {\em J. Symb. Comput.}, 47:883--901, 2012.

\bibitem{JM}
D.~Jovanovic and L.~M. de~Moura.
\newblock Solving non-linear arithmetic.
\newblock In {\em IJCAR}, pages 339--354, 2012.

\bibitem{L}
S.~\L{}ojasiewicz.
\newblock {\em Ensembles semi-analytiques}.
\newblock I.H.E.S., 1964.

\bibitem{LW}
R.~Loos and V.~Weispfenning.
\newblock Applying linear quantifier elimination.
\newblock {\em The Computer Journal}, 36(5):450--462, 1993.

\bibitem{MC1}
S.~McCallum.
\newblock An improved projection for cylindrical algebraic decomposition of
  three dimensional space.
\newblock {\em J. Symbolic Comp.}, 5:141--161, 1988.

\bibitem{MC2}
S.~McCallum.
\newblock An improved projection for cylindrical algebraic decomposition.
\newblock In B.~Caviness and J.~Johnson, editors, {\em Quantifier Elimination
  and Cylindrical Algebraic Decomposition}, pages 242--268. Springer Verlag,
  1998.

\bibitem{R}
J.~Renegar.
\newblock On the computational complexity and geometry of the first order
  theory of the reals.
\newblock {\em J. Symbolic Comp.}, 13:255--352, 1992.

\bibitem{S2}
A.~Strzebo\'nski.
\newblock Computing in the field of complex algebraic numbers.
\newblock {\em J. Symbolic Comp.}, 24:647--656, 1997.

\bibitem{S4}
A.~Strzebo\'nski.
\newblock Solving systems of strict polynomial inequalities.
\newblock {\em J. Symbolic Comp.}, 29:471--480, 2000.

\bibitem{S7}
A.~Strzebo\'nski.
\newblock Cylindrical algebraic decomposition using validated numerics.
\newblock {\em J. Symbolic Comp.}, 41:1021--1038, 2006.

\bibitem{S8}
A.~Strzebo\'nski.
\newblock Computation with semialgebraic sets represented by cylindrical
  algebraic formulas.
\newblock In {\em Proceedings of the International Symposium on Symbolic and
  Algebraic Computation, ISSAC 2010}, pages 61--68. ACM, 2010.

\bibitem{S9}
A.~Strzebo\'nski.
\newblock Solving polynomial systems over semialgebraic sets represented by
  cylindrical algebraic formulas.
\newblock In {\em Proceedings of the International Symposium on Symbolic and
  Algebraic Computation, ISSAC 2012}, pages 335--342. ACM, 2012.

\bibitem{T}
A.~Tarski.
\newblock {\em A decision method for elementary algebra and geometry}.
\newblock University of California Press, 1951.

\bibitem{W1}
V.~Weispfenning.
\newblock Quantifier elimination for real algebra - the quadratic case and
  beyond.
\newblock {\em AAECC}, 8:85--101, 1993.

\bibitem{W2}
D.~Wilson.
\newblock Real geometry and connectedness via triangular description: Cad
  example bank, 2012.
\newblock http://opus.bath.ac.uk/29503/.

\end{thebibliography}

\end{document}
