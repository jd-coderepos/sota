
\documentclass[letterpaper]{article}\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{epsfig}\setcounter{MaxMatrixCols}{30}
\providecommand{\U}[1]{\protect\rule{.1in}{.1in}}
\frenchspacing
\newcommand{\sg}{\sigma}
\newcommand{\fig}[3]
{\begin{figure}[ht] \centerline{\scalebox{#1}{\epsfig{file=#2.eps}}}
\vspace{-1mm} \caption{#3} \label{fig:#2}
\end{figure}}
\begin{document}

\title{Expressing Preferences using Preference Set Constraint Atoms}
\author{Alex Brik, Jeffrey B. Remmel\\Department of Mathematics, University of California, San Diego, CA 92093-0112\\\ }
\maketitle

\begin{abstract}
This paper introduces an extension of Answer Set Programming called Preference
Set Constraint Programming which is a convenient and general formalism to
reason with preferences. PSC programming extends Set Constraint Programming
introduced by Marek and Remmel \cite{MR} by introducing two types of
preference set constraint atoms, measure preference set constraint atoms and
pre-ordered preference set constraint atoms, which are extensions of set
constraint atoms. We show that the question of whether a PSC program has a
preferred stable model is CoNP-complete. We give examples of the uses of the
preference set constraint atoms and show that Answer Set Optimization
\cite{BNT03} and General Preference \cite{SP} can be expressed using
preference set constraint atoms.

\end{abstract}

\section{\bigskip Introduction}

The notion of a set constraint (SC)\ atom and a set constraint logic program
was introduced by Marek and Remmel in \cite{MR}. In this paper we extend these
notions to define preference set constraint (PSC) atoms and PSC logic
programs. The purpose of these extensions is to use PSC atoms to express preferences.

PSC\ programming is an intuitive and general formalism for expressing
preferences. We demonstrate its generality by showing that PSC programing can
be used to express optimal stable models of Answer Set Optimization (ASO) of
\cite{BNT03} and general preferences of \cite{SP}. An extension of PSC
programming can be used to express preferred answer sets and weakly preferred
answer sets of \cite{BrewkaE99}. However, due to space limitations, we will
not discuss the last two examples.

In this paper, we shall focus on the formal definitions of PSC programming.
However, there are a number of interesting issues concerning the best way to
implement PSC programs. While such issues are for the most part outside of the
scope of this paper, we note that an implementation of PSC\ programming will
not necessarily be a simple application of the definitions. The question of
what is the best way to implement PSC\ programming efficiently is one that
requires additional research, and we will only briefly discuss a few salient
implementation issues in this article.

The subject of expressing preferences using Answer Set Programming (ASP)\ has
been discussed extensively in the literature. Various approaches have been
proposed. We refer the reader to the article \cite{BNT08} for an accessible
overview of the subject and to a more detailed albeit older survey
\cite{DSTW04}.

In \cite{DSTW04} various approaches are classified for handling preferences in
nonmonotonic reasoning. The paper identified the following criteria.

\begin{itemize}
\item \textbf{Host system}. This is a particular formalism which is extended
to handle the preferences. In our case the host system is a SC logic program.

\item \textbf{What is the preference ordering an ordering on}?\ PSC
programming allows the user to directly specify preference orderings on sets
of atoms.

\item \textbf{Meta-level vs. object-level preferences}. This criteria
identifies whether preferences are imposed ``externally"\ on the host system,
or the preferences are used within the object theory. Our approach is a
meta-level approach.

\item \textbf{Static vs. dynamic preferences}. This criteria specifies whether
the preferences are fixed at the time that the theory is specified or can be
determined \textquotedblleft on the fly". PSC programming implements static preferences.

\item \textbf{Properties of the preference ordering}. PSC programming enforces
a pre-order on the set of PSC\ stable models.

\item \textbf{Prescriptive vs. descriptive preferences}. This criteria
concerns preference orderings on the rules and is not applicable to PSC programming.

\item \textbf{From preference to preferred results}. This criteria identifies
broad categories for methods that generate preferred answer sets from a theory
and a set of preferences. In PSC programming preferred PSC stable models are
standard PSC stable models satisfying additional criteria.
\end{itemize}

As noted in \cite{DSTW04}, the majority of ASP type systems that reason about
preferences use a preference ordering on the set of rules to express
preferences. An example of such an approach is given in \cite{BrewkaE99}.
There are exceptions such as for instance \cite{SI00}, \cite{Brewka02} that
specify preferences on the literals and more recently ASO which uses a second
preference program to specify preferences on the answer sets. ASO is in fact
the approach that is closest to PSC programming.

Delgrande et al. note that to have the most general ASP type system that can
reason about preferences, one must be able to handle preferences on sets of
objects. PSC programming allows the user to specify preferences on subsets of
atoms. This fact distinguishes PSC\ programming from most other approaches for
expressing preferences in ASP. PSC programming is different from ASO\ in that
the host system of PSC\ programming is a SC logic program, whereas the host
system of ASO\ is an ASP\ logic program. We will show that ASO programming can
be viewed as a particular case of PSC programming.

Since literals can be viewed as sets of cardinality 1, there are similarities
between PSC\ programming and some of the proposals that specify preferences on
the literals. Due to the space constraints we will limit the related
discussion to few remarks.

In \cite{Brewka02} Brewka introduces Logic Programs with Ordered Disjunction
(LPODs). The key feature of LPODs are ordered disjunctions of the form
 in the heads of the rules. The meaning is that if
possible , if not possible  then , ..., if not possible
, ..., then . The priorities among the answer sets of
LPODs are generated using the indices of the disjuncts included in the stable
models. As shown in \cite{BrewkaNS04} deciding whether  is a preferred
answer set of LPOD\  is coNP-complete, which is the complexity of the same
problem for PSC\ programs. Thus a polynomial time translation between the
formalisms exists.

In \cite{BuccafurriLR00}, Buccafurri et al. extend the language of Disjunctive
Datalog by weak constraints (DATALOG). The weak constraints
are constructs of the form  where , ...,
 are literals. The weak constraints effectively allow to specify sets
of atoms, i.e. a weak constraint specifies those sets of atoms that violate
the constraint.  is a model of a DATALOG program if
 is a model of the underlying Disjunctive Datalog program and if it
minimizes the sum of the weights of the violated weak constraints.
DATALOG programs possess a certain similarity with the
measure PSC\ programs. In particular both specify preferences on sets and both
use numeric weights for the models. However, there are significant differences
between the two approaches. First, the host system of DATALOG
is Disjunctive Datalog programs. For the measure PSC programs it is SC
programs. Second, integer weights associated with candidate models in
DATALOG allow the use of a binary search procedure in finding
models, whereas the use of binary search is not helpful for the measure PSC
programs since the stopping criteria is not easily determined due to the
arbitrary weights. Thus if the complexities of the host systems were the same,
the complexities of the search for optimal models would be different in the
two approaches.

The rest of the paper is structured as follows. In section 2, we will describe
the preliminaries of ASP\ and SC logic programming. In section 3, we will
introduce PSC programming. In the same section there will be a discussion
pertaining to implementing PSC programming. In section 4 we will show that
PSC\ programming can be used to express optimal stable models of ASO. In
section 5 we will show that the general preferences of \cite{SP} can be
expressed using PSC\ atoms. In section 6, we will discuss computational
complexity of PSC\ programming. In section 7, we will give conclusions and
directions for further research.

\section{Preliminaries}

\noindent\textbf{Answer Set Programming.}

Answer set programming is logic programming with stable model or answer set
semantics \cite{GL}, \cite{GL91}. ASP\ systems are ideal logic-based systems
to reason about a variety of types of data and integrate quantitative and
qualitative reasoning. The question of whether a finite propositional logic
program has a stable model is NP-complete \cite{Elkan}, \cite{MT}. It is also
the case that any NP search problem can be (uniformly) reduced to the problem
of finding a stable model of a finite propositional logic program \cite{MR2}.

A \emph{normal propositional logic program}  consists of rules of the form

where  are atoms and  is a
non-classical negation operator. The set ... is called the set of \textit{premises} of rule  and the set
 is called the set of
\textit{constraints} of rule . The atom  is called the
\textit{conclusion} of rule  and is denoted by .
Either , , or both may be empty. Let  denote the
Herbrand base of . A subset  is called a model of a rule
 if  and  implies .
 is a model of a program  if it is a model of every rule of .

Given , the Gelfond-Lifschitz transform  of  with
respect to  is obtained by removing every rule  such that  and then removing the constraints from all the
remaining rules.  is called a \textbf{stable model }of  if  is the
least model of .\newline\ \newline\textbf{Set Constraint Logic
Programming.}

Set constraint programming was introduced in \cite{MR} as an extension of
. It generalized Answer Set Programming (ASP) with
cardinality constraint atoms or weight constraint atoms as defined in
\cite{NSS99}, \cite{NS00}.

Suppose that we are given a finite set of atoms . We let  denote the set of all subsets of . A \emph{set
constraint atom} over  is a pair  where
. Given a set of atoms  and a
SC\ atom , we say that  satisfies
 (or  is a model of ) and write  if
.

A \emph{set constraint} (SC) rule  is an expression of the form
where , , ...,  are SC atoms. The set  will be referred to as the body of the
rule  and the atom  will be referred to as the
conclusion of the rule. A set of atoms  is a \emph{model} of  (or 
satisfies ) if , ...,  implies . An SC program  is a set of SC rules and a set of atoms  is a model of
 if  is a model of every rule in .

We note that the satisfaction of literals can be easily expressed in terms of
the satisfaction of set constraints. That is, for an atom , 
if and only  and  if and only if
. Thus each literal  or  in a normal logic program
can be written as a SC atom and hence each normal logic program can be
considered as SC logic program. However such a translation makes normal logic
programs harder to read. Thus, in what follows, we shall write  for the SC
atom  and  for a SC atom .

Given an SC\ atom , the upper-closure
 of  with respect to  is the family  . A family  of subsets of  is \emph{closed} if
. Notice that the closure of a closed family  of subsets of
 is  itself. The \emph{closure} of a SC atom  is .

A \emph{Horn SC\ rule} is a SC rule where the head of the rule is an ordinary
atom and all SC\ atoms in the body are closed, i.e. a rule of the form

where for , , ..., , . The reason for
calling such a rule Horn is that if  satisfies a Horn SC\ rule , then
all the supersets of  will satisfy . A \emph{Horn SC logic program}
(Horn SC\ program for short)\ is a SC program consisting entirely of Horn
SC\ rules. Given a Horn SC program , we define the one-step provability
operator  by letting  equal to the set of all  such that
there exists a rule ,..., in  where  for . It is easy to prove that the one-step
provability operator associated with a Horn SC program is monotone and hence a
Horn SC program  has a least fixed point which is the smallest model of .

The notion of SC stable model of a SC logic program is defined using a
modification of the Gelfond-Lifschitz transform called NSS transform. That is,
let  be a SC program and let  be a subset of atoms. The \emph{NSS
transform, }\emph{\ of }\emph{\ with respect to
} is defined in two steps. First, eliminate from  all rules whose
bodies are not satisfied by . In the second step, for each remaining rule
, ...,  and for each 
generate the rule ,...,  The resulting
program  is a Horn SC program. Consequently, ,
 has a least model .  is called a \emph{SC stable model} of
 if  is a model of  and .

Marek and Remmel in \cite{MR} proved the following proposition showing the
equivalence of a normal logic program and its representation as SC program.

\textbf{Proposition 1.} Let  be a normal logic program and let  be a set
of atoms. Then  is a stable model of  in the sense of Gelfond and
Lifschitz if and only if  is a stable model of  viewed as SC program.

\section{Preference Set Constraints in Logic Programs}

In this section, we will define two types of preference set constraint atoms,
measure PSC atoms and pre-ordered PSC atoms, and two types of preference set
constraint programs, measure PSC programs and pre-ordered PSC programs which
are extensions of SC atoms and SC programs, respectively. We will also discuss
some of the issues related to the possible implementations of PSC programming.

A \emph{measure preference set constraint} (measure PSC) atom is a triple
 where  is a SC
atom and  is a \emph{measure
function}. The SC reduct of ,
, is just the SC atom .
A \emph{pre-ordered preference set constraint} (pre-ordered PSC) atom is a
triple  where  is
a SC atom and  is a pre-order on . The SC reduct of , , is just the
SC atom . If  is a set atoms, we say that  is a
model of  if  and  is a model of  if
. If  is a SC atom, then we
let .

A measure PSC rule  is a rule of the form

where  are SC atoms and  is either a SC atom or a
measure PSC atom. We define the  reduct of , denoted by , to be
the rule . A measure PSC program  is a
set of measure PSC rules and we define the SC reduct of  to be the set of
 such that  is in . We say that a set of atoms  is a model of
 if and only if  is a model of  and  is a stable model of 
if and only if it is a stable model of .

Similarly, a pre-ordered PSC rule  is a rule of the form  where  are SC atoms and  is either
a SC atom or a pre-ordered PSC atom. We define the  reduct of , denoted
by , to be the rule . A
pre-ordered PSC program  is a set of pre-ordered PSC rules and we define
the SC reduct of  to be the set of  such that  is in . Again
we say that a set of atoms  is a model of  if and only if  is a model
of  and  is a stable model of  if and only if it is a stable
model of .

Our idea is that if we are given a measure PSC program or a pre-ordered PSC
program , then the preference set constraint atoms can be used to induce a
pre-order on the set of stable models of . Before we can talk about this
induced pre-order, we need to define a pre-order on the models of a set of PSC
atoms . That is, suppose that  is a set of pre-ordered PSC atoms and we
are given two sets of atoms  and  which satisfy every element of
. Then we say that \emph{\ is preferred to }\emph{\ relative
to }, written  if for all ,  and there is at least one
 such that .
(Here, as usual for two sets  and  and a pre-order ,  denotes
 and . We say that \emph{\ is equivalent to
}\emph{\ relative to }, written  if for
all ,  and
. Hence, our pre-order on the models of  is
essentially a product order over the set of local preference orders induced by
each of pre-ordered PSC atoms in . We say that \emph{\ is
indistinguishable from }\emph{\ relative to }, written  if  and .

A slightly weaker type of pre-order on models can be induced by measure PSC
atoms. That is, given a set  of measure PSC atoms and two sets of atoms
 and  which are models of , we say that \emph{\ is
weakly preferred to }\emph{\ relative to }, written  if

Note that for  to be weakly preferred to  relative to , we do
not require that for every , , but only in the aggregate  is
preferred to . This type of pre-order induced on models of sets of
measure preference atoms allows the user more flexibility in specifying
preferences. This is because one is allowed to weigh local preferences so that
the weight coming from the  associated with the measure PSC atom
 makes a much bigger contribution to
(\ref{wpref}) than the weight coming from the  associated with the
measure PSC atom . Thus it is possible to make
sure that the local preferences specified by  are
much more important than the local preferences specified by . We say that \emph{\ is indistinguishable from
}\emph{\ relative to }, written  if
 and , i.e.



We are now in position to define how we can use PSC programs to specify
preferences on stable models. We will start out considering what we call
\emph{simple PSC programs}. A simple pre-ordered PSC program is a pre-ordered
PSC program  which consists of two types of rules:

where  are SC atoms and

where  is a pre-ordered PSC atom. Given a simple pre-ordered PSC program
, we let  denote the set of pre-ordered PSC atoms
that appear in a rule of type (\ref{C2}) in . Note that any stable model
 of  must satisfy all the pre-ordered PSC atoms in . Given two
stable models  and  of , we say that \emph{\ is
preferred to }\emph{\ relative to }, written , if .

Similarly, a simple measure PSC program is a measure PSC program  which
consists of two types of rules:

where  are SC atoms and

where  is a measure PSC atom. Given a simple measure PSC program , we
let  denote the set of measure PSC atoms that appear
in a rule of type (\ref{D2}) in . Note that any stable model  of 
must satisfy all the measure PSC atoms in . Given two stable models
 and  of , \emph{\ is weakly preferred to }\emph{\ relative to }, written , if
.

\bigskip

To be practical, any implementation of PSC\ programming will have to be
restricted to a class of programs that can be represented in a compact way. In
this section we will discuss the \emph{algorithmic approach} for implementing
PSC\ programming - an approach that in many cases can produce compact
representations and that is conducive to efficient and practical
implementations of PSC\ programming.

The idea is that for a pre-ordered PSC atom  or a measure PSC atom  or a SC\ atom   and 
are implemented by algorithms  and  respectively. That is, for
any set of atoms , the algorithm  returns , and, for any
set of atoms , the algorithm  returns  if  and  if
. Thus an implementation of PSC rule may be a string of the form
, where , , ...,  are names of the algorithms that for an input set of atoms 
return a subset of . , , ...,  are names of Boolean valued
algorithms that take a set of atoms as an input. For a pre-ordered PSC
program,  will be a three valued algorithm that takes two sets of atoms as
inputs. For a measure PSC program,  will be a real valued algorithm that
takes a set of atoms as an input. We note that an extension of ASP\ that uses
arbitrary algorithms was considered in \cite{HybridASP}.

In many cases this approach produces efficient implementations. Consider the
following example. Suppose that for a SC\ atom ,  contains only those subsets of  that consist of an even number of
elements. Implementation of this atom by enumerating  is clearly
inefficient as there are  sets with even
number of elements in . Thus we do not want to represent  by an
enumeration of all the subsets of  of even cardinality. However, an
algorithm returning  if and only if the input set has even number of
elements is trivial to implement and will run in  time.

An obvious implementation can be obtained as follows. Let  be an enumeration of . Thus any subset of  can be
represented as a vector of  binary digits (bits). For instance, suppose
that , ..., . Consider  where ,
, . Then an 8 bit representation of  is 101001. Assuming
this representation we have the following pseudocode for .

{\small boolean AF (Y)\ }

{\small \ \ n = size(Y);}

{\small \ \ result = true;}

{\small \ \ for i=1:n if Y[i] == 1 then result = \symbol{126}result; endfor;}

\ {\small return result;}

{\small end}

where Y[i] is the ith bit of the bit vector Y, and \symbol{126}result is the
boolean NOT\ operation.

Suppose that instead of the subsets of  of even cardinality we want to
enforce the cardinality constraint on the subsets of  of  such that
. There are
 such
subsets, and of course we do not want to enumerate them. However, as in the
previous example there is a simple algorithm that will implement this
cardinality constraint.

{\small boolean AF (Y)\ }

{\small \ \ n = size(Y);}

{\small \ \ cardinality = 0;}

{\small \ \ for i=1:n if Y[i] == 1 then cardinality = cardinality +\ 1;
endfor;}

{\small \ \ return 3
= cardinality \&\&\ cardinality
= n-3;}

{\small end}

PSC\ semantics specifies what an implementation of PSC\ programming should do.
It is not a prescription for how PSC\ programming should be implemented. Thus
the fact that PSC programming deals with sets should not be understood to mean
that PSC programming has to be implemented by enumerating sets. Efficient
implementations of PSC programming will not use such an approach. We will use
two examples to motivate the fact that semantics does not necessarily
prescribe how the formalism is to be implemented.

First, consider stable model semantics. The formalism shows that a stable
model can be found by choosing a subset of the Herbrand base of a logic
program and then checking that the subset is a stable model. Now, while
undoubtedly useful, the formalism is impractical if implemented as stated.
Indeed, modern ASP\ solvers such as \emph{smodels }\cite{SimonsNS02} and
\emph{clasp }\cite{GebserKNS07} use efficient algorithms to implement stable
model semantics, where the algorithms do not rely on searching through the
entire powerset of the Herbrand base of a logic program, which would be the
case if the semantics was considered as a prescription for implementations.

Second, consider cardinality constraint programming \cite{NSS99}. The
formalism has been implemented in \emph{smodels-2} \cite{Simons99} and is
generally considered to be a practical extension of ASP. However, its
practicality follows from the fact that efficient implementations of
cardinality constraint programming exist.

To illustrate how the algorithmic approach for implementing PSC programming
might work we will consider the problem of finding a vertex cover of size less
than  for a given graph, with a preference for the covers that include
vertex .

For a given graph a measure PSC program can be constructed as follows. For
every edge  include a rule, specifying that either  or  is in a stable
model. Also include the following rule , where  is the set of all the vertices of the graph and for
  if  and



Now, an algorithmic implementation of  is very simple: for any subset 
of the Herbrand base .

The implementation of  is very similar to the cardinality constraint
implementation above. Finally the algorithm roF(U) simply has to check the
condition U[iw]==1, where iw is the index in the bit array corresponding to
the atom . That is . The preference can be given by any of the
three approaches for measure PSC programs.

The example demonstrates that compact representations of PSC\ programs can be
created and that such representations are conducive to efficiently
implementing PSC\ programming.

\bigskip

In many cases, simple PSC programs are adequate to express preferences. In
fact pre-ordered simple PSC programs will be used to express optimal stable
models of ASO.

We will now proceed with the examples illustrating how PSC\ programming can be used.

\textbf{Example 1.}\label{Ex1} Bob is a Ph.D. student who is about to graduate
from his university. Bob is guessing that he will have multiple job offers and
wants to determine a method by which he will make his decision. Bob identifies
two important criteria in making a decision. These are the type of institution
and its location. He thus introduces the following atoms: R - for the job at a
research university, T - for the job at a teaching university, C - for the job
in a company, CAL-for the job located in California, and NCal-for the job not
located in California. Thus the set of atoms is , , , ,
. Then any offer is described by a set of atoms from the following
family of sets: ,   , , , ,
. Finally Bob decides on the following ordering of sets :
, \  ,   ,  \ ,
  ,  , .

In this example and all the following examples in this section, we will assume
that Bob is trying to decide between two jobs  and . Thus we
introduce a base program .  contains the rule

This rule says that, in any stable model , exactly one of  and
 is contained. Then we add rules to specify the relevant information
about jobs  and . For example, if  is a job at a research
university in California and  is a job at a teaching university outside
of California, we would add the following rules: ,, ,.

Then Bob's preferences can be described by the simple pre-ordered PSC\ program
 which consists of  plus the rule . \ \ 

\textbf{Example 2.}\label{Ex2} Bob soon realizes that not all locations
outside of California have the same weight. He is actually more likely to
consider an offer from a location which is near California than from a
location which is far from California. Bob thinks that a job at a research
university is preferable to a job at a teaching university and that a job at a
teaching university is preferable to a job at a company. Yet, Bob notices that
he will prefer a job from a teaching university in California to a job from a
research university which is more than 500 miles away from California.

He thus revises his original approach. There are still predicate atoms ,
,  to specify a research university, or a teaching university or a
company respectively. However, now Bob introduces a set of predicate atoms
, where  is
the set of natural numbers and  indicates a distance 
from California. Thus  indicates that the location of the
job is in California. Note that in an implementation of PSC programming
 can be an algorithm that on an input  will simply return the
set of atoms in  of the form  for . While
 represents an infinite set, its implementation can be compact
and efficient.

Now let , ,  and let ,  , , , . Bob defines a measure function as
follows  where ,  and .

Thus Bob's preferences are specified by the simple measure PSC\ program which
consists of  plus the rule  \ 

If we consider more general pre-ordered PSC programs  and measure PSC
programs, then we have several natural choices for how to induce a pre-order
on the set of stable models of . If  is a pre-ordered (measure)\ PSC
program and  is a stable model of , then we let  denote the set of all pre-ordered (measure)\ PSC\ atoms  such that there
is a rule  where  is a pre-ordered
(measure) PSC atom and  satisfies the body of . Since all stable models
of  are models of  by definition,  must be a model of .

Note, however, that if  and  are stable models of  it is not
necessarily the case that . Now in the case where
, the obvious thing to do for the pre-ordered PSC
programs is to say that  is preferred to  relative to  if and
only if . However, if , then one has several natural choices. First, one can
simply consider the pre-ordered PSC atoms in , i.e. the pre-ordered PSC atoms which are the conclusions of rules of 
which are satisfied by both  and . Thus we say that  is
\emph{in common preferred} to  relative to , written , if and only if . A second natural choice that one might want to use in
certain situations is to take the point of view that satisfying a pre-ordered
PSC atom  that appears in the head of a rule in  is more preferable than
not satisfying . Thus we say that  is \emph{in total preferred} to
 relative to , written , if and only
if either (a)  and either  or  or (b)  and
.

\textbf{Example 3.}\label{Ex3} As Bob has more time to contemplate the job
offers, he realizes that his life will be simplified if the job is in a town
where there is a good public transportation system. Also, being a classical
music lover, Bob considers an easy access to live classical concerts as one of
the factors in making his decision. Not being sure about the weight that
public transportation and live classical music concerts should have in the
decision making process, he reverts to the pre-ordered PSC\ program from
Example 1. Bob reasons that he will keep his preferences as they already are,
except when there is an access to live classical music concerts in the area.
In that case, a location outside of California with a good system of public
transportation is preferable to a location in California without such a
system. Thus Bob introduces two new predicate atoms:\  - to indicate the
presence of local access to live classical music concerts and  to indicate
the presence of a good system of public transportation. Bob adds a new rule to
the program  to produce a new program .  consists of
 plus the following two rules:

where , , , , , , ,
,  and , ,  
  .

Now  since     , ,  and , ,  . However  because   and , , \newline

Similarly we can define a pre-order on the set of stable models of measure
PSC\ programs. In the case where , the obvious
thing to do is to say that  is weakly preferred to  relative to
 if and only if . However, if
, then one has several natural choices. One
is to simply consider the measure PSC atoms in , i.e. the measure PSC atoms which are the conclusions of rules
of  which are satisfied by both  and . Thus we say that
 is \emph{in common weakly preferred} to  relative to ,
written , if and only if . As before, our second natural
choice is to take the point of view that satisfying a measure PSC atom 
that appears in the head of a rule in  is more preferable than not
satisfying . Thus we say that  is \emph{in total weakly preferred}
to  relative to , written , if and
only if (a)  and either  or  or (b)  and
. We also have a
third natural choice that one might want to use in certain circumstances which
is just to compare the two sums  and \newline. Thus we say that 
is \emph{in sum weakly preferred} to  relative to , written
, if



\textbf{Definition 1. }\textit{A set of atoms }\textit{\ is called an in
common preferred PSC stable model of a pre-ordered PSC program }\textit{\ if }\textit{\ is a PSC stable model of }\textit{\ and for
all PSC stable models }\textit{\ of }\textit{, }\textit{.}

An \emph{in total preferred PSC stable model}, an \emph{in common weakly
preferred PSC stable model}, an \emph{in total weakly preferred PSC stable
model}, an \emph{in sum weakly preferred PSC stable model }are defined
similarly. To refer to any of these definitions without explicitly naming them
we may say that  \emph{is a preferred PSC stable model of a PSC program}
.

\section{PSC Programs and Answer Set Optimization Programs}

As was stated in the introduction, the closest approach to PSC\ programming is
ASO. In ASO, one starts with an ASP\ program  over a set of atoms
 and then a preference specification is given by a separate preference
program . The rules of  are of the form
where s and s are literals and the s are Boolean
combinations over . Here a Boolean combination over  is a formula
built of atoms in  by means of disjunction, conjunction, strong negation
 and default negation , with the restriction that strong negation
is allowed to appear only in front of atoms, and default negation is allowed
to appear only in front of literals.

Next suppose that we are given a set of literals . Then the definition of
 satisfying a Boolean combination , written , uses the
standard inductive definition of satisfaction of propositional formulas except
that   where  is literal if and only if . Then
we define the satisfaction degree  for any rule of
the form of (\ref{preference rule}) by setting (i) 
if either the body of  is not satisfied by  or the body of  is
satisfied by , but none of the s are satisfied and (ii)
  if the body of  is
satisfied by  and at least one of the s is satisfied by . This
allows one to define a satisfaction vector , ...,  for any answer set  of  for
a preference program , ..., .

One can then use satisfaction vectors to define a pre-order on answer sets of
 as follows. First for any two possible values  and  of
 (i)  if  and  or if  and
, (ii)  if  and   , , ..., and (iii) 
if ,   , , ... and  relative to the usual order on
the natural numbers. Then for two sets of literals  and 
 if  for every , ...,  
if  and for some , ...,    .  if  and  if . Finally, a set of literals  is an \emph{optimal model of an
ASO\ program} ,  if  is an answer set of  and
there is no answer set  of  such that .

We will now show how optimal models of an ASO program can be expressed using
PSC programming. Let  be an
ASO\ program.


Let  be the set of all atoms that occur in the rules of  and
. Note that any stable model of  of  must be a subset of
. Consequently, any optimal model of ,  must be a
subset of .

Let  consist of the rules , , ...,  where
 is of the form , ...,
,  .

We will now construct a simple pre-ordered PSC\ program  and we will show
that there is a one-to-one correspondence between the preferred PSC\ stable
models of  and the optimal stable models of , .

The Herbrand base  of  will consist of , the set
  where for  
is a new atom not in , and where for all ,  if  then
, and a new atom  so that . That is .

For a set  define  .
For a rule  let  be the set of
all the atoms that occur in .

We define a PSC program  to be the set of all rules

The pre-order  is defined as follows. For ,
  if one of the following
conditions hold.

1. ; 2.  and ; 3.  and ; 4.  and  where  is minimal and  and  where  is minimal and
, i.e.,  iff .

Let  be the set of rules consisting of two rules for each 
\  \ and , ,
.

Then the PSC program  is defined by .

We can prove the following two theorems.

\textbf{Theorem 1. }\textit{1. For all }\textit{\ if }\textit{\ is a stable model of }\textit{\ in the sense of Gelfond
and Lifschitz, then }\textit{\ is a stable model of }\textit{\ in the set of PSC.}

\textit{2. For all }, \textit{\ if }\textit{\ is a stable model of }\textit{\ in the sense of PSC, then } where  \textit{\ is a stable model of }\textit{\ in the sense of Gelfond and Lifschitz.}

\textbf{Theorem 2. }\textit{1. If }\textit{\ is an optimal stable model of
}, \textit{\ then }\textit{\ is a preferred PSC\ stable model of }\textit{.}

\textit{2. If }\textit{\ is a preferred PSC\ stable model of },\textit{\ then }\textit{\ is an optimal stable model of
}\textit{.} \newline

A reasonable concern in the construction of  is the efficiency of the
implementation of the PSC\ atoms .The implementation of such an atom can be
a string  where , ,  are
the names of the algorithms. The algorithm corresponding to  on the input
set of atoms  will return . The
algorithm corresponding to  will always return  since any subset of
 is in . The algorithm corresponding to
 on the inputs  and  will return  iff
 and  otherwise. The algorithm for 
can be as efficient as the algorithm in the implementation of ASO. Our
algorithm can use the ASO\ algorithm to check the conditions , , , ,  that
are necessary for its evaluation.

\section{Using PSC\ Programs to Express General Preferences}

In this section we will show that the general preferences of \cite{SP} can be
expressed using PSC\ atoms. In \cite{SP}, the language  for
planning preferences specification was introduced.  allows users
to elegantly express multi-dimensional preferences among plans that achieve
the same goal. In , users can define \emph{general preferences}
by building them from simpler \emph{atomic preferences} using a small number
of special operators.

A \emph{basic desire formula} (basic desire for short) is a formula expressing
a single preference about a trajectory. Son and Pontelli provide a formal
definition of the notion of \emph{basic desire}, as well as a formal
definition of the notion of a \emph{trajectory}, and define what it means for
a trajectory \emph{to satisfy} a basic desire. For the purposes of this paper,
it is not necessary to restate these definitions. It will suffice to assume
that a basic desire is a formula  in some language and that, for any
trajectory , we can determine whether  \emph{satisfies} , written , or whether \emph{\ does not satisfy
}, written . We will also assume that each
basic desire corresponds to a unique predicate atom. In addition, we will use
the basic desires and the predicate atoms corresponding to them interchangeably.

Let  be a basic desire formula and let  and  be two
trajectories. The trajectory  is \emph{preferred} to the trajectory
, written , if  and
.  and  are \emph{indistinguishable
with respect to }, written , if either
(1) and  or (2)\  and .

An \emph{atomic preference formula} is defined as a formula of the type
... where , ..., 
are basic desire formulas. If  and  are trajectories and
... is an atomic preference
formula, then we say  and  are \emph{indistinguishable with
respect to } (written as ) if 
   and 
is \emph{preferred to } with respect to  (written as ) if  such that
  and
.

The set of \emph{general preference formulas} (general preferences) are
defined via the following inductive definition: (i) every atomic preference
formula  is a general preference formula, (ii) if ,  are general preference formulas, then , , and  are general preference formulas, and (iii) if
, , ...,  are general preference formulas, then
 . . .  is a general preference formula.

Let  be a general preference formula and let ,  be two
trajectories. Then we say  is \emph{preferred to }\emph{\ with
respect to } (written ) if:

1.  is an atomic preference formula and 

2.  and  and


3.  and ( \ and
) or ( and
) or ( and
).

4.  and 

5.  . . . , and there exists
 such that (  and ) \newline

We say  is \emph{indistinguishable from }\emph{\ with respect
to } (write ) if:

1.  is an atomic preference formula and 

2. ,  and


3. ,  and


4.  and 

5.  . . . , and for all  . \newline

Let  be the set of all the basic desire predicate atoms. Let  be a
finite subset of  and . Let 
be a pre-order on . For a trajectory  let  i.e. the
set of all the basic desires satisfied by . Then we say that \emph{\ satisfies } if
. We say that a trajectory \emph{\ is preferred to a trajectory }\emph{\ with respect to
} if . This will be denoted by . We say that trajectories \emph{, }\emph{\ are indistinguishable with respect to } if . This
will be denoted by .

\textbf{Theorem 3. }\textit{For a general preference formula }
\textit{there exists a pre-ordered PSC\ atom }\textit{ such that for two trajectories }\textit{, }\textit{, }\textit{\ in the
sense of \cite{SP} iff }\textit{ and }\textit{in the sense of \cite{SP} iff }\textit{.}

The proof, omitted due to space limitations shows how to construct
.

\section{\label{complexity}The Computational Complexity of the Set of
Preferred PSC Stable Models}

We can prove the following result on the computational complexity of finding a
\textquotedblleft preferred\textquotedblright\ PSC stable models of a PSC
program. Please note that the theorem's preconditions are formulated to be
useful for analyzing algorithmic implementations of PSC programming as
discussed in section 3.

\textbf{Theorem 4. }\textit{Let }\textit{\ be a finite PSC program. Let
}\textit{\ be the set of all atoms appearing in }\textit{\ and assume
that }\textit{\ is finite. Suppose that for any subset }\textit{\ of
}\textit{\ and any PSC atom }\textit{\ or }\textit{\ or any SC
atom }\textit{\ determining the intersection
}\textit{\ and the membership }\textit{\ can be done in
polynomial time on the number of elements in }\textit{\ and }\textit{.
If }\textit{\ is a pre-ordered PSC program, then suppose that for any PSC
atom }\textit{\ in }\textit{\ for
any two sets in }\textit{, the comparison operation }\textit{\ on
these subsets can be performed in polynomial time on the number of elements in
the subsets. If }\textit{\ is a measure PSC program, then suppose that for
any PSC atom }\textit{\ in }\textit{\ and any subset }\textit{\ of }\textit{, the computation
}\textit{\ can be performed in polynomial time on
the number of elements of }\textit{. Then given }\textit{,
the problem of determining whether }\textit{\ is a preferred PSC stable
model of }\textit{\ for any of the induced pre-orders on stable models
described in Section 3 is CoNP-complete relative to the size of }\textit{\ and the number of elements in }\textit{.} \newline

Now, in \cite{BNT03} it was shown that the problem of deciding whether there
exists an answer set for an ASO program ,  is
NP-complete and the problem of deciding whether  is an optimal model of  is coNP-complete. This is the complexity of the corresponding problems for
PSC programs. That is, the problem of deciding whether there exists a stable
model for a PSC program  is NP-complete and the problem of deciding whether
a PSC stable model  of a PSC program  is a preferred PSC stable model is
co-NP complete.

\section{Conclusions and directions for further research}

In this paper, we have introduced an approach to specifying preferences in ASP
called Preference Set Constraint Programming which is an extension of SC
programming of \cite{MR}. PSC programming uses two types of PSC
atoms:\ pre-ordered PSC atoms and measure PSC atoms. These atoms can be used
to define pre-ordered PSC\ programs and measure PSC\ programs. For pre-ordered
PSC programs, we have considered two approaches for specifying preferences:
\textquotedblleft in common"\ and \textquotedblleft in total". For the measure
PSC programs we have considered three approaches:\ \textquotedblleft in
common", \textquotedblleft in total" and \textquotedblleft in sum". We show
that the problem of determining whether  is a preferred PSC stable models
of a PSC program is CoNP-complete. To demonstrate the expressive power of PSC
programming, we have shown that PSC\ programming can be used to express
optimal stable models of ASO \cite{BNT03}, and the general preferences of Son
and Pontelli \cite{SP}. It is also the case that the preferred stable models
and the weakly preferred stable models of \cite{BrewkaE99} can be expressed by
an extension of PSC programming, although it was not discussed in this paper.

We have only briefly discussed implementations of PSC\ programming, but
clearly it is an important issue for applications.

There are a number of areas for further research on PSC programming. One is to
study the exact relationships between PSC programming and other approaches for
reasoning with preferences. In particular, one must pay special attention to
the efficiency of expressing preferences in any two systems that are being
compared. A second is to study extensions of PSC programming where we add the
ability of the user to express preference by preference orderings on rules. We
will study both of these questions in subsequent papers.

Finally, the five approaches for specifying preferences using PSC programs can
be viewed as special cases of the following generalization. A
\emph{PSC\ system}  is a pair  where 
is a PSC program and  is a pre-order on the set of PSC\ stable models of
 with the property that if  and  are PSC stable models of 
such that   
and , then  or  if  is a
pre-ordered PSCprogram and  or 
if  is a measure PSC\ program. We suggest that one should study abstract
properties of PSC systems.

\bibliographystyle{aaai}
\bibliography{bibliography}



\end{document}