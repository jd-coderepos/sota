\documentclass{LMCS}

\def\dOi{9(4:9)2013}
\lmcsheading {\dOi}
{1--42}
{}
{}
{Oct.~24, 2012}
{Oct.~31, 2013}
{}

\ACMCCS{[{\bf Theory of computation}]: Computational complexity and
  cryptography---Complexity classes\,/\,Complexity theory and logic;
  Formal languages and automata theory---Formalisms---Rewrite systems;
  Logic---Logic and verification}

\usepackage[utf8x]{inputenc}\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[numbers,sort&compress]{natbib}   
\usepackage{tikz}
\usetikzlibrary{decorations,shapes.callouts,arrows,positioning}
\usepackage{slashed} 
\usepackage{url}
\usepackage[bookmarks=false]{hyperref}
\usepackage{xargs}
\usepackage{stmaryrd}
\usepackage{bbding}
\usepackage{xifthen}
\usepackage{enumitem}
\usepackage{pop}
\newtheorem{example}[thm]{Example}
\newtheorem{definition}[thm]{Definition}
\newtheorem{theorem}[thm]{Theorem}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{claim}[thm]{Claim}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem*{remark}{Remark}

\begin{document}
\title[Polynomial Path Orders]{Polynomial Path Orders}

\author[M.~Avanzini]{Martin Avanzini}
\address{Institute of Computer Science\\University of Innsbruck\\ Austria}
\email{\{martin.avanzini,georg.moser\}@uibk.ac.at}


\author[G.~Moser]{Georg Moser}
\address{\vspace{-18 pt}}
\thanks{This work is partially supported by FWF (Austrian Science Fund) project I-603-N18}

\renewcommand{\labelitemi}{-}

\keywords{Term Rewriting, Complexity Analysis, Implicit Computational
Complexity, Automation}

\subjclass{F.4.1, F.4.2, F.1.3, D.2.4}

\begin{abstract}
This paper is concerned with the complexity analysis of
constructor term rewrite systems and its ramification in implicit
computational complexity.
We introduce a path order with multiset status, 
the \emph{polynomial path order} \POPSTAR, that is applicable
in two related, but distinct contexts.
On the one hand \POPSTAR\ induces polynomial innermost runtime complexity
and hence may serve as a syntactic, and fully automatable, method to analyse
the innermost runtime complexity of term rewrite systems.
On the other hand \POPSTAR\ provides an order-theoretic 
characterisation of the polytime computable functions: 
the polytime computable functions are exactly the functions
computable by an orthogonal constructor TRS compatible with \POPSTAR.
\end{abstract}

\maketitle

\section{Introduction}\label{s:intro}

In this paper we are concerned with the complexity analysis of
constructor term rewrite systems.
Since term rewrite systems (TRSs for short) underlie much of 
declarative programming, time complexity of functions defined by TRSs
is of particular interest.

In rewriting two notions of complexity have been widely studied. 
Hofbauer and Lautemann proposed to assess the complexity of a given TRS 
as the maximal length of derivation sequences. More precisely
the \emph{derivational complexity function} relates the maximal length of a 
derivation with the size of the starting term~\cite{HL89}. 
As an alternative Hirokawa and the second author proposed to study the 
\emph{runtime complexity function}~\cite{HM08}, which forms a variation
of the derivational complexity function. Instead of all possible derivations,
one studies only derivations with starting terms whose arguments are constructor terms
(aka \emph{basic terms}), see also~\cite{BCMT01}.
In the context of this paper, runtime complexity is the more natural notion. 
We emphasise that the runtime complexity of a rewrite system
forms a \emph{polynomially invariant} cost model~\cite{Boas:TCS:90}, cf.~Section~\ref{s:basics}.

To motivate our studies, we present a natural encoding of
the well-known satisfiability problem  of propositional logic 
as a TRS.\@ Given a propositional formula in conjunctive normal form, 
the TRS  given below computes a satisfying assignment if it exists.
Note that  is not confluent, i.e., the computation is performed 
nondeterministically. 
The rewrite system  thus encodes 
the function problem \emph{} associated with the satisfiability
problem. 
 is complete for the class of \emph{function problems over } 
( for short). See Section~\ref{s:basics} where  is formally defined. 
As corollary to the polynomial invariance of
the runtime complexity of rewrite systems, we obtain that the runtime complexity
of  is expected to be polynomial.

\begin{example}
\label{ex:rssat}
Consider the following (non-confluent) TRS :\footnote{This is a slight variant of Example \textsf{TCT\_12/sat.xml} in the current 
Termination Problem Database (TPDB) version 8.0.}
2mm]
\rlabel{RSsat:eq:ZO} && \meq(\mZ(x),\mO(y)) & \to \mfalse 
& ~
\rlabel{RSsat:eq:ZZ} && \meq(\mZ(x),\mZ(y)) & \to \meq(x,y) 
\\
\rlabel{RSsat:eq:OZ} && \meq(\mO(x),\mZ(y)) & \to \mfalse 
& ~
\rlabel{RSsat:eq:OO} && \meq(\mO(x),\mO(y)) & \to \meq(x,y) 
\\
\rlabel{RSsat:eq:np} && \meq(-x,+y) & \to \mfalse 
& ~
\rlabel{RSsat:eq:nn} && \meq(-x,-y) & \to \meq(x,y) 
\\
\rlabel{RSsat:eq:pn} && \meq(+x,-y) & \to \mfalse 
& ~
\rlabel{RSsat:eq:pp} && \meq(+x,-y) & \to \meq(x,y) 
\\
\rlabel{RSsat:eq:ee} && \meq(\varepsilon,\varepsilon) & \to \mtrue 
\2mm]
\rlabel{RSsat:verify:b} && \verify(\nil) & \to \mtrue 
& ~
\rlabel{RSsat:verify:r} && \verify(l \cons ls) & \to \mif(\member(\mneg(l),ls), \mfalse, \verify(ls))
\2mm]
\rlabel{RSsat:guess:b} && \guess(\nil) & \to \nil
& ~
\rlabel{RSsat:guess:r} && \guess(c \cons cs) & \to \choice(c) \cons \guess(cs)
\2mm]
\rlabel{RSsat:issat} && \issat(cs) & \to \mparbox{1cm}{\issat'(\guess(cs))}
\\
\rlabel{RSsat:issat'} && \issat'(as) & \to \mparbox{1cm}{\mif(\verify(as),as,\unsat) \tpkt}
{6}
    \rlabel{RS2:a} && \bin(x,\Null) & \to \ms(\Null) 
    & \quad
    \rlabel{RS2:b} && \bin(\Null,\ms(y)) & \to \Null 
    & \quad    
    \rlabel{RS2:c} && \bin(\ms(x),\ms(y)) & \to \mP(\bin(x,\ms(y)),\bin(x,y))
    \tpkt
{4}
  & \text{\textsf{(Values)}} & & \quad & \Val & \ni v &~&\defsym~x \mid c(\seq{v}) \\
  & \text{\textsf{(Basic Terms)}} & & & \BASICS & \ni s & &  \defsym~ x \mid f(\seq{v}) \\
  & \text{\textsf{(Terms)}} & & & \TERMS & \ni t & & \defsym~ x \mid c(\seq{t}) \mid f(\seq{t})
  \tpkt

  f(\seq{v}) = t_0 \irew t_1 \irew \cdots \irew t_\ell = w \tpkt

{(\seq{v},w) \in \sem{f}} \quad\defiff\quad {f(\seq{v}) \irsn[\RS] w} \text{ and  is accepting with respect to }\tpkt

 \rc[\RS](n) \defsym 
 \max\{\ell \mid \exists s \in \BASICS, \size{s} \leqslant n \text{ and } s  = t_0 \irew t_1 \irew \dots \irew t_\ell\} \tpkt
{6}
    \rlabel{dup:1} &~& \m{btree}(0) & \to \m{leaf}  
    \qquad & 
    \rlabel{dup:3} &~& \m{dup}(t) & \to \m{node}(t,t)
    \quad &
    \rlabel{dup:2} &~& \m{btree}(\ms(n)) & \to \m{dup}(\m{btree}(n)) \tpkt 
  
  \m{btree}(\ms^{n}(0)) 
  \rew \m{dup}(\m{btree}(\ms^{n-1}(0)))
  \rew \m{node}(\m{btree}(\ms^{n-1}(0)), \m{btree}(\ms^{n-1}(0)))
  \rew \dots
  \tkom
  
\label{scheme:srn} 
\tag{\ensuremath{\mathrm{SRN}}}
\begin{aligned}
  f(\sn{0,\vec{x}}{\vec{y}}) & = g(\sn{\vec{x}}{\vec{y}}) 
     \\
  f(\sn{2z + i,\vec{x}}{\vec{y}}) & = 
   h_i(\sn{z,\vec{x}}{\vec{y},f(\sn{z,\vec{x}}{\vec{y}})})\quad i \in \set{1,2}
   \tkom
\end{aligned}
\label{scheme:sc} \tag{\ensuremath{\mathrm{SC}}}
  f(\sn{\vec{x}}{\vec{y}}) = h(\sn{\vec{r}(\sn{\vec{x}}{})}{\vec{s}(\sn{\vec{x}}{\vec{y}})}) \tpkt
{4}
    \rlabel{plus1} &~& +(\sn{0}{y}) & \to y 
    & \qquad
    \rlabel{plus2} &~& +(\sn{\ms(\sn{}{x})}{y}) & \to \ms(\sn{}{+(\sn{x}{y})})
    \\
    \rlabel{times1} &~& \times(\sn{0,y}{}) & \to 0 
    & \qquad
    \rlabel{times2} &~& \times(\sn{\ms(\sn{}{x}),y}{}) & \to +(\sn{y}{\times(\sn{x,y}{})})
  
  \rlabel[\therule{times2}a]{times2a}~\times(\sn{\ms(\sn{}{x}),y}{}) \to +(\sn{\times(\sn{x,y}{})}{y})
  \tpkt
  {4}
    \rlabel{exp1} &~& \m{exp}(0,y) & \to \ms(\sn{}{0})  \qquad\qquad &
    \rlabel{exp2} &~& \m{exp}(\ms(\sn{}{x}),y) & \to \times(\sn{y,\m{exp}(x,y)}{}) \tkom
  
    \m{f}_k(\sn{\ms(x_1), x_2,x_3, \dots,x_k}{}) & \to \m{f}_k(\sn{x_1, x_2, x_3, \dots,x_k}{}) \\
    \m{f}_k(\sn{0,\ms(x_2), x_3, \dots, x_k}{}) & \to \m{f}_k(\sn{x_2, x_2, x_3, \dots,x_k}{}) \\
    & \ \,\vdots \\
    \m{f}_k(\sn{0,\dots,0,\ms(x_k)}{}) & \to \m{f}_k(\sn{x_k,\dots,x_k,x_k}{})
  
  \m{f}_k(\ms^n(0), \dots, \ms^n(0)) 
  \rsl[\RS_k]{{\geqslant}c_k \cdot n^k} \m{f}_k(0, \dots, 0)
  
  \m{f}_{k+1}(\ms^{n}(0), \dots, \ms^{n}(0), \ms^n(0)) 
  & \rsl[\RS_{k+1}]{{\geqslant}c_k \cdot n^k} \m{f}_{k+1}(0, \dots, 0,\ms^{n}(0)) \\
  & \rew[\RS_{k+1}]\m{f}_{k+1}(\ms^{n-1}(0),\dots,\ms^{n-1}(0),\ms^{n-1}(0)) \tpkt
  
  \m{f}_{k+1}(\ms^{n}(0), \dots, \ms^{n}(0), \ms^n(0)) 
  \rsl[\RS_{k+1}]{{\geqslant}f(n)} \m{f}_{k+1}(0, \dots, 0, 0) 
  {4}
  \rlabel{dc:1} && +(0;y) & \to y 
  & \qquad
  \rlabel{dc:2} && +(\ms(;x);y) & \to \ms(;+(x;y))  
  \\
  \rlabel{dc:3} && \m{d}(0;) & \to 0 
  & \qquad
  \rlabel{dc:4} && \m{d}(\ms(;x);) & \to \ms(;\ms(;\m{d}(x;)))
  \\
  \rlabel{dc:5} && \m{q}(0;) & \to 0 
  & \qquad
  \rlabel{dc:6} && \m{q}(\ms(;x);) & \to +(\ms(;\m{d}(x;));\m{q}(x;))
  \tkom
{4}
    \rlabel{nc:f} && \mf(\sn{n}{}) & \to \mh(\sn{}{\m{gs}(\sn{n}{})})
    & \qquad
    \rlabel{nc:gs1}  && \m{gs}(\sn{0}{}) & \to 0
    \\
    \rlabel{nc:h} && \mh(\sn{}{\mg(\sn{}{n})}) & \to \mc(\sn{}{\mh(\sn{}{n}),\mh(\sn{}{n})})
    & \qquad
    \rlabel{nc:gs2}  && \m{gs}(\sn{\m{s}(\sn{}{n})}{}) & \to \mg(\sn{}{\m{gs}(\sn{n}{})}{})
    \\
    \rlabel{nc:g}  && \mg(\sn{}{\bot}) & \to \mc(\sn{}{\mh({\sn{}{\bot}}),\mh({\sn{}{\bot}})})
    \tkom
  
  \mf(\sn{\ms^n(\sn{}{0})}{}) 
  \rew[\RSnc] \mh(\sn{}{\m{gs}(\sn{\ms^n(\sn{}{0})}{})}) 
  \rss[\RSnc] \mh(\sn{}{\mg^n(\sn{}{0})}{}) \tkom
  
  f(c(\seq{x}), \vec{y}) = h_c(\seq{x},\vec{y},f(x_1,\vec{y}),\dots,f(x_n,\vec{y})) \tkom
{4}
    \rlabel{gr:call}  && \mf(\sn{n}{}) & \to \m{traverse}(\sn{\m{btree}(\sn{n}{})}{})
    \\
    \rlabel{gr:g1}  && \m{traverse}(\sn{\m{leaf}}{}) & \to \m{leaf}
    \\
    \rlabel{nc:g2}  && \m{traverse}(\sn{\m{node}(\sn{}{x,y})}{}) & \to \m{node}(\sn{}{\m{traverse}(\sn{x}{}), \m{traverse}(\sn{y}{})})
    \tpkt
  
  \FSn \defsym \bigl\{ \fn \mid f \in \FS, \normal(f) = \{i_1,\dots,i_k\} \text{ and } \ar(\fn) = k \}\bigr\}
\tpkt

  \width(a) \defsym
  \begin{cases}
    1 & \text{if  is a variable, }\\
    \max \{1,\width(a_1),\dots,\width(a_n)\} & \text{if  with , and}\\
    \sum_{i=1}^n \width(a_i)
    & \text{if }
    \tpkt
  \end{cases}

  \norm{t} \defsym
  \begin{cases}
    1 & \text{ is a variable,} \\
    1+ \max\{0\} \cup \{\norm{t_{j}} \mid j = k+1,\dots,k+l\} & \text{}.
  \end{cases}
  \tpkt

  \ints_\RS(t) & \defsym
  \begin{cases}
    \nil & \text{ if ,} \\
    \lst{\fn(\intn_\RS(t_1), \dots, \intn_\RS(t_k))} \append \ints(t_{k+1}) \append \cdots \append \ints(t_{k+l}) & \text{ otherwise where (),}
  \end{cases}\\
  \intn_\RS(t) & \defsym \ints_\RS(t) \append \NM{t} \tpkt

\ints(s) = \lst{\fn(\intn(u_1),\dots,\intn(u_k))} \append \ints(u_{k+1}) \append \cdots \append \ints(u_{k+l}) 
= \lst{\fn(\natToSeq{\depth(u_1)},\dots,\natToSeq{\depth(u_k)})}
\tpkt

    \rlabel{RSf:1} \m{f}(\sn{0}{y}) & \to y 
    & \rlabel{RSf:2} \m{f}(\sn{\ms(x)}{y}) & \to \m{g}(\sn{\m{h}(\sn{x}{})}{\m{f}(\sn{x}{y})})
  
    \lst{\fsn{\m{f}}(\natToSeq{1})} & \gpopv[][] \nil && \text{from rule \rlbl{1}}\\
    \mparbox[r]{45mm}{\lst{\fsn{\m{f}}(\natToSeq{\depth(x\sigma) + 1})}} & \gpopv[][] \mparbox[l]{65mm}{\lst{\fsn{\m{g}}(\intn(\m{h}(\sn{x\sigma}{})))~\fsn{\m{f}}(\natToSeq{\depth(x\sigma)})}}  && \text{from rule \rlbl{2},}
  
  s = f(s_1,\dots,s_i,\dots,s_{k+l}) \irew[\RS_f] f(s_1,\dots,t_i,\dots,s_{k+l}) = t \tkom
  
    \ints(s) 
    & = \lst{\fn(\intn(s_1), \dots, \intn(s_i), \dots, \intn(s_k))} \append \ints(s_{k+1}) \append \cdots \append \ints(s_{k+l}) \tag{a}\\
    & \gpopv[][] \lst{\fn(\intn(s_1), \dots, \intn(t_i), \dots, \intn(s_k))} \append \ints(s_{k+1}) \append \cdots \append \ints(s_{k+l}) = \intn(t), \text{ or} \
To be able to deal with steps below normal argument positions as in , we also 
  orient images of . This results additionally in following constraints:

\end{example}









The \emph{polynomial path order on sequences} (\emph{\POP}~for short), 
denoted by , constitutes a generalisation of the \emph{path order for } 
as put forward in~\cite{AM05}.
Whereas we previously used the notion of safe mapping to 
dictate predicative recursion on compatible TRSs, 
the order on sequences relies on the explicit separation of safe 
arguments as given by predicative interpretations.
Following Buchholz~\cite{B95}, it suffices to present \emph{finite approximations}
 of~.
The parameters  and  are used to controls the width and depth
of right-hand sides.
Fix a precedence  on the normalised signature .
We extend term equivalence with respect to  to sequences by 
disregarding the order on elements.
\begin{definition}\label{d:eqi}
  We define  if  or there exists a permutation 
  such that  for all , 
  where either 
  (i) , , or 
  (ii) ,  and .
\end{definition}

In correspondence to , the order  
is based on an auxiliary order .

\begin{definition}\label{d:gppv} 
  Let .
  We define  with respect to the precedence  inductively as follows:
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item\label{d:gppv:st}
     if   for some ;
  \item\label{d:gppv:ia}
     if  and the following conditions are satisfied:
    \begin{itemize}
    \item  for all ;
    \item ;
    \end{itemize}
  \item\label{d:gppv:ialst}
     if the following conditions are satisfied:
    \begin{itemize}
    \item  for all ;
    \item ;
    \end{itemize}
  \item\label{d:gppv:ms} 
     if the following conditions are satisfied:
    \begin{itemize}
    \item ;
    \item  for all ;
    \item  for at least one ;
    \item ;
    \end{itemize}
  \end{enumerate}
  Here  denotes .  We write
   to abbreviate .
\end{definition}

We stress that the definition
lacks a case  where .
Still the order is sufficient to account for 
terms oriented by the auxiliary order .

\begin{example}[Example~\ref{ex:pint} continued]\label{ex:gppv}
  Reconsider rule  from the TRS  given in Example~\ref{ex:pint}, where
  in particular .
  We show below  
  for all substitutions . 
First recall that by the overloading of concatenation, we can write
  
  with  occurrences of , appending -times the empty sequence  
  for all . 
  Using that  and  
  for , 
  we can thus prove  whenever .
  Moreover we have
  
\end{example}

\noindent We arrive at the definition of the full order .
\begin{definition}\label{d:gpopv} 
  Let .
  We define  inductively as the least extension of  such that:
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item\label{d:gpopv:st}
     if  for some ;
  \item\label{d:gpopv:ep}
     if  
    and following conditions are satisfied: 
    \begin{itemize}
    \item ;
    \item ;
    \end{itemize}
  \item\label{d:gpopv:ialst} 
     
    and following conditions are satisfied: 
    \begin{itemize}
    \item  for at most one ;
    \item  for all ;
    \item ;
    \end{itemize}
  \item\label{d:gpopv:ms} 
    
    and following conditions are satisfied: 
    \begin{itemize}
    \item ;
    \item  for all ; \item  for at least one ; \item ;
    \end{itemize}
  \end{enumerate}
  Here  denotes . 
  We write  to abbreviate .
\end{definition}

The polynomial path order on sequences forms a restriction of the recursive path order with 
multiset status, where the variadic symbol  is implicitly 
ranked lowest in the precedence. As a consequence the order
it is well-founded~\cite{Ferreira95}.
The use of the auxiliary order in  accounts 
for our restriction that predicative recursive TRSs admit at most one 
recursive call per right-hand side.
Observe  for all terms , 
consequently   if at least one term  is ground.

\begin{example}[Example~\ref{ex:gppv} continued]\label{ex:gpopv} 
  We continue with the orientation of root steps from
  the TRS  depicted in Example~\ref{ex:pint}
  for substitutions .
Consider the more involved case  due to rule \rref{RSf:2}.
Note that in the orientation below we
  use  to orient the recursive call (proof step \rlbl{5}), 
  and  for the remaining elements (proof step \rlbl{6}).
  
  For the last orientation we employ that the width of the left-hand side 
  is at least , and the length of the right hand side is 
  , as required we have 
  
\end{example}

Observe that as in the above example, 
the parameter  in  controls 
the depth of the proof tree of . 
Since leafs of such proof trees hold either due to case 
or the absence of arguments in the right-hand side, it follows that 
the depth of  is bounded linearly 
in  and the depth of .
From the example it should also be clear how the parameter  
controls the length of right-hand sides, 
compare steps~\rlbl{9} and~\rlbl{10} where we had to increase 
the parameter .

In the example we obtained that the predicative embedding of 
root steps  
of predicative recursive TRS  is possible for , 
independent on the considered substitution . 
The next lemma clarifies that such a global  can always be found, 
and depends on the right-hand sides only. 

\begin{lemma}\label{l:int:len}
  Let , , and  be a normalising substitution. Then
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item\label{l:int:len:S} ; and
  \item\label{l:int:len:gsq} if   then ; and
  \item\label{l:int:len:gpop} if  then .
  \end{enumerate}
\end{lemma}






As a consequence of the above lemma we obtain: if  is a root step of 
a predicative TRS , then 
 
for . 
In the predicative embedding we instantiate 
 by twice the maximum size of right-hand sides of .
The side-conditions imposed on  
allow us to estimate the length of right-hand sides based on 
the width of left-hand sides and the parameter .
This and other frequently used properties are collected in the next lemma,
whose proof is not difficult.

\begin{lemma}\label{l:approx}
  The following properties hold for all  and .
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item\label{l:approx:kmon}  for all ;
  \item\label{l:approx:modeqi} ;
  \item\label{l:approx:bound}  implies ;
  \item\label{l:approx:subseq}  implies .
  \end{enumerate}
\end{lemma}




Following~\cite{AM05} we define a function  that measures the 
-descending lengths on sequences. To simplify matters, 
we restrict the definition of  to ground sequences.
As images of predicative interpretations are always ground, this suffices for our purposes.
\begin{definition}
We define 
as

\end{definition}

Note that due to Lemma~\eref{l:approx}{modeqi}, 
whenever . The next lemma confirms that sequences act purely as containers.

\begin{lemma}\label{l:slowsum} 
  For  it holds that .
\end{lemma}
\begin{proof}
  Let .
  We first show .
  Let  and consider maximal sequences
   and
  .
  Using Lemma~\eref{l:approx}{subseq} repeatedly we get
  
and thus 
   holds
  for all . We conclude
   
  with a straight forward induction on .

  It remains to verify .
  For this we show that  implies 
  by induction on .
  Consider the base case .
  Since  is ground it follows that , the claim is trivially satisfied.
  For the inductive step , 
  let .
  Since  is a sequence, .
  Hence  where  
  and thus  for all .
  Additionally  and hence  
  for at least one .
As in the first half of the proof, one verifies 
  for all .
  Note  as , 
  hence induction hypothesis is applicable to  and all  ().
  It follows that 
  
  This concludes the second part of the proof.
\end{proof}

The central theorem of this section, Theorem~\ref{t:pop}, states that 
is polynomial in , 
where the polynomial bound depends only on  and the rank  of .
The proof of this is involved.
To cope with the multiset comparison underlying ,
we introduce as a first step an \emph{order-preserving} 
extension  of  to multisets of sequences, 
in the sense that  holds 
whenever  
(provided , cf.~Lemma~\ref{l:slowpoly}).
As the next step toward our goal, we estimate  in terms 
of 
whenever  and .
Technically we bind following functions by polynomials . 
For all  with 
we define  as 
  


The definition of  is defined in terms of an order-preserving homomorphism from  to . 
To illustrate the construction carried out below, consider the following example.
\begin{example}\label{ex:multisets}
  Consider multisets  of size .
Conceive such multisets  as 
  natural 
  numbers written in base- (with  for all ), 
  where digits  are sorted from left to right in decreasing order.
  Then one can formulate chains  
  that can be understood as decreasing counters 
  which however wrap from
   to . 
  Compare the TRS  defined in Lemma~\ref{l:imprecise} that models such counters.\@
  Using the correspondence, it is
  easy to prove that the length of a chain of this form
  starting from 
  is given by
  
  The inclusion follows by -times application of the 
  Faulhaber's formula~\cite{K93}, which states that 
  for all , 
   for some polynomial  of degree . 
\end{example}

The above example gives a polynomial lower bound on the number of  descending 
sequences on multisets  of size .
We now prove that this lower bound also serves as an asymptotic upper bound, 
for all multisets of natural number of length \emph{up to} . 
For  and  we define the family of functions  
such that 

Here  denote the \nth{}\ element of  sorted in descending order, i.e., 
 
for  and some permutation  such that  ().
\begin{lemma}\label{l:homo}
  Let  such that . Then
  for all  and  we obtain:
  \begin{enumerate}[labelsep=*,leftmargin=*]
\item\label{l:homo:5} 
     implies , and
  \item\label{l:homo:4} 
    .
  \end{enumerate}
\end{lemma}

Let  be fixed and let  collect all multisets of size up to .
By Lemma~\ref{l:homo} the functions  
gives an order preserving homomorphism from  to .
Furthermore this homomorphism is polynomially bounded in its elements.
We extend this homomorphism to multisets  over .
Let  such that .
  We define  as follows:
  ,
  where .
We obtain:
\begin{lemma}\label{l:slowpoly}
  Let  and let . Then
  
\end{lemma}






In Theorem~\ref{t:pop} below we prove 
for some constants  depending only on  and . 
Inevitably the proof of Theorem~\ref{t:pop} is technical, 
the reader may to skip the formal proof on the first read.
In the proof of Theorem~\ref{t:pop}, we instantiate the constants  by parameters , 
which are defined by recursion on  as follows:\label{d:dkp:ckp}

The theorem is then proven by induction on  and .
Consider term  with  and .
At the heart of the proof, we show that 
 for arbitrary  with . 
The most involved case is  where for all 
but one  we have . 
Here it is important to give a precise analysis of the order , 
exploiting the parameters  and . 
To this avail we define for  and  a family of auxiliary functions 
 by

Having as premise the induction hypothesis of the main proof, the next lemma 
explains the r\^ole of .
\begin{lemma}\label{l:pop:aux}
  Let .
  Let  and 
  .
  Suppose  for all  and .
  Then for all , 
  
\end{lemma}
\begin{proof}

  We prove lemma by induction on .
  The base case  is easy to show, hence 
  assume . 
  Suppose , we continue by case analysis:
  \begin{description}[leftmargin=0.3cm]
  \item[\dcase{}] 
  Then  for some ,
  and consequently . 
  Then by definition and assumption we even have .

  \item[\dcase{ where ] 
    Then 
     for all .
    Set . We have
    
    As in the considered case  holds, we have
     
    and so by assumption and arithmetical reasoning we conclude
    
  \item[\dcase{ where ]
    Order constraints give 
    and  ().
    Exploiting that  is ground, a standard argument shows 
    that , and consequently 
    .
    Thus
    
    Since by Lemma~\ref{l:slowsum} we have , 
    using \eqref{e:bindwidth} we see
    
  \end{description}
\end{proof}




\begin{theorem}\label{t:pop}
  Let  and . There exists constants  
  (depending only on  and ) such that 
  for all  we have 
  
\end{theorem}
\begin{proof}
  Fix  such that ,  and .
To show the theorem, we prove that for all  with  
  we have  
  for constants  and  as defined on page~\pageref{d:dkp:ckp}.
  The proof is by induction on the lexicographic combination of  and .
  The base case where  and  is easy to proof, we consider the inductive 
  step. 
  Consider the inductive step. By induction hypothesis 
  we have 
  
  For  we will use the induction hypothesis as a premise to Lemma~\ref{l:pop:aux}, 
  for  we use below the consequence
  
  We analyse the cases  and  separately. 
  In both cases we perform a side induction on . 
  \smallskip 
  \begin{description}[leftmargin=0.3cm]
  \item[\dcase{}]
    By side induction on  we prove that 
    for all  with .
    
    Note that if  holds, 
    as in the proof of Lemma~\ref{l:pop:aux},
    we even have . 

    Consider now  where . 
    The ordering constraints give  and
    , 
    from Lemma~\ref{l:slowpoly} we thus get . 
Since also  in this case
    we conclude as we even have
    

    Next consider  where .
    The order constraints give
    (i)  for some ,
    (ii)  for all , and
    (iii) .
    We have 
    
    For the last inequality, compare Equation~\eqref{e:bindwidth} from Lemma~\ref{l:pop:aux}.
    As  by Lemma~\ref{l:slowsum}, substituting 
    the above inequalities we get
    
    This concludes the final case of the side induction.
    Since  this preparatory step gives
    
    we conclude the case .

    \medskip

  \item[\dcase{}]
We show first that for all , if  then
    
    The proof is by induction on . 
    Suppose . 
    The base case  is trivial, so consider the inductive step .
    As in the case ,
    if  then even , 
    and if  then even .
    Consider .
    Then  with 
    (i)  for some ,
    (ii)  for all , and
    (iii) .
    A standard argument gives
    
    for all , thus
    
    Using Lemma~\ref{l:slowsum} and substituting 
    the above inequalities we get
    
    as desired, we conclude Equation~\eqref{t:pop:a}.
From this preparatory step,  
    and  we finally get
    
    and conclude also this case.\qedhere
  \end{description}
\end{proof}


















\noindent As a consequence, the number of -descents on 
basic terms interpreted with predicative interpretation  
is polynomial in sum of depths of normal arguments.

\begin{corollary}\label{c:pop}
  Let  and consider 
   with  normal arguments.
There exists a constant  depending only on  and 
  the rank of  such that:
  
  for all .
\end{corollary}
\proof
  Let  be as given by the corollary. 
  Recall that since arguments of  are values, we have  as indicated on page~\pageref{d:normonval}, 
  and further  holds for all .
  Thus
  
As  is constant, say , by Lemma~\ref{l:slowsum} we see that
  . 
We conclude as
  



\section{Predicative Embedding}\label{s:embed}

Fix a predicative recursive TRS  and signature , 
and let  be the polynomial path order underlying  
based on the (admissible) precedence .
We denote by  also the induced precedence on  
given by:  if  and  if .
Further, we set  for all .
We denote by  (and respectively ) the approximation 
given in Definition~\ref{d:gpopv} (respectively Definition~\ref{d:gppv}) with underlying precedence .

In this section, we establish the embedding of  into  as
outlined in the proof plan on page~\pageref{popstar:proofplan}; in the sequel
 is set to twice the maximum size of right-hand sides of .
Lemma~\ref{l:embed:root} below proves the embedding of root steps 
for the case . In Lemma~\ref{l:embed:ctx} we then show that the embedding is closed under contexts.
The next auxiliary lemma connects the auxiliary orders  and  (compare Example~\ref{ex:gppv}).

\begin{lemma}\label{l:embedgsq:root}
  Suppose ,  and . 
  Then for predicative interpretation 
  we have 
  
\end{lemma}
\begin{proof}
The proof proceeds by induction on the definition of  and makes
use of Lemmas~\ref{l:gpop:val},~\ref{l:int:len} and~\ref{l:approx}.
\end{proof}




\begin{lemma}\label{l:embed:root}
  Suppose ,  and . 
  Then for predicative interpretation 
  we have 
  
\end{lemma}
\begin{proof}
  Let , ,  be as given in the lemma.
  We prove the stronger assertions
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item \label{l:er1} , 
  \item \label{l:er2}  if , and
  \item \label{l:er3} .
  \end{enumerate}
As , 
Property~\ref{l:er1} and Lemma~\eref{l:approx}{bound}
yield  .
Furthermore
. 
Hence Property~\ref{l:er3} immediately
yields .


We continue with the proof of the assertions by induction on  
and set .
\begin{description}[leftmargin=0.3cm]
  \item[{\dcase{}}]
Due to Lemma~\ref{l:gpop:val} (employing ) 
we obtain that  is a safe subterm of 
and .
The latter implies  and thus
Properties~\ref{l:er1} and~\ref{l:er2} follow.
For Property~\ref{l:er3}, observe that 
    .
Here the last inequality follows by a simple case distinction on .
From this and  we get


  \item[\dcase{}]
    The assumption gives  where 
    and further  for all normal argument positions , and
     for all safe argument positions , of . 
    Additionally  for at most one argument position .
Set  and 
    let  for all safe argument positions 
    . Hence, we obtain:

    Applying Lemma~\ref{l:embedgsq:root} on all normal arguments of , we see
    
    from the assumptions  and  for all .
    Since  by assumption, induction hypothesis on  gives 
.
We obtain:

Induction hypothesis on safe argument positions  gives:

Due to Lemma~\eref{l:int:len}{S}, . 
Hence property~~\ref{l:er1} follows by 
using equations \eqref{e:c3:0}--\eqref{e:c3:3}.
Likewise, Property~\ref{l:er3} follows by an additional use of
 and
    
Here the first inequality follows by Lemma~\eref{l:int:len}{gpop}.
For Property~\ref{l:er2} we proceed as above, but strengthen inequality~\eqref{e:c3:1} 
to .



  \item[\dcase{}]
    Then  where .
    Further, the assumption gives
    
    and .
    Hence  and Property~\ref{l:er2} is vacuously 
    satisfied. 
    We prove Properties~\ref{l:er1} and~\ref{l:er3}.
    Using  for all normal argument positions 
    and employing Lemma~\ref{l:gpop:val} we see that
     implies

Hence due to 
     and 
    we obtain:
    
Assumption  together with
     for all  gives
    . As a consequence we have  for all
     and we obtain:

    which concludes the argument for property~\ref{l:er1}.
For property~\ref{l:er3}, 
    we see that the order constraints on safe arguments 
    imply . 
    Thus , 
    using this and Equation~\eqref{eq:root:ep} we obtain 
    
    by Lemma~\eref{l:approx}{kmon} and Lemma~\eref{l:approx}{subseq}.\qedhere
  \end{description}
\end{proof}

\begin{lemma}
  \label{l:embed:ctx}
  Let  and . Then for , 
  
\end{lemma}
\begin{proof}
We proceed by induction on the context . 
It suffices to consider the inductive step.
Consider terms  and 
. We restrict our attention
the predicative interpretation  and show , whenever 
. 

Recall that  and .
If  then  follows 
from  and Lemma~\eref{l:approx}{subseq}.
Hence suppose .
We consider only the case where .
The assumption  
implies that  is a safe argument position of . 
Hence we obtain:

By definition we have . This together
with  yields  
by the shape of  and .
Using Lemma~\eref{l:approx}{subseq} and the assumption 
we obtain:

From this we have 
and thus due to Lemma~\eref{l:approx}{modeqi}
and Lemma~\eref{l:approx}{subseq} we obtain 
.\qedhere


\end{proof}

We have established our first main result.
\begin{proof}[Proof of Theorem~\ref{t:popstar}]
  Let  be a predicative recursive TRS and fix an 
  arbitrary basic term . 
  Set the parameter  as follows:

As  and  are finite,  is well-defined.
Consider a maximal -derivation
  
  starting from an arbitrary term , that is, .
  Using Lemma~\ref{l:embed:root} together with Lemma~\ref{l:embed:ctx} -times 
  we get 
  
  As a consequence, we have  by definition
of  and thus:

where the asymptotic estimation follows by Corollary~\ref{c:pop}.
Note that the degree  depends only on~.
\end{proof}




\section{An Order-Theoretic Characterisation of the Polytime Functions}\label{s:icc}

We now present the application of polynomial path orders
in the context of \emph{implicit computational complexity}.
As by-product of Proposition~\ref{p:invariance} and Theorem~\ref{t:popstar} we immediately obtain
that  is \emph{sound} for  respectively .
\begin{theorem}\label{t:icc:soundness}
Let  be a predicative recursive (constructor) TRS.\@ 
  For every relation  defined by , 
  the function problem  associated with  is in .
  Moreover, if  is confluent then .
\end{theorem}

Although it is decidable whether a TRS  is predicative recursive (we 
present a sound and complete automation in Section~\ref{s:exps}), 
confluence is undecidable in general. To get a decidable result for , 
one can replace confluence by an decidable criteria, for instance orthogonality. 

We will now also establish that \POPSTAR\ is \emph{complete} for , that is, 
every function  is computed by some confluent (even orthogonal) 
predicative recursive TRS.\@
For this we employ Beckmann and Weiermann's \emph{term rewriting characterisation} of the 
Bellantoni and Cook's class .

\begin{definition}{\cite[Definition~2.2]{BW96}}
\label{d:Rb}
For each  the set of function symbols  
with  normal and  safe argument positions is the 
least set of function symbols such that
\begin{enumerate}[labelsep=*,leftmargin=*]
\item , , , 
  and , where ; 
\item if , 
  and  then ; 
\item if  and  then ; 
\end{enumerate}
The \emph{predicative signature} is given by .
Only the constant  and \emph{dyadic successors} , 
which serve the purpose of encoding natural numbers in binary, 
are constructors. The remaining symbols from  are defined symbols.
\end{definition}

In Figure~\ref{fig:1} we recall from~\cite[Definition~2.7]{BW96} 
the (infinite) schema of rewrite rules  that 
form a term rewriting characterisation of the class .
Here we let  range over  and set
 and 
 for  respectively  distinct variables. 

\begin{figure}[ht]
\begin{tabular}{@{\quad}r@{~}c@{~}l@{\hspace{-10mm}}r}
  \multicolumn{4}{@{}l}{\textbf{Initial Functions}}\1mm]
   &  &  &  for  \1mm]
   &  &  & for all  \1mm]
   &  &  & for  \3mm]
  \multicolumn{4}{@{}l}{\textbf{Safe Composition} ()} \3mm]
  \multicolumn{4}{@{}l}{\textbf{Safe Recursion on Notation} ()} \1mm]
     &  &  & for 
\end{tabular}
\caption{Term Rewriting Characterisation of the Class~}
\label{fig:1}
\end{figure}

\begin{remark}
We emphasise that the system  is called \emph{infeasible} in~\cite{BW96}.
Indeed  admits an exponential lower bound on the derivation height if
one considers full rewriting. This is induced by duplicating redexes as
explained already in Example~\ref{ex:dup} on page~\pageref{ex:dup}. 
However, this should rather be understood as a miss-configuration 
of the evaluation strategy, rather than a defect of the rewrite system. 
Indeed, in our completeness argument below, we exploit that
 is predicative recursive, thus the \emph{innermost} runtime complexity
is polynomial, as expected.
\end{remark}

We emphasise that the above rules are all orthogonal and 
the following proposition verifies that  generates only polytime computable functions.
\begin{proposition}\label{prop:Rf}{\cite[Lemma~5.2]{BW96}}
  Let . There exists a finite restriction 
  such that  computes .
\end{proposition}

We arrive at our completeness result.
\begin{theorem}\label{t:icc:completeness}
For every  there exists a finite, orthogonal, and 
  predicative recursive (constructor) TRS  that computes .
\end{theorem}
\begin{proof}
  Take the finite TRS  from Proposition~\ref{prop:Rf} that computes .
  Obviously  is orthogonal hence confluent. 

  It remains to verify that  is compatible with some instance .
  To define  we use the separation of normal from safe argument positions
  as indicated in the rules.
  To define the precedence underlying , we 
  define a mapping  from the signature of  
  into the natural numbers as follows:
  \begin{itemize}
  \item  if  is one of , , , , ,  or ;
  \item ;
  \item . 
  \end{itemize}
Finally for each pair of function symbol  and  occurring in , we set
   if .
  Then  defines an admissible precedence. 
 
 It is straight forward to verify that  where
   is based on the precedence~ and the safe mapping as indicated in
  Definition~\ref{d:Rb}.
\end{proof}

Observe that compatibility of  with \POPSTAR\ together with 
Theorem~\ref{t:popstar} yields a 
strengthened version of Theorem~4.3 in~\cite{BW96},
as due to our result the innermost derivation height is polynomially
bounded in the depth of the normal arguments only. The latter result can 
be obtained directly, by a simplification of 
the semantic argument given in~\cite[Section~4]{BW96}, see~\cite{AM04}.

By Theorem~\ref{t:icc:soundness} and Theorem~\ref{t:icc:completeness} we obtain a
precise characterisation of the class of polytime computable functions and
thus arrive at the second main result of the paper.

\begin{corollary}\label{c:FP}
  The following class of functions are equivalent:
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item The class of functions computed by confluent predicative recursive (constructor) TRSs.
  \item The class of polytime computable functions . 
  \end{enumerate}
\end{corollary}
We note that it is not decidable whether a rewrite system is confluent. However, 
to get a decidable characterisation we could replace confluence by orthogonality, compare 
Theorem~\ref{t:icc:completeness}.





\section{A Non-Trivial Closure Property of the Polytime Computable Functions}\label{s:popstarps}

Bellantoni~\cite{B:92} already observed that the class  is closed under
\emph{predicative recursion on notation with parameter substitution} (scheme \eqref{scheme:srnps}). 
Essentially this recursion scheme allows substitution on \emph{safe} argument positions. More precise, 
a new function  is defined by the equations


Bellantoni's result has been reobtained by Beckmann and 
Weiermann~\cite[Corollary~5.4]{BW96} employing a similar
term rewriting characterisation. In this section, we introduce
the \emph{polynomial path order with parameter substitution} (\emph{\POPSTARP} for short).
\POPSTARP\ provides an order-theoretic characterisation of
predicative recursion with parameter substitution, that again precisely
captures the class . Furthermore \POPSTARP\ induces polynomial
innermost runtime complexity. As a consequence, we obtain yet another proof
of Bellantoni's result.

The next definition introduces .
It is a variant of , where 
clause  has been modified and allows computation at safe argument positions.
\begin{definition}\label{d:gpopps}
  Let  denote a precedence.  
  Consider terms  such that .
  Then  if one of the following alternatives holds:
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item\label{d:gpopps:st}  for some , or
  \item\label{d:gpopps:ia} ,  where  
    and the following conditions hold:
    \begin{itemize}
    \item  for all normal argument positions ;
    \item  for all safe argument positions ;
    \item  for at most one safe argument position ;
    \end{itemize}
  \item\label{d:gpopps:ep} ,  where 
    and the following conditions hold:
    \begin{itemize}
    \item ;
    \item  and  for all safe argument positions .
    \end{itemize}
  \end{enumerate}
  Here .
\end{definition}

The next lemma shows that  extends the analytic power of .
\begin{lemma}\label{l:psextends}
  For any underlying admissible precedence , .
\end{lemma}
Note that \POPSTARP~is strictly more powerful than \POPSTAR, as witnessed by 
the following example.

\begin{example}\label{ex:rsrev}
Consider the constructor TRS  defining the reversal of
lists in a tail recursive fashion:

It is not difficult to see that  is compatible with \POPSTARP,
if we use the precedence .
Note that orientation of rule~\rref{RSrev:revt:r}
breaks down to  and 
.
On the other hand,  fails as the corresponding clause  
requires .
\end{example}

Due to Lemma~\ref{l:psextends}, \POPSTARP\ is complete for the class of
polytime computable functions.
To show that it is sound, we prove that 
\POPSTARP~induces polynomially bounded runtime complexity in the sense of Theorem~\ref{t:popstar}.
The crucial observation is that the embedding of  into  does not break
if we relax compatibility constraints to .

\begin{lemma}\label{l:embed:root:ps}
  Suppose ,  and . 
  Then for predicative interpretation 
  we have 
  
\end{lemma}
\proof
  First one verifies that 
  Lemma~\ref{l:int:len} holds even if we replace 
   by . 
  In particular, the assumptions give 
  
The proof follows the pattern of the proof of Lemma~\ref{l:embed:root}, i.e.,
  we proceed by induction on . 

  We cover only the new case .
  Let , , and  be as given in the lemma.
    Then  where .
    Further, the assumption gives
    .
    As  
    it suffices to verify Property~\ref{l:er1} and Property~\ref{l:er3}
    from Lemma~\ref{l:embed:root}.
    As before, we obtain:
    
By assumption  and , induction hypothesis gives 
    
    As  by Lemma~\eref{l:int:len}{S}, 
    we obtain 
    from equations~\eqref{eq:root:ep:ps} and~\eqref{eq:ti:ep:ps}.
Likewise, from this assertion~\ref{l:er3} follows by  using additionally 
    
    and
    \vspace{-3 pt}



\noindent Following the pattern of the proof of Theorem~\ref{t:popstar}, replacing
the use of Lemma~\ref{l:embed:root} by Lemma~\ref{l:embed:root:ps} we obtain:
\begin{theorem}\label{t:popstarps}
  Let  be a constructor TRS compatible with an instance of .
Then the innermost derivation height of any basic term 
   is bounded by a polynomial in the 
  maximal depth of normal arguments .
  The polynomial depends only on  and the signature .
\end{theorem}

As a corollary we get the following variant of~Theorem~5.3 in~\cite{BW96}.
\begin{corollary}
Let  be the rewrite system based on the defining equations from Figure~\ref{fig:1} 
and the Schema~\eqref{scheme:srnps}. Then 
the innermost derivation height of any basic term  
is bounded by a polynomial in the maximal depth of normal arguments .
\end{corollary}
\begin{proof}
By construction there exists an instance  such that .
Thus by the theorem, the result follows.  
\end{proof}

Applying Proposition~\ref{p:invariance} yields that predicative recursion is closed under parameter substitution.
We can even show a stronger result from Theorem~\ref{t:popstarps}.

\begin{corollary}
  Let  be a constructor TRS compatible with an instance of .\@ 
  For every relation  defined by , 
  the function problem  associated with  is in .
  Moreover, if  is confluent than .
\end{corollary}

By Lemma~\ref{l:psextends}, parameter substitution extends the power of , 
together with Theorem~\ref{t:icc:completeness} that shows completeness of , 
this shows completeness of \POPSTARP. We obtain our third result.\footnote{Again confluence can be replaced by orthogonality, as in Corollary~\ref{c:FP}.}
\begin{corollary}\label{c:fptime:ps}
  The following class of functions are equivalent:
  \begin{enumerate}[labelsep=*,leftmargin=*]
  \item The class of functions computed by confluent constructor TRS compatible with an instance of . 
  \item The class of polytime computable functions . 
  \end{enumerate}
\end{corollary}


\section{Automation of Polynomial Path Orders}\label{s:impl}

In this section we present an automation of polynomial path orders,  
for brevity we restrict our efforts to the order .
Consider a constructor TRS . Checking whether  is predicative 
recursive is equivalent to guessing a precedence  and partitioning 
of argument positions so that  holds for the induces
order . 
As standard for recursive path orders~\cite{ZM07,SFTGACMZ07},
this search can be automated by encoding the constraints imposed by Definition~\ref{d:gpop}
into \emph{propositional logic}. 
To simplify the presentation, we extend the language of propositional 
logic with truth-constants  and  in the obvious way.
In the constraint presented below we employ the following atoms. 

\subsection{Propositional Atoms}
To encode the separation of normal from safe arguments, we
introduce for  and  the atoms 
so that  represents the assertion that the \nth{} argument position of  is safe.
Further we set  for -ary  and ,
reflecting that argument positions of constructors are always safe. 

Since  is blind on constructors, predicative 
recursive TRSs are even compatible with  
as induced by an admissible precedence where constructors are equivalent and minimal.
For each pair of symbols , we introduce
propositional atoms  and  so that 
represents the assertion , and likewise 
 represents the assertion .
Overall we define for function symbols  and  the propositional formulas


To ensure that the variables  and respectively  encode a preorder on  
we encode an order preserving homomorphism into the natural order  on . 
To this extent, to each  we associate a natural number  encoded as binary string
with  bits. 
It is straight forward to define Boolean formulas  (respectively ) that are satisfiable iff 
the binary numbers  and  are decreasing (respectively equal) in the natural order. Using these we set


We say that a propositional assignment  \emph{induces} the precedence
 if  satisfies  when  and  when . 
The next lemma verifies that  serves our needs.
\begin{lemma}
  For any assignment  that satisfies , 
   induces an admissible precedence on .
Vice versa, for any admissible precedence  on , 
  any valuation , satisfying  iff  and 
   iff , also satisfies
  the formula .
\end{lemma}

\subsection{Order Constraints}
For concrete pairs of terms  and , we define

which enforces the orientation  using propositional formulations 
of the three clauses in Definition~\ref{d:gpop}. 
To complete the definition for arbitrary left-hand sides, we set  for all .
Further, weak orientation is given by

where the constraint  refers to a formulation of 
Definition~\ref{d:eqis} in propositional logic, defined as follows.
For  we simply set . 
Consider the case  and . 
Then  if  
and moreover  for all  and 
some permutation  on argument positions that takes the separation of normal and safe positions into account.
To encode , we use fresh atoms  for . 
The propositional formula 
is used to assert that the atoms  reflect a permutation on . 
Here  expresses that exactly one of its arguments evaluates to .
We set

To complete the definition, we set  for 
the remaining cases.
\begin{lemma}
  Suppose the assignment  induces an admissible precedence  and 
   satisfies . 
  Then  with respect to the precedence .
  Vice versa, if  then  is satisfiable by assignments  
  that induce the precedence underlying .
\end{lemma}

We now define the encoding for the different cases underlying the definition of .
Assuming that  enforces  clause  is expressible
as 

in propositional logic. 
For clause  we use propositional atoms  ()
to mark the unique argument position of  that allows
. 
The propositional formula  expresses that zero or one
 valuates to . 
Further, we introduce the auxiliary constraint 

and  for .
Using these, clause  becomes expressible as 

Here  if  and otherwise .
The propositional formula  expresses the orientation with the  and is given by

and otherwise , where

This concludes the propositional formulation of clause .

The main challenge in formulating clause 
is to deal with the encoding of multiset-comparisons. 
We proceed as in~\cite{SK07} and encode the underlying \emph{multiset cover}.
\begin{definition}
Let  denote the multiset extension of a binary relation .
Then a pair of mapping  
where  
and 
is a multiset cover on multisets  and 
if the following holds for all :
\begin{enumerate}[labelsep=*,leftmargin=*]\label{d:mscover}
\item\label{d:mscover:1} if  then , in this case we say that  \emph{covers} ; 
\item\label{d:mscover:2} if  then  and  is invective on , 
  i.e.,  covers only .
\end{enumerate}
The multiset cover  is said to be \emph{strict} if at least one cover is strict, 
i.e.,  for some .
\end{definition}

It is straight forward to verify that multiset covers characterise the multiset extension
of  in the following sense.
\begin{lemma}
  We have  if and only if there 
  exists a multiset cover  on  and .
  Moreover,  if and only if the cover is strict.
\end{lemma}

Consider the orientation . 
Then normal arguments are strictly, and safe arguments weakly decreasing with 
respect to the multiset-extension of . 
Since the partitioning of normal and safe argument is not fixed, 
in the encoding of  we formalise a multiset-comparison on \emph{all} arguments, 
where the underlying multiset-cover  
will be restricted so that if  covers , i.e., , 
then both  and  are safe or respectively normal.
To this extend, for a specific multiset cover  we introduce variables  and 
, where  represents  and
 denotes  (, ).
We set

Here the first line establishes the Condition~\eref{d:mscover}{1}, where
 additionally enforces the separation of normal from safe arguments.
The final line formalises
that  maps  to , Condition~\eref{d:mscover}{2}
as well as the strictness condition on normal arguments.
This completes the encoding of .

\begin{lemma}
  Suppose  induces an admissible precedence  and satisfies . 
  Then  with respect to the precedence .
  Vice versa, if  then  is satisfiable assignments  
  that induce the precedence underlying .
\end{lemma}

Putting the constraints together we get the following theorem,
which witnesses the fourth main result of this paper.
\begin{theorem}
  Let  be a constructor TRS.\@ 
  The propositional formula 
  
  is satisfiable if and only if  is predicative recursive.
\end{theorem}

We have implemented this reduction to \SAT~in our complexity analyser \TCT.\@
As underlying \SAT-solver we employ the open source solver \minisat~\cite{ES03}.


\subsection{Efficiency Considerations}
The \SAT-solver \minisat\ requires its input in CNF.\@
For a concise translation of  to CNF 
we use the approach of Plaisted and Greenbaum~\cite{PG86} that 
gives an equisatisfiable CNF linear in size.
Our implementation also eliminates redundancies resulting from 
multiple comparisons of the same pair of term  by 
replacing subformulas  with unique 
propositional atoms . Since  
occurs only in positive contexts, it suffices to 
add , resulting in an equisatisfiable formula.
Also during construction of  our implementation
performs immediate simplifications under Boolean laws.





\section{Experimental Assessment}\label{s:exps}

In this section we present an empirical evaluation of polynomial path orders.
We selected two testbeds: Testbed~\textsf{TC} constitutes 
of 597 terminating constructor TRSs, obtained
by restricting the innermost runtime complexity problemset 
from the \emph{Termination Problem Database}\footnote{The TPDB is available online~\url{http://termcomp.uibk.ac.at/}.} 
(\emph{TPDB} for short), version 8.0,
to known to be terminating constructor TRSs.
Termination is checked against the data available from the termination competition.
Testbed~\textsf{TCO}, containing 290 examples, results from restricting Testbed~\textsf{TC} to 
orthogonal systems.
Unarguably the TPDB is an imperfect choice as examples were collected primarily to 
assess the strength of termination provers, but it is at the moment the only 
extensive source of TRSs. 

Experiments were conducted with  version 1.9.1,\footnote{Available from \url{http://cl-informatik.uibk.ac.at/software/tct/}.}
on a laptop with 4Gb of RAM and Intel Core i7--2620M CPU (2.7GHz, quad-core).
We assess the strength of  and  in comparison to its predecessors  and .\@
The implementation of ,  and  follows the line of polynomial path orders 
as explained in Section~\ref{s:impl}.\footnote{As far as we know our implementation of  in~\TCT\ is
the only implementation currently available.}
We contrast these syntactic techniques to \emph{interpretations}
as implemented in our complexity tool .\@
The last column show result of constructor restricted 
matrix interpretations~\cite{MMNWZ11} (dimension  and )
as well as polynomial interpretations~\cite{BCMT01} (degree  and ), 
run in parallel on the quad-core processor.
We employ interpretations in their default configuration of \TCT, 
noteworthy coefficients (respectively entries in coefficients) 
range between  and , and we also make use of the \emph{usable argument positions} 
criterion~\cite{HM11} that weakens monotonicity constraints.
Table~\ref{tbl:exp1}
shows totals on systems that can respectively cannot be handled.\footnote{Full evidence available at \url{http://cl-informatik.uibk.ac.at/software/tct/experiments/popstar}.}
To the right of each entry we annotate the average execution time, in seconds.

\newcommand{\tm}[1]{\parbox[b]{9mm}{\bf{\tiny{#1}}}}
\renewcommand{\c}[1]{\parbox[b]{9mm}{{\hfill\small{#1}}}}
\begin{table}[h]
  \centering
  \begin{tabular}{l@{}l@{\quad}cccc@{\quad}c}
\hline
    \TOP & 
    & \MPO 
    & \LMPO
    & \POPSTAR
    & \POPSTARP
    & interpretations
    \BOT
    \\
    \hline
    \textbf{TC} \TOP 
    & \textsf{compatible}
    & \c{76}\tm{0.33} & \c{57}\tm{0.20} & \c{43}\tm{0.18} & \c{56}\tm{0.19} & \c{139}\tm{2.77} \\
    & \TOP \textsf{incompatible}
    & \c{521}\tm{0.58} & \c{540}\tm{0.47} & \c{554}\tm{0.42} & \c{541}\tm{0.43} & \c{272}\tm{6.47} \\
    & \TOP\BOT \textsf{timeout}
    & --- & --- & --- & --- & \c{186}\tm{25.0} \\
    \hline
    \textbf{TCO} \TOP 
    & \textsf{compatible}
    & \c{40}\tm{0.29} & \c{29}\tm{0.16} & \c{24}\tm{0.14} & \c{29}\tm{0.15} & \c{75}\tm{2.81} \\
    & \TOP \textsf{incompatible}
    & \c{250}\tm{0.33} & \c{261}\tm{0.27} & \c{266}\tm{0.26} & \c{261}\tm{0.27} & \c{133}\tm{6.12} \\
    & \TOP\BOT \textsf{timeout}
    & --- & --- & --- & --- & \c{82}\tm{25.0} \\
    \hline
  \end{tabular}
\caption{Empirical Evaluation, comparing syntactic to semantic techniques.}
\label{tbl:exp1}
\end{table}

It is immediate that syntactic techniques cannot compete with the expressive 
power of interpretations. 
In Testbed~\textsf{TC} there are in fact only three examples 
compatible with \POPSTARP\ where \TCT~could not find interpretations.
There are additionally four examples compatible with \LMPO\ but not so with interpretations, 
including the TRS  from Example~\ref{ex:RS2}. 
All but one (noteworthy the merge-sort algorithm from Steinbach and K\"uhlers collection 
\cite[Example~2.43]{SK90}) 
of these do in fact admit exponential runtime complexity, 
thus a~priori they are not compatible to the restricted interpretations.


We emphasise that parameter substitution significantly increases the strength of 
\POPSTAR, 13 examples are provable by \POPSTARP\ but neither by \POPSTAR\ nor \LMPO.\@
\LMPO\ could benefit from parameter substitution, 
we conjecture that the resulting order is still sound for . 

In sum on Testbed~\textsf{TCO}, containing only orthogonal TRSs, 
in total 75 systems (26\% of the testbed)
can be verified to encode polytime computable functions, 35 (12\% of the testbed)
can be verified polytime computable by only syntactic techniques. 
It should be noted that not all examples appearing in our collection encode polytime computable 
functions, the total amount of such systems is unknown. 

It seems that Table~\ref{tbl:exp1} clearly shows the weakness of polynomial
path orders (even with parameter substitution) for automated polynomial
runtime complexity. However, remark the average execution times provided.
\POPSTARP\ succeeds on average 14 times faster than polynomial and 
matrix interpretations. Here the difficulty of implementing interpretations efficiently 
is also reflected in the total number of timeouts.
Furthermore note that a competitive complexity
analyser cannot be based on direct techniques alone. 
Instead, our complexity analyser \TCT\ recursively decomposes complexity problems using 
various complexity preserving transformation techniques~\cite{AM13}, 
discarding those problems that can be handled by basic techniques as 
contrasted in Table~\ref{tbl:exp1}.
Certificates are only obtained
if finally all subproblems can be discarded,
above all it is crucial that subproblems can be discarded 
quickly. Due to the efficiency of syntactic methods, these 
can be safely preposed to semantic techniques, thus speeding up the overall procedure.



\section{Conclusion and Future Work}\label{s:conclusion}

This paper is concerned with the complexity analysis of
constructor term rewrite systems and its ramification in implicit
computational complexity.

We have proposed a path order with multiset status, 
the polynomial path order \POPSTAR. 
The order  is a syntactical restriction of multiset path orders, 
with the distinctive feature that the innermost runtime complexity
of compatible TRSs lies in  for some .
Based on , we delineate a class of rewrite systems, dubbed
systems of predicative recursion, 
so that the class of functions computed by these systems
corresponds to , the class of polytime computable functions.
We have shown that an extension of , the order 
that also accounts for parameter substitution, 
increases the intensionality of .

From the viewpoint of implicit computational complexity we
have provided new implicit characterisations of the
class of polytime functions. More precisely, \POPSTAR\ and \POPSTARP\ 
are sound for the class of function problems  and are readily
applicable to obtain exact characterisations of the polytime
computable functions. As an easy corollary, we have given
an alternative proof of Bellantoni's result that the polytime
computable functions are closed under parameter substitution. 

From the viewpoint of (automated) runtime complexity analysis
we have proposed two new syntactic techniques to establish
polynomial innermost runtime complexity. 
In contrast to semantic techniques polynomial path orders 
are partly lacking in intensionality but greatly surpluses
in verification time. Note that in our complexity prover \TCT, we do not intend to replace 
semantic techniques, but rather prepose them by \POPSTARP, in 
order to improve \TCT\ both in analytic power and speed. 

In runtime complexity analysis one is in particular interested 
in obtaining asymptotically tight bounds. 
Although we could estimate the degree of the witnessing
bounding function for \POPSTAR\ and \POPSTARP, 
such a bound would be a gross overestimation.
This is partly due to the underlying multiset extension.

Very recently, together with Eguchi we have proposed a
simplification of the polynomial path orders studied here: 
the \emph{small polynomial path orders} (\emph{\POPSTARS} for short).
This termination order entails a finer control on the runtime
complexity: for any rewrite system compatible with \POPSTARS\
that employs recursion upto depth , the innermost runtime complexity 
is polynomially bounded of degree . This bound is tight,
see~\cite{AEM12}.
This becomes possible, as the underlying scheme of safe composition
is restricted to so-called \emph{weak safe composition}.






\section*{Acknowledgement}

We are in particular thankful to Nao Hirokawa for fruitful discussions.
Furthermore the second author would like to thank Toshiyasu Arai for having
introduced him to the topic of predicative recursion.
Finally, we are indebted to the annonymous reviewers for their constructive criticism.

\bibliographystyle{plainnat}
\begin{thebibliography}{59}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Albert et~al.(2009)Albert, Arenas, Genaim, G{\'o}mez-Zamalloa, Puebla,
  Ram\'{\i}rez, Rom{\'a}n, and Zanardini]{AAGGPRRZ:2009}
E.~Albert, P.~Arenas, S.~Genaim, M.~G{\'o}mez-Zamalloa, G.~Puebla,
  D.~Ram\'{\i}rez, G.~Rom{\'a}n, and D.~Zanardini.
\newblock {Termination and Cost Analysis with COSTA and its User Interfaces}.
\newblock \emph{Electronic Notes in Theoretical Computer Science}, 258\penalty0
  (1):\penalty0 109--121, 2009.

\bibitem[Alias et~al.(2010)Alias, Darte, Feautrier, and Gonnord]{ADFG10}
C.~Alias, A.~Darte, P.~Feautrier, and L.~Gonnord.
\newblock {Multi-dimensional Rankings, Program Termination, and Complexity
  Bounds of Flowchart Programs}.
\newblock In \emph{Proc.\ of \nth{17} SAS}, volume 6337 of \emph{Lecture Notes
  in Computer Science}, pages 117--133, 2010.

\bibitem[Arai and Moser(2004)]{AM04}
T.~Arai and G.~Moser.
\newblock {A Note on a Term Rewriting Characterization of PTIME}.
\newblock In \emph{Proc.\ of \nth{7} WST}, pages 10--13. number AIB-2004-07 of
  Aachener Informatik-Berichte, 2004.
\newblock Extended abstract.

\bibitem[Arai and Moser(2005)]{AM05}
T.~Arai and G.~Moser.
\newblock {Proofs of Termination of Rewrite Systems for Polytime Functions}.
\newblock In \emph{{Proc.\ of \nth{25} FSTTCS}}, volume 3821 of \emph{Lecture
  Notes in Computer Science}, pages 529--540. Springer Verlag, 2005.

\bibitem[Avanzini and Moser(2008)]{AM08}
M.~Avanzini and G.~Moser.
\newblock {Complexity Analysis by Rewriting}.
\newblock In \emph{Proc.\ of \nth{9} FLOPS}, volume 4989 of \emph{Lecture Notes
  in Computer Science}, pages 130--146. Springer Verlag, 2008.

\bibitem[Avanzini and Moser(2009{\natexlab{a}})]{AM09}
M.~Avanzini and G.~Moser.
\newblock {Dependency Pairs and Polynomial Path Orders}.
\newblock In \emph{Proc.\ of \nth{20} RTA}, volume 5595 of \emph{Lecture Notes
  in Computer Science}, pages 48--62. Springer Verlag, 2009{\natexlab{a}}.

\bibitem[Avanzini and Moser(2009{\natexlab{b}})]{AM09b}
M.~Avanzini and G.~Moser.
\newblock {Polynomial Path Orders and the Rules of Predicative Recursion with
  Parameter Substitution}.
\newblock In \emph{Proc.\ of \nth{10} WST}, pages 16--20, 2009{\natexlab{b}}.

\bibitem[Avanzini and Moser(2010{\natexlab{a}})]{AM10}
M.~Avanzini and G.~Moser.
\newblock {Complexity Analysis by Graph Rewriting}.
\newblock In \emph{Proc.\ of \nth{10} FLOPS}, volume 6009 of \emph{Lecture
  Notes in Computer Science}, pages 257--271. Springer Verlag,
  2010{\natexlab{a}}.

\bibitem[Avanzini and Moser(2010{\natexlab{b}})]{AM10b}
M.~Avanzini and G.~Moser.
\newblock {Closing the Gap Between Runtime Complexity and Polytime
  Computability}.
\newblock In \emph{Proc.\ of \nst{21} RTA}, volume~6 of \emph{Leibniz
  International Proceedings in Informatics}, pages 33--48, 2010{\natexlab{b}}.

\bibitem[Avanzini and Moser(2013{\natexlab{a}})]{AM13}
M.~Avanzini and G.~Moser.
\newblock {A Combination Framework for Complexity}.
\newblock In \emph{Proc.\ 24th RTA}, volume~21, pages 55--70. Leibniz
  International Proceedings in Informatics, 2013{\natexlab{a}}.

\bibitem[Avanzini and Moser(2013{\natexlab{b}})]{AM13b}
M.~Avanzini and G.~Moser.
\newblock {Tyrolean Complexity Tool}: {F}eatures and usage.
\newblock In \emph{Proc.\ 24th RTA}, Leibniz International Proceedings in
  Informatics, pages 71--80, 2013{\natexlab{b}}.
\newblock 21.

\bibitem[Avanzini et~al.(2008)Avanzini, Moser, and Schnabl]{AMS08}
M.~Avanzini, G.~Moser, and A.~Schnabl.
\newblock {Automated Implicit Computational Complexity Analysis (System
  Description)}.
\newblock In \emph{Proc.\ of \nth{4} IJCAR}, volume 5195 of \emph{Lecture Notes
  in Computer Science}, pages 132--139. Springer Verlag, 2008.

\bibitem[Avanzini et~al.(2012)Avanzini, Eguchi, and Moser]{AEM12}
M.~Avanzini, N.~Eguchi, and G.~Moser.
\newblock {A New Order-theoretic Characterisation of the Polytime Computable
  Functions}.
\newblock In \emph{Proc.\ of \nth{10} APLAS}, volume 7705 of \emph{Lecture
  Notes in Computer Science}, pages 280--295, 2012.

\bibitem[Baader and Nipkow(1998)]{BN98}
F.~Baader and T.~Nipkow.
\newblock \emph{{Term Rewriting and All That}}.
\newblock Cambridge University Press, 1998.

\bibitem[Baillot et~al.(2009)Baillot, Marion, and Rocca]{BMR09}
P.~Baillot, J.-Y. Marion, and S.~Ronchi~Della Rocca.
\newblock {Guest Editorial: Special Issue on Implicit Computational
  Complexity}.
\newblock \emph{ACM Transactions on Computational Logic}, 10\penalty0 (4),
  2009.

\bibitem[Beckmann and Weiermann(1996)]{BW96}
A.~Beckmann and A.~Weiermann.
\newblock {A Term Rewriting Characterization Of the Polytime Functions and
  Related Complexity Classes}.
\newblock \emph{Archive for Mathematical Logic}, 36:\penalty0 11--30, 1996.

\bibitem[Bellantoni(1992)]{B:92}
S.~Bellantoni.
\newblock \emph{Predicative Recursion and Computational Complexity}.
\newblock PhD thesis, University of Torronto, Faculty for Computer Science,
  1992.

\bibitem[Bellantoni and Cook(1992)]{BC92}
S.~Bellantoni and S.~Cook.
\newblock {A new Recursion-Theoretic Characterization of the Polytime
  Functions}.
\newblock \emph{Computational Complexity}, 2\penalty0 (2):\penalty0 97--110,
  1992.

\bibitem[Boas(1990)]{Boas:TCS:90}
P.~Van~Emde Boas.
\newblock {Machine Models and Simulation}.
\newblock In \emph{Handbook of Theoretical Computer Science, Volume A:
  Algorithms and Complexity (A)}, pages 1--66. The MIT Press, 1990.

\bibitem[Bonfante and Moser(2010)]{BonfanteMoser:2010}
G.~Bonfante and G.~Moser.
\newblock {Characterising Space Complexity Classes via {Knuth-Bendix} Orders}.
\newblock In \emph{Proc.\ of \nth{17} LPAR}, volume 6397 of \emph{Lecture Notes
  in Computer Science}, pages 142--156, 2010.

\bibitem[Bonfante et~al.(2001)Bonfante, Cichon, Marion, and Touzet]{BCMT01}
G.~Bonfante, A.~Cichon, J.-Y. Marion, and H.~Touzet.
\newblock {Algorithms with Polynomial Interpretation Termination Proof}.
\newblock \emph{Journal of Functional Programming}, 11\penalty0 (1):\penalty0
  33--53, 2001.

\bibitem[Bonfante et~al.(2011)Bonfante, Marion, and Moyen]{BMM11}
G.~Bonfante, J.-Y. Marion, and J.-Y. Moyen.
\newblock {Quasi-interpretations: A Way to Control Resources}.
\newblock \emph{Theoretical Computer Science}, 412\penalty0 (25), 2011.

\bibitem[Buchholz(1995)]{B95}
W.~Buchholz.
\newblock {Proof-theoretical Analysis of Termination Proofs}.
\newblock \emph{Annals of Pure and Applied Logic}, 75:\penalty0 57--65, 1995.

\bibitem[Cichon and Weiermann(1997)]{CW97}
E.~A. Cichon and A.~Weiermann.
\newblock {Term Rewriting Theory for the Primitive Recursive Functions}.
\newblock \emph{Annals of Pure and Applied Logic}, 83\penalty0 (3):\penalty0
  199--223, 1997.

\bibitem[{Dal Lago} and Martini(2009{\natexlab{a}})]{LM09}
U.~{Dal Lago} and S.~Martini.
\newblock {On {C}onstructor {R}ewrite {S}ystems and the {L}ambda-{C}alculus}.
\newblock In \emph{Proc.\ of \nth{36} ICALP}, volume 5556 of \emph{Lecture
  Notes in Computer Science}, pages 163--174. Springer Verlag,
  2009{\natexlab{a}}.

\bibitem[{Dal Lago} and Martini(2009{\natexlab{b}})]{LM:2009b}
U.~{Dal Lago} and S.~Martini.
\newblock {Derivational Complexity is an Invariant Cost Model}.
\newblock In \emph{Proc.\ of \nst{1} FOPARA}, 2009{\natexlab{b}}.

\bibitem[E{\'e}n and S{\"o}rensson(2003)]{ES03}
Niklas E{\'e}n and Niklas S{\"o}rensson.
\newblock {An Extensible SAT-solver}.
\newblock In \emph{Proc.\ of \nth{6} SAT}, volume 2919 of \emph{Lecture Notes
  in Computer Science}, pages 502--518. Springer Verlag, 2003.

\bibitem[Ferreira(1995)]{Ferreira95}
M.~C.~F. Ferreira.
\newblock \emph{{Termination of Term Rewriting}}.
\newblock PhD thesis, University of Utrecht, November 1995.
\newblock Well-foundedness, Totality and Transformations.

\bibitem[Gulwani et~al.(2009)Gulwani, Mehra, and Chilimbi]{GMC09}
S.~Gulwani, K.K. Mehra, and T.M. Chilimbi.
\newblock {SPEED: Precise and Efficient Static Estimation of Program
  Computational Complexity}.
\newblock In \emph{Proc.\ of \nth{36} POPL}, pages 127--139. Association for
  Computing Machinery, 2009.

\bibitem[Hirokawa and Moser(2008)]{HM08}
N.~Hirokawa and G.~Moser.
\newblock {Automated Complexity Analysis Based on the Dependency Pair Method}.
\newblock In \emph{Proc.\ of \nth{4} IJCAR}, volume 5195 of \emph{Lecture Notes
  in Artificial Inteligence}, pages 364--380. Springer Verlag, 2008.

\bibitem[Hirokawa and Moser(2011)]{HM11}
N.~Hirokawa and G.~Moser.
\newblock {Automated Complexity Analysis Based on the Dependency Pair Method}.
\newblock \emph{CoRR}, abs/1102.3129, 2011.
\newblock submitted.

\bibitem[Hofbauer(1992)]{H92}
D.~Hofbauer.
\newblock {Termination Proofs by Multiset Path Orderings Imply Primitive
  Recursive Derivation Lengths}.
\newblock \emph{Theoretical Computer Science}, 105:\penalty0 129--140, 1992.

\bibitem[Hofbauer and Lautemann(1989)]{HL89}
D.~Hofbauer and C.~Lautemann.
\newblock {Termination Proofs and the Length of Derivations}.
\newblock In \emph{Proc.\ of \nrd{3} RTA}, volume 355 of \emph{Lecture Notes in
  Computer Science}, pages 167--177. Springer Verlag, 1989.

\bibitem[Hoffmann et~al.(2011)Hoffmann, Aehlig, and Hofmann]{HAH11}
J.~Hoffmann, K.~Aehlig, and M.~Hofmann.
\newblock {Multivariate Amortized Resource Analysis}.
\newblock In \emph{Proc.\ of \nth{38} POPL}, pages 357--370. Association for
  Computing Machinery, 2011.

\bibitem[Hoffmann et~al.(2012)Hoffmann, Aehlig, and Hofmann]{HAH12}
J.~Hoffmann, K.~Aehlig, and M.~Hofmann.
\newblock {Resource Aware ML}.
\newblock In \emph{CAV}, volume 7358 of \emph{Lecture Notes in Computer
  Science}, pages 781--786, 2012.

\bibitem[Hofmann and Rodriguez(2013)]{HR13}
M.~Hofmann and D.~Rodriguez.
\newblock {Automatic Type Inference for Amortised Heap-Space Analysis}.
\newblock In \emph{Proc.\ of \nnd{22} ESOP}, volume 7792 of \emph{Lecture Notes
  in Computer Science}, pages 593--613, 2013.

\bibitem[Knuth(1993)]{K93}
D.~E. Knuth.
\newblock {Johann Faulhaber and Sums of Powers}.
\newblock \emph{MC}, 203:\penalty0 277--294, 1993.

\bibitem[Lago(2011)]{DalLago:2011}
U.~Dal Lago.
\newblock {A Short Introduction to Implicit Computational Complexity}.
\newblock In \emph{Lectures on Logic and Computation - ESSLLI 2010 Copenhagen,
  Denmark, August 2010, ESSLLI 2011, Ljubljana, Slovenia, August 2011, Selected
  Lecture Notes}, volume 7388 of \emph{Lecture Notes in Computer Science},
  pages 89--109, 2011.

\bibitem[Lago et~al.(2010)Lago, Martini, and Zorzi]{DLMZ:10}
U.~Dal Lago, S.~Martini, and M.~Zorzi.
\newblock {General Ramified Recurrence is Sound for Polynomial Time}.
\newblock In \emph{Proc.\ of DICE2010}, volume~23 of \emph{Electronic
  Proceedings in Theoretical Computer Science}, pages 47--62, 2010.

\bibitem[Leivant(1990)]{Leivant:1990}
D.~Leivant.
\newblock Subrecursion and lambda representation over free algebras
  (preliminary summary).
\newblock In \emph{Feasible mathematics (Ithaca, NY, 1989)}, Progr. Comput.
  Sci. Appl. Logic, pages 281--291. Birkhäuser Boston, 1990.

\bibitem[Leivant(1991)]{L91}
D.~Leivant.
\newblock {A Foundational Delineation of Computational Feasiblity}.
\newblock In \emph{Proc.\ of \nth{6} LICS}, pages 2--11. IEEE Computer Society,
  1991.

\bibitem[Leivant(1993)]{Leivant93}
D.~Leivant.
\newblock {Stratified Functional Programs and Computational Complexity}.
\newblock In \emph{Proc.\ of \nth{20} POPL}, pages 325--333. ACM Press, 1993.

\bibitem[Marion(2003)]{M03}
J.-Y. Marion.
\newblock {Analysing the Implicit Complexity of Programs}.
\newblock \emph{Information and Computation}, 183:\penalty0 2--18, 2003.

\bibitem[Marion and P{\'e}choux(2009)]{MP:09}
J.-Y. Marion and R.~P{\'e}choux.
\newblock {Sup-interpretations, a Semantic Method for Static Analysis of
  Program Resources}.
\newblock \emph{ACM Trans. Comput. Log.}, 10\penalty0 (4), 2009.

\bibitem[Middeldorp et~al.(2011)Middeldorp, Moser, Neurauter, Waldmann, and
  Zankl]{MMNWZ11}
A.~Middeldorp, G.~Moser, F.~Neurauter, J.~Waldmann, and H.~Zankl.
\newblock {Joint Spectral Radius Theory for Automated Complexity Analysis of
  Rewrite Systems}.
\newblock In \emph{Proc.\ of \nth{4} CAI}, volume 6472 of \emph{Lecture Notes
  in Computer Science}, pages 1--20. Springer Verlag, 2011.

\bibitem[Moser and Schnabl(2008)]{MS08}
G.~Moser and A.~Schnabl.
\newblock Proving quadratic derivational complexities using context dependent
  interpretations.
\newblock In \emph{Proc.\ of \nth{19} RTA}, volume 5117 of \emph{Lecture Notes
  in Computer Science}, pages 276--290, 2008.

\bibitem[Moser and Weiermann(2003)]{MW03}
G.~Moser and A.~Weiermann.
\newblock Relating derivation lengths with the slow-growing hierarchy directly.
\newblock In \emph{Proc.\ of \nth{14} RTA}, volume 2706 of \emph{Lecture Notes
  in Computer Science}, pages 296--310, 2003.

\bibitem[Noschinski et~al.(2011)Noschinski, Emmes, and Giesl]{NEG11}
L.~Noschinski, F.~Emmes, and J.~Giesl.
\newblock {A Dependency Pair Framework for Innermost Complexity Analysis of
  Term Rewrite Systems}.
\newblock In \emph{Proc.\ of \nrd{23} CADE}, Lecture Notes in Computer Science,
  pages 422--438. Springer Verlag, 2011.

\bibitem[Papadimitriou(1995)]{Papa}
Christos~H. Papadimitriou.
\newblock \emph{{C}omputational {C}omplexity}.
\newblock {A}ddison {W}esley {L}ongman, second edition, 1995.

\bibitem[Plaisted and Greenbaum(1986)]{PG86}
D.~A. Plaisted and S.~Greenbaum.
\newblock {A Structure-Preserving Clause Form Translation}.
\newblock \emph{Journal of Symbolic Computation}, 2\penalty0 (3):\penalty0
  293--304, 1986.

\bibitem[Schneider-Kamp et~al.(2007{\natexlab{a}})Schneider-Kamp, Fuhs,
  Thiemann, Giesl, Annov, Codish, Middeldorp, and Zankl]{SFTGACMZ07}
P.~Schneider-Kamp, C.~Fuhs, R.~Thiemann, J.~Giesl, E.~Annov, M.~Codish,
  A.~Middeldorp, and H.~Zankl.
\newblock Implementing {RPO} and {POLO} {U}sing {SAT}.
\newblock In \emph{DDP}, number 07401 in Leibniz International Proceedings in
  Informatics. Dagstuhl, 2007{\natexlab{a}}.

\bibitem[Schneider-Kamp et~al.(2007{\natexlab{b}})Schneider-Kamp, Thiemann,
  Annov, Codish, and Giesl]{SK07}
P.~Schneider-Kamp, R.~Thiemann, E.~Annov, M.~Codish, and J.~Giesl.
\newblock {Proving Termination Using Recursive Path Orders and SAT Solving}.
\newblock In \emph{Proc.\ of \nth{6} FroCoS}, volume 4720 of \emph{Lecture
  Notes in Computer Science}, pages 267--282. Springer Verlag,
  2007{\natexlab{b}}.

\bibitem[Simmons(1988)]{Simmons:1988}
H.~Simmons.
\newblock {The Realm of Primitive Recursion}.
\newblock \emph{Applied Mathematicas Letters}, 27:\penalty0 177--188, 1988.

\bibitem[Steinbach and K{\"u}hler(1990)]{SK90}
J.~Steinbach and U.~K{\"u}hler.
\newblock {Check your Ordering - Termination Proofs and Open Problems}.
\newblock Technical Report SEKI-Report SR-90-25, University of Kaiserslautern,
  1990.

\bibitem[Tarjan(1985)]{Tarjan:1985}
R.E. Tarjan.
\newblock {Amortized Computational Complexity}.
\newblock \emph{SIAM J.~Alg.\ Disc.\ Meth}, 6\penalty0 (2):\penalty0 306--318,
  1985.

\bibitem[Te{R}e{S}e(2003)]{TeReSe}
Te{R}e{S}e.
\newblock \emph{{Term Rewriting Systems}}, volume~55 of \emph{Cambridge Tracks
  in Theoretical Computer Science}.
\newblock Cambridge University Press, 2003.

\bibitem[Zankl and Korp(2010)]{HZMK10}
H.~Zankl and M.~Korp.
\newblock {Modular Complexity Analysis via Relative Complexity}.
\newblock In \emph{Proc.\ of \nst{21} RTA}, volume~6 of \emph{Leibniz
  International Proceedings in Informatics}, pages 385--400, 2010.

\bibitem[Zankl and Middeldorp(2007)]{ZM07}
H.~Zankl and A.~Middeldorp.
\newblock {Satisfying KBO Constraints}.
\newblock In \emph{Proc.\ of the \nth{18} RTA}, volume 4533 of \emph{Lecture
  Notes in Computer Science}, pages 389--403. Springer Verlag, 2007.

\bibitem[Zuleger et~al.(2011)Zuleger, Gulwani, Sinn, and Veith]{ZulegerGSV11}
F.~Zuleger, S.~Gulwani, M.~Sinn, and H.~Veith.
\newblock {Bound Analysis of Imperative Programs with the Size-Change
  Abstraction}.
\newblock In \emph{Proc.\ of \nth{18} SAS}, volume 6887 of \emph{Lecture Notes
  in Computer Science}, pages 280--297. Springer Verlag, 2011.

\end{thebibliography}
 
\end{document}
