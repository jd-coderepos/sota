
\documentclass{article} \usepackage{iclr2021_conference,times}
\iclrfinalcopy



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}

\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{capt-of}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{xcolor}
\usepackage{makecell} 

\definecolor{navyblue}{rgb}{0.0, 0.0, 0.5}

\title{Accurate Learning of Graph Representations with Graph Multiset Pooling}




\author{Jinheon Baek,\quad Minki Kang\thanks{Equal contribution},\quad Sung Ju Hwang\\
    KAIST, AITRICS, South Korea \\
  \texttt{\{jinheon.baek, zzxc1133, sjhwang82\}@kaist.ac.kr} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}


Graph neural networks have been widely used on modeling graph data, achieving impressive results on node classification and link prediction tasks. Yet, obtaining an accurate representation for a graph further requires a pooling function that maps a set of node representations into a compact form. A simple sum or average over all node representations considers all node features equally without consideration of their task relevance, and any structural dependencies among them. Recently proposed hierarchical graph pooling methods, on the other hand, may yield the same representation for two different graphs that are distinguished by the Weisfeiler-Lehman test, as they suboptimally preserve information from the node features. To tackle these limitations of existing graph pooling methods, we first formulate the graph pooling problem as a multiset encoding problem with auxiliary information about the graph structure, and propose a \emph{Graph Multiset Transformer} (GMT) which is a multi-head attention based global pooling layer that captures the interaction between nodes according to their structural dependencies. We show that GMT satisfies both injectiveness and permutation invariance, such that it is at most as powerful as the Weisfeiler-Lehman graph isomorphism test. Moreover, our methods can be easily extended to the previous node clustering approaches for hierarchical graph pooling. Our experimental results show that GMT significantly outperforms state-of-the-art graph pooling methods on graph classification benchmarks with high memory and time efficiency, and obtains even larger performance gain on graph reconstruction and generation tasks.\footnote{Code is available at https://github.com/JinheonBaek/GMT}

\end{abstract}

\section{Introduction}

Graph neural networks (GNNs)~\citep{GNN/1, GNN/2}, which work with graph structured data, have recently attracted considerable attention, as they can learn expressive representations for various graph-related tasks such as node classification, link prediction, and graph classification. While the majority of the existing works on GNNs focus on the message passing strategies for neighborhood aggregation~\citep{GCN, GraphSAGE}, which aims to encode the nodes in a graph accurately, graph pooling~\citep{SortPool, DiffPool} that maps the set of nodes into a compact representation is crucial in capturing a meaningful structure of an entire graph.

As a simplest approach for graph pooling, we can average or sum all node features in the given graph~\citep{avg/pooling/1, GIN} (Figure~\ref{fig:concept_figure} (B)). However, since such simple aggregation schemes treat all nodes equally without considering their relative importance on the given tasks, they can not generate a meaningful graph representation in a task-specific manner. Their flat architecture designs also restrict their capability toward the hierarchical pooling or graph compression into few nodes. To tackle these limitations, several differentiable pooling operations have been proposed to condense the given graph. There are two dominant approaches to pooling a graph. Node drop methods~\citep{SortPool, SAGPool} (Figure~\ref{fig:concept_figure} (C)) obtain a score of each node using information from graph convolutional layers, and then drop unnecessary nodes with lower scores at each pooling step. Node clustering methods~\citep{DiffPool, MincutPool} (Figure~\ref{fig:concept_figure} (D)), on the other hand, cluster similar nodes into a single node by exploiting their hierarchical structure.

Both graph pooling approaches have obvious drawbacks. First, node drop methods unnecessarily drop some nodes at every pooling step, leading to information loss on those discarded nodes. On the other hand, node clustering methods compute the \emph{dense} cluster assignment matrix with an adjacency matrix. This prevents them from exploiting sparsity in the graph topology, leading to excessively high computational complexity~\citep{SAGPool}. Furthermore, to accurately represent the graph, the GNNs should obtain a representation that is as powerful as the Weisfeiler-Lehman (WL) graph isomorphism test~\citep{WLtest}, such that it can map two different graphs onto two distinct embeddings. While recent message-passing operations satisfy this constraint~\citep{WL/GNN, GIN}, most deep graph pooling works~\citep{DiffPool, SAGPool, TopKPool, MincutPool} overlook graph isomorphism except for a few~\citep{SortPool}.

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.975\linewidth]{images/concept_integration.pdf}
    \vskip -0.125in
    \caption{\small \textbf{Concepts (Left):} Conceptual comparison of graph pooling methods. Grey box indicates the readout layer, which is compatible with our method. Also, green check icon indicates the model that can be as powerful as the WL test. \textbf{(Right):} An illustration of set, multiset, and graph multiset encoding for graph representation.}
    \vskip -0.15in
    \label{fig:concept_figure}
\end{figure*}

To obtain accurate representations of graphs, we need a graph pooling function that is as powerful as the WL test in distinguishing two different graphs. To this end, we first focus on that the graph representation learning can be regarded as a \emph{multiset} encoding problem, which allows for possibly repeating elements, since a graph may have redundant node representations (See Figure~\ref{fig:concept_figure}, right). However, since a graph is more than a multiset due to its structural constraint, we further define the problem as a \emph{graph multiset} encoding, whose goal is to encode two different graphs, given as multisets of node features with auxiliary structural dependencies among them (See Figure~\ref{fig:concept_figure}, right), into two unique embeddings. We tackle this problem by utilizing a graph-structured attention unit. By leveraging this unit as a fundamental building block, we propose the \emph{Graph Multiset Transformer} (GMT), a pooling mechanism that condenses the given graph into the set of representative nodes, and then further encodes relationships between them to enhance the representation power of a graph. We theoretically analyze the connection between our pooling operations and WL test, and further show that our graph multiset pooling function can be easily extended to node clustering methods.

We then experimentally validate the \textbf{graph classification} performance of GMT on 10 benchmark datasets from biochemical and social domains, on which it significantly outperforms existing methods on most of them. However, since graph classification tasks only require discriminative information, to better quantify the amount of information about the graph in condensed nodes after pooling, we further validate it on  \textbf{graph reconstruction} of synthetic and molecule graphs, and also on two \textbf{graph generation} tasks, namely molecule generation and retrosynthesis. Notably, GMT outperforms baselines with even larger performance gap on graph reconstruction, which demonstrates that it learns meaningful information without forgetting original graph structure. Finally, it improves the graph generation performance on two tasks, which shows that GMT can be well coupled with other GNNs for graph representation learning. In sum, our main contributions are summarized as follows:

\begin{itemize}[itemsep=1.0mm, leftmargin=*]
\item We treat a graph pooling problem as a multiset encoding problem, under which we consider relationships among nodes in a set with several attention units, to make a compact representation of an entire graph only with one global function, without additional message-passing operations.
\item We show that existing GNN with our parametric pooling operation can be as powerful as the WL test, and also be easily extended to the node clustering approaches with learnable clusters.
\item We extensively validate GMT for graph classification, reconstruction, and generation tasks on synthetic and real-world graphs, on which it largely outperforms most graph pooling baselines.
\end{itemize}

 \section{Related Work}

\vspace{-0.03in}
\paragraph{Graph Neural Network}
Existing graph neural network (GNN) models generally encode the nodes by aggregating the features from the neighbors~\citep{GCN, GraphSAGE, GAT, PGNN}, and have achieved a large success on node classification and link prediction tasks. Recently, there also exist transformer-based GNNs~\citep{graph/transformer, graph/transformer/2} that further consider the relatedness between nodes in learning the node embeddings. However, accurately representing the given graph as a whole remains challenging. While using mean or max over the node embeddings allow to represent the entire graph for graph classification~\citep{graph/classification/1, graph/classification/2}, they are mostly suboptimal, and may output the same representation for two different graphs. To resolve this problem, recent GNN models~\citep{GIN, WL/GNN} aim to make the GNNs to be as powerful as the Weisfeiler-Lehman test~\citep{WLtest} in distinguishing graph structures. Yet, they also rely on simple operations, and we need a more sophisticated method to represent the entire graph.

\vspace{-0.03in}
\paragraph{Graph Pooling}
Graph pooling methods play an essential role of representing the entire graph. While averaging all node features is directly used as simplest pooling methods~\citep{avg/pooling/1, avg/pooling/2}, they result in a loss of information since they consider all node information equally without considering key features for graphs. To overcome this limitation, there have been recent studies on graph pooling to compress the given graph in a task specific manner. Node drop methods use learnable scoring functions to drop nodes with lower scores~\citep{SortPool, TopKPool, SAGPool}. Moreover, node clustering methods cast the graph pooling problem into the node clustering problem to map the nodes into a set of clusters~\citep{DiffPool, EigenPool, HaarPool, MincutPool, StructPool}. Some methods combine these two approaches by first locally clustering the neighboring nodes, and then dropping unimportant clusters~\citep{ASAP}. Meanwhile, edge clustering gradually merges nodes by contracting high-scoring edges between them~\citep{edgepool}. In addition, \cite{Memory/GNN} model the memory layer to aggregate nodes without utilizing message-passing after pooling. Finally, there exists a semi-supervised pooling method~\citep{semi-hi/classification} that scores nodes with an attention scheme~\citep{attention/not/attention}, to weight more on the important nodes on pooling.

\vspace{-0.03in}
\paragraph{(Multi-)Set Representation Learning}
Note that a set of nodes in a graph forms a multiset~\citep{GIN}; a set that allows possibly repeating elements. Therefore, contrary to the previous set-encoding methods, which mainly consider non-graph problems~\citep{Set/3D/2, Set/pointcloud/2, Set/fewshot/2}, we regard the graph representation learning as a multi-set encoding problem. Mathematically, \cite{deepsets, deepsets/max} provide the theoretical grounds on permutation invariant functions for the set encoding. Further, \cite{SetTransformer} propose Set Transformer, which uses attention mechanism on the set encoding. Building on top of these theoretical grounds on set, we propose the multiset encoding function that explicitly considers the graph structures.
 \section{Graph Multiset Pooling}
We posit the graph representation learning problem as a multiset encoding problem, and then utilize the graph-structured attention to consider the global graph structure when encoding the given graph.

\subsection{Preliminaries}
We begin with the general descriptions of graph neural network, and graph pooling.

\paragraph{Graph Neural Network}
A graph  can be represented by its adjacency matrix  and the node set  with  nodes, along with the  dimensional node features . Graph Neural Networks (GNNs) learn feature representation for different nodes using neighborhood aggregation schemes, which are formalized as the following \textbf{Message-Passing} function:

where  is the node features computed after -steps of the GNN simplified as follows: ,  and  are arbitrary differentiable functions,  denotes a set of neighboring nodes of , and  is initialized as the input node features .

\paragraph{Graph Pooling}
While message-passing functions can produce a set of node representations, we need an additional  function to obtain an entire graph representation  as follows:

As a  function, we can simply use the average or sum over all node features  from the given graph~\citep{avg/pooling/1, GIN}. However, since such aggregation schemes take all node information equally without considering the graph structures, they lose structural information that is necessary for accurately representing a graph. To tackle this limitation, \textbf{Node Drop} methods~\citep{TopKPool, SAGPool} select the high scored nodes  with learnable score function  at layer , to drop the unnecessary nodes, denoted as follows:

where function  depends on specific implementations, and  function samples the top k nodes by dropping nodes with low scores . Whereas \textbf{Node Clustering} methods~\citep{DiffPool, MincutPool} learn a cluster assignment matrix  with node features , to coarsen the nodes and the adjacency matrix  at layer  as follows:

where generating an assignment matrix  depends on specific implementations. While these two approaches obtain decent performances on graph classification tasks, they are suboptimal since node drop methods unnecessarily drop arbitrary nodes, and node clustering methods have limited scalability to large graphs~\citep{GNN/sparse/pooling:Readout, SAGPool}. Therefore, we need a sophisticated graph pooling layer that coarsens the graph with sparse implementation without discarding nodes.

\subsection{Graph Multiset Transformer}
We now describe the \emph{Graph Multiset Transformer} (GMT) architecture, which can accurately represent the entire graph, given a multiset of node features. We first introduce a multiset encoding scheme that allows to embed two different graphs into distinct embeddings, and then describe the graph multi-head attention that reflects the graph topology in the attention-based multiset encoding.

\paragraph{Multiset Encoding}
The input of the graph pooling function  consists of nodes in a graph, and they form a multiset (i.e. a set that allows for repeating elements) since different nodes can have identical feature vectors. To design a graph pooling function that is as powerful as the WL test, it needs to satisfy the permutation invariance and injectiveness over the multiset, since two non-isomorphic graphs should be embedded differently through the injective function. While the simple sum pooling satisfies the injectiveness over a multiset~\citep{GIN}, it may treat all node embeddings equally without consideration of their relevance to the task. To resolve this issue, we consider attention mechanism on the multiset pooling function to capture structural dependencies among nodes within a graph, in which we can provably enjoy the expressive power of the WL test.

\paragraph{Graph Multi-head Attention}
To overcome the inability of simple pooling methods (e.g. sum) on distinguishing important nodes, we use the attention mechanism as the main component in our pooling scheme. Assume that we have  node vectors, and the input of the \emph{attention function} (Att) consists of query , key  and value , where  is the number of query vectors,  is the number of input nodes,  is the dimensionlity of the key vector, and  is the dimensionality of the value vector. Then we compute the dot product of the query with all keys, to put more weights on the relevant values, namely nodes, as follows:  where  is an activation function. Instead of computing a single attention, we can further use a multi-head attention~\citep{Transformer}, by linearly projecting the query , key , and value   times respectively to yield  different representation subspaces. The output of the \emph{multi-head attention function} (MH) then can be denoted as follows:

where the operations for  parallel projections are parameter matrices , , and . Also, the output projection matrix is , where  is the output dimensionality for the multi-head attention (MH) function. 

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.975\linewidth]{images/architectures_refac.pdf}
    \vskip -0.125in
    \caption{\small \textbf{Graph Multiset Transformer.}
    Given a graph passed through several message passing layers, we use an attention-based pooling block (GMPool) and a self-attention block (SelfAtt) to compress the nodes into few important nodes and consider the interaction among them respectively, within a multiset framework.}
    \vskip -0.125in
    \label{fig:architecture}
\end{figure*}

While multi-head attention is superior to trivial pooling methods such as sum or mean as it considers global dependencies among nodes, the  function suboptimally generates the key  and value  for Att, since it linearly projects the obtained node embeddings  from equation~\ref{messsage-passing} to further obtain the key and value pairs. To tackle this limitation, we newly define a novel \emph{graph multi-head attention block} (GMH). Formally, given node features  with their adjacency information , we construct the key and value using GNNs, to explicitly leverage the graph structure as follows:


\paragraph{Graph Multiset Pooling with Graph Multi-head Attention}
Using the ingredients above, we now propose a graph pooling function that satisfies the injectiveness and permutation invariance, such that the overall architecture can be at most as powerful as the WL test, while taking the graph structure into account. Given node features  from GNNs, we define a \emph{Graph Multiset Pooling} (GMPool), which is inspired by the Transformer~\citep{Transformer, SetTransformer}, to compress the  nodes into the  typical nodes, with a parameterized seed matrix  for the pooling operation that is directly optimized in an end-to-end fashion, as follows (Figure~\ref{fig:architecture}-GMPool):

where  is any row-wise feedforward layer that processes each individual row independently and identically, and  is a layer normalization~\citep{LayerNormalization}. Note that the output of the GMPool is a set of  vectors, such that we can condense the all nodes into the set of  nodes. Also, since we should obtain the one feature vector to represent each graph, we set  in the final layer of our overall pooling architectures. Intuitively, feature aggregation using attention is beneficial in the extreme case  because the influence of each instance on the target task is not necessarily equal. 

\paragraph{Self-Attention for Inter-node Relationship}
While previously described GMPool condenses the set of entire nodes into  representative nodes, a major drawback of this scheme is that it does not consider the relationships between nodes in the given set, which limits its ability to accurately represent the graph structure. To tackle this limitation, one should further consider the interactions among  or condensed  different nodes. To this end, we propose a \emph{Self-Attention function} (SelfAtt), inspired by the Transformer~\citep{Transformer, SetTransformer}, as follows (Figure~\ref{fig:architecture}-SelfAtt):


\paragraph{Overall Architecture}
We now describe the full structure of \emph{Graph Multiset Transformer} (GMT) consisting of GNN and pooling layers using ingredients above (See Figure~\ref{fig:architecture}). For a graph  with node features  and an adjacency matrix , the  is denoted as follows:

where we can stack several GNNs to construct the deep structures. After obtaining a set of node features  from an encoder, the pooling layer aggregates the features into a single vector form; Pooling . To deal with a large number of nodes, we first condense the entire graph into  representative nodes with \emph{Graph Multiset Pooling} (GMPool), which is also adaptable to the varying size of nodes, and then utilize the interaction among them with \emph{Self-Attention Block} (SelfAtt). Finally, we get the entire graph representation by using GMPool with  as follows:

where  is the identity or coarsened adjacency matrix since adjacency information should be adjusted after compressing the nodes from  to  with  (See Appendix~\ref{appendix/model/detail} for detail).

\subsection{Connection with Weisfeiler-Lehman Graph Isomorphism Test}
Weisfeiler-Lehman (WL) test~\citep{WLtest} is known for its ability to efficiently distinguish two different graphs. Recent studies~\citep{WL/GNN, GIN} show that GNNs can be made to be as powerful as the WL test, by using an injective function over a multiset to map two different graphs into distinct spaces. Building on previous powerful GNNs, if our graph pooling function is injective, then our overall architecture can be at most as powerful as the WL test. To do so, we first recount the theorem from~\cite{GIN}, as formalized in Theorem 1.

\textbf{Theorem 1 (Non-isomorphic Graphs to Different Embeddings).} \emph{Let  be a GNN, and Weisfeiler-Lehman test decides two graphs  and  as non-isomorphic. Then,  maps two different graphs  and  to distinct vectors if node aggregation and update functions are injective, and graph-level readout, which operates on a multiset of node features , is injective.}

Since we focus on the representation of graphs through pooling, we deal with the injectiveness of the  function. Our next Lemma 2 states that  can represent the injective function. 

\textbf{Lemma 2 (Uniqueness on Graph Multiset Pooling).} \emph{Assume the input feature space  is a countable set. Then the output of the  with  for a seed vector  can be unique for each multiset  of bounded size. Further, the output of the full  constructs a multiset with k elements, which are also unique on the input multiset .}

\textbf{All proofs regarding the WL test are provided in Appendix~\ref{appendix/wlproof}}. Moreover, our next Proposition 3 states that the sequence of GMPool and SelfAtt with proper GNN is as powerful as the WL test.

\textbf{Proposition 3 (Injectiveness on Pooling Function).} 
\emph{The overall Graph Multiset Transformer with multiple GMPool and SelfAtt can map two different graphs  and  to distinct embedding spaces, such that the resulting GNN with proposed pooling functions can be as powerful as the WL test.}

\subsection{Connection with Node Clustering Approaches \label{paragraph/node/clustering}}
Node clustering is widely used for coarsening a graph in a hierarchical manner, as described in the equation~\ref{node/clustering}. However, since they require to store and even multiply the adjacency matrix  with the soft assignment matrix : , they need a quadratic space  for  nodes, which is problematic for large graphs. Meanwhile, our GMPool does not compute a coarsened adjacency matrix , such that graph pooling is possible only with a sparse implementation, as formalized in Theorem 4. \textbf{All proofs regarding node clustering are provided in Appendix~\ref{appendix/clusterproof}}.

\textbf{Theorem 4 (Space Complexity of Graph Multiset Pooling).} \emph{Graph Multiset Pooling condsense a graph with  nodes to  nodes in  space complexity, which can be further optimized to .}

In spite of this huge strength on space complexity, our GMPool can be further approximated to the node clustering methods by manipulating an adjacency matrix, as formalized in Proposition 5.

\textbf{Proposition 5 (Approximation to Node Clustering).} \emph{Graph Multiset Pooling  can perform hierarchical node clustering with learnable  cluster centroids by Seed Vector  in equation~\ref{GMPool}.}

Note that, contrary to previous node clusterings~\citep{DiffPool, MincutPool}, GMPool learns data dependent  cluster centroids that might be more meaningful to capture graph structures.
 \section{Experiment}
To validate the proposed \emph{Graph Multiset Transformer} (GMT) for graph representation learning, we evaluate it on classification, reconstruction and generation tasks of synthetic and real-world graphs.

\subsection{Graph Classification}
\paragraph{Objective}
The goal of graph classification is to predict a label  of a given graph , with a mapping function . To this end, we use a set of node representations  to obtain an entire graph representation  that is used to classify a label . We then learn  with a cross-entropy loss, to minimize the negative log likelihood as follows: .

\paragraph{Datasets} 
Among TU datasets~\citep{classification/datasets}, we select 6 datasets including 3 datasets (D\&D, PROTEINS, and MUTAG) on Biochemical domain, and 3 datasets (IMDB-B, IMDB-M, and COLLAB) on Social domain with accuracy for evaluation metric. Also, we use 4 molecule datasets (HIV, Tox21, ToxCast, BBBP) from the OGB datasets~\citep{OGB} with ROC-AUC for evaluation metric. Statistics are reported in the Table~\ref{table:results:chemical}, and more details are described in the Appendix~\ref{appendix/classification/data}.

\vspace{-0.03in}
\paragraph{Models}
\textbf{1) GCN. 2) GIN.} GNNs with mean or sum pooling~\citep{GCN, GIN}. \textbf{3) Set2Set.} Set pooling baseline~\citep{Set2Set}. \textbf{4) SortPool. 5) SAGPool. 6) TopKPool. 7) ASAP.} The methods~\citep{SortPool, SAGPool, TopKPool, ASAP} that use the node drop, by dropping nodes (or clusters) with lower scores using scoring functions. \textbf{8) DiffPool. 9) MinCutPool. 10) HaarPool. 11) StructPool.} The methods~\citep{DiffPool, MincutPool, HaarPool, StructPool} that use the node clustering, by grouping a set of nodes into a set of clusters using a cluster assignment matrix. \textbf{12) EdgePool.} The method~\citep{edgepool} that gradually merges two adjacent nodes that have a high score edge. \textbf{13) GMT.} The proposed Graph Multiset Transformer (See Appendix~\ref{appendix/classification/model} for detailed descriptions).

\vspace{-0.03in}
\paragraph{Implementation Details}
For a fair comparison of pooling baselines~\citep{SAGPool}, we fix the GCN~\citep{GCN} as a message passing layer. We evaluate the model performance on TU datasets for 10-fold cross validation~\citep{SortPool, GIN} with LIBSVM~\citep{LIBSVM}. Also, we use the initial node features following the fair comparison setup~\citep{fair/GNN}. We evaluate the performance on OGB datasets with their original feature extraction and data split settings~\citep{OGB}. Experimental details are described in the Appendix~\ref{appendix/classification/implementation}.


\begin{table*}[t]
\caption{\small \textbf{Graph classification results} on test sets. The reported results are mean and standard deviation over 10 different runs. Best performance and its comparable results () from the t-test are marked in bold. Hyphen (-) denotes out-of-resources that take more than 10 days (See Figure~\ref{time} for the time efficiency analysis).}
\centering
\resizebox{\textwidth}{!}{
\renewcommand{\arraystretch}{1.0}
\renewcommand{\tabcolsep}{1.0mm}
\begin{tabular}{lccccccccccc}
\toprule
                & \multicolumn{7}{c}{\textbf{Biochemical Domain}} & \multicolumn{3}{c}{\textbf{Social Domain}} & \multirow{2}{*}{\textbf{Significance}} \\
                \cmidrule(l{2pt}r{2pt}){2-8} \cmidrule(l{2pt}r{2pt}){9-11}
    & \textbf{D\&D} & \textbf{PROTEINS} & \textbf{MUTAG} & \textbf{HIV} & \textbf{Tox21} & \textbf{ToxCast} & \textbf{BBBP} & \textbf{IMDB-B} & \textbf{IMDB-M} & \textbf{COLLAB} \\ 
\midrule
\# graphs       & 1,178     & 1,113     & 188       & 41,127    & 7,831     & 8,576     & 2,039     & 1,000     & 1,500     & 5,000     & -\\
\# classes      & 2         & 2         & 2         & 2         & 12        & 617       & 2         & 2         & 3         & 3         & -\\ 
Avg \# nodes    & 284.32    & 39.06     & 17.93     & 25.51     & 18.57     & 18.78     & 24.06     & 19.77     & 13.00     & 74.49     & -\\
\midrule
GCN         & 72.05  0.55 & 73.24  0.73 & 69.50  1.78 & \textbf{76.81}  1.01 & 75.04  0.80 & 60.63  0.51 & 65.47  1.73 & \textbf{73.26}  0.46 & 50.39  0.41 & \textbf{80.59}  0.27 & 3 / 10 \\
GIN         & 70.79  1.17 & 71.46  1.66 & 81.39  1.53 & 75.95  1.35 & 73.27  0.84 & 60.83  0.46 & \textbf{67.65}  3.00 & \textbf{72.78}  0.86 & 48.13  1.36 & 78.19  0.63 & 2 / 10 \\
\midrule
Set2Set    & 71.94  0.56 & 73.27  0.85 & 69.89  1.94 & 74.70  1.65 & 74.10  1.13 & 59.70  1.04 & 66.79  1.05 & \textbf{72.90}  0.75 & 50.19  0.39 & 79.55  0.39 & 1 / 10 \\
SortPool   & 75.58  0.72 & 73.17  0.88 & 71.94  3.55 & 71.82  1.63 & 69.54  0.75 & 58.69  1.71 & 65.98  1.70 & 72.12  1.12 & 48.18  0.83 & 77.87  0.47 & 0 / 10 \\
DiffPool   & 77.56  0.41 & 73.03  1.00 & 79.22  1.02 & 75.64  1.86 & 74.88  0.81 & 62.28  0.56 & \textbf{68.25}  0.96 & \textbf{73.14}  0.70 & \textbf{51.31}  0.72 & 78.68  0.43 & 3 / 10 \\
SAGPool(G) & 71.54  0.91 & 72.02  1.08 & 76.78  2.12 & 74.56  1.69 & 71.10  1.06 & 59.88  0.79 & 65.16  1.93 & 72.16  0.88 & 49.47  0.56 & 78.85  0.56 & 0 / 10 \\
SAGPool(H) & 74.72  0.82 & 71.56  1.49 & 73.67  4.28 & 71.44  1.67 & 69.81  1.75 & 58.91  0.80 & 63.94  2.59 & \textbf{72.55}  1.28 & 50.23  0.44 & 78.03  0.31 & 1 / 10 \\
TopKPool   & 73.63  0.55 & 70.48  1.01 & 67.61  3.36 & 72.27  0.91 & 69.39  2.02 & 58.42  0.91 & 65.19  2.30 & 71.58  0.95 & 48.59  0.72 & 77.58  0.85 & 0 / 10 \\
MinCutPool & \textbf{78.22}  0.54 & \textbf{74.72}  0.48 & 79.17  1.64 & 75.37  2.05 & 75.11  0.69 & 62.48  1.33 & 65.97  1.13 & 72.65  0.75 & \textbf{51.04}  0.70 & \textbf{80.87}  0.34 & 4 / 10 \\
StructPool & \textbf{78.45}  0.40 & \textbf{75.16}  0.86 & 79.50  1.75 & 75.85  1.81 & 75.43  0.79 & 62.17  1.61 & \textbf{67.01}  2.65 & 72.06  0.64 & 50.23   0.53 & 77.27  0.51 &   3 / 10 \\
ASAP       & 76.58  1.04 & 73.92  0.63 & 77.83 1.49 & 72.86  1.40 & 72.24  1.66 & 58.09  1.62 & 63.50  2.47 & 72.81  0.50 & \textbf{50.78}   0.75 & 78.64  0.50 &  1 / 10 \\
EdgePool   & 75.85  0.58 & \textbf{75.12}  0.76 & 74.17 1.82 & 72.66  1.70 & 73.77  0.68 & 60.70  0.92 & \textbf{67.18}  1.97 & 72.46  0.74 & \textbf{50.79}   0.59 &         -        &  3  / 9 \\
HaarPool   &         -        & - & 66.11 1.50 &         -        &         -        &         -        & 66.11  0.82 & \textbf{73.29}  0.34 & 49.98   0.57 &         -        &   1 / 5 \\
\midrule
GMT (Ours) & \textbf{78.72}  0.59 & \textbf{75.09}  0.59 & \textbf{83.44}  1.33 & \textbf{77.56}  1.25 & \textbf{77.30}  0.59 & \textbf{65.44}  0.58 & \textbf{68.31}  1.62 & \textbf{73.48}  0.76 & \textbf{50.66}  0.82 & \textbf{80.74}  0.54 & \bf 10 / 10 \\
\bottomrule
\end{tabular}
}
\vspace{-0.12in}
\label{table:results:chemical}
\end{table*} \begin{figure}[!t]
    \begin{minipage}{0.35\linewidth}
        \centering
        \resizebox{1\textwidth}{!}{
        \renewcommand{\tabcolsep}{0.9mm}
        \renewcommand{\arraystretch}{1.25}
        \begin{tabular}{lcccccc}
        \toprule
        {\bf Model} & \textbf{D\&D} & {\bf PROTEINS} & \textbf{BBBP} \\
        \midrule
        GMT     & \textbf{78.72} & \bf 75.09 & \bf 68.31\\
        \midrule
        w/o message passing & 78.06 & \underline{75.07} & 65.26 \\
        \midrule
        w/o graph attention & \underline{78.08} & 74.50 & \underline{66.21}\\
        w/o self-attention & 75.13 & 74.22 & 64.53\\
        mean pooling & 72.05 & 73.24 & 65.47\\
        \bottomrule
        \end{tabular}
        }
        \vskip -0.08in
        \captionof{table}{\small Ablation Study of GMT on the D\&D, PROTEINS, and BBBP datasets for graph classification.}
        \label{ablation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
        \centerline{\includegraphics[width=1\linewidth]{images/memory.pdf}}
        \vskip -0.17in
        \caption{\small Memory efficiency of GMT compared with baselines. X indicates out-of-memory error.}
        \label{memory}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
        \centerline{\includegraphics[width=1\linewidth]{images/time_new.pdf}}
        \vskip -0.17in
        \caption{\small Time efficiency of GMT compared with baselines. X indicates out-of-memory error.}
        \label{time}
    \end{minipage}
    \vskip -0.175in
\end{figure}

 
\vspace{-0.03in}
\paragraph{Classification Results}
Table~\ref{table:results:chemical} shows that our GMT outperforms most baselines, or achieves comparable performance to the best baseline results. These results demonstrate that our method is simple yet powerful as it only performs a single global operation at the final layer, unlike several baselines that use multiple pooling with a sequence of message passing (See Figure~\ref{fig:appendix/layers} for the detailed model architectures). Note that, since graph classification tasks mostly require the discriminative information to predict the labels of a graph, GNN baselines without parametric pooling, such as GCN and GIN, sometimes outperform pooling baselines on some datasets. In addition, recent work~\citep{rethinking/pooling}, which reveals that message-passing layers are dominant in the graph classification, supports this phenomenon. Therefore, we conduct experiments on graph reconstruction to directly quantify the amount of retained information after pooling, which we describe in the next subsection.

\paragraph{Ablation Study} To see where the performance improvement comes from, we conduct an ablation study on GMT by removing graph attention, self attention, and message-passing operations. Table~\ref{ablation} shows that using graph attention with self-attention helps significantly improve the performances from the mean pooling. Further, performances of the GMT without message-passing layers indicate that our pooling layer well captures the graph multiset structure only with pooling without GNNs. 


\vspace{-0.05in}
\paragraph{Efficiency} While node clustering methods achieve decent performances in Table~\ref{table:results:chemical}, they are known to suffer from large memory usage since they cannot work with sparse graph implementations. To compare the GPU \textbf{Memory Efficiency} of GMT with baseline models, we test it on the Erdos-Renyi graphs~\citep{randomgraph} (See Appendix~\ref{appendix/classification/efficiency} for detail setup). Figure~\ref{memory} shows that our GMT is highly efficient in terms of memory thanks to its compatibility with sparse graphs, making it more practical over memory-heavy pooling baselines. 
In addition to this, we measure the \textbf{Time Efficiency} to further validate the practicality of GMT in terms of time complexity. We validate it with the same Erdos-Renyi graphs (See Appendix~\ref{appendix/classification/efficiency} for detail setup). Figure~\ref{time} shows that GMT takes less than (or nearly about) a second even for large graphs, compared to the slowly working models such as HaarPool and EdgePool. This result further confirms that our GMT is practically efficient.

\subsection{Graph Reconstruction \label{experiment/recon}}
Graph classification does not directly measure the expressiveness of GNNs since identifying discriminative features may be more important than accurately representing graphs. Meanwhile, graph reconstruction directly quantifies the graph information retained by condensed nodes after pooling.

\vspace{-0.05in}
\paragraph{Objective} 
For graph reconstruction, we train an autoencoder to reconstruct the input node features  from their pooled representations . The learning objective to minimize the discrepancy between the original graph  and the reconstructed graph  with a cluster assignment matrix  is denoted as follows:


\vspace{-0.05in}
\paragraph{Experimental Setup} 
We first experiment with \textbf{Synthetic Graph}, such as ring and grid~\citep{MincutPool}, that can be represented in a 2-D Euclidean space, where the goal is to restore the location of each node from pooled features, with an adjacency matrix. We further experiment with real-world \textbf{Molecule Graph}, namely ZINC datasets~\citep{ZINC}, which consists of 12K molecular graphs. See Appendix~\ref{appendix/reconstruction/experimentaldetail} for the experimental details including model descriptions.

\begin{figure}[!t]
    \begin{minipage}{0.46\linewidth}
        \centerline{\includegraphics[width=1\linewidth]{images/graph_reconstruction.pdf}}
        \vskip -0.16in
        \caption{\small Reconstruction results of ring and grid synthetic graphs, compared to node drop and clustering methods. See Figure~\ref{fig:appendix/synthetic} for high resolution.}
        \label{recon:synthetic}
    \end{minipage}
    \hfill
    \begin{minipage}{0.52\linewidth}
        \centerline{\includegraphics[width=1\linewidth]{images/zinc_results.pdf}}
        \vskip -0.125in
        \caption{\small Reconstruction results on the ZINC molecule dataset by varying the compression ratio. Solid lines denote the mean, and shaded areas denote the variance.}
        \label{recon:ZINC}
    \end{minipage}
    \vskip -0.15in
\end{figure}

 
\begin{wrapfigure}{t}{0.35\textwidth}
 \centering
  \vspace{-0.17in}
  \includegraphics[width=0.35\textwidth]{images/molecule_reconstruction.pdf}
  \vspace{-0.275in}
  \caption{\small Reconstruction example with assigned clusters as colors on left and reconstructed molecules on right.}
  \vspace{-0.2in}
  \label{recon:ZINC:sample}
\end{wrapfigure}

\vspace{-0.05in}
\paragraph{Reconstruction Results}
Figure~\ref{recon:synthetic} shows the original and the reconstructed graphs for \textbf{Synthetic Graph} of ring and grid structures. The noisy results of baselines indicate that the condensed node features do not fully capture the original graph structure. Whereas our GMPool yields almost perfect reconstruction, which demonstrates that our pooling operation learns meaningful representation without discarding the original graph information. We further validate the reconstruction performance of the proposed GMPool on the real-world \textbf{Molecule Graph}, namely ZINC, by varying the compression ratio. Figure~\ref{recon:ZINC} shows reconstruction results on the molecule graph, on which GMPool largely outperforms all compared baselines in terms of validity, exact match, and accuracy (High score indicates the better, and see Appendix~\ref{appendix/reconstruction/experimentaldetail} for the detailed description of evaluation metrics). With given results, we demonstrate that our GMPool can be easily extended to the node clustering schemes, while it is powerful enough to encode meaningful information to reconstruct the graph. 

\vspace{-0.05in}
\paragraph{Qualitative Analysis} 
We visualize the reconstruction examples from ZINC in Figure~\ref{recon:ZINC:sample}, where colors in the left figure indicate the assigned clusters on each atoms, and red dashed circles indicate the incorrectly predicted atoms on the reconstructed molecule. As shown in Figure~\ref{recon:ZINC:sample}, GMPool yields more calibrated clustering than MinCutPool, capturing the detailed substructures, which results in the successful reconstruction (See Figure~\ref{fig:appendix/zinc} in Appendix D for more reconstruction examples).

\subsection{Graph Generation \label{experiment/generation}}

\paragraph{Objective} Graph generation is used to generate a valid graph that satisfies the desired properties, in which graph encoding is used to improve the generation performances. Formally, given a graph  with graph encoding function , the goal here is to generate a valid graph  of desired property  with graph decoding function  as follows:

 is a distance metric between the generated graph and desired properties, to guarantee that the graph has them.

\vspace{-0.075in}
\paragraph{Experimental Setup}
To evaluate the applicability of our model, we experiment on \textbf{Molecule Generation} to stably generate the valid molecules with MolGAN~\citep{MolGAN}, and \textbf{Retrosynthesis} to empower the synthesis performances with Graph Logic Network (GLN)~\citep{GLN}, by replacing their graph embedding function  to ours. In both experiments, we replace the average pooling to either the MinCutPool or GMT. See Appendix~\ref{appendix/generation/experimentaldetail} for more experimental details.

\begin{figure}[t!]
    \begin{minipage}{0.46\linewidth}
        \centering
        \centerline{\includegraphics[width=1\linewidth]{images/molgan_result.pdf}}
        \vskip -0.15in
        \captionof{figure}{\small Validity curve for molecule generation on QM9 dataset from MolGAN. Solid lines denote the mean and shaded areas denote the variance.}
        \label{gen:molgan}
    \end{minipage}
    \hfill
    \begin{minipage}{0.51\linewidth}
        \centering
        \resizebox{1.0\textwidth}{!}{
        \renewcommand{\tabcolsep}{1mm}
        \renewcommand{\arraystretch}{1.0}
            \begin{tabular}{clcccccc}
            \toprule
            \multicolumn{2}{c}{Top-\textit{k} accuracy:} & {1} & {3} & {5} & {10} & {20} & {50} \\
            \midrule
Reaction          & GLN        & 51.41 & 67.55 & 74.92 & 83.48 & 88.64 & 92.37 \\
            Class             & MinCutPool & 51.17 & 67.47 & \bf 75.59 & \bf 83.68 & 89.31 & 92.31 \\
            Unknown           & GMT (Ours) & \bf 51.83 & \bf 68.20 & 75.17 & 83.20 & \bf 89.33 & \bf 92.47 \\
            \midrule
Reaction          & GLN        & 63.53 & 78.27 & 84.32 & 89.51 & 92.17 & 93.17 \\
            Class             & MinCutPool & 63.91 & 79.19 & 84.76 & 89.69 & 92.13 & 93.23 \\
            as Prior          & GMT (Ours) & \bf 64.17 & \bf 79.61 & \bf 85.32 & \bf 89.97 & \bf 92.31 & \bf 93.25 \\
            \bottomrule
            \end{tabular}
        }
        \vskip -0.05in
        \captionof{table}{\small Top-k accuracy for Retrosynthesis experiment on USPTO-50k data, for cases where the reaction class is given as prior information (Bottom) and not given (Top).}
        \label{gen:gln}
    \end{minipage}
    \vskip -0.15in
\end{figure}

 
\vspace{-0.075in}
\paragraph{Generation Results}
The power of a discriminator distinguishing whether a molecule is real or fake is highly important to create a valid molecule in MolGAN. Figure~\ref{gen:molgan} shows the validity curve on the early stage of MolGAN training for \textbf{Molecule Generation}, and the representation power of GMT significantly leads to the stabilized generation of valid molecules than baselines. Further, Table~\ref{gen:gln} shows \textbf{Retrosynthesis} results, where we use the GLN as a backbone architecture. Similar to the molecule generation, retrosynthesis with GMT further improves the performances, which suggests that GMT can replace existing pooling methods for improved performances on diverse graph tasks.
 \vspace{-0.15in}
\section{Conclusion}
\vspace{-0.075in}
In this work, we pointed out that existing graph pooling approaches either do not consider the task relevance of each node (sum or mean) or may not satisfy the injectiveness (node drop and clustering methods). To overcome such limitations, we proposed a novel graph pooling method, \emph{Graph Multiset Transformer} (GMT), which not only encodes the given set of node embeddings as a multiset to uniquely embed two different graphs into two distinct embeddings, but also considers both the global structure of the graph and their task relevance in compressing the node features. We theoretically justified that the proposed pooling function is as powerful as the WL test, and can be extended to the node clustering schemes. We validated the proposed GMT on 10 graph classification datasets, and our method outperformed state-of-the-art graph pooling models on most of them. We further showed that our method is superior to the existing graph pooling approaches on graph reconstruction and generation tasks, which require more accurate representations of the graph than classification tasks. We strongly believe that the proposed pooling method will bring substantial practical impact, as it is generally applicable to many graph-learning tasks that are becoming increasingly important. 

\subsubsection*{Acknowledgments}
\vspace{-0.05in}
This work was supported by Institute of Information \& communications Technology Planning \& Evaluation (IITP) grant funded by the Korea government (MSIT) (No.2019-0-00075, Artificial Intelligence Graduate School Program (KAIST)), and the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (NRF-2018R1A5A1059921).
 
\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\newpage
\newpage

\appendix

\section{Proofs}

\subsection{Proofs regarding Weisfeiler-Lehman Test \label{appendix/wlproof}}
We first recount the theorem of~\citet{GIN} to define a GNN that is injective over a multiset (Theorem 1). We then prove that the proposed \emph{Graph Multiset Pooling} (GMPool) can map two different graphs to distinct spaces (Lemma 2). Finally, we show that our overall architecture \emph{Graph Multiset Transformer} (GMT) with a sequence of proposed \emph{Graph Multiset Pooling} (GMPool) and \emph{Self-Attention} (SelfAtt) can represent the injective function over the input multiset (Proposition 3).

\textbf{Theorem 1 (Non-isomorphic Graphs to Different Embeddings).} \emph{Let  be a GNN, and Weisfeiler-Lehman test decides two graphs  and  as non-isomorphic. Then,  maps two different graphs  and  to distinct vectors if node aggregation and update functions are injective, and graph-level readout, which operates on a multiset of node features , is injective.}

\begin{proof}
To map two non-isomorphic graphs to distinct embedding spaces with GNNs, we recount the theorem on Graph Isomorphism Network. See Appendix B of~\cite{GIN} for details.
\end{proof}

\textbf{Lemma 2 (Uniqueness on Graph Multiset Pooling).} \emph{Assume the input feature space  is a countable set. Then the output of the  with  for a seed vector  can be unique for each multiset  of bounded size. Further, the output of the full  constructs a multiset with k elements, which are also unique on the input multiset .}

\begin{proof}
We first state that the GNNs of the Graph Multi-head Attention (GMH) in a GMPool can represent the injective function over the multiset  with an adjacency information , by selecting proper message-passing functions that satisfy the WL test~\citep{GIN, WL/GNN}, denoted as follows: , where . Then, given enough elements, a  can express the sum pooling over the multiset  defined as follows: , where  and  are mapping functions (see the proof of PMA in~\citet{SetTransformer}). 


Since  is a countable set, there is a mapping from the elements to prime numbers denoted by . If we let , then  which constitutes an unique mapping for every multiset  (see~\citet{multiset/injective}). In other words,  is injective. Also, we can easily construct a function , such that  is the injective function for every multiset , where  is derived from the GNN component in the GMPool; .

Furthermore, since a  considers multiset elements without any order, it satisfies the permutation invariance condition for the multiset function.

Finally, each  block has  components such that the output of it consists of  elements as follows: , which allows multiple instances for its elements. Then, since each  is unique on the input multiset , the output of the  that consists of  outputs is also unique on the input multiset .
\end{proof}

Thanks to the universal approximation theorem~\citep{univ/approx}, we can construct such functions  and  using multi-layer perceptrons (MLPs).


\textbf{Proposition 3 (Injectiveness on Pooling Function).} 
\emph{The overall Graph Multiset Transformer with multiple GMPool and SelfAtt can map two different graphs  and  to distinct embedding spaces, such that the resulting GNN with proposed pooling functions can be as powerful as the WL test.}

\begin{proof}
By Lemma 2, we know that a \emph{Graph Multiset Pooling} (GMPool) can represent the injective function over the input multiset . If we can also show that a \emph{Self-Attention} (SelfAtt) can represent the injective function over the multiset, then the sequence of the GMPool and SelfAtt blocks can satisfy the injectiveness.

Let  be a zero matrix in SelfAtt function.  then can be approximated to the any instance-wise feed-forward network denoted as follows: . Therefore, this  is a suitable transformation  that can be easily constructed over the multiset elements , to satisfy the injectiveness.
\end{proof}

To maximize the discriminative power of the Graph Multiset Transformer (GMT) by satisfying the WL test, we assume that SelfAtt does not consider the interactions among multiset elements, namely nodes. While proper GNNs with the proposed pooling function can be at most as powerful as the WL test with this assumption, our experimental results with the ablation study show that the interaction among nodes is significantly important to distinguish the broad classes of graphs (See Table~\ref{ablation}).


\subsection{Proofs regrading Node Clustering \label{appendix/clusterproof}}
We first prove that the space complexity of the \emph{Graph Multiset Pooling} (GMPool) without GNNs can be approximated to the  with  nodes (Theorem 4). After that, we show that the GMPool can be extended to the node clustering approaches with learnable cluster centroids (Proposition 5).


\textbf{Theorem 4 (Space Complexity of Graph Multiset Pooling).} \emph{Graph Multiset Pooling condsense a graph with  nodes to  nodes in  space complexity, which can be further optimized to .}

\begin{proof}
Assume that we have key  and value  matrices in the  function of Graph Multi-head Attention (GMH) for the simplicity, which is described in the equation~\ref{GMH}. Also,  is defined as a seed vector  in the GMPool function of the equation~\ref{GMPool}. To obtain the weights on the values , we multiply the query  with key : . This matrix multiplication then maps a set of  nodes into a set of  nodes, such that it requires  space complexity. Also, we can further drop the constant term : , by properly setting the small  values; .

The multiplication of the attention weights  with value  also takes the same complexity, such that the overall space complexity of GMPool is , which can be further optimized to .
\end{proof}

The space complexity of GNNs with sparse implementation requires  space complexity, where  is the number of nodes, and  is the number of edges in a graph. Therefore, multiple GNNs followed by our GMPool require the total space complexity of  due to the space complexity of the GNN operations. However, GNNs with our GMPool are more efficient than node clustering methods, since node clustering approaches need  space complexity.

\textbf{Proposition 5 (Approximation to Node Clustering).} \emph{Graph Multiset Pooling  can perform hierarchical node clustering with learnable  cluster centroids by Seed Vector  in equation~\ref{GMPool}.}

\begin{proof}
Node clustering approaches are widely used to coarsen a given large graph in a hierarchical manner with several message-passing functions. The core part of the node clustering schemes is to generate a cluster assignment matrix , to coarsen nodes and adjacency matrix as in an equation~\ref{node/clustering}. Therefore, if our Graph Multiset Pooling (GMPool) can generate a cluster assignment matrix , then the proposed GMPool can be directly approximated to the node clustering approaches.

In the proposed GMPool, query  is generated from a learnable set of  seed vectors , and key  and value  are generated from node features  with GNNs in the Graph Multi-head Attention (GMH) block, as in an equation~\ref{GMH}. In this function, if we decompose the attention function  into the dot products of the query with all keys, and the corresponding weighted sum of values, then the first dot product term inherently generates a soft assignment matrix as follows: . Therefore, the proposed GMPool can be easily extended to the node clustering schemes, with the inherently generated cluster assignment matrix; , where one of the proper choices for the activation function  is the softmax function as follows: 


Furthermore, through the learnable seed vectors  for the query , we can learn data dependent  different cluster centroids in an end-to-end fashion.
\end{proof}

Note that, as shown in the section~\ref{experiment/recon} of the main paper, the proposed GMPool significantly outperforms the previous node clustering approaches~\citep{DiffPool, MincutPool}. This is because, contrary to them, the proposed GMPool can explicitly learn data dependent  cluster centroids by learnable seed vectors .

\section{Details for Graph Multiset Transformer Components \label{appendix/model/detail}}
In this section, we describe the \emph{Graph Multiset Pooling} (GMPool) and \emph{Self-Attention} (SelfAtt), which are the components of the proposed \emph{Graph Multiset Transformer}, in detail.

\paragraph{Graph Multiset Pooling} The core components of the Graph Multiset Pooling (GMPool) is the Graph Multi-head Attention (GMH) that considers the graph structure into account, by constructing the key  and value  using GNNs, as described in the equation~\ref{GMH}. As shown in the Table~\ref{ablation} of the main paper, this graph multi-head attention significantly outperforms the naive multi-head attention (MH in equation~\ref{MH}). However, after compressing the  nodes into the  nodes with , we can not directly perform further GNNs since the original adjacency information is useless after pooling. To tackle this limitation, we can generate the new adjacency matrix  for the compressed nodes, by performing node clustering as described in Proposition 5 of the main paper as follows:

where  is the generated cluster assignment matrix, and  is the coarsened adjacency matrix as described in the equation~\ref{node/clustering}. However, this approach is well known for their scalability issues~\citep{SAGPool, GNN/sparse/pooling:Readout}, since they require quadratic space  to store and even multiply the adjacency matrix  with the soft assignment matrix . Therefore, we leave doing this as a future work, and use the following trick. By replacing the adjacency matrix  with the identity matrix  in the GMPool except for the first block, we can easily perform multiple GMPools without any constraints, which is approximated to the GMPool with MH in the equation~\ref{MH}, rather than GMH in the equation~\ref{GMH}, as follows:


\paragraph{Self-Attention}
The Self-Attention (SelfAtt) function can consider the inter-relationships between nodes in a set, which helps the network to take the global graph structure into account. Because of this advantage, the self-attention function significantly improves the proposed model performance on the graph classification tasks, as shown in the Table~\ref{ablation} of the main paper. From a different perspective, we can regard the Self-Attention function as a graph neural network (GNN) with a complete graph. Specifically, given  nodes from the previous layer, the Multi-head Attention (MH) of the Self-Attention function first constructs the adjacency matrix among all nodes with their similarities, through the matrix multiplication of the query with key: , and then computes the outputs with the sum of the obtained weights on the value. In other words, the self-attention function can be considered as one message passing function with a soft adjacency matrix, which might be further connected to the Graph Attention Network~\citep{GAT}.

\section{Experimental Setup}
In this section, we first introduce the baselines and our model, and then describe the experimental details about graph classification, reconstruction, and generation tasks respectively.


\subsection{Baselines and Our Model \label{appendix/classification/model}}
\textbf{1) GCN.} This method~\citep{GCN} is the mean pooling baseline with Graph Convolutional Network (GCN) as a message passing layer.

\textbf{2) GIN.} This method~\citep{GIN} is the sum pooling baseline with Graph Isomorphism Network (GIN) as a message passing layer.

\textbf{3) Set2Set.} This method~\citep{Set2Set} is the set pooling baseline that uses a recurrent neural network to encode a set of all nodes, with content-based attention over them.

\textbf{4) SortPool.} This method~\citep{SortPool} is the node drop baseline that drops unimportant nodes by sorting their representations, which are directly generated from the previous GNN layers.

\textbf{5) SAGPool.} This method~\citep{SAGPool} is the node drop baseline that selects the important nodes, by dropping unimportant nodes with lower scores that are generated by the another graph convolutional layer, instead of using scores from the previously passed layers. Particularly, this method has two variants. \textbf{6.1) SAGPool(G)} is the global node drop method that drops unimportant nodes one time at the end of their architecture. \textbf{6.2) SAGPool(H)} is the hierarchical node drop method that drops unimportant nodes sequentially with multiple graph convolutional layers.  

\textbf{6) TopkPool.} This method~\citep{TopKPool} is the node drop baseline that selects the top-ranked nodes using a learnable scoring function.

\textbf{7) ASAP.} This method~\citep{ASAP} is the node drop baseline that first locally generates the clusters with neighboring nodes, and then drops the lower score clusters using a scoring function.

\textbf{8) DiffPool.} This method~\citep{DiffPool} is the node clustering baseline that produces the hierarchical representation of the graphs in an end-to-end fashion, by clustering similar nodes into the few nodes through graph convolutional layers. 

\textbf{9) MinCutPool.} This method~\citep{MincutPool} is the node clustering baseline that applies the spectral clustering with GNNs, to coarsen the nodes and the adjacency matrix of a graph.

\textbf{10) HaarPool.} This method~\citep{HaarPool} is the spectral-based pooling baseline that compresses the node features with a nonlinear transformation in a Haar wavelet domain. Since it directly uses the spectral clustering to generate a coarsened matrix, the time complexity cost is relatively higher than other pooling methods.

\textbf{11) StructPool.} This method~\citep{StructPool} is the node clustering baseline that integrates the concept of the conditional random field into the graph pooling. While this method can be used with a hierarchical scheme, we use it with a global scheme following their original implementation, which is similar to the SortPool~\citep{SortPool}.

\textbf{12) EdgePool.} This method~\citep{edgepool} is the edge clustering baseline that gradually merges the nodes, by contracting the high score edge between two adjacent nodes. 

\textbf{13) GMT.} Our Graph Multiset Transformer that first condenses all nodes into the important nodes by GMPool, and then considers interactions between nodes in a set. Since it operates on the global READOUT layer, it can be coupled with hierarchical pooling methods by replacing their last layer.

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.95\linewidth]{images/appendix_layers_extended.pdf}
    \vskip -0.15in
    \caption{\small \textbf{Illustration of High-level Model Architectures. (Top):} Global Graph Classification; GCN, GIN, Set2Set, SortPool, SAGPool(G), StructPool, GMT. \textbf{(Middle:)} Hierarchical Graph Classification; DiffPool, SAGPool(H), TopKPool, MinCutPool, ASAP, EdgePool, HaarPool. \textbf{(Bottom:)} Graph Reconstruction; DiffPool, TopKPool, MinCutPool, GMT. MP denotes the message passing layer.}
    \vskip -0.15in
    \label{fig:appendix/layers}
\end{figure*}

\subsection{Graph Classification}

\paragraph{Dataset \label{appendix/classification/data}}
Among TU datasets~\citep{classification/datasets}, we select the 6 datasets including 3 datasets (D\&D, PROTEINS, and MUTAG) on Biochemical domain, and 3 datasets (IMDB-B, IMDB-M, and COLLAB) on Social domain. We use the classification accuracy as an evaluation metric. As suggested by~\cite{fair/GNN} for a fair comparison, we use the one-hot encoding of their atom types as initial node features in the bio-chemical datasets, and the one-hot encoding of node degrees as initial node features in the social datasets. Moreover, we use the recently suggested 4 molecule graphs (HIV, Tox21, ToxCast, BBBP) from the OGB datasets~\citep{OGB}. We use the ROC-AUC for an evaluation metric, and use the additional atom and bond features, as suggested by~\citet{OGB}. Dataset statistics are reported in the Table~\ref{table:results:chemical} of the main paper.

\paragraph{Implementation Details on Classification Experiments \label{appendix/classification/implementation}}
For all experiments on TU datasets, we evaluate the model performance with a 10-fold cross validation setting, where the dataset split is based on the conventionally used training/test splits~\citep{TUdataset/split, SortPool, GIN}, with LIBSVM~\citep{LIBSVM}. In addition, we use the 10 percent of the training data as a validation data following the fair comparison setup~\citep{fair/GNN}. For all experiments on OGB datasets, we evaluate the model performance following the original training/validation/test dataset splits~\citep{OGB}. We use the early stopping criterion, where we stop the training if there is no further improvement on the validation loss during 50 epochs, for the TU datasets. Further, the maximum number of epochs is set to 500. We then report the average performances on the validation and test sets, by performing overall experiments 10 times with different seeds.

For all experiments on TU datasets except the D\&D, the learning rate is set to , hidden size is set to , batch size is set to , weight decay is set to , and dropout rate is set to . Since the D\&D dataset has a large number of nodes (See Table~\ref{table:results:chemical} in the main paper), node clustering methods can not perform clustering operations on large graphs with large batch sizes, such that the hidden size is set to , and batch size is set to  on the D\&D dataset. For all experiments on OGB datasets except the HIV, the learning rate is set to , hidden size is set to , batch size is set to , weight decay is set to , and dropout rate is set to . Since the HIV dataset contains a large number of graphs compared to others (See Table~\ref{table:results:chemical} in the main paper), the batch size is set to  for fast training. Then we optimize the network with Adam optimizer~\citep{kingma2014adam}. For a fair comparison of baselines~\citep{SAGPool}, we use the three GCN layers~\citep{GCN} as a message passing function for all models with jumping knowledge strategies~\citep{JumpingKnowledge}, and only change the pooling architecture throughout all models, as illustrated in Figure~\ref{fig:appendix/layers}. Also, we set the pooling ratio as 25\% in each pooling layer for both baselines and our models.

\paragraph{Implementation Details on Efficiency Experiments \label{appendix/classification/efficiency}}
To compare the GPU \textbf{memory efficiency} of GMT against baseline models including node drop and node clustering methods, we first generate the Erdos-Renyi graphs~\citep{randomgraph} by varying the number of nodes , where the edge size  is twice the number of nodes: . For all models, we compress the given  nodes into the  nodes at the first pooling function.

To compare the \textbf{time efficiency} of GMT against baseline models, we first generate the Erdos-Renyi graphs~\citep{randomgraph} by varying the number of nodes  with  edges, following the setting of HaarPool~\citep{HaarPool}. For all models, we set the pooling ratio as  except for HaarPool, since it compresses the nodes according to the coarse-grained chain of a graph. We measure the forward time, including CPU and GPU, for all models with 50 graphs over one batch.

\subsection{Graph Reconstruction \label{appendix/reconstruction/experimentaldetail}}

\paragraph{Dataset}
We first experiment with synthetic graphs represented in a 2-D Euclidean space, such as ring and grid structures. The node features of a graph consist of their location in a 2-D coordinate space, and the adjacency matrix indicates the connectivity pattern of nodes. The goal here is to restore all node locations from compressed features after pooling, with the intact adjacency matrix.

While synthetic graphs are appropriate choices for the qualitative analysis, we further do the quantitative evaluation of models with real-world molecular graphs. Specifically, we use the subset~\citep{benchmarkingGNN} of the ZINC dataset~\citep{ZINC}, which consists of 12K real-world molecular graphs, to further conduct a graph reconstruction on the large number of various graphs. The goal of the molecule reconstruction task is to restore the exact atom types of all nodes in the given graph, from the compressed representations after pooling.

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{images/appendix_graph_reconstruction.pdf}
    \vskip -0.2in
    \caption{High resolution images for synthetic graph reconstruction results in Figure~\ref{recon:synthetic}.}
    \label{fig:appendix/synthetic}
    \vskip -0.15in
\end{figure*}

\paragraph{Common Implementation Details}
Following~\citet{MincutPool}, we use the two message passing layers both right before the pooling operation and right after the unpooling operation. Also, both pooling and unpooling operations are performed once and sequentially connected, as illustrated in the Figure~\ref{fig:appendix/layers}. We compare our methods against both the node drop (TopKPool~\citep{TopKPool}) and node clustering (DiffPool~\citep{DiffPool} and MinCutPool~\citep{MincutPool}) methods. For the node drop method, we use the unpooling operation proposed in the graph U-net~\citep{TopKPool}. For the node clustering methods, we use the graph coarsening schemes described in the equation~\ref{node/clustering}, with their specific implementations on generating an assignment matrix. For our proposed method, we only use the one Graph Multiset Pooling (GMPool) without SelfAtt, where we follow the node clustering approaches as described in the subsection~\ref{paragraph/node/clustering} by generating a single soft assignment matrix with one head  in the multi-head attention function. For experiments of both synthetic and molecule reconstructions, the learning rate is set to , and hidden size is set to . We then optimize the network with Adam optimizer~\citep{kingma2014adam}.


\paragraph{Implementation Details on Synthetic Graph}
We set the pooling ratio of all models as 25\%. For the loss function, we use the Mean Squared Error (MSE) to train models. We use the early stopping criterion, where we stop the training if there is no further improvement on the training loss during 1,000 epochs. Further, the maximum number of epochs is set to 10,000. Note that, there is no other available graphs for validation of the synthetic graph, such that we train and test the models only with the given graph in the Figure~\ref{fig:appendix/synthetic}. The baseline results are adopted from~\citet{MincutPool}.


\paragraph{Implementation Details on Molecule Graph} 
We set the pooling ratio of all models as 5\%, 10\%, 15\%, and 25\%, and plot all results in the Figure~\ref{recon:ZINC} of the main paper. Note that, in the case of molecule graph reconstruction, a softmax layer is appended at the last layer of the model architecture to classify the original atom types of all nodes. For the loss function, we use the cross entropy loss to train models. We use the early stopping criterion, where we stop the training if there is no further improvement on the validation loss during 50 epochs. Further, the maximum number of epochs is set to 500, and batch size is set to 128. Note that, in the case of molecule graph reconstruction on the ZINC dataset, we strictly separate the training, validation and test sets, as suggested by~\citet{benchmarkingGNN}. We perform all experiments 5 times with 5 different random seeds, and then report the averaged result with the standard deviation. Note that, in addition to baselines mentioned in the common implementation details paragraph, we compare two more baselines: GCN with a random assignment matrix for pooling, which is adopted from~\citet{rethinking/pooling}, and StructPool~\citep{StructPool}, for the real-world molecule graph reconstruction.


\paragraph{Evaluation Metrics for Molecule Reconstruction}
For quantitative evaluations, we use the three metrics as follows: \textit{1) validity} indicates the number of reconstructed molecules that are chemically valid, \textit{2) exact match} indicates the number of reconstructed molecules that are exactly same as the original molecules, and \textit{3) accuracy} indicates the classification accuracy of atom types of all nodes.

\subsection{Graph Generation \label{appendix/generation/experimentaldetail}}

\paragraph{Common Implementation Details}
In the graph generation experiments, we replace the graph embedding function  from existing graph generation models to the proposed Graph Multiset Transformer (GMT), to evaluate the applicability of our model on generation tasks, as described in the subsection~\ref{experiment/generation} of the main paper. As baselines, we first use the original models with their implementations. Specifically, we use the MolGAN\footnote{https://github.com/yongqyu/MolGAN-pytorch}~\citep{MolGAN} for molecule generation, and Graph Logic Network (GLN)\footnote{https://github.com/Hanjun-Dai/GLN}~\citep{GLN} for retrosynthesis. For both experiments, we directly follow the experimental details of original papers~\citep{MolGAN, GLN} for a fair comparison. Furthermore, to compare our models with another strong pooling method, we use the MinCutPool~\citep{MincutPool} as an additional baseline for generation tasks, since it shows the best performance among baselines in the previous two classification and reconstruction tasks.


For MinCutPool, since it cannot directly compress the all  nodes into the  cluster to represent the entire graph, we use the following trick to replace the simple pooling operation (e.g. sum or mean) with it. We first condense the graph into the k clusters () using one MinCutPool layer, and then average the condensed nodes to get a single representation of the given graph. However, our proposed Graph Multiset Transformer (GMT) can directly compress the all  nodes into the  node with one learnable seed vector, by using the single  block. In other words, we use the one  to represent the entire graph by replacing their simple pooling (e.g. sum or mean), in which we use the following softmax activation function for computing attention weights:



\paragraph{Implementation Details on Molecule Generation}
For the molecule generation experiment with the MolGAN, we replace the average pooling in the discriminator with . We use the QM9 dataset~\citep{qm9} following the original MolGAN paper~\citep{MolGAN}. To evaluate the models, we report the validity of 13,319 generated molecules at the early stage of the MolGAN training, over 4 different runs. As depicted in Figure~\ref{gen:molgan} of the main paper, each solid curve indicates the average validity of each model with  different runs, and the shaded area indicates the half of the standard deviation for 4 different runs.

\paragraph{Implementation Details on Retrosynthesis}
For the retrosynthesis experiment with the Graph Logic Network (GLN), we replace the average pooling in the template and subgraph encoding functions with . We use the USPTO-50k dataset following the original paper~\citep{GLN}. For an evaluation metric, we use the Top-\textit{k} accuracy for both reaction class is not given and given cases, following the original paper~\citep{GLN}. We reproduce all results in Table~\ref{gen:gln} with published codes from the original paper. 


\section{Additional Experimental Results}


\begin{table*}[t]
\caption{\small Graph classification results on validation sets with standard deviations. All results are averaged over 10 different runs. Best performance and its comparable results () from the t-test are marked in blod. Hyphen (-) denotes out-of-resources that take more than 10 days (See Figure~\ref{time} for the time efficiency analysis).}
\centering
\resizebox{\textwidth}{!}{
\renewcommand{\tabcolsep}{0.9mm}
\begin{tabular}{lccccccccccc}
\toprule
                & \multicolumn{7}{c}{\textbf{Biochemical Domain}} & \multicolumn{3}{c}{\textbf{Social Domain}} \\
                \cmidrule(l{2pt}r{2pt}){2-8} \cmidrule(l{2pt}r{2pt}){9-11}
    & \textbf{D\&D} & \textbf{PROTEINS} & \textbf{MUTAG} & \textbf{HIV} & \textbf{Tox21} & \textbf{ToxCast} & \textbf{BBBP} & \textbf{IMDB-B} & \textbf{IMDB-M} & \textbf{COLLAB} \\ 
\midrule
\# graphs       & 1,178     & 1,113     & 188       & 41,127    & 7,831     & 8,576     & 2,039     & 1,000     & 1,500     & 5,000     \\
\# classes      & 2         & 2         & 2         & 2         & 12        & 617       & 2         & 2         & 3         & 3         \\ 
Avg \# nodes    & 284.32    & 39.06     & 17.93     & 25.51     & 18.57     & 18.78     & 24.06     & 19.77     & 13.00     & 74.49     \\
\midrule
GCN     & 76.17  0.65 & 77.13  0.44 & 76.56  1.75 & 81.27  0.92 & 78.80  0.40 & 65.66  0.40 & 93.35  1.08 & 77.93  0.28 & 54.29  0.23 & 83.08  0.13 \\
GIN     & 76.85  0.61 & 78.43  0.45 & \textbf{94.44}  0.52 & 82.10  1.01 & 78.20  0.45 & 66.29  0.42 & 94.64  0.36 & \textbf{78.38}  0.26 & 54.04  0.29 & 82.19  0.25 \\
\midrule
Set2Set    & 76.32  0.40 & 77.64  0.41 & 79.72  2.40 & 80.07  0.93 & 79.13  0.75 & 66.39  0.49 & 91.89  1.48 & 78.13  0.30 & 54.39  0.19 & 82.34  0.23 \\
SortPool   & 80.68  0.59 & 77.92  0.42 & 81.33  3.00 & 81.17  2.30 & 75.97  0.76 & 64.26  1.17 & 94.21  1.04 & 77.46  0.60 & 52.95  0.62 & 80.58  0.25 \\
DiffPool   & 81.33  0.33 & 79.09  0.36 & 87.94  1.93 & \textbf{83.16}  0.44 & 80.02  0.38 & \textbf{69.73}  0.79 & \textbf{96.32}  0.36 & 77.86  0.39 & 54.77  0.19 & 81.69  0.31 \\
SAGPool(G) & 76.73  0.80 & 77.01  0.58 & 88.11  1.21 & 80.55  1.89 & 77.03  0.76 & 65.51  0.91 & \textbf{95.59}  1.22 & \textbf{78.09}  0.58 & 53.73  0.42 & 81.91  0.45 \\
SAGPool(H) & 79.56  0.67 & 77.24  0.56 & 86.06  2.07 & 79.21  1.50 & 75.36  2.63 & 64.05  0.83 & 93.05  3.00 & 77.11  0.46 & 53.49  0.65 & 80.55  0.56 \\
TopKPool   & 78.54  0.73 & 75.47  0.90 & 75.06  2.12 & 79.24  1.84 & 75.06  2.30 & 64.56  0.56 & 93.31  2.32 & 76.12  0.79 & 52.75  0.58 & 79.94  0.86 \\
MinCutPool & 81.96  0.39 & 79.23  0.66 & 87.22  1.72 & \textbf{83.12}  1.27 & \textbf{81.10}  0.42 & \textbf{69.09}  1.12 & \textbf{95.99}  0.47 & 77.76  0.36 & \textbf{54.94}  0.19 & \textbf{83.37}  0.18 \\
StructPool & \textbf{82.56}  0.37 & \textbf{80.00}  0.27 & 91.5  0.95 & 81.09  1.26 & 79.61  0.70 & 66.49  1.59 & 95.18  0.59 & 77.14  0.31 & 54.13   0.39 & 79.90  0.18 \\
ASAP       & 81.58  0.38 & 78.71  0.45 & 91.33 0.65 &  79.80  1.88  & 77.33  1.34 & 63.82  0.75 & 92.96  1.09 & 77.89  0.51 & \textbf{55.17}   0.33 & 82.11  0.33 \\
EdgePool   & 80.32  0.44 & 79.61  0.25 & 87.28 1.18 & 81.84  1.32 & 78.92  0.29 & 66.21  0.64 & 94.98  0.62 & 77.50  0.25 & 54.69   0.40 &         -        \\
HaarPool   &         -        & - & 68.22 0.86 &         -        &         -        &         -        & 89.98  0.58 & 76.72  0.60 & 53.03   0.14 &         -        \\
\midrule
GMT (Ours) & 82.19  0.40 & \textbf{80.01}  0.21 & 91.00  0.82 & \textbf{83.54}  0.78 & \textbf{80.91}  0.41 & \textbf{69.77}  0.67 & 95.14  0.48 & \textbf{78.43}  0.22 & \textbf{55.14}  0.25 & \textbf{83.37}  0.11 \\
\bottomrule
\end{tabular}
}
\vspace{-0.15in}
\label{app:table:results:chemical}
\end{table*} 
\paragraph{Validation Results on Graph Classification}
We additionally provide the graph classification results on validation sets. As shown in Table~\ref{app:table:results:chemical}, the proposed GMT outperforms most baselines, or achieves comparable performances to the best baseline results even in the validation sets. While validation results can not directly measure the generalization performance of the model for unseen data, these results further confirm that our method is powerful enough, compared to baselines. Regarding the results of test sets on the graph classification task, please see Table~\ref{table:results:chemical} in the main paper.


\begin{wraptable}{t}{0.4\textwidth}
    \vspace{-0.3in}
    \small
    \centering
    \caption{\small Graph classification results for OGB test datasets with standard deviations.}
    \resizebox{0.4\textwidth}{!}{
        \renewcommand{\tabcolsep}{0.75mm}
        \renewcommand{\arraystretch}{0.9}
        \begin{tabular}{llccccc}
        \toprule
        & {\bf Model} & {\bf HIV} & {\bf Tox21} \\
        \midrule
        \multirow{2}{*}{Leaderboard} & GCN & 76.06  0.97 & 75.29  0.69 \\
        & GIN & 75.58  1.40 & 74.91  0.51 \\
        \midrule
        \multirow{2}{*}{Reproduced} & GCN & 76.81  1.01 & 75.04  0.80 \\
        & GIN & 75.95  1.35 & 73.27  0.84 \\
        \midrule
        Ours & GMT & \textbf{77.56}  1.25 & \textbf{77.30}  0.59 \\
        \bottomrule
        \end{tabular}
    }
    \vskip -0.15in
    \label{app:leaderboard}
\end{wraptable}

\paragraph{Leaderboard Results on Graph Classification}
For a fair comparison, we experiment with all baselines and our models in the same setting, as described in the implementation details of Appendix~\ref{appendix/classification/implementation}. Specifically, we average the results over 10 different runs with the same hidden dimension (128, while leaderboard uses 300), and the same number of message-passing layers (3, while leaderboard uses 5) with 10 different seeds for all models. Therefore, the reproduced results can be slightly different from the leaderboard results, as shown in Table~\ref{app:leaderboard}, since the leaderboard uses different hyper-parameters with different random seeds (See~\cite{OGB} for more details). However, our reproduction results are almost the same as the leaderboard results, and sometimes outperform the leaderboard results (See the GCN results for the HIV dataset in Table~\ref{app:leaderboard}). Therefore, while we conduct all experiments under the same setting for a fair comparison, where specific hyperparameter choices are slightly different from the leaderboard setting, these results indicate that there is no significant difference between reproduced and leaderboard results.


\begin{table}[t]
\small
\centering
\caption{\small Quantitative results of the graph reconstruction task on reconstructing the node features and the adjacency matrix for synthetic graphs, with two different minimization objectives and error calculation metrics:  and . * indicates the model without using adjacency normalization.}
\resizebox{\textwidth}{!}{
    \begin{tabular}{lccccccccccccc}
    \toprule
     Data: & \multicolumn{4}{c}{Grid Graph} & \multicolumn{4}{c}{Ring Graph} \\
     \cmidrule(l{2pt}r{2pt}){2-5} \cmidrule(l{2pt}r{2pt}){6-9}
     Objective: & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
     \cmidrule(l{2pt}r{2pt}){2-3} \cmidrule(l{2pt}r{2pt}){4-5} \cmidrule(l{2pt}r{2pt}){6-7} \cmidrule(l{2pt}r{2pt}){8-9}
     Error Calculation: &  &  &  &  &  &  &  & \\
    \midrule
    DiffPool & 0.0833 & 12110194 & 0.3908 & 0.0856 & 0.0032 & 617.7706 & 0.6208 & 0.0948 \\
    MinCutPool & 0.0001 & 0.0092 & 1.2883 & 0.0051 & 0.0005 & 0.0424 & 0.5026 & 0.0128 \\
    MinCutPool* & 0.0002 & 201.7619 & 2.0261 & 0.0616 & 0.0003 & 68.23 & 0.5211 & 0.0725 \\
    GMT (Ours) & 0.0001 & 0.0102 & 0.2353 & 0.0084 & 0.0000 & 0.0331 & 0.5475 & 0.0324 \\
    \bottomrule
    \end{tabular}
}
\label{app:adj:recon}
\end{table}

\paragraph{Quantitative Results on Graph Reconstruction for Synthetic Graphs}
While we conduct experiments on reconstructing node features on the given graph, to quantify the retained information on the condensed nodes after pooling (See Section~\ref{experiment/recon} for experiments on the graph reconstruction task), we further reconstruct the adjacency matrix to see if the pooling layer can also condense the adjacency structure without loss of information. The learning objective to minimize the discrepancy between the original adjacency matrix  and the reconstructed adjacency matrix  with a cluster assignment matrix  is defined as follows: 


Then we design the following two experiments. First, pooling layers are trained to minimize the objective in Section~\ref{experiment/recon}: . After that, we measure the discrepancy between the original and the reconstructed node features: , and also measure the discrepancy between the original and the reconstructed adjacency matrix: . Second, pooling layers are trained to minimize the objective described in the previous paragraph: , and then we measure the aforementioned two discrepancies in the same way.

We experiment with synthetic grid and ring graphs, illustrated in Figure~\ref{fig:appendix/synthetic}. Table~\ref{app:adj:recon} shows that the error is large when the objective and the error metric are different, which indicates that there is a high discrepancy between the required information for condensing node and the required information for condensing adjacency matrix. In other words, the compression for node and the compression for adjacency matrix might be differently performed to reconstruct the whole graph information. 

Also, Table~\ref{app:adj:recon} shows that there are some cases where there is no significant difference in the calculated adjacency error (), when minimizing nodes discrepancies and minimizing adjacency discrepancies (See 0.0331 and 0.0324 for the proposed GMT on the Ring Graph). Furthermore, calculated errors for the adjacency matrix when minimizing adjacency discrepancies are generally larger than the calculated errors for node features when minimizing nodes discrepancies. These results indicate that the adjacency matrix is difficult to reconstruct after pooling. This might be because the reconstructed adjacency matrix should be further transformed from continuous values to discrete values (0 or 1 for the undirected simple graph), while the reconstructed node features can be directly represented as continuous values. We leave further reconstructing adjacency matrices and visualizing them as a future work.



\paragraph{Additional Examples for Molecule Reconstruction}
We visualize the additional examples for molecule reconstruction on the ZINC dataset in Figure~\ref{fig:appendix/zinc}. Molecules on the left side indicate the original molecule, where the transparent color denotes the assigned cluster for each node, which is obtained by the cluster assignment matrix  with node (atom) representations in a graph (molecule) (See Proposition 5 for more detail on generating the cluster assignment matrix). Also, molecules on the right side indicate the reconstructed molecules with failure cases denoted as a red dotted circle. 

As visualized in Figure~\ref{fig:appendix/zinc}, we can see that the same atom or the similarly connected atoms obtain the same cluster (color). For example, the atom type O mostly obtains the yellow cluster, and the atom type F obtains the green cluster. Furthermore, ring-shaped substructures that do not contain O or N mostly receive the blue cluster, whereas ring-shaped substructures that contain O and N receive the green and yellow clusters respectively.

\begin{figure*}[h]
    \centering
    \includegraphics[width=0.9\linewidth]{images/appendix_molecule.pdf}
    \vskip -0.175in
    \caption{\textbf{Molecule Reconstruction Examples (Left):} Original molecules with the assigned cluster on each node represented as color, where cluster is generated from \emph{Graph Multiset Pooling} (GMPool). \textbf{(Right):} Reconstructed molecules. Red dotted circle indicates the incorrect atom prediction.}
    \label{fig:appendix/zinc}
\end{figure*} 
\end{document}
