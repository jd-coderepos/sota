\documentclass{article}
\usepackage[psamsfonts]{amsfonts}
\usepackage{amsfonts,amssymb,amsmath,stmaryrd}
\usepackage{theorem}
\usepackage{xspace}
\usepackage{epsfig}
\usepackage{subfigure}


\usepackage[bookmarksnumbered=true,pdftitle={Partitioning the Threads of a Mobile System},
            pdfauthor={J{\'e}r{\^o}me Feret},pdfkeywords={static analysis, 
                         mobile systems,
                         abstract interpretation}]{hyperref}




\newcommand{\bydef}{:=}
\newcommand{\Nset}{\mathbb{N}}
\newcommand{\fracbis}[2]{\frac{\strut #1}{\strut #2}}
\newcommand{\boxexample}{}

\newtheorem{thm}{Theorem}[section]
\newtheorem{example}[thm]{Example}
\newtheorem{definition}[thm]{Definition}
\newtheorem{theorem}[thm]{Theorem}

\newcommand{\picalcul}{-calculus}
\newcommand{\ambientcalcul}{{\emph{ambient} calculus}}
\newcommand{\ambient}{\emph{ambient}}
\newcommand{\ambients}{\emph{ambients}}
\newcommand{\Ambients}{\emph{Ambients}}
\newcommand{\spicalcul}{{\emph{spi}-calculus}}
\newcommand{\bioambients}{{\textsc{bio}-\emph{ambients}}}
\newcommand{\bioambient}{\textsc{bio}-\emph{ambient}}
\newcommand{\Bioambients}{\textsc{Bio}-\emph{ambients}}
\newcommand{\Bioambient}{\textsc{Bio}-\emph{ambient}}
\newcommand{\joincalcul}{{\emph{join}-calculus}}

\newcommand{\Names}{\mathcal{V}}
\newcommand{\Labels}{\mathcal{L}}
\newcommand{\concu}{|}
\newcommand{\nuu}{\nu\;}
\newcommand{\repli}{\ast}
\newcommand{\rec}{?}
\newcommand{\eme}{!}
\newcommand{\emptypro}{\mathbf{0}}
\newcommand{\y}{\overline{y}}
\newcommand{\x}{\overline{x}}


\newcommand{\pp}[1]{}
\newcommand{\pps}[1]{(at program point \pp{#1})}
\newcommand{\make}{\mathrm{make}}
\newcommand{\bang}[1]{\overline{\repli}^{#1}}
\newcommand{\globalname}[1]{\mathrm{#1}}
\newcommand{\internal}[1]{\textnormal{\texttt{#1}}}
\newcommand{\capability}[1]{\textsc{#1}}
\newcommand{\data}[1]{\textsf{#1}\,}
\newcommand{\recur}[1]{{\textsl{#1}}}
\newcommand{\variable}[1]{\textit{#1}}

\newcommand{\mke}{mk}
\newcommand{\ret}{r}
\newcommand{\cack}{\variable{ack}}
\newcommand{\cdata}{\data{data}}
\newcommand{\addinit}{\data{add}}
\newcommand{\addread}{\data{return}}
\newcommand{\addwrite}{\data{ack}}
\newcommand{\port}{\variable{fwd}}
\newcommand{\cbang}{\recur{rec}}
\newcommand{\ccreate}{\globalname{alloc}}
\newcommand{\cnull}{\globalname{null}}
\newcommand{\ccell}{\internal{cell}}
\newcommand{\cread}{\capability{read}}
\newcommand{\cwrite}{\capability{write}}
\newcommand{\datawrite}{\variable{val}'}
\newcommand{\dataread}{\variable{val}}

\newcommand{\memlaba}{1}
\newcommand{\memlabb}{2}
\newcommand{\memlabc}{3}
\newcommand{\memlabd}{4}
\newcommand{\memlabe}{5}
\newcommand{\memlabf}{6}
\newcommand{\memlabg}{7}
\newcommand{\memlabh}{8}
\newcommand{\memlabi}{9}
\newcommand{\memlabj}{10}
\newcommand{\memlabk}{11}
\newcommand{\memlabl}{12} 
\newcommand{\memlabm}{13} 
\newcommand{\memlabn}{14} 
\newcommand{\memlabo}{15}  
\newcommand{\memlabp}{16}  
\newcommand{\memlabq}{17} 
\newcommand{\memlabr}{18}  
\newcommand{\memlabs}{19}  
\newcommand{\memlabt}{20}  




\newcommand{\crec}{\recur{rec}}
\newcommand{\mutlaba}{1}
\newcommand{\mutlabb}{2}
\newcommand{\mutlabc}{3}
\newcommand{\mutlabd}{4}
\newcommand{\mutlabe}{5}
\newcommand{\mutlabf}{6}

\newcommand{\cfalaba}{1}
\newcommand{\cfalabc}{2}
\newcommand{\cfalabd}{3}
\newcommand{\cfalabe}{4}
\newcommand{\cfalabf}{5}
\newcommand{\cfalabg}{6}
\newcommand{\cfalabh}{7}
\newcommand{\cfalabi}{8}
\newcommand{\cfalabj}{9}
\newcommand{\cfalabk}{10}
\newcommand{\cfalabl}{11}
\newcommand{\cfalabm}{12}
\newcommand{\cfalabn}{13}
\newcommand{\cfalabo}{14}
\newcommand{\cfalabp}{15}
\newcommand{\llinkint}[1]{\internal{l}{#1}}
\newcommand{\rlinkint}[1]{\internal{r}{#1}}
\newcommand{\clinkint}[1]{\internal{c}{#1}}
\newcommand{\varr}{r}
\newcommand{\varl}{l}
\newcommand{\varx}{x}
\newcommand{\varc}{c}
\newcommand{\celllinkint}[1]{[\llinkint{#1},\clinkint{#1},\rlinkint{#1}]}

\newcommand{\llinkvar}[1]{\internal{l}{#1}}
\newcommand{\rlinkvar}[1]{\internal{r}{#1}}
\newcommand{\clinkvar}[1]{\internal{c}{#1}}
\newcommand{\cellvar}[1]{[\llinkvar{#1},\clinkvar{#1},\rlinkvar{#1}]}
\newcommand{\cset}{\capability{set}}
\newcommand{\celllinkvar}[1]{[\llinkvar{#1},\clinkvar{#1},\rlinkvar{#1}]}

\newcommand{\flowdom}[1]{\mathcal{F}(#1)}
\newcommand{\flowsub}[1]{\sqsubseteq_{\flowdom{#1}}}
\newcommand{\flowconc}[1]{\gamma_{\flowdom{#1}}}
\newcommand{\flowbot}[1]{\bot_{\flowdom{#1}}}
\newcommand{\normalflowdom}[1]{\mathcal{F}_{n}(#1)}
\newcommand{\normalflowsub}[1]{\sqsubseteq_{\normalflowdom{#1}}}
\newcommand{\normalflowconc}[1]{\gamma_{\normalflowdom{#1}}}
\newcommand{\normalflowcup}[1]{\sqcup_{\normalflowdom{#1}}}
\newcommand{\cana}{\internal{a}}
\newcommand{\semlaba}{1}
\newcommand{\semlabb}{2}
\newcommand{\semlabc}{3}
\newcommand{\semlabd}{4}
\newcommand{\semlabe}{5}

\newcommand{\alloc}{\globalname{b}}
\newcommand{\addone}{\variable{c}}
\newcommand{\addtwo}{\variable{c}'}
\newcommand{\addthree}{\variable{c}''}
\newcommand{\argone}{\internal{c}}
\newcommand{\argtwo}{\internal{c}'}
\newcommand{\argthree}{\internal{c}''}
\newcommand{\clock}{\internal{l}}
\newcommand{\cm}{\internal{m}}
\newcommand{\crr}{\internal{r}}
\newcommand{\twolaba}{1}
\newcommand{\twolabb}{2}
\newcommand{\twolabc}{3}
\newcommand{\twolabd}{4}
\newcommand{\twolabe}{5}
\newcommand{\twolabf}{6}
\newcommand{\twolabg}{7}
\newcommand{\twolabh}{8}
\newcommand{\twolabi}{9}
\newcommand{\twolabj}{10}
\newcommand{\twolabk}{11}
\newcommand{\twolabl}{12}
\newcommand{\twolabm}{13}
\newcommand{\twolabn}{14}
\newcommand{\twolabo}{15}
\newcommand{\twolabp}{16}
\newcommand{\twolabq}{17}
\newcommand{\twolabr}{18}

\newcommand{\canb}{\internal{b}}
\newcommand{\canc}{\internal{c}}
\newcommand{\varu}{\variable{u}}
\newcommand{\varv}{\variable{v}}
\newcommand{\synlaba}{1}
\newcommand{\synlabb}{2}
\newcommand{\synlabc}{3}
\newcommand{\synlabd}{4}
\newcommand{\synlabe}{5}
\newcommand{\synlabf}{6}
\newcommand{\synlabg}{7}

\newcommand{\server}{\globalname{server}}
\newcommand{\duplicate}{\globalname{give\_id}}
\newcommand{\instance}{\globalname{instance}}
\newcommand{\client}{\globalname{client}}
\newcommand{\ambk}{\internal{k}}
\newcommand{\ambx}{\internal{x}}
\newcommand{\ambp}{\internal{p}}
\newcommand{\amblaba}{1}
\newcommand{\amblabb}{2}
\newcommand{\amblabc}{3}
\newcommand{\amblabd}{4}
\newcommand{\amblabe}{5}
\newcommand{\amblabf}{6}
\newcommand{\amblabg}{7} 
\newcommand{\amblabh}{8} 
\newcommand{\amblabi}{9} 
\newcommand{\amblabj}{10} 
\newcommand{\amblabk}{11} 
\newcommand{\amblabl}{12} 
\newcommand{\amblabm}{13} 
\newcommand{\amblabn}{14} 
\newcommand{\amblabo}{15} 
\newcommand{\amblabp}{16} 
\newcommand{\amblabq}{17} 
\newcommand{\amblabr}{18} 
\newcommand{\bfclient}{\globalname{\bf client}}
\newcommand{\bfduplicate}{\globalname{\bf giveid}}
\newcommand{\bfp}{\internal{\bf p}}
\newcommand{\bfserver}{\globalname{\bf server}}

\newcommand{\emptyfun}{\emptyset}
\newcommand{\prolabel}{\Labels}
\newcommand{\System}{\mathcal{S}}
\newcommand{\BN}{\texttt{bv}}
\newcommand{\FN}{\texttt{fv}}
\newcommand{\interface}{\mathtt{I}}
\newcommand{\type}{\texttt{type}}
\newcommand{\Extract}{\mathbf{\beta}}


\newcommand{\Markers}{\Labels^{\ast}}
\newcommand{\Env}[1]{\Markers \times (#1 \rightarrow (\Names\times\Markers))}
\newcommand{\env}[1]{\mathcal{E}(#1)}
\newcommand{\initstan}{\mathcal{I}}
\newcommand{\nonstan}[1]{\overset{\scriptscriptstyle{#1}}{\scriptstyle \longrightarrow}}
\newcommand{\states}{\mathcal{C}}
\newcommand{\Coll}{\states(\System)}
\newcommand{\component}{\texttt{comp}}
\newcommand{\inputm}{\emph{input}}
\newcommand{\outputm}{\emph{output}}
\newcommand{\fetch}{\emph{fetch}}
\newcommand{\args}{\texttt{arg}}
\newcommand{\canal}{\texttt{chan}}
\newcommand{\cont}{\texttt{cont}}
\newcommand{\launch}{\texttt{launch}}
\newcommand{\lrec}{l_{\rec}}
\newcommand{\leme}{l_{\eme}}
\newcommand{\idrec}{\textit{id}_{\rec}}
\newcommand{\ideme}{\textit{id}_{\eme}}
\newcommand{\Erec}{E_{\rec}}
\newcommand{\Eeme}{E_{\eme}}
\newcommand{\trec}{t_{\rec}}
\newcommand{\ttuplerec}{(\lrec,\idrec,\Erec)}
\newcommand{\teme}{t_{\eme}}
\newcommand{\ttupleeme}{(\leme,\ideme,\Eeme)}
\newcommand{\Vrec}{V_{\rec}}
\newcommand{\Veme}{V_{\eme}}
\newcommand{\translabel}{\Labels^2}
\newcommand{\extendedSigma}{\Sigma}
\newcommand{\ExtendedSigma}{\extendedSigma}
\newcommand{\continued}{(cont.)}

\newcommand{\inonunu}{\shareanalysis\ \continued}
\newcommand{\cnonunu}{\shareanalysis\ \continued}

\newcommand{\piunit}{\alpha_\computationunit}
\newcommand{\computationunit}{\textsc{unit}}
\newcommand{\abstractunit}{\textsc{unit}^{\sharp}}
\newcommand{\giveindex}{\texttt{getvar}}

\newcommand{\lfp}{\textit{lfp}}
\newcommand{\abstraction}[1]{\mathcal{A}_{#1}}
\newcommand{\abst}[1]{\textsc{post}_{#1}}
\newcommand{\aunion}[1]{\sqcup_{#1}}
\newcommand{\adom}[1]{\mathcal{C}_{#1}^{\sharp}}
\newcommand{\abot}[1]{\bot_{#1}}
\newcommand{\conc}[1]{\gamma_{#1}}
\newcommand{\ainit}[1]{\mathcal{I}_{#1}^{\sharp}}
\newcommand{\wid}[1]{\nabla_{#1}}
\newcommand{\tuple}[1]{(\adom{#1},
                        \aunion{#1},
                        \abot{#1},\conc{#1},
                        \ainit{#1},
                        \abst{#1},
                        \wid{#1})}
\newcommand{\limit}[1]{\llbracket \mathcal{S} 
                       \rrbracket_{\abstraction{#1}}}
 
\newcommand{\counterpart}[1]{\mathbb{F}_{\scriptscriptstyle\!\mathcal{A}_{#1}}^{\sharp}}
\newcommand{\iterate}[1]{\mathcal{F}^{\scriptscriptstyle \wid{#1}}}
\newcommand{\iteraten}[2]{\mathcal{F}_{#2}^{\scriptscriptstyle \wid{#1}}}




\newcommand{\envf}{\textsc{env}}
\newcommand{\Atomekey}{\textit{Atom}}
\newcommand{\Atomeshortkey}{}
\newcommand{\Atome}[1]{\Atomekey(#1)}
\newcommand{\Moleculekey}{\textit{Molecule}}
\newcommand{\Moleculeshortkey}{}
\newcommand{\Molecule}[2]{\Moleculekey(#1,#2)}
\newcommand{\gammaatome}[1]{\gamma^{\Atomeshortkey}_{#1}}
\newcommand{\cupatome}[1]{\sqcup^{\Atomeshortkey}_{#1}}
\newcommand{\botatome}[1]{\bot^{\Atomeshortkey}_{#1}}
\newcommand{\widatome}[1]{\nabla^{\Atomeshortkey}_{#1}}
\newcommand{\gammamolecule}[2]{\gamma^{\Moleculeshortkey}_{({#1},{#2})}}
\newcommand{\botmolecule}[2]{\bot^{\Moleculeshortkey}_{\scriptscriptstyle ({\scriptscriptstyle #1},{\scriptscriptstyle #2})}}
\newcommand{\Envkey}{\mathrm{env}}
\newcommand{\Envdom}{\mathcal{C}^{\sharp}_{\Envkey}}
\newcommand{\gammaenv}{\gamma_{\Envkey}}
\newcommand{\botenv}{\bot_{\Envkey}}
\newcommand{\cupenv}{\sqcup_{\Envkey}}
\newcommand{\sat}{\models}
\newcommand{\jfetchm}{{\textsc{fetch}}}
\newcommand{\fetchm}[2]{\jfetchm(#1,#2)}
\newcommand{\jgc}{\textsc{gc}}
\newcommand{\gc}[2]{\jgc(#1,#2)}
\newcommand{\jdeclare}{{\bf \nu}^{\sharp}}
\newcommand{\declare}{\jdeclare}
\newcommand{\jextension}{\textsc{new}}
\newcommand{\extension}{\jextension}
\newcommand{\jsync}{\textsc{sync}}
\newcommand{\sync}[2]{\jsync(#1,#2)}
\newcommand{\concat}{\bullet}
\newcommand{\initenv}{\ainit{\Envkey}}
\newcommand{\widenv}{\wid{\Envkey}}
\newcommand{\fst}{\textsc{fst}}
\newcommand{\snd}{\textsc{snd}}

\newcommand{\cfadomain}{labels and equalities}
\newcommand{\icfadomain}{\cfadomain}
\newcommand{\ccfadomain}{\cfadomain\ \continued}

\newcommand{\shareanalysis}{the shared memory}
\newcommand{\iflowanalysis}{\shareanalysis\ \continued}
\newcommand{\cflowanalysis}{\shareanalysis\ \continued}

\newcommand{\countvar}{\var}
\newcommand{\tp}{\textsc{cu}}
\newcommand{\var}{\mathcal{K}}
\newcommand{\numkey}{\textsc{con}}
\newcommand{\abstnum}{\mathcal{N}(\var)}
\newcommand{\gammanum}{\gamma_{\abstnum}}
\newcommand{\domnum}{\adom{\numkey}}
\newcommand{\cupnum}{\sqcup_{\abstnum}}
\newcommand{\botnum}{\bot_{\abstnum}}
\newcommand{\xinum}{\chi_{\abstnum}}
\newcommand{\initnum}{\ainit{\numkey}}
\newcommand{\nablanum}{\nabla_{\numkey}}
\newcommand{\addnum}{+^{\sharp}}
\newcommand{\minnum}{-^{\sharp}}
\newcommand{\syncnume}{\textsc{sync}_{\numkey}}
\newcommand{\syncnum}[2]{\syncnume(#1,#2)}
\newcommand{\concnum}{\gamma_{\numkey}}
\newcommand{\zeronum}{\xinum(\emptyset)}
\newcommand{\widnum}{\wid{\numkey}}
\newcommand{\Numkey}{\text{con}}
\newcommand{\Numdom}{\adom{\Numkey}}
\newcommand{\botNum}{\abot{\Numkey}}
\newcommand{\cupNum}{\aunion{\Numkey}}
\newcommand{\gammaNum}{\gamma_{\Numkey}}

\newcommand{\countdom}{interval and affine constraints}
\newcommand{\icount}{\countdom}
\newcommand{\ccount}{\countdom\ \continued}

\newcommand{\icontentanalysis}{\shareanalysis\ \continued}
\newcommand{\ccontentanalysis}{\shareanalysis\ \continued}

\begin{document}
\bibliographystyle{plain}
\author{J{\'e}r{\^o}me Feret \\
{\'E}cole Normale Sup{\'e}rieure \\
Harvard Medical School\\
jerome\_feret@hms.harvard.edu}



\title{Partitioning the Threads of a Mobile System}



\maketitle

\begin{abstract}
In this paper, we show how thread partitioning helps in proving properties of  mobile systems.
Thread partitioning consists in gathering the threads of a mobile system into several classes. The partitioning criterion is left as a parameter of both the mobility model and the properties we are interested in. Then, we design a polynomial time abstract interpretation-based static analysis that counts the number of threads inside each partition class.
\end{abstract}

\section{Introduction}

A mobile system is a pool of threads that interact with each other.
These interactions dynamically change the system by controlling both the creation and the destruction of links  between threads (by modifying the accesses to channels and/or modifying the spatial configuration).
These interactions also control the creation of threads.
The size of a mobile system may be unbounded.
A mobile system may describe telecommunication networks, reconfigurable systems, \emph{client-server} applications, cryptographic protocols, or biological systems. Several models exist according to the application field and the granularity of the observation level.

We use abstract interpretation \cite{c:thesis,cc:popl77} to derive abstract semantics, which are sound, decidable, but approximate. We use partitioning \cite{cc:popl79,bourdoncle} to separate the  threads according to dynamical information.  The partitioning criterion depends on both the model and the properties of interest. In models based on channeled communications (as in the -calculus \cite{milner:polyadic}), we can partition the threads according to the name of the channel they operate on. In models with explicit locations (as in \ambients\ \cite{ambients}), we can partition the threads according to their location in the system. When there are both channeled communications and locations (as in D- \cite{Dpi} or in \bioambients\ \cite{bio}), we partition the threads according to both the channel they operate on and their location.
In more complex cases, the partitioning criterion may be given manually.
For instance, in the \spicalcul, channels are not relevant, so we partition the threads according to the principals that share a session \cite[p:269]{feret:thesis} thanks to some end-user's annotations. Nevertheless, we believe that a better understanding of the problem 
should allow the automatic inference of these annotations.

Our analysis then counts automatically the number of threads inside  each partition class. To get an accurate analysis, we have to relate, for each computation step,  the partition classes of  the threads that interact and  the partition classes of the threads that are created. When analyzing mobile \ambients\ \cite{NiNi00popl}, these relations are given by the model.
This is not the case in less structured models, where a non uniform (i.e.~that distinguishes recursive instances) analysis \cite{feret:sas2000,feret:esop2002,feret:jlap,feret:thesis} of the dynamic linkage between threads is required. To make contents analysis and non uniform analysis collaborate, we locally partition computation steps \cite{mauborgne:rival05} 
according to some assumptions about the partition classes of the threads that interact. Then, we use a coalesced product between both analyses, so that if 
one detects that some assumptions are contradictory, the other ignores the corresponding interaction. 


We apply our framework to prove  automatically the absence of race conditions in a shared-memory with dynamic allocation written in the \picalcul. We also analyze precisely the relation between the contents of an \ambient\ and its location in the network. In the author's PhD.~Thesis \cite{feret:thesis}, we prove an authentication property \cite{BlanchetSAS02} in a cryptographic protocol \cite{Woo}   in the \spicalcul\ \cite{spi}.

\paragraph{Outline.}
We discuss related works in Sect.~\ref{related}.
We detail the contribution of this paper in Sect.~\ref{contribution}.
We give some examples in Sect.~\ref{examples}.
We give in Sect.~\ref{non-stan} a non-standard semantics for the \picalcul.
We define  both thread and step partitioning in Sect.~\ref{partition class}.
We derive a generic abstraction in Sect.~\ref{ai}.
We give an environment analysis in Sect.~\ref{environment}  
and a contents analysis in Sect.~\ref{occurrence}. 


\section{Related works}
\label{related}
In this section, we discuss some related works. 
\subsection{Control flow analyses} 
Our analysis requires an accurate description of the potential interactions between the agents. Many type systems \cite{hennessy.riely:resource-access} and control flow analyses \cite{nielson:journal,nielson:concur98} propose a uniform description of these interactions in which recursive instances cannot be distinguished. In \cite{feret:jlap,feret:sas2000,feret:esop2002}, we proposed non-uniform control flow analyses, which distinguish between recursive instances of names. 
All these analyses abstract away the properties about concurrency.
\subsection{Groups}
Groups \cite{cardelli00secrecy,cardelli00ambient} are used in type system to prevent certain communications.
Recursive instances of groups are distinguished. The communication of a name outside the initial scope of its group is forbidden. 
On the contrary, our analysis computes relationship between the partition classes of interacting threads. So we can analyze systems where a name first exits the scope of the thread that had declared it and then returns inside this scope.  
\subsection{Numerical domains and concurrency}
Numeric analyses are widely used to analyze concurrency properties such as mutual exclusion and non-exhaustion of resources.
Disjunctive completion-based domains are used  in \cite{HJNN99ai} to count globally the components in \ambients\ and  in \cite{NiNi00popl,gori:aplas} to count the components inside each \ambient. 
These domains ignore the algebraic structure of numerical properties. 
Consequently, these analyses are exponential in time.
In \cite{feret:jlap,feret:getco2000}, we use affine equalities to count the threads of \picalcul\ systems  in polynomial time.
This analysis counts threads globally, regardless of their linkage. 
In the present paper, we  use information about the dynamic linkage of threads to gather threads in partition classes. Then we count the number of threads inside each partition class. Our approach is model-independent \cite{feret:thesis}.
Besides, we can detect and prove history-dependent and spatial-dependent properties (e.g.~see Ex.~\ref{content}).
\subsection{Behavioral types}
Behavioral types can express complex concurrency properties such as the absence of race conditions. 
But, in \cite{igarashi.kobayashi:generic-type}, some properties involving several names  cannot be checked because of the abstraction (e.g.~see Ex.~\ref{twonames}). 
The type system in \cite{rajamani.rehof:behavioral-module,rehofpopl02} can express and check more properties, but the type checking algorithm does not always terminate, whereas our inference algorithm  does in polynomial in time.
Moreover, 
our occurrence counting and control flow analyses refine each other thanks to local trace partitioning. 
In Ex.~\ref{cfahelp}, we cannot analyze precisely mutual exclusion without the help of a precise control flow analysis.

\section{Contribution}
\label{contribution}
In this section, we describe the main contributions of this paper. 

This paper is a summary of the framework proposed in \cite[Chap.~10]{feret:thesis}. This framework is generic with respect to the model. In this paper,  we focus on systems that are written in the -calculus. The main contributions of this paper are the following:
\begin{enumerate}
\item \emph{thread partitioning}: in this paper, we partition the threads of a mobile system according to some semantics criteria;
\item \emph{local trace partitioning}: then, we provide an extended labeled transition system in which each  computation step is annotated with information about the partition classes of the threads that interact; this  allows several analyses to share information about the partition classes of the threads that interact;
\item \emph{control flow analysis}: we refine existing analyses \cite{feret:sas2000,feret:esop2002,feret:jlap,feret:thesis} so as to take into account the constraints about the partition classes of the threads that interact;
\item \emph{content analysis}: we propose a new analysis to count the number of threads inside each partition class; this analysis is parametric with respect to a numerical domain (we use the same domain as in the occurrence counting analysis \cite{feret:getco2000,feret:jlap,feret:thesis} that counts the number of threads in the whole system).
\end{enumerate}

\section{Examples}
\label{examples}

In this section, we give some examples to motivate our framework. 

\subsection{Our running example}

First, we introduce an example that is easy to analyze: we  prove that there are never two simultaneous outputs over the same channel in a shared memory written in the \picalcul.  We give a manual proof in order to stress the  properties that are useful during the analysis. The goal of this example is just to understand how the analysis behaves: we use this example all along the paper. 


We use  a version of the \picalcul\  inspired from
\cite{milner:polyadic,turner:thesis,cham}.
Let  be  an infinite set of variables and  be a finite set of labels. 
Let  be some variables,  be a label, 
and  be a tuple of variables.
The agent  denotes the parallel composition of two agents  and . It performs  and  simultaneously. 
The agent  binds the variable  to a fresh channel name in .
The agent  does nothing (it is usually omitted).
The agent   sends a message (i.e.~a tuple of channel names) via the channel the name to which the variable  is bound. 
The agent  waits for a message on the channel  to which the variable  is bound, and binds the tuple  of distinct variables to the received  names. The agent  is a \emph{resource} which replicates itself when  receiving messages.
Name restriction  and message reception  or  are the only variable binders.
We denote by  the set of the variables that are free in . 
Labels help in locating syntactic components. 
Moreover, the notation  stands for  where , , and  are fresh labels, and : it denotes an unbounded number of concurrent instances of .

{
\begin{example}[a shared memory]
\label{memory}
A shared memory with dynamic allocation of cells may be described  
in the \picalcul\ as follows:
\begin{tabbing}
\\
\;\=\\
\>\=\;\\
\>\\
\>\\
\\
\>\\
\>
\end{tabbing}
Whenever a message is sent via the channel name declared by the restriction  \pps{\memlaba}, a memory cell is allocated.
Three names are introduced. The name  encodes the contents of the memory cell: the contents of the cell are always output once over the channel named  (the name  denotes the initialization value); the names  and  encode respectively the capability to read and to overwrite the contents of the cell. 
The client is given the capability to interact with the cell \pps{\memlabc}.
The memory can deal with an unbounded number of read \pps{\memlabd} and write \pps{\memlabh} requests. 
A read request requires a return address to which the contents of the cell are forwarded (please note that we copy the contents of the cell once, so as not to lose them). 
A write request requires two arguments, the new contents and an acknowledgment address: the cell contents  are first removed and then replaced with  the new contents, the acknowledgment controls client requests sequentiality. 
An unbounded number of clients are created \pps{\memlabk}.
Each client creates a cell and performs an arbitrary number of read \pps{\memlabo} and write \pps{\memlabr} requests.

We want to prove that there is never more than one simultaneous output on any channel  opened by an instance of the restriction .
First, we propose a manual proof to give intuitions about our framework.
The analysis in this paper discovers this property automatically.
Let us denote by  the set of the names introduced by an instance of the restriction , we will prove that at any configuration of the system and any name : there is either no thread, or exactly one output (at program point \pp{\memlabb}, \pp{\memlabf}, or \pp{\memlabj}) on the corresponding channel.
For any configuration  and any name , we define  as  whenever the name  has not been allocated yet, and as  otherwise. We denote by  the number of threads at program point  that operate on the channel named . 
Now, we prove by induction over the history of the system that . At the beginning of the system, we have, for any , , so the property holds. 
When two threads at program points \pp{\memlaba} and \pp{\memlabm} interact, a fresh name  is allocated. Since this name is fresh, we have, before the interaction, ; after the interaction,  we have  and . This way, the property still holds. 
We now consider an interaction  between a thread  at program point  and a thread  at program point ; 
this interaction launches a thread at program point .
We consider  several cases according to the relationships among the channels on which these three threads operate. 
There are  cases: they may operate on the same channel, on two distinct channels (three cases), or on three distinct channels. 
We use a control flow analysis to detect which cases are possible: we detect that the only possible case is the case where the three threads operate on the same channel . 
During the transition,  is decremented and  is incremented ( is not changed when ), so the property of interest  still holds.\boxexample
\end{example}}

\subsection{More complex examples}

In this section, 
we describe more complex examples in order to illustrate some difficulties that can be tacked by our analysis.

{
\begin{example}[related names]
Our analysis can  abstract the usage of several names together. We consider the following system (adapted from \cite{igarashi.kobayashi:generic-type}) in the \picalcul:
\label{twonames}
\begin{tabbing}

\=\\
\hspace*{1cm}\\
\\
\hspace*{1cm}
\end{tabbing}
The server \pps{\twolaba} creates several objects. Each object is made of a lock \clock, a method \cm, and a return address \crr. 
Each session \pps{\twolabo} consists in locking the method, calling the method, receiving the returned value (which is abstracted away),  
and then releasing the lock. 
There is an unbounded number of clients \pps{\twolabi}. 
Each one creates an object \pps{\twolabj}, 
receives the lock, the method, and the returned address during three channeled communications, and performs an arbitrary number of sessions \pps{\twolabn}. 
We partition\footnote{This partitioning is made possible in the non-standard semantics where each name is tagged with the identifier of the thread that has declared it (see Sect.~{\ref{non-stan}}).}
 the threads according to the recursive instance of the resource that has declared the name of the channel on which each thread operates.
Our analysis detects and proves that there can never be more than one simultaneous call of the same method.  This result is beyond the reach of \cite{igarashi.kobayashi:generic-type}, because the names \clock, \cm, and \crr\  are not communicated during a single communication.
\boxexample
\end{example}}

\begin{example}[control flow dependence]
\label{cfahelp}
We now illustrate the importance of the control flow analysis.
We describe a doubly-linked list of cells as follows:

\begin{tabbing}
\=\=\\
\\
\\
\>\\
\>\\ 

\end{tabbing}
Each cell is encoded by three names: the name  encodes a backward pointer to the previous cell, the name  encodes the cell address (the contents are abstracted away), and  the name  encodes a forward pointer to the next cell.
Each cell is output on the channel named  \pps{\cfalabg}. 
Then, at program point , we pick a cell.
We collect its address , we follow the forward pointer, 
then we follow the backward pointer, 
and we collect the address  of the reached cell. 
The control flow analysis \cite{feret:sas2000} detects that the addresses
  and  are the same. This information is passed to the occurrence counting domain thanks to the local trace partitioning. Thus, we prove automatically that there is no simultaneous outputs over an instance of a channel named .

It may look a bit curious to use two variables for the same name. 
But, these kinds of things are common in automatically generated systems. 
With a more general point of view, this difficulty is similar to the problem of aliasing in data structures. \boxexample
\end{example}

{
\begin{example}[a -semaphore]
Our analysis is not limited to the detection of mutual exclusion.
In the following example: 

 our analysis detects automatically that 
there are never more than two simultaneous outputs over an instance of the channel .
Besides, our analysis detects and proves the number of simultaneous outputs without requiring a bound on the number of copies that have to be distinguished by the analyzer. 
\boxexample
\end{example}}

{\begin{example}[synchronous communications]
Content analysis can also refine the control flow analysis.
In the following system:

the content analysis detects that, for each instance, the thread at the program point \pp{\synlabb} (resp.~\pp{\synlabf}) and the thread at the program point \pp{\synlabc} (resp.~\pp{\synlabe}) are in mutual exclusion. 
The control flow analysis uses this information to prove that the variable  (resp.~) can only be bound to a channel opened by the restriction  (resp.~).
\boxexample\end{example}}

\subsection{An example in mobile \ambients}

Our last example is written in another process calculus to illustrate that our framework is generic.

In mobile \ambients\ \cite{ambients}, 
a system is described by a hierarchy of named sites , called \ambients\ ( is a name,  is a label, and  is a process).
\Ambients\ may contain some other \ambients\  and some agents // that provide them the capability to move in the hierarchy of \ambients\ or to open  some \ambients\ 
 (when an \ambient\ opens another one, the former \ambient\ gets the contents of the later). These interactions are controlled both by \ambient\ names (the name of the  target \ambient\ and the name occurring in the capability must be the same) and by spatial constraints. 
These interactions are described by the following reduction rules:
 ,  , and 
.
\Ambients\ are also fitted with communication primitives: the agent   waits for a message (that can be either a name or a capability path), whereas the agent  sends a message. 
These communications are not channeled because 
threads can communicate only when they are in a same \ambient.
Both \ambients\ and \ambient\ names can be created dynamically. As in the -calculus, we use guarded replication: the agent  duplicates itself when receiving a message and the agent  duplicates itself when opening another \ambient.
\begin{example}[the contents of an \ambient]
\label{content}
A \emph{client-server} protocol  may be described in the \ambient-calculus as follows:
\begin{tabbing}
\\
\=\=\\
\>\>\=\\
\=\=\=\=\\
\>\>\>\\
\>\>
\end{tabbing}
In this protocol, some packets are created \pps{\amblabj}. They are initially located in the \ambient\ . Each packet is identified by a fresh name . The packet contains some routing information to enter the \ambient\ . Once inside the server \ambient, the packet expels an \ambient\  in order to communicate the name of the packet to the server.
The server may open this \ambient\ \pps{\amblabb}, receive the name of the packet \pps{\amblabc}, and create an \ambient\ \pps{\amblabd} that enters the packet. Then the packet opens \pps{\amblabl} this \ambient\ to receive the capability to return inside the \ambient\ .
In this example, we abstract away what is happening to the packet while it is in the server domain. 


We partition the threads (both agents and \ambients) according to their location and the location of their surrounding \ambient. 
Then, we count the number of threads inside each class of the partition.
Our analysis discovers   the contents of the packet according to its position in the network. 
For instance, we detect that whenever the packet is inside the \ambient\ : 
it contains only threads at the program points \pp{\amblabd}, \pp{\amblabk}, \pp{\amblabl}, and \pp{\amblabm}; 
moreover, either there is exactly one thread 
at each program point \pp{\amblabk}, \pp{\amblabl}, and \pp{\amblabm}, or 
no threads at these three program points.
Similar information are inferred for the other potential locations of the packet.
We notice that our analysis loses all information about the number of threads at program point \pp{\amblabd}, because it cannot infer that for a given packet, only one instance can receive the name of the packet. But since we detect that only one can be opened, this has no influence on the inference of the other properties.
As in Ex.~\ref{memory}, we require an abstraction of the local history of each packet to reach this accuracy level:
we count the number  of each kind  of transition,
 we also consider the variables  that are defined as  if , and  otherwise. \boxexample
\end{example}

\section{Non-standard semantics}
\label{non-stan}

To prove the properties that interest us, we need to distinguish recursive instances of threads. 
Standard semantics are not convenient, because the -conversion breaks the relations between the threads and the name of the channels that they open. In this section, we recall a non-standard semantics \cite{feret:sas2000,feret:jlap,feret:thesis}. This semantics is more concrete: each thread is annotated with information about both its history and the history of the names that it handles. 


\subsection{Notations}
We consider a closed mobile system  (i.e.~) in the \picalcul.
We may assume  that each variable is bound  exactly once in the system (either by a name restriction or by an input).
We may also assume that syntactic components  are labeled with distinct labels.
For any label , we denote by   the subprocess the first action of which is labeled with  .
We define  as  if   matches , as  if   matches , and as  if   matches .
Besides, with the same notations, we define , , and . 
For any process , we define the set  of the labels of the threads that are launched in , 
, 
, 
, and 
.
For any label , we denote by  the set of the variables that are free  in the threads at program point .
Thus, we define  as .



\begin{figure*}[t]
\subfigure[Non-standard initial configuration.]
{\begin{minipage}[c]{\linewidth}

\end{minipage}}

\subfigure[Non-standard transition system.]
{\begin{minipage}[c]{\linewidth}


\vspace*{5mm}


\end{minipage}}
\caption{Non-standard semantics.}
\label{non-standard semantics}
\end{figure*}


\subsection{Semantics}
We define a non-standard semantics in which both threads and channel names are tagged with the history of their creation. 
History markers  are sequences of labels in .
Markers encode the history of the replications which have led to the creation of thread instances. 
The markers of initial threads are . 
When a computation step does not involve fetching a resource,
markers are just passed to the continuations; when a resource is fetched, the new instance is tagged with   where  and  are respectively  the label and the marker of the output thread. 

Then, we stamp each  name with  the marker of the thread  which has declared it. Thus, a channel name is a pair  composed of a variable  and a marker , which means  that this is the name of the channel that has been opened by the restriction  of a thread tagged with the marker  .

A \emph{configuration} of the system  is  a set of \emph{thread instances}. 
Each thread instance is a -tuple composed of a \emph{label}   that denotes a syntactic component, an unambiguous \emph{marker} , and an \emph{environment}  which specifies the channel names to which free variables are bound.
Thread instances are created at the beginning of the computation and when agents interact. 
The function   applied to a subprocess, a marker, and an environment, collects all the threads that are spawned when a continuation is launched: we set 
 , where,  maps 
any  to ,  
and any  to .
This simulates name restriction by binding any new  variable  to the name of the channel opened by the restriction  of a thread the marker of which is .
The initial state and computation rules are given in Fig. \ref{non-standard semantics}. The correspondence between the non-standard and the usual semantics  is proved   in \cite{feret:jlap,feret:thesis}.



\begin{example}[\cnonunu]
We apply our non-standard semantics with our shared memory example (see.~Ex.~\ref{memory}). We obtain the initial state  where:

The thread  is a resource that can allocate memory cells, the thread  can interact with the thread  to create clients recursively. Since these three  threads  are in the initial state, their thread marker is . 

We create a first client by making the threads  and  interact. 
We obtain the state , where:

The thread  
allows the creation of further clients 
and the thread  describes a client that can allocate a memory cell. 
We create a second client by making the threads  and  interact. 
We get the state , where:

The thread  
allows the creation of further clients 
and the thread   describes the second  client. 
Both clients are identified by their thread markers  and . Besides, the link between threads and the channel names that they handle is explicit: the thread  can operate on the name , whereas the thread  can operate on the name .
\boxexample\end{example}

\section{Thread partitioning and trace partitioning}
\label{partition class}

In this section, we first partition the threads of the system in several partition classes. Then we partition computation steps according to some relations about the threads that are involved. As a result, we obtain an extended labeled transition system.

\subsection{Thread partitioning}
Let  be a finite set of keys. 
Our analysis is parameterized by  a function  mapping each program point label  to a function in . 
Then, we partition the threads  in a configuration according to the value  of the variable  for each key . 
We can also partition threads according to the markers of their names (we focus on partitioning according to full names to simplify the presentation.).
For example, to prove the absence of race conditions, 
we gather the threads that operate on the same channel (we define   as  and  as ).
In \ambients, we partition threads in accordance with their location and the location of their surrounding \ambient\ (thus,  contains two keys). 
We know that: whenever two threads are in the  same \ambient, the location of their surrounding \ambient\ is the same (partitioning the threads also 
according to the location of their surrounding \ambient\ allows for a more precise  partitioning at the abstract level). 
We denote by  a  set of keys, such that:
for any configuration , for any threads  and  in the configuration , if,
for any , , then,  for any , .
This implication will be useful whenever we know that two threads are in the same configuration but in distinct partition classes.

Each partition class is identified by a function , called \emph{computation unit}.
We denote by  the set  of all computation units.
There may be an unbounded number of computation units. 
We gather them into a finite set of abstract computation units by abstracting away the information about markers: 
we define the set  of abstract computation units as . The abstraction function  maps each computation unit   to the abstract one .


\subsection{Local trace partitioning}
\newcommand{\vartrans}{\mathcal{T}(\lrec,\leme)}
We consider a computation step . We denote by  and by  the threads that interact in the computation step . 
The thread  launches one thread for each label   in the set  and the thread  launches  one thread for each label  in the set . We denote by  the cardinal of the set  and by  the cardinal of the set . 
Thus, the computation step  involves  threads. 
Each of these threads is denoted by a pair  where  is the label of the thread program point and  is equal to  when this thread is related to the input  thread or to  when this thread is related to the output thread. This way, we denote by 
 the set . 
\newcommand{\abstractcontext}{\textsc{context}}
\newcommand{\classes}{(\vartrans)_{\sim}}
\newcommand{\classede}[1]{[#1]_{\sim}}

To get a more precise analysis, 
we partition the set of computation steps according to some properties about the computation units of the threads that are involved in these computation steps.
We denote by  the set of pairs  such that  is an equivalence relation\footnote{Given an equivalence relation  over a set ,  denotes the equivalence class  of   and  denotes the set  of equivalence classes.}  in  that relates the threads that share the same computation unit  and  maps each equivalence class to its abstract computation unit.
Intuitively, the relation  means that the thread denoted by the pair  and the thread denoted by the pair  are in the same computation unit; moreover,  is the abstract computation unit of the thread denoted by the pair . 
More formally, we denote by  the function which maps any pair  to the computation unit of the thread denoted by the pair .
Then, we define the abstraction function  which  maps each computation step to its partition case as: 
, 
where  is defined as  if and only if .



\section{Abstraction}
\label{ai}
In this section, we use the abstract interpretation framework \cite{c:thesis,cc:popl77} to design a generic abstraction of transition systems. 

\subsection{Reachable states}
We denote  by  the set  of all configurations, by  the set of pairs 
in , and, for any finite set  of variables, by  the set of  marker/environment (over ) pairs.
We are interested in , the set  of all configurations that are reachable through a finite computation sequence.
The set  is the least fixpoint of the -complete endomorphism  on the complete lattice , where  is defined as .
This least fixpoint is usually not decidable, so 
 we use a relaxed version of the abstract interpretation framework
\cite{cc:frameworks}  to compute a sound---but not necessarily complete---approximation of it.





\subsection{Generic abstraction}
We choose an \emph{abstract domain}, which is  a set of abstract symbolic properties about configurations.
It captures  the properties of interest and abstracts away the other properties. Each abstract property is mapped to the set of the concrete elements which satisfy this property by a  concretization map . The abstract domain is fitted with several primitives to handle its elements. 
An abstract union  gathers the information described by several abstract elements. It satisfies: . 
We also need an abstraction  of the initial configuration (i.e.~).
To simulate computation steps in the abstract, we introduce an abstract operator .  
This operator partitions each transition into several sub-cases: given an abstract property  and a sub-case , the set  contains all the states  that are reachable from any state  by a computation step  such that .
An abstract element  such that   provides the basis for our abstract iteration. Finally, we use a widening operator  to ensure the termination of our analysis. It satisfies ; moreover,  
for any sequence , the sequence  that is defined by  and  for any , is ultimately  stationary.
We do not use narrowing because, we iterate only functions  that satisfy: 
.
\begin{definition}
Any tuple  that satisfies these assumptions is called an abstraction.\end{definition}

Given an abstraction , we define the abstract counterpart  of the function 
 as the function that maps any abstract element  to the abstract element .
The function  satisfies the soundness condition , . 

Then, we extrapolate the iterates of .
We define the abstract iteration \cite{cc:frameworks,cc:galois-widening} of  as   
 and  for any .
The abstract iteration 
is ultimately stationary.
Moreover, its limit  satisfies  because  is monotonic.

\subsection{Coalesced product}
\label{product}
Several abstractions can be composed to refine each other.
We consider two abstractions:

We define the coalesced product between the abstractions  and  as the tuple , 
where the domain  is defined as ; 
the concretization  is defined as the intersection of the two concretizations (i.e.~);
the abstract union , the element , the widening operator , and the abstraction  of the initial state  are all defined pairwise; the abstract element  is defined as 
 whenever either  or 
, and as
 otherwise.
The coalesced product between  and  is also an abstraction. 
We stress on the fact that the coalesced product is more powerful than a mere product. Thanks to the extended labeled transition system, several analyses can share 
constraints about the threads that are involved 
in computation steps. This way, analyses refine each other. 

We use our framework with the coalesced product between an analysis of the dynamic linkage between  threads (Sect.~\ref{environment}) and an analysis of each computation unit contents (Sect.~\ref{occurrence}).

\section{Environment analysis}
\label{environment}

\newcommand{\allconstraint}{\textit{Constraints}(\Vrec,\Veme)}
\newcommand{\constraintset}{C}
\newcommand{\constraint}{c}

We design an analysis of the dynamic linkage between threads. 
This analysis aims at capturing the relationship between the computation units of the threads that are involved in computation steps.


\subsection{Abstract domain}
Our goal is to map each program point label to an abstraction of the set of the marker/environment pairs which may be associated to any thread at this program point at run-time. 
So, we introduce for any set of variables   a parametric abstract domain    of properties.
The concretization  of a property  is 
a set of marker/environment pairs m in .
The operator  maps each finite set of properties to a weaker
property: for each finite set , , . 
The element  is an abstraction of the empty set 
(i.e.~we assume that ).
The operator  is a widening operator \cite{cc:galois-widening}.
Then, our main environment abstract domain 
is the set of the functions that map each program point label  that occurs in the system  to an element in . 
The domain structure (, , and )  is defined point wise. 
The abstract domain   is related to  by
the concretization function  that maps each abstract property
 to the set of  configurations
 such that .

\begin{example}[\icfadomain]
\label{cfadomain}
We propose a simple \emph{cfa} domain to analyze the shared memory example (see Ex.~\ref{memory}).  In this example, the names that occur in computation units are never communicated. As a consequence, equality  among variables \cite[Sect.~5.1.1]{feret:esop2002}  and a uniform approximation of the control flow \cite{nielson:journal,nielson:concur98} are enough. In general, numerical abstractions of markers \cite{feret:sas2000,feret:esop2002}  are required. All these analyses \cite{nielson:journal,nielson:concur98,feret:esop2002,feret:sas2000} are polynomial time.

Given a set  of variables, we introduce the abstract domain 
 as the set . Each abstract element  denotes a set  of functions. More precisely,  and . This way, in the abstract element , the function  describes constraints about the label of values and the set  describes constraints about equality and inequality relations among values.

We define a partial order  over  as: , for any , and  if and only if both  and . 
We notice that the concretization  is monotonic with respect to . Several abstract elements may have the same concretization, nevertheless, for each abstract element , the set of the elements  such that  has a least element that we denote . The element  is called the normal form of . We denote by  the set  of all normal forms. We denote by  the restriction of  to . Each subset  has a least upper bound with respect to , that we denote by . 

The domain  is a good candidate for . 
We also set , 
, and . Since  is a finite domain, we define the widening operator  as .
\boxexample\end{example}


\begin{figure*}[p]
\subfigure[Initial configuration abstraction.]
{\label{initenv}
\begin{minipage}{0.99\linewidth}

\end{minipage}}
\subfigure[Abstract \textsc{post} operator.]{
\label{postenv}
\begin{minipage}{0.99\linewidth}
 Let  and  be two program point labels in  , such that
, , and such that the length of the lists  and  is the same.
We denote   and . 
Let  be a partition case and  be an abstract element.

We define:
\begin{itemize}
\item  and ;

\item 
\item 

where  ,

\item , 


where ;


\item ;


\item _=_{\not =}_\text{lbl}, 
where:


,


_=,


_{\not =},


_\text{lbl};
\item  ;

\item 

where 
\end{itemize}
\end{minipage}}
\caption{Environment analysis.}
\label{abstractenv}
\end{figure*}


Now, we simulate the non-standard semantics in the abstract.
\subsection{Initial state}
At the beginning of the concrete computation, 
the configuration contains one thread at each program point the label of which is in the set . Thread markers are  and environments map each free variable  to the name . In the abstract, we require two primitives.
First, the abstract property  is the abstraction of the pair . This means that:  .
Then, the  primitive  simulates name allocation. 
Let  be a set of variables and  be a fresh variable. 
The primitive  is a function in  and, for any abstract element , 
the concretization  contains at least all pairs   such that (i) , (ii) , and (iii) .

\begin{example}[\ccfadomain]
In our simple \emph{cfa} domain (see Ex.~\ref{cfadomain}), 
the primitive  can be defined as  (where, in the first component, the symbol  denotes the function defined over the empty set). Moreover, we define  by: 
  and by  where  and . This means that we know that the channel has been opened by an instance of a restriction  and we know that this value is fresh. Then, we apply our closure .
\boxexample\end{example}

The abstraction  of initial state is defined in Fig.~\ref{initenv} as the function that maps any program point  to the abstract element  whenever 
 and ; 
and to the abstract element  otherwise.

\begin{example}[\cflowanalysis]
We apply our analysis with the simple \emph{cfa} abstract domain (e.g.~see Ex.~\ref{cfadomain}) on the shared memory system (e.g.~see Ex.~\ref{memory}).
We obtain that: , , , and  
for any .
\boxexample\end{example}

\subsection{Transition step}
In the concrete, an interaction involves two threads:  at a program point labeled with    and  at a program point labeled with . 
The first thread either inputs a message or fetches a resource; 
the second thread outputs a message.
We simulate such a transition  in the abstract in Fig.~\ref{postenv}. 
We start from the abstract element  and we define the pair  as .

\begin{example}[\cflowanalysis]
We apply our analysis with the simple \emph{cfa} abstract domain (e.g.~see Ex.~\ref{cfadomain}) on the shared memory system (e.g.~see Ex.~\ref{memory}).
As an example, we focus on the interaction between a thread at program point \pp{\memlabe} and a thread at  program point \pp{\memlabj} in any calling context .
We also assume that the element 
 is equal to  and 
that the  element  is equal to .


We want to prove that:
\begin{itemize}
\item  both that interact and the thread that is launched at program point \pp{\memlabf} belong to the same partition class (i.e.~, );
\item the thread that interacts at the program point \pp{\memlabe} and the thread that is launched at the program point \pp{\memlabg} do not belong to the same partition class (i.e.~);
\item  and that the abstraction of the computation unit of interacting threads is  (i.e.~). 
\end{itemize}
Then, we want to abstract the environment of the thread that is launched at program point \pp{\memlabf}.
\boxexample\end{example}

\subsubsection{Extending environments}
First, we collect information about the potential binding of the  threads  and . We denote by  the element  and by  the element . 
In the concrete, a new thread marker is computed when the input thread is a resource. 
We require a primitive  to simulate the allocation of this fresh marker in the abstract. 
For any set  of variables, any abstract element , and any label , the abstract element  satisfies: the concretization  
contains at least all pairs  such that 
 .

\begin{example}[\ccfadomain]
In our simple \emph{cfa} domain (see Ex.~\ref{cfadomain}), 
we do not track any information about thread markers.
So we define the element  as .
\boxexample\end{example}

Then, we define  as  whenever the thread  is a resource (i.e.~if ), and 
 as  otherwise.

\begin{example}[\cflowanalysis]
In our example, we have:

\boxexample\end{example}

We now extend the environments to deal with the variables introduced during the interaction.
In the concrete, the threads  and   bind some new variables to some names. 
The sequence  is the sequence of the variables that are bound by name passing.
We use an abstract primitive  to create these variables without any information about them. 
For any set  of variables, any variable , and any abstract element , the abstract element  satisfies: . 

\begin{example}[\ccfadomain]
We can define the primitive  by  and by . 
\boxexample\end{example}

Thus,  we define  by . The set of the variables that are 
bound by name restriction in the thread  is given by , whereas the one in the thread  is given by . We introduce these variables thanks to the primitive . We define  and  .

\begin{example}[\cflowanalysis]
In the shared memory example, the variable  is bound during the communication. 
Moreover, since  no variable is bound by a name restriction, the abstract element 
 is equal to   
where , and the abstract element 
 is equal to .
\boxexample\end{example}

To get precise relations between the binding of former variables and the binding of the variables bound by the communication, we gather the two descriptions  and . 
For that purpose, we assume that we are given, for any subset of variables ,, 
an abstract domain  of properties about 
sets of pairs of marker/environment pairs.
Each property in  is related by a concretization function  to the elements of  which satisfy this property.
We also introduce an element  that satisfies .
The domains , , and  are related by the following primitives. 
The primitive  simulates pair construction.
For any  and any , the element  satisfies: ;
the primitives  and  abstract the projection functions: 
for any , the elements  and  satisfy:
 .

Then, we gather the two properties thanks to the abstract product . 
We define  as . 
We denote by  the pair of sets of variables such that . The element  abstracts a set of pairs . We introduce some formal variable to denote the channel names that are bound  either in the environment , or in the environment . We introduce the set  of formal variables. 

\begin{example}[\ccfadomain]
We can define the abstract domain  as . 
The concretization  maps each abstract element  to the set of pairs  such that the map  belongs to . 
The bottom element  can be defined as .

The primitive  maps 
 to  and any other element  to the element . 
The primitive   maps  to 
 and any  other element  to the element . 
The abstract product is defined by: 
 and by 
, where  and .
\boxexample\end{example}



\begin{example}[\cflowanalysis]
In our example, the abstract element  is equal to  where the function   is defined as the following function:

\boxexample\end{example}





\subsubsection{Collecting new constraints}


Now, we collect the set  of all the constraints that we have about the environments  and .
The formal variable   denotes the value  of the variable  in the input thread and the variable  denotes the value  of the variable  in the output thread.
We consider three kinds of constraints:
the constraint   where  means that the formal variables  and  denote the same channel name: we write  if and only if ;
the constraint   is the negation of the constraint : we write  if and only if ;
the constraint , where  and  means that  is the label of the name that is denoted by the formal variable : 
we write  if and only if 
 matches .
We denote by  the set of all such constraints.
First, we collect the constraints due to communication: 
the constraint  encodes the fact that both threads interact over the same channel and 
the set  of constraints encodes name-passing. 
Now we consider the constraints given by :
for any pair  such that ,  
the set of constraints   encodes the fact that the threads that are denoted by the pairs  and  share the same computation unit; 
conversely, when  is not a singleton, we cannot extract constraints from non-equality among computation units, but  
when  is a singleton , for any pairs  such that , the constraint  encodes the fact that the threads that are denoted by the pairs  and  are not in the same computation unit; 
last, for any pair , the set of constraints  models the fact that  
is the abstract computation unit of the thread denoted by the pair .

\begin{example}[\cflowanalysis]
In our example, we get the constraint set , where:
 and , , and  are defined as in Fig.~\ref{postenv} (they depend on the pair ).
\boxexample\end{example}





We can now define  as , where the primitive  is used to enforce some constraints in abstract elements. For any set  of constraints and any abstract element , the element  
is such that the set   contains at least all pairs  that satisfy both   and  . 

\begin{example}[\ccfadomain]
We can define the primitive  as follows:

where



\noindent We stress that the normalization step is crucial to propagate information, and especially to detect unsatisfiable constraints.
\boxexample\end{example}

\begin{example}[\cflowanalysis]
First, we prove that the interaction is not possible as soon as 
, , , or   :
\begin{itemize} 
\item If , we have  . Then,  .
\item If , we have  . 
But . 
Then, .
\item 
If , we have .
Then,  matches  with , , and .
Since , we have .
\item 
If  , 
 . Then  matches  with 
. So 
.
\end{itemize}

Until the end of the section, we assume that: , , , and . 

With these assumptions, we have:
\begin{itemize}
\item , 
\item , 
\item , 
\item .
\end{itemize}
Then,  
where the function  is defined as 

Since the constraint  belongs to 
the set  of constraints, we can deduce that the abstract element  is equal to , where .
\boxexample\end{example}

\subsubsection{Updating the abstract element}

Whenever we have , the constraints are not satisfiable, so we set . Otherwise, we first separate information about the input and the output threads, then we update the information about the threads that are launched. For that purpose, we use a primitive   to simulate garbage collection: for any sets  of variables such that , and any abstract element , the  abstract element  satisfies the property .


\begin{example}[\ccfadomain]
The primitive  can be defined by   and  by .
\boxexample\end{example}

We define the element   by , where  whenever the label  belongs to  the set , 
  whenever 
the label  is in the set , 
and   otherwise.

\begin{example}[\cflowanalysis]
In our example, the function  satisfies:   is equal to the element , where . This is a precise abstraction of the environment of the thread that is launched at the program point \pp{\memlabf}.
\end{example}

\subsection{Soundness}

Thm.~\ref{envsound} states the soundness of our environment analysis.
\begin{theorem}
\label{envsound} is an abstraction.
\end{theorem}



\section{Contents  analysis}
\label{occurrence}


Contents analysis counts both the number of threads inside each computation unit and the number of computation steps in the history of computation units. 
Its main goal is to detect mutual exclusion of threads inside computation units.

\subsection{Abstract domain}
Let  be the  set of variables .
We use these variables to abstract both the contents and the history of computation units.
Given a computation unit: the variable  counts the occurrence number of threads at the program point   in this computation unit,
 the variable  counts the number of computation steps labeled with  that have modified this computation unit, and the variable  is equal to  if at least one computation step labeled with  has modified the contents of this computation unit and  is equal to  otherwise.

We assume that we are given an abstract domain  to abstract functions in .
Each abstract property is related to the set  by a  concretization .
An operator  maps each finite set of properties to a weaker
property: for each finite set ,
, . 
The element  is the abstraction of the empty set (i.e.~we have ).  The operator  is a widening \cite{cc:galois-widening}.
Then, our main  abstract domain 
 is the set  of the functions mapping each abstract computation unit to an abstraction of its contents.
The structure (, , and )  is defined point wise. 
We define the concretization  of any abstract element  as the set of  all configurations  such that for any concrete computation unit ,  is an approximation of the contents of . More precisely, we require that there exists  a map   such that , the number of  threads in  at the program point   in the computation unit  is equal to . We also require that, for any , we have  whenever , and   otherwise (we require no further properties about the variables  and ).

\begin{example}[\icount]
\label{intequ}
We propose to use a reduced product between the interval domain \cite{cc76} and the affine equality domain \cite{karr}. This way, our abstract domain expresses constraints either of the form , or of the form . Interval constraints (of the form  where  and ) express properties of interest. Affine equalities (of the form  where , and  express more complex properties, such as mutual exclusion. This allows for more precise calculations in the interval domain. Moreover, affine equalities capture relations when some threads are created and some others are consumed. To get a good precision, we need  to avoid undetermined forms (when two unbounded values are subtracted) as much as possible.  So, we use the approximate reduced product given in \cite[Chap.~9]{feret:thesis}, in which each primitive can be computed in  operations. Thus, we get a polynomial analysis. 

Other domains could have been considered. 
The polyhedron domain  \cite{ch} is too  expensive.
The octagon domain   \cite{mine:thesis,mine} cannot express the affine invariants that are required when dealing with semaphores that both involve more than two agents and several tokens.
Abstract multi-sets \cite{HJNN99ai,NiNi00popl} are exponential  in time.
\boxexample\end{example}

\begin{example}[\icontentanalysis]
We apply our content analysis on the example of the shared-memory (e.g.~see example \ref{memory}) with the reduced product of intervals and affine equalities (e.g.~see example \ref{intequ}).
We denote by  the result of our analysis. 
The constraint system   describes the usage of channels opened by the instances of the restriction .
Our goal is to prove that the system  entails both the affine equality constraint  and the interval constraint .
This means that either the channel has not been opened yet (i.e.~), or the channel has been opened (i.e.~) and there is exactly one output over it at the program point \pp{\memlabb}, \pp{\memlabf}, or \pp{\memlabj} (since ).
\boxexample\end{example}

Now, we simulate the non-standard semantics in the abstract.

\subsection{Initial state}
\begin{figure*}[p]
\subfigure[Initial configuration abstraction.]{
\label{initocc}
\begin{minipage}{0.99\linewidth}

\end{minipage}}
\subfigure[Abstract \textsc{post} operator.]{
\label{postocc}
\begin{minipage}{0.996\linewidth}
Let  and  be two program point labels in  , such that
, , and such that the length of the lists  and  is the same.
Let  be a partition case and  be an abstract element.
We define  by , whenever there exists  such that 
; otherwise, we define it by 
, where, for any :
\begin{itemize}
\item , 

 
\item  

\item  
\item 

\item  and ;
\item ;
\item .
\end{itemize}
\end{minipage}}
\caption{Contents analysis.}
\label{absocc}
\end{figure*}
At the beginning of the concrete computation, 
 each variable  is bound to  the name . 
Besides, the configuration contains one thread at each program point the label of which is in the set . 
Thus, a thread at program point  is in the computation unit .
So, at the beginning of the computation, a computation unit  is either empty, or it contains a thread at each program point  such that . 
In the abstract, we introduce a primitive . For any set , we denote by  the characteristic function of  which  maps any variable  to  whenever , and to  otherwise. We require that .

\begin{example}[\ccount]
In our abstract domain, the primitive  maps any set  of variables, to the set of constraints .
\boxexample\end{example}

The abstract state  is defined in Fig.~\ref{initocc} as the function 
mapping any abstract computation unit  to the element  .

\begin{example}[\ccontentanalysis]
In the shared memory example (e.g.~see Ex.~\ref{memory}), the abstract element  is equal to:

since we have: , , and .
\boxexample\end{example}

\subsection{Transition step}
We consider an abstract element , two program point labels  and , and a transition sub-case . We simulate in the abstract any computation step  that matches , where  (e.g.~see Fig.~\ref{postocc}).

\begin{example}[\ccontentanalysis]
As a running example, we simulate an interaction between a thread at the program point \pp{\memlabe} and 
a thread at the program point \pp{\memlabj}. 
We start from an abstract element  such that
the system  is made of both the constraints  and .

We set  and .
Thanks to the control flow analysis, we only take into account the transitions where , , , , and . Indeed, results coming from the other cases are ignored thanks to the coalesced product (e.g.~see \ref{product}). 
\boxexample\end{example}

\subsubsection{Is the step possible ?}
First, we check whether the computation step is possible, or not. 
Whenever we have , 
there must be a computation unit  in  such that both   and  contains at least one thread at the program point  and one thread at the program point ; 
whenever we have ,
there must be two computation units  and  such that: for any ,  and   contains at least a thread at the program point .
To check these properties, we require an abstract primitive  to check whether some variables may simultaneously take a non-zero value.
For any set  of variables and any abstract element , 
the set  should be included in the concretization .
If there exists  such that 
 is equal to the bottom element , 
the computation step is not possible, so we define  as .
Otherwise, we  update the abstraction of any computation unit involved in the computation step.




\begin{example}[\ccontentanalysis]
We know that i)  and ii) .
We compute  that is defined by the expression   .
The system  is equivalent to the system: 

 By reduction, we obtain that 
 is equivalent to the system:
  
This means that the interaction is only enabled when the cell has already been created () and when both interacting threads are in the computation unit ( and ). 
In this case, there is no thread at either the program point \pp{\memlabb}, or at the program point \pp{\memlabf} (). 
\end{example}

\subsubsection{Abstracting the former contents of partition classes}

Let us consider a class . 
The class  denotes a computation unit  that is transformed during the computation step. 
We first compute an abstraction  of the contents of  before the computation step. 
In the case where there exists a pair  and a key  such that ,  the computation unit maps a key to a fresh name, 
so we can deduce that the computation unit  has been created during the transition step. In such a case, we define  as . Otherwise, we take into account the abstraction of the computation unit and the threads that are required to enable the computation step: we define  as .




\begin{example}[\ccontentanalysis]
First, we compute the contents of partition class  before the computation step.
The  element   is equal to 
, so the system  contains the constraints  , , 
, and 
. By reduction, we obtain that the system   is given by the constraints , , .  
This means that the interaction is only enable when the cell has already been created () and if the interacting threads are in the computation unit ( and ). 
In such a case, there is no thread at the program point \pp{\memlabb} or at the program point \pp{\memlabf} (). 
\boxexample\end{example}


\begin{example}[\ccontentanalysis]
We now consider a case when  a computation unit is necessarily empty.
We simulate an interaction between a thread at the program point
\pp{\memlaba} and a thread at the program point \pp{\memlabm}.
This way, we set  and .
Thanks to the control flow analysis, we only take into account the transitions where   and . 
The interaction launches a thread at the program point \pp{\memlabb}.
But, we have  , , and .
So .
Thus we can conclude that  is equal to . This way, the thread is launched in an empty computation unit.
\boxexample\end{example}



\subsubsection{Abstracting the evolution of partition classes}

Then, we compute the set of labels of the threads that are created and consumed in the computation unit .
The input thread is consumed in  only if it is not a resource and if it was in the computation unit : so we define  as  if both    and , and as 
   otherwise. The output thread is always consumed (we only check whether it is in , or not): so we define  if , and 
  otherwise. The threads that are created during the computation step are dealt with the same way: we define , for any . 

\begin{example}[\ccontentanalysis]
In our running example, the set 
 is equal to , the set  is equal to . Since the constraints  and  are satisfied, we can deduce that the set  is equal to . Last, the set 
   is empty.
\boxexample\end{example}

The abstraction  of the contents of the computation unit  after the computation step can then be defined as , where  and  are sound counterparts to the point wise addition and to the point wise subtraction. More precisely, for any  and , we have: 
, and the concretization  contains at least all functions  such that: , , and for any , . 

\begin{example}[\ccount]
\hspace*{-1mm}The primitives  and   are both computed pair-wise over the system of affine constraints and over the system of interval constraints. More details can be found in \cite[Chap.~9,\;Sect.~9.3.1]{feret:thesis}..
\boxexample\end{example}

The last step consists in updating the local history of computation units. 
We introduce a primitive . The function  increments, in the abstract, the value of variable  and sets the value of variable  to . So, for any function , the function  that maps  to ,  to , and any other variable  to  should be an element of the concretization . Thus, we define  as . 

\begin{example}[\ccount]
We can define the primitive  by using the usual transfer functions for assignments in interval constraints (e.g.~see \cite{cc76}) and in affine equalities (e.g.~see \cite{karr}).
\boxexample\end{example}

\begin{example}[\ccontentanalysis]
In our running example, the system 
 is given by the constraints , ,  , 
, .  
Then,  is given by the constraints 
, ,  , 
, , , and .
\boxexample\end{example}

\subsubsection{Updating abstract elements}
We are left to update the abstraction of the computation units whose 
abstract computation unit is . We define, for any ,  as .

\begin{example}[\ccontentanalysis]
We recall the fact that the system  entails the affine constraints  and the interval constraint . 
The class  is the only one such that 
. Moreover,  the affine constraints  and the interval constraint  are also entailed by the system . The analysis discovers that these constraints are invariant.
\boxexample\end{example}

\subsection{Soundness}

Thm.~\ref{contsound} states the soundness of our content analysis.

\begin{theorem}
\label{contsound}
 is an abstraction.
\end{theorem}


\section{Conclusion}

We have proposed a generic framework for statically inferring properties of mobile systems. This framework is based on thread partitioning: we gather the threads of a mobile system into several classes. The criterion of thread partitioning is left as a parameter. We use the product of an analysis of the dynamic linkage between the threads of a system and an analysis of the number of threads inside each partition class. As a result, we get a polynomial-time (with respect to the length of the initial state) analysis, which succeeds in proving the absence of race conditions in a shared memory  written in the \picalcul.
In \cite[Chap:10]{feret:thesis}, we propose a version of this framework for the \ambient-calculus (see.~Sect.~10.2), and a model independent version (see.~Sect.~10.3). 
We succeed in proving authentication properties in a version \cite{Woo} of the Woo and Lam one-way public-key authentication protocol that is written in the \spicalcul\ \cite{spi}. For that purpose, we partition the threads according to the identities of the principals that have initiated the session. 

Thread partitioning may also be used in \emph{reconfigurable systems} to prove that the system may not switch to a new version until all components have  been installed. For that purpose, we may partition threads according to the version identifier. As future works, we are also  interested in using thread partitioning to refine the type checking of authorization policies \cite{authorization}.





\bibliography{document}
\end{document}
