\documentclass{tlp}



\usepackage{epic}
 \usepackage{eepic}
 \usepackage{epsfig}
 \usepackage{url}
 \usepackage{xspace}
 \usepackage{latexsym}
 \usepackage{amsmath}
 \usepackage{amssymb}

\newif\ifreporxt

\newcommand{\TODO}[1]{{\large\bf TODO: }#1\ensuremath{\Box}}
\newcommand{\nop}[1]{}








\newcommand{\tabstretch}{\raisebox{0ex}[3ex][2ex]{}}

\newcommand{\mathem}[1]{\emph{\ensuremath{#1}}}

\newcommand{\set}[1]{\{ #1 \}}

\newcommand{\Pol}{{\rm P}}
\newcommand{\NP}{\textrm{NP}\xspace}
\newcommand{\CONP}{\textrm{co-NP}\xspace}
\newcommand{\SigmaP}[1]{\ensuremath{\Sigma_{#1}^P}}
\newcommand{\PiP}[1]{{\Pi}_{#1}^{P}}
\newcommand{\DeltaP}[1]{\ensuremath{\Delta_{#1}^P}}

\newcommand{\Or}{\ensuremath{\mathtt{\,v\,}}\xspace}
\newcommand{\derives}{\ensuremath{\mathtt{\ :\!\!-}\ }}
\newcommand{\wderives}{\ensuremath{:\sim}}
\newcommand{\uneq}{\ensuremath{<>}}
\newcommand{\Comma}{\ \ ;\ \ }

\newcommand{\p}{\ensuremath{{\mathcal{P}}}}
\newcommand{\GP}{\ensuremath{Ground(\p)}}
\newcommand{\GRules}{\ensuremath{GroundRules(\p)}}
\newcommand{\GWC}{\ensuremath{GroundWC(\p)}}
\newcommand{\BP}{\ensuremath{B_{\p}}}
\newcommand{\UP}{\ensuremath{U_{\p}}}

\newcommand{\intelligent}{\ensuremath{\p}}

\newcommand{\R}{\ensuremath{r}}
\newcommand{\GR}{\ensuremath{Ground(\R)}}
\newcommand{\Gaweak}{\ensuremath{Ground(\aweak)}}
\newcommand{\HR}{\ensuremath{H(\R)}}
\newcommand{\BR}{\ensuremath{B(\R)}}
\newcommand{\BpR}{\ensuremath{B^+(\R)}}
\newcommand{\BnR}{\ensuremath{B^-(\R)}}

\newcommand{\tneg}{\ensuremath{\neg}}
\newcommand{\naf}{\ensuremath{\mathtt{not}}\xspace}

\newcommand{\dlv}{{\sc DLV}\xspace}
\newcommand{\dlvf}[1]{\mbox{{\sc DLV}{\rm[}{\rm]}}\xspace}
\newcommand{\K}{\ensuremath{\cal K}\xspace}
\newcommand{\dlvk}{\texttt{\small{DLV}}\xspace}
\newcommand{\Kc}{\ensuremath{\mathcal{K}^c}\xspace}
\newcommand{\gnt}{GnT\xspace}
\newcommand{\NoMoRe}{NoMoRe\xspace}

\newcommand{\gco}{{\bf \small{GCO}}\xspace}


\newcommand{\DLPI}{\ensuremath{\mathrm{DLP}^<}}

\newcommand{\tuple}[1]{\langle#1\rangle}

\def\WP{{\cal W}_{\p}}
\def\WPinf{{\cal W}_{\p}^{\omega}(\emptyset)}




\newcommand{\varset}{\ensuremath{\sigma_{var}}\xspace}
\newcommand{\constset}{\ensuremath{\sigma_{const}}\xspace}
\newcommand{\predset}{\ensuremath{\sigma_{pred}}\xspace}
\newcommand{\termset}{\ensuremath{\sigma_{term}}\xspace}

\newcommand{\arity}[1]{\ensuremath{arity(#1)}}

\newcommand{\q}{\ensuremath{{\cal Q}}}
\newcommand{\guessprog}{\ensuremath{{\cal G}}}
\newcommand{\checkprog}{\ensuremath{{\cal C}}}
\newcommand{\optprog}{\ensuremath{{\cal O}}}
\newcommand{\factprog}{\ensuremath{{\cal F}}}

\newcommand{\base}[1]{\ensuremath{B_{#1}}}
\newcommand{\universe}[1]{\ensuremath{U_{#1}}}

\newcommand{\ground}[1]{\ensuremath{Ground(#1)}}

\newcommand{\programs}[1]{\ensuremath{\Pi_{#1}}}

\newcommand{\arule}[1][]{\ensuremath{r_{#1}}}
\newcommand{\aconstr}[1][]{\ensuremath{c_{#1}}}
\newcommand{\aquery}[1][]{\ensuremath{q_{#1}}}
\newcommand{\aprog}[1][]{\ensuremath{\p_{#1}}}
\newcommand{\anint}[1][]{\ensuremath{I_{#1}}}
\newcommand{\apint}[1][]{\ensuremath{{\cal I}_{#1}}}
\newcommand{\aweak}[1][]{\ensuremath{w_{#1}}}
\newcommand{\apjnt}[1][]{\ensuremath{{\cal J}_{#1}}}
\newcommand{\incint}{\ensuremath{\Box}}

\newcommand{\bravecons}{\ensuremath{\models_b}}
\newcommand{\cautiouscons}{\ensuremath{\models_c}}

\newcommand{\head}[1]{\ensuremath{H(#1)}}
\newcommand{\body}[1]{\ensuremath{B(#1)}}
\newcommand{\posbody}[1]{\ensuremath{B^+(#1)}}
\newcommand{\negbody}[1]{\ensuremath{B^-(#1)}}
\newcommand{\litbody}[1]{\ensuremath{{\cal B}(#1)}}
\newcommand{\atoms}[1]{\ensuremath{Atoms(#1)}}

\newcommand{\AS}[1]{\ensuremath{{\cal AS}(#1)}}
\newcommand{\OAS}[1]{\ensuremath{{\cal OAS}(#1)}}
\newcommand{\ASI}[2]{\ensuremath{{\cal AS}(#1,#2)}}

\newcommand{\wmax}[1]{\ensuremath{w_{max}^{#1}}}
\newcommand{\lmax}[1]{\ensuremath{l_{max}^{#1}}}

\newcommand{\val}[2]{\ensuremath{val_{#1}(#2)}}
\newcommand{\valh}[2]{\ensuremath{val^H_{#1}(#2)}}
\newcommand{\valb}[2]{\ensuremath{val^B_{#1}(#2)}}

\newcommand{\WC}[1]{\ensuremath{WC(#1)}}
\newcommand{\Rules}[1]{\ensuremath{Rules(#1)}}



\newcommand{\rulesetsep}{\ \ ;\ \ }

\newcommand{\dlfact}[1]{\ensuremath{#1.}}
\newcommand{\dlquery}[1]{\ensuremath{#1?}}
\newcommand{\dlrule}[2]{\ensuremath{#1 \derives #2.}}
\newcommand{\dlconstraint}[1]{\ensuremath{\derives #1.}}
\newcommand{\dlweakconstraint}[3]{\ensuremath{\wderives #1.\ [#2:#3]}}

\newcommand{\dlstrictfact}[1]{\ensuremath{#1!}}
\newcommand{\dlstrictrule}[2]{\ensuremath{#1 \derives #2!}}

\newcommand{\dlalignedfact}[1]{\code{#1.}}
\newcommand{\dlalignedquery}[1]{\code{#1?}}
\newcommand{\dlalignrule}[2]{\code{#1 \derives } \=\code{#2.}}
\newcommand{\dlalignedrule}[2]{\code{#1 \derives } \>\code{#2.}}
\newcommand{\dlalignedincompleterule}[2]{\code{#1 \derives } \=\code{#2}}
\newcommand{\dlalignedstubrule}[1]{\> \code{#1.}}
\newcommand{\dlalignconstraint}[1]{\code{\derives } \=\code{#1.}}
\newcommand{\dlalignedconstraint}[1]{\code{\derives } \>\code{#1.}}
\newcommand{\dlalignedincompleteconstraint}[1]{\code{\derives } \=\code{#1}}
\newcommand{\dlalignedstubconstraint}[1]{\>\code{#1.}}
\newcommand{\dlalignweakconstraint}[2]{\code{\wderives} \=\code{#1. [#2]}}
\newcommand{\dlalignedweakconstraint}[2]{\code{\wderives} \>\code{#1. [#2]}}

\newcommand{\displacedcode}[1]{\begin{center}\ensuremath{\mathtt{#1}}\end{center}}

\newcommand{\inlinekrule}[1]{\texttt{#1}}

\newenvironment{simpleprogram}[1][]
   {\vspace{-0.5ex}\begin{itemize}\item[]
      \tt
      \begin{tabbing}
      \code{#1}\ \= \kill
   }
   {\end{tabbing}\end{itemize}\vspace{-3ex}}

\newcommand{\spi}[2][]{\code{#1}\>\code{#2}\\}
\newcommand{\spfsi}[2][]{\footnotesize\code{#1}\>\footnotesize\code{#2}\\begin{sublabeledprogram}}
   {\end{sublabeledprogram}2ex]}
\newcommand{\lpsi}[1]{\spi{#1}}

\newcommand{\gt}{\ensuremath{>}}
\newcommand{\lt}{\ensuremath{<}}

\newcommand{\code}[1]{\ensuremath{#1}}
\newenvironment{dlvcode}
  {}
\newenvironment{dlvcode2}
  {}


\newcommand{\emptycodeline}{\
\{\,{\tt p(\t)} \in \BP \setminus N \ | \ \mbox{ either }\, {\tt p}\, 
    \mbox{ is an EDB predicate, or } {\tt magic\_p(\t)} \in N\,\}.

\variantqpi = \EDB(\p) \cup M^\magica \cup \{ {\tt p(\t)} \in I \ \mid {\tt magic\_p(\t)} \in M^\magica \},

\noindent
where  is the unique stable model of \magicRules.
\end{definition}

In this definition, we exploit the fact that \magicRules has a unique and finite stable model for \ASPFNFR{} queries (see Lemma~\ref{lem:magicUnique} for a detailed proof).
By definition, for a magic variant  of an interpretation  for ,  holds. More interesting, the magic variant of a stable model for  is in turn a stable model for 
preserving truth/falsity of .
The following formalizes the intuition above.

\begin{lemma}\label{lem:variant_stable_model} 
If  is a stable model of an \ASPFN{} program  with a finitely recursive query , then  is a stable model of 
and  if and only if .
\end{lemma}
\begin{proof}
Consider a modified rule  having
 and :
\begin{dlvcode}
\R_g': \ \tt p_1(\t_1)\,\Or\,\cdots\,\Or\,p_n(\t_n) \derives 
     magic\_p_1(\t_1),\,\ldots,\,magic\_p_n(\t_n),\\
\phantom{\R_g': \ \tt p_1(\t_1)\,\Or\,\cdots\,\Or\,p_n(\t_n) \derives }
     \tt q_1(\s_1),\,\ldots,\,q_j(\s_j),\,\naf~q_{j+1}(\s_{j+1}),\,\ldots,\,\naf~q_m(\s_m).
\end{dlvcode}We can show that
\begin{dlvcode}
\R_g: \ \tt p_1(\t_1)\,\Or\,\cdots\,\Or\,p_n(\t_n) \derives 
    q_1(\s_1),\,\ldots,\,q_j(\s_j),\,\naf~q_{j+1}(\s_{j+1}),\,\ldots,\,\naf~q_m(\s_m).
\end{dlvcode}belongs to . 
\nop{
\begin{proof}
By definition,  if and only if there is  
such that  for some substitution .
Since ,  and

if and only if a modified rule  such that  has been
produced.
\end{proof}
}
Since  and 
, we have 
, ,
and . 
Thus,  because
 is a model of .
Moreover, if there is a model  of ,
then  is a model for ,
contradicting the assumption that  is a stable model of .

Thus,  is a stable
model of .
Since  belongs either to  or to , 
the claim follows by Proposition~\ref{prop:killed_unfounded}.
\end{proof}

From the above lemma, together with Lemma~\ref{lem:extending_minimal_models}, the
correctness of the Magic Set method with respect to query answering directly follows.

\begin{theorem}\label{thm:equivalence}
\label{theo:dms_equivalence}
If   is an \ASPFNFR{} query over , then both  and  hold.
\end{theorem}


\section{Decidability Result}\label{sec:decidability}

In this section, we prove that \ASPFNFR{} queries are decidable.
To this end, we link finitely recursive queries to finitely ground programs.
More specifically, we show that the Magic-Set rewriting of a finitely recursive
query is a finitely ground program, for which querying is known to be decidable.

We first show some properties of the rewritten program due to the particular
restrictions applied to the adopted SIPS.

\begin{lemma}\label{lem:magicStratified}
If  is an \ASPFNFR{} query over , 
then  is stratified.
\end{lemma}
\begin{proof}
Each cycle of
dependencies in  involving predicates of  is also present in
. Indeed, each magic rule has exactly one magic atom in the head and one
in the body, and each modified rule is obtained by adding 
only magic atoms to the body of a rule belonging to . 
Since  is stratified by assumption, such cycles have 
no negative dependencies.
Any new cycle stems only from magic rules, which are positive.
\end{proof}

Now consider the program consisting of the magic rules produced for 
a finitely recursive query. 
We can show that this program has a unique and finite stable model,
that we will denote .

\begin{lemma}\label{lem:magicUnique}
Let  be an \ASPFNFR{} query over .
Then the program \magicRules has a unique and finite stable model .
\end{lemma}
\begin{proof}
Since \magicRules is positive and normal,  is unique.
If we show that  contains all and only the relevant atoms for ,
then we are done because  is finitely recursive on .
To this end, note that the only fact in \magicRules is the query seed
, and each magic rule 
in  ( a substitution) is such that
 is relevant for .
Indeed,  has been produced during the 
{\em Generation} phase involving a rule  with  
and ;
since each variable in  appears also in ,
 is such that  and
, i.e., 
is relevant for .
\end{proof}


We can now link \ASPFNFR{} queries and finitely ground programs.

\begin{theorem}\label{theo:magicFinitelyGround}
Let  be an \ASPFNFR{} query over .
Then  is finitely ground.
\end{theorem}
\begin{proof}
Let  be a component ordering for
.
Since each cycle of dependencies in  involving predicates of 
is also present in , components with
non-magic predicates are disjoint from components with magic predicates.
For a component  with magic predicates, 
 is a subset of ,
which is finite by Lemma~\ref{lem:magicUnique}.

For a component  with a non-magic predicate , we consider
a modified rule  with an atom :
\begin{dlvcode}
\R': \ \tt p_1(\t_1)\,\Or\,\cdots\,\Or\,p_n(\t_n) \derives 
     magic\_p_1(\t_1),\,\ldots,\,magic\_p_n(\t_n),\\
\phantom{\R': \ \tt p_1(\t_1)\,\Or\,\cdots\,\Or\,p_n(\t_n) \derives }
     \tt q_1(\s_1),\,\ldots,\,q_j(\s_j),\,\naf~q_{j+1}(\s_{j+1}),\,\ldots,\,\naf~q_m(\s_m).
\end{dlvcode}Thus, the component containing  precedes  in .
Moreover, since  is finitely recursive on , each variable appearing in
 appears also in .
Therefore,  is finite also in this case.
\end{proof}

We are now ready for proving the decidability of brave and cautious reasoning
for the class of finitely recursive queries on \ASPFN{} programs.

\begin{theorem}\label{theo:decidability}
Let  be an \ASPFNFR{} query over .
Deciding whether  cautiously/bravely entails  is computable.
\end{theorem}
\begin{proof}
From Theorem~\ref{thm:equivalence}, 
 and  hold.
Since  is finitely ground by Theorem~\ref{theo:magicFinitelyGround},
decidability follows from Thereom~\ref{theo:fg-reasoningDecidable}.
\end{proof}


\section{Expressiveness Result}\label{sec:expressiveness}

In this section, we show that the restrictions which guarantee the
decidability of \ASPFNFR{} queries do not limit their expressiveness.
Indeed, any computable function can be encoded by an \ASPFNFR{}
program (even without using disjunction and negation).  To this end,
we show how to encode a deterministic Turing Machine as a positive
program with functions and an input string by means of a query.  In
fact it is well-known that Horn clauses (under the classic first-order
semantics) can represent any computable function \cite{tarn-77}, so we
just have to adapt these results for \ASPFNFR{} programs and queries.


A Turing Machine  with semi-infinite tape 
is a 5-tuple ,
where  is an alphabet (i.e., a set of symbols),
 is a set of states,
 are two distinct states (representing the initial and 
final states of , respectively), and
 
is a transition function.
Given an input string , the initial configuration of 
is such that the current state is ,
the tape contains  followed by an infinite sequence of blank symbols 
(a special tape symbol occurring in ; we are assuming  does not contain
any blank symbol), 
and the head is over the first symbol of the tape.
The other configurations assumed by  with input  are then obtained by means 
of the transition function :
If  and  are the current state and symbol, respectively,
and , then  overwrites  with ,
moves its head according to ,
and changes its state to .
 {\em accepts}  if the final state  is reached
at some point of the computation.

A configuration of  can be encoded by an instance of ,
where  is the current state,  the symbol under the head,
 the list of symbols on the left of the head in reverse order,
and  a finite list of symbols on the right of the head containing
at least all the non-blank symbols.
The query  representing the initial configuration
of  with input  is
\begin{dlvcode}
\begin{array}{lcl}
\tt conf(s_i,[\ ],x_1,[x_2, \ldots, x_n])? && \tt \mbox{if } n > 0; \\
\tt conf(s_i,[\ ],\blank,[\ ])? && \tt \mbox{otherwise.}
\end{array}
\end{dlvcode}The program  encoding  contains a rule
 representing the final state ,
and a set of rules implementing the transition function .
For each state  and for 
each symbol ,  contains the following rules:
\begin{dlvcode}
\begin{array}{lcl}
\tt conf(s,[V|L],v,R) \derives conf(s',L,V,[v'|R]). && \tt \mbox{if } \delta(s,v) = (s',v',\leftarrow); \\
\tt conf(s,L,v,[V|R]) \derives conf(s',[v'|L],V,R). && \tt \mbox{if } \delta(s,v) = (s',v',\rightarrow); \\
\tt conf(s,L,v,[\ ]) \ \ \ \derives conf(s',[v'|L],\blank,[\ ]). && \tt \mbox{if } \delta(s,v) = (s',v',\rightarrow).
\end{array}
\end{dlvcode}Note that we do not explicitly represent the infinite sequence of blanks on the right of the tape; the last rule above effectively produces a blank whenever the head moves right of all explicitly represented symbols. The atoms therefore represent only the effectivley reached tape positions. We now show the correctness of  and .

\begin{theorem}\label{theo:turingCorrectness}
The program  bravely/cautiously
entails  if and only if  accepts .
\end{theorem}
\begin{proof}[Proof Sketch]
 bravely/cautiously entails 
if and only if the unique stable model of  contains
a sequence of atoms  such that
 is the query atom,
 is an instance of ,
and there is a rule in  (implementing the transition
function of )
having  in head and  in the body,
for each .
Since instances of  represent configurations of ,
the claim follows.
\end{proof}

We can now link computable sets (or functions) and finitely recursive queries.

\begin{theorem}\label{theo:turingFinRecQ}
Let  be a computable set (or function).
Then, there is an \ASPFN{} program  such that, for each string ,
the query  is finitely recursive on ,
and  cautiously/bravely entails  if and only if .
\end{theorem}
\begin{proof}
Let  be a Turing Machine computing  and  be the
program encoding . Program  is clearly in
\ASPFN{} (actually, it is even negation-free).
By Theorem~\ref{theo:turingCorrectness}, it only remains to prove that 
 is finitely recursive on .
By construction of , for each ground atom 
 in ,
there is exactly one rule in  having 
in head.
This rule has at most one atom  in its body, and
implements either the transition function or the final state of .
Thus, the atoms relevant for  are exactly the atoms
representing the configurations assumed by  with input .
The claim then follows because  halts in a finite number of steps
by assumption.
\end{proof}

We note that when applying magic sets on the Turing machine encoding,
the magic predicates effectively encode all reachable configurations,
and a bottom-up evaluation of the magic program corresponds to a
simulation of the Turing machine. Hence only
encodings of Turing machine invocations that visit all (infinitely
many) tape cells are not finitely recursive. We also note
that recognizing whether an \ASPFN{} query or a program is finitely
recursive is RE-complete\footnote{That is, complete for the class of recursively enumerable decision problems.}.

\nop{
Finally, by combining Theorem~\ref{theo:turingFinRecQ} and 
Theorem~\ref{theo:decidability} 
with the R.E-completeness of the 
halting problem, we obtain the next theorem.

\begin{corollary}\label{cor:REcomplete}
The following problems are R.E.-complete:
 recognizing whether a program  is finitely recursive;
 recognizing whether a query  is finitely recursive on a program .
\end{corollary}
}

\nop{
\TODO{Malvi: Eliminare da qui fino a fine sezione (possiamo usarlo per un altro articolo.}

We start by identifying interesting properties of finitely ground programs.

\begin{lemma}\label{lem:exchangeComponents1}
Let  be a component ordering for
a program .
Let  and  be two components such that there is no path between
 and  (in both directions).
Then  
is a component ordering for  and .
\end{lemma}
\begin{proof}
Since there is no path between  and , in both directions,
 is a component ordering for .
Thus, we want to show that  (note that
 involves the instantiation of  in ),
since in this case we have .

By definition of , we have .
Consider now .
By definition of , there is  such that
 , for some substitution ,
and  is the simplification of  w.r.t.\ .
Since there is no path between  and  by assumption,
we distinguish two cases:
\begin{enumerate}[2.]
 \item
 If there is an atom  such that ,
 then no predicate appearing in  belongs to .
 Thus,  is equivalent to .
 Therefore, 
 (note that  involves the instantiation of  in ).
 
 \item
 Otherwise, no predicate appearing in  belongs to .
 In this case we consider  and note that  is produced
 and simplified w.r.t.\  in ,
 that is, .
\end{enumerate}

Now consider .
Thus, there is  such that
, for some substitution ,
and   is the simplification of  w.r.t.\ .
By definition of module, such a rule  does not belong to .
Therefore, since there is no path between  and  by assumption,
no predicate appearing in  belongs to .
Thus,  is equivalent to  is the simplification of 
w.r.t.\ .
We then consider  (which involves the instantiations of 
in ) and note that  is produced and simplified
w.r.t.\  in ,
that is, .

In sum, we have . 
The inclusion in the other direction follows by symmetry,
and so we are done.
\end{proof}

\begin{corollary}\label{cor:exchangeComponents}
Let  be a component ordering for
a program .
Let  and  () be two components such that there is no path between
 (in any direction).
Then exchanging  and  in  results to a component ordering
 such that .
\end{corollary}
\begin{proof}
We prove the claim by induction on .
For  we have Lemma~\ref{lem:exchangeComponents1}.
Thus, in order to exchange  and , with , we can first
exchange  with  (by the induction hypothesis), and then 
exchange  and  at distance 1 (by Lemma~\ref{lem:exchangeComponents1}).
\end{proof}

\begin{theorem}
Let  be a program such that there is no cycle in .
Then, for each pair of component ordering , , 
we have .
\end{theorem}
\begin{proof}
The component ordering  can be obtained from  by applying
several component exchanging. Thus, by Corollary~\ref{cor:exchangeComponents},
we have that .
\end{proof}

\begin{corollary}\label{cor:finitelyGroundSome}
Let  be a program such that there is no cycle in .
Then  is finitely ground if and only if
 is finite for ``some'' component ordering .
\end{corollary}



\begin{theorem}\label{theo:magicFinitelyGround}
Let  be a finitely recursive query on a stratified program .
Then  is finitely ground.
\end{theorem}
\begin{proof}
\TODO{Malvi: Qui c'e' un po' di confusione.}
Since  is stratified,  has no cycle.
Thus, by Corollary~\ref{cor:finitelyGroundSome}, it is enough to show that 
 is finite for some component ordering .
We then consider  such that
 are the components with magic predicates,
and  the components with standard predicates.
Therefore,  are finite, 
since  is finitely recursive on  by assumption.
Moreover,  are finite because
each rule  in  is such that all the variables
of  appears in a magic atom belonging to ,
and only a finite number of magic instances are present in .
\end{proof}
}

\section{Related Work}\label{sec:relatedwork}

\newcommand{\ldl}{\xspace}
\newcommand{\fdnc}{\xspace}
\newcommand\dependson{\geqslant}



The extension of ASP with functions has been the subject
of intensive research in the last years.
The main proposals can be classified in two groups:

1. {\em Syntactically restricted fragments}, such as
    {\em -restricted
    programs}~\cite{syrj-2001}, {\em
    -restricted programs}~\cite{gebs-etal-2007-lpnmr},
    {\em finite-domain programs}
    \cite{cali-etal-2008-iclp}, {\em argument}-{\em
    restricted programs} \cite{lier-lifs-2009-iclp},
    \fdnc\ {\em programs} \cite{simk-eite-2007-lpar},
    {\em bidirectional programs}
    \cite{eite-simk-2009-ijcai}, and the proposal of
    \cite{lin-wang-2008-KR}; these approaches introduce
    syntactic constraints (which can be easily checked
    at small computational cost) or explicit domain
    restrictions, thus allowing computability of answer
    sets and/or decidability of querying;

2. {\em Semantically restricted fragments}, such as
    {\em finitely ground programs}~\cite{cali-etal-2008-iclp},
    {\em finitary programs}~\cite{bona-02-iclp,bona-04},
    {\em disjunctive finitely-recursive
    programs}~\cite{base-etal-2009-tplp} and {\em queries}~\cite{cali-etal-2009-lpnmr};
    with respect to syntactically restricted fragments, these 
    approaches aim at identifying broader classes of
    programs for which computational tasks such as
    querying are decidable. However, the membership of programs in these fragments is undecidable in general.


There have been a few other proposals that treat function symbols not
in the traditional LP sense, but as in classical
logic, where most prominently the unique names assumption does not
hold. We refer to \cite{caba-2008-iclp} for an overview.

Our work falls in the group 2. It is most closely related
to~\cite{bona-02-iclp},
\cite{base-etal-2009-tplp}, and especially \cite{cali-etal-2009-lpnmr},
which all focus on {\em querying} for {\em disjunctive} programs.

The work in~\cite{bona-02-iclp} studies how to extend
finitary programs \cite{bona-04} preserving decidability
for ground querying in the presence of disjunction. To this
end, an extra condition on disjunctive heads is added to the
original definition of finitary program of~\cite{bona-04}.
\nop{
Given a dependency relation which considers only
connections between head and body atoms (that is,  iff there exists  such that 
and ), a disjunctive program  is finitary in
the sense of \cite{bona-02-iclp} if {\em (1)}~each ground
atom in  depends on finitely many other atoms, {\em (2)}
the set  of atoms appearing in odd-negated cycles is
finite and {\em (3)} the set  of atoms  for which
there is a rule  in which  and there is an atom 
which is recursive with  and  positively depends on
, is finite \footnote{Given erratum
\cite{bona-err-2008}, it turns out that both  and 
must be known besides being finite.}.
}
Interestingly, the class of \ASPFNFR{} programs,
which features decidable reasoning (as proved in
Theorem~\ref{theo:decidability}), enlarges the stratified
subclass of disjunctive finitary programs
of~\cite{bona-02-iclp}. Indeed, while all stratified finitary
programs trivially belong to the class of \ASPFNFR{} programs,
the above mentioned extra condition on disjunctive heads is not guaranteed to be
fulfilled by \ASPFNFR{} programs
(even if negation is stratified or forbidden at all).
\nop{
as witnessed by the following program:
\begin{dlvcode2}
p(X) \Or q(X) \implied\ s(X).\qquad\qquad & q(X) \implied\ p(X). \\
p(f(X)) \implied\ q(X). & p(1). \\
p(X) \implied\ q(X). \\
\end{dlvcode2}
}
Instead, in \cite{base-etal-2009-tplp}, 
a redefinition (including disjunction) of
finitely recursive programs is considered, initially introduced
in~\cite{bona-04} as a super-class of finitary programs
allowing function symbols and negation. The authors show
a compactness property and semi-decidability results for cautious ground
querying, but no decidability results are given.




Our paper extends and generalizes the work \cite{cali-etal-2009-lpnmr},
in which the decidability of querying over finitely recursive {\em negation-free}
disjunctive programs is proved via a magic-set rewriting.
To achieve the extension, we had to generalize the magic set technique
used in \cite{cali-etal-2009-lpnmr} to deal also with stratified negation.
The feasibility of such a generalization was not obvious at all,
since the magic set rewriting of a stratified program can produce unstratified
negation~\cite{kemp-etal-95},
which can lead to undecidability in the presence of functions.
We have proved that, thanks to the structure of \ASPFNFR{} programs and the adopted SIPS,
the magic set rewriting preserves stratification.
The presence of negation also complicates the proof that the 
rewritten program is query-equivalent to the original one.
To demonstrate this result, we have exploited the characterization
of stable models via unfounded sets of \cite{leon-etal-97b},
and generalized the equivalence proof of \cite{alvi-etal-2009-TR}
to the case of programs with functions.


Finally, our studies on computable fragments of logic
programs with functions are loosely related to termination
studies of SLD-resolution for Prolog programs (see
e.g.~\cite{bruy-etal-2007-acm}).

\nop{
Some other papers about the magic-set
technique~\cite{banc-etal-1986,ullm-89,beer-rama-87}
are related to the present work as well, for which
different extensions and refinements have been proposed.
Among the more recent works, an adaptation for
soft-stratifiable programs~\cite{behr-2003-pods}, the
generalization to the disjunctive
case~\cite{cumb-etal-2004-iclp} and to Datalog with
(possibly unstratified) negation~\cite{fabe-etal-2007-jcss}
are worth remembering.
}


\section{Conclusion}\label{sec:conclusion}

In this work we have studied the language of \ASPFNFR{} queries and
programs. By adapting a magic set technique, any \ASPFNFR{} query can be
transformed into an equivalent query over a finitely ground
program, which is known to be decidable and for which an implemented
system is available. We have also shown that the \ASPFNFR{} language can
express any decidable function. In total, the proposed language and
techniques provide the means for a very expressive, yet decidable
and practically usable logic programming framework.

Concerning future work, we are working on adapting an existing
implementation of a magic set technique to handle \ASPFNFR{} queries
as described in this article, integrating it into
\dlv-Complex~\cite{dlvcomplex-web}, thus creating a useable \ASPFNFR{}
system. We also intend to explore practical application scenarios;
promising candidates are query answering over ontologies and in
particular the Semantic Web, reasoning about action and change, or
analysis of dynamic multi-agent systems.

\bibliography{bibtex}

\end{document}
