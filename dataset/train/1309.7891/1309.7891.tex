\documentclass[a4paper,11pt]{article}

\usepackage{enumerate}
\usepackage{amssymb,amsmath,epsfig,amsthm,color}
\usepackage{boxedminipage}




 \usepackage[ pdftex, plainpages = false, pdfpagelabels, 
bookmarks=false,
                 bookmarksopen = true,
                 bookmarksnumbered = true,
                 breaklinks = true,
                 linktocpage,
                 pagebackref,
                 colorlinks = true,  linkcolor = blue,
                 urlcolor  = blue,
                 citecolor = red,
                 anchorcolor = green,
                 hyperindex = true,
                 hyperfigures
                 ]{hyperref} 




\usepackage{vmargin}
\setmarginsrb{1.1in}{1.1in}{1.1in}{1.1in}{0mm}{0mm}{0mm}{7mm}


\newtheorem{rrule}{Reduction Rule}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}


\newcommand{\cc}{{\mathcal{C}}}
\newcommand{\Oh}{{\mathcal{O}}}
\newcommand{\lcac}{{\textbf{LCA-closure}}}
\newcommand{\hd}{\textbf{d}_{H}}
\newcommand{\cupall}{\pmb{\pmb{\cup}}}

\newcommand{\name}[1]{\textsc{#1}}
\newcommand{\parnamedefn}[4]{
\begin{tabbing}
\name{#1} \\
\emph{Input:} \hspace{1cm} \= \parbox[t]{10cm}{#2} \\
\emph{Parameter:}            \> \parbox[t]{10cm}{#3} \\
\emph{Question:}             \> \parbox[t]{10cm}{#4} \\

\end{tabbing}
}


\bibliographystyle{abbrv}





\title{\bf Tree Deletion Set has a Polynomial Kernel
\newline
(but no OPT approximation)
}



\author{Archontia C. Giannopoulou\thanks{Department of Informatics, University of Bergen, P.O. Box 7803, N-5020 Bergen, Norway.
\texttt{\{archontia.giannopoulou,daniello\}@ii.uib.no}.}~\thanks{This author's research, leading to these results, has received funding from the European Research Council under the European Union's Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement n. 267959.} 
\and Daniel Lokshtanov\thanks{Supported by Bergen Research Foundation grant BeHard.}
\and Saket Saurabh\thanks{The Institute of Mathematical Sciences, Chennai, India. \texttt{saket@imsc.res.in}. Supported by Parameterized Approximation, ERC Starting Grant 306992.}
\and Ond\v{r}ej Such\'{y}\thanks{Faculty of Information Technology, Czech Technical University Prague, Czech Republic. \texttt{ondrej.suchy@fit.cvut.cz}.}
}

\date{}
\pagestyle{plain}
\begin{document}
\maketitle

\begin{abstract}
In the {\sc Tree Deletion Set} problem the input is a graph  together with an integer . The objective is to determine whether there exists a set  of at most  vertices such that  is a tree. The problem is {\sf NP}-complete and even {\sf NP}-hard to approximate within any factor of OPT for any constant . In this paper we give a  size kernel for the {\sc Tree Deletion Set} problem. To the best of our knowledge our result is the first counterexample to the ``conventional wisdom'' that kernelization algorithms automatically provide approximation algorithms with approximation ratio close to the size of the kernel.
An appealing feature of our kernelization algorithm is a new algebraic reduction rule that we use to handle the instances on which {\sc Tree Deletion Set} is hard to approximate.
\end{abstract}

\section{Introduction} \label{sec_intro}
In the {\sc Tree Deletion Set} problem we are given as input an undirected graph  and integer , and the task is to determine whether there exists a set  of size at most  such that  is a tree, that is a connected acyclic graph. This problem was first mentioned by Yannakakis~\cite{Yannakakis79} and is closely related to the classical {\sc Feedback Vertex Set} problem. Here input is a graph  and integer  and the goal is to decide whether there exists a set  on at most  vertices such that  is acyclic. The only difference between the two problems is that in {\sc Tree Deletion Set}  is required to be connected, while in {\sc Feedback Vertex Set} it is not. Both problems are known to be {\sf NP}-complete~\cite{GJ79,Yannakakis79}.

Despite the apparent similarity between the two problems their computational complexity differ quite dramatically. {\sc Feedback Vertex Set} admits a factor -approximation algorithm, while {\sc Tree Deletion Set} is known to not admit any approximation algorithm with ratio  for any , unless {\sf P} = {\sf NP}~\cite{BafnaBF99,Yannakakis79}. With respect to parameterized algorithms, the two problems exhibit more similar behavior. Indeed, most techniques that yield fixed parameter tractable algorithms for {\sc Feedback Vertex Set}~\cite{ChenFLLV08,CaoCL10} can be adapted to also work for {\sc Tree Deletion Set}~\cite{RamanSS13}. 

It is also interesting to compare the behavior of the two problems with respect to polynomial time preprocessing procedures. Specifically, we consider the two problems in the realm of {\em kernelization}. We say that a parameterized graph problem admits a {\em kernel} of size  if there exists a polynomial time algorithm, called a {\em kernelization algorithm}, that given as input an instance  to the problem outputs an equivalent instance  with  and . If the function  is a polynomial, we say that the problem admits a {\em polynomial kernel}. We refer to the surveys~\cite{GN07,LokshtanovMS12} for an introduction to kernelization. For the {\sc Feedback Vertex Set} problem, Burrage et al.~\cite{BurrageEFLMR06} gave a kernel of size . Subsequently, Bodlaender~\cite{Bodlaender07} gave an improved kernel of size   and finally Thomass\'{e}~\cite{Thomasse10} gave a kernel of size . On the other hand the existence of a polynomial kernel for {\sc Tree Deletion Set} was open until this work. It seems difficult to directly adapt any of the known kernelization algorithms for {\sc Feedback Vertex Set} to {\sc Tree Deletion Set}. Indeed, Raman et al.~\cite{RamanSS13} conjectured that {\sc Tree Deletion Set} does not admit a polynomial kernel. 

The main reason to conjecture that {\sc Tree Deletion Set} does not admit a polynomial kernel stems from an apparent relation between kernelization and approximation algorithms. Prior to this work, all problems that were known to admit a polynomial kernel, also had approximation algorithms with approximation ratio polynomial in OPT. Here OPT is the value of the optimum solution to the input instance. In fact most kernelization algorithms are already approximation algorithms  with approximation ratio polynomial in OPT. This relation between approximation and kernelization led Niedermeier~\cite{rolf_invitation} to conjecture that {\sc Vertex Cover} does not admit a kernel with  vertices for , as this probably would yield a factor  approximation for the problem thus violating the Unique Games Conjecture~\cite{KhotR08}. 

It is easy to show that an approximation algorithm for {\sc Tree Deletion Set} with ratio  would yield an approximation algorithm for the problem with ratio  thereby proving {\sf P} = {\sf NP}. In particular, suppose {\sc Tree Deletion Set} had an  algorithm for some constant . Since the algorithm will never output a set of size more than , the approximation ratio of the algorithm is upper bounded by . This rules out approximation algorithms for  {\sc Tree Deletion Set} with ratio , and makes it very tempting to conjecture that  {\sc Tree Deletion Set} does not admit a polynomial kernel. 

In this paper we show that  {\sc Tree Deletion Set} admits a kernel of size . To the best of our knowledge this is the first example of a problem which does admit a polynomial kernel, but does not admit any approximation algorithm with ratio  under plausible complexity assumptions.\\

\noindent {\bf Our methods.} 
The starting point of our kernel are known reduction rules for {\sc Feedback Vertex Set} adapted to our setting. By applying these graph theoretical reduction rules we are able to show that there is a polynomial time algorithm that given 
an instance  of {\sc Tree Deletion Set} outputs an equivalent instance  and a partition of  into sets , , and  such that 
\begin{enumerate}\setlength\itemsep{-.7mm}
\item\label{introlem:clse1} , 
\item\label{introlem:clse2} , 
\item\label{introlem:clse3}  is an independent set, and 
\item\label{introlem:clse4} for every ,  and  is a double clique.
\end{enumerate}

\noindent Here a ``double clique'' means that for every pair ,  of vertices in , there are two edges between them. Thus we will allow  to be a multigraph, and consider a double edge between two vertices as a cycle. In order to obtain a polynomial kernel for {\sc Tree Deletion Set} it is sufficient to reduce the set  to size polynomial in .

For every vertex  and tree deletion set  we know that , since otherwise  would contain a double edge. Further, if  then  has to be connected to the rest of 
 and hence  , implying that  is a leaf in . Therefore  must be a tree. We can now reformulate the problem as follows.

For each vertex  in  we have a variable  which is set to  if  and  if . For each vertex  we have a linear equation . The task is to determine whether it is possible to set the variables to  or  such that (a) the subgraph of  induced by the vertices with variables set to  is (connected) a  tree   and (b) the number of variables set to  plus the number of unsatisfied linear equations is at most .

At this point it looks difficult to reduce  by graph theoretic means, as performing operations on these vertices correspond to making changes in a system of linear equations. In order to reduce  we prove that there exists an algorithm that given a set  of linear equations on  variables and an integer  in time  outputs a set  of at most  linear equations such that any assignment of the variables that violates at most  linear equations of  satisfies all the linear equations of . To reduce  we simply apply this result and keep only the vertices of  that correspond to linear equations in . We believe that our reduction rule for linear equations adds to the toolbox of algebraic reduction rules for kernelization~\cite{KratschW12soda,KratschW12,Wahlstrom13} and will find more applications in the future.





\section{Basic Notions}

For every positive integer  we denote by  the set  and for every set  we denote by  the 2-subsets of .  denotes the natural numbers and  denotes the real numbers.

For a  {graph} , we use   to denote its vertex set  and  to denote its edge set .
If  we denote by  the graph obtained from  after removing the vertices of . 
In the case where , we abuse notation and write  instead of .  
For , the {\em neighborhood} of  in , , is the set .
Again, in the case where  we abuse notation and write  instead of .
We use   to denote the set of the connected components of .
Given a graph class  we denote by  the set .
Given two vectors , we denote by  the Hamming distance of  and , that is,  is equal to 
the number of positions where the vectors differ. For every  we denote by  the vector . 
When  is implied from the context we abuse notation and denote  as .

Given a graph  and a set , we say that  is a {\em feedback vertex set} of  if the graph  does not contain any cycles. In the case
where  is connected we call  {\em tree deletion set} of .
Moreover, given a set , we say that  is a double clique of  if every pair of vertices in  is joined by a double edge.

For a rooted tree  and vertex set  in  the least common ancestor-closure ({\em LCA-closure})  is obtained by the following process.
Initially, set . Then, as long as there are vertices  and  in  whose least common ancestor  is not in , add  to . Finally, output
 as the LCA-closure of .

\begin{lemma}[\cite{FominLMS12}]\label{caclsbnd}
Let  be a tree, , and . Then,  and for every connected component  of , .
\end{lemma}


\section{A polynomial kernel for {\sc Tree Deletion Set}}
In this section we prove a polynomial size kernel for a weighted variant of the  {\sc Tree Deletion Set} problem. More precisely the problem we will study is following. 

\begin{center}
\begin{boxedminipage}{.99\textwidth}

\textsc{Weighted Tree Deletion Set  ({\sc wTDS})}

\begin{tabular}{ r l }
\textit{~~~~Instance:} & A graph , a function , and\\
& a positive integer . \\
\textit{Parameter:} & .\\
\textit{Question:} & Does there exist a set  such that\\ 
&  and  is a tree? \\
\end{tabular}
\end{boxedminipage}
\end{center}

\subsection{Known Reduction Rules for {\sc wTDS}}

In this subsection we state some already known reduction rules for  {\sc wTDS} that are going to be needed during our proofs.

\begin{rrule}[\cite{RamanSS13}]\label{rrule1}
If , then answer NO.
\end{rrule}

\begin{rrule}[\cite{RamanSS13}]
If the input graph is disconnected, then delete all vertices in connected components of weight less than  
and decrease  by the weight of the deleted vertices.
\end{rrule}

\begin{rrule}[\cite{RamanSS13}]\label{rrule3}
If  is of degree 1 and  is its only neighbor, then delete  and increase the weight of  by the weight of .
\end{rrule}

\begin{rrule}[\cite{RamanSS13}]\label{rrule4}
If  is a path in the input graph, such that  and  for every , then 
 replace the vertices  by two vertices  and  with edges , , 
and  and with  and .
Moreover, if  and  or , then apply  and then  delete  and connect 
 directly to .
\end{rrule}

Given a vertex  of , an {\em -flower of order } is a set of cycles pairwise intersecting exactly in .
If  has a -flower of order , then  should be in every tree deletion set of weight at most  as otherwise we would need at least 
vertices to hit all cycles passing through .
Thus the following reduction rule is safe.

\begin{rrule}\label{rrule5}
Let  be an instance of {\sc wTDS}. If  has a -flower of order at least , then remove  and decrease the parameter  by the weight of . 
The resulting instance is .
\end{rrule}

\begin{theorem}[\cite{Thomasse10}]\label{algosepvrt}
Let  be a multigraph and  be a vertex of  without a self loop. Then in polynomial time we can either check whether there is 
a -flower of order  or find a set of vertices  of size at most  intersecting every cycle containing .
\end{theorem}

\begin{rrule}\label{rrule6}
Let  be an instance of {\sc wTDS}. If  is a vertex such that , then let .
\end{rrule}

An instance  of {\sc wTDS} is called {\em semi-reduced} if none of the Reduction Rules~\ref{rrule1} -~\ref{rrule6} can be applied.

\begin{theorem}[\cite{BafnaBF99}]\label{apprxalgofvs}
There is an  time algorithm that given a graph  that admits a feedback vertex set of size at most  outputs a 
feedback vertex set of  of size at most .
\end{theorem}


\subsection{A structural decomposition}\label{subsct:strcdecomp}

In this subsection we decompose an instance  of {\sc wTDS} to an equivalent instance  where  is partitioned into
three sets , , and , such that the size of  and  is polynomial in  and  is an independent set.
In particular we obtain the following result. 

\begin{lemma}\label{mainlem}
There is a polynomial time algorithm that given a semi-reduced instance  of {\sc wTDS} outputs an equivalent instance  and 
a partition of  into sets , , and  such that 
\begin{enumerate}[(i)]
\item\label{clse1} , 
\item\label{clse2}  induces a forest and , 
\item\label{clse3}  is an independent set, and 
\item\label{clse4} for every ,  and  is a double clique.
\end{enumerate}
\end{lemma}

\begin{proof} We divide the proof into three parts:  the identification of the set  and the proof of~(\ref{clse1}),  the transformation of  to an 
intermediate graph , the identification of the set , and the proof of~(\ref{clse2}), 
and finally,  the transformation of  to , the identification of  and the proof of~(\ref{clse3}) and~(\ref{clse4}).\\

\noindent {\bf Identification of the set  and proof of~(\ref{clse1}).}
We begin the proof of the lemma with the identification of the set . 
First notice that every tree deletion set of  of weight at most  is also a feedback vertex set of  of size at most  in the underlying non-weighted graph. Thus, by applying Theorem~\ref{apprxalgofvs} we may find 
in polynomial time a feedback vertex set  of . If  then output NO. Otherwise,
 
\noindent As the instance  is semi-reduced, Reduction Rule~\ref{rrule5} is not applicable and  does not contain a -flower of order , .
 Therefore, from Theorem~\ref{algosepvrt}, we get that for every  we can find in polynomial time a set  intersecting 
 every cycle that goes through  in  and such that 

Let  and notice that from the definition of , and Eq.~\eqref{fvsszebnd} and~\eqref{sepszebnd}, 

Let  and note that, as  is a feedback vertex set of , all 's are trees. 
 From now on, without loss of generality we will assume that  is rooted at some vertex , .\\

\noindent Let , . In other words,  denotes the set of vertices of  that are also vertices of , . 
Let also , that is, let  denote the least common ancestor-closure of the set  in the tree . 
Let  and note that . Observe now that from 
Lemma~\ref{caclsbnd} and Eq.~\eqref{qszebnd} we get that

Finally, we define  to be the set .
From Eq.~\eqref{fvsszebnd} and~\eqref{qclsszebnd} it follows that 

and we conclude the first part of our proof.\\

\noindent{\bf Transformation of  to an intermediate graph , identification of the set , and proof of~(\ref{clse2}).}
We continue our proof by working towards the identification of the set . 
First notice that a straightforward implication of Lemma~\ref{caclsbnd} is that we may partition 
into three sets , , and  in such a way that  
contains all the graphs in  that have exactly  neighbors in , .\\

\noindent {\em Claim 1.} For every connected component  and every vertex , , that is, 
every vertex  of  and every vertex  of  have at most one neighbor in every connected component  of .\\

\noindent {\em Proof of Claim 1.} Let  and  and assume to the contrary that . 
Then, as  is connected, the graph  contains a cycle that goes through .
 If , we end up to a contradiction to the facts that 
 and the set  intersects every cycle that goes through . If , it contradicts to the facts that 
  (recall that ) and  is acyclic. \hfill \\
 

\noindent Let , that is, 
. For every pair  we let 

and

In other words,  is the set of the connected components in  
whose neighborhood in  contains both  and  and  denotes the cardinality of . We partition  into 
two sets  and . In particular


\noindent Notice that Claim 1 implies that  equals the number of vertex-disjoint 
paths between  and  whose internal vertices belong to  .
Let . 
Observe then that if neither  nor  belong to a tree deletion set of  we need at least  vertices to hit all the cycles 
of  as otherwise, from the Pigeonhole Principle, for every  with  
there exist two connected components  and  in  
such that  and thus the graph induced by  contains a cycle.
This implies that  is a yes instance if and only if at least one of the vertices  and  is contained
in every tree deletion set of  of weight . Thus, the instance  obtained from  after adding
double edges between the pairs of vertices  and , , is equivalent to  and .
This completes the transformation of  to the intermediate graph . We continue now with the identification of the set 
and the proof of~(\ref{clse2}).\\

\noindent We let  and finally, we define  to be the set 

\noindent From the definition, it follows that  induces a forest. We now prove the upper bound on the size of . We first need the following.\\

\noindent {\em Claim 2.}
If  is a connected component of  then .\\

\noindent {\it Proof of Claim 2.}
Let  be a connected component of . 
First recall that, from Claim 1, every vertex of  has at most 1 neighbor in  and, from construction of , 
 has at most 2 neighbors in . This implies that there are at most  vertices in  that have a 
neighbor in , and in particular in . We call this set of vertices .
Let  be the set of vertices of degree 1 in , that is, the leaves of . From Reduction Rule~\ref{rrule3} it follows that for every ,  and thus, as ,  has at least one neighbor in . Therefore,  and 

Let now  be the set of vertices of degree at least 3 in . For  it is easy to observe that, by standard combinatorial arguments on trees, 


Finally, let  be the set  and  be the set of paths in  with endpoints in . Again, as , it holds
that .
Observe that by construction of  all the inner vertices of the paths in  have degree exactly 2. Therefore, from Reduction Rule~\ref{rrule4} we get that every path in  contains at most 2 vertices. This implies that .
To conclude, as , we get that .
 \hfill \\

\noindent We now prove an upper bound on . 
Notice first that, by definition,  can be written as the union of the graph classes  and , where 

and

Moreover,  and thus, it follows that 



\noindent From Claim 2, in order to prove an upper bound on  it is enough to prove upper bounds on  and .
Recall first that for every pair  there exist at most  connected components containing both  and  in their
common neighborhood and therefore 

\noindent For the upper bound on , for every  we partition the set 
into two sets  and  in the following way.

Observe that 
 
For every , it trivially holds that 

Moreover, we claim that for every , . Indeed, assume to the contrary that  for some F.
Then there exist  vertices , , such that
for every  there exist two connected components  and  in  such that 
. This implies that the graph induced by the vertex , the vertices , , and the
graphs  and , , contains a -flower of order  (notice that, as all the graphs belong to , 
they are pairwise disjoint). This is a contradiction to the fact that  is semi-reduced.
Therefore, for every ,

From Eq.~\eqref{eqnealwefaw},~\eqref{regaliuhgawel}, and~\eqref{lwekfjwaegfa} we obtain that

Finally, from Eq.~\eqref{eqngergkmlerg},~\eqref{aefalwefnlkflwa},~\eqref{aergwalag}, and Claim 2 we get that.



\noindent We continue by showing that 

\noindent Observe that, from Claim 2, in order to find an upper bound on  it is enough to 
find an an upper bound on .
We do so with the following claim.\\

\noindent {\em Claim 3.} .\\


\noindent {\em Proof of Claim 3.} Let , 
that is, let  be the set of neighbors of the graphs in  in .
Let  be the graph with vertex set  where two vertices in  are connected by an edge if and only if they are the neighbors of
a graph  in . Hence, the number of edges of  equals .
Notice then that if  is a forest the claim follows from Eq.~\eqref{qclsszebnd}.
We now work towards showing that  is a forest. Indeed, assume to the contrary that there exists a cycle in . 
Then it is easy to see that we may find a cycle
in the graph  induced by the graphs in  which correspond to the edges of the cycle in 
and their neighborhood in .
Recall that  and therefore  is a subgraph of .
This contradicts to the fact that  is a feedback vertex set of  and completes the proof of the claim.
\hfill \\


\noindent To conclude the proof of the upper bound on  we notice that Eq.~\eqref{cc2szebnd} follows from Claims 2 and 3, and the inequality below.

Thus, from Eq.~\eqref{grbgdfn},~\eqref{rstsze}, and~\eqref{cc2szebnd}, we obtain that .


\medskip

\noindent {\bf Transformation of  to , identification of , and proof of~(\ref{clse3}) and~(\ref{clse4}).}
We now continue with the construction of the graph  and the identification of the set .\\

\noindent In order to construct the graph  we first need the following claim for the connected components of .\\

\noindent {\em Claim 4.} For every connected component ,  and
 is a double clique.\\

\noindent {\em Proof of Claim 4.} Recall that,  and that . It follows that
. 
This implies that for every connected component , .
Let now  and  be two vertices in  that are not joined by a double edge. 
By construction of the graph , this implies that .
Moreover, the definitions of the sets  and , imply that there is no graph  such that 
. Therefore, for every graph , 
the graph induced by  is a double clique.
 \hfill \\

\noindent Finally, let  be the graph obtained from  after contracting every connected component  of  
into a single vertex  and setting as . We define  to be the set . 
Then~(\ref{clse3}) follows from construction of . Claim 4 implies that for every vertex , . 
This completes the proof of~(\ref{clse4}) and concludes the construction of the instance 
 and the identification of the sets , , and .\\

\noindent 
It remains to prove that the instances  and  are equivalent. 
As it has already been proved that the instances  and  are equivalent
it is enough to prove that  and  are equivalent.
Notice that if  is a yes instance then  is also a yes instance; for every vertex  in the tree deletion set of weight at most  of 
we consider the vertex  in the tree deletion set of  whenever  
and the vertices of the connected component that was contracted to  whenever .  
In order to prove that if  is a yes instance then  is also a yes instance we start with the 
following. \\

\noindent {\em Claim 5.} If there exists a tree deletion set  of  of weight at most  then there exists a tree deletion set  of  
of weight at most  such that for every , either  or .\\

\noindent {\em Proof of Claim 5.} Recall that for every  
it holds that  is a double clique (Claim 4).
Therefore, either  or there exists a unique vertex of  that does not belong to .
Notice that in the case where , as  is a separator of , 
it trivially follows that either  or  and the claim holds. Let us now assume that there exists a unique vertex  of 
 that does not belong to  and that . As, from Claim 1, every vertex of  has exactly
one neighbor in  it follows that the graph  does not contain a cycle.
Moreover,  is a cut vertex of  and therefore the graph  is a tree.
Thus in the case where  we can remove the vertices of  from  
without introducing any cycles to the graph .
Therefore  is also a tree deletion set of  and this concludes the proof of the claim.
\hfill \\

Let now  be a tree deletion set of  of weight at most . From Claim 5 we may assume that for every connected component  of 
 either  of .
Then it is straightforward to see that the vertex set  consisting of the vertices  and the vertices of  that correspond to the
connected components of  whose vertices belong to  is a tree deletion set of  of weight equal to the weight 
of .
\end{proof}

\subsection{Results on Linear Equations}\label{subsct:lnreqtns}

\begin{lemma}\label{mtrx1lem}
For every matrix  and positive integer , there exists a submatrix  of , 
where , such that for every  with , . 
Furthermore, the matrix  can be computed in time , where  is the matrix multiplication exponent (~\cite{Williams12}).
\end{lemma}

\begin{proof}
In order to identify  we identify  (non-empty) submatrices of  that have at most  rows each 
 in the following way:
First, let  be a minimal submatrix of  whose rows span all the rows of , that is, let  be a base of the 
vector space generated by the rows of , and 
let also  be the submatrix obtained from  after removing the rows of .
We identify the rest of the matrices inductively as follows: For every , if  is not the empty matrix we let  
be a minimal submatrix of  whose rows span all the rows of  and finally we let  be the matrix occurring 
from  after removing the rows of .

We now define the submatrix  of . Let  be the greatest integer for which  is not the empty matrix.
Let  be the matrix consisting of the union of the rows of the (non-empty) matrices  and , . 
As the rank of the matrices , , , is upper bounded by 
, the matrices , , , have at most  rows each, and therefore  has at most  rows. 
Observe that if  then the union of the rows of the non-empty matrices , , ,
contains all the rows of  and thus we may assume that  and the lemma trivially holds.
Hence, it remains to prove the lemma for the case where , and therefore  consists of the union of the matrices , .
 As it always holds that 
 
it is enough to prove that for every  for which 
 , . Thus, it is enough to prove that for every row  
 of the matrix  obtained from  after removing the rows of , it holds that . 
 Towards this goal let  be a vector such that . 
 From the Pigeonhole Principle there exists an  such that ,
 that is, if  are the rows of  then , for every .
Recall however that the row  of  is spanned by the rows  of . 
Therefore, there exist , , such that .
It follows that 
 
and therefore .
This implies that

Finally, for a rectangular matrix of size , , Bodlaender et al.~\cite{BodlaenderCKN13} give an algorithm that computes a minimum weight column basis in
time . By running this algorithm  times we can find the matrix  in time  and this completes the proof
of the lemma. 
\end{proof}

\begin{lemma}\label{mtrx2lem}
There exists an algorithm that given a set  of linear equations on  variables and an integer 
outputs a set  of at most  linear equations such that any assignment of the variables that violates at most  linear
equations of  satisfies all the linear equations of . Moreover, the running time of the algorithm is . 
\end{lemma}

\begin{proof}
Let  denote the  variables and  denote the coefficient of  in the -th linear equation of , , . 
Let also  denote the constant term of the -th linear equation of . In other words, the -th equation of  is denoted as
.
Finally, let  be the matrix where the -element of the -th row is 
, , . From Lemma~\ref{mtrx1lem}, it follows that
for every positive integer  there exists a submatrix  of  with at most  rows and  columns such that for every 
 for which ,  and
 can be computed in time . 
Let  be the set of linear equations that correspond to the rows of . Let then , 
, , be an assignment that does not satisfy at most  of the equations of .
This implies that , where . Again, from Lemma~\ref{mtrx1lem}, 
we get that . Thus, the above assignment satisfies all the
linear equations of .
\end{proof}

\subsection{The Main Theorem}

In this subsection by combining the structural decomposition of Subsection~\ref{subsct:strcdecomp} 
and Lemma~\ref{mtrx2lem} from Subsection~\ref{subsct:lnreqtns} we obtain a kernel for {\sc wTDS} of size .

\begin{theorem} 
{\sc wTDS} admits a kernel of size  and   bits.
\end{theorem}
\begin{proof}
Let  be an instance of {\sc wTDS}. Without loss of generality we may assume that it is semi-reduced and that, 
from Lemma~\ref{mainlem},  can be partitioned into 
three sets , , and  satisfying the conditions of Lemma~\ref{mainlem}. Note here that as  is semi-reduced,  is connected and therefore
every vertex of  has at least one neighbor in .
We construct an instance  of {\sc wTDS} in the following way.
Let  and . We assign a variable  to , , and a linear equation 
to , , where  is the equation  and  if  
and 0 otherwise. Let  and  be the subset of  obtained from Lemma~\ref{mtrx2lem}. 
Let also  and . We now prove that  is equivalent to . 

We first prove that if  is a yes instance then so is .
Let  be a tree deletion set of  of weight at most . Then  is a tree and as for every vertex , 
 is a double clique then  has degree exactly 1 in . Therefore, the graph obtained from  
after removing  is still a tree. This implies that  is a tree deletion
set of  of weight at most  and  is a yes instance.

Let now  be a yes instance and  be a tree deletion set of  of weight at most . 
We claim that there exist at most  vertices 
in  whose neighborhood lies entirely in . Indeed, assume to the contrary that there exist at least  vertices of  whose neighborhood lies
entirely in . Let  be the set of those vertices. Notice that for every vertex , if , then either  or 
.
Notice that if , then  has weight at least , a contradiction. Therefore, there exists a vertex  that is not contained in .
Then .  Moreover, recall that  has at least one neighbor  in  and from the hypothesis  is contained in . 
Therefore . As , it follows that . Furthermore, recall that 
. Thus, , a contradiction to the fact that  has weight at most .
Therefore, there exist at most  vertices of  whose neighborhood is contained entirely in .
For every , let , where  if  and 1 otherwise.
Then there exist at most  linear equations in  which are not satisfied by the above assignment. 
However, from the choice of  all the linear equations in  are satisfied and therefore, every vertex in  has exactly one 
neighbor in . Thus  is a tree and hence,  is a tree deletion set of  as well.

Notice that , where  (Lemma~\ref{mtrx2lem}) and therefore .
It is also easy to see that . Indeed, notice first that as the set  is an independent set there are no edges between its vertices. Moreover,
from Lemma~\ref{mainlem} there are no edges between the vertices of the set  and the set . Observe that, from the construction of  and subsequently
of , Lemma~\ref{mainlem} implies that every vertex of  has at most  neighbors in . As  there exist 
edges between the vertices of  and the vertices of . Notice that from~(\ref{clse2}) of Lemma~\ref{mainlem},  induces a forest and thus there 
exist at most  edges between its vertices. Moreover, from~(\ref{clse1}) of Lemma~\ref{mainlem}, again there exist  edges between the 
vertices of . It remains to show that there exist  edges with one endpoint in  and one endpoint in . Recall first that 
every  has at most one neighbor in every  connected component of  and that every connected component has at most 2 neighbors in
. Therefore, there exist at most  edges between every connected component of  and . 
Moreover, from Eq.~\eqref{grbgdfn},\eqref{eqngergkmlerg},~\eqref{aefalwefnlkflwa}, and~\eqref{aergwalag}, and Claim 3 we obtain that  contains 
 connected components. Therefore, there exist  edges with one endpoint in  and one endpoint in .
Thus, {\sc wTDS} has a kernel of  vertices and edges. 
Finally, from Reduction Rule~\ref{rrule6}, the weight of every vertex is upper bounded by  and thus, it can be encoded using  bits resulting to a
kernel of {\sc  wTDS} with  bits.
\end{proof}
\newpage

\bibliography{tdsbibl,tds-final}




\end{document}
