\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage[caption=false]{subfig}
\usepackage{mynotation}



\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

\newcommand{\parsection}[1]{\noindent\textbf{#1:}}

\cvprfinalcopy 

\def\cvprPaperID{****} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\ifcvprfinal\pagestyle{empty}\fi
\begin{document}

\title{ECO: Efficient Convolution Operators for Tracking}

\author{Martin Danelljan, Goutam Bhat, Fahad Shahbaz Khan, Michael Felsberg \\
	\small Computer Vision Laboratory, Department of Electrical Engineering, Link\"oping University, Sweden\\
	\small\{\texttt{martin.danelljan},\; \texttt{goutam.bhat},\; \texttt{fahad.khan},\; \texttt{michael.felsberg}\}\texttt{@liu.se}
	{}
}

\maketitle


\begin{abstract}
   In recent years, Discriminative Correlation Filter (DCF) based methods have significantly advanced the state-of-the-art in tracking. However, in the pursuit of ever increasing tracking performance, their characteristic speed and real-time capability have gradually faded. Further, the increasingly complex models, with massive number of trainable parameters, have introduced the risk of severe over-fitting. In this work, we tackle the key causes behind the problems of computational complexity \emph{and} over-fitting, with the aim of simultaneously improving \emph{both} speed and performance.

We revisit the core DCF formulation and introduce: (i) a factorized convolution operator, which drastically reduces the number of parameters in the model; (ii) a compact generative model of the training sample distribution, that significantly reduces memory and time complexity, while providing better diversity of samples; (iii) a conservative model update strategy with improved robustness and reduced complexity. We perform comprehensive experiments on four benchmarks: VOT2016, UAV123, OTB-2015, and TempleColor.
When using expensive deep features, our tracker provides a 20-fold speedup and achieves a  relative gain in Expected Average Overlap compared to the top ranked method \cite{DanelljanECCV2016} in the VOT2016 challenge. Moreover, our fast variant, using hand-crafted features, operates at 60 Hz on a single CPU, while obtaining  AUC on OTB-2015. \end{abstract}



\section{Introduction}


Generic visual tracking is one of the fundamental problems in computer vision. It is the task of estimating the trajectory of a target in an image sequence, given only its initial state. Online visual tracking plays a crucial role in numerous real-time vision applications, such as smart surveillance systems, autonomous driving, UAV monitoring, intelligent traffic control, and human-computer-interfaces. Due to the online nature of tracking, an ideal tracker should be accurate and robust under the hard computational constraints of real-time vision systems.

\begin{figure}[!t]
	\centering \newcommand{\wid}{0.25\columnwidth}\includegraphics*[trim = 80 0 90 0, width = \wid]{figures/intro/uav_wakeboard10140}\includegraphics*[trim = 90 0 80 0, width = \wid]{figures/intro/uav_wakeboard10165}\includegraphics*[trim = 80 0 90 0, width = \wid]{figures/intro/uav_wakeboard10201}\includegraphics*[trim = 30 0 140 0, width = \wid]{figures/intro/uav_wakeboard10240}
	\includegraphics*[trim = 0 0 0 50, width = \wid]{figures/intro/Human20810}\includegraphics*[trim = 0 0 0 50, width = \wid]{figures/intro/Human20997}\includegraphics*[trim = 0 0 0 50, width = \wid]{figures/intro/Human21052}\includegraphics*[trim = 0 0 0 50, width = \wid]{figures/intro/Human21105}
	\includegraphics*[trim = 10 0 60 0, width = \wid]{figures/intro/CarScale0140}\includegraphics*[trim = 10 0 60 0, width = \wid]{figures/intro/CarScale0205}\includegraphics*[trim = 10 0 60 0, width = \wid]{figures/intro/CarScale0212}\includegraphics*[trim = 10 0 60 0, width = \wid]{figures/intro/CarScale0224}
	\includegraphics*[trim = 2 2 2 5, width = 0.42\columnwidth]{figures/intro/legend}\vspace{-1mm}\caption{A comparison of our approach ECO with the baseline C-COT \cite{DanelljanECCV2016} on three example sequences. In all three cases, C-COT suffers from severe over-fitting to particular regions of the target. This causes poor target estimation in cases of scale variations (top row), deformations (middle row), and out-of-plane rotations (bottom row). Our ECO tracker successfully tackles the causes of over-fitting, leading to better generalization of the target appearance, while achieving a 20-fold speedup.}\vspace{-2.5mm}\label{fig:intro}\end{figure}

In recent years, Discriminative Correlation Filter (DCF) based approaches have shown continuous performance improvements in terms of accuracy and robustness on tracking benchmarks \cite{VOT2016,OTB2015}. The recent advancement in DCF based tracking performance is driven by the use of multi-dimensional features \cite{DanelljanCVPR14,galoogahiICCV13}, robust scale estimation \cite{DanelljanBMVC14,DanelljanTPAMI2016}, non-linear kernels \cite{Henriques14}, long-term memory components \cite{LTC_CVPR15}, sophisticated learning models \cite{KAUST_ECCV16,DanelljanCVPR2016a} and reducing boundary effects \cite{DanelljanICCV2015,GaloogahiCVPR2015}. However, these improvements in accuracy come at the price of significant reductions in tracking speed. For instance, the pioneering MOSSE tracker by Bolme \etal \cite{MOSSE2010} is about  faster than the recent top-ranked DCF tracker, C-COT \cite{DanelljanECCV2016}, in the VOT2016 challenge \cite{VOT2016}, but obtains only half the accuracy.

As mentioned above, the advancement in DCF tracking performance is predominantly attributed to powerful features and sophisticated learning formulations \cite{DanelljanVOT2015,DanelljanECCV2016,HCF_ICCV15}. This has led to substantially larger models, requiring hundreds of thousands of trainable parameters. On the other hand, such complex and large models have introduced the risk of severe over-fitting (see figure~\ref{fig:intro}). In this paper, we tackle the issues of over-fitting in recent DCF trackers, while restoring their hallmark real-time capabilities.

\subsection{Motivation}

We identify three key factors that contribute to \emph{both} increased computational complexity and over-fitting in state-of-the-art DCF trackers.

\parsection{Model size}
The integration of high-dimensional feature maps, such as deep features, has led to a radical increase in the number of appearance model parameters, often beyond the dimensionality of the input image. As an example, C-COT \cite{DanelljanECCV2016} continuously updates about 800,000 parameters during the online learning of the model. Due to the inherent scarcity of training data in tracking, such a high-dimensional parameter space is prone to over-fitting. Further, the high dimensionality causes an increase in the computational complexity, leading to slow tracking speed.

\parsection{Training set size}
State-of-the-art DCF trackers, including C-COT, require a large training sample set to be stored due to their reliance on iterative optimization algorithms. In practice however, the memory size is limited, particularly when using high-dimensional features. A typical strategy for maintaining a feasible memory consumption is to discard the oldest samples. This may however cause over-fitting to recent appearance changes, leading to model drift (see figure~\ref{fig:intro}). Moreover, a large training set increases the computational burden.

\parsection{Model update}
Most DCF-based trackers apply a continuous learning strategy, where the model is updated rigorously in every frame. On the contrary, recent works have shown impressive performance without any model update, using Siamese networks \cite{SiameseFC}. Motivated by these findings, we argue that the continuous model update in state-of-the-art DCF is excessive and sensitive to sudden changes caused by, \eg, scale variations, deformations, and out-of-plane rotations (see figure~\ref{fig:intro}). This excessive update strategy causes both lower frame-rates and degradation of robustness due to over-fitting to the recent frames.

\subsection{Contributions}
We propose a novel formulation that addresses the previously listed issues of state-of-the-art DCF trackers. As our first contribution, we introduce a factorized convolution operator that dramatically reduces the number of parameters in the DCF model. Our second contribution is a compact generative model of the training sample space that effectively reduces the number of samples in the learning, while maintaining their diversity. As our final contribution, we introduce an efficient model update strategy, that simultaneously improves tracking speed and robustness. 

Comprehensive experiments clearly demonstrate that our approach concurrently improves both tracking performance and speed, thereby setting a new state-of-the-art on four benchmarks: VOT2016, UAV123, OTB-2015, and TempleColor. Our approach significantly reduces the number of model parameters by , training samples by  and optimization iterations by  in the learning, compared to the baseline. On VOT2016, our approach outperforms the top ranked tracker, C-COT \cite{DanelljanECCV2016}, in the challenge, while achieving a significantly higher frame-rate. Furthermore, we propose a fast variant of our tracker that maintains competitive performance, with a speed of 60 frames per second (FPS) on a single CPU, thereby being especially suitable for computationally restricted robotics platforms. 
\section{Baseline Approach: C-COT}
\label{sec:CCOT}

In this work, we collectively address the problems of computational complexity and over-fitting in state-of-the-art DCF trackers. We adopt the recently introduced Continuous Convolution Operator Tracker (C-COT) \cite{DanelljanECCV2016} as our baseline. The C-COT obtained the top rank in the recent VOT2016 challenge \cite{VOT2016}, and has demonstrated outstanding results on other tracking benchmarks \cite{TempleColor,OTB2015}. Unlike the standard DCF formulation, Danelljan \etal \cite{DanelljanECCV2016} pose the problem of learning the filters in the continuous spatial domain. The generalized formulation in C-COT yields two advantages that are relevant to our work.

The first advantage of C-COT is the natural integration of multi-resolution feature maps, achieved by performing convolutions in the continuous domain. This provides the flexibility of choosing the cell size (\ie resolution) of each visual feature independently, without the need for explicit re-sampling.
The second advantage is that the predicted detection scores of the target are directly obtained as a continuous function, enabling accurate sub-grid localization.


Here, we briefly describe the C-COT formulation, adopting the same notation as in \cite{DanelljanECCV2016} for convenience. The C-COT discriminatively learns a convolution filter based on a collection of  training samples . Unlike the standard DCF, each feature layer  has an independent resolution .\footnote{For clarity, we present the one-dimensional domain formulation. The generalization to higher dimensions, including images, is detailed in \cite{DanelljanECCV2016}.} The feature map is transfered to the continuous spatial domain  by introducing an interpolation model, given by the operator ,

Here,  is an interpolation kernel with period . The result  is thus an interpolated feature layer, viewed as a continuous -periodic function. We use  to denote the entire interpolated feature map, where .

In the C-COT formulation, a continuous -periodic multi-channel convolution filter  is trained to predict the detection scores  of the target as,

The scores are defined in the corresponding image region  of the feature map . In \eqref{eq:conv_op}, the convolution of single-channel -periodic functions is defined as . The multi-channel convolution  is obtained by summing the result of all channels, as defined in \eqref{eq:conv_op}. The filters are learned by minimizing the following objective,

The labeled detection scores  of sample  is set to a periodically repeated Gaussian function. The data term consists of the weighted classification error, given by the -norm , where  is the weight of sample . The regularization integrates a spatial penalty  to mitigate the drawbacks of the periodic assumption, while enabling an extended spatial support \cite{DanelljanICCV2015}.


As in previous DCF methods, a more tractable optimization problem is obtained by changing to the Fourier basis. Parseval's formula implies the equivalent loss,

Here, the hat  of a -periodic function  denotes the Fourier series coefficients  and the -norm is defined by . The Fourier coefficients of the detection scores \eqref{eq:conv_op} are given by the formula , where  is the Discrete Fourier Transform (DFT) of .

In practice, the filters  are assumed to have finitely many non-zero Fourier coefficients , where .
Eq.~\eqref{eq:loss_fs} then becomes a quadratic problem, optimized by solving the normal equations,

Here,  and  are vectorizations of the Fourier coefficients in  and , respectively. The matrix  exhibits a sparse structure, with diagonal blocks containing elements of the form . Further,  is a diagonal matrix of the weights  and  is a convolution matrix with the kernel . The C-COT \cite{DanelljanECCV2016} employs the Conjugate Gradient (CG) method \cite{NumericalOptimization} to iteratively solve \eqref{eq:normal_eq}, since it was shown to effectively utilize the sparsity structure of the problem.


 
\section{Our Approach}
\label{sec:method}

\begin{figure*}[!t]
	\centering \newcommand{\wid}{4.23cm}\vspace{-3.5mm}\subfloat[C-COT\label{fig:filters_ccot}]{\includegraphics[height = \wid]{figures/ccot_filters_deep12.png}}\hspace{1mm}
	\subfloat[Ours\label{fig:filters_scot}]{\includegraphics[height = \wid]{figures/scot_filters_deep12.png}}\caption{Visualization of the learned filters corresponding to the last convolutional layer in the deep network. We display all the 512 filters  learned by the baseline C-COT (a) and the reduced set of 64 filters  obtained by our factorized formulation (b). The vast majority of the baseline filters contain negligible energy, indicating irrelevant information in the corresponding feature layers. Our factorized convolution formulation learns a compact set of discriminative basis filters with significant energy, achieving a radical reduction of parameters.}\vspace{-2mm}\label{fig:filters}
\end{figure*}

As discussed earlier, over-fitting and computational bottlenecks in the DCF learning stem from common factors. We therefore proceed with a collective treatment of these issues, aiming at both improved performance \emph{and} speed. 

\parsection{Robust learning}
As mentioned earlier, the large number of optimized parameters in \eqref{eq:loss_spatial} may cause over-fitting due to limited training data. We alleviate this issue by introducing a factorized convolution formulation in section~\ref{sec:fac}. This strategy radically reduces the number of model parameters by  in the case of deep features, while increasing tracking performance. Moreover, we propose a compact generative model of the sample distribution in section~\ref{sec:sample_model}, that boosts diversity and avoids the previously discussed problems related to storing a large sample set. Finally, we investigate strategies for updating the model in section~\ref{sec:optimization} and conclude that a less frequent update of the filter stabilizes the learning, which results in more robust tracking.

\parsection{Computational complexity}
The learning step is the computational bottleneck in optimization-based DCF trackers, such as C-COT. The computational complexity of the appearance model optimization in C-COT is obtained by analyzing the Conjugate Gradient algorithm applied to \eqref{eq:normal_eq}. The complexity can be expressed as ,\footnote{See the supplementary material for a derivation.} where  is the number of CG iterations and  is the average number of Fourier coefficients per filter channel. Motivated by this complexity analysis of the learning, we propose methods for reducing ,  and  in sections \ref{sec:fac}, \ref{sec:sample_model}, and \ref{sec:optimization} respectively.

\subsection{Factorized Convolution Operator}
\label{sec:fac}

We first introduce a factorized convolution approach, with the aim of reducing the number of parameters in the model. We observed that many of the filters  learned in C-COT contain negligible energy. This is particularly apparent for high-dimensional deep features, as visualized in figure~\ref{fig:filters}. Such filters hardly contribute to target localization, but still affect the training time. Instead of learning one separate filter for each feature channel , we use a smaller set of basis filters , where . The filter for feature layer  is then constructed as a linear combination  of the filters  using a set of learned coefficients . The coefficients can be compactly represented as a  matrix . The new multi-channel filter can then be written as the matrix-vector product . We obtain the factorized convolution operator,

The last equality follows from the linearity of convolution. The factorized convolution \eqref{eq:fac_conv_op} can thus alternatively be viewed as a two-step operation where the feature vector  at each location  is first multiplied with the matrix . The resulting -dimensional feature map is then convolved with the filter . The matrix  thus resembles a linear dimensionality reduction operator, as used in \eg \cite{DanelljanCVPR14}. The key difference is that we learn the filter  and matrix  \emph{jointly}, in a discriminative fashion, by minimizing the classification error \eqref{eq:loss_spatial} of the factorized operator \eqref{eq:fac_conv_op}. 

For simplicity, we consider learning the factorized operator \eqref{eq:fac_conv_op} from single training sample . To simplify notation, we use  to denote the Fourier coefficients of the interpolated feature map . The corresponding loss in the Fourier domain \eqref{eq:loss_fs} is derived as,

Here we have added the Frobenius norm of  as a regularization, controlled by the weight parameter .

Unlike the original formulation \eqref{eq:loss_fs}, our new loss \eqref{eq:loss_fac} is a non-linear least squares problem. Due to the bi-linearity of , the loss \eqref{eq:loss_fac} is similar to a matrix factorization problem \cite{Hong_2015_ICCV}. Popular optimization strategies for these applications, including Alternating Least Squares, are however not feasible due to the parameter size and online nature of our problem. Instead, we employ Gauss-Newton \cite{NumericalOptimization} and use the Conjugate Gradient method to optimize the quadratic subproblems. The Gauss-Newton method is derived by linearizing the residuals in \eqref{eq:loss_fac} using a first order Taylor series expansion. Here, this corresponds to approximating the bi-linear term  around the current estimate  as,

Here, we set . In the last equality, the Kronecker product  is used to obtain a vectorization of the matrix step .

The Gauss-Newton subproblem at iteration  is derived by substituting the first-order approximation \eqref{eq:taylor} into \eqref{eq:loss_fac},

Since the filter  is constrained to have finitely many non-zero Fourier coefficients, eq.\ \eqref{eq:GN_loss} is a linear least squares problem. The corresponding normal equations have a partly similar structure to \eqref{eq:normal_eq}, with additional components corresponding to the matrix increment  variable.\footnote{See supplementary material for the derivation of the normal equations.} We employ the Conjugate Gradient method to optimize each Gauss-Newton subproblem to obtain the new filter  and matrix increment . The filter and matrix estimates are then updated as  and .

The main objective of our factorized convolution operation is to reduce the computational and memory complexity of the tracker. Due to the adaptability of the filter, the matrix  can be learned just from the first frame. This has two important implications. Firstly, only the projected feature map  requires storage, leading to significant memory savings. Secondly, the filter can be updated in subsequent frames using the projected feature maps  as input to the method described in section~\ref{sec:CCOT}. This reduces the linear complexity in the feature dimensionality  to the filter dimensionality , \ie .

\begin{figure*}[!t]
	\centering \newcommand{\wid}{0.86\textwidth}\includegraphics[width = \wid]{figures/sample_model.pdf}\vspace{-2mm}
	\caption{Visualization of the training set representation in the baseline C-COT (bottom row) and our method (top row). In C-COT, the training set consists of a sequence of consecutive samples. This introduces large redundancies due to slow change in appearance, while previous aspects of the appearance are forgotten. This can cause over-fitting to recent samples. Instead, we model the training data as a mixture of Gaussian components, where each component represent a different aspect of the appearance. Our approach yields a compact yet diverse representation of the data, thereby reducing the risk of over-fitting.
	}\vspace{-3mm}\label{fig:sample_model}
\end{figure*}

\subsection{Generative Sample Space Model}
\label{sec:sample_model}

Here, we propose a compact generative model of the sample set that averts the earlier discussed issues of storing a large set of recent training samples. Most DCF trackers, such as SRDCF~\cite{DanelljanICCV2015} and C-COT~\cite{DanelljanECCV2016}, add one training sample  in each frame . The weights are typically set to decay exponentially , controlled by the learning rate . If the number of samples has reached a maximum limit , the sample with the smallest weight  is replaced. This strategy however requires a large sample limit  to obtain a representative sample set.

We observe that collecting a new sample in each frame leads to large redundancies in the sample set, as visualized in figure~\ref{fig:sample_model}. The standard sampling strategy (bottom row) populates the whole training set with similar samples , despite containing almost the same information. Instead, we propose to use a probabilistic generative model of the sample set that achieves a compact description of the samples by eliminating redundancy and enhancing variety (top).

Our approach is based on the joint probability distribution  of the sample feature maps  and corresponding desired outputs scores . Given , the intuitive objective is to find the filter that minimizes the expected correlation error. This is obtained by replacing \eqref{eq:loss_spatial} with
Here, the expectation  is evaluated over the joint sample distribution . Note that the original loss \eqref{eq:loss_spatial} is obtained as a special case by estimating the sample distribution as , where  denotes the Dirac impulse at the training sample .\footnote{We can without loss of generality assume the weights  sum to one.} 
Instead, we propose to estimate a compact model of the sample distribution  that leads to a more efficient approximation of the expected loss \eqref{eq:loss_expected}.

We observe that the shape of the desired correlation output  for a sample  is predetermined, here as a Gaussian function. The label functions  in \eqref{eq:loss_spatial} only differ by a translation that aligns the peak with the target center. This alignment is equivalently performed by shifting the feature map . We can thus assume that the target is centered in the image region and that all  are identical. 
Hence, the sample distribution can be factorized as  and we only need to estimate .
For this purpose we employ a Gaussian Mixture Model (GMM) 
such that . Here,  is the number of Gaussian components ,  is the prior weight of component , and  is its mean. The covariance matrix is set to the identity matrix  to avoid costly inference in the high-dimensional sample space.

To update the GMM, we use a simplified version of the online algorithm by Declercq and Piater~\cite{Declercq2008}. Given a new sample , we first initialize a new component  with  and  (\emph{concatenate} in~\cite{Declercq2008}). If the number of components exceeds the limit , we \emph{simplify} the GMM.  We discard a component if its weight  is below a threshold. Otherwise, we merge the two closest components  and  into a common component ~\cite{Declercq2008},

The required distance comparisons  are efficiently computed in the Fourier domain using Parseval's formula. Finally, the expected loss \eqref{eq:loss_expected} is approximated as,

Note that the Gaussian means  and the prior weights  directly replace  and , respectively, in \eqref{eq:loss_spatial}. So, the same training strategy as described in section~\ref{sec:CCOT} can be applied.

The key difference in complexity compared to \eqref{eq:loss_spatial} is that the number of samples has decreased from  to . In our experiments, we show that the number of components  can be set to , while obtaining an improved tracking performance. Our sample distribution model  is combined with the factorized convolution from section~\ref{sec:fac} by replacing the sample   with the projected sample . The projection does not affect our formulation since the matrix  is constant after the first frame.

\subsection{Model Update Strategy}
\label{sec:optimization}

The standard approach in DCF based tracking is to update the model in each frame \cite{MOSSE2010,DanelljanICCV2015,Henriques14}. In C-COT, this implies optimizing \eqref{eq:loss_spatial} after each new sample is added, by iteratively solving the normal equations \eqref{eq:normal_eq}. Iterative optimization based DCF methods exploit that the loss function changes gradually between frames. The current estimate of the filter therefore provides a good initialization of the iterative search. Still, updating the filter in each frame have a severe impact on the computational load.

Instead of updating the model in a continuous fashion every frame, we use a sparser updating scheme, which is a common practice in non-DCF trackers \cite{MDNet,MEEM2014}. Intuitively, an optimization process should only be started once sufficient change in the objective has occurred. However, finding such conditions is non-trivial and may lead to unnecessarily complex heuristics. Moreover, optimality conditions based on the gradient of the loss \eqref{eq:loss_spatial}, given by the residual of \eqref{eq:normal_eq}, are expensive to evaluate in practice. We therefore avoid explicitly detecting changes in the objective and simply update the filter by starting the optimization process in every th frame. The parameter  determines how often the filter is updated, where  corresponds to optimizing the filter in every frame, as in standard DCF methods. In every th frame, we perform a fixed number of  Conjugate Gradient iterations to refine the model. As a result, the average number of CG iterations per frame is reduced to , which has a substantial effect on the overall computational complexity of the learning. Note that  does not affect the updating of the sample space model, introduced in section~\ref{sec:sample_model}, which is updated every frame. 

To our initial surprise, we observed that a moderately infrequent update of the model () generally led to improved tracking results. We mainly attribute this effect to reduced over-fitting to the recent training samples. By postponing the model update a few frames, the loss is updated by adding a new mini-batch to the training samples, instead of only a single one. This might contribute to stabilizing the learning, especially in scenarios where a new sample is affected by sudden changes, such as out-of-plane rotations, deformations, clutter, and occlusions (see figure~\ref{fig:intro}).

While increasing  leads to reduced computations, it may also reduce the convergence speed of the optimization, resulting in a less discriminative model. A naive compensation by increasing the number of CG iterations  would counteract the achieved computational gains. Instead, we aim to achieve a faster convergence by better adapting the CG algorithm to online tracking, where the loss changes dynamically. This is obtained by substituting the standard Fletcher-Reeves formula to the Polak-Ribi\`ere formula \cite{CGpain} for finding the momentum factor, since it has shown improved convergence rates for inexact and flexible preconditioning \cite{IPCG}, which have similarities to our scenario.
 
\section{Experiments}
We validate our proposed formulation by performing comprehensive experiments on
four benchmarks: VOT2016 \cite{VOT2016}, UAV123 \cite{UAV123}, OTB-2015 \cite{OTB2015}, and TempleColor \cite{TempleColor}.

\begin{table}[!t]
	\centering
	\resizebox{0.85\columnwidth}{!}{\begin{tabular}{lcccc}
\toprule
&Conv-1&Conv-5&HOG&CN\\\midrule
Feature dimension, &96&512&31&11\\
Filter dimension, &16&64&10&3\\\bottomrule
\end{tabular} 	}\vspace{1mm}\caption{The settings of the proposed factorized convolution approach, as employed in our experiments. For each feature, we show the dimensionality  and the number of filters .}\label{tab:fac_settings}\vspace{-3mm}
\end{table}


\subsection{Implementation Details}
\label{sec:details}
Our tracker is implemented in Matlab. We apply the same feature representation as C-COT, namely a combination of the first (Conv-1) and last (Conv-5) convolutional layer in the VGG-m network \cite{Chatfield14}, along with HOG \cite{Dalal05} and Color Names (CN) \cite{Weijer09a}. For the factorized convolution presented in section~\ref{sec:fac}, we learn one coefficient matrix  for each feature type. The settings for each feature is summarized in table~\ref{tab:fac_settings}. The regularization parameter  in \eqref{eq:loss_fac} is set to . The loss \eqref{eq:loss_fac} is optimized in the first frame using 10 Gauss-Newton iterations and 20 CG iterations for the subproblems \eqref{eq:GN_loss}. In the first iteration , the filter  is initialized to zero. To preserve the deterministic property of the tracker, we initialize the coefficient matrix  by PCA, though we found random initialization to be equally robust.

For the sample space model, presented in section~\ref{sec:sample_model}, we set the learning rate to . The number of components are set to , which represents an 8-fold reduction compared to the number of samples () used in C-COT. We update the filter in every  frame (section~\ref{sec:optimization}). We use the same number of  Conjugate Gradient iterations as in C-COT. Note that \emph{all} parameters settings are kept fixed for all videos in a dataset.

\begin{table}[!t]
	\centering
	\resizebox{\columnwidth}{!}{\begin{tabular}{l@{}c@{}c@{}c@{}c@{}c@{}c@{\hspace{-3mm}}c}
\toprule
&Baseline&&Factorized&&Sample&&Model\\
&C-COT&&Convolution&&Space Model&&Update\\
&(Sec.~\ref{sec:CCOT})&&(Sec.~\ref{sec:fac})&&(Sec.~\ref{sec:sample_model})&&(Sec.~\ref{sec:optimization})\\\midrule
EAO&0.331&&0.342&&0.352&&\tabfirst{0.374}\\
FPS&0.3&&1.1&&2.6&&6.0\\
Compl.\ change&-&&&&&&\\
Compl.\ red.&-&&&&&&\\
\bottomrule
\end{tabular}
 	}\vspace{1mm}\caption{Analysis of our approach on the VOT2016. The impact of progressively integrating one contribution at the time, from left to right, is displayed. We show the performance in Expected Average Overlap (EAO) and speed in FPS (benchmarked on a single CPU). We also summarize the reduction in learning complexity  obtained in each step, both symbolically and in absolute numbers (bottom row) using our settings. Our contributions systematically improve both performance and speed.}\label{tab:baseline}\vspace{-4mm}
\end{table}

\subsection{Baseline Comparison}
\label{sec:baseline_results}

Here, we analyze our approach on the VOT2016 benchmark by demonstrating the impact of progressively integrating our contributions. The VOT2016 dataset consists of 60 videos compiled from a set of more than 300 videos. The performance is evaluated both in terms of accuracy (average overlap during successful tracking) and robustness (failure rate). The overall performance is evaluated using Expected Average Overlap (EAO) which accounts for both accuracy and robustness. We refer to \cite{VOT2015} for details.

Table~\ref{tab:baseline} shows an analysis of our contributions. The integration of our factorized convolution into the baseline leads to a performance improvement and a significant reduction in complexity (). The sample space model further improves the performance by a relative gain of  in EAO, while reducing the learning complexity by a factor of . Additionally incorporating our proposed model update elevates us to an EAO score of , leading to a final relative gain of  compared to the baseline. In table~\ref{tab:baseline} we also show the impact on the tracker speed achieved by our contributions. For a fair comparison, we report the FPS measured on a single CPU for all entries in the table, without accounting for feature extraction time. Each of our contributions systematically improves the speed of the tracker, combining to a 20-fold final gain compared to the baseline. When including all steps (also feature extraction), the GPU version of our tracker operates at 8 FPS.

\begin{figure}[!t]
	\centering \newcommand{\wid}{0.8\columnwidth}
	\includegraphics[width = \wid]{figures/sota_VOT/VOT2016_EAO_log.pdf}\vspace{-0.5mm}
	\caption{Expected Average Overlap (EAO) curve on VOT2016. Only the top 10 trackers are shown for clarity. The EAO measure, computed as the average EAO over typical sequence lengths (grey region), is displayed in the legend (see \cite{VOT2015} for details).
}\vspace{-2mm}\label{fig:vot_eao}
\end{figure}

We found the settings in table~\ref{tab:fac_settings} to be insensitive to minor changes. Substantial gain in speed can be obtained by reducing the number of filters , at the cost of a slight reduction in performance. To further analyze the impact of our jointly learned factorized convolution approach, we compare with applying PCA in the first frame to obtain the matrix . PCA degrades the EAO from  to , while our discriminative learning based method achieves .

We observed that our sample model provides consistently better results compared to the training sample set management employed in C-COT when using the same number of components and samples (). This is particularly evident for a smaller number of components/samples: When reducing the number of samples from  to  in the standard approach, the EAO decreases from  to  (). Instead, when using our approach with  components, the EAO increases by  to . In case of the model update, we observed an upward trend in performance when increasing  from 1 to 6. When increasing  further, a gradual downward trend was observed. We therefore use  throughout our experiments.

\begin{table}[!t]
	\centering
	\resizebox{1.01\columnwidth}{!}{\begin{tabular}{l@{~}c@{~~}c@{~~}c@{~~}c@{~~}c@{~~}c@{~~}c@{~~}c@{~~}c@{~~}c}
	\toprule
	&SRBT&EBT&DDC&Staple&MLDF&SSAT&TCNN&C-COT&\textbf{ECO-HC}&\textbf{ECO}\\
	&\cite{VOT2016}&\cite{EBT}&\cite{VOT2016}&\cite{Staple}&\cite{VOT2016}&\cite{VOT2016}&\cite{TCNN}&\cite{DanelljanECCV2016}&Ours&Ours\\\midrule
	EAO&0.290&0.291&0.293&0.295&0.311&0.321&0.325&\tabsecond{0.331}&0.322&\tabfirst{0.374}\\
	Fail.\ rt.&1.25&0.90&1.23&1.35&\tabsecond{0.83}&1.04&0.96&0.85&1.08&\tabfirst{0.72}\\
	Acc.&0.50&0.44&0.53&\tabsecond{0.54}&0.48&\tabfirst{0.57}&\tabsecond{0.54}&0.52&0.53&\tabsecond{0.54}\\
	EFO&3.69&3.01&0.20&\tabsecond{11.14}&1.48&0.48&1.05&0.51&\tabfirst{15.13}&4.53\\\bottomrule
\end{tabular}

 	}\vspace{1mm}\caption{State-of-the-art in terms of expected average overlap (EAO), robustness (failure rate), accuracy, and speed (in EFO units) on the VOT2016 dataset. Only the top-10 trackers are shown. Our deep feature based ECO achieve superior EAO, while our hand-crafted feature version (ECO-HC) has the best speed.}\label{tab:VOT_sota}\vspace{-2mm}
\end{table}

\subsection{State-of-the-art Comparison}
Here, we compare our approach with state-of-the-art trackers on four challenging tracking benchmarks. Detailed results are provided in the supplementary material.

\begin{figure*}[!t]
	\centering \newcommand{\wid}{0.33\textwidth}\vspace{-3.5mm}
	\subfloat[UAV123\label{fig:sota_uav}]{\includegraphics[width = \wid]{figures/sota_uav/quality_plot_overlap_OPE_AUC}}\subfloat[OTB-2015\label{fig:sota_otb}]{\includegraphics[width = \wid]{figures/sota_OTB100/quality_plot_overlap_OPE_AUC}}\subfloat[Temple-Color\label{fig:sota_tpl}]{\includegraphics[width = \wid]{figures/sota_tpl/quality_plot_overlap_OPE_AUC}}\caption{Success plots on the UAV-123 (a), OTB-2015 (b) and TempleColor (c) datasets. Only the top 10 trackers are shown in the legend for clarity. The AUC score of each tracker is shown in the legend. Our approach significantly improves the state-of-the-art on all datasets.}\vspace{-2mm}\label{fig:success_plots}
\end{figure*}

\parsection{VOT2016 Dataset}
In table~\ref{tab:VOT_sota} we compare our approach, in terms of expected average overlap (EAO), robustness, accuracy and speed (in EFO units), with the top-ranked trackers in the VOT2016 challenge. The first-ranked performer in VOT2016 challenge, C-COT, provides an EAO score of . Our approach achieves a relative gain of  in EAO compared to C-COT. Further, our ECO tracker achieves the best failure rate of  while maintaining a competitive accuracy. We also report the total speed in terms of EFO, which normalizes the speed with respect to hardware performance. Note that EFO also takes feature extraction time into account, a major additive complexity that is independent of our DCF improvements. In the comparison, our tracker ECO-HC using only hand-crafted features (HOG and Color Names) achieves the best speed. Among the top three trackers in the challenge, which are all based on deep features, TCNN \cite{TCNN} obtains the best speed with an EFO of . Our deep feature version (ECO) achieves an almost 5-fold speedup in EFO and a relative performance improvement of  in EAO compared to TCNN. Figure~\ref{fig:vot_eao} displays the EAO curves of the top-10 trackers.

\parsection{UAV123 Dataset}
Aerial tracking using unmanned aerial vehicles (UAVs) has received much attention recently, with many vision applications, including wild-life monitoring, search and rescue, navigation, and crowd surveillance. In these applications, persistent UAV navigation is required, for which real-time tracking output is crucial. In such cases, the desired tracker should be accurate and robust, while operating in real-time under limited hardware capabilities, \eg, CPUs or mobile GPU platforms. We therefore introduce a real-time variant of our method (ECO-HC), based on hand-crafted features (HOG and Color Names), operating at 60 FPS on a single i7 CPU (including feature extraction).

We evaluate our trackers on the recently introduced aerial video benchmark, UAV123 \cite{UAV123}, for low altitude UAV target tracking. The dataset consists of 123 aerial videos with more than 110K frames. The trackers are evaluated using success plot \cite{Wu13}, calculated as percentage of frames with an intersection-over-union (IOU) overlap exceeding a threshold. Trackers are ranked using the area-under-the-curve (AUC) score. Figure~\ref{fig:sota_uav} shows the success plot over all the 123 videos in the dataset. We compare with all tracking results reported in \cite{UAV123} and further add Staple \cite{Staple}, due to its high frame-rate, and C-COT \cite{DanelljanECCV2016}. Among the top 5 compared trackers, only Staple runs at real-time, with an AUC score of . Our ECO-HC tracker also operates in real-time (60 FPS), with an AUC score of , significantly outperforming Staple by . C-COT obtains an AUC score of . Our ECO outperforms C-COT, achieving an AUC score of , using same features.

\parsection{OTB2015 Dataset}
We compare our tracker with 20 state-of-the-art methods: TLD \cite{Mikolajczyk10d}, Struck \cite{Torr11b}, CFLB \cite{GaloogahiCVPR2015}, ACT \cite{DanelljanCVPR14}, TGPR \cite{TGPR2014}, KCF \cite{Henriques14}, DSST \cite{DanelljanBMVC14}, SAMF \cite{Li2014}, MEEM \cite{MEEM2014}, DAT \cite{possegger15a}, LCT \cite{LTC_CVPR15}, HCF \cite{HCF_ICCV15}, SRDCF \cite{DanelljanICCV2015}, SRDCFad \cite{DanelljanCVPR2016a}, DeepSRDCF \cite{DanelljanVOT2015}, Staple \cite{Staple}, MDNet \cite{MDNet}, SiameseFC \cite{SiameseFC}, TCNN \cite{TCNN} and C-COT \cite{DanelljanECCV2016}.

Figure~\ref{fig:sota_otb} shows the success plot over all the 100 videos in the OTB-2015
dataset \cite{OTB2015}. Among the compared trackers using hand-crafted features, SRDCFad provides the best results with an AUC score of . Our proposed method, ECO-HC, also employing hand-crafted features outperforms SRDCFad with an AUC score of , while running on a CPU with a speed of 60 FPS. Among the compared deep feature trackers, C-COT, MDNet and TCNN provide the best results with AUC scores of ,  and  respectively. Our approach ECO, provides the best performance with an AUC score of .

\parsection{TempleColor Dataset}
In figure~\ref{fig:sota_tpl} we present results on the TempleColor dataset \cite{TempleColor} containing 128 videos. Our method again achieves a substantial improvement over C-COT, with a gain of  in AUC.
 
\section{Conclusions} 
We revisit the core DCF formulation to counter the issues of over-fitting and computational complexity. 
We introduce a factorized convolution operator to reduce the number of parameters in the model. We also propose a compact generative model of the training sample distribution to drastically reduce memory and time complexity of the learning, while enhancing sample diversity. Lastly, we suggest a simple yet effective model update strategy that reduces over-fitting to recent samples. Experiments on four datasets demonstrate state-of-the-art performance with improved frame rate. 

\noindent\textbf{Acknowledgments}:
This work has been supported by SSF (SymbiCloud), VR (EMC, starting grant 2016-05543), SNIC, WASP, Visual Sweden, and Nvidia. 

{\small
\bibliographystyle{ieee}
\bibliography{references}
}

\clearpage


\section*{Supplementary Material}

This supplementary material contains additional details and derivations related to the our approach presented in section~\ref{sec:method}. It also includes hardware specifications and additional experimental results on the VOT2016 and OTB-2015 datasets.

\subsection*{Complexity Analysis of the Learning}
\label{sec:supp_complexity}

Here, we derive the computational complexity of the learning step in the baseline C-COT \cite{DanelljanECCV2016}. The learning itself is completely dominated by the problem of solving the normal equations \eqref{eq:normal_eq}.
This linear system is iteratively solved using the Conjugate Gradient (CG) method \cite{NumericalOptimization,CGpain}. The dominating computation in CG is the evaluation of the left-hand side of \eqref{eq:normal_eq}, which is performed once per CG iteration. This computation is performed as

where the parentheses are used to indicate the order in which the operations are performed. Since the conjugate symmetry in the filter  is preserved by the operations in \eqref{eq:cg_order}, only half of the spectrum needs to be processed. We can therefore regard  as a complex vector of  elements, where  is the bandwidth of channel  in the filter (see section~\ref{sec:CCOT}),  is the average number of Fourier coefficients per channel and  is the number of feature channels .

The matrix  contains a diagonal block  of size  for each sample  and channel . Here, we have defined . The diagonal of  consists of the elements . As previously shown for the discrete DCF case \cite{galoogahiICCV13}, the matrix  can be permuted to a block diagonal matrix , where  contains the elements . The operations  and  can thus be implemented as block-wise dense matrix-vector multiplications, with a total of  operations. Moreover,  is a diagonal matrix containing the weights , giving  operations.

In the second term of \eqref{eq:cg_order}, arising from the spatial regularization in the loss \eqref{eq:loss_spatial},  and  are convolution matrices with the kernel . These operations have a complexity of , where  are the number of non-zero coefficients in  (\ie the size of the kernel). In practice however, the kernel  is small (typically ), having a lesser impact on the overall complexity. To simplify the complexity expression, we therefore disregard this term. By taking the number of CG iterations  into account, we thus obtain the final expression   for the complexity of the learning step.

The preprocessing steps needed for the CG optimization only have a marginal impact on the overall learning time. The most significant of these being the Fast Fourier Transform (FFT) of the feature map, having a  complexity, where  is the resolution of feature channel . But since the FFT computations correspond to roughly  of the total time in C-COT, we exclude this part.

\subsection*{Factorized Convolution Operator Optimization}
\label{sec:supp_optimization}

Here, we provide more details regarding the optimization procedure for learning the factorized convolution operator (section~\ref{sec:fac}). We consider the case of learning the factorized operator  in \eqref{eq:fac_conv_op} based on a single sample ,

The loss is obtained by employing the factorized operator  in the data term of the original loss \eqref{eq:loss_spatial} and adding a regularization on the Frobenius norm  of .

By applying the Parseval's formula to the first two terms of \eqref{eq:fac_spatial} and utilizing the linearity and convolution properties of the Fourier series coefficients, we obtain the equivalent loss \eqref{eq:loss_fac}, where we have defined the interpolated feature map as  to simplify notation. Note that the matrix-vector products in \eqref{eq:loss_fac} are performed point-wise,


We use the Gauss-Newton method \cite{NumericalOptimization} to optimize the non-linear least squares problem \eqref{eq:loss_fac}. In each iteration , the residual in the data-term is linearized by performing a first order Taylor expansion \eqref{eq:taylor} at the current estimate . This gives the following quadratic sub-problem \eqref{eq:GN_loss}.
To derive a simple formula for the normal equations of \eqref{eq:GN_loss}, we first introduce some notation. Let  be the vectorization of , analogously to \eqref{eq:normal_eq}, and define . Further, let  denote the th column in  and set . We then define the matrices,

Here,  has a structure very similar to the matrix  in \eqref{eq:normal_eq}, but contains only a single training sample. Note that the diagonal blocks in  are padded with zero matrices  along the columns to achieve the same number of  rows.

The Gauss-Newton sub-problem \eqref{eq:GN_loss} can then be expressed as,

Here, the convolution matrix  and the vectorization  are defined as in \eqref{eq:normal_eq}. The normal equations of \eqref{eq:GN_quadratic} are obtained by setting the gradient to zero,

We employ the Conjugate Gradient method to iteratively solve the sub-problem \eqref{eq:GN_normal}.

\subsection*{Hardware Specifications}
\label{sec:supp_hw}

Our tracker is implemented in Matlab and uses Matconvnet \cite{matconvnet} for deep feature extraction. The frame-rate measurements of our CPU implementation were performed on a desktop computer with a 4-core Intel Core i7-6700 CPU at  GHz. The frame-rate measurements of our GPU implementation were performed on a Tesla K40 GPU.

\subsection*{Additional Results on VOT2016}
\label{sec:supp_VOT}
Here, we provide further experimental evaluation on the VOT2016 dataset \cite{VOT2016} with 60 videos. The videos and the evaluation toolkit can be obtained from \url{http://www.votchallenge.net/vot2016/}.

In the VOT2016 dataset, each frame is labeled with five different attributes: camera motion, illumination change, occlusion, size change and motion change. Figure~\ref{fig:VOT_attribute} visualizes the EAO of each attribute individually. Our approach achieves the best results on three attributes and improves over the baseline C-COT \cite{DanelljanECCV2016} on all five attributes.

\begin{figure}[!t]
	\centering
	\newcommand{\wid}{\columnwidth}
	\newcommand{\name}{figures/sota_VOT}
	\includegraphics[width=\wid]{\name /VOT2016_attributes.pdf}\caption{Expected Average Overlap (EAO) scores for each attribute on the VOT2016 dataset. Here, \emph{empty} denotes frames with no labeled attribute.}
	\label{fig:VOT_attribute}
\end{figure}

\subsection*{Additional Results on OTB-2015}
\label{sec:supp_OTB}
Here, we report additional results on the OTB-2015 dataset \cite{OTB2015} with 100 videos. The ground truth annotations and videos are available at \url{https://sites.google.com/site/benchmarkpami/}.

In the OTB-2015 dataset, each video is annotated with 11 different attributes: scale variation, background clutter, out-of-plane rotation, in-plane rotation, illumination variation, motion blur, fast motion, deformation, occlusion, out of view and low resolution. The success plots of all attributes are shown in figure~\ref{fig:attribute}. Our ECO tracker achieves the best performance on 8 out of 11 attributes. Further, our method improves over the baseline C-COT \cite{DanelljanECCV2016} on 9 out of 11 attributes. For a fair comparison, we employ the same combination of deep and hand-crafted features in the baseline C-COT and as in our ECO tracker on the OTB, TempleColor and UAV123 datasets (Conv1, Conv5 and HOG). Note that this set of features provides substantially improved performance in C-COT compared to the original results reported in \cite{DanelljanECCV2016}, where only deep convolutional features are used.



\begin{figure*}[!t]
	\centering
	\newcommand{\wid}{0.33\textwidth}
	\newcommand{\name}{figures/sota_OTB100}
	\newcommand{\eval}{OPE}
	\includegraphics[width=\wid]{\name /quality_plot_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /scale_variations_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /background_clutter_overlap_\eval _AUC.pdf}
	\includegraphics[width=\wid]{\name /out-of-plane_rotation_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /in-plane_rotation_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /illumination_variations_overlap_\eval _AUC.pdf}
	\includegraphics[width=\wid]{\name /blur_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /abrupt_motion_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /deformation_overlap_\eval _AUC.pdf}
	\includegraphics[width=\wid]{\name /occlusions_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /out-of-view_overlap_\eval _AUC.pdf}\includegraphics[width=\wid]{\name /low_resolution_overlap_\eval _AUC.pdf}
	\caption{Success plots on the OTB-2015 dataset \cite{OTB2015}. The total success plot (top-left) is displayed along with the plots for all 11 attributes. The title text indicate the name of the attribute and the number of videos associated with it. The area-under-the-curve scores for the top 10 trackers are shown in the legend.}
	\label{fig:attribute}
\end{figure*} 
\end{document}
