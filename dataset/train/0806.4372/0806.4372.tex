\documentclass[10pt]{article}
\usepackage{pst-all}
\usepackage{letterspace}
\usepackage{psfrag}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{graphicx}
\usepackage{caption2}
\usepackage[noend]{algorithmic}
\usepackage[plain]{algorithm}


\usepackage{color}
\usepackage[nohead, top=3cm, bottom=1cm, left=2.9cm,
right=3.1cm]{geometry}


\usepackage{letterspace}
\usepackage{graphicx}
\usepackage{psfrag}






\def\yskip{\penalty-50\vskip3pt plus3pt minus2pt}
\def\y{\yskip}
\def\yy{\yskip\yskip}
\def\yyy{\yskip\yskip\yskip}
\def\qed{\hskip 3pt\vrule height 6pt width 3pt depth 0pt}
\def\q5uad{\quad\quad\quad\quad\quad}

\def\mytab{\phantom{xxxx}}

\def\sec#1#2{\par\yskip\yskip\yskip
\noindent{\bb #1. #2}\par
    \nobreak\vskip .2cm\noindent}
\def\subsec#1#2{\par\yskip\yskip\yskip\noindent{\bf #1.
#2}\nobreak\yskip
    \noindent}

\def\myhang{\par\yskip\hangindent21pt}
\def\mynoindent{\par\yskip}
\def\chl{\yyy\y\par\noindent}


\def\s{\ }
\def\ss{\ \ }
\def\sss{\ \ \ }
\def\ssss{\ \ \ \ }
\def\bs{\ssss \s}
\def\Bs{\bs \bs}
\def\BBs{\Bs \Bs}


\newcommand\kreis[1]{\ensuremath{\mathbin{\settowidth{\dimen7}{\mbox{}}\makebox[0pt][l]{}\makebox[\dimen7]{#1}}}}


\usepackage{fancyheadings}
\pagestyle{fancyplain} \headrulewidth=0pt

\lhead{} \chead{} \rhead{}

\lfoot{}

\cfoot{\phantom{\Large} \thepage}

\rfoot{}

\def\baselinestretch{1.14}





\title{\bf The 1-fixed-endpoint Path Cover Problem is Polynomial on Interval Graphs \vspace{0.4cm}}

\author{\large Katerina Asdre \s and \s Stavros D. Nikolopoulos}

\date{}

\begin{document}

\maketitle

\vspace{-0.6cm}

\centerline{\it Department of Computer Science, University of
Ioannina}

\centerline{\it P.O.Box 1186, GR-45110 \s Ioannina, Greece}

\centerline{\tt \{katerina, stavros\}@cs.uoi.gr}

\vskip 0.3in

\begin{center}
\noindent
\parbox{5.5in}
{{\bf Abstract:} \s We consider a variant of the path cover
problem, namely, the -fixed-endpoint path cover problem, or kPC
for short, on interval graphs. Given a graph  and a subset
 of  vertices of , a -fixed-endpoint path
cover of  with respect to  is a set of
vertex-disjoint paths  that covers the vertices of
 such that the  vertices of  are all endpoints
of the paths in . The kPC problem is to find a
-fixed-endpoint path cover of  of minimum cardinality; note
that, if  is empty the stated problem coincides with
the classical path cover problem. In this paper, we study the
1-fixed-endpoint path cover problem on interval graphs, or 1PC for
short, generalizing the 1HP problem which has been proved to be
NP-complete even for small classes of graphs. Motivated by a work
of Damaschke \cite{Damaschke}, where he left both 1HP and 2HP
problems open for the class of interval graphs, we show that the
1PC problem can be solved in polynomial time on the class of
interval graphs. The proposed algorithm is simple, runs in
 time, requires linear space, and also enables us to solve
the 1HP problem on interval graphs within the same time and space
complexity.


\bigskip
\noindent {\bf Keywords:} \s perfect graphs, interval graphs, path
cover, fixed-endpoint path cover, linear-time algorithms.}
\end{center}


\vskip 0.3in \section{Introduction}
{\bf Framework--Motivation.} A well studied problem with numerous
practical applications in graph theory is to find a minimum number
of vertex-disjoint paths of a graph  that cover the vertices of
. This problem, also known as the path cover problem (PC),
finds application in the fields of database design, networks, code
optimization among many others (see \cite{AdPe90, AR90, LiOlPru95,
SSSR93}); it is well known that the path cover problem and many of
its variants are NP-complete in general graphs \cite{GaJo79}. A
graph that admits a path cover of size one is referred to as
Hamiltonian. Thus, the path cover problem is at least as hard as
the Hamiltonian path problem (HP), that is, the problem of
deciding whether a graph is Hamiltonian. The path cover problem is
known to be NP-complete even when the input is restricted to
several interesting special classes of graphs; for example, it is
NP-complete on planar graphs \cite{GaJoTar}, bipartite graphs
\cite{Gol}, chordal graphs \cite{Gol}, chordal bipartite graphs
\cite{Muller} and strongly chordal graphs \cite{Muller}. Bertossi
and Bonuccelli \cite{BertBonucc} proved that the Hamiltonian
Circuit problem is NP-complete on several interesting classes of
intersection graphs.

\y Several variants of the HP problem are also of great interest,
among which is the problem of deciding whether a graph admits a
Hamiltonian path between two points (2HP). The 2HP problem is the
same as the HP problem except that in 2HP two vertices of the
input graph~ are specified, say,  and ,  and we are asked
whether  contains a Hamiltonian path beginning with  and
ending with . Similarly, the 1HP problem is to determine
whether a graph~ admits a Hamiltonian path starting from a
specific vertex  of , and to find one if such a path does
exist. Both 1HP and 2HP problems are also NP-complete in general
graphs \cite{GaJo79}. In \cite{Damaschke}, Damaschke provided a
foundation for obtaining polynomial-time algorithms for several
problems concerning paths in interval graphs, such as finding
Hamiltonian paths and circuits, and partitions into paths. In the
same paper, he stated that the complexity status of both 1HP and
2HP problems on interval graphs remains an open question.
Motivated by the above issues we state a variant of the path cover
problem, namely, the 1-fixed-endpoint path cover problem (1PC),
which generalizes the 1HP problem.

\yy\noindent Problem 1PC: Given a graph  and a vertex , a {\it 1-fixed-endpoint path cover} of the graph~ with
respect to  is a path cover of  such that the vertex  is
an endpoint of a path in the path cover; a {\it minimum
1-fixed-endpoint path cover} of  with respect to  is a
1-fixed-endpoint path cover of  with minimum cardinality; the
{\it 1-fixed-endpoint path cover problem} (1PC) is to find a
minimum 1-fixed-endpoint path cover of the graph~.

\yy\noindent {\bf Contribution.} In this paper, we study the
complexity status of the 1-fixed-endpoint path cover problem (1PC)
on the class of interval graphs \cite{BraLeSpi, Gol}, and show
that this problem can be solved in polynomial time. The proposed
algorithm runs in  time on an interval graph~ on 
vertices and  edges and requires linear space. The proposed
algorithm for the 1PC problem can also be used to solve the 1HP
problem on interval graphs within the same time and space
complexity. Using our algorithm for the 1PC problem and a simple
reduction described by M\"{u}ller in \cite{Muller}, we solve the
HP problem on a -convex graph  with ,
which was left open in \cite{UeharaUno}. We also show that the 1HP
problem on a convex graph  is solvable in time quadratic in the
number of its vertices. Figure~\ref{class} shows a diagram of
class inclusions for a number of graph classes, subclasses of
comparability and chordal graphs, and the current complexity
status of the 1HP problem on these classes; for definitions of the
classes shown, see \cite{BraLeSpi, Gol}.

\begin{figure}[t]
\yy \hrule \y\y\y
  \centering
  \includegraphics[scale=0.7]{classes.eps}
  \centering
  \caption{\small{The complexity status (NP-complete, unknown, polynomial) of the 1HP problem for some graph subclasses of comparability and chordal graphs.  indicates that
  class  contains class .}}
  \label{class}
 \yy \hrule \y\y
\end{figure}

\yy\noindent {\bf Related Work.} Interval graphs form an important
class of perfect graphs \cite{Gol} and many problems that are
NP-complete on arbitrary graphs are shown to admit polynomial time
algorithms on this class \cite{AR90, Gol, Keil}. Both Hamiltonian
Circuit (HC) and Hamiltonian Path (HP) problems are polynomially
solvable for the class of interval and proper interval graphs.
Keil introduced a linear-time algorithm for the HC problem on
interval graphs \cite{Keil} and Arikati and Rangan \cite{AR90}
presented a linear-time algorithm for the minimum path cover
problem on interval graphs. Bertossi \cite{Bertossi} proved that a
proper interval graph has a Hamiltonian path if and only if it is
connected. He also gave an  algorithm for finding a
Hamiltonian circuit in a proper interval graph. Recently, Asdre
and Nikolopoulos proposed a linear-time algorithm for the
k-fixed-endpoint path cover problem (kPC) on cographs and on
proper interval graphs \cite{AsdNik, AsdNik2}. Furthermore, Lin
et~al. \cite{LiOlPru95} proposed an optimal algorithm for the path
cover problem on cographs while Nakano et~al. \cite{NaOlZo03}
proposed an optimal parallel algorithm which finds and reports all
the paths in a minimum path cover of a cograph in  time
using  processors on a PRAM model. Hsieh et~al.
\cite{HsiehHoHsuKo} presented an -time sequential
algorithm for the Hamiltonian problem on a distance-hereditary
graph and also proposed a parallel implementation of their
algorithm which solves the problem in  time using
 processors on a PRAM model. A unified approach
to solving the Hamiltonian problems on distance-hereditary graphs
was presented in \cite{HungChangDH}, while Hsieh \cite{Hsieh}
presented an efficient parallel strategy for the 2HP problem on
the same class of graphs. Algorithms for the path cover problem on
other classes of graphs were proposed in \cite{HungChangCA, Nik,
SSSR93}.

\yy\noindent {\bf Road Map.} The paper is organized as follows. In
Section~2 we establish the notation and related terminology, and
we present background results. In Section~3 we describe our
algorithm for the 1PC problem, while in Section~4 we prove its
correctness and compute its time and space complexity. Section~5
presents some related results and in Section~6 we conclude the
paper and discuss possible future extensions.



\section{Theoretical Framework}

We consider finite undirected graphs with no loops or multiple
edges. For a graph~, we denote its vertex and edge set by
 and , respectively. Let  be a subset of the vertex
set of a graph~. Then, the subgraph of  induced by  is
denoted by .


\vskip 0.2in \subsection{Structural Properties of Interval Graphs}

A graph  is an {\it interval graph} if its vertices can be put
in a one-to-one correspondence with a family  of intervals on
the real line such that two vertices are adjacent in  if and
only if their corresponding intervals intersect.  is called an
{\it intersection model} for  \cite{AR90}. Interval graphs find
applications in genetics, molecular biology, archaeology, and
storage information retrieval \cite{Gol}. Interval graphs form an
important class of perfect graphs \cite{Gol} and many problems
that are NP-complete on arbitrary graphs are shown to admit
polynomial time algorithms on this class \cite{AR90, Gol, Keil}.
The class of interval graphs is {\it hereditary}, that is, every
induced subgraph of an interval graph  is also an interval
graph. We state the following numbering for the vertices of an
interval graph proposed in \cite{RamRan}.

\medskip
\par\noindent
{\bf Lemma~2.1.} (Ramalingam and Rangan \cite{RamRan}): {\it The
vertices of any interval graph  can be numbered with integers
 such that if  and  then
.}

\yyy\noindent As shown in \cite{RamRan}, the numbering of
Lemma~2.1, which results from numbering the intervals after
sorting them on their right ends \cite{AR90}, can be obtained in
linear time, that is,  time. An ordering of the vertices
according to this numbering is found to be quite useful in solving
many problems on interval graphs \cite{AR90, RamRan}. Throughout
the paper, the vertex numbered with  will be denoted by ,
, and such an ordering will be denoted by .
We say that  if , .






\vskip 0.2in \subsection{Interval Graphs and the 1PC Problem}

Let  be an interval graph with vertex set  and edge set
,  be a set containing a single vertex of
, and let  be a minimum
-fixed-endpoint path cover of  with respect to 
of size  (or  for
short); recall that the size of  is
the number of paths it contains. The vertex belonging to the set
 is called {\it terminal} vertex, and the set
 is called the {\it terminal set} of , while those
of  are called {\it non-terminal or free}
vertices. Thus, the set  contains
two types of paths, which we call {\it terminal} and {\it
non-terminal or free} paths: a {\it terminal path}  is a path
having the terminal vertex as an endpoint and a {\it non-terminal
or free path}  is a path having both its endpoints in . The set of the non-terminal paths in a minimum 1PC
of the graph  is denoted by , while  denotes the set
containing the terminal path. Clearly,  and
.

\y Our algorithm for computing a 1PC of an interval graph is based
on a greedy principle, visiting the vertices according to the
ordering , and uses
three operations on the paths of a 1PC of , where , . These three operations,
namely {\tt connect}, {\tt insert} and {\tt bridge} operations,
are described below and are illustrated in Fig.~\ref{operations}.

\begin{itemize}

\item []
{\tt Connect} operation: Let  be a free endpoint of a path
 of  and let  be a
free or a terminal vertex such that  sees . We say
that we {\it connect} vertex  to the path , or,
equivalently, to the vertex , if we extend the path  by
adding an edge which joins vertex  with vertex .



\item [] {\tt Insert} operation: Let , , , be a
path of  and let  be a
free vertex such that  sees  and . We say that
we {\it insert} vertex  into , if we replace the path
 with the path .

\item [] {\tt Bridge} operation: Let  and  be two
paths of  and let  be a
free vertex. We say that we {\it bridge} the two paths  and
 using vertex  if we connect  with a free
endpoint of  and a free endpoint of .

\end{itemize}

\begin{figure}[t]
\yy \hrule \yyy
  \centering
   \begin{minipage}[c]{2in}
    \centering
    \includegraphics[scale=1]{OPconnect.eps}
\center{\small{(a)}}
  \end{minipage}
  \begin{minipage}[c]{2in}
    \centering
    \includegraphics[scale=1]{OPinsert.eps}
\center{\small{(b)}}
  \end{minipage}
  \begin{minipage}[c]{2in}
    \centering
    \includegraphics[scale=1]{OPbridge.eps}
\center{\small{(c)}}
  \end{minipage}
\caption{\small{Illustrating (a) connect, (b) insert, and (c) bridge operations; .}} \yy \hrule \y\y
\label{operations}
\end{figure}

Let  be a path of  and let 
and  be its endpoints. We say that  is the left (resp.
right) endpoint of the path and  is the right (resp. left)
endpoint of the path if  (resp. ).
Throughout the paper, a trivial path (i.e. a path consisting of
one vertex) is considered to have two endpoints, while a trivial
path consisting of the terminal vertex  is
considered to have one terminal endpoint and one free endpoint.

\y Let  be an interval graph on  vertices and let
 be a minimum 1PC of size
. Since a trivial path is considered to have
two endpoints, the number of endpoints in
 is . For each
vertex  we denote by  the number of neighbors of
 in ; that is, . We call {\it d-connectivity} of
 the sum of . It is easy to see that . Clearly, any minimum 1PC
 has d-connectivity equal to
.

\vskip 0.3in \section{The Algorithm}

We next present an algorithm for the 1PC problem on interval
graphs. Our algorithm takes as input an interval graph  on 
vertices and  edges and a set  containing
the terminal vertex , and computes a minimum 1PC of
 in  time; it is based on a greedy principle to extend
a path of a minimum 1PC using operations on the left and right
endpoints of its paths and properties of the graph , . We point out that, if a
vertex sees the two endpoints of only one non-terminal path ,
it is connected to the left endpoint of the path . Furthermore,
for each vertex , , we denote by
 the number of endpoints  belonging
to different paths with index . We also define
 and
, . The algorithm works as follows:


\bigskip \noindent{\it Algorithm Minimum\_1PC} \y \noindent{\it
Input:} an interval graph  on  vertices and  edges and a
vertex ; \y \noindent{\it Output:} a minimum 1PC
 of the interval graph ; \y

\begin{enumerate}
  \item Construct the ordering  of the vertices of ;
  \item Execute the subroutine ; the minimum
  1PC  is the set
  of paths returned by the subroutine;
\end{enumerate}

\y \noindent where the description of the subroutine
 is presented below.

\yyy It is easy to see that, if  is the
size of a minimum 1PC of  with respect to 
then the size of a minimum 1PC of  is either
 or . Indeed,
suppose that the size of a minimum 1PC of  is
. Since a terminal vertex cannot
decrease the size of a minimum 1PC, we have
.
Thus, , a
contradiction. Suppose now that the size of a minimum 1PC
 of  is
. Then, adding a trivial path containing
vertex  to  results to
a 1PC of  of size , a contradiction.

\y We next describe the operation {\tt bridge} in detail. Note
that in most cases we bridge two paths through their leftmost free
endpoints. Suppose that when vertex  is processed it sees at
least one free endpoint of a non-terminal path , say, ,
and at least the free endpoint of the terminal path , say,
, and both endpoints of a non-terminal path , say,
 and . Let ,  and  be the left endpoints
and ,  and  be the right endpoints of the paths
,  and , respectively. There exist three cases
where we do not bridge two paths through the leftmost free
endpoints (see Fig.~\ref{bridgeOP}(a)-(c)). In these three cases
the bridge operation works as follows:

\yy \noindent (a) : we bridge 
and  through  (or,  if ) and
.

\bigskip
\small{ \yy \hrule \y\y\y \noindent{\it process }() \y
\noindent{\it Input:} the ordering  of the vertices of 
and the index  of the terminal vertex ;\y \noindent{\it
Output:} a minimum 1PC  of ;
\y\noindent
  ;
  ; ;\\
  ; ; \phantom{\tt else}{\it \{the left and right endpoints of the path \}}\\
{\tt for}  {\tt to}  {\tt do}\\
 {\tt if}  {\tt then}\\
\phantom{\tt el} {\tt if}  {\tt and}  {\tt then}\phantom{\tt else}{\it \{ is the leftmost neighbor of  in \}}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt if} at
least two endpoints are free vertices {\tt then} {\tt bridge}; ;\\
 \phantom{\tt
el}\phantom{\tt el}\phantom{\tt el}{\tt else}\phantom{\tt else} {\it \{ and one endpoint is the terminal vertex , and the other, say, , is a free vertex.\}}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}{\tt if} process() returns a
1PC  of 
paths {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt el} {\tt connect}  to the leftmost endpoint
of ; {\tt connect}  to ;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt el} ;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}{\tt else-if} process()
returns a 1PC  of 
paths {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt el}{\tt if}  can be connected to the leftmost left endpoint and then  can bridge paths {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt el}\phantom{\tt el} {\tt connect}  to the
leftmost left endpoint of ; {\tt bridge}; \\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt el}\phantom{\tt el} ;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}{\tt else} {\tt connect}  to the leftmost endpoint;\\
\phantom{\tt el} {\tt if}  {\tt and}
 {\tt and}
the endpoint , is a free vertex {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt if}  sees an internal vertex  {\tt then} {\tt connect\_break};\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt else connect}  to the leftmost free endpoint;\\
\phantom{\tt el} {\tt if}  {\tt or}
 {\tt or}
( {\tt and}
the endpoint , is the terminal vertex) {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt if}  has
two consecutive neighbors into a path {\tt then} {\tt insert}  into the path;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt else-if}
 sees an internal vertex  {\tt then}\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}{\tt if}  is an edge of a path  and  sees an endpoint  of a path  {\tt then} \\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}\phantom{\tt
el} remove the edge  of ; {\tt connect}  to ; {\tt connect}  to ;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}\phantom{\tt
el}{\tt else} {\tt new\_path}; ;\\
\phantom{\tt el}\phantom{\tt el}\phantom{\tt el}{\tt else}
;
;\\
\phantom{\tt el}{\tt endif};\\
 {\tt if}  {\tt then}\\
\phantom{\tt el}\phantom{\tt el}{\tt if}
 {\tt then} {\tt connect} 
to the leftmost endpoint of ;\\
\phantom{\tt el}\phantom{\tt el}{\tt else}
;
;\\
\phantom{\tt el}{\tt endif};\\
\phantom{\tt el}{\tt for}  {\tt to}  {\tt do} {\tt update} ;   {\tt update\_endpoints};\\
{\tt endfor};\\
  .
\yyy \hrule \y\y}
\normalsize{
\bigskip

\begin{figure}[t]
\hrule \bigskip \hspace*{0.3in}
   \begin{minipage}[l]{2in}
    \includegraphics[scale=0.8]{bridge5.eps}
    \hspace*{1in}\small{(a)}
  \end{minipage}
  \begin{minipage}[r]{2in}
   \hspace*{1.1in}
    \includegraphics[scale=0.8]{bridge3.eps}
   \hspace*{2.2in}\small{(b)}
  \end{minipage}
\vspace{0.2in}

\hspace*{0.25in}
  \begin{minipage}[c]{2in}
    \hspace*{0.05in}
    \includegraphics[scale=0.8]{bridge4.eps}
   \hspace*{1.05in}\small{(c)}
  \end{minipage}
 \begin{minipage}[c]{2in}
    \hspace*{0.9in}
    \includegraphics[scale=0.8]{bridge1.eps}
   \hspace*{2.25in}\small{(d)}
  \end{minipage}
\vspace{0.2in}
 \vspace*{-0.2in}

\hspace*{0.25in}
 \begin{minipage}[c]{2in}
    \hspace*{1.5in}
    \includegraphics[scale=0.8]{bridge2.eps}
   \hspace*{2.9in}\small{(e)}
  \end{minipage}

    \caption{\small{Illustrating some cases of the bridge operation.}}
\bigskip \hrule
 \label{bridgeOP}
\end{figure}


\y\noindent (b) : if  we bridge  and  through  and ;
otherwise, we \phantom{(b)} bridge  and  through 
and .

\y \noindent (c) : we bridge  and
 through  (or,  if ) and .


\yy Suppose now that  is a non-terminal path having  and
 as its left and right endpoints, respectively,  is the
terminal path with left endpoint  and right endpoint
. Also, let  be a non-terminal path with left and
right endpoints  and , respectively, and  a
non-terminal path with left and right endpoints  and ,
respectively (see Fig.~\ref{bridgeOP}(d)-(e)). We distinguish the
following two cases:

\y \noindent (d) : if  or  we bridge  and  through
\phantom{(d)}  ( if ) and . If
 and  we bridge  and
 through  and .

\y \noindent (e) : if  or  we bridge  and  through
\phantom{(e)}  ( if ) and ;
otherwise, we bridge  and  through  ( if ) and .



\yy \noindent Figure~\ref{bridgeOP} presents cases (a)-(e).
Suppose that we have the two paths  and  of case~(e) and
vertex  sees both  and , that is,  and , where  and . Then, the bridge
operation constructs the path . Suppose now that we have
the two paths  and  of case~(c) and vertex  sees
all vertices with index greater or equal to , that is,
 and , where  and . Then, the
bridge operation constructs the path . Suppose that there
exist two paths  and  as in case~(d) and vertex 
sees all vertices with index , , where , that is, 
and , where  and .
If  then the bridge operation constructs the path ;
otherwise, it constructs the path  . If there exist two
paths  and  as in case~(b) and vertex  sees all
vertices with index greater or equal to , that is,  and , where  and , then the bridge
operation constructs the path , if , or the path
, if .

\y We next describe the operation {\tt new\_path} which creates a
new path when the vertex  is processed. There exist three
cases where operation new\_path creates a new non-trivial path
while in all other cases it creates a new trivial path. Suppose
that  sees an internal vertex  belonging to a path
 such that
. We remove the edge  from 
and we obtain  and . Then, we connect  to . The case where  and  is similar. If  sees an
internal vertex  belonging to a path  such that , we
remove the edge  from  and we obtain  and . Then, we connect 
to . Suppose now that  sees an internal vertex 
belonging to a path  such that . We remove the edge
 from  and we obtain 
and . Then, we connect  to . The
above cases, where the operation new\_path creates a new
non-trivial path, are described below:

\y \noindent (a) : We create paths
 and . The case \phantom{(a) }where  and
 is similar.

\y \noindent (b) : We create paths
 and .

\y \noindent (c)\phantom{c}: We create
paths  and .



\yy Note that, the rightmost endpoint of a path in
 is 
and, thus, . The 1PC
 of the graph  in each of the
above cases contains two new endpoints, vertices  and
 such that ; thus, .
Figure~\ref{newOP} presents the above cases.

\y The operation {\tt connect\_break} is similar to the operation
new\_path. Specifically, suppose that in the above cases (a)-(c)
there exists a path  such that
. Then, the operation connect\_break works
similarly to the operation new\_path; the only difference is that
 is also connected to . Note that, in all other cases,
operation connect\_break coincides with the operation connect.

\begin{figure}[t]
\hrule \bigskip \hspace*{0.6in}
   \begin{minipage}[l]{2in}
\includegraphics[scale=0.8]{new1.eps}
\end{minipage}
\vspace{0.2in}

\hspace*{0.6in}
  \begin{minipage}[r]{2in}
    \includegraphics[scale=0.8]{new2.eps}
\end{minipage}
\vspace{0.2in}

\hspace*{0.6in}
  \begin{minipage}[c]{2in}
   \includegraphics[scale=0.8]{new5.eps}
\end{minipage}

    \y\caption{\small{Illustrating some cases of the new\_path operation.}}
\bigskip \hrule
 \label{newOP}
\end{figure}



\y Concerning the ordering of the endpoints of the paths of the
1PC constructed by Algorithm Minimum\_1PC, we prove the following
lemmata.

\medskip
\par\noindent
{\bf Lemma~3.1.} {\it Let  be an interval graph with no
terminal vertex. Let , ,
be a path in the 1PC  of the graph
 constructed by Algorithm Minimum\_1PC and let  and 
be the left and right endpoints of , respectively. Then,
there is no path , , , such that  or
, where  and  are the left and right
endpoints of , respectively.}

\yy \noindent {\sl Proof.} \s Let ,  be a path in the 1PC
 constructed by Algorithm
Minimum\_1PC and let  and  be its left and right
endpoints, respectively. Let , , , and let  and  be its
left and right endpoints, respectively. Suppose that
. Since  and  are the endpoints of 
and , the path  contains at least one edge, say,
, such that . Clearly, vertices  and
 are free vertices. Since , we also have
. Then, according to Algorithm Minimum\_1PC, when
vertex  is processed, vertex  is an endpoint of the path
, and, thus,  bridges the paths  and  through
vertices  and , a contradiction. Similarly, we can prove
that  or . \ \qed

\y Using similar arguments we can prove the following lemma:

\medskip
\par\noindent
{\bf Lemma~3.2.} {\it Let  be an interval graph containing a
terminal vertex. Let , ,
be a non-terminal path in the 1PC 
of the graph  constructed by Algorithm Minimum\_1PC and let
 and  be the left and right endpoints of ,
respectively. Then, there is no non-terminal path , , , such that  or
, where  and  are the left and right
endpoints of , respectively.}


\section{Correctness and Time Complexity}

Let  be an interval graph on ~vertices and~ edges and let
 be a subset of  containing a single vertex. In
order to prove the correctness of Algorithm Minimum\_1PC, we use
induction on . We also prove a property of the minimum 1PC
 of  constructed by our algorithm:
Algorithm Minimum\_1PC computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, ,
where  is the index of the rightmost endpoint of a path
in . Furthermore, one of the
following holds:

\noindent (i) ,
, or

\noindent (ii) if ,
 and , , where 
is the index of the rightmost endpoint of a path in
, then there exists a vertex 
such that ,  and there exists no vertex , , such that
.

\noindent Recall that a trivial path has two endpoints that
coincide. Hence, we prove the following theorem.

\bigskip
\par\noindent
{\bf Theorem~4.1.} {\it Let  be an interval graph on
~vertices and~ edges and let . Algorithm
Minimum\_1PC computes a minimum 1PC 
of the graph  having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, ,
where  is the index of the rightmost endpoint of a path
in . Furthermore, one of the
following holds:
\begin{itemize}
\item[(i)] ,
, or \item[(ii)] if ,  and
, , where  is the index of the rightmost endpoint
of a path in , then there exists a
vertex  such that ,  and there exists no
vertex , , such that
.
\end{itemize}}

\yy \noindent {\sl Proof.} \s We use induction on . The basis
 is trivial. Assume that Algorithm Minimum\_1PC computes a
minimum 1PC  of every interval
graph , , with at most
 vertices having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, ,
where  is the index of the rightmost endpoint of a path in
. Furthermore, one of the
following holds:
\begin{itemize}
\item[(i)] , , or

\item[(ii)] if ,  and , , where  is the
index of the rightmost endpoint of a path in
, then there exists a vertex
 such that ,
 and there exists no vertex , , such that
.

\end{itemize}

\noindent Let  be the size of
. We show that the algorithm
computes a minimum 1PC  of the graph
 having  endpoints  belonging to
different paths with index , ,
such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, ,
where  is the index of the rightmost endpoint of a path
in . Furthermore, one of the
following holds:
\begin{itemize}
\item[(i)] ,
, or \item[(ii)] if ,  and
, , where  is the index of the rightmost endpoint
of a path in , then there exists a
vertex  such that ,  and there exists no
vertex , , such that
.

\end{itemize}

\yy {\bf Case~A:} Vertex  is not the terminal vertex. Let
 be the size of
. Clearly, the size
 of a minimum 1PC of  is equal to
 or  or
. We distinguish the following cases:

\y {\bf \textit{Case~A.1}:} When the algorithm processes vertex
, it uses  to bridge two paths (operation bridge), that
is, ;
consequently,  is a minimum 1PC of
, that is, .

\y \textit{Case~A.1.a}: Suppose that , . We show that the
algorithm computes a minimum 1PC  of
the graph  having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, .
Clearly, vertex  is an internal vertex of a path in any other
minimum 1PC , otherwise removing it
from  would result to a 1PC of
 of size , a
contradiction. Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index  such
that . Suppose
that . Note
that . Indeed, let
 be a minimum 1PC of  having
 endpoints
 belonging to different paths with index . Suppose that vertex  is an internal vertex in
. Then, the algorithm constructs
 paths while 
contains at least  paths, a contradiction.
Suppose that vertex  is an endpoint in
. Note that, according to the
algorithm, if  has degree greater or equal to one, then it
belongs to a path containing more than one vertex. Consequently,
the other endpoint of the path containing  is one of the
 endpoints, and, thus, the algorithm
constructs  paths while
 contains at least
 paths, a contradiction. Since
 there exists a
vertex , , such that . This implies that vertex  is the
right endpoint of a path  in the minimum 1PC
 constructed by the algorithm.
Without loss of generality, we assume that , .

\y Let  be the path of
 containing vertex . Then,
 and . Indeed, suppose that at least one of 
and  has index less or equal to , say, . Since
 we have . Let  be the path of
 containing vertex . Suppose
that  and . Then, due to the induction
hypothesis, both of the endpoints of  have index greater than
. However, according to the algorithm (operation bridge),
such an ordering of the endpoints cannot exist, a contradiction.
Suppose that  and . Then, due to the
induction hypothesis, at least one of the endpoints of  should
have index greater than . Again, according to the algorithm
(operation bridge), such an ordering of the endpoints cannot
exist, a contradiction. Suppose now that  and
. Then, due to the induction hypothesis, computing a
1PC of  we had case~(e) which is described in Section~3 and
. However, in this case, vertex  would not
be the right endpoint of a path in
, a contradiction.

\y Consequently,  and . Then, both endpoints of 
have indexes less than . This implies that vertex  has
bridged two non-terminal paths for which we have an endpoint of
one path between the endpoints of the other, which is a
contradiction according to Lemma~3.2.

\y Consequently, we have shown that there does not exist a minimum
1PC  having an index, say, ,
for which we have  endpoints
 belonging to different paths with index , where
.

\y Case~1.b: Suppose that ,  and
, , where  is the index of the rightmost endpoint of a path
in , and there exists a vertex
 such that ,
 and there exists no vertex , ,
such that . We show
that the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index , , such that , , where  is the index of the rightmost
endpoint of a path in . Furthermore,
one of the following holds:
\begin{itemize}
\item[(i)] ,
, or \item[(ii)] if ,  and
, , where  is the index of the rightmost endpoint
of a path in , then there exists a
vertex  such that ,  and there exists no
vertex , , such that
.

\end{itemize}

\y Suppose that there exists a minimum 1PC
 such that
. Then,
similarly to Case~A.1.a, we show that there is no other minimum
1PC  such that
, .

\y Suppose now that there exists a minimum 1PC
 such that ,  and
, , where  is the index of the rightmost endpoint
of a path in . We show that there
exists a vertex  such that ,  and there exists no
vertex , , such that
.

\y Note that, there cannot exist a minimum 1PC
 such that , . Indeed,
suppose that there exists a minimum 1PC
 such that , . Consider the
case where  belongs to a path in
 and it is connected to vertices
 and  such that  and .
Then, removing  from  we
obtain a minimum 1PC of  such that
 or
. If  belongs to a path in
 and it is connected to vertices
 and , then removing  from
 we obtain a minimum 1PC of 
such that . Thus, there exist three paths in
 such that there are no left
endpoints between their right endpoints in , a contradiction.
Consider now the case where  belongs to a path in
 and it is connected to vertices
 and  such that  and .
Then, . Note that  belongs to a path
 in  and it is connected to
vertices  and  such that  and .
Removing  from  should result
to a minimum 1PC of  such that . Consequently, both endpoints of
 have index less than , which implies that there
exists a specific ordering of the endpoints of the paths in
, which, according to the
algorithm, is not possible, a contradiction. The case where 
belongs to a path in  and it is
connected to vertices  and  such that 
and  is similar.

\y Using similar arguments with Case~A.1.a, we show that there
exists no vertex , , such that
. Suppose that
, .
Note that  belongs to a path  such that
 and . Thus,  belongs to a path
 such that  and
. If we remove  from
 then there exists a vertex
 such that
. This implies that
. Furthermore, if we remove  from
 and we obtain
, which implies that
, then , , a contradiction. If we remove  from
 and we obtain
, then there exists a
specific ordering of the endpoints of the paths in
 which, according to the
algorithm, is not possible, a contradiction. Consequently, there
exists a vertex  such that , .

\y {\bf \textit{Case~A.2}:} When the algorithm processes vertex
, it constructs a 1PC of size 
of  of , where
 is the terminal vertex, and then connects the path  to an existing path. This operation is performed when vertex
 sees the endpoints of at least one non-terminal path, say
, the terminal vertex  and no other
endpoint of the terminal path, say, .
Then, the terminal path, , has the same endpoints as in
, the vertices of  become
internal vertices of , while all the other paths remain the
same. Note that when the connect operation is performed, it may
use a vertex of the terminal path in order to increase the value
of an , , and, in this
case, . Then, for
the endpoints of the terminal path, say,  and
, we have . Consequently, since vertex 
sees the endpoints of , the terminal vertex  and no
other endpoint of the terminal path , if operation connect
was called previously, it cannot have used a vertex of the
terminal path and, thus,
 cannot hold.
Consequently, ,
.

\y The above procedure results to a 1PC of  of size
;
consequently,  is a minimum 1PC of
, that is, .

\y We show that the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .
Clearly, vertex  is an internal vertex of a path in any other
minimum 1PC , otherwise removing it
from  would result to a 1PC of
 of size less or equal to , a
contradiction. Suppose that there exists a minimum 1PC
 having an index, say, , such
that  and . This implies that
 and there exists a
vertex  such that  and
. Clearly,
. Removing  from
 results to a minimum 1PC of 
having at least two free neighbors of  as endpoints belonging
to different paths, say,  and ; suppose that at least
one of them has index greater than . Then,
, a
contradiction. Thus,  and  and the
right endpoint of the path that they belong, has also index less
than . Thus,

or
,
a contradiction. Suppose now that . Since there
cannot exist a vertex  such that  and
, there exists a
vertex  such that  and
 and . Clearly, . If  is the right endpoint
of , then  and thus . However, according to
the algorithm, there cannot exist an endpoint between vertices
 and , a contradiction.

\y {\bf \textit{Case~A.3}:} When the algorithm processes vertex
, it constructs a 1PC of size  of
 of , where 
is the terminal vertex, it connects  to the leftmost left
endpoint it sees, and it uses  to bridge two paths. This
operation is performed when vertex  sees the endpoints of at
least one non-terminal path, say , the
terminal vertex  of the terminal path, say,  and an internal vertex  of , and it
does not see . Then, the terminal path, , has the
same endpoints as in , the
vertices of  become internal vertices of , while all the
other paths remain the same. Recall that, when the connect
operation is performed, it may use a vertex of the terminal path
in order to increase the value of an , , and, in this case,
. Then, for the
endpoints of the terminal path, say,  and
, we have . Consequently, since vertex 
sees the endpoints of , the terminal vertex  and not
, if operation connect was called previously, it cannot
have used a vertex of the terminal path and, thus,
 cannot hold.
Consequently, ,
.

\y Consider the case where vertex  sees the endpoints of only
one non-terminal path, that is, of . If applying the
algorithm to  results to a 1PC of size
 then it contains a path with one
endpoint  such that . Indeed, suppose that there does
not exist such a path and  consists of more than one vertex.
This implies that all vertices of  have bridged two paths and
therefore we obtain a 1PC of size less than
, a contradiction. Suppose now that
the algorithm does not construct a path in the 1PC of 
with one endpoint  such that  and let the path 
consist of one vertex, say, . This implies that vertex
 has bridged two paths and the same holds for every vertex
, . Thus, if  is removed from
, the algorithm would construct a minimum 1PC of size
. Since the size of
 constructed by the algorithm is
, removing  and  results
to a 1PC of size . Consequently,
 cannot be used for bridging two paths in
. This implies that the 1PC
of  constructed by the algorithm contains a path with an
endpoint  such that . It is easy to see that if vertex
 sees the endpoints of more than one non-terminal path,
applying the algorithm to  results to a 1PC of size
 having a path with one endpoint
 such that .

\y The above procedure results to a 1PC of  of size
;
consequently,  is a minimum 1PC of
, that is, .

\y Using similar arguments as in Case~A.2, we show that the
algorithm computes a minimum 1PC  of
the graph  having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, .

\y {\bf \textit{Case~A.4}:} When the algorithm processes vertex
, it connects  to a path, that is,
. Suppose that
there exists a 1PC  of size
, that is, vertex  is an
internal vertex of a path  in .
We distinguish the following cases:

(i) . Removing
 from  results to a minimum 1PC of  having two
(free) neighbors of  as endpoints belonging to different
paths. Since the algorithm does not use  to bridge two paths,
the constructed minimum 1PC of  does not have two (free)
neighbors of  as endpoints belonging to different paths.
Consequently, there is a minimum 1PC of  for which there
exists an index  such that
, a contradiction.

(ii) , where  is the terminal
vertex.  Removing  and  from  results to a minimum
1PC of  of size , a
contradiction. Indeed, since the algorithm does not use  to
bridge two paths, removing  from  results to
 paths.

\y Consequently, there does not exist a 1PC
 of size
, and, thus, the 1PC constructed by
the algorithm is minimum.

\y \textit{Case~A.4.a}: Suppose that , . We show that the
algorithm computes a minimum 1PC  of
the graph  having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, .
Furthermore, one of the following holds:
\begin{itemize}
\item[(i)] ,
, or \item[(ii)] if ,  and
,  then there exists a vertex  such that
, 
and there exists no vertex , , such
that .

\end{itemize}

\y Suppose that  is not an endpoint in
; let . According to operation connect, we break the terminal
path of , which has the terminal
vertex, , as its right endpoint. Note that the terminal
vertex is the second rightmost endpoint in
 (see Section~3). The second
rightmost endpoint of  has index
greater than , and  becomes a left endpoint of a path in
. Assume that there exists a minimum
1PC  having an index, say, ,
for which we have  endpoints
 belonging to different paths with index , where
. Similarly, to
Case~A.1, there exists a vertex , , such that
.

\y Suppose that  is an endpoint of a path . Then, since
, ,
. Note that, there cannot exist a minimum
1PC  such that
, . Indeed, suppose that there exists a minimum 1PC
 such that , . If we remove
 from  we obtain
 or
.
However, 
and , a
contradiction. According to the connect operation, , thus . If we remove  from
 we obtain
.
However,  or
, a
contradiction. Consequently, there exists no vertex , , such that
. Suppose that
, .
Let  be the new endpoint created by the connect operation.
Again, since ,  and if we
remove  from  we obtain
.
However, , a
contradiction. Consequently, if ,  and
,  then there exists a vertex  such that
, 
and there exists no vertex , , such
that . Suppose
that the second rightmost endpoint in
, say, , has index less than
the second rightmost endpoint in ,
say, , that is, . Then,

and , a
contradiction.

\y Suppose that  is not an endpoint in
; let . Clearly, one of  is a vertex
that could not be an endpoint in .
We show that . Suppose that . Since ,
then we have
, which
implies that the new endpoint in 
has index greater than the new endpoint created in
, a contradiction. It is easy to see
that there cannot exist a a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index  such
that . Let
 be the terminal vertex. We have
. It is easy
to see that there cannot exist a minimum 1PC
 having an index, say, , , for which we have  endpoints
 belonging to different paths with index , such that
.

\y Suppose that  is the right endpoint of a path . Then, there cannot
exist a minimum 1PC  such that .
We show that the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .
Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index ,
where .
Similarly, to Case~1, there exists a vertex , , such that .

\y Suppose that  is an endpoint of a path . Note that if
, then  and  should be
the terminal vertex belonging to a non-trivial path, otherwise
 would not be minimum. Thus, if
 is not the terminal vertex,  or
. Then, if we remove  from
 and
, we obtain

and ; thus,
, a
contradiction. On the other hand, if , then, if we
remove  from  and
, we obtain

or
.
Also, ; thus,
, a
contradiction.

\y Suppose that  is not an endpoint in
; let . If  then if we remove
 from  and
, we obtain

or
.
Also, ; thus,
, a
contradiction. Consequently, ; however,
we have shown that  becomes an endpoint in
 only when a new right endpoint
cannot be created by making  an internal vertex, a
contradiction.


\y \textit{Case~A.4.b}: Suppose that ,  and
,  and there exists a vertex  such that
, 
and there exists no vertex , , such that
. We show that
the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .

\y Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index ,
where .
Similarly, to Case~A.1, there exists a vertex , , such that .
Using similar arguments as in Case~A.4.a, we show that  is an
endpoint of a path  and that there cannot exist a
minimum 1PC  having an index, say,
, for which we have  endpoints
 belonging to different paths with index , where
.



\y {\bf \textit{Case~A.5}:} When the algorithm processes vertex
, it inserts  into a path, that is,
. This implies
that  we have .
Suppose that there exists a 1PC  of
size , that is, vertex  is an
internal vertex of a path  in .
Then, removing vertex  from 
results to a 1PC of  of size ,
and, thus, minimum, such that there exists an index , , for which , a contradiction.

\y Consequently, there does not exist a 1PC
 of size
, and, thus, the 1PC constructed by
the algorithm is minimum.

\y \textit{Case~A.5.a}: Suppose that , . We show that the
algorithm computes a minimum 1PC  of
the graph  having  endpoints 
belonging to different paths with index , , such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, .

\y Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index ,
where .
Similarly, to Case~A.1, there exists a vertex , , such that .

\y Suppose that  is an endpoint of a path , such that .
Then,  and the size of a minimum 1PC of
 is , a contradiction.

\y Suppose that  is an endpoint of a path , such that
. Then, removing vertex  from
 results to a 1PC of  of size
, and, thus, minimum, such that there
exists an index  for which , . Then, , which is equal to the index of the terminal
vertex, and  is the terminal path such that its left endpoint
in , that is, vertex ,
has index greater than the index of the left endpoint of the
terminal path in . Note that,
 cannot be an endpoint in
 since , , and, thus, a 1PC
of  having  as an endpoint cannot be minimum.
However, removing  from 
results to a 1PC of  of size 
having  as an endpoint, a contradiction.

\y Suppose now that  is not an endpoint in
; let . If  then if we remove
 from  and
, we obtain

and , a
contradiction. Consequently, . Suppose
that the value of d-connectivity of
 is ; then the value of
d-connectivity of  is .
However, the corresponding value of
 is not increased by vertices
 and , since  and  are
internal vertices not successive into a path in a 1PC of 
and there exist two vertices connected to  and  in
, say,  and ,
respectively, for which  and  are reduced, and,
thus, they reduce the d-connectivity by two. In order to obtain
 for  the vertices of
 must increase the d-connectivity by
two. However, the size of  is also
 and vertices  and 
are also internal in . Thus,
increasing the d-connectivity by two is not possible and we have a
contradiction. Note that ; otherwise we would
have also  and  and there would
exist a 1PC having the same endpoints as
 and containing a path  with , a contradiction.

\y \textit{Case~A.5.b}: Suppose that ,  and
,  and there exists a vertex  such that
, 
and there exists no vertex , , such that
. Using
similar arguments as in Case~A.4.a where  is not an endpoint
in , we show that the algorithm
computes a minimum 1PC  of the graph
 having  endpoints  belonging to
different paths with index , ,
such that there is no other minimum 1PC
 having 
endpoints  belonging to different paths with index
 such that
, .
Furthermore, if ,
 and ,  then there exists a
vertex  such that ,  and there exists no
vertex , , such that
.


\y {\bf \textit{Case~A.6}:} When the algorithm processes vertex
, it creates a new path having vertex  as an endpoint,
that is, .
This implies that  we have
. Suppose that there exists a 1PC
 of size
, that is, vertex  is an
internal vertex of a path  in .
Then, removing vertex  from 
results to a 1PC of  of size ,
and, thus, minimum, such that there exists an index  for which
, a contradiction.

\y Suppose now that there exists a 1PC
 of size
. Let  be an endpoint of a path
 in . We distinguish the
following cases:

(i) . Removing vertex  from
 results to a 1PC of  of size
, and, thus, minimum, such that there
exists an index  for which , . Then, , which is equal to the index of the terminal
vertex, and  is the terminal path such that its left endpoint
in , that is, vertex , has
index greater than the index of the left endpoint of the terminal
path in . Note that,  cannot
be an endpoint in  since
, , and, thus, a 1PC of  having  as an endpoint
cannot be minimum. However, removing  from
 results to a 1PC of  of size
 having  as an endpoint, a
contradiction.

(ii) , where  is the terminal vertex. Removing
 and  from  results to a 1PC of  of size
, a contradiction. Indeed, since the
algorithm does not use  to bridge two paths, removing 
from  results to  paths.

\y Now let  be an internal vertex of a path  in .
Suppose that  (the case where  is trivial) and
, where  is the terminal vertex. Since the
algorithm constructs  paths, at least
 neighbors of  have bridged paths reducing the
size of the 1PC and at most one of them was inserted; otherwise
there would exist at least two successive neighbors into a path or
at least one of them would be an endpoint. Suppose that  and
 have both bridged paths. Then, applying the algorithm to
 would result to a minimum 1PC of
 of size .
However, if we remove vertices  and  from
 we obtain a 1PC of
 of size , a
contradiction. Suppose now that  was inserted and  has
bridged paths. We distinguish the following cases:

(i) . Clearly, applying the algorithm to 
results to a minimum 1PC of  of size
. Furthermore, applying the algorithm
to  results to a minimum 1PC  of
 of size  such that no
free neighbor of  is an endpoint and if  sees the
terminal vertex , it is not a trivial path in
. Indeed, any neighbor  of  such
that  cannot be an endpoint in  since
every vertex  such that  is also a neighbor of .
Note that, . Furthermore, since  is inserted, when
vertex  was processed, no neighbor of  was an
endpoint and if  vertex  does not belong to
a trivial path. Indeed, let  be an endpoint when
the algorithm processes vertex  or  belongs to a
trivial path. This implies that, when we apply the algorithm to
, we have one neighbor of , say, , bridging
through vertex  or vertex ; then  would be inserted
through the edge  or , which is a
contradiction since this results to two neighbors of  being
successive. Additionally, no neighbor of  becomes an endpoint
and vertex  does not belong to a trivial path until vertex
 is processed, since all vertices with index greater than
 are neighbors of , and, thus, they are used to bridge
paths reducing the size of the 1PC. Note that, according to the
algorithm, vertex  cannot belong to a trivial path until
vertex  is processed, since no bridge operation results
to  belonging to a trivial path. Consequently, applying the
algorithm to  results to a minimum 1PC
 of size
 such that no free neighbor of 
is an endpoint and if  sees the terminal vertex , it is
not a trivial path in .

(ii) . Similarly to case (i), applying the algorithm to
 results to a minimum 1PC
 of size
 such that no free neighbor of 
is an endpoint and if  sees the terminal vertex , it is
not a trivial path in . Indeed, when
vertex  is processed, no neighbor of  is an endpoint
and if  sees the terminal vertex , it is not a trivial
path. Furthermore, since no neighbor of  can be an endpoint,
no vertex with index greater than  is an endpoint.
Additionally, no neighbor of  becomes an endpoint and if
, vertex  does not belong to a trivial path
until vertex  is processed, since all vertices with index
greater than  are neighbors of , and, thus, they are
used to bridge paths reducing the size of the 1PC. Note that,
according to the algorithm, vertex  cannot belong to a
trivial path until vertex  is processed. Consequently,
applying the algorithm to  results to a minimum 1PC
 of size
 such that no free neighbor of 
is an endpoint and if  sees the terminal vertex , it is
not a trivial path in .

\y Since  is an internal vertex of a path  in 
which has size , if we remove vertices
 and  from  we obtain a 1PC of  of
size  such that a free neighbor of
 is an endpoint, a contradiction; the same holds when
 . If  then  belongs to a trivial path in
, a contradiction. If  or , then removing
vertices  and  from  results to a 1PC of
 of size , a contradiction.

\y Now let , where  is the terminal vertex.
The case where  is an internal vertex of a path  in
 which has size
 leads to a contradiction similarly to
the case where . Suppose that  is an
internal vertex of a path  in
 which has size
. According to the algorithm, no
neighbor of  is inserted until vertex  is processed.
Also, it is easy to see that, no neighbor of  with index
greater than  is inserted, either. Indeed, let , ,
be a neighbor of  which is inserted into the terminal path.
Since the algorithm results to 
paths,  is inserted through an edge  such that
 and  is connected to a vertex
 such that . This implies that the
ordering of the vertices  and  of the
terminal path is as follows:  or
; Without loss of generality suppose that
. Let  be the other endpoint of the
terminal path. Clearly . Also, without loss of
generality, suppose that . Consequently, when vertex
 is processed, the algorithm has constructed a path having
two successive vertices,  and , which have indexes
greater than those of the endpoints of the path, that is, 
and . This is a contradiction, since it implies that there
exists at least one vertex with index greater than  which sees
; in this case the algorithm could not result to a path
having  as an endpoint. Consequently, we have shown that if
we apply the algorithm to , no neighbor of  is inserted
into the terminal path. Furthermore, since there are no neighbors
of  successive into a path, all neighbors of  bridge
paths reducing the size of the 1PC. This implies that, if we apply
the algorithm to , we obtain a minimum 1PC of
 of size . Furthermore,
if we apply the algorithm to , we obtain a
minimum 1PC of  of size
. However, removing  and
 from  which is a path in
, we obtain a 1PC of
 of size at most , a
contradiction; thus,  cannot be an internal vertex of a path
 in
 which has size
.

\y We have shown that there does not exist a 1PC
 of size
, and, thus,
 is a minimum 1PC of , that is,
.

\y Using similar arguments as in Case~A.4.a where  is an
endpoint in , we show that the
algorithm computes a minimum 1PC  of
every interval graph  with  vertices having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .

\yy {\bf Case~B:} vertex  is the terminal vertex. Clearly,
the size  of a minimum 1PC of  is
equal to  or
. We distinguish the following cases:

\y {\bf \textit{Case~B.1}:} When the algorithm processes vertex
, it connects  to a path, that is,
. Since  is
the terminal vertex, the 1PC  is a
minimum 1PC of , that is,
.

\y We show that the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .

\y Suppose that . Then, there cannot exist a minimum
1PC  such that .
Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index ,
where .
Similarly, to Case~A.1, there exists a vertex , , such that .

\y Suppose that . If , then
, and, thus, . Then, if we
remove  from  and
, we obtain

and ; thus,
, a
contradiction. On the other hand, if , then, if we
remove  from  and
, we obtain

or
.
Also, ; thus,
, a
contradiction.

\y {\bf \textit{Case~B.2}:} When the algorithm processes vertex
, it constructs a new trivial path, that is,
. Suppose that
there exists a 1PC  of size
. Clearly, vertex  cannot belong
to a trivial path in , since
removing it results to a 1PC of  of size
, a contradiction. Thus, let  be the path
containing . Removing vertex  from
 results to a 1PC of  of size
, and, thus, minimum, having a neighbor
of , that is, vertex , as an endpoint of a path. Since
 does not contain the terminal vertex, according to the
induction hypothesis, this is a contradiction. Consequently, the
1PC  is a minimum 1PC of , that
is,
.


\y We show that the algorithm computes a minimum 1PC
 of the graph  having
 endpoints  belonging to different
paths with index , , such that
there is no other minimum 1PC 
having  endpoints  belonging to
different paths with index  such that
, .

\y Since  there cannot exist a minimum 1PC
 such that .
Assume that there exists a minimum 1PC
 having an index, say, , for
which we have  endpoints 
belonging to different paths with index ,
where . Suppose
that  and . Similarly, to Case~A.1, there exists a vertex , , such that .

\y Suppose that ; the case where  is
trivial. If , then , and,
thus, vertex  would be connected, a contradiction. If
, then, if we remove  from
 and
, we obtain

and , a
contradiction. \s \qed

\yy Let  be an interval graph on  vertices and 
edges and let  be a terminal set containing a vertex
. Then, Algorithm Minimum\_1PC computes a minimum 1PC
 of  in  time and requires
linear space. Recall that the ordering  of the vertices is
constructed in linear time \cite{RamRan}. Hence, we can state the
following result.

\bigskip
\par\noindent
{\bf Theorem~4.2.} {\it Let  be an interval graph on
~vertices and let  be a subset of 
containing a single vertex. A minimum 1-fixed-endpoint path cover
of  with respect to  can be computed in 
time.}


\vskip 0.3in \section{Related Results on Convex and Biconvex Graphs}
Based on the results for the 1PC problem on interval graphs, and
also on the reduction described by M\"{u}ller in \cite{Muller}, we
study the HP and 1HP problems on convex and biconvex graphs. A
bipartite graph  is called {\it -convex} (or simply
convex) if there exists an ordering  so that for all 
the set N(y) is -consecutive \cite{Muller};  is {\it
biconvex} if it is convex on both  and .

\y In this section, we solve the HP and 1HP problems on a biconvex
graph . Moreover, we show that the HP problem on a
-convex graph  on  vertices can be solved in
 time if  or  and a 1HP starting at
vertex , if there exists, can be computed in  time if
( and ) or .

\y  We next describe an algorithm for the HP problem on a biconvex
graph . Note that the operation Algorithm\_HP
corresponds to the algorithm for computing a minimum path cover of
an interval graph described in \cite{AR90}.


\bigskip \noindent{\it Algorithm HP\_Biconvex} \y \noindent{\it
Input:} a biconvex graph  on  vertices; \y
\noindent{\it Output:} a Hamiltonian path of , if one exists;
\y

\begin{enumerate}
  \item {\tt if}  {\tt then} {\tt return}( does not have a Hamiltonian path);
  \item {\tt if}  {\tt then} \\
         \phantom{if} {\tt construct} the interval graph : , ,
         where  is as follows: \\
         \phantom{if} \phantom{if} \phantom{if}  iff  and ;\\
         \phantom{if} {\tt if}  {\tt then} \\
         \phantom{if} \phantom{if} \phantom{if} {\tt Minimum\_1PC(,)};\\
         \phantom{if} \phantom{if} \phantom{if} {\tt if} 
         {\tt then} {\tt return();}\\
         \phantom{if} \phantom{if} \phantom{if} {\tt else} {\tt return}( does not have a Hamiltonian path);\\
         \phantom{if} {\tt else} \\
         \phantom{if} \phantom{if} \phantom{if} {\tt for}  {\tt to}  {\tt do} \\
         \phantom{if} \phantom{if} \phantom{if} \phantom{for}  {\tt Minimum\_1PC()};\\
         \phantom{if} \phantom{if} \phantom{if} \phantom{for} {\tt if}  {\tt then} {\tt return();}\\
         \phantom{if} \phantom{if} \phantom{if} {\tt end-for;}\\
         \phantom{if} \phantom{if} \phantom{if} {\tt return}( does not have a Hamiltonian path);
  \item {\tt if}  {\tt then} \\
         \phantom{if} {\tt Algorithm\_HP()};\\
         \phantom{if} {\tt if}  {\tt then} {\tt return();}\\
         \phantom{if} {\tt else} {\tt return}( does not have a Hamiltonian path);
  \item {\tt if}  {\tt then} \\
         \phantom{if} {\tt construct} the interval graph : , ,
         where  is as follows: \\
         \phantom{if} \phantom{if}  iff  and ;\\
         \phantom{if} {\tt Algorithm\_HP()};\\
         \phantom{if} {\tt if}  {\tt then} {\tt return();}\\
         \phantom{if} {\tt else} {\tt return}( does not have a Hamiltonian path);
\end{enumerate}


\y \noindent {\bf Observation~5.1.} \s Uehara and Uno in
\cite{UeharaUno} claim that the HP problem on a biconvex graph
 on  vertices can be solved in  time even if
. Specifically, they claim that  has an HP if and only
if the interval graph  has an HP, where  is an interval
graph such that  and , where
 is as follows:  iff  and
. However, this is not true,
since there exists a counterexample, which is presented at
Figure~\ref{biconvex}. Indeed, the biconvex graph  of
Figure~\ref{biconvex} does not have an HP while for  we have
. Suppose that we
construct an interval graph  such that  and
, where  is as follows:  iff  and . Then,  has an HP, that is, . Thus, there exists no algorithm with time
complexity  and we can state the following result.


\begin{figure}[t]
\yy \hrule \y\y\y
  \centering
  \includegraphics[scale=1]{biconvex.eps}
  \centering
  \caption{\small{A biconvex graph .}}
  \label{biconvex}
 \yy \hrule \y\y
\end{figure}

\bigskip
\par\noindent
{\bf Theorem~5.1.} {\it The Hamiltonian path problem on a biconvex
graph  on  vertices can be solved in  time.}

\bigskip Similarly, we show that the Hamiltonian path problem on a
-convex graph  on  vertices can be solved in
 time when  or . It is easy to see
that if  then the -convex graph  has a
Hamiltonian path if and only if the interval graph  has a 2HP
between any two vertices of . Thus, we can state the following
result.

\bigskip
\par\noindent
{\bf Corollary~5.1.} {\it The Hamiltonian path problem on a
-convex graph  on  vertices can be solved in
 time if  or .}

\bigskip We next describe an algorithm for the 1HP problem on a
biconvex graph .

\bigskip \noindent{\it Algorithm 1HP\_Biconvex} \y \noindent{\it
Input:} a biconvex graph  on  vertices and a vertex
; \y \noindent{\it Output:} a a Hamiltonian path of
 starting at vertex , if one exists; \y

\begin{enumerate}
  \item {\tt if}  {\tt then} {\tt return}( does not have a 1HP);
  \item {\tt if}  {\tt then} \\
         \phantom{if} {\tt construct} the interval graph : , , where  is as follows: \\
         \phantom{if} \phantom{if} \phantom{if}  iff  and ;\\
         \phantom{if} {\tt Minimum\_1PC()};\\
         \phantom{if} {\tt if}  {\tt then} {\tt return();}\\
         \phantom{if} {\tt else} {\tt return}( does not have a 1HP);
  \item {\tt if}  {\tt then} {\tt return}( does not have a 1HP);
  \item {\tt if}  {\tt then} \\
         \phantom{if} {\tt construct} the interval graph : , , where  is as follows: \\
         \phantom{if} \phantom{if}  iff  and ;\\
         \phantom{if} {\tt Minimum\_1PC()};\\
         \phantom{if} {\tt if}  {\tt then} {\tt return();}\\
         \phantom{if} {\tt else} {\tt return}( does not have a 1HP);
  \end{enumerate}


\y Since Algorithm Minimum\_1PC requires  time to compute
a 1HP of an interval graph on  vertices and the graph  can
be constructed in  time \cite{Muller}, Algorithm
1HP\_Biconvex returns a 1HP, if there exists, of a biconvex graph
on  vertices in  time. Hence, we can state the
following result.

\bigskip
\par\noindent
{\bf Theorem~5.2.} {\it Let  be a biconvex graph on
~vertices and let  be a vertex of . The 1HP problem on
 can be solved in  time.}

\bigskip Let  be a -convex graph on
~vertices and let  be a vertex of . Similarly, we show
that the 1HP problem on  can be solved in  time when
( and ) or . Clearly, if 
and  then  does not have a 1HP. It is easy to see that
if ( and ) or ( and ) then
the -convex graph  has a Hamiltonian path if and only
if the interval graph  has a 2HP between  and a vertex of
. Thus, we can state the following result.

\bigskip
\par\noindent
{\bf Corollary~5.2.} {\it Let  be a -convex graph on
~vertices and let  be a vertex of . The 1HP problem on
 can be solved in  time if ( and ) or
. If  and  then  does not have a
1HP.}



\vskip 0.3in \section{Concluding Remarks}

This paper presents an  time algorithm for the 1PC problem
on interval graphs. Given an interval graph  and a vertex 
of , our algorithm constructs a minimum path cover of  such
that  is an endpoint. Thus, if the graph  is Hamiltonian,
our algorithm constructs a 1HP. It would be interesting to see if
the problem can be solved in linear time. Furthermore, an
interesting open question is whether the -fixed-endpoint path
cover problem (kPC) can be polynomially solved on interval graphs.
Given a graph  and a subset  of  vertices of
, a -fixed-endpoint path cover of  with respect to
 is a set of vertex-disjoint paths  that
covers the vertices of  such that the  vertices of
 are all endpoints of the paths in . The
kPC problem is to find a -fixed-endpoint path cover of  of
minimum cardinality. Note that, the kPC problem generalizes the
2HP problem; the complexity status of the 2HP problem on interval
graphs remains an open question. }


 \frenchspacing \vskip 0.4in

\begin{thebibliography}{99}
\bibitem{AdPe90} G.S.~Adhar and S.~Peng, Parallel algorithm for path covering,
Hamiltonian path, and Hamiltonian cycle in cographs, {\it Int'l
Conference on Parallel Processing}, Vol.~III: Algorithms and
Architecture, Pennsylvania State University Press, 1990, pp.
364--365.

\bibitem{AR90} S.R.~Arikati and C.P.~Rangan, Linear algorithm for optimal path
cover problem on interval graphs, {\it Inform. Process. Lett.}
{\bf 35} (1990), 149--153.

\bibitem{AsdNik} K.~Asdre and S.D.~Nikolopoulos, A linear-time algorithm for the
-fixed-endpoint path cover problem on cographs, {\it Networks}
{\bf 50} (2007) 231--240.

\bibitem{AsdNik2} K.~Asdre and S.D.~Nikolopoulos, A polynomial solution for the
-fixed-endpoint path cover problem on proper interval graphs,
{\it Proc. 18th International Conference on Combinatorial
Algorithms (IWOCA'07)}, Lake Macquarie, Newcastle, Australia,
2007.



\bibitem{Bertossi} A.A.~Bertossi, Finding Hamiltonian circuits in proper interval
graphs, {\it Inform. Process. Lett.} {\bf 17} (1983), 97--101.

\bibitem{BertBonucc} A.A.~Bertossi and M.A.~Bonuccelli, Finding Hamiltonian circuits in
interval graph generalizations, {\it Inform. Process. Lett.} {\bf
23} (1986), 195--200.

\bibitem{BraLeSpi} A.~Brandst\"{a}dt, V.B.~Le, and J.~Spinrad, {\it Graph classes --
A survey}, SIAM Monographs in Discrete Mathematics and
Applications, SIAM, Philadelphia, 1999.









\bibitem{Damaschke} P.~Damaschke, Paths in interval graphs and circular arc graphs,
{\it Discrete Math.} {\bf 112} (1993), 49--64.



\bibitem{GaJo79} M.R.~Garey and D.S.~Johnson, {\it Computers and intractability: A
guide to the theory of NP-completeness}, W.H.~Freeman, San
Francisco, 1979.

\bibitem{GaJoTar} M.R.~Garey, D.S.~Johnson, and R.E.~Tarjan, The planar Hamiltonian
circuit problem is NP-complete, {\it SIAM J. Comput.} {\bf 5}
(1976), 704--714.



\bibitem{Gol} M.C.~Golumbic, {\it Algorithmic Graph Theory and Perfect Graphs},
Academic Press, New York, 1980. Second edition, Annals of Discrete
Mathematics 57, Elsevier, 2004.







\bibitem{Hsieh} S.Y.~Hsieh, An efficient parallel strategy for the
two-fixed-endpoint Hamiltonian path problem on distance-hereditary
graphs, {\it J. Parallel Distrib. Comput.} {\bf 64} (2004),
662--685.

\bibitem{HsiehHoHsuKo} S.Y.~Hsieh, C.W.~Ho, T.S.~Hsu, and M.T.~Ko, The Hamiltonian
problem on distance-hereditary graphs, {\it Discrete Appl. Math.}
{\bf 154} (2006), 508--524.

\bibitem{HungChangDH} R.W.~Hung and M.S.~Chang, Linear-time algorithms for the
Hamiltonian problems on distance-hereditary graphs, {\it
Theoretical Comp. Science} {\bf 341} (2005), 411--440.

\bibitem{HungChangCA} R.W.~Hung and M.S.~Chang, Solving the path cover problem on
circular-arc graphs by using an approximation algorithm, {\it
Discrete Appl. Math.} {\bf 154} (2006), 76--105.



\bibitem{Keil}  J.M.~Keil, Finding Hamiltonian circuits in interval graphs, {\it
Inform. Process. Lett.} {\bf 20} (1985), 201--206.



\bibitem{LiOlPru95} R.~Lin, S.~Olariu, and G.~Pruesse, An optimal path cover algorithm
for cographs, {\it Comput. Math. Appl.} {\bf 30} (1995), 75--83.





\bibitem{Muller}  H.~M\"{u}ller, Hamiltonian circuits in chordal bipartite graphs,
{\it Discrete Math.} {\bf 156} (1996), 291--298.

\bibitem{NaOlZo03} K.~Nakano, S.~Olariu, and A.Y.~Zomaya, A time-optimal solution for
the path cover problem on cographs, {\it Theoretical Comp.
Science} {\bf 290} (2003), 1541--1556.

\bibitem{Nik}  S.D.~Nikolopoulos, Parallel algorithms for Hamiltonian problems on
quasi-threshold graphs, {\it J. Parallel Distrib. Comput.} {\bf
64} (2004), 48--67.



\bibitem{RamRan}
G.~Ramalingam and C.P.~Rangan, A unified approach to domination
problems on interval graphs, {\it Inform. Process. Lett.} {\bf 27}
(1988), 271--274.





\bibitem{SSSR93} R.~Srikant, R.~Sundaram, K.S.~Singh, and C.P.~Rangan, Optimal path
cover problem on block graphs and bipartite permutation graphs,
{\it Theoretical Comp. Science} {\bf 115} (1993), 351--357.

\bibitem{SuKaNa}  Y.~Suzuki, K.~Kaneko, and M.~Nakamori, Node-disjoint paths
algorithm in a transposition graph, {\it IEICE Trans. Inf. \&
Syst.} {\bf E89-D} (2006), 2600--2605.

\bibitem{UeharaUno}  R.~Uehara and Y.~Uno, On computing longest paths in small graph
classes, {\it Int. J. Foundations Comput. Science} {\bf 18}
(2007), 911--930.

\end{thebibliography}

\end{document}
