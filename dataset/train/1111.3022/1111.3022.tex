\documentclass[12pt,journal,letterpaper,compsoc]{IEEEtran}
\pdfoutput=1
\IEEEoverridecommandlockouts

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[linesnumbered,boxed,ruled,vlined]{algorithm2e}


\onecolumn
\renewcommand{\baselinestretch}{1.2}




\ifCLASSINFOpdf

\else

\fi

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Design of a Sliding Window over Asynchronous Event Streams}

\author{\IEEEauthorblockN{Yiling Yang, Yu Huang\IEEEauthorrefmark{1}, Jiannong Cao, Xiaoxing Ma, Jian Lu\\}
\thanks{\IEEEauthorrefmark{1}Corresponding author.}
\IEEEauthorblockA{State Key Laboratory for Novel Software Technology\\
Nanjing University, Nanjing 210093, China\\
Department of Computer Science and Technology\\
Nanjing University, Nanjing 210093, China\\
csylyang@smail.nju.edu.cn,
\{yuhuang, xxm, lj\}@nju.edu.cn\\}
Internet and Mobile Computing Lab, Department of Computing\\
Hong Kong Polytechnic University, Hong Kong, China\\
csjcao@comp.polyu.edu.hk
}

\maketitle

\begin{abstract}

The proliferation of sensing and monitoring applications motivates adoption of the event stream model of computation. Though sliding windows are widely used to facilitate effective event stream processing, it is greatly challenged when the event sources are distributed and asynchronous. To address this challenge, we first show that the snapshots of the asynchronous event streams within the sliding window form a convex distributive lattice (denoted by {\it Lat-Win}). Then we propose an algorithm to maintain {\it Lat-Win} at runtime. The {\it Lat-Win} maintenance algorithm is implemented and evaluated on the open-source context-aware middleware we developed. The evaluation results first show the necessity of adopting sliding windows over asynchronous event streams. Then they show the performance of detecting specified predicates within {\it Lat-Win}, even when faced with dynamic changes in the computing environment.

\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}
\label{sec:introduction}

Sensing devices such as wireless sensor motes and RFID readers are gaining adoption on an increasing scale for tracking and monitoring purposes. An emerging class of applications includes context-aware computing in a smart home/office \cite{Huang09, Huang11}, supply chain management \cite{Niederman07}, and facility management \cite{Wu06}. These applications require the online processing of a large amount of events from multiple event sources, which necessitate the {\it event stream model} of computation \cite{Tirthapura06, Wu06}.

In tracking and monitoring applications, event streams are often generated from multiple distributed sources. More importantly, the event sources may not have a global clock or shared memory. Communications among the event sources may suffer from finite but arbitrary delay. It is a critical challenge how to process such {\it asynchronous event streams}  \cite{Tirthapura06, Huang09, Huang11}.

For example in a smart office scenario, the context-aware middleware may receive the event stream of user's location updates from his mobile phone (we assume that the user's location can be decided by the access point his phone connects to) \cite{Huang09, Huang11}. The middleware may also receive event streams from sensors in the meeting room about whether there is a presentation going on. Due to the asynchrony among the event sources, the middleware cannot easily decide the composite global event ``the user is in the meeting room, where a presentation is going on", in order to mute the mobile phone intelligently.

Coping with the asynchrony has been widely studied in distributed computing \cite{Babaoglu93, Schwarz94}. One important approach relies on the ``happen-before" relation resulting from message passing \cite{Lamport78}. Based on this relation, various types of logical clocks can be devised \cite{Schwarz94, Mattern89}. Based on logical time, one key notion in an asynchronous system is that all meaningful observations or global snapshots of the system form a distributive lattice \cite{Babaoglu93, Schwarz94}.

In tracking and monitoring applications, the events may quickly accumulate to a huge volume, and so will the lattice of global snapshots of the asynchronous event streams\cite{Schwarz94, Jard94}. Processing of the entire event streams is often infeasible and, more importantly, not necessary \cite{Braverman11}. In such applications, we are often concerned only on the most recent events. This can be effectively captured by the notion of a {\it sliding window} \cite{Datar02, Tirthapura06, Braverman11}. Processing events within the window (discarding the stale events) can greatly reduce the processing cost. Also in the smart office scenario, user's location half an hour ago is often of little help in meeting his current need. Thus we can keep a sliding window (say latest 5 location updates) over the user's location stream.

Challenge of the asynchrony and effectiveness of the sliding window motivate us to study the following problem. In a system of  asynchronous event streams and one sliding window on each stream, we define an {\it n-dimensional sliding window} as the Cartesian product of the window on every event source. Considering the system of asynchronous event streams within the -dimensional sliding window, does the lattice structure of global snapshots preserve? If it does, how to effectively maintain this lattice of snapshots at runtime? How to support effective detection of predicates over event streams within the window? Toward these problems, the contribution of this work is two-fold:
\begin{itemize}
  \item We first prove that global snapshots of asynchronous event streams within the -dimensional sliding window form a distributive lattice (denoted by {\it Lat-Win}). We also find that {\it Lat-Win} is a convex sub-lattice of the ``original lattice'' (obtained when no sliding window is imposed and the entire streams are processed);
  \item Then we characterize how {\it Lat-Win} evolves when the window slides over the asynchronous event streams. Based on the theoretical characterization, we propose an online algorithm to maintain {\it Lat-Win} at runtime.
\end{itemize}

A case study of a smart office scenario is conducted to demonstrate how our proposed {\it Lat-Win} facilitates context-awareness in asynchronous pervasive computing scenarios \cite{Huang09, Huang11}. The {\it Lat-Win} maintenance algorithm is implemented and evaluated over MIPA -- the open-source context-aware middleware we developed \cite{MIPA, Huang10b, Huang11}. The performance measurements first show the necessity of adopting the sliding window over asynchronous event streams. Then the measurements show that using the sliding window, fairly accurate predicate detection (accuracy up to 95\%) can be achieved, while the cost of event processing can be greatly reduced (to less than 1\%).

The rest of this paper is organized as follows. Section \ref{sec:preliminaries} presents the preliminaries. Section \ref{sec:design-overview} overviews how {\it Lat-Win} works, while Section \ref{sec:characterization} and \ref{sec:algorithm} detail the theoretical characterization and algorithm design respectively. Section \ref{sec:evaluation} presents the experimental evaluation. Section \ref{sec:related-work} reviews the related work. Finally, In Section \ref{sec:conclusion}, we conclude the paper and discuss the future work.

\section{Preliminaries}
\label{sec:preliminaries}

In this section, we first describe the system model of asynchronous event streams. Then we discuss the lattice of global snapshots of asynchronous event streams. Finally, we introduce the {\it -dimensional sliding window} over asynchronous event streams. Notations used through out this work are listed in Table \ref{T:Notations-Model}.
\begin{table}[htbp]
\caption{Notations Used in Design of {\it Lat-Win}}
\label{T:Notations-Model} \centering
\begin{tabular}{r | l}
\hline
Notation & Explanation \\
\hline
\hline

 & number of non-checker processes \\

 & non-checker / checker process () \\

 & event / local state on  \\

 & queue of local states from each  on  \\

 & sliding window on a single event stream \\

 & the oldest/latest local state within  \\

 & uniform size of every  \\

 & -dimensional sliding window over asynchronous event streams \\

 & global state of the asynchronous event streams \\

 & Consistent Global State (CGS) \\

 &  constituent local state of  \\

{\it LAT} & original lattice of CGSs when no sliding window is used and the entire streams are processed \\

{\it Lat-Win} & lattice of CGSs within the -dimensional sliding window \\

 &  the minimal/maximal CGSs in {\it Lat-Win} \\

\hline
\end{tabular}
\end{table}

\subsection{A System of Asynchronous Event Streams}

In a tracking/monitoring application, we are faced with multiple distributed event sources which generate event streams at runtime. The event sources do not necessarily have global clocks or shared memory. The event sources are modeled as  {\it non-checker processes} . Each  produces a stream of {\it events} connected by its {\it local states}: ``, , , , , ", as shown in Fig. \ref{F:space time diagram}. The event may be local, indicating status update of the entity being monitored and causing a local state change, or global, e.g. communication via sending/receiving messages. The non-checker processes form a loosely-coupled asynchronous system. We assume that no messages are lost, altered or spuriously introduced, as in \cite{Garg94, Garg96}. The underlying communication channel is not necessarily FIFO.

We re-interpret the notion of time based on Lamport's definition of the {\it happen-before} relation (denoted by `') resulting from message causality \cite{Lamport78}. This happen-before relation can be effectively encoded and decoded based on the logical vector clock scheme \cite{Mattern89}. Specifically, for two events  and  in the system of asynchronous event streams, we have  iff:

\begin{itemize}
  \item , or
  \item , or
  \item .
\end{itemize}

\noindent For two local states  and ,  iff the ending of  happen-before (or coincides with) the beginning of  (note that the beginning and ending of a state are both events). As shown in Fig. \ref{F:space time diagram},  and .

\begin{figure}[htbp]
    \subfigure[Sliding windows over asynchronous event streams]{
        \label{F:space time diagram}
        \begin{minipage}[b]{0.5\textwidth}
        \centering
        \includegraphics[width=2.5in]{Figs/space-time-window-1.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[The -dimensional sliding window over the lattice]{
        \label{F:window over lattice}
        \begin{minipage}[b]{0.5\textwidth}
        \centering
        \includegraphics[width=2.5in]{Figs/lattice-window-1.pdf}
        \end{minipage}}\\
    \centering\parbox[c]{1.6in}{\caption{System model}}
    \label{F:system model}
\end{figure}

One {\it checker process}  is in charge of collecting and processing the asynchronous event streams. For example in a context-aware computing scenario \cite{Huang11},  may be a context reasoning process deployed over the context-aware middleware. In a supply chain management scenario,  may be a central administration application, monitoring the progresses of multiple supply chains.

Whenever  generates a new event and proceeds to a new local state, it sends the local state with the vector clock timestamp to . We use message sequence numbers to ensure that  receives messages from each  in FIFO manner \cite{Garg94, Garg96, Huang09, Huang11}.

\subsection{Lattice of Consistent Global States(CGS)}
\label{sec:lattice}

In the tracking/monitoring application, we are concerned with the state of the entities being monitored after specific events are executed. For a system of asynchronous event streams, we are thus concerned with the global states or snapshots of the whole system.

A global state  of asynchronous event streams is defined as a vector of local states from each non-checker process . A global state may be either consistent or inconsistent. The notion of {\it Consistent Global State (CGS)} is crucial in processing of asynchronous event streams. Intuitively, a global state is consistent if an omniscient external observer could actually observe that the system enters that state. Formally, a global state  is {\it consistent} if and only if the constituent local states are pairwise concurrent \cite{Babaoglu93}, i.e., 

\noindent The CGS denotes a global snapshot or meaningful observation of the system of asynchronous event streams.

It is intuitive to define the {\it precede} relation (denoted by `') between two CGSs:  if  is obtained via advancing  by exactly one local state on one non-checker process. The {\it lead-to} relation (denoted by `') is defined as the transitive closure of `'.

The set of all CGSs together with the `' relation form a distributive lattice \cite{Babaoglu93, Schwarz94}. As shown in Fig. \ref{F:window over lattice}, black dots denote the CGSs and the edges between them depict the '' relation. The crosses ``'' denote the inconsistent global states. The lattice structure among all CGSs serves as a key notion for the detection of global predicates over asynchronous event streams \cite{Babaoglu93, Schwarz94}.

\subsection{The -dimensional Sliding Window over Asynchronous Event Streams}

On , states of each event source  are queued in . As discussed in Section \ref{sec:introduction}, in many cases, it is too expensive and often unnecessary to process the entire event stream. A {\it local sliding window}  of size  is imposed on each . Then we can define the {\it -dimensional sliding window}  as the Cartesian product of each : .

As shown in Fig. \ref{F:space time diagram}, the window  with  on  currently contains \{, , \}. The 2-dimensional sliding window  is depicted by the gray square in Fig. \ref{F:window over lattice}. The arrival of  will trigger the 2-dimensional window to slide in 's dimension, and  is updated to \{, , \}.

We assume that the concurrency control scheme is available on , which means that the events from all non-checker processes are processed one at a time. We also assume that the sliding windows on the event streams have uniform size . Note that this assumption is not restrictive and is for the ease of interpretation. Our proposed scheme also works if the windows on different streams have different sizes.

\section{Lat-Win - Design Overview}
\label{sec:design-overview}

The central problem in this work is how to characterize and maintain the -dimensional sliding window over asynchronous event streams. Toward this problem, our contribution is two-fold. First, we characterize {\it Lat-Win} - the lattice of CGSs over the asynchronous event streams within the -dimensional sliding window. Then we propose an online algorithm to maintain {\it Lat-Win} at runtime.
\begin{figure}[htbp]
        \begin{minipage}[b]{1\textwidth}
        \centering
        \includegraphics[width=7in]{Figs/design-overview.pdf}
        \end{minipage}\\
    \subfigure[{\it Lat-Win} induced by \{, , , , , \}, and  arrives]{
        \label{F:design overview 1}
        \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=2.2in]{Figs/design-overview-1-1.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[{\it Lat-Win} grows with the CGSs which contain  as a constituent, and  is updated]{
        \label{F:design overview 2}
        \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=2.2in]{Figs/design-overview-2.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[{\it Lat-Win} prunes the CGSs which contain  as a constituent, and  is updated]{
        \label{F:design overview 3}
        \begin{minipage}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=2.2in]{Figs/design-overview-3.pdf}
        \end{minipage}}
    \caption{Online maintenance of {\it Lat-Win}. When  arrives, {\it Lat-Win} first grows with a set of new CGSs and then prunes the stale CGSs.}
    \label{F:design overview}
\end{figure}

\subsection{Characterization of Lat-Win}


An important property concerning {\it Lat-Win} is that all CGSs within the -dimensional sliding window together with the '' relation have the lattice structure. Moreover, {\it Lat-Win} turns out to be a distributive convex sublattice of the original lattice {\it LAT} (the lattice obtained when no sliding window is used and all event streams are processed). As shown in Fig. \ref{F:window over lattice}, the gray square in the middle is a 2-dimensional sliding window over two asynchronous event streams produced by  and . The CGSs within the square form a convex sublattice of the original lattice, i.e., the {\it Lat-Win}.

When an event  is executed and  arrives at a new local state , the stale local state  () in window  will be discarded. The {\it Lat-Win} will ``grow'' with a set of CGSs consisting of  and other local states from , and ``prune'' the CGSs which contain  as a constituent.

For example in Fig. \ref{F:design overview}, assume that the {\it Lat-Win} is initially shown in Fig. \ref{F:design overview 1}. When a new local state  arrives,  will be discarded. State  will be combined with local states in  to obtain the CGS  in the blue rectangle in Fig. \ref{F:design overview 2}. CGSs which contain  as a constituent in the left shaded rectangle will be discarded as shown in Fig. \ref{F:design overview 3}. The CGSs in the current window (e.g., the gray square in Fig. \ref{F:design overview 3}) remain to be a sublattice. It seems that the 2-dimensional window containing the {\it Lat-Win} slides over the asynchronous event streams produced by  and .

\subsection{Online Maintenance of Lat-Win}

Based on the theoretical characterization above, we propose an algorithm for maintaining {\it Lat-Win} at runtime. Let  () denote the CGS which has no predecessors (successors) in {\it Lat-Win}.  and  serve as two ``anchors" in updating {\it Lat-Win}. When a new local state arrives, the {\it Lat-Win} ``grows" from  and ``prunes" from , as shown in Fig. \ref{F:design overview}. After the growing and pruning,  and  are also updated for further maintenance of {\it Lat-Win}. Due to the symmetry in the lattice structure, the growing and pruning of {\it Lat-Win} are dual. So are the updates of  and .

\section{Lat-Win - Characterizing the Snapshots of Windowed Asynchronous Event Streams}
\label{sec:characterization}

The theoretical characterization of {\it Lat-Win} consists of two parts. First we study the lattice of snapshots within the -dimensional sliding window. Then we study how the {\it Lat-Win} evolves as the -dimensional window slides.

\subsection{Sub-lattice within the Sliding Window}

An -dimensional sliding window consists of  local windows sliding on event streams produced by non-checker processes , and induces  segments of local states .

The happen-before relation between local states has been encoded in their logical clock timestamps. Based on the local states as well as the happen-before relation among them, we can get a set of CGSs within the -dimensional sliding window. An important property we find is that the CGSs within the -dimensional sliding window, together with the `' relation, also form a lattice - {\it Lat-Win}. More importantly, {\it Lat-Win} is a {\it distributive convex sub-lattice} of the original lattice {\it LAT}. Formally,\\

\noindent{\bf Theorem 1.} {\it Given an -dimensional sliding window  over asynchronous event streams, let  denote the CGSs constructed from local states in . If  is not empty,
\begin{itemize}
    \item[1.] (, ) forms a lattice, denoted by {\it Lat-Win};
    \item[2.] {\it Lat-Win} is a sublattice of {\it LAT};
    \item[3.] {\it Lat-Win} is convex and distributive.
\end{itemize}}

\noindent{\it Proof:}

1.1: A {\it lattice} is a poset  such that for all , the least upper bound ({\it join}) of  and  (denoted ) and the greatest lower bound ({\it meet}) of  and  (denoted ) exist and are contained in the poset. For two CGSs , .

We prove it by contradiction. Assume that  and  does not exist. It is obvious that  is unique, so as . It is to say that  is not a CGS, that is, . Assume without loss of generality that , i.e.,  or . Then, we get . Thus, , which is contrary to that  is a CGS. Thus,  exists. The proof of the existence of  is the same.

\iffalse
If    or  = , then   , which is contrary to that  is a CGS; If   , then , which is also contrary to that  is a CGS. Thus,  exists. The proof of the existence of  is the same.
\fi

It is easy to prove that  and  are both in , because the constituent local states of  and  are all in , and  contains all the CGSs constructed from local states in . Thus, (, ) forms a lattice.

1.2: Let  denote the CGSs of the original lattice {\it LAT}. A subset , is a {\it sublattice} of lattice , iff  is non-empty and , . It is obvious that  of {\it Lat-Win} is a subset of . From the proof of Theorem 1.1, we can easily prove that {\it Lat-Win} is a sublattice of {\it LAT}.

1.3: A subset  of a lattice  is called {\it convex} iff , and  imply that  (see Section I.3 in \cite{Gratzer03}). For three CGSs , , , it infers that  or  or . Note that  and  contains all local states within . Thus, , and . Thus, {\it Lat-Win} is a convex sublattice of the original lattice {\it LAT}.

It is a well known result in lattice theory \cite{Davey02} that the set of all CGSs of a distributed computation forms a distributive lattice under the  relation. Thus, {\it LAT} is a distributive lattice. It can be proved that any sublattice of a distributive lattice is also a distributive lattice \cite{Davey02}. Thus, {\it Lat-Win} is also a distributive lattice. \qed \\

The geometric interpretation of Theorem 1 is that  can be viewed as an -dimensional ``cube'' over the original lattice, and CGSs within this cube also form a lattice {\it Lat-Win}. Moreover, the `convex' and `distributive' properties of the original lattice {\it LAT} preserve when we focus on CGSs within the cube. Let  = (, ). As shown in Fig. \ref{F:design overview 1}, the local windows are  = \{, , \} and  = \{, , \}. They define a square on the original lattice (Fig. \ref{F:window over lattice}) and induce a sublattice {\it Lat-Win} = (\{, , , , \}, ). The induced {\it Lat-Win} is convex because all CGSs ``greater than''  and ``smaller than''  in the original lattice are contained in the {\it Lat-Win}.

Given {\it Lat-Win} defined in Theorem 1, we further study how {\it Lat-Win} is contained in the cube. Is this cube a tight wrapper, i.e., does {\it Lat-Win} span to the boundary of the cube? First note that the maximal CGS and the minimal CGS are both important to the update of {\it Lat-Win}. Intuitively, the maximal CGS  of {\it Lat-Win} is on the upper bound  of at least one local window , so that {\it Lat-Win} could grow with newly arrived local states from . Dually, the minimal CGS  of the {\it Lat-Win} is on the lower bound  of at least one local window , so that {\it Lat-Win} could grow from the stale local states from  in the past. Formally,\\

\noindent{\bf Theorem 2.} {\it If {\it Lat-Win} is not empty,
\begin{itemize}
    \item[1.] ;
    \item[2.] .
\end{itemize}}

\noindent{\it Proof:}

2.1: Let  () denote the successor local state (event) to local state  on , i.e., , . Let  denote the global state formed by combining global state  and  (i.e., , ).

We prove it by contradiction. If {\it Lat-Win} is not empty and , then . Because  is the maximal CGS, , global state  is not CGS.

Global state  is not CGS,  and . Global state  is not CGS,  and . (If , we can get that  or , which is contrary to irreflexivity). By induction on the length of the set containing the used indexes (\{\} above), we can get that to the last global state , the set contains all the indexes, and  (If , it will lead to the contradiction to irreflexivity). Thus, if {\it Lat-Win} is not empty, .

2.2: The proof is dual as above. \qed \\

As shown in Fig. \ref{F:design overview 1}, the maximal CGS  =  = ,  =  =  and the minimal CGS  =  = .

\subsection{Update of Lat-Win when the Window Slides}

\begin{figure}[htbp]
    \subfigure[The restrictions which have no CGSs induced by  and ]{
        \label{F:restrictions}
        \begin{minipage}[b]{0.235\textwidth}
        \centering
        \includegraphics[width=1.8in]{Figs/restrictions-1.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[The empty window induced by \{, , , , , \}, and  arrives]{
        \label{F:example 1}
        \begin{minipage}[b]{0.235\textwidth}
        \centering
        \includegraphics[width=1.8in]{Figs/example-1.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[{\it Lat-Win} induced by \{, , , , , \}, and  arrives]{
        \label{F:example 2}
        \begin{minipage}[b]{0.235\textwidth}
        \centering
        \includegraphics[width=1.8in]{Figs/example-2.pdf}
        \end{minipage}}\hspace*{\fill}
    \subfigure[{\it Lat-Win} induced by \{, , , , , \}, and  arrives]{
        \label{F:example 3}
        \begin{minipage}[b]{0.235\textwidth}
        \centering
        \includegraphics[width=1.8in]{Figs/example-3.pdf}
        \end{minipage}}
    \caption{Restrictions and the slide of the -dimensional window. Assume the arrival of local states is .}
    \label{F:examples}
\end{figure}

In this section, we discuss the update of {\it Lat-Win} when the -dimensional window slides. Informally, the window slides as a new event is executed on  and  arrives at a new local state.

When a new local state from  arrives, the stale local state (i.e., the old ) will be discarded. {\it Lat-Win} will grow with the CGSs containing the newly arrived local state, and prune the CGSs containing the stale local state, as shown in Fig. \ref{F:design overview}. Since the intersection between the set of new CGSs and the set of stale CGSs is empty, the growing and pruning of {\it Lat-Win} can be proceeded in any order. In this work, we first add newly obtained CGSs to {\it Lat-Win} and then prune the stale CGSs. During the growing and pruning process,  and  are also updated for further updates of {\it Lat-Win}.

We characterize the evolution of {\it Lat-Win} in three steps:
\begin{itemize}
    \item Lemma 3 defines the {\it restrictions} of lattice, which serves as the basis for further growing and pruning;
    \item Theorem 4 defines the condition when {\it Lat-Win} can grow and Theorem 5 identifies the new  and  when {\it Lat-Win} grows;
    \item Theorem 6 defines the condition when {\it Lat-Win} can prune and Theorem 7 identifies the new  and  when {\it Lat-Win} prunes.
\end{itemize}

\noindent The growing and pruning are dual, as well as the updates of  and .

\subsubsection{Restrictions}

Before we discuss the update of {\it Lat-Win}, we first introduce the notion of {\it restrictions}. When we obtain a global state and decide that it is not consistent, we can induce a specific region containing only inconsistent global states. The specific regions are also called {\it restrictions} in \cite{Mattern89}.

The geometric interpretation can be illustrated by the example in Fig. \ref{F:restrictions}, global states  = () and  = () are not consistent ( and  in Fig. \ref{F:space time diagram}). When looking from ,  makes the lower gray region have no CGSs. When looking from ,  makes the upper gray region have no CGSs. Formally, we have the following lemma: \\

\noindent{\bf Lemma 3.} To a CGS  of a lattice, and two global states ,  () is the first (last) local state after (before)  on , , ,
\begin{itemize}
    \item[1.] If  is not CGS, then , and none of the global states in the following set is CGS:
        \{  or ,  or \};
    \item[2.] If  is not CGS, then , and none of the global states in the following set is CGS:
        \{  or ,  or \}.
\end{itemize}

\noindent{\it Proof:}

3.1: If  is not CGS, it is easy to verify that . To any global state  in  or  or , it is easy to verify that . Thus, global state  is not consistent, and none of the global states in the set is CGS.

3.2: The proof is dual as above. \qed\\

\subsubsection{Growing of {\it Lat-Win}}

On the arrival of a new local state , the -dimensional window slides in 's dimension, i.e., , and a set of newly obtained CGSs (containing ) will be added into {\it Lat-Win}. We find that the growing process does not have to explore the whole combinational space of the new local state with all local states from every . If {\it Lat-Win} is not empty, it will grow from  in {\it Lat-Win}. The reason is that, if the next global state growing from  is not consistent, as  in Lemma 3, it can be proved that the global states containing the newly arrived local state as a constituent are all in the restriction induced by a further global state and therefore not consistent. When {\it Lat-Win} is empty, the lattice can grow iff one CGS can be obtained containing the new local state and a lower bound of some local window. This is because as discussed in Theorem 2, the new  should contain at least a lower bound of a local window. Formally, \\

\noindent{\bf Theorem 4.} When a new event  is executed on  and the new local state  from  arrives,
\begin{itemize}
    \item[1.] If {\it Lat-Win} , then {\it Lat-Win} can grow iff  (the old ) and global state  (, ) is CGS;
    \item[2.] If {\it Lat-Win} = , then {\it Lat-Win} can grow iff ,  is CGS\}.
\end{itemize}

\noindent{\it Proof:}

4.1: ``'': We first prove that if {\it Lat-Win} is not empty and can grow, . We prove it by contradiction. If ,  and . From the proof of Theorem 2.1, we can easy to verify that  and . Note that . Thus, to any new global states  containing , . By Lemma 3, {\it Lat-Win} cannot grow, which is contract to that {\it Lat-Win} can grow. Thus, if {\it Lat-Win} is not empty and can grow, .

We then prove that if {\it Lat-Win} is not empty and can grow, global state  (, ) is CGS. We prove it by contradiction. If  is not CGS, ,  (). If , by the proof of Theorem 2.1, we can easily verify that ,  and . Thus, . Thus, to any new global states  containing , . By Lemma 3, {\it Lat-Win} cannot grow. Thus, if {\it Lat-Win} is not empty and can grow, global state  (, ) is CGS.

``'': Global state  is CGS, thus {\it Lat-Win} can grow.

4.2: ``'': It is easy to verify the theorem by Theorem 2.2. It can be proved by contradiction. If ,  is CGS\}, after the process of growing, the new  contains , and . By combining the predecessor local state of each  with , a violation of irreflexivity will be inferred, dual as the proof of Theorem 2.1.

``'': ,  is CGS\}, then {\it Lat-Win} can grow. \qed \\

We illustrate the theorem by three examples in Fig. \ref{F:example 1}, Fig. \ref{F:example 2}, and Fig. \ref{F:example 3}, on the arrival of , , and , respectively. In Fig. \ref{F:example 1}, the current {\it Lat-Win} is empty and  arrives. The lattice can grow iff the global state  = (, ) is CGS. Note that  is CGS (as shown in Fig. \ref{F:restrictions}). Thus {\it Lat-Win} can grow to the new lattice in Fig. \ref{F:example 2}. In Fig. \ref{F:example 2}, the current {\it Lat-Win} is not empty and  arrives. {\it Lat-Win} can grow iff  and the global state  = (, ) is CGS. Note that  is not CGS (in Fig. \ref{F:restrictions}). Thus {\it Lat-Win} cannot grow, as shown in Fig. \ref{F:example 3}. In Fig. \ref{F:example 3}, the current {\it Lat-Win} is not empty and  arrives. {\it Lat-Win} can grow iff  and the global state  = (, ) is CGS. Note that  is CGS (in Fig. \ref{F:restrictions}). Thus {\it Lat-Win} can grow to the new lattice in Fig. \ref{F:design overview 1}.

The maximal and minimal CGSs are important to the update of {\it Lat-Win}. Thus, we discuss how to locate  and  after the growing of {\it Lat-Win} for further updates. After the growing of {\it Lat-Win}, the new  should contain the new local state as a constituent. If {\it Lat-Win} was empty and grows with the new local state,  should contain the new local state as a constituent.

For example in Fig. \ref{F:example 1}, {\it Lat-Win} is empty and can grow with the newly arrived local state , the new  =  and the new  = , as shown in Fig. \ref{F:example 2}. Formally, \\

\noindent{\bf Theorem 5.} When a new event  is executed on  and the new local state  from  arrives,
\begin{itemize}
    \item[1.] If {\it Lat-Win} can grow, then  (the new ); else  remains.
    \item[2.] If {\it Lat-Win} =  and can grow, then ; else  remains.
\end{itemize}

\noindent{\it Proof:}

5.1: If {\it Lat-Win} can grow, all the new CGSs contain  as a constituent. The CGS  in Theorem 4.1 ensures that the new maximal CGS is at least ``larger than'' . Thus, the new  is in the set of the new CGSs, and .

5.2: If {\it Lat-Win} =  and can grow, it is easy to verify . \qed \\

\subsubsection{Pruning of {\it Lat-Win}}

On the arrival of a new local state, after the growing of new CGSs, {\it Lat-Win} will prune the CGSs which contain the stale local state. The pruning does not have to explore the whole lattice to check whether a CGS contains the stale local state. Intuitively, {\it Lat-Win} can prune, iff {\it Lat-Win} is not empty and  contains the stale local state. Formally, \\

\noindent{\bf Theorem 6.} When a new event  is executed on  and the new local state  from  arrives, after the growing, {\it Lat-Win} can prune, iff {\it Lat-Win}  and .

\noindent{\it Proof:}

``'': If {\it Lat-Win} can prune, that is, there is at least a CGS containing the stale local state (the old ). Thus,  equals the old , and .

``'': If {\it Lat-Win}  and ,  contains the stale local state. Thus, {\it Lat-Win} can prune. \qed \\

For example, in Fig. \ref{F:example 2}, on the arrival of ,  and . Thus {\it Lat-Win} can prune, as shown in Fig. \ref{F:example 3}. In Fig. \ref{F:example 3}, on the arrival of ,  and . Thus {\it Lat-Win} does not have to prune, as shown in Fig. \ref{F:design overview 1}.

We then discuss how to locate  and  after the pruning of {\it Lat-Win} for further updates. When a new local state from  arrives, after the pruning of {\it Lat-Win}, if {\it Lat-Win} prunes to be empty, the maximal and minimal CGSs are {\it null}. If {\it Lat-Win} prunes to be non-empty, the minimal CGS should contain the new . Formally, \\

\noindent{\bf Theorem 7.} When a new event  is executed on  and the new local state  from  arrives, after the growing,
\begin{itemize}
    \item[1.] If , then ; else  remains.
    \item[2.] If , then ; else if {\it Lat-Win} can prune, then ; else  remains.
\end{itemize}

\noindent{\it Proof:}

7.1: If , all CGSs in {\it Lat-Win} contain the stale local state. Thus, {\it Lat-Win} prunes to be empty, and .

7.2: If , {\it Lat-Win} prunes to be empty, and ; If  and {\it Lat-Win} can prune, there is at least a CGS containing . Thus, the new . \qed \\

For example, in Fig. \ref{F:example 2}, on the arrival of , {\it Lat-Win} can prune and , then the new  and  is not changed, as shown in Fig. \ref{F:example 3}.

\section{Lat-Win - Online Maintenance Algorithm}
\label{sec:algorithm}

In this section, we present the design of the {\it Lat-Win} maintenance algorithm, based on the theoretical characterization above.  and  serve as two anchors in maintaining {\it Lat-Win}. When a new local state arrives, {\it Lat-Win} grows from  and prunes from . After the growing and pruning,  and  are also updated for further maintenance of {\it Lat-Win}.

 is in charge of collecting and processing the local states sent from non-checker processes. Upon initialization,  gets the window size  and initializes  local windows  over local states from each . Upon receiving a new local state from ,  first enqueues the local state into  and then updates {\it Lat-Win} in the order of growing and pruning. Pseudo codes of the maintenance algorithm are listed in Algorithm 1.

\begin{algorithm}[htbp]
\SetAlgoVlined
\textbf{Upon} Initialization\\
    get window size \;
    initialize window buffers \;
\textbf{Upon} Receiving local state () from \\
    \;
    \If{}
    {
        pop the front continuous local states of  to the end of \;
        trigger \;
    }
    \vspace{0.3cm}
    \\
    \While{}
    {
        pop \;
        push  into  \tcc*[r]{}
         \tcc*[r]{Algorithm 2}
         \tcc*[r]{Algorithm 3}
    }
\caption{{\it Lat-Win} maintenance algorithm\label{A:Checker-Process}}
\end{algorithm}

\subsection{Growing of {\it Lat-Win}}

On the arrival of a new local state, the process of growing consists of three steps. First, it is checked whether {\it Lat-Win} can grow, as discussed in Theorem 4. If yes, {\it Lat-Win} will grow with a set of new CGSs containing the new arrived local state. During the step of growing,  and  are updated too, as discussed in Theorem 5. Pseudo codes of growing are listed in Algorithm 2.

When {\it Lat-Win} is empty, the lattice can grow iff the set  in line 2 contains a CGS, as discussed in Theorem 4.2. If  has a CGS, the  sub-routine will be triggered to add the new CGSs. When {\it Lat-Win} is not empty, the lattice can grow iff  and the next global state satisfy the condition defined in Theorem 4.1, as shown in line 5-8. If the condition is satisfied, the  sub-routine will be triggered to add the new CGSs. The growing of {\it Lat-Win} is achieved by recursively adding all the predecessors and successors of a CGS, as shown in line 10-19. During the growing process,  and  are also updated. Theorem 5 ensures that  can be found in the new added CGSs, and that when {\it Lat-Win} was empty,  can be found in the new added CGSs, as shown in line 12-13.

\begin{algorithm}[htbp]
\SetAlgoVlined
\uIf{{\it Lat-Win} = }
{
     =  = , ,  = ,  is CGS\}\;
    \If{} {
        get a CGS  from ;\hspace{0.05in});

    }
}
\ElseIf{}
{
    combine  and  to get a global state \;
    \If{ is CGS}
    {
        connect  to ;\hspace{0.05in}\;
    }
}
\vspace{0.3cm}
)\\
Set  is CGS, \}\;
Set  is CGS, \}\;
\lIf{}
{
    \;
}
\lIf{}
{
    \;
}
\ForEach{ in }
{
    \If{ does not exist}
    {
        connect  to ;\hspace{0.05in}\;
    }
}
\ForEach{ in }
{
    \If{ does not exist}
    {
        connect  to ;\hspace{0.05in}\;
    }
}
\caption{\label{A:grow_lattice()}}
\end{algorithm}

\subsection{Pruning of {\it Lat-Win}}

Dually, the process of pruning consists of three steps as well. First, it is checked whether {\it Lat-Win} can prune, as discussed in Theorem 6. If yes, {\it Lat-Win} will prune the set of CGSs which contain the stale local state. During the step of pruning,  and  are updated too, as discussed in Theorem 7. Pseudo codes of pruning are listed in Algorithm 3.

The lattice can prune iff the condition in line 1 is satisfied, as discussed in Theorem 6. If  is the stale local state ( in line 2), {\it Lat-Win} will prune to be empty. Otherwise, the CGSs which contain the stale local state will be deleted, as shown in line 5-16. During the pruning process,  is also updated. Theorem 7 ensures that  can be found in the CGSs which contain the new , as shown in line 13-15.

\begin{algorithm}[htbp]
\SetAlgoVlined
\If{{\it Lat-Win}  \&\& }
{
    \eIf{}
    {
        {\it Lat-Win} = , \;
    }
    {
        Set \;
        \While{}
        {
            pop  from \;
            Set  is CGS\}\;
            \ForEach{ in }
            {
                delete the connection between  and \;
                \uIf{ \&\& }
                {
                    add  into \;
                }
                \ElseIf{}
                {
                    Set  is CGS\} \tcc*[r]{without }
                    \lIf{}
                    {
                        \;
                    }
                }
            }
            delete \;
        }
    }
}
\caption{\label{A:prune_lattice(C,k)}}
\end{algorithm}

\subsection{Complexity Analysis}
\label{sec:complexity analysis}

Regarding the space for storing a single CGS as one unit, the worst-case space cost of the original lattice maintenance is , where  is the upper bound of number of events of each non-checker process, and  is the number of non-checker processes. However, the worst-case space cost of sliding windows over the original lattice is bounded by the size  of the windows, that is, , where  is a fixed number and much less than . Due to the incremental nature of Algorithm 2, the space cost of the incremental part of {\it Lat-Win} in each time of growing is .

The worst-case time cost of growing (Algorithm \ref{A:grow_lattice()}) happens when all the global states in the blue rectangle in Fig. \ref{F:design overview 2} are CGSs. Thus, the worst-case time of growing is , where  is the number of the global states in the blue rectangle and  is the time cost of checking whether a global state is consistent.

The worst-case time cost of pruning (Algorithm \ref{A:prune_lattice(C,k)}) happens when all the CGSs in the left shaded rectangle in Fig. \ref{F:design overview 3} should be discarded. Thus, the worst-case time of pruning is , where  is the worst-case number of the CGSs in the left shaded rectangle.

From the performance analysis we can see that, by tuning the sliding window size , the cost of asynchronous event stream processing can be effectively bounded. This justifies the adoption of sliding windows when only recent part of the event streams are needed by the tracking/monitoring application, and the application needs to strictly bound the cost of event processing.

\section{Experimental Evaluation}
\label{sec:evaluation}

In this section, we further investigate the performance of {\it Lat-Win} via a case study. We first describe a smart office scenario to demonstrate how our approach supports context-awareness in asynchronous pervasive computing scenarios. Then, we describe the experiment design. Finally, we discuss the evaluation results.

\subsection{Achieving Context-awareness by On-line Processing of Asynchronous Event Streams}

We simulate a smart office scenario, where a context-aware application on Bob's mobile phone automatically turns the phone to silent mode when Bob attends a lecture\cite{Huang11}.

The application detects that Bob attends a lecture by specification of the concurrency property: : {\it location of Bob is the meeting room, a speaker is in the room, and a presentation is going on} \cite{Huang11}. The application needs to turn the phone to silent mode when the property definitely holds. Formally, , which is explained in detail below.

The location context is detected by Bob's smart phone. When the phone connects to the access point in the meeting room, we assume that Bob is in this room. Specifically, non-checker process  is deployed on Bob's smart phone, which updates the phone's connection to access points. Local predicate  = {\it``the user's smart phone connects to the AP inside the meeting room''} is specified over .

An RFID reader is deployed in the room to detect the speaker. Specifically, non-checker process  is deployed on the RFID reader, and local predicate  = {\it``the RFID reader detects a speaker''} is specified over .

We detect that a presentation is going on if the projector is working. Specifically, non-checker process  is deployed over the projector, and local predicate  = {\it``the projector is on''} is specified over .

Observe that the mobile phone, the RFID reader, and the projector do not necessarily have synchronized clocks, and Bob may not be willing to synchronize his mobile with other devices due to privacy concerns. They suffer from message delay of wireless communications. Furthermore, the recent data is more informative and useful to the context-aware application than stale data, thus the sliding window can be imposed over the streams of context.

Non-checker processes produce event streams and communications among them help establish the happen-before relation among events. A checker process  is deployed on the context-aware middleware to collect local states with logical clock timestamps from non-checker processes, and maintain {\it Lat-Win} at runtime. Based on {\it Lat-Win},  can further detect the concurrency property  \cite{Huang11} and notify the mobile phone to turn to silent mode.

The detection of concurrency properties assumes the availability of an underlying context-aware middleware. We have implemented the middleware based on one of our research projects - {\it Middleware Infrastructure for Predicate detection in Asynchronous environments} (MIPA) \cite{MIPA, Huang10b, Huang11}.

\subsection{Experiment Design}

The user's and speaker's stay inside and outside of the meeting room, as well as the working period of the projector are generated following the Poisson process. Specifically, the sensors collect context data every 1 min. We model the message delay by exponential distribution. The average duration of local contextual activities is 25 mins and the interval between contextual activities is 5 mins. Lifetime of the experiment is up to 100 hours.

In the experiments, we first study the benefits of imposing sliding window over asynchronous event streams in the percentage of detection  and the percentage of space cost .  is defined as the ratio of . Here,  denotes the number of times the algorithm detects the specified property on {\it Lat-Win}.  denotes the number of times the algorithm detects the specified property on the original lattice {\it LAT}.  is defined as the ratio of . Here,  denotes the average size of {\it Lat-Win} as the window slides.  denotes the size of the original lattice over the lifetime of the experiment.

Then, we study the performance of {\it Lat-Win} in the probability of detection , the space cost  and time cost . Here,  is defined as the ratio of .  is defined above and  denotes the number of times such property holds in the window when global time is available.  is defined above and  denotes the average time from the instant when  is triggered to that when the detection finishes.

\subsection{Evaluation Results}

In this section, we first discuss the benefits of imposing sliding window over asynchronous event streams. Then we discuss the performance of the {\it Lat-Win} maintenance algorithm.

\subsubsection{Benefits of Sliding Window}

In this experiment, we investigate the impact of window size  on the percentage of detection  and the percentage of space cost . We fix the average message delay to 0.5 s.

The experiment shows that the sliding window enables the trade-off between  and . As shown in Fig. \ref{F:trade-off}, the increase of  results in monotonic increase in both  and . When we tune  from 1 to 4,  (the upper blue line) increases quickly up to 97.11\%. When we tune  from 4 to 10,  increases slowly and remains quite high towards 100\%.  (the lower green line) increases almost linearly as  increases. When we set  to 10,  remains small than 1\%. We can find that, rather than maintaining the whole original lattice, imposing a quite small sliding window over asynchronous event streams can keep  high and  quite small. It indicates that recent data is more relevant and important to the application. When the window size is 4, the relative growth rate between  and  slows down, and  is quite high,  is 27.23.  Thus, in the following experiments, we set the window size  as 4 to study the performance of {\it Lat-Win}. (Notice that in different scenarios, the turning point of  may be different.)

\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=3.5in]{Figs/LatWinvsLAT.pdf}\\
  \centering\parbox[c]{2.5in}{\caption{Benefits of sliding window.}}
  \label{F:trade-off}
\end{center}
\end{figure}

\subsubsection{Performance of {\it Lat-Win}}

In this experiment, we investigate the performance of {\it Lat-Win} in the probability of detection , the average space cost , and the average time cost . We first vary the asynchrony, i.e., the message delay. We also vary the window size . Finally, we vary the number of non-checker processes .

\paragraph{Effects of Tuning the Message Delay}

In this experiment, we study how the message delay affects the performance of {\it Lat-Win}. We fix the window size  to 4. We find that when encountered with reasonably long message delay (less than 5 s),  (the upper blue line) decreases slowly and remains over 85\%, as shown in Fig. \ref{F:message-delay}. When we tune the average message delay from 0 s to 5 s,  increases slowly to about 30, whereas the worst-case cost is , as discussed in Section \ref{sec:complexity analysis}. The decrease of  and the increase of  are mainly due to the increase of the uncertainty caused by the asynchrony (i.e., the message delay).  is smaller than , because the detection algorithm may detect the property to be true but in physical world the property is not satisfied due to the increasing uncertainty caused by the asynchrony. Furthermore, the increase of message delay results in a slow increase in , which remains less than 1 ms.

\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=3.5in]{Figs/tuningMessageDelay.pdf}\\
  \centering\parbox[c]{2.5in}{\caption{Tuning the message delay.}}
  \label{F:message-delay}
\end{center}
\end{figure}

\paragraph{Effects of Tuning Size of the Sliding Window}

In this experiment, we study how the window size affects the performance of {\it Lat-Win}. We fix the message delay to 0.5 s. As shown in Fig. \ref{F:window-size}, the increase of window size  results in monotonic increase in both  and . When we tune  from 2 to 5,  (the upper blue line) increases quickly up to 99\%. The increase is mainly because that as  increases, the window has more information and thus can detect the property more accurately.  (the black bars) increases slowly as  increases, and is much smaller than the worst-case cost. Thus, imposing the sliding window over asynchronous event streams can achieve high accuracy while saving a large amount of space cost. Furthermore, the increase of window size results in a slow increase in , which remains less than 1 ms.

\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=3.5in]{Figs/tuningWindowSize.pdf}\\
  \centering\parbox[c]{3in}{\caption{Tuning size of the sliding window.}}
  \label{F:window-size}
\end{center}
\end{figure}

\paragraph{Effects of Tuning the Number of Non-checker Processes}

In this experiment, we study how the number of non-checker processes  affects the performance of {\it Lat-Win}. We fix the average message delay to 0.5 s and the window size  to 4. We tune  from 2 to 9. As shown in Fig. \ref{F:number-of-NPs},  decreases linearly as  increases. When  increases from 2 to 9,  decreases about 20\%. The decrease is mainly because the asynchrony among non-checker processes accumulates as  increases.  increases exponentially as  increases. However, as  increases, the space cost of {\it Lat-Win} is much less than the worst-case (less than 1\%), and even less than that of the original lattice.  and  are also shown in Table. \ref{T:cost of sliding window}. We find that  is approximately in , which is in accordance with the analysis in Section \ref{sec:complexity analysis}, where  is a parameter associated with the asynchrony. In this experiment setting,  is around 0.75.  also increases exponentially as  increases.

\begin{figure}[htbp]
\begin{center}
  \includegraphics[width=3.5in]{Figs/tuningNumberOfNPs.pdf}\\
  \centering\parbox[c]{3.9in}{\caption{Tuning the number of non-checker processes.}}
  \label{F:number-of-NPs}
\end{center}
\end{figure}

\begin{table}[htbp]
\caption{Cost of Sliding Window When Tuning the Number of Non-checker Processes}
\label{T:cost of sliding window} \centering
\begin{tabular}{c|c|c|c|c|c|c|c|c}
\hline
Number of NPs () & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
\hline
 & 9 & 25 & 78 & 221 & 768 & 2691 & 9799 & 34408 \\
\hline
 & 0.5 & 0.6 & 2.0 & 7.5 & 36 & 184 & 1616 & 14766 \\
\hline
\end{tabular}
\end{table}

\section{Related Work}
\label{sec:related-work}

The lattice of global snapshots is a key notion in modeling behavior of asynchronous systems \cite{Schwarz94, Babaoglu96, Babaoglu95, Cooper91, Hua10, Huang09, Huang10a, Huang11, Mittal07, Sen07}, and is widely used in areas such as distributed program debugging \cite{Garg94, Garg96} and fault-tolerance \cite{Mittal05}. One critical challenge is that the lattice of snapshots evolves to exponential size in the worst-case. Various schemes are used to cope with the lattice explosion problem \cite{Mittal07, Sen07, Dumais02, Jard94, Chen11}. For example, in \cite{Mittal07, Sen07}, the authors proposed the computation slice to efficiently compute all global states which satisfy a regular predicate\cite{Mittal07}. In \cite{Jard94}, the authors discussed that certain (useless) part of the lattice can be removed at runtime to reduce the size of lattice. In this work, we make use of the observation that, in many tracking/monitoring applications, it is often prohibitive and, more importantly, unnecessary to process the entire streams. Thus, we use sliding windows over distributed event streams to reduce the size of the lattice.

Sliding windows are widely used in event stream processing \cite{Babcock02, Braverman11, Datar02, Tirthapura06}. Existing sliding windows are mainly designed over a single stream. However, it is not sufficiently discussed concerning the coordination of multiple (correlated) sliding windows over asynchronous event streams. We argue that the coordination of multiple windows is crucial to explicitly model and handle the asynchrony. In this work, to cope with the asynchrony among multiple event sources, we maintain a sliding window over each event stream. We consider the Cartesian product as an -dimensional sliding window. Then we study the lattice of global snapshots of asynchronous event streams within the window.

\section{Conclusion and Future Work}
\label{sec:conclusion}

In this work, we study the processing of asynchronous event streams within sliding windows. We first characterize the lattice structure of event stream snapshots within the sliding window. Then we propose an online algorithm to maintain {\it Lat-Win} at runtime. The {\it Lat-Win} is implemented and evaluated over MIPA.

In our future work, we will study how to make use of the partial asynchrony among event streams, to further improve the cost-effectiveness of event stream processing. We will also study the approximate/probabilistic detection of specified predicates over asynchronous event streams.

\section*{Acknowledgements}

This work is supported by the National Natural Science Foundation of China (No. 60903024, 61021062) and the National 973 Program of China (2009CB320702).

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,TR110211}

\end{document} 