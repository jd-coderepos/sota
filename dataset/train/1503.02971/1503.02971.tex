\documentclass{llncs}

\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\sat}{\vDash}
\newcommand{\unsat}{\not \vDash}
\newcommand{\imp}{\rightarrow}
\newcommand{\R}[1]{\mu^{-1}_{#1}}
\newcommand{\Proj}[1]{\mu_{#1}}
\newcommand{\skt}{\text{skt}}
\newcommand{\apr}{ \Rightarrow_{APR}}
\newcommand{\I}[1]{\mathcal{I}_{#1}}
\newcommand{\G}[1]{\mathcal{G}_\Sigma(#1)}
\newcommand{\ceil}[1]{\left \lceil{#1}\right \rceil}                                                                                                                                                                                                                                                                            
\newtheorem{defin}{Definition}
\newtheorem{lem}[theorem]{Lemma}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{exmp}{Example}
\newcommand{\vars}{\operatorname{vars}}
\newcommand{\shortrules}[6]{\noindent\begin{minipage}{#6ex}{\bfseries #1}\end{minipage}  #2  #3 \par\smallskip\noindent #4} 

\title{First-Order Logic Theorem Proving and Model Building via Approximation and Instantiation}
\author{Andreas Teucke\inst{1,2} \and Christoph Weidenbach\inst{1}}

\institute{Max-Planck Institut for Informatics, Campus E1 4
66123 Saarbr\"ucken
Germany \and Graduate School of Computer Science, Saarbr\"ucken, Germany
}


\date{}

\pdfinfo{/Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\pagenumbering{arabic} 

\begin{document}
\pagestyle{plain}
\maketitle

\begin{abstract}
In this paper we consider first-order logic theorem proving and model
building via approximation and instantiation. 
Given a clause set we propose its approximation into a simplified clause set where
satisfiability is decidable. The approximation extends the signature
and  preserves unsatisfiability: if the simplified clause set is satisfiable in some model, 
so is the original clause set in the same model interpreted in the original signature. 
A refutation generated by a decision procedure on the simplified clause set can 
then either be lifted to a refutation in 
the original clause set, or it guides 
a refinement excluding the previously found unliftable refutation. 
This way the approach is refutationally complete. We do not step-wise lift refutations
but conflicting cores, finite unsatisfiable clause sets representing at least one refutation.
The approach is dual to many
existing approaches in the literature because our approximation preserves unsatisfiability.
\end{abstract}


\section{Introduction} \label{sec:intro}

The Inst-Gen calculus by Ganzinger and Korovin~\cite{DBLP:conf/birthday/Korovin13} and its
implementation in iProver has shown to be very successfull. The calculus is based on a
under-approximation - instantiation refinement loop. A given first-order clause set is under-approximated
by finite grounding and afterwards a SAT-solver is used to test unsatisfiability. If the
ground clause set is unsatisfiable then a refutation for the original clause set is found.
If it is satisfiable, the model generated by the SAT-solver is typically not a model for
the original clause set. If it is not, it is used to instantiate the
original clause such that the found model is ruled out for the future.

In this paper we define a calculus that is dual to the Inst-Gen calculus.
A given first-order clause set is over-approximated into a decidable fragment
of first-order logic: a monadic, shallow, linear Horn (mslH) theory~\cite{Weidenbach99cade}.
If the over-approximated clause set is satisfiable, so is the original clause set.
If it is unsatisfiable, the found refutation is typically not a refutation for
the original clause set. If it is not, the refutation is analyzed to instantiate
the original clause set such that the found refutation is ruled out for the future.
The mslH fragment properly include first-order ground logic, but is also expressive
enough to represent minimal infinite models.

In addition to developing a new proof method for first-order logic this constitutes our second motivation
for studying the new calculus and the particular mslH approximation. It is meanwhile accepted that
a model-based guidence can significantly improve an automated reasoning calculus. The propositional
CDCL calculus~\cite{NieuwenhuisEtAl06} 
is one prominent example for this insight. In first-order logic, (partial) model operators
typically generate inductive models for which almost all interesting properties become undecidable,
in general. One way out of this problem is to generate a model for an approximated clause set, such
that important properties with respect to the original clause set are preserved. In the case of our calculus and approximation, a found model
can be effectively translated into a model for the original clause set. So our result is also a first
step towards model-based guidence in first-order logic automated reasoning.

For example, consider the first-order Horn clauses 
; ; ; ; ; 
that are approximated (Section~\ref{sec:abstr}) into the mslH theory
; ; ; ; ; ; 
where the relation  is encoded by the function  and the non-linear occurrence of  in the first
clause is approximated by the introduction of the additional variable . The approximated clause set
has two refutations: one using  and the second using  plus
the rest of the clauses, respectively. While the first refutation cannot be lifted, the second one is liftable to 
a refutation of the original clause set (Section~\ref{sec:lifting}). Actually, we do not consider refutations, but conflicting cores (Definition~\ref{conlfictCore}).
Conflicting cores are finite, unsatisfiable clause sets where variables are considered to be shared among clauses and rigid such that
any instantiation preserves unsatisfiability. Conflicting cores can be effectively generated out of refutations via instantiation
of (copies of) the input clauses involved in the refutation.
For the above second refutation the conflicting core of the approximated clause set is
; ; ; .\newline
In case the first refutation is selected for lifting, it fails, so the original clause set is refined (Section~\ref{abstrref}). The refinement
replaces the first clause with\newline
;  and .\newline
The approximation of the resulting new clause set does no longer enable a refutation using . Therefore, the refutation using  is found after refinement.
In case the original clause set contains a non-Horn clause, one positive literal is selected by the approximation.

The paper is now organized as follows. Section~\ref{sec:abstr} introduces some basic notions and the approximation relation 
that transforms any first-order clause set into an mslH theory.
The lifting of conflicting cores is described in Section~\ref{sec:lifting} and the respective abstraction refinement
in Section~\ref{abstrref} including soundness and completeness results. Missing proofs can be found in the appendix.
The paper ends with Section~\ref{sec:furewo} on future/related work and a conclusion.

  
\section{Linear Shallow Monadic Horn Approximation} \label{sec:abstr}

We consider a standard first-order language without equality where  
denotes the set of function symbols.
The symbols  denote variables,  constants, 
 are functions and  terms. 
Predicates are denoted by , literals by , clauses by , and sets of clauses by  .
The term  denotes that the term  has the subterm  at position . 
The notion is extended to atoms, clauses, and multiple positions.
A predicate with at most one argument is called monadic.
A literal is either an atom or an atom preceded by  and it is then respectively  called positive or negative.
A term is shallow if it has at most depth one. 
It is called linear if there are no duplicate variable occurrences. 
A literal, where every term is shallow, is also called shallow. 
A clause is a multiset of literals which we write as an implication  where the atoms in  denote the positive literals
and the atoms in  the negative literals.
If  is empty we omit , e.g., we write  instead of  whereas if
 is empty  is always shown.
If a clause has at most one positive literal, it is a Horn clause.
If there are no variables, then terms, atoms and clauses are respectively called ground.
A substitution  is a mapping from variables into terms denoted by pairs .
If for some term (literal, clause) ,  is ground, then  is a grounding substitution.


A Herbrand interpretation  is a - possibly infinite - set of positive ground literals and  is said to satisfy a 
clause , denoted by , if   or  for every grounding substitution .
An interpretation  is called a model of  if  satisfies , , i.e., 
 for every . Models are considered \emph{minimal} with respect to set inclusion.
A set of clauses  is satisfiable, if there exists a model that satisfies . Otherwise the set is unsatisfiable.

\begin{defin}[Conflicting Core]\label{conlfictCore}
A finite clause set  is a conflicting core if for all grounding substitutions  the clause set  is unsatisfiable. 
 is a conflicting core of  if  is a conflicting core 
and for every clause  there exists a  such that .
\end{defin}

\begin{defin}[Specific Instances]\label{specInst}
Let  be a clause and ,  be two substitutions
such that  and  have no common instances.
Then the \emph{specific instances} of  with
respect to ,  are clauses  such that
(i)~any ground instance of  is an instance of some ,
(ii)~there is no  such that both  and  are 
instances of .
\end{defin}

The definition of specific instances can be extended to a single substitution .
In this case we require  and  to be linear,
condition~(i) from Definition~\ref{specInst} above,  and no , 
 has a common instance with .
Note that under the above restrictions specific instances always exist~\cite{Lassez:1987:ERT:33031.33036}.

\begin{defin}[Approximation]
Given a clause set  and a relation  on clause sets with  then
(1)~ is called an \emph{over-approximation}  if satisfiability of  implies satisfiability of ,
(2)~ is called an \emph{under-approximation} if unsatisfiability of  implies unsatisfiability of .
\end{defin}


Next we introduce our concrete over-approximation  that 
eventually maps a clause set  to an mslH
clause set . Starting from a clause set  the transformation is parameterized
by a single monadic projection predicate , fresh to 
and for each non-monadic predicate  a projection function  fresh to . The approximation
always applies to a single clause and we establish on the fly an ancestor relation between 
the approximated clause(s) and the parent clause. The ancestor relation is needed for lifting and refinement.

\bigskip
\shortrules{Monadic}{}{}{provided ;  is the ancestor of }{MO}{10}

\bigskip
\shortrules{Horn}{}{}{provided ;  is the ancestor of }{HO}{10}

\bigskip
\shortrules{Shallow}{}{}{provided  is a complex term,  not a top position,  and  fresh, 
and ;  is the ancestor of  and }{SH}{10}

\bigskip
\shortrules{Linear}{}{}{provided  is fresh, the positions ,  denote
two different occurrences of  in ;  is the ancestor of }{LI}{10}


\bigskip
For the Horn transformation, the choice of the  is arbitrary.
In the Shallow rule,  and  can be arbitrarily chosen as long as they ``add up'' to .
The goal, however, is to minimize the set of common variables 
.
If this set is empty the Shallow transformation is satisfiability preserving.
In rule Linear, the duplication of  is not needed if .


\begin{defin}[] \label{def:approx:trans}
The overall approximation  is given by 
with a preference on the different rules where  Monadic precede Horn precede Shallow precede Linear transformations.\\
\end{defin}


\begin{defin}
Given a non-monadic n-ary predicate , projection predicate , and projection function ,
define the injective function 
and  for any atom with a predicate symbol different from .
The function is extended to clauses, clause sets and interpretations.
\end{defin}


\begin{lem}[ is sound and terminating]\label{Apr_sound}
The approximation rules are sound and terminating:
(i)~  terminates
(ii)~the Monadic transformation is an over-approximation
(iii)~the Horn transformation is an over-approximation
(iv)~the Shallow transformation is an over-approximation
(v)~the Linear transformation is an over-approximation
\end{lem}
\begin{proof}
(i)~The transformations can be considered sequentially, because of the imposed rule preference (Definition~\ref{def:approx:trans}). 
The monadic transformation strictly reduces the number of non-monadic atoms.
The Horn transformation strictly reduces the number of non-Horn clauses.
The Shallow transformation strictly reduces the multiset of term depths of the newly introduced clauses compared
to the removed ancestor clause.
The linear transformation strictly reduces the number of duplicate variables occurrences in positive literals. 
Hence   terminates.

(ii) Consider a transformation  that exactly removes all occurrences of atoms  and
replaces those by atoms .
Then,  and .
Let  be a model of  and .  
Since  ,  and thus, .
Hence,  is a  model of .
Therefore, the Monadic transformation is an over-approximation.

(iii) Let .
The clause  subsumes the clause . Therefore, for any 
if   then .
Therefore, the Horn transformation is an over-approximation.

(iv) Let .
Let  be a model of  and  be a ground clause. 
If  is an instance of a clause in , then .
Otherwise  for some ground substitution .
Then  
and .
Since ,  also satisfies the resolvent . 
Hence .
Therefore, the Shallow transformation is an over-approximation.

(v)  Let .
Let  be a model of  and  be a ground clause. 
If  is an instance of a clause in , then .
Otherwise  for some ground substitution .
Then  and
.
Hence .
Therefore, Linear transformation is an over-approximation.
\end{proof}


\begin{cor}
(i)~ is an over-approximation.
(ii)~If ,  are the non-monadic predicates in  and  is satisfied by model , \\
then    is a model of .
\end{cor}
\begin{proof}
Follows from Lemma~\ref{Apr_sound} (ii)-(v).
\end{proof}

In addition to being an over-approximation, the minimal model (with respect to set inclusion)
 of the eventual approximation
generated by   preserves the skeleton term structure
of the original clause set, if it exists. The refinement introduced in Section~\ref{abstrref}
instantiates clauses. Thus it contributes to finding a model or a refutation.

\begin{defin}[Term Skeleton]\label{termSkel}
The term skeleton of term  , , is defined as \\
(1) , where  is a fresh variable \\
(2) . 
\end{defin}


\begin{lem}\label{termSkelLem2}
Let  be a monadic clause set and  be its approximation via  . 
Let  be satisfiable and  be a minimal model for .
If   and  is a predicate in , then there exists a clause 
 and a substitution  such that
 and for each variable  and predicate  with , , where .
\end{lem}

\begin{proof}
By induction on .\\
For the base , assume there is no  with  and .
Then  is still a model of  and therefore  is not minimal.\\
Let  ,  and  is a predicate in  and hence also in . 
By the induction hypothesis, there exist a clause  and a substitution  such that
 and for each variable  and predicate  with , , where .
The first approximation rule application is either a Linear, a Shallow or a Horn transformation,
considered below by case analysis.

Horn Case. Let  be a Horn transformation that replaces  with .
If , then  fulfills the claim.
Otherwise,  fulfills the claim since  and .

Linear Case. Let  be a linear transformation that replaces  with .
If , then  fulfills the claim.
Otherwise,  fulfills the claim since  and .

Shallow Case. Let  be a shallow transformation that replaces  with  and .
Since  is fresh, .
If , then  fulfills the claim.
Otherwise,  and hence,  and  for .
Then by the induction hypothesis, there exist a clause  and a substitution  such that
 and for each variable  and predicate  with , , where .
By construction, . 
Thus,   and  imply there exists a  such that .
Furthermore since , if , then 
either  and thus  , where , or 
 and thus  , where .
Hence,   fulfills the claim.
\end{proof}


\begin{lem}\label{termSkelLem}
Let  be a clause set and  be its approximation via  . Let  be
satisfiable and  be a minimal model for .
If   
and  is a predicate in , then there exist a clause 
  ()
and a substitution  such that
 ( for all ).
\end{lem}


\begin{proof}
Let  be the non-monadic predicates in  and . Then,  is monadic and also has  as its approximation via .

 Let  and  is a predicate in . Since  is monadic,  is a predicate in .
Hence by Lemma ~\ref{termSkelLem2}, there exists a clause  
and a substitution  such that . 
Then,  fulfills the claim.

Let  and  is a predicate in .  is monadic and a predicate in .
Hence by Lemma ~\ref{termSkelLem2}, there exists a clause  
and a substitution  such that .
Therefore,  with   for all .
Then,  fulfills the claim.
\end{proof}

The above lemma also holds if satisfiability of  is dropped and  is replaced
by the superposition partial minimal model operator~\cite{Weidenbach01handbook}.


\section{Lifting the Conflicting Core} \label{sec:lifting}

Given a monadic, linear, shallow, Horn approximation  of  
and a conflicting core  of , using the transformations
provided in this section we attempt to lift  to a conflicting
core  of .
In case of success this shows the unsatisfiability of .
In case an approximation step cannot be lifted the original clause
set is refined by instantiation, explained in the next section.

Let  be an unsatisfiable monadic, linear, shallow, Horn approximation. 
Since  belongs to a decidable first-order fragment,
we expect an appropriate decision procedure to generate a proof of unsatisfiability for , 
e.g., ordered resolution with selection \cite{Weidenbach99cade}.
A conflicting core can be straightforwardly generated out of a resolution refutation 
by applying the substitutions of the proof to the used input clauses.

Starting with a resolution refutation, in order to construct the conflicting core, 
we begin with the singleton set containing the pair of empty clause and the empty substitution.
Furthermore, we assume that all input clauses from  used in the refutation are
variable disjoint. 
Then we recursively choose a pair  from the set where .
There exists a step in the refutation that generated this clause. 
In the case of a resolution inference, there are two parent 
clauses  and  in the refutation and two substitutions  and 
such that  is the resolvent of  and .
In the case of a factoring inference, there is one parent 
clause  in the refutation and a substitution 
such that  is the factor of .  
Replace   by  and  or 
by  respectively.
The procedure terminates in linear time in the size of the refutation.
For each pair , collect the clause , resulting
in a conflicting core  of .

\begin{exmp}\label{coreex}
Let   with signature . 
 is unsatisfiable and  a possible resolution refutation is resolving  
and  with . From this we get the conflicting core \\
.

An alternative refutation is to resolve   and  with 
substitution  
and then the resolvent and  with substitution . 
From this refutation we construct the conflicting core  
  .

\end{exmp} 

Note that in Example \ref{coreex}   is more general than  since .
A conflicting core is minimal in that it represents the most general clauses corresponding to the refutation from that it is generated.

\subsubsection{Lifting the Monadic Transformation.}
Since the Monadic transformation is satisfiability preserving, lifting always succeeds by replacing any  atoms in the core  by .

\begin{exmp}\label{LiftMonadicEx}
Let  . 
Then   is a Monadic transformation of 
and a conflicting core is   .
Reverting the atoms in   gives    a conflicting core of .
\end{exmp} 


\begin{lem}[Lifting the Monadic Transformation]\label{liftmonadic}
Let  be the transformation  that exactly removes all occurrences of atoms  and replaces those by atoms .
If  is a conflicting core for  then there is a conflicting core  of .
\end{lem}

\begin{proof}
Since the Monadic transformation is satisfiability preserving, unsatisfiability of  directly implies unsatisfiability of  and the existence of a conflicting core of .
\end{proof}

\subsubsection{Lifting the Horn Transformation.}
For a Horn transformation there are two ways for lifting.
The first, directly lifting the core, only succeeds in special cases, where the original clause and its approximation are  equivalent 
for the instantiations appearing in the core.

\begin{exmp}\label{LiftHornEx}
Let  . 
Then   is a Horn transformation of 
and a conflicting core is  .
By substituting  with ,   lifts to   a conflicting core of .
\end{exmp} 

\begin{lem}[Lifting the Horn Transformation (direct)]\label{lifthorn1}
Let  where 
 and .
Let  be a conflicting core of .
If for all ,  there is a 
substitution  such that
,
such that  and 

is a conflicting core, then
 is
a conflicting core of .
\end{lem}

\begin{proof}
Let   be a grounding substitution for  and . 
Since ,
.
Hence,  is unsatisfiable because  is unsatisfiable.
Therefore,  is an conflicting core of .
\end{proof}


Of course, the condition  itself is undecidable, in general. The above lemma is meant to be a justification for
the cases where this relation can be decided, e.g, by reduction. In general, the next lemma applies.
We assume any non-Horn clauses have exactly two positive literals. 
Otherwise, we would have first redefined pairs of positive literals using fresh predicates. 
Further assume w.l.o.g. that Horn transformation always chooses the first positive Literal of a non-Horn clause.

The indirect method uses the information from the conflicting core to replace the non-Horn clause with a satisfiable equivalent unit clause,
which is then  solved recursively. Since this unit clause is already Horn, we lifted
one Horn approximation step.

\begin{exmp}
Let . 
The Horn transformation  has a conflicting core 
.
 abstracts a resolution refutation with  as the result.
If we replace   with  in such a refutation,  the result will be  instead and hence  
Since  subsumes , \\  is satisfiable if  is too.
\end{exmp} 


\begin{lem}[Lifting the Horn Transformation (indirect)]\label{lifthorn2}
Let  be a set of variable disjoint clauses, 
,
 and  and
 be a conflicting core of  where Lemma~\ref{lifthorn1} does not apply.
Let  , where  is a variable renaming and
 for any , and . 
If there exists a conflicting core  of , then a  conflicting core of  exists.
\end{lem}

\begin{proof}
From the conflicting core , we can conclude that there exists an unsatisfiability proof of  which derives  and uses   as the only instance of . If we were to replace  by  , the unsatisfiability proof's root clause would instead be .
Hence, we know that . 
Furthermore,  since  subsumes .

Let  for  and 
Then   is a conflict core of  .
\end{proof}

Note that  now again contains the Non-Horn clause . 
Then, in a following indirect Horn lifting step  can not necessarily be again replaced by  .
Hence, the indirect Horn lifting needs to be repeated.

\subsubsection{Lifting the Shallow Transformation.}
A Shallow transformation introduces a new predicate , which is removed in the lifting step.
We take all clauses with -atoms in the conflicting core and generate any 
possible resolutions on -atoms. 
The resolvents, which don't contain -atoms anymore, then replace their parent clauses in the core.
Lifting succeeds if all introduced resolvents are instances of clauses before the shallow
transformation.


\begin{exmp}\label{LiftShallowEx}
Let .
Then   is a Shallow transformation of 
and  a conflicting core is  .
By replacing \\
 and  with the resolvent,  lifts to  a conflicting core of .
\end{exmp} 

\begin{lem}[Lifting the Shallow Transformation]\label{liftshallow}
Let  where  and .
Let  be a conflicting core of . 
Let  be the set of all resolvents from  clauses from  on the  literal.
If for all clauses ,  there is a substitution  such that  then
 is a conflicting core of .
\end{lem}

\begin{proof}
Let   be a grounding substitution for  and  and  be an interpretation. 
As   is unsatisfiable, there is a clause  such that . \\
If  does not contain an -atom, then  and hence .\\
Now assume only clauses that contain -atoms are false under . 
By construction, any such clause is equal to either   or  for some substitution .
Let  , i.e.,
we change the truth value for -Literals such that the clauses unsatisfied under  are satisfied under .\\
Since   and  only differ on literals with predicate  and  is unsatisfiable, some clause , containing an -atom and satisfied under , has to be false under .\\
Let . Since ,  was added to  by some clause , where .
Hence,  and  can be resolved on their -literals and the resolvent  is in .
Since ,  and  contains no -atom,  and therefore .\\
For  the proof is analogous.\\
Thus, for all interpretations  and grounding substitutions ,  and hence  is a conflicting core of .
 \end{proof}

\subsubsection{Lifting the Linear Transformation.}
In order to lift a Linear transformation the remaining and the newly introduced variable  
need to be instantiated the same term. 

\begin{exmp}\label{liftLinEx}
Let  . 
Then   is a Linear transformation of  and
and     is a conflicting core of .
Since  and  are instances of  lifting succeeds and  is also a core of .
\end{exmp} 

\begin{lem}[Lifting the Linear Transformation]\label{liftlin}
Let  where  and .
Let  be a conflicting core of .
If for all ,  we have  then
 is a conflicting core of .
\end{lem}

\begin{proof}
Let  be a grounding substitution for  and . 
As  for , .
Hence, .
Since  is unsatisfiable  is unsatisfiable as well.
Therefore,   is a conflicting core of .
\end{proof}

\subsubsection{Lifting with Instantiation.}
By definition, if  is a conflicting core of , then  is also a conflicting core of  for any . 
Example \ref{liftex} shows it is sometimes possible to instantiate a conflicting core, where no lifting lemma applies, into a core, where one does.
This then still implies a successful lifting.

\begin{exmp}\label{liftex}
Let  . 
Then   is a Linear transformation of  and
and     is a conflicting core of .
Since for   Lemma \ref{liftlin} is not applicable.

However,  Lemma \ref{liftlin} can be applied on   .
\end{exmp} 



\section{Approximation Refinement}\label{abstrref}

In the previous section, we have presented the lifting process.
If, however, in one of the lifting steps  conditions of the lemma are not met, lifting fails and 
we now refine the original clause set in order to rule out the non-liftable conflicting core.
Again, since lifting fails at one of the approximation steps, we consider the different
approximation steps for refinement.


\subsubsection{Linear Approximation Refinement.}
A Linear transformation
enables further instantiations of the abstracted clause compared to the original, 
that is, two variables that were the same can now be instantiated differently. 
If the conflicting core of the approximation contains such instances the lifting fails.

\begin{defin}[Linear Approximation Refinement]
Let  be a set of variable disjoint clauses, 
 and
 be a conflicting core of  where Lemma~\ref{liftlin} does not apply.
Let 
 such that  and  have no common instances. 
Let  be the Ancestor of .
Then the \emph{linear approximation refinement} of , , , ,  is the clause
set  where the  are the specific
instances of  with respect to the substitutions  and
.
\end{defin}

Note that if there is no , where  and  have no common instances, 
it implies that there is a substitution 
where Lemma~\ref{liftlin} applies on . Hence,  is a liftable
conflicting core.

Let 
and the core  of  contains the clause , where  and  have no common instances.
After applying Linear Approximation Refinement, there are  and  with  such that   contains all instances where 
and  contains all instances where . 
Assume there is a  with an ancestor  such that  is an instance of .
This would imply that  has instances, where  and .
Then , which is a contradiction to Definition \ref{specInst}. 


\begin{exmp}\label{LinAbsEx}
Let  . 
Then   is a Linear transformation of  and
and    is a conflicting core of .\\
Due to  lifting fails.
The Linear Approximation Refinement replaces  in  with  and .
In the refined approximation  
the violating clause  is not an instance of  and hence, the not-liftable conflicting core  cannot be found again.
\end{exmp} 

\subsubsection{Shallow Approximation Refinement.}
The Shallow transformation is somewhat more complex than linear transformation, 
but the idea behind it is very similar to the linear case.
As mentioned before, the Shallow transformation can always be lifted 
if the set of common variables
 is empty. 
Otherwise, each such variable potentially 
introduces instantiations that are not liftable.

\begin{defin}[Shallow Approximation Refinement]
Let  be a set of variable disjoint clauses, 
 and
 be a conflicting core of  where Lemma~\ref{liftshallow} does not apply.
Let  be the resolvent from the final Shallow rule application such that  for any . 
Let  and  be the parent clauses of .
Let , where  and  have no common instances. 
Let  be the Ancestor of .
Then the \emph{shallow approximation refinement} of , , , ,  is the clause
set  where the  are the specific
instances of  with respect to the substitutions  and
.
\end{defin}

As in Linear Approximation Refinement, if for every resolvent    and  have common instances, it implies that there is a substitution 
where Lemma~\ref{liftshallow} applies on .
After applying Shallow Approximation Refinement, there are  and  with  such that   contains all instances where 
and  contains all instances where . 
Hence,  is now the ancestor of , while  is the ancestor of .
Since they have different ancestors, they can no longer be resolved on their -atoms which now have different predicates.
Hence  is no longer a resolvent in the conflicting  core.  


\begin{exmp}
Let  with signature   .
Then   is a Shallow transformation of  and
and   is a conflicting core of .\\
The clauses  and  have the resolvent , which is not an instance of  .
The Shallow Approximation Refinement replaces  in  with , ,\\  and .\\
The approximation of the refined  is now satisfiable. 
\end{exmp}

\subsubsection{Horn Approximation Refinement.}
Lifting a core of a Horn transformation fails, if  the positive literals removed by 
the Horn transformation are not dealt with in the approximated proof.
Since Lemma \ref{lifthorn2} only handles cases where the approximated clause appears uninstantiated in the conflicting core,
the Horn Approximation Refinement is used to ensure such a core exists. 

\begin{defin}[Horn Approximation Refinement]
Let  be a set of variable disjoint clauses, 
,
 and  and
 be a conflicting core of  where Lemmas ~\ref{lifthorn1} and ~\ref{lifthorn2} do not apply.
Let  
 be a clause from the final Horn rule application such that  is not a variable renaming and
 for any , and . 
Let  be the Ancestor of 
and  a substitution such that  is linear for .
Then the \emph{horn approximation refinement I} of , , ,  is the clause
set  where the  are the specific
instances of  with respect to the substitutions .
\end{defin}

Note that the condition for the extended version of  specific instantiation to have a finite representation is not generally met by an arbitrary .
Therefore,  may need to be further instantiated or even made ground. 
After the Horn Approximation Refinement, Lemma~\ref{lifthorn2} can be applied on 
the clause with ancestor .

\begin{exmp}
Let  with signature . 
The Horn transformation  has a conflicting core 
.
We pick  as the instance of  to use for  the Horn Approximation Refinement.
The result is    
and its approximation also has  as a conflicting core.
However, now Lemma \ref{lifthorn2} applies.
\end{exmp} 



\begin{lem}[Completeness]\label{complete}
Let  be an unsatisfiable clause set and  its approximation.
Then, there exists a conflicting core of  that can be lifted to .
\end{lem}


\begin{proof}
by induction on the number  of approximation steps. The case  is obvious.
For , let .
By the inductive hypothesis, there is a conflicting core   of  which can 
be lifted to .\\
The final approximation rule application is either a Linear, a Shallow, a Horn or a Monadic transformation,
considered below by case analysis.

Linear Case. Let .
For every  , . 
Hence  
is a conflicting core of .
By Lemma \ref{liftlin}  can be lifted back to .
Hence, the conflicting core  can be lifted to .

Shallow Case. Let .
We construct  from  by replacing every   with  and .
 is a conflicting core, which by  applications of Lemma \ref{liftshallow} on each  can be lifted to .
From  we get  by renaming every  into , which is a conflicting core of .
The existence of   shows that  can be lifted to .

Horn Case. W.l.o.g. let .
Let  and .
If  holds for at most one , we construct  from  by replacing  with  such that .
Since  subsumes , .
As  is a superset of ,  is therefore a ground conflicting core of .
If  and  are already equivalent,   can be lifted to .
Otherwise, let  be  where    is instead replaced by .
Again since  subsumes ,  is a ground conflicting core. 
As shown before,  is a lifting from  to .\\
Assume  and  holds for . 
In this case the original clause  can be specifically instantiated in such a way that  and  are no longer instances of the same clause,
while  remains a conflicting core.
Hence, after finitely many such partitions eventually the first case will hold. 

Monadic Case. Let  where  has no occurrence of an atom 
 and  no occurrence of an atom  and
all introduced atoms in the transformation are of the form .
By the inductive hypothesis, there is a ground conflicting core   of  which can be lifted to .
By Lemma \ref{Apr_sound}(ii) Monadic transformation  preserves unsatisfiability and therefore  is a ground conflicting core of . 
 can be lifted to  a conflicting core of .
\end{proof}

The above lemma considers static completeness, i.e., it does not tell how the conflicting
core that can eventually be lifted is found. One way is to enumerate all refutations of  
in a fair way. A straightforward fairness criterion is to enumerate the refutations by increasing
term depth of the clauses used in the refutation. Since the decision procedure on the
mslH fragment~\cite{Weidenbach99cade} generates only finitely many different
non-redundant clauses not exceeding a concrete term depth with respect to the renaming of variables, eventually the 
liftable refutation will be generated.



\section{Future and Related Work} \label{sec:furewo}


The condition for the lifing lemma for Shallow transformation (Lemma \ref{liftshallow})  is stronger than necessary, as the following example shows.  

\begin{exmp}\label{shallowex2}
Let   \\    and
   is a Shallow transformation of . 
 and  are unsatisfiable and   
is a conflicting core of . Lifting  fails because the resolvent  is not an instance of  .
However, if we ignored the violating resolvents, it would result in the valid conflicting core  \\ .
\end{exmp} 

This does not break lifting. 
The shallow refinement will partition the clause in such a way that the resolvents that violate the lifting condition are one-by-one removed.
In Example~\ref{shallowex2}, the refinement would partition   on the variable .
This will result in   and   containing different -predicates and hence no longer being resolvable. 

However, a refinement is not necessary to achieve this effect. 
The necessary information can be taken from the refutation 
and incorporated into the conflicting core during construction.

If a problem  is unsatisfiable, not only does there exist an unsatisfiability proof but one where -literals only occur on leaves.
Such a proof can be found by a ordered resolution calculus through selecting negative -literals and an ordering where positive -literals are strictly maximal.
Given such a setting a solver will only resolve a clause  
 with  on the -atom 
and hence any -atom will only appear at the leaves of the refutation.

In such a proof, we then uniquely rename the -predicate in each pair of leaves.
The conflicting core constructed from this proof then only allows resolutions on -literals that also occur in the proof. 
On this core we can then check the lifting condition.

In example \ref{shallowex2} the core would then instead be 
    .
This core is liftable to  by Lemma \ref{liftshallow}.
 

\subsubsection{Related Work}
In ''A theory of abstractions''~\cite{Giunchiglia:1992:TA:146945.146951}  Giunchiglia and Walsh don't define an actual approximation but a general framework to classify and compare approximations, which are here called abstractions. 
They informally define abstractions as ''the process of mapping a representations of a problem'' that ''helps deal with the problem in the original search space by preserving certain desirable properties`` and ''is simpler to handle``. 

In their framework an abstraction is a mapping between formal systems, i.e., a triple of a language, axioms and deduction rules, which satisfy one of the following conditions:
An increasing abstraction (TI)  maps theorems only to theorems, i.e., if  is a theorem, then  is also a theorem, 
while a decreasing abstraction (TD)   maps only theorems to theorems, i.e., if  is a theorem, then  was also a theorem.

Furthermore, they define dual definitions for refutations, where not theorems but formulas that make a formal system inconsistent  are considered.
An increasing abstraction (NTI) then maps inconsistent formulas only to inconsistent formulas and vice versa for decreasing abstractions (NTD).

They list several examples of abstractions such as  ABSTRIPS by Sacerdoti~\cite{Sacerdott:1973:PHA:1624775.1624826}, a GPS planning method by Newell and Simon~\cite{Newell:1972:HPS:1095704}, Plaisted's theory of abstractions~\cite{journals/ai/Plaisted81}, propositional abstractions exemplified by Giunchiglia~\cite{conf/ecai/GiunchigliaG88}, predicate abstractions by by Plaisted~\cite{journals/ai/Plaisted81} and Tenenberg~\cite{Tenenberg87preservingconsistency}, domain abstractions by Hobbs~\cite{Hobbs85granularity} and Iemielinski~\cite{Imielinski:1987:DAL:1625995.1626083} and ground abstractions introduced by Plaisted~\cite{journals/ai/Plaisted81}.

With respect to their notions the approximation described in this paper is an abstraction where the desirable property is the over-approximation and the decidability of the fragment makes it simpler to handle. More specifically in the context of \cite{Giunchiglia:1992:TA:146945.146951} the approximation is an NTI abstraction for refutation systems, i.e., it is an abstraction that preserves inconsistency of the original. 

In  Plaisted~\cite{journals/ai/Plaisted81} three classes of abstractions are defined. The first two are ordinary and weak abstractions, which share the condition that if  subsumes  then every abstraction of  is subsumed by some abstraction of . However, our approximation falls in neither class as it violates this condition via the Horn approximation. For example  subsumes , but the Horn 
approximation  of  is not subsumed by any approximation of .    
The third class are generalization functions, which change not the problem but abstract the resolution rule of inference. 

The theorem prover iProver uses the Inst-Gen~\cite{DBLP:conf/birthday/Korovin13} method, 
where a first-order problem is abstracted with a SAT problem by replacing every variable by the fresh constant . 
The approximation is solved by a SAT solver and its answer is lifted to the original 
by equating abstracted terms with the set they represent, e.g., if  is true in a
 model returned by the SAT solver, then all instantiations of the original  are 
considered true as well. 
Inst-Gen abstracts using an  under-approximation of the original clause set.
In case the lifting of the satisfying model is inconsistent, 
the clash is resolved by appropriately instantiating the involved clauses, which mimics an inference step.
This is the dual of our method with the roles of satisfiability and unsatisfiability switched.
A further difference, however, is that Inst-Gen only finds finite models after approximation, 
while our approximation also discovers infinite models.
For example the simple problem , , ,  has the satisfying model where  is the set of even numbers.
However, iProver's approximation can never return such a model as any  will necessarily abstract both true and false atoms and therefore instantiate new clauses infinitely. 
Our method on the other hand will produce the approximation , , ,  ,  , which  is saturated after inferring  and .

In summary, we have presented the first sound and complete calculus for
first-order logic based on an over-approximation-refinement loop. There
is no implementation so far, but the calculus will be practically useful if a problem
is close to the mslH fragment in the sense that only a few refinement loops
are needed for finding the model or a liftable refutation. 
The abstraction relation is already implemented and applying it to all satisfiable non-equality
problems TPTP version~6.1 results in a success rate of 34\%, i.e., for all these problems
the approximation is not too crude and directly delivers the result.

It might be possible
to apply our idea to other decidable fragments of first-order logic.
However, then they have to support via approximation the presented lifting and refinement
principle. 

Our result is also a first step towards a  model-based guidance of first-order
reasoning. We proved that a model of the approximated clause set is also a model for the
original clause set. For model guidance, we need this property also for partial models. For example,
in the sense that if a clause is false with respect to a partial model operator on
the original clause set, it is also false with respect to a partial model operator on
the approximated clause set. This property does not hold for the standard superposition partial
model operator and the mslH approximation suggested in this paper. It is subject to future research.

\bibliographystyle{plain}
\bibliography{abstractions}

\clearpage
\appendix






\ \\
\ \\
\ \\
\ \\
\ \\
\ \\

\section{Skeleton and Partial Minimal Model Construction}

As mentioned before, Lemma \ref{termSkelLem} also holds if satisfiability of  is dropped and  is replaced
by the superposition partial minimal model operator~\cite{Weidenbach01handbook}.

\begin{defin}[Partial Minimal Model Construction]
Given the set of ground clauses  of  and an ordering  we construct an interpretation  for , called a partial model,  inductively as follows:

Clauses  with  are called productive.
\end{defin}

Note that this construction doesn't terminate since the ground clause set of  is generally infinite.



\begin{lem}\label{termSkelLem3}
Let  be a monadic clause set and  be its approximation via  . 
If   and  is a predicate in , then there exists a clause 
 and a substitution  such that
 and for each variable  and predicate  with , , where .
\end{lem}

\begin{proof}
By induction on .\\
The base  holds by definition of the model operator . \\
Let  ,  and  is a predicate in  and hence also in . 
By the induction hypothesis, there exist a clause  and a substitution  such that
 and for each variable  and predicate  with , , where .

Let  be a Horn transformation that replaces  with .
If , then  fulfills the claim.
Otherwise,  fulfills the claim since  and .

Let  be a linear transformation that replaces  with .
If , then  fulfills the claim.
Otherwise,  fulfills the claim since  and .

Let  be a shallow transformation that replaces  with  and .
Since  is fresh, .
If , then  fulfills the claim.
Otherwise,  and hence,  and  for .
Then by the induction hypothesis, there exist a clause  and a substitution  such that
 and for each variable  and predicate  with , , where .
By construction, . 
Thus,   and  imply there exists a  such that .
Furthermore since , if , then 
either  and thus  , where , or 
 and thus  , where .
Hence,   fulfills the claim.
\end{proof}

\begin{lem}\label{termSkelLem4}
Let  be a clause set and  be its approximation via  . 
If   
and  is a predicate in , then there exist a clause 
  ()
and a substitution  such that
 ( for all ).
\end{lem}


\begin{proof}
Let  be the non-monadic predicates in  and  .
Then,  is monadic and also has  as its approximation via .

 Let  and  is a predicate in . Since  is monadic,  is a predicate in .
Hence by Lemma ~\ref{termSkelLem3}, there exists a clause  
and a substitution  such that . 
Then,  fulfills the claim.

Let  and  is a predicate in .  is monadic and a predicate in .
Hence by Lemma ~\ref{termSkelLem3}, there exists a clause  
and a substitution  such that .
Therefore,  with   for all .
Then,  fulfills the claim.
\end{proof}

 
\end{document}
