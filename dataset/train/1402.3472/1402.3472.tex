\providecommand{\jump}[1]{\mathtt{jump}(#1)}
\providecommand{\jumpset}[1]{X_{#1}}
\providecommand{\secp}[1]{A_{#1}}
\providecommand{\jumpfam}{\mathcal{J}}
\providecommand{\chainfam}{\mathcal{C}}

In this section we conclude the proof of Theorem~\ref{thm:spic}
by showing the following.
\begin{theorem}\label{thm:dp}
Given a \spic{} instance  with ,
 a threshold  and a family ,
one can in  time find the canonical ordering  of , assuming that
\begin{enumerate}
\item ;
\item for each , ;
\item each section consistent with  belongs to .
\end{enumerate}
\end{theorem}
Observe that if we apply Theorem~\ref{thm:dp} to a branch with a \spic{} instance ,
the threshold  and family  output by Theorem~\ref{thm:sec-enum},
then we obtain the algorithm promised by Theorem~\ref{thm:spic}.

The algorithm of Theorem~\ref{thm:dp} is a dynamic programming algorithm.
Henceforth assume that the instance  with threshold  and family 
is as promised in the statement of Theorem~\ref{thm:dp}, and let  be the canonical ordering of .
We develop two different ways of separating the graphs  and  into smaller parts,
suitable for dynamic programming. Consequently, the dynamic programming algorithm
has in some sense `two layers', and two different types of states.

\subsection{Layer one: jumps and jump sets}

We first develop a way to split the graphs  and  `vertically'.
To this end, first denote for any position 
the section ; note that this definition also makes sense
for  and .
Second, for any position  define

in this definition we follow the convention that the minimum of an empty set is . Moreover, we define a \emph{jump set} for position  as

See also Fig.~\ref{fig:jump} for an illustration.

\begin{figure}
\centering
\includegraphics{fig-jump}
\caption{A jump at position  and the corresponding jump set.
  The jump set , denoted with gray, is a clique in , and no edge of 
    connects  with .}
\label{fig:jump}
\end{figure}

The next two lemmata follow directly from the definition of a jump and the properties
of  umbrella orderings.
\begin{lemma}\label{lem:jump-ineq}
For any positions  and , if  then .
\end{lemma}
\begin{lemma}\label{lem:jump-cut} Jump set 
 is  a clique in , but no edge of 
connects a vertex of  with a vertex of .
\end{lemma}

We now slightly augment the graph  so that  for all interesting
positions; see also Figure~\ref{fig:augment}.
We take  branches, guessing the first
and the last vertex of  in the ordering ; denote them by  and .
We introduce  new vertices,  
and new edges  in .
We also introduce new positions , isolated in  and connected
by edges  in .
We define , , ,
    and .
Moreover, we put  and  before all vertices of  in the ordering ,
and ,  and  after them.
Note that, if we precede all the vertices in the ordering  with
 and succeed with  we obtain an ordering with no
higher cost. Due to the way we have extended  to the new vertices, the
extended ordering  defined in this way is the canonical ordering
of the extended graph . Hence, we may abuse the notation and denote by 
the graph after the addition of these five new vertices, and assume that  again.

\begin{figure}
\centering
\includegraphics{fig-augment}
\caption{Augmentation of the input graph .}
\label{fig:augment}
\end{figure}


Observe now that  and ,
 as  and .
Moreover,  and ,
as , , and 

The main observation now is that a jump set, together with all edges of 
incident with it (i.e., ) contains
all sufficient information to divide the problem into parts before and after
a jump set.
\begin{lemma}\label{lem:jump-equiv}
For any position , the following holds.
\begin{enumerate}
\item
For any  such that  we have

\item For any bijection 
such that  for any  and 
both inclusions~\eqref{eq:jump-left} and~\eqref{eq:jump-right} hold
for any  with ,
if we define an ordering  of  as
 if  and  otherwise,
then  is feasible and  is a subgraph of . 
\end{enumerate}
\end{lemma}
\begin{proof}
The first statement is straightforward from the properties of an umbrella ordering.
Let  and  be as in the second statement.
Observe that inclusions~\eqref{eq:jump-left} and~\eqref{eq:jump-right}, together with the fact that  is a clique in ,
imply that  and  differ only on the internal order of twin classes of  and consequently .
Together with the fact that  for any , this means that  is a feasible ordering of  and an umbrella ordering of .
Consequently ,  is a subgraph of , and the lemma is proven.
\end{proof}

We use Lemma~\ref{lem:jump-equiv} to fit the task of computing  into Lemma~\ref{lem:lex-match}.
\begin{lemma}\label{lem:jump-detect}
Given a position  and the sets ,  and
, one can
in polynomial time compute the ordering .
\end{lemma}
\begin{proof}
First, observe that the data promised in the lemma statement allows
us to compute  and 
for every .
Define a binary relation  on  as  if and only if
both~\eqref{eq:jump-left} and~\eqref{eq:jump-right} hold for  and .
Lemma~\ref{lem:jump-equiv} asserts that  is a total quasi-order on .
That is, the set  can by partitioned into sets 
such that  and  for any  and
, and ,  for any 
and , .
(Formally, we terminate the current branch if  does not satisfy these properties.)

Observe that  maps  onto .
Lemma~\ref{lem:jump-equiv} asserts that all vertices of 
are placed by  on the first  positions of the range of ,
all vertices of  are placed on the next  positions etc.
We use Lemma~\ref{lem:lex-match} to find a lexicographically minimum ordering  that satisfies the above
and additionally  for each .
Define  as in Lemma~\ref{lem:jump-equiv}.
By the minimality of , we have , but Lemma~\ref{lem:jump-equiv}
asserts that  is a subgraph of .
Hence,  is of minimum possible cost.
By the lexicographical minimality of , we have 
and the lemma is proven.
\end{proof}



With help of family , Lemma~\ref{lem:jump-detect} allows us to efficiently enumerate
jump sets with their surroundings.
\begin{theorem}\label{thm:jump-enum}
One can in  time enumerate a family 
of at most  tuples  such that:
\begin{enumerate}
\item in each tuple  we have
\begin{enumerate}
\item  and ,
\item  is a complete graph,
\item  is a bijection between  and ;
\end{enumerate}
\item for any position , if there are at most 
edges of  incident to , then
the tuple  belongs to .
\end{enumerate}
\end{theorem}
\begin{proof}
We provide a procedure of guessing at most  candidate tuples that will constitute the family . Since the promised properties of elements of  can be checked in polynomial time, it suffices to argue that every triple of the form  will be among the guessed candidates.

The number of choices for  and  is .
Observe that then .
Furthermore, there are  ways to choose 
and, by Lemma~\ref{lem:jump-detect}, we can further deduce . Finally,  observe that  by the definition of a jump it follows that every triple  satisfies the promised properties of the elements of .
\end{proof}

We are now ready to describe the first layer of our dynamic programming algorithm.
\begin{definition}[layer-one state]
A \emph{layer-one state} is a pair  of two elements of ,
,  such that 
 and .
The \emph{value} of a layer-one state  is a bijection
 satisfying the following:
\begin{enumerate}
\item  is a feasible ordering of its domain, that is,
  for any  we have  and
  for any  such that , we have
  ;
\item  for any  and
 for any ;
  \label{p:layer-one-last}
\item among all functions  satisfying the previous conditions,\label{p:layer-one-min}
   minimizes the cardinality of  
(where in the expression  the function  is treated as an ordering of the set 
 in the \spic{} instance );
\item among all functions  satisfying the previous conditions, 
 is lexicographically minimum.
\end{enumerate}
\end{definition}

We first observe the following consequence of the above definition.
\begin{lemma}\label{lem:layer-one-1}
For any  such that , we have that  is a layer-one state and

In particular, .
\end{lemma}
\begin{proof}
Let . It is straightforward to verify that  is a layer-one state
and  satisfies the first \ref{p:layer-one-last} properties of the value of a layer-one state.
Also, no edges of  are incident to  nor to , and hence  and
 is a layer-one state.

Let  be any function satisfying the first \ref{p:layer-one-min} conditions of the definition
of a value of the layer-one state .
Let  be an ordering of  defined as  if  is the domain of , and  otherwise.
It is straightforward to verify that  is feasible, using the separation property provided by Lemma~\ref{lem:jump-cut} and the fact that .
For the same reasons, by the definition of  we have that . By the optimality of  we have that , and so . By the optimality of  we infer that , and  is also a minimum completion of .
Since  is also lexicographically minimum, it is easy to see that the last criterion of the definition of the value of the layer-one state  indeed chooses .
\end{proof}
By Lemma~\ref{lem:layer-one-1}, our goal is to compute  by dynamic programming. Observe
that both  and  are known, due to the augmentation performed at the beginning of this section.

Our dynamic programming algorithm computes value  for every
layer-one state , and we will ensure that  for any  with ;
we will not necessarily guarantee that the values of 
and  are equal for other states.
(Formally,  may also take value of , which implies that either  or  is not consistent with ;
 we assign this value to  whenever we find no candidate for its value.)

Consider now one layer-one state  with 
, .
The base case for computing  is the case where .
Then  is the only candidate for the value , provided that  and  agree on the intersection of their domains.

In the other case, we iterate through all possible tuples
, with 
such that both  and  are layer-one states,
and try  as a candidate value for .
That is, we temporarily
pick  with the same criteria as for , but taking into
account only values  for different choices of .

Since the minimization for  is taken over smaller set of functions
than for , we infer that
\begin{enumerate}
\item the cardinality of  is not larger than the cardinality of ;
\item even if these two sets are of equal size,  is lexicographically
not larger than .
\end{enumerate}
However, observe that if  and 
and there exists  such that  and ,
    then  is taken into account when evaluating . If we compute the values for the states  in the order of non-decreasing values of , then the values  have been computed before, and moreover by induction hypothesis they are equal to  and , respectively. Therefore,

is taken as a candidate value for  and, consequently, .

Finally, we need to ensure that  in the case
when such position  does not exist. To this end, we take also more
candidate values for , computed by the layer-two dynamic programming
in the next section. We ensure that, if ,
 but for any  we have ,
then the layer-two dynamic programming actually outputs  as one of the candidates,
     and runs in time  for any choice of . By Theorem~\ref{thm:jump-enum} there are at most  layer-one states. Hence by using  work for each of them will give the running time promised in Theorem~\ref{thm:dp}.

\subsection{Layer two: chains}

In this section we are given a layer-one state  with , ;
denote ,  for .
We are to compute, in time , the value , assuming: , , and
for no position  it holds that . By Theorem~\ref{thm:jump-enum}, it implies that the number of edges of 
incident to any set  for  is more than . Observe that the following holds  , and hence  for . 

For any position , consider the following sequence:  and  (with the convention that ).
Observe the following.
\begin{lemma}\label{lem:short-z}
For any  it holds that .
\end{lemma}
\begin{proof}
Consider any . For any  such that  we have
that there are more than  edges of  incident to .
However, the sets  are pairwise disjoint for different values of .
Since , we infer that for less than  values  we may have , and the lemma is proven.
\end{proof}

By a straightforward induction from Lemma~\ref{lem:jump-ineq} we obtain the following.
\begin{lemma}\label{lem:z-interlace}
For any two positions  with 
and for any  it holds that

\end{lemma}
The next observation gives us the crucial separation property for the layer-two dynamic programming (see also Figure~\ref{fig:CiDi}).
\begin{lemma}\label{lem:z-cut}
For any positions  with 
define

Then
\begin{enumerate}
\item sets  form a partition of ;
\item for any , it holds that both  and 
are cliques in ;
\item for any  there is no edge in  between  and ;
\item for any  there is no edge in  between  and .
\end{enumerate}
\end{lemma}
\begin{proof}
All statements follow from the definitions 
and , and from Lemmata~\ref{lem:jump-cut} and~\ref{lem:z-interlace}.
\end{proof}

\begin{figure}
\centering
\includegraphics{fig-CiDi}
\caption{The separation property provided by Lemma~\ref{lem:z-cut}.
The sequences  and  are denoted with rectangular and hexagonal shapes, respectively.
The sets  and  are denoted with dots and lines, respectively.}
\label{fig:CiDi}
\end{figure}


Intuitively, Lemma~\ref{lem:z-cut} implies that we may independently consider the vertices of
 and of : the sequences  and 
give us some sort of `horizontal' partition of the graphs  and .
We now formalize this idea.

\begin{definition}[chain]
A \emph{chain} is a quadruple , where

with the following properties:
\begin{enumerate}
\item  if and only if ;
\item  for any ;
\item  for any ;
\item , for any ;
\item  if and only if ;
\item no edge of  connects a vertex of  with a vertex
of  for any .
\end{enumerate}
A chain  is \emph{consistent} with the ordering 
if  and for all 
\begin{enumerate}
\item ;
\item ;
\item .
\end{enumerate}
\end{definition}

We remark here that if  then  for any , and hence  
for any  in the definition above.

Our next lemma follows immediately  from the definition of a chain.
\begin{lemma}\label{lem:ord-to-chain}
For  , let . For every , let 

Then  is a chain consistent with .

\end{lemma}

Moreover, the bound of Lemma~\ref{lem:short-z} gives us the following enumeration algorithm.
\begin{theorem}\label{thm:chain-enum}
In  time one can enumerate a family 
of at most  chains that contains all chains consistent with .
\end{theorem}
\begin{proof}
There are  possible values for .
For each , there are at most  choices for ,
 choices for  and  choices for .
The bound  due to Lemma~\ref{lem:short-z} yields the desired bound.
Observe that the properties of a chain can be verified in polynomial time.
\end{proof}

We are now finally ready to state the definition of a layer-two state with its value.
\begin{definition}[layer-two state]
A \emph{layer-two state} consists of two chains ,  with  such that
\begin{enumerate}
\item ,
\item ,  for any  and ,  for any ;
\item  if and only if  for any  and ;
\end{enumerate}
Furthermore, we denote

and require that for any  all positions of  are pairwise adjacent in .
We define  to be equal to  with additionally  and each  turned into a clique, for every .
Note that by Lemma~\ref{lem:intersection-union},  is a proper interval graph with identity being an umbrella ordering. Moreover, it holds that  by the construction of  and the fact that .

The \emph{value} of a layer-two state  is a bijection

such that:
\begin{enumerate}
\item  is a feasible ordering of its domain, that is,
for any  in the domain of  we have , and
  for any  in the domain of  such that , it holds that
  ;
\item  whenever ;
\item  for all ;
\item  whenever  and  whenever ;\label{p:layer-two-last}
\item among all functions  satisfying the previous conditions,  minimizes the cardinality
of ,
where the set  is defined as the unique minimal completion for the ordering  of the subgraph of  induced by the domain of 
and \spic{} instance ;\label{p:layer-two-min}
\item among all functions  satisfying the previous conditions, 
 is lexicographically minimum.
\end{enumerate}
\end{definition}

Note that in the definition of a layer-two state we {\em{do not}} require that any of the chains begins in , i.e. that  or  are in this interval. The values for the states where these chains begin at arbitrary positions within  will be essential for computing the final value we are interested in.

Similarly as in the case of layer-one states, we have the following claim.
\begin{definition}[relevant pair]
A pair  with  is called
\emph{relevant} if one of the following holds:
\begin{enumerate}
\item ,
\item , or
\item there exists a position 
such that 
(see also Figure~\ref{fig:relevant}).
\end{enumerate}
\end{definition}

\begin{figure}
\centering
\includegraphics{fig-relevant}
\caption{The last case of the definition of a relevant pair .
  Both positions  and  need to belong to the gray area.}
\label{fig:relevant}
\end{figure}

\begin{lemma}\label{lem:layer-two-ord}
For any  such that , the pair  is a layer-two state.
If moreover  is a relevant pair, then  is a restriction of  to the domain of .
In particular, .
\end{lemma}
\begin{proof}
By somehow abusing the notation, we denote  and . It is straightforward to verify from the definition that  is a layer-two state
and the restriction of  to  satisfies the first~\ref{p:layer-two-last} requirements
of the definition of a value of a layer-two state, even if  is not a relevant pair.
Moreover, observe that Lemma~\ref{lem:z-cut} implies that  is a completion for the ordering
 of  in the instance . Hence, .

Now assume that  is a relevant pair and denote  and 
for .
If , then observe that the sets  are empty, and the state in question asks for an empty function. Hence, assume .
Define an ordering  of  so that  for any , and  otherwise.

Let us define . 
In the subsequent claims we establish some properties of the graph  and ordering .
\begin{claim}\label{cl:layer-two:margins}
.
\end{claim}
\begin{proof}
Note here that  and  agree on positions before  and after . Observe also that  and  are cliques in , and  can have non-empty intersection only with the first of the intervals .
Since , it follows by the definition of  that that intervals  and  are cliques in  as well. Since , the claim follows.
\cqed\end{proof}

\begin{claim}\label{cl:layer-two:umbrella}
 is a umbrella ordering of .
\end{claim}
\begin{proof}
Consider any  with  and
; we want to show the umbrella property for the triple
 in the graph . We consider a few cases, depending on the intersection .
\begin{enumerate}
\item If  or , then the umbrella property holds by the definition of  and .
\item If  or , then recall that . Then the umbrella property for  follows from the fact that  is an umbrella ordering of .

Hence, in the remaining cases we have in particular that  and . Observe also that the assumption  implies that , since  and .

\item If  and  then, by the structure of , we have ,  for some . We claim that . Assume the contrary. Observe that if  then in particular .
By Lemma~\ref{lem:z-cut}, no edge of  connects  with , so in particular there is no such edge neither in , which is subgraph of . Likewise, there is no edge between  and  in . By the construction of  it follows that also no edge of  connects  with .
As  and  differ only on the internal ordering of each set , and , we have a contradiction,
and hence .
It follows that  and, by Lemma~\ref{lem:z-cut}, .
  By the definition of , .

In the remaining cases we have that either  or  does not belong to . Hence  by the definition of .

\item If  and , then, by Lemma~\ref{lem:z-cut}, we have 
and  for some . By Lemma~\ref{lem:z-cut},
 is a clique in , and, by the definition of ,
 is a clique in . Hence,  regardless whether  or not.
\item If  and  for some , then, by Lemma~\ref{lem:z-cut},
  . As in the previous case, Lemma~\ref{lem:z-cut} asserts that 
 is a clique in , and the definition of 
gives us that  is a clique in . Consequently,   regardless whether  or not.
\item If  and  then, as , we have that pair  is 
a relevant pair due to existence of some position . Since , we have that .
As , we have that also  and . By the definition of  we infer that  and, additionally,  in the case .
If  then  and  by the definition of .
\item If  and , then let  for some
. Since  and  differ only on internal ordering of sets  and , then the condition  implies also . Since  and  is an umbrella ordering of , we infer that . By the definition of  this implies that .
\end{enumerate}
\cqed\end{proof}

\begin{claim}\label{cl:layer-two:Gdown}
.
\end{claim}
\begin{proof}
Consider any .
Denote ,  and similarly denote  and  for the ordering ; we want to show that .
As  we have .
If  then  by the definition of .
Otherwise, without loss of generality assume that , and hence .
If additionally  then  follows directly from the definition of  and the fact that .
In the remaining case, if , we have  and  for some
. Moreover, from the assumption  we infer that , and consequently .
By the definition of , we need to show that .

We consider two cases, depending on the relative order of  and . If , then we have  by Lemma~\ref{lem:z-cut}
and consequently . By Lemma~\ref{lem:z-cut} again,  is adjacent to all vertices of 
in the graph , and .
A similar argument holds if  and : by Lemma~\ref{lem:z-cut}, we have first that  and, second,
that  is adjacent in  to all vertices of , and hence .
In the remaining case, if  and  (hence ),  from  it follows that the reason why  is a relevant pair
is existence of some position . Since , we infer that . Hence,  is
adjacent in  to all vertices of , in particular to , and the claim is proven.  
\cqed\end{proof}

\begin{claim}\label{cl:layer-two:Gup} 
 and  is a feasible ordering of .
\end{claim}
\begin{proof}
Observe that it follows directly from the definition of  that  for any vertex .
Hence, to show feasibility of  it suffices to show that .

Consider any . If both  and  belong to  or both do not belong,
then the claim is obvious by the feasibility of both  and .
Assume then  and . If  then clearly . 
Otherwise,  and  for some .
If  then Lemma~\ref{lem:z-cut} implies that .
By Lemma~\ref{lem:z-cut} again,  is a clique in  and hence in  as well, so .
A similar situation happens if  and :  and again Lemma~\ref{lem:z-cut}
together with feasibility of  proves the claim.
In the remaining case  and . As  we have  and hence the reason why  is a relevant pair
must be existence of some position . As  we have . As ,
the position  is adjacent to all positions of  in  and hence  as claimed.
\cqed\end{proof}

From the above claims we infer that , whereas
.
By the minimality of both  and , including the lexicographical minimality, we have  and the lemma is proven.
\end{proof}

The layer-two dynamic programming algorithm computes,
for any layer-two state ,   
a function 
that satisfies the first~\ref{p:layer-two-last} conditions of , and we will inductively ensure that 
for any relevant pair .
We compute the values  in the order of decreasing value of  and, subject to that, increasing value of .
(Formally,  may also take value of , which implies that either  or  is not consistent with ;
 we assign this value to  whenever we find no candidate for its value.)

Consider now a fixed layer-two state  with
 and .
We start with the the base case when we have that either  or
. Observe that in this situation we have that the domain of  is either  or  with an additional element  which must be mapped to . Hence all the values of  are fixed by ,  and , and there is only one candidate for this value.
It is straightforward to verify that, in the case when  and , this
unique candidate is indeed a restriction of  and hence equals .

In the inductive step we have  and .
We consider two cases, depending on the value of .

First assume .
In this case consider all possible chains  such that both  and  are layer-two states,
and .
We take as candidate value for  the union , and pick  using the criteria
from the definition of the value , but taking only functions  for all choices of  as candidates.

We claim that if ,  and  is a relevant pair, then 
. Note that it suffices to show that  is considered as a candidate for 
in the aforementioned process for some choice of .
Consider any  and observe that if  is a relevant pair,
then also  and  are relevant pairs: this is clearly true for
the case  and, in the last case of the definition of a relevant pair,
notice that the same position  witnesses also that  and  are relevant.
Denote  and observe that we consider a candidate  for .
By Lemma~\ref{lem:layer-two-ord} and the inductive assumption, this candidate is a restriction of , and hence,
again by Lemma~\ref{lem:layer-two-ord}, equals .

We are left with the case . As , we have .
For  define , and
,  and 
for any , and .
In this case we consider only one candidate for , being , extended with 
.

It remains to show that if ,  and  is an relevant pair,
then .
Observe that  and .
Moreover, the position  witnesses that  is a relevant pair, and hence
 by induction.
This completes the proof that  for all relevant pairs .

As candidates for the value  of the layer-one state  we are currently processing, we take all the values  for all the layer-two states  for which the domain of  is equal to the domain of . By Theorem~\ref{thm:chain-enum}, there are at most  guesses for such states, and they can be enumerated in  time. Observe also that if indeed  and , then the layer-two state  will be among the enumerated states. Since  is a relevant pair, we have that , while by Lemma~\ref{lem:layer-two-ord} we have that  is equal to the restriction of  to its domain, which in turn is equal to the domain of . Hence, the restriction of  to the domain of , which is exactly equal to  by Lemma~\ref{lem:layer-one-1}, will be among the enumerated candidate values --- this was exactly the property needed by the layer-one dynamic program.


By Theorem~\ref{thm:chain-enum} there are  layer-two states, thus the entire computation of 
takes  time, as was promised.
This concludes the proof of Theorem~\ref{thm:dp}, and hence finishes the proof of Theorem~\ref{thm:main}.
