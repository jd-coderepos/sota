\documentclass{article}



\usepackage[final, nonatbib]{neurips_2019}


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{caption}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs} \usepackage{enumitem} 
\usepackage{bm}
\usepackage{placeins}
\usepackage{algorithmicx,algpseudocode,algorithm}

\usepackage{wrapfig,tikz}
\usepackage{amsmath,longtable,fancyhdr,booktabs,multirow,graphicx,float}
\usepackage{adjustbox, bigstrut, tabularx, multirow, makecell, diagbox}
\usepackage{amssymb,xcolor,amsthm}
\usepackage{color}
\usepackage{colortbl}
\usepackage{theoremref}
\usepackage{stmaryrd}
\bibliographystyle{abbrv}

\newcommand{\abs}[1]{\lvert#1\rvert}
\newcommand{\T}{\intercal}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}

\newcommand{\ud}{\mathrm{d}}
\newcommand{\up}{\mathrm}
\def\dbar{\mathrm{\mathchar'26\mkern-12mu d}}
\newcommand{\wave}{\sim}
\newcommand{\mcal}{\mathcal}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newtheorem{problem}{Problem}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}
\newtheorem{proposition}{Proposition}
\newtheorem{assumption}{Assumption}
\newtheorem{assumptions}{Assumptions}
\newtheorem{definition}{Definition}
\newtheorem{innercustomthm}{Theorem}
\newenvironment{customthm}[1]
{\renewcommand\theinnercustomthm{#1}\innercustomthm}
{\endinnercustomthm}
\newtheorem{innercustomlem}{Lemma}
\newenvironment{customlem}[1]
{\renewcommand\theinnercustomlem{#1}\innercustomlem}
{\endinnercustomlem}
\newtheorem{innercustomhyp}{Hypothesis}
\newenvironment{customhyp}[1]
{\renewcommand\theinnercustomhyp{#1}\innercustomhyp}
{\endinnercustomhyp}
\newtheorem{innercustomprop}{Proposition}
\newenvironment{customprop}[1]
{\renewcommand\theinnercustomprop{#1}\innercustomprop}
{\endinnercustomprop}
\newtheorem{innercustomass}{Assumption}
\newenvironment{customass}[1]
{\renewcommand\theinnercustomass{#1}\innercustomass}
{\endinnercustomass}

\newcommand{\be}{}

\definecolor{Gray}{gray}{0.85}
\definecolor{LightCyan}{rgb}{0.88,1,1}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argsup}{arg\,sup}
\DeclareMathOperator*{\arginf}{arg\,inf}

\makeatletter
\usepackage{xspace}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}

\newcommand{\eqnref}[1]{Eq\onedot~\eqref{#1}}
\newcommand{\figref}[1]{Fig\onedot~\ref{#1}}
\newcommand{\algoref}[1]{Alg\onedot~\ref{#1}}
\newcommand{\equref}[1]{Eq\onedot~\eqref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\tabref}[1]{Tab\onedot~\ref{#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\prgref}[1]{Program~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}
\newcommand{\clmref}[1]{Claim~\ref{#1}}
\newcommand{\corref}[1]{Corollary~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\propref}[1]{Proposition~\ref{#1}}
\newcommand{\ptyref}[1]{Property~\ref{#1}}
\newcommand{\assref}[1]{Assumption~\ref{#1}}
\newcommand{\bfx}{\mathbf{x}}
\newcommand{\bfv}{\mathbf{v}}
\newcommand{\bfz}{\mathbf{z}}
\newcommand{\bfe}{{\bs{\epsilon}}}
\newcommand{\bftheta}{{\boldsymbol{\theta}}}
\newcommand{\bfalpha}{{\boldsymbol{\alpha}}}
\newcommand{\bfphi}{{\boldsymbol{\phi}}}
\newcommand{\bfy}{\mathbf{y}}
\newcommand{\bfs}{\mathbf{s}}
\newcommand{\bfh}{\mathbf{h}}
\def\eg{\emph{e.g}\onedot}
\def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot}
\def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{cf}\onedot}
\def\Cf{\emph{Cf}\onedot}
\def\etc{\emph{etc}\onedot}
\def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot}
\def\dof{d.o.f\onedot}
\def\aka{a.k.a\onedot}
\def\iid{i.i.d\onedot}
\def\as{a.s\onedot}
\def\etal{\emph{et al}\onedot}

\newcommand{\y}[1]{{\color{cyan} [YS: {#1}]}}
\newcommand{\s}[1]{{\color{magenta} [SE: {#1}]}}

\usepackage[textsize=tiny]{todonotes}


\title{Generative Modeling by Estimating Gradients of the Data Distribution}


\author{Yang Song\\
  Stanford University\\
  \texttt{yangsong@cs.stanford.edu}\\
  \And
  Stefano Ermon\\
  Stanford University\\
  \texttt{ermon@cs.stanford.edu}
}

\begin{document}
\maketitle
\begin{abstract}
We introduce a new generative model where samples are produced 
via Langevin dynamics using gradients of the data distribution estimated with score matching. 
Because gradients can be ill-defined and hard to estimate when the data resides on low-dimensional manifolds, 
we perturb the data with different levels of Gaussian noise, and jointly estimate the corresponding scores, \ie, the vector fields of gradients of the perturbed data distribution for all noise levels. For sampling, we propose an annealed Langevin dynamics where we use gradients corresponding to gradually decreasing noise levels as the 
sampling process
gets closer 
to the data manifold. 
Our framework allows flexible model architectures, requires no sampling during training or the use of adversarial methods, and provides a learning objective that can be used for principled 
model comparisons. Our models produce samples 
comparable 
to GANs on MNIST, CelebA and CIFAR-10 datasets, achieving a new state-of-the-art inception score of 8.87 
on CIFAR-10. Additionally, we demonstrate that our models learn effective representations via image inpainting experiments.
\end{abstract} \section{Introduction}
Generative models have many applications in machine learning. 
To list a few, they have been used to generate high-fidelity images~\cite{karras2018style,brock2018large}, synthesize realistic speech and music fragments~\cite{oord2016wavenet}, improve the performance of semi-supervised learning~\cite{kingma2014semi, dai2017good}, detect adversarial examples and other anomalous data~\cite{song2018pixeldefend}, imitation learning~\cite{ho2016generative}, and explore promising states in reinforcement learning~\cite{ostrovski2017count}.
Recent progress 
is mainly driven by two 
approaches: likelihood-based methods~\cite{graves2013generating, kingma2014auto, dinh2014nice, oord2016pixel} and generative adversarial networks (GAN~\cite{goodfellow2014generative}). The former uses log-likelihood (or a suitable surrogate) as the training objective, while the latter uses adversarial training to minimize -divergences~\cite{nowozin2016f} or integral probability metrics~\cite{arjovsky2017wasserstein,sriperumbudur2009integral} between model and data distributions. 

Although likelihood-based models and GANs have achieved great success,
they have some intrinsic limitations.
For example, likelihood-based models either have to use specialized architectures to build a normalized probability model (\eg, autoregressive models, flow models), or use surrogate losses (\eg, the evidence lower bound used in variational auto-encoders~\cite{kingma2014auto}, contrastive divergence in energy-based models~\cite{hinton2002training}) for training. GANs avoid some of the limitations of likelihood-based models, but their training can be unstable due to the adversarial training procedure.
In addition, the GAN objective is not suitable for evaluating and comparing different GAN models.
While other objectives exist for generative modeling, such as noise contrastive estimation~\cite{gutmann2010noise} and minimum probability flow~\cite{sohl2009minimum}, these methods typically only work well for low-dimensional data.



In this paper, we explore a new principle for generative modeling based on estimating and sampling from the \textit{(Stein) score}~\cite{liu2016kernelized} of the logarithmic data density, which is 
the gradient of the log-density function at the input data point.
This is a vector field pointing in the direction where the log data density grows the most. We use a neural network trained with score matching~\cite{hyvarinen2005estimation} to learn this vector field from data.
We then produce samples using Langevin dynamics, which approximately works
by gradually moving a random initial sample to high density regions along the (estimated) vector field of scores.
However, there are two main challenges with this approach. 
First, if the data distribution is supported on a low dimensional manifold---as it is often assumed for many real world datasets---the score will be undefined in the ambient space, and score matching will fail to provide a consistent score estimator. Second, the scarcity of training data in low data density regions, \eg, far from the manifold, hinders the accuracy of score estimation and slows down the mixing of Langevin dynamics sampling. Since Langevin dynamics will often be initialized in low-density regions of the data distribution, inaccurate score estimation in these regions will 
negatively affect the sampling process. 
Moreover, mixing can be difficult 
because of the need of traversing low density regions to transition between modes of the distribution. 

To tackle these two challenges, we propose to \emph{perturb the data with random Gaussian noise of various magnitudes}. Adding random noise ensures the resulting distribution does not collapse to a low dimensional manifold. Large noise levels 
will produce samples in low density regions of the original (unperturbed) data distribution,  
thus improving score estimation. 
Crucially, we train a single score network conditioned on the noise level 
and estimate the scores 
at all noise magnitudes. 
We then propose \emph{an annealed version of Langevin dynamics}, where we initially use scores corresponding to the highest noise level, and gradually anneal down the noise level until it is small enough to be indistinguishable from the original data distribution. Our sampling strategy is inspired by simulated annealing~\cite{kirkpatrick83optimizationby,neal2001annealed} which heuristically improves optimization 
for multimodal landscapes. 


Our approach has several desirable properties. First, our objective is tractable for almost all parameterizations of the score networks without the need of special constraints or architectures, and can be optimized without adversarial training, MCMC sampling, or other approximations during training. The objective can also be used to quantitatively compare different models on the same dataset. Experimentally, we demonstrate the efficacy of our approach on MNIST, CelebA~\cite{liu2015faceattributes}, and CIFAR-10~\cite{Krizhevsky09learningmultiple}. We show that the samples look comparable to those generated from modern likelihood-based models and GANs. On CIFAR-10, our model sets the new state-of-the-art inception score of 8.87 for unconditional generative models, and achieves a competitive FID score of 25.32. We show that the model learns meaningful representations of the data by image inpainting experiments.

 \section{Score-based generative modeling}
Suppose our dataset consists of \iid samples  from an unknown data distribution . We define the \emph{score} of a probability density  to be . The \emph{score network}  is a neural network parameterized by , which will be trained to approximate the score of . The goal of generative modeling is to use the dataset to learn a model for generating new samples from . The framework of score-based generative modeling has two ingredients: score matching and Langevin dynamics.

\subsection{Score matching for score estimation}\label{sec:sm}
Score matching~\cite{hyvarinen2005estimation} is originally designed for learning non-normalized statistical models based on \iid samples from an unknown data distribution. Following \cite{song2019ssm}, we repurpose it for score estimation. Using score matching, we can directly train a score network  to estimate  without training a model to estimate  first. Different from the typical usage of score matching, we opt not to use the gradient of an energy-based model as the score network to avoid extra computation due to higher-order gradients. The objective minimizes , which can be shown equivalent to the following up to a constant 
where  denotes the Jacobian of . As shown in~\cite{song2019ssm}, under some regularity conditions the minimizer of \eqnref{eqn:ssm} (denoted as ) satisfies  almost surely. In practice, the expectation over  in \eqnref{eqn:sm} can be quickly estimated using data samples. However, score matching is not scalable to deep networks and high dimensional data~\cite{song2019ssm} due to the computation of . Below we discuss two popular methods for large scale score matching.

\paragraph{Denoising score matching} Denoising score matching~\cite{vincent2011connection} is a variant of score matching that completely circumvents . It first perturbs the data point  with a pre-specified noise distribution  and then employs score matching to estimate the score of the perturbed data distribution . The objective was proved equivalent to the following:

As shown in \cite{vincent2011connection}, the optimal score network (denoted as ) that minimizes \eqnref{eqn:dsm} satisfies  almost surely. However,  is true only when the noise is small enough such that .

\paragraph{Sliced score matching}
Sliced score matching~\cite{song2019ssm} uses random projections to approximate  in score matching. The objective is

where  is a simple distribution of random vectors, \eg, the multivariate standard normal. As shown in \cite{song2019ssm}, the term  can be efficiently computed by forward mode auto-differentiation. Unlike denoising score matching which estimates the scores of \emph{perturbed} data, sliced score matching provides score estimation for the original \emph{unperturbed} data distribution, but requires around four times more computations due to the forward mode auto-differentiation.

\subsection{Sampling with Langevin dynamics}
Langevin dynamics can produce samples from a probability density  using only the score function . Given a fixed step size , and an initial value  with  being a prior distribution, the Langevin method recursively computes the following

where . 
The distribution of  equals  when  and , in which case  becomes an exact sample from  under some regularity conditions~\cite{welling2011bayesian}. When  and , a Metropolis-Hastings update is needed to correct the error of \eqnref{eqn:langevin}, but 
it can often be ignored in practice~\cite{chen2014stochastic,du2019implicit,nijkamp2019anatomy}. 
In this work, we assume this error is negligible when  is small and  is large.

Note that sampling from \eqnref{eqn:langevin} only requires the score function . Therefore, in order to obtain samples from , we can first train our score network such that  and then approximately obtain samples with Langevin dynamics using . This is the key idea of our framework of \emph{score-based generative modeling}.


 \section{Challenges of score-based generative modeling}\label{sec:challenges}
In this section, we analyze more closely the idea of score-based generative modeling. We argue that there are two major obstacles that prevent a na\"{i}ve application of this idea. 
\subsection{The manifold hypothesis}
\begin{wrapfigure}[11]{r}{0.5\textwidth}
    \centering
    \vspace{-1em}
    \includegraphics[width=\linewidth]{diagrams/manifold.png}
    \caption{\textbf{Left}: Sliced score matching (SSM) loss \wrt iterations. No noise is added to data. \textbf{Right}: Same but data are perturbed with .}\label{fig:manifold}
\end{wrapfigure}
The manifold hypothesis states that data in the real world tend to concentrate on low dimensional manifolds embedded in a high dimensional space (\aka, the ambient space). This hypothesis empirically holds for many datasets, and has become the foundation of manifold learning~\cite{belkin2003laplacian,roweis2000nonlinear}. Under the manifold hypothesis, score-based generative models will face two key difficulties. First, since the score  is a gradient taken in the \emph{ambient space}, it is undefined when  is confined to a low dimensional manifold. Second, the score matching objective \eqnref{eqn:sm} provides a consistent score estimator only when the support of the data distribution is the whole space (\cf, Theorem 2 in \cite{hyvarinen2005estimation}), and will be inconsistent when the data reside on a low-dimensional manifold.

The negative effect of the manifold hypothesis on score estimation can be seen clearly from \figref{fig:manifold}, where we train a ResNet (details in Appendix~\ref{app:exp:toy}) to estimate the data score on CIFAR-10. For fast training and faithful estimation of the data scores, we use the sliced score matching objective (\eqnref{eqn:ssm}). As \figref{fig:manifold} (left) shows, when trained on the original CIFAR-10 images, the sliced score matching loss first decreases 
and then fluctuates irregularly. In contrast, if we perturb the data with a small Gaussian noise (such that the perturbed data distribution has full support over ), the loss curve will converge (right panel). Note that the Gaussian noise  we impose is very small for images with pixel values in the range , and is almost indistinguishable to human eyes.
\subsection{Low data density regions}\label{sec:low_density}
The scarcity of data in low density regions can cause difficulties for both score estimation with score matching and MCMC sampling with Langevin dynamics.
\subsubsection{Inaccurate score estimation with score matching}\label{sec:inaccuratesm}
\begin{wrapfigure}[15]{r}{0.5\linewidth}
\centering
\vspace{-1em}
\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=\linewidth]{paper/diagrams/data_scores.png}
\end{subfigure}\begin{subfigure}{0.5\linewidth}
\centering
\includegraphics[width=\linewidth]{paper/diagrams/estimated_scores.png}
\end{subfigure}
\caption{\textbf{Left}: ; \textbf{Right}: . The data density  is encoded using an orange colormap: darker color implies higher density. Red rectangles highlight regions where . }\label{fig:low_density}
\end{wrapfigure}
In regions of low data density, score matching may not have enough evidence to estimate score functions accurately, due to the lack of data samples. To see this, recall from \secref{sec:sm} that score matching minimizes the expected squared error of the score estimates, \ie, . In practice, the expectation \wrt the data distribution is always estimated using \iid samples . Consider any region  such that . In most cases , and score matching will not have sufficient data samples to estimate  accurately for .



To demonstrate the negative effect of this, we provide the result of a toy experiment (details in Appendix~\ref{app:exp:toy}) in \figref{fig:low_density} where we use sliced score matching to estimate scores of a mixture of Gaussians . As the figure demonstrates, score estimation is only reliable in the immediate vicinity of the modes of , where the data density is high.

\subsubsection{Slow mixing of Langevin dynamics}

When two modes of the data distribution are separated by low density regions, Langevin dynamics will not be able to correctly recover the relative weights of these two modes in reasonable time, and therefore might not converge to the true distribution. Our analyses of this are largely inspired by~\cite{wenliang2018learning}, which analyzed the same phenomenon in the context of density estimation with score matching.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/anneal.png}
    \caption{Samples from a mixture of Gaussian with different methods. (a) Exact sampling. (b) Sampling using Langevin dynamics with the exact scores. (c) Sampling using annealed Langevin dynamics with the exact scores. Clearly Langevin dynamics estimate the relative weights between the two modes incorrectly, while annealed Langevin dynamics recover the relative weights faithfully.
    }
    \label{fig:anneal}
\end{figure}


Consider a mixture distribution , where  and  are normalized distributions with disjoint supports, and . In the support of , , and in the support of , . In either case, the score  does not depend on . Since Langevin dynamics use  to sample from , the samples obtained will not depend on . In practice, this analysis also holds when different modes have approximately disjoint supports---they may share the same support but be connected by regions of small data density. In this case, Langevin dynamics can produce correct samples in theory, but may require a very small step size and a very large number of steps to mix.

To verify this analysis, we test Langevin dynamics sampling for the same mixture of Gaussian used in Section~\ref{sec:inaccuratesm} and provide the results in \figref{fig:anneal}. We use the ground truth scores when sampling with Langevin dynamics. Comparing \figref{fig:anneal}(b) with (a), it is obvious that the samples from Langevin dynamics have incorrect relative density between the two modes, as predicted by our analysis.

 \section{Noise Conditional Score Networks: learning and inference}
We observe that perturbing data with random Gaussian noise makes the data distribution more amenable to score-based generative modeling. First, since the support of our Gaussian noise distribution is the whole space, the perturbed data will not be confined to a low dimensional manifold, which obviates difficulties from the manifold hypothesis and makes score estimation well-defined. Second, large Gaussian noise has the effect of filling low density regions in the original unperturbed data distribution; therefore score matching may get more training signal to improve score estimation. Furthermore, by using multiple noise levels we can obtain a sequence of noise-perturbed distributions that converge to the true data distribution. We can improve the mixing rate of Langevin dynamics on multimodal distributions by leveraging these intermediate distributions in the spirit of simulated annealing~\cite{kirkpatrick83optimizationby} and annealed importance sampling~\cite{neal2001annealed}.

Built upon this intuition, we propose to improve score-based generative modeling by 1) \emph{perturbing the data using various levels of noise}; and 2) \emph{simultaneously estimating scores corresponding to all noise levels by training a single conditional score network}. After training, when using Langevin dynamics to generate samples, we initially use scores corresponding to 
large noise, and gradually anneal down the noise level. This helps smoothly transfer the benefits of large noise levels to low noise levels where the perturbed data are almost indistinguishable from the original ones. In what follows, we will elaborate more on the details of our method, including the architecture of our score networks, the training objective, and the annealing schedule for Langevin dynamics.



\subsection{Noise Conditional Score Networks}
Let  be a positive geometric sequence that satisfies . Let  denote the perturbed data distribution. We choose the noise levels  such that  is large enough to mitigate the difficulties discussed in \secref{sec:challenges}, and  is small enough to minimize the effect on data. We aim to train a conditional score network to jointly estimate the scores of all perturbed data distributions, \ie, . Note that  when . We call  a \textit{Noise Conditional Score Network (NCSN)}.

Similar to likelihood-based generative models and GANs, the design of model architectures plays an important role in generating high quality samples. In this work, we mostly focus on architectures useful for image generation, and leave the architecture design for other domains as future work. Since the output of our noise conditional score network  has the same shape as the input image , we draw inspiration from successful model architectures for dense prediction of images (\eg, semantic segmentation). In the experiments, our model  combines the architecture design of U-Net~\cite{ronneberger2015unet} with dilated/atrous convolution~\cite{Yu2016,Yu2017,chen2017deeplab}---both of which have been proved very successful in semantic segmentation. In addition, we adopt instance normalization in our score network, inspired by its superior performance in some image generation tasks~\cite{ulyanov2016instance,dumoulin2017learned-iclr,huang2017arbitrary}, and we use a modified version of conditional instance normalization~\cite{dumoulin2017learned-iclr} to provide conditioning on . More details on our architecture can be found in Appendix~\ref{app:arch}.

\subsection{Learning NCSNs via score matching}

Both sliced and denoising score matching can train NCSNs. We adopt denoising score matching as it is slightly faster and naturally fits the task of estimating scores of noise-perturbed data distributions. However, we emphasize that empirically sliced score matching can train NCSNs as well as denoising score matching. We choose the noise distribution to be ; therefore . For a given , the denoising score matching objective (\eqnref{eqn:dsm}) is

Then, we combine \eqnref{eqn:dsm2} for all  to get one unified objective

where  is a coefficient function depending on . Assuming  has enough capacity,  minimizes \eqnref{eqn:all} if and only if  \as for all , because \eqnref{eqn:all} is a conical combination of  denoising score matching objectives.

There can be many possible choices of . Ideally, we hope that the values of  for all  are roughly of the same order of magnitude. Empirically, we observe that when the score networks are trained 
to optimality,
we approximately have . This inspires us to choose . Because under this choice, we have . Since  and , we can easily conclude that the order of magnitude of  does not depend on .


We emphasize that our objective \eqnref{eqn:all} requires no adversarial training, no surrogate losses, and no sampling from the score network during training (\eg, unlike contrastive divergence). Also, it does not require  to have special architectures in order to be tractable. In addition, when  and  are fixed, it can be used to quantitatively compare different NCSNs.

\subsection{NCSN inference via annealed Langevin dynamics}
\begin{wrapfigure}[15]{r}{0.5\textwidth}
\vspace{-2.2em}
\begin{minipage}{0.5\textwidth}
\begin{algorithm}[H]
	\caption{Annealed Langevin dynamics.}
	\label{alg:anneal}
	\begin{algorithmic}[1]
	    \Require{.}
	    \State{Initialize }
	    \For{ to }
	        \State{} \Comment{ is the step size.}
            \For{ to }
                \State{Draw }
                \State{\resizebox{0.75\textwidth}{!}{}}
            \EndFor
            \State{}
        \EndFor
        \item[]
        \Return{}
	\end{algorithmic}
\end{algorithm}
\end{minipage}
\end{wrapfigure}
After the NCSN  is trained, we propose a sampling approach---annealed Langevin dynamics (\algoref{alg:anneal})---to produced samples, inspired by simulated annealing~\cite{kirkpatrick83optimizationby} and annealed importance sampling~\cite{neal2001annealed}. As shown in \algoref{alg:anneal}, we start annealed Langevin dynamics by initializing the samples from some fixed prior distribution, \eg, uniform noise. Then, we run Langevin dynamics to sample from  with step size . Next, we run Langevin dynamics to sample from , starting from the final samples of the previous simulation and using a reduced step size . We continue in this fashion, using the final samples of Langevin dynamics for  as the initial samples of Langevin dynamic for , and tuning down the step size  gradually with . Finally, we run Langevin dynamics to sample from , which is close to  when .


Since the distributions  are all perturbed by Gaussian noise, their supports span the whole space and their scores are well-defined, avoiding difficulties from the manifold hypothesis. When  is sufficiently large, the low density regions of  become small and the modes become less isolated. As discussed previously, this can make score estimation more accurate, and the mixing of Langevin dynamics faster. We can therefore assume that Langevin dynamics produce good samples for . These samples are likely to come from high density regions of , which means they are also likely to reside in the high density regions of , given that  and  only slightly differ from each other. As score estimation and Langevin dynamics perform better in high density regions, samples from  will serve as good initial samples for Langevin dynamics of . Similarly,  provides good initial samples for , and finally we obtain samples of good quality from .



There could be many possible ways of tuning  according to  in \algoref{alg:anneal}. Our choice is . The motivation is to fix the magnitude of the ``signal-to-noise'' ratio  in Langevin dynamics. Note that . Recall that empirically we found  when the score network is trained close to optimal, in which case . Therefore  does not depend on .

To demonstrate the efficacy of our annealed Langevin dynamics, we provide a toy example where the goal is to sample from a mixture of Gaussian with two well-separated modes using only scores. We apply \algoref{alg:anneal} to sample from the mixture of Gausssian used in \secref{sec:low_density}. In the experiment, we choose  to be a geometric progression, with ,  and . The results are provided in \figref{fig:anneal}. Comparing \figref{fig:anneal} (b) against (c), annealed Langevin dynamics correctly recover the relative weights between the two modes whereas standard Langevin dynamics fail.

 \section{Experiments}
In this section, we demonstrate that our NCSNs are able to produce high quality image samples on several commonly used image datasets. In addition, we show that our models learn reasonable image representations by image inpainting experiments.

\paragraph{Setup} We use MNIST, CelebA~\cite{liu2015faceattributes}, and CIFAR-10~\cite{Krizhevsky09learningmultiple} datasets in our experiments. For CelebA, the images are first center-cropped to  and then resized to . All images are rescaled so that pixel values are in . We choose  different standard deviations such that  is a geometric sequence with  and . Note that Gaussian noise of  is almost indistinguishable to human eyes for image data. When using annealed Langevin dynamics for image generation, we choose  and , and use uniform noise as our initial samples. We found the results are robust \wrt the choice of , and  between  and  generally works fine. We provide additional details on model architecture and settings in Appendix~\ref{app:arch} and \ref{app:exp}.
\begin{table}\begin{minipage}[b]{0.55\linewidth}
\begin{center}
\begin{adjustbox}{max width=0.8\linewidth}
\begin{tabular}{lcc}
        \toprule
        Model & Inception & FID\\
        \midrule
        \multicolumn{3}{l}{\textbf{CIFAR-10 Unconditional}} \\
        \midrule
        PixelCNN~\cite{van2016conditional} &  & \\
        PixelIQN~\cite{ostrovski2018autoregressive} &  & \\
        EBM~\cite{du2019implicit} &  &  \\
        WGAN-GP~\cite{gulrajani2017improved} &  & \\
        MoLM~\cite{ravuri2018learning} &  & \\
        SNGAN~\cite{miyato2018spectral} &  &  \\
        ProgressiveGAN~\cite{karras2018progressive} &  & - \\
        \textbf{NCSN (Ours)} & {} & \\
        \midrule
        \multicolumn{3}{l}{\textbf{CIFAR-10 Conditional}}\\
        \midrule
        EBM~\cite{du2019implicit} &  &  \\
        SNGAN~\cite{miyato2018spectral} &  & \\
        BigGAN~\cite{brock2018large} &  & \\
        \bottomrule
    \end{tabular} 
\end{adjustbox}
\end{center}
\caption{Inception and FID scores for CIFAR-10} \label{tab:score}
\end{minipage}\hfill
\begin{minipage}[b]{0.45\linewidth}
\begin{center}
\includegraphics[width=0.9\linewidth]{diagrams/sampling.png}
\end{center}
\captionof{figure}{Intermediate samples of annealed Langevin dynamics.}
\label{fig:sampling}
\end{minipage}
\end{table}

\begin{figure}\centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/mnist_samples.png}
        \caption{MNIST}
        \label{fig:mnist_samples}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/celeba_samples_small.png}
        \caption{CelebA}
        \label{fig:celeba_samples}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/cifar10_samples_small.png}
        \caption{CIFAR-10}
        \label{fig:cifar10_samples}
    \end{subfigure}
    \caption{Uncurated samples on MNIST, CelebA, and CIFAR-10 datasets.}
    \label{fig:samples}
\end{figure}

\paragraph{Image generation} In \figref{fig:samples}, we show uncurated samples from annealed Langevin dynamics for MNIST, CelebA and CIFAR-10. As shown by the samples, our generated images have higher or comparable quality to those from modern likelihood-based models and GANs. To intuit the procedure of annealed Langevin dynamics, we provide intermediate samples in \figref{fig:sampling}, where each row shows how samples evolve from pure random noise to high quality images. More samples from our approach can be found in Appendix~\ref{app:samples}. We also show the nearest neighbors of generated images in the training dataset in Appendix~\ref{app:nn}, in order to demonstrate that our model is not simply memorizing training images. To show it is important to learn a conditional score network jointly for many noise levels and use annealed Langevin dynamics, we compare against a baseline approach where we only consider one noise level  and use the vanilla Langevin dynamics sampling method. Although this small added noise helps circumvent the difficulty of the manifold hypothesis (as shown by \figref{fig:manifold}, things will completely fail if no noise is added), it is not large enough to provide information on scores in regions of low data density. As a result, this baseline fails to generate reasonable images, as shown by samples in Appendix~\ref{app:baseline}.

For quantitative evaluation, we report inception~\cite{salimans2016improved} and FID~\cite{heusel2017gans} scores on CIFAR-10 in \tabref{tab:score}. As an \emph{unconditional} model, we achieve the state-of-the-art inception score of 8.87, which is even better than most reported values for \emph{class-conditional} generative models. Our FID score 25.32 on CIFAR-10 is also comparable to top existing models, such as SNGAN~\cite{miyato2018spectral}. We omit scores on MNIST and CelebA as the scores on these two datasets are not widely reported, and different preprocessing (such as the center crop size of CelebA) can lead to numbers not directly comparable.

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/inpainting.png}
    \caption{Image inpainting on CelebA (\textbf{left}) and CIFAR-10 (\textbf{right}). The leftmost column of each figure shows the occluded images, while the rightmost column shows the original images.}
    \label{fig:inpainting}
\end{figure}
\paragraph{Image inpainting} In \figref{fig:inpainting}, we demonstrate that our score networks learn generalizable and semantically meaningful image representations that allow it to produce diverse image inpaintings. Note that some previous models such as PixelCNN can only impute images in the raster scan order. In contrast, our method can naturally handle images with occlusions of arbitrary shapes by a simple modification of the annealed Langevin dynamics procedure (details in Appendix~\ref{app:inpainting_algo}). We provide more image inpainting results in Appendix~\ref{app:inpainting}. 


 \section{Related work}

Our approach has some similarities with methods that learn the transition operator of a Markov chain for sample generation~\cite{bengio2013generalized,sohl2015deep,bordes2017learning,goyal2017variational,song2017nice}. For example, generative stochastic networks (GSN~\cite{bengio2013generalized,alain2016gsn}) use denoising autoencoders to train a Markov chain whose equilibrium distribution matches the data distribution. Similarly, our method trains the score function used in Langevin dynamics to sample from the data distribution. However, GSN often starts the chain very close to a training data point, and therefore requires the chain to transition quickly between different modes. In contrast, our annealed Langevin dynamics are initialized from unstructured noise. Nonequilibrium Thermodynamics (NET~\cite{sohl2015deep}) used a prescribed diffusion process to slowly transform data into random noise, and then learned to reverse this procedure by training an inverse diffusion. However, NET is not very scalable because it requires the diffusion process to have very small steps, and needs to simulate chains with thousands of steps at training time.


Previous approaches such as Infusion Training (IT~\cite{bordes2017learning}) and Variational Walkback (VW~\cite{goyal2017variational}) also employed different noise levels/temperatures 
for training transition operators of a Markov chain. Both IT and VW (as well as NET) train their models by maximizing the evidence lower bound of a suitable marginal likelihood.   
In practice, they tend to produce blurry image samples, similar to variational autoencoders. In contrast, our objective is based on score matching instead of likelihood, and we can produce images comparable to GANs.

There are several structural differences that further distinguish our approach from previous methods discussed above. First, \emph{we do not need to sample from a Markov chain during training}. In contrast, the walkback procedure of GSNs needs multiple runs of the chain to generate ``negative samples''. Other methods including NET, IT, and VW also need to simulate a Markov chain for every input to compute the training loss. This difference makes our approach more efficient and scalable for training deep models. Secondly, \emph{our training and sampling methods are decoupled from each other}. For score estimation, both sliced and denoising score matching can be used. For sampling, any method based on scores is applicable, including Langevin dynamics and (potentially) Hamiltonian Monte Carlo~\cite{neal2012mcmc}. Our framework allows arbitrary combinations of score estimators and (gradient-based) sampling approaches, whereas most previous methods tie the model to a specific Markov chain. Finally, \emph{our approach can be used to train energy-based models (EBM)} by using the gradient of an energy-based model as the score model. In contrast, it is unclear how previous methods that learn transition operators of Markov chains can be directly used for training EBMs.

Score matching was originally proposed for learning EBMs. However, many existing methods based on score matching are either not scalable~\cite{hyvarinen2005estimation} or fail to produce samples of comparable quality to VAEs or GANs~\cite{kingma2010regularized,saremi2018deep}. To obtain better performance on training deep energy-based models, some recent works have resorted to contrastive divergence~\cite{hinton2002training}, and propose to sample with Langevin dynamics for both training and testing~\cite{du2019implicit,nijkamp2019anatomy}. However, unlike our approach, contrastive divergence uses the computationally expensive procedure of Langevin dynamics as an inner loop during training. The idea of combining annealing with denoising score matching has also been investigated in previous work under different contexts. In \cite{geras2014scheduled,chandra2014adaptive,zhang2018convolutional}, different annealing schedules on the noise for training denoising autoencoders are proposed. However, their work is on learning representations for improving the performance of classification, instead of generative modeling. The method of denoising score matching can also be derived from the perspective of Bayes least squares~\cite{raphan2007learning,raphan2011least}, using techniques of Stein's Unbiased Risk Estimator~\cite{miyasawa1961empirical,stein1981estimation}.

 \section{Conclusion}
We propose the framework of score-based generative modeling where we first estimate gradients of data densities via score matching, and then generate samples via Langevin dynamics. We analyze several challenges faced by a na\"{i}ve application of this approach, and propose to tackle them by training Noise Conditional Score Networks (NCSN) and sampling with annealed Langevin dynamics. Our approach requires no adversarial training, no MCMC sampling during training, and no special model architectures. Experimentally, we show that our approach can generate high quality images that were previously only produced by the best likelihood-based models and GANs. We achieve the new state-of-the-art inception score on CIFAR-10, and an FID score comparable to SNGANs. 

\subsection*{Acknowledgements}
Toyota Research Institute ("TRI")  provided funds to assist the authors with their research but this article solely reflects the opinions and conclusions of its authors and not TRI or any other Toyota entity. This research was also supported by NSF (\#1651565, \#1522054, \#1733686), ONR  (N00014-19-1-2145), AFOSR (FA9550-19-1-0024). \bibliography{sgn}
\newpage
\appendix
\section{Architectures}\label{app:arch}
The architecture of our NCSNs used in the experiments has three important components: instance normalization, dilated convolutions and U-Net-type architectures. Below we give more background on them and discuss how we modified them to suit our purpose. For more comprehensive details and a reference implementation, we recommend the readers to check our publicly available code base. Our score networks are implemented in \texttt{PyTorch}. Code and checkpoints are available at \href{https://github.com/ermongroup/ncsn}{\color{cyan} https://github.com/ermongroup/ncsn}.
\subsection{Instance normalization} 
We use conditional instance normalization~\cite{dumoulin2017learned-iclr} so that  takes account of  when predicting the scores. In conditional instance normalization, a different set of scales and biases is used for different . More specifically, suppose  is an input with  feature maps. Let  and  denote the mean and standard deviation of the -th feature map of , taken along the spatial axes. Conditional instance normalization is achieved by

where  and  are learnable parameters,  denotes the index of feature maps, and  denotes the index of  in . 

However, one downside of instance normalization is that it completely removes the information of  for different feature maps. This can lead to shifted colors in the generated images. To fix this issue, we propose a simple modification to conditional instance normalization. First, we compute the mean and standard deviation of 's and denote them as  and  respectively. Then, we add another learnable parameter . The modified conditional instance normalization is defined as

We abbreviate this modification of conditional instance normalization as CondInstanceNorm++. In our architecture, we add CondInstanceNorm++ before every convolutional layer and pooling layer.

\subsection{Dilated convolutions}
Dilated convolutions can be used to increase the size of receptive field while maintaining the resolution of feature maps. It has been shown very effective in semantic segmentation because they preserve the location information better using feature maps of larger resolutions. In our architecture design of NCSNs, we use it to replace all the subsampling layers except the first one.

\subsection{U-Net architecture} 
U-Net is an architecture with special skip connections. These skip connections help transfer lower level information in shallow layers to deeper layers of the network. Since the shallower layers often contain low level information such as location and shape, these skip connections help improve the result of semantic segmentation. For building , we use the architecture of RefineNet~\cite{lin2017refinenet}, a modern variant of U-Net that also incorporates ResNet designs. We refer the readers to \cite{lin2017refinenet} for a detailed description of the RefineNet architecture.

In our experiments, we use a 4-cascaded RefineNet. We use pre-activation residual blocks. We remove all batch normalizations in the RefineNet architecture, and replace them with CondInstanceNorm++. We replace the max pooling layers in Refine Blocks with average pooling, as average pooling is reported to produce smoother images for image generation tasks such as style transfer. In addition, we also add CondInstanceNorm++ before each convolution and average pooling in the Refine Blocks, although no normalization is used in the original Refine Blocks. All activation functions are chosen to be ELU. As mentioned previously, we use dilated convolutions to replace the subsampling layers in residual blocks, except the first one. Following the common practice, we increase the dilation by a factor of 2 when proceeding to the next cascade. For CelebA and CIFAR-10 experiments, the number of filters for layers corresponding to the first cascade is 128, while the number of filters for other cascades are doubled. For MNIST experiments, the number of filters are halved. 


\section{Additional experimental details} \label{app:exp}
\subsection{Toy experiments}\label{app:exp:toy}
For the results in \figref{fig:manifold}, we train a ResNet with sliced score matching on CIFAR-10. We use pre-activation residual blocks, and the ResNet is structured as an auto-encoder, where the encoder contains 5 residual blocks and the decoder mirrors the architecture of the encoder. The number of filters for each residual block of the encoder part is respectively 32, 64, 64, 128 and 128. The 2nd and 4th residual block of the encoder subsamples the feature maps by a factor of two. We use ELU activations throughout the network. We train the network with 50000 iterations using Adam optimizer and a batch size of 128 and learning rate of 0.001. The experiment was run on one Titan XP GPU.

For the results in \figref{fig:low_density}, we choose . The score network is a 3-layer MLP with 128 hidden units and softplus activation functions. We train the score network with sliced score matching for 10000 iterations with Adam optimizer. The learning rate is 0.001, and the batch size is 128. The experiment was run on an Intel Core i7 GPU with 2.7GHz.

For the results in \figref{fig:anneal}, we use the same toy distribution . We generate 1280 samples for each subfigure of \figref{fig:anneal}. The initial samples are all uniformly chosen in the square . For Langevin dynamics, we use  and . For annealed Langevin dynamics, we use ,  and . We choose  to be a geometric progression, with ,  and . Both Langevin methods use the ground-truth data score for sampling. The experiment was run on an Intel Core i7 GPU with 2.7GHz.

\subsection{Image generation}
During training, we randomly flip the images in CelebA and CIFAR-10. All models are optimized by Adam with learning rate  for a total of 200000 iterations. The batch size is fixed to 128. We save one checkpoint every 5000 iterations. For MNIST, we choose the last checkpoint at the 200000-th training iteration. For selecting our CIFAR-10 and CelebA models, we generate 1000 images for each checkpoint and choose the one with the smallest FID score computed on these 1000 images. Our image samples and results in \tabref{tab:score} are from these checkpoints. Similar model selection procedures have been used in previous work, such as ProgressiveGAN~\cite{karras2018progressive}.

The inception and FID scores are computed using the official code from OpenAI \footnote{\href{https://github.com/openai/improved-gan/tree/master/inception_score}{\color{cyan}https://github.com/openai/improved-gan/tree/master/inception\_score}}~\cite{salimans2016improved} and TTUR~\cite{heusel2017gans} authors \footnote{\href{https://github.com/bioinf-jku/TTUR}{\color{cyan}https://github.com/bioinf-jku/TTUR}} respectively. The architectures are described in Appendix~\ref{app:arch}. When reporting the numbers in \tabref{tab:score}, we compute inception and FID scores based on a total of 50000 samples.

The baseline model uses the same score network. The only difference is that the score network is only conditioned on one noise level . When sampling using Langevin dynamics, we use  and .

The models on MNIST were run with one Titan XP GPU, while the models on CelebA and CIFAR-10 used two Titan XP GPUs.
\subsection{Image inpainting}\label{app:inpainting_algo}
We use the following \algoref{alg:inpaint} for image inpainting.

\begin{algorithm}[h]
	\caption{Inpainting with annealed Langevin dynamics.}
	\label{alg:inpaint}
	\begin{algorithmic}[1]
	    \Require{} \Comment{ is smallest step size;  is the number of iteration for each noise level.}
	    \Require{} \Comment{ is a mask to indicate regions not occluded;  is the given image.}
	    \State{Initialize }
	    \For{ to }
	        \State{} \Comment{ is the step size.}
	        \State{Draw }
	        \State{}
            \For{ to }
                \State{Draw }
                \State{}
                \State{}
            \EndFor
            \State{}
        \EndFor
        \item[]
        \Return{}
	\end{algorithmic}
\end{algorithm}
The hyperparameters are the same as those of the annealed Langevin dynamics used for image generation.

\newpage
\section{Samples}\label{app:samples}
\subsection{Samples from the baseline models}\label{app:baseline}
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_mnist_samples.jpg}
        \caption{MNIST}
        \label{fig:baseline_mnist}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_celeba_samples.jpg}
        \caption{CelebA}
        \label{fig:baseline_celeba}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_cifar10_samples.jpg}
        \caption{CIFAR-10}
        \label{fig:baseline_cifar10}
    \end{subfigure}
    \caption{Uncurated samples on MNIST, CelebA, and CIFAR-10 datasets from the baseline model.}
    \label{fig:baseline_samples}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_mnist_sampling.jpg}
        \caption{MNIST}
        \label{fig:baseline_mnist_p}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_celeba_sampling.jpg}
        \caption{CelebA}
        \label{fig:baseline_celeba_p}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/baselines/baseline_cifar10_sampling.jpg}
        \caption{CIFAR-10}
        \label{fig:baseline_cifar10_p}
    \end{subfigure}
    \caption{Intermediate samples from Langevin dynamics for the baseline model.}
    \label{fig:baseline_samples_procedure}
\end{figure}
\FloatBarrier
\vfill
\newpage
\subsection{Nearest neighbors}\label{app:nn}
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/nn_l2.png}
    \caption{Nearest neighbors measured by the  distance between images. Images on the left of the red vertical line are samples from NCSN. Images on the right are nearest neighbors in the training dataset.}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/nn_inception.png}
    \caption{Nearest neighbors measured by the  distance in the feature space of an Inception V3 network pretrained on ImageNet. Images on the left of the red vertical line are samples from NCSN. Images on the right are nearest neighbors in the training dataset.}
\end{figure}
\FloatBarrier
\vfill
\newpage

\subsection{Extended samples}
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_samples/mnist_samples_large.jpg}
    \caption{Extended MNIST samples}
    \label{fig:mnist_large}
\end{figure}
\FloatBarrier
\vfill
\newpage
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_samples/celeba_samples_large.jpg}
    \caption{Extended CelebA samples}
    \label{fig:celeba_large}
\end{figure}
\FloatBarrier
\vfill
\newpage
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_samples/cifar10_samples_large.jpg}
    \caption{Extended CIFAR-10 samples}
    \label{fig:cifar10_large}
\end{figure}
\FloatBarrier
\vfill
\newpage
\subsection{Extended intermediate samples from annealed Langevin dynamics}
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_sampling/celeba_sampling_large.jpg}
    \caption{Extended intermediate samples from annealed Langevin dynamics for CelebA.}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_sampling/cifar10_sampling_large.jpg}
    \caption{Extended intermediate samples from annealed Langevin dynamics for CelebA.}
\end{figure}
\FloatBarrier
\vfill
\newpage
\subsection{Extended image inpainting results}\label{app:inpainting}
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_inpaint/celeba_inpainting_large.jpg}
    \caption{Extended image inpainting results for CelebA. The leftmost column of each figure shows the occluded images, while the rightmost column shows the original images.}
\end{figure}
\FloatBarrier
\vfill
\newpage
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{diagrams/large_inpaint/cifar10_inpainting_large.jpg}
    \caption{Extended image inpainting results for CIFAR-10. The leftmost column of each figure shows the occluded images, while the rightmost column shows the original images.}
\end{figure}
\FloatBarrier
\vfill \end{document}
