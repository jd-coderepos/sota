\documentclass[proceedings]{stacs}
\stacsheading{2009}{51--62}{Freiburg}
\firstpageno{51}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pstricks,pst-node,pstricks-add}
\usepackage{enumerate}

\usepackage{stmaryrd,mathrsfs}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{times}


\theoremstyle{plain}\newtheorem{satz}[thm]{Satz}
\theoremstyle{definition}\newtheorem{crucial}[thm]{Crucial Definition}




\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}


\newcommand{\rnc}{\renewcommand}
\newcommand{\nev}{\newenvironment}
\newcommand*{\und}{\ensuremath{\wedge}}
\newcommand*{\Und}{\ensuremath{\bigwedge}}
\newcommand*{\oder}{\ensuremath{\vee}}
\newcommand*{\Oder}{\ensuremath{\bigvee}}
\newcommand*{\nicht}{\ensuremath{\neg}}
\newcommand*{\impl}{\ensuremath{\rightarrow}}
\newcommand*{\gdw}{\ensuremath{\leftrightarrow}}

\newcommand*{\Fertig}{{}\hfill \ensuremath{\square}}
\newcommand*{\Qed} {\null\hfill\ensuremath{\blacksquare}}


\newcommand{\bigO}{\ensuremath{{O}}}

\newcommand{\aufgerundet}[1]{\ensuremath{\left\lceil {#1} \right\rceil}}
\newcommand{\abgerundet}[1]{\ensuremath{\left\lfloor {#1} \right\rfloor}}

\newcommand{\ov}[1]{\overline{#1}}
\newcommand{\vek}[1]{\vec{#1}}
\newcommand{\bigvek}[1]{\overrightarrow{#1}}


\renewcommand*{\geq}{\ensuremath{\geqslant}}
\renewcommand*{\leq}{\ensuremath{\leqslant}}


\newcommand{\twodots}{.\,.\,}
\newcommand{\deff}{:=}
\newcommand{\parno}{\par\noindent}
\newcommand{\raus}[1]{}

\newcommand{\fertig}{\Fertig}
\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\NNpos}{\ensuremath{\NN_{\scriptscriptstyle\geq 1}}}

\newcommand{\set}[1]{\ensuremath{\{ #1 \}}}
\newcommand{\setc}[2]{\set{ #1 : #2}}
\newcommand{\bigset}[1]{\ensuremath{\left\{ #1 \right\}}}
\newcommand{\bigsetc}[2]{\bigset{ #1 : #2}}

\newcommand*{\A}{\ensuremath{\mathcal{A}}}
\newcommand*{\B}{\ensuremath{\mathcal{B}}}
\newcommand*{\C}{\ensuremath{\mathcal{C}}}
\newcommand*{\D}{\ensuremath{\mathcal{D}}}
\newcommand*{\Q}{\ensuremath{\mathcal{Q}}}


\newenvironment{mi}{\begin{itemize}}{\end{itemize}}
\newenvironment{me}{\begin{enumerate}}{\end{enumerate}}
\newenvironment{mea}{\begin{enumerate}[\mbox{\quad }(a)]}{\end{enumerate}}

\newcommand{\myparagraph}[1]{\subsubsection*{{\bf #1}}}


\newcommand{\nicole}[1]{\marginpar{\scriptsize\textbf{to do:} #1}}




\newcommand{\DI}{\ensuremath{\mathbb{D}}}
\newcommand{\Disj}{\ensuremath{\textit{Disj}}}

\newcommand{\aut}{\text{mp2s-automaton}}
\newcommand{\auta}{\text{mp2s-automata}}

\newcommand{\kf}{\ensuremath{k_{\scriptscriptstyle f}}}
\newcommand{\kb}{\ensuremath{k_{\scriptscriptstyle b}}}

\newcommand{\start}{\ensuremath{\textsl{start}}}
\newcommand{\accept}{\ensuremath{\textsl{accept}}}
\newcommand{\reject}{\ensuremath{\textsl{reject}}}

\newcommand{\adv}{\ensuremath{\textsl{advance}}}
\newcommand{\stay}{\ensuremath{\textsl{stay}}}

\newcommand{\eos}{\ensuremath{\textsl{end}}}

\newcommand{\vv}{\ensuremath{v}}

\newcommand{\config}{\ensuremath{\textit{config}}}

\begin{document}
\title[Lower Bounds for Multi-Pass Processing of Multiple Data Streams]
{Lower Bounds for Multi-Pass Processing of \\ Multiple Data Streams}

\author{Nicole Schweikardt}{Nicole Schweikardt}
\address{Institut f\"ur Informatik, 
  Goethe-Universit\"at Frankfurt am Main, \newline
  Robert-Mayer-Str.\ 11--15, D-60325 Frankfurt am Main, 
  Germany}  \email{schweika@informatik.uni-frankfurt.de}  \urladdr{http://www.informatik.uni-frankfurt.de/\~{}schweika}  



\keywords{data streams, lower bounds, machine models, automata, the set disjointness problem}
\subjclass{
 F.1.1 (Computation by Abstract Devices: Models of Computation); \\
 F.2.2 (Analysis of Algorithms and Problem Complexity: Nonnumerical Algorithms and Problems); \\
 F.2.3 (Analysis of Algorithms and Problem Complexity: Tradeoffs between Complexity Measures)
}
\vspace{-1ex}







\begin{abstract}
  \noindent 
  This paper gives a brief overview of computation models for data stream processing, and
  it introduces a new model for multi-pass processing of
  multiple streams, the so-called \emph{\auta{}}. Two algorithms for solving the 
  set disjointness problem with these automata are presented.
  The main technical contribution of this paper is the proof of a 
  lower bound on the size of memory and the number of heads that are
  required for solving the set disjointness problem with \auta{}.
\end{abstract}

\maketitle






\section{Introduction}\label{section:introduction}


In the basic data stream model, the input consists of a stream of data items 
which can be read only sequentially, one after the other.
For processing these data items, a memory buffer of limited size is available.
When designing data stream algorithms, one aims at 
algorithms whose memory size is far smaller than the size of the input.

Typical application areas for which
data stream processing is relevant are, e.g., 
IP network traffic analysis, mining text message streams, or processing
meteorological data generated by sensor networks.
Data stream algorithms are also used to support query optimization
in relational database systems.
In fact, virtually all query optimization methods in 
relational database systems rely on information about
the number of distinct values of an attribute or the self-join size of a relation 
--- and these pieces of information have to be maintained while the database is updated. 
Data stream algorithms for accomplishing this task have been introduced in the seminal
paper \cite{alomatsze99}.



Most parts of the data stream literature deal with the task of performing
\textbf{one pass over a single stream}. For a detailed overview
on algorithmic techniques for this scenario we refer to \cite{Muthukrishnan-DataStream-Algos}.
 \emph{Lower bounds} on the size of  memory needed for solving a problem by a 
one-pass algorithm are usually obtained by applying methods from 
\emph{communication complexity} 
(see, e.g., \cite{alomatsze99,henragraj99}).
In fact, for many concrete problems it is known that the memory needed 
for solving the problem by a deterministic one-pass algorithm is at 
least linear in the size  of the input.
For some of these problems, however,
\emph{randomized} one-pass algorithms can still compute good \emph{approximate} answers 
while using memory of size sublinear in .
Typically, such algorithms are based on \emph{sampling}, 
i.e., only a ``representative'' portion of the data is taken into account, 
and \emph{random projections}, i.e., only a rough ``sketch'' of the data is stored in memory.
See \cite{Muthukrishnan-DataStream-Algos,ChristianSohler-Survey} for a comprehensive survey 
of according algorithmic techniques and for pointers to the literature.

Also the generalization where \textbf{multiple passes over a single stream} are performed, 
has received considerable attention in the literature. 
Techniques for proving lower bounds in this scenario can be found, 
e.g., in 
\cite{henragraj99,GuhaMcGregor-ICALP08,DBLP:journals/dcg/ChanC07,DBLP:conf/focs/GalG07,munpat80}.


A few articles also deal with the task of \textbf{processing several streams in parallel}.
For example, the authors of \cite{Shalem-BarYossef-icde2008} consider 
algorithms which perform one pass over several streams.
They introduce a new model of multi-party communication complexity that is suitable for
proving lower bounds 
on the amount of memory necessary for one-pass algorithms on multiple
streams.
In \cite{Shalem-BarYossef-icde2008}, these results are used for determining 
the exact space complexity of processing particular XML twig queries.
\\
In recent years, the database community has also addressed the issue of 
designing general-purpose \emph{data stream management systems}
and query languages that are suitable for new application areas where multiple data streams
have to be processed in parallel. To get an overview of this research area, 
\cite{bbdmw02} is a good starting point. Foundations for a theory of \emph{stream queries}
have been laid in \cite{DBLP:conf/dbpl/GurevichLB07}.
Stream-based approaches have also
been examined in detail in connection with \emph{XML query processing and validation},
see, e.g.\ the papers \cite{SegoufinVianu_PODS02,SegoufinSirangelo_ICDT07,SuciuEtAl_TODS04,ChanFelberEtAl-VLDBJ2002,barfonjos04,barfonjos05,grokocschwe05a}.


The \emph{finite cursor machines} (FCMs, for short) of 
\cite{FCM-paper} are a computation model for performing
\textbf{multiple passes over multiple streams}.
FCMs were introduced as an abstract model of database query processing. 
Formally, they are defined in the framework of 
\emph{abstract state machines}.
Informally, they can be described as follows:
The input for an FCM is a relational database, each relation of which is 
represented by a \emph{table}, i.e., an ordered list of rows, where each 
row corresponds to a tuple in the relation.
Data elements are viewed as
``indivisible'' objects that can be manipulated by a number of ``built-in'' operations. 
This feature is very convenient to model standard operations on data types 
like integers, floating point numbers,
or strings, which may all be part of the universe of data elements.
FCMs can operate in a finite number of \emph{modes} using an 
\emph{internal memory} in which they can
store bitstrings. They access each relation through a finite number of 
\emph{cursors}, each of which can read one row of a table at any time.
The model incorporates certain \emph{streaming} or \emph{sequential processing} 
aspects by imposing a restriction on the movement of the cursors: 
They can move on the tables only sequentially in one direction. 
Thus, once the last cursor has left a row of a table, 
this row can never be accessed again during the computation.
Note, however, that several cursors can be moved asynchronously over the same table 
at the same time, and thus, entries in different, possibly far apart, 
regions of the table can be read and processed simultaneously.

A common feature of the computation models mentioned so far in this paper is that the
input streams are \emph{read-only} streams that cannot be modified during a
pass. Recently, also
\textbf{stream-based models for external memory processing}
have been proposed, among them 
the \emph{StrSort model} \cite{aggdatrajruh04,Ruhl-PhD}, 
the \emph{W-Stream} model \cite{WStream-Paper}, and the
model of \emph{read/write streams} 
\cite{groschwe05a,grokocschwe05a,groherschwe06,BJR-STOC07,BH-FOCS08}.
In these models, several passes may be performed over a single stream or over
several streams in parallel, and during a pass, the content of the stream may be
modified.
\\
\par

A detailed introduction to \emph{algorithms on data streams}, respectively, to the 
related area of \emph{sublinear algorithms} can be found in
\cite{Muthukrishnan-DataStream-Algos,ChristianSohler-Survey}.
A survey of \emph{stream-based models for external memory processing} and of 
methods for proving 
\emph{lower bounds} in these models is given in \cite{Schweikardt-PODS07survey}.
A database systems oriented overview of so-called \emph{data stream systems} can
be found in \cite{bbdmw02}.
For a list of \emph{open problems} in the area of data streams we refer to
\cite{Kanpur-2006-ListOfOpenProblems}.
\\
\par

In the remainder of this article, a new computation model for multi-pass processing
of multiple streams is introduced: the \emph{\auta{}}. 
In this model,
(read-only) streams can be processed by forward scans as well as 
backward scans, and several ``heads'' can be used to perform several passes 
over the streams in parallel. 
After fixing the basic notation in Section~\ref{section:preliminaries}, the computation
model of \auta{} is introduced in Section~\ref{section:mpms-automata}.
In Section~\ref{section:main-result}, we consider the \emph{set disjointness problem} 
and prove upper bounds as well as lower bounds
on the size of memory and the number of heads that are necessary for solving
this problem with an \aut{}.
Section~\ref{section:conclusion} concludes the paper by pointing out some directions
for future research.


\section{Basic notation}\label{section:preliminaries}

If  is a function from the set of non-negative integers to the set
of reals, we shortly write  instead of  (where
 denotes the smallest integer ).
We write  to denote the logarithm of  with respect to base 2.
For a set  we write  to denote the set of all 
finite strings over alphabet . We view   as 
the set of all finite \emph{data streams} that can be built from 
elements in .
For a stream  write  to denote the
length of , and we write  to denote the element 
in  that occurs at the -th position in , i.e., 
.


\section{A computation model for multi-pass processing of multiple streams}
\label{section:mpms-automata}

In this section, we fix a computation model for multi-pass processing
of multiple streams. 
The model is quite powerful: 
Streams can be processed by forward scans as well as backward scans, and
several ``heads'' can be used to perform several passes over the stream 
in parallel.
For simplicity, we restrict attention to the case
where just \emph{two} streams are processed in parallel.
Note, however, that it is straightforward to generalize the model to an
arbitrary number of streams.

The computation model, called
\emph{\auta}\footnote{\emph{``mp2s''} stands for 
\underline{m}ulti-\underline{p}ass processing of \underline{2} 
\underline{s}treams}, can be described as follows:
Let  be a set, and let  be integers with 
 and .
An \vspace{1ex} 
\begin{center}
  \emph{\aut{}  with parameters }  \vspace{1ex}
\end{center}
receives as input two streams  and .
The automaton's memory consists of  different states
(note that this corresponds to a memory buffer consisting of 
 bits). The automaton's state space is denoted by .
We assume that  contains a designated \emph{start state} and
that there is a designated subset  of  of 
so-called \emph{accepting states}.

On each of the input streams  and , the automaton
has  heads that process the stream from left to right 
(so-called \emph{forward heads}) and  heads that process the stream 
from right to left (so-called \emph{backward heads}).
The heads are allowed to move asynchronously.
We use  to denote the total number of heads, i.e., .

\begin{figure}[h!tbp]
 \begin{center}
  \fbox{\vek{S}\vek{T}Q\lg m}\caption{The meaning of the parameters  of an \aut.}
 \end{center}
\end{figure}

In the \emph{initial configuration} of  on input ,
the automaton is in the \emph{start state},
all \emph{forward} heads on  and  are placed on the leftmost
element in the stream, i.e.,  resp.\ , and all
\emph{backward} heads are placed on the rightmost element in the stream, 
i.e.,  resp.\ . 

During each computation step, depending on
(a) the current state (i.e., the current content of the automaton's
memory) and (b) the elements of  and  at the 
current head positions,
a deterministic transition function determines
(1) the next state (i.e., the new content of the automaton's memory) 
and (2) which of the  heads should be advanced to the 
next position (where forward heads are advanced one step to the right, and
backward heads are advanced one step to the left). Formally, the 
transition function can be specified in a straightforward way by a function 
 
where  denotes the automaton's state space, and  is a special
symbol (not belonging to ) which indicates that a head has 
reached the end of the stream (for a forward head this means that the
head has been advanced beyond the rightmost element of the stream, and for
a backward head this means that the head has been advanced beyond the
leftmost element of the stream).

The automaton's computation on input  ends as soon as
each head has passed the entire stream. The input is \emph{accepted} if the
automaton's state then belongs to the set  of accepting states, and
it is \emph{rejected} otherwise.
\\
\par

The computation model of \auta{} is closely related to the \emph{finite 
cursor machines} of \cite{FCM-paper}. In both models, several streams can
be processed in parallel, and several heads (or, ``cursors'')
may be used to perform several ``asynchronous'' passes over the same stream in 
parallel. In contrast to the \auta{} of the present paper, finite cursor machines
were introduced as an abstract model for database query processing, and their
formal definition in \cite{FCM-paper} is presented in the framework of 
\emph{abstract state machines}.

Note that \auta{} can be viewed as a generalization of other models for 
one-pass or multi-pass processing of streams.
For example, the scenario of \cite{Shalem-BarYossef-icde2008}, where a single
pass over two streams is performed, is captured by an \aut{} where
1~forward head and no backward heads are available on each stream. 
Also, the scenario where  consecutive passes
of each input stream are available (cf., e.g., \cite{henragraj99}), can 
be implemented by an
\aut{}: just use  forward heads and  backward heads, and let
the -th head wait at the first position of the stream until the
-th head has reached the end of the stream.




\section{The set disjointness problem}\label{section:main-result}

Throughout Section~\ref{section:main-result} we consider a particular
version of the \emph{set disjointness problem} where, 
for each integer , 
\  \
is a fixed set of  data items.
We write  to denote the following decision problem:
The input consists of two streams  and  over 
with .
The goal is to decide whether the sets  and 
 are disjoint.

An \aut{} \emph{solves} the problem  if, for all valid
inputs to  (i.e., all  with ),
it accepts the input if, and only if, the corresponding
sets are disjoint.


\subsection{Two upper bounds for the set disjointness problem}\label{subsec:upperbounds}

It is straightforward to see that the problem  can be solved
by an \aut{} with ~states and a single forward head on each of the
two input streams: During a first phase, the
head on  processes  and stores, in the automaton's
current state, the subset of  that has been seen while processing .
Afterwards, the head on  processes  and checks whether
the element currently seen by this head belongs to the subset of  that
is stored in the automaton's state. 
Clearly,  states suffice for this task, since . We thus
obtain the following trivial upper bound:

\begin{proposition}\label{prop:upper-bound-trivial}
  can be solved by an \aut{} with parameters
 .
\end{proposition}

The following result shows that, at the expense of increasing the number 
of forward heads on each stream to , the memory consumption can
be reduced exponentially:

\begin{proposition}\label{prop:upper-bound-sqrt}
  can be solved by an \aut{} with parameters
 .\footnote{To be precise, the proof shows that already 
     states suffice.}
\end{proposition}
\begin{proof}
The automaton proceeds in two phases. 

The goal in \emph{Phase~1} is to move, 
for each , the -th head on  onto
the -th position in . 
This way, after having finished \emph{Phase~1}, the heads 
partition  into  sub-streams, each of
which has length .
Note that  states suffice for accomplishing this: The automaton simply
stores, in its state, the current position of the rightmost head(s) on .
It starts by
leaving head~1 at position  and moving the remaining heads on 
to the right until position  is reached. 
Then, it leaves head~2 at position  and proceeds by moving the
remaining heads to the right until position  is reached, etc.

During \emph{Phase~2}, the automaton checks whether the two sets are disjoint.
This is done in  sub-phases. During the -th sub-phase, the
-th head on  processes  from left to right and compares
each element in  with the elements on the current positions of
the  heads on . When the -th head on  has 
reached the end of the stream, each of the heads on  is moved one
step to the right. This finishes the -th sub-phase.
Note that \emph{Phase~2} can be accomplished by using just 2 states:
By looking at the combination of heads on  that have already 
passed the entire stream, the automaton can tell which sub-phase it is 
currently performing. Thus, for \emph{Phase~2} we just need
one state for indicating that the automaton is in \emph{Phase~2}, 
and an additional state for storing that the
automaton has discovered already that the two sets are \emph{not} disjoint.
\end{proof}



\subsection{Two lower bounds for the set disjointness problem}\label{subsec:lowerbound}

We first show a lower bound for \auta{} where only forward heads are available:

\begin{theorem}\label{thm:lower-bound-forward}
 For all integers , , , such that,
 for \  \ and  \ ,
 
 the problem  cannot be solved 
 by any \aut{} with parameters .
\end{theorem}
\begin{proof}
Let , , and  
be chosen such that they meet the theorem's assumption.
For contradiction, let us assume that  is an \aut{} with parameters
 that solves the problem .

Recall that
\  \
is a fixed set of  data items.
Throughout the proof we will restrict attention to input streams  and
 which are enumerations of the elements in a set \vspace{1ex}

for arbitrary  and its complement
.
\\
Note that for all  we have \vspace{1ex}

For each  we let  be the stream of length 
which is defined as follows: For each , it carries  
data item  at position ; and for each , it carries data item  at
position .
The stream  contains the same data items as , but in the
opposite order: For each , it
carries data item  at position ; and for each , it carries
data item  at position .

For sets , we write  to denote the input instance
 and  for the problem .
From (\ref{equ:1}) and our assumption that the \aut{}  solves , we obtain 
that 

Throughout the remainder of this proof, our goal is to find two sets
 such that \vspace{1ex}
\begin{enumerate}
 \item
   , \ and \vspace{1ex}
 \item
   the accepting run of  on  is ``similar'' to the
   accepting run of  on , so that the two runs can be combined into
   an accepting run of  on  (later on in the proof, we will see
   what ``similar'' precisely means).
  \vspace{1ex}
\end{enumerate}
Then, however,
the fact that  accepts input  contradicts (\ref{equ:2}) and thus
finishes the proof of Theorem~\ref{thm:lower-bound-forward}.

For accomplishing this goal, we let 

be 1 plus the number of pairs of heads on the two streams. We subdivide the set
 into  consecutive blocks  of equal size 
. I.e., for each , block  consists of the
indices in .

We say that a pair  of heads of  \emph{checks block } during the run
on input 
if, and only if, at some point in time during the run, there exist
 such that head  is on element
 or  in  and head  is on element
 or  in .

Note that each pair of heads can check at most one block, since only forward heads
are available and the data items in  are arranged in the reverse
order (with respect to the indices  of elements  and ) than in .
Since there are  blocks, but only  pairs  of heads on the
two streams, we know that for each  there exists
a block  that is \emph{not checked} during 's run on .

In the following, we determine a set 
 with  
such that for all , item (2) of our goal is satisfied.
We start by using a simple averaging argument to find a
 and 
a set 
such that \vspace{1ex}
\begin{mi}
 \item 
   for each , block  is not checked during 's run on input
   , \ and  \vspace{1ex}
 \item 
   . \vspace{1ex}
\end{mi}
For the remainder of the proof we fix .
\\
We next choose a sufficiently large set  in which everything outside
block  is fixed:\\
A simple averaging argument shows that there is a
 and a  such that
\vspace{1ex}
\begin{mi}
 \item
   for each , \ \ , \ \ and \vspace{1ex}
 \item 
   .
   \vspace{1ex}
\end{mi}
We next identify a set  such that for all  the runs of
 on  and  are ``similar'' in a sense suitable for
item~(2) of our goal. To this end, for each head  of  we let
 be the \emph{configuration} (i.e., the current state and the absolute
positions of all the heads) in the run of  on input  at the 
particular point in time where head  has just left block  (i.e., head
 has just left the last element  or  with  that it can
access).
We let  be the ordered tuple of the configurations  for all
heads  of .
Note that the number of possible configurations  is 
\ , since  has  states and since each of the
 heads can be at one out of  possible positions in its input stream.
Consequently, the number of possible -tuples  of configurations is 
\ .
\\
A simple averaging argument thus yields a tuple  of configurations and
a set  such that \vspace{1ex}
\begin{mi}
 \item 
   for all , \ , \ and \vspace{1ex}
 \item
    \vspace{1ex}
\end{mi}
Using the theorem's assumption on the 
numbers , , and , one obtains that .
Therefore, we can find two sets  with .

To finish the proof of Theorem~\ref{thm:lower-bound-forward}, it remains to show that
the runs of  on  and on  
can be combined into a run of  on  such that  (falsely) accepts
input . To this end let us summarize what we know about  and  in 
: \vspace{1ex}

\begin{mea}
 \item  and  only differ in block .
  \vspace{1ex}
 \item Block  is not checked during 's runs on  and 
   on . I.e., while any head on  (resp.\ ) is
   at an element  or  with , no head on 
   (resp.\ ) is on an element  or  with .
  \vspace{1ex}
 \item Considering 's runs on  and on , each
  time a head leaves the last position in  that it can access, both runs are 
  are in exactly the same configuration. I.e., they are in the same state, and all
  heads are at the same absolute positions in their input streams.
  \vspace{1ex}
\end{mea}

\noindent
Due to item~(a),
's run on input  starts in the same way as the runs on
 and : As long as no head has reached an element in
block , the automaton has not yet seen any difference between  on
the one hand and  and  on the other hand.

At some point in time, however, some head  will enter block , 
i.e., it will enter the first element  or  with  that 
it can access.
The situation then is as follows: \vspace{1ex}
\begin{mi}
 \item 
   If  is a head on , then, due to item~(b), no head on 
    is at an element in . 
   Therefore, until head  leaves block ,  will go through the 
   same sequence of configurations as in its run on input . 
   Item~(c) ensures that when  leaves block ,  is in the same configuration
   as in its runs on  and on .
  \vspace{1ex}
 \item
   Similarly, if  is a head on , then, due to item~(b), no head on 
    is at an element in . 
   Therefore, until head  leaves block ,  will go through the 
   same sequence of configurations as in its run on input . 
   Item~(c) ensures that when  leaves block ,  is in the same configuration
   as in its runs on  and on .
  \vspace{1ex}
\end{mi}

\noindent
In summary, in 's run on , each time a head  has just left the
last element in block  that it can access, it is in exactly the same 
configuration as in 's runs on  and on  at the points
in time where head  has just left the
last element in block  that it can access.
After the last head has left block , 's run on  finishes
in exactly the same way as 's runs on  and . 
In particular, it accepts  (since it accepts  and
). This, however, is a contradiction to (\ref{equ:2}).
Thus, the proof of Theorem~\ref{thm:lower-bound-forward} is complete.
\end{proof}

\medskip

\begin{remark}
Let us compare the lower bound from Theorem~\ref{thm:lower-bound-forward} 
with the upper bound of Proposition~\ref{prop:upper-bound-sqrt}: The upper bound
tells us that  can be solved by an \aut{} with  states and
 forward heads on each input stream. The lower bound
implies (for large enough ) that
if just  forward heads are available on each stream, not even
 states suffice for solving the problem  with an
\aut{}.
\end{remark}

\begin{remark}
A straightforward calculation shows that the assumptions of 
Theorem~\ref{thm:lower-bound-forward} are satisfied, for example,
for all sufficiently large 
integers  and all integers  and  with
\  \ and 
\ .
\end{remark}



\par

Theorem~\ref{thm:lower-bound-forward} can be generalized 
to the following lower bound for \auta{} where also backward heads are available:

\begin{theorem}\label{thm:lower-bound-general}
 For all , , ,  such that,
 for \  \ and  \ ,
 the problem  cannot be solved 
 by any \aut{} with parameters .
\end{theorem}
\begin{proof}
The overall structure of the proof is the same as in the proof of
Theorem~\ref{thm:lower-bound-forward}.
We consider the same sets , for all .
The stream  is chosen in the same way as in the proof of
Theorem~\ref{thm:lower-bound-forward}, i.e., 
for each , the stream  carries  
data item  at position ; and for each , it carries data item  at
position .

Similarly as in the proof of Theorem~\ref{thm:lower-bound-forward}, the
stream  contains the same data items as . Now, however, the
order in which the elements occur in  is a bit more elaborate.
For fixing this order, we choose the following parameters: \vspace{1ex}

We subdivide the set
 into  consecutive blocks  of equal size 
. I.e., for each , block  consists of the
indices in .
\\
Afterwards, we further subdivide each block  into  consecutive subblocks of 
equal size . These subblocks are denoted .
Thus, each subblock  consists of the indices in  
.

Now let  be the permutation of  which maps, for all  with
 and , \ element 
 \ onto \ element \ 
.
Thus,  maps elements in block  onto elements in block , and
inside these two blocks,  maps the elements of subblock  onto
elements in subblock . 
Note that  reverses the blocks  in order, but it does \emph{not} reverse the 
order of the subblocks .

Finally, we are ready to fix the order in which the elements in  occur in the
stream : For each , the stream  carries
data item  at position ; and for each , it carries
data item  at position .

In the same way as in the proof of Theorem~\ref{thm:lower-bound-forward}, we
write  to denote the input instance  and .

A pair of heads  is called \emph{mixed} if one of the heads is a
forward head and the other is a backward head.
Since  reverses the order of the blocks , 
it is straightforward to see that every \emph{non-mixed} pair of heads can
check at most one of the blocks . Since there are
 blocks, but only  non-mixed pairs of heads, we know that for
all  there exists a block  that is 
\emph{not checked} by any non-mixed pair of heads during 's run on input
.

The same averaging argument as in the proof of Theorem~\ref{thm:lower-bound-forward}
thus tells us that there is a
 and 
a set 
such that \vspace{1ex}
\begin{mi}
 \item 
   for each , block  is not checked by any non-mixed pair of
   heads during 's run on input
   , \ and  \vspace{1ex}
 \item 
   . \vspace{1ex}
\end{mi}
From our particular choice of , it is straightforward to see that every
\emph{mixed} pair of heads can check at most one of the subblocks
. Since there are  such subblocks, but
only  mixed pairs of heads, there must be a  
and a set  such that \vspace{1ex}
\begin{mi}
 \item 
   for each , subblock  is not checked by any pair of
   heads during 's run on input
   , \ and  \vspace{1ex}
 \item 
   . \vspace{1ex}
\end{mi}
For the remainder of the proof we fix , and we let
 denote the total number of heads. Using these notations, 
the rest of the proof can be taken vertatim from the proof of 
Theorem~\ref{thm:lower-bound-forward}.
\end{proof}


The proof of
Theorem~\ref{thm:lower-bound-general} is implicit in \cite{FCM-paper}
(see Theorem 5.11 in \cite{FCM-paper}). There, however, the proof is formulated
in the terminology of a different
machine model, the so-called \emph{finite cursor machines}.



\section{Final remarks}\label{section:conclusion}

Several questions concerning the computational power of 
\auta{} occur naturally. On a technical level, it would be nice
to determine the exact complexity of the set disjointness problem with
respect to \auta{}.
In particular: Is the upper bound provided by Proposition~\ref{prop:upper-bound-sqrt}
optimal?
Can backward scans significantly help for solving the set disjointness problem?
Are  heads really necessary for
solving the set disjointness problem when only a sub-exponential number of states
are available?


A more important task, however, is to consider also randomized versions
of \auta{}, to design efficient randomized approximation algorithms for particular
problems, and to develop techniques for proving lower bounds in the randomized model.


\myparagraph{Acknowledgement.}
I would like to thank Georg Schnitger for
helpful comments on an earlier version of this paper.


\begin{thebibliography}{10}

\bibitem{aggdatrajruh04}
G.~Aggarwal, M.~Datar, S.~Rajagopalan, and M.~Ruhl.
\newblock On the streaming model augmented with a sorting primitive.
\newblock In {\em Proc.\ FOCS'04}, pages 540--549, 2004.

\bibitem{alomatsze99}
N.~Alon, Y.~Matias, and M.~Szegedy.
\newblock The space complexity of approximating the frequency moments.
\newblock {\em Journal of Computer and System Sciences}, 58:137--147, 1999.

\bibitem{bbdmw02}
B.~Babcock, S.~Babu, M.~Datar, R.~Motwani, and J.~Widom.
\newblock Models and issues in data stream systems.
\newblock In {\em Proc.\ PODS'02}, pages 1--16, 2002.

\bibitem{barfonjos04}
Z.~Bar-Yossef, M.~Fontoura, and V.~Josifovski.
\newblock On the memory requirements of {XPath} evaluation over {XML} streams.
\newblock In {\em Proc.\ PODS'04}, pages 177--188, 2004.

\bibitem{barfonjos05}
Z.~Bar-Yossef, M.~Fontoura, and V.~Josifovski.
\newblock Buffering in query evaluation over {XML} streams.
\newblock In {\em Proc.\ PODS'05}, pages 216--227, 2005.

\bibitem{BH-FOCS08}
P.~Beame and D.-T. Huynh-Ngoc.
\newblock On the value of multiple read/write streams for approximating
  frequency moments.
\newblock In {\em Proc.\ FOCS'08}, 2008.

\bibitem{BJR-STOC07}
P.~Beame, T.~S. Jayram, and A.~Rudra.
\newblock Lower bounds for randomized read/write stream algorithms.
\newblock In {\em Proc.\ STOC'07}, pages 689--698, 2007.

\bibitem{ChanFelberEtAl-VLDBJ2002}
C.~Y. Chan, P.~Felber, M.~Garofalakis, and R.~Rastogi.
\newblock Efficient filtering of {XML} documents with {XPath} expressions.
\newblock {\em VLDB Journal}, 11(4):354--379, 2002.

\bibitem{DBLP:journals/dcg/ChanC07}
T.~M. Chan and E.~Y. Chen.
\newblock Multi-pass geometric algorithms.
\newblock {\em Discrete {\&} Computational Geometry}, 37(1):79--102, 2007.

\bibitem{ChristianSohler-Survey}
A.~Czumaj and C.~Sohler.
\newblock Subliner-time algorithms.
\newblock {\em Bulletin of the EATCS}, 89:23--47, 2006.

\bibitem{WStream-Paper}
C.~Demetrescu, I.~Finocchi, and A.~Ribichini.
\newblock Trading off space for passes in graph streaming problems.
\newblock In {\em Proc.\ SODA'06}, pages 714--723, 2006.

\bibitem{DBLP:conf/focs/GalG07}
A.~G{\'a}l and P.~Gopalan.
\newblock Lower bounds on streaming algorithms for approximating the length of
  the longest increasing subsequence.
\newblock In {\em Proc.\ FOCS'07}, pages 294--304, 2007.

\bibitem{SuciuEtAl_TODS04}
T.~Green, A.~Gupta, G.~Miklau, M.~Onizuka, and D.~Suciu.
\newblock Processing {XML} streams with deterministic automata and stream
  indexes.
\newblock {\em ACM Transactions on Database Systems}, 29(4):752--788, 2004.

\bibitem{FCM-paper}
M.~Grohe, Y.~Gurevich, D.~Leinders, N.~Schweikardt, J.~Tyszkiewicz, and J.~{Van
  den Bussche}.
\newblock Database query processing using finite cursor machines.
\newblock {\em Theory of Computing Systems}, 2009.
\newblock To appear. A preliminary version can be found in \emph{Proc.\
  ICDT'07}, pages 284--298.

\bibitem{groherschwe06}
M.~Grohe, A.~Hernich, and N.~Schweikardt.
\newblock Randomized computations on large data sets: Tight lower bounds.
\newblock In {\em Proc.\ PODS'06}, pages 243--252, 2006.
\newblock Full version available as CoRR Report, arXiv:cs.DB/0703081.

\bibitem{grokocschwe05a}
M.~Grohe, C.~Koch, and N.~Schweikardt.
\newblock Tight lower bounds for query processing on streaming and external
  memory data.
\newblock Accepted at \emph{Theoretical Computer Science}, special issue for
  selected papers from ICALP'05.

\bibitem{groschwe05a}
M.~Grohe and N.~Schweikardt.
\newblock Lower bounds for sorting with few random accesses to external memory.
\newblock In {\em Proc.\ PODS'05}, pages 238--249, 2005.

\bibitem{GuhaMcGregor-ICALP08}
S.~Guha and A.~McGregor.
\newblock Tight lower bounds for multi-pass stream computation via pass
  elimination.
\newblock In {\em Proc.\ ICALP'08}, pages 760--772, 2008.

\bibitem{DBLP:conf/dbpl/GurevichLB07}
Y.~Gurevich, D.~Leinders, and J.~{Van den Bussche}.
\newblock A theory of stream queries.
\newblock In {\em Proc.\ DBPL}, pages 153--168, 2007.

\bibitem{henragraj99}
M.~Henzinger, P.~Raghavan, and S.~Rajagopalan.
\newblock Computing on data streams.
\newblock In {\em External memory algorithms}, volume~50, pages 107--118.
  DIMACS Series in Discrete Mathematics and Theoretical Computer Science, 1999.

\bibitem{Kanpur-2006-ListOfOpenProblems}
A.~{McGregor et al.}
\newblock Open problems in data streams and related topics, December 2006.
\newblock IITK Workshop on Algorithms for Data Streams. 
  \url{http://www.cse.iitk.ac.in/users/sganguly/workshop.html}.

\bibitem{munpat80}
J.~Munro and M.~Paterson.
\newblock Selection and sorting with limited storage.
\newblock {\em Theoretical Computer Science}, 12:315--323, 1980.

\bibitem{Muthukrishnan-DataStream-Algos}
S.~Muthukrishnan.
\newblock Data {S}treams: {A}lgorithms and {A}pplications.
\newblock {\em Foundations and Trends in Theoretical Computer Science}, 1(2),
  2005.

\bibitem{Ruhl-PhD}
M.~Ruhl.
\newblock {\em Efficient Algorithms for New Computational Models}.
\newblock PhD thesis, Massachusetts Institute of Technology, 2003.

\bibitem{Schweikardt-PODS07survey}
N.~Schweikardt.
\newblock Machine models and lower bounds for query processing.
\newblock In {\em Proc.\ PODS'07}, pages 41--52, 2007.

\bibitem{SegoufinSirangelo_ICDT07}
L.~Segoufin and C.~Sirangelo.
\newblock Constant-memory validation of streaming {XML} documents against
  {DTDs}.
\newblock In {\em Proc.\ ICDT'07}, pages 299--313, 2007.

\bibitem{SegoufinVianu_PODS02}
L.~Segoufin and V.~Vianu.
\newblock Validating streaming {XML} documents.
\newblock In {\em Proc.\ PODS'02}, pages 53--64, 2002.

\bibitem{Shalem-BarYossef-icde2008}
M.~Shalem and Z.~Bar-Yossef.
\newblock The space complexity of processing {XML} twig queries over indexed
  documents.
\newblock In {\em Proc.\ ICDE'08}, pages 824--832, 2008.

\newpage
\phantom{.}
\end{thebibliography}


\end{document}
