\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}






\usepackage[final]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         

\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{flushend}

\usepackage[ruled,linesnumbered]{algorithm2e}


\title{ResT: An Efficient Transformer for Visual Recognition}



\author{Qing-Long Zhang, Yu-Bin Yang\thanks{This work is funded by the Natural Science Foundation of China (No. 62176119).} \\
  State Key Laboratory for Novel Software Technology\\
  Nanjing University, Nanjing 21023, China\\
  \texttt{wofmanaf@smail.nju.edu.cn, yangyubin@nju.edu.cn} \\
}

\begin{document}

\maketitle

\begin{abstract}
This paper presents an efficient multi-scale vision Transformer, called ResT, that capably served as a general-purpose backbone for image recognition. Unlike existing Transformer methods, which employ standard Transformer blocks to tackle raw images with a fixed resolution, our ResT have several advantages: (1) A memory-efficient multi-head self-attention is built, which compresses the memory by a simple depth-wise convolution, and projects the interaction across the attention-heads dimension while keeping the diversity ability of multi-heads; (2) Positional encoding is constructed as spatial attention, which is more flexible and can tackle with input images of arbitrary size without interpolation or fine-tune; (3) Instead of the straightforward tokenization at the beginning of each stage, we design the patch embedding as a stack of overlapping convolution operation with stride on the token map. We comprehensively validate ResT on image classification and downstream tasks. Experimental results show that the proposed ResT can outperform the recently state-of-the-art backbones by a large margin, demonstrating the potential of ResT as strong backbones. The code and models will be made publicly available at https://github.com/wofmanaf/ResT.
\end{abstract}

\section{Introduction}
\label{sec:intro}
Deep learning backbone architectures have been evolved for years and boost the performance of computer vision tasks such as classification~\cite{DBLP:journals/corr/abs-2010-11929,DBLP:journals/corr/abs-2012-12877,DBLP:journals/corr/abs-2101-11986,DBLP:conf/cvpr/HeZRS16}, object detection~\cite{DBLP:conf/eccv/CarionMSUKZ20,DBLP:journals/corr/abs-2010-04159,DBLP:conf/iccv/LinGGHD17,DBLP:journals/corr/abs-2006-09214}, and instance segmentation~\cite{DBLP:conf/iccv/HeGDG17,DBLP:conf/eccv/TianSC20,DBLP:journals/corr/abs-2003-10152}, etc.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.70\linewidth]{fig_1}
	\end{center}
	\caption{Examples of backbone blocks. \textbf{Left:} A standard ResNet Bottleneck Block~\cite{DBLP:conf/cvpr/HeZRS16}. \textbf{Middle:} A Standard Transformer Block. \textbf{Right:} The proposed Efficient Transformer Block. The only difference compared with standard Transformer block is the replacement of the Multi-Head Self-Attention (MSA) with Efficient Multi-head Self-Attention (EMSA).}
	\label{fig:figure1}
\end{figure}

There are mainly two types of backbone architectures most commonly applied in computer vision: convolutional network (CNN) architectures~\cite{DBLP:conf/cvpr/HeZRS16,DBLP:journals/corr/abs-2102-00240} and Transformer ones~\cite{DBLP:journals/corr/abs-2010-11929,DBLP:journals/corr/abs-2101-11986}. Both of them capture feature information by stacking multiple blocks. The CNN block is generally a bottleneck structure~\cite{DBLP:conf/cvpr/HeZRS16}, which can be defined as a stack of , , and  convolution layers with residual learning (shown in Figure~\ref{fig:figure1}a). The  layers are responsible for reducing and then increasing channel dimensions, leaving the  layer a bottleneck with smaller input/output channel dimensions. The CNN backbones are generally faster and require less inference time thanks to parameter sharing, local information aggregation, and dimension reduction. However, due to the limited and fixed receptive field, CNN blocks may be less effective in scenarios that require modeling long-range dependencies. For example, in instance segmentation, being able to collect and associate scene information from a large neighborhood can be useful in learning relationships across objects~\cite{DBLP:journals/corr/abs-2101-11605}. 

To overcome these limitations, Transformer backbones are recently explored for their ability to capture long-distance information~\cite{DBLP:journals/corr/abs-2010-11929,DBLP:journals/corr/abs-2101-11986,DBLP:journals/corr/abs-2012-12877,DBLP:journals/corr/abs-2103-14030}. Unlike CNN backbones, the Transformer ones first split an image into a sequence of patches (i.e., tokens), then sum these tokens with positional encoding to represent coarse spatial information, and finally adopt a stack of Transformer blocks to capture feature information. A standard Transformer block~\cite{DBLP:conf/nips/VaswaniSPUJGKP17} comprises a multi-head self-attention (MSA) that employs a query-key-value decomposition to model global relationships between sequence tokens, and a feed-forward network (FFN) to learn wider representations (shown in Figure~\ref{fig:figure1}b). As a result, Transformer blocks can dynamically adapt the receptive field according to the image content.



Despite showing great potential than CNNs, the Transformer backbones still have four major shortcomings: 
(1) It is difficult to extract the low-level features which form some fundamental structures in images (e.g., corners and edges) since existing Transformer backbones direct perform tokenization of patches from raw input images.
(2) The memory and computation for MSA in Transformer blocks scale quadratically with spatial or embedding dimensions (i.e., the number of channels), causing vast overheads for training and inference.
(3) Each head in MSA is responsible for only a subset of embedding dimensions, which may impair the performance of the network, particularly when the tokens embedding dimension (for each head) is short, making the dot product of query and key unable to constitute an informative function.  
(4) The input tokens and positional encoding in existing Transformer backbones are all of a fixed scale, which are unsuitable for vision tasks that require dense prediction. 





\begin{figure*}[htb]
	\begin{center}
		\includegraphics[width=1.0\linewidth]{fig_3}
	\end{center}
	\caption{The pipeline of the proposed ResT. Similar to ResNet~\cite{DBLP:conf/cvpr/HeZRS16}, ResT build stages with stacked blocks, making it flexible to serve as the backbone of downstream tasks, such as Object detection, Person ReID, and Instance Segmentation, etc.}
	\label{fig:figure3}
\end{figure*}

In this paper, we proposed an efficient general-purpose backbone ResT (named after ResNet~\cite{DBLP:conf/cvpr/HeZRS16}) for computer vision, which can remedy the above issues. As illustrated in Figure~\ref{fig:figure3}, ResT shares exactly the same pipeline of ResNet, i.e., a stem module applied for extracting low-level information and strengthening locality, followed by four stages to construct hierarchical feature maps, and finally a head module for classification. Each stage consists of a patch embedding, a positional encoding module, and multiple Transformer blocks with specific spatial resolution and channel dimension. 
The patch embedding module creates a multi-scale pyramid of features by hierarchically expanding the channel capacity while reducing the spatial resolution with overlapping convolution operations. Unlike the conventional methods which can only tackle images with a fixed scale, our positional encoding module is constructed as spatial attention which is conditioned on the local neighborhood of the input token. By doing this, the proposed method is more flexible and can process input images of arbitrary size without interpolation or fine-tune. Besides, to improve the efficiency of the MSA, we build an efficient multi-head self-attention (EMSA), which significantly reduce the computation cost by a simple overlapping Depth-wise Conv2d. In addition, we compensate short-length limitations of the input token for each head by projecting the interaction across the attention-heads dimension while keeping the diversity ability of multi-heads.



We comprehensively validate the effectiveness of the proposed ResT on the commonly used benchmarks, including image classification on ImageNet-1k and downstream tasks, such as object detection, and instance segmentation on MS COCO2017.
Experimental results demonstrate the effectiveness and generalization ability of the proposed ResT compared with the recently state-of-the-art Vision Transformers and CNNs. For example, with a similar model size as ResNet-18 (69.7\%) and PVT-Tiny (75.1\%), our ResT-Small obtains a Top-1 accuracy of 79.6\% on ImageNet-1k.







\section{ResT}
\label{sec:rest}
As illustrated in Figure~\ref{fig:figure3}, ResT shares exactly the same pipeline as ResNet~\cite{DBLP:conf/cvpr/HeZRS16}, i.e., a stem module applied to extract low-level information, followed by four stages to capture multi-scale feature maps. Each stage consists of three components, one patch embedding module (or stem module), one positional encoding module, and a set of  efficient Transformer blocks. Specifically, at the beginning of each stage, the patch embedding module is adopted to reduce the resolution of the input token and expanding the channel dimension. The positional encoding module is fused to restrain position information and strengthen the feature extracting ability of patch embedding. After that, the input token is fed to the efficient Transformer blocks (illustrated in Figure~\ref{fig:figure1}c). In the following sections, we will introduce the intuition behind ResT.

\subsection{Rethinking of Transformer Block}
\label{sec:3.1}
The standard Transformer block consists of two sub-layers of MSA and FFN. A residual connection is employed around each sub-layer. Before MSA and FFN, layer normalization (LN~\cite{DBLP:journals/corr/BaKH16}) is applied. For a token input , where ,  indicates the spatial dimension, channel dimension, respectively. The output for each Transformer block is:


\textbf{MSA.} 
MSA first obtains query \textbf{Q}, key \textbf{K}, and value \textbf{V} by applying three sets of projections to the input, each consisting of  linear layers (i.e., heads) that map the  dimensional input into a  dimensional space, where  is the head dimension. For the convenience of description, we assume , then MSA can be simplified to single-head self-attention (SA). The global relationship between the token sequence can be defined as

The output values of each head are then concatenated and linearly projected to form the final output. The computation costs of MSA are , which scale quadratically with spatial dimension or embedding dimensions according to the input token. 

\textbf{FFN.}
The FFN is applied for feature transformation and non-linearity. It consists of two linear layers with a non-linearity activation. The first layer expands the embedding dimensions of the input from  to  and the second layer reduce the dimensions from  to . 

where  and  are weights of the two Linear layers respectively,  and  are the bias terms, and  is the activation function GELU~\cite{DBLP:journals/corr/HendrycksG16}. In standard Transformer block, the channel dimensions are expanded by a factor of 4, i.e., . The computation costs of FFN are .


\subsection{Efficient Transformer Block}
\label{sec:3.2}



As analyzed above, MSA has two shortcomings: (1) The computation scales quadratically with  or  according to the input token, causing vast overheads for training and inference; (2) Each head in MSA only responsible for a subset of embedding dimensions, which may impair the performance of the network, particularly when the tokens embedding dimension (for each head) is short.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[width=0.50\linewidth]{fig_4}
	\end{center}
	\caption{Efficient Multi-Head Self-Attention.}
	\label{fig:figure4}
\end{figure}

To remedy these issues, we propose an efficient multi-head self-attention module (illustrated in Figure~\ref{fig:figure4}). Here, we make some explanations. 

(1) Similar to MSA, EMSA first adopt a set of projections to obtain query \textbf{Q}. 

(2) To compress memory, the 2D input token  is reshaped to 3D one along the spatial dimension (i.e., ) and then feed to a depth-wise convolution operation to reduce the height and width dimension by a factor . To make simple,  is adaptive set by the feature map size or the stage number. The kernel size, stride and padding are , , and  respectively. 

(3) The new token map after spatial reduction  is then reshaped to 2D one, i.e., , . Then  is feed to two sets of projection to get key  and value .

(4) After that, we adopt Eq.~\ref{eq:eqs} to compute the attention function on query \textbf{Q}, \textbf{K} and value \textbf{V}.

Here,  is a standard  convolutional operation, which model the interactions among different heads. As a result, attention function of each head can depend on all of the keys and queries. However, this will impair the ability of MSA to jointly attend to information from different representation subsets at different positions. To restore this diversity ability, we add an Instance Normalization~\cite{DBLP:journals/corr/UlyanovVL16} (i.e, IN()) for the dot product matrix (after Softmax).

(5) Finally, the output values of each head are then concatenated and linearly projected to form the final output.

The computation costs of EMSA are , much lower than the original MSA (assume ), particularly in lower stages, where  is tend to higher.

Also, we add FFN after EMSA for feature transformation and non-linearity. The output for each efficient Transformer block is:


\subsection{Patch Embedding}
\label{sec:3.3}
The standard Transformer receives a sequence of token embeddings as input. Take ViT~\cite{DBLP:journals/corr/abs-2010-11929} as an example, the input image  is split with a patch size of . These patches are flattened into 2D ones and then mapped to latent embeddings with a size of , i.e, , where . However, this straightforward tokenization is failed to capture low-level feature information (such as edges and corners)~\cite{DBLP:journals/corr/abs-2101-11986}. In addition, the length of tokens in ViT are all of a fixed size in different blocks, making it unsuitable for downstream vision tasks such as object detection and instance segmentation that require multi-scale feature map representations.

Here, we build an efficient multi-scale backbone, calling ResT, for dense prediction. As introduced above, the efficient Transformer block in each stage operates on the same scale with identical resolution across the channel and spatial dimensions. Therefore, the patch embedding modules are required to progressively expand the channel dimension, while simultaneously reducing the spatial resolution throughout the network. 

Similar to ResNet, the stem module (can be seen as the first patch embedding module) are adopted to shrunk both the height and width dimension with a reduction factor of 4. To effectively capture the low-feature information with few parameters, here we introduce a simple but effective way, i.e, stacking three  standard convolution layers (all with padding 1) with stride 2, stride 1, and stride 2, respectively. Batch Normalization~\cite{DBLP:conf/icml/IoffeS15} and ReLU activation \cite{DBLP:journals/jmlr/GlorotBB11} are applied for the first two layers. In stage 2, stage 3, and stage 4, the patch embedding module is adopted to down-sample the spatial dimension by  and increase the channel dimension by . This can be done by a standard  convolution with stride 2 and padding 1. For example, patch embedding module in stage 2 changes resolution from  to  (shown in Figure~\ref{fig:figure3}). 


\subsection{Positional Encoding}
\label{sec:3.4}
Positional encodings are crucial to exploiting the order of sequence. In ViT~\cite{DBLP:journals/corr/abs-2010-11929}, a set of learnable parameters are added into the input tokens to encode positions. Let  be the input,  be position parameters, then the encoded input can be represent as

However, the length of positions is exactly the same as the input tokens length, which limits the application scenarios.   

\begin{wrapfigure}{r}{0.36\textwidth}
	\vspace{-30pt}
	\begin{center}
		\includegraphics[width=0.8\linewidth]{fig_2}
	\end{center}
	\caption{Patch and PE in ResT.}
	\label{fig:figure2}
\end{wrapfigure}

To remedy this issue, the new positional encodings are required to have variable lengths according to input tokens. Let us look closer to Eq.~\ref{eq:eq5}, the summation operation is much like assigning pixel-wise weights to the input. Assume  is related with , i.e., , where  is the group linear operation with the group number of . Then Eq.~\ref{eq:eq5} can be modified to
 


Besides Eq.~\ref{eq:eq6},  can also be obtained by more flexible spatial attention mechanisms. Here, we propose a simple yet effective spatial attention module calling PA(pixel-attention) to encode positions. Specifically, PA applies a  depth-wise convolution (with padding 1) operation to get the pixel-wise weight and then scaled by a sigmoid function . The positional encoding with PA module can then be represented as
 

Since the input token in each stage is also obtained by a convolution operation, we can embed the positional encoding into the patch embedding module. The whole structure of stage  can be illustrated in Figure~\ref{fig:figure2}. Note that PA can be replaced by any spatial attention modules, making the positional encoding flexible in ResT.


\subsection{Classification Head}
The classification head is performed by a global average pooling layer on the output feature map of the last stage, followed by a linear classifier. The detailed ResT architecture for ImageNet-1k is shown in Table~\ref{tab:tab1}, which contains four models, i.e., ResT-Lite, ResT-Small and ResT-Base and ResT-Large, which are bench-marked to ResNet-18, ResNet-18, ResNet-50, and ResNet-101, respectively. 

\begin{table*}[htb]
	\caption{Architectures for ImageNet-1k. Here, we make some definitions. ``" means convolution layers with kernel size , output channel  and stride . ``" is the FFN structure with hidden channel  and output channel . And ``" is the EMSA operation with the number of heads  and reduction . ``C" is 64 for ResT-Lite and ResT-Small, and 96 for ResT-Base and ResT-Large.``PA" is short for pixel-wise attention, which are introduced in Section~\ref{sec:3.4}.}
	\label{tab:tab1}
	\begin{center}
		\resizebox{1.0\linewidth}{!}{
		\setlength{\tabcolsep}{2.0pt}{
			\begin{tabular}{c|c|c|c|c|c}
				\toprule[1.2pt]
				Name & Output & Lite & Small & Base & Large \\
				\midrule[1.1pt]
				stem & 56  56  & \multicolumn{4}{c}{patch\_embed: Conv-3\_C/2\_2, Conv-3\_C/2\_1, Conv-3\_C\_2,PA}\\
				\midrule
				\multirow{1}{*}{stage1} & \multirow{1}{*}{56  56}  &  
				&   
				& 	
				&  \\		
				\midrule
				
				\multirow{4}{*}{stage2} & \multirow{4}{*}{28  28} & \multicolumn{4}{c}{patch\_embed: Conv-3\_2C\_2, PA} \\
				\cmidrule{3-6}
				& &  
				&   
				& 
				&  \\
				\midrule
				
				\multirow{4}{*}{stage3} & \multirow{4}{*}{14  14} & \multicolumn{4}{c}{patch\_embed: Conv-3\_4C\_2, PA} \\
				\cmidrule{3-6}
				& &  
				&   
				& 
				&  \\
				\midrule
				
				\multirow{3}{*}{stage4} & \multirow{3}{*}{7  7} & \multicolumn{4}{c}{patch\_embed: Conv-3\_8C\_2, PA} \\
				\cmidrule{3-6}
				& &  
				&   
				& 
				&  \\
				\midrule				
				
				Classifier &  & \multicolumn{4}{c}{average pool, 1000d fully-connected} \\
				\midrule
				\multicolumn{2}{c|}{GFLOPs} & 1.4 & 1.94 &  4.26 & 7.91 \\
				\bottomrule[1.2pt]
			\end{tabular}
		}
	}
	\end{center}
\end{table*}

\section{Experiments}
\label{sec:exp}

In this section, we conduct experiments on common-used benchmarks, including ImageNet-1k for classification, MS COCO2017 for object detection, and instance segmentation. In the following subsections, we first compared the proposed ResT with the previous state-of-the-arts on the three tasks. Then we adopt ablation studies to validate the important design elements of ResT.

\subsection{Image Classification on ImageNet-1k}
\textbf{Settings.} For image classification, we benchmark the proposed ResT on ImageNet-1k, which contains 1.28M training images and 50k validation images from 1,000 classes. The setting mostly follows ~\cite{DBLP:journals/corr/abs-2012-12877}. Specifically, we employ the AdamW~\cite{DBLP:conf/iclr/LoshchilovH19} optimizer
for 300 epochs using a cosine decay learning rate scheduler and 5 epochs of linear warm-up. A batch size of 2048 (using 8 GPUs with 256 images per GPU), an initial learning rate of 5e-4, a weight decay of 0.05, and gradient clipping with a max norm of 5 are used. We include most of the augmentation and regularization strategies of ~\cite{DBLP:journals/corr/abs-2012-12877} in training, including RandAugment~\cite{DBLP:conf/nips/CubukZS020}, Mixup~\cite{DBLP:conf/iclr/ZhangCDL18}, Cutmix~\cite{DBLP:conf/iccv/YunHCOYC19}, Random erasing~\cite{DBLP:conf/aaai/Zhong0KL020}, and stochastic depth~\cite{DBLP:conf/eccv/HuangSLSW16}. An increasing degree of stochastic depth augmentation is employed for larger models, i.e., 0.1, 0.1, 0.2, 0.3 for ResT-Lite, Rest-Small, ResT-Base, and ResT-Large, respectively. For the testing on the validation set, the shorter side of an input image is first resized to 256, and a center crop of 224 × 224 is used for evaluation.

\begin{table*}[htb]
	\caption{Comparison with state-of-the-art backbones on ImageNet-1k benchmark. Throughput (images / s) is measured on a single V100 GPU, following ~\cite{DBLP:journals/corr/abs-2012-12877}. All models are trained and evaluated on 224224 resolution. The best records and the improvements over bench-marked ResNets are marked in \textbf{bold} and \textcolor[rgb]{ 0,  0,  1}{blue}, respectively.}
	\label{tab:tab2}
		\setlength{\tabcolsep}{6.0pt}{
	\begin{center}
		\begin{tabular}{c|c|c|c|c|c}
			\toprule[1.2pt]
			Model & \#Params (M) & FLOPs (G) & Throughput & Top-1 (\%) & Top-5 (\%) \\
			\midrule[1.1pt]
			\multicolumn{6}{c}{ConvNet} \\
			\midrule
			ResNet-18~\cite{DBLP:conf/cvpr/HeZRS16} & 11.7  & 1.8 & 1852 & 69.7  & 89.1  \\ 
			ResNet-50~\cite{DBLP:conf/cvpr/HeZRS16} & 25.6  & 4.1 & 871 & 79.0  & 94.4  \\ 
			ResNet-101~\cite{DBLP:conf/cvpr/HeZRS16} & 44.7  & 7.9 & 635 & 80.3  & 95.2  \\ 
			\midrule
			RegNetY-4G~\cite{DBLP:conf/cvpr/RadosavovicKGHD20} & 20.6 & 4.0 & 1156 & 79.4 & 94.7 \\ 
			RegNetY-8G~\cite{DBLP:conf/cvpr/RadosavovicKGHD20} &39.2 & 8.0 & 591 & 79.9  & 94.9 \\ 
			RegNetY-16G~\cite{DBLP:conf/cvpr/RadosavovicKGHD20} & 83.6 & 15.9 & 334 & 80.4  & 95.1 \\
			\midrule
			\multicolumn{6}{c}{Transformer} \\		 
			\midrule
			DeiT-S~\cite{DBLP:journals/corr/abs-2012-12877} & 22.1  & 4.6 & 940 & 79.8 & 94.9  \\ 
			DeiT-B~\cite{DBLP:journals/corr/abs-2012-12877} & 86.6  & 17.6 &292 & 81.8  & 95.6  \\ 
			\midrule
			PVT-T~\cite{wang2021pyramid} & 13.2  & 1.9 & 1038 & 75.1  & 92.4  \\ 
			PVT-S~\cite{wang2021pyramid} & 24.5  & 3.7 & 820 & 79.8  & 94.9  \\ 
			PVT-M~\cite{wang2021pyramid} & 44.2  & 6.4 & 526 & 81.2  & 95.6  \\ 
			PVT-L~\cite{wang2021pyramid} & 61.4  & 9.5 & 367 & 81.7  & 95.9  \\ 
			\midrule
			Swin-T~\cite{DBLP:journals/corr/abs-2103-14030} & 28.29 & 4.5  & 755 & 81.3 & 95.5 \\ 
			Swin-S~\cite{DBLP:journals/corr/abs-2103-14030} & 49.61 & 8.7 & 437 & 83.3 & 96.2 \\ 
			Swin-B~\cite{DBLP:journals/corr/abs-2103-14030} & 87.77 & 15.4 & 278 & 83.5 & 96.5 \\ 
			\midrule
			\textbf{ResT-Lite (Ours)} & 10.49 & 1.4 & 1246 & \textbf{77.2 (\textcolor[rgb]{ 0,  0,  1}{})} & \textbf{93.7 (\textcolor[rgb]{ 0,  0,  1}{})} \\ 
			\textbf{ResT-Small (Ours)} & 13.66 & 1.9 & 1043 & \textbf{79.6 (\textcolor[rgb]{ 0,  0,  1}{})} & \textbf{94.9 (\textcolor[rgb]{ 0,  0,  1}{})} \\ 
			\textbf{ResT-Base (Ours)} & 30.28 & 4.3 & 673 & \textbf{81.6 (\textcolor[rgb]{ 0,  0,  1}{})} & \textbf{95.7 (\textcolor[rgb]{ 0,  0,  1}{})} \\ 
			\textbf{ResT-Large (Ours)} & 51.63 & 7.9 & 429 & \textbf{83.6 (\textcolor[rgb]{ 0,  0,  1}{})} & \textbf{96.3 (\textcolor[rgb]{ 0,  0,  1}{})} \\ 
			\bottomrule[1.2pt]
		\end{tabular}
	\end{center}
		}
\end{table*}

\textbf{Results.} Table ~\ref{tab:tab2} presents comparisons to other backbones, including both Transformer-based ones and ConvNet-based ones. We can see, compared to the previous state-of-the-art Transformer-based architectures with similar model complexity, the proposed ResT achieves significant improvement by a large margin. For example, for smaller models, ResT noticeably surpass the counterpart PVT architectures with similar complexities: +4.5\% for ResT-Small (79.6\%) over PVT-T (75.1\%). For larger models, ResT also significantly outperform the counterpart Swin architectures with similar complexities: +0.3\% for ResT-Base (81.6\%) over Swin-T (81.3\%), and +0.3\% for ResT-Large (83.6\%) over Swin-S(83.3\%) using  input.

Compared with the state-of-the-art ConvNets, i.e., RegNet, the ResT with similar model complexity also achieves better performance: an average improvement of 1.7\% in terms of Top-1 Accuracy. Note that RegNet is trained via thorough architecture search, the proposed ResT is adapted from the standard Transformer and has strong potential for further improvement.

\subsection{Object Detection and Instance Segmentation on COCO}
\label{sec:obj}
\textbf{Settings.} Object detection and instance segmentation experiments are conducted on COCO 2017, which contains 118k training, 5k validation, and 20k test-dev images. We evaluate the performance of ResT using two representative frameworks: RetinaNet~\cite{DBLP:conf/iccv/LinGGHD17} and Mask RCNN~\cite{DBLP:conf/iccv/HeGDG17}. For these two frameworks, we utilize the same settings: multi-scale training (resizing the input such that the shorter side is between 480 and 800 while the longer side is at most 1333), AdamW~\cite{DBLP:conf/iclr/LoshchilovH19} optimizer (initial learning rate of 1e-4, weight decay of 0.05, and batch size of 16), and  schedule (12 epochs).  Unlike CNN backbones, which adopt post normalization and can directly apply to downstream tasks. ResT employs the pre-normalization strategy to accelerate network convergence, which means the output of each stage is not normalized before feeding to FPN~\cite{DBLP:conf/cvpr/LinDGHHB17}. Here, we add a layer normalization (LN~\cite{DBLP:journals/corr/BaKH16}) for the output of each stage (before FPN~\cite{DBLP:conf/cvpr/LinDGHHB17}), similar to Swin~\cite{DBLP:journals/corr/abs-2103-14030}.
Results are reported on the validation split.

\textbf{Object Detection Results.} Table~\ref{tab:tab3} lists the results of RetinaNet with different backbones. From these results, it can be seen that for smaller models, ResT-Small is +3.6 box AP higher (40.3 vs. 36.7) than PVT-T with a similar computation cost. For larger models, our ResT-Base surpassing the PVT-S by +1.6 box AP.

\begin{table*}[htb]
	\caption{Object detection performance on the COCO val2017 split using the RetinaNet framework.}
	\label{tab:tab3}
	\setlength{\tabcolsep}{8.8pt}{
		\begin{center}
			\begin{tabular}{c|cccccc|c}
				\toprule[1.2pt]
				Backbones & AP50:95 & AP50 & AP75 & APs & APm & APl & Param (M) \\ 
				\midrule[1.1pt]
				R18 \cite{DBLP:conf/cvpr/HeZRS16} & 31.8  & 49.6  & 33.6  & 16.3  & 34.3  & 43.2 & 21.3 \\ 
				PVT-T \cite{wang2021pyramid} & 36.7  & 56.9  & 38.9  & 22.6  & 38.8  & 50.0 & 23.0 \\ 
				\textbf{ResT-Small(Ours)} & \textbf{40.3} & 61.3 & 42.7 & 25.7 & 43.7 & 51.2 & 23.4 \\ 
				\midrule
				R50 \cite{DBLP:conf/cvpr/HeZRS16} & 37.4  & 56.7  & 40.3  & 23.1  & 41.6  & 48.3 & 37.9 \\ 
				PVT-S \cite{wang2021pyramid} & 40.4  & 61.3  & 43.0  & 25.0  & 42.9  & 55.7 & 34.2 \\
				Swin-T~\cite{DBLP:journals/corr/abs-2103-14030} & 41.5  & 62.1  & 44.1  & 27.0  & 44.2  & 53.2 & 38.5  \\  
				\textbf{ResT-Base (Ours)} & \textbf{42.0} & 63.2 & 44.8 & 29.1 & 45.3 & 53.3 & 40.5 \\ 
				\midrule
				R101 \cite{DBLP:conf/cvpr/HeZRS16} & 38.5  & 57.8  & 41.2  & 21.4  & 42.6  & 51.1 & 56.9 \\ 
				PVT-M \cite{wang2021pyramid} & 41.9  & 63.1  & 44.3  & 25.0  & 44.9  & 57.6 & 53.9 \\
				Swin-S~\cite{DBLP:journals/corr/abs-2103-14030} & 44.5  & 65.7  & 47.5  & 27.4  & 48.0  & 59.9 & 59.8  \\  
				\textbf{ResT-Large (Ours)} & \textbf{44.8} & 66.1 & 48.0 & 28.3 & 48.7 & 60.3 & 61.8 \\ 
				\bottomrule[1.2pt]
			\end{tabular}
		\end{center}
	}
\end{table*}

\textbf{Instance Segmentation Results.} Table~\ref{tab:tab4} compares the results of ResT with those of previous state-of-the-art models on the Mask RCNN framework. Rest-Small exceeds PVT-T by +2.9 box AP and +2.1 mask AP on the COCO val2017 split. As for larger models, ResT-Base brings consistent +1.2 and +0.9 gains over PVT-S in terms of box AP and mask AP, with slightly larger model size. 


\begin{table*}[htb]
	\caption{Object detection and instance segmentation performance on the COCO val2017 split using Mask RCNN framework.}
	\label{tab:tab4}
	\setlength{\tabcolsep}{6.0pt}{
		\begin{center}
			\begin{tabular}{c|ccc|ccc|c}
				\toprule[1.2pt]
				Backbones &  &  &  &  &  &  & Param (M) \\ 
				\midrule[1.1pt]
				R18 \cite{DBLP:conf/cvpr/HeZRS16} & 34.0  & 54.0  & 36.7  & 31.2  & 51.0  & 32.7 & 31.2 \\ 
				PVT-T \cite{wang2021pyramid} & 36.7  & 59.2  & 39.3  & 35.1  & 56.7  & 37.3 & 32.9  \\ 
				\textbf{ResT-Small(Ours)} & \textbf{39.6} & 62.9 & 42.3 & \textbf{37.2} & 59.8 & 39.7 & 33.3 \\ 
				\midrule
				R50 \cite{DBLP:conf/cvpr/HeZRS16} & 38.6  & 59.5  & 42.1  & 35.2  & 56.3  & 37.5 & 44.3 \\ 
				PVT-S \cite{wang2021pyramid} & 40.4  & 62.9  & 43.8  & 37.8  & 60.1  & 40.3 & 44.1  \\ 
				\textbf{ResT-Base(Ours)} & \textbf{41.6} & 64.9 & 45.1 & \textbf{38.7} & 61.6 & 41.4 & 49.8 \\ 
				\bottomrule[1.2pt]
			\end{tabular}
		\end{center}
	}
\end{table*}

\subsection{Ablation Study}
\label{sec: ablation}
In this section, we report the ablation studies of the proposed ResT, using ImageNet-1k image classification. To thoroughly investigate the important design elements, we only adopt the simplest data augmentation and hyper-parameters settings in ~\cite{DBLP:conf/cvpr/HeZRS16}. Specifically, the input images are randomly cropped to 224 × 224 with random horizontal flipping. All the architectures of ResT-Lite are trained with SGD optimizer (with weight decay 1e-4 and momentum 0.9) for 100 epochs, starting from the initial learning rate of  (with a linear warm-up of 5 epochs) and decreasing it by a factor of 10 every 30 epochs. Also, a batch size of 2048 (using 8 GPUs with 256 images per GPU) is used.

\textbf{Different types of stem module.}
Here, we test three type of stem modules: (1) the first patch embedding module in PVT~\cite{wang2021pyramid}, i.e.,  convolution operation with stride 4 and no padding; (2) the stem module in ResNet~\cite{DBLP:conf/cvpr/HeZRS16}, i.e., one  convolution layer with stride 2 and padding 3, followed by one  max-pooling layer; (3) the stem module in the proposed ResT, i.e., three  convolutional layers (all with padding 1) with stride 2, stride 1, and stride 2, respectively. We report the results in Table~\ref{tab:tab5}. The stem module in the proposed ResT is more effective than that in PVT and ResNet: +0.92\% and +0.64\% improvements in terms of Top-1 accuracy, respectively. 


\begin{table*}[htb]
	\begin{minipage}{0.49\linewidth}
		\centering
		\caption{Comparison of various stem modules on ResT-Lite. Results show that the proposed stem module is more effective than existing ones in PVT and ResNet.}
		\label{tab:tab5}
\begin{tabular}{ccc}
			\toprule[1.2pt]
			Stem & Top-1 (\%) & Top-5 (\%) \\ 
			\midrule[1.1pt]
			PVT~\cite{wang2021pyramid} & 71.96 & 89.87 \\ 
			\midrule
			ResNet~\cite{DBLP:conf/cvpr/HeZRS16}& 72.24 & 90.17 \\
			\midrule
			ResT (Ours) & 72.88  & 90.62  \\ 
			\bottomrule[1.2pt]
		\end{tabular}


	\end{minipage}
	\hfill
	\begin{minipage}{0.49\linewidth}
	\centering
	\caption{Comparison of different reduction strategies of EMSA on ResT-Lite. Results show that Average Pooling can be an alternative to Depth-wise Conv2d to make a trade-off.}
	\label{tab:ta9}
	\centering
	\begin{tabular}{ccc}
		\toprule[1.2pt]
		Reduction & Top-1 (\%) & Top-5 (\%) \\ 
		\midrule[1.1pt]
		DWConv & 72.88 & 90.62 \\ 
		\midrule
		Avg Pooling & 72.64 & 90.41 \\
		\midrule
		Max Pooling & 72.20 & 89.97 \\
		\bottomrule[1.2pt]
	\end{tabular}
\end{minipage}
\end{table*}

\textbf{Ablation study on EMSA.} As shown in Figure!\ref{fig:figure4}, we adopt a Depth-wise Conv2d to reduce the computation of MSA. Here, we provide the comparison of more strategies with the same reduction stride . Results are shown in Table~\ref{tab:ta9}. As can be seen, average pooling achieves slightly worse results (-0.24\%) compared with the original Depth-wise Conv2d, while the results of the Max Pooling strategy are the worst. Since the pooling operation introduces no extra parameters, therefore, average pooling can be an alternative to Depth-wise Conv2d in practice. 


\begin{table*}[htb]
	\begin{minipage}{0.49\linewidth}  
	\centering
	\caption{Ablation study results on the important design elements of EMSA on ResT-Lite, including the  convolution operation and Instance Normalization in Eq.~\ref{eq:eqs}.}
	\label{tab:tab7}
\begin{tabular}{ccc}
		\toprule[1.2pt]
		Methods & Top-1 (\%) & Top-5 (\%) \\
		\midrule[1.1pt]
		origin & 72.88  & 90.62  \\  
		\midrule
		w/o IN & 71.98 & 90.32 \\
		\midrule
		w/o Conv-1\&IN  & 71.72 & 89.93 \\ 
		\bottomrule[1.2pt]
	\end{tabular}


\end{minipage}
	\hfill
	\begin{minipage}{0.49\linewidth}  
		\centering
		\caption{Comparison of various positional encoding (PE) strategies on ResT-Lite.}
		\label{tab:ta6}
		\centering
		\begin{tabular}{ccc}
			\toprule[1.2pt]
			Encoding & Top-1 (\%) & Top-5 (\%) \\ 
			\midrule[1.1pt]
			w/o position & 71.54 & 89.82 \\ 
			\midrule
			+ LE & 71.98 & 90.32 \\
			\midrule
			+ GL & 72.04 & 90.41 \\
			\midrule
			+ PA & 72.88  & 90.62  \\ 
			\bottomrule[1.2pt]
		\end{tabular}
		
	\end{minipage}
\end{table*}      

In addition, EMSA also adding two important elements to the standard MSA, i.e., one  convolution operation to model the interaction among different heads, and the Instance Normalization(IN) to restore diversity of different heads. Here, we validate the effectiveness of these two settings. Results are shown in Table~\ref{tab:tab7}. We can see, without IN, the Top-1 accuracy is degraded by 0.9\%, we attribute it to the destroying of diversity among different heads because the  convolution operation makes all heads focus on all the tokens. In addition, the performance drops 1.16\% without the convolution operation and IN. This can demonstrate that the combination of long sequence and diversity are both important for attention function. 



\textbf{Different types of positional encoding.} In section \ref{sec:3.4}, we introduced 3 types of positional encoding types, i.e., the original learnable parameters with fixed lengths~\cite{DBLP:journals/corr/abs-2010-11929} (LE), the proposed group linear mode(GL), and PA mode. These encodings are added/multiplied to the input patch token at the beginning of each stage. Here, we compared the proposed GL and PA with LE, results are shown in Table~\ref{tab:ta6}. We can see, the Top-1 accuracy degrades from 72.88\% to 71.54\% when the PA encoding is removed, this means that positional encoding is crucial for ResT. The LE and GL, achieve similar performance, which means it is possible to construct variable length of positional encoding. Moreover, the PA mode significantly surpasses the GL, achieving 0.84\% Top-1 accuracy improvement, which indicates that spatial attention can also be modeled as positional encoding.  

\section{Conclusion}
In this paper, we proposed ResT, a new version of multi-scale Transformer which produces hierarchical feature representations for dense prediction. We compressed the memory of standard MSA and model the interaction between multi-heads while keeping the diversity ability. To tackle input images with arbitrary, we further redesign the positional encoding as spatial attention.
Experimental results demonstrate that the potential of ResT as strong backbones for dense prediction. We hope that our approach will foster further research in visual recognition. 



{\small
	\bibliographystyle{ieee_fullname}
	\bibliography{vit_ref}
}


\appendix

\section{Appendix}
We provide the related work and more experimental results to complete the experimental sections of the main paper.

\subsection{Related Work}
\label{sec:ret_work}
\textbf{Convolutional Networks.}
As the cornerstone of deep learning computer vision, CNNs have been evolved for years and are becoming more accurate and faster. Among them, the ResNet series~\cite{DBLP:conf/cvpr/HeZRS16,DBLP:conf/cvpr/XieGDTH17,DBLP:journals/corr/abs-2004-08955} are the most famous backbone networks because of their simple design and high performance. The base structure of ResNet is the residual bottleneck, which can be defined as a stack of one , one , and one  Convolution layer with residual learning. Recent works explore replacing the  Convolution layer with more complex modules~\cite{DBLP:journals/corr/abs-2101-11605,DBLP:conf/cvpr/LiW0019} or combining with attention modules~\cite{DBLP:journals/corr/abs-2102-00240,DBLP:journals/corr/abs-1711-07971}. Similar to vision Transformers, CNNs can also capture long-range dependencies if correctly incorporated with self-attention such as Non-Local or MSA. These studies show that the advantage of CNN lies in parameter sharing and focuses on the aggregation of local information, while the advantage of self-attention lies in the global receptive field and focuses on the aggregation of global information. Intuitively speaking, global and local information aggregation are both useful for vision tasks. Effectively combining global information aggregation and local information aggregation may be the right direction for designing the best network architecture.

\textbf{Vision Transformers.}
Transformer is a type of neural network that mainly relies on self-attention to draw global dependencies between input and output. Recently, Transformer-based models are explored to solve various computer vision tasks such as image processing~\cite{DBLP:journals/corr/abs-2012-00364}, classification~\cite{DBLP:journals/corr/abs-2010-11929,DBLP:journals/corr/abs-2010-11929,DBLP:journals/corr/abs-2101-11986}, and object detection~\cite{DBLP:conf/eccv/CarionMSUKZ20,DBLP:journals/corr/abs-2010-04159}, etc. Here, we focus on investigating the classification vision Transformers. These Transformers usually view an image as a sequence of patches and perform classification with a Transformer encoder. The encoder consists of several Transformer blocks, each including an MSA and an FFN. Layer-norm (LN) is applied before each layer and residual connections are employed in both the self-attention and FFN module. 

Among them, ViT~\cite{DBLP:journals/corr/abs-2010-11929} is the first fully Transformer classification model. In particular, ViT split each image into  or  with a fixed length, then several Transformer layers are adopted to model global relation among these tokens for input classification. DeiT~\cite{DBLP:journals/corr/abs-2012-12877} explores the data-efficient training and distillation of ViT. Tokens-to-Tokens (T2T-ViT)~\cite{DBLP:journals/corr/abs-2101-11986} point out that the simple tokenization of input images in ViT fails to model the important local structure (e.g., edges, lines) among neighboring pixels, leading to its low training sample efficiency. Transformer-in-Transformer (TNT)~\cite{DBLP:journals/corr/abs-2103-00112} split each image into a sequence of patches and each patch is reshaped to pixel sequence. After embedding, two Transformer layers are applied for representation learning where the outer Transformer layer models the global relationships among the patch embedding and the inner one extracts local structure information of pixel embedding. Pyramid Vision Transformer (PVT)~\cite{wang2021pyramid} follows the ResNet paradigm to construct Transformer backbones, making it more suitable for downstream tasks. MViT~\cite{mvit2021} further apply pooling function to reduce computation costs.

\textbf{Positional Encoding.}
Different from CNNs, which can implicitly encode spatial position information by zero-padding~\cite{DBLP:conf/iclr/IslamJB20}, the self-attention in Transformers has no ability to distinguish token order in different positions. Therefore, positional encoding is essential for the patch embeddings to retain positional information. There are mainly two types of positional encoding most commonly applied in vision Transformers, i.e., absolute positional encoding and relative positional encoding. The absolute positional encoding is used in ViT~\cite{DBLP:journals/corr/abs-2010-11929} and its extended methods, where a standard learnable 1D position embedding is added to the sequence of embedded patches. The relative method is used in BoTNet~\cite{DBLP:journals/corr/abs-2101-11605} and Swin Transformer~\cite{DBLP:journals/corr/abs-2103-14030}, where the split 2D relative position embeddings are added. Generally speaking, the relative positional encodings are better suited for vision tasks, this can be attributed to attention not only taking into account the content information but also relative distances between features at different locations~\cite{DBLP:conf/nips/ParmarRVBLS19}.

\subsection{Visualization and Interpretation}
\label{sec:vis}

\textbf{Analysis on EMSA.}
In this part, we measure the diversity of EMSA. To simplify, we apply  to denote the attention map, with  be the number of heads in EMSA. Assume  is the -th attention map (after reshape), where . Then we can compute the cross-layer similarity to measure the diversity of different heads. 



\begin{figure}[htb]
	\centering
	\includegraphics[width=1.0\linewidth]{fig_6}
	\caption{Attention map visualization of the last blocks of stage 4 of the ResT-Lite.}
	\label{fig:fig6}
\end{figure}

To thoroughly measure the diversity, we calculate extract three types of : the attention map before Conv-1 (i.e., ), the one after Conv-1 (i.e., ), and the one after Instance Normalization~\cite{DBLP:journals/corr/UlyanovVL16} (i.e., ). We randomly sample 1,000 images from the ImageNet-1k validation set and visualize the mean diversity in Figure~\ref{fig:fig6}. 

As shown in Figure~\ref{fig:fig6}b, although the  convolution model the interactions among different heads, it impairs the ability of MSA to jointly attend to information from different representation subsets at different positions. After instance normalization (in Figure~\ref{fig:fig6}c), the diversity ability is restored.

\textbf{Interpretabilty.}
In order to validate the effectiveness of ResT more intuitively, we sample 6 images from the ImageNet-1k validation split. We use Group-CAM~\cite{DBLP:journals/corr/abs-2103-13859} to visualize the heatmaps at the last convolutional layer of ResT-Lite. For comparison, we also draw the heatmaps of its counterpart ResNet-50. As shown in Figure~\ref{fig:fig5}, the proposed ResT-Lite can adaptively produce heatmaps according to the image content.

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.0\linewidth]{fig_5}
	\caption{Sample visualization on ImageNet-1k val split generated by Group-CAM~\cite{DBLP:journals/corr/abs-2103-13859}.}
	\label{fig:fig5}
\end{figure}


\subsection{More Experiments}
\textbf{Comparisons of EMSA and MSA.}
In this part, we make a quantitative comparison of the performance and efficiency of the two modules on ResT-Lite (keeping other components intact). Experimental settings are the same as Ablation Study (Section ~\ref{sec: ablation}7), except for the batch size of MSA, which is 512 since each V100 GPU can only tackle 64 images at the same time. We report the results in Table~\ref{tab:tab8}. Both versions of ResT-Lite share almost the same parameters. However, the EMSA version achieves better Top-1 accuracy (+0.2\%) with fewer computations(-0.2G). The actual inference throughput indicates EMSA (1246) is 2.4x faster than the original MSA(512). Therefore, EMSA can capably serve as an effective replacement for MSA. 

\begin{table*}[htb]
	\vspace*{-10pt}
	\caption{Comparison of MSA and EMSA.}
	\label{tab:tab8}
	\setlength{\tabcolsep}{6.0pt}{
		\begin{center}
			\begin{tabular}{cccccc}
				\toprule[1.2pt]
				Model & \#Params (M) & FLOPs (G) & Throughput & Top-1 (\%) & Top-5 (\%) \\
				\midrule[1.1pt]
				MSA & 10.48  & 1.6 & 512 & 72.68  & 90.46  \\ 
				\midrule
				EMSA & 10.49  & 1.4 & 1246 & 72.88  & 90.62  \\ 
				\bottomrule[1.2pt]
			\end{tabular}
		\end{center}
	}
	\vspace*{-10pt}
\end{table*}

\textbf{Object Detection.}
In Section~\ref{sec:obj}, we replace the backbone in RetinaNet~\cite{DBLP:conf/iccv/LinGGHD17} with ResT and add a layer normalization (LN~\cite{DBLP:journals/corr/BaKH16}) for the output of each stage (before FPN~\cite{DBLP:conf/cvpr/LinDGHHB17}), just like Swin. Here, we further validate the effectiveness of LN. We follow the same setting as Section~\ref{sec:obj}. Results are reported in Table~\ref{tab:tab9}.   

\begin{table}[htb]
	\centering
	\caption{Object Detection.}
	\label{tab:tab9}
	\begin{tabular}{c|cc}
		\toprule[1.2pt]
		Backbones & Setting & AP50:95 \\
		\midrule[1.1pt]
		\multirow{2}{*}{ResT-Small} & w/o LN  & 39.5  \\
		& w LN  & 40.3 \\ 
		\midrule
		\multirow{2}{*}{ResT-Base} & w/o LN  & 41.2 \\ 
		& w LN  & 42.0 \\ 
		\bottomrule[1.2pt]
	\end{tabular}
		
\end{table}

From Table~\ref{tab:tab9}, we can see, LN is indeed matters in downstream tasks. An average +0.8 box AP improvement is achieved with LN for RetinaNet~\cite{DBLP:conf/iccv/LinGGHD17}.

\subsection{Discussions}
\textbf{Mathematical Definition of GL.}
Given  with size , where  is spatial dimension and  is the channel dimension, GL first splits  into  non-overlapping groups,


where the size of  is . 

All ’s are then simultaneously transformed by  linear operations to produce  outputs 

where  is the linear operation weight. 

’s are then concatenated to produce the final  output . In ResT, we set , i.e., the channel dimension of the input.

\textbf{Ablation Study Settings.}
Note that the settings between ablation study and the main results are different. Here, we give the explanations.
We adopt the simplest data augmentation and hyper-parameters settings in ResNet~\cite{DBLP:conf/cvpr/HeZRS16} to thoroughly investigate the important components of ResT, i.e., eliminating the influence of strong data augmentation and training tricks. Under this setting, we demonstrate that Vision Transformers can still achieve better results without training tricks. Specifically, the Top-1 accuracy of ResT-Lite is 72.88, which outperforms the ResNet-18 (69.76) by +3.1 improvement. We believe the same setting as ResNet in the ablation study can eliminate the doubt of Vision Transformer to some extent, i.e., the improvements of Vision Transformer over CNN mainly come with strong data augmentation and training tricks. This can promote the ongoing and future research of Vision Transformer.



\end{document}
