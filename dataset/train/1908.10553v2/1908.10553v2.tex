\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}







\usepackage[final]{neurips_2019}




\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{natbib}
\usepackage{xcolor}
\usepackage{epsfig}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage{multirow}
\usepackage{stfloats}

\newcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\tabref}[1]{Tab.~\ref{#1}}
\newcommand{\equref}[1]{Eqn.~\ref{#1}}
\newcommand{\secref}[1]{Sec.~\ref{#1}}

\graphicspath{{./images/}}
\raggedbottom

\def\eg{\emph{e.g.}}
\def\ie{\emph{i.e.}}
\def\etal{et al.}





\title{Unsupervised Scale-consistent Depth and Ego-motion Learning from Monocular Video}



\author{Jia-Wang Bian, Zhichao Li, Naiyan Wang,  Huangying Zhan
  \And Chunhua Shen, Ming-Ming Cheng, Ian Reid \\ \\
  University of Adelaide, Australia \\ 
  Australian Centre for Robotic Vision, Australia \\
  TuSimple, China \\ 
  Nankai University, China
}


\begin{document}

\maketitle

\begin{abstract}
Recent work has shown that CNN-based depth and ego-motion estimators can be learned using unlabelled monocular videos.
However, the performance is limited by unidentified moving objects that violate the underlying static scene assumption in geometric image reconstruction.
More significantly, due to lack of proper constraints, networks output scale-inconsistent results over different samples, \ie, the ego-motion network cannot provide full camera trajectories over a long video sequence because of the per-frame scale ambiguity.
This paper tackles these challenges by proposing a geometry consistency loss for scale-consistent predictions and an induced self-discovered mask for handling moving objects and occlusions.
Since we do not leverage multi-task learning like recent works, our framework is much simpler and more efficient.
Comprehensive evaluation results demonstrate that our depth estimator achieves the state-of-the-art performance on the KITTI dataset.
Moreover, we show that our ego-motion network is able to predict a globally scale-consistent camera trajectory for long video sequences,
and the resulting visual odometry accuracy is competitive with the recent model that is trained using stereo videos.
To the best of our knowledge, this is the first work to show that deep networks trained using unlabelled monocular videos can predict globally scale-consistent camera trajectories over a long video sequence.

\end{abstract}


\section{Introduction}\label{sec-introduction}
Depth and ego-motion estimation is crucial for various applications in robotics and computer vision.
Traditional methods are usually hand-crafted stage-wise systems, which rely on correspondence search~\cite{lowe2004distinctive, Bian_2017_CVPR} and multi-view geometry~\cite{hartley2003multiple, bian2019bench} for estimation. 
Recently, deep learning based methods~\cite{eigen2014depth, liu2016learning} show that the depth can be inferred from a single image by using Convolutional Neural Network (CNN).
Especially, unsupervised methods~\cite{zhou2017unsupervised, mahjourian2018unsupervised,yin2018geonet,zou2018df, ranjan2019cc} show that CNN-based depth and ego-motion networks can be solely trained on monocular video sequences without using ground-truth depth or stereo image pairs (pose supervision).
The principle is that one can warp the image in one frame to another frame using the predicted depth and ego-motion, and then employ the image reconstruction loss as the supervision signal~\cite{zhou2017unsupervised} to train the network.
However, the performance limitation arises due to the moving objects that violate the underlying static scene assumption in geometric image reconstruction.
More significantly, due to lack of proper constraints the network predicts scale-inconsistent results over different samples, \ie, the ego-motion network cannot provide a full camera trajectory over a long video sequence because of the per-frame scale ambiguity\footnote{Monocular systems such as ORB-SLAM~\cite{mur2015orb} suffer from the scale ambiguity issue, but their predictions are globally scale-consistent. However, recently learned models using monocular videos not only suffer from the scale ambiguity, but also predict scale-inconsistent results over different snippets.}.

To the best of our knowledge, no previous work (unsupervised learning from monocular videos) addresses the scale-inconsistency issue mentioned above.
To this end, we propose a geometry consistency loss for tackling the challenge.
Specifically, for any two consecutive frames sampled from a video, we convert the predicted depth map in one frame to 3D space, then project it to the other frame using the estimated ego-motion, and finally minimize the inconsistency of the projected and the estimated depth maps.
This explicitly enforces the depth network to predict geometry-consistent (of course scale-consistent) results over consecutive frames.
With iterative sampling and training from videos, depth predictions on each consecutive image pair would be scale-consistent, and the frame-to-frame consistency can eventually propagate to the entire video sequence.
As the scale of ego-motions is tightly linked to the scale of depths, the proposed ego-motion network can predict scale-consistent relative camera poses over consecutive snippets.
We show that just simply accumulating pose predictions can result in globally scale-consistent camera trajectories over a long video sequence (\figref{fig-vo}).



Regarding the challenge of moving objects, recent work addresses it by introducing an additional optical flow~\cite{yin2018geonet,zou2018df, ranjan2019cc, wang2018joint}
or semantic segmentation network~\cite{jiao2018look}.
Although this improves performance significantly, it also brings about huge computational cost during training.
Here we show that we could automatically discover a mask from the proposed geometry consistency term for solving the problem without introducing new networks.
Specifically, we can easily locate pixels that belong to dynamic objects/occluded regions or difficult regions (\eg, textureless regions) using the proposed term.
By assigning lower weights to those pixels, we can avoid their impact to the fragile image reconstruction loss (see~\figref{fig-show} for mask visualization).
Compared with these recent approaches~\cite{yin2018geonet, zou2018df,ranjan2019cc} that leverage multi-task learning, the proposed method is much simpler and more efficient.




We conduct detailed ablation studies that clearly demonstrate the efficacy of the proposed approach.
Furthermore, comprehensive evaluation results on the KITTI~\cite{Geiger2013IJRR} dataset show that
our depth network outperforms state-of-the-art models that are trained in more complicated multi-task learning frameworks~\cite{yin2018geonet,zou2018df,ranjan2019cc,Wang2018CVPR}. 
Meanwhile, our ego-motion network is able to predict scale-consistent camera trajectories over long video sequences, and the accuracy of trajectory is competitive
with the state-of-the-art model that is trained using stereo videos~\cite{zhan2018unsupervised}.




To summarize, our main contributions are three-fold:
\begin{itemize}
    \item We propose a geometry consistency constraint to enforce the scale-consistency of depth and ego-motion networks, leading to a globally scale-consistent ego-motion estimator.


    \item We propose a self-discovered mask for dynamic scenes and occlusions by the aforementioned geometry consistency constraint. 
    Compared with other approaches, our proposed approach 
    does not require additional optical flow or semantic segmentation networks, which makes the learning framework simpler and more efficient.
    
    \item The proposed depth estimator achieves state-of-the-art performance on the KITTI dataset, 
    and the proposed ego-motion predictor shows competitive visual odometry results compared with the state-of-the-art model that is trained using stereo videos.


\end{itemize}

\section{Related work}

Traditional methods rely on the disparity between multiple views of a scene to recover the 3D scene geometry,
where at least two images are required~\cite{hartley2003multiple}.
With the rapid development of deep learning,
Eigen~\etal~\cite{eigen2014depth} show that the depth can be predicted from a single image using Convolution Neural Network (CNN).
Specifically, they design a coarse-to-fine network to predict the single-view depth and use the ground truth depths acquired by range sensors as the supervision signal to train the network.
However, although these supervised methods~\cite{eigen2014depth, liu2016learning, kuznietsov2017semi, tang2018ba, yin2018hierarchical, Yin2019enforcing} show high-quality flow and depth estimation results, it is expensive to acquire ground truth in real-world scenes.

Without requiring the ground truth depth, Garg~\etal~\cite{garg2016unsupervised} show that a single-view depth network can be trained using stereo image pairs.
Instead of using depth supervision, they leverage the established epipolar geometry~\cite{hartley2003multiple}. 
The color inconsistency between a left image and a synthesized left image warped from the right image is used as the supervision signal.
Following this idea, Godard~\etal~\cite{godard2017unsupervised} propose to constrain the left-right consistency for regularization, and Zhan~\etal~\cite{zhan2018unsupervised} extend the method to stereo videos.
However, though stereo pairs based methods do not require the ground truth depth, accurately rectifying stereo cameras is also non-trivial in real-world scenarios.


To that end, Zhou~\etal~\cite{zhou2017unsupervised} propose a fully unsupervised framework, in which the depth network can be learned solely from monocular videos.
The principle is that they introduce an additional ego-motion network to predict the relative camera pose between consecutive frames.
With the estimated depth and relative pose, image reconstruction as in~\cite{garg2016unsupervised} is applied and the photometric loss is used as the supervision signal.
However, the performance is limited due to dynamic objects that violate the underlying static scene assumption in geometric image reconstruction.
More importantly, Zhou~\etal~\cite{zhou2017unsupervised}'s method suffers from the per-frame scale ambiguity, in that a single and consistent scaling of the camera translations is missing and only direction is known.
As a result, the ego-motion network cannot predict a full camera trajectory over a long video sequence.

For handling moving objects, recent work~\cite{yin2018geonet, zou2018df} proposes to introduce an additional optical flow network.
Even more recently~\cite{ranjan2019cc} introduces an extra motion segmentation network.
Although they show significant performance improvement, there is a huge additional computational cost added into the basic framework, yet they still suffer from the scale-inconsistency issue.
Besides, Liu~\etal~\cite{liu2018self} use depth projection loss for supervision density, similar to the proposed consistency loss,
but their method relies on the pre-computed 3D reconstruction for supervision.

To the best of our knowledge, this paper is the first one to show that the ego-motion network trained in monocular videos can predict a globally scale-consistent camera trajectory over a long video sequence.
This shows significant potentials to leverage deep learning methods in Visual SLAM~\cite{mur2015orb} for robotics and autonomous driving.



\section{Unsupervised Learning of Scale-consistent Depth and Ego-motion}

\subsection{Method Overview}\label{sec-overview}
Our goal is to train depth and ego-motion networks using monocular videos,
and constrain them to predict scale-consistent results.
Given two consecutive frames (, ) sampled from an unlabeled video, 
we first estimate their depth maps (, ) using the depth network,
and then predict the relative 6D camera pose  between them using the pose network.

With the predicted depth and relative camera pose, we can synthesize the reference image  by interpolating the source image ~\cite{jaderberg2015stn, zhou2017unsupervised}.
Then, the network can be supervised by the photometric loss between the real image  and the synthesized one .
However, due to dynamic scenes that violate the geometric assumption in image reconstruction, the performance of this basic framework is limited.
To this end, we propose a geometry consistency loss  for scale-consistency and a self-discovered mask  for handling the moving objects and occlusions.
\figref{fig-sdm} shows an illustration of the proposed loss and mask.

Our overall objective function can be formulated as follows:

where  stands for the weighted photometric loss () by the proposed mask , and  stands for the smoothness loss.
We train the network in both forward and backward directions to maximize the data usage, and for simplicity we only derive the loss for the forward direction.

In the following sections, we first introduce the widely used photometric loss and smoothness loss in \secref{sec-photo-smooth}, and then describe the proposed geometric consistency loss in \secref{sec-gc} and the self-discovered mask in \secref{sec-mask}.


\subsection{Photometric loss and smoothness loss}\label{sec-photo-smooth}

\paragraph{Photometric loss.}
Leveraging the brightness constancy and spatial smoothness priors used in classical dense correspondence algorithms~\cite{baker2004lucas},
previous works~\cite{zhou2017unsupervised, yin2018geonet, zou2018df, ranjan2019cc} have used the photometric error between the warped frame and the reference frame as an unsupervised loss function for training the network.

With the predicted depth map  and the relative camera pose , 
we synthesize  by warping , where differentiable bilinear interpolation~\cite{jaderberg2015stn} is used as in~\cite{zhou2017unsupervised}.
With the synthesized  and the reference image , we formulate the objective function as

where  stands for valid points that are successfully projected from  to the image plane of ,
and  defines the number of points in .
We choose  loss due to its robustness to outliers. However, it is still not invariant to illumination changes in real-world scenarios. Here we add an additional image dissimilarity loss SSIM~\cite{wang2004image} for better handling complex illumination changes, since it normalizes the pixel illumination.
We modify the photometric loss term~\equref{eqn-photometric1} as:

where  stands for the element-wise similarity between  and  by the SSIM function~\cite{wang2004image}.
Following~\cite{godard2017unsupervised, yin2018geonet, ranjan2019cc}, we use   and  in our framework.


\paragraph{Smoothness loss.}
As the photometric loss is not informative in low-texture nor homogeneous region of the scene,
existing work incorporates a smoothness prior to regularize the estimated depth map.
We adopt the edge-aware smoothness loss used in~\cite{ranjan2019cc}, which is formulated as:

where  is the first derivative along spatial directions. 
It ensures that smoothness is guided by the edge of images.


\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{images/sc-figure.pdf}
\caption{Illustration of the proposed geometry consistency loss and self-discover mask.
Given two consecutive frames (, ), we first estimate their depth maps (, ) and relative pose () using the network,
then we get the warped () by converting  to 3D space and projecting to the image plane of  using ,
and finally we use the inconsistency between  and the  interpolated from  as the geometric consistency loss  (\equref{eqn-gc}) to supervise the network training.
Here, we interpolate  because the projection flow does not lie on the pixel grid of .
Besides, we discover a mask  (\equref{eqn-mask}) from the inconsistency map for handling dynamic scenes and ill-estimated regions (\figref{fig-show}).
For clarity, the photometric loss and smoothness loss are not shown in this figure.
}
\label{fig-sdm}
 \vspace{-2mm}
\end{figure}


\subsection{Geometry consistency loss}\label{sec-gc}

As mentioned before, we enforce the geometry consistency on the predicted results.
Specifically, we require that  and  (related by ) conform the same 3D scene structure,
and minimize their differences.
The optimization not
only encourages the geometry consistency between samples in a batch but also transfers the consistency to the entire sequence. 
\eg, depths of  agree with depths of  in a batch; depths of  agree with depths of  in another training batch. 
Eventually, depths of  of a sequence should all agree with each other.
As the pose network is naturally coupled with the depth network during training, our method yields scale-consistent predictions over the entire sequence.


With this constraint, we compute the depth inconsistency map .
For each , it is defined as:

where  is the computed depth map of  by warping  using ,
and   is the interpolated depth map from the estimated depth map  (Note that we cannot directly use  because the warping flow does not lie on the pixel grid ).
Here we normalize their difference by their sum.
This is more intuitive than the absolute distance as it treats points at different absolute depths equally in optimization.
Besides, the function is symmetric and the outputs are naturally ranging from  to , which contributes to numerical stability in training.

With the inconsistency map, we simply define the proposed geometry consistency loss as:

which minimizes the geometric distance of predicted depths between each consecutive pair and enforces their scale-consistency.
With training, the consistency can propagate to the entire video sequence.
Due to the tight link between ego-motion and depth predictions, the ego-motion network can eventually predict globally scale-consistent trajectories (\figref{fig-vo}).


\begin{figure}[t]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.47\linewidth]{images/fig-a.pdf}& 
\includegraphics[width=0.47\linewidth]{images/fig-b.pdf}\\
(a)  & (b) \\
\includegraphics[width=0.47\linewidth]{images/show-03.pdf}& 
\includegraphics[width=0.47\linewidth]{images/show-04.pdf}\\
(c) & (d) \\
\end{tabular}
\caption{Visual results. Top to bottom: sample image, estimated depth, self-discovered mask.
The proposed mask can effectively identify occlusions and moving objects.}
\label{fig-show}
 \vspace{-2mm}
\end{figure}

\subsection{Self-discovered mask}\label{sec-mask}

To handle moving objects and occlusions that may impair the network training,
recent work propose to introduce an additional optical flow~\cite{yin2018geonet,zou2018df,ranjan2019cc} or semantic segmentation network~\cite{jiao2018look}.
This is effective, however it also introduces extra computational cost and training burden.
Here, we show that these regions can be effectively located by the proposed inconsistency map  in \equref{eqn-depthdiff}.

There are several scenarios that result in inconsistent scene structure observed from different views, including (1) dynamic objects, (2) occlusions, and (3) inaccurate predictions for difficult regions.
Without separating them explicitly, we observe each of these will result in  increasing from its ideal value of zero.

Based on this simple observation, we propose a weight mask  as  is in :

which assigns low/high weights for inconsistent/consistent pixels. It can be used to re-weight the photometric loss.
Specifically, we modify the photometric loss in~\equref{eqn-photometric2} as



By using the mask, we mitigate the adverse impact from moving objects and occlusions.
Further, the gradients computed on inaccurately predicted regions carry less weight during back-propagation.
\figref{fig-show} shows visual results for the proposed mas, which coincides with our anticipation stated above.



\section{Experiment}
\subsection{Implementation details}\label{sec-details}

\paragraph{Network architecture.}
For the depth network, we experiment with DispNet~\cite{zhou2017unsupervised} and DispResNet~\cite{ranjan2019cc}, which takes a single RGB image as input and outputs a depth map.
For the ego-motion network, PoseNet without the mask prediction branch~\cite{zhou2017unsupervised} is used. 
The network estimates a 6D relative camera pose from a concatenated RGB image pair.
Instead of computing the loss on multiple-scale outputs of the depth network (4 scales in~\cite{zhou2017unsupervised} or 6 scales in~\cite{ranjan2019cc}),
we empirically find that using single-scale supervision (\ie, only compute the loss on the finest output) is better (\tabref{tab:ablation2}).
Our single-scale supervision not only improves the performance but also contributes a more concise training pipeline.
We hypothesize the reason of this phenomenon is that the photometric loss is not accurate in low-resolution images, where the pixel color is over-smoothed.











\paragraph{Single-view depth estimation.}
The proposed learning framework is implemented using PyTorch Library~\cite{paszke2017automatic}.
For depth network, we train and test models on KITTI raw dataset~\cite{Geiger2013IJRR} using Eigen~\cite{eigen2014depth}’s split that is the same with related works~\cite{zou2018df,yin2018geonet,ranjan2019cc,zhou2017unsupervised}.
Following~\cite{zhou2017unsupervised}, we use a snippet of three sequential video frames as a training sample, 
where we set the second image as reference frame to compute loss with other two images and then inverse their roles to compute loss again for maximizing the data usage.
The data is also augmented with random scaling, cropping and horizontal flips during training, and we experiment with two input resolutions ( and ).
We use ADAM~\cite{kingma2014adam} optimizer, and set the batch size to  and the learning rate to .
During training, we adopt , , and  in~\equref{eqn-totalloss}.
We train the network in  epochs with  randomly sampled batches in one epoch, and validate the model at per epoch.
Also, we pre-train the network on CityScapes~\cite{Cordts2016Cityscapes} and finetune on KITTI~\cite{Geiger2013IJRR}, each for  epochs.
Here we follow Eigen~\etal~\cite{eigen2014depth}'s evaluation metrics for depth evaluation. 


\paragraph{Visual odometry prediction.}
For pose network, following Zhan~\etal~\cite{zhan2018unsupervised}, we evaluate visual odometry results on KITTI odometry dataset~\cite{Geiger2013IJRR}, where sequence 00-08/09-10 are used for training/testing.
We use the standard evaluation metrics by the dataset for trajectory evaluation rather than Zhou~\etal~\cite{zhou2017unsupervised}'s 5-frame pose evaluation, since they are more widely used and more meaningful.






\subsection{Comparisons with the state-of-the-art}

\paragraph{Depth results on KITTI raw dataset.}
\tabref{tab:depth} shows the results on KITTI raw dataset~\cite{Geiger2013IJRR},
where our method achieves the state-of-the-art performance when compared with models trained on monocular video sequences.
Note that recent work~\cite{yin2018geonet,zou2018df,ranjan2019cc,yang2018unsupervised} all jointly learn multiple tasks, while our approach does not.
This effectively reduces the training and inference overhead.
Moreover, our method competes quite favorably with other methods using stronger supervision signals such as calibrated stereo image pairs (\ie, pose supervision) or even ground-truth depth annotation.

\begin{table}[!t]
    \caption{Single-view depth estimation results on test split of KITTI raw dataset~\cite{Geiger2013IJRR}. The methods trained on KITTI raw dataset~\cite{Geiger2013IJRR} are denoted by K. Models with pre-training on CityScapes~\cite{Cordts2016Cityscapes} are denoted by CS+K. (D) denotes depth supervision, (\textcolor{red}{B}) denotes binocular/stereo input pairs, (\textcolor{blue}{M}) denotes monocular video clips. (\textcolor{green}{J}) denotes joint learning of multiple tasks. The best performance in each block is highlighted as bold.}
    \label{tab:depth}
    \centering
    \scalebox{0.8}{
    \begin{tabular}{l c| c c c c | c c c}
    \toprule[2pt]
     & & \multicolumn{4}{c|}{Error } & \multicolumn{3}{c}{Accuracy }  \\
     \cline{3-9}
     Methods & Dataset & AbsRel & SqRel & RMS & RMSlog &  &  &  \\
     \hline
     Eigen \etal~\cite{eigen2014depth} & K (D) & 0.203 & 1.548 & 6.307 & 0.282 & 0.702 & 0.890 & 0.958 \\
     Liu \etal~\cite{liu2016learning} & K (D) & 0.202 & 1.614 & 6.523 & 0.275 & 0.678 & 0.895 & 0.965 \\
     Garg \etal~\cite{garg2016unsupervised} & K (\textcolor{red}{B}) & 0.152 & 1.226 & 5.849 & 0.246 & 0.784 & 0.921 & 0.967\\
     Kuznietsov \etal~\cite{kuznietsov2017semi} & K (\textcolor{red}{B}+D) & \textbf{0.113} & \textbf{0.741} & \textbf{4.621} & \textbf{0.189} & \textbf{0.862} & \textbf{0.960} & \textbf{0.986} \\
     Godard \etal~\cite{godard2017unsupervised} & K (\textcolor{red}{B}) & 0.148 & 1.344 & 5.927 & 0.247 & 0.803 & 0.922 & 0.964 \\
     Godard \etal~\cite{godard2017unsupervised} & CS+K (\textcolor{red}{B}) & 0.124 & 1.076 & 5.311 & 0.219 & 0.847 & 0.942 & 0.973 \\
     Zhan \etal~\cite{zhan2018unsupervised} & K (\textcolor{red}{B}) & 0.144 & 1.391 & 5.869 & 0.241 & 0.803 & 0.928 & 0.969\\
     \hline
     Zhou \etal~\cite{zhou2017unsupervised} & K (\textcolor{blue}{M}) & 0.208 & 1.768 & 6.856 & 0.283 & 0.678 & 0.885 & 0.957 \\
     Yang \etal~\cite{yang2018unsupervised} (\textcolor{green}{J}) & K (\textcolor{blue}{M}) & 0.182 & 1.481 & 6.501 & 0.267 & 0.725 & 0.906 & 0.963 \\
     Mahjourian \etal~\cite{mahjourian2018unsupervised} & K (\textcolor{blue}{M}) & 0.163 & 1.240 & 6.220 & 0.250 & 0.762 & 0.916 & 0.968 \\
     Wang
     \etal~\cite{Wang2018CVPR} & K (\textcolor{blue}{M}) & 0.151 & 1.257 & 5.583 & 0.228 & 0.810 & 0.936 & 0.974 \\
     Geonet-VGG~\cite{yin2018geonet} (\textcolor{green}{J}) & K (\textcolor{blue}{M}) & 0.164 & 1.303 & 6.090 & 0.247 & 0.765 & 0.919 & 0.968 \\
     Geonet-Resnet~\cite{yin2018geonet} (\textcolor{green}{J}) & K (\textcolor{blue}{M}) & 0.155 & 1.296 & 5.857 & 0.233 & 0.793 & 0.931 & 0.973\\
DF-Net~\cite{zou2018df} (\textcolor{green}{J}) & K (\textcolor{blue}{M}) & 0.150 & 1.124 & 5.507 & 0.223 & 0.806 & 0.933 & 0.973\\
     CC~\cite{ranjan2019cc} (\textcolor{green}{J}) & K (\textcolor{blue}{M}) & 0.140 & \textbf{1.070} & \textbf{5.326} & \textbf{0.217} & 0.826 & 0.941 & \textbf{0.975}\\
     Ours & K (\textcolor{blue}{M}) & \textbf{0.137} & 1.089 & 5.439 & \textbf{0.217} & \textbf{0.830} & \textbf{0.942} & \textbf{0.975}\\
     \hline
     Zhou \etal~\cite{zhou2017unsupervised} & CS+K (\textcolor{blue}{M}) & 0.198 & 1.836 & 6.565 & 0.275 & 0.718 & 0.901 & 0.960 \\
     Yang \etal~\cite{yang2018unsupervised} (\textcolor{green}{J}) & CS+K (\textcolor{blue}{M}) & 0.165 & 1.360 & 6.641 & 0.248 & 0.750 & 0.914 & 0.969 \\
     Mahjourian \etal~\cite{mahjourian2018unsupervised} & CS+K (\textcolor{blue}{M}) & 0.159 & 1.231 & 5.912 & 0.243 & 0.784 & 0.923 & 0.970 \\
     Wang
     \etal~\cite{Wang2018CVPR} & CS+K (\textcolor{blue}{M}) & 0.148 & 1.187 & 5.496 & 0.226 & 0.812 & 0.938 & 0.975 \\
     Geonet-Resnet~\cite{yin2018geonet} (\textcolor{green}{J}) & CS+K (\textcolor{blue}{M}) & 0.153 & 1.328 & 5.737 & 0.232 & 0.802 & 0.934 & 0.972 \\
     DF-Net~\cite{zou2018df} (\textcolor{green}{J}) & CS+K (\textcolor{blue}{M}) & 0.146 & 1.182 & 5.215 & 0.213 & 0.818 & 0.943 & \textbf{0.978} \\
     CC~\cite{ranjan2019cc} (\textcolor{green}{J}) & CS+K (\textcolor{blue}{M}) & 0.139 & \textbf{1.032} & \textbf{5.199} & 0.213 & 0.827 & 0.943 & 0.977 \\
     Ours & CS+K (\textcolor{blue}{M}) & \textbf{0.128} & 1.047 & 5.234 & \textbf{0.208} & \textbf{0.846} & \textbf{0.947} & 0.976 \\
    \toprule[2pt]
    \end{tabular}
    }
\end{table}














\begin{table}[!t]
\centering
    \caption{Visual odometry results on KITTI odometry dataset~\cite{Geiger2013IJRR}.
    We report the performance of ORB-SLAM~\cite{mur2015orb} as a reference and compare with recent deep methods.
    K denotes the model trained on KITTI, and CS+K denotes the model with pre-training on Cityscapes~\cite{Cordts2016Cityscapes}.
    }
    \label{tab-vo}
    \scalebox{0.8}{
    \begin{tabular}{l | c c | c c}
     \toprule[2pt]
     Methods & \multicolumn{2}{c|}{Seq. 09} & \multicolumn{2}{c}{Seq. 10} \\
     &  () &  () &  () &  () \\
     \hline
    ORB-SLAM~\cite{mur2015orb} & 15.30 & 0.26 & 3.68 & 0.48 \\
    \hline
    Zhou~\etal~\cite{zhou2017unsupervised} & 17.84 & 6.78 & 37.91 & 17.78 \\
    Zhan~\etal~\cite{zhan2018unsupervised} & 11.93 & 3.91 & 12.45 & \textbf{3.46} \\
    Ours (K)  & 11.2  & 3.35 & \textbf{10.1} & 4.96 \\
    Ours (CS+K) & \textbf{8.24} & \textbf{2.19} & 10.7 & 4.58 \\
     \hline
     \toprule[2pt]
    \end{tabular}
    }
\end{table}


\begin{figure}[!t]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.47\linewidth]{images/09.pdf} & 
\includegraphics[width=0.47\linewidth]{images/10.pdf} \\
(a) sequence 09  & (b) sequence 10 \\
\end{tabular}
\caption{Qualitative results on the testing sequences of KITTI odometry dataset~\cite{Geiger2013IJRR}.
}
\label{fig-vo}
\end{figure}

\paragraph{Visual odometry results on KITTI odometry dataset.}
We compare with SfMLearner~\cite{zhou2017unsupervised} and the methods trained with stereo videos~\cite{zhan2018unsupervised}.
We also report the results of ORB-SLAM~\cite{mur2015orb} system (without loop closing) as a reference, though emphasize that this results in a comparison note between a simple frame-to-frame pose estimation framework with a Visual SLAM system, in which the latter has a strong back-end optimization system (\ie, bundle adjustment~\cite{triggs1999bundle}) for improving the performance.
Here, we ignore the frames (First 9 and 30 respectively) from the sequences (09 and 10) for which ORB-SLAM~\cite{mur2015orb} fails to output camera poses because of unsuccessful initialization.
\tabref{tab-vo} shows the average translation and rotation errors for the testing sequence 09 and 10, and \figref{fig-vo} shows qualitative results.
Note that the comparison is highly disadvantageous to the proposed method: 
\emph{i)} we align per-frame scale to the ground truth scale for~\cite{zhou2017unsupervised} due to its scale-inconsistency, while we only align one global scale for our method;
\emph{ii)} \cite{zhan2018unsupervised} requires stereo videos for training, while we only use monocular videos.
Although it is unfair to the proposed method, the results show that our method achieves competitive results with~\cite{zhan2018unsupervised}.
Even when compared with the ORB-SLAM~\cite{mur2015orb} system, our method shows a lower translational error and a better visual result on sequence 09. 
This is a remarkable progress that deep models trained on unlabelled monocular videos can predict a globally scale-consistent visual odometry.



\subsection{Ablation study}\label{sec-ablation}

In this section, we first validate the efficacy of the proposed geometry-consistency loss  and the self-discovered weight mask .
Then we experiment with different scale numbers, network architectures, and image resolutions.

\paragraph{Validating proposed  and .}
We conduct ablation studies using DispNet~\cite{zhou2017unsupervised} and images of  resolution.
\tabref{tab:ablation1} shows the depth results for both single-scale and multi-scale supervisions.
The results clearly demonstrate the contribution of our proposed terms to the overall performance.
Besides, \figref{fig-ablation} shows the validation error during training, which indicates that the proposed  can effectively prevent the model from overfitting.


\begin{table}[h]
    \caption{Ablation studies on  and . Brackets show results of multi-scale (4) supervisions.} 
    \label{tab:ablation1}
    \centering
    \scalebox{0.8}{
    \begin{tabular}{l|cccc|ccc}
       \toprule[2pt]
      & \multicolumn{4}{c|}{Error } & \multicolumn{3}{c}{Accuracy }  \\
      \cline{2-8}
      Methods & AbsRel & SqRel & RMS & RMSlog &  &  &  \\
      \hline
      Basic &  0.161 (0.185) & 1.225 & 5.765 & 0.237 & 0.780 & 0.927 & 0.972\\
      Basic+SSIM  & 0.160 (0.163) & 1.230 & 5.950 & 0.243 & 0.775 & 0.923 & 0.969\\
      Basic+SSIM+GC  & 0.158 (0.161) & 1.247 &  5.827 & 0.235 & 0.786 & 0.927 & 0.971\\
      Basic+SSIM+GC+M & \textbf{0.151} (\textbf{0.158}) & \textbf{1.154} & \textbf{5.716} & \textbf{0.232} & \textbf{0.798} & \textbf{0.930} & \textbf{0.972}\\
      \toprule[2pt]
    \end{tabular}
    }
\end{table}


\begin{figure}[ht]
\centering
\includegraphics[width=0.47\linewidth]{images/single-scale.pdf} 
\includegraphics[width=0.47\linewidth]{images/multi-scale.pdf}
\caption{Validation error.
Both \emph{Basic} and \emph{Basic+SSIM} overfit after about  epochs, while others do not due to proposed .
Besides, models with the single-scale supervision in training outperforms those with multi-scale (4) supervisions.
}
\label{fig-ablation}
\end{figure}



\paragraph{Proposed single-scale vs multi-scale supervisions.}
As mentioned in \secref{sec-details}, we empirically find that using single-scale supervision leads to better performance than using the widely-used multi-scale solution.
\tabref{tab:ablation2} shows the depth results.
We hypothesis the reason is that the photometric loss is not accurate in low-resolution images, where the pixel color is over-smoothed.
Besides, as the displacement between two consecutive views is small, the multi-scale solution is unnecessary.

\begin{table}[ht]
    \caption{Ablation studies on scale numbers of supervision.} 
    \label{tab:ablation2}
    \centering
    \scalebox{0.8}{
    \begin{tabular}{l|cccc|ccc}
      \toprule[2pt]
      & \multicolumn{4}{c|}{Error } & \multicolumn{3}{c}{Accuracy }  \\
      \cline{2-8}
     \#Scales & AbsRel & SqRel & RMS & RMSlog &  &  &  \\
      \hline
      1 & \textbf{0.151} & \textbf{1.154} & \textbf{5.716} & \textbf{0.232} & \textbf{0.798} & \textbf{0.930} & \textbf{0.972} \\
      2 & 0.152 & 1.192 & 5.900 & 0.235 & 0.795 & 0.927 & 0.971 \\
      3 & 0.159 & 1.226 & 5.987 & 0.240 & 0.780 & 0.921 & 0.969 \\
      4 & 0.158 & 1.214 & 5.898 & 0.239 & 0.782 & 0.925 & 0.971 \\
      \toprule[2pt]
    \end{tabular}
    }
    \vspace{-2mm}
\end{table}




\paragraph{Network architectures and image resolutions.}
\tabref{tab:ablation3} shows the results of different network architectures on different resolution images,
where DispNet and DispResNet are both borrowed from CC~\cite{ranjan2019cc}, and DispNet is also used in SfMLearner~\cite{zhou2017unsupervised}.
It shows that higher resolution images and deeper networks can results in better performance.

\begin{table}[ht]
\centering
    \caption{Ablation studies on different network architectures and image resolutions.}
    \label{tab:ablation3}
    \scalebox{0.8}{
    \begin{tabular}{l c| c c c c | c c c}
     \toprule[2pt]
     & & \multicolumn{4}{c|}{Error } & \multicolumn{3}{c}{Accuracy }  \\
     \cline{3-9}
     Methods & Resolutions & AbsRel & SqRel & RMS & RMSlog &  &  &  \\
     \hline
     DispNet   &  \multirow{ 2}{*}{} & 0.151 & 1.154 & 5.716 & 0.232 & 0.798 & 0.930 &0.972\\
     DispResNet & & 0.149 & 1.137 & 5.771 & 0.230 & 0.799 & 0.932 & 0.973\\
     \hline
     DispNet & \multirow{ 2}{*}{} & 0.146 & 1.197 & 5.578 & 0.223 & 0.814 & 0.940 & \textbf{0.975}\\
     DispResNet & & \textbf{0.137} & \textbf{1.089} & \textbf{5.439} & \textbf{0.217} & \textbf{0.830} & \textbf{0.942} & \textbf{0.975}\\
     \toprule[2pt]
    \end{tabular}
    }
    \vspace{-2mm}    
\end{table}





\subsection{Timing and memory analysis}


\paragraph{Training time and parameter numbers.}
We compare with CC~\cite{ranjan2019cc}, and both methods are trained on a single 16GB Tesla V100 GPU.
We measure the time taken for each training iteration consisting of forward and backward pass using a batch size of 4.
The image resolution is .
CC~\cite{ranjan2019cc} needs train 3 parts, including (Depth, Pose), Flow, and Mask.
In contrast our method only trains (Depth, Pose).
In total, CC takes about \emph{7 days} for training as reported by authors, while our method takes about \emph{32 hours}.
\tabref{tab-tim} shows the per-iteration time and model parameters of each network.

\begin{table}[ht]
    \centering
    \caption{Training time per iteration and model parameters for each network.}
    \scalebox{0.8}{
    \begin{tabular}{l|ccc|c}
      \toprule[2pt]
      & \multicolumn{3}{c|}{CC~\cite{ranjan2019cc}} & Ours \\
      \hline
      Network & (Depth, Pose) & Flow & Mask & (Depth, Pose) \\
      \hline
      Time & 0.96s & 1.32s & 0.48s & 0.55s \\
      \hline
      Parameter Numbers & (80.88M, 2.18M) & 39.28M & 5.22M & (80.88M, 1.59M)\\
      \toprule[2pt]
    \end{tabular}
    }
    \label{tab-tim}
\end{table}


\paragraph{Inference time.}
We test models on a single RTX 2080 GPU.
The batch size is 1, and the time is averaged over 100 iterations.
\tabref{tab-test-time} shows the results.
The DispNet and DispResNet architectures are same with SfMLearner~\cite{zhou2017unsupervised} and CC~\cite{ranjan2019cc}, respectively,
so their speeds are theoretically same.

\begin{table}[!ht]
    \centering
    \caption{Inference time on per image or image pair.}
    \scalebox{0.8}{
    \begin{tabular}{l|ccc}
      \toprule[2pt]
      & DispNet & DispResNet & PoseNet \\
      \hline
       & 4.9 ms  & 9.6 ms & 0.6 ms\\
       & 9.2 ms  & 15.5 ms & 1.0 ms\\
      \toprule[2pt]
    \end{tabular}
    }
    \label{tab-test-time}
     \vspace{-2mm}
\end{table}



\section{Conclusion}
This paper presents an unsupervised learning framework for scale-consistent depth and ego-motion estimation.
The core of the proposed approach is a geometry consistency loss for scale-consistency and a self-discovered mask for handling dynamic scenes.
With the proposed learning framework, our depth model achieves the state-of-the-art performance on the KITTI~\cite{Geiger2013IJRR} dataset,
and our ego-motion network can show competitive visual odometry results with the model that is trained using stereo videos.
To the best of our knowledge, this is the first work to show that deep models training on unlabelled monocular videos can predict a globally scale-consistent camera trajectory over a long sequence.
In future work, we will focus on improving the visual odometry accuracy by incorporating drift correcting solutions into the current framework.

\subsubsection*{Acknowledgments}
The work was supported by the Australian Centre for Robotic Vision.
Jiawang would also like to thank TuSimple, where he started research in this field.


\bibliographystyle{unsrt}
\bibliography{reference}

\section{Supplementary}

\subsection{Pose estimation results on 5-frame snippets}

Although the visual odometry results shown in the main paper is more important, 
we also evaluate pose estimation results using Zhou~\etal~\cite{zhou2017unsupervised}'s evaluation metric on 5-frame snippets.
\tabref{tab-pose} shows the results, where our method shows slightly lower performances with the state-of-the-art methods but the gap is small.

\begin{table}[ht]
\centering
    \caption{Pose estimation results on KITTI odometry dataset.}
    \label{tab-pose}
    \scalebox{0.9}{
    \begin{tabular}{ c c c}
    \toprule[2pt]
    & Seq. 09 & Seq. 10 \\
    \hline
    ORB-SLAM (full) &  &   \\
    \hline
    ORB-SLAM (short) &  &  \\
    Mean Odometry &  &  \\
    Zhou \etal~\cite{zhou2017unsupervised} &  &  \\
    Mahjourian \etal~\cite{mahjourian2018unsupervised} &  &  \\
    GeoNet~\cite{yin2018geonet} &  &  \\
    DF-Net~\cite{zou2018df} &  &  \\
    CC~\cite{ranjan2019cc} &  &  \\
    Ours &  &  \\
    \toprule[2pt]
    \end{tabular}
    }
\end{table}

\subsection{Depth estimation results on Make3D dataset.}
To verify the generalization ability of the trained model, we also test it on Make3D dataset~\cite{saxena2006learning}.
\tabref{tab:make3d} shows the relative depth error, where our model is trained on KITTI~\cite{Geiger2013IJRR} without fine-tuning on Make3D~\cite{liu2016learning}.
The results demonstrate that our method performs slightly better than other state-of-the-art methods.


\begin{table}[ht]
\centering
    \caption{Depth results (AbsRel) on Make3D~\cite{saxena2006learning} test set without finetuning.
}
    \label{tab:make3d}
    \scalebox{0.8}{
    \begin{tabular}{ c | c c c c c c}
    \toprule[2pt]
    Methods &
    Zhou \etal~\cite{zhou2017unsupervised} & 
    Godard \etal~\cite{godard2017unsupervised} &
DF-Net \etal~\cite{zou2018df} & 
    CC~\cite{ranjan2019cc} & Ours \\
    \hline
    AbsRel &
    0.383 & 0.544 & 0.331 & 0.320 & \textbf{0.312} \\
    \toprule[2pt]
    \end{tabular}
    }
\end{table}

\subsection{More qualitative results}

\figref{fig-show2} illustrates visual results of depth estimation and occlusion detection by the proposed approach.

\begin{figure}[!h]
\centering
\begin{tabular}{cc}
\includegraphics[width=0.47\linewidth]{images/show-01.pdf}& 
\includegraphics[width=0.47\linewidth]{images/show-02.pdf}\\
(a) & (b) \\
\includegraphics[width=0.47\linewidth]{images/show-05.pdf}& 
\includegraphics[width=0.47\linewidth]{images/show-06.pdf}\\
(c) & (d)
\end{tabular}
\caption{Visual results. Top to bottom: sample image, estimated depth, self-discovered mask.}
\label{fig-show2}
\vspace{-2mm}
\end{figure}

\end{document}
