\documentclass[11pt,onecolumn]{article}
\usepackage{times,amsmath,epsfig}
\usepackage{xspace,latexsym,syntonly}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{epsfig}
\newcounter{theorem}

\newcommand{\force}{\mbox{}}

\newcommand{\ghat}{\mbox{}}

\newcommand{\bzero}{\mbox{}}

\newcommand{\va}{\mbox{}}
\newcommand{\vah}{\mbox{}}
\newcommand{\vat}{\mbox{}}
\newcommand{\vb}{\mbox{}}
\newcommand{\vd}{\mbox{}}
\newcommand{\rh}{\mbox{}}
\newcommand{\Itl}{\mbox{}}


\newcommand{\vxt}{\mbox{}}
\newcommand{\vh}{\mbox{}}
\newcommand{\vhh}{\mbox{}}
\newcommand{\ve}{\mbox{}}
\newcommand{\vg}{\mbox{}}
\newcommand{\vgh}{\mbox{}}
\newcommand{\vp}{\mbox{}}
\newcommand{\vph}{\mbox{}}
\newcommand{\vq}{\mbox{}}
\newcommand{\vt}{\mbox{}}
\newcommand{\vw}{\mbox{}}
\newcommand{\vwh}{\mbox{}}
\newcommand{\wh}{\mbox{}}
\newcommand{\vwt}{\mbox{}}
\newcommand{\wt}{\mbox{}}
\newcommand{\vs}{\mbox{}}
\newcommand{\vsh}{\mbox{}}
\newcommand{\vst}{\mbox{}}
\newcommand{\vr}{\mbox{}}
\newcommand{\vx}{\mbox{}}
\newcommand{\vv}{\mbox{}}
\newcommand{\vu}{\mbox{}}
\newcommand{\vy}{\mbox{}}
\newcommand{\vz}{\mbox{}}
\newcommand{\vn}{\mbox{}}
\newcommand{\vnt}{\mbox{}}
\newcommand{\vzero}{\mbox{}}
\newcommand{\vone}{\mbox{}}

\newcommand{\mA}{\mbox{{}}}
\newcommand{\mAh}{\mbox{}}
\newcommand{\mAt}{\mbox{}}
\newcommand{\mB}{\mbox{}}
\newcommand{\mBh}{\mbox{}}
\newcommand{\mC}{\mbox{{}}}
\newcommand{\mCh}{\mbox{}}
\newcommand{\mD}{\mbox{{}}}
\newcommand{\mDt}{\mbox{}}
\newcommand{\mE}{\mbox{{}}}
\newcommand{\mG}{\mbox{{}}}
\newcommand{\mF}{\mbox{{}}}
\newcommand{\mH}{\mbox{{}}}
\newcommand{\mHb}{\mbox{}}
\newcommand{\mI}{\mbox{{}}}
\newcommand{\mIh}{\mbox{}}
\newcommand{\mN}{\mbox{{}}}
\newcommand{\mM}{\mbox{{}}}
\newcommand{\mMh}{\mbox{{}}}
\newcommand{\mP}{\mbox{}}
\newcommand{\mQ}{\mbox{}}
\newcommand{\mR}{\mbox{}}
\newcommand{\mRh}{\mbox{}}
\newcommand{\mRt}{\mbox{}}
\newcommand{\mS}{\mbox{}}
\newcommand{\mSb}{\mbox{}}
\newcommand{\mSh}{\mbox{}}
\newcommand{\mSt}{\mbox{}}
\newcommand{\mT}{\mbox{}}
\newcommand{\mU}{\mbox{}}
\newcommand{\mUh}{\mbox{}}
\newcommand{\mV}{\mbox{}}
\newcommand{\mVh}{\mbox{}}
\newcommand{\mW}{\mbox{}}
\newcommand{\mWh}{\mbox{}}
\newcommand{\mWt}{\mbox{}}
\newcommand{\mX}{\mbox{}}
\newcommand{\mY}{\mbox{}}
\newcommand{\mZ}{\mbox{}}





\newcommand{\ga}{\alpha}
\newcommand{\gb}{\beta}
\newcommand{\grg}{\gamma}
\newcommand{\gd}{\delta}
\newcommand{\gre}{\varepsilon}
\newcommand{\gep}{\epsilon}
\newcommand{\gz}{\zeta}
\newcommand{\gzh}{\mbox{}}
\newcommand{\gh}{\eta}
\newcommand{\gth}{\theta}
\newcommand{\gi}{iota}
\newcommand{\gk}{\kappa}
\newcommand{\gl}{\lambda}
\newcommand{\gm}{\mu}
\newcommand{\gn}{\nu}
\newcommand{\gx}{\xi}
\newcommand{\gp}{\pi}
\newcommand{\gph}{\phi}
\newcommand{\gr}{\rho}
\newcommand{\gs}{\sigma}
\newcommand{\gsh}{\hat \sigma}
\newcommand{\gt}{\tau}
\newcommand{\gu}{\upsilon}
\newcommand{\gf}{\varphi}
\newcommand{\gc}{\chi}
\newcommand{\go}{\omega}



\newcommand{\gG}{\Gamma}
\newcommand{\gD}{\Delta}
\newcommand{\gTh}{\Theta}
\newcommand{\gL}{\Lambda}
\newcommand{\gX}{\Xi}
\newcommand{\gP}{\Pi}
\newcommand{\gS}{\Sigma}
\newcommand{\gU}{\Upsilon}
\newcommand{\gF}{\Phi}
\newcommand{\gO}{\Omega}



\def\bm#1{\mbox{\boldmath }}
\newcommand{\vga}{\mbox{}}
\newcommand{\vgb}{\mbox{}}
\newcommand{\vgd}{\mbox{}}
\newcommand{\vge}{\mbox{}}
\newcommand{\vgl}{\mbox{}}
\newcommand{\vgm}{\mbox{}}
\newcommand{\vgr}{\mbox{}}
\newcommand{\vgn}{\mbox{}}
\newcommand{\vgrh}{\mbox{}}
\newcommand{\vgrt}{\mbox{}}

\newcommand{\vgt}{\mbox{}}
\newcommand{\vgth}{\mbox{}}
\newcommand{\vgtt}{\mbox{}}
\newcommand{\vpsi}{\mbox{}}
\newcommand{\vphi}{\mbox{}}
\newcommand{\vxi}{\mbox{}}
\newcommand{\vth}{\mbox{}}
\newcommand{\vthh}{\mbox{}}

\newcommand{\mgG}{\mbox{}}
\newcommand{\mgGh}{\mbox{}}
\newcommand{\mgD}{\mbox{}}
\newcommand{\mgU}{\mbox{}}
\newcommand{\mgL}{\mbox{}}
\newcommand{\mPsi}{\mbox{}}
\newcommand{\mgX}{\mbox{}}
\newcommand{\mgS}{\mbox{}}

\newcommand{\oA}{{\open A}}
\newcommand{\oC}{{\open C}}
\newcommand{\oF}{{\open F}}
\newcommand{\oN}{{\open N}}
\newcommand{\oP}{{\open P}}
\newcommand{\oQ}{{\open Q}}
\newcommand{\oR}{{\open R}}
\newcommand{\oZ}{{\open Z}}



\newcommand{\Nu}{{\cal V}}
\newcommand{\cA}{{\cal A}}
\newcommand{\cB}{{\cal B}}
\newcommand{\cC}{{\cal C}}
\newcommand{\cD}{{\cal D}}
\newcommand{\cF}{{\cal F}}
\newcommand{\cH}{{\cal H}}
\newcommand{\cK}{{\cal K}}
\newcommand{\cI}{{\cal I}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cM}{{\cal M}}
\newcommand{\cN}{{\cal N}}
\newcommand{\cO}{{\cal O}}
\newcommand{\cP}{{\cal P}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cS}{{\cal S}}
\newcommand{\cU}{{\cal U}}
\newcommand{\cV}{{\cal V}}
\newcommand{\cT}{{\cal T}}
\newcommand{\cX}{{\cal X}}

\newcommand{\rH}{^{*}}
\newcommand{\rT}{^{ \raisebox{1.2pt}{}}}
\newcommand{\rF}{_{ \raisebox{-1pt}{}}}
\newcommand{\rE}{{\rm E}}

\newcommand{\dom}{\hbox{dom}}
\newcommand{\rng}{\hbox{rng}}
\newcommand{\Span}{\hbox{span}}
\newcommand{\Ker}{\hbox{Ker}}
\newcommand{\On}{\hbox{On}}
\newcommand{\otp}{\hbox{otp}}
\newcommand{\ZFC}{\hbox{ZFC}}
\def\Re{\ensuremath{\hbox{Re}}}
\def\Im{\ensuremath{\hbox{Im}}}
\newcommand{\SNR}{\ensuremath{\hbox{SNR}}}
\newcommand{\CRB}{\ensuremath{\hbox{CRB}}}
\newcommand{\diag}{\ensuremath{\hbox{diag}}}
\newcommand{\trace}{\ensuremath{\hbox{tr}}}


\newcommand{\dlot}{\mbox{}}
\newcommand{\Dlot}{\mbox{}}
\newcommand{\Dlof}{\mbox{}}
\newcommand{\dlof}{\mbox{}}
\newcommand{\bP}{\mbox{}}
\newcommand{\Pot}{\mbox{}}
\newcommand{\Sot}{\mbox{}}
\newcommand{\gDot}{\mbox{}}

\newcommand{\Potr}{\mbox{}}
\newcommand{\Sotr}{\mbox{}}
\newcommand{\gDotr}{\mbox{}}

\newcommand{\Pofr}{\mbox{}}
\newcommand{\Sofr}{\mbox{}}
\newcommand{\Dofr}{\mbox{}}


\newcommand{\Sa}{\mbox{}}
\newcommand{\Qk}{\mbox{}}
\newcommand{\Ca}{\mbox{}}

\newcommand{\gkp}{\mbox{}}
\newcommand{\aron}{ Aronszajn }

\newcommand{\sqkp}{\mbox{}}
\newcommand{\dkp}{\mbox{}}
\newcommand{\sqsqnce}
{\mbox{\\  \ \ }}
\newcommand{\dsqnce}{\mbox{}}



\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newcounter{definition}
\newtheorem{definition}{Definition}



\newcommand{\beq}{}
\newcommand{\bea}{\begin{array}}
\newcommand{\ena}{\end{array}}
\newcommand{\bdf}{\begin{definition}}
\newcommand{\blm}{\begin{lemma}}
\newcommand{\edf}{\end{definition}}
\newcommand{\elm}{\end{lemma}}
\newcommand{\bthm}{\begin{theorem}}
\newcommand{\ethm}{\end{theorem}}
\newcommand{\bprp}{\begin{prop}}
\newcommand{\eprp}{\end{prop}}
\newcommand{\bcl}{\begin{claim}}
\newcommand{\ecl}{\end{claim}}
\newcommand{\bcr}{\begin{coro}}
\newcommand{\ecr}{\end{coro}}
\newcommand{\bquest}{\begin{question}}
\newcommand{\equest}{\end{question}}

\newcommand{\rarrow}{{\rightarrow}}
\newcommand{\Rarrow}{{\Rightarrow}}
\newcommand{\larrow}{{\larrow}}
\newcommand{\Larrow}{{\Leftarrow}}
\newcommand{\restrict}{{\upharpoonright}}
\newcommand{\nin}{{\not \in}}











\newcommand{\ie}{\hbox{i.e.}}
\newcommand{\eg}{\hbox{e.g.}}





 

\newenvironment{proof}{\textit{Proof:}}{\hfill\\}
\newtheorem{observation}{Observation}
\newtheorem{theorem}{Theorem}
\begin{document}
\title{ Expected time complexity of the auction algorithm and the push relabel algorithm for maximal bipartite matching on random graphs }
\author{Oshri Naparstek and Amir Leshem}
\date{\today}
\maketitle
\begin{abstract}
In this paper we analyze the expected time complexity of the auction algorithm for the matching problem on random bipartite graphs. We prove that the expected time complexity of the auction algorithm for bipartite matching is  on sequential machines. This is equivalent to other augmenting path algorithms such as the HK algorithm. Furthermore, we show that the algorithm can be implemented on parallel machines with  processors and shared memory with an expected time complexity of .

\end{abstract}

\section {Introduction}
 One of the most extensively studied problems in combinatorial optimization in the last 50 years known as the Bipartite Maximum Cardinality Matching (BMCM). The main goal of the BMCM problem is to find an assignment where the maximal number of vertices are matched on bipartite graphs, thus making it a special case of the max-flow problem as well as the max-sum assignment problem. Hence, any algorithm that solves one of these problems also solves the BMCM problem. Most of the algorithms that solve the BMCM problem are augmenting paths algorithms.The Hopcroft-Karp (HK) algorithm \cite{hopcroft1973n} is one of the most well-studied of these. The HK algorithm has a worst case time complexity of  where  is the number of vertices in the bipartie graph and  is the number of edges in the graph. The HK algorithm was revisited more recently by Feder and Motwani \cite{feder1991clique} and was proven to have a worst case time complexity of . Another well known augmenting path algorithm that solves the BMCM problem is Dinic's algorithm \cite{dinic1970algorithm}. Motwani \cite{motwani1994average} proved that Dinic's algorithm achieves perfect matching on random bipartite graphs with an expected running time of  where  is the expected number of neighbours per vertex. It was later shown by Bast et al. \cite{bast2006matching} that algorithms that use the shortest augmenting paths, have an expected time complexity of . Recently it was shown by Frize et al. \cite{chebolu2010finding} that maximum cardinality matching can be found on sparse random graphs with an expected time complexity of  using a combination of the Karp-Sipser heuristic and an augmenting path. Goel et al. \cite{goel2010perfect} presented an algorithm with an expected time of  iterations on regular bipartite graphs.

 Other solutions to the BMCM problem that do not use the augmenting path method include the auction algorithm \cite{bertsekas1979distributed} and the push relabel (PR) algorithm \cite{goldberg1988new}. The main difference between the augmenting path algorithms described above and these algorithms is that in augmenting path algorithms, an augmenting path is first found and then augmented. By contrast, in the auction and PR algorithms, only two edges are augmented on each iteration according to some update rule. It was shown by both Goldberg \cite{goldberg1995efficient} and Bertsekas \cite{bertsekas1992forward} that the push relabel algorithm and the auction algorithm are equivalent. Since these algorithms are equivalent we will refer only to the auction algorithm from now on.
 The average time complexity of the auction algorithm is not known and the problem of calculating it has remained unresolved  more than  years. However, in many cases it has been shown that the auction algorithm converges faster than other methods in solving the assignment problem \cite{bertsekas1990auction}. Furthermore, several experimental studies \cite{setubal1993new,setubal1996sequential,cherkassky1998augment,kaya2012push} showed that in practice, auction algorithms outperforms augmenting paths based algorithms on many real life scenarios for the solution of the BMCM problem. Bertsekas \cite{bertsekas1991reverse} conjectured that the average running time of the auction algorithm would be  on bipartite graphs with uniformly distributed weights where m is the number of edges in the bipartite graph and  is the number of vertices on each side of the graph.

In this paper we analyze the average time complexity of the auction algorithm for the BMCM problem.
We prove that the expected time complexity of the auction algorithm for random bipartite graphs where each edge is independently selected with probability  is   on sequential machines. We show that by reducing the density of the graph such that  the complexity reduces to . We then present a parallel implementation of the algorithm for parallel machines with  processors and a shared memory. We prove that the expected time complexity of the parallel implementation is .

\section {Notation and problem formulation}

\begin{definition}
Let  be a graph with a vertex set  and an edge set . The neighbor set of vertex  is given by
\beq
n_v=\left\{u \in V: \{u,v\}\in E\right\}
\eeq
\end{definition}
\begin{definition}
Let  be bipartite graph with vertex sets  and an edge set . Let  and let  be a bipartite subgraph of  with vertex sets  and an edge set . We say that  is a matching on  if
\beq
\max_{v\in U\cup V}|n_v|=1
\eeq
\end{definition}
\begin{definition} Let  be bipartite graph with vertex sets  and an edge set . If  is a matching and  then we say  is a perfect matching.
\end{definition}
\begin{definition}
Let  be bipartite graph with vertex sets  and an edge set . Let  and let  be a bipartite subgraph of  with vertex sets  and an edge set .
We say that a vertex  is free if  otherwise we say it is not free.
\end{definition}
\begin{definition}
 Let  be a graph with vertex set  and an edge set . A \emph{path}  of length  is an ordered set with  vertices  such that  and .
\end{definition}
\begin{definition}
Let  be bipartite graph with vertex sets  and an edge set . Let  be a non-maximal matching on .  An \emph{alternating path}  on  given partial matching  is a path where  if  is even and  if  is odd. An illustration of an alternating path is shown in Fig \ref{figure_alternating_path}.
\end{definition}
\begin{figure}[htbp]
\centering \includegraphics[width=0.3\textwidth]{a_path.pdf}
\caption{Alternating path \ref{lemma_neighbor} }
\label{figure_alternating_path}
\end{figure}
\begin{definition}
Let  be a bipartite graph with vertex sets  and an edge set . Let  be a non-maximal matching. An \emph{augmenting path} of  is an alternating path on  that starts at a free vertex in  and ends at a free vertex in .
\end{definition}
The BMCM problem is defined as follows:
 Let  be a bipartite graph with vertex set  and an edge set . Find an assignment  with maximal number of edges.



\section{The auction algorithm}
\label{section_auction_alg}
The auction algorithm \cite{bertsekas1979distributed} is an intuitive method for solving the assignment problem. In many cases it has been shown to converge faster than other methods for this case \cite{bertsekas1990auction}. Auctions in which unassigned people raise their prices and bid for objects simultaneously was the original inspiration for the auction algorithm. Similarly, the auction algorithm has two stages, the bidding stage and the assignment stage. In the bidding stage each unassigned individual raises the price of the object he wishes to acquire by the difference between the most profitable object and the second most profitable object plus some constant . In the assignment stage every object is assigned to the highest bidder. The two stages are repeated until all bidders are assigned an object. More specifically, let  be the matrix of the initial rewards. Let  be a matrix of the bids.  is the price vector where  is given by:
\beq\label{eq_rho}
\rho_k=\max_{n}\textbf{B}(n,k)
\eeq
Let  be an assignment (permutation) vector  where  is the object that is assigned to the 'th person; i.e., the matching  is a perfect matching.
\beq
(U_n,V_{\eta_n})\in M
\eeq
\begin{definition} An object  is said to be \emph{assigned} to person  by  if .
\end{definition}
\begin{table}
\caption{The Auction algorithm (Bertsekas 79)}
\label{table_auction_alg}
\begin{tabular}{l}
\hline
Select , set all the people as unassigned and set \\
\textbf{Repeat until all the people are assigned}\\
\ \ 1. Choose an unassigned person \\
\ \ 2. Calculate his maximum profit  \\
\ \ 3. Calculate the second maximum profit\\
\ \ \ \ \ \\
\ \ \ \ \ \\
\ \ 4. Assign object  to person . If this object has been\\
\ \ \ \ \ assigned to another person, make this \\
\ \ \ \ \ person unassigned (and as a result unassigned).\\
\ \ 5. Set person  as assigned\\
\ \ 6. Update the price of object  to be \\
\ \ \ \ \ \\
\textbf{end} \\
\hline
\end{tabular}
\end{table}
The reward of the 'th person on assignment  is denoted by 
and the price that the 'th person pays on assignment  is denoted by
.
Given a positive scalar , an assignment  and a price , a person  is termed \emph{happy} with assignment  if the profit (i.e., reward minus price) is within  of the maximal profit achievable by person . This condition is called -Complementary slackness (-CS).
\beq\label{eq_ecs}
\textbf{R}(n,\eta_n)-\rho_{\eta_n}\geq\max_k(\textbf{R}(n,k)-\rho_k)-\epsilon
\eeq
When all the people are assigned and happy, the algorithm stops. It was shown in \cite{bertsekas1979distributed} that the algorithm terminates in finite time. The algorithm is within  of being optimal at termination \cite{bertsekas1979distributed}. Also, if the initial prices are all zeros and  the algorithm still converges in finite time and with the same bounds on optimality. The original Bertsekas auction algorithm is depicted in Table \ref{table_auction_alg}.
\section{A simplified auction algorithm for maximal bipartite matching}
The BMCM problem is a special case of the assignment problem where the values in the reward matrix are either  or . Furthermore, since the reward matrix is integer valued, the choice of  is sufficient for obtaining an optimal solution \cite{bertsekas1979distributed}. The cardinality of a matching is the number of vertices that were assigned to edges with weight .
Here we simplify the auction algorithm and assume that on each iteration an unassigned person is picked and raises the price of his most desirable object by exactly .  Under this assumption, the price
\beq
\rho_k=\frac{h_k}{N}
\eeq
where  is the number of times that the price of the 'th object was raised.
We further simplify the algorithm and assume that a person would only bid on objects with positive rewards.
Under this assumption the -CS condition \ref{eq_ecs} for an object with a positive reward becomes:
\beq
1-\frac{h_{\eta_n}}{N}\geq\max_k(1-\frac{h_k}{N})-\frac{1}{N}.
\eeq
Multiplying both sides by  and rearranging yields a simplified -CS condition for the BMCM problem
\beq\label{eq_ecs_bipart}
h_{\eta_n}-1\leq\min_k(h_k).
\eeq
Using the simplified -CS condition we can derive a simplified version of the auction algorithm for the BMCM problem.
On each iteration an unassigned person is chosen, the person is assigned to the 'th channel with minimal  and raises it by .
The description of the algorithm using graph theory terminology is as follows:
Let  be a bipartite graph with vertex sets  where  and an edge set . Let  be the value assigned to the vertices in . On each iteration a free vertex  is  assigned to a vertex  with minimal value . If another vertex was previously assigned to that vertex it becomes free. The algorithm stops after a perfect matching is found or the number of iterations is larger than .
The algorithm is depicted in Table \ref{table_alg}. Note that the simplified auction algorithm is equivalent to the push relabel algorithm with double push \cite{goldberg1995efficient}.
\begin{table}
\label{table_alg}
\caption{Simplified auction algorithm for maximal matching in bipartite graphs}
\begin{enumerate}
\item Initialize  and set 
\item While  and  do
\begin{enumerate}
\item Choose a free vertex 
\item 
\item 
\item 
\item 
\item 
\end{enumerate}
\item Return
\end{enumerate}

\end{table}


\section{The average number of iterations of the simplified auction algorithm for the BMCM problem}
\label{section_alg}
In this section we analyze the expected time complexity of the simplified auction algorithm for the BMCM problem.
\begin{observation} \label{lamma_T_sum_H}Let  be the number of iterations until the algorithm terminates and let  be the value of vertex  at termination, then
\beq
T=\sum_{v=1}^N h_v
\eeq
\end{observation}

\begin{proof}
The proof is trivial since on every iteration the value of exactly one vertex is increased by .
\end{proof}
\begin{lemma}
\label{lemma_neighbor}Let  be a bipartite graph with vertex sets  and an edge set . Let  be a non maximal matching obtained by the algorithm in the 'th iteration. Let  be the value of vertex  in the 'th iteration of the algorithm.
Let  be a subset of  defined by:
\beq
D_l(i)=\left\{v\in V:h_v(i)\geq l\right\}.
\eeq
If  and  then
\beq
n_u\subseteq D_{l-1}(i)
\eeq
\end{lemma}

\begin{proof}
If  and  it implies that  for some  and
\beq
h_{v_0}(k+1)=h_{v_0}(k)+1=l.
\eeq
This implies that for every vertex  in the 'th iteration
\beq
h_{v}(k+1)\geq h_v(k+1)-1=h_v(k)=l-1.
\eeq
This implies that in the 'th iteration
\beq
n_u\subseteq D_{l-1}(k).
\eeq
Since  is a non-decreasing function of  (prices never go down)
\beq
n_u\subseteq D_{l-1}(k)\subseteq D_{l-1}(i).
\eeq
\end{proof}
An illustration of lemma \ref{lemma_neighbor} is given in Figure \ref{figure_neghbor}.
\begin{figure}[htbp]
\centering \includegraphics[width=0.45\textwidth]{bipart1.pdf}
\caption{An illustration of lemma \ref{lemma_neighbor} }
\label{figure_neghbor}
\end{figure}
\begin{claim}
\label{lemma_dl_1} Let  be bipartite graph with vertex sets  and an edge set . Let  be a non maximal matching obtained by the algorithm in the 'th iteration. Let  be a free vertex such that in the 'th iteration of the algorithm . Let  be the end point of an alternating path  with  starting from  then
\beq
\bea{ll}
v\not\in D_{l-2}(i)\setminus D_{l-1}(i)& \forall v\in n_{u_{1}}
\ena
\eeq
\end{claim}
\begin{proof}
We first observe that if , then by definition for every vertex 
\beq
v\not\in D_{l-1}(i)\setminus D_{l}(i).
\eeq
By the definition of an alternating path, if  there exists a vertex  such that ,  and .
Hence, by lemma \ref{lemma_neighbor} it implies that
\beq
n_{u_{1}}\subseteq D_{l-1}(i).
\eeq
Reapplying the lemma implies that for every vertex 
\beq
v\not\in D_{l-2}(i)\setminus D_{l-1}(i).
\eeq
\end{proof}


\begin{lemma}
\label{lemma_max_h} Let  be bipartite graph with vertex sets  and an edge set . Let  be a non maximal matching obtained by the algorithm in the 'th iteration and let  be a free vertex such that in the 'th iteration of the algorithm ;  then every augmenting path of  on  starting from  is at least of length .
\end{lemma}

\begin{proof}
Let  be the end point of an alternating path  with  starting from .
By recursively applying claim \ref{lemma_dl_1} we get that for every vertex 
\beq\label{eq_D0D1}
v\not\in D_{l-m-1}(i)\setminus D_{l-m}(i).
\eeq
The last vertex in an augmenting path is a free vertex.
Note that a vertex  is free only if
\beq
v\in D_{0}(i)\setminus D_{1}(i).
\eeq
However, from equation \ref{eq_D0D1} if  then for all ,
\beq
\bea{ll}
v\not\in D_{0}(i)\setminus D_{1}(i).
\ena
\eeq
This means that if  is an augmenting path that starts from  there are at least  odd elements on  .
This implies that any augmenting path that starts from  has at least  elements.
\end{proof}
A well-known theorem by Berge \cite{berge1957two} states that if a bipartite graph  contains a perfect matching there exists an augmenting path in  with respect to any non maximal matching .
\begin{theorem}\cite{berge1957two}
 \label{theorem_augment}  Let  be a bipartite graph with vertex sets  and an edge set . If  contains a perfect matching there exists an augmenting path in  for any partial matching .
 \end{theorem}
We will now use the above theorem and lemma \ref{lemma_max_h} to prove the following lemma:
\begin{lemma}
 \label{lemma_neighbour_less_l} Let  be a bipartite graph with vertex sets  and an edge set . If  contains a perfect matching and for any non-perfect matching   there exists an augmenting path of length at most , then for each free vertex  and a partial matching  obtained by the algorithm in the th iteration there exists at least one neighbor  such that  on each iteration of the algorithm.
 \end{lemma}
\begin{proof}

Assume towards contradiction that  contains a perfect matching and for any non-perfect matching   there exists an augmenting path of length at most  but on the 'th iteration there exists a free vertex  with respect to  such that if  then . This means that . By lemma \ref{lemma_max_h} each augmenting path that begins at  is of length of at least . However, our assumption is that for any non maximal matching  of  there exists at least one augmenting path of length  or less. This implies that  is not the starting vertex of any augmenting path of  on . This also implies that  is not the starting vertex of any augmenting path of  on  for any . This is true since we know from lemma \ref{lemma_neighbor} that
\beq
D_{m}(i)\subseteq D_{m}(j),\forall m,\forall j\geq i
\eeq
 Hence,  is not the starting vertex of an augmenting path of  on  where . This implies that there is no augmenting path of length at most  to . This can occur in two situations:
  \begin {enumerate}
  \item No augmenting path exists to  on . Theorem \ref{theorem_augment} implies that no perfect matching exists for  in contradiction to the assumption that a perfect matching exists.
  \item There exists an augmenting to  on  but with length at least . This is a contradiction to our assumption that every non maximal matching contains an augmenting path of length at most 
  \end{enumerate}
\end{proof}
\begin{lemma}
\label{lemma_h_less_2l} Let  be a bipartite graph with vertex sets  and an edge set . If  contains a perfect matching and for any non-perfect matching  there exists an augmenting path of length at most , then for every  at each iteration of the algorithm until the algorithm terminates
\beq
h_v(i)\leq l+1 ,\forall i,v\in V
\eeq
\end{lemma}
\begin{proof}
On each iteration , the free vertex from  select a vertex  such that  and set . However, we assume that  contains a perfect matching and for any non-perfect matching  there exists an augmenting path of length at most . Hence, by lemma \ref{lemma_neighbour_less_l} to any free vertex at the 'th iteration with respect to a partial matching  there exists a vertex  such that . This means
\beq
\min_{v\in n_u}h_v(i)\leq l,\forall i.
\eeq
As a result, if there exists vertex  where  then
\beq
\arg\min_{v\in n_u}h_v(i)\neq v_0.
\eeq
This implies that if  its value never rises and as a result
\beq
h_v(i)\leq l+1 ,\forall i,v\in V.
\eeq
\end{proof}
\begin{lemma}
 \label{lemma_worst_case}Let  be a bipartite graph with vertex sets  and an edge set . If  contains a perfect matching then
\beq
T\leq N(N-1)
\eeq
\end{lemma}
\begin{proof}
 contains  vertices. Hence, every path is of length at most  and in particular every augmenting path is of length at most  for any non maximal matching.
By lemma \ref{lemma_h_less_2l} we get that
\beq
h_v(i)\leq N-1 ,\forall i,v\in V
\eeq
Using lemma \ref{lamma_T_sum_H} we get:
\beq
T=\sum_{v=1}^N h_v\leq N(N-1)
\eeq
\end{proof}
\begin{definition}   Let  be bipartite graph with vertex sets  and an edge set . If  is a random graph where each edge occurs with probability  we say that .
\end{definition}
\begin{definition}
 if  and for any non-maximal matching  there exists an augmenting path for  of length at most  where  and  is some constant.
\end{definition}
\begin{observation} \label{lemma_log_path_alg} Let  and let and let  be the number of iterations until the algorithm terminates then
\beq
T\leq N(L+1).
\eeq
where .
\end{observation}
\begin{proof}
; hence, for any non maximal matching  there exists an augmenting path of length at most .
let , then
by lemma \ref{lemma_h_less_2l} we get that
\beq
h_v(i)\leq L+1 ,\forall i , v\in V.
\eeq
Using lemma \ref{lamma_T_sum_H} we get:
\beq
T=\sum_{v=1}^N h_v\leq N(L+1)=\frac{N\tilde {c}\log(N)}{\log(Np)}+N.
\eeq
\end{proof}
The following theorem was proven in \cite{motwani1994average}:
\begin{theorem}\label{lemma_prob_bnp} Let  where  then for every  there exists  such that for every 
\beq
\Pr(G\in \tilde{B}(N,p))\geq 1-N^{-\gamma}.
\eeq
\end{theorem}
The following theorem was proven in \cite{erdHos1966existence}:
\begin{theorem} \label {theorem_prob_perfect}Let  and  then
\beq
\lim_{N\to\infty}\Pr\left(G \textrm{ contains a perfect matching}\right)=e^{-2N^{1-c}}.
\eeq
\end{theorem}
We now prove the main theorem of the paper:
\begin{theorem}\label{theorem_N_iter} Let  be a random bipartite graph with  vertices on each side and . Then the expected number of iterations until the algorithm terminates is:
\beq
E(T)\leq O\left(\frac{N\log(N)}{\log(Np)}\right)
\eeq
\end{theorem}
\begin{proof}
Let
\beq
A=\{G\in B(N,p): G \textrm{ does not contains a perfect matching}\}
\eeq
and let
\beq
B=\{G\in B(N,p)\setminus \tilde{B}(N,p)\}.
\eeq
From Theorem \ref{lemma_prob_bnp} we know that there exists  such that for every 
\beq
\Pr\left(B\right)\leq N^{-\gamma}.
\eeq
From theorem \ref{theorem_prob_perfect} we know that if ,  and , there exists  such that for every 
\beq
\Pr\left(A\right)\leq \frac{2}{N^{c-1}}\leq \frac{2}{N}.
\eeq
let  and let  be
\beq
\tilde{N}=\max(N_{\gamma},N_1)
\eeq
let   be
\beq
\displaystyle \breve{B}(N,p)=\left\{G:G \textrm{ contains a perfect matching}\right\}\cap\tilde{B}(N,p).
\eeq
Using the union bound,
\beq
\displaystyle \Pr\left(G\in \breve{B}(N,p)\right)=1-\Pr\left(A\cup B\right)\geq 1-\Pr(A)-\Pr(B)
\eeq
If ,  then
\beq
\Pr\left(G\in \breve{B}(N,p)\right)\geq 1-\frac{3}{N}.
\eeq

From lemma \ref{lemma_worst_case} and Lemma \ref{lemma_log_path_alg} we know that:
\beq
T\leq \left\{\begin{matrix} N(N-1),
& G\not\in \breve{B}(N,p)  \\
\frac{N\tilde {c}\log(N)}{\log(Np)}+N,
 & G\in \breve{B}(N,p)
\end{matrix}\right. ,
\eeq

this implies that if ,  then
\beq
\bea{l}
\displaystyle E\left(T\right)\leq \left(1-\frac{3}{N}\right)\left(\frac{N\tilde {c}\log(N)}{\log(Np)}+N\right)+\frac{3}{N}(N^2-N)=\\
\displaystyle = O\left(\frac{N\log(N)}{\log(Np)}\right).
\ena
\eeq
If  the number of iterations is
\beq
O\left(\frac{N\log(N)}{\log(\log(N))}\right).
\eeq
\end{proof}


\section{Expected time complexity}
In this section we use the results from the previous section to analyze the expected time complexity of the algorithm in sequential and parallel implementations. We first prove that the expected running time of the algorithm is  on sequential machines. We point out that if the graph is dense it is advantageous to take a random sparse subgraph of the original graph and perform the algorithm on the sparse subgraph. Then, we introduce a parallel implementation of the algorithm for machines with  processors and a shared memory. We prove that if  the expected time complexity is .
\subsection{Sequential implementation}\label {subsection_seq}
We now analyze the expected time complexity of the algorithm for random bipartite graphs from  on sequential machines. From Theorem \ref{theorem_N_iter} we know that the expected number of iterations is bounded by . Hence we need to show that the expected numbed of operations per iteration is . The next theorem shows that the algorithm can be implemented with   time complexity on sequential machines.

\begin{theorem}\label{theorem_seq} Let  be a random bipartite graph with , then the algorithm finds a maximal matching on a sequential machine with one processor with the expected time bounded by 
\end{theorem}
\begin{proof}

In section \ref{section_alg} we proved that the expected number of iterations until convergence is bounded by
\beq
E\left(T\right)\leq O\left(\frac{N\log(N)}{\log(Np)}\right)
\eeq
where  is the number of iterations until convergence.
Define  to be the number of operations needed in each iteration and  to be the total number of operations preformed by the algorithm.


All of the operations in each iterations are  except for the operation of finding a vertex with minimal value for the chosen vertex  which requires  operations where  is the number of neighbours of vertex . Since the number of neighbors of each vertex is an independent random variable and   then
\beq
E\left(T_{total}\right)=E\left(T\right)E\left(T_{inner}\right)=O\left(\frac{pN^2\log(N)}{\log(Np)}\right)
\eeq
If  then
\beq
E\left(T_{total}\right)=O\left(\frac{N\log^2(N)}{\log\log(N)}\right)
\eeq
\end{proof}
When the graph is dense; i.e.,  the algorithm converges with a time complexity of  which is not particularly good. To improve the expected running time performance, we can obtain a sparse random graph from the dense graph by randomly choosing  edges from the original dense graph where  is binomially distributed as
\beq
d\sim Bin(|E|,\frac{c\log(N)}{Np})
\eeq
Let  be the sparse graph obtained from  by randomly selecting  edges of . If  contains a perfect matching, a solution for the MCM problem for  is also a solution for . If  doest not contain a perfect matching the algorithm is applied on  with  iterations. Hence, the expected time complexity even for dense graphs remains:
\beq
\bea{l}
\displaystyle E\left(T_{total}\right)\leq\left(1-\frac{2}{N}\right)O\left(\frac{N\log^2(N)}{\log\log(N)}\right)+\frac{2}{N}O\left(N^2\log(N)\right)=\\
\displaystyle =O\left(\frac{N\log^2(N)}{\log\log(N)}\right)
\ena
\eeq

\subsection{Parallel Implementation}
We now analyze a parallel implementation of the algorithm on a machine with  processors and a shared memory. We show that if  the expected time complexity of the algorithm is . As in the sequential case, the expected number of outer iterations is . This implies that for  . In the parallel implementation we keep a sorted tree for each vertex of . If  is a random graph with  then
\beq
\bea{ll}
E(|n_u|)=c\log(N), & \forall u\in U\\
E(|n_v|)=c\log(N), & \forall v\in V\\
\ena
\eeq
This implies that on each iteration we need to maintain  sorted trees with an expected number of  elements per tree. The maintenance of each sorted tree can be done in parallel over  processors with  operations per processor. Hence, the expected time complexity for the parallel implementation is given by:
\beq
E(T_{total})=E(T)E(T_{inner})=O\left(\frac{N\log^2(N)}{Q}\right)
\eeq
and if  the expected time becomes
\beq
E(T_{total})=O\left(N\log(N)\right)
\eeq

Note that if  is not sparse we can obtain a sparse graph from the dense graph and use the same arguments as in the sequential implementation to get
\beq
E(T_{total})=O\left(N\log(N)\right)
\eeq

\section {Conclusion}
In this paper we analyzed the expected time complexity of the auction algorithm for the matching problem on random bipartite graphs. We proved that the expected time complexity of the auction algorithm for bipartite matching is just as good as other augmenting path algorithms such  as the HK algorithm. Furthermore, we showed that the algorithm can be implemented on parallel machines with  processors and a shared memory with an expected time complexity of .




\bibliographystyle{amsalpha}
\newcommand{\etalchar}[1]{}
\providecommand{\bysame}{\leavevmode\hbox to3em{\hrulefill}\thinspace}
\providecommand{\MR}{\relax\ifhmode\unskip\space\fi MR }
\providecommand{\MRhref}[2]{\href{http://www.ams.org/mathscinet-getitem?mr=#1}{#2}
}
\providecommand{\href}[2]{#2}
\begin{thebibliography}{BoTLfIS90}

\bibitem[BC92]{bertsekas1992forward}
D.P. Bertsekas and D.A. Casta{\~n}on, \emph{A forward/reverse auction algorithm
  for asymmetric assignment problems}, Computational Optimization and
  Applications \textbf{1} (1992), no.~3, 277--297.

\bibitem[BCT91]{bertsekas1991reverse}
D.P. Bertsekas, D.A. Castanon, and H.~Tsaknakis, \emph{Reverse auction and the
  solution of inequality constrained assignment problems}, Unpublished Report
  (1991).

\bibitem[Ber57]{berge1957two}
C.~Berge, \emph{Two theorems in graph theory}, Proceedings of the National
  Academy of Sciences of the United States of America \textbf{43} (1957),
  no.~9, 842.

\bibitem[Ber79]{bertsekas1979distributed}
D.P. Bertsekas, \emph{A distributed algorithm for the assignment problem}, Lab.
  for Information and Decision Systems Working Paper, MIT (1979).

\bibitem[BMST06]{bast2006matching}
Holger Bast, Kurt Mehlhorn, Guido Schafer, and Hisao Tamaki, \emph{Matching
  algorithms are fast in sparse random graphs}, Theory of Computing Systems
  \textbf{39} (2006), no.~1, 3--14.

\bibitem[BoTLfIS90]{bertsekas1990auction}
D.P. Bertsekas, Massachusetts~Institute of~Technology. Laboratory~for
  Information, and Decision Systems, \emph{An auction algorithm for shortest
  paths}, Massachusetts Institute of Technology, Laboratory for Information and
  Decision Systems, 1990.

\bibitem[CF{\etalchar{+}}10]{chebolu2010finding}
Prasad Chebolu, Alan Frieze, et~al., \emph{Finding a maximum matching in a
  sparse random graph in o (n) expected time}, Journal of the ACM (JACM)
  \textbf{57} (2010), no.~4, 24.

\bibitem[CGM{\etalchar{+}}98]{cherkassky1998augment}
Boris~V Cherkassky, Andrew~V Goldberg, Paul Martin, Jo{\~a}o~C Setubal, and
  Jorge Stolfi, \emph{Augment or push: a computational study of bipartite
  matching and unit-capacity flow algorithms}, Journal of Experimental
  Algorithmics (JEA) \textbf{3} (1998), 8.

\bibitem[Din70]{dinic1970algorithm}
Efim~A Dinic, \emph{Algorithm for solution of a problem of maximum flow in
  networks with power estimation}, Soviet Math. Dokl, vol.~11, 1970,
  pp.~1277--1280.

\bibitem[ER66]{erdHos1966existence}
P.~Erd{\H{o}}s and A.~R{\'e}nyi, \emph{On the existence of a factor of degree
  one of a connected random graph}, Acta Mathematica Hungarica \textbf{17}
  (1966), no.~3, 359--368.

\bibitem[FM91]{feder1991clique}
Tom{\'a}s Feder and Rajeev Motwani, \emph{Clique partitions, graph compression
  and speeding-up algorithms}, Proceedings of the twenty-third annual ACM
  symposium on Theory of computing, ACM, 1991, pp.~123--133.

\bibitem[GK95]{goldberg1995efficient}
Andrew~V Goldberg and Robert Kennedy, \emph{An efficient cost scaling algorithm
  for the assignment problem}, Mathematical Programming \textbf{71} (1995),
  no.~2, 153--177.

\bibitem[GKK10]{goel2010perfect}
Ashish Goel, Michael Kapralov, and Sanjeev Khanna, \emph{Perfect matchings in o
  (n log n) time in regular bipartite graphs}, Proceedings of the 42nd ACM
  symposium on Theory of computing, ACM, 2010, pp.~39--46.

\bibitem[GT88]{goldberg1988new}
Andrew~V Goldberg and Robert~E Tarjan, \emph{A new approach to the maximum-flow
  problem}, Journal of the ACM (JACM) \textbf{35} (1988), no.~4, 921--940.

\bibitem[HK73]{hopcroft1973n}
John~E Hopcroft and Richard~M Karp, \emph{An n\^{}5/2 algorithm for maximum
  matchings in bipartite graphs}, SIAM Journal on Computing \textbf{2} (1973),
  no.~4, 225--231.

\bibitem[KLMU12]{kaya2012push}
Kamer Kaya, Johannes Langguth, Fredrik Manne, and Bora U{\c{c}}ar,
  \emph{Push-relabel based algorithms for the maximum transversal problem},
  Computers \& Operations Research (2012), 1266--1275.

\bibitem[Mot94]{motwani1994average}
R.~Motwani, \emph{Average-case analysis of algorithms for matchings and related
  problems}, Journal of the ACM (JACM) \textbf{41} (1994), no.~6, 1329--1356.

\bibitem[S{\etalchar{+}}96]{setubal1996sequential}
Jo{\~a}o~C Setubal et~al., \emph{Sequential and parallel experimental results
  with bipartite matching algorithms}, University of Campinas, Tech. Rep.
  IC-96-09 (1996).

\bibitem[Set93]{setubal1993new}
Jo{\~a}o~C Setubal, \emph{New experimental results for bipartite matching},
  Proceedings of netflow93 (1993), 211--216.

\end{thebibliography}

\end{document}
