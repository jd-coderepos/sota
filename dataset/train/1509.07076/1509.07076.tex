\documentclass[12pt,a4paper]{article}

\addtolength{\oddsidemargin}{-.6in}
\addtolength{\evensidemargin}{-.6in}
\addtolength{\textwidth}{1.2 in}
\addtolength{\topmargin}{-.7in}
\addtolength{\textheight}{1.1 in}
	

\usepackage{amsmath}                    \usepackage{amssymb}                    \usepackage{amsthm}                     \usepackage{amsfonts}                   \usepackage[pdftex]{graphicx} 
\usepackage{color}
\usepackage{bbm} 




\theoremstyle{definition}
\newtheorem{dfn}{Definition}
\theoremstyle{plain}
\newtheorem{thm}[dfn]{Theorem}
\newtheorem{prp}[dfn]{Proposition}
\newtheorem{lemma}[dfn]{Lemma}
\newtheorem{cor}[dfn]{Corollary}


\newenvironment{prf}{\noindent {\bf Proof.}}{\begin{flushright}\vspace{-2em}\footnotesize\normalsize\end{flushright}\smallskip}
\newenvironment{rmk}{\noindent {\bf Remark.}}{}
\newenvironment{claim}{\noindent {\bf Claim.}}{}

\begin{document}

\title{Graphic Realizations of Joint-Degree Matrices\footnote{All the results of this work are as of July 6, 2009. Throughout the paper, however, references to more recent works have been added, so that it is up to date.}}

\author{Georgios Amanatidis\thanks{Department of Informatics, Athens University of Economics and Business, Email: \textsf{gamana@aueb.gr}.
Supported in part by an ACO and an ARC 
Georgia Tech Fellowiship, and NSF-CCF-TF-0830683.}
\and Bradley Green\thanks{Facebook, Email: \textsf{Brg@fb.com}.
Supported in part by an NSF VIGRE Fellowship.} 
\and Milena Mihail\thanks{College of Computing, 
Georgia Institute of Technology, Email: \textsf{mihail@cc.gatech.edu}. 
Supported in part by NSF-CCF-0539972 and NSF-CCF-TF-0830683.}}

\date{\vspace{-5ex}}

\maketitle
\thispagestyle{empty} 

\hspace{1cm}

\begin{abstract}
In this paper we introduce extensions and modifications of the
classical degree sequence graphic realization problem studied by Erd\H{o}s-Gallai and Havel-Hakimi, 
as well as of the corresponding connected graphic realization version.
We define the joint-degree matrix graphic 
(resp. connected graphic) realization problem,
where in addition to the degree sequence, 
the exact number of desired edges 
between vertices of different degree classes
is also specified. 
We give necessary and sufficient conditions, and polynomial time decision and construction algorithms 
for the graphic and connected graphic realization problems.
These problems arise naturally in the current topic of graph modeling for complex networks.
From the technical point of view, 
the joint-degree matrix realization algorithm is straightforward.
However, the connected joint-degree matrix realization algorithm 
involves a novel recursive search of suitable local graph modifications.
Also, we outline directions for further work of both theoretical and practical interest. In particular,
we give a Markov chain which converges to the uniform distribution over all realizations. We show
that the underline state space is connected, and we leave the question of the mixing rate open.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

Let  be a sequence of integers.
The classical {\it graphic realization} problem asks
if there a simple graph on  vertices
whose degrees are exactly .
Erd\H{o}s and Gallai
showed that the natural necessary conditions for graphic realizability,
namely that each subset of the highest  degree vertices can absorb
their degrees within their subset and the degrees of the remaining vertices:
,
are also sufficient \cite{ErdosGallai,bergebook}.
The well known Havel-Hakimi
algorithm \cite{HavelHakimi1,HavelHakimi2} achieves
a realization
in an efficient greedy way. It repeatedly sorts the vertices according
to residual unsatisfied degree, picks any vertex
of residual degree ,
and connects it to the  vertices of highest residual degree.
The process is repeated until all the degrees are satisfied.
If one further wants to construct a {\it connected graphic realization}
(a requirement which is clearly important in networking),
Erd\H{o}s and Gallai showed that
the obvious necessary condition 
(i.e., there is a spanning tree) is also sufficient.
In particular, it is easy to see that a non-connected realization
can be transformed to a connected
realization by a sequence of flips, each flip breaking a cycle inside
a connected component, and reducing the number of
connected components by one.
A  ``flip''
picks two edges   and 
such that  and  are not edges,
removes  and  from the graph,
and adds  and  to the graph.
It is clear that flips do
not change the degrees of the graph.

Now, let  be a set of vertices.
Let 
be a partition of  denoting
subsets of vertices with the same degree and let 
be a function denoting the degree
of vertices in class .
Let  be a  matrix
denoting the number of edges between  and ;
if  it is the number of edges entirely within .
The {\it joint-degree matrix graphic realization} problem is,
given , decide
whether there is a simple graph  on , such that,
 each vertex in  has degree , 
 there are exactly  edges between  and ,
and, , there are exactly  edges entirely inside .
The {\it joint-degree matrix connected graphic realization} problem
is to decide whether a \emph{connected} graphic realization for 

exists. Furthermore, we want to either construct such a realization,
or output a certificate that no such graphic connected realization 
exists.
In this paper we give necessary and sufficient conditions, and polynomial (in ) time algorithms
for the decision and construction of the joint-degree graphic
and connected graphic realization problems.


The practical significance of joint-degree
matrix realization problems arises in graph
models for several classes of complex networks.
For instance, in networking, models for Internet
topologies are constantly used to simulate
network protocols and predict network evolution.
Commonly used topology generators, such as
GT-ITM \cite{Zegura2,Zegura3} which generates random nearly regular graphs,
and power-law based generators \cite{Faloutsos,ACL1,ACL2,Brite2,Inet,ALENEX03}, generate random graphs.
However, the properties of topologies constructed using
purely random graph models were challenged,
most notably in \cite{hot2,alderson}.
Using qualitative arguments and striking images,
they argued that 
power law random graphs construct a dense core
of nodes with very high degrees,
while nodes of smaller degree are mostly attached to the periphery of the
network. On the other hand, highly optimized Internet topologies
place low degree but very high bandwidth routers at the center of the network,
while high degree nodes are mostly placed in the periphery
to split the signal manyways toward the end users. 
To quantify their argument, \cite{alderson} used a random graph 

under several power law 
models \cite{nsbook2,nsbook3,chungbook2,newmanbook,durrettbook},
and a real network topology .
They found that
  
is much larger than
.
Independently, \cite{Newman1,Newman5} made the same observation
for several other technological and biological networks.

Going one step further, \cite{UCSDnet1,UCSDnet2}
argued that, 
a determining metric
for a graph of given degrees
to resemble a real network topology,
is the specific number of links
between vertices in different degree classes.
Using heuristics that presumably approximate
the target number of edges between degree classes, 
\cite{UCSDnet2} constructed graphs
strikingly similar to real network topologies. 
The joint-degree matrix graphic and connected graphic realization problems 
studied in Sections \ref{sec:algorithm1} and \ref{sec:algorithm2}
formalize the approach of \cite{UCSDnet1,UCSDnet2}. In general, one would want 
to construct a uniformly random realization of .
We state this as an open problem in Section 4. However, for practical purposes, 
the heuristics of \cite{UCSDnet1,UCSDnet2} achieved very satisfactory results 
using randomness in a configuration model adjusted to the  problem.
On the other hand, there are no theoretical results concerning the properties of this model.
In the same sense, our joint degree matrix realization algorithm in Section 2, also
allows substantial randomness in the choice of the edge to be added in each of its greedy steps.


In Section \ref{sec:algorithm1} we address the joint-degree matrix
graphic realizability problem. We show that the natural necessary conditions
are also sufficient, and can be checked efficiently. 
We also obtain a second polynomial time construction 
algorithm, which is a key for the algorithm in Section \ref{sec:algorithm2}.
This Balanced Degree Algorithm constructs the graph by increasing the number of
edges, without increasing the number of connected components.
In Section \ref{sec:algorithm2} we address 
the joint-degree matrix connected graphic realizability problem.
By sharp contrast to the degree sequence connected realization, 
here the necessary and sufficient conditions are fairly complex,
and of exponential size. However, using a recursive algorithm
that searches for suitable local graph modifications to construct
a connected graph, we manage to either construct such a graph in polynomial time, or identify 
at least one necessary condition that fails to hold. 
In Section \ref{sec:discussion} we discuss 
structural differences between degree sequence 
and joint-degree matrix problems. 
In particular, the former are known to be related to 
matchings, while no corresponding fact is known for the latter. 
Finally, in Section \ref{sec:discussion}, we propose a natural Markov chain 
for sampling from , and we show  that it is 
ergodic.

\noindent \textbf{Recent related work.} Independently, \cite{SP12, CDEM15, GTM15} give polynomial time algorithms for constructing a graph in . Moreover, in \cite{SP12} an alternative proof is proposed for the fact that the Markov chain we define in Section \ref{sec:discussion} is ergodic. This proof however was flawed, as noted in \cite{CDEM15}, where an alternative proof is given as well. With respect to the mixing time of this Markov chain, \cite{SP12} performed experiments based on the autocorrelation of each edge; these experiments
suggest that the Markov chain mixes quickly. In a more recent work, \cite{EMT15} shows fast mixing for a related Markov chain over the subset of  that contains the balanced realizations, i.e. realizations where for each  the edges connecting  to  are as uniformly distributed on  as possible. (Notice that this is not what we call a \emph{balanced} graph, e.g. in Lemma \ref{lem:last} or in Section \ref{sec:algorithm2}.)



\section{Joint-Degree Matrix Graphic Realization}
\label{sec:algorithm1}


Let  be a set of vertices and 

be a partition of  denoting
subsets of vertices with the same degree. Let 
be a function denoting the degrees
of vertices in class  and  be a  matrix
denoting the number of edges between  and ;
if  it is the number of edges entirely within .
The {\it joint-degree matrix graphic realization} problem is,
given , decide
whether there is a simple graph  on , such that,
 each vertex in  has degree ,
 there are exactly  edges between  and ,
and , there are exactly  edges entirely inside .
We use the notation 
to also denote the set of all such graphs.

We will prove that the following natural
necessary conditions for the instance 
to have a graphic realization are also sufficient:\smallskip\\
{\it (i) Degree feasibility}:
, for . \smallskip\\
{\it (ii) Matrix feasibility}:
The matrix  is symmetric with nonnegative integral entries,
and
, for ,
while
, for .\smallskip

There is a straightforward algorithm for constructing a graph 
. First, the algorithm
constructs a graph  that has the ``right'' number of edges
between any ,  (or within a ). Then, the degrees 
within each  are taken care of, resulting in a graph
.

The algorithm proceeds as follows:\medskip\\
Start with an empty graph  on \\
For each \\  choose arbitrarily  edges between
vertices of , and add them to \\
For each \\  choose arbitrarily  edges between
vertices of  and , and add them to \\
For each \\ 
 While not all degrees in  are equal\\
  Choose  such that 
and \\
  Find  
neighbors of  that are not neighbors of \\
  Disconnect them from  and connect them to \\
Output \medskip

To see that the algorithm works, first notice that if 
, for ,
and
, for 
the edge-adding part of the algorithm works. This results in a graph 
 that satisfies the  requirements, but not necessarily 
the degree requirements. 

Now, assume that there exist some  such that
not all the degrees in  are equal to . If 
, this means that there exist 
 such that 
and . Also, there are 
neighbors of  that are non-neighbors of , and 
.
Also, notice that each iteration in the ``while" loop reduces 
the number of ``wrong degrees" by at least one, without affecting 
the  requirements. That is, in at most  iterations
.\medskip

Although the Joint-Degree Matrix Graphic Realization problem has a
straightforward solution, this is not the case if we also ask for the resulting 
graph to be connected. Before we move to this problem, we  present an 
alternative algorithm for the Joint-Degree Matrix Graphic Realization
that we will need later.



\subsection*{Balanced Degree Algorithm}



\label{sec:BalancedDegreeAlgorithm}

This construction algorithm grows the graph 
in iterations, one edge at a time, starting from the empty graph ,
keeping the edges between each  and  always  
(resp. the edges within each  always  ),
and ending with a realization .
The key idea of the algorithm is to
maintain a {\it balanced degree invariant}
within each .
If  is the graph after iteration ,
the algorithm maintains 
,
for  (where  is the
degree of vertex  in graph , as usual).
This motivates the following definition.
For the graph  after iteration ,
for all , 
let 
and let .

The algorithm proceeds as follows: While there is some  and  (possibly )
such that  is not satisfied,
the construction algorithm picks any such  and 
and adds an edge between  and  (resp. inside ),
while maintaining the balanced degree invariant
and without affecting the extend to which the other 's
are satisfied.
Let us assume that we are at the beginning of the th
iteration, and  have been picked such that  is not satisfied.
Let  and assume  and  are suitably defined for all . 
There are several cases to consider:\smallskip \\
If  consider Cases A1, A2 and A3 below, 
in the order that they are listed:\\
{\bf Case A1:} if there exist 
such that  then add  to ;\\
{\bf Case A2} if there exist  
such that  then\\
pick a  and find a neighbor  of  
such that ;\\
delete the edge  from 
and add the edges  and  to ;\\
{\bf Case A:} if there exist 
such that  then symmetric to Case A2;\\
{\bf Case A3:} find  
such that ;\\
pick  and find a neighbor  of  
such that ;\\
pick  and find a neighbor  of 
such that ;\\
delete the edges  from  
and add the edges  to ;\smallskip\\
If  consider Cases B1, B2 and B3 below,
in the order that they are listed:\\
{\bf Case B1:} if there exist 
such that  then add  to ;\\
{\bf Case B2} if there exist 
such that  then\\
if  then add  to \\
elseif  then\\
pick a  and find a neighbor  of 
such that ;\\
delete the edge  from 
and add the edges  and  to ;\\
{\bf Case B3:} find 
such that ;\\
if  then\\
pick a  and find a neighbor  of 
such that ;\\
delete the edge  from 
and add the edges  and  to ;\\
elseif  then\\
pick ;\\
find a neighbor  of  such that ;\\
find a neighbor  of  such that ;\\
delete the edges  from 
and add the edges  to ;


\begin{thm}
\label{them:algorithm1}
If the degree and matrix feasibility conditions hold,
then the above algorithm  
constructs a graph .
The algorithm runs in time polynomial in . 
In particular, , if  is the graph at the end of the  th 
iteration, 
then, the number of edges between  and  (resp. inside ) 
have increased by one, the number of edges between and inside all other 
degree classes have not changed,
and the balanced degree invariant holds.
\end{thm}

\begin{prf}
Assume that we are at the beginning of the th iteration and 
the balanced degree invariant holds.  
We show that the above algorithm maintains 
the invariant after the next edge is added.

Observe first that, for all ,
the sets  and  are always nonempty and 
. In fact, either , 
or  is a partition of . 
In the sequel, if we refer to , then we are assuming that .

Now let  and  be two indices so that  has less 
than  edges in the subgraph induced by .  
By matrix feasibility, 
there is an edge  with  and .

Consider first the case . 
If the edge  falls into Case A1, 
the invariant clearly holds for .  
In Case A2 (A is symmetric) since , 
there is a .  
Since , there is a neighbor  of  
such that .  
The specified actions maintain the invariant.

If Case A3 is reached, we must have  such that  and . 
Consider .
Since no edge in Case A2 (or A) was available, 
we must have  and .
Since  is a neighbor of  but not of ,
and , 
there must exist some  that is a neighbor of  but not of . 
Similarly, there must exist some  that is a neighbor of  
but not of  (possibly ). 
Because  are both in  
and  are both in ,
we can remove  and add . 
This way, the extend to which the requirements of matrix 
are satisfied is not affected, 
but the degrees of  and  change
so that we can add  to  and the statement of the theorem is true.

Next consider the case . 
If , then it is clear that Case B1 maintains the invariant.

Now, assume there is no available edge with both ends in , 
but there exist  such that .
If , adding  to the current graph maintains 
the invariant since after the addition 
, .

So suppose that , and let . 
Since , there exists an edge  such that 
.  Note that . 
Now the specified actions satisfy the theorem.


The last possibility is that the only available 
edges have .
Notice that by exhausting Case B2 first, 
 implies .
Again, we consider two cases:  and .

In the former case, pick a . Since  is a 
neighbor of  but not of , 
and , there must exist some  that is a 
neighbor of  but not of . 
Because  both are in   
we can remove  and add . 
This way the  requirements are not affected for any , 
but the degrees of  and  change so that we can add  to  and keep
the invariant true.

In the latter case, where , 
pick a . Notice that 
is a neighbor of  
(or else  would have been added in B1). 
Since  is a neighbor of  but not of ,
and , 
there must exist some  that is a neighbor of  but not of . 
Similarly, there must exist some  that is a neighbor of  
but not of  (possibly ). 
Because  all are in , we can remove  
and add . This way the  requirements 
are not affected for any , but the degrees of  and  change 
so that we can add  to  and the invariant holds.

As long as there exists some  not yet satisfied, 
the algorithm manages to increase the number of -- edges
by one without changing the number of -- edges, 
for any . Therefore in 
iterations, all the edge requirements are met. 
Now, since degree feasibility holds and for any  
we have , 
we get that , as desired.
\end{prf}


\noindent{\bf Remark 1:} The transformations of  
adding and deleting edges in all non-trivial cases of the algorithm
resemble augmenting paths.
However, in general, these transformation are not
augmenting paths. For example, in Case A3,
the sequence of edges
, , ,
 and 
includes the case where .
We clearly have an alternating sequence but not a path.
We shall revisit this comment in Section \ref{sec:discussion}.\medskip

\noindent{\bf Remark 2:} We claim that the construction algorithm
never increases the number of connected components.
In particular, it can be verified that, in all cases, when
an edge is removed, a path between its endpoints is created 
by the edges added in the same iteration.
In particular, if the graph  at iteration  is connected,
the final output graph  will be connected.
We will use this fact critically in the algorithm
which constructs a connected realization of  
in Section \ref{sec:algorithm2}.



\subsection*{A generalization}
\label{sec:Generalizations}



It is natural to consider the generalization of the joint degree matrix problem 
, where we allow 
the entries of  to be in . 
If , there is no restriction on the number of edges
between the corresponding sets.
We can use the 
main idea of the proof of Theorem \ref{them:algorithm1}
to provide a polynomial time construction algorithm.
This is proved in Theorem \ref{thm:*gener} below.

Notice that, if the entire matrix  consists of 's,
then this is the standard degree sequence realizability problem.
In the case where  contains both integers and 's, if  is nonempty, 
then there exists some graph
 such that the subgraph  of  defined
by the integer entries of  satisfies the balanced degree invariant. This is proved in Lemma \ref{lem:last} below.
We call such a graph 
a \emph{balanced  graph}.

\begin{lemma}
\label{lem:last}
If , then there exists a
balanced  graph.
\end {lemma}
\begin{prf}
Let  and consider the subgraph  of 
with vertex set  and edge set
. Assume that 
does not satisfy the balanced degree invariant. 
Then consider  on  with edge set
. We can find  and  in some  such that,
, and thus . 
We can pick
a neighbor  of  in  that is not a neighbor of , 
and a neighbor 
of  in  that is not a neighbor of . 
We remove  in  and add
 and . 
We repeat the above procedure until  satisfies the balanced
degree invariant. 
Notice that the edge flips are such that the resulting graph
 is still in .
\end{prf}

\begin{thm}\label{thm:*gener}
If , then we can construct a graph 
in polynomial time.
\end{thm}
\begin{prf} Notice that for any balanced graph ,
if we consider the subgraph  defined by the  entries of
, it is a realization
of the same degree sequence, 
say  and the same
edge restrictions, i.e.,
there are no edges between vertices of  and  if .
This fact, together with Lemma \ref{lem:last} suggest the following algorithm
to construct a graph , if one exists:
Let  be the matrix we get if we substitute all 's with 0's.
We first run the construction algorithm of this section 
with input .
This will construct a graph  that has  edges between
 and  if  and 0 otherwise, and satisfies the
balanced degree invariant.
Now, what we need to add to get a 
is a graph on  with degree sequence defined by 
for every , where -- edges are forbidden if .
However, this is reduced to finding a matching in a properly defined graph 
. 

To see this, notice that if we want to construct a graph on vertex set
 with a given 
degree sequence  and a given set  of forbidden edges,
we can define the graph 
as follows.
The vertex set is ,
where ,
              .
The vertices  denote a potential
edge between  and  in the graphic realization.
The vertices  will enforce the required degrees .
Now the edges are
.
It is straightforward to verify that
the degree sequence, given , is realizable
if and only if  
has a perfect matching.
\end{prf}



\section{Joint-Degree Matrix Connected Realization}
\label{sec:algorithm2}



We now turn to the question of constructing a connected graphic
realization of an instance ,
or showing that such a realization does not exist.
It is easy to see that this problem
is different from its counterpart
Erd\H{o}s-Gallai condition (the degrees summing up
to at least )).
In particular, there are graphically realizable instances
of  which include many edges,
but have no graphic connected realization
(for example, if all the edges are required to be inside distinct 
classes  and , ).
It is also easy to see that arbitrary simple flips
cannot be used to decrease the number of connected components
of a non-connected graphic realization .
In particular, let  and  be edges in ,
let  and  be edges not in ,
and let , , 
and .
Then, the flip of removing  and 
and adding  and  yields
a graph in  
if and only if 
or/and  .

In what follows we 
give  necessary and sufficient conditions
for  to have a connected realization.
The proof provides a polynomial (in ) time algorithm that constructs a
connected realization, if one exists,
or produces a certificate that  does not have
a connected realization.

Roughly, the general approach to construct
a connected graph in  is to first construct a tree
on 
that does not violate the upper bounds specified by .
This will be called a \emph{{valid tree for}} .
If such a tree exists, then Lemma \ref{lem:3-1} shows how to transform it to a tree
that does not violate the upper bounds specified by  and   and also 
satisfies the balanced degree invariant.We call such a tree a \emph{balanced tree for}
.
We may then continue with the greedy construction algorithm 
of Section \ref{sec:algorithm1} which,
by Remark 2 at the end of Section \ref{sec:algorithm1}, 
never increases the number of connected components, so that we extend the balanced tree
to a  graph.
\begin{lemma}
\label{lem:3-1}
Let  be a valid tree for  .
Then, we can efficiently construct a balanced tree for ,
 .
\end{lemma}
\begin{prf}
To construct  we modify the degrees within each . 
We make use of the
fact that, in any tree, if we pick two vertices  and , we can
move any neighbor of  to become a neighbor , with the exception
of the neighbor that lies on the unique -- path of the tree. Let
 be the average degree in  of the vertices in
. 
Then, as long as
 such that 
 and ,
move neighbors of  to , until either , or
. 
This will need at most
 iterations. We do this for every  to get a balanced 
tree .
Notice that, while the degrees are made as equal as possible, the
number of edges between  and  is not affected, for any .
Thus,  is a balanced tree for .
\end{prf}

If there is no connected realization, then we want to produce a
{\it certificate of non existence} of a valid tree.
In general, it is not clear how to construct efficiently a valid tree
or a certificate of non existence of such a tree.
Indeed, the sufficient and necessary conditions for connectivity
listed below appear to require exponential search.
However, our Valid Tree Construction Algorithm
solves both problems in polynomial time.
With this motivation in mind, we proceed to the technical details.

We need some more notation.
Let  be a connected realization in
.
Let ,
where 
is the minimum possible number of connected components of a subgraph of 
induced by .
Let 
be derived from  in the natural way:
 and
.
\begin{lemma}
\label{lem:3-2}
A valid tree  for

can be transformed efficiently to a valid tree  for .
\end{lemma}
\begin{prf}
To turn  to a tree  on
, that satisfies the 's as upper bounds 
we stick a path of length 
on an arbitrary vertex of , so that we get 
vertices. We do this for every .
Now notice that for the resulting tree  we have
that the edges of  inside  are 
. Recall that,
by definition, . Therefore,
the edges of  inside  are at most . 
Moreover,
those paths inside each  were the only thing added to . 
That is, the number of edges between  and  are
at most
.
Thus we created a tree  on  that does not violate the
's, and therefore the 's.
\end{prf}


Therefore, Lemmata \ref{lem:3-1} and \ref{lem:3-2} reduced the problem 
to finding sufficient and necessary conditions for the existence
of a valid tree  for ,
an efficient construction
for some , if it exists,
or a certificate that  does not exist.

We are ready to state the necessary and sufficient conditions. 
Let ,
and let

be a partition of . The interpretation is that each  will collapse to a single vertex.
Define the undirected weighted graph
 as follows:\\
 ,
that is, one vertex  for each  and one vertex  for each
                   .\\
 If there exists 
and  such that , then
 and
.  \\
 If there exists ,
and, for some , there exists 
such that , then 
and .  \\
 If there exist ,
 and ,
then  and
.\smallskip

\noindent
{\it Necessary  and Sufficient Conditions:}
Given a connected  we can easily get a valid
tree   for .
To do so, we collapse each connected component of the subgraph  of , induced
by , in to a single vertex, and if necessary a few of these vertices together, 
so that the cardinality of the vertices of  reduces from  to . 
Then, we delete any loops or multiple vertices. The resulting graph is still connected. We do this 
 and then take a spanning tree of the resulting connected graph. This is a valid
tree   for .
Then, the existence of
 implies 
the following necessary condition for a connected realization to exist:
for every  and every ,
the graph  is connected
and .

On the other hand, we call a pair   such that
the above necessary condition fails,
a {\it certificate that no connected realization of }
 {\it exists}.

Next, we will show that the above stated necessary condition
for a connected realization of  to exist
is also sufficient.
In particular, we will prove that the  
{\bf Algorithm Valid Tree Construction} below
either produces a valid tree  for
,
or produces a certificate 
that no connected realization of  exists.


The construction algorithm is as follows.
Let .
The algorithm tries to construct a valid tree on 
by maintaining  edges which
are valid for 
(the number of edges between each 
and  never exceeds ),
while at the same time decreasing the number of connected components
by adding and removing edges appropriately.
The main idea is that, {\it if two components cannot be connected
in a trivial way} that maintains validity,
{\it then the 's that intersect more than one connected
components play a critical role}.
We constantly try to ``free'' an edge incident to such a
 while preserving validity and not increasing the
number of connected components.
In the case that such a  intersects a cycle,
this is an easy task. Otherwise, we have to remove all the
's that intersect more than one components,
and try to connect two components in the resulting graph.
We recursively repeat this until we connect something,
and then it is easy to find a sequence of adding and removing edges
that connects two components in the original graph and maintains validity.
If the recursion fails, we 
have a certificate
that no connected realization exists.\medskip

\noindent
{\bf Algorithm Valid Tree Construction}
\\
{\bf begin}\\
;
start by a graph  consisting of
 valid edges over ;\\
; comment:  is the depth of the recursion;\\ 
; comment:  is an auxiliary graph;\\
{\bf while}  is not connected\\
 {\bf begin}\\
 ;\\
 ;
comment: 's intersecting some cycle of ;\\
 ;\\
 e\widetilde{V}_{i}\in P_j;\\
 {\bf Case 1: if}
        an edge 
                 connecting two connected components in \\
 without violating upper bounds of  \\
 add  to ; remove any edge from any cycle of ;\\
 ;
           ; ;\\
 {\bf Case 2: elseif} \\
 pick  in some 
           that are not connected in  and ;\\
 find a neighbor  of  that lies on the same cycle in  ;
           find any neighbor  of  in ;\\
 remove  and  from  and add  and  to ;\\
 ;
           ; ;\\
 {\bf Case 3: elseif} \\
 let 
           be the connected components of ;\\
 let  for ;
           let ;
           let ; \\
 output  and terminate;
           comment: {\it found a certificate of non existence};\\
 {\bf Case 4: else} ;
                   ; ;\\
{\bf end};\\ 
output ; comment: {\it found a connected realization};\\
{\bf end}.
\begin{thm}
\label{thm:algorithm2}
Algorithm Valid Tree Construction outputs 
a valid tree for 
,
if such a tree exists. 
Otherwise, it outputs a certificate  showing that 
no such tree exists.
The algorithm runs in time polynomial in . 
\end{thm}
\begin{prf}
First, notice that we start with a graph  
on  vertices and  edges, 
that does not violate any upper bounds imposed by . 
The algorithm also creates at most  graphs
, 
such that  is an induced subgraph of  
(and thus of  as well) on strictly
less vertices. 
To be precise,  contains one or more of the 
's. 
To see this, notice that for  to be constructed 
this must happen in Case 4, 
and then  is the subgraph of  induced on 
. 
But  in this case should be nonempty,
or the algorithm would have terminated in Case 3.
Now, for each of these graphs, say , we associate four sets: \\
 is the set of the 's that intersect 
more than one connected component of , \\
 is the set of edges that have at least one endpoint 
in some ,\\
 is the set of all vertices that belong to some cycle in ,\\
 is the set of the 's 
that intersect some cycle in .

Notice that if  is not connected, then for any  
such that a  is constructed by the algorithm
we have  
(and thus  
as well). 
To see this notice that  is either a tree, or contains a cycle.
Moreover, whenever a  is created (in Case 4),
its vertex set contains  
(otherwise, the current iteration would not go further than Case 2). 
That is, if 
contains a cycle, so does  (if created at all). 
The above also implies that whenever  is created, 
.
As discussed above, the algorithm cannot go to Case 4 for  
consecutive iterations.
Therefore, within  iterations one of Cases 1,2 or 3 happens. 

Suppose that either Case 1 or Case 2 happen,
i.e., two connected components 
of  become connected to each other without any  
being violated. 
If , the number of connected components of  is 
decreased. 
Assume not. 
Notice that  and  in  must be subgraphs of
the same connected component, 
otherwise they would have been connected 
to each other in an earlier iteration,
when  was still . 
Now,  is updated by adding  and 
back to  and this becomes the current graph . 
Just for notational convenience, we are going to call this graph 
 as opposed to the old . 
Notice that  is not affected, i.e.,
. 
The key observation now is that, in  a new cycle is created, 
containing 
one new edge added in the last iteration, 
as well as some  from some  
(that was on a path connecting  and  in ). 
That is, in the next iteration Case 2 will happen
and the number of components of  will go down by one as well.
So, we have that if Cases 1 or 2 happen, while , 
then in the next  iterations
Case 2 will happen. 
This results in decreasing the number 
of connected components of  by one. 

Now suppose that Case 3 happens.
That is, for some ,  and Cases 1 and 2 fail.
Let  be the connected components of  
and let  and 
 be defined as in the algorithm. 
The definition of the
's makes sense because, in , 
if a vertex  is in a component
 then all vertices of  are in .
Consider the graph  together with 
all vertices and edges removed in the previous  iterations, 
i.e., the current . Then, there exists some ,
such that all cycles in 
are contained in the subgraph of  induced by the vertices of . 
We claim that
in , any edge that can be added without violating the upper bounds 
given by ,
must have both its endpoints in some .

To prove the latter claim, 
we show that all other possible cases fail to happen. 
Assume that there exists an edge  that 
can be added to  without violating any constraint, 
such that , where
. But then, 
 would have been found and added in Case 1 of the current iteration. 
In particular, if  
and , 
then we must have  
or else  and  would become connected
in Case 1 of the current iteration.
Now, assume
that there exists an edge  
that can be added to  without violating any constraint, 
such that either  
with , or 
 with .
This means that a few iterations back,
when  was ,  was available also. 
But  intersects at least two connected
components of  and therefore, 
 such that  and  lie in 
different connected components in . 
Since adding  is legal, so is adding . 
But then,
 would have been added in Case 1 of that iteration. This proves the claim.

By the above claim, for any  that are not contained 
in ,
we must have as many edges as possible between  and
, that is, if  
denotes the bipartite graph induced by  and ,
 
Also, for any  and 
 we must already have 
as many edges as possible between  and
all the 's in  in . That is,
 

Now notice that if we identify all  
with one single vertex to get  from
,  remains disconnected, 
but contains no cycles. That is, . 
But,


That is, if we use  and  
to construct the weighted graph 
 as in the necessary and sufficient condition, then 

i.e., the condition fails to hold and  is indeed a 
certificate showing that no connected graph in 
 exists.

From the above, within no more than  iterations, 
Algorithm Valid Tree Construction either reduces the 
number of components of , or terminates, 
giving a certificate . 
Therefore, in at most
 iterations the algorithm terminates, and if
a valid tree  of   exists, 
 is going to be such a tree.
\end{prf}




\section{A step towards sampling}
\label{sec:Sampling}



Towards uniform sampling from ,we can define 
a natural Markov chain on .
Let  and  be two vertices that belong to  for some .
Also let  be vertices such that , but .
Then, the graph  with  is 
still in . We call such an operation a \emph{legal switch} and denote it
as  (Figure \ref{fig1}). Two legal switches are distinct, if they produce different
graphs.\medskip


We define the Markov chain  as follows.
Given a state/graph , first calculate the number of distinct legal 
switches, . Notice that this can be done in  time.
\begin{itemize}
	\item W.p. , let .
	\item W.p. , choose one of the  distinct legal switches. Perform
	the switch and let  be the resulting graph. With probability
	 let , otherwise let .
\end{itemize}

Clearly,  is aperiodic. Notice that if  is the uniform distribution on ,
for all . That is, if  is
irreducible, then its unique stationary distribution is the uniform distribution .

Below we show that   is irreducible. Usually this is a trivial step,
but here it is a bit more involved. We should note here that 
\cite{SP12} independently proposed an alternative proof for the irreducibility of . This proof however was flawed, as noted in \cite{CDEM15}, where an alternative proof is given. Our approach below is simpler, although not completely straightforward.  Let  and
 be two arbitrary instances in . We want to show that there exists
a sequence of legal switches that applied to  gives . First, we need 
to introduce some notation and terminology. In what follows  is the symmetric
difference of the current graph  and ; initially, . We will refer 
to the edges of  as \emph{straight}, and the edges of 
 as \emph{squiggly}. The graph  is the union of straight 
and squiggly edges. Also, we will refer to the edges of  as
\emph{dashed}, and to the rest of the edges (edges in neither  nor ) 
as \emph{dotted}. Obviously, the depiction of the edges will reflect their names.

If there exist vertices  of  such that  is straight,  is squiggly
and  belong to the same , then we call  a \emph{pairing node} (Figure \ref{fig2}).

\begin{figure}[h]
\hspace{-0.5cm}
\begin{minipage}[b]{0.65\linewidth}
\centering
\includegraphics[scale=0.6]{fig1}
\caption{A legal switch.}
\label{fig1}
\end{minipage}
\hspace{-3cm}
\begin{minipage}[b]{0.65\linewidth}
\centering
\includegraphics[scale=0.6]{fig2}
\caption{A pairing node.}
\label{fig2}
\end{minipage}
\end{figure}

Finally, notice that  the number of straight and the number of
squiggly edges adjacent to  are equal, i.e., they are .


\begin{lemma}
The Markov chain  defined above is irreducible.
\end{lemma}

\begin{prf}
By induction on . If , then  has to contain an alternating 
cycle of length 4, with straight and squiggly edges, with two non adjacent vertices 
in the same . Thus we can go from  to  in one legal switch.

Now assume that . 

\noindent\textbf{Case 1:}  contains a pairing node .

\noindent\emph{Subcase 1a:} There exists a straight neighbor of , say , that 
is also a squiggly neighbor of  (Figure \ref{fig3}a). Then, by switching  in , 
we reduce  to . Thus, by induction, we can go from  to  by 
performing a sequence of legal switches.

\noindent\emph{Subcase 1b:} There exists a straight neighbor of , say , that 
is also a dotted neighbor of , or there exists a dashed neighbor of , , that 
is also a squiggly neighbor of  (Figure \ref{fig3}b). Then, by switching  in , 
we reduce  to . Thus, by induction, we can go from  to  by 
performing a sequence of legal switches.

\noindent\emph{Subcase 1c:} There exists a straight neighbor of , say , that 
is also a dashed neighbor of , or there exists a dotted neighbor of , , that 
is also a squiggly neighbor of  (Figure \ref{fig3}c). Notice that by switching  
in , we get a graph , such that . Thus, by induction, 
we can go from  to  by performing a sequence of legal switches. Then, by 
switching  in , we get .

\begin{figure}[h]
\centering
\includegraphics[scale=0.55]{fig3}
\caption{Case 1.}
\label{fig3}
\end{figure}

Now, we claim that always one of the above subcases holds. Assume not. That is, \emph{(i)} 
all straight neighbors of  ( excluded) are also straight neighbors of  and 
\emph{(ii)} all squiggly neighbors of  ( excluded) are also squiggly neighbors 
of . Since,  is a squiggly neighbor of  and a straight neighbor of ,
\emph{(i)} implies that  (Figure \ref{fig4}a) and \emph{(ii)} implies 
that  (Figure \ref{fig4}b), producing a contradiction.\medskip

\begin{figure}[h]
\centering
\includegraphics[scale=0.65]{fig4}
\caption{Subcases 1a, 1b, and 1c exhaust all possibilities for Case 1.}
\label{fig4}
\end{figure}

\noindent\textbf{Case 2:}  contains no pairing node. 

\noindent Then, there exist two edges, one squiggly  and one straight  such 
that  are all distinct and ,  for some  (Figure \ref{fig5}).
\begin{figure}[h]
\centering
\includegraphics[scale=0.65]{fig5}
\caption{If no pairing node exists.}
\label{fig5}
\end{figure}
Notice that  can only be either dashed or dotted. Assume it is dotted. (\emph{The case 
where  is dashed is symmetric}.) Then,  is a neighbor of  in , but not 
of . Since  and  have the same degree in , there exists some  such that 
 is in , while  is not.

\noindent\emph{Subcase 2a:} The edge  is straight and  is dotted. Then, by 
switching  in , we keep  and we create the pairing node 
 (Figure \ref{fig6}a). By Case 1 above and induction, we can go from  to  by 
performing a sequence of legal switches.

\noindent\emph{Subcase 2b:} The edge  is dashed and  is squiggly. Like above, 
by switching  in , we keep  and we create the pairing 
node  (Figure \ref{fig6}b). By Case 1 above and induction, we can go from  to  by 
performing a sequence of legal switches.

\noindent\emph{Subcase 2c:} The edge  is dashed and  is dotted. Then, by 
switching  in , we have  and we create two pairing nodes 
 (Figure \ref{fig6}c). By examining the pairing node  with  like we did in subcases 1a, 
1b, 1c above, we either reduce  to  and proceed with induction, or we
reduce  to , while  has the pairing node , in which case, by Case 1 
above and induction, we can go from  to  by performing a sequence of legal switches.

\begin{figure}[h]
\centering
\includegraphics[scale=0.55]{fig6}
\caption{Subcases 2a, 2b, and 2c}
\label{fig6}
\end{figure}

Notice that in Case 2, it is not possible to have  to be straight and  to be
squiggly.\\

\end{prf}



\vspace{-3 ex}\section{Further Directions}
\label{sec:discussion}


For the original 
degree sequence graphic realization problem,
when a graphic realization of a degree sequence 
 exists,
several interesting generalizations
can be solved efficiently.
For example, 
if there are costs on edges, then we
can find a minimum cost realization and 
we can generate a realization, or a connected realization 
uniformly at random 
(under mild restrictions on the degree sequence \cite{JS2,ALENEX03,SODAMCMC,FOCS06}).

The above problems have efficient algorithms
because the original problem has a reduction
to perfect matchings \cite{Val79,JS2,Sinclair}.
In particular, for
 as above,
define the graph 
as follows.
The vertex set is ,
where ,
              .
The vertices  denote a potential
edge between  and  in the graphic realization.
The vertices  will enforce the required degrees .
Now the edges are
.
It is straightforward to verify that
the degree sequence is realizable
if and only if  
has a perfect matching.

Is there a reduction from the
joint-degree matrix realization problem to some
version of matching, flow, or a similar
better understood combinatorial problem?
The relatively smooth decision and construction
algorithm outlined in Section \ref{sec:algorithm1} for realizability
suggests that such a reduction might exist.
One should probably try to reverse engineer the construction algorithm;
however, the main difficulty is outlined in Remark 1 at the end of 
Section \ref{sec:algorithm1},
namely, the alternating sequences of edges involved in the
algorithm are not pure augmenting paths. The existence of a
such a reduction may help solve the problems listed in the next paragraph.

The most interesting open question is undoubtedly whether one can efficiently sample from . It would be interesting to 
prove that the Markov chain we suggest in Section \ref{sec:Sampling}, or any other
Markov chain for that matter, is rapid mixing. Although some progress has been made in this direction in \cite{EMT15}, the problem remains largely open. Similar questions can be asked for a weighted version of the problem.
Let  be an instance of the joint-degree matrix
realization problem.
If there is a cost associated with every potential edge,
can we construct a realization of minimum cost?
More importantly, can we generate uniformly at random such a realization? 


It is also natural to define the following generalization of the graphic realization problem, where conditions on the number of edges
involve arbitrary subsets of vertices.
In particular, for 
and positive integers ,
let 
be an arbitrary partition of ,
and let , ,
be a  matrix, where  is the number of edges between  and . As is, this is the same as the \emph{partition adjacency matrix problem} introduced in \cite{Ch14}, and the \emph{skeleton graph problem} introduced in \cite{EHIM15}, where some special cases are studied.
Is there a polynomial decision/construction algorithm for the above problem in general?
Notice that this is not a direct generalization of the joint-degree matrix problem, as was noted in \cite{EHIM15}, unless we modify the above definition to specify the degree subsequences in each .






\bibliographystyle{plain}


\begin{thebibliography}{10}

\bibitem{ACL2}
W.~Aiello, F.~Chung, and L.~Lu.
\newblock Random evolution in massive graphs.
\newblock {\em FOCS}, 2000.

\bibitem{ACL1}
W.~Aiello, F.~Chung, and L.~Lu.
\newblock A random graph model for massive graphs.
\newblock {\em STOC}, 2000.

\bibitem{hot2}
D.~Alderson, J.~Doyle, R.~Govindan, and W.~Willinger.
\newblock Toward an optimization-driven framework for designing and generating
  realistic internet topologies.
\newblock {\em ACM Sigcomm CCR}, 2003.

\bibitem{nsbook2}
A.~Barabasi.
\newblock {\em Linked: The New Science of Networks}.
\newblock NY Perseus, 2002.

\bibitem{bergebook}
C.~Berge.
\newblock {\em Graphs and Hypergraphs}.
\newblock North Holland Publishing Company, 1973.

\bibitem{Zegura3}
K.~Calvert, M.~Doar, and E.W. Zegura.
\newblock Modeling internet topology.
\newblock {\em IEEE Communications Magazine}, 1997.

\bibitem{chungbook2}
F.~Chung and L.~Lu.
\newblock {\em Complex Graphs and Networks}.
\newblock AMS, 2004.

\bibitem{SODAMCMC}
C.~Cooper, M.~Dyer, and C.~Greenhill.
\newblock Sampling regular graphs and a p2p network.
\newblock {\em SODA}, 2005.

\bibitem{Ch14}
\'{E}. Czabarka.
\newblock {On realizations of a Partition Adjacency Matrix}.
\newblock {\em Unpublished Manuscript}, 2014.

\bibitem{CDEM15}
\'{E}. Czabarka, A.~Dutle, P.~L. Erd\H{o}s, and I.~Mikl\'{o}s.
\newblock On realizations of a joint degree matrix.
\newblock {\em Discrete Applied Mathematics}, 181:283 -- 288, 2015.

\bibitem{nsbook3}
S.~N. Dorogovetisev and J.~F.~F. Mendes.
\newblock {\em Evolution of Networks: from Biological Nets to the Internet and
  WWW}.
\newblock Oxford University Press, 2003.

\bibitem{durrettbook}
R.~Durrett.
\newblock {\em Random Graph Dynamics}.
\newblock Cambridge U. Press, 2006.

\bibitem{EHIM15}
P.~L. {Erd{\H o}s}, S.~G. {Hartke}, L.~{van Iersel}, and I.~{Mikl{\'o}s}.
\newblock {Graph realizations constrained by skeleton graphs}.
\newblock {\em ArXiv e-prints: 1508.00542}, 2015.

\bibitem{ErdosGallai}
P.~Erd\H{o}s and T.~Gallai.
\newblock Graphs with prescribed degrees of vertices.
\newblock {\em Math. Lapok}, 11, 1960.

\bibitem{EMT15}
P.~L. Erd\H{o}s, I.~Mikl\'{o}s, and Z.~Toroczkai.
\newblock A decomposition based proof for fast mixing of a markov chain over
  balanced realizations of a joint degree matrix.
\newblock {\em SIAM Journal on Discrete Mathematics}, 29(1):481--499, 2015.

\bibitem{Faloutsos}
M.~Faloutsos, P.~Faloutsos, and C.~Faloutsos.
\newblock On power-law relationships of the internet topology.
\newblock {\em Sigcomm}, 1999.

\bibitem{FOCS06}
T.~Feder, A.~Guetz, M.~Mihail, and A.~Saberi.
\newblock A local exchange markov chain on graphs with given degrees and
  applications in p2p networks.
\newblock {\em FOCS}, 2006.

\bibitem{GTM15}
M.~Gjoka, B.~Tillman, and A.~Markopoulou.
\newblock Construction of simple graphs with a target joint degree matrix and
  beyond.
\newblock In {\em 2015 IEEE Conference on Computer Communications (INFOCOM)},
  pages 1553--1561, 2015.

\bibitem{ALENEX03}
C.~Gkantsidis, M.~Mihail, and E.~Zegura.
\newblock The markov chain simulation method for generating connected power law
  random graphs.
\newblock {\em ALENEX (SODA Workshop)}, 2003.

\bibitem{HavelHakimi2}
S.L. Hakimi.
\newblock On the realizability of a set of integers as degrees of the vertices
  of a graph.
\newblock {\em SIAM, J. Applied Math.}, 10, 1960.

\bibitem{HavelHakimi1}
V.~Havel.
\newblock A remark on the existence of finite graphs.
\newblock {\em Kaposis Pest Mat}, 80, 1955.

\bibitem{JS2}
M.~Jerrum and A.~Sinclair.
\newblock Fast uniform generation of regural graphs.
\newblock {\em TCS}, 73, 1990.

\bibitem{Inet}
C.~Jin, Q.~Chen, and S.~Jamin.
\newblock Inet: Internet topology generator, http://irl.eecs.umich.edu/jamin.
\newblock {\em University of Michigan technical Report}, CSE-TR-433-00, 2000.

\bibitem{alderson}
L.~Li, D.~Alderson, W.~Willinger, and J.~Doyle.
\newblock A first-principles approach to understanding the internet's router
  level topology.
\newblock {\em Sigcomm}, 2004.

\bibitem{UCSDnet2}
P.~Mahadevan, D.~Krioukov, K.~Fall, and A.~Vahdat.
\newblock Systematic topology analysis and generation using degree
  correlations.
\newblock {\em Sigcomm}, 2006.

\bibitem{UCSDnet1}
P.~Mahadevan, D.~Krioukov, M.~Fomenkov, B.~Huffaker, X.~Dimitropoulos,
  kc~claffy, and A.~Vahdat.
\newblock The internet as-topology: Three data sources and a definitive metric.
\newblock {\em ACM Sigcomm CCR}, 2006.

\bibitem{Brite2}
A.~Medina, I.~Matta, and J.~Byers.
\newblock On the origin of power laws in internet topologies.
\newblock {\em ACM Sigcomm CCR}, 2000.

\bibitem{Newman1}
M.~Newman.
\newblock Assortative mixing in networks.
\newblock {\em Phys. Rev. Lett. 89}, 2002.

\bibitem{Newman5}
M.~Newman.
\newblock Mixing patterns in networks.
\newblock {\em Phys. Rev. Lett. E 67}, 2003.

\bibitem{newmanbook}
M.~Newman, Barabasi A.L., and D.~Watts.
\newblock {\em The Structure and Dynamics of Networks}.
\newblock Princeton U. Press, 2006.

\bibitem{Sinclair}
A.~Sinclair.
\newblock {\em Algorithms for Random Generation and Counting: A Markov Chain
  Approach}.
\newblock Springer-Verlag, 1997.

\bibitem{SP12}
I.~Stanton and A.~Pinar.
\newblock Constructing and sampling graphs with a prescribed joint degree
  distribution.
\newblock {\em J. Exp. Algorithmics}, 17:3.5:3.1--3.5:3.25, September 2012.

\bibitem{Val79}
L.~Valiant.
\newblock The complexity of enumeration and reliability problems.
\newblock {\em SIAM, J. Computing}, 8, 1979.

\bibitem{Zegura2}
E.~W. Zegura, Ken Calvert, and S.~Bhattacharjee.
\newblock How to model an internetwork.
\newblock In {\em Infocom}, 1996.


\end{thebibliography}



\end{document}
