
\documentclass{article} \usepackage{iclr2020_conference,times}

\iclrfinalcopy


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{booktabs}       \usepackage{hyperref}
\usepackage{url}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{array}
\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{amsmath,amssymb}
\usepackage{pifont}
\setcitestyle{circle}
\definecolor{darkblue}{rgb}{0,0.08,0.45}
\usepackage{threeparttable}
\hypersetup{
    colorlinks=true,
    citecolor=darkblue
}
\usepackage[american]{babel}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage[misc]{ifsym}

\title{PC-DARTS:\ Partial Channel Connections for Memory-Efficient Architecture Search}



\author{Yuhui Xu\textsuperscript{1}\quad Lingxi Xie\textsuperscript{2}\quad Xiaopeng Zhang\textsuperscript{2}\quad Xin Chen\textsuperscript{3}\\
  \textbf{Guo-Jun Qi}\textsuperscript{\textbf{4}}\quad \textbf{Qi Tian}\textsuperscript{\textbf{2}(\Letter)}\quad \textbf{Hongkai Xiong}\textsuperscript{\textbf{1}} \\
  \textsuperscript{1}Shanghai Jiao Tong University \quad \textsuperscript{2}Huawei Noah's Ark Lab\\
  \textsuperscript{3}Tongji University\quad \textsuperscript{4}Futurewei Technologies \\
  \small\texttt{yuhuixu@sjtu.edu.cn}\quad
  \small\texttt{\{198808xc,zxphistory\}@gmail.com}\quad
  \small\texttt{1410452@tongji.edu.cn}\\
  \small\texttt{guojunq@gmail.com}\quad
  \small\texttt{tian.qi1@huawei.com}\quad
  \small\texttt{xionghongkai@sjtu.edu.cn}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
\let\thefootnote\relax\footnote{\textsuperscript{} This work was done when Yuhui Xu and Xin Chen were interns at Huawei Noah's Ark Lab.}
\footnote{\textsuperscript{\Letter} Qi Tian is the corresponding author.}
\let\thefootnote\relax\footnote{This work was supported in part by the National NSFC under Grant Nos. 61971285, 61425011, 61529101, 61622112, 61720106001, 61932022, and in part by the Program of Shanghai Academic Research Leader under Grant 17XD1401900. We thank Longhui Wei and Bowen Shi for instructive discussions.}

Differentiable architecture search (DARTS) provided a fast solution in finding effective network architectures, but suffered from large memory and computing overheads in jointly training a super-network and searching for an optimal architecture. In this paper, we present a novel approach, namely, \textbf{Partially-Connected DARTS}, by sampling a small part of super-network to reduce the redundancy in exploring the network space, thereby performing a more efficient search without comprising the performance. In particular, we perform operation search in a subset of channels while bypassing the held out part in a shortcut. This strategy may suffer from an undesired inconsistency on selecting the edges of super-net caused by sampling different channels. We alleviate it using \textit{edge normalization}, which adds a new set of edge-level parameters to reduce uncertainty in search. Thanks to the reduced memory cost, PC-DARTS can be trained with a larger batch size and, consequently, enjoys both faster speed and higher training stability. Experimental results demonstrate the effectiveness of the proposed method. Specifically, we achieve an error rate of  on CIFAR10 with merely  GPU-days for architecture search, and a state-of-the-art top-1 error rate of  on ImageNet (under the mobile setting) using 3.8 GPU-days for search. \textit{Our code has been made available at \url{https://github.com/yuhuixu1993/PC-DARTS}}.
\end{abstract}

\section{Introduction}
\label{Introduction}

Neural architecture search (NAS) emerged as an important branch of automatic machine learning (AutoML), and has been attracting increasing attentions from both academia and industry. The key methodology of NAS is to build a large space of network architectures, develop an efficient algorithm to explore the space, and discover the optimal structure under a combination of training data and constraints (\textit{e.g.}, network size and latency). Different from early approaches that often incur large computation overheads~\citep{zoph2016neural,zoph2018learning,real2018regularized}, recent one-shot approaches~\citep{pham2018efficient,liu2018darts} have reduced the search costs by orders of magnitudes, which advances its applications to many real-world problems. In particular, DARTS~\citep{liu2018darts} converts the operation selection into weighting a fixed set of operations. This makes the entire framework differentiable to architecture hyper-parameters and thus the network search can be efficiently accomplished in an end-to-end fashion. Despite its sophisticated design, DARTS is still subject to a large yet redundant space of network architectures and thus suffers from heavy memory and computation overheads. This prevents the search process from using larger batch sizes for either speedup or higher stability. Prior work~\citep{chen2019progressive} proposed to reduce the search space, which leads to an approximation that may sacrifice the optimality of the discovered architecture.



In this paper, we present a simple yet effective approach named Partially-Connected DARTS (PC-DARTS) to reduce the burdens of memory and computation. The core idea is intuitive: instead of sending all channels into the block of operation selection, we randomly sample a subset of them in each step, while bypassing the rest directly in a shortcut. We assume the computation on this subset is a surrogate approximating that on all the channels. Besides the tremendous reduction in memory and computation costs, channel sampling brings another benefit -- operation search is regularized and less likely to fall into local optima. However, PC-DARTS incurs a side effect, where the selection of channel connectivity would become unstable as different subsets of channels are sampled across iterations. Thus, we introduce \textit{edge normalization} to stabilize the search for network connectivity by explicitly learning an extra set of edge-selection hyper-parameters. By sharing these hyper-parameters throughout the training process, the sought network architecture is insensitive to the sampled channels across iterations and thus is more stable.



Benefiting from the partial connection strategy, we are able to greatly increase the batch size. Specifically, as only  of channels are  randomly sampled for an operation selection, it reduces the memory burden by almost  times. This allows us to use a  times larger batch size during search, which not only accelerates the network search but also stabilizes the process particularly for large-scale datasets. Experiments on benchmark datasets  demonstrate the effectiveness of PC-DARTS. Specifically, we achieve an error rate of  in less than  GPU-days (around  hours) on a single Tesla V100 GPU, surpassing the result of  reported by DARTS that required  GPU-day. Furthermore, PC-DARTS allows a direct search on ImageNet (while DARTS failed due to low stability), and sets the state-of-the-art record with a top-1 error of  (under the mobile setting) in only  GPU-days ( hours on eight Tesla V100 GPUs).







\section{Related Work}
\label{RelatedWork}

Thanks to the rapid development of deep learning, significant gain in performance has been brought to a wide range of computer vision problems, most of which owed to manually desgined network architectures~\citep{krizhevsky2012imagenet,simonyan2014very,he2016deep,huang2017densely}. Recently, a new research field named neural architecture search (NAS) has been attracting increasing attentions. The goal is to find automatic ways of designing neural architectures to replace conventional handcrafted ones. According to the heuristics to explore the large architecture space, existing NAS approaches can be roughly divided into three categories, namely, evolution-based approaches, reinforcement-learning-based approaches and one-shot approaches.

The first type of architecture search methods~\citep{liu2017hierarchical,xie2017genetic,real2017large,elsken2018efficient,real2018regularized,miikkulainen2019evolving} adopted evolutionary algorithms, which assumed the possibility of applying genetic operations to force a single architecture or a family evolve towards better performance. Among them, Liu~\textit{et al.}~\citep{liu2017hierarchical} introduced a hierarchical representation for describing a network architecture, and Xie~\textit{et al.}~\citep{xie2017genetic} decomposed each architecture into a representation of `genes'. Real~\textit{et al.}~\citep{real2018regularized} proposed aging evolution which improved upon standard tournament selection, and surpassed the best manually designed architecture since then. Another line of heuristics turns to reinforcement learning (RL)~\citep{zoph2016neural,baker2016designing,zoph2018learning,zhong2018practical,liu2018progressive}, which trained a meta-controller to guide the search process. Zoph~\textit{et al.}~\citep{zoph2016neural} first proposed using a controller-based recurrent neural network to generate hyper-parameters of neural networks. To reduce the computation cost, researchers started to search for blocks or cells~\citep{zhong2018practical,zoph2018learning} instead of the entire network, and consequently, managed to reduce the overall computational costs by a factor of . Other kinds of approximation, such as greedy search~\citep{liu2018progressive}, were also applied to further accelerate search. Nevertheless, the computation costs of these approaches, based on either evolution or RL, are still beyond acceptance.

In order to accomplish architecture search within a short period of time, researchers considered to reduce the costs of evaluating each searched candidate. Early efforts include sharing weights between searched and newly generated networks~\citep{cai2018efficient}, and later these methods were generalized into a more elegant framework named one-shot architecture search~\citep{brock2017smash,cai2018proxylessnas,liu2018darts,pham2018efficient,xie2018snas}, in which an over-parameterized network or super-network covering all candidate operations was trained only once, from which exponentially many sub-networks can be sampled. As typical examples, SMASH~\citep{brock2017smash} trained the over-parameterized network by a HyperNet~\citep{ha2016hypernetworks}, and ENAS~\citep{pham2018efficient} shared parameters among child models to avoid retraining each candidate from scratch.

This paper is based on DARTS~\citep{liu2017hierarchical}, which introduced a differentiable framework for architecture search, and thus combine the search and evaluation stages into one. A super-network is optimized during the search stage, after which the strongest sub-network is preserved and then re-trained. Despite its simplicity, researchers detected some of its drawbacks, such as instability~\citep{Li2019RandomSA,Sciuto2019EvaluatingTS}, which led to a few improved approaches beyond DARTS~\citep{cai2018proxylessnas,chen2019progressive,mei2020atomnas}. In particular, ProxylessNAS~\citep{cai2018proxylessnas} was the first method that searched directly on ImageNet, and P-DARTS~\citep{chen2019progressive} designed a progressive search stage to bridge the depth gap between the super-network and the sub-network.

\begin{figure}[!t]
\renewcommand{\baselinestretch}{1.0}
\centering
\includegraphics[width=0.95\textwidth]{framework.pdf}\\
\caption{Illustration of the proposed approach (best viewed in color), partially-connected DARTS (PC-DARTS). As an example, we investigate how information is propagated to node , \textit{i.e.}, . There are two sets of  hyper-parameters during search, namely,  and , where  and . To determine , we only sample a subset, , of channels and connect them to the next stage, so that the memory consumption is reduced by  times. To minimize the uncertainty incurred by sampling, we add  as \textit{extra} edge-level parameters.}
\label{fig_framework}
\end{figure}


\section{The Proposed Approach}
\label{Approach}

\subsection{Preliminaries: Differentiable Architecture Search (DARTS)}

We first review the baseline DARTS~\citep{liu2018darts}, and define the notations for the discussion later. Mathematically, DARTS decomposes the searched network into a number () of cells. Each cell is represented as a directed acyclic graph (DAG) with  nodes, where each node defines a network layer. There is a pre-defined space of operations denoted by , in which each element, , is a fixed operation (\textit{e.g.}, identity connection, and  convolution) performed at a network layer. Within a cell, the goal is to choose one operation from  to connect each pair of nodes. Let a pair of nodes be , where , the core idea of DARTS is to formulate the information propagated from  to  as a weighted sum over  operations, namely, , where  is the output of the -th node, and  is a hyper-parameter for weighting operation . The output of a node is the sum of all input flows, \textit{i.e.}, , and the output of the entire cell is formed by concatenating the output of nodes --, \textit{i.e.}, . Note that the first two nodes,  and , are input nodes to a cell, which are fixed during architecture search.

This design makes the entire framework differentiable to both layer weights and hyper-parameters , so that it is possible to perform architecture search in an end-to-end fashion. After the search process is finished, on each edge , the operation  with the largest  value is preserved, and each node  is connected to two precedents  with the largest  preserved.


\subsection{Partial Channel Connections}

A drawback of DARTS lies in memory inefficiency. In the main part of the searched architecture,  operations and the corresponding outputs need to be stored at each node (\textit{i.e.}, each network layer), leading to  memory to use. To fit into a GPU, one must reduce the batch size during search, which inevitably slows down search speed, and may deteriorate search stability and accuracy.

An alternative solution to memory efficiency is the \textbf{partial channel connection} as depicted in Figure~\ref{fig_framework}. Take the connection from  to  for example. This involves defining a channel sampling mask , which assigns  to selected channels and  to masked ones. The selected channels are sent into mixed computation of  operations, while the masked ones bypass these operations, \textit{i.e.}, they are directly copied to the output,

where,  and  denote the selected and masked channels, respectively. 
In practice, we set the proportion of selected channels to  by regarding  as a hyper-parameter. By varying , we could trade off between architecture search accuracy (smaller ) and efficiency (larger )  to strike a balance (See Section~\ref{Experiments:Ablation:Sampling} for more details).




A direct benefit brought by the partial channel connection is that the memory overhead of computing  is reduced by  times. This allows us to use a larger batch size for architecture search. There are twofold benefits. First, the computing cost could be reduced by  times during the architecture search. Moreover, the larger batch size implies the possibility of sampling more training data during each iteration. This is particularly important for the stability of architecture search. In most cases, the advantage of one operation over another is not significant, unless more training data are involved in a mini-batch to reduce the uncertainty in updating the parameters of network weights and architectures. 



\subsection{Edge Normalization}
\label{Approach:EdgeNormalization}

Let us look into the impact of sampling channels on neural architecture search. There are both positive and negative effects. On the \textbf{upside}, by feeding a small subset of channels for operation mixture while bypassing the remainder, we make it less biased in selecting operations. In other words, for edge , given an input , the difference from using two sets of hyper-parameters  and  is largely reduced, because only a small part () of input channels would go through the operation mixture while the remaining channels are left intact. This regularizes the preference of a weight-free operation (\textit{e.g.}, \textit{skip-connect}, \textit{max-pooling}, \textit{etc.}) over a weight-equipped one (\textit{e.g.}, various kinds of \textit{convolution}) in . In the early stage, the search algorithm often prefers weight-free operations, because they do not have weights to train and thus produce more consistent outputs, \textit{i.e.}, . In contrast, the weight-equipped ones, before their weights are well optimized, would propagate inconsistent information across iterations. Consequently, weight-free operations often accumulate larger weights (namely ) at the beginning, and this makes it difficult for the weight-equipped operations to beat them even after they have been well trained thereafter. \textit{This phenomenon is especially significant when the proxy dataset (on which architecture search is performed) is difficult, and this could prevent DARTS from performing satisfactory architecture search on ImageNet.} In experiments, we will show that PC-DARTS, with partial channel connections, produces more stable and superior performance on ImageNet.

On the \textbf{downside}, in a cell, each output node  needs to pick up two input nodes from its precedents , which are weighted by , respectively, following the original DARTS. However, these architecture parameters are optimized by randomly sampled channels across iterations, and thus the optimal connectivity determined by them could be unstable as the sampled channels change over time. This could cause undesired fluctuation in the resultant network architecture. To mitigate this problem, we introduce edge normalization that weighs on each edge  explicitly, denoted by , so that the computation of  becomes:


Specifically, after the architecture search is done, the connectivity of edge  is determined by both  and , for which we multiply the normalized coefficients together, \textit{i.e.}, multiplying  by . Then the edges are selected by finding the large edge weights as in DARTS. Since  are shared through the training process, the learned network architecture is insensitive to the sampled channels across iterations, making the architecture search more stable. 
In Section~\ref{Experiments:Ablation:Components}, we will show that edge normalization is also effective over the original DARTS. Finally, the extra computation overhead required for edge normalization is negligible.

\subsection{Discussions and Relationship to Prior Work}

First of all, there are two major contributions of our approach, namely, channel sampling and edge normalization. Channel sampling, as the key technique in this work, has not been studied in NAS for reducing computational overhead (other regularization methods like Dropout~\citep{srivastava2014dropout} and DropPath~\citep{larsson2016fractalnet} cannot achieve the same efficiency, in both time and memory, as channel sampling). It accelerates and regularizes search and, with the help of edge normalization, improves search stability. Note that both search speed and stability are very important for a search algorithm. Combining channel sampling and edge normalization, we obtain the best accuracy on ImageNet (based on the DARTS search space), and the direct search cost on ImageNet ( GPU-days) is the lowest known. Moreover, these two components are easily transplanted to other search algorithms to improve search accuracy and speed, \textit{e.g.}, edge normalization boosts the accuracy and speed of the original DARTS methods.

Other researchers also tried to alleviate the large memory consumption of DARTS. Among prior efforts, ProxylessNAS~\citep{cai2018proxylessnas} binarized the multinomial distribution  and samples two paths at each time, which significantly reduced memory cost and enabled direct search on ImageNet. PARSEC~\citep{casale2019probabilistic} also proposed a sampling-based optimization method to learn a probability distribution. Our solution, by preserving all operations for architecture search, achieves a higher accuracy in particular on challenging datasets like ImageNet ( over ProxylessNAS and  over PARSEC). Another practical method towards memory efficiency is Progressive-DARTS~\citep{chen2019progressive}, which eliminated a subset of operators in order to provide sufficient memory for deeper architecture search. In comparison, our approach preserves all operators and instead performs sub-sampling on the channel dimension. This strategy works better in particular on large-scale datasets like ImageNet.

\section{Experiments}
\label{Experiments}



\subsection{Datasets and Implementation Details}
\label{Experiments:Settings}

We perform experiments on CIFAR10 and ImageNet, two most popular datasets for evaluating neural architecture search. CIFAR10~\citep{krizhevsky2009learning} consists of  images, all of which are of a spatial resolution of . These images are equally distributed over  classes, with  training and  testing images. ImageNet~\citep{deng2009imagenet} contains  object categories, and  training images and  validation images, all of which are high-resolution and roughly equally distributed over all classes. Following the conventions~\citep{zoph2018learning,liu2018darts}, we apply the \textit{mobile setting} where the input image size is fixed to be  and the number of multi-add operations does not exceed  in the testing stage.

Following DARTS~\citep{liu2018darts} as well as conventional architecture search approaches, we use an individual stage for architecture search, and after the optimal architecture is obtained, we conduct another training process from scratch. In the search stage, the goal is to determine the best sets of hyper-parameters, namely  and  for each edge . To this end, the trainnig set is partitioned into two parts, with the first part used for optimizing network parameters, \textit{e.g.}, convolutional weights, and the second part used for optimizing hyper-parameters. The entire search stage is accomplished in an end-to-end manner. For fair comparison, the operation space  remains the same as the convention, which contains  choices, \textit{i.e.}, 33 and 55 \textit{separable convolution}, 33 and 55 \textit{dilated separable convolution}, 33 \textit{max-pooling}, 33 \textit{average-pooling}, \textit{skip-connect} (\textit{a.k.a.}, \textit{identity}), and \textit{zero} (\textit{a.k.a.}, \textit{none}).

We propose an alternative and more efficient implementation for partial channel connections. For edge , we do not perform channel sampling at each time of computing , but instead choose the first  channels of  for operation mixture directly. To compensate, after  is obtained, we shuffle its channels before using it for further computations. This is the same implementation used in ShuffleNet~\citep{zhang2018shufflenet}, which is more GPU-friendly and thus runs faster.

\iffalse
Similar as the optimization process in DARTS~\citep{liu2018darts}, the goal for architecture search is to find  and  that minimize the validation loss ,where the weights  are obtained by minimizing the training loss . For simplification, we adopt the first order gradient approximation. The gradients of  and  are given by  and  respectively.  can be further absorbed into  as described in Eq.~\ref{equ.5}.

In this case, each operation  in edge  expressed by being weighted by . We select operations and edges according to .

\textbf{Implementation Details}\hspace{0.4cm} Partially using the features directly may incur bad searching quality without making full use of the capacity of the over-parameterized network. We introduce two kinds of differentiable \textbf{Feature Mixture} (FM) operations: Channel Shift and Channel Shuffle~\citep{zhang2018shufflenet} to mix the features on each edge, as shown in Fig.~\ref{fig_edge}:
\begin{itemize}
	\item Channel shift: channels are ring shifted after the operations.
	\item Channel shuffle: channels are shuffled after the operations.
\end{itemize}
\fi

\begin{table}[t]
\centering
\caption{Comparison with state-of-the-art network architectures on CIFAR10.}
\label{tab.1}
\begin{threeparttable}[b]
\resizebox{\textwidth}{!}{
\begin{tabular}{@{}lcccccc@{}}
\toprule
\multirow{2}{*}{\textbf{Architecture}} & \textbf{Test Err.} & \textbf{Params} & \textbf{Search Cost} & \multirow{2}{*}{\textbf{Search Method}} \\
&                            \textbf{(\%)} & \textbf{(M)} & \textbf{(GPU-days)} &\\
\midrule
DenseNet-BC~\citep{huang2017densely}                       & 3.46  & 25.6 & -    & manual \\
\midrule
NASNet-A + cutout~\citep{zoph2018learning}                 & 2.65  & 3.3  & 1800 & RL      \\
AmoebaNet-B + cutout~\citep{real2018regularized}           & 2.550.05 & 2.8  & 3150 & evolution \\
Hireachical Evolution~\citep{liu2017hierarchical}          & 3.750.12 &  15.7 & 300  & evolution \\
PNAS~\citep{liu2018progressive}                            & 3.410.09 & 3.2  & 225  & SMBO \\
ENAS + cutout~\citep{pham2018efficient}                    & 2.89 & 4.6  & 0.5  & RL \\
NAONet-WS~\citep{luo2018neural}       & 3.53 & 3.1 & 0.4 & NAO\\
\midrule
DARTS (1st order) + cutout~\citep{liu2018darts}           & 3.000.14 &  3.3 & 0.4  & gradient-based \\
DARTS (2nd order) + cutout~\citep{liu2018darts}          & 2.760.09 &  3.3 & 1 & gradient-based \\
SNAS (moderate) + cutout~\citep{xie2018snas}    & 2.850.02 & 2.8  & 1.5  & gradient-based \\
ProxylessNAS + cutout~\citep{cai2018proxylessnas}   & 2.08 & -     &  4.0    & gradient-based \\
P-DARTS + cutout~\citep{chen2019progressive}                                    & 2.50 &  3.4  & 0.3 & gradient-based \\
BayesNAS + cutout~\citep{zhou2019bayesnas}                               & 2.810.04 &  3.4  & 0.2& gradient-based \\
\midrule
PC-DARTS + cutout                                    & 2.570.07 & 3.6  & \textbf{0.1}& gradient-based \\
\bottomrule
\end{tabular}
}
\begin{tablenotes}
\item[] {\footnotesize Recorded on a single GTX 1080Ti. It can be shortened into  GPU-days if Tesla V100 is used.}
\item[] {\footnotesize We ran PC-DARTS  times and used standalone validation to pick the best from the  runs. This process}
\item {\footnotesize was done by using  out of  training images for training, and the remaining  images for valida-}
\item {\footnotesize tion. The best one in validation was used for testing, which reported a test error of .}
\end{tablenotes}
\end{threeparttable}
\end{table}

\subsection{Results on CIFAR10}
\label{Experiments:CIFAR10}

In the search scenario, the over-parameterized network is constructed by stacking  cells ( normal cells and  reduction cells), and each cell consists of  nodes. We train the network for  epochs, with the initial number of channels being . The  training set of CIFAR10 is split into two subsets with equal size, with one subset used for training network weights and the other used for architecture hyper-parameters.

We set  for CIFAR10, \textit{i.e.}, only  features are sampled on each edge, so that the batch size during search is increased from  to . Besides, following~\citep{chen2019progressive}, we freeze the hyper-parameters,  and , and only allow the network parameters to be tuned in the first  epochs. This process, called warm-up, is to alleviate the drawback of the parameterized operations. The total memory cost is less than  so that we can train it on most modern GPUs. The network weights are optimized by momentum SGD, with an initial learning rate of  (annealed down to zero following a cosine schedule without restart), a momentum of 0.9, and a weight decay of . We use an Adam optimizer~\citep{kingma2014adam} for  and , with a fixed learning rate of , a momentum of  and a weight decay of . Owing to the increased batch size, the entire search process only requires  hours on a GTX 1080Ti GPU, or  hours on a Tesla V100 GPU, which is almost  faster than the original first-order DARTS.

\begin{figure}[t]
\centering
\begin{minipage}{0.49\textwidth}
\subfloat[the normal cell found on CIFAR10]{\includegraphics[width=1.0\linewidth]{cifar_n.pdf}}\label{ncells_s1}\\
\subfloat[the reduction cell found on CIFAR10]{\includegraphics[width=1.0\linewidth]{cifar-r.pdf}}\label{ncells_s2}
\end{minipage}
\begin{minipage}{0.49\textwidth}
\subfloat[the normal cell found on ImageNet]{\includegraphics[width=1.0\linewidth]{image_n.pdf}}\label{ncells_s3}\\
\begin{center}
\subfloat[the reduction cell on ImageNet]{\includegraphics[width=1.0\linewidth]{image_r.pdf}}\label{ncells_dv2}
\end{center}
\end{minipage}
\caption{Cells found on CIFAR10 and ImageNet. Searching on ImageNet makes the normal cell more complex (deeper), although the reduction cell is very similar to that found on CIFAR10.}
\label{fig:cells}
\end{figure}

The evaluation stage simply follows that of DARTS. The network is composed of  cells ( normal cells and  reduction cells), and each type of cells share the same architecture. The initial number of channels is . The entire  training set is used, and the network is trained from scratch for  epochs using a batch size of . We use the SGD optimizer with an initial learning rate of  (annealed down to zero following a cosine schedule without restart), a momentum of , a weight decay of  and a norm gradient clipping at . Drop-path with a rate of  as well as cutout~\citep{devries2017improved} is also used for regularization. We visualize the searched normal and reduction cells in the left-hand side of Figure~\ref{fig:cells}.

Results and comparison to recent approaches are summarized in Table~\ref{tab.1}. In merely  GPU-days, PC-DARTS achieve an error rate of , with both search time and accuracy surpassing the baseline, DARTS, significantly. To the best of our knowledge, our approach is the fastest one that achieves an error rate of less than . Our number ranks among the top of recent architecture search results. ProxylessNAS used a different protocol to achieve an error rate of , and also reported a much longer time for architecture search. P-DARTS~\citep{chen2019progressive} slightly outperforms our approach by searching over a deeper architecture, which we can integrate our approach into P-DARTS to accelerate it as well as improve its performance (consistent accuracy gain is obtained).



\subsection{Results on ImageNet}
\label{Experiments:ImageNet}

We slightly modify the network architecture used on CIFAR10 to fit ImageNet. The over-parameterized network starts with three convolution layers of stride 2 to reduce the input image resolution from  to .  cells ( normal cells and  reduction cells) are stacked beyond this point, and each cell consists of  nodes. To reduce search time, we randomly sample two subsets from the  training set of ImageNet, with  and  images, respectively. The former one is used for training network weights and the latter for updating hyper-parameters.

ImageNet is much more difficult than CIFAR10. To preserve more information, we use a sub-sampling rate of , which doubles that used in CIFAR10. Still, a total of  epochs are trained and architecture hyper-parameters are frozen during the first  epochs. For network weights, we use a momentum SGD with an initial learning rate of  (annealed down to zero following a cosine schedule without restart), a momentum of , and a weight decay of . For hyper-parameters, we use the Adam optimizer~\citep{kingma2014adam} with a fixed learning rate of , a momentum  and a weight decay of . We use eight Tesla V100 GPUs for search, and the total batch size is . The entire search process takes around  hours. We visualize the searched normal and reduction cells in the right-hand side of Figure~\ref{fig:cells}.

\begin{table}[t]
\centering
\caption{Comparison with state-of-the-art architectures on ImageNet (mobile setting).}
\label{tab.2}
\begin{threeparttable}[b]
\resizebox{\textwidth}{!}{
\begin{tabular}{@{}lcccccc@{}}
\toprule
\multirow{2}{*}{\textbf{Architecture}} & \multicolumn{2}{c}{\textbf{Test Err. (\%)}} & \textbf{Params} &  & \textbf{Search Cost} & \multirow{2}{*}{\textbf{Search Method}} \\
\cmidrule(lr){2-3}
&                            \textbf{top-1} & \textbf{top-5} & \textbf{(M)} & \textbf{(M)} & \textbf{(GPU-days)} &\\
\midrule
Inception-v1~\citep{szegedy2015going}          & 30.2 & 10.1 & 6.6 & 1448 & -    & manual \\
MobileNet~\citep{howard2017mobilenets}         & 29.4 & 10.5 & 4.2 & 569  & -    & manual \\
ShuffleNet 2 (v1)~\citep{zhang2018shufflenet} & 26.4 & 10.2 & 5  & 524  & -    & manual \\
ShuffleNet 2 (v2)~\citep{ma2018shufflenet}    & 25.1 & - & 5  & 591  & -    & manual \\
\midrule
NASNet-A~\citep{zoph2018learning}              & 26.0 & 8.4  & 5.3 & 564  & 1800 & RL \\
AmoebaNet-C~\citep{real2018regularized}        & 24.3 & 7.6  & 6.4 & 570  & 3150 & evolution \\
PNAS~\citep{liu2018progressive}                & 25.8 & 8.1  & 5.1 & 588  & 225  & SMBO \\
MnasNet-92~\citep{tan2018mnasnet}              & 25.2 & 8.0  & 4.4 & 388  & -    & RL \\
\midrule
DARTS (2nd order)~\citep{liu2018darts}      & 26.7 & 8.7  & 4.7 & 574  & 4.0    & gradient-based \\
SNAS (mild)~\citep{xie2018snas}     & 27.3 & 9.2  & 4.3 & 522  & 1.5  & gradient-based \\
ProxylessNAS (GPU)~\citep{cai2018proxylessnas}       & 24.9 & 7.5  & 7.1 & 465  & 8.3  & gradient-based \\
P-DARTS (CIFAR10)~\citep{chen2019progressive}                 & 24.4 & 7.4  & 4.9 & 557  & 0.3  & gradient-based \\
P-DARTS (CIFAR100)~\citep{chen2019progressive}                 & 24.7 & 7.5  & 5.1 & 577  & 0.3  & gradient-based \\
BayesNAS~\citep{zhou2019bayesnas}                         & 26.5 & 8.9  & 3.9 & -  & 0.2  & gradient-based \\
\midrule
PC-DARTS (CIFAR10)                    & 25.1 & 7.8  & 5.3 & 586  & 0.1  & gradient-based \\
PC-DARTS (ImageNet)        & \textbf{24.2} &\textbf{7.3}  & 5.3 & 597  & 3.8 & gradient-based \\
\bottomrule			
\end{tabular}
}
\begin{tablenotes}
\item[] {\footnotesize This architecture was searched on ImageNet directly, otherwise it was searched on CIFAR10 or CIFAR100.}
\end{tablenotes}
\end{threeparttable}
\end{table}

The evaluation stage follows that of DARTS, which also starts with three convolution layers with a stride of  that reduce the input image resolution from  to .  cells ( normal cells and  reduction cells) are stacked beyond this point, with the initial channel number being . The network is trained from scratch for  epochs using a batch size of . We use the SGD optimizer with a momentum of , an initial learning rate of  (decayed down to zero linearly), and a weight decay of . Additional enhancements are adopted including label smoothing and an auxiliary loss tower during training. Learning rate warm-up is applied for the first  epochs.

Results are summarized in Table~\ref{tab.2}. Note that the architectures searched on CIFAR10 and ImageNet itself are both evaluated. For the former, it reports a top-1/5 error of /, which significantly outperforms / reported by DARTS. This is impressive given that our search time is much shorter. For the latter, we achieve a top-1/5 error of /, which is the best known performance to date. In comparison, ProxylessNAS~\citep{cai2018proxylessnas}, another approach that directly searched on ImageNet, used almost doubled time to produce /, which verifies that our strategy of reducing memory consumption is more efficient yet effective.


\makeatletter\def\@captype{figure}\makeatother
\begin{minipage}{.45\textwidth}
\centering
\vspace{0.2cm}
\includegraphics[width=6.8cm]{ablation_1.pdf}\\
\caption{Search cost and accuracy comparison between our approach with different sampling rates, namely, , ,  and , among which  makes a nice tradeoff between accuracy and efficiency.}
\label{fig:sampling}
\end{minipage}
\makeatletter\def\@captype{table}\makeatother
\hfill
\begin{minipage}{.5\textwidth}
\centering
\small
\begin{tabular}{cccc}
\hline
\multicolumn{4}{c}{CIFAR10}\\
\textbf{PC}&\textbf{EN} & \textbf{Test Error} &\textbf{Search Cost}\\
\hline
\xmark& \xmark& 3.000.14\%& 0.4 GPU-days\\
\xmark& \cmark& 2.820.05\%& 0.4 GPU-days\\
\cmark& \xmark& 2.670.11\%& 0.1 GPU-days\\
\cmark& \cmark& 2.570.07\%& 0.1 GPU-days\\
\hline
\hline
\multicolumn{4}{c}{ImageNet (ILSVRC2012)}\\
\textbf{PC}&\textbf{EN} & \textbf{Test Error} &\textbf{Search Cost}\\
\hline
\xmark& \xmark& 26.80.1\%& 7.7 GPU-days\\
\xmark& \cmark& 26.30.1\%& 7.7 GPU-days\\
\cmark& \xmark& 26.20.1\%& 3.8 GPU-days\\
\cmark& \cmark& 25.80.1\%& 3.8 GPU-days\\
\hline			
\end{tabular}
\caption{Ablation study on CIFAR10 and ImageNet. PC and EN denote partial channel connections and edge normalization, respectively. All architectures on ImageNet are re-trained by  epochs (the  error corresponds to the best entry, , reported in Table~\ref{tab.2} ( epochs).}
\label{tab:components}
\end{minipage}

\subsection{Ablation Study}
\label{Experiments:Ablation}

\subsubsection{Effectiveness of Channel Proportion }
\label{Experiments:Ablation:Sampling}

We first evaluate , the hyper-parameter that controls the sampling rate of channels. Note that a tradeoff exists: increasing the sampling rate (\textit{i.e.}, using a smaller ) allows more accurate information to be propagated, while sampling a smaller portion of channels casts heavier regularization and may alleviate over-fitting. To study its impacts, we evaluate the performance produced by four sampling rates, namely , ,  and , on CIFAR10, and plot the results into a diagram of search time and accuracy in Figure~\ref{fig:sampling}. One can observe that a sampling rate of  yields superior performance over  and  in terms of both time and accruacy. Using , while being able to further reduce search time, causes a dramatic accuracy drop.

These experiments not only justify the tradeoff between accuracy and efficiency of architecture search, but also reveal the redundancy of super-network optimization in the context of NAS. More essentially, this reflects the gap between search and evaluation, \textit{i.e.}, a better optimized super-network does not guarantee a better searched architecture -- in other words, differentiable NAS approaches are easily to over-fit on the super-network. From this viewpoint, channel sampling plays the role of regularization, which shrinks the gap between search and evaluation.



\subsubsection{Contributions of Different Components of PC-DARTS}
\label{Experiments:Ablation:Components}

Next, we evaluate the contributions made by two components of PC-DARTS, namely, partial channel connections and edge normalization. The results are summarized in Table~\ref{tab:components}. It is clear that edge normalization brings the effect of regularization even when the channels are fully-connected. Being a component with very few extra costs, it can be freely applied to a wide range of approaches involving edge selection. In addition, edge normalization cooperates well with partial channel connections to provide further improvement. Without edge normalization, our approach can suffer low stability in both the number of network parameters and accuracy. On CIFAR10, we run search without edge normalization for several times, and the testing error ranges from  to . On the other hand, with edge normalization, the maximal difference among five runs does not exceed . Therefore, we justify our motivation in designing edge normalization (see Section~\ref{Approach:EdgeNormalization}), \textit{i.e.}, it can be a standalone method for stabilizing architecture search, yet it works particularly well under partial channel connection, since the latter introduces randomness and stabilization indeed helps.



\begin{table}[!t]
\centering
\small
\caption{Experiments on stability of DARTS and PC-DARTS. Left: Evaluations of searched architectures in five independent search runs. Middle: architectures searched with different numbers of epochs. Right: runs on architectures searched with different numbers of nodes.}
\label{table:stability}
\begin{threeparttable}[b]
\resizebox{\textwidth}{!}{
\begin{tabular}{l|ccccc|cccc|ccc}	
\toprule
\multirow{2}*{\textbf{Methods}} & \multicolumn{5}{c|}{\textbf{Runs}} & \multicolumn{4}{c|}{\textbf{Epochs}} & \multicolumn{3}{c}{\textbf{Nodes}}\\
& \textbf{\#1} & \textbf{\#2} & \textbf{\#3} & \textbf{\#4} & \textbf{\#5} & \textbf{50} & \textbf{75} & \textbf{100} & \textbf{125} & \textbf{5} & \textbf{6} & \textbf{7} \\
\midrule
DARTS-v1(\%) &2.89 &3.15 &2.99 &3.07 &3.27 &2.98 &2.87 &3.32 &3.08 &3.03 &2.98 &2.89 \\
DARTS-v2(\%) &3.11 &2.68 &2.77 &3.14 &3.06 &2.76 &2.93 &3.51 &3.18 &2.82 &2.76 &3.02 \\
PC-DARTS(\%) &2.72 &2.67 &2.57 &2.75 &2.64 &2.57 &2.67 &2.69 &2.75 &2.63 &2.57 &2.64 \\
\bottomrule		
\end{tabular}}
\end{threeparttable}
\end{table}

\subsubsection{Stability of Our Approach}

In this part, we demonstrate the stability of our approach from three different perspectives. Results are summarized in Table~\ref{table:stability}, with detailed analysis below.

\textbf{First}, we evaluate the stability of different approaches by conducting 5 independent search runs.  We re-implement DARTS-v1 and DARTS-v2 with the proposed code, as well as that of our approach, and perform five individual search processes with the same hyper-parameters but different random seeds (0, 1, 2, 3, 4). The architectures found by DARTS in different runs, either v1 or v2, suffer much higher standard deviations than that of our approach (DARTS-v1: , DARTS-v2: , PC-DARTS: ).

\textbf{Second}, we study how the search algorithm is robust to hyper-parameters, \textit{e.g.}, the length of the search stage. We try different numbers of epochs, from  to , and observe how it impacts the performance of searched architectures. Again, we find that both DARTS-v1 and DARTS-v2 are less robust to this change.

\textbf{Third}, we go one step further by enlarging the search space, allowing a larger number of nodes to appear in each cell -- the original DARTS-based space has  nodes, and here we allow ,  and  nodes. From  to  nodes, the performance of all three algorithms goes up, while from  to  nodes, DARTS-v2 suffers a significant accuracy drop, while PC-DARTS mostly preserves it performance. As a side note, all these algorithms fail to gain accuracy in enlarged search spaces, because CIFAR10 is relatively simple and the performance of searched architectures seems to saturate.

With all the above experiments, we can conclude that PC-DARTS is indeed more robust than DARTS in different scenarios of evaluation. This largely owes to the regularization mechanism introduced by PC-DARTS, which (i) forces it to adjust to dynamic architectures, and (ii) avoids the large pruning gap after search, brought by the \textit{none} operator.



\subsection{Transferring to Object Detection}

To further validate the performance of the architecture found by PC-DARTS, we use it as the backbone for object detection. We plug the architecture found on ImageNet, as shown in Figure~\ref{fig:cells}, into a popular object detection framework named Single-Shot Detectors~(SSD)~\citep{Liu2016SSDSS}. We train the entire model on the MS-COCO~\citep{Lin2014MicrosoftCC} trainval dataset, which is obtained by a standard pipeline that excludes  images from the val set, merges the rest data into the  train set and evaluates it on the test-dev 2015 set.

Results are summarized in Table~\ref{table:detection}. Results for SSD, YOLO and MobileNets are from~\citep{tan2018mnasnet}. With the backbone searched by PC-DARTS, we need only  FLOPs to achieve an AP of , which is  higher than SSD300 (but with  fewer FLOPs), or  higher than SSD512 (but with  fewer FLOPs). Compared to the `Lite' versions of SSD, our result enjoys significant advantages in AP, surpassing the most powerful one (SSDLiteV3) by an AP of . All these results suggest that the advantages obtained by PC-DARTS on image classification can transfer well to object detection, a more challenging task, and we believe these architectures would benefit even more application scenarios.

\begin{table}[!t]
\centering
\caption{Detection results, in terms of average precisions, on the MS-COCO dataset (test-dev 2015).}
\label{table:detection}
\begin{threeparttable}[b]
\resizebox{\textwidth}{!}{
\begin{tabular}{lccccccccc}	
\toprule
\textbf{Network}       &\textbf{Input Size}&\textbf{Backbone} &\textbf{}&\textbf{}&\textbf{}  &\textbf{}&\textbf{}&\textbf{} &\textbf{}\\
\midrule
SSD300~\citep{Liu2016SSDSS} 	&300300&VGG-16&35.2B&23.2&41.2&23.4&5.3 &23.2& 39.6\\
SSD512~\citep{Liu2016SSDSS} 	&512512&VGG-16&99.5B&26.8&46.5&27.8&9.0 &28.9& 41.9\\
YOLOV2~\citep{Redmon2016YOLO9000BF} &416416&Darknet-19&17.5B&21.6&44.0&19.2&5.0 &22.4 &35.5\\
\midrule
Pelee~\citep{Wang2018PeleeAR}&304304&PeleeNet&1.3B&22.4 &38.3& 22.9&-&-&-\\
SSDLiteV1~\citep{howard2017mobilenets}   &320320&MobileNetV1&1.3B&22.2&-&-&-&-&-\\
SSDLiteV2~\citep{Sandler2018MobileNetV2IR}&320320&MobileNetV2&0.8B&22.1&-&-&-&-&-\\
SSDLiteV3~\citep{tan2018mnasnet} &320320&MnasNet-A1&0.8B &23.0 &-& -&3.8 &21.7 &42.0\\
\midrule
PC-DARTS with SSD	   &320320&PC-DARTS &1.2B &	28.9&46.9&30.0&7.9&32.0&48.3\\
\bottomrule		
\end{tabular}
}
\begin{tablenotes}
\item[] {\footnotesize The backbone architecture of PC-DARTS was searched on ImageNet (with a  top-1 error).}
\end{tablenotes}\end{threeparttable}
\end{table}
\section{Conclusions}
\label{Conclusions}

In this paper, we proposed a simple and effective approach named partially-connected differentiable architecture search (PC-DARTS). The core idea is to randomly sample a proportion of channels for operation search, so that the framework is more memory efficient and, consequently, a larger batch size can be used for higher stability. Additional contribution to search stability is made by edge normalization, a light-weighted module that requires merely no extra computation. Our approach can accomplish a complete search within  GPU-days on CIFAR10, or  GPU-days on ImageNet, and report state-of-the-art classification accuracy in particular on ImageNet.

This research delivers two important messages that are important for future research. First, differentiable architecture search seems to suffer even more significant instability compared to conventional neural network training, and so it can largely benefit from both (i) \textbf{regularization} and (ii) \textbf{a larger batch size}. This work shows an efficient way to incorporate these two factors in a single pipeline, yet we believe there exist other (possibly more essential) solutions for this purpose. Second, going one step further, our work reveals the redundancy of super-network optimization in NAS, and experiments reveal a gap between improving super-network optimization and finding a better architecture, and regularization plays an efficient role in shrinking the gap. We believe these insights can inspire researchers in this field, and we will also follow this path towards designing stabilized yet efficient algorithms for differentiable architecture search.



\bibliography{iclr2020}
\bibliographystyle{iclr2020_conference}


\iffalse
\appendix
\section{Appendix}
\textcolor{red}{
\subsection{FLOPs Constraint}
Despite the performance of the searched architecture, we also consider about its computation complexity (FLOPs). Such constraint during search phase can be reflected as a FLOPs regularizer in the loss function. 

where  is the cross-entrophy loss of the training of the supernet,  is the FLOPs regularizer:

 contains FLOPs of operations in 
}
\fi

\end{document}
