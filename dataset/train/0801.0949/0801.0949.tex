
\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{xspace}
\usepackage{epsfig}



\newcommand{\be}{\begin{itemize}}
\newcommand{\ee}{\end{itemize}}
\newcommand{\bn}{\begin{enumerate}}
\newcommand{\en}{\end{enumerate}}

\newcommand{\bp}{\begin{proposition}}
\newcommand{\ep}{\end{proposition}}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
\newcommand{\bco}{\begin{corollary}}
\newcommand{\eco}{\end{corollary}}
\newcommand{\bt}{\begin{theorem}}
\newcommand{\et}{\end{theorem}}
\newcommand{\bpr}{\begin{proof}}
\newcommand{\epr}{\end{proof}}
\newcommand{\bd}{\begin{definition}}
\newcommand{\ed}{\end{definition}}

\newcommand{\beqn}{\begin{centeqn}}
\newcommand{\eeqn}{\end{centeqn}}
\newcommand{\beqnnbsp}{\begin{centeqn-nbsp}}
\newcommand{\eeqnnbsp}{\end{centeqn-nbsp}}
\newcommand{\bleqn}[1]{\begin{centlabeqn}{#1}}
\newcommand{\eleqn}{\end{centlabeqn}}
\newcommand{\bleqnnbsp}[1]{\begin{centlabeqn-nbsp}{#1}}
\newcommand{\eleqnnbsp}{\end{centlabeqn-nbsp}}

\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\ul}{\underline}
\newcommand{\bs}{\bigskip}
\renewcommand{\ss}{\smallskip}

\newcommand{\bfg}{\begin{figure}}
\newcommand{\efg}{\end{figure}}





\newenvironment{centeqn}	{{\ms\\ \hspace*{\fill}}} 
   {\hspace*{\fill}\ms\\}

\newsavebox{\EqnLabel}
\newenvironment{centlabeqn}[1]		{\sbox{\EqnLabel}{#1}
    {\ss\\ \hspace*{\fill}}
   } 
   {\hfill{\makebox[0in][r]{\usebox{\EqnLabel}}}\ms\\}

\newenvironment{centeqn-nbsp} {{\ms\\ \hspace*{\fill}}}
   {\hspace*{\fill}}






\newcommand{\intrdef}{\emph}	\newcommand{\intr}{\emph}	

\newcommand{\smpage}{\noindent \parbox{\textwidth}}


\newcommand{\emp}{\emph}        
\newcommand{\empi}[1]{\textit{#1\/}}
\newcommand{\empb}[1]{\textbf{#1\/}}
\newcommand{\empbi}[1]{\textbf{\textit{#1\/}}}





\newcommand{\AND}{\bigwedge}
\newcommand{\INT}{\bigcap}
\newcommand{\OR}{\bigvee}
\newcommand{\UN}{\bigcup}


\newcommand{\ar}{\rightarrow}	\newcommand{\choice}{\mbox{}}
\renewcommand{\d}{\, . \,}	\newcommand{\df}{\mbox{}}
\newcommand{\ev}{\equiv}
\newcommand{\ex}{\exists}
\newcommand{\fa}{\forall}
\newcommand{\false}{\mathit{false}}
\newcommand{\halfind}{\hspace*{1.5em}}
\newcommand{\ifof}{\Longleftrightarrow}	\newcommand{\imp}{\Rightarrow}		\newcommand{\ind}{\hspace*{3.0em}}
\newcommand{\ints}{\cap}
\renewcommand{\l}{\ell}
\newcommand{\la}[1]{\mbox{}}

\newcommand{\lra}{\mbox{}}
\newcommand{\pind}{\hspace*{3.0em}}
\newcommand{\pl}{\!\parallel\!}
\newcommand{\plb}{\!\mathbf{\parallel}\!}
\newcommand{\s}{\mbox{}}
\newcommand{\sat}{\models}
\newcommand{\spc}{\mbox{\vspace{-0.25in}}}
\newcommand{\st}[2]{\mbox{}}	\newcommand{\sub}{\subseteq}
\newcommand{\tl}[1]{\mbox{}}\newcommand{\true}{\mathit{true}}
\newcommand{\un}{\cup}
\newcommand{\union}{\cup}
\newcommand{\up}{\raisebox{0.2ex}{}}

\newcommand{\dn}{\mbox{}}


\newcommand{\struct}[2]{\raisebox{-0.1in}{}}







\newcommand{\Agf}{A_{(g,f)}}	\newcommand{\EnvA}{\mathit{Env}_A}
\newcommand{\EVL}{\mathit{EVL}}
\newcommand{\I}{{\cal I}}
\newcommand{\lflag}{\lambda\mathit{flag}}
\newcommand{\flag}{\mathit{flag}}

\newcommand{\lla}[2]{\mbox{}}
\newcommand{\Lla}[2]{\mbox{}}
\newcommand{\GREEN}{\mathsf{Green}}
\newcommand{\RED}{\mathsf{Red}}
\newcommand{\G}{\mathsf{G}}
\newcommand{\R}{\mathsf{R}}
\newcommand{\pair}[2]{\lpb #1, #2 \rpb}
\newcommand{\lpb}{\langle \hspace{-0.34em} \langle \hspace{-0.34em} \langle}	
\newcommand{\rpb}{\rangle \hspace{-0.34em} \rangle \hspace{-0.34em} \rangle}



\newcommand{\acts}{\mathit{acts}}
\newcommand{\bad}{\mathit{bad}}
\newcommand{\al}{\alpha}		
\newcommand{\bottom}{\mathit{bottom}} 
\newcommand{\cat}{\mbox{}}
\newcommand{\clos}[1]{\widehat{{#1}}}	\newcommand{\esig}{\mathit{esig}}
\newcommand{\exec}{\mathit{exec}}
\newcommand{\execs}{\mathit{lexecs}}
\newcommand{\lexecs}{\mathit{lexecs}}
\newcommand{\iexecs}{\mathit{execs}^\omega}
\newcommand{\ext}{\mathit{ext}}
\newcommand{\frag}{\mathit{frag}}
\newcommand{\fault}{\mathit{fault}}
\newcommand{\fstate}{\mathit{fstate}}
\newcommand{\ga}{\gamma}		
\newcommand{\good}{\mathit{good}}
\newcommand{\height}{\mathit{height}}
\newcommand{\inp}{\mathit{in}}
\renewcommand{\int}{\mathit{int}}
\newcommand{\lattices}{\mathit{lattices}}
\newcommand{\local}{\mathit{local}}
\newcommand{\lprec}{\prec}
\newcommand{\lpreceq}{\preceq}
\newcommand{\lstate}{\mathit{lstate}}
\newcommand{\out}{\mathit{out}}
\newcommand{\pr}{\mathit{pair}}
\newcommand{\sig}{\mathit{sig}}
\newcommand{\signal}{\kappa}
\newcommand{\start}{\mathit{start}}
\newcommand{\states}{\mathit{states}}
\newcommand{\steps}{\mathit{steps}}
\newcommand{\subs}{\lhd}		\newcommand{\suc}{\mathit{succ}}	\newcommand{\topp}{\mathit{top}}\newcommand{\trace}{\mathit{trace}}
\newcommand{\traces}{\mathit{traces}}




\newcommand{\lpreorder}{\sqsubseteq_\l}	\newcommand{\spreorder}{\sqsubseteq_s}	\newcommand{\simu}{\leq}

\newcommand{\lpsim}{\simu_{\l F}}	\newcommand{\lpfs}{\simu_{\l F}}		\newcommand{\lprm}{\simu_{\l R}}		\newcommand{\lpbs}{\simu_{\l B}} 	\newcommand{\ilpbs}{\simu_{i\l B}} \newcommand{\lphr}{\simu_{\l H}}		\newcommand{\lppr}{\simu_{\l P}} 	\newcommand{\ilppr}{\simu_{i\l P}} 

\newcommand{\nonsilent}{\mathit{nonsilent}} 
\newcommand{\nonalwayssilent}{\mathit{nonalwayssilent}} 
\newcommand{\nonsometimessilent}{\mathit{nonsilent}} 








\newcommand{\ESDSAlg}{\mbox{\textit{ESDS-Alg}}}
\newcommand{\ESDSI}{\mbox{\textit{ESDS-I}}}
\newcommand{\ESDSII}{\mbox{\textit{ESDS-II}}}
\newcommand{\MI}{\mbox{\textit{M-I}}}
\newcommand{\MII}{\mbox{\textit{M-II}}}
\newcommand{\SpReq}{\mathit{SpReq}}
\newcommand{\SpStab}{\mathit{SpStab}}
\newcommand{\ImpReq}{\mathit{ImpReq}}
\newcommand{\ImpStab}{\mathit{ImpStab}}
\newcommand{\Users}{\mbox{\textit{Users}}}
\newcommand{\Frontend}{\mathit{Frontend}}
\newcommand{\Replica}{\mathit{Replica}}
\newcommand{\Channel}{\mathit{Channel}}

\newcommand{\chan}{\mathit{channel}}
\newcommand{\client}{\mathit{client}}
\newcommand{\newreq}{\mathit{newreq}} 
\newcommand{\pndg}{\mathit{pending}}
\newcommand{\req}{\mathrm{``request\mbox{''}}}
\newcommand{\resp}{\mathrm{``response\mbox{''}}}
\newcommand{\strict}{\mathit{strict}}









\renewcommand{\S}{{\cal S}}	\newcommand{\remove}[1]{}












\newcommand{\ea}{\Diamond \Box} 



\newcommand{\iof}{\Box \Diamond} 

\newcommand{\always}{\Box}
\newcommand{\eventually}{\Diamond} 





\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newtheorem{definition}{Definition}


\newtheorem{assumption}{Assumption}


\newtheorem{subtheorem}{Theorem}[subsection]
\newtheorem{sublemma}[subtheorem]{Lemma}
\newtheorem{subproposition}[subtheorem]{Proposition}
\newtheorem{subcorollary}[subtheorem]{Corollary}

\newtheorem{subdefinition}[subtheorem]{Definition}


\newtheorem{observation}{Observation}




\newcommand{\case}[2]{\vspace{1.5ex} \noindent \textit{Case} #1: #2.}
\newcommand{\scase}[2]{\vspace{1.5ex} \noindent \textit{Subcase} #1: #2.}
\newcommand{\sscase}[2]{\vspace{1.0ex} \noindent \textit{Subsubcase} #1: #2.}






\newcommand{\ms}[1]{\relax\ifmmode
                \mathord{\mathcode`\-="702D\it #1\mathcode`\-="2200}\else
{\it #1}\fi
}










\def\ioisize{\footnotesize}


\newcommand{\ioi}[3]{\bgroup\ioisize \begin{tabbing}
XX\=XX\=    \kill           Input:\+ \\                 #1 \-  \\
Output: \+ \\
  #2 \- \\
Internal: \+\\
  #3 \-
\end{tabbing} \egroup} 

\newcommand{\io}[2]{\bgroup\ioisize \begin{tabbing}
XX\=XX\=    \kill           Input:\+ \\                 #1 \-  \\
Output: \+ \\
  #2 \- 
\end{tabbing} \egroup} 

\newcommand{\ioti}[4]{\bgroup\ioisize \begin{tabbing}
XX\=XX\=    \kill           Input:\+ \\                 #1 \-  \\
Output: \+ \\
  #2 \- \\
Time-passing: \+ \\
  #3 \- \\
Internal: \+\\
  #4 \-
\end{tabbing} \egroup} 

\newcommand{\ei}[2]{\bgroup\ioisize \begin{tabbing}
XX\=XX\=    \kill           External:\+ \\              #1 \-  \\
Internal: \+\\
  #2 \-
\end{tabbing} \egroup} 



\newcommand{\eonly}[1]{\bgroup\ioisize \begin{tabbing}
XX\=XX\=    \kill           External:\+ \\              #1 \-  \\
\end{tabbing} \egroup} 







\def\iocodesize{\scriptsize}
 
\newcommand{\iocodeonecol}[1]{\begin{center}\iocodesize
\begin{minipage}[t]{.95\linewidth}
\hbox to\linewidth{}
#1
\end{minipage}
\end{center}}

\newcommand{\iocode}[2]{\vspace{-15pt}\begin{center}\iocodesize
\begin{minipage}[t]{.475\linewidth}
\hbox to\linewidth{}
#1
\end{minipage}
\hspace{.01\linewidth} 
\begin{minipage}[t]{.475\linewidth}
\hbox to\linewidth{}
#2
\end{minipage}
\end{center}}

\newcommand{\ef}[2]{\begin{tabbing}         \= XXX\=XX\=XX\=XX\=XX\=   \kill
\protect #1\\
\>Eff: \+ \+ \>
   #2  \- \-
\end{tabbing}}


\newcommand{\prcef}[3]{\begin{tabbing}        \= XXX\=XX\=XX\=XX\=  \kill
\protect #1\\
\>Pre: \+ \+ \>
  #2  \-  \- \\ 
\>Eff: \+  \+ \>
  #3 \- \- 
\end{tabbing}} 


\newcommand{\prc}[2]{\begin{tabbing}        \= XXX\=XX\=XX\=XX\=  \kill
\protect #1\\
\>Pre: \+ \+ \>
  #2  \-  \- 
\end{tabbing}} 


\newlength\Mwidth
\newlength\jsawidth

\def\statedef#1{\def\auxstatedef{#1}\def\auxempty{}\settowidth{\Mwidth}{M}
\jsawidth=\textwidth
\advance\jsawidth by -7cm
\advance\jsawidth by -\Mwidth
\advance\jsawidth by -10\tabcolsep
\advance\jsawidth by -6\arrayrulewidth
\begin{trivlist}\item[]\begin{tabular}{|p{2.5cm}|c|p{2.2cm}|p{2.3cm}|p{\jsawidth}|}
\hline
{\bf Variable} & \phantom{M} & {\bf Type} & {\bf Initially} & {\bf Description}\\
\hline\hline}
\def\endstatedef{\\ 
\ifx\auxstatedef\auxempty
  \hline
\else \hline\hline
   \multicolumn{5}{|l|}{\auxstatedef}\\\hline
 \fi
\end{tabular}\end{trivlist}}

\def\statetext{\begin{minipage}[t]{\linewidth}}
\def\endstatetext{\end{minipage}\vspace{2pt}}





\newcommand{\ifstmnt}[2]{\ifbranch{if #1 then}{#2}}

\newcommand{\ifbranch}[2]{\begin{tabbing}         XX\= XXX\=XX\=XX\=XX\=XX\=   \kill
\protect #1\\
\>\+ \+ \>
   #2  \- \-
\end{tabbing}}




\newcommand{\action}[1]{\textsf{#1}}
\newcommand{\statevar}[1]{\ms{#1}}



\newcommand{\arrow}[1]{\raisebox{0ex}[2ex]{\raisebox{-.25ex}{}}}
\newcommand{\sarrow}[2]{\raisebox{0ex}[2ex]{\raisebox{-.25ex}{}}\!_{#2}\,}







\newcommand{\automatontitle}[1]{\vspace{2ex} \noindent 
     \textbf{Automaton #1}\\}


\newcommand{\ioautomatontitle}[1]{\vspace{2ex} \noindent 
     \textbf{I/O Automaton #1}\\}

\newenvironment{signature}[1][Signature]{\noindent\textbf{#1}\iocodesize\vspace{0ex}}{}




\newenvironment{statevarlist}[1][State]
   {\noindent\textbf{#1}\iocodesize\vspace{0ex}
    \begin{list}{}{\topsep=2ex \itemsep=-0.5ex \leftmargin=0ex \labelwidth=0ex}}
   {\end{list}}





\newenvironment{actionlist}[1][Actions]{\vspace{1ex}\noindent\textbf{#1}\iocodesize}{}


\newcommand{\inputaction}[2]{\ef{\textbf{Input} #1}{#2}}
\newcommand{\outputaction}[3]{\prcef{\textbf{Output} #1}{#2}{#3}}
\newcommand{\internalaction}[3]{\prcef{\textbf{Internal} #1}{#2}{#3}}
\newcommand{\externalaction}[3]{\prcef{\textbf{External} #1}{#2}{#3}}









\usepackage{calc}       

\renewcommand{\iocode}[3][.475]{\vspace{-15pt}\begin{center}\iocodesize
\begin{minipage}[t]{#1\linewidth}
\hbox to\linewidth{}
#2
\end{minipage}
\hspace{.01\linewidth} 
\begin{minipage}[t]{.95\linewidth-#1\linewidth}
\hbox to\linewidth{}
#3
\end{minipage}
\end{center}}







\newcommand{\dbspec}{\textit{DB-Spec}\xspace}
\newcommand{\dbimp}{\textit{DB-Imp}\xspace}






\newcommand{\Op}{{\cal O}}

\newcommand{\request}{\action{request}}
\newcommand{\response}{\action{response}}

\newcommand{\send}{\action{send}}
\newcommand{\receive}{\action{receive}}
\newcommand{\doit}{\action{do\_it}}

\newcommand{\enter}{\action{enter}}
\newcommand{\calc}{\action{calculate}}
\newcommand{\calculate}{\action{calculate}}
\newcommand{\stabilize}{\action{stabilize}}
\newcommand{\addcons}{\action{add\_constraints}}

\newcommand{\wait}{\statevar{wait}}
\newcommand{\rept}{\statevar{rept}}

\newcommand{\channel}{\statevar{channel}}
\newcommand{\pending}{\statevar{pending}}
\newcommand{\rcvd}{\statevar{rcvd}}
\newcommand{\done}{\statevar{done}}
\newcommand{\stable}{\statevar{stable}}

\newcommand{\ops}{\statevar{ops}}
\newcommand{\po}{\statevar{po}}
\newcommand{\newpo}{\statevar{new-po}}
\newcommand{\stabilized}{\statevar{stabilized}}

\newcommand{\id}{\ms{id}}
\newcommand{\op}{\ms{op}}
\newcommand{\prev}{\ms{prev}}
\newcommand{\val}{\ms{val}}

\newcommand{\idof}[1]{{#1}.\ms{id}}
\newcommand{\opof}[1]{{#1}.\ms{op}}
\newcommand{\prevof}[1]{{#1}.\ms{prev}}
\newcommand{\strictof}[1]{{#1}.\ms{strict}}
\newcommand{\stateof}[1]{{#1}.\ms{s}}
\newcommand{\valof}[1]{{#1}.\ms{v}}

\newcommand{\opsof}[1]{\ms{ops}({#1})}

\newcommand{\datatrans}{\tau}
\newcommand{\datatransextend}{{\tau^+}}
\newcommand{\datastate}{\statevar{data\_state}}
\newcommand{\responses}{\statevar{responses}}
\newcommand{\mkseq}[1]{{\langle #1 \rangle}}

\newcommand{\mkmsg}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\reqmsg}[1]{\mkmsg{\text{``request''}, #1}}		\newcommand{\respmsg}[1]{\mkmsg{\text{``response''}, #1}}	\newcommand{\gossipmsg}[1]{\mkmsg{\text{``gossip''}, #1}}	

\newcommand{\msgset}{\mathcal{M}}
\newcommand{\reqmsgset}{\msgset_{\ms{req}}}
\newcommand{\respmsgset}{\msgset_{\ms{resp}}}
\newcommand{\gossipmsgset}{\msgset_{\ms{gossip}}}

\newcommand{\minlbl}{\statevar{minlabel}}
\newcommand{\lbl}{\statevar{label}}

\newcommand{\valset}{\ms{valset}}

\newcommand{\CSC}{\mathit{CSC}}

\newcommand{\TC}{\mathrm{TC}}

\newcommand{\opdescs}{\mathcal{O}}
\newcommand{\labels}{\mathcal{L}}

\newcommand{\idset}{\mathcal{I}}
\newcommand{\reps}{\mathcal{R}}

\newcommand{\requested}{\statevar{requested}}
\newcommand{\responded}{\statevar{responded}}
\newcommand{\calculated}{\statevar{calculated}}

\newcommand{\datavals}{V}



\newcommand{\setinsert}[2]{#1 \gets #1 \cup \{#2\}}
\newcommand{\setdelete}[2]{#1 \gets #1 -  \{#2\}}
\newcommand{\spn}[1]{\mathit{span}(#1)}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\logicor}{\lor}
\newcommand{\restrict}{|}
\newcommand{\LC}{\mathit{lc}}
\newcommand{\intersect}{\cap}
\newcommand{\Intersect}{\bigcap}
\newcommand{\horline}{\rule{\textwidth}{1pt}}
 


\newenvironment{proof}{\vspace{-1.0ex}\textit{Proof.} }
                      {\hfill{}}









\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{9in}
\setlength{\footskip}{0.5in}

\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}   

\setlength{\parindent}{1.5em}
\setlength{\parskip}{1ex}

\renewcommand{\floatpagefraction}{0.8}






\begin{document}

\bc
\textbf{\Large On the Refinement of Liveness Properties of Distributed Systems}\footnote{Some of the 
results in this paper appeared in the eighteenth
ACM Symposium on Principles of Distributed Computing, (PODC'99), under the title
``Liveness-preserving Simulation Relations''.}\0.05in]
\vskip 0.05in
{\large Department of Computer Science}\\
{\large American University of Beirut}\\
{\large and}\\
{\large Center for Advanced Mathematical Sciences}\\
{\large American University of Beirut}\\
\texttt{paul.attie@aub.edu.lb}

\today



\ec


 
\begin{abstract}

We present a new approach for reasoning about liveness properties of
distributed systems, represented as automata. Our approach is based
on simulation relations, and requires reasoning only over finite
execution fragments. Current simulation-relation based methods for
reasoning about liveness properties of automata require reasoning
over entire executions, since they involve a proof obligation of the
form: if a concrete and abstract execution ``correspond'' via the
simulation, and the concrete execution is live, then so is the
abstract execution.

Our contribution consists of (1) a formalism for defining liveness
properties, (2) a proof method for liveness properties based on that
formalism, and (3) two expressive completeness results: firstly, our
formalism can express any liveness property which satisfies a natural
``robustness'' condition, and secondly, our formalism can express any
liveness property at all, provided that history variables can be used.

To define liveness, we generalize the notion of a complemented-pairs
(Streett) automaton to an infinite state-space, and an infinite number
of complemented-pairs. Our proof method provides two main techniques:
one for refining liveness properties across levels of abstraction, and
the other for refining liveness properties within a level of
abstraction. The first is based on extending simulation relations so
that they relate the liveness properties of an abstract (i.e., higher
level) automaton to those of a concrete (i.e., lower level)
automaton. The second is based on a deductive method for inferring new
liveness properties of an automaton from already established liveness
properties of the same automaton. This deductive method is
diagrammatic, and is based on constructing ``lattices'' of liveness
properties. Thus, it supports proof decomposition and separation of
concerns. 

\end{abstract}

\section{Introduction and Overview}

One of the major approaches to the construction of correct distributed
systems is the use of an operational specification, e.g., an \intr{automaton}
or a \intr{labeled transition system}, which is successively refined, via
several intermediate levels of abstraction, into an
implementation. The implementation is considered correct if and only if each of
its externally visible behaviors, i.e., \intr{traces}, is also a trace of the
specification. 
This ``trace inclusion'' of the implementation in the specification is
usually established transitively by means of establishing the trace
inclusion of the system description at each level of abstraction in
the system description at the next higher level.  When reasoning at
any particular level, we call the lower level the concrete level, and
the higher level the abstract level.

The correctness properties of a distributed system are classified into
\intr{safety} and \intr{liveness} \cite{Lam77}: 
safety properties state that ``nothing bad happens,'' for example,
that a database system never produces incorrect responses to queries, 
while
liveness properties state that ``progress occurs in the system,'' for
example, every query sent to a database system is eventually responded to.
Safety properties are characterized by the fact that they are violated
in finite time: e.g., once a database has returned an incorrect
response to an external user, there is no way to recover to where the
safety property is satisfied. Liveness properties, on the other
hand, are characterized by the fact that there is always the
possibility of satisfying them: the database always has the
opportunity of responding to pending queries.
Thus, an operational specification defines the required safety properties by
means of an automaton, or labeled transition system. The reachable
states and transitions of the automaton are the ``good''
states/transitions, whose occurrence does not violate safety. Any
unreachable states, if present, are ``bad,'' i.e., they represent a
violation of the safety properties, e.g., due to a fault.
The occurrence of such a ``bad'' state is something that happens in
finite time, and so constitutes the violation of a safety property.
The liveness properties are specified by designating a subset of the
executions of the automaton as being the ``live'' executions, leading
to the notion of \intr{live execution property}.
These are the executions along which eventually, all the necessary
actions are executed, e.g., the actions that respond to pending queries.
To express the idea that there is always the possibility of
satisfying a liveness property, this subset of the executions must have the property
that any finite execution can be extended to an execution in the
subset \cite{AL91}. 

Distributed systems consist of many sequential processes which execute
concurrently. To reason effectively about such large systems,
researchers have proposed the use of \emph{compositional reasoning}:
global properties of the entire system are inferred by first
deducing local properties of the constituent processes or subsystems, and then
combining these local properties to establish the global properties.
In particular, we desire that refinement is compositional: when a
particular process  is refined to a new process , we wish
to reason only about whether  is a correct refinement of ,
without having to engage in global reasoning involving all of the
other processes in the system. The need for compositional reasoning,
as well as notions such as behavioral subtyping \cite{LW94} and
information hiding, motivated the development of the notion of
\emph{externally visible behavior}, e.g., the set of traces of an
automaton, where a trace is a sequence of ``external'' actions,
visible at the interface, which the automaton can engage in.
Typically, a trace is obtained by taking an execution and removing all
the \emph{internal} information, i.e., the states and the internal actions.

The notion of externally visible behavior then leads naturally to
notions of external safety and liveness properties, which are
specified over the traces of an automaton, rather than over the
(internal) states and executions.
The external safety property is the set of all traces,
since this is the external ``projection'' of all the executions, which
define the reachable states and transitions, which in turn give us the
safety properties, as discussed above.
The external liveness property is obtained by taking the 
traces of all the live executions. These are called the \emph{live
traces}, and the set of all live traces is a \intr{live trace
property}. 




Trace inclusion usually means that every trace of the concrete
automaton is a trace of the abstract automaton.  Thus, trace inclusion
deals with safety properties: every safety property of the set of
traces of the concrete automaton is also a safety property of the set
of traces of the abstract automaton. Thus, external
safety properties are preserved by the refinement from the abstract to
the concrete.  Trace inclusion does not address liveness properties,
however.
The appropriate notion of inclusion for external liveness properties is
\intr{live trace inclusion} \cite{GSSL93,GSSL98}: every live trace of the
concrete automaton is a live trace of the abstract automaton.







Consider again the database example, with the external liveness property that
every query submitted is eventually processed.  Let  be a
high-level specification of such a system.  By using state variables
that record requests and responses, this property can be easily stated
in terms of the executions of , which results in a live execution
property.  The set of traces of the live executions then gives the
corresponding live trace property. Provided that the state variables
which record requests and responses are updated correctly, the live
trace property will only contain traces in which every input of a
query to the database (e.g., from an external ``user'') is eventually
followed by an output of a response from the database (to the user).

Let  be an implementation of . The live executions of  are
defined by the liveness properties that typically can be guaranteed by
reasonable implementations, e.g., ``fair scheduling''
\cite{Fr86}---every continuously enabled action (or process) is
eventually executed, and fair polling of message channels---every
message sent is eventually received\footnote{We do not address
fault-tolerance for the time being, thus messages are always received
along a live execution. See Section~\ref{sec:fault-tolerance} for a
discussion of how the techniques presented in this paper can be
applied to fault-tolerance.}.
The set of traces of the live executions then gives the 
live trace property corresponding to this action/process fairness and
reliable message delivery in the underlying execution behavior.
However, the live trace property that we wish to verify for  is not
this property per se, but the same live trace property which  has, namely that
every input of a query to
the database is eventually followed by an appropriate output from the database.
This paper addresses the problem of verifying such liveness properties
for an implementation  .

It is clear that verifying that the live traces of  are contained
in the live traces of  immediately yields the desired conclusion,
namely that  has the desired live trace property.
Thus, live trace inclusion applied to the above example implies that
every trace of an execution of  in which all messages sent are
eventually received, and all continuously enabled actions (processes)
are eventually executed, i.e., a live trace of , is also a live
trace of , i.e., a trace in which all queries receive a response. This
is exactly what is required, since the liveness properties of 
along executions where, for example, messages sent are not received,
are not of interest. Conversely, a live execution of , in which all
messages sent are received, and scheduling is fair, should produce an
external behavior which has the desired liveness properties:
every query receives a response.
More generally, live trace inclusion 
implies that external liveness properties are
preserved by the refinement from the specification  to the implementation
.


One of the main proof techniques for establishing trace inclusion is
that of establishing a \textit{simulation} \cite{LV95} or
\emph{bisimulation} \cite{Mil99} between the concrete and the abstract
automata.  A simulation (or bisimulation) establishes a certain
correspondence (depending on the precise type of simulation)
between the states/transitions of the concrete automaton and
the states/transitions of the abstract automaton, which then implies trace
inclusion.
An important advantage of the simulation-based approach is that it
only requires reasoning about individual states and finite execution
fragments, rather
than reasoning about entire (infinite) executions.  Unfortunately, the
end-result, namely the establishment of trace inclusion, does not, as
we establish in the sequel, imply live trace inclusion, since 
the set of live traces is, in general, a proper subset of the set of traces.
\remove{
Reasoning about liveness has traditionally been associated with
reasoning over entire executions, e.g., using well-foundedness arguments, 
variant functions, fairness etc. 
}


\paragraph{Our contributions.}
In this paper, we show how to use simulation relations to reason about
liveness.
\remove{This is therefore a significant methodological advance over current methods.}
Our approach uses a state-based technique to specify live execution 
properties: a \intr{liveness condition} is given as a (possibly infinite) set
of ordered pairs , where , 
are sets of states.
An execution is considered to satisfy a single pair
 iff whenever it contains infinitely many states
in , then it also contains infinitely many states 
in .  An execution is live iff it satisfies all the pairs
in the liveness condition. A trace is live iff it is the trace of some
live execution.
Our notion of liveness condition is akin to the acceptance condition
of a \intr{complemented-pairs (or Streett) automaton}
\cite{AH95,EL85,GL94}, except that we allow an infinite number of pairs,
and also our automata can have an infinite number of states and
transitions. 
We then present the notion of \intr{liveness-preserving simulation
relation}, which appropriately relates the states mentioned in the
concrete automaton's liveness condition to those mentioned in the
abstract automaton's liveness condition.  This is done in two stages.
The first stage refines the liveness condition of the abstract
automaton into a ``derived'' liveness condition of the concrete
automaton.  This derived condition may contain complemented-pairs that
are not directly specified in the liveness condition of the concrete
automaton.  The second stage then proves that the derived condition is
implied by the directly specified liveness condition of the concrete
automaton (using a ``lattice'' construction).  
The use of such a derived liveness condition allows us to
break down the refinement problem at each level into two simpler
subproblems, since the derived liveness condition of the concrete
automaton can usually be formulated to better match with the
liveness condition of the abstract automaton.
Establishing a liveness-preserving simulation relation then allows us
to conclude that every live trace of the concrete automaton is also a
live trace of the abstract automaton.
As discussed above, our method can be applied to multiple levels of
abstraction, where the specification is successively refined in
stages, producing several intermediate descriptions of the specified
system, until a description that is directly implementable on the
desired target architecture and has adequate performance and
fault-tolerance properties is derived.
Thus, we address the problem of preserving liveness properties in the
successive refinement of a specification into an implementation,
which contributes to making the method scalable, as our 
extended example in Section~\ref{sec:example} shows.

We establish two expressive completeness results for 
complemented-pairs liveness conditions. The first shows that any live execution
property which satisfies a natural ``robustness'' condition can be
specified by a complemented-pairs liveness condition. The second shows that any
live execution property whatsoever can be specified by a
complemented-pairs liveness condition, provided that history variables can be
used.

The paper is organized as follows.
Section~\ref{sec:background} provides technical background on automata
and simulation relations from
\cite{GSSL93} and \cite{LV95}.  Section~\ref{sec:live-automata} gives
our key technical notion of a live automaton, i.e., an automaton
equipped with a liveness condition, and also defines live executions,
live traces, and derived liveness properties.
Section~\ref{sec:sim-rels} presents our definitions for
liveness-preserving simulation relations, and shows that
liveness-preserving simulation relations
imply live trace inclusion.  Section~\ref{sec:lattices}
shows how a derived liveness condition can be deduced from the directly
specified condition. Together, these two sections give our
method for refining liveness properties.
Section~\ref{sec:example} applies our
results to the eventually-serializable data service of \cite{FGLLS99,LLSG92}.
Section~\ref{sec:discussion} examines some
alternative choices for expressing liveness, shows that our method
can also be applied to fault-tolerance properties, and briefly discusses the
mechanization of our method. 
Section~\ref{sec:expressiveness} discusses the expressiveness of complemented-pairs
for liveness properties, and presents two relative completeness results.
Section~\ref{sec:related} discusses related work.  Finally,
Section~\ref{sec:conc} presents our conclusions and discusses avenues
for further research.
Appendix~\ref{app:simulation-relations} gives some background on
simulation relations,
Appendix~\ref{app:TL} gives some background on temporal logic, and
Appendix~\ref{app:esds} presents I/O automaton pseudocode for the 
eventually-serializable data service of \cite{FGLLS99,LLSG92}.


\section{Technical Background}
\label{sec:background}

The definitions and theorems in this section are taken from \cite{GSSL93} and
\cite{LV95}, to which the reader is referred for details and proofs.


\subsection{Automata}
\label{sec:automata}

\bd[Automaton]
An \emph{automaton}  consists of four components:
\bn
\item a set  of states,
\item a nonempty set  of start states,
\item an action signature  where
 and  are disjoint sets of external and internal
actions, respectively let  denote the set , and
\item a transition relation .
\label{def:automaton}
\en
\ed

Let  range over states and  range over
actions. Write  iff . We say
that  is \intr{enabled} in .  An execution fragment  of
automaton  is
an alternating sequence of states and actions  such that  for all , i.e.,  conforms to the
transition relation of . Furthermore, if  is finite then it
ends in a state. 
If  is an execution fragment, then
 is the first state along , and if 
 is finite, then
 is the last state along .
If  is a
finite execution fragment,  is an execution fragment, and
, then  is the
concatenation of  and  (with  repeated
only once). 
Let  be an execution fragment. Then
the length of , denoted , is the number of actions in
.  is infinite if  is infinite, 
and  if  consists of a single state.
Also, .
If  is a prefix of , we write . We also
write  for  and .

An execution of  is an execution fragment that begins with a state
in . 
The set of all executions of  is denoted by , and
the set of all infinite executions of  is denoted by .
A state of  is \emph{reachable} iff it occurs in some execution of
.
The trace  of execution fragment  is obtained
by removing all the states and internal actions from .
The set of traces of an automaton  is defined as the set of traces
 such that  is the trace of some execution of .  It
is denoted by .
If  is a set of executions, then
 is the set of traces  such that  is the
trace of some execution in . 
If  is an action, then we define  if  is external, and
 (the empty sequence) if  is internal.
If  is a sequence of actions, then 
,
where juxtaposition denotes concatenation.

If  is a relation over  (i.e., ) and , then we define
.
We use  to denote the restriction of a mapping to a subset of its domain.



\subsection{Simulation Relations}
\label{sec:simulation-relations}

We shall study five different simulation relations: 
forward simulation, refinement mapping, backward simulation,
history relation, and prophecy relation.
These relations all preserve safety properties.
In Section~\ref{sec:sim-rels}, we extend these simulation relations so
that they preserve liveness as well as safety.
A forward simulation requires that (1) each execution of
an external action  of  is matched by a finite execution
fragment of  containing , and all of whose other actions are
internal to , and (2) each execution of an internal action of 
is matched by a finite (possibly empty) execution fragment of  all
of whose actions are internal to  (if the fragment
is empty, then we have , i.e.,  and  must be related by
the simulation).
It follows that forward simulation implies trace inclusion
(also referred to as the \intr{safe preorder} below), i.e., 
if there is a forward simulation from  to , then
.
Likewise, the other simulation relations all imply trace inclusion (the backward
simulation and prophecy relation must be image-finite) for similar reasons.
See Lemma 6.16 in \cite{GSSL93} for a formal proof of this result.

We use  to denote forward simulation, refinement
mapping, image-finite backward simulation, history relation,
image-finite prophecy relation, respectively. 
Thus, when we write , we mean that  is
one of these relations.
We write  if there exists a forward simulation from 
to  w.r.t. some invariants, and 
 via  if  is a forward simulation from
 to  w.r.t. some invariants. Similarly for the other simulation relations.
Appendix~\ref{app:simulation-relations} gives formal definitions for
all of these simulation relations. 





\subsection{Execution Correspondence}

Simulation relations induce a correspondence between the executions of
the concrete and the abstract automata. This correspondence is
captured by the notion of -relation.
If  is an execution of automaton
, then define 
 to be  if , and
to be  (the empty sequence) if .



\bd[-relation and Index Mappings]
Let  and  be automata with the same external actions and let 
be a relation over . Furthermore, let
 and  be executions of  and , respectively:
\ms\\
\ind  \\
\ind  \ms\\
Say that  and  are \intrdef{-related}, written
, if there exists a total, nondecreasing mapping

such that:
\bn
   \item \label{clause:index-mapping:init} ,

   \item \label{clause:index-mapping:corr}
          for all , ,

   \item \label{clause:index-mapping:trace}
          for all 
               , , and



   \item \label{clause:index-mapping:cofinal}
         for all , there exists an , 
             , such that .
\en
The mapping  is referred to as an \intrdef{index mapping} from
 to  with respect to .
Write  if for every execution  of , there
exists an execution  of  such that .
\label{def:index-mapping}
\ed






\bt [Execution Correspondence Theorem]
Let  and  be automata with the same external actions.
Suppose  via , where .
Then .
\label{thm:execution-correspondence}
\et




\bl  
Let  and  be automata with the same external actions and let 
be a relation over . If , then .
\label{lem:traces}
\el


Theorem~\ref{thm:execution-correspondence} and Lemma~\ref{lem:traces} appear
in \cite{GSSL93} as Theorem 6.11 and Lemma 6.15, respectively.




\subsection{Linear-time Temporal Logic}

We use the fragment of linear-time temporal
logic consisting of the  (always) and
 (eventually) operators over state assertions \cite{Pn77,MP92}.
In particular, we use the ``infinitary'' operators  (infinitely often)
and  (eventually always).
We specify state assertions as a set of states, the state in question
satisfying the assertion iff it belongs to the set.

For example, if  is a set of states, then
 means `` contains infinitely many states from ,''
and
 means ``all but a finite number of states of
                           are from .'' 
These operators can be combined with propositional connectives
 so that, for example,
 means ``if  contains
infinitely many states from , then it also contains 
infinitely many states from ,
and
 means ``all but a finite number of states of
                                are not from .'' 

Appendix~\ref{app:TL} provides a formal definition of the syntax and
semantics of the temporal logic that we use.


\section{Live Automata}
\label{sec:live-automata}

We first formalize the notions of live execution property and live
trace property, that discussed in the introduction.


\bd[Live Execution Property]
\label{def:liveness-property}
Let  be an automaton, and . Then,
 is a \emph{live execution property} for  if and only if
for every finite execution  of , there exists an infinite
execution  of  such that
 and .
\ed
In other words, a live execution property is a set of infinite
executions of  such that every finite execution of  can be
extended to an infinite execution in the set.
This requirement was proposed in \cite{AL91}, where it is called
\emph{machine closure}.

Note that we do not consider interaction with an environment in this
paper. THis is why we use automata rather than I/O automata, i.e., we
have external actions without an input/output distinction.
This issue is treated in detail in \cite{GSSL98}, where a
liveness property is defined as a set of executions (finite or
infinite) such that 
any finite execution can be extended to an execution in the set.
Thus, an extension may be finite, unlike our approach. This is because
requiring extension to an infinite execution may constrain the
environment: an execution ending in a state with no enabled internal
or output action will then require the environment to execute an
action that is an output of the environment and an input of the
automaton, so that the execution can be extended to an infinite one. 
We defer treating this issue to another occasion.


\bd[Live Trace Property]
\label{def:live-trace-property}
Let  be an automaton, and . Then,
 is a \emph{live trace property} for  if and only if
there exists a live execution property  for  such that 
.
\ed

In \cite{GSSL93,GSSL98}, the notion of live execution property was the
basic liveness notion, and a live automaton was defined to be an
automaton  together with a live execution property.
This use of an arbitrary set of executions as a liveness property,
subject only to the machine closure constraint resulted in a proof
method in \cite{GSSL93} which requires reasoning over entire
executions. Since we wish to avoid this, we take as our basic liveness
notion the \intr{complemented-pairs condition} of Streett automata,
with the proviso that we extend it to an infinite state-space and an
infinite number of complemented-pairs.
In the next section, we show that this approach to specifying liveness
entails no loss of expressiveness, provided that we can use history
variables.



Let  be an automaton. We say that  is a
\intrdef{complemented-pair}\footnote{When it is clear from context, we just
say ``pair''.} over  iff  is an ordered pair
 where , .
Given , we define the selectors  and . 
Let  be an infinite execution of . Then, we write
 iff ,
i.e., if  contains infinitely many states
in , then it also contains infinitely many states in
.
We also write 
 in this case. Our goal is a method for refining liveness properties using reasoning
over states and finite execution fragments only, in particular,
avoiding reasoning over entire (infinite) executions. We therefore formulate a
liveness condition based on states rather than executions.


\bd[Live Automaton with Complemented-pairs Liveness Condition] 
\label{def:live-automaton}
A \intrdef{live automaton} is a pair  where:
\bn

\item  is an automaton, and

\item  is a set of pairs

where  and  for
all , and  is some cardinal, which serves as an
index set,

\en

and ,  satisfy the following constraint:

\be
\item for every finite execution  of , there exists an infinite
execution  of  such that

 and .

\ee
\ed
 inherits all of the attributes of , namely the states,
start states, action signature, and transition relation of . 
The executions (execution fragments) of  are the executions
(execution fragments) of , respectively. 
We say that  is a \emph{complemented-pairs liveness condition} over .
Often we use just ``liveness condition'' instead of 
``complemented-pairs liveness condition.''

The constraint in Definition~\ref{def:live-automaton} is the machine
closure requirement, that every finite execution can be extended to a
live execution.



\bd[Live Execution]
\label{def:live-execution}
Let  be a live automaton. An execution  of  is a
\intrdef{live execution} iff  is infinite and .\\
We define .
\ed





Our notion of liveness condition is essentially the acceptance condition for
finite-state complemented-pairs automata on infinite strings
\cite{EL85}, with the important difference that we generalize it to an
arbitrary (possibly infinite) state space, and allow a possibly
infinite set of pairs. 
Despite the possibility that  and
 are infinite sets of states, it is nevertheless very
convenient to have an infinite number of complemented-pairs.  Using the database
example of the introduction, we can express the 
liveness property ``every query submitted is eventually processed'' as the
infinite set of pairs 
x, 
and where  is the set of all queries that have been submitted
but not yet processed ( is removed from  when it is processed).
Being able to allocate one pair for each query facilitates the very
straightforward expression of this liveness property.
Our extended example in Section~\ref{sec:example} also uses an
infinite number of pairs in this manner.

The above discussion applies to any system in which there are an infinite number
of \empi{distinguished} operations, e.g., each operation has a unique
identifier, as opposed to, for example mutual exclusion for a fixed
finite number of processes,, where there
are an infinite number of entries into the critical section by some
process , but these need not be ``distinguished,'' since the single
liveness property 

is sufficient to account for all of these. 
The key point is that only a bounded number of 
outstanding requests must be dealt with ( the number of
processes) , whereas in 
a system in which there are an infinite number
of {distinguished} operations, an unbounded number of outstanding
requests must be dealt with. We conjecture that the liveness property 
``every request is eventually satisfied'' cannot even be stated using
a finite number of complemented pairs.


The safe preorder, live preorder \cite{GSSL93} embody our notions of correct
implementation with respect to safety, liveness, respectively.

\bd[Safe preorder, Live preorder] Let ,  be live
automata with the same external actions .
We define: \ms\\
\ind Safe preorder:   iff
		       \1.5ex]
\begin{picture}(0,0)\includegraphics{lattice-req.pstex}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(7302,5011)(511,-5450)
\put(1201,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-4036){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4036){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(2776,-3586){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2776,-1486){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(526,-2386){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(601,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(601,-2776){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(5026,-2386){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(5026,-2776){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(5101,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2626,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2851,-5386){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3376,-586){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} \end{center}
\horline
\caption{Complemented-pairs lattice that establishes
         
         ().}
\label{fig:lattice-req}
\efg
We justify the complemented-pairs in Figure~\ref{fig:lattice-req} as
follows:
\bn

\item .\\
 is continuously enabled and eventually happens, for at
least one replica .

\item .\\
Liveness of , and the definition of action 
in Figure~\ref{fig:replica}.

\item .\\
If  holds continuously, then
either  is continuously enabled and eventually happens (making  true),
or  is disabled because  becomes true due to a gossip message.
Establishing  essentially requires a
``sublattice'' for each . This sublattice is a
``chain'' consisting of three pairs, with the ordering (a) 
(b)  (c):
   \bn

   \item 
   is the bottom element. It is justified since each client
   includes in  only operations that have already been requested. Thus
    is eventually received by some replica , at which point 
    holds.

   \item 
   is the middle element.
   It is justified ``inductively,'' i.e., it can be expanded into a sublattice in
   exactly the same way as 
   .
   This ``nested'' expansion is guaranteed to terminate however, since 
   is finite, for all .

   \item  is the top
   element. It is justified since  eventually sends a gossip message to .

   \en
By applying Lemma~\ref{lem:lattice} to this sublattice, we conclude 
.
Now  increases monotonically,  is
stable---once true, it remains true.
Hence, from the aforementioned pair for each 
, we conclude that 
eventually holds, and remains true subsequently, as required.

Note that the condition  does not need to be verified as
eventually holding, since it merely expresses a constraint on the value of the
``action parameter'' , i.e., the only instances of  which are
enabled are those having values of  that satisfy . That
is,  is properly regarded as part of the ``name'' of the action
.






\item  .\\
\label{pairs-list:strict}
This is justified by the following sublattice, where the ordering
relation is (a)  (b)  (c)  (d)  (e).
, , 
are implicit conjuncts of all the predicates in the sublattice, except
the  predicate of pair (e), and are omitted for clarity.
   \bn



   \item .
   Justified since  sends
   gossip messages to every other replica .

   \item .
   Justified since each  sends gossip messages to .

   \item .
   Justified since  sends gossip messages to every other replica .

   \item .
   Justified since each  sends gossip messages to .

   \item .
   Justified since  , 
   , and
    all hold continuously, since
    and  grow monotonically.
   Hence  is continuously enabled, and so is
   eventually executed.

   \en



\item .\\
 is continuously enabled and eventually happens.


\item .\\
Liveness of , and the definition of action 
in Figure~\ref{fig:front-end}.

\item .\\
 is continuously enabled and eventually happens.
\en


\paragraph{Establishing .}

We use the complemented-pairs lattice over  given in 
Figure~\ref{fig:lattice-stab} together with
Lemma~\ref{lem:lattice}.
\bfg
\begin{center}
\horline\1.5ex]
\begin{picture}(0,0)\includegraphics{lattice-stab.pstex}\end{picture}\setlength{\unitlength}{3947sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6627,4786)(1186,-5450)
\put(7726,-4036){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4036){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4261){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-1711){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(1201,-2161){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-1711){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-1936){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(7726,-2161){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}.}}}}
\put(2776,-3586){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2626,-4486){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2851,-5386){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3301,-2611){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3226,-811){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3271,-1711){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} \end{center}
\horline
\caption{Complemented-pairs lattice that establishes
         
         ().}
\label{fig:lattice-stab}
\efg
The bottom three complemented-pairs in Figure~\ref{fig:lattice-stab}
also occur in Figure~\ref{fig:lattice-req}, and have therefore already
been justified. We justify the remaining pairs as follows.
\bn

\item .
Justified since  sends
gossip messages to every other replica.

\item .
Justified since each  sends gossip messages to .

\item .
Justified since  sends gossip messages to every other replica.

\en





Since Definition~\ref{def:live-fwd-sim-inv} is now satisfied, we have established
.  Hence, applying
Theorem~\ref{thm:liveness}, we conclude .
Together with 

established above, we have
, as desired.


We have illustrated three levels of abstraction, and two
liveness-preserving forward simulations, between the top and middle,
and middle and bottom levels. It is straightforward to continue this
process. For example, an actual implementation would not simply route
a request to any replica, but would select the replica according to
certain criteria, for example load balancing/performance \cite{MDZ99},
or distance from the client \cite{PK00}.
Thus, the front-ends
and replicas would be refined to incorporate a
load-balancing/anycast/replica (or mirror) location ``service'' which,
given a request from a client , assigns some replica  to service
that request. We then map the complemented-pair 

into a pair at the next lower level
which expresses the liveness of the service: the service
eventually assigns some replica  to every request .  This pair could then
be justified by constructing a lattice whose elements are the
specified or derived liveness properties of the service.
 




\section{Discussion}
\label{sec:discussion}


\subsection{Alternative Choices for Specifying Liveness Properties}
\label{sec:alternatives}

We have used the complemented-pairs acceptance condition to specify
liveness properties. There are other acceptance conditions 
for finite automata over infinite strings that we could have
chosen: Buchi, generalized-Buchi, Rabin, and Muller. We briefly
discuss each in turn.

A Buchi condition is a single set  of states, and the
computation must contain an infinite number of states from .
This can be expressed as a single complemented
pair , and so is subsumed by complemented-pairs.
A generalized-Buchi condition  is a set 
 
of sets of states, and for each , the computation should
contain an infinite number of states from .
This can be expressed as the set of complemented-pairs

and so is also subsumed by complemented-pairs.

The Rabin condition is a set 

of pairs, however the acceptance condition is different.
A computation  is accepted iff for some pair
, 
 does not contain an infinite number of states in , and
 does contain an infinite number of states in .
This condition is a ``disjunctive'' one, it constrains a computation
only with respect to any one of the pairs, not all of them at once.
Since, in writing specifications, conjunction is far more useful than
disjunction, i.e., we typically list some properties \emph{all} of which
must be satisfied, we feel that this condition would not be useful in
practice.

The Muller condition is a set 

of sets of states, and, the set of states that
occur infinitely often along the computation should be exactly one of
the . This condition is not very suitable for an
infinite-state model, since it is possible (and indeed, often the
case) that an infinite computation does not contain any particular state
that recurs infinitely often, since the model usually contains
unbounded data, such as integers, reals, sequences, or sets.
Thus, the set of states \emph{each of which} 
occurs infinitely often along the computation, is usually empty.



Finally, we consider the ``temporal leads-to'' property.  Roughly, 
leads-to  means that, whenever  holds, then  subsequently 
holds. In our framework, leads-to properties can be expressed and
verified by using history variables. 
Let  be a boolean history variable that is initially false,
is set whenever  holds, and reset whenever  holds.
Then, the complemented-pair  expresses `` leads-to .''
Since  is not used to affect control flow, it
does not need to be ``implemented.'' Thus, the issue of
atomically detecting the values of  and  at run time and updating
, does not arise.





\remove{
\subsection{Open Problems for Infinite State Acceptance Conditions}
\label{sec:open-problems}

...
}

\subsection{Application to Fault-tolerance}
\label{sec:fault-tolerance}

Our method can be applied to the verification of \emph{fault
tolerance} properties. We consider situations in which the occurrence
of a fault can cause the system to enter a ``bad'' state, i.e., one
that is unreachable under normal execution \cite{AAE98}.
Let  denote the set of states that are reachable under normal system
execution from a start state, and
let  denote the set of states that result immediately
after a fault occurs, i.e., the post-states of faults (the faults can
occur in any state, good or bad). 
If follows that, under normal execution (no faults) only good states
are reachable from good states.

\remove{
Thus,  is the set of states reachable when the system
execution is subject to faults.
}

We are interested in ``nonmasking'' fault-tolerance properties of the type: once
faults stop occurring, the system will eventually recover to a good state (and
therefore remain forever after in good states, since only good states
are reachable from good states in the absence of faults). 
Expressed in temporal logic, this is .
This is logically equivalent to . We can
express this as the complemented pair .

\remove{
The constraint that eventually
faults stop occurring means that the number of faults that occur is finite. This
can be expressed as the pair . The recovery property
can be expressed as the pair .  Since  exhausts
all the states reachable under fault-prone execution, this means that every bad
state is eventually followed by a good state, or equivalently, a good state
eventually occurs, i.e., the pair .
}

Hence, the liveness condition  defines
the set of ``live'' executions to be either 
(1) those along which an
infinite number of faults occur (in which case we have no obligation
to recover to a good state) or 
(2) those along which an infinite number of good
states occur. In the latter case, we may also assume that faults stop
occuring, since the negation of this is covered by case (1).
Since only good states are reachable from good states, it follows that
there is some suffix consisting entirely of good states, and so the
system has recovered.

\remove{
only a finite number of faults occur, and furthermore, every bad state
is eventually followed by a good state.  In the suffix of an execution
in which faults no longer occur, the property of being in a good state
is stable: once the system is in a good state, it remains in a good
state.  Thus, the live executions are those in which only a finite
number of faults occur, and eventually the execution reaches a good
state and remains in good states forever after. This is precisely the
fault-tolerance property we wish to verify.
}

Thus, ``live'' executions are those in which the system exhibits the
desired fault-tolerance property.  The trace of such an execution is
then an ``external fault-tolerant behavior.''

We can now refine such nonmasking fault-tolerance properties, i.e., to
establish that the external fault-tolerant behaviors of an
implementation are included in those of the specification.  Our
framework thus can take the place of theories that are specialized to
dealing with nonmasking fault-tolerance, e.g., \cite{DA02},
which we have shown is just a particular kind of liveness property.


 
\subsection{Mechanization Of Our Method}
\label{sec:mechanization}

Our method imposes the following proof obligations:
\bn

\item Devise an appropriate liveness-preserving simulation and check
that it satsifies all of the conditions of its definition
(one of Definitions~\ref{def:live-fwd-sim-inv}--\ref{def:live-proph-inv}).

\item For each derived pair, devise a complemented-pairs lattice and check
  that it satisfies the conditions of Definition~\ref{def:lattice}.

\en

These conditions can be formalized in a first-order assertion language
with interpreted symbols. We refer the reader to \cite{GL00,GV04} for
details. The conditions can be verified using theorem provers
such as PVS \cite{OSR92}. For lack of space, we omit an extended
discussion of these issues, which can be found, for example, in
\cite{GV04}.
That paper presents \empi{normed simulations}, where the 
existence of a finite execution fragment at the abstract level that
matches a concrete transition is replaced by the existence 
of either a single matching transition, or an internal transition that
decreases a supplied norm (a function over a well-founded domain).
It should be possible to extend the ideas in this paper to normed
simulations. For example, if the concrete transition contains a 
state, then we require that, by the time that either the matching
abstract transition has been generated, or the norm function has
decreased to minimum, that a corresponding  state has appeared
at the abstract level. We leave the details to another occasion.







\section{Expressive Completeness of Complemented-pairs Liveness Conditions}
\label{sec:expressiveness}





We now investigate the expressiveness of complemented-pairs: what 
are the live execution properties which can be expressed by
complemented-pairs conditions? First, we make this notion precise.

\bd
Let  be an automaton and 
let  be a live execution property for . Then we say that
a liveness condition  \intrdef{expresses}  if and only if 
 is a live automaton and .
\ed


The use of (complemented-pairs) liveness conditions to specify
liveness means that the liveness of an execution depends only on the
set of states which occur in that execution, and not on their
ordering. This is necessary, to satisfy the machine closure condition,
since ordering is a safety property: once an ordering is violated
along a finite execution, no extension can then satisfy the ordering.

In Section~\ref{sec:completeness}, we show that, under some
assumptions that are natural for infinite-state systems, that the
generalized Buchi condition is expressively complete, i.e., they can
express any live execution property. Since complemented pairs subsumes
generalized Buchi, the result then carries over to our framework.

In Section~\ref{sec:forest}, we show that complemented pairs are
expressively complete if history variables can be used.

\remove{
In a strict sense, this implies a loss of expressive power.  This is
however an unavoidable consequence of reducing reasoning about
liveness from reasoning over entire executions to reasoning over
individual states and finite execution fragments. 
Moreover, this expressiveness can
be regained by using history variables, which record some aspect of
the execution up to the current state. At the extreme, we can use a
history variable which maintains a complete record of the execution so
far, and in this case, as we show below (Section~\ref{sec:forest}),
any live execution property
is expressible by some complemented-pairs condition. Using such a
history variable is tantamount to introducing aspects of reasoning
about finite executions into our method, in the guise of reasoning
about individual states/transitions.
Thus, by using history variables that record only a few aspects of the
current execution, versus history variables that record everything
which has occurred so far, we can trade off expressiveness 
versus an increased proof burden. Furthermore, in all cases, our
method avoids reasoning about \emph{infinite} executions, which, for
example, methods based on fairness must do.
}


\subsection{Relative Expressive Completeness of Complemented-pairs
  Liveness Conditions}
\label{sec:completeness}

\remove{
We now show that, under some assumptions that are natural for
infinite-state systems, that complemented-pairs conditions are
expressively complete, i.e, they can express any live execution
property.
}

In infinite-state systems, it is often the case that the occurrence of
``significant'' events is permanently recorded by changes to the state.
For instance, in the eventually-serializable data service of
Section~\ref{sec:example}, the execution of every operation on the
data results
in a permanent record of that operation's unique identifier. 
Any database system which maintains logs is also an example of this.
So is a real-time system in which clocks maintain the time,
if we consider the passage of time to be a
significant event.
This large class of systems justifies the assumption that a particular
state cannot repeat infinitely often along a live execution, since we
expect that significant events (e.g., operation execution, transaction
commit, time passage) occur infinitely often along a live execution.
Thus, we assume the following condition in this section:

\begin{assumption}[No infinite repetition]
\label{ass:no-infinite-repetition}
Let  be a live automaton, and
 be a live execution of . Then, there
is no state  such that  for an infinite number of values
for the index .  
That is, no state occurs infinitely often along .
\end{assumption}
 

Since a generalized-Buchi condition depends only on the set of states
which occur in that execution, we take it as reasonable that if one
execution contains ``more'' states than another, and the latter
execution is live, then the former execution should also be live. 
In this section, we restrict attention to liveness properties which
satisfy this condition, which we call \emph{robust} properties.
Our notion of one execution containing ``more'' states than another 
is captured by a relation  between executions.

\bd[]
\label{def:subsumption}
Let  and  be infinite executions of automaton .
Then  iff there exists a suffix  of  
and a mapping  such that 
\bn
\item , and 
\item  is a finite set.
\en
\ed

Thus,  iff  has some suffix  which can be
put into a correspondence with  as follows. If a state 
occurs some finite  number of times in , 
then state  also occurs some finite number of times in .
If  occurs infinitely often in , then  also occurs
infinitely often in . Note that Assumption~\ref{ass:no-infinite-repetition}
does not rule this out, since it applies only to live executions.
 is clearly reflexive and transitive, and so is a preorder.
We formalize the condition discussed above as the class of 
\intr{robust} live execution properties.

\bd[Robust Live Execution Property]
\label{def:robust-live-execution-property}
Let  be a live execution property for automaton .
Then,  is \emph{robust for } if and only if:\\
\ind for all , 
       if  and  then .
\ed

Our robustness condition corresponds more closely to using a
generalized-Buchi acceptance condition than a complemented-pairs
acceptance condition (see Section~\ref{sec:alternatives} above). Since
complemented-pairs subsume generalized-Buchi, this is still within our
framework, and also allows for a simpler technical development.
The definition of live trace properties corresponding to robust live
execution properties is straightforward.

\bd[Robust Live Trace Property]
\label{def:robust-live-trace-property}
Let  be an automaton, and . Then,
 is a \emph{robust live trace property} for  if and only if
there exists a robust live execution property  for  such that 
.
\ed



\remove{
We can now establish our relative completeness result: if  is
a robust live execution property, then there exists a
complemented-pairs liveness condition  which expresses , that
is, the executions which satisfy  are exactly those in .
}

We now show that an execution in  can be distinguished
from an execution outside  by means of a simple Buchi
acceptance condition.
For an execution , define .



\bp
\label{prop:distinguish-two-execs}
Let  be an automaton, and let  be an arbitrary
robust live execution property for .
Let   be such that 
 and . 
Then there exists a set  such that
 and .
\ep
\bpr
Since  is an infinite execution, we have by 
Assumption~\ref{ass:no-infinite-repetition} that  is an infinite set. 
Now suppose that  is a finite set.
Then, by Assumption~\ref{ass:no-infinite-repetition}, there exists a suffix 
 of  which contains no state in .
Hence . 
By Assumption~\ref{ass:no-infinite-repetition}
each state along  repeats only a finite number of times. 
Hence we have  by Definition~\ref{def:subsumption}.
Hence , again by Definition~\ref{def:subsumption}.
Thus by Definition~\ref{def:robust-live-execution-property}, ,
contrary to assumption. 
We conclude that  is an infinite set.
Thus .
Also, , by definition.
So, letting  establishes the proposition.
\epr

We next show that an execution outside  can be distinguished
from every execution inside  by means of a simple Buchi
acceptance condition.

\bp
\label{prop:distinguish-nonlive-exec}
Let  be an automaton, and let  be an arbitrary
robust live execution property for .
Let   be such that . 
Then there exists a set  such that
 and
.
\ep
\bpr
Let  be an arbitrary execution in , and let  be the set
given by Proposition~\ref{prop:distinguish-two-execs} for , .
Then  and .
Let . Then,
, since .
Also, 
 since  for every 
, . 
\epr

We now present the relative completeness result: every 
execution outside  can be distinguished
from every execution inside  by means of a 
generalized-Buchi acceptance condition.


\remove{
We now present the relative completeness result: every 
execution outside  can be distinguished
from every execution inside  by means of a 
complemented-pairs liveness condition. In fact, since the condition we
construct has  for the  sets of all its pairs, it is
also a generalized-Buchi acceptance condition.
}


\bt[Relative Expressive Completeness of Generalized-Buchi]
\label{thm:execs-relative-completeness}
Let  be an automaton, and let  be an arbitrary
robust live execution property for . 
Then there exists a generalized-Buchi condition 
 
over  such that                     .
\et
\bpr
If  then letting 
establishes the theorem. Hence we assume that
 is a proper subset of  for the rest of the proof.
Let  be an arbitrary execution in , and let
 be as given in Proposition~\ref{prop:distinguish-nonlive-exec} for .
Let .
Define .
We show that .
The proof is by double-containment.


\noindent
{}:
Choose arbitrarily .
So .
Hence  by 
Proposition~\ref{prop:distinguish-nonlive-exec}, and so 
.
Thus  by definition of .
Taking the contrapositive yields 
 implies , i.e., .

\noindent
{}:
Choose arbitrarily  and .
Hence  by
Proposition~\ref{prop:distinguish-nonlive-exec}. 
Hence .
Hence  by definition of .
Thus .
\remove{
Since , we have by Definition~\ref{def:liveness-property}
that  satisfies the constraint of Definition~\ref{def:live-automaton}.
Hence  is a liveness condition over . This concludes the proof.}
\epr




\bco[Relative Expressive Completeness of Complemented-pairs]
\label{thm:traces-relative-completeness}
Let  be an automaton, and let  be an arbitrary
robust live trace property for . Then there exists a 
complemented-pairs liveness condition
 over  such that .
\eco
\bpr
Let  be an arbitrary robust live trace property for .
By Definition~\ref{def:robust-live-trace-property}, 
there exists a robust live execution property  for  such that 
.
By Theorem~\ref{thm:execs-relative-completeness}, there exists a 
generalized-Buchi condition  over 
such that 
.
Let . Then 
.
Hence there exists a complemented-pairs liveness condition
 over  such that .
\epr





\subsection{Expressive Completeness of Complemented-pairs for Liveness Properties of 
            Forest Automata}
\label{sec:forest}

An automaton  is a \intrdef{forest automaton} iff for each reachable state
 of , there is exactly one (finite) execution of  with last
state . 
Thus, if  are arbitrary different infinite executions of , then
they have only a finite number of states in common.
Any automaton can be turned into a forest automaton by
adding a history variable which records the execution up to the current
state. While this is obviously impractical for a real implementation,
such a variable is only needed for modeling and analysis purposes; it
does not have to be implemented since it does not affect the actual 
execution of the automaton.\footnote{The terms ``ghost variable'' and
``auxiliary variable'' have been used in the literature for this notion.}

Let  be an arbitrary infinite execution of .
Define .


\bp
\label{prop:exec-pair}
Let  be a forest automaton. Then
.
\ep
\bpr
Let  be arbitrary elements of .
If , then ,
since  have only a finite number of states in common.
Hence , and so .
If , then , and so 
      .
\epr


We show that, if  is a live execution
property for automaton , then there exists a liveness
condition which expresses , i.e. such that an execution
satisfies every complemented-pair in the condition iff it is a member
of .


\bt[Expressive Completeness of Complemented-pairs for Forest Automata]
\label{thm:execs-forest-completeness}
Let  be a forest automaton, and let  be an arbitrary
live execution property for .
Then there exists a complemented-pairs liveness condition
 over  such that .
\et
\bpr
If  then letting 
establishes the theorem. Hence we assume that
 is a proper subset of  for the rest of the proof.
Let .
We show that . The proof is by double-containment.

\noindent
{}:
Choose arbitrarily  and .
Now  by definition, and so .
From the definition of , we have .
Hence, by Proposition~\ref{prop:exec-pair}, .
Since  was chosen arbitrarily from 
, we conclude .
Hence  , since . 

\noindent
{}:
Choose arbitrarily  and .
Hence .
Hence, by Proposition~\ref{prop:exec-pair}, .
Since  was chosen arbitrarily from 
, we conclude, from the definition of , that 
.
\remove{
Since , we have by Definition~\ref{def:liveness-property}
that  satisfies the constraint of Definition~\ref{def:live-automaton}.
Hence  is a liveness condition over . This concludes the proof.}
\epr




\bco[Expressive Completeness of Complemented-pairs for Forest Automata]
\label{thm:traces-forest-completeness}
Let  be a forest automaton, and let  be an arbitrary
live trace property for . Then there exists a complemented-pairs liveness condition
 over  such that .
\eco
\bpr
Let  be an arbitrary live trace property for .
By Definition~\ref{def:live-trace-property}, 
there exists a live execution property  for  such that 
.
By Theorem~\ref{thm:execs-forest-completeness}, there exists a liveness condition
 over  such that .
Hence there exists a liveness condition
 over  such that .
\epr



\section{Related Work}
\label{sec:related}

The use of an infinite number of complemented pairs was proposed by
Vardi \cite{Var91}, which defines a recursive Streett automaton to be
one whose transition relation is recursive, and whose complemented
pairs are defined by recursive sets. Recursive Buchi automata are
defined similarly. Recursive Wolper automata are those with a
recursive transition relation and no acceptance conditions. Every
infinite run of the Wolper automaton is accepting.
The paper shows that Recursive Wolper, Buchi, and Street
automata all accept the same set of languages, namely .
In our approach, we make no restrictions on the set of complemented
pairs. For example, we allow uncountable sets of pairs, which could be
useful for specifications over uncountable domains, e.g., the reals.

The safety-liveness classification was first proposed in \cite{Lam77}.
Formal characterizations of safety and liveness, variously based on Buchi
automata, temporal logic, or the Borel hierarchy, 
were given in \cite{AS87,MP90,Sis94}. 
Many researchers have proposed deductive systems for proving
properties of infinite-state reactive and distributed systems, including liveness
properties, e.g., \cite{AS89,Lam94,Lam02,MP91}.
Some of the methods proposed to date incorporate diagrammatic
techniques, similar in spirit to our complemented-pairs
lattices. 
In particular, Owicki and Lamport \cite{OL82} propose \emph{proof lattices},
and Manna and Pnueli \cite{MP83,MP93} propose
\emph{proof diagrams}, both for establishing liveness properties of
concurrent programs. 
In \cite{MP94}, Manna and Pnueli propose three different kinds of 
\emph{verification diagrams}, two for safety properties, and one for
liveness properties of the form 
, where  are state-assertions,
that is, temporal leads-to properties. Nodes in this diagram are
labeled with state-assertions, and directed edges between nodes
represent program transitions. 
Some of these edges correspond to ``helpful'' transitions, which are
guaranteed to occur (using fairness) if execution enters their source
node, and whose occurrence makes progress towards making  true.
Browne et. al. \cite{BMS95} and Manna et. al. \cite{MBSU98} present
\emph{generalized verification diagrams}, 
which can be used to establish arbitrary temporal properties of
programs, including liveness properties. These are a particular kind
of -automaton (``formula automata'').
These methods relate a program, expressed in an operational notation,
to a property expressed in temporal logic, i.e., they relate two
artifacts expressed in very different notations.  Thus, they cannot be
used to refine liveness properties in a multi-stage stepwise
refinement method that, starting with a high-level specification,
expressed in a particular (operational) notation, 
constructs a sequence of artifacts, all expressed in the \emph{same} notation, 
and each a refinement of the previous one, and ending with the
detailed implementation.

Our complemented-pairs lattices relate a liveness property of an
automaton, to a liveness property of a lower level automaton, i.e.,
the relationship is between two artifacts expressed in the same
notation. This forms the basis for a multi-stage proof
technique that refines high-level liveness properties down to the
liveness properties of an implementation in several manageable
steps (our use of ``sublattices'' in Section~\ref{sec:example} is an
example of this). Furthermore, each indivudual refinement step is
itself decomposed into the tasks involved in constructing lattices and 
discharging the associated ``verification conditions.''
We feel that this ability to decompose a liveness proof into
multiple stages directly attacks the scalability problem,
and is one of our main contributions.
\remove{
[[[removed in response to referees]]]
In addition, all of the above discussed proof systems rely on either
well-foundedness arguments or on fairness, to establish liveness
properties. Thus, they inherently require reasoning over entire executions.
}
UNITY \cite{CM88} provides a framework in which a subclass of general
liveness properties, namely ``leads-to'' can be verified and
refined. The approach is proof theoretic, and also relies on
fairness. We showed in Section~\ref{sec:alternatives} above how to
deal with leads-to properties in our framework.
All of the aforementioned methods operate only at the level of
executions, and do not provide a notion of external behavior, such as
a set of traces.




Gawlick et. al. \cite{GSSL93,GSSL98} presents a proof method
for liveness properties.  In that paper, a
liveness property of an automaton  is modeled as a subset  of
the executions of .\footnote{ must satisfy the machine closure
constraint of Definition~\ref{def:live-automaton}.}
However, the method presented there imposes a proof obligation
concerning the liveness of individual executions, without providing
any rule or method for discharging this obligation. Specifically, 
in addition to establishing a simulation, we have to
show that if an execution  of the implementation 
corresponds to an execution  of the specification ,
and  is live (i.e.,  is a member of the liveness
property), then  is also live\footnote{See \cite{GSSL93}, page 89.}.
Merely establishing a simulation between  and 
is insufficient to show this, since the simulation relation makes no
reference to the liveness conditions of  and .
The main concern in \cite{GSSL93} is the interaction between
liveness properties and parallel composition; a
notion of ``environment-freedom'' is introduced which 
enables the use of compositional verification for liveness.
The published version \cite{GSSL98} omits the proof method.

Likewise, Jensen~\cite{Jen99} presents simulation relations for 
proving liveness properties, and also requires that an ``inclusion''
condition be verified. A difference is that the live executions are
exactly the fair executions, and so the inclusion property becomes:
if an execution  of the implementation 
corresponds to an execution  of the specification ,
and  is fair, then  is also fair 
(Theorems 2.9 and 2.10 in \cite{Jen99}).

Sogaard-Andersen, Lynch, and Lampson \cite{SLL93} presents a similar
method, with the main difference being that the liveness property is
given by a linear temporal logic formula. Now, the proof obligation is
that if an execution  of the implementation  corresponds to
an execution  of the specification , and 
satisfies the liveness formula for , then  satisfies the
liveness formula for .




Henzinger et.~al.~\cite{HKR97} presents various extensions of
simulation that take fairness into account.  Fairness is expressed
using either Buchi or Streett (i.e., complemented-pairs) acceptance
conditions. However, the fair simulation notions are defined using a
game-theoretic semantics, and require a priori that fair executions of
the concrete automaton have matching fair executions in the abstract
automaton. There is no method of matching the  and 
states in the concrete and abstract automata to assure fair trace
containment. Also, the setting is finite state, and the paper
concentrates on algorithms for checking fair simulation.


Alur and Henzinger \cite{AH95} proposes the use of complemented-pairs acceptance
conditions to define liveness properties. However it restricts the
conditions to contain only a finite number of pairs. As our example in
Section~\ref{sec:example} shows, it is very convenient to be able to
specify an infinite number of pairs---in this case, we were able to
use two pairs for each operation  submitted to the data service,
one pair to check for response, and the other to check for
stabilization. It would be quite difficult to specify the liveness
properties of the data service using only a finite number of pairs.
If however, the system being considered is finite-state, then we
remark that much of the work on temporal logic model
checking seems applicable. For example, the algorithm
of Emerson and Lei~\cite{EL85} for model checking under fairness assumptions can
handle the complemented-pairs acceptance condition.
While \cite{AH95} gives rules for compositional and modular
reasoning, it does not provide a method for refining liveness
properties. As stated above, we believe this is a crucial aspect of a
successful methodology for dealing with liveness. It should be clear
that Figure~\ref{fig:lattice-req} provides a very succinct
presentation for the refinement of the liveness property expressed by
, namely that every request
eventually receives a response.

Our work is in the linear-time setting, where the external behavior is
a set of traces. In the branching-time setting, the external behavior
can be given as a ``trace-tree'' \cite{HKR97}, i.e., a tree whose
branches are traces. Our liveness-preserving
simulation relations should imply an appropriate containment notion
between ``live-trace-trees,'' i.e., a tree whose branches are live
traces. However we point out technical differences between our setting
and \cite{AH95,HKR97}: we abstract away states and internal actions to
obtain traces, whereas in \cite{AH95,HKR97} an execution is a sequence
of states (actions are not named), and a 
trace is obtained by applying an ``observation function'' to each
state along the execution.

Kesten, Pnueli, and Vardi~\cite{KP00,KPV01} present a method of
\empi{finitary abstraction}: construct a finite-state abstraction (``abstract
system'') of an
infinite-state ``concrete'' system, and model check this abstraction for the
required properties. The method deals with properties expressed in
full linear time temporal logic, (and so handles both safety and
liveness), and is complete, i.e., a suitable finite state abstraction
can always be constructed.
The semantics of the concrete system is given by a \empi{Fair Discrete
System} (FDS), which consists of
(1) a finite set of typed system variables, containing the data and
control state (the \empi{concrete} variables),
(2) a predicate giving the set of initial states, 
(3) a predicate giving the transition relation, 
(4) a \empi{justice condition};  a finite set of predicates ,
where each  must hold infinitely often along a computation, and
(5) a \empi{compassion condition}, 
a finite set of pairs of predicates ;
along a computation, if  holds infinitely often, then
 must hold infinitely often.
The {justice} and {compassion} conditions ensure that the concrete
system satisfies liveness properties by restricting attention to
``fair'' computations.
For a given concrete system, a finite-state abstract system is
specified syntactically, by giving a set of abstract variables (with
finite domains), and for each abstract variable, giving its value as
an expression over the concrete variables. This implicitly defines a
mapping from concrete to abstract states, and gives rise to two
abstraction operators on concrete predicates: 
(1) a universal (contracting) abstraction, that holds in an abstract
state iff the concrete predicate holds in all corresponding concrete
states, and 
(2) an existential (expanding) abstraction, that holds in an abstract
state iff the concrete predicate holds in some corresponding concrete
state.
The (concrete) temporal properties to be verified are abstracted
by distributing these operators through temporal modalities (nexttime,
until) and disjunction. Distribution through negation converts a 
universal abstraction into an existential one, and vice-versa.
The abstract system is obtained by applying existential abstraction to
the initial state predicate and each justice predicate. The transition 
relation is abstracted by ``lifting'' it to the abstract level using
the definitions of the abstract variables in terms of the concrete
variables.
The compassion pairs \mbox{} are abstracted by applying
universal abstraction to  and existential abstraction to .
\remove{
This is analogous to our requirement in
Definition~\ref{def:live-fwd-sim-inv} that a  state in an
abstract execution fragment implies the existence of a  state in
the corresponding concrete transition, while a  state in the
concrete transition implies the existence of a  state in the
corresponding abstract execution fragment.
}
A main result is that if the abstracted system satisfies the
abstracted property, then the concrete system satisfies the concrete
property.  Another main result is that the method is complete: if the
concrete system satsifies the property, then there exists a
corresponding finite state abstract system and abstracted property
such that the abstract system satsifies the abstract property.  To
obtain completeness, the concrete system must be ``augmented'' by
composing it (synchronously) with a ``ranking monitor,'' which tracks
the difference in successive values of a variant function (``progress
measure'' in the paper) that decreases with progress towards
satisfying the liveness property, and is defined over a well-founded
domain. The reason for incompleteness of the unaugmented method is
liveness properties.
A major difference with our approach is that the number of
complemented pairs is finite, whereas we allow an infinite set.
Furthermore, the abstract system in our approach is not necessarily
finite state. Verification in our approach is by manually devising a
liveness-preserving simulation relation, and the needed complemented
pairs lattices, and then checking the conditions in the corresponding
definitions, possibly with mechanization via theorem proving (see
Section~\ref{sec:mechanization}).  Verification in \cite{KP00,KPV01}
is by manually devising the finitary abstraction mapping and the
ranking monitors, and then model-checking the resulting abstracted
system against the abstracted property. There is no method for
deriving a liveness property at one level from other liveness
properties at the same level, like our complemented-pairs lattices
provide.

In \cite{Ur98}, a method of abstraction based on Galois theory is presented. 
This is based on extensions of the framework of abstract
interpretation \cite{CC77} to temporal properties. 
Again, there are two abstraction notions: under-approximation and
over-approximation.
In \cite{DGG00}, the interaction between abstraction and model
checking under fairness is discussed.  
It is pointed out that abstraction really requires three-valued logic,
since, e.g., a proposition that is true in one concrete state and
false in another has ``unknown'' value in an abstract state
that represents both concrete states.
To handle fairness properly, two abstractions of the transition
relation are introduced, called the free and constrained transition
relations. 



\section{Conclusions and Further Work}
\label{sec:conc}

We have presented five liveness-preserving simulation relations that
allow us to refine the liveness properties of infinite-state
distributed systems.
Our method for refining liveness requires reasoning only over
individual states and finite execution fragments, rather than
reasoning over entire executions.  We believe that the use of
simulation-based refinement together with complemented-pairs lattices
for expressing and combining liveness properties provides a
powerful and general framework for refining liveness properties.
In particular, our approach facilitates the decomposition of the
refinement task at each level into simpler subtasks: devise the
liveness-preserving simulation relation, and devise the
complemented-pairs lattices. Since the lattices are a kind of diagram,
they also facilitate the decomposition of proofs and the separation of
concerns, which contributes to scalability of the method.

The general approach and techniques used in this paper do not depend
intimately on the particular automaton model that we used.  Thus, for
example, our approach can be applied to labeled transition systems,
which are used to define operational semantics for process algebras
such as Algebra of Communicating Processes \cite{BW90},
Communicating Sequential Processes \cite{Hoa85},
Calculus of Communicating Systems \cite{Mil89}, and the -calculus \cite{Mil99}.
Our approach can also be extended in a
straightforward way to formalisms with unlabeled actions, such as
(finite or infinite) Kripke structures, 
since the fact that actions are named is not used in any essential
way, it just contributes to the ``matching'' condition in simulation
relations, and to the definition of external behavior (trace).



We showed that the Streett acceptance condition (generalized to
arbitrary cardinality) is expressive enough to define any liveness
property, provided that it satisfies a notion of robustness, or
provided that history variables can be used.  \remove{ This suggests a
new direction of research: investigating such infinite-state
generalizations of Buchi, Rabin, Muller, and Streett automata.  }

Simulation relations as a proof method for refinement have been widely
studied. One major impediment to their widespread adoption in practice
is the absence of efficient methodologies for establishing simulation
relations. Doing so usually requires long proofs, with many invariants,
etc. Some of the ideas in this paper may be applicable to
decomposing and simplifying the task of establishing simulation
relations in the first place. For example, it may be possible to apply
our approach to refining the invariants that are used in such
proofs. Another potential application is to models of computation for
dynamic \cite{ALy01}, real-time \cite{LSVK03}, hybrid \cite{LSV03}, and
probabilistic \cite{S95}  systems.
For example, a real-time analogue of a complemented-pair condition
would be: if a  state occurs, then a  state must occur
within  time units. A complemented-pairs lattice that refines a
complemented-pair would then have to satisfy, in addition to the
current requirements of Definition~\ref{def:lattice}, a condition for
the time bounds: every path from the bottom element to the top element
should have a ``total'' time bound matching the pair being refined.
In \cite{ALy01}, we present an automata-theoretic model for dynamic
computation, in which individual processes (automata) that constitute
a system can be created and destroyed, and can dynamically change
their action signature. Since the techniques of this paper assume only
a generic automaton structure, they are applicable to the model of 
\cite{ALy01}. Combining these two pieces of work will result in a
comprehensive method for verifying the liveness properties of
dynamic systems.











\clearpage
\bibliographystyle{plain}
\bibliography{bibfiles/ABBREV,bibfiles/DIST,bibfiles/IOAUT,bibfiles/MODEL,bibfiles/SYNTH,bibfiles/LOGIC,bibfiles/MOBILE,bibfiles/SENG}






\clearpage
\appendix



\section{Simulation Relations}
\label{app:simulation-relations}

We present here five simulation relations, using the definitions of \cite{LV95}.

\bd[Forward Simulation] Let  and  be automata with the same
external actions. A \intrdef{forward simulation} from  to 
is a relation  over  that satisfies:
\bn
   \item If , then .
   \item If  and , then there exists a
finite execution fragment  of  such that , 
, and .
\en
\ed





Simulation based proof methods typically use \intr{invariants} to
restrict the steps that have to be considered. An invariant of an
automaton is a predicate that holds in all of its reachable states, or
alternatively, is a superset of the reachable states.




\bd[Forward Simulation w.r.t. Invariants]
Let  and  be automata with the same external actions and with
invariants , , respectively. A \intrdef{forward simulation}
from  to  with respect to  and 
is a relation  over 
that satisfies:
\bn

\item \label{clause:fwd-sim-inv:init} If , then
.


\item \label{clause:fwd-sim-inv:trans}
If , , and , then
there exists a finite execution fragment  of  such that
, 
, and .

\en
\label{def:fwd-sim-inv}
\ed
We write  if there exists a forward simulation from 
to  w.r.t. some invariants, and 
 via  if  is a forward simulation from
 to  w.r.t. some invariants.




\bd[Refinement Mapping w.r.t. Invariants]
Let  and  be automata with the same external actions and with
invariants , , respectively. A \intrdef{refinement mapping}
from  to  with respect to  and 
is a function  from  to 
that satisfies:
\bn

\item \label{clause:ref-inv:init} If , then
.


\item \label{clause:ref-inv:trans}
If , , and , then
there exists a finite execution fragment  of  such that
, 
, and .

\en
\label{def:ref-inv}
\ed
We write  if there exists a refinement mapping from 
to  w.r.t. some invariants, and 
 via  if  is a refinement mapping from
 to  w.r.t. some invariants.




\bd[Backward Simulation w.r.t. Invariants]
Let  and  be automata with the same external actions and with
invariants , , respectively. A \intrdef{backward simulation}
from  to  with respect to  and 
is a relation  over 
that satisfies:
\bn

\item If , then .

\item \label{clause:back-sim-inv:init} 
If , then .


\item \label{clause:back-sim-inv:trans}
If , , and , then
there exists a finite execution fragment  of  such that
, 
, and
.

\en
\label{def:back-sim-inv}
\ed
A backward simulation  w.r.t. invariants is \intr{image-finite} iff
for each ,  is a finite set.
We write  if there exists a backward simulation from 
to  w.r.t. some invariants, and 
 via  if  is a backward simulation from
 to  w.r.t. some invariants.
If the backward simulation is image-finite, then we write 
,  via , respectively.


\bd[History Relation w.r.t. Invariants]
Let  and  be automata with the same external actions and with
invariants , , respectively. A \intrdef{history relation}
from  to  with respect to  and 
is a relation  over 
that satisfies:
\bn

\item \label{clause:hist-inv:init}
 is a forward simulation from  to  w.r.t.  and .

\item \label{clause:hist-inv:trans}
 is a refinement from  to  w.r.t.  and .

\en
\label{def:hist-inv}
\ed
We write  if there exists a history relation from 
to  w.r.t. some invariants, and 
 via  if  is a history relation from
 to  w.r.t. some invariants.



\bd[Prophecy Relation w.r.t. Invariants]
Let  and  be automata with the same external actions and with
invariants , , respectively. A \intrdef{prophecy relation}
from  to  with respect to  and 
is a relation  over 
that satisfies:
\bn

\item \label{clause:proph-inv:init}
 is a backward simulation from  to  w.r.t.  and .

\item \label{clause:proph-inv:trans}
 is a refinement from  to  w.r.t.  and .

\en
\label{def:proph-inv}
\ed
A prophecy relation  w.r.t. invariants is \intr{image-finite} iff
for each ,  is a finite set.
We write  if there exists a prophecy relation from 
to  w.r.t. some invariants, and 
 via  if  is a prophecy relation from
 to  w.r.t. some invariants.
If the prophecy relation is image-finite, then we write 
,  via , respectively.





\newpage
\section{Linear-time Temporal Logic}
\label{app:TL}

We define the syntax and semantics of the temporal logic that we use as
follows. This is essentially linear-time temporal logic
without the until and nexttime operators.


\bd[Syntax of Linear-time Temporal Logic]
\label{def:TL-syntax}
The syntax of a linear-time temporal logic formula is given inductively 
as follows, where  are sub-formulae, and  is a set of states
which defines a state-assertion\textup{:}
\be

\item Each of  and  is a formula

\item  is a formula which intuitively means that 
      holds in every state of the execution being considered

\item  is a formula which intuitively means that 
      holds in some state of the execution being considered

\ee
\ed

Formally, we define the semantics of linear-time temporal logic
formulae with respect to an infinite execution, that is, an infinite
sequence of states.


\bd[Semantics of Linear-time Temporal Logic]
We use the usual notation to indicate truth:
 means that  is true of execution .
We define  inductively, where 
is an infinite sequence of states, and
 is the suffix of  starting in .

\begin{tabbing}
aaa\=              aaaaaaaaaaaa\= aaaaaaa\=        \kill
   \>              \>iff     \>\\
   \>         \>iff     \>it is not the case that \\
   \>      \>iff     \> and \\
   \>      \>iff     \>for all , \\
   \>  \>iff     \>for some , 
\end{tabbing}
\ed
In particular,  meains that  for an
infinite number of values of .




\newpage
\section{I/O Automaton Code for the ESDS Example, from \protect \cite{FGLLS99}}
\label{app:esds}




\begin{figure}[hb]

\horline
\ioautomatontitle{}

\begin{signature}
\io{, 
	where  and 
}{, 
	where 
}
\end{signature}



\begin{statevarlist}

\item , a subset of , initially empty


\end{statevarlist}

\begin{actionlist}


\iocode{

\prcef{\textbf{Output} }
{ \\
  
}{
}

}{

\ef{\textbf{Input} }
{None
}

}

\end{actionlist}

\horline
\caption{The Users Automaton}
\label{fig:users}
\efg






\begin{figure}[hb]

\horline
\ioautomatontitle{}

\begin{signature}

\ioi{, 
	where 
}{, 
	where  and 
}{, 
	where  
	and  is a strict partial order on  \\
, 
	where  \\
, 
	where  and  \\ 
, 
	where  is a partial order on 
}
\end{signature}

\begin{statevarlist}

\item , a subset of , initially empty; 
	the operations requested but not yet responded to
\item , a subset of , initially empty; 
	operations and responses that may be returned to clients
\item , a subset of , initially empty; 
	the set of all operations that have ever been entered
\item , a partial order on , initially empty; 
	constraints on the order operations in  are applied
\item , a subset of , initially empty;
	the set of stable operations

\end{statevarlist}

\begin{actionlist}

\iocode{\ef{\textbf{Input} }
{
}

\prcef{\textbf{Internal} }
{ \\
   \\
   \\
   \\
   \\
   \\
  
}{ \\
  
}

\prcef{\textbf{Internal} }
{ \\
  
}{
}

}{

\prcef{\textbf{Internal} }
{ \\
   \\
  , 
	 \\
  
}{
}

\prcef{\textbf{Internal} }
{ \\
   \\
  
}{if  then  
}

\prcef{\textbf{Output} }
{ \\
  
}{ \\
   
}

}

\end{actionlist}
\horline
\caption{The Specification ESDS-I}
\label{fig:ESDSI}
\efg





\bfg

\horline

\iocode{

\prcef{\textbf{Internal} }
{ \\
   \\
 \\
   \\
   \\
  
}{ \\
  
}

}{

\prcef{\textbf{Internal} }
{ \\
  , 
	 \\
   totally orders 
}{
}

}

\horline

\caption{The Specification ESDS-II. Only differences with ESDS-I are shown.}
\label{fig:ESDSII}
\efg



\bfg

\horline

\ioautomatontitle{}

\begin{signature}

\io{, 
	where  and  \\
, 
	where  is a replica and  
}{, 
	where , , and  \\ 
, 
	where  is a replica and 
}
\end{signature}



\begin{statevarlist}

\item , a subset of , initially empty 
\item , a subset of , initially empty 

\end{statevarlist}

\begin{actionlist}

\iocode{\ef{\textbf{Input} }
{
}

\prcef{\textbf{Output} }
{
}{None
}

}{

\ef{\textbf{Input} }
{if  then 
}

\prcef{\textbf{Output} }
{ \\
  
}{ \\
  
}
}

\end{actionlist}

\horline
\caption{The Automaton for the front end of client }
\label{fig:front-end}
\efg







\bfg

\horline
\ioautomatontitle{}

\begin{signature}

\ioi{, 
	where  is a client and  \\
, 
	where  is a replica and  
}{, 
	where  is a client and  \\
, 
	where  is a replica and  
}{, 
	where  and 
}
\end{signature}

\begin{statevarlist}

\item , a subset of , initially empty; 
	the messages that require a response
\item , a subset of , initially empty; 
	the operations that have been received
\item  for each replica , 
	a subset of , initially empty; 
	the operations  knows are done at 
\item  for each replica , 
	a subset of , initially empty; 
	the operations  knows are stable at  
\item , 
	initially all ; 
	the minimum label  has seen for  
\item Derived variable: 
	, 
	a strict partial order on ; 
	the local constraints at 


\end{statevarlist}

\begin{actionlist}

\iocode{

\ef{\textbf{Input} }
{ \\
  
}

\prcef{\textbf{Internal} }
{ \\
   \\
   for all 
}{ \\
   
}

\prcef{\textbf{Output} }
{ \\
   \\
   \\ 
   
}{
}

}{

\prc{\textbf{Output} }
{; ; \\ 
  ; 
}

\ef{\textbf{Input} }
{ \\
   \\
   \\
   for all  \\
   \\
   \\
  
}
}

\end{actionlist}

\horline
\caption{Automaton for replica }
\label{fig:replica}
\efg












\bfg

\horline

\ioautomatontitle{}

\begin{signature}

\io{, 
	where 
}{, 
	where  
}
\end{signature}



\begin{statevarlist}

\item , a multiset of messages, (taken from ),
	initially empty
\end{statevarlist}

\begin{actionlist}

\iocode{\ef{\textbf{Input} }
{
}

}{

\prcef{\textbf{Output} }
{
}{
}
}

\end{actionlist}

\horline
\caption{The Channel Automaton}
\label{fig:channel}
\efg








\end{document}
