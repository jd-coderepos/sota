\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\pagestyle{plain}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{authblk}



\makeatletter

\newcommand{\noun}[1]{\textsc{#1}}





\usepackage{cite}

\usepackage{tikz}

\DeclareMathAlphabet{\mathscr}{OT1}{pzc}{m}{it}

\usepackage[ruled,vlined]{algorithm2e}

\usetikzlibrary{patterns}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}{Observation}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{assumption}{Assumption}

\newcommand{\eps}{\varepsilon}
\newcommand{\schedule}{\ensuremath{\mathcal{S}}}

\newcommand{\OO}{\mathcal{O}}
\newcommand{\UB}{\text{UB}}
\newcommand{\opt}{\textsc{Opt}}
\newcommand{\OPT}{\opt}
\newcommand{\alg}{\textsc{Alg}}

\DeclareMathOperator{\modulo}{mod}

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\Rg}{\mathbf{R}_{\geq0}}
\newcommand{\n}{[n]}
\newcommand{\innerand}{\text{ and }}
\newcommand{\classNP}{\mathsf{NP}}
\newcommand{\classcoNP}{\mathsf{coNP}}
\newcommand{\classPSPACS}{\mathsf{PSPACE}}
\newcommand{\claimqed}{\hfill }


\newcommand{\com}[1]{\marginpar{\scriptsize\raggedright #1}}
\newcommand{\mxx}[1]{\com{{M: #1}}}
\newcommand{\nic}[1]{\com{{N: #1}}}
\newcommand{\yann}[1]{\com{{Y: #1}}}

\renewcommand{\epsilon}{\varepsilon}



\makeatother

\begin{document}

\title{Packing a Knapsack of Unknown Capacity}


\author{Yann Disser\thanks{Supported by the Alexander von Humboldt Foundation.}}
\author{Max Klimm}
\author{Nicole Megow\thanks{Supported by the German Science Foundation (DFG) under contract  ME 3825/1.}}
\author{Sebastian Stiller}

\affil{\small Department of Mathematics, Technische Universit\"at Berlin, Germany.
\\
\texttt{\{disser,klimm,nmegow,stiller\}@math.tu-berlin.de}.}
\maketitle
\begin{abstract}
We study the problem of packing a knapsack without knowing its capacity.
Whenever we attempt to pack an item that does not fit, the item is
discarded; if the item fits, we have to include it in the packing.
We show that there is always a policy that packs a value within factor
2 of the optimum packing, irrespective of the actual capacity. If
all items have unit density, we achieve a factor equal to the golden
ratio . Both factors are shown to be best possible.

In fact, we obtain the above factors using packing policies that are
\emph{universal} in the sense that they fix a particular order of
the items and try to pack the items in this order, independent of
the observations made while packing. We give efficient algorithms
computing these policies. On the other hand, we show that, for any
, the problem of deciding whether a given universal policy
achieves a factor of  is -complete. If 
is part of the input, the same problem is shown to be -complete
for items with unit densities. Finally, we show that it is -hard
to decide, for given , whether a set of items admits a universal
policy with factor , even if all items have unit densities.
\end{abstract}
\smallskip
\section{Introduction}

In the standard knapsack problem we are given a set of items, each
associated with a size and a value, and a capacity of the knapsack.
The goal is to find a subset of the items with maximum value who's
size does not exceed the capacity. In this paper, we study the \emph{oblivious
}knapsack problem where the capacity of the knapsack is not given.
Whenever we try to pack an item, we observe whether or not it fits
the knapsack. If it does, the item is packed into the knapsack and
cannot be removed later. If it does not fit, we discard it and continue
packing with the remaining items. The central question of this paper
is how much we loose by not knowing the capacity, in the worst case.
The oblivious variant of the knapsack problem naturally arises whenever
items are prioritized by a different entity or at a different time
than the actual packing of the knapsack.

A solution to the oblivious knapsack problem is a policy that governs
the order in which we attempt to pack the items, depending only on
the observation which of the previously attempted items did fit into
the knapsack and which did not. In other words, a policy is a binary
decision tree with the item that is tried first at its root. The two
children of the root are the items that are tried next, which of the
two depends on whether or not the first item fits the knapsack, and
so on. We aim for a solution that is good for \emph{every} possible
capacity, compared to the best solution of the standard knapsack problem
for this capacity. Formally, a policy has \emph{robustness factor
 }if, for any capacity, packing according to the policy results
in a value that is at least a -fraction of the optimum
value for this capacity.

We show that the oblivious knapsack problem always admits a robustness
factor of 2. In fact, this robustness factor can be achieved with
a policy that packs the items according to a fixed order, irrespective
of the observations made while packing. Such a policy is called \emph{universal.
}We provide an algorithm that computes a 2-robust, universal policy
in time  for a given set of  items. We complement
this result by showing that no robustness factor better than 2 can
be achieved in general, even by policies that are not universal. In
other words, the cost of not knowing the capacity is exactly 2.

We give a different efficient algorithm for the case that all items
have unit density, i.e., size and value of each item coincide. This
algorithm produces a universal policy with a robustness factor of
at most the golden ratio . Again, we show that
no better robustness factor can be achieved in general, even by policies
that are not universal. 

While good universal policies can be found efficiently, it is intractable
to compute the robustness factor of a \emph{given} universal policy
and it is intractable to compute the best robustness factor an instance
admits. Specifically, we show that, for any\emph{ }fixed\emph{ },
it is -complete to decide whether a given universal policy
is -robust. For unit densities we establish a slightly weaker
hardness result by showing that it is -complete to decide
whether a given universal policy achieves a \emph{given} robustness
factor . Finally, we show that, for given , it is
-hard to decide whether an instance of the oblivious
knapsack problem admits a universal policy with robustness factor
, even when all items have unit density.


\subsection*{Related work}

The knapsack problem has been studied for different models of imperfect
information. In the \emph{stochastic} knapsack problem, sizes and
values of the items are random variables. It is known that a policy
maximizing the expected value is -hard to compute,
see Dean et al.~\cite{deanGV04}. The authors assume that the packing
stops when the first item does not fit the knapsack, and give a universal
policy that approximates the value obtained by an optimal, not necessarily
universal, policy by a factor of~. They also provide a non-universal
policy within a factor of  of the optimal policy. Bhalgat
et al.~\cite{bhalgatGK11} give an algorithm with an improved approximation
guarantee of . They also give a PTAS for the case that
it is allowed to violate the capacity of the knapsack by a factor
of .

In \emph{robust} knapsack problems, a set of possible scenarios for
the sizes and values of the items is given. Yu~\cite{yu96}, Bertsimas
and Sim~\cite{bertsimasS03}, Goetzmann et al.~\cite{GoetzmannST11},
and Monaci and Pferschy~\cite{monaciP11} study the problem of maximizing
the worst-case value of a knapsack under various models. Büsing et
al.~\cite{busingKK11-discrete} and Bouman et al.~\cite{boumanAH11}
study the problem from a computational point of view. Both allow for
an adjustment of the solution after the realization of the scenario.
Similar to our model, Bouman et al.~consider uncertainty in the capacity.

The notion of a \emph{robustness factor} that we adopt in this work
is due to Hassin and Rubinstein~\cite{hassinR02} and is defined
as the worst-case ratio of solution and optimum, over all realizations.
Kakimura et al.~\cite{kakimuraMS11} analyze the complexity of deciding
whether an -robust solution exists for a knapsack instance
with an unknown bound on the number of items that can be packed. Megow
and Mestre~\cite{megowM13} study a variant of the knapsack problem
with unknown capacity closely related to ours. In contrast to our
model, they assume that the packing stops once the first item does
not fit the remaining capacity. In this model, a universal policy
with a constant robustness factor may fail to exist, and, thus, Megow
and Mestre resort to \emph{instance-sensitive} performance guarantees.
They provide a PTAS that constructs a universal policy with robustness
factor arbitrarily close to the best possible robustness factor for
every particular instance.

The concept of \emph{obliviousness }is used in various other contexts
(explicitly or implicitly), such as hashing~(Carter and Wegman~\cite{carterW79}),
caching (Frigo et al.~\cite{frigoLPR99}, Bender et al.~\cite{benderCD02})
routing~(Valiant and Brebner~\cite{valiantB81}, Räcke~\cite{raecke09}),
TSP (Papadimitriou~\cite{papadimitriou94}, Deineko et al.~\cite{deinekoRW95},
Jia et al,~\cite{jiaLNRS05}), Steiner tree and set cover~(Jia et
al,~\cite{jiaLNRS05}), and scheduling~(Epstein et al.~\cite{epsteinLMMMSS12},
Megow and Mestre~\cite{megowM13}). In all of these works, the general
idea is that specific parameters of a problem instance are unknown,
e.g., the cache size or the set of vertices to visit in a TSP tour,
and the goal is to find a \emph{universal solution }that performs
well for all realizations of the hidden parameters.

Universal policies for the oblivious knapsack problem play a role
in the design of public key cryptosystems. One of the first such systems
-- the Merkle–Hellman knapsack cryptosystem \cite{merkleH78} -- is
based on particular instances that allow for a -robust universal
policy for the oblivious knapsack problem. The basic version of this
cryptosystem can be attacked efficiently, e.g.,~by the famous attack
of Shamir~\cite{shamir82}. This attack uses the fact that the underlying
knapsack instance has exponentially increasing item sizes. A better
understanding of universal policies may help to develop knapsack-based
cryptosystems that avoid the weaknesses of Merkle and Hellman's.


\section{Preliminaries}

An instance of the \emph{oblivious knapsack problem} is given by a
set of  items~, where each item 
has a non-negative \emph{value}  and a
strictly positive \emph{size} . For a subset
 of items, we write  and 
to denote its total value and total size, respectively, of the items
in . A \emph{solution} for instance  is a policy
 that governs the order in which the items are considered
for packing into the knapsack. The policy must be independent of the
capacity of the knapsack, but the choice which item to try next may
depend on the observations which items did and which items did not
fit the knapsack so far. Formally, a solution policy is a binary decision
tree that contains every item exactly once along each path from the
root to a leaf. The \emph{packing}  of
 for a fixed capacity  is obtained as follows: We
start with  and check whether the item
 at the root of  fits the knapsack, i.e., whether
. If the item fits, we add  to
 and continue packing recursively with the left
subtree of . Otherwise, we discard  and continue packing recursively
with the right subtree of .

A \emph{universal policy } for instance  is a
policy that does not depend on observations made while packing, i.e.,
the decision tree for a universal policy has a fixed permutation of
the items along every path from the root to a leaf. We identify a
universal policy with this fixed permutation and write .
Analogously to general policies, the packing 
of a universal policy~ for capacity 
is obtained by considering the items in the order given by the permutation~
and adding every item if it does not exceed the remaining capacity. 

We measure the quality of a policy for the oblivious knapsack problem
by comparing its packing with the optimal packing for each capacity.
More precisely, a policy  for instance 
is called~-\emph{robust} \emph{for capacity} , ,
if it holds that~,
where  denotes an optimal packing for
capacity . We say  is -\emph{robust} if
it is -robust for all capacities. In this case, we call~
the \emph{robustness factor} of policy .


\section{Solving the Oblivious Knapsack Problem\label{sec:Algorithm}}

In this section, we describe an efficient algorithm that constructs
a universal policy for a given instance of the oblivious knapsack
problem. The solution produced by our algorithm is guaranteed to pack
at least half the value of the optimal solution for any capacity .
We show that this is the best possible robustness factor. 

The analysis of our algorithm relies on the classical \emph{modified
greedy} algorithm (cf.~\cite{korteV02}). We compare the packing
of our policy, for each capacity, to the packing obtained by the modified
greedy algorithm instead of the actual optimum. As the modified greedy
is a 2-approximation, to show that our policy is 2-robust it is sufficient
to show that its packing is never worse the one obtained by the modified
greedy algorithm. We briefly review the modified greedy algorithm.

\begin{algorithm}[b]   
  \DontPrintSemicolon 
  \KwIn{set of items , capacity }
  \KwOut{subset  such that  and }     
  \caption{\textsc{MGreedy}(, )}\label{alg:mgreedy}     

  \;
  \;   
  , \;   
  \uIf{}   
  {\Return \; }   
  \Else   {\Return \; } 
\end{algorithm}

Let~ denote the \emph{density} of item . The
modified greedy algorithm (\textsc{MGreedy}) for a set of items~
and known knapsack capacity~ first discards all items that are
larger than~ from . The remaining items are sorted
in non-increasing order of their densities, breaking ties arbitrarily.
The algorithm then either takes the longest prefix~ of the resulting
sequence that still fits into capacity~, or the first item~
that does not fit anymore, depending on which of the two has a greater
value. In the latter case, we say that~ is a \emph{swap item}
(for capacity ) that and  is a \emph{swap capacity}. In both
cases, we refer to~ as the \emph{greedy set} for capacity~.
See Algorithm~\ref{alg:mgreedy} for a formal description. 

For our analysis, it is helpful to fix the tie-breaking rule of the
greedy algorithm. To this end, we assume that there is a bijection
, that maps every item  to a \emph{tie-breaking
index} , and that the modified greedy algorithm initially sorts
the items decreasingly with respect to the tuple ,
i.e., the items are sorted non-increasingly by density and whenever
two items have the same density, they are sorted by decreasing tie-breaking
index. In the following, for two items , we write 
if and only if , or  and , and
say that  has higher density than .

We evaluate the quality of our universal policy by comparing it for
every capacity with the solution of \textsc{MGreedy}. This analysis
suffices because of the following well-known property of the modified
greedy algorithm.
\begin{theorem}
[cf.~\cite{korteV02}] For every instance  of the
standard knapsack problem with known capacity, .\label{thm:greedy}

\end{theorem}
We are now ready to describe our algorithm ~(Algorithm~\ref{our_algo})
that produces a universal policy tailored to imitate the behavior
of  without knowing the capacity. 

First,  determines which items are swap items.
It then starts with an empty permutation, and considers the items
in order of non-decreasing sizes, inserting each item into the permutation.
Swap items are always placed in front of all items already in the
permutation, and all other items are inserted in front of the first
item in the permutation that has a lower density.

We prove the following result.

\RestyleAlgo{ruled,vlined} 
\begin{algorithm}[tb]   
  \DontPrintSemicolon 
  \KwIn{set of items } 
  \KwOut{sequence of items }\caption{\textsc{Universal}()\label{our_algo}}
 
  \;
  \;
  
  \For{}   
  {     
    \uIf{ is a swap item}     
    {\;}     
    \Else     
    {       
      \;       
      \While{ {\bf and} }       
      { \; }       
      \;     
    }   
  }
  \Return \; 
\end{algorithm}
\begin{theorem}
The algorithm \noun{Universal} constructs a universal policy of robustness
factor~. \label{thm:2-competitive} 
\end{theorem}
Before we prove this theorem, we first analyze the structure of the
permutation output by  in terms of density, size,
and value. First, we prove that every item following a non-swap item
has lower density.
\begin{lemma}
For a sequence  returned by , we have 
for every non-swap item , . \label{lem:densities} \end{lemma}
\begin{proof}
For , let  be the index of
the iteration in which  inserts  into
. We distinguish two cases.

If , then the item  cannot be a swap item,
since it would appear in front of the item  if it was. As
each non-swap item is inserted into  such that all items left
of it are larger with respect to , the claim follows.

If , since it is not a swap item,  is put
in front of  because it has a higher density.  
\end{proof}
We prove that no item preceding a swap item has smaller size.
\begin{lemma}
For a permutation  returned by , we have
 for every swap item ,
and every other item . \label{lem:sizes} \end{lemma}
\begin{proof}
Since  is a swap item, it stands in front of all items inserted
earlier into . Hence, all items that appear in front of 
in  have been inserted in a later iteration of .
Since  processes items in order of non-decreasing
sizes, we have .  
\end{proof}
We prove that no item preceding a swap item has smaller value.
\begin{lemma}
For a permutation  returned by , we have
 for every swap item ,
and every other item . \label{lem:values} \end{lemma}
\begin{proof}
We distinguish three cases.

\emph{First case:}  is a swap item and .
By Lemma~\ref{lem:sizes}, we have ,
and the claim trivially holds.

\emph{Second case:}  is a swap item and .
Since  is a swap item, there is a capacity 
such that

In particular, for  we obtain



Since, by Lemma~\ref{lem:sizes}, , the
item  is included in the set on the right hand side of~\eqref{eq:rhs}.
We conclude that .

\emph{Third case:}  is not a swap item. Let 
be the first swap item after  in , i.e., 

Note that the minimum is attained as  is a swap item. The
analysis of the first two cases implies that .
By Lemma~\ref{lem:densities} we have ,
and by Lemma~\ref{lem:sizes} we have .
Hence, .  
\end{proof}
Finally, the next lemma gives a legitimation for the violation of
the density order in the output permutation. Essentially, whenever
an item precedes denser items, we guarantee that it is worth at least
as much as all of them combined.
\begin{lemma}
For a permutation  returned by , we have

for every item . \label{lem:order_violation_legitimation} \end{lemma}
\begin{proof}
We distinguish whether  is a swap item, or not.

If  is a swap item, by definition,  is worth more
than the greedy set for some capacity . Thus,

 Since items whose size is strictly larger than  are
inserted into  at a later iteration of ,
they can only end up behind  if they are smaller with respect
to . Hence, 

and thus ,
as claimed.

If, on the other hand,  is not a swap item, let 
be the first swap item after it in . If no such item exists,
the claim holds by Lemma~\ref{lem:densities}, since 

Otherwise, by Lemma~\ref{lem:densities}, we obtain

and hence 

Consequently, and by the argument above for swap items, 

Finally, by Lemma~\ref{lem:values}, we have .
\end{proof}

We now prove Theorem~\ref{thm:2-competitive}.
\begin{proof}
[of Theorem \ref{thm:2-competitive}] We show that for every set of
items , the permutation 
satisfies  for every
capacity . By Theorem~\ref{thm:greedy}, it
suffices to show 
for all capacities. We distinguish between swap capacities and capacities
where  outputs a greedy set.

First, assume that  is a swap capacity, and let 
be the swap item returned by the modified greedy algorithm. Then,
 contains at least one item  with . By
Lemma~\ref{lem:values} we have 



Now assume that  is not a swap capacity. Let 
be the set of items in the greedy set for capacity  that are not
packed by the permutation . Similarly, let .
If , then 
and we are done. Suppose now that . Then, also
. For all items , we have 
and . Since  is not a
swap capacity,  is the greedy set
for capacity , and thus  for
all  and . By definition of  and
since , we also have ,
i.e., the first item  in~ is encountered
before every item from . It follows that 

 Using  and  (Lemma~\ref{lem:order_violation_legitimation})
we get 

\end{proof}
While it is obvious that \noun{Universal} runs in polynomial time,
we show that it can be modified to run in time . 
\begin{theorem}
The algorithm \noun{Universal} can be implemented to run in time .\label{thm:running time
Universal}\end{theorem}
\begin{proof}
We first argue how all swap items can be determined in time .
We use that an item is a swap item if and only if it is worth more
than all smaller items of higher density combined. This is true, because
every item  that is worth more than all smaller items of higher
density is a swap item for capacity . Conversely, a swap item
 for capacity  is worth more than all items of higher
density that are smaller than .

We maintain a balanced search tree for items that is ordered by size
and stores the total value of the items of both subtrees in the corresponding
root. Inserting an item into this tree as well as determining whether
an item is worth more than all smaller items in the tree both takes
time . To determine the set of swap items, we iterate
over all items in order of decreasing densities and insert items one
by one into the search tree. After each insertion, we query whether
the newly inserted item is worth more than all smaller items in the
tree. This is true if and only if the item is worth more than all
smaller items of higher density, i.e., if and only if the item is
a swap item. Including the initial sorting by density, we can determine
all swap items in time .

We construct the output permutation  by iterating over the items
in order of increasing size, as in Algorithm~\ref{our_algo}. We
maintain a list  of balanced search trees, each ordered by density.
Except for the last tree in , every tree contains exactly one
swap item, which is the item of smallest density in the tree. The
density of a tree is the density of this swap item (or 0 if the tree
has no swap item). Each tree stores the items in  to the left
of the corresponding swap item (if it exists) and to the right of
the swap item of the preceding tree in  (if it exists). We start
with a list containing a single tree with no corresponding swap item,
which eventually holds all non-swap items that end up behind the last
swap item in . Whenever we encounter a new swap item, we add
a new tree consisting of only this swap item to the front of .
For each non-swap item, we have to find the correct tree to insert
it into. Once we know the tree, we can determine the position at which
to insert the item into the tree, and thus in , in time 
simply by searching the tree. 

To complete the proof, we need an efficient way to find the correct
tree in  for a non-swap item. For this purpose, we maintain a
sublist  of  that contains only those trees that are needed
for the remainder of the algorithm. Whenever a new swap item 
adds a tree to the front of , we also add the tree to the front
of~. Observe that from this point on no items are inserted into
trees of a higher density than . Hence, before inserting the tree
of  to , we may remove trees of higher density from the front
of~. This guarantees that  remains sorted by density. We
can thus implement  as a balanced search tree order by density.
This way, we can find the correct tree for each non-swap item in time
. Since every tree is removed at most once from ,
the amortized cost for maintaining the sublist is constant for each
swap item.

Since  requires  iterations, the total running
time is .  
\end{proof}
We now give a general lower bound on the robustness factor of any
policy for the oblivious knapsack problem. This shows that 
is best possible.
\begin{theorem}
For every , there are instances of the oblivious knapsack
problem where no policy achieves a robustness factor of .\end{theorem}
\begin{proof}
We give a family of instances, one for each size . We ensure
that for every item  of the instance of size , there is a
capacity , such that packing item  first can only lead to
a solution that is worse than  by a
factor of at least . This completes the proof, as the factor
approaches  for increasing values of .

The instance of size  is given by 
with

 where  denotes the -th Fibonacci number ().

We need to show that, no matter which item is tried first (i.e., no
matter which item is the root of the policy), there is a capacity
for which this choice ruins the solution. Observe that both values
and sizes of the items are strictly increasing. Assume that item 
is packed first. Since the smallest item has size , for
capacity , no additional
item fits the knapsack. However, the unique optimum solution in this
case is . These two
items fit the knapsack, as .
By definition, 

Hence, policies that first pack item  do not achieve a robustness
factor .

Now, assume that one of the two smallest items is packed first. For
capacity , no additional
item fits the knapsack. The unique optimum solution, however, is to
pack item . It remains to compute the ratios 

Hence, policies that first pack item 1 or item 2 do not achieve a
robustness factor .  
\end{proof}

\section{Unit Densities\label{sec:Unit-Densities}}

In this section we restrict ourselves to instances of the oblivious
knapsack problem, where all items have unit density, i.e., 
for all items . For two items  we say that 
is smaller than  and write  if , or 
and , where  is the tiebreaking index introduced in
Section~\ref{sec:Algorithm}. We give an algorithm ~(cf.~Algorithm~\ref{our_algo_ud})
that produces a universal policy tailored to achieve the best possible
robustness factor equal to the golden ratio .
The algorithm considers the items from smallest to largest, and inserts
each item into the output sequence as far to the end as possible,
such that the item is not preceded by other items that are more than
a factor~ smaller. Intuitively, the algorithm tries as
much as possible to keep the resulting order sorted increasingly by
size; only when an item dominates another item by a factor of at least~
the algorithm ensures that it precedes this item in the final sequence.
Note that, even though  is irrational, for rationals 
the condition  can be tested efficiently by testing
the equivalent condition .

\begin{algorithm}[tb]      
  \DontPrintSemicolon    
  \KwIn{set of items }    
  \KwOut{sequence of items }   
  \caption{\textsc{UniversalUD}()\label{our_algo_ud}}        
  \;   
  \;   
  \For{}      
  {                
    \;            
    \While{ {\bf and} }            
    { \; }            
\;        
  }   
  \Return \;  
\end{algorithm}
\begin{theorem}
The algorithm  constructs a universal policy
of robustness factor  when all items have unit density. \end{theorem}
\begin{proof}
Given an instance  of the oblivious knapsack problem with unit
densities and any capacity , we compare the packing
 that results from the solution )
with an optimal packing . We define the set  of items
in  for which at least one smaller item is not in ,
i.e., more precisely, let .

We first consider the case that  and set 
to be the smallest item in  with respect to `'. Consider
the iteration  of  in which  is
inserted into , i.e., . By definition of , there
is an item  with  Let  be the first
such item in . Since , we have .
From  and , it follows that  precedes
 in  (and thus in ). Let  be the item directly
preceding  in . If ,  was compared with
 when it was inserted into , with the result that
 and thus . If
, by definition of , we still have .
Also, either  and thus , or  was
compared with  when it was inserted into  in an earlier
iteration of , with the result that .
Again, .

In both cases it follows from  that ,
and using  we get 



Now, assume that . Intuitively, this means that 
consists of a prefix of  (the smallest items). Let 
be the items in , and let 
be the items in . As  consists
of a prefix of , we have  and thus
. If , the claim trivially holds. Otherwise, since
 is empty, we have . Is suffices to show 
for all . To this end, we consider any fixed .
From 
it follows that

 This implies that  cannot precede all items of 
in , as . Hence, there is an item 
that precedes  in . Since , in the iteration
when  inserted  into ,  was
already present. From the fact that  ended up preceding 
it follows that  was compared with  and thus .
We obtain

{which implies the result.}
\end{proof}
A naïve implementation of \noun{UniversalUD }runs in time .
We improve this running time to . 
\begin{theorem}
The algorithm  can be implemented to run in
time . \label{thm:running time UniversalUD}\end{theorem}
\begin{proof}
To improve the running time from the naïve , we maintain
a balanced search tree  that stores a subset of the items in 
sorted decreasingly by their sizes. Whenever an item gets inserted
to the front of~, and only then, we also insert it into .
This way, the items in  remain sorted by their positions in 
throughout the execution of the algorithm. We need an efficient way
of finding, in each iteration  of ~(Algorithm~\ref{our_algo_ud}),
the first item  in  for which ,
or detecting that no such item exists. We claim that, if such an item
exists, it is stored in  and can thus be found in time .

It suffices to show that for every item  and its predecessor
 in  we have that none of the items that precede  in 
are smaller than . To see this, we argue that none of the items
between  and  in  are smaller than . We can then
repeat the argument for  and its predecessor , etc. For the
sake of contradiction, let  be the first item between  and
 with . None of the items between  and 
are smaller than , hence both  and  are inserted into
 earlier than all of them. Let  be the iteration in which
 is inserted into . Since  is inserted earlier into
, and since  is inserted to the front of , 
is at the front of . This is a contradiction to 
not being in .
\end{proof}
We now establish that  is best possible, even
if we permit non-universal policies.
\begin{theorem}
There are instances of the oblivious knapsack problem where no policy
achieves a robustness factor of , for any ,
even when all items have unit density.\end{theorem}
\begin{proof}
Consider an instance of the oblivious knapsack problem with five items
of unit density and values equal to
,
for sufficiently small . We show that no algorithm
achieves a robustness factor of  for this instance.
To this end we consider an arbitrary algorithm  and
distinguish different cases depending on which item the algorithm
tries to pack first. 
\renewcommand{\theenumi}{(\alph{enumi})}
\renewcommand{\labelenumi}{\theenumi}

\begin{enumerate}
\item If  tries item 1 or item 2 first, it cannot fit any
additional item for a capacity equal to , as even
. For this capacity  is worse
by a factor of  than the
optimum solution, which packs item 5. 

\item If  tries item 3 first, it cannot fit any additional
item for a capacity equal to , as even
. For this capacity  is
worse by a factor of  than
the optimum solution which packs items 1 and~2. 
\item If  tries item 4 first, it cannot fit any additional
item for a capacity equal to ,
as even .
For this capacity  is worse by a factor of

than the optimum solution which packs items 2 and 3. 
\item If  tries item 5 first, it cannot fit any additional
item for a capacity equal to , as even .
For this capacity  is worse by a factor of 
than the optimum solution which packs items 3 and 4.  
\end{enumerate}
\end{proof}


\section{Hardness\label{sec:Hardness}}

Although we can always find a -robust universal policy in polynomial
time, we show in this section that, for any fixed ,
it is intractable to decide whether a given policy is -robust,
even if it is universal. This hardness result also holds for instances
with unit densities when  is part of the input. As the final
-- and arguably the most interesting -- result of this section, we
establish -hardness of the the problem to decide for
a given instance and given , whether the instance admits
a universal policy with robustness factor . All proofs rely
on the hardness of the following version of .
\begin{lemma}
\label{lem:subset_sum}Let  be a set
of positive integer weights and  be a target
sum. The problem of deciding whether there is a subset 
with  is -complete, even when\end{lemma}
\begin{enumerate}
\item  for some integer ,\label{enu:subsetSum1}

\begin{enumerate}
\item all weights are in the interval ,\label{enu:subsetSum2}
\item all weights have a difference of at least 2 to the closest power of
2.\label{enu:subsetSum3}
\end{enumerate}
\end{enumerate}
\begin{proof}
Without Properties~\ref{enu:subsetSum1} to \ref{enu:subsetSum3},
the  problem is well known to be -complete
(e.g., Garey and Johnson~\cite{gareyJ79}). Given an instance 
of this classical problem, we construct an equivalent instance with
Properties~\ref{enu:subsetSum1} to \ref{enu:subsetSum3}. We first
multiply all weights in  as well as the target sum  with 
to obtain an equivalent instance . In the new instance,
all weights are even but not a power of 2, hence they have distance
at least 2 to the closest power of 2. We set , with

and define two new weights

We set  to obtain the final instance .
Properties~\ref{enu:subsetSum1} and \ref{enu:subsetSum2} are satisfied
by construction. Also, any solution to the instance  has
to include both  and , since .
Hence, the instance remains equivalent to the original instance .
Since , and since  is a power of two, the new
items  and  are far enough from the closest power of 2 (which
either is  or ).
\end{proof}
We first show that it is intractable to determine the robustness factor
of a given universal policy.
\begin{theorem}
\label{thm:hardness} For any fixed and polynomially representable
 it is -complete to decide whether a given
universal policy for the oblivious knapsack problem is -robust.\end{theorem}
\begin{proof}
Regarding the membership in , note that if a universal
policy  is not -robust, then there is a capacity 
such that . Thus,  together with
 is a certificate for  not being an -robust
solution. 

For the proof of -hardness, we reduce from the variant
of \textsc{SubsetSum} specified in Lemma~\ref{lem:subset_sum}. An
instance of this problem is given by a set 
of positive integer weights in the range  and a target sum
 for some integer . Let  be polynomially
representable. We may assume without loss of generality that 
as we can ensure this property by multiplying  and all items in
 by a sufficiently large power of 2.

We construct an instance  and a sequence  such that 
is an -robust universal policy for  if and
only if the instance of \textsc{SubsetSum} given by  and 
has no solution. To this end, we introduce for each weight 
an item with value and size equal to . In this way, the optimal
knapsack solution for capacity  is at least  if the instance
of \textsc{SubsetSum} has a solution. Furthermore, we introduce a
set of additional items that make sure that the robustness factor
for all capacities except  is at most  while maintaining
the property that the optimal knapsack solution for capacity 
is strictly less than  if the instance of \textsc{SubsetSum} has
no solution.

We now explain the construction of  and  is detail. Let
, i.e., .
Note that  by our assumptions on  and .
For each weight , we introduce an item  with .
The set of these items is called \emph{regular} and is denoted by
. Furthermore, we introduce a set of auxiliary
items. Let . Then, for each ,
we introduce an auxiliary item  with size 
and value . Denoting the set of auxiliary
items by , we have .
Finally, we introduce a dummy item~ with  and 

The universal policy  is defined as .
The hardness proof relies on the claim that  is a -robust
universal policy for all capacities except , i.e., 



As all item sizes are integer, it suffices to consider integer capacities.
To prove \eqref{eq:except at T}, let us first consider capacities
. Since the density of each item with size not larger
than  is bounded from above by , it is sufficient to show
that . To this end, we show that every capacity
 is packed without a gap by the exponentially
decreasing sequence of items . We prove
this statement by induction over . For~, the statement
is true, since there is only a single item with length , which
packs the capacity  optimally. Now assume that the statement
is true for all  and consider the sequence .
We distinguish two cases. For capacities ,
item~ is packed and, using the induction hypothesis, the
residual capacity 
can be packed without a gap by the remaining sequence .
For capacities , item  is not packed, and, again
using the induction hypothesis, we derive that  can be packed
by . This completes the proof of our claim for
.

Let us now consider our claim for capacities . In this
case,  and we can trivially bound the robustness factor
of  by observing that

 

We proceed to show that  is an -robust universal policy
if and only if the instance of \textsc{SubsetSum} given by  and
 has no solution. Let us first assume that the instance of \textsc{SubsetSum}
has no solution. We prove that  is -robust. For all
capacities except  this is clear from claim~ \eqref{eq:except at T}.
For capacity , we argue as follows: As there is no packing of
 with items of density~1, we bound  from above
by , whereas  packs all auxiliary items.
We get 



Now, assume that the instance of \textsc{SubsetSum} has a solution.
Then,  and thus 

and we conclude that  is not -robust. 
\end{proof}

We give a result similar to Theorem~\ref{thm:hardness} for instances in which each item has unit
density. Note that this time we require  to be part of
the input.

\pagebreak

\begin{theorem}
\label{thm:hardness_unit} It is -complete to decide
whether, for given , a given universal policy for the oblivious
knapsack problem is -robust, even when all items have unit
density.\end{theorem}
\begin{proof}
Membership in  follows from Theorem~\ref{thm:hardness}.
To prove hardness, we again reduce from \textsc{SubsetSum} (Lemma~\ref{lem:subset_sum})
using a similar construction as in the proof of Theorem~\ref{thm:hardness}.
Let the set  of weights and the target sum
 of an instance of \textsc{SubsetSum} be given, with .
We proceed to explain the construction of a universal policy 
for which the decision whether  is -robust is -hard,
for some .

For each weight , we introduce an item  with value
. The set of these items is called \emph{regular} and
is denoted by . Let  and .
For each , we introduce an auxiliary item 
with value . Denoting the set of auxiliary
items by , we have .
We further introduce a set of dummy items ,
where . We set 
for each , and . The
values of the dummy items sum up to .
In total, the sum of the values of all dummy and auxiliary items is

Finally, we define the sequence  as 

i.e.,  first tries to pack the dummy items in decreasing order,
then the auxiliary items in decreasing order, and finally the regular
items in non-increasing order. Let .
We proceed to prove the statement of the theorem by showing that 
is an -robust universal policy if and only if the instance
 of  has no solution. To this end, we
first prove that  is always an -robust universal policy
for all capacities except the \emph{critical} capacities in the interval
. Then, we argue that  is
-robust for the critical capacities if and only if the instance
 of \textsc{SubsetSum} has no solution.

We start by proving that  is within an -fraction
of  for all capacities . Since
the regular items are of integer values and the values of the auxiliary
items each are an -fraction of an integer, only capacities
 for which the ratio  is not smaller than 
can be packed without a gap. Otherwise, the value of an optimal solution
is bounded from above by . For capacities ,
we obtain

The value packed by  is given by

From \eqref{eq:bound_opt-1} and \eqref{eq:bound_us-1} it follows
that 

for all .

We proceed to prove that  is within an -fraction of an optimal
solution for all capacities . We distinguish
two cases for each such capacity .

\emph{First case:} , i.e., all auxiliary
items are packed by . Since, in , the dummy item 
with value  precedes all auxiliary items, and since ,
this case can only occur for capacities

On the other hand, the gap  is at most the gap left
after trying all dummy items and packing all auxiliary items, i.e.,
.
Thus,



\emph{Second case: },
i.e., not all auxiliary items are packed. This implies that the gap
 is at most . We calculate



Next, we consider capacities .
For these capacities, all dummy items and all auxiliary items are
packed by . Using that the gap  is at most ,
we obtain



To finish the proof, let us finally consider the critical capacities
. We proceed to show that 
is within an -fraction of  for all 
if and only if  does not have a solution. Let us first assume
that  does not have a solution. Then, 
and we obtain

for all . If, on the other
hand,  has a solution, then , implying that 


i.e.,  is not an -robust universal policy.
\end{proof}

Finally, we prove that it is hard to decide whether a given instance
admits an -robust universal policy when  is part
of the input.

\pagebreak 
\begin{theorem}
It is -hard to decide whether, for given ,
an instance of the oblivious knapsack problem admits an -robust
universal policy, even when all items have unit density.\end{theorem}
\begin{proof}
We again reduce from \textsc{SubsetSum}. To this end, let 
be an instance of \textsc{SubsetSum}~(Lemma~\ref{lem:subset_sum}),
let  be the set of items constructed from  in the proof
of Theorem~\ref{thm:hardness_unit}, and let .
We proceed to show that  admits an -robust universal
policy if and only if the instance \textsc{ }of \textsc{SubsetSum}
has no solution.

For the case that  has no solution, an -robust universal
policy is constructed in the proof of Theorem~\ref{thm:hardness_unit}.
Thus, it suffices to show that if  has a solution,  does
not admit an -robust universal policy.

First, we claim that any -robust universal policy 
contains the auxiliary items in decreasing order. Otherwise, for the
sake of contradiction, let  be the first auxiliary item in 
that is preceded by a smaller auxiliary item . Consider the capacity
. As all dummy items are larger than , only auxiliary
and regular items can be in . Since  precedes , we
have . 

If\emph{ } contains only auxiliary items, since the sum of
the values of the auxiliary items smaller than  is ,
we can use that  to obtain .
If \emph{} contains a regular item , then ,
and hence the gap  cannot be packed with a value more than
. It follows that .
In either case we have

This is a contradiction to the assumption that  is -robust.
We conclude that the auxiliary items appear in  in decreasing
order.

Second, we claim that if  contains a regular item, then 
is not -robust. By the argument above, we may assume that
the auxiliary items in  are ordered decreasingly. Let  be
the regular item contained in  that appears first in .
Consider the capacity  The auxiliary items
that appear before  in  (if any) are ordered decreasingly.
All of them must be larger than , otherwise, the gap left after
packing them for capacity  would be too small to fit . By
Lemma~\ref{lem:subset_sum}, we have that neither  nor 
are a power of 2, thus  does not contain any of the auxiliary
items preceding . All regular items that appear before  in
 are larger than , since they are not in . Hence,
 does not contain any regular items except . We conclude
that . On the other hand,  is an integer multiple
of  and can be packed without a gap by auxiliary items
only. We obtain

We conclude that if an -robust universal policy  exists,
then  does not contain regular items. It follows that 
and, thus,  Using that the 
instance  has a solution, we obtain


which implies that no -robust universal policy exists.
\end{proof}
\bibliographystyle{abbrv}
\bibliography{univ-knapsack}

\end{document}
