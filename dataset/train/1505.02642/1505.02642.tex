\documentclass{sigplanconf}


\usepackage{latexsym, amssymb, amsmath, amsfonts,amsthm,stmaryrd}
\usepackage{graphicx}
\usepackage{semantic}


\newcommand{\draftnote}[2][{$\mbox{}^\star$}]{#1 \marginpar
{\small
\raggedright
\textsf{\hspace*{-1.6ex}#2} }}



\newcommand{\signedcomment}[3]{\draftnote[$\mbox{}^{\color{#2} \star}$]{{\color{#2} \small [#1] #3}} }


\newcommand{\ds}[1]{\signedcomment{DS}{blue}{#1}} \newcommand{\he}[1]{\signedcomment{HE}{magenta}{#1}}


\newcommand{\fadetext}[1]{{\color{gray}[#1]}}

\newcommand{\protectedTable}{\setName{ProtectedTable}}
\newcommand{\protectedEnvironment}{\setName{ProtectedEnv}}




\newcommand{\mySim}[3] { \relation{#1} \sim \relation{#2} }
\newcommand{\pset}{\mathcal{P}}

\newcommand{\eqdef}{\mathrel{\stackrel{{\scriptscriptstyle\mathrm{def}}}{=}}}

\DeclareMathAlphabet{\mathsc}{OT1}{cmr}{m}{sc}

	

\newcommand{\proofcase}[2][Case]{\noindent  
 \raisebox{2ex}{\mbox{}} \textbf{#1: #2}.~~}

\newcommand{\Implies}{\Longrightarrow}
\newcommand{\isimpliedby}{\Leftarrow}
\newcommand{\Iff}{\Longleftrightarrow}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}

\newcommand{\ForAll}[2]
           {\forall #1 .\,#2}
\newcommand{\Exists}[2]
           {\exists #1 .\,#2}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Real}{\mathbb{R}}

\newcommand{\RangeS}{S}

\newcommand{\Set}[1]{ \{ #1 \} }
\newcommand{\SetDef}[2]{ \{ #1 \; | \; #2 \} }
\newcommand{\Union}{\cup}

\newcommand{\relation}[1]{#1}\newcommand{\set}[1]{#1} 

\newcommand{\opSymbol}[1]{{\mathsf{#1}}} 
\newcommand{\opName}[1]{\opSymbol{#1}}
\newcommand{\setName}[1]{\mathrm{\mathbf{#1}}}
\newcommand{\varName}[1]{\mathit{#1}}


\newcommand{\codomain}{\opName{codomain}} \newcommand{\Probability}[1] {\Pr[#1]} 

\newcommand{\List}[1] {[ #1 ]} 

\newcommand{\upto}{,\!\makebox[1em][c]{.\hfil.\hfil.},} 

\newcommand{\Map}[1]{\List{#1}} \newcommand{\MapDef}[2]{\Map{#1 \; | \; #2}}

\newcommand{\pfn}{\rightharpoonup} 

\newcommand{\munion}{\upr} \newcommand{\upr}{\uplus}


\usepackage{esvect} \newcommand{\vect}[1] {\vv{#1}}





\newcommand{\Intersect}{\mathop{\cap}} 



\newcommand*{\llbrace}{\BeginAccSupp{method=hex,unicode,ActualText=2983}\textnormal{\usefont{OMS}{lmr}{m}{n}\char102}\mathchoice{\mkern-4.05mu}{\mkern-4.05mu}{\mkern-4.3mu}{\mkern-4.8mu}\textnormal{\usefont{OMS}{lmr}{m}{n}\char106}\EndAccSupp{}}
\newcommand*{\rrbrace}{\BeginAccSupp{method=hex,unicode,ActualText=2984}\textnormal{\usefont{OMS}{lmr}{m}{n}\char106}\mathchoice{\mkern-4.05mu}{\mkern-4.05mu}{\mkern-4.3mu}{\mkern-4.8mu}\textnormal{\usefont{OMS}{lmr}{m}{n}\char103}\EndAccSupp{}}

\newsavebox{\lXbrace}
\savebox{\lXbrace}{$\llbrace$}
\newsavebox{\rXbrace}
\savebox{\rXbrace}{$\rrbrace$}

\def\lxbrace{\hstretch{0.6}{\scalerel*{\usebox{\lXbrace}}{\llbrace}}}
\def\rxbrace{\hstretch{0.6}{\scalerel*{\usebox{\rXbrace}}{\rrbrace}}}





\newcommand{\mSet}[1]{\lxbrace #1 \rxbrace}


\newcommand{\mSetBig}[1]{\scalerel{\lxbrace}{ #1 } 
                         \scalerel*{\rxbrace}{ #1 }}
\newcommand{\mSetDef}[2]{\lxbrace #1 \; \vert \; #2\, \rxbrace
}

\makeatletter
\newsavebox{\mystrut}
\newcommand{\mSetDefBig}[3][1.5ex]{
\dimen@ #1
\savebox{\mystrut}{\raisebox{-1\dimen@}{\rule{0pt}{3\dimen@}}}
\scalerel*{\lxbrace}{\usebox{\mystrut}}
  #2 \; \scalerel*{\vert}{\usebox{\mystrut}} \; #3\,
   \scalerel*{\rxbrace}{\usebox{\mystrut}}
}
\makeatother


\newcommand{\upreserving}[2] {\relation{#1} \upr \relation{#2}}

\newcommand{\filter}[2] {\relation{#1} \bullet \set{#2}}

\newcommand{\dom}[1] {\Dom(#1)}
\newcommand{\depRel}[1] {\widetilde{#1}}
\newcommand{\depFunc}[1] {\hat{#1}}

\newcommand{\apply}[2] {#1(#2)} 

\newcommand{\Table} {\setName{Table}}
\newcommand{\Tbl} {\setName{Table}}
\newcommand{\LinTbl}{\setName{ProvTable}}
\newcommand{\Rec} {\setName{Rec}}

\newcommand{\IdTable}{\opName{Id}}
\newcommand{\ConstTable}{\opName{Const}}

\newcommand{\Configuration}[3] {\langle #1, #2, #3 \rangle}
\newcommand{\Conf} {\mathds{C}}
\newcommand{\InitConf} {\setName{Init}}
\newcommand{\Configs} {\setName{Config}} 

\newcommand{\Silent} {\tau}
\newcommand{\Budget} {B}
\newcommand{\Env}[1] {#1}

\newcommand{\Program}[1] {#1}
\newcommand{\AllPrograms} {\mathds{P}}
\newcommand{\AllStates} {\setName{State}}

\newcommand{\noDep} {\bot} \newcommand{\Query}[1] {{Q_{#1}} }
\newcommand{\QueryVec}[1]{\vect{Q}, #1}  

\newcommand{\QUERY}  {Query} 

\newcommand{\QueryAct}{\opName{query}} \newcommand{\QuerySet}{\setName{Query}} 


\newcommand{\RecordSet}{\setName{Record}}
\newcommand{\Record}[1] {#1}
\newcommand{\Length}[1] {|#1|}
\newcommand{\Size}[1] {\opName{size}(#1)}

\newcommand{\DepSubset}[3] { \relation{#1} \rSub{#3} \relation{#2} }
\newcommand{\rSub}[1]{ \mathrel{\overset{#1}{\sqsubset}}}

\newcommand{\Sim}[3] {#1 \rSim{#3} #2}
\newcommand{\rSim}[1]{\mathrel{\overset{#1}{\sim}}}

\newcommand{\Init}[1] {\opName{Init}(\System{#1})}

\newcommand{\Mstep}[2] { \xRightarrow{#1}_{#2} } \newcommand{\Sstep}[2] { \xrightarrow{#1}_{#2} } \newcommand{\Pstep}[1] { \xrightarrow{#1} } 

\newcommand{\EmptyTrace} {[]} 
\newcommand{\EmptySet} {\{\}} 

\renewcommand{\epsilon}{\varepsilon} \newcommand{\Xepsilon} {\mathscr{E}} \newcommand{\Epsilon}{\Xepsilon}
\newcommand{\select}{\opSymbol{select}} 
\newcommand{\System}[1] {#1}
\newcommand{\Id}[2] {#1_{#2}}  

\newcommand{\trace} {t}
\newcommand{\compatible}[2]{#1 \vdash #2}


\newcommand{\Dom}{\opSymbol{dom}}
\newcommand{\Range}{\opSymbol{range}}
\newcommand{\TVar}{\setName{TVar}}
\newcommand{\tvar} {\varName{tv}}
\newcommand{\Expr}{\setName{Expr}}
\newcommand{\Val}{\setName{Val}}
\newcommand{\Input}{\opSymbol{input}}

\newcommand{\AllTables} {\setName{Table}}
\newcommand{\SensitivityFunc} {\opName{stability}}

\newcommand{\ProgAct} {\setName{ProgAct}} \newcommand{\Act} {\setName{Act}}         


\newcommand{\emptyenv}{\emptyset} 

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.25} 

\lstdefinestyle{csharp} {
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\footnotesize\ttfamily},
numberstyle={\tiny},
numbers=left,
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
morecomment = [l]{//},
morecomment = [l]{///},
morecomment = [s]{/*}{*/},
morestring=[b]",
sensitive = true,
morekeywords = {async, await, abstract,
event, new, struct,
as, explicit, null, switch,
base, extern, object, this,
bool, false, operator, throw,
break, finally, out, true,
byte, fixed, override, try,
case, float, params, typeof,
catch, for, private, uint,
char, foreach, protected, ulong,
checked, goto, public, unchecked,
class, if, readonly, unsafe,
const, implicit, ref, ushort,
continue, in, return, using,
decimal, int, sbyte, virtual,
default, interface, sealed, volatile,
delegate, internal, short, void,
do, is, sizeof, while,
double, lock, stackalloc,
else, long, static,
enum, namespace, string }
}






\usepackage[compact
           ]{titlesecMod} \titlespacing{\section}{0pt}{*2}{*1} 



\titleformat{\paragraph}[runin]
   {\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}



\AtBeginDocument{\addtolength\abovedisplayskip{-0.4\baselineskip}\addtolength\belowdisplayskip{-0.4\baselineskip}\addtolength{\textfloatsep}{-4ex}
\addtolength{\intextsep}{-4ex}
\addtolength{\abovecaptionskip}{-2ex}
\addtolength{\belowcaptionskip}{2ex}
}



\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}


 
\begin{document}

\conferenceinfo{POPL'06} {January 11--13, 2006, Charleston, South Carolina, USA.}
\CopyrightYear{2006}
\copyrightdata{1-59593-027-2/06/0001} 

\preprintfooter{DRAFT}


\title{On Flow-Sensitive Security Types}
\authorinfo{Sebastian Hunt}
        {Department of Computing\\ School of Informatics, City University\\ London EC1V OHB, UK}
        {seb\mbox{\rm @}soi.city.ac.uk} \authorinfo{David Sands}
        {Department of Computer Science and Engineering, \\
         Chalmers University of Technology \\
         G\"oteborg, Sweden }
        {dave\mbox{\rm @}chalmers.se}

\maketitle

\begin{abstract}

This article investigates formal properties of a family of
semantically sound flow-sensitive type systems for tracking information flow in simple
While programs. The family is indexed by the choice of flow lattice.

By choosing the flow lattice to be the powerset of program variables,
we obtain a system which, in a very strong sense, subsumes all other
systems in the family (in particular, for each program, it provides
a principal typing from which all others may
be inferred).  This distinguished system is shown to be equivalent
to, though more simply described than, Amtoft and Banerjee's
Hoare-style independence logic (SAS'04).

In general, some lattices are more expressive than others. 
Despite this, we show that no type system in the family can give
better results for a given choice of lattice than the type system
for that lattice itself.

Finally, for any program typeable in one of these systems, we show
how to construct an equivalent program which is typeable in a simple
flow-insensitive system.  We argue that this general approach could
be useful in a proof-carrying-code setting.

\end{abstract}

\category{D.3}{PROGRAMMING LANGUAGES}{}
\category{F.3.1}{LOGICS AND MEANINGS OF PROGRAMS}{Specifying and Verifying and Reasoning about Programs}
\category{F.3.2}{LOGICS AND MEANINGS OF PROGRAMS}{Semantics of Programming Languages}[Program analysis]

\terms
Languages, Security, Theory

\keywords
flow-sensitivity,
information flow,
non-interference,
static analysis,
type systems

\section{Introduction}

This article investigates formal properties of a family of
flow-sensitive type systems for tracking information flow.

The analysis of information flow in programs has received considerable
attention in recent years due to its connection to the problem of
secure information flow \cite{Sabelfeld:Myers:JSAC}. The classic
end-to-end confidentiality policy says that if certain data in a
system is considered secret from the perspective of a certain observer
of the system, then during computation there
should be no information flow from that
data to that observer. Denning and Denning
\cite{Denning:Denning:Certification} pioneered the use of program
analysis to statically determine if the information flow properties of
a program satisfy a certain confidentiality policy. 

Most of the more recent work in this area (see  \cite{Sabelfeld:Myers:JSAC} for an overview)
has
been based upon the use of \emph{security type systems} to formulate
the analysis of secure information flow, and to aid in a rigorous
proof of its correctness.

We will focus, like many works in the area, on systems in which
secrets are stored in variables. Security \emph{levels} are associated
with variables, and this describes the intended secrecy of the
contents.  The simplest instance of the problem involves two security
levels: high ($\diamH$) which denotes secrets, and low ($\diamL$) which denotes
public data.  A partial ordering, $\diamL \sleq \diamH$, denotes that the only
permitted information flow is from $\diamL$ to $\diamH$. The security problem is
to verify that there is no dependency between the initial value of the
high variables (the secret to which the program has access), and the
final value of the low variables (the outputs which are visible to the
public).

With respect to the treatment of variables, one feature of almost all
recent type based systems is that they are \emph{flow-insensitive}.
This means that the order of execution is not taken into account in
the analysis. One simple intuition for the notion of flow-insensitivity
\cite{Nielson+:Program:Analysis} is that an analysis is
flow-insensitive if the results for analysing $C_1\<;>C_2$ are the same as
that for $C_2\<;>C_1$.  In this respect the analysis of
\cite{Volpano:Smith:Irvine:Sound} (which can be viewed as a
reformulation of Denning and Denning's original analysis) is
flow-insensitive. In particular flow-insensitivity of this style of type
system means that if a program is to be typed as ``secure'' then
\emph{every} subprogram must also be typed as ``secure''. So for
example the trivial program $l := h \<;> l := 0$ where $h$ contains a
secret, and the final value of $l$ is low (publicly observable) is
considered insecure because the subprogram $l := h$ is insecure.

More generally, flow-insensitivity uses a single abstraction (in this
case a single security level) to represent each variable in the
program. Flow-sensitivity, on the other hand, increases accuracy by
providing a different abstraction at each program point.

Although there are a number of empirical/experimental analyses of the
relationship between flow-sensitive and flow-insensitive program
analyses (see e.g. \cite{Carini:Hind:Flow}), there has been very little discussion of
this dimension in connection to information flow analysis.

In this article we investigate flow-sensitive typings
for a simple While language.
We present a
family of semantically sound security type systems (parameterised
by the choice of flow lattice) which allow the type of a
variable to ``float'', assigning different security types at
different points in the program (Section~\ref{sect:family}).

Although this type system is extremely simple, it turns up some surprises. 
Our main results are the following:
\begin{itemize}
\item Although we can freely choose an arbitrarily
  complex flow lattice, there is a single ``universal'' lattice, and hence
  a single type system, from which all other typings in all other
  instances can be deduced.
In fact, all possible typings in all possible lattices
  can be obtained from one 
  principal typing in the universal lattice.
  From the principal typing, we can construct both
  the strongest (smallest) output typing for a given input typing,
  and the weakest (largest) input typing for a given output typing.
  The universal lattice is the powerset of program variables. 
\item For the universal lattice, we show that the type system is
  equivalent to Amtoft and Banerjee's 
  Hoare-like logic for program dependence
  \cite{Amtoft:Banerjee:SAS04}, which is expressed in terms of
  input-variable output-variable independence pairs. Because our
  formulation is based on dependence rather than independence, it
  is arguably simpler and admits a more straightforward correctness
  proof, without the need to resort to a non-standard trace semantics.
\item In general, some lattices are more expressive than others.
    For example, in contrast to the two-point lattice $\diamL \sleq \diamH$,
  a single derivation in the type system for the universal lattice
    can identify fine-grained inter-variable dependencies of the form
  ``$x$ may depend on the initial value of $y$ but not on $z$''.
  Despite this variation in expressiveness, we establish in Section \ref{sect:completeness} 
  an ``internal completeness'' result which shows that no type system in the family
  can give better results for a given choice of lattice than the
  type system for that lattice itself.
\item Finally in Section~\ref{sect:transformation} we show that for any program
  typeable in an instance of the flow-sensitive system, we are able to
  construct an equivalent program which is typeable in a simple
  flow-insensitive system. The translation is given by a
  security-type-directed translation, introducing extra variables.
  This general approach could be useful in a proof-carrying-code
  setting where the code consumer can have a simple type system, but
  the code producer is free to work in a more permissive system and
  use the translation to provide more easily checked code.
\end{itemize}

\subsection{Related Work}
A number of authors have presented flow-sensitive information flow
analyses e.g. \cite{Clark+:JCL}.
Those close in style to a type system formulation include Ban\^atre
\emph{et al} \cite{Banatre:Bryce:LeMetayer:ESORICS94}, who present a
system very similar to that of \cite{Amtoft:Banerjee:SAS04}, except
that all indirect flows are handled in a pre-pass. Andrews and Reitman 
describe a similar logic \cite{Andrews:Reitman:Axiomatic} but 
did not consider semantic soundness. 

In the treatment of information flow analysis of low level code (e.g.,
\cite{GenaimS05,Hedin:Sands:Timing}), flow-sensitivity arises as an essential
component to handle single threaded structures such as stacks and
registers, since obviously stacks and registers cannot be assigned a
fixed type throughout program execution.

The transformation we present in Section~\ref{sect:transformation} is 
related to \emph{single static assignment}(SSA)\cite{SSA}, although the perspective is quite different. We discuss this further in Section~\ref{subsec:SSA}


\section{A Family of Type Systems}
\label{sect:family}

We work with a simple While language with the usual semantics.
Program variables are drawn from a finite set $\Var$.
A flow-insensitive type system, such as that in \cite{Volpano:Smith:Irvine:Sound},
has the following form: each variable is assigned a fixed security
level. When assigning an expression to a variable $x := E$, all
variables in $E$ must have an equal or lower security level.  When
assignments take place in loops or conditional branches, to avoid
indirect information flows the level of $x$ must be at least as high
as the level of any variable in the branching expression.

To allow types to be flow-sensitive, we must allow the type of a variable to ``float''. 
For example, taking the two-point flow lattice, 
when assigning an expression to a variable $x := y + x$, 
if $x$ has type $\diamL$ before the assignment and $y$ has type $\diamH$, then 
after the assignment $x$ must be considered to have type $\diamH$. 

The flow-sensitive system we define is 
a family of inference systems, 
one for each choice of flow lattice $\lattice$ (where $\lattice$ may be
any finite lattice).
For a command $C$, judgements have the form
\[
        \judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}
\]
where $p \in \lattice$, and $\Gamma, \Gamma'$ are type environments of type $\Var \rightarrow \lattice$.
The inference rules are shown in Table~\ref{table:version1}.
The idea is that if $\Gamma$ describes the security levels of variables which hold 
before execution of $C$, then $\Gamma'$ will describe the security levels of those variables after execution of $C$.
The type $p$ represents the usual ``program counter'' level and serves to eliminate 
indirect information flows; the derivation rules ensure that only variables which end up
(in $\Gamma'$) with types greater than or equal to $p$ may be changed by $C$.
We write $\judgeL{\lattice}{}{\Gamma}{C}{\Gamma'}$ to mean $\judgeL{\lattice}{\perp_{\lattice}}{\Gamma}{C}{\Gamma'}$.
We drop the $\lattice$ subscript from judgements where the identity of the lattice is clear
from the context or is not relevant to the discussion.

In some of the derivation rules we write $\ejudge{\Gamma}{E}{t}$ to mean that expression $E$ has type
$t$ assuming type environment $\Gamma$.
Throughout this paper the type of an expression is defined simply by
taking the lub of the types of its free variables:
\[
        \ejudge{\Gamma}{E}{t} \mbox{ iff } t = \bigsqcup_{x \in \fv(E)} \Gamma(x).
\]
This is consistent with the typings used in many systems, 
though more sophisticated typing rules for expressions would be possible in principle.
\begin{table}
\begin{center}
\[
\begin{array}{c}
        \inference[Skip]{
        }{
                \judge{p}{\Gamma}{\<skip>}{\Gamma}
        }
\\[4ex]
        \inference[Assign]{
                \ejudge{\Gamma}{E}{t}
        }{
                \judge{p}{\Gamma}{x \<:=> E}{\Gamma[x \mapsto p \sqcup t]}
        }
\\[4ex]
        \inference[Seq]{
                \judge{p}{\Gamma}{C_1}{\Gamma'} &
                \judge{p}{\Gamma'}{C_2}{\Gamma''}
        }{
                \judge{p}{\Gamma}{C_1 \<;> C_2}{\Gamma''}
        }
\\[4ex]
        \inference[If]{
                \ejudge{\Gamma}{E}{t} &
                \judge{p \sqcup t}{\Gamma}{C_i}{\Gamma'} \quad i = 1,2
        }{
                \judge{p}{\Gamma}{\<if>\;E\;C_1\;C_2}{\Gamma'}
        }
\\[4ex]
        \inference[While]{
                \ejudge{\Gamma}{E}{t} &
                \judge{p \sqcup t}{\Gamma}{C}{\Gamma}
        }{
                \judge{p}{\Gamma}{\<while>\;E\;C}{\Gamma}
        }
\\[4ex]
        \inference[Sub]{
                \judge{p_1}{\Gamma_1}{C}{\Gamma'_1}
        }{
                \judge{p_2}{\Gamma_2}{C}{\Gamma'_2}
        } \quad p_2 \sqsubseteq p_1, \Gamma_2 \sqsubseteq \Gamma_1, \Gamma'_1 \sqsubseteq \Gamma'_2
\end{array}
\]
\end{center}
\caption{Flow-Sensitive Type Rules}
\label{table:version1}
\end{table}

\section{Semantic Soundness}\label{sect:semantic-soundness}
The type systems satisfy a straightforward non-interference condition:
only changes to inputs with types $\sqsubseteq t$ should be visible
to outputs with type $t$.
More precisely,
given a derivation $\judge{}{\Gamma}{C}{\Gamma'}$, the final value of a variable $x$ with
final type $t = \Gamma'(x)$, should depend at most on the initial values of
those variables $y$ with initial types $\Gamma(y) \sqsubseteq t$.
Following \cite{Hunt:Sands:PEPM91,Sabelfeld:Sands:HOSC01,Heintze:Riecke:Slam} we formalise this using equivalence relations.
\begin{definition}
        Let $R$ and $S$ be equivalence relations on stores.
        We say that program $C$ maps $R$ into $S$, written $C: R \parper S$, iff,
        for all $\sigma, \rho$,
                if $\config{C}{\sigma} \conv \sigma'$
                and $\config{C}{\rho} \conv \rho'$
                then $\sigma \mathrel{R} \rho \Rightarrow \sigma' \mathrel{S} \rho'$.
\end{definition}
We note that this is a partial correctness condition:
it allows $C$ to terminate on $\sigma$ but diverge on $\rho$, even when $\sigma \mathrel{R} \rho$.
This reflects the fact that the type systems take no
account of the ways in which the values of variables may affect a program's termination behaviour.
Given $\Gamma: \Var \rightarrow \lattice$ and $t \in \lattice$, we write
$\eqGT{\Gamma}{t}$ for the equivalence relation on stores which relates stores which are equal
on all variables having type $\sqsubseteq t$ in environment $\Gamma$, thus: $\sigma \eqGT{\Gamma}{t} \rho$ iff
$\forall{x}. \Gamma(x) \sqsubseteq t \Rightarrow \sigma(x) = \rho(x)$.

The formal statement of correctness for a derivation
$\judge{p}{\Gamma}{C}{\Gamma'}$ has two parts, one asserting a simple safety property relating to $p$
(as described in Section~\ref{sect:family}) and the other asserting the non-interference property.
\begin{definition}
        The semantic security relation
        $\semsecL{\lattice}{p}{\Gamma}{C}{\Gamma'}$ holds iff both the following conditions are satisfied:
        \begin{enumerate}
                \item \label{semsec:safety}
                        For all $\sigma, \sigma', x$, if $\config{C}{\sigma} \conv \sigma'$ and $\Gamma'(x) \not\sqsupseteq p$,
                        then $\sigma'(x) = \sigma(x)$.
                \item \label{semsec:nonint}
                        For all $t \in \lattice$, $C: (\eqGT{\Gamma}{t}) \parper (\eqGT{\Gamma'}{t})$.
        \end{enumerate}
\end{definition}
As with $\vdash_{\lattice}$, we suppress the $\lattice$ subscript where possible.
We write $\semsecL{\lattice}{}{\Gamma}{C}{\Gamma'}$ to mean $\semsecL{\lattice}{\perp_{\lattice}}{\Gamma}{C}{\Gamma'}$
(note that condition \ref{semsec:safety} is vacuous for $p = \perp$).
\begin{theorem}[Semantic Soundness]\label{theorem:semantic-soundness}
        $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'} => \semsecL{\lattice}{p}{\Gamma}{C}{\Gamma'}$.
\end{theorem}
The proof for condition~2 of the semantic security relation
depends on condition~1, but not vice versa.
Proof of condition~1 is by an easy argument that $\Gamma'(x) \not\sqsupseteq p$ implies that
$C$ contains no assignments to $x$.
Proof of condition~2 is by induction on the derivation.

The reverse implication, semantic completeness, does \emph{not} hold, as shown by the following:
\begin{example}
Consider the program $C \eqdef \<if>\;(h \<==> 0)\;(l \<:=> h)\;(l \<:=> 0)$.
This is semantically equivalent
to $l \<:=> 0$ so it is clear that $\semsec{}{\Gamma}{C}{\Gamma}$ holds for arbitrary $\Gamma$.
However, for $\Gamma(h) = \mathsc{h}, \Gamma(l) = \mathsc{l}$, with $\mathsc{l} \sqsubset \mathsc{h}$,
$\notJudge{}{\Gamma}{C}{\Gamma}$, because $\ejudge{\Gamma}{(h \<==> 0)}{\mathsc{h}}$ and
the assignments to $l$ force
$\Gamma'(l) \sqsupseteq \mathsc{h}$.
\end{example}

\section{The Algorithmic Type System}
In this section we introduce a variant of the typing rules in which the 
weakening rule (Sub) is removed
and folded into the If and While rules.
The result is a system which calculates the smallest
$\Gamma'$ such that $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}$.
The Skip, Assign and Seq rules are unchanged.
The replacement If and While rules are shown in Table~\ref{table:version2}.
\begin{table*}
\begin{center}
\[
\begin{array}{c}
        \inference[If]{
                \ejudge{\Gamma}{E}{t} &
                \judgeA{p \sqcup t}{\Gamma}{C_i}{\Gamma'_i} \quad i = 1,2
        }{
                \judgeA{p}{\Gamma}{\<if>\;E\;C_1\;C_2}{\Gamma'}
        } \quad \Gamma' = \Gamma'_1 \lub \Gamma'_2
\\[4ex]
        \inference[While]{
                \ejudge{\Gamma'_i}{E}{t_i} &
                \judgeA{p \sqcup t_i}{\Gamma_i'}{C}{\Gamma''_i} &
                0 \leq i \leq n
        }{
                \judgeA{p}{\Gamma}{\<while>\;E\;C}{\Gamma'_n}
        } \quad \Gamma'_0 = \Gamma, \; \Gamma'_{i+1} = \Gamma''_i \lub \Gamma, \; \Gamma'_{n+1} = \Gamma'_n
\end{array}
\]
\end{center}
\caption{Flow-Sensitive Type Rules: Algorithmic Version}
\label{table:version2}
\end{table*}
The rules are deterministic: given an input type environment
exactly one derivation is possible for any given $C$.
(Well, almost. The While rule allows the chain $\Gamma'_0, \Gamma'_1, \cdots, \Gamma'_n$ to be
extended arbitrarily by appending unnecessary repetitions of the limit. We may assume
that $n$ is chosen minimally.)
\begin{theorem}[Algorithmic Correctness]\label{theorem:algo}
For all $\lattice$ and for all $C$:
\begin{enumerate}

\item\label{theorem:algo:monotone}
For all $p, \Gamma$, there exists a unique $\Gamma'$ such that
$\judgeAL{\lattice}{p}{\Gamma}{C}{\Gamma'}$ and furthermore, the corresponding
function $\spc{\lattice}{C}(p,\Gamma) \mapsto \Gamma'$ is monotone.

\item\label{theorem:algo:complete}
If $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}$ then $\spc{\lattice}{C}(p,\Gamma) \sleq \Gamma'$.

\item\label{theorem:algo:sound}
If $\judgeAL{\lattice}{p}{\Gamma}{C}{\Gamma'}$ then $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}$.

\end{enumerate}
\end{theorem}
\begin{corollary}\label{coroll:algo}
    $\spc{\lattice}{C}(p,\Gamma)$ is the least $\Gamma'$ such that $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}$.
\end{corollary}
\begin{proof}[Proof of Algorithmic Correctness]
Proof of part~\ref{theorem:algo:monotone} of the theorem is by induction on the structure of the command.
The interesting case is $\<while>\;E\;C$.
By induction hypothesis, $\spc{\lattice}{C}$ is well-defined and monotone.
It follows that the sequences $\Gamma, \Gamma'_1,\Gamma'_2,\ldots$
and $\perp, \Gamma''_0, \Gamma''_1,\ldots$ may be constructed
as $\Gamma, F(\Gamma),F^2(\Gamma),\ldots$ and $\perp,G(\perp),G^2(\perp),\ldots$,
with $F$ and $G$ being monotone functions derived from $\spc{\lattice}{C}$; thus these sequences
form the ascending chains shown in Figure~\ref{fig:chain}. The chains have finite height because the
lattices are finite, thus $n$ is guaranteed to exist such that $\Gamma'_{n+1} = \Gamma'_n$
and it is then immediate that $\Gamma'_m = \Gamma'_n$ for all $m > n$. Put more succinctly, the While rule specifies
$\Gamma'_n$ as an iterative construction of the least fixed point of a monotone function on a finite lattice.
\begin{figure}
\begin{center}
    \includegraphics{chain-diagram}
\end{center}
\caption{Construction of a Minimal While Typing}
\label{fig:chain}
\end{figure}

The proofs of parts \ref{theorem:algo:complete} and \ref{theorem:algo:sound} of the theorem are then by straightforward inductions
on the $\judgeL{\lattice}{p}{\Gamma}{C}{\Gamma'}$ derivation and the structure of $C$, respectively.
\end{proof}
In Section~\ref{sect:transformation} we adapt this version of the type system to define a program transformation
which allows the use of conventional fixed-type systems in place of the flow-sensitive ones.



\section{A Limiting Case: Dependency Analysis}
Given the correctness condition, it is clear that the type systems defined above
are calculating dependency relationships between program variables.
Intuitively, we might expect to gain the most precise dependency information by choosing the flow
lattice $\pset(\Var)$, which allows us to consider arbitrary sets of variables (including the singleton sets)
as distinct types.
In Section~\ref{sect:completeness}
we explore in detail this question of precision, with some slightly
surprising results.
Section~\ref{sect:completeness} also
formally establishes the special status of the type system for $\pset(\Var)$;
anticipating this, we introduce some terminology:
\begin{definition}
The \emph{universal lattice} is the flow lattice $\pset(\Var)$ of sets of program variables.
The \emph{universal system} is the corresponding type system.
\end{definition}
In this section we show that the universal system is equivalent to (is, in fact, the De Morgan dual of)
Amtoft and Banerjee's Hoare-style independence logic \cite{Amtoft:Banerjee:SAS04}.

For notational clarity when comparing
the universal system with other choices of $\lattice$, we let $\Delta, \Delta'$ range over type
environments just in the universal system (thus
$\Delta, \Delta': \Var \rightarrow \pset(\Var)$).



\pagebreak
\subsection{Comparison with Amtoft-Banerjee Hoare Logic}
In \cite{Amtoft:Banerjee:SAS04}, Amtoft and Banerjee define a Hoare-style logic for deducing independence relationships
between variables in While programs.
Judgements in the logic have the form
\[
    \judge{G}{T}{C}{T'}
\]
where $G \in \pset(\Var)$ and $T, T' \in \pset(\Var \times \Var)$.
The idea is roughly as follows.
Suppose that $C$ is preceded by some previous computation on the store.
We will refer to the
value of a variable before this preceding computation as its \emph{original} value.
Then a pair
$\ABpair{x}{y}$ in $T'$ represents an assertion that the value of $x$ after $C$ is independent
of the original value of $y$, assuming that all the independence pairs in $T$ are valid
for the preceding computation.
For ease of comparison, rather than sets of independence pairs $T$,
we present the logic in terms of mappings $\nabla, \nabla' : \Var -> \pset(\Var)$
(this depends simply on the set isomorphism $A \times B \cong A -> \pset(B)$).
Thus Amtoft-Banerjee (AB) judgements in our presentation have the form
\[
    \judge{G}{\nabla}{C}{\nabla'}
\]
The AB derivation rules are shown in Table~\ref{table:AB}.
\begin{table*}
\begin{center}
\[
\begin{array}{c}
    \inference[Assign{AB}]{
    }{
        \judge{G}{\nabla}{x \<:=> E}{\nabla'}
    } \quad
        \begin{array}{l}
            \mbox{if } \forall y . \forall w \in \nabla'(y) .\\
            \quad x \neq y => w \in \nabla(y) \\
            \quad x = y => w \not\in G \wedge \forall z \in \fv(E) . w \in \nabla(y)
        \end{array}
\\[4ex]
    \inference[Seq{AB}]{
        \judge{G}{\nabla}{C_1}{\nabla'} &
        \judge{G}{\nabla'}{C_2}{\nabla''}
    }{
        \judge{G}{\nabla}{C_1 \<;> C_2}{\nabla''}
    }
\\[4ex]
    \inference[If{AB}]{
        \judge{G'}{\nabla}{C_i}{\nabla'} \quad i = 1,2
    }{
        \judge{G}{\nabla}{\<if>\;E\;C_1\;C_2}{\nabla'}
    } \quad
        \begin{array}{ll}
            \mbox{if} & G \subseteq G' \\
            \mbox{and} & w \not\in G' => \forall x \in \fv(E) . w \in \nabla(x)
        \end{array}
\\[4ex]
    \inference[While{AB}]{
        \judge{G'}{\nabla}{C}{\nabla}
    }{
        \judge{G}{\nabla}{\<while>\;E\;C}{\nabla}
    } \quad
        \begin{array}{ll}
            \mbox{if} & G \subseteq G' \\
            \mbox{and} & w \not\in G' => \forall x \in \fv(E) . w \in \nabla(x)
        \end{array}
\\[4ex]
    \inference[SubAB]{
        \judge{G_1}{\nabla_1}{C}{\nabla'_1}
    }{
        \judge{G_2}{\nabla_2}{C}{\nabla'_2}
    } \quad
        G_2 \subseteq G_1, \nabla_2 \preceq \nabla_1, \nabla'_1 \preceq \nabla'_2
\end{array}
\]
\end{center}
\caption{Amtoft-Banerjee Hoare Logic}
\label{table:AB}
\end{table*}
The ordering $\preceq$ is pointwise reverse subset inclusion, thus:
\[
    \nabla_1 \preceq \nabla_2 \mbox{ iff } \forall x \in \Var . \nabla_1(x) \supseteq \nabla_2(x)
\]
Note that the ordering used on $G$ is just $\subseteq$, not $\preceq$.

The relationship between the AB logic and the universal system is straightforward:
for each
$\Delta$ there is a corresponding $\nabla$ such that $\nabla(x)$ is the complement of $\Delta(x)$.
Where the universal system derives sets of dependencies, the AB logic
simply derives the complementary set of independencies.
(An AB context set $G$, on the other hand,
corresponds directly to the \emph{same} set $p$ in a $\pset(\Var)$-derivation.)
We use the following notation:
\[
    \begin{array}{lcl}
    \compl{\Delta} & \eqdef & \nabla, \mbox{ where } \nabla(x) = \Var - \Delta(x) \\
    \compl{\nabla} & \eqdef & \Delta, \mbox{ where } \Delta(x) = \Var - \nabla(x)
    \end{array}
\]
Clearly this is an order isomorphism: $\compl{\compl{\Delta}} = \Delta$ and $\Delta_1 \sqsubseteq \Delta_2$ iff
$\compl{\Delta_1} \preceq \compl{\Delta_2}$, etc.
\begin{theorem}
    The AB logic and the universal system are De Morgan duals. That is,
    $\judge{G}{\Delta}{C}{\Delta'}$ is derivable in the universal system iff
    $\judge{G}{\compl{\Delta}}{C}{\compl{\Delta'}}$ is derivable in the AB logic.
\end{theorem}
The proof amounts, essentially, to showing that each AB rule is the dual of the universal system
counterpart.
This is not quite literally true, since the way some AB rules are formulated builds in
the potential for implicit weakening,
which must be made explicit using Sub in the corresponding $\pset(\Var)$-derivation.
For example, consider the second side condition on the rule IfAB.
If we re-state this in its contrapositive form
\[
    (\exists x \in \fv(E). w \not\in \nabla(x)) => w \in G'
\]
it is easily seen that the two side-conditions together amount to
\begin{equation}\label{eqn:weakdual}
    G' \supseteq G \;\cup\! \bigcup_{x \in \fv(E)} \compl{\nabla}(x)
\end{equation}
Note that any subderivation concluding
at a premise to
IfAB with $G'$ strictly greater than required by (\ref{eqn:weakdual}),
can have an instance of SubAB added at the end to make
$G' = G \cup \bigcup_{x \in \fv(E)} \compl{\nabla}(x)$.
With this caveat, the side condition for IfAB is equivalent to
the If premise in the universal system.
Similar observations apply to the side conditions for AssignAB and WhileAB.

\section{Internal Completeness}\label{sect:completeness}
In this section we explore a fundamental relationship between different members of our
family of flow-sensitive type systems.
For simplicity of presentation, we consider only ``top-level'' typing judgements, ie, those
of the form $\judge{}{\Gamma}{C}{\Gamma'}$ (see Section~\ref{sect:principal} for further remarks
on this point).
We start by formalising a key notion: the sense in which one typing
can be viewed as subsuming another
(possibly in a different lattice).
Given $\Gamma, \Gamma' : \Var \rightarrow \lattice$,
we refer to a pair $\typing{\Gamma}{\Gamma'}$ as an $\lattice$-typing.
If $\judge{}{\Gamma}{C}{\Gamma'}$ we say that typing $\typing{\Gamma}{\Gamma'}$ is derivable for $C$.
\begin{definition}
    An $\lattice_1$-typing $\typing{\Gamma_1}{\Gamma'_1}$ is said to subsume
    an $\lattice_2$-typing $\typing{\Gamma_2}{\Gamma'_2}$ iff, for all commands $C$
    \[
        \semsecL{\lattice_1}{}{\Gamma_1}{C}{\Gamma'_1} => \semsecL{\lattice_2}{}{\Gamma_2}{C}{\Gamma'_2}
    \]
\end{definition}
Note that this is a \emph{semantic} notion of subsumption: one typing subsumes another
precisely when the non-interference property specified by the former is stronger - satisfied
by fewer programs - than that specified by the latter.
As we shall see (Theorem~\ref{theorem:internalcompleteness}),
the type systems actually faithfully reflect this semantic relationship.

As defined, subsumption appears difficult to verify, since it quantifies over all possible programs.
In fact, it suffices to compare the order relationships between the two pairs
of type environments:
\begin{theorem}\label{theorem:subsumption}
    $\lattice_1$-typing $\typing{\Gamma_1}{\Gamma'_1}$ subsumes
    $\lattice_2$-typing $\typing{\Gamma_2}{\Gamma'_2}$\; iff, for all $x,y \in \Var$:
    \[
        \Gamma_1(x) \sleq \Gamma'_1(y) => \Gamma_2(x) \sleq \Gamma'_2(y)
    \]
\end{theorem}
\begin{proof}
For the \emph{only if} direction we show the contrapositive.
Assume $\Gamma_1(x) \sleq \Gamma_1'(y)$ and $\Gamma_2(x) \not\sleq \Gamma_2'(y)$.
We must find some command $C$ such that
$\semsecL{\lattice_1}{}{\Gamma_1}{C}{\Gamma'_1}$
but $\not\!\!\!\semsecL{\lattice_2}{}{\Gamma_2}{C}{\Gamma'_2}$.
Let $\{ z_1,\ldots,z_n \} = \Var - \{y\}$ and let $C$ be
the program
\[
        y := x ; z_1 := 0 ; \cdots ; z_n := 0
\]
(the use of $0$ here is arbitrary, any constant will do). It is then easy to verify that
$C: (\eqGT{\Gamma_1}{t}) \parper (\eqGT{\Gamma_1'}{t})$ holds for all $t$ but
$C: (\eqGT{\Gamma_2}{s}) \parper (\eqGT{\Gamma_2'}{s})$ fails for $s = \Gamma_2'(y)$.

For the \emph{if} direction,
Assume
\[
\begin{array}{ll}
        \mathrm{(A1)} & \Gamma_1(x) \sleq \Gamma_1'(y) => \Gamma_2(x) \sleq \Gamma_2'(y) \\
        \mathrm{(A2)} & \semsecL{\lattice_1}{}{\Gamma_1}{C}{\Gamma'_1}
\end{array}
\]
We have to show, for all $s \in \lattice_2$, $C : (\eqGT{\Gamma_2}{s}) => (\eqGT{\Gamma_2'}{s})$.
Suppose $\sigma \eqGT{\Gamma_2}{s} \rho$ and $\config{C}{\sigma} \conv \sigma'$
and
$\config{C}{\rho} \conv \rho'$
and
$\Gamma_2'(y) \sleq s$.
We must show $\sigma'(y) = \rho'(y)$.
Now, for any $x$,
$\Gamma_2(x) \sleq \Gamma_2'(y) => \Gamma_2(x) \sleq s => \sigma(x) = \rho(x)$.
Hence, by (A1),
$\Gamma_1(x) \sleq \Gamma_1'(y) => \sigma(x) = \rho(x)$,
thus $\sigma \eqGT{\Gamma_1}{t} \rho$, where
$t = \Gamma_1'(y)$.
Hence, by (A2),
$\sigma' \eqGT{\Gamma_1'}{t} \rho'$,
hence
$\sigma'(y) = \rho'(y)$ as required.
\end{proof}
This result shows that the semantic content of a judgement
$\judge{}{\Gamma}{C}{\Gamma'}$ is uniquely determined by the set of pairs
$\{ (x,y) | \Gamma(x) \sleq \Gamma'(y) \}$: the smaller this set, the stronger
the non-interference property. In fact, these pairs are precisely the dependencies
allowed by the typing: if $\Gamma(x) \sleq \Gamma'(y)$ then the final value
of $y$ after executing $C$ \emph{may depend on} the initial value of $x$.
Alternatively, we may consider the contrapositive form of
Theorem~\ref{theorem:subsumption}, which says that
$\typing{\Gamma_1}{\Gamma'_1}$ subsumes
$\typing{\Gamma_2}{\Gamma'_2}$\; iff
\[
        \Gamma_2(x) \not\sleq \Gamma'_2(y) => \Gamma_1(x) \not\sleq \Gamma'_1(y)
\]
This allows us to understand a typing in
terms of \emph{independence} relations (as used by Amtoft and Banerjee).
The larger the set $\{ (x,y) | \Gamma(x) \not\sleq \Gamma'(y) \}$, the stronger
the non-interference property: if $\Gamma(x) \not\sleq \Gamma'(y)$ then the final value
of $y$ after executing $C$ \emph{must be independent of} the initial value of $x$.

Now suppose we have an $\lattice_1$-typing which subsumes an $\lattice_2$-typing,
and suppose we find that the $\lattice_2$-typing is \emph{not} derivable for $C$
in the $\lattice_2$-type system. Will it ever be possible to verify the soundness
of the $\lattice_2$-typing for $C$ indirectly, by deriving the subsuming $\lattice_1$-typing
in the $\lattice_1$-system instead?
We might expect this to happen
in the case that $\lattice_1$ has more points, and is therefore able to make more refined
dependency distinctions, than $\lattice_2$.
Consider the examples shown
in Figure~\ref{fig:diamond}, where
$\lattice$ is the four point lattice depicted.
\begin{figure*}
\begin{center}
\begin{minipage}{20mm}
    \includegraphics[width=20mm]{Diamond.eps}
\end{minipage}
$
{}
\qquad
\begin{array}[c]{lccc}
    \vdash_{\pset(\Var)}{} &
        {[x: \Set{x}, y: \Set{y}, z: \Set{z}]} &
        {\<if>\;x\;(y := z)\;(y := 0)} &
        {[x: \Set{x}, y: \Set{x,z}, z: \Set{z}]} \\
{} \\
    \vdash_{\lattice}{} &
        {[x: \diamM, y: \diamL, z: \diamN]} &
        {\<if>\;x\;(y := z)\;(y := 0)} &
        {[x: \diamM, y: \diamH, z: \diamN]}
\end{array}
$
\end{center}
\caption{Example Derivations}
\label{fig:diamond}
\end{figure*}
It can readily be verified that the $\pset(\Var)$-typing
subsumes the $\lattice$-typing and both
judgements are derivable.
However,
the $\lattice$ judgement simply assigns $y$ the most conservative typing in $\lattice$,
whereas
the $\pset(\Var)$ judgement captures the fact
that the final value of $y$ may depend on both $x$ and $z$, but not on the initial value of $y$.
Could it be, that as part of a derivation for some larger program,
this fine-grained derivation for $y$
enables us to derive
a $\pset(\Var)$-typing subsuming an $\lattice$-typing which cannot be derived in the simpler
$\lattice$-system?
Surprisingly, the answer is No, as confirmed by the following theorem.
\begin{theorem}[Internal Completeness]\label{theorem:internalcompleteness}
        If $\lattice_1$-typing $\typing{\Gamma_1}{\Gamma'_1}$ subsumes
        $\lattice_2$-typing $\typing{\Gamma_2}{\Gamma'_2}$
        and $\judgeL{\lattice_1}{}{\Gamma_1}{C}{\Gamma'_1}$, then
    $\judgeL{\lattice_2}{}{\Gamma_2}{C}{\Gamma'_2}$.
\end{theorem}
Before we can prove the theorem, we need to develop some further machinery.
As an additional benefit of this development, we find that,
for each command $C$, there is a principal typing
from which all others can be obtained.

\subsection{Monotone Renaming of Types}
This section establishes a key technical result used in the proof of the Internal Completeness theorem.
Roughly speaking, the result says that we can take any derivation and, by consistently
renaming the security types, obtain a new one. The notion of renaming is very
general and allows us to translate a derivation for one choice
of lattice into a derivation for a different lattice;
we require only that the renaming function be monotone.
Given $\Gamma: \Var -> \lattice_1$ and a renaming
function $f: \lattice_1 -> \lattice_2$, we write $f\st(\Gamma): \Var -> \lattice_2$
for the pointwise extension of $f$ to $\Gamma$, thus
$f\st(\Gamma)(x) \eqdef f(\Gamma(x))$.

\begin{lemma}[Monotone Renaming]
Let $f:\lattice_1 -> \lattice_2$ be monotone.
Then
$\judgeL{\lattice_1}{p}{\Gamma}{C}{\Gamma'}
=>
\judgeL{\lattice_2}{f(p)}{f\st(\Gamma)}{C}{f\st(\Gamma')}$.
\end{lemma}
\begin{proof}
By induction on the height of the $\lattice_1$-derivation.
We present the Assign and While cases by way of illustration.

\proofcase{Assign}
We have an $\lattice_1$- derivation of the form:
\[
    \inference{
        \ejudgeL{\lattice_1}{\Gamma}{E}{t}
    }{
        \judgeL{\lattice_1}{p}{\Gamma}{x \<:=> E}{\Gamma'}
    }
\]
where $\Gamma' = \Gamma[x \mapsto p \lub t]$.
We can construct an $\lattice_2$- derivation:
\[
    \inference{
        \ejudgeL{\lattice_2}{f\st(\Gamma)}{E}{t'}
    }{
        \judgeL{\lattice_2}{f(p)}{f\st(\Gamma)}{x \<:=> E}{f\st(\Gamma)[x \mapsto f(p) \lub t']}
    }
\]
It suffices to show that $f\st(\Gamma)[x \mapsto f(p) \lub t'] \sqsubseteq f\st(\Gamma')$
(since we can then use Sub). By the definitions, $f\st(\Gamma)[x \mapsto f(p) \lub t'](y) = f\st(\Gamma')(y)$ for all
$y \neq x$ and it remains to show $f(p) \lub t' \sqsubseteq f(p \lub t)$.
Now by monotonicity of $f$ we have
\begin{equation}\label{eqn:monotone-typing}
    t' \eqdef \bigsqcup_{y \in \fv(E)} f(\Gamma(y))
        \sleq
    f\left(\bigsqcup_{y \in \fv(E)} \Gamma(y)\right) = f(t)
\end{equation}
Finally, using this and monotonicity of $f$ again, we have
$f(p) \lub t' \sqsubseteq f(p) \lub f(t) \sqsubseteq f(p \lub t)$.

\proofcase{While}
We have an $\lattice_1$- derivation of the form:
\[
    \inference{
        \ejudgeL{\lattice_1}{\Gamma}{E}{t} &
        \judgeL{\lattice_1}{p \lub t}{\Gamma}{C}{\Gamma}
    }{
        \judgeL{\lattice_1}{p}{\Gamma}{\<while>\;E\;C}{\Gamma}
    }
\]
By induction hypothesis we have $\judgeL{\lattice_2}{f(p \lub t)}{f\st(\Gamma)}{C}{f\st(\Gamma)}$.
As in the Assign case, we have $\ejudgeL{\lattice_2}{f\st(\Gamma)}{E}{t'}$
and $f(p) \lub t' \sqsubseteq f(p \lub t)$, allowing us to construct:
\[
    \inference{
        \ejudgeL{\lattice_2}{f\st(\Gamma)}{E}{t'} &
        \inference[Sub]{
            \judgeL{\lattice_2}{f(p \lub t)}{f\st(\Gamma)}{C}{f\st(\Gamma)}
        }{
            \judgeL{\lattice_2}{f(p) \lub t'}{f\st(\Gamma)}{C}{f\st(\Gamma)}
        }
    }{
        \judgeL{\lattice_2}{f(p)}{f\st(\Gamma)}{\<while>\;E\;C}{f\st(\Gamma)}
    }
\]

\end{proof}

\subsection{Canonical Derivations}
Given the Monotone Renaming lemma, we might hope to prove the
Internal Completeness theorem by a construction for a suitable
monotone renaming function to translate the $\lattice_1$-derivation
into an $\lattice_2$-derivation for the subsumed typing. However,
since an appropriate construction is not immediately obvious\footnote{Though we can read it off easily enough once we have the proof. It is:
$f(s) = \bigsqcup\{\Gamma_2(x) | \Gamma_1(x) \sleq s\}$.}, we go via an indirect route.
We begin our detour by showing how to produce any given derivation
$\judgeL{\lattice}{}{\Gamma}{C}{\Gamma'}$
from a particular form of 
derivation in the universal system. To do this
we construct, for each choice of $\Gamma$, an \emph{abstract interpretation} 
 \cite{Cousot:Cousot:Abstract:Interpretation} which is given by 
a \emph{pair} of monotone renaming maps:
\begin{definition}
Given $\Gamma: \Var \rightarrow \lattice$, we define the maps
$\alpha_\Gamma : \pset(\Var) \rightarrow \lattice$
and
$\gamma_\Gamma : \lattice \rightarrow \pset(\Var)$
by:
\begin{eqnarray}
        \alpha_\Gamma(X) & \eqdef & \bigsqcup_{x \in X} \Gamma(x) \\
        \gamma_\Gamma(t) & \eqdef & \{ x \;|\; \Gamma(x) \sqsubseteq t \}
\end{eqnarray}
\end{definition}
These maps enjoy a special status.
Recall \cite{davey90introduction}
that a Galois Connection (GC) between $\lattice_1$ and $\lattice_2$
is a pair of maps $\vect{\alpha,\gamma}$ with
$\alpha: \lattice_1 \rightarrow \lattice_2$,
$\gamma: \lattice_2 \rightarrow \lattice_1$ and such that
$\alpha(s) \sqsubseteq t \iff s \sqsubseteq \gamma(t)$.
Key properties of a GC are that $\alpha, \gamma$ are both monotone,
$\alpha \circ \gamma \sleq \mathrm{id}$,
$\gamma \circ \alpha \sgeq \mathrm{id}$,
$\alpha$ preserves joins and $\gamma$ preserves meets.
Furthermore, the two component maps uniquely determine each other, thus:
\begin{eqnarray}
        \alpha(s) & = & \bigsqcap \{ t \;|\; s \sqsubseteq \gamma(t) \}
            \label{eqn:alpha} \\
        \gamma(t) & = & \bigsqcup \{ s \;|\; \alpha(s) \sqsubseteq t \}
            \label{eqn:gamma}
\end{eqnarray}
\begin{lemma}
        For any $\Gamma: \Var \rightarrow \lattice$, the pair
        $\vect{\alpha_\Gamma,\gamma_\Gamma}$ is a Galois Connection between $\pset(\Var)$ and $\lattice$.
\end{lemma}
Our first use of these renaming functions is, given
an $\lattice$-typing $\typing{\Gamma}{\Gamma'}$, to construct a 
typing in the universal system
which subsumes it.
A central r\^{o}le is played by the particular $\pset(\Var)$ type environment
which maps each $x$ to the singleton $\Set{x}$.
We denote this environment by $\Delta_0$.
Thus, for all
$x \in \Var$,
\(
        \Delta_0(x) \eqdef \Set{x}
\).
\begin{lemma}\label{lemma:shift}
    $\typing{\Delta_0}{\gamma\st_\Gamma(\Gamma')}$
    subsumes 
    $\typing{\Gamma}{\Gamma'}$.
\end{lemma}
\begin{proof}
    Assume $\Delta_0(x) \subseteq \gamma_\Gamma(\Gamma'(y))$.
    We must show that $\Gamma(x) \sleq \Gamma'(y)$.
    Since $\Delta_0(x) = \Set{x}$, the assumption
    is just $x \in \gamma_\Gamma(\Gamma'(y))$,
    hence $\Gamma(x) \sleq \Gamma'(y)$ by definition of $\gamma_\Gamma$.
\end{proof}
It turns out that the two related typings stand or fall together: for any $C$, the
one is derivable if and only if the other is.
\begin{lemma}[Canonical Derivations]\label{lemma:canonical}
\mbox{} \\
$
\judgeL{\lattice}{}{\Gamma}{C}{\Gamma'}
<=>
\judge{}{\Delta_0}{C}{\gamma\st_\Gamma(\Gamma')}
$
\end{lemma}
\begin{proof}
The proof makes essential use of the Monotone Renaming lemma.
For the $=>$ direction, Monotone Renaming gives
$\judge{}{\gamma\st_\Gamma(\Gamma)}{C}{\gamma\st_\Gamma(\Gamma')}$.
It then suffices to show that $\Delta_0 \subseteq \gamma\st_\Gamma(\Gamma)$,
since appending a single use of Sub then gives the required derivation.
To show $\Delta_0 \subseteq \gamma\st_\Gamma(\Gamma)$ we must show
$x \in \gamma_\Gamma(\Gamma(x))$ for all $x$, and this is
just $\Gamma(x) \sleq \Gamma(x)$.

For the $<=$ direction, Monotone Renaming gives
$\judge{}{\alphaG\st(\Delta_0)}{C}{\alphaG\st(\gammaG\st(\Gamma'))}$.
Now, by (\ref{eqn:alpha}),
$
\alphaG(\Set{x}))
= \bigsqcap\SetDef{t}{x \in \gammaG(t)}
= \bigsqcap\SetDef{t}{\Gamma(x) \sleq t}
= \Gamma(x)
$,
thus
$\alphaG\st(\Delta_0) = \Gamma$.
By standard properties of a GC, $\alphaG\st(\gammaG\st(\Gamma')) \sleq \Gamma'$.
Thus the required derivation follows by appending a single use of Sub.
\end{proof}

Now we can prove the theorem stated at the start of Section~\ref{sect:completeness}.
\begin{proof}[Proof of Internal Completeness]
Assume 
$\lattice_1$-typing $\typing{\Gamma_1}{\Gamma'_1}$ subsumes
$\lattice_2$-typing $\typing{\Gamma_2}{\Gamma'_2}$ and
$\judgeL{\lattice_1}{}{\Gamma_1}{C}{\Gamma'_1}$.
We must show $\judgeL{\lattice_2}{}{\Gamma_2}{C}{\Gamma'_2}$ which,
by the Canonical Derivations lemma, is equivalent to
\begin{equation}\label{eqn:complete-end}
    \judge{}{\Delta_0}{C}{\gamma_{\Gamma_2}\st(\Gamma'_2)}
\end{equation}
Furthermore, again by the Canonical Derivations lemma, the existence
of our assumed derivation is equivalent to
\begin{equation}\label{eqn:complete-start}
    \judge{}{\Delta_0}{C}{\gamma_{\Gamma_1}\st(\Gamma'_1)}
\end{equation}
It thus suffices to show
\begin{equation}\label{eqn:complete-middle}
    \gamma_{\Gamma_1}\st(\Gamma'_1) \sleq \gamma_{\Gamma_2}\st(\Gamma'_2)
\end{equation}
and append a single use of Sub to derive (\ref{eqn:complete-end}) from (\ref{eqn:complete-start}).
To show (\ref{eqn:complete-middle}) we must show
$\Gamma_1(y) \sleq \Gamma'_1(x) => \Gamma_2(y) \sleq \Gamma'_2(x)$,
and this is just the assumed type subsumption, so we are done.
\end{proof}
As we noted above, the use of Galois Connections above
is a form of abstract interpretation, and is reminiscent 
of the study of \emph{complete} abstract interpretations
\cite{CousotCousot79-1,GiacobazziRanzatoScozzari}.
We have not explored these connections deeply, but a key difference
would appear to be in our use of a different GC for each choice of
$\Gamma$, rather than a single GC relating all
$\lattice$-derivations to counterpart
derivations in the universal system.

\subsection{Principal Typings}\label{sect:principal}
As an additional corollary of the Canonical Derivations lemma, we find that, for each
command $C$, there is a typing derivable for
$C$ from which all others can be inferred, namely
\[
    \judge{}{\Delta_0}{C}{\Delta_C}
\]
where $\Delta_C$ is the smallest $\Delta'$ such that $\judge{}{\Delta_0}{C}{\Delta'}$
(recall that, by Corollary~\ref{coroll:algo}, this exists and is given by
$\spc{\pset(\Var)}{C}(\emptyset,\Delta_0)$).
The Canonical Derivations lemma shows that
derivability of any given
$\judgeL{\lattice}{}{\Gamma}{C}{\Gamma'}$ is equivalent
to $\forall x . \Delta_C(x) \subseteq \gammaG\st(\Gamma'(x))$, which unpacks to:
\begin{equation}
    y \in \Delta_C(x) => \Gamma(y) \sleq \Gamma'(x)
\end{equation}
In fact, we can show that $\typing{\Delta_0}{\Delta_C}$ is a \emph{principal} typing
for $C$, in the sense defined by Wells \cite{Wells:ICALP-2002}.
Transposed to our setting\footnote{For this purpose, we view our family as a single type system consisting of the disjoint
union of all its members.},
Wells makes the following definitions:
\begin{itemize}
\item A pre-order on typings: $\typingN{1} \leq \typingN{2}$ iff $\forall C . \judgeN{1} => \judgeN{2}$.
\item Principal typings: typing $\typingN{1}$ is \emph{principal for} $C$ iff $\judgeN{1}$, and
$\judgeN{2} => \typingN{1} \leq \typingN{2}$.
\end{itemize}
\begin{theorem}[Principal Typing]
$\typing{\Delta_0}{\Delta_C}$ is principal for $C$.
\end{theorem}
Before proving the theorem we state an easy lemma about subsumption:
\begin{lemma}\label{lemma:monotonesubsumption}
If $\typingN{1}$ subsumes $\typingN{2}$ and $\Gamma' \sleq \Gamma_1'$, then
$\typing{\Gamma_1}{\Gamma'}$ subsumes $\typingN{2}$.
\end{lemma}
\begin{proof}[Proof of Principal Typing]
By definition of $\Delta_C$, $\judge{}{\Delta_0}{C}{\Delta_C}$. Suppose
$\judge{}{\Gamma}{C}{\Gamma'}$.
We must show, for all $C'$, $\judge{}{\Delta_0}{C'}{\Delta_C} => \judge{}{\Gamma}{C'}{\Gamma'}$.
So suppose $\judge{}{\Delta_0}{C'}{\Delta_C}$. By Internal Completeness, it suffices to show
that $\typing{\Delta_0}{\Delta_C}$ subsumes $\typing{\Gamma}{\Gamma'}$.
By Lemma~\ref{lemma:shift},
$\typing{\Delta_0}{\gamma\st_\Gamma(\Gamma')}$
subsumes
$\typing{\Gamma}{\Gamma'}$ so, by Lemma~\ref{lemma:monotonesubsumption},
it suffices to show $\Delta_C \sleq \gamma\st_\Gamma(\Gamma')$.
By the Canonical Derivations lemma (using $\judge{}{\Gamma}{C}{\Gamma'}$),
$\judge{}{\Delta_0}{C}{\gamma\st_\Gamma(\Gamma')}$, so by definition of $\Delta_C$,
$\Delta_C \sleq \gamma\st_\Gamma(\Gamma')$.
\end{proof}

As noted earlier, we have restricted attention to typing judgements
$\judge{p}{\Gamma}{C}{\Gamma'}$ with $p = \perp$. While this is appropriate
when we wish to consider whole programs, it does not allow us to apply
our principal typings result compositionally. We believe the results above
extend straightforwardly to the general case, the key step being to
adjoin a ``program counter variable'' to $\Var$, so the universal lattice
becomes $\pset(\Var + \{ \mathrm{pc} \})$.

\subsubsection{Polymorphism}\label{sect:polymorphism}
The principal typing result above suggests that we should be able to view
typings in the universal system as polymorphic, in some sense.
In fact, this can be done quite directly:
we may take an isomorphic view of $\pset(\Var)$
which shows typings in the universal system to be polymorphic in the standard
sense of types involving type variables.
Assume given a set of type variables $\TVar \cong \Var$, ranged over by $\beta$.
Assume also some particular 1-1 mapping between the two sets: we write
$\beta_x$ for the type variable associated to program variable $x$.
In this view, $\Delta_0$ is a type environment which assigns a unique polymorphic
variable $\beta_x$ to each $x$.
The application of $\alpha_\Gamma$ to $\Delta_0$ in the proof
($<=$) of the Canonical Derivations lemma amounts to an
instantiation of the type variables to produce $\Gamma$.
In general, $\alpha_\Gamma$ interprets a set $T$ of type
variables as the lub of the interpretations of its elements.
Thus, in this view, types in the $\pset(\TVar)$ lattice can be thought
of as formal lubs, which can be interpreted as elements in any lattice
$\lattice$ by fixing an interpretation $I$ for each $\beta$.

As above, let
$\Delta_C$ be the smallest $\Delta'$ such that $\judge{}{\Delta_0}{C}{\Delta'}$.
It can be shown that fixing $\Gamma$ and calculating
$\alpha_\Gamma\st(\Delta_C)$ gives us
$\spc{\lattice}{C}(\perp,\Gamma)$, ie
the smallest
$\Gamma'$ such that $\judge{}{\Gamma}{C}{\Gamma'}$.
More interestingly, $\Delta_C$ may also be used
in the reverse direction,
to calculate the greatest $\Gamma$ such that $\judge{}{\Gamma}{C}{\Gamma'}$
for a given $\Gamma'$.
The idea is to construct an interpretation
$I:\TVar -> \lattice$
which ``unifies'' $\Delta_C$ and $\Gamma'$, in the sense that
\begin{equation}
    \alpha_I(\Delta_C(x)) \sleq \Gamma'(x)
\end{equation}
for all $x$, where $\alpha_I(T) \eqdef \bigsqcup_{\beta \in T}I(\beta)$.
The greatest $I$ satisfying this equation for all $x$ is given by
\begin{equation}\label{eqn:greatest}
    I(\beta) \eqdef \bigsqcap \SetDef{\Gamma'(x)}{\beta \in \Delta_C(x)}
\end{equation}
The hope is that taking $\Gamma(x) \eqdef I(\beta_x)$ should then
give us the greatest $\Gamma$ such that $\judge{}{\Gamma}{C}{\Gamma'}$.
This is borne out by the following:
\begin{proposition}
Given $\Gamma': \Var -> \lattice$,
let $I$ be defined as in (\ref{eqn:greatest}).
Then $\Gamma(x) \eqdef I(\beta_x)$ is the greatest $\Gamma$ such that $\judge{}{\Gamma}{C}{\Gamma'}$.
\end{proposition}
\begin{proof}
By the Canonical Derivations lemma, it suffices to show that the $\Gamma$
defined is the greatest such that
\begin{equation}\label{eqn:greatballsoffire}
    \judge{}{\Delta_0}{C}{\gammaG\st(\Gamma')}
\end{equation}
Firstly, we show that (\ref{eqn:greatballsoffire}) holds by showing that
$\gammaG(\Gamma'(x)) \supseteq \Delta_C(x)$ for all $x$.
Suppose $\beta_y \in \Delta_C(x)$, then we must show that
$\Gamma(y) = I(\beta_y) \sleq \Gamma'(x)$. This holds because
$\beta_y \in \Delta_C(x)$ implies $\Gamma'(x)$ belongs to the set
over which the meet is taken in (\ref{eqn:greatest}).

It remains to show
that $\gamma\st_{\Gamma''}(\Gamma') \sgeq \Delta_C => \Gamma'' \sleq \Gamma$.
We show the contrapositive,
so suppose $\Gamma'' \not\sleq \Gamma $. Thus, by (\ref{eqn:greatest}),
for some $z$, $\beta_x \in \Delta_C(z)$ and $\Gamma''(x) \not\sleq \Gamma'(z)$,
thus $\beta_x \in \Delta_C(z)$ but $\beta_x \not\in \gamma_{\Gamma''}(\Gamma'(z))$.
\end{proof}

\section{Transformation to Fixed-Types}
\label{sect:transformation}
We have seen that floating types enable more programs to be typed than
a standard fixed-type approach.  In this section we show that if
a program is typeable in the floating type system, then there is an
equivalent program which is typeable in a traditional fixed-type system. We
show this by construction: we extend the type system so that it also
\emph{generates} such a program. 
Take as an example the following valid judgement for the flow lattice $\diamL\sqsubseteq \diamH$, and the type environment 
$\Gamma = [\, l : \diamL, h : \diamH]$:
\[
\judge{\diamL}{\Gamma}{l \<:=> h ; l \<:=> 0 ; h \<:=> 0 ; l \<:=> h}{\Gamma}
\]
A traditional security type system would not be able to handle this
example because the level of $l$ becomes temporarily high, and then
the level of $h$ becomes low.  To systematically transform the program to
make it typeable by a fixed-type system, we represent
each variable by a family of variables, one for each element of the
flow lattice. The idea is that at any point in the computation we will
be working with one particular member of the family.  Whenever we need
to raise the type of a variable from $s$ to $t$ in the original program
we represent
this in the transformed program by performing an assignment to \emph{move} 
information from $x_s$ to $x_t$, and by
henceforth working with $x_t$.

Using this idea, the above program can be represented by the following:
\[
 l_\diamH \<:=> h_\diamH ; l_\diamL \<:=> 0; h_\diamL \<:=> 0 ; l_\diamL \<:=> h_\diamL
\]
where $h_\diamH$ and $h_\diamL$, for example, are distinct variables. 
The initial inputs $l$ and $h$ are here represented by $l_\diamL$ and $h_\diamH$ respectively. 
In a flow-insensitive security type system the program is deemed secure because
$l_\diamL$ (and $h_\diamL$) only ever contain ``low'' information. 


\subsection{Fixed Variables}
To discuss fixed types more precisely it is convenient to 
introduce a new class of such type-indexed 
variables into the language: 
\begin{definition}
  For any given lattice of types $\lattice$, define the set of
  \emph{fixed variables}, $\FVar$,  to be the set of type-indexed variables 
\[ \FVar \eqdef \{ x_t \;|\; x \in \Var, t \in \lattice.\} \]
  To distinguish the
  fixed variables from the ``ordinary'' variables we will henceforth
  refer to the variables in $\Var$ as \emph{floating variables}.
\end{definition}
So, for example, if we are working in the two-level flow lattice,
then for each floating variable $x$, we have in addition two fixed
variables $x_\diamL$ and $x_\diamH$.

We will now extend the language with fixed-type variables.
Their dynamic semantics is just as for floating variables.
We are going to present a transformation by adapting the algorithmic
version of the type system, but first we must
extend it to cover fixed-type variables:
we extend the rule for expressions
and add a rule for fixed-type assignment.  We do not extend
the type environments to cover fixed variables since their type is
given by their index.

Let $\fv(E)$ denote the free floating variables (as before), and 
define $\ffv(E)$ to denote the free fixed variables of expression $E$ (and similarly for commands). 
Then the typing of expressions in the extended language is given by 
\[
        \ejudge{\Gamma}{E}{t} \mbox{ iff } t = \bigsqcup_{x \in \fv(E)} \Gamma(x) \; \; \lub \bigsqcup_{x_t \in \ffv(E)} t
\]
The fixed type rule is simply:
\[ 
\inference[Fixed-Assign]{
                \ejudge{\Gamma}{E}{s} & s \sqsubseteq t, \; p \sqsubseteq t
        }{
                \judgeA{p}{\Gamma}{x_t \<:=> E}{\Gamma}
        }
\]
It is straightforward to extend the soundness arguments to encompass fixed variables.

Note that if we restrict our attention to programs with no free
floating variables ($\fv(C) = \emptyset$), then type environments are
redundant. We will use metavariable $D$ to range over commands with no free floating variables. 
We will write $\fjudge{p}{D}$ to denote
$\judgeA{p}{\Gamma}{D}{\Gamma}$ for arbitrary $\Gamma$.
It should be straightforward to
see that derivations of this form correspond exactly to derivations in
e.g. Volpano, Smith and Irvine's system \cite{Volpano:Smith:Irvine:Sound}, and other
Denning-style analyses, although we will not prove this formally.

\subsection{Translation}
Now we present the translation as an extension of the type system (algorithmic version) 
to judgements of the form
\[
  \judgeL{\lattice}{p}{\Gamma}{C ~> D}{\Gamma'}
\]
(we do not decorate $\vdash$ for this system since the form of the judgements
readily distinguish them from the previously defined systems).
First we need some basic constructions and notations. 
\begin{definition}\label{def:fassign}
\mbox{}\begin{enumerate}
\item 
For any type environments $\Gamma$ and $\Gamma'$,
let $\fassign{\Gamma}{\Gamma'}$ denote the set
\[
\{
   x_s \<:=> x_t \;|\; \Gamma(x) = s, \Gamma'(x) = t, s \neq t
\}
\]
\item 
Let $S$ be a set of variable to variable assignment statements.
We say that $S$ is \emph{independent} if for any distinct pair 
$w := x$ and $y := z$ in $S$,
the variables
$w$, $x$, $y$ and $z$ are all distinct.
For independent $S$, all sequentialisations
are semantically equivalent and we
let $S$ represent the command obtained by 
some canonical (but unspecified) sequentialisation.
\end{enumerate}
\end{definition}
\begin{lemma} 
$\fassign{\Gamma}{\Gamma'}$ is an independent set of assignments
\end{lemma}
Thus we will write $\fassign{\Gamma}{\Gamma'}$ to denote the command obtained by some canonical sequentialisation of the assignments.

\begin{definition}
For any type environment $\Gamma$,
let $E^\Gamma$ denote the expression obtained by replacing each floating variable $x$ in  $E$ with the fixed variable $x_s$ where $s = \Gamma(x)$.
\end{definition}

With these definitions we are ready to introduce the translation. 
The rules are presented in Table~\ref{table:translation}.
\begin{table*}
\begin{center}
\[
\begin{array}{c}
        \inference[Skip-t]{
        }{
                \judge{p}{\Gamma}{\<skip>  ~>  \<skip>}{\Gamma}
        }
\\[4ex]
        \inference[Assign-t]{
                \ejudge{\Gamma}{E}{t} \quad s =  p \lub t  
        }{
                \judge{p}{\Gamma}{x \<:=> E  ~>  x_{s} \<:=> E^\Gamma}{\Gamma[x \mapsto s]}
        }
\\[4ex]
        \inference[Seq-t]{
                \judge{p}{\Gamma}{C_1 ~> D_1}{\Gamma'} &
                \judge{p}{\Gamma'}{C_2 ~> D_2}{\Gamma''}
        }{
                \judge{p}{\Gamma}{C_1 \<;> C_2 ~> D_1 \<;> D_2}{\Gamma''}
        }
\\[4ex]
        \inference[If-t]{
                \ejudge{\Gamma}{E}{t} &
                \judge{p \sqcup t}{\Gamma}{C_i ~> D_i}{\Gamma'_i} \quad i = 1,2
        }{
                \judge{p}{\Gamma}{\<if>\;E\;C_1\;C_2
~> \<if>\;E^\Gamma \;(D_1\<;>\fassign{\Gamma'}{\Gamma_1})\;
                     (D_2\<;>\fassign{\Gamma'}{\Gamma_2})
}{\Gamma'}
        } \quad \Gamma' = \Gamma'_1 \lub \Gamma'_2
\\[4ex]
        \inference[While-t]{
                \ejudge{\Gamma'_i}{E}{t_i} &
                \judge{p \sqcup t_i}{\Gamma_i'}{C ~> D_i}{\Gamma''_i} &
                0 \leq i \leq n
        }{
                \judge{p}{\Gamma}{\<while>\;E\;C
~> \fassign{\Gamma'_n}{\Gamma}\<;>\<while>\;E^{\Gamma'_n}\; (D_n\<;>\fassign{\Gamma'_n}{\Gamma''_n})
}{\Gamma'_n}
        } \quad \Gamma'_0 = \Gamma, \; \Gamma'_{i+1} = \Gamma''_i \lub \Gamma, \; \Gamma'_{n+1} = \Gamma'_n
\end{array}
\]
\end{center}
\caption{Translation to fixed types}
\label{table:translation}
\end{table*}

The basic idea of the translation $\judgeL{\lattice}{p}{\Gamma}{C ~> D}{\Gamma'}$
is that for any program point in $D$ corresponding to a point in $C$,
for each variable $x$, 
only one member of the family $\{ x_t \}_{t \in \lattice}$  will be ``in
play''. The type variables in play at any given program point are given by the type environment
at that program point. So for example if $\Gamma(x) = s$
then $x_s$ will be the $x$-variable in play at the beginning of
the execution of $D$. 

\begin{example}
Since a type derivation is structural in the syntax, for any derivation we can associate
a type environment with each program point.
Consider the example derivation shown in Figure~\ref{fig:translation-example}:
in the central column we write the environment update (rather than the whole environment)
yielding the environment after that program point
in the corresponding sub-derivation, and on the right-hand side we write the translated program. 
The example uses the four point lattice introduced previously
(Figure~\ref{fig:diamond}).

\begin{figure*}[htbp]
  \begin{gather*}
\text{Initial typing: }\{ [ w : \diamL ; x: \diamM; y : \diamN ; z : \diamH ] \} 
\\[2ex]
  \begin{array}{l|l|l} 
\text{Code} & \text{Environment change} & \text{Translated code}
\\ 
\hline \\
\<if>~x = 0~\<then>~y := y + 1; w := z & [ y \mapsto \diamH; w \mapsto \diamH] & \<if>~ x_\diamM= 0~\<then>~ y_\diamH := y_\diamM + 1 ; w_\diamH := z_\diamH \\
&  & \phantom{\<if>~ x_\diamM= 0}
~\<else>~ y_\diamH := y_\diamL; w_\diamH := w_\diamL \\
\<while>~ x > 0                &                & \<while>~ x_\diamM > 0 \\
\qquad     z := z + w          &               & \qquad z_\diamH := z_\diamH + w_\diamH \\         
\qquad     x := x - 1          &               & \qquad x_\diamM := x_\diamM - 1  \\ 
\qquad     z := x              & [z \mapsto \diamM] & \qquad z_\diamM := x_\diamM \\
                               &               & \qquad z_\diamH := z_\diamM      
\end{array}
\end{gather*}
\caption{Example translation derivation}
  \label{fig:translation-example}
\end{figure*}
\end{example}



It remains to establish two properties of the translated terms:
\begin{itemize}
\item \emph{Correctness:} they should be semantically equivalent to the original terms, and
\item \emph{Static Soundness:} they should still be typeable. 
\end{itemize}  

\subsection{Correctness}

Correctness means that the input-output behaviour of the program and
its translation should be the same. We refer to this as \emph{semantic
  equivalence}.  Since the original programs operate on floating
variables, and the translation operates on fixed variables, we must
construct a suitable relation between them.

\begin{definition}\label{def:store}
Let $\sigma$ range over floating variable stores and
let $\rho$ range over fixed variable stores.
Then for each type environment $\Gamma$
we define the compatibility relation as
\[
\sigma \sim_\Gamma \rho <=> \forall x \in \Var. \sigma(x) = \rho(x_{\Gamma(x)})
\]
\end{definition}

\begin{theorem}[Translation Correctness]\label{theorem:trans-dynamic}
\mbox{} \\ 
If $\judge{p}{\Gamma}{C ~> D}{\Gamma'}$ then for all $\sigma$ and $\rho$ such that 
$\sigma \sim_\Gamma \rho$, 
\begin{itemize}
\item $\config{C}{\sigma} \conv \sigma' => \exists \rho'. \config{D}{\rho} \conv \rho' \text{ and } \sigma' \sim_{\Gamma'} \rho'$
\item $\config{D}{\rho} \conv \rho' => \exists \sigma'. 
  \config{C}{\sigma} \conv \sigma' \text{ and } \sigma' \sim_{\Gamma'} \rho'$
\end{itemize}
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix:translation}.
\end{proof}

\subsection{Static Soundness} 
The fact that the translated programs are equivalent to the originals ensures
that they have the same security properties, since noninterference is an extensional property. 
Here we show, more significantly, 
that the translated program is also typeable -- and since
it only contains fixed variables this means that it is typeable in a
conventional fixed type system.

\begin{lemma}[Expression Soundness]
\label{lemma:expression-soundness}
If $\Gamma |- E : t$ then $|- E^\Gamma : t$
\end{lemma}
Follows directly from the definitions.


\begin{theorem}[Static Soundness]\label{theorem:trans-static}
If $\judge{p}{\Gamma}{C ~> D}{\Gamma'}$ then
\(
\fjudge{p}{D}
\)
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix:static}.
\end{proof}

\subsection{Complexity}
\label{subsec:complexity}

The transformation increases program size by adding assignments of the
form $\fassign{\Gamma'}{\Gamma}$. These assignments arise whenever, in
the flow-sensitive system, a variable changes its level. Since the
only way that a variable can change its level is through an
assignment, the size of
$\fassign{\Gamma'}{\Gamma}$ is bounded by the number ($a$) of assignment statements in
the original program. The number of such assignments that are added to
the program is proportional to the number ($b$) of conditional and while
statements. This gives us a bound of ${\cal O}(ab)$,
i.e., quadratic in the program size. This
upper bound is tight, as shown by the following program, where we use the
 two-point lattice, and initially $h$ is the only variable assigned type $\diamH$: 
\[ \begin{array}{l}
  \<if>~ y_1 \<then> 
\\ \qquad \<if>~y_2~ \<then>
\\ \qquad \qquad \cdots
\\ \qquad \qquad  \<if>~y_n~ \<then>
\\ \qquad \qquad\quad \<if>~h~ \<then>~ x_1 := 0; \cdots ; x_n := 0 
\end{array}
\]
where the one-armed conditional is just shorthand for a conditional with
$\<skip>$ in the else branch. 
The above program is typeable, where in the final environment, $x_1\ldots x_n$ have type $\diamH$. Writing $X_\diamH := X_\diamL$ for the sequence of assignments 
$x_{1\diamH} := x_{1\diamL}; \cdots ; x_{n\diamH} := x_{n\diamL}$, the transformed program is:
\[
\begin{array}{l}
  \<if>~ y_{1\diamL}~ \<then> 
\\ \qquad \<if>~y_{2\diamL}~ \<then>
\\ \qquad \qquad \cdots
\\ \qquad \qquad  \<if>~y_{n\diamL}~ \<then>
\\ \qquad \qquad\qquad \<if>~h_\diamH~ \<then>~ x_{1\diamH} := 0; \cdots ; x_{n\diamH} := 0 
\\ \qquad \qquad\qquad \<else>~ X_\diamH := X_L
\\ \qquad \qquad  \<else>~ X_\diamH := X_L
\\ \qquad \qquad \cdots
\\ \<else> ~ X_\diamH := X_L
\end{array}
\]
It seems likely that there is a more precise bound based on the depth
of nesting of loops and conditions, and that such blow ups are unlikely
in practice.

\subsection{Relation to Single Static Assignment}
\label{subsec:SSA}
Our transformation introduces additional variables, and this addition
is performed in such a way that a flow-insensitive analysis on the
transformed program achieves the same effect as a flow-sensitive
analysis on the original.
Viewed in this way, our transformation has a similar
effect to transformation to \emph{single static assignment form}
(SSA) (see e.g. \cite{Appel:Compilerbook}).  Single static assignment
is used in the compilation chain to improve and simplify dataflow
analyses. It works by the introduction of additional variables 
in such a way that every variable is assigned-to exactly once. 
Since there is only one assignment per variable, it follows by construction 
that there is no need for a flow-sensitive analysis on a program in SSA form,
since there is only one program point that can influence the type of a variable.

Our transformation is however rather different from SSA.  The
transformation we have described uses a flow-sensitive analysis in
order to construct the transformed program, whereas SSA's purpose is
to avoid the need to perform more complex analyses in the first place.
Thus our transformation approach is perhaps not interesting when
viewed from a classic compiler-construction perspective.

However, applications such as security are not directly
relevant to optimisation and compilation. In a mobile-code setting, a
code consumer may demand that the code can be verified to satisfy some
information-flow policy. Furthermore, in order to have a small trusted
computing base, a small and simple type system is preferable.
Transformations of the kind presented here are interesting in this
setting because they allow the code producer the benefits of
constructing well-typed code in a more expressive system, without
requiring the code consumer to verify code with respect to this more
complex system\footnote{The result of the SSA transformation is not an executable
program, since it contains the so-called $\phi$-nodes at all
join-points, so SSA would be unsuitable for this purpose.
However, \cite{Amme+:SafeTSA} proposes a mobile code representation based on SSA.}. 



\section{Conclusions}
We have presented and investigated the formal properties
of a family of semantically sound flow-sensitive type systems for 
tracking information flow in simple
While programs. The family is indexed by the choice
of flow lattice.

The key results we have shown are that:
\begin{itemize}
    \item For a given program, all derivations in all members of 
    the family can be inferred from the
    derivation of a principal typing in the universal system (ie, the type system
        for the flow lattice $\pset(\Var)$).

    \item The universal system is
    equivalent to Amtoft and Banerjee's
    Hoare-style independence logic.

    \item Each member of the family is ``complete'' with respect
    to the whole family, in that no member can
    be used to validate more $\lattice$-typings than the $\lattice$-system
    itself.

    \item Given a flow-sensitive type derivation for a program, we can systematically
    transform it to produce a semantically equivalent program
    which is typeable in a simple flow-insensitive system.
\end{itemize}
Possible avenues for future work include extending the flow-sensitive systems and
program transformation to richer programming languages and deriving more precise
complexity results for the program transformation.











\acks
Many thanks to David Clark for participation in 
discussions on this work, and for suggesting 
the worst-case complexity example. Discussions with Sruthi~Bandhakavi and 
Daniel~Hedin on alternative formulations of Amtoft and Banerjee's system were particularly useful. Thanks to Josef~Sveningsson for drawing our attention to the connection to SSA, and to Niklas~Broberg for system support.
We also benefited from comments and suggestions 
from Dennis~Walter and the anonymous referees.

\bibliographystyle{alpha}
\newcommand{\etalchar}[1]{$^{#1}$}
\begin{thebibliography}{ADvRF01}

\bibitem[AB04]{Amtoft:Banerjee:SAS04}
Torben Amtoft and Anindya Banerjee.
\newblock Information flow analysis in logical form.
\newblock In {\em SAS 2004 (11th Static Analysis Symposium), Verona, Italy,
  August 2004}, volume 3148 of {\em LNCS}, pages 100--115. Springer-Verlag,
  2004.

\bibitem[ADvRF01]{Amme+:SafeTSA}
Wolfram Amme, Niall Dalton, Jeffery von Ronne, and Michael Franz.
\newblock Safe{TSA}: {A} type safe and referentially secure mobile-code
  representation based on static single assignment form.
\newblock In {\em {SIGPLAN} '01 Conference on Programming Language Design and
  Implementation}, pages 137--147, 2001.

\bibitem[App98]{Appel:Compilerbook}
Andrew~W. Appel.
\newblock {\em Modern Compiler Implementation in Java}.
\newblock Cambridge University Press, Cambridge, 1998.

\bibitem[AR80]{Andrews:Reitman:Axiomatic}
G.~R. Andrews and R.~P. Reitman.
\newblock An axiomatic approach to information flow in programs.
\newblock {\em ACM TOPLAS}, 2(1):56--75, January 1980.

\bibitem[BBL94]{Banatre:Bryce:LeMetayer:ESORICS94}
J.-P. Ban\^atre, C.~Bryce, and D.~{Le M\'etayer}.
\newblock Compile-time detection of information flow in sequential programs.
\newblock In {\em Proc. European Symp. on Research in Computer Security},
  volume 875 of {\em LNCS}, pages 55--73. Springer-Verlag, 1994.

\bibitem[CC77]{Cousot:Cousot:Abstract:Interpretation}
P.~Cousot and R.~Cousot.
\newblock Abstract interpretation: {A} unified lattice model for static
  analysis of programs by construction or approximation of fixpoints.
\newblock In {\em Proc. ACM Symp. on Principles of Programming Languages},
  pages 238--252, January 1977.

\bibitem[CC79]{CousotCousot79-1}
P{.} Cousot and R{.} Cousot.
\newblock Systematic design of program analysis frameworks.
\newblock In {\em Conference Record of the Sixth Annual ACM SIGPLAN-SIGACT
  Symposium on Principles of Programming Languages}, pages 269--282, San
  Antonio, Texas, 1979. ACM Press, New York, NY.

\bibitem[CFR{\etalchar{+}}89]{SSA}
Ron Cytron, Jeanne Ferrante, Barry~K. Rosen, Mark~K. Wegman, and F.~Kenneth
  Zadeck.
\newblock An efficient method of computing static single assignment form.
\newblock In {\em 16th Annual ACM Symposium on Principles of Programming
  Languages}, pages 25--35, 1989.

\bibitem[CH95]{Carini:Hind:Flow}
Paul~R. Carini and Michael Hind.
\newblock Flow-sensitive interprocedural constant propagation.
\newblock In {\em PLDI '95: Proceedings of the ACM SIGPLAN 1995 conference on
  Programming language design and implementation}, pages 23--31. ACM Press,
  1995.

\bibitem[CHH02]{Clark+:JCL}
D.~Clark, C.~Hankin, and S.~Hunt.
\newblock Information flow for {Algol-like} languages.
\newblock {\em Journal of Computer Languages}, 28(1):3--28, April 2002.

\bibitem[DD77]{Denning:Denning:Certification}
D.~E. Denning and P.~J. Denning.
\newblock Certification of programs for secure information flow.
\newblock {\em Comm. of the ACM}, 20(7):504--513, July 1977.

\bibitem[DP90]{davey90introduction}
B.~Davey and H.~Priestley.
\newblock {\em Introduction to Lattices and Order}.
\newblock Cambridge University Press, 1990.

\bibitem[GRS00]{GiacobazziRanzatoScozzari}
Roberto Giacobazzi, Francesco Ranzato, and Francesca Scozzari.
\newblock Making abstract interpretations complete.
\newblock {\em J. ACM}, 47(2):361--416, 2000.

\bibitem[GS05]{GenaimS05}
S.~Genaim and F.~Spoto.
\newblock Information {F}low {A}nalysis for {J}ava {B}ytecode.
\newblock In R.~Cousot, editor, {\em Proc.\ of the Sixth International
  Conference on Verification, Model Checking and Abstract Interpretation
  (VMCAI'05)}, volume 3385 of {\em Lecture Notes in Computer Science}, pages
  346--362, Paris, France, January 2005. Springer-Verlag.

\bibitem[HR98]{Heintze:Riecke:Slam}
N.~Heintze and J.~G. Riecke.
\newblock The {SLam} calculus: programming with secrecy and integrity.
\newblock In {\em Proc. ACM Symp. on Principles of Programming Languages},
  pages 365--377, January 1998.

\bibitem[HS91]{Hunt:Sands:PEPM91}
S.~Hunt and D.~Sands.
\newblock {B}inding {T}ime {A}nalysis: {A} {N}ew {PER}spective.
\newblock In {\em Proceedings of the {A}{C}{M} Symposium on Partial Evaluation
  and Semantics-Based Program Manipulation (PEPM'91)}, pages 154--164,
  September 1991.
\newblock ACM SIGPLAN Notices 26(9).

\bibitem[HS05]{Hedin:Sands:Timing}
D.~Hedin and D.~Sands.
\newblock Timing aware information flow security for a {J}ava{C}ard-like
  bytecode.
\newblock In {\em First Workshop on Bytecode Semantics, Verification, Analysis
  and Transformation (BYTECODE '05)}, 2005.
\newblock To Appear, ENTCS.

\bibitem[NRH99]{Nielson+:Program:Analysis}
F.~Nielson, H.~{Riis Nielson}, and C.~Hankin.
\newblock {\em Principles of Program Analysis}.
\newblock Springer-Verlag, 1999.

\bibitem[SM03]{Sabelfeld:Myers:JSAC}
A.~Sabelfeld and A.~C. Myers.
\newblock Language-based information-flow security.
\newblock {\em IEEE J. Selected Areas in Communications}, 21(1):5--19, January
  2003.

\bibitem[SS01]{Sabelfeld:Sands:HOSC01}
A.~Sabelfeld and D.~Sands.
\newblock A per model of secure information flow in sequential programs.
\newblock {\em Higher Order and Symbolic Computation}, 14(1):59--91, March
  2001.
\newblock Earlier version in ESOP'99.

\bibitem[VSI96]{Volpano:Smith:Irvine:Sound}
D.~Volpano, G.~Smith, and C.~Irvine.
\newblock A sound type system for secure flow analysis.
\newblock {\em J. Computer Security}, 4(3):167--187, 1996.

\bibitem[Wel02]{Wells:ICALP-2002}
J.~B. Wells.
\newblock The essence of principal typings.
\newblock In {\em Proc. International Colloquium on Automata, Languages and
  Programming}, volume 2380 of {\em LNCS}, pages 913--925. Springer-Verlag,
  2002.

\end{thebibliography}

\clearpage
\appendix

\section{Proofs from Section~\ref{sect:transformation}}

\subsection{Translation Correctness}\label{appendix:translation}
In proving the theorem we will make use of the following simple lemmas:
\begin{lemma}\label{lemma:sim}
If $\sigma \sim_\Gamma \rho$ then 
\begin{enumerate}
\item \label{a}
\( \config{\fassign{\Gamma'}{\Gamma}}{\rho}\conv \rho'
\mbox{ where }   \sigma \sim_\Gamma \rho'
\)
\item \label{b}
\(
|[E|]\sigma = |[E^\Gamma|]\rho
\)
\end{enumerate}
\end{lemma}




\begin{proof}
  \begin{enumerate}
  \item
From  definition~\ref{def:fassign}, the effect of $\fassign{\Gamma'}{\Gamma}$ on state $\rho$ 
can be written as 
\[
\rho' = \rho[x_{\Gamma'(x)} \mapsto \rho(x_{\Gamma(x)} ) \mid x \in \Var]
\]
(note that we have ignored the condition $\Gamma(x) \neq \Gamma'(x)$
in the definition of $\fassign{\Gamma'}{\Gamma}$ since these are just identity updates).
So we have for all $x \in \Var$
\begin{align*}
\sigma(x) &= \rho(x_{\Gamma(x)}) \\
          &= \rho[x_{\Gamma'(x)} \mapsto \rho(x_{\Gamma(x)} ) \mid x \in \Var](x_{\Gamma'(x)})\\
          &= \rho'(x_{\Gamma'(x)}) 
\end{align*}
and hence $\sigma \sim_{\Gamma'} \rho'$ as required.
\item
Straightforward from the definitions.
  \end{enumerate}
\end{proof}
\begin{proof}[Proof of Translation Correctness]
  We argue by induction on the derivation in a standard big-step
  semantics.  For collections of independent assignments of the form
  $\fassign{\Gamma'}{\Gamma}$ we somewhat improperly treat them as if
  they are evaluated in a single atomic step.
We illustrate the first part of the theorem, although most steps are in fact reversible, so the proof in the other direction is essentially the same. We focus on the more interesting cases. 

Suppose that $\judge{p}{\Gamma}{C ~> D}{\Gamma'}$, $\sigma \sim_\Gamma
\rho$ and that $\config{C}{\sigma} \conv \sigma'$. We prove that
$\config{D}{\rho} \conv \rho'$ where $\sigma' \sim_{\Gamma'} \rho'$ by
induction on the derivation of $\config{C}{\sigma} \conv \sigma'$ and
cases according to the last rule applied:

\proofcase{Assign}
We have a derivation of the form 
\[
 \inference{
                \ejudge{\Gamma}{E}{t} \quad s =  p \lub t  
        }{
                \judge{p}{\Gamma}{x \<:=> E  ~>  x_{s} \<:=> E^\Gamma}{\Gamma[x \mapsto s]}
        }
\]
Suppose that $|[E|] \sigma = V$, and hence that 
\[ \config{x \<:=> E}{\sigma}\conv \sigma[x\mapsto V]. \]
By Lemma~\ref{lemma:sim}, $|[E^\Gamma|] \sigma = V$ and hence
\[ \config{x_{\sigma} \<:=> E^\Gamma}{\sigma}\conv \sigma[x\mapsto V]. \]

\proofcase{While}
There are two cases according to the value of the conditional. 
We just show the harder case where the last step of the derivation has the form:
\[
    \inference{
        |[E|]\sigma = \<true> &
        \config{C}{\sigma}\conv \sigma' &
        \config{\<while>\;E\;C}{\sigma'}\conv\sigma''
    }{
        \config{\<while>\;E\;C}{\sigma}\conv\sigma''
    }
\]
We have a translation derivation of the form
\[
    \inference{
            \ejudge{\Gamma'_i}{E}{t_i} &
            \judge{p \sqcup t_i}{\Gamma_i'}{C ~> D_i}{\Gamma''_i} &
            0 \leq i \leq n
    }{
            \judge{p}{\Gamma}{\<while>\;E\;C
~> \fassign{\Gamma'}{\Gamma}\<;>\<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})
}{\Gamma'}
    }
\]
where $\Gamma'_0 = \Gamma, \; \Gamma'_{i+1} = \Gamma''_i \lub \Gamma, \; \Gamma'_{n+1} = \Gamma'_n$
and $\Gamma' = \Gamma'_n, \Gamma'' = \Gamma''_n, D = D_n$.
Henceforth let $W_D$ denote the subterm $\<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})$.
Assume that $\sigma \sim_\Gamma \rho$. We are required to show that 
\[ \config{\fassign{\Gamma'}{\Gamma}\<;>W_D}{\rho}\conv\rho'' ~\text{where}~ \sigma \sim_{\Gamma'}\rho'' \]
We assemble the following facts in order to construct a derivation for this claim. 
From Lemma~\ref{lemma:sim}(\ref{a}) we get
  \begin{equation}
\config{\fassign{\Gamma'}{\Gamma}}{\rho}\conv\rho_1~\text{where}~ 
\sigma \sim_{\Gamma'} \rho_1\label{eq:one}
\end{equation}
and from Lemma~\ref{lemma:sim}(\ref{b})
  \begin{equation}
    \label{eq:two}
    \config{E^{\Gamma'}}{\rho_1}\conv\<true>.
  \end{equation}
From the induction hypothesis for the subderivation for $C$ we have
  \begin{equation}
    \label{eq:three}
    \config{D}{\rho_1}\conv \rho_2 ~\text{where}~ \sigma' \sim_{\Gamma''} \rho_2,
  \end{equation}
and from Lemma~\ref{lemma:sim}(\ref{a}),  
  \begin{equation}
\config{\fassign{\Gamma'}{\Gamma''}}{\rho_2}\conv\rho_3~\text{where}~ 
\sigma' \sim_{\Gamma'} \rho_3\label{eq:four}
\end{equation}
Finally from the premises of the typing judgement, we also have the weaker judgement:
\[
\judge{p}{\Gamma'}{\<while>\;E\;C
~> \fassign{\Gamma'}{\Gamma}\<;>W_D
}{\Gamma'}
\]
Now we apply the induction hypothesis for the second evaluation premise,
with respect to this judgement, to obtain
\begin{equation}
  \label{eq:five}
  \config{W_D}{\rho_3}\conv \rho'' ~\text{where}~ \sigma'' \sim_{\Gamma'} \rho''
\end{equation}
Finally from these facts 
we construct the required derivation, which is given in Figure~\ref{fig:while-dynamic}.
\begin{figure*}\[
\setpremisesend{0.2em}\setpremisesspace{0.6em}
    \inference{
        \inference*{(\ref{eq:one})}{\config{\fassign{\Gamma'}{\Gamma}}{\rho}\conv\rho_1} &
        \inference{
            \inference*{(\ref{eq:two})}{\config{E^{\Gamma'}}{\rho_1}\conv\<true>} &
            \inference{
                \inference*{(\ref{eq:three})}{\config{D}{\rho_1}\conv\rho_2}
              & \inference*{(\ref{eq:four})}{\config{\fassign{\Gamma'}{\Gamma''}}{\rho_2}\conv\rho_3}
            }{
                \config{D\<;>\fassign{\Gamma'}{\Gamma''}}{\rho_1}\conv\rho_3
            } &
            \inference*{(\ref{eq:five})}{\config{W_D}{\rho_3}\conv \rho''}
        }{
            \config{W_D}{\rho_1}\conv \rho''
        }  
    }{
        \config{\fassign{\Gamma'}{\Gamma}\<;>\<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})}{\rho}
            \conv\rho''
    }
\]
  \caption{Concluding derivation, While case, Theorem~\ref{theorem:trans-dynamic} }
  \label{fig:while-dynamic}
\end{figure*}
\end{proof}

\subsection{Static Soundness}\label{appendix:static}
The proof is by induction on the structure of the translation 
derivation, making use of the following simple weakening lemmas:
\begin{lemma}\mbox{}
  \label{lemma:weakening}
  \begin{itemize}
  \item If $p |- D$ and $p' \sqsubseteq p$ then $p' |- D$ 
\item If~$\judgeA{p}{\Gamma}{C}{\Gamma'}$ then for all $x$, 
$\Gamma(x) \neq \Gamma'(x) => p \sqsubseteq \Gamma'(x)$
\end{itemize}
\end{lemma}
\begin{proof}
The first item is a straightforward induction on the derivation, and
we omit the details.

The second item is also by induction on the derivation.
We present the three key cases.

\proofcase{Assign} The conclusion of the rule is:
\[
    \judgeA{p}{\Gamma}{x \<:=> E}{\Gamma[x \mapsto p \sqcup t]}
\]
The initial and final type environment only differ (potentially) in $x$ 
and we see immediately that $p \sqsubseteq \Gamma'(x) = p \lub t$.

\proofcase{If} The rule provides a derivation of the form
\[
    \inference{
        \judgeA{p \sqcup t}{\Gamma}{C_i}{\Gamma'_i} \quad i = 1,2 \quad \Gamma' = \Gamma'_1 \lub \Gamma'_2
    }{
        \judgeA{p}{\Gamma}{\<if>\;E\;C_1\;C_2}{\Gamma'}
    }
\]
The induction hypothesis gives, for $i = 1,2$, 
\[ \forall x. \Gamma(x) \neq \Gamma'_i(x) => p \sqsubseteq \Gamma'_i(x) \]
So suppose that for some particular $x$ we have 
$\Gamma(x) \neq \Gamma'(x)$.
Since $\Gamma' = \Gamma'_1 \lub \Gamma'_2$
we must have 
$\Gamma(x) \neq \Gamma'_i(x)$ for either $i=1$ or $i=2$ (or both).
It follows from the induction hypothesis that
$p \sqsubseteq \Gamma'_i(x)$ for this $i$, and hence that 
$p \sqsubseteq \Gamma'_1(x) \lub \Gamma'_2(x)$ as required.

\proofcase{While} The rule provides a derivation of the form
\[
    \inference{
            \ejudge{\Gamma'_i}{E}{t_i} &
            \judgeA{p \sqcup t_i}{\Gamma_i'}{C}{\Gamma''_i} &
            0 \leq i \leq n
    }{
            \judgeA{p}{\Gamma}{\<while>\;E\;C}{\Gamma'_n}
    }
\]
where $\Gamma'_0 = \Gamma, \; \Gamma'_{i+1} = \Gamma''_i \lub \Gamma, \; \Gamma'_{n+1} = \Gamma'_n$.
The induction hypothesis gives, for $0 \leq i \leq n$,
$\Gamma''_i(x) \neq \Gamma'_i(x) => p \lub t_i \sleq \Gamma''_i(x)$.

Assume $\Gamma'_n(x) \neq \Gamma(x)$. Now suppose
that $\Gamma''_i(x) = \Gamma'_i(x)$ for all $i$ with $0 \leq i \leq n$:
we show that this contradicts the assumption (ie we show that
it entails $\Gamma'_n(x) = \Gamma(x)$) by induction on $n$. The base case
is immediate since $\Gamma'_0 = \Gamma$, so consider $n = k+1$.
By construction, $\Gamma'_{k+1}(x) = \Gamma''_k(x) \lub \Gamma(x)$
so, by supposition, $\Gamma'_{k+1}(x) = \Gamma'_k(x) \lub \Gamma(x)$.
But by IH $\Gamma'_k(x) = \Gamma(x)$, hence $\Gamma'_{k+1}(x) = \Gamma(x)$.

We have shown that $\Gamma'_n(x) \neq \Gamma(x)$ implies the existence
of some $i$ such that $\Gamma''_i(x) \neq \Gamma'_i(x)$ so, by the induction hypothesis,
$p \lub t_i \sleq \Gamma''_i(x)$, hence $p \sleq \Gamma''_i(x)$.
But, as illustrated in Figure~\ref{fig:chain}, $\Gamma''_i \sleq \Gamma'_n$ holds
for all $i$, so we
are done.
\end{proof}

\begin{proof}[Proof of Static Soundness]
We give a couple of illustrative cases.
 
\proofcase{Assign-t} The derivation is of the form 
\[ 
    \inference{
        \ejudge{\Gamma}{E}{t} \quad s =  p \lub t  
    }{
        \judge{p}{\Gamma}{ x \<:=> E  ~>  x_{s} \<:=> E^\Gamma}{\Gamma[x \mapsto s]}
    }
\]

From Lemma~\ref{lemma:expression-soundness} we have that $\ejudge{}{E^\Gamma}{t}$, and thus $ p |-  x_{s} \<:=> E^\Gamma$ follows directly from the Assign-fixed axiom.

\proofcase{While-t}
Assume the last rule in the inference has the form:
\[
    \inference{
            \ejudge{\Gamma'_i}{E}{t_i} &
            \judge{p \sqcup t_i}{\Gamma_i'}{C ~> D_i}{\Gamma''_i} &
            0 \leq i \leq n
    }{
            \judge{p}{\Gamma}{\<while>\;E\;C
~> \fassign{\Gamma'}{\Gamma}\<;>\<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})
}{\Gamma'}
    }
\]
where $\Gamma'_0 = \Gamma, \; \Gamma'_{i+1} = \Gamma''_i \lub \Gamma, \; \Gamma'_{n+1} = \Gamma'_n$
and $\Gamma' = \Gamma'_n, \Gamma'' = \Gamma''_n, D = D_n$.

Since the translation system is a conservative extension of the type system, we have a derivation $\judgeA{p}{\Gamma}{\<while>\;E\;C}{\Gamma'}$, and hence by Lemma~\ref{lemma:weakening} that 
\[
\forall x. \Gamma(x) \neq \Gamma'(x) => p \sqsubseteq \Gamma'(x).
\]
this, together with the fact that $\Gamma \sqsubseteq \Gamma'$ means that every assignment in $\fassign{\Gamma'}{\Gamma}$ is typeable, and hence that
\begin{equation}
  \label{eq:gamma'gamma}
  p |- \Gamma' := \Gamma
\end{equation}
Similarly with the subderivation $\judge{p \sqcup t_n}{\Gamma'}{C ~> D}{\Gamma''}$ we get, using Lemma~\ref{lemma:weakening} that 
\[
\forall x. \Gamma'(x) \neq \Gamma''(x) => p \lub t_n \sqsubseteq \Gamma''(x).
\]
and in the same manner as above we can conclude that
\begin{equation}
  \label{eq:gamma'gamma''}
  p \lub t_n |- \fassign{\Gamma'}{\Gamma''}. 
\end{equation}
Furthermore, Lemma~\ref{lemma:expression-soundness} gives
\begin{equation}
  \label{eq:egamma'}
  |- E^{\Gamma'} : t_n, 
\end{equation}
and the inductive hypothesis gives us
\begin{equation}
  \label{eq:ieD}
p \lub t_n |- D.
\end{equation}
Putting this together we obtain the concluding derivation
\[ \setpremisesend{0.2em}\setpremisesspace{0.6em}
\inference{
   \inference*{(\ref{eq:gamma'gamma})} {p |- \Gamma' := \Gamma} 
   &
   \inference{
      \inference*{(\ref{eq:egamma'})}{|- E^{\Gamma'} : t_n}   
     &\inference*{
         \inference*{(\ref{eq:ieD})}{p \lub t_n |- D}&
         \inference*{(\ref{eq:gamma'gamma''})}
                   {p \lub t_n |- \fassign{\Gamma'}{\Gamma''}}    
      }
      {p \lub t_n |- D\<;>\fassign{\Gamma'}{\Gamma''}} 
   }
   {p |- \<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})  }
}
{p |- \fassign{\Gamma'}{\Gamma}\<;> 
      \<while>\;E^{\Gamma'}\; (D\<;>\fassign{\Gamma'}{\Gamma''})
}
\]
\end{proof}

\end{document}
