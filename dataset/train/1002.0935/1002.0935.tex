\documentclass[copyright]{eptcs}
\providecommand{\volume}{118}
\providecommand{\anno}{2011}







\usepackage{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{mathptmx}
\usepackage{helvet}
\usepackage{listings}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{empheq}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{footmisc}

\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{algorithm2e}





\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}








\input{diagrams}
\diagramstyle[h=2mm,w=3mm,PostScript=dvips]










\newcommand{\msg}[1]{\mathsf{msg}(#1)}
\newcommand{\dmsg}[1]{\mathsf{dmsg}(#1)}

\newcommand{\cpsa}{\textsc{cpsa}}
\newcommand{\kind}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\Names}{\kind{T}_{\mbox{\footnotesize name}}}
\newcommand{\Text}{\kind{T}} \newcommand{\Key}{\kind{K}}
\newcommand{\Algebra}{\kind{A}} \newcommand{\BAlgebra}{\kind{B}}
\newcommand{\C}{\kind{C}} \newcommand{\M}{\kind{M}}
\newcommand{\B}{\kind{B}} \newcommand{\PP}{\kind{P}}
\newcommand{\Q}{\kind{Q}} \newcommand{\A}{\kind{A}}
\renewcommand{\SS}{\kind{S}} \newcommand{\R}{\kind{R}}
\newcommand{\opr}[1]{\operatorname{\kind{#1}}}
\newcommand{\Tag}{\kind{Tag}} \newcommand{\Nonce}{\kind{Nonce}}
\newcommand{\dom}{\kind{dom}} \newcommand{\node}{\kind{nodes}}
\newcommand{\pk}[1]{\operatorname{\kind{pubk}}(#1)}
\newcommand{\sk}[1]{\operatorname{\kind{privk}}(#1)}
\newcommand{\signk}[1]{\operatorname{\kind{signk}}(#1)}
\newcommand{\pkp}{\operatorname{\kind{pubkp}}}
\newcommand{\skp}{\operatorname{\kind{privkp}}}
\newcommand{\goods}{\mathsf{goods}}
\newcommand{\price}{\mathsf{price}} \newcommand{\ship}{\mathsf{ship}}
\newcommand{\epmo}{\mathsf{EPMO}} \newcommand{\bank}{\mathsf{Bank}}
\newcommand{\mo}{\mathsf{mo}}
\newcommand{\Rel}[1]{\opr{\mathbf{#1}}}

\newcommand{\skel}{\ensuremath{\mathbb{A}}}
\newcommand{\skeleton}[1]{\ensuremath{\kind{skeleton}(#1)}}
\newcommand{\pathinfo}{\ensuremath{\mathbb{PI}}}

\newcommand{\transfers}{\ensuremath{\mathsf{transfer}}}
\newcommand{\ships}{\ensuremath{\mathsf{ship}}}

\newcommand{\nwle}{\ensuremath{\mathbin{{\le}_{\mathit{n}}}}}

\newcommand{\customer}{\mathsf{Customer}}
\newcommand{\merchant}{\mathsf{Merchant}}
\newcommand{\Th}[1]{\ensuremath{\mathsf{Th}_{#1}}}
\newcommand{\ThD}[1]{\ensuremath{\mathsf{Th}_{#1}^{\mathsf{D}}}}
\newcommand{\says}{\ensuremath{\mathsf{\ says\ }}}
\newcommand{\Says}{\ensuremath{\mathop{\mathsf{Says}}}}
\newcommand{\except}{\ensuremath{\mathsf{\ except\ }}}
\newcommand{\has}{\ensuremath{\mathsf{\ has\ }}}
\newcommand{\dotdot}{\ensuremath{\mathsf{.\,.}}}
\newcommand{\speaksfor}{\Rightarrow}


\newcommand{\cf}[1]{\ensuremath{\mathsf{cf}( #1 )}}
\newcommand{\cfs}[2]{\ensuremath{\mathsf{cfs}( #1,#2 )}}
\newcommand{\Disquote}[1]{\ensuremath{\mathsf{Disquote}_{#1}}}
\newcommand{\Quote}[1]{\ensuremath{\mathsf{Quote}_{#1}}}
\newcommand{\Close}{\ensuremath{\mathsf{Close}}}

\newcommand{\prin}[1]{{\mathsf{prin}}(#1)}
\newcommand{\ipsec}{\textsf{IPsec}}

\newcommand{\Keyset}{\mathfrak{K}}              \newcommand{\PKey}{{\Key}_{\cal P}}
\newcommand{\PubKey}{\kind{P}}
\newcommand{\bnd}{\mathcal{B}}
\newcommand{\bndC}{\mathcal{C}}
\newcommand{\somekeys}{\mathcal{K}}
\newcommand{\lang}[1]{\mathcal{L}_{#1}}
\newcommand{\langminus}[1]{\mathcal{L}_{#1}^0}
\newcommand{\langminussep}[1]{\mathcal{L}_{#1}^{0,\mathrm{sep}}}
\newcommand{\orig}{\mathcal{O}}

\newcommand{\cons}{\,{\hat{\ }}\,}
\newcommand{\seq}[1]{\langle #1 \rangle}
\newcommand{\braket}[2]{\langle #1\mid #2 \rangle}
\newcommand{\bra}[1]{\langle #1\mid}
\newcommand{\conjrows}[2]{#1\mathbin{\&}#2}
\newcommand{\strandnode}[2]{ {#1}\downarrow{#2} }
\newcommand{\safe}[1]{ \kind{Safe}_{#1} }
\newcommand{\isafe}[1]{ \kind{Safe\_ind}_{#1} }
\newcommand{\prot}{ \kind{Prot} }
\newcommand{\hull}{\kind{hull}}

\newcommand{\ltk}[1]{\ensuremath{\kind{ltk}(#1)}}

\newcommand{\length}[1]{{| #1 |}}
\newcommand{\Resp}{\kind{Resp}}
\newcommand{\Orig}{\kind{Init}}
\newcommand{\Init}{\kind{Init}}
\newcommand{\Serv}{\kind{Serv}}
\newcommand{\RespPar}{\Resp}
\newcommand{\OrigPar}{\Orig}
\newcommand{\ServPar}{\Serv}
\newcommand{\NSInit}{\kind{NSInit}}
\newcommand{\NSResp}{\kind{NSResp}}
\newcommand{\NSLInit}{\kind{NSLInit}}
\newcommand{\NSLResp}{\kind{NSLResp}}
\newcommand{\HNonce}{\kind{HearNonce}}
\newcommand{\HKey}{\kind{HearKey}}

\newcommand{\CInit}{\kind{\rm CInit}}
\newcommand{\CResp}{\kind{\rm CResp}}
\newcommand{\CServ}{\kind{\rm CServ}}

\newcommand{\Hear}[2]{\kind{Lsn{#1}}[#2]}

\newcommand{\Inv}{\kind{\bf inv}}
\newcommand{\Paste}{\kind{\bf join}}
\newcommand{\Encr}{\kind{\bf encr}}
\newarrow{StrNext}      ===={=>}
\newarrow{DotStrNext}   ....{=>}
\newarrow{DotTo}   ....{>}
\newarrow{Bond} ----{->}
\newarrow{DashTo}{}{dash}{}{dash}>
\newarrow{MapTo}      |---{->}
\newcommand{\PenStrand}[1]{\textsf{#1}} \newcommand{\Tree}{\kind{\bf tree}}

\newcommand{\csp}{\textsc{csp}}
\newcommand{\fdr}{\textsc{fdr~1}}
\newcommand{\fdrtwo}{\textsc{fdr~2}}
\newcommand{\fdrnv}{\textsc{fdr}}

\newarrow{StrNext}      ===={=>}
\newarrow{Bond} ----{->}
\newarrow{DashTo}{}{dash}{}{dash}>
\newcommand{\strand}[1]{\langle #1 \rangle}
\newcommand{\Resptr}{{\cal T}_{\kind{\footnotesize resp}}}
\newcommand{\Origtr}{{\cal T}_{\kind{\footnotesize init}}}
\newcommand{\Servtr}{{\cal T}_{\kind{\footnotesize serv}}}
\newcommand{\enc}[2]{\{\!\!|#1|\!\!\}_{#2}}
\newcommand{\tagged}[2]{[\![\,#1\,]\!]_{#2}}
\newcommand{\hash}[1]{\kind{hash}(#1)}
\newcommand{\roleskel}[3]{\{\!\!\{#1\}\!\!\}^{#2,#3}}
\newcommand{\restricted}{\mathbin{\mid\!\hspace{-1.2pt}\grave{}}}


\newcommand{\sends}[2]{#1 \longrightarrow #2}

\newcommand{\Excise}{\, \dag}
\newcommand{\Redir}{\, \clubsuit}

\newcommand{\subterm}{\sqsubseteq}
\newcommand{\term}{\kind{msg\/}}
\newcommand{\tr}{\mbox{tr\/}}
\newcommand{\iv}{\mbox{iv\/}}
\newcommand{\rv}{\mbox{rv\/}}
\newcommand{\mv}{\mbox{mv\/}}
\newcommand{\initiator}{\mbox{initiator\/}}
\newcommand{\responder}{\mbox{responder\/}}
\newcommand{\key}{\mbox{key\/}}
\newcommand{\nv}{\mbox{nv\/}}
\newcommand{\bt}{\mbox{pbt\/}}
\newcommand{\consequence}{\longrightarrow}

\newcommand{\router}{\vrule height3mm width3mm depth0mm}
\newcommand{\host}{\circle*{2}}
\newcommand{\sembrack}[1]{[\![#1]\!]}
\newcommand{\pathto}[1]{\ensuremath{\stackrel{#1}{\longrightarrow}}}

\newcommand{\inboundS}{\ensuremath{\partial^{in} S}}
\newcommand{\outboundS}{\ensuremath{\partial^{out} S}}
\newcommand{\boundS}{\ensuremath{\partial S}}

\newcommand{\start}{{\bf start}}
\newcommand{\finish}{{\bf stop}}

\newcommand{\rdy}{\mathbf{ready}}
\newcommand{\accept}{\mathbf{accept}}
\newcommand{\authentic}{\mathbf{authentic}}
\newcommand{\continue}{\mathbf{continue}}


\newcommand{\cn}[1]{\ensuremath{\mathop{\smash{\sf#1}}\!\mathop{\vphantom{#1}}\nolimits}}
\newcommand{\until}{\ensuremath\mathbin\mathcal{U}}
\newcommand{\releases}{\ensuremath\mathbin\mathcal{R}}
\newcommand{\eventually}{\ensuremath\mathop\diamond}
\newcommand{\selinux}{\textsf{SELinux}}

\newcommand{\turnstile}{\ensuremath{\mathop{\mid\!\!\!-}}}
\newcommand{\simV}{\mathbin{\sim_{\kind{V}}}}
\newcommand{\unsimV}{\mathbin{\not\sim_{\kind{V}}}}
\newcommand{\simL}{\mathbin{\sim_{\kind{L}}}}




\newcommand{\strandno}{\ensuremath{\mathsf{str\_non}}}
\newcommand{\stranduo}{\ensuremath{\mathsf{str\_uniq}}}


\newcommand{\uo}{\ensuremath{\mathsf{unique}}}
\newcommand{\no}{\ensuremath{\mathsf{non}}}
\newcommand{\uop}{\ensuremath{\mathsf{uniquep}}}
\newcommand{\nop}{\ensuremath{\mathsf{nonp}}}
\newcommand{\used}{\ensuremath{\mathsf{used}}}

\newcommand{\Prim}{\ensuremath{\Sigma_1}}
\newcommand{\Second}{\ensuremath{\Sigma_2}}

\newcommand{\applyrep}[2]{\ensuremath{#1 \cdot #2}}

\newcommand{\tuple}[2]{\ensuremath{#1\mathbin{\mid_{#2}}}}
\newcommand{\step}[2]{\par\medskip\noindent{\textbf{#1.}  \textit{#2}}}



\newtheorem{prop}{Proposition}{\bfseries}{\itshape}
\newtheorem{mylemma}[prop]{Lemma}{\bfseries}{\itshape}
\newtheorem{example}{Example}{\bfseries}{\upshape}
\newtheorem{cor}[prop]{Corollary}{\bfseries}{\itshape}


\newtheorem{assumption}{Assumption}






\newcommand{\shapes}[1]{\ensuremath{\mathsf{shapes}(#1)}}
\newcommand{\abstr}[1]{\ensuremath{\mathsf{abstr}(#1)}}
\newcommand{\nodes}[1]{\ensuremath{\mathsf{nodes}(#1)}}


\newcommand{\Rstrct}[3]{\Im\langle#1::#2::(#3)\rangle}

\newcommand{\rng}[1]{{\sf range}(#1)}

\newcommand{\restr}{\nabla}








\newcommand{\TOP}[1]{{\sf top}(#1)}
\newcommand{\error}{\Rightarrow_{\textsf{err}}}
\newcommand{\lts}[1]{\ \stackrel{#1}\longrightarrow\ }
\newcommand{\msgbox}[2]{[#1]_{#2}}
\newcommand{\interact}[4]{#1\rightarrow#2:\mathsf{#3}\langle#4\rangle}
\newcommand{\rec}{\mathbf {rec}\ }
\newcommand{\pp}{\mathrel{\boldsymbol{\mathord{\mid}}}}
\newcommand{\plus}{\ \mathbf +\ }
\newcommand{\pfx}{\mathbf.\ }
\newcommand{\INACT}{\mathbf0 }

\newcommand{\tproves}[3]{#1\,\vdash\,#2#3}

\newcommand{\inputP}[4]{{\sf in:}\ #1\rightarrow\Sigma_i\mathsf{#2}_i(#3_i)\pfx #4_i}
\newcommand{\inputPs}[3]{{\sf in:}\ #1\rightarrow\Sigma_i\mathsf{#2}(#3)}
\newcommand{\outputP}[4]{{\sf out:}\ #1\leftarrow\&_i\mathsf{#2}_i(#3_i)\pfx #4_i}
\newcommand{\outputPs}[3]{{\sf out:}\ #1\leftarrow\&\mathsf{#2}(#3)}
\newcommand{\LET}[3]{{\sf let}\ #1=#2\ {\sf in}\  #3}
\newcommand{\ltsII}[1]{\ \stackrel{#1}\dashrightarrow\ }
\newcommand{\ppp}{\mathrel{\boldsymbol{\mathord{\mid\!\mid}}}}
\newcommand{\pr}[2]{#1\boldsymbol[\;#2\;\boldsymbol]}
\newcommand{\INACTNW}{\mathbf\epsilon }


\newcommand{\queue}[3]{#1\hookrightarrow #2:#3}

\newcommand{\epp}[2]{{\sf epp}(#1,#2)}
\newcommand{\mergeable}{\bowtie}
\newcommand{\merge}{\sqcup}



\newcommand{\Out}[1]{\ \stackrel{#1}\longrightarrow\ }
\newcommand{\In}[1]{\ \stackrel{#1}\longleftarrow\ }

\newcommand{\who}{\mathsf{who}}


\newcommand{\heads}[1]{{\sf heads}(#1)}



\newcommand{\Rule}[2]{\displaystyle{\frac{#1}{#2}}}
\newcommand{\Did}[1]{(\textsc{#1})}
\newcommand{\NI}{\noindent}

\newcommand{\ceil}[1]{\lceil #1\rceil}

\newcommand{\op}[1]{{\sf #1}}




\newcommand{\eppsem}[1]{\sembrack{#1}^{}}



\newcommand{\eppproves}[3]{#1\,\models\,#2\,\rhd\,#3}

\newcommand{\cryptoproves}[3]{#1\,\Vdash\,#2\,\rhd\,#3}

\newcommand{\semproves}[3]{#1\,\models\,#2\,\rhd\,#3}




\newtheorem{definition}{Definition}

\def\titlerunning{Execution Models for Choreographies and Cryptoprotocols}
\def\authorrunning{Carbone and Guttman}


\title{Execution Models for Choreographies and Cryptoprotocols}





\author{Marco Carbone\thanks{The author was partially supported by EPSRC grant EP/F002114}\\
IT University of Copenhagen\\
Copenhagen, Denmark\\
\url{carbonem@itu.dk}\\
\and
Joshua Guttman{}\\
Worcester Polytechnic Institute\\
Worcester, MA, United States\\
\url{guttman@wpi.edu}\\
}



\begin{document}
\maketitle

\begin{abstract}
A choreography describes a transaction in which several principals
interact.  Since choreographies frequently describe business processes
affecting substantial assets, we need a security infrastructure in
order to implement them safely.  As part of a line of work devoted to
generating cryptoprotocols from choreographies, we focus here on the
execution models suited to the two levels.   

We give a strand-style semantics for choreographies, and propose a
special execution model in which choreography-level messages are
faithfully delivered exactly once.  We adapt this model to handle
multiparty protocols in which some participants may be compromised.  

At level of cryptoprotocols, we use the standard Dolev-Yao execution
model, with one alteration.  Since many implementations use a "nonce
cache" to discard multiply delivered messages, we provide a semantics
for at-most-once delivery.   
\end{abstract}

\section{Introduction}
\label{sec:introduction}


Choreographies are global descriptions of transactions including
business or financial transactions.  They describe the intertwined
behavior of several principals as they negotiate some agreement
and--frequently--commit some state change.  A key idea is
\emph{end-point projection}~\cite{carbone.honda.yoshida:esop07}, which
converts a global description into a set of descriptions that
determine the local behavior of the individual participants in a
choreography.  Conversely, \emph{global synthesis} of a choreography
from local behaviors is also sometimes possible, i.e.~meshing a set of
local behaviors into a comprehensive global
description~\cite{MostrousYoshidaHonda09}.

Because these transactions may transfer sums of money and other
objects of value, or may communicate sensitive information among the
principals, they require a security infrastructure.  It would be
desirable to synthesize a cryptographic protocol directly from a
choreography description, to control how adversaries can interfere
with transactions among compliant principals.  Corin et
al.~\cite{CDFBL08} have made a substantial start on this problem, with
further advances described in~\cite{BhargavanEtAl09}.  However, many
questions remain, for instance how to optimize the generated
cryptographic protocols, how best to establish that they are always
correct, and indeed how best to define their correctness.

This last question concerns how to state what control the protocol
should provide, against adversaries trying to interfere with
transactions.  It is a substantial question because the execution
model that choreographies use is quite distant from the execution
model cryptographic protocols are designed to cope with.  For
instance, choreographies use an execution model---or communication
model---in which messages are never received by any party other than
the intended recipient, or if the formalism represents channels, they
are received only over the channel.  Moreover, messages are always
delivered if the recipient is willing to receive the message.
Messages are delivered only if they were sent, and specifically only
if they were sent by the expected peer.  Finally, they are delivered
only once.  These aspects of the model mean that confidentiality and
integrity properties are built into the underlying assumptions.  A
security infrastructure is intended to justify exactly these
assumptions, i.e.~to provide a set of behaviors in which these
assumptions are satisfied.

Naturally, these behaviors must be achieved within an underlying model
in which the adversary is much stronger.  In this model---typically
called the \emph{Dolev-Yao model}, after a paper~\cite{DolevYao83} in
which Dolev and Yao formalized ideas suggested by Needham and
Schroeder~\cite{NeedhamSchroeder78}---all messages may be received by
the adversary, so that confidentiality needs to be achieved by
encryption.  They may be delivered zero times, once, or repeatedly,
and they may be misdelivered to the wrong participant.  When
delivered, a message may appear to come from a participant that did
not send it.  The adversary may alter messages in transit, including
applying cryptographic operations using keys that he knows, or may
obtain by manipulating the protocol.

Digital signatures may be used to notify a recipient reliably of the
source of a message (and of the integrity of its contents).  Symmetric
encryption may also be used to ensure authenticity:  a recipient knows
that the encrypted message was prepared by a party that knew the
secret key, and intended it for a peer that also knew the secret key.
Nonces, which are simply randomly chosen bitstrings, may be used to
ensure freshness.  The principal  that chose a nonce knows, when
receiving a message containing it, that the nonce was inserted after
 chose it.  Moreover, if  engages in many sessions and
associates a different nonce with each,  can ensure that messages
containing one nonce cannot be misdirected to a session using a
different nonce. 

In this paper, we begin the process of relating the Dolev-Yao model of
execution to the choreography execution model.  This is a key step in
generating cryptographic protocols and proving them faithful to the
intent of the choreography.  In particular, we represent the two
execution models using the strand space
model~\cite{strandspaces,GuttmanEtAl05}.


\paragraph{Goals of this Paper.} We provide a few definitions and
an example to indicate how the strand space framework can relate
choreographies to the cryptographic protocols that implement them.

In particular, we consider a very simple choreography language, and
provide a semantics for it as a set of ``abstract bundles.''  That is,
each session of the protocol executes according to one of the bundles
predicted by the semantics.  Moreover, any collection of sessions that
may have occurred takes the following form: its events partition into
bundles that are obtained by instantiating the parameters in bundles
given in the semantics.  Also, if two nodes belong to different
partition elements, there is no  ordering between them,
unless the executions are generated as parts of some higher-level
choreography that might determine a causal ordering.

We call this an {\em abstract bundle semantics} because it builds in
the assumptions of the choreography level: messages do not have
explicit cryptographic operations, and the choreography-level
communication assumptions are satisfied.
Messages are always delivered exactly once; sender and recipient are
never mismatched; no message is created by adversary operations.  We
must connect this idealized semantics with a more realistic semantics
at the cryptographic level, in which the adversary may be active.

One peculiarity of our message datatype is that we allow ``boxes.''  A
box  is a message prepared on role
 that can be opened only by a principal playing role .
At the choreography level, this property is enforced by a type system.
We use these boxes to make explicit the confidentiality and
authentication requirements of a choreography in the case where some
roles are played by compromised participants.  However, in this
article, we focus on the simplest case, in which no participants are
compromised.  That is, we will assume here, that any participant who
is sent a box, will behave only as predicted by the choreography.

Our semantics at the \emph{cryptographic level} is a standard strand
space treatment, except for one ingredient.  Namely, this semantics
assumes that some kinds of messages are delivered at most once.  These
are session-initiating messages that contain a nonce, or in some
protocols a freshly generated session key.  Implementations now use a
nonce-caching technique in which the nonces of previously executed
sessions are retained in a cache.  A new incoming message contains a
nonce which is compared against the cache; if it is present, then with
overwhelming probability there has been a replay attempt, and the
message is discarded.  Otherwise, the nonce is recorded and the
session proceeds.  So as not to need to retain nonces forever,
implementations typically combine this with a timestamp, and assume
that uncompromised principals are loosely synchronized.  A message
with too old a timestamp is discarded.  Nonces may be dropped from the
cache when their timestamps have expired.  In this approach, the nonce
and the timestamp must appear digitally signed in the incoming message
to prevent manipulation by the adversary.

We define a cryptographic protocol to properly implement a
choreography if, when abstracting its possible executions in this
at-most-once semantics, we obtain exactly the possible executions of
the abstract bundle semantics for the choreography.  

We explore here a simple example in which the participants are
well-known to each other from the start of the transaction.  However,
the ideas also apply when additional participants may be chosen during
execution, and keys must be distributed as part of the message flow.




\section{Strand Spaces}
\label{sec:strandspaces}


Strand spaces \cite{strandspaces,GuttmanEtAl05} were developed as a
simplest possible model for cryptographic protocol analysis, but are
also applicable to other kinds of distributed systems. In strand
spaces, we consider {\em strands}, behavioural traces for roles
represented as finite linear sequences of transmission and reception
events. The model provides techniques for analysing how various
strands can be combined together in a run of a protocol including some
adversary behaviour. 

Let  be a set of messages.
\begin{definition}[Strand Space]
  A {\em directed term} is a pair denoted by  (for  a
  message ) where  is a direction with 
  representing transmission and  reception.  A trace is an element
  of , the set of infinite sequences of directed terms.

  \NI A {\em strand space} is a set  equipped with a trace mapping
   and its elements are called {\em
    strands}.
\end{definition}
\NI If  is a strand in some strand space  then its
 member denotes the  transmission or
reception event in .  Formally, we interpret this as the pair
, which we call a \emph{node} on the strand .  

We write  when, for some  and ,  and
, i.e.~ is the node immediately following  on the
strand .  We write  for the message sent or received in the
directed term of .  That is, if , and  is a
transmission  or reception  of message , then .
We occasionally write  for the message together with
its direction.  We write  when for some ,  and .  Thus,  could receive its message directly
from .  

\smallskip

But how can strands be combined together in order to represent
executions of a protocol? This is precisely captured by the notion of
{\em bundle} for a strand space :
\begin{definition}[Bundle] 
A finite acyclic directed graph
   is a \emph{bundle}
  for  if
  \begin{enumerate}

  \item  is a set of strand nodes in  such that if
     and , then ;
    
  \item  where
  \begin{enumerate}
    \item  is the restriction of  to
    nodes in ;
    \item ; and
    \item for any reception node , there is exactly
    one transmission node  such that
    .
  \end{enumerate}

  \end{enumerate}
   iff there is a path using arrows
   from  to  in
  .
\end{definition}
A \emph{bundle} is a causally well-founded graph -- essentially, a
Lamport diagram -- built from strands and transmission edges.  The
relation  is a well-founded partial order, meaning
that the \emph{bundle induction} principle holds, that every non-empty
set of nodes of  contains -minimal members.

The notions of strand and bundle, and the principle of bundle
induction, are the essential ingredients in the strand space model.
Choices -- such as what operations the adversary strands offer, or what additional
closure properties bundles may satisfy -- can vary to model different
problems concerning cryptographic protocols or distributed
communication more generally.

\smallskip

\NI {\bf Example.}  We briefly introduce an example in order to
clarify the concepts introduced above. Let  be composed by the
following strands:
  \begin{center}
    (1) \quad\qquad (2) \quad\qquad (3) \quad\qquad (4)
    \quad\qquad
    (5) 
  \end{center}
  where
  {\small
  \begin{center}
    \begin{tabular}{llll}
            &
          \\
       &
       \\
       &
       \\
            &
       &
       &
       \\
       &
      
    \end{tabular}
  \end{center}
}
  Below, we report two possible executions in the strand space 
  (for clarity, we label  with the corresponding message):\
  C::=&\phantom{{}\mid\quad{}}\Sigma_i\,\interact{\rho_1}{\rho_2}{op_i}{\tilde
    M_i}\pfx C_i\mid\quad \INACT\qquad&\qquad M::= &
  \phantom{{}\mid\quad{}}v\mid \msgbox{\tilde
    M}{\rho_1\rho_2} 
  \Did{C-Com}\
  &\
  \Rule
  {}
  {
    \Sigma_i\,\interact{\rho_1}{\rho_2}{op_i}{\tilde M_i}\pfx C_i
    \quad\lts{(\rho_1,\rho_2,\op{op_i},\tilde M)}\quad
    C_i
  }

  1.\quad &
  \interact{\mathsf{C}}{\mathsf{S}}{\texttt{req}}{\mathsf{prod}}\pfx\
  \interact{\mathsf{S}}{\mathsf{C}}{\texttt{reply}}{\mathsf{quote}}\pfx\\
  2.\quad & (\quad\interact{\mathsf{C}}{\mathsf{S}}{\texttt{ok}}
  {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx\
  \interact{\mathsf{S}}{\mathsf{B}}{\texttt{pay}}
  {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx
  (\quad\interact{\mathsf{B}}{\mathsf{S}}{\texttt{okcf}}
  {\msgbox{\mathsf{receipt}}{\mathsf{B}\mathsf{C}}}\pfx\\
  3.\quad & 
  \phantom{
    (\quad\interact{\mathsf{C}}{\mathsf{S}}{\texttt{ok}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx\
    \interact{\mathsf{S}}{\mathsf{B}}{\texttt{pay}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx
    (\quad
  }
  \interact{\mathsf{S}}{\mathsf{C}}{\texttt{rcpt}}
  {\msgbox{\mathsf{receipt}}{\mathsf{B}\mathsf{C}}}\\
  4.\quad & 
  \phantom{
    (\quad\interact{\mathsf{C}}{\mathsf{S}}{\texttt{ok}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx\
    \interact{\mathsf{S}}{\mathsf{B}}{\texttt{pay}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx
    (\quad
  }
  \quad\qquad\qquad+\\
  5.\quad & 
  \phantom{
    (\quad\interact{\mathsf{C}}{\mathsf{S}}{\texttt{ok}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx\
    \interact{\mathsf{S}}{\mathsf{B}}{\texttt{pay}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx
    (\quad
  }
  \interact{\mathsf{B}}{\mathsf{S}}{\texttt{nopaycf}}{}\pfx\\
  6.\quad & 
  \phantom{
    (\quad\interact{\mathsf{C}}{\mathsf{S}}{\texttt{ok}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx\
    \interact{\mathsf{S}}{\mathsf{B}}{\texttt{pay}}
    {\msgbox{\mathsf{card}}{\mathsf{C}\mathsf{B}}}\pfx
    (\quad
  }
  \interact{\mathsf{S}}{\mathsf{C}}{\texttt{nopay}}{}\quad)\\
  7.\quad & \qquad\qquad\qquad\qquad+\\
  8.\quad & \phantom{(\quad}
  \interact{\mathsf{C}}{\mathsf{S}}{\texttt{refuse}}{\mathsf{reason}})
\semproves{} C{ \{(\mathcal B_1,\who_1),\ldots,(\mathcal
  B_i,\who_i)\}}
  \begin{array}{rl}
    \Did{ABS-Com}\ 
    &
    \Rule
    {
      \begin{array}{l}
        \forall i\pfx\semproves{}{C_i}{\{(\mathcal B_{i1},\who_{i1}),\ldots,(\mathcal B_{ij_i},\who_{ij_i})\}}
      \end{array}
    }
    {
      \semproves{}
      {\Sigma_i\,\interact{\rho_1}{\rho_2}{op_i}{\tilde M_i}\pfx C_i}
      {
        \left(
          \begin{array}{c}
            \bigcup_i \{(\mathcal B_{ij_i},\who_{ij_i})\}_{j_i}[\rho_1,\rho_2,\op{op}_i(\tilde M_i)]\\
          \end{array}
        \right)
      }
    }
  \end{array}

  \begin{array}{rl}
  \Did{ABS-Zero}\ 
  &
  \Rule
  {
    \op e\text{ fresh}
  }
  {
    \semproves{\emptyset}{\INACT}{(\{\op e^\rho\}_\rho,\lambda \rho\pfx\op e^\rho)}
  }
  \end{array}

  (\mathcal B,\who)[\mu]\ = \
  (\quad
  (
  \mathcal N\cup\{n_i\}_i,
  \mathcal E\cup\{n_i\Rightarrow \who(\rho_i)\}_{i}\cup\{n_1\rightarrow n_2\},
  \preceq'
  ),\quad
  \who[\rho_i\mapsto n_i\Rightarrow \who(\rho_i)]_i
  \quad)
5mm]
    \begin{tabular}{lll}
      (ii)\quad 
      \begin{diagram}
        \mathsf{C} &
        \ \ldots\text{as in (i)}\ldots\ &
        \mathsf{S} &
        \ \ldots\text{as in (i)}\ldots\ &
        \mathsf{B}
        \\\\\\
        \dImplies&&\dImplies&&\dImplies\\\\\\
        \bullet&\lTo^{\texttt{nopay}\langle\rangle}
        &\bullet&\lTo^{\texttt{nopaycf}\langle\rangle}
        &\ast
      \end{diagram}    
      \quad\qquad&\quad\qquad
      (iii)\quad
      \begin{diagram}
        \mathsf{C} & \rTo^{\texttt{req}\langle\texttt{prod}\rangle}        & \mathsf{S} \\\\\\
        \dImplies      &        &  \dImplies            &                 &   \\
        \bullet        & \lTo^{\texttt{reply}\langle\mathsf{quote}\rangle}          & \bullet        \\\\\\
        \dImplies      &        &  \dImplies            &                 &   \\
        \ast & \rTo^{\texttt{refuse}\langle\mathsf{reason}\rangle} & \bullet
      \end{diagram}    
    \end{tabular}
    \caption{Bundles for the Buyer-Seller protocol}
    \label{fig:exabs}
 \end{figure}
 The nodes marked with  are those points where there is a
 possibility of branching i.e.  bundle (ii) is identical to (i) up to
 its  while (iii) is identical to (i) and (ii) up to its
 . Note that (iii) only involves roles  and .

\smallskip

\smallskip

\NI In the sequel, let  be defined
as follows: 

Intuitively, the operation above is inverse to  i.e. removes the first communication from a bundle (if
equal to , undefined otherwise). We can then conclude this
section with a result that relates the LTS semantics to the bundle
semantics. 
\begin{theorem}\label{theorem}
  Let  be a choreography. Then, 
  \begin{enumerate}

  \item if  then there exists a bundle  in
     such that
     for ;

  \item if  is defined and  then there exists  such that .

  \end{enumerate}
\end{theorem} 



\section{An execution model for Cryptoprotocols}
\label{sec:cryptoprotocols}


Cryptographic protocols are modelled by strand spaces where the set of
messages  is more general. Formally, crypto-level messages, denoted
by the syntactic category  have the following syntax:

Above, the value  ranges over the disjoint union of infinite sets
of nonces (denoted by ), atomic keys (denoted by ) and other
basic values.  We will write a sequence of messages in the form
. A node of a protocol  is
\emph{regular} if it lies on a strand of , not on an adversary
strand.

\begin{definition}[Deliver-once] Suppose that  is a set of
  messages, and  is a bundle.   \emph{delivers messages
    in}  \emph{only once} if  there exists an injective
  function , where
\begin{itemize}
  \item  is the set of regular nodes  in  such that a
    member of  is received on , and
  \item  is the set of regular nodes  in  such that a
    member of  is transmitted on .
  \end{itemize} 
When  is a family of sets indexed by , we
  say that  is \emph{deliver-once} for  when
   delivers messages in each  only once.
\end{definition} 
We typically apply this definition when  is a set of values that
will be generated freshly, and  is a set of messages of
particular forms containing one such value  ( in the
example below).

\paragraph{Cryptoprotocol Example.} The Buyer-Seller cryptoprotocol
implements the choreography example of Section~\ref{sec:choreography}.
It provides parametric strands that define the behaviors of the
principals as they send and receive encrypted messages to provide
security services for the behaviors in the choreography.  The central
idea is that the first few messages use public encryption keys and
nonces to establish symmetric keys.  The remaining messages then use
the keys in a straightforward way.  To establish a key between  and
,  sends a message containing a nonce, encrypted with 's
public key.   returns a message encrypted with 's public key.
It contains 's nonce as well as a fresh symmetric key to be used
for this session.  We use different syntactic tags in each encrypted
unit which correspond to the 's in the choreography (denoted
by the typewriter font \texttt{op}).  At this level, the tags ensure
that no unit can be confused with any other (this is the reason why
the 's are all distinct at choreography level).  The key exchange phase takes the form shown in
Fig.~\ref{fig:key:exchange}.
\begin{figure}
  \centering
  \begin{diagram}[h=3mm,w=8mm]
C & \rTo{m_1\cons m_2} & \qquad & \rTo{m_1\cons x} & S &&&& \\
        \dStrNext &  & &  & \dStrNext & & & & \\
        &&&& \bullet & \rTo{m_3\cons x}       & \qquad &\rTo{m_3\cons m_2} & B\\
        &&&& \dStrNext & & & & \dStrNext\\
        &&&& \bullet & \lTo{m_4\cons y}&\qquad&\lTo{m_4\cons
          m_5}&\bullet \\
        &&&& \dStrNext &&&& \\ 
        \bullet& \lTo{m_6\cons m_5} &\qquad&\lTo{m_6\cons y} & \bullet
        &&&& \\ 
        \dStrNext &&&& \dStrNext &&&& \dStrNext \\
        \null &&&& \null &&&& \null 
  \end{diagram}
  \begin{tabular}[c]{l@{\qquad\qquad}r}
     &
      \\ 
     &
      \\ 
     & 
    
  \end{tabular}
  \caption{Key exchange phase}
  \label{fig:key:exchange}
\end{figure}
Each participant leaves the key exchange phase knowing that 
are shared among , and that two symmetric keys are to be used
for encryption in the next phase.  For instance,  knows to use
 to communicate with the seller in the ensuing exchange, and
to use  to communicate with the bank.  

In the ensuing stage, the participants use these keys to transfer the
payloads amongst themselves.  Their exchange---in the successful case,
in which the transaction completes---takes the form shown in
Fig.~\ref{fig:payloads}.
\begin{figure}[th]
  \centering
    \begin{diagram}[h=3mm,w=8mm]
C & \rTo{p_1} & \qquad & \rTo{p_1} & S &&&& \\
      \dStrNext &  & &  & \dStrNext & & & & \\
      \bullet & \lTo{p_2} & \qquad & \lTo{p_2} & \bullet &&&& \\
      \dStrNext &  & &  & \dStrNext & & & & \\
      \ast & \rTo{p_3} & \qquad & \rTo{p_3} & \bullet &&&& \\
      \dStrNext &  & &  & \dStrNext & & & & \\
      &&&& \bullet & \rTo{p_4}       & \qquad &\rTo{p_4} & B\\
      &&&& \dStrNext & & & & \dStrNext\\
      &&&& \bullet & \lTo{p_5}&\qquad&\lTo{p_5[p_6/y]} & \ast \\
      &&&& \dStrNext &&&& \\
      \bullet& \lTo{p_6} &\qquad&\lTo{y} & \bullet
      &&&& 
  \end{diagram}
  \ \\
  \ \\
  \ \\
  \begin{tabular}[c]{l@{\qquad\qquad}r}
     &
      \\ 
     &
      \\ 
     & 
    
  \end{tabular}
  \caption{Payload exchange phase}
  \label{fig:payloads}
\end{figure}
However,  and  each have an opportunity to prevent the
exchange from completing, at the nodes marked .  If 
transmits  instead of , then 
must terminate the exchange before contacting .  If  transmits
 instead
of , then  and  must terminate the transaction.

Let us assume that the participants of a run use their private
decryption keys only in accordance with this protocol, and that the
nonces  and keys  are in fact freshly
chosen and unguessable.  On this assumption, there are essentially
only three possible executions, if we consider only those of minimal
size, given that a role completed.  When  completes normally, then
the other participants have completed normally with matching
parameters.  When  completes with a client refusal, then  has
refused and  has had a matching key exchange phase but no more.
When  completes with a  message, then  has
refused to pay, and  has been informed of this.  This analysis
indicates that the protocol appears to achieve its goals.  Indeed, we
have confirmed this with the tool \textsc{cpsa}, a Cryptographic
Protocol Shapes Analyzer~\cite{DoghmiGuttmanThayer07}, which
enumerates the minimal, essentially different executions of the
protocol.  We can then check the assertions we have just made by
inspecting those executions.  
 



\section{Abstraction and Correctness} A partial function  over
messages is an \emph{abstraction map} if (1)  (if defined)
contains no cryptographic operators, nonces nor keys, and (2) the
parameters in  (if defined) always appear in .

For instance,  could map  to
 in our Buyer-Seller
example.  The result has no cryptography and no nonces, and the tags
 and  appear in the argument.  

We say that an abstract strand  is an \emph{image} of a
cryptographic strand  if, ignoring transmissions or receptions on
, for which  is undefined, for each transmission or
reception node  on , its message  is
, where  is the corresponding transmission or
reception node (resp) on .  That is,  yielding the trace
of , when mapped through the trace of  restricted to the
domain of .

Suppose that a concrete strand  has its first  nodes in a
concrete bundle , but  is undefined for the messages on
these nodes.  We then say that  is \emph{abstractly vacuous in}
.  In the opposite case, when some node  of  is in
 and  is well-defined, we say that  is
\emph{abstractly non-vacuous in} .

An abstract bundle  is an \emph{image} of a cryptographic bundle
 if (1) there is a bijection  between the abstractly
non-vacuous regular strands  of  and the regular strands
 of ; (2)  is always an image of ; and (3)
the transmission relation  is formed by connecting
nodes of  such that  implies
, for some concrete nodes of which  are
images.  See~\cite{Guttman09a} for a related notion of protocol
transformation, and~\cite{MaffeiEtAl07} for an approach to protocol
verification via abstraction functions.

Suppose that  is a concrete bundle and  is a
family of sub-graphs of  that partitions the regular nodes of
.  We say that  \emph{separates} 
\emph{into components} when each  is a bundle on its own.

\begin{definition}[Faithfulness] \label{def:faithful}
Cryptoprotocol  is \emph{faithful to} choreography  if there
is an abstraction function  such that:
\begin{enumerate}
  \item Every  is an image of some bundle 
  of ;\label{clause:fth:upward:cover}
  \item If  is a bundle of , then some family
   separates  into components.  Moreover, each
  image  of any  is an initial sub-bundle of
  , for some  and some substitution
  .\label{clause:fth:downward:separate}
\end{enumerate}
If  is a family of sets of messages, then  is
\emph{faithful to}  \emph{assuming the deliver-once property for}
 if the above holds for bundles of  that are
deliver-once for .
\end{definition}

\smallskip

\NI {\bf Faithfulness in the Buyer-Seller protocol.} We use the
protocol analysis tool \textsc{cpsa}~\cite{DoghmiGuttmanThayer07} as
part of a proof that the protocol of Fig.~\ref{fig:key:exchange} and
Fig.~\ref{fig:payloads} is faithful to the choreography in
Fig.~\ref{fig:exabs}.  There are three stages:
\begin{enumerate}
  \item \textsc{cpsa} determines the minimal, essentially different
  executions that are possible, given that any one party has had a
  complete run.  

  These are the expected success execution  and failure
  execution , modulo the fact that a party never
  knows whether its last message was successfully delivered, if its
  last action is a transmission.  In particular, the active parties
  agree on all parameters to the session.
  \item Based on this \textsc{cpsa} output, inspection shows that
  Def.~\ref{def:faithful}, Clause~\ref{clause:fth:upward:cover} is
  satisfied:  Any run  is the abstraction of some
  concrete bundle .
  \item Because  are the only minimal
  forms of execution, every larger execution  is a (possibly
  non-disjoint) union of executions of these forms.  That is, there is
  a family of maps , where each  maps either 
  or  to some subset of the regular nodes of .
  Moreover, each regular node  is the image of some node
  in , or  under at least one of the
  .

  However, each pair of strands agrees on a pair of freshly chosen
  values, where each of them has chosen one of the values.  This
  forces the range of  and  either to coincide or be
  disjoint.  Hence Clause~\ref{clause:fth:downward:separate} is
  satisfied when we define the family  by saying that
  two nodes belong to the same  if they are both in the range
  of any one .    
\end{enumerate}






\section{Concluding Remarks}
We have introduced two execution models, one for choreography
(assuming no compromised participants) and one for cryptoprotocols
with deliver-once assumptions.  The abstract bundle semantics gives a
set of bundles representing all the possible runs of the protocol
described by a choreography.  We have sketched a form of argument for
proving that a cryptoprotocol is faithful to the ABS of a
choreography.

In \cite{CG09b}, we studied an abstract semantics for the choreography
language presented here where roles can belong to compromised
principals. The ideas of abstraction have yet to be extended to the
compromised case and to a choreography language with infinite
states. The work by Bhargavan et al. in \cite{BhargavanEtAl09, CDFBL08} is
closely related to ours: they provide a compiler for generating ML
code that can then be type-checked for verifying its security
property. Their notion of faithfulness is guaranteed for the
well-typed code generated from the source choreography.

In future work, we aim at developing systematic techniques for proving
that certain transformations preserve all of the goals of a protocol,
while achieving additional goals~\cite{Guttman09a}.







\label{sect:bib}
\bibliographystyle{plain}
\bibliography{session}



\end{document}
