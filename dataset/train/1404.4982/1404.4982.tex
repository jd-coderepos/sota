 \documentclass{llncs}
\pagestyle{headings}
\usepackage{graphicx}
\usepackage{amssymb}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{amsmath}

\newcommand{\la}{\ensuremath{ \mathcal{L}}}
\newcommand{\dfs}{\ensuremath{dfs}}


\usepackage[usenames,dvipsnames,table]{xcolor}
\newcommand{\sd}[1]{{#1}}
\newcommand{\sdm}[1]{\marginpar{\color{Mahogany}{#1}}}
\newcommand{\ngr}[1]{{\color{SeaGreen}#1}}
\newcommand{\ngrc}[1]{\marginpar{\color{SeaGreen}{#1}}}
\newcommand{\mbt}[1]{{\color{NavyBlue}#1}}
\newcommand{\mbtc}[1]{\marginpar{\color{NavyBlue}{#1}}}
\usepackage{todonotes}

\newcommand{\ceil}[1]{\left \lceil #1 \right \rceil}
\newcommand{\floor}[1]{\left \lfloor #1 \right \rfloor}
\newcommand{\abs}[1]{\left | #1 \right |}

\newcommand{\drop}[1]{}

\newtheorem*{warmup}{Warm-up}




\begin{document}


\title{Dynamic and Multi-functional Labeling Schemes}



\author{S\o ren Dahlgaard, Mathias B\ae k Tejs Knudsen and Noy Rotbart }

\institute{
 Department of Computer Science, University of Copenhagen\\
  Universitetsparken 5, 2100 Copenhagen\\
  \texttt{\{soerend,makn,noyro\}@di.ku.dk} }

\maketitle

\begin{abstract}
We investigate labeling schemes supporting  adjacency, ancestry, sibling,
and connectivity queries  in forests. 
In the course of more than 20 years, the existence of   labeling schemes supporting each of these  functions was proven, with the most recent being ancestry [Fraigniaud and Korman, STOC '10].
Several multi-functional labeling schemes also enjoy lower or upper bounds of
 or  respectively.
Notably an upper bound of  for adjacency+siblings
and a lower bound of  for each of the functions siblings, ancestry, and
connectivity [Alstrup et al., SODA '03].
We improve the constants hidden in the -notation. In particular we show a
 lower bound for connectivity+ancestry 
and connectivity+siblings, as well as an upper bound of
 for connectivity+adjacency+siblings
by altering existing methods.

In the context of dynamic labeling schemes it is known that
ancestry requires  bits [Cohen, et~al.~PODS '02]. 
In contrast, we show upper and lower bounds on the label size for adjacency, siblings, and
connectivity of  bits, and   to support all three functions.
There exist efficient adjacency labeling schemes for planar, bounded treewidth, bounded arboricity and interval graphs.
In a dynamic setting, we show a lower bound of   for each of those families.
\end{abstract}

\section{Introduction}\label{sec:intro}

A labeling scheme is a  method of distributing the information about the
structure of a graph among its vertices by assigning short \emph{labels},
such that a selected function on pairs of vertices can be computed using only their labels.
The concept  was introduced in a restricted manner by Bruer and Folkman~\cite{Breuer67}, revisited by Kannan, Naor and Rudich~\cite{Kannan92},
and explored by a wealth of subsequent work~\cite{Alstrup02,Alstrup05,Korman10,alstrup2013near,Thorup01,Peleg00}.

Labeling schemes for trees have been studied extensively in the literature due
to their practical applications in improving the performance of XML search
engines. Indeed, XML documents can be viewed as labeled forests, and typical
queries over the documents amount to testing classic properties such as
adjacency, ancestry, siblings and connectivity  between such labeled tree nodes
\cite{wu2004prime}. In their seminal paper, Kannan et. al.~\cite{Kannan92}
introduced labeling schemes using at most  \footnote{Throughout this
paper we let  unless stated otherwise.} bits
for each of the functions adjacency, siblings  and ancestry. Improving
these results have been motivated heavily by the fact that a small improvement
of the label size may contribute significantly to the performance of XML search
engines. Alstrup, Bille and Rauhe~\cite{Alstrup05} established a lower bound of
 for the functions siblings, connectivity and ancestry
along with a matching upper bound for the first two. \sd{For adjacency, a  labeling scheme was presented in \cite{Alstrup02}.} A   labeling scheme for ancestry was established only recently by
Fraigniaud and Korman~\cite{Korman10}.

In most settings, it is the case that the \sd{structure of the graph to be
labeled}\drop{data structure} is not known in advance.
In contrast to the \emph{static} setting described above, a \emph{dynamic}
labeling scheme typically receives the tree as an online sequence of
\sd{topological events}\drop{addition of leaves}, with a natural extension
that includes  removal of
leaves. Cohen, Kaplan and Milo~\cite{cohen2010labeling} considered
\emph{dynamic labeling schemes} where the  encoder receives   leaf
insertions and assigns unique   labels that must remain unchanged throughout
the labeling process. In this context, they showed  a tight bound of
 bits for any dynamic ancestry labeling scheme\drop{\footnote{From
hereon, the lower bound  is referred as Cohen's  bound.}}. We stress the
importance of their lower bound by showing that it extends to  routing, NCA,
and distance as well. In light of this lower bound, Korman, Peleg and
Rodeh~\cite{korman2004labeling} introduced  dynamic labeling schemes, where
node re-label is permitted and performed by message passing. In this model they
obtain a compact labeling scheme for ancestry, while keeping the number of
messages small. Additional results in this setting include conversion methods
for static labeling schemes~\cite{korman2004labeling,korman2007general}, as
well as specialized distance~\cite{korman2007general,korman2007labeling} and
routing~\cite{korman2008improved,korman2009compact} labeling schemes.
See~\cite{Rotbart14} for experimental evaluation.

Considering the static setting, a natural question is to determine the label
size required to support some, or all, of the functions. Simply concatenating
the labels mentioned yield a  label size, which is clearly
undesired. Labeling schemes supporting multiple functions (or multi-functional
labeling schemes) were previously studied in \cite{Alstrup05}, showing an upper
bound of  bits for combined adjacency and sibling
queries. \sd{We observe, that their scheme can be combined with the ideas of
\cite{Alstrup02} to produce a  labeling scheme for
adjacency and siblings.}
\drop{We show that most labeling schemes can be altered to also support
connectivity queries by adding an extra  bits.
 Thm.~\ref{thm:static-combo-lb} shows that such a labeling scheme requires at
 least  bits -- even if it supports just connectivity
 and sibling/ancestry queries.}

See Table~\ref{table:complexities} for a summary of labeling schemes for
forests including the results of this paper.

\begin {table}[h]
	\begin{center}
	    \begin{tabular}{ | l | l | l | l | }
		    \hline
		   \textbf{Function } & \textbf{Static Label Size} & \textbf{Static Lower Bound}  & \textbf{Dynamic} \\ \hline\hline
		   Adjacency  	&~\cite{Alstrup02}  &  & {\color{blue} ~(Th.~\ref{thm:simple-dyn}}) \\ \hline
		   Connectivity  	&~\cite{Alstrup05} & ~\cite{Alstrup05}  &  {\color{blue} ~(Th.~\ref{thm:simple-dyn}}) \\ \hline
		   Sibling  		&~\cite{lewenstein2013succinct} & ~\cite{Alstrup05}  & {\color{blue} ~(Th.~\ref{thm:simple-dyn}}) \\ \hline
		   Ancestry   	&~\cite{Korman10} & ~\cite{Alstrup05} & ~\cite{cohen2010labeling} \\ \hline \hline
		  AD/S		& {\color{blue}  ~(Cor.~\ref{cor:adj_sib_static})}& 	~\cite{Alstrup05}& {\color{blue} ~(Th.~\ref{thm:simple-dyn})} \\ \hline
		   C/S  		& {\color{blue} ~(Th.~\ref{thm:static-con-alter-ub})} & ~(Th.~\ref{thm:static-combo-lb}) & {\color{blue} ~(Th.~\ref{thm:combo_dyn})} \\ \hline
		   C/AN   		&{\color{blue} ~(Th.~\ref{thm:static-con-alter-ub})} & {\color{blue} ~(Th.~\ref{thm:con-anc})} &  ~\cite{cohen2010labeling} \\ \hline
		   C/AD/S   	& {\color{blue} ~(Cor.~\ref{cor:adj_sib_static})} & {\color{blue} ~(Th.~\ref{thm:static-combo-lb})} & {\color{blue} ~(Th.~\ref{thm:combo_dyn})} \\ \hline	\hline
		   Routing   	&~\cite{Thorup01}   &~\cite{Alstrup05} & {\color{blue} ~(Sec.~\ref{Sec:Dynamic})}  \\  \hline
		   NCA   		&~\cite{alstrup2013near}  & ~\cite{alstrup2013near}  &  {\color{blue} ~(Sec.~\ref{Sec:Dynamic})} \\ \hline
		    Distance	& ~\cite{Peleg00}  & ~\cite{Peleg00}  & {\color{blue} ~(Sec.~\ref{Sec:Dynamic})} \\  \hline\hline
		    Sibling*  		&  &   &  \\ \hline
		   Connectivity*  	& &   &  \\ \hline
		    C/S*  	& {\color{blue} ~(Th.~\ref{thm:static-con-alter-ub})} & {\color{blue} ~(Th.~\ref{thm:con_sib_dyn_lb})}  &  \\ \hline
	    \end{tabular}
	 \end{center}
	 	 	\caption{Upper and lower  label sizes  for labeling  trees with  nodes (excluding additive constants).
			 Routing  is reported in the designer-port model~\cite{Fraigniaud01} and NCA with no pre-existing labels~\cite{alstrup2013near},
			 functions marked with * denote non-unique labeling schemes, and bounds without a reference are folklore.
			 Dynamic labeling schemes are all tight.}
	\label{table:complexities}
\end {table}

\subsection{Our contribution}
We first \sd{observe} that for \sd{the dynamic setting, we can achieve efficient
labeling schemes for the functions adjacency, sibling, and connectivity
without the need of relabeling.}
\drop{the functions adjacency, sibling and connectivity no
relabeling is required to achieve efficient dynamic labeling schemes.}
More precisely, we observe that the original  adjacency labeling
scheme due to  Kannan et. al.~\cite{Kannan92} is in fact suitable for the
dynamic setting. Moreover, the original labeling scheme also supports sibling
queries and a slightly modified scheme is shown to work for connectivity. We
also present simple families of insertion sequences for which labels of size
 are required, showing that in the dynamic setting the original
labeling schemes are in fact optimal. The result is in contrast to the static
case, where adjacency labels requires strictly fewer bits than both sibling and
connectivity. The labeling schemes also reveal an exponential gap between
ancestry and  the functions mentioned for the dynamic setting. In
Section~\ref{sec-other-graphs} we show a construction of simple lower bounds of
 for adjacency labeling schemes on various important graph
families.

In the context of multi-functional labeling schemes, we show the following
results. First, we show that  bits are necessary and sufficient for
any dynamic labeling scheme supporting adjacency and connectivity. Turning to
static labeling schemes, we show a tight  bound for
any unique labeling scheme supporting both connectivity and siblings/ancestry.
\sd{For the upper bound, we prove the more general result, that}
\drop{In order to show the upper bound, we prove that} any labeling scheme of size
 growing faster than  can be altered to support connectivity as well by adding at most  bits.
\sd{Coupled with our observation, that \cite{Alstrup02} and \cite{Alstrup05}
provide a  scheme for adjacency and sibling, this
provides a  labeling scheme for all the functions
adjacency, sibling and connectivity.}
\section{Preliminaries}
A binary string  is a member of the set , and we denote its size by , and the concatenation of two binary strings  by .

A \emph{label assignment}  for a tree  is a mapping of each 
	to a bit  string , called  the \emph{label} of .
Given  a tree  rooted in  with  nodes, and let .
	The function  returns \textbf{true} if and only if  and  are adjacent in ,
	   returns \textbf{true} if and only if  is on the path ,
	   returns \textbf{true} if and only if  and  have the same parent in \footnote{By this definition, a node is a sibling to itself.},
	   returns an identifier  of the edge connected to   on the path to  ,
	   returns the label of the first node in common on the paths  and ,
	and  returns the length of the path from  to .
	The functions mentioned previously are also defined for forests.
	Given a rooted forest  with  nodes, for any two nodes  in  the function   returns  \textbf{true}  if  and  are in the same tree in .


	Given a function  defined on sets of vertices,
	 an  \emph{ f-labeling scheme} for a family of graphs  consists   of  an encoder  and decoder.
	The  \emph{encoder}  is an algorithm that receives a graph  as input and  computes a label assignment . If the encoder receives  as a sequence of topological events\footnote{Cohen et al. defines such a sequence as  a set of insertion of nodes into an initially empty tree, where the root is inserted first,and all other insertions are of the form ``insert node  as a child of node ''.  We extend it to support ``remove leaf '', where the root may never be deleted. } the labeling scheme is \emph{dynamic}.
	 The \emph{decoder}  is an algorithm  that receives any two labels   and  computes the query , such that  . The \emph{size} of the labeling scheme is the maximum label size.
	 If for all graphs  , the label assignment   is an injective mapping, i.e. for all distinct , , we say that the labeling scheme assigns \emph{unique} labels. Unless stated otherwise, the labeling schemes presented are assumed to assign unique labels. Moreover, we allow the decoder to know the label size.

	 Let  be a family of graphs, a graph , and suppose that an f-labeling scheme assigns a node  the label .
	  If  does not appear in any of the label assignments for the other graphs in , we say that the label is \emph{distinct} for the labeling scheme over .
All labeling schemes constructed in this paper require  encoding time and  decoding time under the assumption of a  word size RAM model. See~\cite{Thorup01} for additional details.

\section{Dynamic labeling schemes}~\label{Sec:Dynamic}
We first note that the lower bound for ancestry due to Cohen, et.~al.~also
holds for NCA, since the labels computed by an NCA labeling scheme can decide ancestry:
Given the labels   of two nodes  in the tree ,  return
true if  is equal to the label returned by the original NCA decoder, and
false otherwise.
Similarly, suppose a labeling scheme for routing\footnote{Routing in the
designer port model~\cite{Fraigniaud01}.} assigns  as the port number on the
path to the root. Given    as before, return true if
 and .
\drop{If there were to exist a dynamic labeling scheme for routing or NCA with
size , the labels produced would be sufficient to determine ancestry,
in contrast to Cohen's bound.}
Peleg~\cite{Peleg05} proved that any  distance labeling scheme can be
converted to  labeling scheme for NCA by  attaching the
depth of any node. Since the depth of a node inserted can not change in our
dynamic setting, we conclude that any lower
bound for ancestry also applies to distance, routing, and NCA.

\subsection{ Upper Bounds} \label{sec:upper-bounds-dynamic}
The following (static) adjacency labeling scheme was introduced by Kannan et al.~\cite{Kannan92}.
Consider an arbitrary rooted tree  with  nodes.
Enumerate the nodes in the tree with the numbers  through , and let,
for each node ,  be the number associated with . Let  be the parent of a node  in the tree.
The label of  is , and the root is labeled
. Given the labels  of two nodes  and , observe
that the two nodes are adjacent if and only if either  or
 but not both, so that the root is not adjacent to
itself.

This is also  a dynamic labeling scheme for adjacency with equal label size.
 Moreover, it is also both a static and dynamic labeling scheme for sibling,
in which case, the decoder must check if .
 A labeling scheme for connectivity can be constructed by storing the
 component number rather than the parent id. After  insertions, each label contains two parts, each in the range
 .  Therefore, the label size required is .

The labeling schemes suggested extend to larger families of graphs.
In particular, the dynamic connectivity labeling scheme  holds  for the family of all graphs.
The family of -bounded degree graphs enjoys a similar dynamic adjacency labeling scheme of size .



\subsection{ Lower Bounds}
We  show that  is in fact a tight bound for any dynamic adjacency labeling scheme for trees.
We denote  by  an  insertion sequence   of   nodes, creating  an \emph{initial  path} of length , followed by    \emph{adjacent leaves}  to node  on the path.
The family of all such insertions sequences is denoted . For illustration see Fig.~\ref{fig:AdjLowerBound}.


\begin{lemma}\label{lem:pers-anc}
Fix some dynamic labeling scheme that supports adjacency. For any ,  must contain at least  distinct labels \drop{wrt.} for this labeling scheme over .
\end{lemma}

\begin{proof}
The labels of  are set to   respectively.
Since the encoder is deterministic, and since every insertion sequence
 first  inserts nodes on the initial  path,these nodes must be labeled
. Let the labels of the adjacent leaves of such an insertion
sequence be denoted by .

			\begin{figure} [h]
				\centering
				\includegraphics[width=.3\textwidth]{adj_lb.pdf}
				\caption{Illustration of . }
				\label{fig:AdjLowerBound}
			\end{figure}


Clearly,  must be different from , as the only other labels adjacent to  are  and , which have already been used on the initial path.
 Consider now any node labeled  of  for . Assume w.l.o.g that . Such a node must be adjacent to  and
 \emph{not} to , as  is contained in the path to . Therefore we must have .
\end{proof}

Identical lower bounds exist for both sibling and connectivity, see App.~\ref{lower-simple}.
\begin{theorem}\label{thm:simple-dyn}
Any dynamic labeling scheme supporting either  adjacency, connectivity, or sibling  requires at least  bits.
\end{theorem}
\begin{proof}
According to Lem.~\ref{lem:pers-anc}, at least  distinct labels are required to label  if adjacency or
sibling requests are supported, and the same applies for   if
connectivity is supported.
\end{proof}


A natural question is whether a randomized labeling scheme could provide labels of size less than .
The next theorem, based on Theorem~3.4 in \cite{cohen2010labeling} answer this question negatively. The proof is deferred to Appendix~\ref{proof:random}.
\begin{theorem}\label{thm:random}
	For any randomized dynamic labelling scheme supporting either
	adjacency, connectivity, or sibling queries
	there exists an insertion sequence such that the expected value
	of the maximal label size is at least  bits.
\end{theorem}

\subsection{Other Graph Families}\label{sec-other-graphs}
In this section, we expand our lower bound ideas to adjacency labeling schemes for the  following families: bounded arboricity- graphs\footnote{The \emph{arboricity} of a graph   is the minimum number of edge-disjoint acyclic subgraphs whose union is .} ,  bounded degree- graphs , and  bounded treewidth- graphs .

In the context of (static) adjacency  labeling schemes,  these families  are   well studied~\cite{Kannan92,Alstrup02,gavoille2007shorter,chung1990universal,Adjiasvhili14}
In particular,  ,  and    enjoy  adjacency labeling schemes of size  \cite{gavoille2007shorter}, and  \cite{Alstrup02} respectfully.

We consider a sequence of node insertions along with all edges adjacent to them, such that an edge  may be introduced along with node  if  node  appeared prior in the sequence, and prove the following.
\begin{theorem}\label{theorem:lower-arboricity}
 Any dynamic adjacency labeling scheme for   requires  bits.
\end{theorem}
\begin{proof}
Let  be the collection of all  nonempty  subsets  of  the integers .
Since there are  such sets possible, .
For every , we denote  by  an  insertion sequence   of   nodes, creating  a path of length , followed by  a single node  connected to the nodes on the path whose number is a member of .
Such a graph has  arboricity  since it can be decomposed into an initial path and a star rooted in .
For each of the   insertion sequences, the label of  must be distinct.
We  conclude that the number of bits required for any adjacency labeling scheme
is at least  bits.
See Fig.~\ref{fig:AdjLowerBoundGraphs} for illustration. 
\end{proof}
\vspace*{-5ex}
			\begin{figure}
				\centering
				\includegraphics[width=.25\textwidth]{Line.pdf}
				\caption{Illustration of  for . The dotted lines may or may not appear in the insertion sequence depending on the element of  chosen. }
				\label{fig:AdjLowerBoundGraphs}
			\end{figure}
\vspace*{-2ex}
The construction of   implies an identical lower
bound for the family of planar graphs, as well as interval graphs. By
 considering all sets  of at most  elements instead, we get
a bound of  label size for any adjacency labeling scheme for , where  is constant.

To show a similar bound on , we prove  that the sequence of insertions creates graphs in .
For every face  in  a planar embedding  of a  planar graph , define
 to be the minimum value of , such that there is a sequence of faces
, with  the exterior face, and , and for , there is a vertex  that is both on face  and . The
radius of  is the minimum value of  such that  for all
regions  of .
\begin{lemma}\cite{bodlaender1988dynamic}\label{lemma:bodlander}
Let  be a planar graph with radius , , then  has treewidth at most .
\end{lemma}
The lemma is useful for our purposes since  the graphs in the  family of  planar graphs resulting from   have radius .
\begin{corollary}
 Any dynamic adjacency labeling scheme for , where  , requires  bits.
\end{corollary}

\section{Multi-Functional Labeling schemes}
In this section we investigate labeling schemes incorporating  two or more of the functions mentioned.
\subsection{Dynamic Multi-Functional Labeling Schemes}
A dynamic labeling scheme for answering any combination of connectivity, adjacency and sibling queries at the same time can be obtained by setting   as described in Section~\ref{sec:upper-bounds-dynamic}  which result in a  labeling scheme.

 We  now show that this upper bound is in fact is tight.
 More precisely, we show that  bits are required to answer  the combination of connectivity and adjacency.
  Let  be an insertion sequence designed as follows: First  nodes are inserted creating an \emph{initial
forest} of single node trees. Then  nodes are added as a path with root in
the th tree. At last,  adjacent \emph{path leaves} are added to the
second-to-last node on the path. For a given  we define  as the family
of all such insertion sequences. See Fig.~\ref{fig:combi_lb} for reference.
\begin{figure}[h]
    \centering
    \includegraphics[width=.6\textwidth]{combi_lb.pdf}
    \caption{Illustration of  for specific values of , , and
    .}
    \label{fig:combi_lb}
\end{figure}

\begin{lemma}\label{lem:combi_lb}
   Fix some dynamic labeling scheme that supports adjacency and connectivity requests.
    For any ,  must contain at least  distinct labels for this labeling scheme over .
\end{lemma}
The  proof of  Lem.~\ref{lem:combi_lb} is found in  App.~\ref{Lemma-combi-bi}.

\begin{theorem}\label{thm:combo_dyn}
    Any dynamic labeling scheme supporting both adjacency and connectivity
    queries requires at least  bits.
\end{theorem}
\begin{proof}
	According to Lem.~\ref{lem:combi_lb} at least
	 distinct labels
	are required to label the family . Thus a label size of at least  bits is needed by any dynamic labeling scheme.
\end{proof}

The same family of insertion sequences can be used to show a 
lower bound for any dynamic labeling scheme supporting both sibling and
connectivity queries. Furthermore, similarly to Theorem~\ref{thm:random}, the
bound holds even without the assumption that the encoder is deterministic.


\subsection{Static Multi-Functional   labeling schemes}~\label{sec:static-multi}
As seen in Thm.~\ref{thm:combo_dyn}, the requirement to support both connectivity and adjacency force an increased label size for any dynamic labeling scheme.
In this section we prove  lower and upper bounds for static labeling schemes that support those operations, both for the case where the labels are necessarily unique, and for the case that they are not. From hereon, all labeling schemes are on the family of rooted forests with at most  nodes.

\begin{theorem}\label{thm:static-con-alter-ub}
    Consider any function  of two nodes in a single tree. If there exists an
    -labeling scheme of size , where  is non-decreasing and
     for any .
    Then there exists an -labeling scheme, which also supports connectivity
    queries of size at most .
\end{theorem}
\begin{proof}
    We will consider the label  defined as
    follows. First, sort the trees of the forest according to their sizes. For the th biggest tree we set  using  bits. Since the tree has at most  nodes, we can pick the label  internally in the tree using only  bits. Finally, we need a separator, , to separate  from . We can represent this using  bits, since  uses at most  bits.

    The total label size is this  bits, which is less than
     if  for some
    constant , which holds by our assumption. Since  is a function of two nodes from
    the same tree, this altered labeling scheme can answer both queries for 
    as well as connectivity. It is now required that any label assigned has size exactly  bits, so that the decoder may correctly identify  in the bit string. For that purpose we  pad labels with less bits with sufficiently many 's.
\end{proof}

As a special case, we get a labeling scheme for connectivity and
sibling/ancestry for  and for connectivity and sibling of
 if the labels need not be unique.

The following corollary is a direct result of~\cite{Alstrup02,Alstrup05}. A
sketch of the proof is found in App.~\ref{app:adj_sib}.
\begin{corollary}\label{cor:adj_sib_static}
There exists unique labeling scheme supporting both sibling and adjacency  queries of size at most .
\end{corollary}

\subsubsection{Lower Bound}
We now show, that the upper bounds implied  by Theorem~\ref{thm:static-con-alter-ub} for labeling schemes supporting siblings and connectivity  are indeed tight for both the unique and non-unique  cases.
To that end we consider the following forests: For any integers  such that 
denote by  a forest consisting of 
components (trees), each with  \emph{sibling groups}, where each sibling
group is composed of  nodes. Note that  has at least
 but no more than  nodes.

Our proofs work as follows:
Firstly, for any two forests  and  as defined above, we
        establish an upper bound on the number of labels that can be assigned
        to both  and .
Secondly, for a carefully chosen family of forests , we  show that when labeling  at least
        a constant fraction of the labels has to be distinct from the labels of
        .
Finally,  by summing over each  we show that a sufficiently
        large number of bits are required by any labeling scheme supporting the
        desired queries.
        
Our technique is a simpler version of the boxes and groups argument of Alstrup et~al.~\cite{Alstrup05}, and generalizes to the case of two nested equivalence classes, namely connectivity and siblings. The proofs for Lem.~\ref{lem:forest-reuse} and~\ref{lem:set-reuse-bound} are in 
App.~\ref{proof:forest-reuse} and App.~\ref{proof:set-reuse-bound} respectively.

\begin{lemma}\label{lem:forest-reuse}
    Let  and  be two forests such that .
    Fix some unique labeling scheme supporting both
    connectivity and siblings, and denote the set of labels assigned to
     and  as  and  respectively.
	Then
    
\end{lemma}


\begin{lemma}\label{lem:set-reuse-bound}
    Let  be a family of forests with
    . Assume there exists a unique
    labeling scheme supporting both connectivity and siblings, and let 
    denote the set of labels assigned by such a scheme to the forest
    . Assume that the sets  have already
    been assigned. Then the number of distinct labels the encoder must
    introduce when assigning  is at least
    
\end{lemma}

We now use Lem.~\ref{lem:set-reuse-bound} to show the following
known result~\cite{Alstrup05}.

\begin{warmup}
    Any static labeling scheme for connectivity queries requires at least  bits.
\end{warmup}
\begin{proof}
    Consider the family of  forests . Since no two nodes are siblings we can use this forest
    combined with Lem.~\ref{lem:set-reuse-bound} as a lower bound for
    connectivity. Let  denote the label set assigned by an encoder for
    . We assume that the labels are assigned in the order
    . By Lem.~\ref{lem:set-reuse-bound} the number of
    distinct labels introduced when assigning  is at least
    
    It follows that labeling the  forests in the family requires at
    least  distinct labels.
\end{proof}


This idea extends to some cases of non-unique labeling schemes, as seen in
the theorem below. The proof  of Thm.~\ref{thm:con_sib_dyn_lb} is included in App.~\ref{proof:con_sib_dyn_lb}.

\begin{theorem}\label{thm:con_sib_dyn_lb}
    Any static labeling scheme supporting both connectivity and sibling queries
    requires at least  bits if the labels need not
    be unique.
\end{theorem}

\begin{theorem}\label{thm:static-combo-lb}
    Any unique static labeling scheme supporting both connectivity and sibling queries
    requires labels of size at  least  .
\end{theorem}
\begin{proof}
	Fix some integer , and assume that  is a power of .
    We consider the family of forests  \linebreak .

    Let  denote the label set assigned to  by an
        encoder. We  assign
        the labels in the order . Thus, when assigning  we have already assigned
        all label sets  with  or  and . By
        Lem.~\ref{lem:set-reuse-bound}, the number of distinct labels introduced
        when assigning  is at least
        
        This counting argument is better demonstrated in
        Fig.~\ref{fig:combo_static_lb}. In the figure, we are concerned with
        assigning the labels in . The grey boxes represent the label
        sets already assigned, and the right-side figure shows the fractions of
         that each set  at most has in common with . Observe
        that we can split the above sum into three cases as demonstrated in the
        figure: If  and  the bound
        supplied by Lem.~\ref{lem:forest-reuse} is . Otherwise,
        either  or , but not both. If , recall
        that  so the bound is . For  the bound is 
        by the same argument. Applying these rules, we see that the number of
        distinct labels introduced is at least
        
        Note that we add , as we have also subtracted  labels for the
        case when .

    By setting  we get that the encoder must introduce  distinct
    labels for each . Since we have  forests, a total
    of  labels are required for labeling the family of forests.
    Each forest consists of no more than  nodes, which concludes the proof.
\end{proof}
\vspace{-7ex}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{combo_static_lb.pdf}
    \caption{Demonstration of the label counting for .}
    \label{fig:combo_static_lb}
\end{figure}

The same proof technique is used to prove the following theorem. For completeness, the proof is presented in Appendix~\ref{proof:con-anc}.
\begin{theorem}\label{thm:con-anc}
Any unique static labeling scheme supporting both connectivity and ancestry queries
requires labels of size at least .
\end{theorem}
\section{Concluding remarks}
We have considered multi-functional labels for the functions adjacency, siblings and connectivity.
We also provided a lower bound for ancestry and connectivity.
A major open question is wether it is possible to have a label of size  supporting all of the functions.
It seems unlikely that the best known labeling scheme for ancestry~\cite{Korman10} can be combined with the ideas of this paper.

In the context of dynamic labeling schemes, if arbitrary node insertion is permitted, neither adjacency nor sibling labels are  possible. All dynamic labeling schemes also operate when removal is allowed, simply by erasing the label to be removed. Moreover, if the tree contains  not more than  nodes at any moment, it is easy to show that labels of size  2   are necessary and sufficient for each of the  functions.
  \bibliographystyle{elsarticle-num}
  \bibliography{Bibliography}
\appendix
\section{Missing proofs}
\subsection{Lower bound for  dynamic labeling schemes}\label{lower-simple}
For the function sibling we use  the same family and a slightly different argument as follows.
First, it again holds that   must be different from
, as they are the  only nodes that are siblings to .
Furthermore, in  the label  (where ) is not a sibling of
, so  must be distinct from .

Finally, for an identical  lower bound on connectivity we define
 to be an  insertion sequence   of   nodes, creating  an
\emph{initial  forest } of   single node trees, followed by  
leaves adjacent to tree . 

\subsection{Proof of Theorem~\ref{thm:random}} \label{proof:random}
\newcommand{\F}{\mathcal{F}}
We  prove the theorem for labeling schemes supporting adjacency requests.
The proof is similar for the two other types of labeling schemes.
Consider the set  consisting of 
different insertion sequences, and say that we uniformly choose an insertions
sequence .
Fix a \emph{deterministic} labeling scheme supporting adjacency requests.
Each of  has 
labels which are distinct for this labeling scheme over  (by
Lem.~\ref{lem:pers-anc}).
Say that we write  as  such that
the maximal label size of the distinct labels over  from 
is smaller than that from  if . Now consider all the labels from the
insertion sequences  which are distinct over . There are at
least  of those meaning that at least one has label size .
This means that there is a label from  which is distinct over  and
has label size . This means that the expected value of
the maximal label size of  (which is uniformly drawn from ) is at least:

Since this holds for any deterministic algorithm Yao's principle yields that
for any randomized algorithm there exists  such that the
expected value of the maximal label size is at least  on that
insertion sequence.

\subsection{Proof of Lemma~\ref{lem:combi_lb}} \label{Lemma-combi-bi}
    Let  be the labels of  and let  be the labels of the path created by the insertion sequence
    . Since the encoder is deterministic, any insertion sequence
     must assign the labels 
    and  to the first  nodes.

    Let  denote the label of the th \emph{path leaf} added as a
    part of the insertion sequence . Clearly
     is different from any  and  by the
    argument of the proof of Lem.~\ref{lem:pers-anc}.

    Consider now two different leaves labeled  and .
    If  and  the labels must be different, as they are part of the
    same insertion sequence.

    If  then by looking at ,  and  are connected.
    By looking at ,  and  are not connected. Hence
    the labels are different. The case  is symmetric.
    If  and  then by looking at ,  and 
    are adjacent. And from  we see that  and  are
    not adjacent. Hence the labels are different. The case  is symmetric.

    In conclusion no two leaves get the same label in any of .	Since 
    has  leaves this means that  contains  labels that are distinct
    for the labelling scheme over .



\subsection{Proof sketch for Corollary \ref{cor:adj_sib_static}}
\label{app:adj_sib}

It was shown in \cite{Alstrup02} how to create a labeling scheme
using a recursive cluster decomposition to support adjacency in  bits. We argue that this decomposition can be combined directly
with the -relationship scheme of \cite{Alstrup05} to create a labeling
scheme supporting both adjacency and sibling using  bits.

In this proof sketch, we assume that the reader is
familiar with the notations and definitions of \cite{Alstrup02,Alstrup05}.

For -relationship, the scheme of \cite{Alstrup05} actually works with
 bits by storing  for heavy
nodes instead of only storing  for light nodes.
The key is to change Lem.~4 in \cite{Alstrup05} to work for heavy nodes. This
is done by considering  instead of  for heavy nodes
in the proof. Since
 we can get label size  for leaves by
adding an extra flag.

The cluster decomposition used in \cite{Alstrup02} works as follows: For some
integer , the tree  is split into  clusters of size . Each
cluster has at most two boundary nodes, which are part of more than one
cluster. We can view the clusters as a macro tree, where the nodes are the
boundary nodes and the edges are the clusters. Each cluster is one of three
types (see Fig.~\ref{fig:cluster_ex}): Either it is a leaf cluster
with just one boundary node (), it is a single edge (), or it is
an internal cluster with two boundary nodes (). Note that for
-clusters, the top boundary node, , has at most one child inside the
cluster.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.4\textwidth]{clustering_ex.pdf}
    \caption{The three different types of clusters.}
    \label{fig:cluster_ex}
\end{figure}

The labeling scheme works by first labeling the macro tree with the modified
-relationship scheme, such that the label of a cluster  is denoted
. Inside each cluster the nodes are labeled, such that the label of a
node  is denoted by .

A node  of the original tree  will be labeled the following way (refer to
Fig.~\ref{fig:cluster_ex} for the node types). Note that upper boundary nodes
 are not included in the cluster -- only lower boundary nodes.
\begin{description}
    \item [Type- node in -cluster :] We set .
    \item [Type- node in -cluster :] We set .
    \item [Type- and type- nodes in -cluster :] We set
         (and identical for ).
    \item [Type  and type- nodes in -cluster :] We set
        .
\end{description}

The  parameter is a constant number of bits specifying the following:
Which cluster type is it . Which type of node is it
child of  in , type  in , type  in ,
type  in , child of  in , child of  in
, none of the above.

The proof of correctness and label size now follows by setting  and the same techniques as in \cite{Alstrup02,Alstrup05}, which is
basically checking the cases of different pairs of node types.

\subsection{Proof of Thorem~\ref{lem:forest-reuse} }  \label{proof:forest-reuse}
    Consider label sets  and  of two sibling groups from  and
     respectively for which . Clearly, we must have
    . Furthermore, no
    other   sibling group of  or  can be assigned  labels from
    , as the sibling relationship must be maintained. We can thus
    create a one-to-one matching between the sibling groups of  and
    ,
    that have labels in common (note that not all sibling groups will
    necessarily be mapped). Bounding the number of common labels thus becomes a
    problem of bounding the size of this matching.
    In order to  maintain the connectivity relation, sibling groups from one component cannot be matched to several  components. Therefore at most 
    sibling groups can be shared per component, and at most  components
    can be shared. Combining this gives the final bound of
    .


\subsection{Proof of Theorem~\ref{lem:set-reuse-bound} } \label{proof:set-reuse-bound}
    Assume that the encoder has already assigned labels to the set .
    The number of distinct labels of  is then exactly
    
    Since  this is bounded from below by
    
    Here the inequality follows from Lem.~\ref{lem:forest-reuse}
    
\subsection{Proof of Theorem
\ref{thm:con_sib_dyn_lb}}\label{proof:con_sib_dyn_lb}
The key idea is to create a family of forests, such that the non-unique case reduces to the unique case.

\begin{proof}
    Assume w.l.o.g.~that  is a power of .
    Consider the family of  forests  . Since each sibling group of
    the forest  has exactly one node, we note that no two
    nodes are siblings. Thus each label of the forest has to be unique, since
    we have assumed that a node is sibling to itself. We can thus use
    Lem.~\ref{lem:forest-reuse} as if we were in the unique case for this
    family of forests.

    Let  denote the label set assigned by an encoder for
    . We  assume that the labels are assigned in the order
    . By Lem.~\ref{lem:set-reuse-bound} the number of
    distinct labels introduced when assigning  is at least
    
    It follows that when labeling each of the  forests in the family,
    any encoder must introduce at least  distinct labels, i.e. 
    distinct labels in total.
    The family consist of forests with no more than  nodes, which
    concludes the proof.
\end{proof}


\subsection{Proof of Theorem \ref{thm:con-anc}} \label{proof:con-anc}

For integers  such that , let  be  a forest
consisting of  components consisting each  of  paths of length
 each connected to a root in the component. Each forest in  consists of at least
 but no more than  nodes.

The key idea in the proof of Thm.~\ref{thm:static-combo-lb} is the use of
Lem.~\ref{lem:forest-reuse}. Below we show  Lem.~\ref{lem:forest-reuse-con-anc}
which is is analogous to Lem.~\ref{lem:forest-reuse} which derives the proof of  Thm.~\ref{thm:con-anc} similarly.

\begin{lemma}\label{lem:forest-reuse-con-anc}
    Let  and  be two forests such that .
    Fix some unique labeling scheme supporting both
    connectivity and ancestry queries, and denote the set of labels assigned to
     and  as  and  respectively.
	Then
    
\end{lemma}
\begin{proof}
	Let  and  be the labels assigned to two paths from  and
	 respectively for which .
	The number of labels the paths have in common is at most
	.
	Furthermore,
	no other paths from  or  can reuse any labels from
	 since the ancestry relation has to be maintained. Therefore
	we can create a one-to-one matching between the paths from  and
    ,
    which have at least on label in common (note that not all sibling groups will
    necessarily be mapped).

    Bounding the number of common labels thus reduces to
    bounding the size of this matching.
    In order to  maintain the connectivity relation, paths from one
    component cannot be matched to more than one. Therefore at most 
    paths can be shared per component, and at most  components
    can be shared. Combining this gives the final bound of
    .
\end{proof}





\end{document}
