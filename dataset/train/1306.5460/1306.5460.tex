\documentclass[11pt]{article}
\usepackage{graphicx,amsmath,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{color}

\setcounter{tocdepth}{3}
\usepackage{epstopdf}
\usepackage{epsfig}
\usepackage{tikz}
\usepackage{subfig}

\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\newcommand{\perpslab}[1]{\mathrm{slab}(#1)}
\newcommand{\etal}{{\em et al.~}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{problem}[theorem]{Problem}

\newcommand{\changed}[1]{#1}
\newcommand{\ignore}[1]{}
\newcommand{\changedagain}[1]{{#1}}
\newcommand{\changeA}[1]{{#1}}
\newcommand{\changeAL}[1]{{#1}}
\newcommand{\note}[1]{{\color{red}#1}}
\newcommand{\changeS}[1]{{#1}}
\newcommand{\changeSH}[1]{{#1}}

\begin{document}

\title{ Self-Approaching Graphs}

\author{
Soroush Alamdari\thanks{Cornell University, Ithaca, USA {\tt alamdari@cs.cornell.edu}}
\and
Timothy M. Chan\thanks{Cheriton School of Computer Science, University of Waterloo, Waterloo, Canada
    {\tt \{tmchan, alubiw, vpathak\}@uwaterloo.ca}}
\and
Elyot Grant\thanks{Massachusetts Institute of Technology, Cambridge, USA {\tt elyot@mit.edu}}
\and
Anna Lubiw\footnotemark[2]\and
Vinayak Pathak\footnotemark[2]
}



\maketitle


\begin{abstract}
In this paper we introduce \emph{self-approaching}  graph drawings. A straight-line drawing of a graph is \emph{self-approaching} if, for any origin vertex  and any destination vertex , there is an -path in the graph such that,
for any point  on the path,
as a point  moves continuously along the path from the origin to , the  Euclidean distance  from  to  is always decreasing.
This is a more stringent condition than a greedy drawing (where only the distance between vertices on the path and the destination vertex must decrease), and guarantees that the drawing is a 5.33-spanner.

We study three topics:
(1) recognizing self-approaching drawings;
(2) constructing self-approaching drawings of a given graph;
(3) constructing a self-approaching Steiner network connecting a given set of points.

We show that: (1) there are efficient algorithms to test if a polygonal path is self-approaching in  and ,
but it is NP-hard to test if a given graph drawing in  has a self-approaching -path;
(2)
we can characterize the trees that have self-approaching drawings;
(3) for any given set of terminal points in the plane, we can find a linear sized network that has a self-approaching path between any ordered pair of terminals.



\end{abstract}



\section{Introduction}
A straight-line graph drawing (or ``geometric graph'') in the plane has points for vertices, and straight line segments for edges, where the weight of an edge is its Euclidean length.  The drawing need not be planar.
Rao \etal\cite{Rao:GeoRouting:2003} introduced the idea of greedy drawings.  A \emph{greedy drawing} of a graph is a straight-line drawing in which, for each origin vertex  and destination vertex , there is a neighbor of  that is closer to  than  is, i.e., there is a \emph{greedy} -path  such that the Euclidean distances  decrease as  increases.
This idea has attracted great interest in recent years (e.g. \cite{Angelini:2009,Bose:theta6:2012,Goodrich:2008,He:2011,Leighton:2010,Papadimitriou:2005}) mainly because a greedy drawing of a graph permits greedy local routing.


It is a very natural and desirable property that a path should always get closer to its destination, but there is more than one way to define this.
Although every vertex along a greedy path gets closer to the destination, the same is not true of intermediate points along edges.
See Figure~\ref{fig:greedy-vs-SA}.


\begin{figure}
\centering

\begin{tikzpicture}[scale=2.5]
\draw (0,0) -- (2, 0);
\draw (0.5, 0.866) node[left] {} -- (2,0);
\draw (0,0) -- (0.65, 1.125);
\draw (2, 0) -- (0.65, 1.125);

\fill[black] (0, 0) node[left] {} circle (0.02);
\fill[black] (2, 0) node[right] {} circle (0.02);
\fill[black] (0.65, 1.125) node[above] {} circle (0.02);

\draw (0.45, 0.78) -- (0.536, 0.73);
\draw (0.536, 0.73) -- (0.58, 0.81);
\end{tikzpicture}

\caption{As we move from  towards , distance to  first decreases (until ), then increases. However, .}
\label{fig:greedy-vs-SA}
\end{figure}



Another disadvantage of greedy paths is that the
length of a greedy path is not bounded in terms of the Euclidean distance between the endpoints.
This is another natural and desirable property for a path to have, and is captured by the
\emph{dilation} (or ``stretch factor'') of a graph drawing---the maximum, over vertices  and , of the ratio of their distance in the graph to their Euclidean distance.
The dilation factor of greedy graph drawings can be unbounded.

Icking \etal\cite{Icking:self-approachingcurves:1995} introduced a stronger notion of
 ``getting closer'' to a destination, that addresses both shortcomings of greedy paths.
A curve from  to  is \emph{self-approaching} if for any three points  appearing in that order along the curve, we have .
Icking \etal proved that a self-approaching curve has \emph{detour} at most 5.3332, where the \emph{detour} or \emph{geometric dilation} of a curve is the supremum over points  and  on the curve, of the ratio of their distance along the curve to their Euclidean distance .
This is stronger than dilation in that we consider all pairs of points, not just all pairs of vertices.

In this paper we introduce the notion of a \emph{self-approaching} graph drawing---a straight-line drawing  that contains, for every pair of vertices  and ,
a self-approaching -path and a self-approaching -path (which need not be the same).
We also explore the related notion of an \emph{increasing-chord} graph drawing, which has the stronger property that every pair of vertices is joined by a path that is self-approaching in both directions.
Rote~\cite{Rote:ICcurves:1994} proved that increasing-chord paths have geometric dilation  at most 2.094.

Our first result is a linear time algorithm to recognize a self-approaching polygonal path in the plane.
This extends to , with some slow-down---we give an algorithm that runs in time  and a lower bound of .  This is in Section~\ref{sec:testingPaths}.

We do not know the complexity of recognizing self-approaching graph drawings in the plane or higher dimensions.
One approach would be to find, for every pair of vertices  and , a self-approaching path from  to  in the graph drawing.   This problem is open in  but we show that it  is NP-hard in .  This is in Section~\ref{sec:SAPathsInGraphs}.


Next, we consider the question of constructing a self-approaching drawing for a given graph.  We give a linear time algorithm to recognize the trees that have self-approaching drawings.  See Section~\ref{sec:SADrawability}.


Finally,  we consider the problem of connecting a given set of terminal points in the plane by a network that has a self-approaching path between every pair of terminals.  We show that this can be done with a linear sized network.  See Section~\ref{sec:SAspanners}.












\section{Background}

A \emph{spanner} is a graph of bounded dilation.  Spanners have been very well-studied---see for example the book by Narasimhan and Smid~\cite{Spanners} and the survey by Eppstein~\cite{Eppstein:Spanners:2000}.
A main goal is to efficiently construct a spanner on a given set of points, with the objective of minimizing dilation while keeping
 the number or total length of edges small.  For recent results, see, e.g.,~\cite{Aronov:Spanners:2008,Giannopoulos:hard-spanners:2010}.
If Steiner vertices are allowed, their number should also be minimized, and different versions of the problem arise if we include the Steiner points in measuring the dilation, see~\cite{Ebbers:Dilation:2007}.

The \emph{detour} of a graph drawing is defined to be the supremum, over all points  of the drawing (whether at vertices, or interior to edges) of the ratio of their distance in the graph to their Euclidean distance.  Note  that if two edges cross in the drawing, then the detour is infinite.  By contrast,  a self-approaching drawing may have crossing edges, for example, any complete geometric graph is self-approaching.
Constructing a network to minimize detour has also been considered~\cite{Ebbers:detour:2006,Dumitrescu:2009}, though not as extensively as spanners.

Relevant background on greedy drawings is as follows.
Answering a conjecture of Papadimitriou and Ratajczak~\cite{Papadimitriou:2005}, Leighton and Moitra~\cite{Leighton:2010}
\changeS{and Angelini \etal\cite{Angelini:2009} independently showed that any 3-connected planar graph has a greedy drawing. However, the number of bits needed for the coordinates in these embeddings is large for routing purposes. Goodrich and Strash~\cite{Goodrich:2008} showed how to find a greedy path in such drawings without storing the actual coordinates, but instead using local information of small size.}
Moitra \cite{Moitra:Thesis:2009} used combinatorial conditions to classify the trees that have greedy embeddings and \changeSH{very recently N{\"o}llenburg and Prutkin \cite{Nollenburg:2013} completely characterized greedy drawable trees.}
Connecting the ideas of greedy drawings and spanners,
Bose \etal\cite{Bose:theta6:2012} showed that every triangulation has an embedding in which local routing produces a path of bounded dilation.

Self-approaching drawings are related to \emph{monotone drawings} in which, for every pair of vertices  and ,  there is an -path that is monotone in some direction.  This concept was introduced by Angelini, et al.,~\cite{Angelini:MonoDraw:2012} who
gave algorithms to construct monotone planar drawings of trees and planar biconnected graphs.   A follow-up paper~\cite{Angelini:MonoFixed:2011} considers the case where a planar embedding is specified.  Self-approaching drawings are not necessarily monotone, and monotone drawings are not necessarily self-approaching.   The one relationship is that any increasing-chord drawing is  a monotone drawing.




Although a monotone path need not be self-approaching, there is a stronger condition that does imply self-approaching, namely that
the path is monotone in both the - and -directions.
Thus, a network with an -monotone path between every pair of terminals is a self-approaching network.  A \emph{Manhattan network} has horizontal and vertical edges and includes an  shortest path between every pair of terminals.   So a Manhattan network is self-approaching.
There is considerable work on finding Manhattan networks of minimum total length (so-called ``minimum Manhattan networks").  There are efficient algorithms with approximation factor 2, and the problem has been shown to be NP-hard~\cite{Chin:MMN-NP-complete:2011}.
More relevant to us is the result of Gudmundsson et al.~\cite{Gudmundsson:smallManhattan:2007} that every point set admits a Manhattan network of  vertices and edges, and there are point sets for which any Manhattan network has size at least .
{\changed This contrasts with our result that every point set admits a self-approaching network of linear size.}

For results on computing the dilation or detour of a path or graph, see the survey by
 Gudmundsson and Knauer~\cite{Gudmundsson:Dilation:2007} and the paper by Wulff-Nilsen~\cite{Wulff-Nilsen:Detour:2010}.

The Delaunay triangulation has several good properties that are relevant to us: it has dilation factor below 2~\cite{Xia:Delaunay:2011}, and is a greedy drawing~\cite{Bose:routing:2004}, although greedy paths in a Delaunay triangulation do not necessarily have bounded dilation.
It is natural to conjecture that the Delaunay triangulation is self-approaching, but we show that this is not the case.





\section{Preliminaries}
We let  denote the Euclidean distance between points  and  in .
{\changed Formally, a
\emph{curve} is a continuous function , and an \emph{-curve} is a curve  with  and .
The \emph{reverse curve} is .
For convenience, we will identify a curve with its image, and ignore the particular parameterization.  When we speak of points  and  \emph{in order along the curve}, or with  \emph{later than}  on the curve, we mean that  and  for some .
A curve is \emph{self-approaching} if for any three points  in order along the curve, we have . See Figure~\ref{fig:exampleSAICcurve}(a).
Note that this definition is sensitive to the direction of the curve---it may happen that a curve is self-approaching but its reverse is not.}

{\changed A curve has \emph{increasing chords} if for any four points  in order along the curve we have . See Figure~\ref{fig:exampleSAICcurve}(b) for an example.
Note that if a curve has increasing chords then the reverse curve also has increasing chords, and the curve and its reverse are both self-approaching.
The converse also holds: if a curve and its reverse are both self-approaching then the  curve has increasing chords, as we then have  for any points  in order along the curve.}


\begin{figure}[htbp]
\begin{center}
\hspace*{\fill}
\subfloat[]{\begin{picture}(0,0)\includegraphics{examplesacurve.eps}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6638,2623)(-11,-2953)
\put(501,-1349){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1364,-2186){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2826,-2499){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(4964,-649){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(5951,-786){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} }
\hspace*{\fill}
\subfloat[]{\begin{picture}(0,0)\includegraphics{exampleiccurve.eps}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5693,2150)(-11,-2244)
\put(851,-1665){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1902,-1978){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3521,-744){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(5039,-711){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(326,-1399){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2880,-1440){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} }
\hspace*{\fill}
\end{center}
\caption{(a) A self-approaching -curve and (b) an increasing-chord curve in .}
\label{fig:exampleSAICcurve}
\end{figure}








The following characterization of self-approaching curves is straightforward:
\begin{lemma}(\cite{Icking:self-approachingcurves:1995})
\label{lem:perpendSA}
{\changed A piecewise-smooth curve is self-approaching iff for each point  on the curve, the line perpendicular to the curve at  does not intersect the curve at a later point.}
\end{lemma}



\begin{corollary}
\label{lem:perpendIC}
{\changed A piecewise-smooth curve has increasing chords iff each line perpendicular to the curve intersects the curve at no other point.}
\end{corollary}


When dealing with straight-line drawings of graphs, we apply Lemma~\ref{lem:perpendSA} to piecewise-linear curves.
\changeA{
For distinct points  and , let  be the line passing through  and .
See Figure~\ref{fig:ell}.
Let  denote the line that passes through  and is perpendicular to , noting that  and  are distinct parallel lines.
Let  denote the closed half-plane that has boundary  and does not contain , and define  similarly.
Let  be the open strip bounded by  and , in other words,
the complement of .
With this notation, we can restate the lemma as follows:}


\begin{figure}[htb]
\centering
\includegraphics[width=2in]{ell.eps}
\caption{
\changeA{The lines  and , the open  (darkly shaded), and the closed half-plane  (lightly shaded).}
}
\label{fig:ell}
\end{figure}

\begin{corollary}
\label{cor:edgeperpend}
Let  be a directed path embedded in  via straight line segments.  Then,  is self-approaching iff for all , the point  lies in .  Equivalently,  is self-approaching iff for all , the convex hull of  lies in .
\end{corollary}



Analogous characterizations are also possible in higher dimensions, with the half-planes  replaced by half-spaces bounded by hyperplanes orthogonal to .




\section{Testing whether paths are self-approaching}
\label{sec:testingPaths}
Corollary~\ref{cor:edgeperpend} implicitly suggests an algorithm to determine whether a directed path embedded in Euclidean space is self-approaching.  In this section, we provide \ignore{improved} algorithms for this task in two and three dimensions, as well as a lower bound.  We assume a real RAM model in which all simple geometric operations can be performed in  time, and we assume that a straight-line drawing of a path  is represented explicitly as a list of  points (requiring  space).
\begin{theorem}
\label{thm:pathSolver}
Given a straight-line drawing of a path  in the plane, it is possible to test whether  is self-approaching in linear time.
\end{theorem}
\begin{proof}
By Corollary~\ref{cor:edgeperpend}, we must only check that for all , the convex hull of  lies in .  We can do all of these checks in  time by performing them iteratively, beginning with  and processing the points in decreasing order.  While doing this, we will either show that  is not self-approaching, or we will be able to use the properties of self-approaching paths to construct the convex hull of the traversed vertices incrementally in linear total time by an algorithm similar to Graham's scan~\cite{Graham}.

We now describe a step of the algorithm.  Assume that the directed path  is self-approaching and assume the convex hull  of vertices \{\} has already been computed and is stored by keeping track of the neighbors of each vertex on its boundary.  Since  is self-approaching, point  must lie on the boundary of  (by Corollary~\ref{cor:edgeperpend}).  Let  and  be the neighbors of  in .
\changeA{Note that  lies in  if and only if it does not intersect  and that happens if and only if the line segments  and  do not intersect .}
We can check this in  time.
If an intersection is found, then  is not self-approaching and we can terminate the algorithm.  Otherwise, we add  to  and recompute the convex hull.  This can be done by repeatedly removing the vertices of  on both sides of  until convex angles are obtained\ignore{, after which the convex hull of  will remain}.  Each vertex in  will be removed at most once from a convex hull in some step of the algorithm, so the total running time for all steps of the algorithm is .
\end{proof}



In three dimensions, we can obtain a similar result with slightly worse running time using an existing convex hull data structure that supports point insertion and half-space range emptiness queries.
\begin{theorem}
\label{thm:pathSolver3D}
Given a straight-line drawing of a path  in , it is possible to test whether  is self-approaching in  time.
\end{theorem}
\begin{proof}
The proof is analogous to that of Theorem~\ref{thm:pathSolver}, with the only change being that we must employ a more complicated data structure to store the convex hull and test whether it intersects a given half-space range.  For each edge , we can ensure that  does not intersect the convex hull  by performing two half-space range emptiness queries on .  If no intersection is found, then we may insert point  to our data structure and perform the next iteration of the algorithm.  If the algorithm successfully inserts all points into , then the path  must be self-approaching.

Achieving the stated running time requires a nontrivial data structure combining several known ideas.  There is a static data structure for half-space range emptiness in  with  space and  query time, by reduction to {\em planar point location\/} in dual space \cite{Kir:pl}; the preprocessing time is  if we are given the convex hull. The static data structure can be transformed into a semidynamic data structure with  amortized insertion time and  query time for a given parameter , by known techniques---namely, a -ary version of Bentley and Saxe's {\em logarithmic method\/}~\cite{BenSax}, using Chazelle's linear-time algorithm for merging two convex hulls~\cite{Cha:merge} as a subroutine. By setting , both amortized insertion time and query time are bounded by , yielding the desired result.
\end{proof}

Next, we show that Theorem~\ref{thm:pathSolver3D} is tight up to a factor of  by proving a lower bound of  on the running time of any algorithm for determining whether a directed path embedded in  is self-approaching.  We do this by reducing from the \emph{set intersection problem}, for which a solution requires  time on an input of size  in the algebraic computation tree model \cite{Ben83}.  We can show the following:
\begin{theorem}
\label{thm:hardnesspath}
Given a straight-line drawing of a path  in , at least  time is required in the algebraic computation tree model to test whether  is self-approaching.
\end{theorem}
\begin{proof}
We first need a few gadgets for our reduction. Let  and .  For a point , we define a \emph{cannon}  at  to be an embedding of a 3-vertex path  where the points are located as follows:
\begin{itemize}
\item  is placed at ,
\item  is placed at , that is,  units to the right of , and
\item  is placed at , on the line that meets the -axis at an angle  and passes through , such that the angle

is a right angle.
\end{itemize}
Similar to a cannon, a \emph{target}  at point  with respect to \changedagain{a line}  is an embedding of a 3-vertex path , where the points in  are positioned as follows:
\begin{itemize}
\item  is placed at ,
\item  at the intersection of  and , where  is the line of slope 1 passing through , and
\item  is placed on the -axis such that the angle
   is a right angle.
\end{itemize}

With these gadgets in hand, we now present a reduction from the set intersection problem.  Let  be an instance of the set intersection problem, where we are asked to check if there is a common element in sets  and . Using Yao's improvement to Ben-Or's lower bound constructions for algebraic computation trees \cite{Yao91}, it suffices to consider the case where  and  are sets of non-negative integers.  Letting  be the maximum element in  and , we first divide each element of  and  by  so that both  and  are subsets of , noting that this can be done in linear time.  Let  so that  for all  with , and let  be a sufficiently large constant (depending on ).  Using \changedagain{the elements} of  and , we embed a path  in  as follows:
\begin{enumerate}
\item Start with the vertex  placed \changedagain{at} the origin.
\item For each , place a cannon  in the -plane, attached to the current path, with  and  for .  Cannon  \changedagain{represents} the element .  At this stage, the path should appear as a chain of  cannons lined up along the -axis.
\item Place the next vertex  of the path \changedagain{at} .
\item For each , add a target  in the -plane, placed at the end of the current path with respect to .  Target  \changedagain{represents} the element  and the targets, like the cannons, \changedagain{are} aligned along the -axis. Figure~\ref{fig:reductionPath} shows what the path looks like at this point.
\item\label{enum:rotate1} Modify the embedding by rotating each cannon about the -axis through an angle  (in other words, relocate  from  to ).
\item Similarly, rotate each target  about the -axis through an angle  by relocating .
\item Let  be the path obtained after these rotations.
\end{enumerate}

\begin{figure}[ht]
\begin{center}
\resizebox{6in}{!}{\begin{picture}(0,0)\includegraphics{reductionpath.eps}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(15546,5606)(-85,-5153)
\put(2196,-2720){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1064,-2936){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault} }}}}
\put(3363,-4544){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault} }}}}
\put(10938,-4690){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault} }}}}
\put(401,-2436){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(8389,-2811){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(11101,-199){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3076,-1849){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1539,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(12901,-2986){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2301,-3424){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} }
\caption{The cannons (left) and the targets (right).}
\label{fig:reductionPath}
\end{center}

\end{figure}
\begin{figure}[ht]
\begin{center}
\begin{picture}(0,0)\includegraphics{reductionpath2.eps}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(14256,5516)(1584,-4665)
\end{picture} \caption{Placement of a target.}
\label{fig:reductionPath2}
\end{center}
\end{figure}

\changedagain{Our proof is based on the claim that  is} a self-approaching path (in the  to  direction) if and only if  and  do not intersect. More specifically,  collides with the target  if and only if element  equals element .

\emph{Only if:} Assume .  It is then easy to see that  collides with the target , since both the cannon  and the target  are rotated around the -axis through the same angle.  It follows, by Lemma~\ref{lem:perpendIC}, that  is not self-approaching.

\emph{If:} By Lemma~\ref{lem:perpendIC}, it suffices to show that if  and  do not intersect, then for any edge  in ,  does not intersect any edges in the path after . It is straightforward from our construction that the only way such an intersection can occur is if  intersects a point  for some  and .  Let  be  as it is positioned prior to step \ref{enum:rotate1} in the construction.
Define  to be the minimum amount that we need to rotate the target , so that the point  does not lie in . It is easy to see that  decreases as  increases, and more specifically that . Therefore, we can choose  large enough (with respect to ), so that  intersects  if and only if , which, by construction, happens only when .  The result follows.
\end{proof}

\ignore{To prove this, we build an embedding of a path in  using `cannons' and `targets', where a slab perpendicular to a `cannon' collides with a `target' if and only if the corresponding elements of the sets  and  are identical.}

The same construction also yields the following:
\begin{corollary}
Given a straight-line drawing of a path  in , at least  time is required in the algebraic computation tree model to test whether  has increasing chords.
\end{corollary}





\section{Finding self-approaching paths in graphs}
\label{sec:SAPathsInGraphs}

{\changed We do not know how to test in polynomial time if a given graph drawing is self-approaching.
This contrasts with the situation for greedy drawings where it suffices to find, for every pair of vertices  and , a ``first edge''  with .
In this section we explore the problem of finding a self-approaching path between two vertices  and  in a graph drawing.  If we could do this in polynomial time, then we could test if a drawing is self-approaching in polynomial time.
We are unable to settle the complexity in two dimensions, but,  by employing the cannons and targets introduced in Section~\ref{sec:testingPaths}, we can show that the problem is hard in three or more dimensions:}



\begin{theorem}
\label{thm:SAPathsInGraphs}
Given a straight-line drawing of a graph  in , and a pair of vertices  and  from , it is NP-hard to determine if a self-approaching -path exists. It is also NP-hard to determine if an increasing-chord -path exists.
\end{theorem}
\begin{proof}
We establish the result for the case of self-approaching paths; the proof for the increasing-chord case is similar.  We reduce from 3SAT.  Let  be an instance of 3SAT. Let  be the variables in . For any , let the literal  be the negation of the literal , both associated with the boolean variable . Let  be the set of clauses associated with , where  and each literal  is either  or  for some value of .  Let . We draw the graph  as follows:
\begin{enumerate}
\item Place the vertex  at the origin.
\item Place two cannons  and  corresponding to  and , both at .
\item For all , place two cannons  and  corresponding to  and , both at the point  = .
\item Place a vertex  at , adjacent to .
\item Place three targets ,  and  at  with respect to the line .
\item For all , place three targets ,  and  at , with respect to the line .
\item For all , rotate  about -axis through an angle of .
\item For all  and , suppose that  (respectively, ).  Then rotate  about the -axis through an angle of  (respectively, )---in other words, rotate  through the same amount that the cannon corresponding to the value of the literal  is rotated, so that a cannon `hits' a target if and only if the cannon and target correspond to the same literal.
\end{enumerate}
The rest of the proof is quite similar to the proof of Lemma~\ref{thm:hardnesspath}.  In particular, we shall show that  is satisfiable if and only if there is a self-approaching path from  to .  We will reuse the following statement from the proof of Lemma~\ref{thm:hardnesspath}: for ,  intersects the target , if and only if  and  are rotated by the same amount, hence correspond to the same literal. Let  be a path from  to . Assume  is a self-approaching path. For each cannon  appearing in , assign the literal corresponding to  to be false, and its negation to be true. Then, it is easy to show that in each clause, there is at least one true literal: the one appearing in . Similar to this, from a satisfying assignment of the variables, we can construct a self-approaching path by taking the cannons corresponding to false literals. For the second part of the path, we use one of the three targets assigned to each clause: one that corresponds to a true literal. This way, since each target that is traversed in  corresponds to a cannon that was not traversed in ,  would be a self-approaching path.

The same proof also works to establish NP-hardness for finding an increasing chord -path.  Note that this is because the drawing of the graph is constructed in a way that any increasing-chord path connecting  to  is a self-approaching path in the -to- direction and vice versa.
\end{proof}


\ignore{To prove this theorem, we reduce from 3SAT.  Our proof uses similar `cannons' and `targets' to those used in the proof of Theorem~\ref{thm:hardnesspath}, but this time, the cannons correspond to variable assignments and the targets correspond to literals in clauses.}



\section{Recognizing graphs having self-approaching drawings}
\label{sec:SADrawability}






In this section
{\changed we characterize trees that have self-approaching drawings and give a linear time recognition algorithm.
This is similar to Moitra's characterization of trees that admit greedy drawings~\cite{Moitra:Thesis:2009}.}  We begin with a simple observation about self-approaching drawings of trees.

\begin{lemma}
\label{lem:treeStrip}
In a self-approaching drawing of a tree , for each edge , there is no edge or vertex of  that intersects .
\end{lemma}
\begin{proof}
Since there is a unique path connecting vertices  and  in any tree , a drawing of  is self-approaching if and only if it has increasing chords.  The result then follows from Corollary~\ref{lem:perpendIC}.
\end{proof}




With this lemma in hand, we state the main theorem of this section.

\begin{theorem}
\label{thm:drawableTrees}
Given a tree , we can decide in linear time whether or not  admits a self-approaching drawing.
\end{theorem}
\begin{proof}
To prove this theorem, we completely characterize trees that admit self-approaching drawings.  We require two definitions of special graphs.

A \emph{windmill} having \emph{sweep length}  is a tree constructed by subdividing
each edge of  with  new vertices
and then attaching a leaf to each subdivision vertex.
\changeAL{The three subgraphs formed by removing the central vertex of the original  are called \emph{sweeps} and the path of  vertices in each sweep is called the \emph{shaft}.}
A windmill is depicted in Figure~\ref{fig:windmillcrab}(a).

\begin{figure}
\begin{center}
\hspace*{\fill}
\subfloat[]{\begin{picture}(0,0)\includegraphics{tricycle.eps}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2600,2600)(945,-2469)
\end{picture} }
\hspace*{\fill}
\subfloat[]{\begin{picture}(0,0)\includegraphics{crab.eps}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4985,3331)(-11,-2480)
\put(914,-2286){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2876,-2286){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3426,-1674){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2614,-1486){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2314,-1086){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2251,-374){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2701,251){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3189,-249){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(801,264){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1314,-311){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(414,-236){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1464,-924){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(314,-1424){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1176,-1649){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} }
\hspace*{\fill}
\end{center}
 \caption{(a) A windmill with sweeps of \changeAL{length } and (b) the crab graph. } \label{fig:windmillcrab}
\end{figure}

The \emph{crab graph} is the 14-vertex tree depicted in Figure \ref{fig:windmillcrab}(b).
A graph  is \emph{crab-free} if it has no subgraph that is isomorphic to some subdivision of the crab graph.

We prove Theorem~\ref{thm:drawableTrees} in two steps.  Write  for the maximum degree of a vertex in .
\begin{enumerate}
\item First we show that a tree  with  admits a self-approaching drawing if and only if  is a subdivision of .
\item Then we show that a tree  with  admits a self-approaching drawing if and only if it is a
\changeAL{subgraph of a} subdivision of a windmill, which happens if and only if  is crab-free.
\end{enumerate}

To establish the first result, the following can be proved:\begin{lemma}
\label{pathdegree}
In an increasing-chord drawing of a path, the sum of the sizes of the angles in any consecutive chain of  left turns (or right turns) is at least  if  and at least  if .
\end{lemma}
\begin{proof}
There is clearly no angle smaller than  in any increasing-chord drawing of a path. Let  and  be the first and last edges of the chain. Let  be the point in the plane such that
  and
  are right angles (See Figure~\ref{fig:anglesgame}).
\changeA{Suppose without loss of generality that  lies to the left of the chain.
The path plus  forms a simple counterclockwise polygon of  vertices because  and  do not intersect the -path.
For the same reason,
angle  is less than .
The sum of the internal angles of a simple polygon on  vertices is .  Thus the sum of the angles on the left of the vertices along the -path is .
To argue about the right side angles, note that the sum of the external angles of a simple polygon on  vertices is .  Also the exterior angle at  is at most .  Thus the sum of the angles on the right of the vertices along the  path is at least .
}

\begin{figure}
\begin{center}
\begin{picture}(0,0)\includegraphics{sumargument.eps}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2837,2128)(472,-1997)
\put(1158,-1775){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(662,-1041){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1520,-266){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2935,-411){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(2956,-1134){\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture} \caption{For proof of Lemma~\ref{pathdegree}.}
\label{fig:anglesgame}
\end{center}
\end{figure}
\end{proof}

\begin{corollary}
If  admits a self-approaching drawing, then . Also, if , then there is only one vertex of degree  in , and the four angles at the vertex of degree  all have size , and the rest of the angles have size .
\end{corollary}
This concludes the first step of the proof.  For the second step, we prove the following three structural lemmas, which establish the equivalence of a tree being a subdivision of a windmill, being crab-free, and admitting a self-approaching drawing.

\begin{lemma}
\label{onethreelemma}
Let  be a crab-free tree with . Then  is \changeS{a subgraph of} a subdivision of a windmill.
\end{lemma}
\begin{proof}
\changeS{We say that a degree-3 vertex  is \emph{canonical} if there are three disjoint paths connecting  to other degree-3 vertices. For example, vertices  and  in Figure \ref{fig:windmillcrab}(b) are canonical. To prove the lemma we look at three cases: (a) there are two or more canonical vertices; (b) there are no canonical vertices; and (c) there is exactly one canonical vertex.

\changeAL{
a) We rule out this case by showing that if  has two canonical degree-3 vertices  and  then it contains a subgraph that is isomorphic to the crab graph:
In the subgraph formed by deleting the  path there are
two degree-3 vertices  and  that have disjoint paths to , and two degree-3 vertices  and  that have disjoint
paths to .
Now it is easy to see that the minimal connected subgraph of  that contains the vertices  and their neighbours is isomorphic to a subdivision of the crab graph.
}

b) If there are no canonical vertices, then there is a path in  that contains all degree  vertices. Such a graph is isomorphic to a subdivision of a sweep which is a subgraph of the windmill.

c) Now it remains to show that the lemma holds if there is a single canonical vertex  in . Suppose  is rooted at  which has three children. If we remove the subtrees rooted at any two children of , we are left with a graph with no canonical vertices. As we showed, such a graph is isomorphic to a subdivision of a sweep. Furthermore,  is an end vertex of the sweep.  This gives us a way to decompose  into three subgraphs intersecting at , such that each subgraph is a subdivision of a sweep, constituting a windmill.}
\end{proof}

\begin{lemma}
\label{secondlemma}
Let  be a tree that is a subdivision of a windmill.  Then  admits a self-approaching drawing.
\end{lemma}
\begin{proof}
It suffices to show that any windmill admits a self-approaching drawing. We draw a  so that each angle is  and edges are unit length.
\changeAL{From each leaf , draw two rays  so that the  wedge between them has angle

for some small  and each of the angles formed by a ray and the incident edge of the  is
.
It can easily be seen that \changeS{for small enough ,
if we expand the wedge at  by  on each side then this ``wide'' wedge of angle  does not contain any part of the drawing of  (See Figure \ref{fig:rays}).
In fact the distance of each of the two other leaves to this wedge is at least
.
}}


\ignore{
\begin{figure}
\begin{center}
\begin{tikzpicture}
\path (0,0) coordinate (origin);
\path (0:1cm) coordinate (P0);
\path (P0) ++(54:3cm) coordinate (P00);
\path (P0) ++(360-54:3cm) coordinate (P01);
\path (1*120:1cm) coordinate (P1);
\path (P1) ++(120+54:3cm) coordinate (P10);
\path (P1) ++(120-54:3cm) coordinate (P11);
\path (P1) ++(120-54:0.1cm) coordinate (P1close0);
\path (P1) ++(120-54-90:0.1cm) coordinate (P1close2);
\path (P1close0) ++(120-54-90:0.1cm) coordinate (P1close1);
\path (P1) ++(120-54-90:7cm) coordinate (P1bad0);
\path (2*120:1cm) coordinate (P2);
\path (P2) ++(240+54:3cm) coordinate (P20);
\path (P2) ++(240-54:3cm) coordinate (P21);
\path (P2) ++(240+54:0.1cm) coordinate (P2close0);
\path (P2) ++(240+54+90:0.1cm) coordinate (P2close2);
\path (P2close0) ++(240+54+90:0.1cm) coordinate (P2close1);
\path (P2) ++(240+54+90:7cm) coordinate (P2bad0);
\draw (origin) -- (P0) (origin) -- (P1) (origin) -- (P2);
\draw [dashed] (P0) -- (P00) (P0) -- (P01) (P1) -- (P10) (P1) -- (P11) (P2) -- (P20) (P2) -- (P21);
\draw [dotted] (P1) -- (P1bad0) (P2) -- (P2bad0);
\draw [red] (P1close0) -- (P1close1) -- (P1close2);
\draw [red] (P2close0) -- (P2close1) -- (P2close2);
\draw [fill=red] (origin) circle (0.04cm);
\node [above right] at (origin) {};
\draw [fill=red] (P0) circle (0.04cm);
\node [above left] at (P0) {};
\draw [fill=red] (P1) circle (0.04cm);
\node [below left] at (P1) {};
\draw [fill=red] (P2) circle (0.04cm);
\node [above left] at (P2) {};
\end{tikzpicture}
\caption{The drawing of  and its three neighbors (solid lines) along with the two rays of the neighbors (dashed).The constructed drawing should be such that the sweep attached to  lies completely inside the area next to  that is bounded by dashed and dotted lines.}
\label{fig:rays}
\end{center}
\end{figure}
}

\begin{figure}
\begin{center}
\includegraphics[width=3.5in]{windmillconstruction-new.eps}
\caption{
\changeAL{Self-approaching drawing of a windmill: The drawing of  and its three neighbors (solid lines) along with the two rays at each of the neighbors (dashed). The wide wedge at  is lightly shaded.  The sweep containing  will be drawn in the darkly shaded region between the two rays at  and outside the wide wedges at  and .}
}
\label{fig:rays}
\end{center}
\end{figure}


\begin{figure}
\begin{center}
\includegraphics[width=5in]{windmillconstruction0.eps}
\caption{Self-approaching drawing of a windmill: Drawing a sweep of \changeAL{length }. The two rays are drawn using dashed segments and
\changeAL{ here is .}}
\label{windmillembeddfig2}
\end{center}
\end{figure}



Let  be a number to be set later. For each leaf  of the drawing of , we draw the sweep that includes  as follows. \changeAL{Assume that  is part of a sweep of length . We draw the sweep between the two rays at  and outside the wide wedges of the other two leaves.
Furthermore,  we ensure that  the strip  of each edge  of the sweep lies inside the wide wedge at .  This prevents intersections between strips of one sweep and edges of any other sweep.


We first draw the shaft of the sweep.
Draw the first edge incident to  so that it has length  and makes an angle of    with one of the rays at . Continue to draw the rest of the shaft with each edge having a  difference of direction with the previous edge and length  (See Figure~\ref{windmillembeddfig2}). This means that the last edge of the shaft is parallel to one of the two rays at .
To ensure that the drawing stays outside the other wide wedges,
 can be set to .





Next we draw the leaves of the sweep.
Draw the leaf attached to  so that it is inside the reflex angle at  and lies exactly on one of the rays. Then draw the rest of the leaves in such a way that each new edge is exactly in the middle of the reflex angle of the two incident edges of the shaft (See Figure~\ref{windmillembeddfig2}). The length of each of these new edges should be small enough so that none of them is inside the strip induced by another one. To satisfy this, the length of each such leaf can be \changeS{.}
Note that the strip of each of these edges lies inside the wide wedge at .
}
\end{proof}


\begin{lemma}
\label{subcrablemma}
Let  be a tree that contains a subdivision of the crab.  Then  does not admit a self-approaching drawing.
\end{lemma}
\begin{proof}
It is easy to see that if a tree admits a self-approaching drawing, then any connected subgraph of it also admits a self-approaching drawing. Therefore, we only need to show that no subdivision of the crab graph has a self-approaching drawing. \changeS{First we show that the crab graph itself does not admit a self-approaching drawing.} By Lemma \ref{pathdegree}, the total size of the chain of four angles on the path from  to  is greater than . By similar arguments, the angles on the path from  to  also sum to . Similarly, by Lemma \ref{pathdegree}, the total size of the chain of three consecutive angles on the path from  to  is greater than . By similar arguments, the angles on the path from  to  also sum to . By Lemma \ref{pathdegree}, each of the four angles formed by the eight leaves has size at least , summing to . This adds up to a total strictly greater than . Since these angles are the angles around the  vertices , and , we have a contradiction.

\changeS{Now consider  to be a subdivision of the crab graph. Each subdivision vertex adds a total of  to the both sides of the inequality, hence the contradiction holds.}
\end{proof}

Combining these results, we obtain the second step of the proof of the theorem.  This completes the characterization of all trees that admit self-approaching drawings.  To complete the proof of Theorem~\ref{thm:drawableTrees}, it suffices to observe that it is possible, in linear time, to check whether a tree  is a subdivision of  or of a windmill.
\end{proof}




\section{Constructing self-approaching Steiner networks}
\label{sec:SAspanners}
We now turn our attention to the following problem: Given a set  of points in the plane, draw a graph  with straight edges and  such that for each ordered pair of points  there is a self-approaching path from  to  in the drawing of . We call the points in   \emph{Steiner points} and the graph  a \emph{self-approaching Steiner network for }. An increasing-chord Steiner network is defined similarly.

We show that small increasing-chord Steiner networks (and hence small self-approaching Steiner networks) can always be constructed for any given set of points in the plane.

\begin{theorem}
\label{thm:steiner}
Given a set  of  points in the plane, there exists an increasing-chord Steiner network for  having  vertices and edges.
\end{theorem}
\begin{proof}
Given points  and , let  denote the angle between the
line  and the -axis (we take the smaller of the two angles
formed, so that ).
A path is {\em -monotone\/} if every vertical line intersects the path
\changeA{in at most one point or one segment and every horizontal line intersects the path in at most one point or one segment.}
Clearly, an -monotone path is self-approaching.
\changeA{We will use rectilinear -monotone paths in our construction.}
We will build a linear-size Steiner network~
with the following property:
\begin{quote}
For every pair of points  with
, there is
a \changeA{rectilinear} -monotone path from  to  in~.
\end{quote}
To handle the remaining pairs of points, we can rotate the coordinate axes by 
and apply the same construction to obtain another Steiner network .
We can then return the union of  and~.

To construct , we first build a {\em quadtree}~\cite{Har-Peled:book},
defined as follows:
The root stores an initial square enclosing .  At each node,
we divide its square into four congruent subsquares and create
a child for each subsquare that is not empty of points of .
The tree has  leaves.

To ensure that the tree has  internal nodes, we compress each maximal path
of degree-1 nodes by keeping only the first and last node in the path.
The result is a {\em compressed quadtree}, denoted .

For each square  in the compressed quadtree , we add the four corner vertices
and edges of  to .
(Note that we allow overlapping edges in our construction;
it is not difficult to avoid overlaps by subdividing the edges appropriately.)
For each leaf square  in  containing a single point ,
we add a 2-link -monotone path in  from  to each corner of .
For each degree-1 square  in  having a single child square ,
we add a 2-link -monotone path in 
from each corner of  to the corresponding corner of .
By induction, it then follows
that for every point  inside a square  in ,
there is an -monotone path in  from  to each corner of .
The number of vertices and edges in  thus far is .

Given a parameter ,
a {\em well-separated pair decomposition\/} of  is
a collection of pairs of sets ,
such that\footnote{
In the original definition~\cite{CalKos},  and  are subsets of ,
but for our purposes, we will take  and  to be regions in the plane
(namely, squares).
}
\begin{enumerate}
\item for every pair of points , there is a unique index 
with  or ;
\item  and  are {\em well-separated\/} in the sense that
both the diameter of  and the diameter of  is at most
, where  is the minimum distance between  and .
\end{enumerate}
It is known that a well-separated pair decomposition consisting
of  pairs always exists~\cite{CalKos}.
Furthermore, such a decomposition
can be constructed by a simple quadtree-based algorithm (for example, see
\cite{Har-Peled:book} or \cite{Chan:wspd}), where the sets  and 
are in fact squares appearing in the compressed quadtree .

To finish the construction of , we consider each pair  in the
decomposition such that  and  are separated by both a vertical line
and a horizontal line.
Without loss of generality, suppose that  is to the left of and below .
We add a 2-link -monotone path in  from the upper right
corner of  to the lower left corner of .
The overall number of vertices and edges in  is .

To show that  satisfies the stated property, let 
with .
Suppose that .
If  and  are intersected by a common horizontal line, then
 must be upper-bounded by  because  and 
are well-separated; this is a contradiction
if we make the constant  sufficiently small.
Thus,  and  must be separated by a horizontal line, and similarly
by a vertical line via a symmetric argument.
Without loss of generality, suppose that  is to the left of and below .
By concatenating -monotone paths in , we can get from 
to the upper right corner of , then to the lower left corner of ,
and finally to .
\end{proof}

In the above construction, the edges
we add for each well-separated pair  may cross other edges, although
it is possible to modify the construction to
ensure that the network  is planar (and similarly ).  However, we do not
know how to avoid crossings in the final network
obtained by unioning  and , while keeping the number of edges linear.
Our construction can be carried out in  time, since that is the cost for building the compressed quad tree and the  well-separated pair decomposition.  The theorem generalizes to any constant dimension.

We note that our construction bears some similarity to the construction used independently by Borradaile and Eppstein~\cite{Borradaile} to create small low-weight plane Steiner spanners in which the paths stay within a bounded range of angles.



Whether planar self-approaching Steiner networks of linear size can be constructed or not is an interesting question.
Delaunay triangulations seemed to be a potential candidate, however, Figure~\ref{fig:Del-not-SA} shows a configuration of 6 points in the plane whose Delaunay triangulation is not a self-approaching drawing.

\begin{figure}
\begin{center}
\includegraphics[width=0.5\textwidth]{Del-not-SA-fig}
\vspace{1cm}
\caption{The Delaunay triangulation of these six points does not have a self-approaching path from  to .  Forbidden edge-vertex pairs are indicated with dashed lines.  From  we must take edge , because  lies in the forbidden region for edge .   Then we cannot go to  since it is in the forbidden region of , nor can we use edge  since  is in its forbidden region.}
\label{fig:Del-not-SA}
\end{center}
\end{figure}
















\section{Conclusions}

We have introduced the notion of self-approaching and increasing-chord graph drawings, with rich connections to greedy drawings, spanners, dilation and detour, and minimum Manhattan networks.

Our results are preliminary.  We leave open the following questions:
\begin{itemize}
\item Can we test, in polynomial time, if a straight-line graph drawing in the plane is self-approaching [or increasing-chord]? Or is the problem NP-complete?
{\changed
\item Given a graph , can we efficiently produce a self-approaching drawing of  if one exists?


\item What classes of graphs have self-approaching [or increasing-chord] drawings? Does, for example, every 3-connected planar graph have a self-approaching drawing?  Even more interesting, which graphs have a self-approaching drawing such that
local routing finds a self-approaching path?
For example, if 3-connected graphs had such drawings, this}
would have the significant implication that every 3-connected planar graph has an embedding where local routing gives paths of bounded detour (hence bounded dilation).
Bose \etal\cite{Bose:theta6:2012} recently proved the weaker result that every triangulation has an embedding where local routing gives paths of bounded dilation.
\end{itemize}



\medskip\noindent
{\bf Acknowledgements.}  Anna Lubiw would like to thank Marcus Brazil, Victor Chepoi, Matthias M\"uller-Hannemann, and Martin Zachariasen for Dagstuhl workshop discussions that inspired this line of enquiry. This work was done as part of an Algorithms Problem Session at the University of Waterloo, and we thank the other participants for helpful discussions.  We thank Prosenjit Bose and Pat Morin for help finding the example in Figure~\ref{fig:Del-not-SA}.

\bibliographystyle{abbrv}
\bibliography{SAdrawings}

\end{document}
