\documentclass[a4paper,final]{llncs}

\makeatletter
\renewcommand*{\thetable}{\arabic{table}}
\renewcommand*{\thefigure}{\arabic{figure}}
\let\c@table\c@figure
\makeatother

\pagestyle{plain}


\newif\iflong
\longtrue



\iflong
\usepackage{longtable}
\fi




\usepackage{times}

\usepackage[T1]{fontenc}
\usepackage[scaled=0.81]{beramono}
\usepackage{hyperref}
\def\sectionautorefname{Sec.}
\def\subsectionautorefname{Sec.}
\def\subsubsectionautorefname{Sec.}
\def\figureautorefname{Fig.}
\def\tableautorefname{Tab.}
\def\exampleautorefname{Ex.}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{array,multirow}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{ifthen}
\newcommand{\custompar}[1]{\parskip 0pt \textbf{\textit{#1}}}
  
\usepackage{listings}
\usepackage{boogie}
\usepackage{why3lang}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.81]{beramono} 
\lstset{basicstyle=\normalsize\ttfamily, showstringspaces=false, columns=fixed, commentstyle=\itshape}
\lstset{numberstyle=\tiny, numbersep=2pt, firstnumber=last, numbers=none}

\newcommand{\tr}{\mathcal{T}}
\newcommand{\enc}{\mathcal{E}}
\newcommand{\des}{\mathcal{D}}
\DeclareRobustCommand{\openCurl}{\ensuremath{\text{\ttfamily\{}}}
\DeclareRobustCommand{\closeCurl}{\ensuremath{\text{\ttfamily\}}}}

\newcommand{\nat}{\textsc{nat}\xspace} \newcommand{\tes}{\textsc{tes}\xspace} \newcommand{\obj}{\textsc{obj}\xspace} 

\usepackage{tikz}
\usetikzlibrary{arrows,automata,shapes.symbols,positioning,calc}


\newcommand{\btw}{\texttt{b2w}\xspace}
\newcommand{\Boogie}{Boogie\xspace}
\newcommand{\WhyML}{WhyML\xspace}
\newcommand{\Why}{Why3\xspace}


\iflong
\newcommand{\tightParagraph}[1]{\paragraph{#1}}
\else
\setlength{\intextsep}{8pt}
\setlength{\textfloatsep}{8pt}
\makeatletter
\newcommand\tightParagraph{\@startsection{paragraph}{4}{\z@}{-5\p@ \@plus -4\p@ \@minus -4\p@}{-0.5em \@plus -0.22em \@minus -0.1em}{\normalfont\normalsize\itshape}}
\makeatother
\fi


\newcommand{\feature}[1]{\subsection{#1}}
\newcommand{\kw}[1]{\emph{#1}}

\newcommand{\typesOf}[1]{\mathit{types}(\MB{#1})}
\newcommand{\ctypesOf}[1]{\mathit{conc}(\MB{#1})}
\newcommand{\concPlus}[1]{\mathit{conc}^+(\MB{#1})}
\newcommand{\BBT}{\mathbb{T}}

\usepackage{changepage}



\begin{document}

\title{Why Just Boogie?}
\subtitle{Translating Between Intermediate Verification Languages}

\author{Michael Ameri\inst{1} \and Carlo A.\ Furia\inst{2}\thanks{Work done mainly while affiliated with ETH Zurich.}}

\institute{
Chair of Software Engineering, Department of Computer Science, \\
ETH Zurich, Switzerland  \email{mameri@student.ethz.ch}
\and
Department of Computer Science and Engineering, \\
Chalmers University of Technology, Sweden  \email{furia@chalmers.se}
}

\maketitle

\begin{abstract}
The verification systems \Boogie and \Why use their respective intermediate languages 
to generate verification conditions from high-level programs.
Since the two systems support different back-end provers (such as Z3 and Alt-Ergo) and are used to encode different high-level languages (such as C\# and Java), being able to translate between their intermediate languages would provide a way to reuse one system's features to verify programs meant for the other.
This paper describes a translation of \Boogie into \WhyML (\Why's intermediate language) that preserves semantics, verifiability, and program structure to a large degree.
We implemented the translation as a tool and applied it to 194 \Boogie-verified programs of various sources and sizes; \Why verified 83\% of the translated programs with the same outcome as \Boogie.
These results indicate that the translation is often effective and practically applicable.
\end{abstract}




\section{Introduction}\label{sec:intro}


Intermediate verification languages (IVLs) are intermediate representations used in verification technology.
Just like compiler design has benefited from decoupling front-end and back-end, IVLs help write verifiers that are more modular: the front-end specializes in encoding the rich semantics of a high-level language (say, an object-oriented language such as C\#) as a program in the IVL; the back-end generates verification conditions (VCs) from IVL programs in a form that caters to the peculiarities of a specific theorem prover (such as an SMT solver).

\Boogie~\cite{boogie-baseref} and \WhyML~\cite{FilliatreP13} are prime examples of popular IVLs with different, often complementary, features and supporting systems (respectively called \Boogie and \Why).
In this paper we describe a translation of \Boogie programs into \WhyML programs and its implementation as the tool \btw.
As we illustrate with examples in \autoref{sec:examples}, using \btw increases the versatility brought by IVLs: without having to design and implement a direct encoding into \WhyML\iflong or even being familiar with its peculiarities\fi, users can take advantage of some of the best features of \Why when working with high-level languages that translate to \Boogie. 




\tightParagraph{\Boogie vs.\ \WhyML.}
While the roles of \Boogie and \WhyML as IVLs are similar, the two languages have different characteristics that reflect a focus on complementary challenges in automated verification.
\Boogie is the more popular language in terms of front-ends that use it as IVL, which makes a translation \emph{from} \Boogie more practically useful than one into it; it has a finely tuned integration with the Z3 prover that results from the two tools having been developed by the same group (Microsoft Research's RiSE); it combines a simple imperative language with an expressive typed logic, which is especially handy for encoding object-oriented or, more generally, heap-based imperative languages.
In contrast, \WhyML has a more flexible support for multiple back-end provers it translates to, including a variety of SMT solvers as well as interactive provers such as Coq; it can split VCs into independent goals and dispatch them to different provers; if offers limited imperative constructs within a functional language that belongs to the ML family, which brings the side benefit of being able to \emph{execute} \WhyML programs---a feature quite useful to debug and validate verification attempts.


\tightParagraph{Goals and evaluation.}
The overall goal of this paper is devising a translation  from \Boogie to \WhyML programs.
\iflong
The translation, described in \autoref{sec:translation}, should preserve correctness, verifiability, and readability as much as possible.
\else
The translation, described in \autoref{sec:translation}, should preserve correctness and verifiability as much as possible.
\fi
Preserving correctness means that, given a \Boogie program , if its translation  is a correct \WhyML program then  is correct (soundness); the converse should also hold as much as possible: if  is incorrect then  is too (precision).
Preserving verifiability means that, given a \Boogie program  that verifies in \Boogie, its translation  is a \WhyML program that verifies in \Why.
\iflong
Preserving readability means that the translation should not introduce unnecessary changes in the structure of programs.
\fi

The differences, outlined above, between \Boogie and \WhyML and their supporting systems make achieving correctness\iflong,\else\ and\fi\ verifiability\iflong, and readability\fi\ challenging.
While we devised  to cover the entire \Boogie language, its current implementation \btw does not fully support a limited number of features (branching, the most complex polymorphic features, and bitvectors) that make it hard to achieve verifiability in practice.
In fact, while replacing branching (goto) with looping is always possible~\cite{Harel-folk}, a general translation scheme does not produce verifiable loops since one should also infer invariants (which are often cumbersome due to the transformation).
Polymorphic maps are supported to the extent that their type parameters can be instantiated with concrete types; this is necessary since \WhyML's parametric polymorphism cannot directly express all usages in \Boogie, but it may also introduce a combinatorial explosion in the translation; hence, \btw fails on the most complex instances that would be unmanageable in \Why.
\Boogie's bitvector support is much more flexible than what provided by \Why's libraries; hence \btw may render the semantics of bitvector operations incorrectly.

These current implementation limitations notwithstanding (see \autoref{sec:translation} for details), we experimentally demonstrate that \btw is applicable and useful in practice.
As \autoref{sec:experiments} discusses, we applied \btw to 194 \Boogie programs of different size and sources; most of the programs have not been written by us and exercise \Boogie in a variety of different ways.
For 83\% (161) of these programs, \btw produces a \WhyML translation that \Why can verify as well as \Boogie can verify the original, thus showing the feasibility of automating translation between IVLs. 


\tightParagraph{Tool availability.}
\iflong\else
For lack of space this paper omits some details that are available as a technical report~\cite{extended-version}.
\fi
The tool \btw is available as open source at:
\iflong\begin{center} \fi
\url{https://bitbucket.org/michael_ameri/b2w/}
\iflong\end{center}\fi








\section{Related Work}\label{sec:related-work}

\tightParagraph{Translations and abstraction levels.}
Translation is a ubiquitous technique in computer science; however, the most common translation schemes bridge \emph{different abstraction levels}, typically encoding a program written in a high-level language (such as Java) into a lower-level representation which is suitable for execution (such as byte or machine code).
Reverse-engineering goes the opposite direction---from lower to higher level---for example to extract modular and structural information from C programs and encode it using object-oriented constructs~\cite{TFNM-ECOOP13}.
This paper describes a translation between intermediate languages---\Boogie and \Why---which belong to \emph{similar abstraction levels}.
In the context of model transformations~\cite{MensG06}, so-called bidirectional transformations~\cite{Stevens07} also target lossless transformations between notations at the same level of abstraction.


\tightParagraph{Intermediate verification languages.}
The Spec\# project~\cite{BarnettFLMSV11} introduced \Boogie to add flex\-i\-bil\-i\-ty to the translation between an object-oriented language \iflong(a dialect of C\#)\fi{} and the verification con\-di\-tions{}\iflong in the logic fragments supported by SMT solvers\fi.
\iflong
An intermediate verification language embodies the idea of intermediate representation---a technique widespread in compiler construction---in the context of verification.
\fi{} 
Since its introduction for Spec\#, \Boogie has been adopted as intermediate verification language for numerous other front-ends such as Dafny~\cite{Leino04}, AutoProof~\cite{TFNP-TACAS15}, Viper~\cite{HeuleKMS13}, and Joogie~\cite{ArltS12}; 
its popularity demonstrates the advantages of using intermediate verification languages.

While \Boogie retains some support for different back-end SMT solvers, Z3\iflong~\cite{Z3}\fi{} remains its\iflong{} fully supported \fi{} primary target.
By contrast, supporting multiple, different back-ends is one of the main design goals behind the \Why system~\cite{FilliatreP13}\iflong, which does not merely generate verification conditions in different formats but offers techniques to split them into independently verifiable units and to dispatch each unit to a different prover\fi.
\Why also fully supports interactive provers,\iflong\footnote{In comparison, \Boogie's support for HOL is restricted and not up-to-date~\cite{BohmeLW08}.}\fi{} which provide a powerful means of discharging the most complex verification conditions that defy complete automation.

\iflong
Another element that differentiates \Boogie and \Why is the support for executing programs; this is quite useful for debugging verification attempts and for applying testing-like techniques to the realm of verification.
Boogaloo~\cite{PFW-RV13} supports symbolic execution of \Boogie programs; Symbooglix is a more recent project with the same goal~\cite{symbooglix}. 
Thanks to it being a member of the ML family, \Why directly supports symbolic execution as well as compilation of \WhyML programs to OCaml.
\fi

In all, while the \Boogie and \WhyML languages belong to a similar abstraction level, they are part of systems with complementary features, which motivates this paper's idea of translating one language into the other.
\iflong
Since \Boogie is overall more popular, in terms of tools that use it as a back-end, the translation from \Boogie to \WhyML is more practically useful than the one in the opposite direction.
\fi

Other intermediate languages for verification are Pilar~\cite{Pilar-VSTTE}, used in the Sireum framework for SPARK; Silver~\cite{HeuleKMS13}, an intermediate language with native support for permissions in the style of separation logic; and the flavor of dynamic logic for object-oriented languages~\cite{SchmittUW10} used in the KeY system.
Another approach to generalizing and reusing different translations uses notions from model transformations to provide validated mappings for different high-level languages~\cite{ChengMP15}.
Future work may consider supporting some of these intermediate languages and approaches.








\section{Motivating Examples}\label{sec:examples}

Verification technology has made great strides in the last decade or two, but a few dark corners remain where automated reasoning shows its practical limitations.
\autoref{fig:motivating-examples} provides three examples of simple \Boogie programs that trigger incorrect or otherwise unsatisfactory behavior. We argue that translating these programs to \WhyML makes it possible to verify them using a different, somewhat complementary verification tool; overall, confidence in the results of verification is improved.

Procedure \B{not_verify} in~\autoref{fig:motivating-examples} has a contradictory postcondition (notice \B{N < N}, \B{N} is a nonnegative constant, and the loop immediately terminates).
Nonetheless, recent versions of \Boogie and Z3 successfully verify it.\footnote{\url{https://github.com/boogie-org/boogie/issues/25}}
More generally, unless the complete toolchain has been formally verified (a monumental effort that has only been performed in few case studies~\cite{Leroy09,KleinAEHCDEEKNSTW10,KumarMNO14}), there is the need to \emph{validate} the successful runs of a verifier.
Translating \Boogie to \Why provides an effective validation, since \Why has been developed independent of \Boogie and uses a variety of backends that \Boogie does not support.
Procedure \B{not_verify} translated to \Why (\autoref{fig:translated-motivating-examples}) does not verify as it should.

Procedures \B{lemma_yes} and \B{lemma_no} in \autoref{fig:motivating-examples} demonstrate \Boogie's support for mathematical real numbers, which is limited in the way the power operator \B{**} is handled. \Boogie vacuously verifies both properties  and , even though Z3 outputs some unfiltered errors that suggest the verification is spurious{}\iflong{} (the power operator \B{**} is not properly supported); indeed, only the inequality encoded by \B{lemma_yes} is correct\fi.
\Why provides a more thorough support for real arithmetic\iflong, both by translating to backends such as Alt-Ergo and by providing a more effective encoding in Z3\fi; 
in fact, it verifies the translated procedure \B{lemma_yes} but correctly fails to verify \B{lemma_no}.

The loop in procedure \B{trivial_inv} in \autoref{fig:motivating-examples} includes an invariant asserting that \B{i} takes only even values.
Even if this is clearly true, \Boogie fails to check it; 
pinning down the precise cause of this shortcoming requires knowledge of \Boogie's (and Z3's) internals, although it likely is a manifestation of the ``triggers'' heuristics that handle  (generally undecidable) quantified expressions. 
\iflong
Based on this knowledge, there are specification patterns that try to work around such idiosyncrasies; in the example, one could introduce a ``witness'' ghost variable \B{k} such that \B{i == 2*k} is an invariant.
\fi
However, if we insist on verifying the program in its original form, \Why can dispatch verification conditions to \emph{interactive} provers, where the user provides the crucial proof steps.\footnote{\Why can also check the invariant automatically by relying on the CVC4 SMT solver.}
Cases such as the loop invariant of \B{trivial_inv} where a proof is ``obvious'' to a human user but it clashes against the default strategies to handle quantifiers are prime candidate to exploit interactive provers.
\iflong
Thus, translating \Boogie to \Why provides another means of exploiting the latter's versatile support for interactive provers and multiple backends.
\fi



\begin{figure}[!thb]
\centering
\scriptsize
\lstset{language=boogie}
\begin{tabular}{p{.33\textwidth} p{.3\textwidth} p{.3\textwidth}}
{\begin{lstlisting}
const N: int;
axiom 0 <= N;

procedure not_verify()
  ensures (forall k, l: int :: 
   0 <= k <= l < N ==> N < N);
{
  var x: int;
  x := -N;
  while (x != x) { }
}\end{lstlisting}}
&
{\begin{lstlisting}
procedure lemma_yes()
  ensures 2.0**3.0 > 0.0;
{  }

procedure lemma_no()
  ensures 2.0**3.0 < 0.0;
{  }\end{lstlisting}}
&
{\begin{lstlisting}
procedure trivial_inv()
{
  var i: int;
  i := 0;
  while (i < 10)
   invariant 0 <= i <= 10;
   invariant 
    (exists j: int :: i == 2*j);
  { i := i + 2; }
}\end{lstlisting}}
\end{tabular}
\caption{Three simple \Boogie programs for which automated reasoning is limited.}
\label{fig:motivating-examples}
\end{figure}
  




\section{Boogie-to-Why3 Translation}\label{sec:translation}

Intermediate languages for verification combine programming constructs and a logic language.
When used to encode programs written in a high-level language, the programming constructs encode program behavior, and the logic constructs encode specifications, constrain the semantics to conform to the high-level language's (typically through axioms), and support other kinds of annotations (such as triggers).

Both \Boogie and \WhyML provide, as logic language, a typed first-order logic with arithmetic.
\Boogie's programming constructs are a simple imperative language with both structured (while loops, procedures) and unstructured (jumps, global variables) statements.
\WhyML's programming constructs combine an ML-like functional language with a few structured imperative features such as mutable variables and loops.

Correspondingly, we define a translation  of \Boogie to \WhyML as the composition  of two translations:  is a desugaring\footnote{This is unrelated to \Boogie's built-in desugaring mechanism (option \B{/printDesugared}).} which rewrites away the \Boogie constructs, such as \emph{call-forall}, that have no similar construct in \WhyML by expressing them using other features of \Boogie.
Then,  encodes \Boogie programs simplified by  as \WhyML programs\iflong, while introducing constraints that ensure that the semantics in \WhyML mirrors the one in \Boogie\fi.
For simplicity, the presentation does not sharply separate the two translations  and  but defines either or both of them as needed to describe the translation of arbitrary \Boogie constructs.

A single feature of the \Boogie language significantly compounds the complexity of the translation: \emph{polymorphic maps}\iflong, which correspond to mappings between domains of generic type\fi.
\iflong
\Why does support polymorphic maps through a library, but its type system is more restrictive and does not allow the same degree of freedom as \Boogie's in using variables of polymorphic map types.
\fi
For clarity, the presentation of the translation initially ignores polymorphic maps.
Then, \autoref{sec:poly-maps-all} discusses how the general translation scheme can be extended to support them.

As running examples, \autoref{fig:translated-motivating-examples} shows how  translates the examples of \autoref{fig:motivating-examples}. 
\iflong
\else
For lack of space, we focus on describing the most significant aspects of the translation that are also implemented; see \cite{extended-version} for the missing details.
\fi

\begin{figure}[!tb]
\centering
\scriptsize
\lstset{language=why3,xleftmargin=0pt}
\begin{tabular}{p{.3\textwidth} p{.31\textwidth} p{.31\textwidth}}
{\begin{lstlisting}
constant N: int
axiom A0: 0 <= N;

val not_verify (): ()
  ensures { forall k, l: int .
   0 <= k <= l < N -> N < N }

let not_verify_impl(): ()
  ensures { forall k, l: int .
   0 <= k <= l < N -> N < N }
 =(
   let x = ref (any int) in
    x.contents <- -N;
    while 
     (x.contents <> x.contents)
    do done;
  end )\end{lstlisting}}
&
{\begin{lstlisting}
val lemma_yes (): ()
  ensures
    { (pow 2.0 3.0) >. 0.0 }

val lemma_no (): ()
  ensures
    { (pow 2.0 3.0) <. 0.0 }

let lemma_yes_impl (): ()
  ensures
    { (pow 2.0 3.0) >. 0.0 }
=( )

let lemma_no_impl (): ()
  ensures
    { (pow 2.0 3.0) <. 0.0 }
=( )\end{lstlisting}}
&
{\begin{lstlisting}
val trivial_inv (): ()

let trivial_inv_impl (): ()
=(
  let i = ref (any int) in
   i.contents <- 0;
   while (i.contents < 10) do
    invariant
      { 0 <= i.contents <= 10 }
    invariant
      { exists j: int . 
          i.contents = 2*j }
    i.contents <- i.contents + 2;
   done;
 )\end{lstlisting}}
\end{tabular}
\caption{The translation to \WhyML of the three \Boogie programs in \autoref{fig:motivating-examples}. \iflong(Boilerplate such as general declarations, imports, and frame condition checking are omitted for clarity.)\fi}
\label{fig:translated-motivating-examples}
\end{figure}




\feature{Types} \label{sec:types}
\iflong
\Boogie types include primitive types, instantiated type constructors, and map types.
\fi

\tightParagraph{Primitive types}
are \B{int} (mathematical integers), \B{real} (mathematical reals), \iflong\else and \fi{}\B{bool} (Bool\-eans)\iflong, and \B{bv} (-bit vectors)\fi.
 translates primitive types into their \Why analogues as shown in \autoref{tab:primitive-types}.
\iflong
Since \Why offers primitive types and operations on them through libraries,  also generates import statements for the libraries that provide the same operations that are available in \Boogie, such as integer to/from real conversion. \fi

\begin{table}
\centering
\footnotesize
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l l r}
 &  & \Why libraries \\
\hline 
{\B{int}} & {\W{int}} & {\W{int.Int}}, {\W{int.EuclideanDivision}} \\
{\B{real}} & {\W{real}} & {\W{real.RealInfix}}, {\W{real.FromInt}}, {\W{real.Truncate}}, {\W{real.PowerReal}} \\
{\B{bool}} & {\W{bool}} & {\W{bool.Bool}} \\
\iflong {\B{bv}} & {\W{bv}} & {\W{bv.BitVector with constant size = }} \fi
\end{tabular}
\caption{Translation of primitive types, and \Why libraries supplying the necessary operations.}
\label{tab:primitive-types}
\end{table}


\tightParagraph{Type constructors.}
A \Boogie type declaration using the \kw{type constructor} syntax \iflong\footnote{ ignores the optional type  modifier \B{finite}, since it does not seem fully supported in Boogie.}\fi{} introduces a new parametric type \B{T}\iflong with parameters \B{a}, , \B{a}\fi.
 translates it to an algebraic type with constructor~\W{T}:
{ \B{type T a  a}  \W{type T 'a 'a}}
for , where ticks \W{'} identify type parameters in \WhyML.




\tightParagraph{Map types.}
A \Boogie \kw{map type} \B{M} declared as:

defines the type of a mapping from  to , for .
\Why supports maps through its library \W{map.Map};{}\iflong\footnote{\Why's maps, like \Boogie's, do not satisfy extensionality~(\url{http://lists.gforge.inria.fr/pipermail/why3-club/2013-February/000572.html}).}\fi{} 
hence, , where an -tuple encapsulates the -type domain of \B{M}.


\feature{Constants}

The translation of constant declarations is generally straightforward, following the scheme:
\begin{center}
\B{const c: T} \W{constant c: T}
\end{center}
\iflong
\else
 expresses \emph{unique} constants and \emph{order} constraints by axiomatization.
\fi

\iflong
\tightParagraph{Unique constants.}
All constants of a type \B{T} declared with the modifier \B{unique} have values that are pairwise different.
Thus, for  constants \B{const unique c, , c: T},  encodes the uniqueness properties using  axioms\iflong , for \fi.


\tightParagraph{Orders.}
\Boogie provides the operator \B{<:} to express partial order over every type;  introduces a polymorphic operator \W{<:} and axiomatizes its reflexive, antisymmetric, and transitive properties\iflong:\else; it also axiomatizes \Boogie's partial-order relation constraints.\fi

\iflong
\begin{why3}[numbers=none]
predicate (<:) (x: 'a) (y: 'a)
axiom ReflexivePO:     forall x: 'a     . x <: x
axiom AntisymmetricPO: forall x y: 'a   . x <: y && y <: x -> x = y
axiom TransitivePO:    forall x y z: 'a . x <: y && y <: z -> x <: z
\end{why3}
\fi

\iflong
\Boogie supplies special syntax to describe a partial-order relations with a certain structure, which corresponds to a DAG where any two nodes  and  are connected by an edge  iff  and  is a direct successor of  in the order.
Let \B{a}, \B{b}, \B{c}, \B{d}, \B{e}, \B{f} be unique\footnote{Uniqueness is not required but makes the order specification easier to present.} constants of the same type \B{T}.
The \Boogie syntax to specify ordering between them is in \autoref{fig:ordering-specs}.
 reconstructs the DAG of the order specification, and then formalizes it in axiomatic form.
For example, the specifications in \autoref{fig:ordering-specs} determine the DAG in \autoref{fig:DAG-specification}, which is axiomatized as in \autoref{fig:axioms-of-DAG}.

\begin{figure}
\centering
\begin{tabular}{l c@{} p{0.6\textwidth}}
\multicolumn{1}{c}{\textsc{\Boogie specification}}  &&  \multicolumn{1}{c}{\textsc{Semantics}} \\
\hline
{\B{const c: T extends a, b;}} && {\B{a}} and {\B{b}} are the only direct successors of {\B{c}} \\
{\B{const a: T extends;}}      && {\B{a}} has no (direct) successors \\
{\B{const d: T extends c complete;}}  && {\B{c}} has no direct predecessors other than {\B{d}} and any others that are explicitly specified \\
{\B{const e, f: T extends unique d;}}  && {\B{d}} is the only direct successor of both {\B{e}} and {\B{f}}, and the subgraphs that originate in {\B{e}} and {\B{f}} are disjoint
\end{tabular}
\caption{Ordering specifications in \Boogie (older versions of \Boogie use \B{<:} instead of \B{extends}).}
\label{fig:ordering-specs}
\end{figure}


\begin{figure}
\centering
\begin{tikzpicture}[->]
\matrix[row sep=0pt, column sep=7mm] {
\node (lb) {}; & \node (b) {\B{b}}; & \node(rb) {};     &                   & \node (e) {\B{e}}; & \node(re) {}; \\
\node (la) {}; & \node (a) {\B{a}}; & \node(c) {\B{c}}; & \node(d) {\B{d}}; &                    &               & \node (bottom) {}; \\
               &                    & \node(uc) {};     &                   & \node (f) {\B{f}}; & \node(urf) {}; \\
};
\path (c) edge (b);
\path (c) edge (a);
\path (d) edge (c);
\path (e) edge (d);
\path (f) edge (d);
\begin{scope}[dotted]
\path (b) edge (lb);
\path (b) edge (la);
\path (rb) edge (b);
\path (uc) edge (a);
\path (re) edge (e);
\path (urf) edge (f);
\end{scope}
\path (bottom) edge[dashed,-] (d);
\end{tikzpicture}
\caption{DAG corresponding to the ordering specification of \autoref{fig:ordering-specs}. Solid edges denote the successor relation; dotted edges denote allowed (but not specified) relations; the dashed line expresses disjointness of the two sub-graphs.}
\label{fig:DAG-specification}
\end{figure}

\begin{figure}
\begin{boogie}[numbers=none,basicstyle=\scriptsize\ttfamily,xleftmargin=20mm]
axiom (c <: a && c <: b && forall : T :: c <:  ==> c ==  || a <:  || b <: )
axiom (forall : T :: !(a <: ))
axiom (d <: c && forall : T ::  <: c ==> c ==  ||  <: d)
axiom (e <: d && forall : T :: e <:  ==> e ==  || d <: )
axiom (f <: d && forall : T :: f <:  ==> f ==  || d <: )
axiom (forall : T ::  <: e ==> !( <: f))
axiom (forall : T ::  <: f ==> !( <: e))

\end{boogie}
\caption{Axiomatization of the ordering specification in \autoref{fig:ordering-specs}.}
\label{fig:axioms-of-DAG}
\end{figure}
\fi
\fi

\feature{Variables} \label{sec:variables}
\Why supports mutable variables through the reference type \W{ref} from theory \B{Ref}.
Boogie global variable declarations become global value declarations of type \W{ref}; Boogie local variable declarations become \W{let} bindings with local scope.
Thus, if \B{v} is a global variable and \B{l_v} is a local variable in \Boogie:
\begin{center}
\begin{tabular}{lc@{}rl}
global variable && {\B{var v: T}} & {\W{val v: ref }\W{T}}  \\
local  variable && {\B{var l_v: T}} & {\W{let l_v = ref (any }\W{T}\W{) in }} 
\end{tabular}
\end{center}
The expression \W{any T} provides a nondeterministic value of type \W{T}.


\feature{Functions}
\Boogie function \emph{declarations} become \WhyML function declarations:


\noindent
\WhyML function \emph{definitions} require, unlike \Boogie's, a variant to ensure that recursion is well-formed.
Therefore, \Boogie function definitions are not translated into \WhyML function definitions but are axiomatized\iflong: if function \B{f} in \eqref{eq:tr-function-decl} has body \B{B},  replaces the body with the \fi.\footnote{To take advantage of \Why's well-formedness checks, we plan to offer translations of \Boogie functions to \WhyML functions as a user option in future work.}

\feature{Expressions} \label{sec:expressions}
\iflong
The translation of \Boogie expressions to \WhyML expressions is mostly straightforward, given the translation of types described above.
We describe the few cases that deserve some detail.
\fi

\iflong
\tightParagraph{Nondeterministic choice.}
The special value \B{*} represent a nondeterministic Boolean choice (used in loop exit flags and conditionals); we define , which provides a nondeterministic Boolean value. \fi

\tightParagraph{Variables.}
Since a \Boogie variable \B{v} of type \B{T} turns into a value \W{v} of type \W{refT}, occurrences of \B{v} in an expression translate to \W{v.contents}, which represents the value attached to reference \W{v}.

\tightParagraph{Map expressions.}
 translates map selection and update using functions \W{get} and \W{set} from theory \W{Map}.
If \B{m} is a map of type \B{M} defined in \autoref{sec:types}, then:\iflong\footnote{Despite its name, \W{set} returns a new map rather than changing its argument's value.}\fi{} 
\begin{center}
\setlength{\tabcolsep}{6pt}
\begin{tabular}{lll}
&  \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
selection 
  & {\B{m[e, , e]}}
  & {\W{get}\B{m}\W{(}\B{e}\W{,}\W{,}\B{e}\W{)}} \\
update 
  & {\B{m[e, , e := f]}}
  & {\W{set}\B{m}\W{(}\B{e}\W{,}\W{,}\B{e}\W{)}\W{f}}
\end{tabular}
\end{center}



\tightParagraph{Lambda expressions.}
\iflong \Boogie recently introduced lambda expressions as syntactic sugar for maps. 
While \WhyML has lambda abstractions, they are not allowed as first-order values in programs~\cite{ClochardFMP14}.
Instead, the \else{} The \fi{} translation desugars lambda expression into constant maps:
, where  is axiomatized by
, and  is \B{e}'s type.

\iflong
\tightParagraph{Old expression.}
Within a procedure's postcondition or body, the expression \B{old(e)} refers to the value of \B{e} in the prestate.
\WhyML offers a more general construct to refer to an expression's value at any labeled point within a procedure's body.
Hence, every \WhyML procedure implementation translating a \Boogie procedure implementation includes a label \W{"begin"}, so that  is just  within postconditions, and is  within bodies.
\fi


\iflong
\tightParagraph{Bitvectors.}
\Why's theory \W{BitVectors} does not provide all operations that are supported by \Boogie.
In particular, it does not support \emph{extraction expressions} \B{b[n:m]} (drop the \B{m} least significant bits and return the next  least significant bits) and \emph{concatenation expressions} \B{b ++ c} (the bit vector obtained by concatenating \B{b} and \B{c}).
 introduces functions \W{extract (b: bv) (n: int) (m: int): bv} and \W{cat (b: bv) (c: bv): bv} 
and uses them to translate applications of these bit vector operators, but leaves them uninterpreted in \Why.
's implementation currently supports only the bitvectors operations available in \Why's theory \W{BitVectors}.
\fi





\feature{Procedures}

\Boogie procedures have a declaration (signature and specification) and zero or more implementations.
The latter follow the general syntax of \autoref{fig:tr-procedures} (left)\iflong, where a procedure \B{p} with input argument \B{t} and output argument \B{u} has one implementation with local variable \B{l} and body \B{B}\fi.
For simplicity of presentation, \B{p} has one input argument, one output argument, and one local variable, but generalizing the description to an arbitrary number of variables is straightforward.

\begin{figure}[!htb]
\lstset{xleftmargin=5mm}
\scriptsize
\begin{tabular}{p{.4\textwidth} p{.45\textwidth}}
{\begin{lstlisting}[language=boogie]
procedure p(t: T where Wt) 
  returns (u: U where Wu);
  requires      R;
  free requires fR;
  modifies      M;
  ensures       E;
  free ensures  fE;

implementation p(t: T) 
  returns (u: U) 
  { 
    var l: L where Wl; 
    B 
  }\end{lstlisting}} 
&
\iflong
{\begin{lstlisting}[language=Why3]
val p (t : T): U
  requires { R }
  writes   { M }
  returns  { | u -> E }
  returns  { | u -> fE }
  returns  { | u -> Wu }

let p_impl0 (t: T): U
  requires { R } requires { fR }
  returns  { | u -> E }
=(
   u: U;  l: L;
  assume { Wg }  -- where of globals
  assume { Wt }  -- where of inputs
  assume { Wl }  -- where of locals
  assume { Wu }  -- where of outputs
  try ( B )
  with | Return -> assume { true } end
  u
 )

let p_impl0_frame (t: T): U
  requires { R } requires { fR }
  writes { M }
  reads {  } -- all globals
  returns  { | u -> true }
=( ... -- as in 
    :=  M
   assume { yes() }
   u )\end{lstlisting}}
\else{\begin{lstlisting}[language=Why3]
val p (t : T): U
  requires { R }
  writes   { M }
  returns  { | u -> E }
  returns  { | u -> fE }
  returns  { | u -> Wu }

let p_impl0 (t: T): U
  requires { R } requires { fR }
  returns  { | u -> E }
=(
   u: U;  l: L;
  assume { Wg }  -- where of globals
  assume { Wt }  -- where of inputs
  assume { Wl }  -- where of locals
  assume { Wu }  -- where of outputs
  try ( B )
  with | Return -> assume { true } end
  u
 )\end{lstlisting}}
\fi
\end{tabular}
\caption{Translation of a \Boogie procedure (left) into \WhyML (right).}
\label{fig:tr-procedures}
\end{figure}

The specification of procedure \B{p} consists of preconditions \B{requires}, frame specification \B{modifies}, and postconditions \B{ensures}.
\iflong
A precondition is an assertion that callers of \B{p} must satisfy upon calling, and that every implementation of \B{p} can assume; \B{free} preconditions need not be satisfied by callers.
A postcondition is an assertion that every implementation of \B{p} must satisfy upon terminating, and that every caller of \B{p} can assume; \B{free} postconditions need not be satisfied by implementations.
Every implementation of \B{p} may only modify the global variables listed in \B{p}'s frame specification.
\else
Specification elements marked \B{free} are assumed without being checked.
\fi

 translates a generic procedure \B{p} as shown in \autoref{fig:tr-procedures} (right).
The declaration of \B{p} determines \W{val p}, which defines the semantics of \B{p} for clients: the \B{free} precondition \B{fR} does not feature there because clients don't have to satisfy it, whereas both \B{free} and non-\B{free} postconditions are encoded as \B{returns} conditions.
The implementation of \B{p} determines \W{let p_impl0}, which triggers the verification of the implementation against its specification: both \B{free} and non-\B{free} preconditions are encoded, whereas the \B{free} postcondition \B{fE} does not feature there because implementations don't have to satisfy it.
The body introduces \W{let} bindings for the local variable \W{l} and for a new local variable~\W{u} which represents the returned value; these declarations are translated as discussed in \autoref{sec:variables}.
Then, a series of \W{assume} encode the semantics of \Boogie's \B{where} clauses, which constrain the nondeterministic values variables can take (\B{Wg} comes from any global variables, which are visible everywhere); 
\B{p}'s body \B{B} is translated and wrapped inside an exception-handling block \W{try}, which does not do anything other than allowing abrupt termination of the body's execution upon throwing a \W{Return} exception (see \autoref{sec:statements} for details).
Regardless of whether the body terminates normally or exceptionally, the last computed value of \W{u} is returned in the last line, and checked against the postcondition in \W{returns}.
\iflong
Another implementation \W{let p_impl0_frame} checks the frame condition (\B{modifies} clause).\footnote{The tool \btw does not currently implement frame condition checks.}
It relies on the same full precondition as \W{p_impl0} but has postcondition \W{true} since \B{E} has already been checked; it includes a \W{writes} clause and a \W{reads} clause.
\Why checks that a global variable is in the \W{writes} clause if and only if it is written by the implementation; since \Boogie's \B{modifies} clause only expresses variables that \emph{may} be written, \W{p_impl0_frame} includes an assignment of every variable in \B{M} to itself so that the requirement that every variable in \W{M} is written is vacuously satisfied.
When a \W{writes} clause is present, \Why also requires a \W{reads} clause and checks that every variable in it is written, read, or both.
The translation builds a \W{reads} clause with all global variables , and vacuously reads all of them using function \W{yes 'a: bool}, which identically returns \W{true} for any input; this makes the \B{reads} clause satisfied by any implementation.
\fi
In all, the modular semantics of \Boogie's procedure \B{p} is preserved.



\feature{Statements}
\label{sec:statements}

\iflong
\tightParagraph{Axioms and assertions.}
\Boogie's \B{assert e}, \B{assume e}, and \B{axiom e} statements translate to 
, 
, and 

in \WhyML.
\fi

\tightParagraph{Assignments.}
Assignments involve variables (global or local), which become mutable references in \WhyML: 
.
\Boogie parallel assignments become simple assignments using \W{let} bindings of limited scope:
\tr(_1\,\,_1)\tr(\MB{havoc v}) = \MW{any}\;\tr(\MB{T})\tr(\MB{return}) = \MW{raise Return}_1\ldots_n_k\tr(head.south)+(-4mm,0mm)(body.north)+(-4mm,0)(body.north)+(4mm,0)(head.south)+(4mm,0mm)(body.south)+(17mm,-2mm)GNG\ell_NNNNNGN \to MNMM \not\to NNMNMN\ell_MN \to \{M_1, \ldots, M_n\}NM_1, \ldots, M_nM_k1 \leq k \leq nN, M_1, \ldots, M_nN\openCurl M_1 \closeCurl\:\:\openCurl\openCurl M_2 \closeCurl\:\:\openCurl\cdots\:\:\openCurl M_n \closeCurl\closeCurl \cdots \closeCurlN\ell_N\tr(\MB{break}) = \MW{raise Break}\tr()\tr()\tr()\tr()\tr()\tr()\tr()
\tr(\MB{call r := p(e)}) \ =\ 
\tr(\MW{t})\;\MW{ <- p(}\tr(\MW{e})\MW{)}
\tr\des(\;)\ =\ ()()()()\tr\tr(\;\openCurl\closeCurl\;) =\ \tr()\tr()\tr()\vec{\alpha}\alpha_1,\ldots,\alpha_mm > 0\MB{T}_1, \ldots, \MB{T}_n, \MB{U}\vec{\alpha}\alpha\alpha\beta\typesOf{pm}\typesOf{pM}\typesOf{p}\typesOf{pm}\MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{pm}\MB{pm} :: \MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{pm[e}_1\MB{,}\ldots\MB{,e}_n\MB{]}\MB{e}_1 :: t_1, \ldots, \MB{e}_n :: t_n, \MB{pm[e}_1\MB{,}\ldots\MB{,e}_n\MB{]} :: u\MB{pm[e}_1\MB{,}\ldots\MB{,e}_n\MB{:= f]}\MB{e}_1 :: t_1, \ldots, \MB{e}_n :: t_n, \MB{f} :: u\MB{f(it)}\MB{it} :: \MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{function f(pm: pM)}\MB{pm} := \MB{it}\MB{it} :: \MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{pm[e}_1\MB{,}\ldots\MB{,e}_n\MB{]} := \MB{f}\MB{e}_1 :: t_1, \ldots, \MB{e}_n :: t_n, \MB{f} :: u\MB{havoc pm}\MB{call}\;\MB{p(it)}\MB{it} :: \MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{procedure p(pm: pM)}\MB{call it :=}\;\MB{p()}\MB{it} :: \MB{[}t_1\MB{,} \ldots\MB{,} t_n\MB{]}u\MB{procedure p() returns(pm: pM)}\typesOf{pm}\MB{x} :: tt\typesOf{pM}\typesOf{m} = \{ \MB{[int]int}, \MB{[\\beta]\\beta} \}\typesOf{n} = \{ \MB{[bool]bool} \}\typesOf{M} = \typesOf{m} \cup \typesOf{n}\beta\ctypesOf{pM}\typesOf{pM}n\vec{a} = a_1, \ldots, a_nT\vec{\alpha}T_{\vec{a}}Ta_k\alpha_kk = 1, \ldots, n\BBTT\typesOf{pM}\MB{(}\BBT\MB{)}\BBT\MB{(id_}\BBT\MB{)}\MB{id_}\vec{t}T_{\vec{t}}\BBTT = \MB{[\\alpha]\\alpha}T_{\MB{int}} = \MB{[int]int}\MB{(}\typesOf{m}\MB{)} = (\MB{[int]int,} \MB{[\\beta]\\beta})\MB{(j_}\typesOf{m}\MB{)} = \MB{(j_int, j_\\beta)}_kk = 1, \ldots, nM_{\MB{a}}\MB{[T}_1\MB{,} \ldots \MB{,T}_n\MB{] U}\alpha_k_k\concPlus{pM} = \ctypesOf{pM} \cup \{M_{\MB{a}}\}\MB{(pm_}\concPlus{pM}\MB{)): (}\concPlus{pM}\MB{)}\MB{(g_}\concPlus{pM}\MB{)}\MB{(x: (}\concPlus{pM}\MB{)}\vec{\beta}\MB{x}\colon XX\vec{\beta}\MB{[}V_1\MB{,}\ldots\MB{,}V_n\MB{]}V_0\typesOf{pM}X = V_kk = 0, \ldots, n\MB{(g_}\mathbb{V}_k\MB{)(x: (}\mathbb{V}_k\MB{))}\mathbb{V}_k = \left\{ \overline{V}_k \mid \MB{[}\overline{V}_1\MB{,}\ldots\MB{,}\overline{V}_n\MB{]}\overline{V}_0 \in \concPlus{pM} \right\}k\MB{[\\beta]\\beta} \in \typesOf{M}\beta\MB{w_}c\MB{W}_c = \MB{C}\MB{(w_}X\MB{)}\beta\tr\des\encm\muM\Sigmam\muM\Sigmam\muM\Sigma\mu\forall\not\exists\mu\Sigma\infty\mu\forall\not\exists\mu\Sigma\infty\mu\forall\not\exists\mu\Sigma\infty\mu\forall\not\exists\mu\Sigma\infty\mu\forall\not\exists\mu\Sigma\infty\mu\forall\not\exists\mu\Sigma\forall\tr\tr\tr$, as implemented by \btw, largely meets the other goal of preserving \emph{verifiability}: even if the experimental subjects all are idiomatic \Boogie programs written independent of the translation effort, 83\% of the translated programs behave in \Why as they do in \Boogie.

In future work, we will address the features of \Boogie that are still not satisfactorily supported by \btw.
We will also devise strategies to take advantage of \Why's multi-prover support.
Other possible directions include formalizing the translation to prove that it preserves correctness; and devising a reverse translation from \WhyML to \Boogie.



\begin{thebibliography}{10}

\bibitem{ArltS12}
S.~Arlt and M.~Sch{\"{a}}f.
\newblock {Joogie}: Infeasible code detection for {Java}.
\newblock In {\em Proceedings of CAV}, volume 7358 of {\em LNCS}, pages
  767--773. Springer, 2012.

\bibitem{boogie-baseref}
M.~Barnett, B.~E. Chang, R.~DeLine, B.~Jacobs, and K.~R.~M. Leino.
\newblock {B}oogie: {A} modular reusable verifier for object-oriented programs.
\newblock In {\em Proceedings of FMCO}, volume 4111 of {\em LNCS}, pages
  364--387. Springer, 2006.

\bibitem{BarnettFLMSV11}
M.~Barnett, M.~F{\"{a}}hndrich, K.~R.~M. Leino, P.~M{\"{u}}ller, W.~Schulte,
  and H.~Venter.
\newblock Specification and verification: the {S}pec{\#} experience.
\newblock {\em Commun. {ACM}}, 54(6):81--91, 2011.

\bibitem{BohmeLW08}
S.~B{\"{o}}hme, K.~R.~M. Leino, and B.~Wolff.
\newblock {HOL-Boogie} -- an interactive prover for the {Boogie}
  program-verifier.
\newblock In {\em Proceedings of TPHOLs}, volume 5170, pages 150--166.
  Springer, 2008.

\bibitem{ChengMP15}
Z.~Cheng, R.~Monahan, and J.~F. Power.
\newblock A sound execution semantics for {ATL} via translation validation --
  research paper.
\newblock In {\em Proceedings of ICMT}, volume 9152 of {\em LNCS}, pages
  133--148. Springer, 2015.

\bibitem{ClochardFMP14}
M.~Clochard, J.~Filli{\^{a}}tre, C.~March{\'{e}}, and A.~Paskevich.
\newblock Formalizing semantics with an automatic program verifier.
\newblock In {\em Proceedings of VSTTE}, volume 8471 of {\em LNCS}, pages
  37--51, 2014.

\bibitem{Z3}
L.~M. de~Moura and N.~Bj{\o}rner.
\newblock {Z3}: An efficient {SMT} solver.
\newblock In {\em Proceedings of TACAS}, pages 337--340, 2008.

\bibitem{FilliatreP13}
J.~Filli{\^{a}}tre and A.~Paskevich.
\newblock {Why3} -- where programs meet provers.
\newblock In {\em Proceedings of ESOP}, volume 7792 of {\em LNCS}, pages
  125--128. Springer, 2013.

\bibitem{F14-TR-20062014}
C.~A. Furia.
\newblock Rotation of sequences: Algorithms and proofs.
\newblock \url{http://arxiv.org/abs/1406.5453}, June 2014.

\bibitem{FMV-CSUR14}
C.~A. Furia, B.~Meyer, and S.~Velder.
\newblock Loop invariants: Analysis, classification, and examples.
\newblock {\em ACM Computing Surveys}, 46(3):Article 34, 2014.

\bibitem{Harel-folk}
D.~Harel.
\newblock On folk theorems.
\newblock {\em Commun. ACM}, 23(7):379--389, 1980.

\bibitem{HeuleKMS13}
S.~Heule, I.~T. Kassios, P.~M{\"{u}}ller, and A.~J. Summers.
\newblock Verification condition generation for permission logics with abstract
  predicates and abstraction functions.
\newblock In {\em Proceedings of {ECOOP}}, volume 7920 of {\em LNCS}, pages
  451--476. Springer, 2013.

\bibitem{KleinAEHCDEEKNSTW10}
G.~Klein, J.~Andronick, K.~Elphinstone, G.~Heiser, D.~Cock, P.~Derrin,
  D.~Elkaduwe, K.~Engelhardt, R.~Kolanski, M.~Norrish, T.~Sewell, H.~Tuch, and
  S.~Winwood.
\newblock {seL4}: formal verification of an operating-system kernel.
\newblock {\em Commun. {ACM}}, 53(6):107--115, 2010.

\bibitem{KumarMNO14}
R.~Kumar, M.~O. Myreen, M.~Norrish, and S.~Owens.
\newblock {CakeML}: a verified implementation of {ML}.
\newblock In {\em Proceedings of POPL}, pages 179--192. {ACM}, 2014.

\bibitem{BoogieManual}
K.~R.~M. Leino.
\newblock This is {B}oogie 2, 2008.
\newblock \url{http://goo.gl/QsH6g}.

\bibitem{Leino04}
K.~R.~M. Leino.
\newblock Developing verified programs with {Dafny}.
\newblock In {\em Proceedings of ICSE}, pages 1488--1490. ACM, 2013.

\bibitem{LeinoP13}
K.~R.~M. Leino and N.~Polikarpova.
\newblock Verified calculations.
\newblock In {\em Proceedings of VSTTE}, pages 170--190, 2013.

\bibitem{Leroy09}
X.~Leroy.
\newblock Formal verification of a realistic compiler.
\newblock {\em Commun. {ACM}}, 52(7):107--115, 2009.

\bibitem{symbooglix}
S.~Liew, C.~Cadar, and A.~Donaldson.
\newblock {Symbooglix}: A symbolic execution engine for {Boogie} programs.
\newblock In {\em Proceedings of ICST}. IEEE, 2016.

\bibitem{MensG06}
T.~Mens and P.~{Van Gorp}.
\newblock A taxonomy of model transformation.
\newblock {\em Electr. Notes Theor. Comput. Sci.}, 152:125--142, 2006.

\bibitem{PFW-RV13}
N.~Polikarpova, C.~A. Furia, and S.~West.
\newblock To run what no one has run before: Executing an intermediate
  verification language.
\newblock In {\em Proceedings of RV}, volume 8174 of {\em LNCS}, pages
  251--268. Springer, 2013.

\bibitem{SarkarWD05}
D.~Sarkar, O.~Waddell, and R.~K. Dybvig.
\newblock Educational pearl: {A} nanopass framework for compiler education.
\newblock {\em J. Funct. Program.}, 15(5):653--667, 2005.

\bibitem{SchmittUW10}
P.~H. Schmitt, M.~Ulbrich, and B.~Wei{\ss}.
\newblock Dynamic frames in {J}ava dynamic logic.
\newblock In {\em Proceedings of FoVeOOS}, volume 6528 of {\em LNCS}, pages
  138--152. Springer, 2011.

\bibitem{Pilar-VSTTE}
L.~Segal and P.~Chalin.
\newblock A comparison of intermediate verification languages: {Boogie} and
  {Sireum/Pilar}.
\newblock In {\em Proceedings of VSTTE}, volume 7152 of {\em LNCS}, pages
  130--145. Springer, 2012.

\bibitem{Stevens07}
P.~Stevens.
\newblock A landscape of bidirectional model transformations.
\newblock In {\em Proceedings of GTTSE}, volume 5235 of {\em LNCS}, pages
  408--424. Springer, 2008.

\bibitem{TFNM-ECOOP13}
M.~Trudel, C.~A. Furia, M.~Nordio, and B.~Meyer.
\newblock Really automatic scalable object-oriented reengineering.
\newblock In {\em Proceedings of ECOOP}, volume 7920 of {\em LNCS}, pages
  477--501. Springer, 2013.

\bibitem{TFNMO12-WCRE12}
M.~Trudel, C.~A. Furia, M.~Nordio, B.~Meyer, and M.~Oriol.
\newblock {C} to {O-O} translation: Beyond the easy stuff.
\newblock In {\em Proceedings of WCRE}, pages 19--28. IEEE Computer Society,
  October 2012.

\bibitem{TFNP-TACAS15}
J.~Tschannen, C.~A. Furia, M.~Nordio, and N.~Polikarpova.
\newblock {A}uto{P}roof: Auto-active functional verification of object-oriented
  programs.
\newblock In {\em Proceedings of TACAS}, volume 9035 of {\em LNCS}, pages
  566--580. Springer, 2015.

\end{thebibliography}
 


\iflong


\newpage
\clearpage
\appendix

\begin{table}
\centering
\scriptsize
\begin{tabular}{l |r *{1}{rr} |r *{4}{rr}}
\multicolumn{1}{c}{} &
\multicolumn{3}{c}{\textsc{\Boogie}} &
\multicolumn{9}{c}{\textsc{\Why}}
\\
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{2}{c}{\textsc{Z3}} &
\multicolumn{1}{c}{} &
\multicolumn{2}{c}{\textsc{Alt-Ergo}} &
\multicolumn{2}{c}{\textsc{CVC3}} &
\multicolumn{2}{c}{\textsc{CVC4}} &
\multicolumn{2}{c}{\textsc{Z3}}
\\
\multicolumn{1}{c}{\textsc{name}} &
\multicolumn{1}{c}{\textsc{loc}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{loc}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}}
\\
\hline
\verb|inv_survey/array_partitioning_v1|  &  42  &  100  &  0.5  &  100  &  50  &  20.1  &  50  &  0.2  &  50  &  21.3  &  50  &  20.3  \\
\verb|inv_survey/array_partitioning_v2|  &  53  &  100  &  0.4  &  125  &  100  &  0.3  &  50  &  0.1  &  50  &  21.3  &  100  &  0.1  \\
\verb|inv_survey/array_stack_reversal|  &  125  &  100  &  0.5  &  204  &  100  &  0.3  &  86  &  0.2  &  71  &  42.5  &  86  &  20.3  \\
\verb|inv_survey/bst|  &  153  &  100  &  0.4  &  258  &  50  &  40.5  &  50  &  0.2  &  75  &  21.4  &  75  &  20.3  \\
\verb|inv_survey/bubble_sort_basic|  &  49  &  100  &  0.5  &  113  &  100  &  0.2  &  50  &  0.1  &  50  &  21.3  &  100  &  0.2  \\
\verb|inv_survey/bubble_sort_improved|  &  53  &  100  &  0.5  &  118  &  100  &  0.6  &  50  &  0.2  &  50  &  21.3  &  100  &  0.1  \\
\verb|inv_survey/comb_sort|  &  56  &  100  &  0.4  &  124  &  100  &  0.3  &  50  &  0.2  &  50  &  21.3  &  100  &  0.2  \\
\verb|inv_survey/dutch_flag|  &  63  &  100  &  0.5  &  133  &  50  &  20.1  &  50  &  0.2  &  50  &  21.3  &  100  &  0.1  \\
\verb|inv_survey/insertion_sort|  &  47  &  100  &  0.6  &  100  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  100  &  0.2  \\
\verb|inv_survey/knapsack|  &  50  &  100  &  0.3  &  97  &  100  &  7.5  &  0  &  0.1  &  0  &  21.2  &  100  &  0.1  \\
\verb|inv_survey/Levenshtein_distance|  &  43  &  100  &  0.3  &  91  &  100  &  0.4  &  0  &  0.1  &  100  &  0.9  &  100  &  0.1  \\
\verb|inv_survey/max_of_array_v1|  &  20  &  100  &  0.4  &  66  &  100  &  0.1  &  0  &  0.1  &  0  &  21.2  &  100  &  0.1  \\
\verb|inv_survey/max_of_array_v2|  &  20  &  100  &  0.4  &  66  &  100  &  0.2  &  0  &  0.1  &  0  &  21.2  &  100  &  0.1  \\
\verb|inv_survey/partition|  &  63  &  100  &  0.4  &  137  &  100  &  0.8  &  50  &  0.1  &  50  &  21.3  &  100  &  0.1  \\
\verb|inv_survey/plateau|  &  43  &  100  &  0.5  &  84  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.3  \\
\verb|inv_survey/reverse|  &  68  &  100  &  0.4  &  131  &  100  &  0.3  &  0  &  0.1  &  0  &  21.3  &  100  &  0.1  \\
\verb|inv_survey/selection_sort|  &  72  &  100  &  0.4  &  160  &  100  &  4.9  &  33  &  0.2  &  33  &  42.4  &  100  &  0.2  \\
\verb|inv_survey/sequential_search_v1|  &  28  &  100  &  0.4  &  72  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|inv_survey/sequential_search_v2|  &  23  &  100  &  0.4  &  70  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|inv_survey/sum_of_array|  &  21  &  100  &  0.3  &  62  &  100  &  0.1  &  100  &  0.1  &  0  &  21.2  &  100  &  0.1  \\
\verb|inv_survey/welfare_crook|  &  44  &  100  &  0.3  &  86  &  100  &  0.1  &  0  &  0.1  &  100  &  0.8  &  0  &  20.2  \\
\verb|rotation/rotation_copy|  &  57  &  100  &  0.4  &  128  &  33  &  40.1  &  33  &  0.2  &  33  &  42.4  &  67  &  20.3  \\
\verb|rotation/rotation_copy_plain|  &  41  &  100  &  0.3  &  80  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  100  &  0.2  \\
\verb|rotation/rotation_reverse|  &  201  &  90  &  0.4  &  318  &  40  &  120.5  &  10  &  0.4  &  50  &  106.6  &  80  &  40.6  \\
\verb|rotation/rotation_swap-1_3|  &  48  &  0  &  0.3  &  88  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|rotation/rotation_swap-2_3|  &  175  &  60  &  0.4  &  201  &  20  &  80.2  &  20  &  0.2  &  20  &  84.7  &  40  &  60.6  \\
\verb|rotation/rotation_swap-3_3|  &  47  &  100  &  0.3  &  96  &  67  &  20.1  &  67  &  0.2  &  67  &  21.3  &  100  &  0.2  \\
\verb|rotation/rotation_swap_iterative-1_2|  &  152  &  100  &  0.5  &  184  &  33  &  40.2  &  33  &  0.2  &  33  &  42.4  &  67  &  20.3  \\
\verb|rotation/rotation_swap_iterative-2_2|  &  253  &  60  &  0.4  &  224  &  20  &  80.2  &  20  &  0.3  &  20  &  84.7  &  40  &  60.6
 \\
 \hline
\verb|oo/autoproof_account|  &  385  &  0  &  0.4  &  446  &  0  &  80.2  &  0  &  0.4  &  0  &  84.8  &  0  &  80.8  \\
\verb|oo/binary_search|  &  68  &  100  &  0.4  &  158  &  67  &  20.1  &  67  &  0.2  &  100  &  0.2  &  100  &  0.2  \\
\verb|oo/joogie_examples|  &  187  &  60  &  0.5  &  277  &  60  &  40.2  &  60  &  0.2  &  60  &  42.4  &  60  &  40.4  \\
\verb|oo/joogie_helloWorld|  &  142  &  50  &  0.5  &  175  &  50  &  20.1  &  50  &  0.1  &  50  &  21.3  &  50  &  20.3  \\
\verb|oo/linked_list_max|  &  44  &  100  &  0.4  &  90  &  100  &  0.2  &  100  &  0.1  &  100  &  0.2  &  100  &  0.1  \\
\verb|oo/rotation_by_copy|  &  52  &  0  &  21.0  &  99  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  100  &  0.3
 \\
 \end{tabular}
\caption{Results for the programs in groups \nat (above the horizontal line) and \obj (below it) in the experiments. 
For each program (\textsc{name}) the \Boogie program length in non-comment non-empty lines of code (\textsc{loc}) and the length of its \textsc{\Why} translation; and, for both \Boogie and \Why, for each choice of SMT solver among \textsc{Alt-Ergo}, \textsc{CVC3}, and \textsc{Z3}: the percentage of goals verified in each program (\textsc{\% v.}) and the verification time (\textsc{t}) in seconds (with a timeout of 180 seconds).}
\label{tab:programs-full-boogie-oo}
\end{table}

\clearpage

\begin{scriptsize}
\begin{longtable}{l |r *{1}{rr} |r *{4}{rr}}
\multicolumn{1}{c}{} &
\multicolumn{3}{c}{\textsc{\Boogie}} &
\multicolumn{9}{c}{\textsc{\Why}}
\\
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{2}{c}{\textsc{Z3}} &
\multicolumn{1}{c}{} &
\multicolumn{2}{c}{\textsc{Alt-Ergo}} &
\multicolumn{2}{c}{\textsc{CVC3}} &
\multicolumn{2}{c}{\textsc{CVC4}} &
\multicolumn{2}{c}{\textsc{Z3}}
\\
\multicolumn{1}{c}{\textsc{name}} &
\multicolumn{1}{c}{\textsc{loc}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{loc}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}} &
\multicolumn{1}{c}{\textsc{\% v.}} &
\multicolumn{1}{c}{\textsc{t}}
\\
\hline
\endhead
\verb|doomed/doomdebug|  &  36  &  0  &  0.3  &  86  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.4  \\
\verb|doomed/doomed|  &  73  &  43  &  0.3  &  185  &  43  &  80.2  &  43  &  0.1  &  43  &  84.7  &  43  &  80.7  \\
\verb|doomed/notdoomed|  &  43  &  50  &  0.3  &  107  &  50  &  40.1  &  50  &  0.1  &  50  &  42.4  &  50  &  40.4  \\
\verb|doomed/smoke0|  &  61  &  67  &  0.3  &  148  &  67  &  40.1  &  67  &  0.2  &  67  &  42.4  &  67  &  40.4  \\
\verb|lock/Lock|  &  86  &  100  &  0.4  &  163  &  67  &  20.1  &  67  &  0.1  &  67  &  21.3  &  67  &  20.2  \\
\verb|lock/LockIncorrect|  &  34  &  0  &  0.3  &  64  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|smoke/smoke0|  &  41  &  100  &  0.3  &  108  &  100  &  0.1  &  100  &  0.1  &  100  &  0.2  &  100  &  0.1  \\
\verb|snapshots/Snapshots0.v0|  &  16  &  0  &  0.3  &  72  &  0  &  80.1  &  0  &  0.1  &  0  &  84.6  &  0  &  80.6  \\
\verb|snapshots/Snapshots0.v1|  &  16  &  50  &  0.3  &  72  &  50  &  40.1  &  50  &  0.1  &  50  &  42.4  &  50  &  40.3  \\
\verb|snapshots/Snapshots0.v2|  &  12  &  67  &  0.3  &  60  &  67  &  20.1  &  67  &  0.1  &  67  &  21.3  &  67  &  20.3  \\
\verb|snapshots/Snapshots1.v0|  &  10  &  50  &  0.3  &  48  &  50  &  20.1  &  50  &  0.1  &  50  &  21.3  &  50  &  20.2  \\
\verb|snapshots/Snapshots1.v1|  &  10  &  50  &  0.3  &  48  &  50  &  20.1  &  50  &  0.1  &  50  &  21.2  &  50  &  20.3  \\
\verb|snapshots/Snapshots1.v2|  &  11  &  50  &  0.3  &  50  &  50  &  20.1  &  50  &  0.1  &  50  &  21.2  &  50  &  20.2  \\
\verb|snapshots/Snapshots10.v0|  &  14  &  100  &  0.3  &  48  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots10.v1|  &  14  &  100  &  0.3  &  48  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots11.v0|  &  10  &  0  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots11.v1|  &  10  &  0  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots12.v0|  &  12  &  100  &  0.4  &  41  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots12.v1|  &  12  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots13.v0|  &  16  &  100  &  0.3  &  43  &  100  &  0.1  &  100  &  0.0  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots13.v1|  &  12  &  0  &  0.4  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots14.v0|  &  16  &  100  &  0.3  &  43  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots14.v1|  &  16  &  0  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots15.v0|  &  11  &  100  &  0.3  &  42  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots15.v1|  &  11  &  0  &  0.3  &  42  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots16.v0|  &  11  &  100  &  0.3  &  40  &  100  &  0.1  &  0  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots16.v1|  &  11  &  0  &  0.3  &  40  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots17.v0|  &  22  &  100  &  0.3  &  61  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots17.v1|  &  22  &  0  &  0.3  &  61  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots18.v0|  &  18  &  100  &  0.3  &  53  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots18.v1|  &  18  &  0  &  0.3  &  53  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots19.v0|  &  8  &  0  &  0.3  &  39  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots19.v1|  &  8  &  0  &  0.3  &  39  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots2.v0|  &  9  &  100  &  0.3  &  38  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots2.v1|  &  9  &  100  &  0.3  &  38  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots2.v2|  &  10  &  100  &  0.3  &  40  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots2.v3|  &  10  &  100  &  0.3  &  40  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots2.v4|  &  10  &  100  &  0.3  &  40  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots2.v5|  &  11  &  100  &  0.3  &  42  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots20.v0|  &  16  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots20.v1|  &  16  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  0  &  20.2  \\
\verb|snapshots/Snapshots21.v0|  &  13  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots21.v1|  &  13  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots22.v0|  &  13  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots22.v1|  &  13  &  100  &  0.3  &  41  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots23.v0|  &  17  &  50  &  0.3  &  52  &  50  &  20.1  &  50  &  0.1  &  50  &  21.2  &  50  &  20.2  \\
\verb|snapshots/Snapshots23.v1|  &  18  &  50  &  0.3  &  53  &  50  &  20.1  &  50  &  0.1  &  50  &  21.3  &  50  &  20.2  \\
\verb|snapshots/Snapshots23.v2|  &  17  &  50  &  0.3  &  52  &  50  &  20.1  &  50  &  0.1  &  50  &  21.2  &  50  &  20.2  \\
\verb|snapshots/Snapshots24.v0|  &  23  &  0  &  0.3  &  51  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  0  &  20.2  \\
\verb|snapshots/Snapshots24.v1|  &  23  &  0  &  0.3  &  51  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  0  &  20.2  \\
\verb|snapshots/Snapshots25.v0|  &  11  &  0  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots25.v1|  &  11  &  0  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots26.v0|  &  11  &  0  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  0  &  20.2  \\
\verb|snapshots/Snapshots26.v1|  &  12  &  0  &  0.3  &  48  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots27.v0|  &  11  &  0  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots27.v1|  &  13  &  0  &  0.3  &  51  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots28.v0|  &  11  &  100  &  0.3  &  48  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots28.v1|  &  12  &  0  &  0.4  &  48  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots29.v0|  &  11  &  100  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots29.v1|  &  11  &  0  &  0.3  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots3.v0|  &  13  &  100  &  0.3  &  41  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots3.v1|  &  13  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots30.v0|  &  11  &  0  &  0.3  &  42  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots30.v1|  &  12  &  0  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots31.v0|  &  12  &  100  &  0.3  &  44  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots31.v1|  &  11  &  0  &  0.4  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots32.v0|  &  12  &  100  &  0.4  &  44  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots32.v1|  &  9  &  0  &  0.3  &  41  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots33.v0|  &  12  &  100  &  0.3  &  44  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots33.v1|  &  6  &  100  &  0.4  &  37  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots34.v0|  &  6  &  100  &  0.3  &  38  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots34.v1|  &  5  &  0  &  0.3  &  36  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots35.v0|  &  6  &  100  &  0.3  &  38  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots35.v1|  &  5  &  0  &  0.3  &  36  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots36.v0|  &  11  &  100  &  0.4  &  44  &  100  &  0.1  &  0  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots36.v1|  &  11  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots37.v0|  &  7  &  100  &  0.3  &  42  &  100  &  0.1  &  0  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots37.v1|  &  7  &  0  &  0.3  &  42  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots38.v0|  &  10  &  100  &  0.4  &  43  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots38.v1|  &  11  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots38.v2|  &  11  &  100  &  0.3  &  44  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots39.v0|  &  10  &  100  &  0.3  &  43  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots39.v1|  &  11  &  0  &  0.4  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots39.v2|  &  11  &  100  &  0.3  &  44  &  100  &  0.1  &  0  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots4.v0|  &  23  &  100  &  0.3  &  64  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.2  \\
\verb|snapshots/Snapshots4.v1|  &  27  &  50  &  0.3  &  76  &  50  &  40.1  &  50  &  0.1  &  50  &  42.4  &  50  &  40.4  \\
\verb|snapshots/Snapshots40.v0|  &  11  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots40.v1|  &  12  &  0  &  0.3  &  45  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots40.v2|  &  12  &  0  &  0.3  &  45  &  0  &  20.0  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots41.v0|  &  31  &  40  &  0.3  &  99  &  40  &  60.2  &  40  &  0.1  &  40  &  63.5  &  40  &  60.5  \\
\verb|snapshots/Snapshots41.v1|  &  31  &  40  &  0.3  &  100  &  40  &  60.1  &  40  &  0.2  &  40  &  63.5  &  40  &  60.5  \\
\verb|snapshots/Snapshots5.v0|  &  9  &  100  &  0.3  &  39  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots5.v1|  &  9  &  0  &  0.3  &  39  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots6.v0|  &  12  &  100  &  0.3  &  43  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots6.v1|  &  12  &  0  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|snapshots/Snapshots7.v0|  &  14  &  100  &  0.3  &  45  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots7.v1|  &  14  &  100  &  0.3  &  45  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots8.v0|  &  11  &  100  &  0.3  &  45  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots8.v1|  &  11  &  100  &  0.3  &  45  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots9.v0|  &  13  &  100  &  0.4  &  47  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|snapshots/Snapshots9.v1|  &  11  &  100  &  0.3  &  45  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|test13/ErrorTraceTestLoopInvViolationBPL|  &  19  &  0  &  0.3  &  86  &  0  &  60.1  &  0  &  0.1  &  0  &  63.5  &  0  &  60.5  \\
\verb|test15/CaptureState|  &  23  &  0  &  0.3  &  62  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test15/InterpretedFunctionTests|  &  15  &  0  &  0.3  &  66  &  0  &  60.1  &  0  &  0.1  &  0  &  63.5  &  0  &  60.5  \\
\verb|test15/IntInModel|  &  3  &  0  &  0.3  &  36  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test15/ModelTest|  &  10  &  0  &  0.3  &  49  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test15/NullInModel|  &  5  &  0  &  0.3  &  39  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test16/LoopUnroll|  &  63  &  0  &  0.3  &  124  &  0  &  60.1  &  0  &  0.1  &  0  &  63.5  &  0  &  60.5  \\
\verb|test17/contractinfer|  &  21  &  0  &  0.3  &  68  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.3  \\
\verb|test2/AssertVerifiedUnder0|  &  26  &  50  &  0.3  &  100  &  0  &  120.2  &  0  &  0.2  &  0  &  126.9  &  0  &  120.9  \\
\verb|test2/AssumeEnsures|  &  53  &  57  &  0.3  &  124  &  57  &  60.2  &  57  &  0.2  &  57  &  63.6  &  57  &  60.5  \\
\verb|test2/AssumptionVariables0|  &  44  &  50  &  0.3  &  137  &  0  &  120.2  &  0  &  0.1  &  0  &  126.9  &  0  &  120.9  \\
\verb|test2/Axioms|  &  24  &  67  &  0.3  &  73  &  67  &  20.1  &  67  &  0.1  &  67  &  21.3  &  67  &  20.2  \\
\verb|test2/B|  &  65  &  100  &  0.3  &  112  &  0  &  80.1  &  0  &  0.1  &  0  &  84.6  &  0  &  80.7  \\
\verb|test2/Call|  &  49  &  40  &  0.3  &  117  &  20  &  80.2  &  20  &  0.1  &  20  &  84.6  &  20  &  80.6  \\
\verb|test2/ContractEvaluationOrder|  &  26  &  25  &  0.3  &  101  &  25  &  60.1  &  25  &  0.1  &  25  &  63.5  &  25  &  60.5  \\
\verb|test2/CutBackEdge|  &  35  &  20  &  0.3  &  96  &  0  &  100.2  &  0  &  0.1  &  0  &  105.8  &  0  &  100.7  \\
\verb|test2/Ensures|  &  61  &  50  &  0.5  &  168  &  50  &  100.2  &  50  &  0.3  &  50  &  105.9  &  50  &  100.8  \\
\verb|test2/False|  &  14  &  100  &  0.3  &  54  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|test2/FormulaTerm2|  &  36  &  50  &  0.3  &  104  &  50  &  40.1  &  50  &  0.2  &  50  &  42.4  &  50  &  40.4  \\
\verb|test2/FreeCall|  &  59  &  64  &  0.5  &  185  &  27  &  160.2  &  27  &  0.2  &  27  &  169.2  &  27  &  161.2  \\
\verb|test2/Implies|  &  28  &  0  &  0.3  &  97  &  0  &  100.1  &  0  &  0.1  &  0  &  105.7  &  0  &  100.7  \\
\verb|test2/InvariantVerifiedUnder0|  &  42  &  17  &  0.3  &  146  &  0  &  120.2  &  0  &  0.2  &  0  &  126.9  &  0  &  120.9  \\
\verb|test2/LoopInvAssume|  &  15  &  0  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test2/Passification|  &  155  &  64  &  0.5  &  290  &  18  &  180.0  &  18  &  0.3  &  18  &  180.0  &  18  &  180.0  \\
\verb|test2/Quantifiers|  &  122  &  57  &  0.4  &  254  &  86  &  40.3  &  64  &  0.3  &  79  &  63.8  &  93  &  20.3  \\
\verb|test2/SelectiveChecking|  &  31  &  25  &  0.3  &  121  &  0  &  80.1  &  0  &  0.1  &  0  &  84.6  &  0  &  80.6  \\
\verb|test2/sk_hack|  &  17  &  100  &  0.3  &  44  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test2/Timeouts0|  &  71  &  0  &  1.3  &  156  &  0  &  60.1  &  0  &  0.2  &  0  &  63.5  &  0  &  60.5  \\
\verb|test2/TypeEncodingM|  &  19  &  0  &  0.3  &  60  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/BooleanQuantification2|  &  9  &  0  &  0.3  &  46  &  0  &  20.1  &  0  &  0.0  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/Boxing|  &  15  &  0  &  0.5  &  49  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/Casts|  &  7  &  0  &  0.3  &  48  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/Colors|  &  13  &  0  &  0.3  &  62  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.4  \\
\verb|test21/DisjointDomains|  &  21  &  0  &  0.4  &  81  &  0  &  60.1  &  0  &  0.2  &  0  &  63.5  &  0  &  60.5  \\
\verb|test21/EmptySetBug|  &  18  &  0  &  0.4  &  54  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/FunAxioms|  &  24  &  50  &  0.5  &  81  &  50  &  20.1  &  50  &  0.1  &  50  &  21.3  &  50  &  20.2  \\
\verb|test21/FunAxioms2|  &  13  &  0  &  0.3  &  49  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/InterestingExamples3|  &  17  &  67  &  0.4  &  71  &  33  &  40.1  &  33  &  0.2  &  33  &  42.4  &  33  &  40.4  \\
\verb|test21/InterestingExamples5|  &  9  &  100  &  0.3  &  45  &  100  &  0.1  &  0  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|test21/Keywords|  &  5  &  100  &  0.3  &  38  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|test21/LargeLiterals0|  &  12  &  0  &  0.3  &  46  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/LetSorting|  &  11  &  100  &  0.3  &  43  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/Maps2|  &  14  &  100  &  0.3  &  52  &  100  &  0.1  &  0  &  0.1  &  100  &  0.2  &  0  &  20.2  \\
\verb|test21/Orderings|  &  13  &  50  &  0.4  &  59  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.4  \\
\verb|test21/Orderings2|  &  11  &  0  &  0.4  &  49  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/Orderings3|  &  22  &  0  &  0.4  &  78  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.4  \\
\verb|test21/Orderings4|  &  7  &  0  &  0.4  &  47  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test21/PolyList|  &  35  &  0  &  0.4  &  91  &  0  &  40.1  &  0  &  0.2  &  0  &  42.4  &  0  &  40.4  \\
\verb|test21/Triggers0|  &  34  &  50  &  0.4  &  92  &  50  &  20.1  &  50  &  0.1  &  0  &  42.4  &  50  &  20.2  \\
\verb|test21/Triggers1|  &  12  &  0  &  0.4  &  50  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test7/MultipleErrors|  &  14  &  0  &  0.3  &  42  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|test7/NestedVC|  &  20  &  50  &  0.3  &  61  &  0  &  40.1  &  0  &  0.1  &  0  &  42.4  &  0  &  40.3  \\
\verb|test7/UnreachableBlocks|  &  34  &  100  &  0.3  &  79  &  50  &  40.1  &  50  &  0.1  &  50  &  42.4  &  50  &  40.4  \\
\verb|textbook/Bubble|  &  47  &  100  &  0.4  &  110  &  0  &  20.1  &  0  &  0.1  &  0  &  21.3  &  0  &  20.2  \\
\verb|textbook/DutchFlag|  &  47  &  100  &  0.3  &  92  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2  \\
\verb|textbook/Find|  &  27  &  100  &  0.3  &  72  &  50  &  20.1  &  50  &  0.1  &  50  &  21.3  &  50  &  20.3  \\
\verb|textbook/McCarthy-91|  &  11  &  100  &  0.3  &  47  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  &  100  &  0.1  \\
\verb|textbook/TuringFactorial|  &  27  &  100  &  0.3  &  81  &  0  &  20.1  &  0  &  0.1  &  0  &  21.2  &  0  &  20.2
 \\
 \caption{Results for the programs in group \tes in the experiments.
The measures are the same as in \autoref{tab:programs-full-boogie-oo}.}
\label{tab:programs-full-tests}
\end{longtable}
\end{scriptsize}

\fi

\end{document}
