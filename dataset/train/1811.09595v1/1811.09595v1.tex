\documentclass[final,nonatbib]{article} \usepackage{nips_2018}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\graphicspath{ {figs/} }
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{cprotect}

\title{Spectral Multigraph Networks for Discovering and Fusing Relationships in Molecules}

\author{Boris Knyazev\thanks{This work was done while the author was an intern at SRI International.}  \  \& Graham W.~Taylor\\
	University of Guelph, Canada \\
	Vector Institute for Artificial Intelligence, Canada \\
	Canadian Institute for Advanced Research\\
	\texttt{\{bknyazev,gwtaylor\}@uoguelph.ca} \\
	\And
	Xiao Lin \& Mohamed R.~Amer \\
	SRI International \\
	201 Washington Rd\\
	Princeton, NJ08540, USA\\
	\texttt{\{xiao.lin,mohamed.amer\}@sri.com}
}





\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

	\maketitle
\begin{abstract}
		Spectral Graph Convolutional Networks (GCNs) are a generalization of convolutional networks to learning on graph-structured data.
Applications of spectral GCNs have been successful, but \textit{limited} to a few problems where the graph is fixed, such as shape correspondence and node classification. In this work, we address this limitation by revisiting a particular family of spectral graph networks, Chebyshev GCNs, showing its efficacy in solving graph classification tasks with a variable graph structure and size. Chebyshev GCNs restrict graphs to have at most one edge between any pair of nodes. To this end, we propose a novel \textit{multigraph} network that learns from multi-relational graphs. We model learned edges with abstract meaning and experiment with different ways to fuse the representations extracted from annotated and learned edges, achieving competitive results on a variety of chemical classification benchmarks.
	\end{abstract}
\section{Introduction}\label{sec:intro}
	Convolutional Neural Networks (CNNs) have seen wide success in domains where data is restricted to a Euclidean space. These methods exploit properties such as stationarity of the data distributions, locality and a well-defined notation of translation, but cannot model data that is non-Euclidean in nature. Such structure is naturally present in many domains, such as chemistry, physics, social networks, transportation systems, and 3D geometry, and can be expressed by graphs~\cite{bronstein2017geometric, hamilton2017representation}. By defining an operation on graphs analogous to convolution, Graph Convolutional Networks (GCNs) have extended CNNs to graph-based data. The earliest methods performed convolution in the spectral domain~\cite{bruna2013spectral}, but subsequent work has proposed generalizations of convolution in the spatial domain. There have been multiple successful applications of GCNs to node classification~\cite{velickovic2017graph} and link prediction~\cite{schlichtkrull2018modeling}, whereas we target graph classification similarly to~\cite{simonovsky2017dynamic}.

	Our focus is on multigraphs, a graph that is permitted to have multiple edges. Multigraphs are important in many domains, such as chemistry and physics.
	The challenge of generalizing convolution to graphs and multigraphs is to have anisotropic convolution kernels (such as edge detectors). Anisotropic models, such as MoNet \cite{monti2017geometric} and SplineCNN~\cite{fey2018splinecnn}, rely on coordinate structure, work well for vision tasks, but are suboptimal for non-visual graph problems. Other general models exist~\cite{gilmer2017neural, battaglia2018relational}, but making them efficient for a variety of tasks conflicts with the ``no free lunch theorem''.

	Compared to non-spectral GCNs, spectral models have filters with more global support, which is important for capturing complex relationships. We rely on Chebyshev GCNs (ChebNet)~\cite{defferrard2016convolutional} that enjoy an explicit control of receptive
	field size. Even though it was originally derived from spectral methods~\cite{bruna2013spectral}, it does not suffer from their main shortcoming --- sensitivity of learned filters to graph size and structure.

	\textbf{Contributions:} We propose a scalable spectral GCN that learns from multigraphs by capturing multi-relational graph paths as well as multiplicative and additive interactions to reduce model complexity and learn richer representations. We also learn new abstract relationships between graph nodes, beyond the ones annotated in the datasets. To our knowledge, we are the first to demonstrate that spectral methods can efficiently solve problems with variable graph size and structure, where this kind of method is generally believed not to perform well.

	\section{Multigraph Convolution}\label{sec:multigraph}
	While we provide the background to understand our model, a review of spectral graph methods is beyond the scope of this paper. Section~\ref{sec:spectral_graph_conv_details} of the Appendix reviews spectral graph convolution.\looseness=-1
\subsection{Approximate spectral graph convolution}
\label{sec:spectral_graph_conv}
We consider an undirected, possibly disconnected, graph  with  nodes, , and edges, , having values in range . Nodes  usually represent specific semantic concepts such as atoms in a chemical compound or users in a social network. Nodes can also denote abstract blocks of information with common properties, such as superpixels in images. Edges  define the relationships between nodes and the scope over which node effects may propagate.

	In spectral graph convolution~\cite{bruna2013spectral}, the filter  is defined on an entire input space.
	Although it makes filters global, which helps to capture complex relationships, it is also desirable to have local support since the data often have local structure and since we want to learn filters independent on the input size  to make the model scalable.

	To address this issue, we can model this filter as a function of eigenvalues  (which is assumed to be constant) of the normalized symmetric graph Laplacian : . We can then approximate it as a sum of  terms using the Chebyshev expansion, where each term  contains powers . Finally, we apply the property of eigendecomposition:
	
	By combining this property with the Chebyshev expansion of , we exclude eigenvectors , that are often infeasible to compute, from spectral graph convolution, and instead express the convolution as a function of graph Laplacian .
	In general, for the input  with  nodes and -dimensional features in each node, the approximate convolution is defined as:

where  are features projected onto the Chebyshev basis  and concatenated for all orders  and  are trainable weights, where .

	This approximation scheme was proposed in~\cite{defferrard2016convolutional}, and Eq.~\ref{eq:cheb_conv_general} defines the convolutional layer in the Chebyshev GCN (ChebNet), which is the basis for our method. Convolution is an essential computational block in graph networks, since it permits the gradual aggregation of information from neighboring nodes. By stacking the operator in~Eq.~\ref{eq:cheb_conv_general}, we capture increasingly larger neighborhoods and learn complex relationships in graph-structured data.
\subsection{Graphs with variable structure and size}
	\label{sec:graph_structure_size}
The approximate spectral graph convolution (Eq.~\ref{eq:cheb_conv_general}) enforces spatial locality of the filters by controlling the order of the Chebyshev polynomial . Importantly, it reduces the computational complexity of spectral convolution from  to , making it much faster in practice assuming the graph is sparsely connected and sparse matrix multiplication is implemented.
	In this work, we observe an important byproduct of this scheme: that learned filters become less sensitive to changes in graph structure and size due to excluding the eigenvectors  from spectral convolution, so that learned filters are not tied to .

	\begin{figure}[]
		\begin{center}
			\vspace{-5pt}
			\begin{tabular}{ccc}
\includegraphics[width=0.25\textwidth, trim={0.8cm 0cm 0cm 0cm}, clip]{ENZYMES_eigenvalues.pdf} &
				\includegraphics[width=0.25\textwidth, trim={0.8cm 0cm 0cm 0cm}, clip]{MUTAG_eigenvalues.pdf} &
				\includegraphics[width=0.25\textwidth, trim={0.8cm 0cm 0cm 0cm}, clip]{NCI1_eigenvalues.pdf} \\
				(a) ENZYMES & (b) MUTAG & (c) NCI1
				\vspace{-10pt}
			\end{tabular}
		\end{center}
		\caption{Histograms of eigenvalues of the rescaled graph Laplacian  for the (a) ENZYMES, (b) MUTAG and (c) NCI1 datasets. Due to the property of eigendecomposition () the distribution of eigenvalues shrinks when we take powers of  to compute the approximate spectral graph convolution (Eq.~\ref{eq:cheb_conv_general}).
		}
		\label{fig:eigen_distr}
	\end{figure}

	The only assumption that still makes a trainable filter  sensitive to graph structure is that we model it as a function of eigenvalues . However, the distribution of eigenvalues of the normalized Laplacian is concentrated in a limited range, making it a weaker dependency on graphs than the spectral convolution via eigenvectors, so that learned filters generalize well to new graphs. Moreover, since we use powers of  in performing convolution (Eq.~\ref{eq:cheb_conv_general}),
	the distribution of eigenvalues  further contracts due to exponentiation of the middle term on the RHS of Eq.~\ref{eq:eigen_property_power}. We believe that this effect accounts for the robustness of learned filters to changes in graph size or structure (Figure~\ref{fig:eigen_distr}).

	\subsection{Graphs with multiple relation types}
	\label{sec:edge_fusion_methods}
In the approximate spectral graph convolution (Eq.~\ref{eq:cheb_conv_general}), the graph Laplacian  encodes a single relation type between nodes. Yet, a graph may describe many types of distinct relations.
	In this section, we address this limitation by extending Eq.~\ref{eq:cheb_conv_general} to a multigraph, i.e.~a graph with multiple () edges (relations) between the same nodes encoded as a set of graph Laplacians , where  is an upper bound on the number of edges per dyad.
	Extensions to a multigraph can also be applied to early spectral models~\cite{bruna2013spectral} but, since ChebNet was shown to be superior in downstream tasks, we choose to focus on the latter model.

	\paragraph{Two dimensional Chebyshev polynomial.}
	The Chebyshev polynomial used in Eq.~\ref{eq:cheb_conv_general} (see Section~\ref{sec:spectral_graph_conv_details} in Appendix for detail) can be extended for two variables (relations in our case) similarly to bilinear models, e.g.~as in~\cite{omar2010two}:


	and, analogously, for more variables. For , the convolution is then defined as:


	where .
	In this case, we allow the model to leverage graph paths consisting of multiple relation types (Figure~\ref{fig:edge_fusion}).
	This flexibility, however, comes at a great computational cost, which is prohibitive for a large number of relations  or large order  due to exponential growth of the number of parameters: . Moreover, as we demonstrate in our experiments, such multi-relational paths do not necessary lead to better performance.

	\begin{figure}[]
		\begin{center}
			\begin{tabular}{ccc}
{\includegraphics[width=0.26\textwidth,trim={2cm 17.5cm 22cm 1.5cm}, clip]{edge_fusion.pdf}} &
				{\includegraphics[width=0.26\textwidth,trim={6.7cm 17.5cm 17.3cm 1.5cm}, clip]{edge_fusion.pdf}} &
				{\includegraphics[width=0.15\textwidth,trim={12cm 17cm 13cm 1.5cm}, clip]{edge_fusion.pdf}} \\
				(a) & (b) &
			\end{tabular}
		\end{center}
		\caption{Comparison of (a) the fusion method based on a two-dimensional (2d) Chebyshev polynomial (Eq.~\ref{eq:2d_cheb},~\ref{eq:2d_cheb_conv}) to (b) other proposed methods in case of a 2-hop filter (a filter averaging features of nodes located two edges away from the filter center -  in this case). Note that (a) can leverage multi-relational paths and the filter centered at node  can access features of the node , which is not possible for other methods (b). In this work, edge type  can denote annotated relations, while  can denote learned ones (Eq.~\ref{eq:edge_predict}). We also allow for three and more relation types.}
		\label{fig:edge_fusion}
	\end{figure}

	\paragraph{Multiplicative and additive fusion.}
	Motivated by multimodal fusion considered in the Visual Question Answering literature (e.g.~\cite{kim2016hadamard}), we propose the multiplicative operator:
	

	where  is a learnable differentiable transformation for relation type  and  are features projected onto the Chebyshev basis .
	In this case, node features interact in a multiplicative way. The advantage of this method is that it can learn separate  for each relation and has fewer trainable parameters preventing overfitting, which is especially important for large  and .
	The element-wise multiplication  in Eq.~\ref{eq:multi_add_cheb_conv} can be replaced with summation to perform additive fusion.

	 \paragraph{Shared projections.}
	 Another potential strength of the approach in Eq.~\ref{eq:multi_add_cheb_conv} is that we can further decrease model complexity by sharing parameters of  between the relation types, so that the total number of trainable parameters does not depend on the number of relations . Despite useful practical properties, as we demonstrate in the experiments, it is usually hard for a single shared  to generalize between different relation types.

	\paragraph{Concatenating edge features.} A more straightforward approach is to concatenate features  for all  relation types and learn a single matrix of weights :

This method, however, does not scale well for large , since the dimensionality of  grows linearly with . Note that even though multi-relational paths are not explicit in Eq.~\ref{eq:multi_add_cheb_conv} and \ref{eq:concat_cheb_conv}, for a \textit{multilayer} network, relation types will still communicate through node features. In Figure~\ref{fig:edge_fusion}, node  will contain features of node  after the first convolutional layer, so that in the second layer the filter centered at node  will have access to features of node  by accessing features of node . Compared to the 2d polynomial convolution defined by Eq.~\ref{eq:2d_cheb_conv}, the concatenation-based, multiplicative and additive approaches require more layers to have a larger multi-relational receptive field.


	\section{Multigraph Convolutional Networks}
	\label{sec:model}
	A frequent assumption of current GCNs is that there is at most one edge between any pair of nodes in a graph. This restriction is usually implied by datasets with such structure, so that in
	many datasets, graphs are annotated with the single most important relation type, for example, whether two atoms in a molecule are bonded~\cite{wale2008comparison, duvenaud2015convolutional}. Meanwhile, data is often complex and nodes tend to have multiple relationships of different semantic, physical, or abstract meanings. Therefore, we argue that there could be other relationships captured by relaxing this restriction and allowing for multiple kinds of edges, beyond those annotated in the data.


	\subsection{Learning edges}
	\label{sec:learn_edges}
	Prior work (e.g.~\cite{schlichtkrull2018modeling,bordes2013translating}),
	proposed methods to learn from multiple edges, but similarly to the methods using a single edge type~\cite{kipf2016semi}, they leveraged only predefined (annotated) edges in the data.
	We devise a more flexible model, which, in addition to learning from an arbitrary number of predefined relations between nodes (see Section~\ref{sec:edge_fusion_methods}), learns abstract edges jointly with a GCN.
	We propose to learn a new edge  between any pair of nodes  and  with features  and  using a trainable similarity function:
	

	where the softmax is used to enforce sparse connections and  can be any differentiable function such as a multilayer perceptron in our work.
	This idea is similar to~\cite{henaff2015deep}, built on the early spectral convolution model~\cite{bruna2013spectral}, which learned an adjacency matrix, but targeted classification tasks for non graph-structured data (e.g.~document classification, with each document is represented as a feature vector). Moreover, we learn this matrix jointly with a more recent graph classification model~\cite{defferrard2016convolutional} and, additionally, efficiently fuse predefined and learned relations. Eq.~\ref{eq:edge_predict} is also similar to that of~\cite{velickovic2017graph}, which used this functional form to predict an attention coefficient  for some \textit{existing} edge . The attention model can only strengthen or weaken some existing relations, but cannot form new relations. We present a more general model that makes it possible to connect previously disconnected nodes and form \textit{new} abstract relations.
	To enforce a symmetry of predicted edges we compute an average: .

	\subsection{Layer pooling versus global pooling}

	Inspired by convolutional networks, previous works~\cite{bruna2013spectral, defferrard2016convolutional,monti2017geometric,simonovsky2017dynamic,fey2018splinecnn} built an analogy of pooling layers in graphs, for example, using the Graclus clustering algorithm~\cite{dhillon2007weighted}.
	In CNNs, pooling is an effective way to reduce memory and computation, particularly for large inputs. It also provides additional robustness to local deformations and leads to faster growth of receptive fields. However, we can build a convolutional network without any pooling layers with similar performance in a downstream task~\cite{springenberg2014striving} --- it just will be relatively slow, since pooling is extremely cheap on regular grids, such as images.
	In graph classification tasks, the input dimensionality, which corresponds to the number of nodes , is often very small () and the benefits of pooling are less clear. Graph pooling, such as in~\cite{dhillon2007weighted}, is also computationally intensive since we need to run the clustering algorithm for each training example independently, which limits the scale of problems we can address.
	Aiming to simplify the model while maintaining classification accuracy, we exclude pooling layers between conv.~layers and perform global maximum pooling (GMP) over nodes following the last conv.~layer. This fixes the size of the penultimate feature vector regardless of the number of nodes (Figure~\ref{fig:pipeline}).


	\section{Experiments}\label{sec:experiments}



	\subsection{Dataset details}
	We evaluate our model on five chemical graph classification datasets frequently used in previous work: NCI1 and NCI109~\cite{wale2008comparison}, MUTAG~\cite{debnath1991structure}, ENZYMES~\cite{schomburg2004brenda}, and PROTEINS~\cite{borgwardt2005protein}. For each dataset, there is a set of graphs with an arbitrary number of nodes  and undirected binary edges  of a single type () and each graph  has a single, categorical label that is to be predicted. Dataset statistics are presented in Table~\ref{table:networks} of the Appendix.

	Every graph represents some chemical compound labeled according to its functional properties.
	In NCI1, NCI109 and MUTAG, edges correspond to atom bonds (types of bonds) and vertices - to atom properties;	in ENZYMES, edges are formed based on spatial distance (edges connect nodes if those are neighbors along the amino acids sequence or if they are neighbors in space within the protein structure~\cite{borgwardt2005protein}); in PROTEINS, edges are similarly formed based on spatial distance between amino acids in proteins. Since edges in these datasets are not directly related to the features of nodes they connect, we expect that learned edges will enrich graph structure and improve graph classification.

	Node features  are discrete in these datasets and represesented as one-hot vectors of length . We do not use any additional node or edge attributes available for some of these datasets.

	These datasets vary in the number of graphs (188 - 4127), class labels (2~-~6) and the number of nodes in a graph (2~-~620) and, thereby, represent a comprehensive benchmark for our method. We follow the standard approach to evaluation~\cite{shervashidze2011weisfeiler,yanardag2015deep} and perform 10-fold cross-validation on these datasets. To minimize any random effects, we repeat experiments 10 times and report average classification accuracies together with standard deviations.

	\subsection{Architectural details and experimental setup}
	\begin{figure}[]
		\begin{center}
			\includegraphics[width=0.95\textwidth, trim={3cm 15cm 1.7cm 1.7cm}, clip]{pipeline.pdf}
		\end{center}
		\caption{Graph classification pipeline. Each  convolutional layer in our model takes the graph  and returns a graph with the same nodes and edges. Node features become increasingly global after each subsequent layer as the receptive field increases, while edges are propagated without changes. As a result, after several graph convolutional layers, each node in the graph contains information about its neighbors and the entire graph. By pooling over nodes we summarize the information collected by each node. Fully-connected layers follow global pooling to perform classification. Dashed orange edges denote connections learned as described in Section~\ref{sec:learn_edges}.
		}
		\label{fig:pipeline}
	\end{figure}

	In all experiments, we train a ChebNet with three graph convolutional layers followed by global max pooling (GMP) and 2 fully-connected layers (Figure~\ref{fig:pipeline}). Batch normalization (BN) and the ReLU activation are added after each layer, whereas dropout is added only before the fully-connected layers. Projections  in Eq.~\ref{eq:multi_add_cheb_conv} are modeled by a single layer neural network with  hidden units and the  activation. The edge prediction function  (see Eq.~\ref{eq:edge_predict}, Section~\ref{sec:learn_edges}) is a two layer neural network with 128 hidden units (32 for PROTEINS), which acts on concatenated node features. Detailed network architectures are presented in Table~\ref{table:networks} of the Appendix.

	We train all models using the Adam optimizer~\cite{kingma2014adam} with learning rate of 0.001, weight decay of 0.0001, and batch size of 32, the learning rate is decayed after 25, 35, and 45 epochs and the models are trained for 50 epochs as in~\cite{simonovsky2017dynamic}.
	We run experiments for different fusion methods (Section~\ref{sec:edge_fusion_methods}) and Chebyshev orders  in range from 2 to 6 (Section~\ref{sec:spectral_graph_conv}) and report the best results in Table~\ref{table:graph_class_results}.

	\newcommand\Tstrut{\rule{0pt}{2.6ex}}
	\newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}
	\newcommand{\std}[1]{{\scriptsize{#1}}}
	\newcommand{\best}[1]{{\bfseries#1}}

	\begin{table}[t!]
		\caption{Chemical graph classification results (average accuracy and standard deviation in \%). Multigraph ChebNet obtains better results by leveraging two types of edges: annotated and learned, whereas all other models use only annotated edges. *We implemented MoNet, GCN and ChebNet. To make a fair comparison to Multigraph ChebNet, we use the same network architectures, batch-normalization, global max pooling. For MoNet, coordinates are defined using node degrees as in~\cite{monti2017geometric}. The top result across all methods for each dataset is bolded.}
		\label{table:graph_class_results}
		\small
		\begin{center}
			\begin{tabular}{lccccc}
				\textbf{Model}     & \textbf{NCI1} & \textbf{ NCI109} & \textbf{MUTAG} & \textbf{ENZYMES} & \textbf{PROTEINS}\Bstrut\\
				\hline
				WL~\cite{shervashidze2011weisfeiler} & 84.6\std{0.4} & 84.5\std{0.2} & 83.8\std{1.5} & 59.1\std{1.1} &  \Tstrut \\
				WL-OA~\cite{kriege2016valid} & \best{86.1\std{0.2}} & \best{86.3\std{0.2}} & 84.5\std{1.7} & 59.9\std{1.1} & 76.4\std{0.4} \\
				structure2vec~\cite{dai2016discriminative} & 83.7 & 82.2 & 88.3 & 61.1 & \\
				DGK~\cite{yanardag2015deep} & 80.3\std{0.5} & 80.3\std{0.3} & 87.4\std{2.7} & 53.4\std{0.9} & 75.7\std{0.5} \\
				PSCN~\cite{niepert2016learning} & 78.6\std{1.9} &  & \best{92.6\std{4.2}} &  & 75.9\std{2.8} \\
			 	ECC~\cite{simonovsky2017dynamic} & 83.8 & 82.1 & 88.3 & 53.5 & \\
				DGCNN~\cite{zhang2018end} & 74.4\std{0.5} &  & 85.8\std{1.7} &  & 76.3\std{0.2} \\
				Graph U-Net~\cite{cangea2018towards} &  &  &  & 64.2 & 75.5 \\
				DiffPool~\cite{ying2018hierarchical} &  &  &  & 62.5 & 76.3 \\
				MoNet~\cite{monti2017geometric} - ours* & 69.8\std{0.2} & 70.0\std{0.3} & 84.2\std{1.2} & 36.4\std{1.2} & 71.9\std{1.2}\\
				GCN~\cite{kipf2016semi} - ours* & 75.8\std{0.7} & 73.4\std{0.4} & 76.5\std{1.4} & 40.7\std{1.8} & 74.3\std{0.5}\\
				\vspace{5pt}
				ChebNet~\cite{defferrard2016convolutional} - ours*& 83.1\std{0.4} & 82.1\std{0.2} & 84.4\std{1.6} & 58.0\std{1.4} & 75.5\std{0.4} \Bstrut\\
				\hline Multigraph ChebNet & 83.4\std{0.4} & 82.0\std{0.3} & 89.1\std{1.4} & 61.7\std{1.3} & \best{76.5\std{0.4}} \Tstrut \\
			\end{tabular}

		\end{center}
	\end{table}

	\vspace{-3pt}
	\subsection{Results}
	\label{sec:results}

	Previous works typically show strong performance on one or two datasets out of five that we use (Table~\ref{table:graph_class_results}). In contrast, the Multigraph ChebNet, leveraging two relation types (annotated and learned, see Section~\ref{sec:learn_edges}), shows high accuracy across all datasets.
	On PROTEINS we outperform all previous methods, while on ENZYMES two recent works based on differentiable pooling~\cite{ying2018hierarchical, cangea2018towards} are better,
	however it is difficult to compare to their results without the standard deviation of accuracies. We	also obtain competitive accuracy on NCI1 outperforming DGK~\cite{yanardag2015deep}, PSCN~\cite{niepert2016learning}, and DGCNN~\cite{zhang2018end}.
	Importantly, the Multigraph ChebNet with two edge types, i.e.~predefined dataset annotations and the learned edges (Section~\ref{sec:learn_edges}) consistently outperforms the baseline ChebNet with a single edge, which shows efficacy of our approach and demonstrates the complementary nature of predefined and learned edges.
	Lower results on NCI1 and NCI109 can be explained by the fact that the node features in the graphs of these datasets are imbalanced with some features appearing only a few times in the dataset. This is undesirable for our method, which learns new edges based on features and the model can predict random values for unseen features.
	On MUTAG we surpass all but one method~\cite{niepert2016learning}. But in this case the dataset is tiny, consisting of 188 graphs and the margin from the top method is not statistically significant.


	\paragraph{Evaluation of edge fusion methods.}
	We train a model using each of the edge fusion methods proposed in Section~\ref{sec:edge_fusion_methods} and report the summary of results in Figure~\ref{fig:edge_fusion_compare}. We count the number of times each method outperforms the others treating all 10 folds independently.
	As expected, graph convolution based on the two-dimensional Chebyshev polynomial is better for lower orders of , since it exploits multi-relational graph paths, effectively increasing the receptive field of filters.
	However, for larger , the model complexity becomes too high due to quadratic growth of the number of parameters and performance degrades.
	Sharing weights for multiplicative or additive fusion generally drops performance with a few exceptions in the multiplicative case. This implies that predefined and learned edges are of a different nature. It would be interesting to validate these fusion methods on a larger number of relation types.

	\begin{figure}[]
		\definecolor{col1}{HTML}{1F77B4}
		\definecolor{col2}{HTML}{FF7F0E}
		\definecolor{col3}{HTML}{2CA02C}
		\definecolor{col4}{HTML}{D62728}
		\definecolor{col5}{HTML}{9467BD}
		\definecolor{col6}{HTML}{8C564B}
		\definecolor{col7}{HTML}{E377C2}
		\begin{subfigure}{0.5\textwidth}
			\begin{flushleft}
				\includegraphics[width=\textwidth]{edge_fusion_compare.eps}
			\end{flushleft}
		\end{subfigure}
		\begin{subfigure}{0.2\textwidth}
			\footnotesize
			\begin{tabular}{lll}
				& \textbf{Fusion method} & \textbf{\# of parameters} \\
				\hline \\
				\tikz \fill [col7] (0.7,0.3) rectangle (0.2,0.2); & Single edge* (Eq.~\ref{eq:cheb_conv_general}) &  \\
				\hline \\
				\tikz \fill [col1] (0.7,0.3) rectangle (0.2,0.2); & Concat (Eq.~\ref{eq:concat_cheb_conv}) &   \\
				\tikz \fill [col2] (0.7,0.3) rectangle (0.2,0.2); & 2d Cheb (Eq.~\ref{eq:2d_cheb_conv}) 	&  \\
				\tikz \fill [col3] (0.7,0.3) rectangle (0.2,0.2); & Multiply (Eq.~\ref{eq:multi_add_cheb_conv}) &  \\
				\tikz \fill [col4] (0.7,0.3) rectangle (0.2,0.2); & Sum (Eq.~\ref{eq:multi_add_cheb_conv}) &  \\
				\tikz \fill [col5] (0.7,0.3) rectangle (0.2,0.2); & M-shared (Eq.~\ref{eq:multi_add_cheb_conv}) &  \\
				\tikz \fill [col6] (0.7,0.3) rectangle (0.2,0.2); & S-shared (Eq.~\ref{eq:multi_add_cheb_conv}) &  \\
			\end{tabular}
		\end{subfigure}
		\cprotect\caption{Comparison of edge fusion methods for 10 folds.
			We observe that some methods perform well for lower order , such as 2d Chebyshev convolution winning in 18/50 cases for , while others perform better for higher , such as \verb+Multiply-shared+. \verb+Multiply+ generally performs well across different . All fusion methods, except for \verb+Sum+ and \verb+Sum-shared+, consistently outperform the \verb+Single-edge+ baseline.
			We also show the number of parameters in  for the Chebyshev convolution layer depending on the number of input features , number of output features , number of relation types , order  and some constant  (number of hidden units in a projection layer  in Eq.~\ref{eq:multi_add_cheb_conv}). *\verb+Single-edge+ denotes using only annotated edges. All other methods additionally use the second edge, learned based on node features.}\label{fig:edge_fusion_compare}
	\end{figure}

	\paragraph{Speed comparison.}
	We compare forward pass speed of the proposed method to the baseline ChebNet, MoNet~\cite{monti2017geometric} and GCN~\cite{kipf2016semi} (Figure~\ref{fig:speed}). Analgously to~\cite{kipf2016semi}, we generate random graphs with  nodes and  edges. ChebNet with 2 edge types (Multigraph ChebNet) is on average two times slower than the baseline ChebNet with a single annotated edge. MoNet is in turn two times slower than Multigraph ChebNet. Multigraph ChebNet with 2d edge fusion is the slowest due to exponential growth of parameters, while GCN is the fastest, although the gap with the baseline ChebNet is small. Therefore, we believe that Multigraph ChebNet with certain edge fusion methods provides a relatively fast, scalable and accurate model.

	\begin{figure}[]
		\begin{center}
			\includegraphics[width=0.5\textwidth]{speed_compare.pdf}
		\end{center}
		\caption{Speed comparison of the baseline ChebNet, ChebNet with two edge types (Multigraph ChebNet), MoNet~\cite{monti2017geometric} and GCN~\cite{kipf2016semi}. MoNet-N refers to MoNet with  filters.
		}
		\label{fig:speed}
	\end{figure}

	\section{Related work and Discussion}
	\label{sec:works}

	Our method relies on a fast approximate spectral graph convolution known as ChebNet~\cite{defferrard2016convolutional}), which was designed for graph classification. A simplified and faster version of this model, Graph Convolutional Networks (GCN)~\cite{kipf2016semi}, which is practically equivalent to the ChebNet with order , has shown impressive node classification performance on citation and knowledge graph datasets in the transductive learning setting. In all our experiments, we noticed that using more global filters (with larger ) is important (Tables~\ref{table:graph_class_results}).
	Other recent works~\cite{hamilton2017inductive, velickovic2017graph} also focus on node classification and, therefore, are not empirically compared to in this work.

	Recent work of~\cite{ying2018hierarchical} proposed a differentiable alternative to clustering-based graph pooling, showing strong results in graph classification tasks, but at the high computational cost. To alleviate this, a more scalable approach based on dropping nodes~\cite{graphunet2018, cangea2018towards} was introduced and can be integrated with our method to further improve results.

	Closely related to our work, \cite{monti2017geometric} formulated the generalized graph convolution model (MoNet) based on a trainable transformation to pseudo-coordinates, which led to learning anisotropic kernels and excellent results in visual tasks. However, in non-visual tasks, when coordinates are not naturally defined, the performance is worse (Table~\ref{table:graph_class_results}). Notably, the computational cost (both memory and speed) of MoNet is higher than for ChebNet due to the patch operator in~\cite[Eq. (9)-(11)]{monti2017geometric} (Figure~\ref{fig:speed}). The argument in favor of MoNet against ChebNet was the sensitivity of spectral convolution methods, including ChebNet, to changes in graph size and structure. We contradict this argument and show superior performance on chemical graph classification datasets.
	SplineCNN~\cite{fey2018splinecnn} is similar to MoNet and is good at classifying both graphs and nodes, but it is also based on pseudo coordinates and, therefore, potentially has the same shortcoming of MoNet. So, its performance on general graph classification problems where coordinates are not well defined is expected to be inferior.

	Another family of methods based on kernels~\cite{shervashidze2011weisfeiler, kriege2016valid} shows strong performance on chemical datasets,	but their application is limitted to small scale graph problems with discrete node features. Scalable extensions of	kernel methods to graphs with continuous features were
	proposed~\cite{niepert2016learning, yanardag2015deep}, but they showed weaker results.


	\section{Conclusion}
	\label{sec:conclusion}
	In this work, we address several limitations of current graph convolutional networks and show competitive graph classification results on a number of chemical datasets. First, we revisit the spectral graph convolution model based on the Chebyshev polynomial, commonly believed to inherit shortcomings of earlier spectral methods, and demonstrate its ability to learn from graphs of arbitrary size and structure. Second, we design and study edge fusion methods for multi-relational graphs, and show the importance of validating these methods for each task to achieve optimal performance. Third, we propose a way to learn new edges in a graph jointly with a graph classification model. Our results show that the learned edges are complimentary to edges already annotated, providing a significant gain in accuracy.

	\section*{Acknowledgments}
	This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
	The authors also acknowledge support from the Canadian Institute for Advanced Research and the Canada Foundation for Innovation.

	\bibliography{iclr2019_conference}
	\bibliographystyle{unsrt}
	\vfill

	\pagebreak
	\vfill

	\section*{Appendix}


	\subsection{Overview of spectral graph convolution and its approximation}
	\label{sec:spectral_graph_conv_details}

	Following the notation of~\cite{defferrard2016convolutional}, spectral convolution on a graph  having  nodes is defined analogously to convolution in the Fourier domain (the convolution theorem) for some one-dimensional features over nodes  and filter  as~\cite{bruna2013spectral,bronstein2017geometric}:

where,  are the eigenvectors of the normalized symmetric graph Laplacian, , where  is an adjacency matrix of the graph ,  are node degrees.
	 follows from the definition of eigenvectors, where  is a diagonal matrix of eigenvalues. The operator  denotes the Hadamard product (element-wise multiplication),  and  is a diagonal matrix with elements of  in the diagonal.

	The spectral convolution in (\ref{eq:spectral_conv_appdx}) can be approximated using the Chebyshev expansion, where  with  and  (i.e.  terms contain powers ) and the property of eigendecomposition:


	Assuming eigenvalues  are fixed constants, filter  can be represented as a function of eigenvalues , such that (\ref{eq:spectral_conv_appdx}) becomes:


	Filter  can be then approximated as a Chebyshev polynomial of degree  (a weighted sum of  terms).
	Substituting the approximated  into Eq.~\ref{eq:spectral_conv_lambda_appdx} and exploiting Eq.~\ref{eq:eigen_property_power_appdx}, the approximate spectral convolution takes the form of (see in~\cite{defferrard2016convolutional, kipf2016semi} for further analysis and~\cite{hammond2011wavelets} for derivations):

where  is a rescaled graph Laplacian with  as the largest eigenvalue of ,  are projections of input features onto the Chebyshev basis and  are learnable weights shared across nodes.
	In this work, we further simplify the computation and fix  ( varies from graph to graph), so that  and assume no loops in a graph.  has the same eigenvectors  as , but its eigenvalues are .

	\subsection{Dataset statistics and network architectures}

	\begin{table}[htp]
		\caption{Dataset statistics and graph network architectures.
		These statistics can also be found in~\cite{KKMMN2016} along with the datasets themselves.  - number of nodes in a graph,  - input dimensionality. GC - graph convolution layer, FC - fully connected layer, D - dropout.}
		\label{table:networks}
		\small
		\centering
		\setlength{\tabcolsep}{5pt}
		\begin{tabular}{lllllll}
			\textbf{Dataset}  & \textbf{\# graphs} &  &  &  &  & \textbf{Architecture} \\
			\hline \\
			NCI1 & 4110 & 3 & 111 & 29.87 & 37 & GC32-GC64-GC128-D0.1-FC256-D0.1-FC2 \\
			NCI109 & 4127 & 4 & 111 & 29.68 & 38 & GC32-GC64-GC128-D0.1-FC256-D0.1-FC2 \\
			MUTAG & 188 & 10 & 28 & 17.93 & 7 & GC32-GC32-GC32-D0.1-FC96-D0.1-FC2 \\
			ENZYMES & 600 & 2 & 126 & 32.63 & 3 & GC32-GC64-GC512-D0.1-FC256-D0.1-FC6 \\
			PROTEINS & 1113 & 4 & 620 & 39.06 & 3 & GC32-GC32-GC32-D0.1-FC96-D0.1-FC2 \\
		\end{tabular}
	\end{table}

	\vfill

\end{document}
