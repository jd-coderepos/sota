\documentclass[english]{llncs}


\usepackage{amssymb,amsmath}
\usepackage{graphicx}

\usepackage{multirow}

\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}

\usepackage{enumitem}

\usepackage{xspace}

\usepackage{hyperref}



\usepackage{ubpalgo}


\let\Oldendproof\endproof \def\endproof{\qed\Oldendproof}

\let\Oldendremark\endremark \def\endremark{\hfill\ensuremath{\diamondsuit}\Oldendremark}

\let\Oldendexample\endexample \def\endexample{\hfill\ensuremath{\triangle}\Oldendexample}


\spnewtheorem{sublemma}{Claim}[sublemmacounter]{\itshape}{\rmfamily}
\numberwithin{sublemma}{lemma}


\spnewtheorem*{subproof}{Proof}{\itshape}{\rmfamily}
\let\Oldendsubproof\endsubproof
\def\endsubproof{\hfill\ensuremath{\Diamond}\Oldendsubproof}



\renewcommand{\theenumi}{(\roman{enumi})}
\renewcommand{\theenumii}{(\alph{enumii})}
\renewcommand{\labelenumi}{(\roman{enumi})}
\renewcommand{\labelenumii}{(\alph{enumii})}
\renewcommand{\labelitemi}{}





\newcommand{\sA}{A}
\newcommand{\sB}{B}
\newcommand{\sC}{C}
\newcommand{\sD}{D}
\newcommand{\sE}{E}

\newcommand{\profit}{\ensuremath{p}}
\newcommand{\creqprofit}{\ensuremath{p}}
\newcommand{\creq}{\ensuremath{r}}
\newcommand{\creqset}{\ensuremath{R}}
\newcommand{\carstate}{\ensuremath{\boldsymbol{z}^c}}
\newcommand{\driverstate}{\ensuremath{\boldsymbol{z}^d}}


\newcommand{\afun}{\ensuremath{f}}
\newcommand{\locations}{\ensuremath{V}}
\newcommand{\aloc}{\ensuremath{loc}}
\newcommand{\acnum}{\ensuremath{\Delta x}}
\newcommand{\vstate}{\ensuremath{\boldsymbol{z}}}
\newcommand{\pathd}{\ensuremath{P}}
\newcommand{\loadd}{\ensuremath{x_m}}
\newcommand{\driver}{\ensuremath{driv}}
\newcommand{\ndriver}{\ensuremath{k}}
\newcommand{\orig}{\ensuremath{orig}}
\newcommand{\origin}{\ensuremath{orig}}
\newcommand{\dest}{\ensuremath{dest}}
\newcommand{\tdep}{\ensuremath{dep}}
\newcommand{\tarr}{\ensuremath{arr}}
\newcommand{\mloadd}{\ensuremath{\ell oad}}
\newcommand{\mpathd}{\ensuremath{path}}
\newcommand{\ntourd}{\ensuremath{n}}
\newcommand{\task}{\ensuremath{\tau}}
\newcommand{\taskset}{\ensuremath{\mathcal{T}}}
\newcommand{\vstatescalar}{\ensuremath{z}}
\newcommand{\actionset}{\ensuremath{\mathcal{A}}}
\newcommand{\adur}{\ensuremath{dur}}




\newcommand{\abs}[1]{\ensuremath{\lvert #1 \rvert}}

\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}}
\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\RR}{\ensuremath{\mathbb{R}}}

\newcommand{\capd}{\ensuremath{L}}
\newcommand{\tourd}{\ensuremath{\Gamma}}
\newcommand{\action}{\ensuremath{\alpha}}

\newcommand{\aexetime}{\ensuremath{t}}
\newcommand{\move}{\ensuremath{m}}
\newcommand{\dist}{\ensuremath{d}}

\newcommand{\tact}{\ensuremath{act}}
\newcommand{\tmov}{\ensuremath{mov}}

\newcommand{\costd}{\ensuremath{\text{cost}^{\text{d}}}}
\newcommand{\costc}{\ensuremath{\text{cost}^{\text{c}}}}

\newcommand{\fc}{\ensuremath{f}}
\newcommand{\fd}{\ensuremath{F}}

\newcommand{\cc}{\ensuremath{c}}
\newcommand{\cd}{\ensuremath{C}}

\newcommand{\bc}{\ensuremath{b}}
\newcommand{\bd}{\ensuremath{B}}
\newcommand{\T}{\ensuremath{\mathcal{T}}}
\newcommand{\capacity}{\ensuremath{\text{cap}}}

\newcommand{\sched}{\mathcal{S}}
\newcommand{\schedule}{\sched}
\newcommand{\TR}{\mathrm{TR}}

\newcommand{\x}{\boldsymbol{x}}
\newcommand{\z}{\boldsymbol{z}}
\newcommand{\zd}{\boldsymbol{Z}^D} \newcommand{\zzd}{Z^D} 

\newcommand{\REOPT}{\textsc{ReOpt}\xspace}
\newcommand{\PDPINSERT}{\textsc{Pdp-Insert}\xspace}
\newcommand{\PDP}{PDP\xspace}


\newcommand{\VO}{V_O}
\newcommand{\VU}{V_U}
\newcommand{\VB}{V_B}
\newcommand{\VD}{V_D}

\newcommand{\Vpick}{{V^+}}
\newcommand{\Vdrop}{{V^-}}
\newcommand{\Vbal}{{V^=}}


\newcommand{\NPhard}{\ensuremath{\mathcal{NP}}\hbox{-}hard}

\newtheorem{hypothesis}{Hypothesis}


\allowdisplaybreaks[2]



\pagestyle{plain}




\title{ReOpt: an Algorithm with a Quality Guaranty for Solving the Static Relocation Problem}

\author{Sahar Bsaybes\inst{2}
        \and
        Sven~O.~Krumke\inst{1}
        \and
        Alain Quilliot\inst{2}
        \and
        Annegret K.\ Wagler\inst{2}
        \and
        Jan-Thierry Wegener\inst{2}\thanks{This work was founded by the French National Research Agency, the European Commission (Feder funds) and the R\'egion Auvergne within the LabEx IMobS3.}}
\institute{University of Kaiserslautern (Department of Mathematics) \\
           Kaiserslautern, Germany\\
           \texttt{krumke@mathematik.uni-kl.de}
          \and
          Universit\'e Blaise Pascal (Clermont-Ferrand II)\\
          Laboratoire d'Informatique, de Mod\'elisation et d'Optimisation des Syst\`emes\\
          BP 10125, 63173 Aubi\`ere Cedex, France\\
        \texttt{\{bsaybes,quilliot,wagler,wegener\}@isima.fr}}


\begin{document}



\maketitle


\begin{abstract}
In a carsharing system, a fleet of cars is distributed at stations in an urban area, customers can take and return cars at any time and station.
For operating such a system in a satisfactory way, the stations have to keep a good ratio between the numbers of free places and cars in each station.
This leads to the problem of relocating cars between stations, which can be modeled within the framework of a metric task system. 
In this paper, we focus on the Static Relocation Problem, where the system has to be set into a certain state, outgoing from the current state.  
We present a combinatorial approach and provide approximation factors for several different situations.
\end{abstract}






\section{Introduction}


Carsharing is a modern way of car rental, attractive to customers who make only occasional use of a car on demand.
Carsharing contributes to sustainable transport as less car intensive means of urban transport, and an increasing number of cities all over the world establish(ed) such services.
Hereby, a fleet of cars is distributed at specified stations in an urban area, customers can take a car at any time and station and return it at any time and station,
provided that there is a car available at the start station and a free place at the final station.
To ensure the latter, the stations have to keep a good ratio between the number of places and the number of cars in each station.
This leads to the problem of balancing the load of the stations, called \emph{Relocation Problem}:
an operator has to monitor the load situations of the stations and to decide when and how to move cars from ``overfull'' stations to ``underfull'' ones.


Balancing problems of this type occur for any car- or bikesharing system, but the scale of the instances, 
the time delay for prebookings and the possibility to move one or more vehicles in balancing steps differ. 
We consider an innovative carsharing system, where the cars are partly autonomous, which allows to build wireless convoys of cars leaded by a special vehicle,
such that the whole convoy is moved by only one driver (cf.~\cite{EDGC:2012:PCS}).

This setting is different from usual carsharing, but similar to bikesharing, where trucks can simultaneously load and move several bikes during the relocation process \cite{Benchimol+etal:RAIRO,do-cmc2013,cirrelt-CMR-2012}.
The main goal is to guarantee a balanced system during working hours (dynamic situation as in \cite{cirrelt-CMR-2012,HKQWW:2015:ODY,HKQWW:LAGOS:2015,KQWW:2014:LNCS,LAGOS2013})
or to set up an appropriate initial state for the morning (static situation as in \cite{do-cmc2013,LAGOS2013}).
Both, the dynamic and the static versions are known to be \NPhard~\cite{Ball+etal:handbook:95a,Ball+etal:handbook:95b,do-cmc2013,Nemhauser+etal:handbook:89}, and different heuristic approaches have been developed, e.g., 
partitioning the problem into subproblems by
discrete particle swarm optimization \cite{CIE:GKA-2013},
by reducing the search space~\cite{KQWW:2014:LNCS},
using variable neighborhood search \cite{EvoCOP:HPHR-2013}, or
partitioning the problem into subproblems with clustering techniques \cite{SHH-2013}.





In this paper, we address the static situation, where the system has to be set into a certain state~, outgoing from the current state~, within a given time horizon.~ 

In Section \ref{sec: model}, we model different variants of the Static Relocation Problem within the framework of a (quasi) metric task system,
where tasks consist in moving cars out of ``overfull'' stations (with ) into ``underfull'' stations (with ).

In the following, we present two approaches to solve the Static Relocation Problem, an exact integer programming based method and a combinatorial approximation algorithm.

In Section~\ref{sec: static: min-cost flows: wo pre w back}, we present an exact approach to solve this problem using coupled flows in time-expanded networks,
where the flow of cars is dependent from the flow of drivers since cars can only be moved in convoys.
Due to the involved flow coupling constraint, all variants of the problem require very long computation times (see also Section~\ref{seq: computational})
which motivated the study of a combinatorial algorithm to solve the problem in reasonably short time.

In Section~\ref{sec: static: reopt}, we propse such an algorithm that firstly matches tasks to generate transport requests,
subsequently solves a Pickup and Delivery Problem, and iteratively augments the transport requests and resulting tours (Section~\ref{sec: static: reopt}). 
This algorithm has an approximation factor based on the convoy size in several different situations (Section~\ref{sec: static: reopt: approximation factor}).
Parts of these results appeared without proofs in~\cite{LAGOS2013}.
 
We finally provide some computational results for both approaches (Section~\ref{seq: computational}), and close with some remarks and future lines of research (Section~\ref{seq: conclusion}).






\section{Problem description and model}
\label{sec: model}


We model the Relocation Problem in the framework of a metric task system. 

By \cite{LAGOS2013}, the studied carsharing system can be understood as a discrete event-based system, where
the system components are the stations , each having an individual capacity cap,
a system state  specifies for each station  the number of cars  at a time point  within a time horizon~ 
and  changes when customers or convoy drivers take or return cars at stations. 


An operator monitors the evolution of system states over time and decides when and how to move cars
between the stations,
in order to avoid infeasible system states  with  or  for some station .
More precisely, a \emph{task} is defined by  where  cars are to pickup (if ) or to deliver (if ) at station  within the time-horizon~. 


In the static situation, we consider a \emph{start state}~ and a \emph{destination state}~.
Then the tasks are induced by the differences between these two states, i.e, for every station  with  we have a task~.
A station  with  is called an~\emph{overfull station}, a station~ with  is called an~\emph{underfull station},
and a station  with  is called an~\emph{balanced station}.


Since our considered carsharing system is located in an urban area, due to one-way streets, the distances between two stations~ and~ may not be symmetric, i.e.,
the distance from~ to~ 
may differ from that from~ to~.
Furthermore, due to the traffic situation, the travel times also may vary.
In order to represent the one-way streets (or different travel times) it is suitable to encode the urban area where the carsharing system is running as a
\emph{(quasi) metric space}\footnote{A quasi metric space  contains a set  and a distance function  so that for all  holds:
  (non-negativity),   iff  (identity of indiscernibles),   (triangle inequality).
Laxly said, a quasi metric is a ``metric'' where the symmetry condition is dropped.}
 induced by a directed weighted graph , where the nodes correspond to stations, arcs to their physical links in the urban area, node weights to the station's capacities,
and the edge weights  determine the distance  between two points  as length of a shortest directed path from~ to~.


All drivers begin and end their work at the same location, a so-called depot.
A depot is represented in  by a distinguished origin .
In larger carsharing systems, there are usually several depots~ distributed within the urban area.
Especially when a driver lives near a depot, he may prefer to start and end its tour in the same depot.
Furthermore, this ensures that always the same number of trucks are located in the depots.
However, in order to decrease the total distances traveled by the drivers, it may be suitable for the operators of the carsharing system that the drivers start and end their tours in different depots.
The number of drivers starting in depot~ is represented by a natural number~; the total number of available drivers is denoted by~.


This together yields a \emph{(quasi) metric task system}, a pair  where  is the above metric space and  a set of tasks, as suitable framework to embed the tours for the convoys. 
A driver able to lead a convoy plays the role of a server.
Each server has capacity~, corresponding to the maximum possible number of cars per convoy; several servers are necessary to serve a task  if  holds.


More precisely, we define the following.
An \emph{action} for driver~ is a -tuple , where 
 specifies the driver  performing the action, 
 specifies the station , 
 is the time  when the action is performed, 
and  the number of cars  to be loaded (if ) or unloaded (if ). 
Hereby, the capacity of the convoy must not be exceeded, i.e., we have .
We say that an action is \emph{performed} (by a driver) if he loads (resp. unloads)  cars at~.
An action is called \emph{pickup action} if , \emph{drop action} if~, and \emph{empty} if .


A \emph{move} from one station to another is
, where
 specifies the driver  that has to move from the origin station  starting at time 
to destination station  arriving at time , and a load of  cars.
Hereby, we require that 
\begin{enumerate}
 \item\label{def: enum: move: 0} ,
\item\label{def: enum: move: 1} , and
 \item\label{def: enum: move: 2} from  follows .
\end{enumerate}
A move  with  is called \emph{waiting move}.



A \emph{tour} is an alternating sequence  of moves and actions with
\begin{enumerate}
 \item\label{def: enum: tour: 1} , 
 \item\label{def: enum: tour: 2} ,
 \item\label{def: enum: tour: 3} , and
 \item\label{def: enum: tour: 5} .
\end{enumerate}
By  we denote the sequence containing the actions of the tour , i.e., ,
and by  we denote the sequence containing the moves of the tour , i.e., .


The \emph{length of a tour} corresponds to the distance traveled by the driver.
Several tours are composed to a transportation schedule. 
A collection of tours  is a \emph{feasible transportation schedule}  for  if 
\begin{enumerate}
 \item\label{def: enum: schedule: 1} every driver has exactly one tour,
 \item\label{def: enum: schedule: 2} each task  is served (i.e., for every task , the number of cars picked up (resp.~dropped) at station~ sum up to~),
 \item\label{def: enum: schedule: 3} all system states  are feasible during the whole time horizon . 
\end{enumerate}
The \emph{total tour length} of a transportation schedule is the sum of the lengths of its tours.
Condition~\ref{def: enum: schedule: 3} requires that, besides the canonical precedences between a move  and its successor move  in the same tour~,
also dependencies between tours are respected
if \emph{preemption} is used, i.e., if a car is transported in one convoy from its origin to an intermediate station, and from there by another convoy to its destination.
This causes dependencies between tours, since some moves cannot be performed before others are done without leading to infeasible intermediate states (the reason why tours may contain waiting moves).
More precisely, an action  induces a precedence, avoiding a system state  with  (resp.~),
if one of the following conditions is true:
\begin{itemize}
\item  drops cars at an overfull station,
\item  picks up cars at an underfull station,
\item  drops or picks up cars at a balanced station.
\end{itemize}
Note, it is possible that the action which is dependent on  may not be uniquely determinable.
Furthermore, an action with a dependency to  does not necessarily fulfill any of the three conditions.



We call a transportation schedule \emph{non-preemptive} if there are no precedences between moves of different tours, and \emph{preemptive} otherwise.
When every driver starts and ends its tour in the same depot, we say it is a transportation schedule \emph{with backhaul}.
Otherwise, we call it a transportation schedule \emph{without backhaul}.

Our goal is to construct non-preemptive transportation schedules of minimal total tour length for the Relocation Problem in the static situation.


\begin{problem}[Static Relocation Problem ]
Given a (quasi) metric space  induced by a (directed) weighted graph ,
start state , destination state  with  and time horizon ,  servers of capacity  and  drivers start at depot ,
find a non-preemptive transportation schedule of minimal total tour length for the metric task system  where  consists of the tasks  for all~ with~.

Hereby, we further classify the Static Relocation Problem into the following problems and their compositions:
\begin{itemize}
 \item Symmetric Static Relocation Problem: if  is a metric space,
 \item Asymmetric Static Relocation Problem: if  is a quasi metric space,
 \item Static Relocation Problem with backhaul: if the solution is a transportation schedule with backhaul, and
 \item Static Relocation Problem without backhaul: if the solution is a transportation schedule without backhaul.
\end{itemize}
\end{problem}






\section{Min-Cost Flows in Time-Expanded Network}
\label{sec: static: min-cost flows: wo pre w back}


In this section, we give an exact approach for the Static Relocation Problem  without preemption by defining a time-expanded network with coupled flows: car and driver flows.
Hereby, we firstly describe the approach for the Static Relocation Problem with backhaul (Sections~\ref{sec: static: min-cost flows: ten: wo pre w back}--\ref{sec: static: min-cost flows: ilp: wo pre w back}).
Afterwards, in Section~\ref{sec: static: min-cost flows: without backhaul}, we show how this approach can be modified in order to solve the Static Relocation Problem without backhaul.



We consider a (quasi) metric space  induced by a (directed) weighted graph  representing the set of stations~, a set of depots ,
the road (or logical) connections  between them, driving times , and the (quasi) metric  induced by the shortest path distances in . 
In addition, there are per unit costs  and  for moving cars and drivers within . 
The task set  consists of the tasks  for all  with . 
The output is a preemptive transportation schedule for the metric task system , the objective is to minimize its total tour length.

For that, we build a directed graph~, with , as a time-expanded version of the original network~. 
For each , the drivers and their convoys will form flows~ and  through~ which are coupled in the sense that on those arcs  used for moves of convoys,
we have the condition  reflecting the dependencies between the two flows.


\subsection{Time-expanded network \texorpdfstring{}{GT}}
\label{sec: static: min-cost flows: ten: wo pre w back}


We build a time-expanded version~ of the original network~.

The node set  is constructed as follows: 
for each station and each depot~ and each time point~ in the given time horizon , there is a node  which represents station/depot~ at time~.

The arc set  of~ is composed of two subsets:
\begin{itemize}
\item  contains, for each station~ of the original network and each , the \emph{holdover arc} connecting~ to~. 
\item  contains, for each edge  of~ and each point in time~ such that , the \emph{relocation arc} from  to .
\end{itemize}
Note, due to the identity of indiscernibles (i.e.,  iff ) it follows that the time-expanded network  is acyclic by construction.
Furthermore,  is constructed the same way, regardless whether the original network is directed or undirected.


\subsection{Flows in \texorpdfstring{}{GT}}
\label{sec: static: min-cost flows: flows: wo pre w back}


On the relocation arcs of~, we define for each driver~ a driver flow  as well as a car flow  which represents the convoy of this driver.
On the holdover arcs of~, we define a driver flow  for each driver but only one car flow .
We specify the capacities as well as the costs for each arc with respect to the different flows.


A flow on a relocation arc corresponds to a (sub)move in a tour, i.e., some cars are moved by drivers in a convoy from station~ to another station~.
Hereby, the stations can be used to pick up or to drop cars, or simply to transit a node (when a driver/convoy passes the station(s) on its way to another station).
A relocation arc from  to  has capacity~ for each of the driver flow , .
In order to ensure that cars are moved only by drivers and only in convoys of capacity~, we require that 

Thus, the capacities for the car flows  on the relocation arcs are not given by constants but by a function.
Note that due to these flow coupling constraints, the constraint matrix 
of the network is not totally unimodular (as in the case of uncoupled flows) and therefore solving such problems becomes hard.
From Equation~\eqref{eq: static: min-cost flows: flows: wo pre w back: 1} it directly follows that  holds for all relocation arcs .

Since we consider transportation schedules without preemption, we must ensure that cars are not exchanged between convoys.
Furthermore, we have to ensure that there is no ``tour internal preemption'', i.e., a tour drops a car at one station and later picks it up again.
Inner preemption and preemption between tours can be avoided by ensuring that cars are only picked up at overfull stations and dropped at underfull stations.
This means that there are more cars in a convoy leaving an overfull station than entering the station.
Analogously, there are more cars in a convoy entering an underfull station than leaving the station, and in balanced stations the number of cars entering the station is equal to the number of cars leaving the station.
Thus, one has to ensure that the following constraints hold for every 

where  denotes the set of incoming relocation arcs of , and  denotes the set of outgoing relocation arcs of .
Note, that the sums in these equations are of a technical nature.
In fact, in each of these equations there is at most one summand positive while all other are zero.
However, since we do not know in advance which one is positive, we have to sum over all incoming resp.~outgoing relocation arcs of a node.


The costs for the driver flows on a relocation arc~ correspond to the distance traveled, i.e., if  corresponds to the edge~ the costs correspond to .


A flow on a holdover arc corresponds to cars/drivers remaining at the station in the time interval~.
Since we do not allow precedences between tours, a car is dropped only at underfull stations and only picked up from overfull stations;
at balanced stations, cars are neither picked up nor dropped (see constraints~\eqref{eq: static: min-cost flows: flows: wo pre wo back: over under balanced: 1}--\eqref{eq: static: min-cost flows: flows: wo pre wo back: over under balanced: 3}).
Therefore, we define only one car flow~ on the holdover arcs.
Furthermore, it follows from~\eqref{eq: static: min-cost flows: flows: wo pre wo back: over under balanced: 1}--\eqref{eq: static: min-cost flows: flows: wo pre wo back: over under balanced: 3}
that at an overfull station the number of cars is non-increasing over time, at an underfull station the number of cars is non-decreasing over time, and at balanced stations the number of cars remains equal all the time.
Thus, it holds for every reachable system state~

Since  and  are feasible system states by definition, this implies that every reachable system state~ is feasible as well.
Thus, capacities are not needed for holdover arcs with respect to the car flow~.
For each driver flow~, , we set a capacity of~1 on the holdover arcs.
Moreover, the cost for all flows on such arcs are zero.




With the help of~, we can assign a depot to each driver.
For that, we set  if driver~ starts (and ends) its tour in the depot~, and  otherwise.

To correctly initialize the system, we use the nodes  as sources for both flows and set their 
balances accordingly to the initial numbers of cars at station~ and time~ and locate the drivers at their depot , i.e.,
the sum of the car flow values on all outgoing arcs of  is set to , and for each driver~, , the sum of the driver flow values on all outgoing arcs of  is set to~.



For all internal nodes  with , we use flow conservation constraints for the car flows~ and , i.e.,

and the standard flow conservation constraints for each driver flows~, i.e.,

for all~.


To ensure that the destination state is reached and each driver returns to its depot, we use as sinks the nodes , , for the car flow 
and the nodes , , for the driver flow, and set their balances accordingly to  resp.~to~ for each driver flow~.
Since there are ~drivers, the sum of all outgoing (resp.~incoming) driver flows of all depots  sums up to~.


Figure \ref{fig: flownetwork} illustrates a time-expanded network with capacities on the arcs as well as the balances for the nodes~ and .
Furthermore, optimal flows  and  based on the network from Figure \ref{fig: reopt} are shown in this figure.


\begin{figure}
  \centering
  \includegraphics[width=0.962\textwidth]{time-expanded-01.pdf}
  \caption{This figure shows the time-expanded network  for the graph  from Figure~\ref{fig: reopt}.
    The time horizon is set to .
    Every node of the form~ represents a station~ (or the depot) at time~.
    In this car sharing system, there are two drivers.
    The driver flow  is indicated by dash dotted arcs, the driver flow~ by dotted arcs, and the car flow  by solid arcs.
    The car flows~ and~ are not shown in the image, however, their flow values are at the corresponding driver flows (if the value is positive).
    The flow values of~ on the holdover arcs are the numbers at the holdover arcs.
    The total tour length is 17.}
  \label{fig: flownetwork}
\end{figure}




\subsection{Integer linear program for Min-Cost-Flow in }
\label{sec: static: min-cost flows: ilp: wo pre w back}


To solve the Static Relocation Problem exactly, we aim at determining convoy tours with a minimal total tour length.
For that, we summarize the previous sections by presenting an integer linear programming formulation for a min-cost flow problem in the time-expanded network :

    \min& \,  \sum_{a\in A_L} w(a) \sum_{i = 1}^k \fd_i(a)                                                                                                      \label{eq: static: min-cost flows: ilp: wo pre w back: 1}\\
    & \fc((v, 0), (v, 1)) + \sum_{a\in \delta^-_L(v,0)} \sum_{i=1}^k \fc_i(a) = z_v^0,                           && \forall (v,0) \in V_T                       \label{eq: static: min-cost flows: ilp: wo pre w back: 10}\\
    & \fc((v,T-1),(v,T)) + \sum_{a\in \delta^+(v,T)} \sum_{i=1}^k \fc_i(a) = z_v^T,                              && \forall (v,T) \in V_T                       \label{eq: static: min-cost flows: ilp: wo pre w back: 11}\\
    & \sum_{a\in \delta^-(v, 0)} \fd_i(a) = \bd_v^i,                                                             && \forall 1 \leq i \leq k                     \label{eq: static: min-cost flows: ilp: wo pre w back: 12}\\
    & \sum_{a\in \delta^+(v_D,T)} \fd_i(a) = \bd_v^i,                                                            && \forall 1 \leq i \leq k                     \label{eq: static: min-cost flows: ilp: wo pre w back: 13}\\
    & 
    \begin{aligned}
    \fc((v&, t-1), (v, t)) + \sum_{a\in \delta^+_L(v,t)} \sum_{i=1}^k \fc_i(a) \\
        &= \fc((v, t), (v, t+1)) + \sum_{a \in \delta^-_L(v,t)} \sum_{i=1}^k \fc_i(a),
    \end{aligned}
                                                                                                                &&  \forall v \in V, 0 < t < T                  \label{eq: static: min-cost flows: ilp: wo pre w back: 14}\\
    & \sum_{a\in \delta^+(v,t)} \fd_i(a) = \sum_{a\in \delta^-(v,t)} \fd_i(a),                && \hspace{-1.2cm} \forall v \in V, 0 < t < T, \forall 1 \leq i \leq k    \label{eq: static: min-cost flows: ilp: wo pre w back: 15}\\
& \sum_{a \in \delta^+_L(v_o, t)} \fc_i(a) \leq \sum_{a \in \delta^-_L(v_o, t)} \fc_i(a), && \hspace{-1.7cm}  \forall v_o \in V_O, \forall 0 < t < T, \forall 1 \leq i \leq k \label{eq: static: min-cost flows: ilp: wo pre w back: 16} \\
    & \sum_{a \in \delta^+_L(v_u, t)} \fc_i(a) \geq \sum_{a \in \delta^-_L(v_u, t)} \fc_i(a), && \hspace{-1.7cm}  \forall v_u \in V_U, \forall 0 < t < T, \forall 1 \leq i \leq k \label{eq: static: min-cost flows: ilp: wo pre w back: 17} \\
    & \sum_{a \in \delta^+_L(v_b, t)} \fc_i(a) = \sum_{a \in \delta^-_L(v_b, t)} \fc_i(a),    && \hspace{-1.7cm}  \forall v_b \in V_B, \forall 0 < t < T, \forall 1 \leq i \leq k \label{eq: static: min-cost flows: ilp: wo pre w back: 18} \\
& \fc_i(a) \leq \capd \cdot \fd_i(a),                                                        && \forall a \in A_L, \forall 1 \leq i \leq k                  \label{eq: static: min-cost flows: ilp: wo pre w back: 20}\\
    & \fc, \fc_i \text{ integer}, \fd_i \text{ binary},          \label{eq: static: min-cost flows: wo pre w back: ilp: 21}
  
where  denotes the set of outgoing arcs of  (and  denotes the set of outgoing relocation arcs of ),
and  denotes the set of incoming arcs of  (and  denotes the set of incoming relocation arcs of ). 
The objective function~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 1} measures and minimizes the total tour length of the transportation schedule.
The equalities~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 10} and~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 12} give the initial number of cars (resp.~drivers) for each station (resp.~for the depots).
Conditions~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 14} and~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 15} are the flow conservation constraints for the flows~ and , respectively.
The conditions~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 11} and~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 13} ensure to reach the destination state
and that every driver returns to its depot at the end of the time horizon.
The conditions~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 16}, \eqref{eq: static: min-cost flows: ilp: wo pre w back: 17} and~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 18}
ensure that cars are only picked up at overfull stations, and dropped at underfull stations.
Finally, the constraints~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 20} couple the flows~ and~ so that cars on relocation arcs cannot move without their driver.
Furthermore, these constraints give the capacities for  on relocation arcs.


Finally, the flows in the time-expanded network have to be interpreted as a transportation schedule.
Hereby, car and driver flows on relocation arcs correspond to a move, differences in the car flow to actions.
Note, one can easily compute a transportation schedule from the resulting flows.
For that, positive flow  on a relocation arc  corresponds to a move .
Actions are implied by differences of flow values between incoming and outgoing relocation arcs, i.e., if we have~ with ,
and  then the action~ is implied.
This implies:


\begin{theorem}
The optimal solution of system \eqref{eq: static: min-cost flows: ilp: wo pre w back} corresponds to a non-preemptive transportation schedule with minimal total tour length
for the Static Relocation Problem with backhaul  (Symmetric and Asymmetric).
\end{theorem}




\subsection{Static Relocation Problem without backhaul}
\label{sec: static: min-cost flows: without backhaul}


In this section, we consider the Static Relocation Problem without backhaul, and
highlight the differences between the exact approach for solving the Static Relocation Problem with and without backhaul.

In the integer linear program stated in the previous section, the equations~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 13} ensure that every driver returns to its depot.
Thus, it is sufficient to conveniently modify these equations.

For that, we replace the equations~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 13} by the following two constraints

Hereby, \eqref{eq: static: min-cost flows: ilp: wo pre wo back: 1} ensures that every driver can return to any depot
and \eqref{eq: static: min-cost flows: ilp: wo pre wo back: 2} ensures that the drivers do not end their tours in a station but only in a depot.
Thus, we can compute non-preemptive transportation schedules with a minimal total tour length for the Symmetric (resp.~Asymmetric) Static Relocation Problem without backhaul.




\section{The combinatorial algorithm \REOPT}
\label{sec: static: reopt}

The computation times for computing an exact solution by solving the integer linear program~\eqref{eq: static: min-cost flows: ilp: wo pre w back: 10}--\eqref{eq: static: min-cost flows: wo pre w back: ilp: 21}
are extremely high even for small instances (see Table~\ref{tab: computational results}).
This motivates the study of a combinatorial algorithm to solve the problem in reasonably short time.
Therefore, we describe in detail the strategy \REOPT\ proposed in \cite{LAGOS2013} to solve a Static Relocation Problem.
The input of \REOPT\ is the Static Relocation Problem .
Hereby, we consider a complete weighted graph  induced by a (quasi) metric space , containing only the overfull stations  (with ),
the underfull stations  (with ), and a set of depots , as well as all connections  between them and driving times .
The task set  again consists of the tasks  for all .
The output of \REOPT\ is a non-preemptive transportation schedule for the (quasi) metric task system , the objective is to minimize its total tour length.

The \REOPT\ approach performs three steps.
Firstly, we construct a weighted complete bipartite graph and find a matching between overfull and underfull stations with minimal edge weight.
Each edge in this matching corresponds to a transport request between two stations.
Secondly, tours for all convoys are constructed (using a heuristic insertion technique) serving each transport request.
Since the transport requests stemming from the minimum matching do not necessarily lead to optimal convoy tours, 
the final step is to iteratively augment the tours by ``rematching'' certain origin/destination pairs, i.e., to reinsert accordingly adapted moves in such a way that the total tour length decreases.



\subsection{First step: Compute transport requests}
\label{sec: static: reopt: first step}


In the first step, we compute transport requests of the form , where  is an overfull station,  an underfull station and  is the number of cars to be transported from  to . 
For that, we construct a weighted complete bipartite graph  and
consider a restricted vector  of edge weights (reflecting the distance between the two adjacent stations)
and a vector  of node weights reflecting the number  of cars which have to be moved in or out the corresponding station .


Define a \emph{perfect -matching} in~ to be a multiset  of the edges such that for each node ,
exactly  incident edges are selected, counted with multiplicities . 
Note that by construction of , the existence of such a perfect -matching
is ensured by  since . 
The goal is to find a perfect -matching~ with minimal edge weight , including multiplicities.
The problem can be formulated by the following integer linear program

    \min& \,  \sum_{a\in A} w_a x_a,                                                                                                                            \label{eq: static: reopt: matching: ilp: 1}\\
    & \sum_{a \in \delta^+(v_o)} x_a = p_{v_o},                                                                 && \forall v_o \in V_O                          \label{eq: static: reopt: matching: ilp: 10}\\
    & \sum_{a \in \delta^+(v_u)} x_a = p_{v_u},                                                                 && \forall v_u \in V_U                          \label{eq: static: reopt: matching: ilp: 11}\\
    & x_a \text{ integer}.                                                                                                                                      \label{eq: static: reopt: matching: ilp: 21}
  
Note that the constraint matrix is totally unimodular, and thus, problem can be solved efficiently~\cite{}.


Each selected matching edge , with  and , corresponds to a transport request for  cars from station  to station .
The set  of all such transport requests provides the input for a Pickup and Delivery Problem (PDP) which has to be solved subsequently in order to construct tours for all convoys serving each transport request.



\subsection{Second step: Serving the transport requests}
\label{sec: static: reopt: second step}


In this section, we give an algorithm~\PDPINSERT\ which solves the PDP using heuristic insertion techniques.
The input for \PDPINSERT\ is the complete weighted graph , the total number  of drivers, the convoy capacity , and the set of transport requests .
The output of \PDPINSERT\ is a non-preemptive transportation schedule for the drivers, which serves all transport requests in~ within the time horizon~.


For that, we define some further notions.
Let  be a tour for a driver~ and let  be a transport request.
We say that  is \emph{served} by  if there exists a pickup action  and a drop action  in ,
so that .
Hereby,  is \emph{fully served} if  and \emph{partially served} if .
By  we denote the number of cars served from  by . 
A transport request  can be \emph{(partially) inserted} into a tour~, serving~ cars, as follows:
\begin{itemize}
 \item select a move  where  shall be inserted,
 \item remove  from ,
 \item add move , action , move  to the tour,
 \item update departure and arrival times of all successive moves and actions,
 \item do analogous steps for .
\end{itemize}
This yields a new tour  which (partially) serves .
By applying the opposite steps,  can be \emph{removed} from , which yields .


Now let  be (fully or partially) served by , and  be the tour derived from  without serving .
We denote the \emph{marginal costs per load unit}  by

Now the algorithm \PDPINSERT\ can be described as follows:
\begin{enumerate}
\item For each driver~ initialize the tour so that it starts and ends in the drivers depot~, i.e., initialize the tour with the move .
\item Choose a transport request  that has an origin or a destination already in a tour, else randomly select one.
\item Calculate the marginal cost per load unit of inserting this transport request to each possible tour.
      Hereby, take the number of cars to be transported into account (i.e., respect the convoy capacity) as well as the time.
      Select the tour with the minimum marginal cost per load unit and insert the transport request into this tour.
\item If the transport request  is fully served, remove it from .
      Otherwise, it is partially served by a tour .
      Then subtract the number of cars inserted from the load of the transport request, i.e., remove  from  and add a new transport request  to .
\item Repeat these steps until all the transport requests are fully served.
\end{enumerate}


\begin{figure}[ht]
    \centering
\includegraphics[width=0.4\textwidth]{reopt-01.pdf}  \includegraphics[width=0.4\textwidth]{reopt-02.pdf}
 \caption{
          In each figure (left and right side), a carsharing system with 6 stations ( to ) and one depot () is illustrated as a graph .
          There are two tours (dashed and dotted), one for each of the two drivers (server capacity ), giving a non-preemptive transportation schedule.
          The numbers at the stations show the amount of cars to be moved from () or to the station ().
          On the left side, the transportation schedule before the reoptimization step is shown (total tour length = 22), on the right side, the transportation schedule after this step (total tour length = 19).
 }
 \label{fig: reopt}
\end{figure}



The algorithm \PDPINSERT\ computes a non-preemptive transportation schedule. 
However, the transportation schedule created from the transport requests stemming from the minimal perfect -matching does not necessarily lead to optimal tours.
Therefore, the final step is to iteratively augment the tours by ``rematching'' certain origin/destination pairs,
i.e., to reinsert accordingly adapted moves in such a way that the total tour length decreases.




\subsection{Third step: Reoptimization}


The algorithm defined here involves the two previous steps: computation of transport requests and the algorithm \PDPINSERT.
The input for the reoptimization step is a transportation schedule  serving all transport requests in  and two natural numbers .
The output is a transportation schedule having a total tour length less or equal to the total tour length of .
The algorithmic scheme of the reoptimization step is as follows:
\begin{enumerate}
 \item From  we withdraw the  transport requests with highest marginal cost per load: .
 \item From the withdrawn transport requests we compute sets of over- and underfull stations, i.e.,
       the set , the set  and the vector 
       by , where  and .
 \item For every pair  and every tour  we compute the additional marginal cost , where 
       and  is the tour after inserting a transport request .
       Let  be the minimal additional marginal cost.
 \item Next we generate a weighted complete bipartite graph  and compute a minimal perfect -matching (as in Step 1).
       From the minimal perfect -matching, transport requests are generated, which serve as input for the algorithm \PDPINSERT\ (as in Step 2).
 \item Redo these steps  times.
 \item Finally, we return the best found transportation schedule, i.e., the one with the smallest total tour length.
\end{enumerate}



Figure~\ref{fig: reopt} shows an example for the reoptimization step improving a transportation schedule stemming from the minimal perfect -matching of Step 1.


The algorithm \REOPT\ is summarized in Algorithm~\ref{alg: static: reopt}.

\begin{algorithm}[ht]
\caption{\REOPT}
\label{alg: static: reopt}
\begin{algorithmic}[1]
  \Require{a Static Relocation Problem , integers , }
  \Ensure{a non-preemptive transportation schedule}
  \State{Find a minimal perfect -matching (Step 1)}                                                                          \label{alg: static: reopt: 1}
  \While{}                                                                                                    \label{alg: static: reopt: 2}
    \State{update }                                                                                                    \label{alg: static: reopt: 3}
    \State{construct  tours by \PDPINSERT\ serving all transport requests (Step 2)}                                          \label{alg: static: reopt: 4}
    \State{rematch after withdrawing the N requests that have highest additional marginal costs in their tours (Step 3)}        \label{alg: static: reopt: 5}
  \EndWhile{}
  \State{\Return{transportation schedule of smallest found total tour length}}                                            \label{alg: static: reopt: 6}
\end{algorithmic}
\end{algorithm}




Finally, we give some comments about the complexity of the algorithm \REOPT.
The minimal perfect -matching of Step~1 of the algorithm \REOPT\ (Section~\ref{sec: static: reopt: first step}), can be computed in polynomial time.
Since constructing an optimal transportation schedule from the minimal perfect -matching (Section~\ref{sec: static: reopt: second step}) results in a dial-a-ride problem, this step is at least~\NPhard.
Thus, the second step cannot be solved in polynomial time unless  holds.
Therefore, the total complexity of \REOPT\ is at least in~.




\section{Approximation factors}
\label{sec: static: reopt: approximation factor}


In this section, we consider several different situations and show that in most of these cases, the algorithm \REOPT achieves a finite approximation factor based on the capacity of the convoys.
We consider the symmetric and asymmetric situations, when there is only one depot on the system and when there are multiple depots.
In the case of multiple depots, we distinguish between tours with and without ``backhaul'', i.e., whether each driver has to return to its starting depot (with backhaul) or to any depot in the system (without backhaul).
Obviously, in the case of only a single depot in the system, the Static Relocation Problem with backhaul and without backhaul coincide.


Firstly, we consider the case when there is only one depot in the system (Section~\ref{sec: static: reopt: single depot}).
Hereby, we show that the approximation factor is equal in both cases, the symmetric and the asymmetric one.
Secondly, we consider multiple depots in the system (Section~\ref{sec: static: reopt: multiple depot}).
In this case, the symmetric and asymmetric situations become different, depending whether the transportation schedule contains only tours with or without backhaul.


Throughout this section, we assume that the time horizon is always large enough.



\subsection{Single depot}
\label{sec: static: reopt: single depot}

In this section, we show that in the case when there is only one depot in the system, \REOPT achieves a finite approximation factor based on the capacity of the convoys.



\begin{theorem}\label{thm: static: reopt: approximation factor}
For the Static Relocation Problem  with one depot,
the algorithm \REOPT\ achieves an approximation factor of . \end{theorem}


That \REOPT\ computes a non-preemptive transportation schedule for the Static Relocation Problem has already been observed in the previous section.
In order to prove the approximation factor, we first introduce some definitions, as well as state and prove some lemmas.


Firstly, from a given tour, we construct a new tour where each action picks up (resp.~drops) exactly one car.
Considering such tours only simplifies several technical issues, like estimating the number of consecutive pickup actions.
Secondly, we construct a new transportation schedule from an optimal transportation schedule and a minimal perfect -matching.
Finally, we compare the lengths of an optimal transportation schedule~, a transportation schedule  derived from a minimal perfect -matching, and the constructed transportation schedule  and show that

holds, which proves the stated approximation factor.
Hereby, we construct the transportation schedule~ by taking moves and actions of the optimal transportation schedule~ and
by constructing moves from the transport requests of the minimal perfect -matching.
Then, the approximation factor  emerges from the maximal number of moves corresponding to moves through the system in order to pickup cars and from moves which are serving a transport requests.


We start by showing how to construct a tour  from a given tour , where in each action exactly one car is picked up or dropped.

For every  do
\begin{itemize}
 \item add move  to ,
 \item for every action~ where more than one car is picked up from a station~ at time~, we ``replace'' the action by actions each picking one car and waiting moves (with 0 waiting time) between these actions,
       i.e., if  then add the following  actions and  moves 
        are added to ,
 \item for every action~ where more than one car is dropped at a station~ at time~, we ``replace'' the action by actions each picking one car and waiting moves (with 0 waiting time) between these actions,
       i.e., if  then add the following  actions and  moves 
        are added to ,
 \item every action  with  is added unchanged to .
\end{itemize}
The tour  is called a \emph{uniform tour} corresponding to .
A transportation schedule containing only uniform tours is called \emph{uniform transportation schedule}.


Note that a uniform tour is indeed a tour.
Furthermore, note that there exists exactly one uniform tour corresponding to a tour (if no unnecessary empty actions and waiting moves are added), but from a uniform tour, one can generally derive several non-uniform tours.

In this section, we consider non-preemptive transportation schedules, i.e., there does not exist a tour depending on another tour.
Therefore, empty actions can be safely removed from any tour in a transportation schedule (some moves may need to be adjusted accordingly).
For the rest of this section, we assume that no action is empty.


\begin{example}\label{ex: static: reopt: uniform tour}
Let us consider the graph and the dashed tour for driver~ from the right side of Figure~\ref{fig: reopt}.
The tour is then given by

and the corresponding uniform tour is then

The ``replaced'' action is highlighted with bold fonts, all other actions  have already the form .
\end{example}



The following lemma is a direct conclusion from the construction of an uniform tour.

\begin{lemma}\label{lem: static: reopt: max consecutive actions}
  Let  be a uniform tour for driver~.
  Then there are at most  consecutive pickup (resp.~drop) actions in the sequence .
\end{lemma}





Next, we construct a graph~ from a given tour, where the set of nodes corresponds to the actions, and the set of arcs to the moves of the tour.
Afterwards, we combine this graph with transport requests (leading to a graph~), which then helps us to construct another tour (from this tour we finally gain the transportation schedule~).
This constructed tour has some nice properties with respect to the number of traverses of each arc of~, which finally helps us to prove our main result (Theorem~\ref{thm: static: reopt: approximation factor}).


From a given tour , we construct a directed weighted graph , where
\begin{enumerate}
 \item the set of nodes  corresponds to the actions in ,  corresponds to the set of pickup actions,  to the set of drop actions, and  to an empty action at the depot , i.e., ;
\item there is an arc from  to  if  and  for a , furthermore there is an arc from  to  and from  to ;
 \item the weight function  corresponds to the distances between the origin and destination stations of the corresponding moves, i.e., we set .
\end{enumerate}
We call such a graph a \emph{tour graph} for , the set  is called the set of \emph{tour arcs}.


Note that one can assign to every arc  of a tour graph a move .
Then  is called the \emph{corresponding move} to .


\begin{example}
The tour graph for the tour  from Example~\ref{ex: static: reopt: uniform tour} is illustrated in Figure~\ref{fig: static: reopt: tour 1 action}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{reopt-tour-graph-01.pdf}
 \caption{
  This figure shows the tour graph for the uniform tour  from Example~\ref{ex: static: reopt: uniform tour}.
  The weights of the arcs correspond to the shortest distance between the connected two stations.
  In the tour graph, a pickup action at station  is denoted by  and a drop action at  by .
 }
 \label{fig: static: reopt: tour 1 action}
\end{figure}
\end{example}




Analogously, to a uniform tour we now define a set of uniform transport requests.
A transport request  is called \emph{uniform} if~.
Obviously, every set of transport requests can be transformed into a set of uniform transport requests by splitting every transport request  into~ uniform transport requests.
A set of transport requests  is called \emph{set of uniform transport requests} if every transport request  is uniform.


To each uniform transport request , we can now assign two actions for a driver~, one pickup  and one drop action .
Hereby, every action is assigned to exactly one transport request.

Let  be a tour graph and let  be a set of transport requests.
Then we construct a directed weighted graph , where
 is the set of \emph{transport arcs}, which consist of arcs corresponding to the transport requests in ,
i.e., for a transport request  there is an arc between  if  is the assigned pickup action of  and  the assigned drop action of .
The weight of a transport arc is equal to the distance between the locations of the two assigned actions.
The graph~ is called a \emph{transport graph} (see Figure~\ref{fig: static: reopt: transport graph} for an illustration).


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{reopt-tour-graph-with-transport-01.pdf}
 \caption{
  This figure shows a transport graph for the uniform tour  from Example~\ref{ex: static: reopt: uniform tour} and the set of transport requests
  .
  The weights of the arcs correspond to the shortest distance between the connected two stations.
  In the tour graph, a pickup action at station  is of the form  and a drop action is of the form .
  The dash-dotted arcs correspond to transport arcs.
 }
 \label{fig: static: reopt: transport graph}
\end{figure}



\begin{remark}\label{rem: static: reopt: construct tour from transport graph}
Let  be a tour graph for a tour  for driver~ and let  be a set of transport requests.
From a transport graph  for  and , one can construct a new tour  that serves all transport requests in , as follows:
\begin{itemize}
 \item Start in the depot  (resp.~the node corresponding to the depot).
 \item Consider the next tour arc  or non-traversed transport arc .
 \item If a tour arc  is selected, we add a corresponding move~ to~ from  to  with .
 \item If necessary, add empty actions (or merge the moves).
 \item If a transport arc  is selected, we add the pickup action~, a move  and a drop action~ to~.
 \item When all transport requests are served, return to depot the by following tour arcs until the depot is reached.
\end{itemize}
The departure and arrival times of a move  are directly induces by the departure and arrival times of the moves preceding .

Note that following this construction, we always construct a tour.
However, without further restrictions
this easy construction
does not ensure an upper bound on the number of traverses of an arc
(later in Algorithm~\ref{alg: static: reopt: construct tour} we give a refined construction which ensures an upper bound on the number of traverses of an arc).
\end{remark}



When we speak about a \emph{constructed tour} (from a transport graph~ and a set of transport requests~),
we mean a tour  which is constructed using only the arcs from~ and which serves all transport requests from~.


\begin{example}\label{ex: static: reopt: tour from transport graph}
Let us consider the transport graph from Figure~\ref{fig: static: reopt: transport graph}.
A possible new tour serving all transport requests  constructed from the transport graph, is then given by (see Figure~\ref{fig: static: reopt: tour from transport graph} for an illustration)

Hereby, the stations  and  both correspond to the station~.
However, for the sake of readability, we use  and  instead of~.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{reopt-tour-from-graph-with-transport-01.pdf}
 \caption{
  This figure shows a possible tour constructed from the transport graph of Figure~\ref{fig: static: reopt: transport graph} serving the transport requests .
 }
 \label{fig: static: reopt: tour from transport graph}
\end{figure}
\end{example}



Our goal is to construct a new tour from a transport graph, constructed from an optimal tour, and from a set of transport requests, which is generated from a minimal perfect p-matching.
Then, we show that the approximation factors from Theorem~\ref{thm: static: reopt: approximation factor} hold for this constructed new tour.
For that we define a function which returns for each arc of a transport graph the number of traverses of the arc during the construction of the tour.


Let  be a uniform tour,  be a set of transport requests and  be a transport graph for  and .
Furthermore, let  be a constructed tour from~ and~.
Then, we consider a so-called \emph{traverse counter function}, which is a function~ which reflects how often a tour arc  is traversed during the construction of .

With the function , we counts the traverses of the tour arcs only, while we the request arcs are handled later.


\begin{example}
\label{ex: static: reopt: traverse counter function}
Let us consider the transport graph from Figure~\ref{fig: static: reopt: transport graph} 
and the tour  from Example~\ref{ex: static: reopt: tour from transport graph}.
The traverse counter function  is then

Note that there are two arcs in the transport graph from Figure~\ref{fig: static: reopt: transport graph} between  and , one tour arc and one request arc.
Hereby, the tour  is constructed not by traversing the tour arc 
but instead by traversing the transport arc from~ to~ is traversed.
Thus, we have .
\end{example}




\begin{lemma}
\label{lem: static: reopt: f leq c plus 1}
  Let  be a uniform tour starting and ending in depot~,  a set of transport requests, and  a transport graph for  and .
  Furthermore, let  be the constructed tour from Algorithm~\ref{alg: static: reopt: construct tour} and let  be a traverse counter function for .
  Then  holds for all tour arcs .
  More specifically, we have
  \begin{enumerate}
   \item \label{lem: static: reopt: f leq c plus 1: 1}  holds for all tour arcs  with ,
   \item \label{lem: static: reopt: f leq c plus 1: 2}  holds for all tour arcs  with .
  \end{enumerate}
\end{lemma}



\begin{proof}


In the Example~\ref{ex: static: reopt: traverse counter function}, we can already make an important observation,
namely, nodes corresponding to a pickup action increase the number of traverses, nodes corresponding to a drop action decrease the number of traverses.
Next, we show that this observation is always true.



\begin{sublemma}
\label{lem: static: reopt: abs diff 1}
Let  be two tour arcs with  and  (i.e.,  is the successive tour arc of ).
Then  holds.
More specifically, it holds
\begin{enumerate}
 \item \label{lem: static: reopt: abs diff 1: 1}  if ,
 \item \label{lem: static: reopt: abs diff 1: 2}  if .
\end{enumerate}
\end{sublemma}



\begin{subproof}
The movement of a driver can be modeled by a flow .
Then the flow conservation constraint  must hold.
Hereby, the transport arcs must be taken into consideration as well.
It is easy to see that there always exists a flow  with  for all tour arcs .
Since every node corresponding to a pickup action has exactly one outgoing transport arc and every drop action has exactly one incoming transport arc,
and due to the flow conservation constraint it follows that
\begin{enumerate}
 \item  if ,
 \item  if 
\end{enumerate}
holds and, thus, proves the statement.
\end{subproof}



There are several consequences from this lemma.
Firstly, we show in the next corollary that the difference of the number of traverses of two different tour arcs can be bounded from above.
Secondly, we show a relation between the number of traverses of an arc and the number of cars that are transfered in the corresponding move within the constructed tour.


\begin{sublemma}
\label{cor: static: reopt: leq C}
Let  be successive tour arcs (i.e, ), and
let  be a function that returns the number of cars transfered in the corresponding moves in .
Then
\begin{enumerate}
 \item \label{cor: static: reopt: leq C: 1} , and
 \item \label{cor: static: reopt: leq C: 2}  holds for all tour arcs~.
  Especially it holds  for every pair of tour arcs .
\end{enumerate}
\end{sublemma}



\begin{subproof}
``\ref{cor: static: reopt: leq C: 1}''
Lemma~\ref{lem: static: reopt: max consecutive actions} shows that in every tour there are maximal  consecutive pickup actions and maximal  consecutive drop actions.
Furthermore, the number of cars in a convoy must not exceed the capacity~.
Since  holds, the difference cannot be greater than~.


``\ref{cor: static: reopt: leq C: 2}''
Let  be a tour arc and let  be the successive tour arc.
We proof the statement with two cases, when the end node of  is a node in  and when it is a node in .

\textit{Case i} (the end node of  is a node in ):
From Claim~\ref{lem: static: reopt: abs diff 1}~\ref{lem: static: reopt: abs diff 1: 1} it follows that .
Since the end node of  corresponds to a pickup action, the number of cars transported in~ is increased by , i.e., we have .
Thus, it follows  and, therefore, .

\textit{Case ii} (the end node of  is a node in ):
From Claim~\ref{lem: static: reopt: abs diff 1}~\ref{lem: static: reopt: abs diff 1: 2} it follows that .
Since the end node of  corresponds to a drop action, the number of cars transported in~ is decreased by , i.e., we have .
Thus, it follows  and, therefore, .

We have shown, that the statement holds for two successive arcs.
The statement for arbitrary pairs now follows by iteratively applying the two cases.
\end{subproof}



Next, we show that the maximum of a traverse counting function is always on the incoming and outgoing tour arcs of the depot.



\begin{sublemma}
\label{cor: static: reopt: f geq f and f gt f}
  Let .
  Then 
  \begin{enumerate}
  \item  for all tour arcs~,
  \item  for all tour arcs~, with .
  \end{enumerate}
\end{sublemma}



\begin{subproof}
Let  be a function that returns the number of cars transfered in the corresponding moves in .
From Lemma~\ref{lem: static: reopt: f leq c plus 1} \ref{lem: static: reopt: f leq c plus 1: 2} we know that  for .
At the beginning and end of a tour, the number of cars in a convoy is always~ and, thus, we have  for all .
The statements now follows since  for all  and  for all , with .
\end{subproof}



In Algorithm~\ref{alg: static: reopt: construct tour} we describe a specific construction for new tours from a given tour and a given set of transport requests.
For this new tour  holds for all .
This can be seen as follows.



\begin{algorithm}[ht]
\caption{Construct new tour}
\label{alg: static: reopt: construct tour}
\begin{algorithmic}[1]
  \Require{a uniform tour  with backhaul for driver~, the depot~, a set of transport requests~}
  \Ensure{a tour  serving all transport requests of~}
\State{construct transport graph }
  \State{initialize }
\State{initialize }                                                          \label{alg: static: reopt: construct tour: 4}
  \While{not every node in  has been visited}
    \If{ \textbf{and} has not been visited}
      \State{mark  as visited}
      \State{follow transport arc and add corresponding moves and actions to }
    \Else{}
      \State{follow tour arc and add corresponding move to }
    \EndIf{}
    \State{update }
  \EndWhile{}
  \State{follow tour  until arriving in depot node}
  \State{if necessary insert empty actions between two successive moves in }
\State{\Return }
\end{algorithmic}
\end{algorithm}



It is fairly easy to see that Algorithm~\ref{alg: static: reopt: construct tour} follows basically the same steps as in Remark~\ref{rem: static: reopt: construct tour from transport graph}.
Furthermore, one can easily see that really a tour is constructed, serving all transport requests.
In contrast to the construction in Remark~\ref{rem: static: reopt: construct tour from transport graph}, Algorithm~\ref{alg: static: reopt: construct tour} ``follows'' the given tour only until it arrives at a non-visited node corresponding to a pickup action and directly serve the transport request.




Since the constructed tour in Algorithm~\ref{alg: static: reopt: construct tour} ``follows'' the moves from~ until the next non-visited pickup action,
it is ensured, that the number of traverses of an arc is not artificially increased.
Thus, the result follows with the help of Lemma~\ref{lem: static: reopt: max consecutive actions}, Claim~\ref{lem: static: reopt: abs diff 1}, Claim~\ref{cor: static: reopt: leq C} and Claim~\ref{cor: static: reopt: f geq f and f gt f}.
\end{proof}





\begin{remark} \label{rem: static: reopt: arbitrary start node}
  Although Algorithm~\ref{alg: static: reopt: construct tour} starts the construction of the tour from the depot, any arbitrary node could be used as a starting node.
  That could be done by removing line~\ref{alg: static: reopt: construct tour: 4} and giving  as a parameter.
  When the construction is started with another node, Lemma~\ref{lem: static: reopt: f leq c plus 1} still holds, and so does Lemma~\ref{cor: static: reopt: existence tour}.
\end{remark}






Let  be a uniform tour, and let  be a set of uniform transport requests so that  serves all transport requests in .
Furthermore, let  be a transport graph for  and .
Since every transport request  is served by , there exists a path of tour arcs in  from the action  corresponding to~ to the action  corresponding to~.
Let this path of tour arcs be .
Due to the triangle inequality we can estimate the length  of the transport arc by

Therefore, the length of all transport arcs can be estimated by applying above formula iteratively on all transport arcs,

where  is the minimal path of tour arcs in  between the corresponding actions.
Now we can consider a function , called \emph{transport estimate function},
where  shows how often the tour arc  is used in the right hand side of Equation~\eqref{eq: static: reopt: estimate length all transport arcs}.
With~ can reformulate Equation~\eqref{eq: static: reopt: estimate length all transport arcs} as




It is easy to see, that the values of a transport estimate function depends on the choice of the set of transport requests~.
In order to prove the main theorem, we consider a specific set of transport requests.
For that let  be a uniform tour for a driver starting and ending in depot~.
A set of uniform transport requests~ so that
\begin{enumerate}
  \item \label{lem: static: reopt: existence tour: i}    serves all transport requests in~,
  \item \label{lem: static: reopt: existence tour: ii}  for every transport request  there are at most~ actions between two corresponding actions for , and
  \item \label{lem: static: reopt: existence tour: iii} there does not exist a transport request  so that the minimal path
                                                        from  to  of tour arcs traverses the tour arcs connecting the depot,
\end{enumerate}
holds is called a set of \emph{close distance uniform transport requests} for~.

In the next lemma, we show that for every uniform tour there exists a set of close distance uniform transport requests.
Hereby, also the motivation for the choice of the name becomes clear as well.


\begin{lemma}
\label{lem: static: reopt: existence tour}
  Let  be a uniform tour for a driver starting and ending in depot~.
  Then there exists a set of close distance uniform transport requests for~.
\end{lemma}



\begin{proof}
Let .
Since a tour starts and ends in the depot and there must be no car in the depot it follows that

holds for every tour .
Furthermore, if  contains actions, it follows that the first action is a pickup action and the last action a drop action.
Otherwise, there exists a move  with  or  or the driver transfers vehicles into the depot, contradicting the definition of a tour.


We construct a set of transportation requests  by assigning the station of the first pickup action in  to the station of the first drop action in ,
the station of the second pickup action in  to the station of the second drop action in , and so forth until all actions are assigned.
Since the number of cars picked up or dropped in an action in  is exactly one and due to Equation~\eqref{eq: static: reopt: existence tour: zero sum},
there exists a pickup action for a drop action.
Thus, it also follows that the number of actions is even in .



Let  be a transportation request and let  be the corresponding pickup and  the corresponding drop action for .
Using this construction, we show that there are at most  actions between  and .

We prove the statement by induction over the number of actions~ in~.
For  and  there are  actions between  and  proving the base case.

Let us assume that the induction hypothesis holds, i.e., there are at most  actions between  and  for all tours with  actions.

Next, we prove the inductive step.
For that, let  have  actions.

We construct a sequence of  actions and  moves from~ by removing the first pickup and the first drop action from~.
Afterwards, we show that this sequence is a tour.
Then the statement follows from the induction hypothesis.

Since every action is non-empty,  is the first pickup action.
Let~ be the first drop action.
Furthermore, let , 
and , .

First, let us consider the following new moves  and 
 and
let , for all , be a move constructed from the move .
Finally, let  for all .

Then 
is an alternative sequence of  moves and  actions.
We show that  is indeed a tour.
It is sufficient to show for every move  in~ that  holds.

For that, we consider the number  of consecutive pickup actions before the move~ and 
number  of consecutive drop actions directly after~ in~,
as well as
the number  of consecutive pickup actions before the move~ and 
number  of consecutive drop actions directly after~ in~.
Since  is a tour, it follows from Lemma~\ref{lem: static: reopt: max consecutive actions} that  holds.
From the construction of  it follows

and, thus, we have .
Furthermore, it follows that the number of cars in the convoy of driver~ are equal in both sequences in and after the move~ and , respectively,
i.e., for every  we have , where  is the number of cars in the move .


Then, it follows for every move  in~ that  holds,
and, thus, that  is a tour with  actions.
Therefore, the induction hypothesis can be applied to  and it follows that there are at most  actions between the corresponding pickup and drop actions of a transportation request.
Since there are at most  consecutive pickup actions at the start of a tour (Lemma~\ref{lem: static: reopt: max consecutive actions}), it follows that there are at most  actions between the first pickup action and the first drop action.
This proves the inductive step and the statement follows.


Since we assign a transport request to every pickup and drop action, the tour serves all transport requests in .


Finally, it follows by construction that there does not exist a transport request  so that the minimal path from  to  of tour arcs traverses the tour arcs connecting the depot.
\end{proof}





\begin{lemma}
\label{cor: static: reopt: existence tour}
  Let  be a uniform tour starting and ending in depot~,
  and let  be a tour graph for .
  Furthermore, let  be a function that returns the number of cars transfered in the corresponding moves in ,
and let~ be a set of close distance uniform transport requests for~.
  Then for a transport estimate function  for~ it holds
  \begin{enumerate}
   \item \label{cor: static: reopt: existence tour: 1}  for all , and
   \item \label{cor: static: reopt: existence tour: 2}  for all .
  \end{enumerate}
\end{lemma}


\begin{proof}
Firstly, we show that for a transport graph  for  and  and a transport estimate function  for  \begin{enumerate}[label=(\alph*),ref=(\alph*)]
      \item \label{lem: static: reopt: existence tour: iii: i}  for all ,  with , and
      \item \label{lem: static: reopt: existence tour: iii: ii}  for all ,  with ,
  \end{enumerate}
holds.
Within the proof, we also show that~\ref{cor: static: reopt: existence tour: 1} holds.
Secondly, the Statement~\ref{cor: static: reopt: existence tour: 2} follows from Claim~\ref{cor: static: reopt: leq C} \ref{cor: static: reopt: leq C: 2}.




To prove the third statement, we show that , where  is the move corresponding to the tour arc~.
This can be seen as follows.
Since  is a set of close distance transport requests, there does not exist a transport request  so that the minimal path of tour arcs traverses the tour arcs connecting the depot.
Thus, we have  where  and .
Since  is a tour, the node  corresponds to a pickup action.
Thus, for the move  corresponding to the tour arc~, we have .
Furthermore, the tour arc  appears once on the right hand side of Equation~\eqref{eq: static: reopt: estimate length all transport arcs}, i.e., .

If  corresponds to a pickup action then the number of cars transfered from  to the next station is increased by one.
Since the destination of the transport request that started in  does not correspond to ,
the corresponding tour arc  appears twice on the right hand side of Equation~\eqref{eq: static: reopt: estimate length all transport arcs}:
once due to the transport request  and once due to .

Analogously, if  corresponds to a drop action, the number of cars transfered from  to the next station is decreased by one.
Since the transport arc corresponding to the transport request  ends in , the number of appearances of the tour arc 
on the right hand side of Equation~\eqref{eq: static: reopt: estimate length all transport arcs} is decreased as well.

In the first case we have  and in the second case .

The above arguments can be applied iteratively to all nodes in , showing that~\ref{lem: static: reopt: existence tour: iii: i} and~\ref{lem: static: reopt: existence tour: iii: ii} hold.


Since the values of the transport estimate function  corresponds to the number of cars transfered in the corresponding move,
the stament follows directly from Claim~\ref{cor: static: reopt: leq C} \ref{cor: static: reopt: leq C: 2}.
\end{proof}



Finally, we prove the main theorem of this section.


\begin{theorem} \label{thm: static: reopt: approximation factor: symmetric and asymmetric}
For the Static Relocation Problem  with one depot,
the algorithm \REOPT\
achieves an approximation factor of  for all .
This approximation factor holds in the symmetric and in the asymmetric case.
\end{theorem}




\begin{proof}
We start by proving a special case when there is only one driver in the system.
Afterwards, we generalize this special case to the general situation when there are  drivers in the system.

Let  be an optimal tour for .
Let  be a set of transportation requests induced by a minimal perfect -matching, and let  an optimal tour serving all transport requests in ,
i.e., a tour with a minimal total tour length serving all transport requests in .
Finally, let  be the constructed tour from Algorithm~\ref{alg: static: reopt: construct tour}.
Then we have

where  is the total tour length of the tour .
Thus, we only need to show that

holds.

Let  be a set of close distance uniform transport requests.
Since  is induced by a minimal perfect -matching, it holds


Let  be a traverse counter function for  and let  be a transport estimate function.
Let  be a function that returns the number of cars transfered in the corresponding moves in .
By definition, a convoy is empty at the beginning of a tour, and therefore,  for .
Since we have  for all  (Lemma~\ref{cor: static: reopt: existence tour}~\ref{cor: static: reopt: existence tour: 1}),
it follows .
From Lemma~\ref{lem: static: reopt: f leq c plus 1} we know that  for all ,
and thus, it follows from Lemma~\ref{cor: static: reopt: existence tour}~\ref{cor: static: reopt: existence tour: 2} that  holds for all .

With above and Equation~\eqref{eq: static: reopt: estimate length all transport arcs: fTR} we can estimate the total tour length  by

proving the statement of the theorem if there is only one driver in the system.



Next we consider the general case, i.e., there are  drivers.
Since there is only one depot, and every tour starts and ends in the depot, all tours can be ``merged'' to one tour.
For that let  be a transportation schedule with  tours and with .
Since by assumption~ is large enough, we can construct a new tour ,
where (except for the first and last tour) the moves to and from the depot are replaced by one move between
the succeeding and preceding station, respectively (see Figure~\ref{fig: static: reopt: k tour one driver} for an illustration).
Thus, all  tours are performed by only one driver.
Due to the triangle inequality it follows that the length of the tour~ is at most the total tour length of the transportation schedule .
Therefore, we can generalize the statement when there are~ drivers in the system.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{reopt-k-tour-graph-01.pdf}
    \includegraphics[width=0.4\textwidth]{reopt-k-tour-graph-02.pdf}
 \caption{
  This figure illustrates how one driver can perform  tours if there is only one depot.
  On the left side, the figure illustrates a transportation schedule with 2 drivers,
  On the right side, a combined transportation schedule with only one driver.
 }
 \label{fig: static: reopt: k tour one driver}
\end{figure}




Finally, note that we constructed a new tour by following either the tour arcs (induced by an optimal tour) or the transport request arcs (induced by the minimal perfect -matching).
Especially, no back arc is traversed.
Thus, it follows that this approximation factor is also valid for the asymmetric case when there is only one depot.
\end{proof}



\subsection{Multiple depots}\label{sec: static: reopt: multiple depot}

In the case that there is only one depot, the algorithm \REOPT has an approximation factor of , independently from the number of drivers,
or whether we have the symmetric or asymmetric case.
In this section, we consider the case when there are multiple depots.
Hereby, we can further distinguish between two situations: every tour must start and end in the same depot (Static Relocation Problem with multiple depots and with backhaul),
and every tour can start and end in a different depot (Static Relocation Problem with multiple depots and without backhaul).


Firstly, we consider the situation where every tour can start and end in a different depot (i.e., tours without backhaul).
We show that in the asymmetric case, the algorithm \REOPT generally does not have an approximation factor.
However, we give for a special case an approximation factor of , namely when in the optimal tour every driver returns to the depot from where its tour started.
Note that this special case makes an assumption to the properties of an optimal tour,
while the case when we have backhaul forces the tours to have certain properties in order to be a feasible solution for the Static Relocation Problem.
In the symmetric case without backhaul, the approximation factor is .
We gain the factor~ since the algorithm \REOPT ensures that all drivers return to their starting depot.


Secondly, we consider the situation when every tour must end in its starting depot (i.e., tours with backhaul).
In this situation, we can show that the algorithm \REOPT has an approximation factor of  in the symmetric and asymmetric situation.
We show this approximation factor, by applying nearly the same steps as we do in previous section,
where we prove the approximation factor for the case when there is only a single depot.
In fact, we mainly modify the construction of the transport graph (Definition~\ref{def: static: reopt: multiple: transport graph}) and Algorithm~\ref{alg: static: reopt: construct tour},
so that they are able to handle not only one tour but multiple tours (Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot}).


In order to show, that there does not exist an approximation factor for the algorithm \REOPT in the asymmetric case, even when there is only one driver, we consider the following example.

\begin{example}\label{ex: static: reopt: multiple: asymmetric non possible}
We consider the asymmetric situation with two depots  and  and four stations .
There is only one driver in the system, the convoy capacity is~.
In the stations  and , one car has to be picked up, and at  and  one car has to be dropped.
We consider the following distances

and for all other pairs of stations  and  we set

with  arbitrary.
An optimal tour  serving all requests is induced by the path .
The total tour length .

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.25\textwidth]{reopt-multiple-depot-asymmetric-01.pdf}
 \caption{
  This figure shows a schedule graph for an optimal tour  and the set of minimal transport requests .
  The arcs, with their numbers below, correspond to the distance between the connected stations.
  For all other distances, i.e., for the distances of the non-visible arcs, the distances are~.
  In the schedule graph, a pickup action at station  is denoted by  and a drop action by .
  The dash-dotted arcs correspond to transport arcs.
 }
 \label{fig: static: reopt: multiple: asymmetric 01}
\end{figure}


A set of transport requests induced by a minimal perfect -matching is given by .
The total tour length  for every tour, serving the transport requests in , is at least~.
Since  was arbitrarily selected, there cannot exist a constant  so that

holds.
\end{example}



The reason why we cannot give an approximation factor in the previous example is that we have to traverse at least once an arc that is not traversed by an optimal tour.
Note that this example holds for all algorithms which compute tours using all arcs from a minimal perfect -matching.
An open question is whether there exists a deterministic algorithm for the Static Relocation Problem with multiple depots without backhaul with a constant approximation factor.


However, in order to prove an approximation factor for the a special case of the Asymmetric Static Relocation Problem with multiple depots without backhaul,
where in the optimal transportation schedule every driver returns to its starting depot,
and in order to prove the approximation factor for the Symmetric Static Relocation Problem with multiple depots without backhaul,
we have to give some definitions and further results.

First, we define a graph similar to a transport graph, but in this case it is constructed from a transportation schedule instead of a tour.
As in the transport graph, the nodes correspond to the actions, and the arcs correspond to moves.


\begin{definition}\label{def: static: reopt: multiple: transport graph}
From a given transportation schedule , 
where 
we can construct a weighted graph ,
with , ,  and ,
where
\begin{enumerate}
 \item the sets of nodes  correspond to the actions in~; the set of \emph{pickup nodes}  corresponds to the set of pickup actions,
        the set of \emph{drop nodes}  to the set of drop actions,
        the set of \emph{depot nodes}  to the set containing empty actions at the depots, i.e., ;
 \item there is an arc from  to  if  and  for a , furthermore there is an arc from  to  and from  to ;
 \item the weight function  corresponds to the distances between the origin and destination stations of the corresponding moves, i.e., we set .
\end{enumerate}
We call such a graph a \emph{schedule graph} for , the set  is called the set of \emph{schedule tour arcs}.

Let  be a set of transport requests.
Then a graph  is called \emph{transport schedule graph}
if  is a schedule graph and the set  corresponds to the transport requests,
i.e., to every transport request  there is an arc  assigned to~.
\end{definition}



Let  be a transportation schedule, let  be a set of transport requests, and let  be the corresponding transport schedule graph.
Then we can construct a directed graph from a transport schedule graph, which has as nodes the tours and as arcs the transport requests between the tours.
Laxly said, this graph ``highlights'' the transport requests which are between two different tours.
This simplified version of a transport schedule graph enables us to prove some properties which we need in order to gain an approximation factor for \REOPT which is independent from the number of depots in the system.
Formally, we define a directed graph , with
\begin{itemize}
 \item each node  corresponds to a tour , and
 \item every arc corresponds to a transport request , where  and  are in different tours, i.e., , , with .
\end{itemize}
We call the graph~ a \emph{tour connection graph} for  (see Figure~\ref{fig: static: reopt: multiple: tour connection graph} for an illustration).
Note, that a tour connection graph is loop free, but there can be multiple arcs between two nodes.



\begin{figure}[ht]
    \centering
    \includegraphics[width=0.65\textwidth]{reopt-tour-connection-graph-with-transport-01.pdf}
 \caption{
  This figure shows a tour connection graph constructed from the two tours shown in Figure~\ref{fig: reopt} and from the transport requests induced by an optimal solution (see Figure~\ref{fig: flownetwork}).
  Solid arcs correspond to the schedule tour arcs, and the dashed arcs correspond to the transport requests.
  In the graph, a pickup action at station  is denoted by  and a drop action by .
  The nodes  and  correspond both to a pickup action at station~ (and analog for the nodes  and ).
  Furthermore, note that both tours start in the same depot, but in a tour connection graph, there is a depot for each tour.
 }
 \label{fig: static: reopt: multiple: tour connection graph}
\end{figure}






\begin{lemma}\label{lem: static: reopt: multiple: tour connection graph: connected thus strongly}
Let  be a transportation schedule,
let  be a set of transport requests, and let  be a corresponding transport schedule graph.
Furthermore, let  be a tour connection graph for .
Then it is true
\begin{enumerate}
 \item\label{lem: static: reopt: multiple: tour connection graph: connected thus strongly: 1} every connected component in  is also strongly connected,
 \item\label{lem: static: reopt: multiple: tour connection graph: connected thus strongly: 2} if every tour in  is a tour with backhaul, then every connected component in  is also strongly connected.
\end{enumerate}
\end{lemma}



\begin{proof}
``\ref{lem: static: reopt: multiple: tour connection graph: connected thus strongly: 1}'': 
we prove that for every node~ and for every outgoing arc  of~ there exists an incoming arc  of~.
Every transport arc  connects exactly two actions.
Whenever~ corresponds to an action in one tour~ and~ corresponds to an action in another tour~, there is an arc .
Since every action in~ is uniform, it follows that the number of non-empty actions in every tour is even.
Therefore, there must exist a transport arc , with  and , i.e., there is an incoming arc in .
Thus, we have  for all .


From Euler's Theorem it now follows that in every connected component of~ there exists an Eulerian walk.
Especially, it follows that every connected component of~ is also strongly connected.


``\ref{lem: static: reopt: multiple: tour connection graph: connected thus strongly: 2}'': 
since  is a transportation schedule with backhaul, every tour of  is represented by a cycle of tour arcs in~ and, thus, a strongly connected component.
From the two statements above it follows that every connected component in~ is also strongly connected.
\end{proof}



Note, in the asymmetric case without backhaul, connected components in~ are generally not strongly connected (e.g., see Example~\ref{ex: static: reopt: multiple: asymmetric non possible}).
Furthermore, whenever we modify this graph so that every connected component becomes strongly connected, at least one arc cannot be estimated in general.
Later we see that in the symmetric case, we can modify~ so that every connected component in~ is also strongly connected and every added arc can be estimated.
This is achieved by connecting some actions with the ``original'' depot.
In the symmetric case, an approximation factor can then still be computed since the distance from~ to~ is equal to the distance from~ to~.



\begin{algorithm}[ht]
\caption{Construct new transportation schedule (asymmetric case with multiple depots and without backhaul)}
\label{alg: static: reopt: multiple: construct tour multiple depot}
\begin{algorithmic}[1]
  \Require{a uniform transportation schedule  with backhaul, a set of depots~, a set of uniform transport requests~}
  \Ensure{a uniform transportation schedule  with backhaul}
\State{construct transport schedule graph }
  \State{initialize  for all }
  \For{}                                                                                                      \Comment{loop through every tour}
    \State{initialize }                                                                                         \Comment{tour  starts in depot }
    \State{initialize }                                                                                               \Comment{the currently considered tour}
    \While{not every node in  has been visited}
      \If{ \textbf{and} has not been visited}                                                              \label{alg: static: reopt: multiple: construct tour multiple depot: 8}
        \State{mark  as visited}                                                                                              \label{alg: static: reopt: multiple: construct tour multiple depot: 9}
        \State{follow transport arc and add corresponding moves and actions to }
        \State{update  if tour is changed}                                                                                    \label{alg: static: reopt: multiple: construct tour multiple depot: 14}
      \Else{}
        \State{follow tour arc and add corresponding move to }                                                       \label{alg: static: reopt: multiple: construct tour multiple depot: 16}
      \EndIf{}
    \State{update }
    \EndWhile{}
    \State{follow current tour until arriving in depot}
  \EndFor
  \State{insert empty actions between two successive moves if necessary}
  \State{\Return }
\end{algorithmic}
\end{algorithm}



Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot} constructs a new transportation schedule with backhaul from a given uniform transportation schedule with backhaul,
a set of depots and a set of uniform transport requests.
Hereby, the algorithm always prioritizes following transport request arcs over following tour arcs.
Similarly to the constructed tour from the previous section, we state and prove some properties of this transportation schedule.


It is easy to see that Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot} constructs a new transportation schedule.
However, it is not obvious that in this transportation schedule all drivers return to their original depot, which we show in the next lemma.


\begin{lemma}\label{lem: static: reopt: multiple: connected eq strongly}
Let  be a uniform transportation schedule with backhaul, let  be a set of depots and let  be a set of uniform transport requests.
Then Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot} constructs a new transportation schedule with backhaul.
\end{lemma}



\begin{proof}
In Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot} we ``follow'' the tour arcs of a tour until we come to a pickup node that has not been visited before
(lines~\ref{alg: static: reopt: multiple: construct tour multiple depot: 8} and~\ref{alg: static: reopt: multiple: construct tour multiple depot: 16}).
If in the algorithm the current node is a non-visited pickup node, then the algorithm ``follows'' the transport
(lines~\ref{alg: static: reopt: multiple: construct tour multiple depot: 9}--\ref{alg: static: reopt: multiple: construct tour multiple depot: 14}).
From Lemma~\ref{lem: static: reopt: multiple: tour connection graph: connected thus strongly} we know that every connected component in~ is also strongly connected.
Furthermore, the number of incoming and outgoing arcs for every node in  are equal and, thus, there exists an Eulerian walk in .
Therefore, it follows that the transportation schedule constructed in Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot} is a transportation schedule with backhaul.
\end{proof}




Next, we show that the approximation factor  holds even in the case of multiple depots.


\begin{theorem}\label{thm: static: reopt: multiple: with backhaul: C plus 1}
For the Static Relocation Problem  with multiple depots and with backhaul, and a complete graph ,
the algorithm \REOPT computes a non-preemptive transportation schedule and achieves an approximation factor of .
This approximation factor holds for the symmetric and asymmetric situation.
\end{theorem}



\begin{proof}
In order to prove this statement, we show how the results of the previous section can be applied to the case when there are multiple depots.
For that we concentrate on an arbitrary tour from the optimal transportation schedule and show that we can apply the results from the previous section on this tour.
Since the tour is arbitrarily selected, the statement then follows.


Let  be a transport schedule graph for an optimal transportation schedule  and let  be a set of transport requests computed from a minimal perfect -matching.
Let  be an arbitrary tour.
We say that there is a \emph{transport request between tours}, if there exists a transport request arc  in  so that  and  with .
In other words, if~ corresponds to a pickup action in a tour~ and~ corresponds to a drop action in tour~ with .

As we did before, we construct tours~ from the optimal transportation schedule and the set of transport requests.

We consider two different cases for this tour, when there are no transport requests in  between this tour and another tour,
and when there are transport requests in  between this tour and another tour.


Case 1 (there are no transport requests in  between this tour and another tour):
in this case, we can directly apply Theorem~\ref{thm: static: reopt: approximation factor} on , showing the statement for this case.

Case 2 (there are transport requests in  between this tour and another tour):
in this case, we cannot directly apply Theorem~\ref{thm: static: reopt: approximation factor} as we did in the previous case. 
However, due to Remark~\ref{rem: static: reopt: arbitrary start node}, it is not necessary to start the construction of a new tour within the depot but it can be used any arbitrary node within a transport graph.
Furthermore, all results from Section~\ref{sec: static: reopt: single depot} hold, when the construction has not been started in the depot.

From Lemma~\ref{lem: static: reopt: multiple: tour connection graph: connected thus strongly} it follows that whenever Algorithm~\ref{alg: static: reopt: multiple: construct tour multiple depot}
``leaves'' a tour at node~, it will eventually ``return'' to a node~.
Hereby,~ is the first ``entered'' node after the tour has been changed.

From the point of view of the tour~, the path from~ to~ in~ is like a transport request from~ to~.
Thus, we replace this path by an artificial transport request arc .
By repeating this procedure for all nodes which are start or end nodes of a transport request between~ and another tour, we receive a transport graph~.
On the constructed tour from~ and the transport requests we apply Theorem~\ref{thm: static: reopt: approximation factor}.
Since the tour was arbitrarily selected, this proves the statement.
\end{proof}




Finally, we consider the Symmetric Static Relocation Problem with multiple depots and without backhaul.
For a first result, we show that the algorithm \REOPT achieves an approximation factor of at most .
In order to prove this approximation factor, we construct in an intermediate step a transportation schedule with backhaul  from the optimal transportation schedule .
For every tour~ we construct a new tour~ by adding an arc from the last action of  back to the ``starting'' depot (if they differ in the original tour).
Since we consider the symmetric situation, this arc can be estimated by the total tour length of .
Thus, the total tour length of this constructed transportation schedule is at most twice as large as the total tour length of the optimal transportation schedule.
Applying Theorem~\ref{thm: static: reopt: multiple: with backhaul: C plus 1} on  then yields:


\begin{theorem}\label{thm: static: reopt: multiple: symmetric: without backhaul: 2 C plus 1}
For the Symmetric Static Relocation Problem  with multiple depots and without backhaul, and a complete graph ,
the algorithm \REOPT computes a non-preemptive transportation schedule and achieves an approximation factor of .
\end{theorem}







\section{Computational Results}
\label{seq: computational}


Both, the exact approach and the heuristic approach \REOPT, have been tested on randomly generated instances (with 20--80 over-/underfull stations,
50--100 stations in total, convoy capacities 5 and 10, and 10--30 drivers).
The stations are randomly distributed on a plane and the distances between two closest stations (w.r.t.~the Euclidean metric) are kept as rounded integers in the graph.
Hereby, we ensure that the graph is connected.
The time horizons are set to 100 in all test runs.
Note that the size of these instances corresponds to small car- or bikesharing systems or to clusters of larger systems, as in~\cite{SHH-2013}.


The algorithm ReOPT has been implemented in C++, and CPLEX v12.4 is used for solving ILPs.
The operating system is Linux (CentOS with kernel version 2.6.32).
The tests have been run on an Intel Xeon X5687 clocked at 3.60GHz, with 64 GB RAM.


For solving the integer linear program of the exact approach, we use Gurobi 5.6.
The test have been run on a Linux server (CentOS with kernel version 2.6.32) with 160 Intel Xeon CPUs E7-8870 clocked at 2.40GHz, with 1 TB RAM.
For the tests, we limited the number of threads to~32.
Since we could not find any feasible solution for the first instance after 40 hours, we rerun the solver on this instance with an increased time-limit of 160 hours.
After about 50 hours, a feasible solution has been found by Gurobi.
However, even after 160 hours, the optimal solution could not be found.
Due to the enormous runtime and the little to no gain, we did not rerun the solver with an increased time-limit on the remaining instances.
The solution found by the ILP solver has a total tour length of~ units and the lower bound found by Gurobi is~ (thus, the duality gap is approximately \%).
Due to the enormous runtime of finding a solution with the exact approach, we did not continue with the other instances.
Furthermore, one can see, that the improvements of the solution of the ILP solver are very little compared to the extra computational time spend.

In order to compute a preemptive transportation schedule, it is not necessary to distinguish between each of the drivers.
Therefore, there are less variables within the integer linear program which models the preemptive situation than within the integer linear program which models a non-preemptive situation for the same instances.
Since the total tour lengths of transportation schedules with preemption give lower bounds for the total tour lengths of non-preemptive transportation schedules,
we state the lower bounds computed from non-preemptive transportation schedules.
The lower bounds from Table~\ref{tab: computational results} are taken from feasible preemptive transportation schedules, and the duality gaps are computed from these lower bounds.


ReOPT computes solutions within a reasonable time (in average less than 1.5 minutes for the smaller instances with at most 40 imbalanced stations,
less than 8 minutes for the middle sized instances with 60 imbalanced stations,
and about 17 minutes for the bigger instances with 80 imbalanced stations, see Table~\ref{tab: computational results}).


\begin{table}
 \centering
 \caption{
    This table shows the average computational results for several test sets of instances of the algorithm ReOPT in comparison to the found optimal value by solving the ILP (the time limit was set to 2h and 4h).
    The considered time horizon is 100 for all test instances.
    The algorithm ReOPT was run several times with different parameters for  and .
    In this table, the following parameters and results are shown: the total amount of stations (1st column) and the number of overfull and underfull stations (2nd column).
    Hereby, the numbers in brackets are the number of overfull resp.~underfull stations.
    Furthermore, it shows the number of drivers , the server capacity \capd, the average runtime in seconds of ReOPT,
    the total tour length found by ReOPT and by the ILP solver, and the average optimality gap ().
 }
 \label{tab: computational results}
\begin{tabular}{c|c|c|c|c|c|c|c|c}
 stations & stations & k  & \capd  & runtime (s) & ttl (ReOPT) & ttl (ILP 2h) & ttl (ILP 4h) & gap (\%)  \\ \hline
 50       & 20 (10/10)    & 10 & 5/10 & 2.5        & 354.25      & 330      & 330      & 7.35      \\
 50       & 40 (20/20)    & 20 & 5/10 & 72.33      & 469         & 435.75   & 432.5    & 7.74      \\
 100      & 60 (30/30)    & 30 & 5/10 & 451.5      & 665.67      & 526      & 521      & 16.73     \\
 100      & 80 (40/40)    & 30 & 5/10 & 981.92     & 658.33      & --       & --       & --
\end{tabular}
\end{table}




\section{Conclusion}
\label{seq: conclusion}


In this paper, we considered the Static Relocation Problem ,
where tours for  drivers have to be computed in a (quasi) metric space , where the maximal length of the tours must be smaller or equal to a given time horizon .
Hereby, the drivers transfer cars between the stations by forming convoys of at most  cars.
In order to have an exact solution we construct a time-expanded network  from the original network  and compute coupled flows (a car and a driver flow) on this network with an ILP.
Due to the coupling constraints, the constraint matrix of the network is not totally unimodular (as in the case of uncoupled flows),
reflecting that the problem is at least \NPhard.

Thus, we presented a heuristic approach to solve the Static Relocation Problem: the algorithm \REOPT.
The construction of the tours by \REOPT\ is as follows:
firstly, transport requests between ``overfull'' and ``underfull'' stations are generated by a perfect -matching.
These transport requests serve as input for a Pickup and Delivery Problem, which is solved in the second step.
Finally, the tours are iteratively augmented by ``rematching'' certain origin/destination pairs, i.e., to reinsert accordingly adapted moves in such a way 
that the total tour length decreases.



The algorithm \REOPT\ has an approximation factor based on the given convoy sizes for the Symmetric Static Relocation Problem with and without backhaul
(Theorem~\ref{thm: static: reopt: approximation factor} and Theorem~\ref{thm: static: reopt: approximation factor: symmetric and asymmetric}).
In the asymmetric situation, the approach \REOPT\ can ensure a finite upper bound for the ratio of its solution to the optimal solution
only for the Asymmetric Static Relocation Problem with backhaul (Example~\ref{ex: static: reopt: multiple: asymmetric non possible} and Theorem~\ref{thm: static: reopt: multiple: symmetric: without backhaul: 2 C plus 1}).
The approximation factors for \REOPT\ in the different situations are summarized in Table~\ref{tab: conclusion: summary: approximation factors}.

\begin{table}[!htbp]
\centering
\caption{This table summarizes the approximation factors of \REOPT.
    All different situations which we consider in this paper are shown.
    In the case that there is only one depot, the tours with and without backhaul coincide (the reason why we marked two entries with a hyphon `-').}
\label{tab: conclusion: summary: approximation factors}
\begin{tabular}{c|c|c|c|c}
&  \multicolumn{2}{c|}{with backhaul} & \multicolumn{2}{c}{without backhaul} \\ \cline{2-5}
          & symmetric   & asymmetric           & symmetric & asymmetric \\ \cline{2-5}
single    &  &           & - & - \\ \hline
multiple  &  &           &   &  \\
\end{tabular}
\end{table}




Both approaches have been tested on randomly generated instances (with 20--80 over-/underfull stations, 50 and 100 stations in total, convoy capacities 5 and 10, and 10--30 drivers). 
The time horizon was set to 100 in all test runs.
Note that the size of these instances corresponds to small car- or bikesharing systems or to clusters of larger systems, as in \cite{SHH-2013}.
While the optimal solution could not be found even after 160 hours, the algorithm
ReOPT computes solutions within a reasonable time (in average less than 1.5 minutes for the smaller instances with at most 40 imbalanced stations,
less than 8 minutes for the middle sized instances with 60 imbalanced stations,
and about 17 minutes for the bigger instances with 80 imbalanced stations), and a reasonable gap to the solution computed by the ILP (see Table~\ref{tab: computational results}).
In order to be able to give at least a meaningful duality gap, we compared the solution with some lower bounds for preemptive transportation schedules, which can be computed in a shorter time.



There are several practical and theoretical open questions according to the Static Relocation Problem.
Improving the runtime and solutions of ReOPT is one goal.
Usually, every driver used gives additional costs.
Thus, it is desirable to know the minimal number of drivers needed in order to solve the Static Relocation Problem within the given time horizon.
To the best of our knowledge this is still an open question.
Due to the time horizon, it is possible that there does not exist a feasible solution for a given instance at all.
Having feasibility conditions is useful in two directions: to save unnecessary computation time for an algorithm and to generate test instances which can give feasible solutions.
Thus, finding feasibility conditions as well as lower bounds for the time horizon is another goal for the future.






\bibliographystyle{plain}

\begin{thebibliography}{10}

\bibitem{Ball+etal:handbook:95a}
Michael~O. Ball, Thomas~L. Magnanti, Clyde~L. Monma, and George~L. Nemhauser,
  editors.
\newblock {\em Network Models}, volume~7 of {\em Handbooks in Operations
  Research and Management Science}.
\newblock Elsevier Science B.V., Amsterdam, 1995.

\bibitem{Ball+etal:handbook:95b}
Michael~O. Ball, Thomas~L. Magnanti, Clyde~L. Monma, and George~L. Nemhauser,
  editors.
\newblock {\em Network Routing}, volume~8 of {\em Handbooks in Operations
  Research and Management Science}.
\newblock Elsevier Science B.V., Amsterdam, 1995.

\bibitem{Benchimol+etal:RAIRO}
Mike Benchimol, Pascal Benchimol, Beno\^{i}t Chappert, Arnaud de~la Taille,
  Fabien Laroche, Fr\'{e}d\'{e}ric Meunier, and Ludovic Robinet.
\newblock Balancing the stations of a self service "bike hire" system.
\newblock {\em RAIRO - Operations Research}, 45:37--61, 0 2011.

\bibitem{do-cmc2013}
Daniel Chemla, Fr\'{e}d\'{e}ric Meunier, and Roberto~Wolfler Calvo.
\newblock Bike sharing systems: {S}olving the static rebalancing problem.
\newblock pages 120--146, 2013.

\bibitem{cirrelt-CMR-2012}
Claudio Contardo, Catherine Morency, and Louis-Martin Rousseau.
\newblock Balancing a dynamic public bike-sharing system.
\newblock Technical Report~9, CIRRELT, 2012.
\newblock \url{https://www.cirrelt.ca/DocumentsTravail/CIRRELT-2012-09.pdf}.

\bibitem{EDGC:2012:PCS}
Madeleine EL-Zaher, Baudouin Dafflon, Franck Gechter, and Jean-Michel Contet.
\newblock Vehicle platoon control with multi-configuration ability.
\newblock {\em Proc.~Computer Science}, 9(0):1503--1512, 2012.

\bibitem{CIE:GKA-2013}
Fatma~Pinar Goksal, Ismail Karaoglan, and Fulya Altiparmak.
\newblock A hybrid discrete particle swarm optimization for vehicle routing
  problem with simultaneous pickup and delivery.
\newblock {\em Computers and Industrial Engineering}, 65(1):39--53, May 2013.

\bibitem{HKQWW:2015:ODY}
Pascal Halffmann, Sven~O. Krumke, Alain Quilliot, Annegret~K. Wagler, and
  Jan-Thierry Wegener.
\newblock On the online max-accept relocation problem.
\newblock {\em Procedings of 6th International Workshop on Freight
  Transportation and Logistics (ODYSSEUS 2015)}, 2015.
\newblock (to appear).

\bibitem{HKQWW:LAGOS:2015}
Pascal Halffmann, Sven~O. Krumke, Alain Quilliot, Annegret~K. Wagler, and
  Jan-Thierry Wegener.
\newblock On the online min-wait relocation problem.
\newblock {\em Procedings of LAGOS2015}, 2015.
\newblock (to appear).

\bibitem{LAGOS2013}
Sven~O. Krumke, Alain Quilliot, Annegret~K. Wagler, and Jan-Thierry Wegener.
\newblock Models and algorithms for carsharing systems and related problems.
\newblock {\em Electronic Notes in Discrete Mathematics}, 44(0):201 -- 206,
  2013.

\bibitem{KQWW:2014:LNCS}
Sven~O. Krumke, Alain Quilliot, Annegret~K. Wagler, and Jan-Thierry Wegener.
\newblock Relocation in carsharing systems using flows in time-expanded
  networks.
\newblock In Joachim Gudmundsson and Jyrki Katajainen, editors, {\em
  Experimental Algorithms}, volume 8504 of {\em LNCS}, pages 87--98. Springer,
  2014.

\bibitem{Nemhauser+etal:handbook:89}
George~L. Nemhauser, Alexander H.~G. {Rinnooy Kan}, and Michael~J. Todd,
  editors.
\newblock {\em Optimization}, volume~1 of {\em Handbooks in Operations Research
  and Management Science}.
\newblock Elsevier Science B.V., Amsterdam, 1989.

\bibitem{EvoCOP:HPHR-2013}
Marian Rainer-Harbach, Petrina Papazek, Bin Hu, and G{\"u}nther~R. Raidl.
\newblock Balancing bicycle sharing systems: A variable neighborhood search
  approach.
\newblock In {\em EvoCOP}, pages 121--132, 2013.

\bibitem{SHH-2013}
Jasper Schuijbroek, Robert Hampshire, and Willem-Jan van Hoeve.
\newblock Inventory rebalancing and vehicle routing in bike sharing systems.
\newblock 2013.
\newblock working paper.

\end{thebibliography}

\end{document}
