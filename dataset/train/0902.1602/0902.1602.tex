\documentclass[proceedings]{stacs}
\stacsheading{2009}{99--110}{Freiburg}
\firstpageno{99}

\usepackage{bbm}
\usepackage{yhmath}
\usepackage{amssymb}

\usepackage[dvips]{epsfig}
\usepackage{graphics,psfrag}

\theoremstyle{plain}\newtheorem{satz}[thm]{Satz}
\theoremstyle{definition}\newtheorem{crucial}[thm]{Crucial Definition}
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}

\newcommand{\G}{\mathbb{G}}
\newcommand{\Z}{\mathbbm{Z}}
\newcommand{\N}{\mathbbm{N}}
\newcommand{\U}{\mathbbm{U}}
\renewcommand{\S}{\mathbbm{S}}
\newcommand{\supp}{\mathrm{supp}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\E}{\mathcal{E}}

\newcommand{\T}{\mathbf{T}}
\newcommand{\Tfinal}{\mathbf{\Sigma}}
\newcommand{\Sub}{\mathbf{S}}
\newcommand{\W}{\mathbf{W}}

\newcommand{\s}{\sigma}

\newcommand{\TM}{\mathcal{M}}
\newcommand{\SFT}{\mathcal{SFT}}
\newcommand{\sofic}{\mathcal{S}ofic}
\newcommand{\shift}{\mathcal{S}}
\newcommand{\reshift}{\mathcal{RE}}
\newcommand{\fshift}{\mathcal{FS}}
\newcommand{\Uclass}{\mathcal{U}}

\newcommand{\Lang}{\mathcal{L}}

\renewcommand{\stop}{\textrm{stop}}
\begin{document}

\title[An order on sets of tilings corresponding to an order on languages]{An order on sets of tilings corresponding to \\ an order on languages}

\author[lab1]{N. Aubrun}{Nathalie Aubrun}
\address[lab1]{Institut Gaspard Monge, Universit\'e Paris-Est Marne-la-Vall\'ee,
	\newline 77454 Marne-la-Vall√©e Cedex 2, France.}  \email{nathalie.aubrun@univ-mlv.fr}  

\author[lab2]{M. Sablik}{Mathieu Sablik}
\address[lab2]{ Laboratoire d'Analyse, Topologie, Probabilit\'e, Universit\'e de Provence,
	\newline 39, rue F. Joliot Curie, 13453 Marseille Cedex 13, France.}	\email{sablik@cmi.univ-mrs.fr}  




\keywords{tiling, subshift, Turing machine with oracle, subdynamics}
\subjclass{G.2.m}




\begin{abstract}
Traditionally a tiling is defined with a finite number of finite forbidden patterns. We can generalize this notion considering any set of patterns. Generalized tilings defined in this way can be studied with a dynamical point of view, leading to the notion of subshift. In this article we establish a correspondence between an order on subshifts based on dynamical transformations on them and an order on languages of forbidden patterns based on computability properties.

\end{abstract}

\maketitle



\vspace{-0,4cm}

\section*{Introduction}\label{S:one}

Given a finite set of tiles  and a finite set of forbidden patterns , a -dimensional tiling is an element of  where the local conditions imposed by  are satisfied at every point of . This basic model captures geometrical aspect of computation~\cite{berger1966udp,robinson1971uan,Myers1974}. To establish structural properties of tilings, it is interesting to study the set of tilings which satisfy the conditions imposed by ~\cite{ballierstacs2008}. 

It is easy to generalize the usual notion of tiling considering an infinite set of forbidden patterns. A set of generalized tilings can be studied with a dynamical point of view with the notion of subshift~\cite{lind1995isd,kitchens1998sd}. In this theory, a set of usual tilings corresponds to a subshift of finite type. 

In dimension , the class of subshifts of finite type is well understood. In particular, the language of a subshift of finite type is given by a local automaton~\cite{beal1993cs}. Given this result, it is natural to characterize subshifts whith a language given by a finite automaton. It is the class of sofic subshifts, which can all be obtained as a factor of a subshift of finite type~\cite{lind1995isd}. Thus, each sofic subshift is obtained by a dynamical transformation of a subshift of finite type. 

Multidimensional subshifts of finite type are not well understood. For example, it is not easy to describe their languages. Moreover, in addition to factors, there exist other types of dynamical transformations on multidimensional subshift: the sub-action of a -dimensional tiling consists in taking the restriction of a tiling to a subgroup of . Hochman showed that every -dimensional subshift whose set of forbidden patterns is recursively enumerable can be obtained by sub-action and factor of a -subshift of finite type~\cite{hochman2007drp}. 

This result suggests that a subshift can simulate another one, where the notion of simulation is given by operations on subshifts inspired by the dynamical theory. This involves different orders depending on the operations which are considered. In this paper, we present five types of operations: product, factor, finite type, sub-action and superposition. It is possible to formulate classic results with this formalism. Our main result (Theorem~\ref{EquivalenceOrdre}) establishes a correspondence between an order on subshifts based on dynamical transformations on them and an order on languages of forbidden patterns based on computability properties. 

The paper is organized as follows: Section~\ref{definition} is devoted to introduce the concepts of tiling and subshift. In Section~\ref{operation}, we present several operations on subshifts which allow to define the notion of simulation of a subshift by another one. Then, in Section~\ref{TuringMachine}, we define an important tool to define runs of a Turing machine with a sofic subshift. This tool is used to prove our main result in the last Section.

\section{Definitions}~\label{definition}
\vspace{-0,6cm}
	\subsection{Generalized tilings}

Let  be a finite alphabet and  be a positive integer. A \emph{configuration}  is an element of . Let  be a finite subset of . Denote  the \emph{restriction} of  to . A \emph{pattern} is an element   and  is the \emph{support} of , which is denoted by . For all , we call  the \emph{elementary support} of size . A pattern with support  is an \emph{elementary pattern}. We denote by  the set of -dimensional elementary patterns. A \emph{-dimensional language}  is a subset of . A pattern  of support  \emph{appears} in a configuration  if there exists  such that for all , , we note .

\begin{definition}
A \emph{tile set} is a tuple  were  is a subset of  called the \emph{set of forbidden patterns}.

A \emph{generalized tiling} by  is a configuration  such that for all ,  does not appear in . We denote by  the set of generalized tilings by . If there is no ambiguity on the alphabet, we just denote it by .
\end{definition}

\begin{remark}
If  is finite, it is equivalent to define a generalized tiling by allowed patterns or forbidden patterns, the latter being the usual definition of tiling.
\end{remark}

             \subsection{Dynamical point of view : subshifts}

One can define a topology on  by endowing  with the discrete topology, and considering the product topology on . For this topology,   is a compact metric space on which  acts by translation via  defined by: 

for all  in . This action is called the shift.

\begin{definition}\label{language}
A -dimensional subshift on the alphabet  is a closed and -invariant subset of . We denote by  (resp. , ) the set of all subshifts (resp. -dimensional subshifts, -dimensional subshifts with ). 

Let  be a subshift. Denote  the set of elementary patterns of size  which appear in some element of , and  the \emph{language} of  which is the set of elementary patterns which appear in some element of  .
\end{definition}

It is also usual to study a subshift as a dynamical system~\cite{lind1995isd,kitchens1998sd}, the next proposition shows the link between both notions.

\begin{proposition}~\label{tiling-subshift}
The set  is a subshift if and only if  where  is the complement of  in .
\end{proposition}
\begin{definition}
Let  be a finite alphabet and  be a subshift.

The subshift  is the \emph{full-shift} associated to . Denote  the set of all full-shifts.

If there exists a finite set  such that  then  is a \emph{subshift of finite type}. Denote  the set of all subshifts of finite type. Subshifts of finite type correspond to the usual notion of tiling.

If there exists a recursively enumerable set  such that  then  is a \emph{recursive enumerable subshift}. Denote  the set of all recursive enumerable subshifts.
\end{definition}
\vspace{-0,5cm}
\section{Operations on tilings}\label{operation}

	\subsection{Simulation of a tiling by another one}

An \emph{operation}  on subshifts transforms a subshift or a pair of subshifts into another one; it is a function  or . We remark that a subshift  (resp. a pair of subshifts ) and the image by an operation  (resp. ) do not necessary have the same alphabet or dimension. An operation can depend on a parameter.

Let  be a set of operations on subshifts. Let  be a set of subshifts. We define the \emph{closure} of  under a set of operations , denoted by , as the smallest set stable by  which contains . 

We say that a subshift  \emph{simulates} a subshift  by  if . Thus there exists a finite sequence of operations chosen among , that transforms  into . We note it by . We remark that 

	\subsection{Local transformations}

We describe three operations that modify locally the subshift.

\noindent \textbf{Product :}

Let  and  be two subshifts of the same dimension, define: 
One has 

\noindent \textbf{Finite type FT:}

These operations consist in adding a finite number of forbidden patterns to the initial subshift. Formally, let  be an alphabet,  be a finite subset and let  be a subshift. By Proposition~\ref{tiling-subshift}, there exists  such that . Define:


If  and  have not the same alphabet or the same dimension, put . We remark that  could be empty if  prohibits too many patterns. By , one lists all operations on subshifts which are obtained by .

By definition of subshift of finite type, one has .

\noindent \textbf{Factor F:}

These operations allow to change the alphabet of a subshift by local modifications. Let  and  be two finite alphabets. A \emph{morphism}  is a continuous function which commutes with the shift action (i.e.  for all ). In fact, such a function can be defined locally~\cite{hedlund1969eaa}: that is to say, there exists  finite, called \emph{neighborhood}, and , called \emph{local function}, such that  for all . Let  be a subshift, define:


If the domain of  and  do not have the same alphabet or the same dimension, put . By , one lists all operations on subshifts which are obtained by .

One verifies that .

\begin{definition}
A sofic subshift is a factor of a subshift of finite type. Thus, the set of sofic subshifts is .
\end{definition}


	\subsection{Transformation on the group of the action}

We describe two operations that modify the group on which the subshift is defined, thus we change the dimension of the subshift.

\noindent  \textbf{Sub-action SA:}

These operations allow to take the restriction of a subshift of  according to a subgroup of . Let  be a sub-group of  generated by  (. Let  be a subshift, define:


It is easy to prove that  is a subshift of . If  and  is not a subgroup of , put . By , one lists all operations on subshifts which are obtained by .

One verifies that  and .

\begin{theorem}\label{stabRE}
.
\end{theorem}

\noindent  \textbf{Superposition SP:}

These operations increase the dimension of a subshift by a superposition of the initial subshift. Let . Let  and  be two subgroups of  such that  is isomorphic to  and . Let  be a subshift, define:


If  and  is not isomorphic to  or , put . By , one lists all operations on subshifts which are obtained by .

It is easy to verify that .

With this formalism, the result of M. Hochman~\cite{hochman2007drp} can be written:

More precisely, he proves that 



\section{Simulation of Turing machines by subshifts}\label{TuringMachine}

A Turing machine is a model of calculation defined by local rules. It seems natural to represent the runs of a machine by a 2-dimensional subshift: one dimension representing the tape and the other time evolution. But the main problem is that in general the Turing machine uses a finite part of the space-time diagram which is represented by the subshift. Robinson~\cite{robinson1971uan} proposes a self-similar structure to construct an aperiodic subshift of finite type of dimension . In fact, it is also possible to use a general construction with substitutions due to Mozes~\cite{mozes1989tss}. This construction allows to give to the machine finite spaces on which it calculates independently. The problem is that we cannot control the entry of the Turing machine in view to recognize a configuration of a subshift. To obtain this property, Hochman~\cite{hochman2007drp} uses similar tools to construct a sofic subshift of dimension  in order to to prove that . In this Section, we present a similar construction which is used to prove our main result in Section~\ref{MainResult}.


	\subsection{Substitution tilings}

Let  be a finite alphabet. A \emph{substitution} is a function  where  . We naturally extend  to a function  by identifying  with .
Starting from a letter placed in  and applying successively  we obtain a sequence of patterns in  for . Such patterns are called \emph{-patterns}.

\begin{definition}
The subshift  defined by the substitution  is

\end{definition}


	\subsection{A framework for Turing machines}

We now describe a family of substitutions  defined on the alphabet , which are used by M. Hochman~\cite{hochman2007drp} to prove . For every integer  the substitution  is given by :
\begin{tiny}

\end{tiny}
where the patterns are of size . Let  be the tiling defined by substitution .

These substitutions have good properties, in particular they are unique derivation substitutions and for this reason they verify~\cite{mozes1989tss}; one obtains:
\begin{proposition}
For every integer , there exists a SFT   and a letter-to-letter morphism  such that 
\end{proposition}

\begin{definition}
If  is a subshift, we define  by :


Notice that if  is an SFT, then  is also an SFT (just shift the forbidden patterns of  to get those of ).
\end{definition}

We now work on the space  and we construct the SFT ,  and  defined by :



Let  be a configuration of the subshift . If we focus on the subshift , we can see rectangles whose corners are defined by the letter  of . These rectangles of size  are spaces of calculation on which the Turing machine runs independently. Moreover the information brought by  gives the size of the entry pattern  on each rectangle : scanning the base of a rectangle from left to right, the entry word is located between the left corner and the first symbol  due to  that occurs. This results are resumed in Proposition~\ref{frameworkTM}.

\begin{proposition}\label{frameworkTM}
The product  is a partition of the space into rectangles, in which each plane  is paved by rectangles of same width and height. Moreover if there is a -rectangle in  with entry of size , then there exists  and  such that there exists a -rectangle in  and a -rectangle in  both with entry of size . 
\end{proposition}

This result will be used in Section~\ref{recinclusion} to prove that, thanks to these arbitrary large rectangles, one can simulate a calculation with an arbitrary number of steps.

	\subsection{A -dimensional sofic subshift}

We now explain how we can use the previously constructed framework to simulate a Turing machine by a subshift. First we recall the formal definition of a Turing machine.

\begin{definition}
Let  be a Turing machine, where :
\begin{itemize}
\item  is a finite set of states;  is the initial state;
\item  are  are two finite alphabets such that ;
\item  is the blank symbol;
\item  is the transition function;
\item  is the set of final states.
\end{itemize}
\end{definition}

We can describe its behaviour with a set of 2-dimensional patterns. First dimension stands for the tape and second dimension for time evolution. For example the rule  will be coded by :





Denote by  the set of forbidden patterns constructed according to the rules of . One can consider the subshift of finite type  where each local pattern corresponds to calculations of the machine . Then thanks to a product operation we superimpose these calculations on the framework, with the following finite conditions :
\begin{itemize}
\item condition \textbf{Init} : to copy out the entry word ;
\item condition \textbf{Head} : the initial state  appears on every rectangle bottom left corner and only here;
\item condition \textbf{Stop} : when a side of a rectangle is reached by the head of the machine, the calculation stops and if necessary the tape content is just copied out until the top of the rectangle;
\item condition \textbf{Final} : when a final state is reached, the tape content is just copied out for next steps of calculation until the top of the rectangle.
\end{itemize}

Define  the subshift:


By stability of the class of subshifts of finite type by ,  is a subshift of finite type up to a letter-to-letter morphism; thus . For all , in the plane , it is possible to find rectangles of size  arbitrary large and an entry of size  also arbitrarily large. On each rectangle, thanks to the conditions , we can observe the evolution of the Turing machine .

\begin{remark}
The construction described here only works for usual Turing machines. In Section~\ref{recinclusion} we explain how to add finite conditions on the subshift  if  is a Turing machine with oracle. 
\end{remark}

\section{Study of the semi-order }\label{MainResult}

In this section we focus on the five operations described previously. Our aim is to study the semi-order .

	\subsection{A semi-order on languages}

A Turing machine with \emph{semi-oracle} is a usual machine with a special state  and an oracle tape. The behaviour of a Turing machine with semi-oracle , where  is a language, is the following : the machine reads an entry pattern  and writes a pattern on the oracle tape, until the state  is reached. If the pattern written on the oracle tape is in  then the machine stops, else it keeps on calculating.

We define a semi-order on languages :

where  is the domain of the machine , that is to say the set of entry words on which  stops. We refer to~\cite{rogersjr1987trf} for definitions and properties of similar semi-orders on languages based on computability.

\begin{prop}\label{semi-order}
 is a semi-order.
\end{prop}

Consider the equivalence relation  if and only if  and . This equivalence relation defines classes of languages, and we can compare them within the semi-order. For instance, the class of recursively enumerable languages is the smallest for this semi-order. We have  for every recursively enumerable language .

	\subsection{Closure theorem: }

The semi-order on languages defined by semi-oracle Turing machines corresponds to a semi-order on  subshifts:

\begin{theorem}\label{EquivalenceOrdre}
Let  be a subshift, one has:

Or equivalently, if  and  are two subshifts of dimension  and , one has:

\end{theorem}





\subsubsection{Direct inclusion} Put . To show , it is sufficient to show the stability of  by all the operations. Let  and  be two languages such that  for . Thus, for , there exists a Turing machine  with semi-oracle  whose domain is exactly .

 \textbf{Stability under product:}
Let , so  with . The language  could be the domain of a Turing machine  with semi-oracle . It suffices to simulate the two Turing machines  and  (each machine runs during one step successively) on each coordinate of a pattern of . Thus .

 \textbf{Stability under finite type:}
Let . Since  is finite, one has  and .

 \textbf{Stability under factor map:} Let  where  is a morphism of neighborhood  and local function . One has  where . Moreover, one has . Indeed, if , we simulate the machine  on all pattern  such that , running successively one step for each pattern. 

 \textbf{Stability under sub-action:} Let  where  is a subgroup of  of dimension . We consider the language  which is the domain of the Turing machine : on a pattern  of support , a Turing machine  simulates successively  on every entry word of support  which completes  in  where  is the minimal support which contains  embedded in . Thus , moreover . This is exactly the same principle as in the proof of Theorem~\ref{stabRE}.

 \textbf{Stability under superposition:} Let  where  is isomorph to  and . Let  be the language where each pattern  is the superposition of patterns  and there exists  such that . Thus  and .




\subsubsection{Reciprocal inclusion}\label{recinclusion}

Let be a subshift; define . Let   be a language such that .  We want to prove that .  



Here, we assume that  and  are one-dimensional languages, but the proof can be adapted to the general case. We explain how to construct the subshift  thanks to operations  and  applied on .

Since  there exists a Turing machine  with semi-oracle  such that . We transform this Turing machine so that it only takes in input patterns of support  (because checked patterns are given by ) and at the moment when the state  is reached, the word written on the oracle tape is copied out in the alphabet , which is simply a copy of , then again copied out in the alphabet  once the oracle has given its answer.

We first list auxiliary subshifts that we need to construct  :

\begin{itemize}
\item the original subshift  written in the copy of :  will simulate the oracle;
\item Turing machine  is coded by a subshift of finite type , where  is an alphabet that contains at least ,  and ;
\item the framework for this Turing machine will be given by ,  and  defined in Section~\ref{TuringMachine}; they are defined on the alphabet  and are subshifts of finite type up to a letter-to-letter morphism.
\end{itemize}

\paragraph{\textbf{Construction of }}
The principle is to construct  a -dimensional subshift on the alphabet . Denote  the canonical basis of . We need these four dimensions for different reasons :
\begin{itemize}
\item the subshift  will appear on ;
\item thanks to , we construct a framework for , so that every rectangle of this framework is in a plane  where ;
\item on  we have the oracle simulated by .
\end{itemize}
\paragraph{Step 1 :} First notice that changing  into  only requires a letter-to-letter morphism. Then we construct  to place  in a -dimensional subshift. We finally add through a product operation  all letters from  :  so that .

\paragraph{Step 2 :} We want  to appear on . Simulations of the Turing machine  will take in input a word written on . So we need to copy out  on  so that these simulations apply to what will be the subshift . We get to it with the finite condition :

We also want to keep accessible all along the simulation the entry word of every rectangle of the framework. To do that we add the finite condition :

We thus obtain a subshift .
\paragraph{Step 3 :} Then we add to  a framework for the Turing machine. We construct  an auxiliary subshift of finite type up to a letter-to-letter morphism, containing well-chosen rectangles. Denote  the finite type condition that ensures . As in Section~\ref{TuringMachine}, we define:
\begin{itemize}
\item  ;
\item  ;
\item  .
\end{itemize}

The rectangles are obtained in . Each rectangle of length  given by  knows the length of its input  given by . Thus we can simulate the Turing machine on words of length , on a tape of length  and simulations are bounded by  steps of calculation. Up to a letter-to-letter morphism,  is a subshift of finite type, so there exists a finite set of patterns  and a morphism  such that . We add this framework to  via  so that we have .

\paragraph{Step 4 :} We add the behaviour of  in rectangles of  but for the moment we do not take into consideration calls for oracle. As in Section~\ref{TuringMachine}, we consider the finite conditions  given by the rule of  and the conditions  which control the interaction of the head of  with the rectangles. For the moment every time the machine calls the oracle it keeps on calculating. Thus .

\paragraph{Step 5 :} To simulate the oracle, we add finite type conditions to ensure that during a calculation, when the machine calls for the oracle in , the pattern  on which the oracle is called coincides with the pattern in  between  and . These new allowed patterns look like :

However, these conditions are only valid in the interior of a rectangle. We denote these finite type conditions by . Then we have .

\paragraph{Step 6 :} In order to avoid dependence problems between different calculations, each configuration of  that appears on  is used for the same calculation, thanks to the finite type condition :

Finally we consider the final state  as a forbidden pattern and we denote by  this subshift. We have .

We simulate the running of the Turing machine  on a pattern  of length . As soon as  calls for the oracle, we compare the word on which the oracle is called and the word on . If the two words coincide then  keeps on calculating, else it comes to the final state . If the machine cannot terminate its calculation within the time given by the rectangle, Proposition~\ref{frameworkTM} ensures that we can find a larger rectangle in which the machine will calculate on the same entry word.

\vspace{0,4cm}
The following picture resumes the behaviour of the machine  on the framework :

\begin{center}
\psfrag{e1}{}
\psfrag{e2}{}
\psfrag{e3}{}
\psfrag{e4}{}
\psfrag{m}{}
\psfrag{q?}{}
\psfrag{qstop}{}
\includegraphics[width=7cm]{construction}
\end{center}

\paragraph{\textbf{Proof that this construction works}}
We now prove that , the projection of  on  is , up to a morphism that just consists in keeping information about .


\paragraph{Proof of :}

Let , we prove that . It is sufficient to prove that every pattern in  is not in . Let  be a pattern in ; it is a sub-pattern of a certain  where  is chosen such that it is of length . By construction of  there exists  arbitrary large such that there exists a rectangle of size  with the entry word . Since , in every rectangle the calculation of the machine  on the word  does not reach the final state . Since these rectangles are arbitrarily large, we can conclude that the machine  never reaches . It means that , thus .

\paragraph{Proof of :}

Let , we construct  such that   and . To insure that  we just need to check that for all , we can impose that  while the calculations of  in the rectangles containing any  do not reach the state .

Let us now focus on a specific rectangle of the framework, on which the machine  calculates on a pattern  of size  that appears in . Since  appears in ,  so the machine  loops on the entry . It means that every time the calculation of  on  calls for the oracle on a pattern ,  is not in . Since , for all pattern  on which the oracle is called, there exists a configuration  such that . Thus we complete  on the following way :
\begin{itemize}
\item[-] if in  the calculation of  calls for the oracle on a pattern , then  previously constructed;
\item[-] if the oracle is not called, we complete  with any .
\end{itemize}
This makes sure that  is in the subshift , so .

\vspace{0.2cm}

The proof of Theorem is completed.\hfill{\tiny }



\paragraph{\textbf{An application of Theorem~\ref{EquivalenceOrdre}:}}
 There does not exist an ``universal'' subshift  which could simulate every element of . Indeed, consider , one has . But there exists  strictly superior to  (see~\cite{rogersjr1987trf}). Moreover, one can choose  such that for all patterns , then for all  such that , one has . Thus . One deduces that .

\section*{Conclusion}

In this article we generalize the notion of tilings considering any set of forbidden patterns. We present operations on sets of tilings, called subshifts, inspired by the dynamical theory. We obtain different notions of simulation, depending on the set of operations which are considered. These notions involve different semi-orders on subshifts and in this article we focus on the semi-order which consider all the transformations presented. This semi-order is quite well understood since we establish a correspondence with a semi-order on languages of forbidden patterns based on computability properties. The following points are still open questions :
\begin{itemize}
 \item In our construction, considering two subshifts  and  respectively of dimension  and  such that , we need  of dimension  to simulate . It is possible to decrease the dimension of ?

 \item For which class  there exists a subshift  such that ?
\end{itemize}

We can also consider other semi-orders involved by other sets of operations and look for general tools to study them. In fact, some of these semi-orders have already been studied. For example, the set of space-time diagrams of a cellular automaton can be viewed as a subshift, and the orders presented in~\cite{mazoyer1999ioc,ollinger2003stacs,theyssier2005acm} could be formalized with the tools introduced in Section~\ref{operation}. 


\bibliographystyle{alpha}
\bibliography{biblio}




\end{document}