
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\returnsa}{\mathcal{R}_{sa}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}
\newcommand{\dpii}{d_{\pi_i}}
\newcommand{\dpi}{d_{\pi}}
\newcommand{\weighti}{w_i}
\newcommand{\pii}{\pi_i}
\newcommand{\expec}{\mathbb{E}}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{wrapfig}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{caption}
\usepackage{makecell}
\usepackage{comment}
\usepackage[bottom]{footmisc}
\usepackage{placeins}

\newcommand{\AK}[1]{\textcolor{red}{AK}: \textcolor{red}{#1}}

\title{Advantage-Weighted Regression: Simple and Scalable Off-Policy Reinforcement Learning}

\author{Xue Bin Peng, Aviral Kumar, Grace Zhang \& Sergey Levine \\
University of California, Berkeley\\
\texttt{\{xbpeng,aviralk,grace.zhang,svlevine\}@berkeley.edu}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
In this paper, we aim to develop a simple and scalable reinforcement learning algorithm that uses standard supervised learning methods as subroutines. Our goal is an algorithm that utilizes only simple and convergent maximum likelihood loss functions, while also being able to leverage off-policy data. Our proposed approach, which we refer to as \textit{advantage-weighted regression} (AWR), consists of two standard supervised learning steps: one to regress onto target values for a value function, and another to regress onto weighted target actions for the policy. The method is simple and general, can accommodate continuous and discrete actions, and can be implemented in just a few lines of code on top of standard supervised learning methods. We provide a theoretical motivation for AWR and analyze its properties when incorporating off-policy data from experience replay. We evaluate AWR on a suite of standard OpenAI Gym benchmark tasks, and show that it achieves competitive performance compared to a number of well-established state-of-the-art RL algorithms. AWR is also able to acquire more effective policies than most off-policy algorithms when learning from purely static datasets with no additional environmental interactions. Furthermore, we demonstrate our algorithm on challenging continuous control tasks with highly complex simulated characters. (\href{https://xbpeng.github.io/projects/AWR/}{Video\footnote{\label{ft:website}Supplementary video: \href{https://xbpeng.github.io/projects/AWR/}{xbpeng.github.io/projects/AWR/}}})
\end{abstract}

\section{Introduction}
Model-free reinforcement learning can be a general and effective methodology for training agents to acquire sophisticated behaviors with minimal assumptions on the underlying task \citep{mnih2015humanlevel,HeessTSLMWTEWER17,Pathak2017}.
However, reinforcement learning algorithms can be substantially more complex to implement and tune than standard supervised learning methods. Arguably the simplest reinforcement learning methods are policy gradient algorithms~\citep{PoliGrad1999}, which directly differentiate the expected return and perform gradient ascent. Unfortunately, these methods can be notoriously unstable and are typically on-policy (or nearly on-policy), often requiring a substantial number of samples to learn effective behaviors.
Our goal is to develop a reinforcement learning algorithm that is simple, easy to implement, and can readily incorporate off-policy experience data.

\begin{figure}[b]
    \vspace{-0.5cm}
	\centering
    \includegraphics[width=1\columnwidth]{figures/teaser.png}
    \vspace{-0.5cm}
\caption{Complex simulated character trained using advantage-weighted regression. \textbf{Left:} Humanoid performing a spinkick. \textbf{Right:} Dog performing a canter.}
\label{fig:teaser}
\end{figure}

In this work, we propose advantage-weighted regression (AWR), a simple off-policy algorithm for model-free RL. Each iteration of the AWR algorithm simply consists of two supervised regression steps: one for training a value function baseline via regression onto cumulative rewards, and another for training the policy via weighted regression. The complete algorithm is shown in Algorithm~\ref{alg:AWR}. AWR can accommodate continuous and discrete actions, and can be implemented in just a few lines of code on top of standard supervised learning methods. Despite its simplicity, we find that AWR achieves competitive results when compared to commonly used on-policy and off-policy RL algorithms, and can effectively incorporate fully off-policy data, which has been a challenge for other RL algorithms. Our derivation of AWR presents an interpretation of our method as a constrained policy optimization procedure, and provides a theoretical analysis of the use of off-policy data with experience replay.

We first revisit the original formulation of reward-weighted regression, an on-policy RL method that utilizes supervised learning to perform policy updates, and then propose a number of new design decisions that significantly improve performance on a suite of standard continuous control benchmark tasks. We then provide a theoretical analysis of AWR, including the capability to incorporate off-policy data with experience replay. Although the design of AWR involves only a few simple design decisions, we show experimentally that these additions provide for a large improvement over previous methods for regression-based policy search, such as reward-weighted regression (RWR)~\citep{Peters2007RWR}, while also being substantially simpler than more modern methods, such as MPO~\citep{abdolmaleki2018maximum}. We show that AWR achieves competitive performance when compared to several well-established state-of-the-art on-policy and off-policy algorithms. We further demonstrate our algorithm on challenging control tasks with complex simulated characters.

\section{Preliminaries}

In reinforcement learning, the objective is to learn a control policy that enables an agent to maximize its expected return for a given task. At each time step $t$, the agent observes the state of the environment $\rvs_t \in \mathcal{S}$, and samples an action $\rva_t \in \mathcal{A}$ from a policy $\rva_t \sim \pi(\rva_t|\rvs_t)$. The agent then applies that action, which results in a new state $\rvs_{t+1}$ and a scalar reward $r_t = r(\rvs_t, \rva_t)$. The goal is to learn an optimal policy that maximizes the agent's expected discounted return $J(\pi)$,
\begin{equation}
     J(\pi) = \expec_{\tau \sim p_\pi(\tau)}\left[\sum_{t=0}^\infty \gamma^t r_t \right] = \expec_{\rvs \sim d_\pi(\rvs)} \expec_{a \sim \pi(\rva|\rvs)} \left[ r(\rvs, \rva)\right],
     \label{eqn:RLObjective}
 \end{equation}
where $p_\pi(\tau)$ represents the likelihood of a trajectory $\tau = \{\left(\rvs_0, \rva_0, r_0 \right), \left(\rvs_1, \rva_1, r_1 \right), ... \}$ under a policy $\pi$, and $\gamma \in [0, 1)$ is the discount factor. $d_\pi(\rvs) = \sum_{t=0}^\infty \gamma^t p(\rvs_t = \rvs | \pi)$ represents the unnormalized discounted state distribution induced by the policy $\pi$ \citep{Sutton1998}, and $p(\rvs_t = \rvs | \pi)$ is the likelihood of the agent being in state $\rvs$ after following $\pi$ for $t$ timesteps.

Our proposed AWR algorithm builds on ideas from reward-weighted regression (RWR)~\citep{Peters2010REP}, a policy search algorithm based on an expectation-maximization framework, which solves the following supervised regression problem at each iteration:
\begin{equation}
\begin{aligned}
    \pi_{k+1} = \mathop{\mathrm{arg \ max}}_{\pi} \quad & \E_{\rvs \sim d_{\pi_k}(\rvs)} \E_{\rva \sim \pi_{k}(\rva|\rvs)} \left[ \mathrm{log} \ \pi(\rva | \rvs) \ \mathrm{exp}\left( \frac{1}{\beta} \mathcal{R}_{\rvs,\rva} \right)\right] .\\
\end{aligned}
\label{eqn:RWR}
\end{equation}
$\pi_k$ represents the policy at the $k$th iteration of the algorithm, and $\mathcal{R}_{\rvs,\rva} = \sum_{t=0}^\infty \gamma^t r_t$ is the return. The RWR update can be interpreted as solving a maximum likelihood problem that fits a new policy $\pi_{k+1}$ to samples collected under the current policy $\pi_k$, where the likelihood of each action is weighted by the exponentiated return received for that action, with a temperature parameter $\beta >0$.
As an alternative to the EM framework, a similar algorithm can also be derived using the dual formulation of a constrained policy search problem \citep{Peters2010REP}.

\section{Advantage-Weighted Regression}
In this work, we propose advantage-weighted regression (AWR), a simple off-policy RL algorithm based on reward-weighted regression. We first provide an overview of the complete advantage-weighted regression algorithm, and then describe its theoretical motivation and analyze its properties. The complete AWR algorithm is summarized in Algorithm~\ref{alg:AWR}. Each iteration $k$ of AWR consists of the following simple steps. First, the current policy $\pi_{k}(\rva|\rvs)$ is used to sample a batch of trajectories $\{\tau_i\}$ that are then stored in the replay buffer $\mathcal{D}$, which is structured as a first-in first-out (FIFO) queue, as is common for off-policy reinforcement learning algorithms~\citep{mnih2015humanlevel,DDPG2016}. Then, the entire buffer $\mathcal{D}$ is used to fit a value function $V_k^{\mathcal{D}}(\rvs)$ to the trajectories in the replay buffer, which can be done with simple Monte Carlo return estimates $\mathcal{R}_{\rvs,\rva}^\mathcal{D} = \sum_{t=0}^T \gamma^t r_t$. Finally, the same buffer is used to fit a new policy using \emph{advantage-weighted} regression, where each state-action pair in the buffer is weighted according to the exponentiated advantage $\exp(\frac{1}{\beta} A^\mathcal{D}(\rvs,\rva))$, with the advantage given by $A^\mathcal{D}(\rvs, \rva) = \mathcal{R}_{\rvs,\rva}^\mathcal{D} - V^{\mathcal{D}}(\rvs)$ and $\beta$ is a hyperparameter. AWR uses only supervised regression as learning subroutines, making the algorithm very simple to implement. In the following subsections, we first motivate the algorithm as an approximation to a constrained policy search problem, and then extend our analysis to incorporate experience replay.

\begin{algorithm}[t]
            \caption{Advantage-Weighted Regression}
            \begin{algorithmic}[1]
            
            \STATE{$\pi_1 \leftarrow \text{random policy}$}
            \STATE{$\mathcal{D} \leftarrow \emptyset$}
            
            \FOR{$\text{iteration} \ k = 1, ... , k_\mathrm{max}$}
                \STATE{$\text{add trajectories} \ \{\tau_i\} \ \text{sampled via} \ \pi_k \ \text{to} \ \mathcal{D}$}
\STATE{$V_k^\mathcal{D} \leftarrow \mathop{\mathrm{arg \ min}}_{V} \ \mathbb{E}_{\rvs, \rva \sim \mathcal{D}} \left[\left|\left| \mathcal{R}_{\rvs,\rva}^\mathcal{D} - V(\rvs) \right|\right|^2\right]$}
                \STATE{$\pi_{k+1} \leftarrow \mathop{\mathrm{arg \ max}}_{\pi} \mathbb{E}_{\rvs, \rva \sim \mathcal{D}} \left[ \mathrm{log} \ \pi(\rva | \rvs) \ \mathrm{exp}\left( \frac{1}{\beta} \left(\mathcal{R}_{\rvs,\rva}^\mathcal{D} - V_k^\mathcal{D}(\rvs) \right) \right) \right]$}
            \ENDFOR
            
            \end{algorithmic}
            \label{alg:AWR}
\end{algorithm}

\subsection{Derivation}
In this section, we derive the AWR algorithm as an approximate optimization of a constrained policy search problem. Our goal is to find a policy that maximizes the expected \emph{improvement} ${\eta(\pi) = J(\pi) - J(\mu)}$ over a sampling policy $\mu(\rva | \rvs)$. We first derive AWR for the setting where the sampling policy is a single Markovian policy. Then, in the next section, we extend our result to the setting where the data is collected from multiple policies, as in the case of experience replay that we use in practice. The expected improvement $\eta(\pi)$ can be expressed in terms of the advantage $A^\mu(\rvs, \rva) = \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)$ with respect to the sampling policy $\mu$ \citep{Kakade2002,TRPOschulman15}:
\begin{equation}
    \eta(\pi) = \expec_{\rvs \sim d_\pi(\rvs)} \expec_{\rva \sim \pi(\rva|\rvs)} \left[A^\mu(\rvs, \rva) \right] = \expec_{\rvs \sim d_\pi(\rvs)} \expec_{\rva \sim \pi(\rva | \rvs)} \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right], \label{eqn:Improvement}
\end{equation}
where $\mathcal{R}_{\rvs,\rva}^\mu$ denotes the return obtained by performing action $\rva$ in state $\rvs$ and following $\mu$ for the following timesteps, and $V^\mu(\rvs) = \int_a \mu(\rva | \rvs) \mathcal{R}_\rvs^\rva \ d\rva$ corresponds to the value function of $\mu$. 
This objective differs from the ones used in the derivations of related algorithms, such as RWR and REPS~\citep{Peters2007RWR,Peters2010REP,abdolmaleki2018maximum}, which maximize the expected return $J(\pi)$ instead of the expected improvement. The expected improvement directly gives rise to an objective that involves the advantage. We will see later that this yields weights for the policy update that differ in a subtle but important way from standard reward-weighted regression. As we show in our experiments, this difference results in a large empirical improvement.

The objective in Equation~\ref{eqn:Improvement} can be difficult to optimize due to the dependency between $d_\pi(\rvs)$ and $\pi$, as well as the need to collect samples from $\pi$.
Following \citet{TRPOschulman15}, we can instead optimize an approximation $\hat{\eta}(\pi)$ of $\eta(\pi)$ using the state distribution of $\mu$:
\begin{equation}
    \hat{\eta}(\pi) = \expec_{\rvs \sim d_\mu(\rvs)} \expec_{\rva \sim \pi(\rva | \rvs)} \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right]. \label{eqn:ApproxImprovement}
\end{equation}
Here, $\hat{\eta}(\pi)$ matches $\eta(\pi)$ to first order \citep{Kakade2002}, and provides a good estimate of $\eta$ if $\pi$ and $\mu$ are close in terms of the KL-divergence~\citep{TRPOschulman15}. Using this objective, we can formulate the following \emph{constrained} policy search problem:
\begin{align}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad & \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs \\
    \textrm{s.t.} \quad & \int_\rvs d_\mu(\rvs) \mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) d\rvs \leq \epsilon . \label{eqn:AWRCons0}
\end{align}
The constraint in Equation~\ref{eqn:AWRCons0} ensures that the new policy $\pi$ is close to the data distribution of $\mu$, and therefore the surrogate objective  $\hat{\eta}(\pi)$ remains a reasonable approximation to $\eta(\pi)$. We refer the reader to \citet{TRPOschulman15} for a detailed derivation and an error bound.

We can derive AWR as an approximate solution to this constrained optimization. This derivation follows a similar procedure as \citet{Peters2010REP},
and begins by forming the Langrangian of the constrained optimization problem presented above,
\begin{equation}
 \begin{aligned}
     \mathcal{L}(\pi, \beta) = & \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs + \beta \left(\epsilon - \int_\rvs d_\mu(\rvs) \mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) d\rvs \right) ,
\label{eqn:AWRLagrangian}
 \end{aligned}
 \end{equation}
where $\beta$ is a Lagrange multiplier. Differentiating $\mathcal{L}(\pi, \beta)$
with respect to $\pi(\rva|\rvs)$ and solving for the optimal policy $\pi^*$ results in the following expression for the optimal policy
\begin{equation}
 \begin{aligned}
     \pi^*(\rva|\rvs) = \frac{1}{Z(\rvs)} \ \mu(\rva|\rvs) \ \mathrm{exp}\left(\frac{1}{\beta}\left( \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right) ,
 \end{aligned}
\end{equation}
with $Z(\rvs)$ being the partition function. A detailed derivation is available in Appendix~\ref{app:Derivation}. If $\pi$ is represented by a function approximator (e.g., a neural network), a new policy can be obtained by projecting $\pi^*$ onto the manifold of parameterized policies,
\begin{align}
    & \mathop{\mathrm{arg \ min}}_{\pi} \quad \mathbb{E}_{\rvs \sim \mathcal{D}} \left[ \mathrm{D_{KL}} \left(\pi^*(\cdot  | \rvs) \middle|\middle| \pi(\cdot  | \rvs)\right) \right]\\
    = & \mathop{\mathrm{arg \ max}}_{\pi} \quad \expec_{\rvs \sim d_\mu(\rvs)} \expec_{\rva \sim \mu(\rva|\rvs)} \left[ \mathrm{log} \ \pi(\rva | \rvs) \ \mathrm{exp}\left( \frac{1}{\beta} \left( \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right) \right].
\label{eqn:AWRUpdate}
\end{align}
While this derivation for AWR largely follows the derivations used in prior work~\citep{Peters2010REP,abdolmaleki2018maximum}, our expected improvement objective introduces a baseline $V^\mu(\rvs)$ to the policy update, which as we show in our experiments, is a crucial component for an effective algorithm. We next extend AWR to incorporate experience replay for off-policy training, where the sampling policy is no longer a single policy, but rather a mixture of policies from past iterations.

\subsection{Experience Replay and Off-Policy Learning}
\label{sec:ReplayDerivation}

A crucial design decision of AWR is the choice of sampling policy $\mu(\rva | \rvs)$. Standard implementations of RWR typically follow an on-policy approach, where the sampling policy is selected to be the current policy $\mu(\rva | \rvs) = \pi_k(\rva | \rvs)$ at iteration $k$. This can be sample inefficient, as data collected at each iteration of the algorithms are discarded after a single update iteration. Importance sampling can be incorporated into RWR to reuse data from previous iterations, but at the cost of larger variance from the importance sampling estimator \citep{POWER2008}. Instead, we can improve sample efficiency of AWR by incorporating experience replay and explicitly accounting for training data from a mixture of multiple prior policies.
As described in Algorithm~\ref{alg:AWR}, at each iteration, AWR collects a batch of data using the latest policy $\pi_k$, and then stores this data in a replay buffer $\mathcal{D}$, which also contains data collected from previous policies $\{\pi_1, \cdots, \pi_k\}$. The value function and policy are then updated using samples drawn from $\mathcal{D}$. This replay strategy is analogous to modeling the sampling policy as a mixture of policies from previous iterations ${\mu_k(\tau) = \sum_{i = 1}^k \weighti \pi_i(\tau)}$, where $\pi_i(\tau) = p(\tau | \pi_i)$ represents the likelihood of a trajectory $\tau$ under a policy $\pi_i$ from the $i$th iteration, and the weights $\sum_i \weighti = 1$ specify the probabilities of selecting each policy $\pi_i$.

We now extend the derivation from the previous section to the off-policy setting with experience replay, and show that Algorithm~\ref{alg:AWR} indeed optimizes the expected improvement over a sampling policy modeled by the replay buffer. Given a replay buffer consisting of trajectories from past policies, the joint state-action distribution of $\mu$ is given by $\mu(\rvs, \rva) = \sum_{i=1}^k \weighti \dpii(\rvs) \pi_i(\rva | \rvs)$, and similarly for the marginal state distribution $d_\mu(\rvs) = \sum_{i=1}^k \weighti \dpii(\rvs)$. The \textit{expected improvement} can now be expressed with respect to the set of sampling policies in the replay buffer: $\eta(\pi) = J(\pi) - \sum_{i} \weighti J(\pi_i)$. Similar to Equation~\ref{eqn:Improvement}, $\eta(\pi)$ can be expressed in terms of the advantage ${A^{\pi_i}(\rvs, \rva) = \mathcal{R}_{\rvs, \rva}^{\pi_i} - V^{\pi_i}(\rvs)}$ of each sampling policies,
\begin{equation}
    \eta(\pi) = J(\pi) - \sum_{i} \weighti J(\pii)  = \expec_{\rvs \sim \dpi(\rvs)}\expec_{\rva \sim \pi(\rva|\rvs)}\left[ \sum_i \weighti A^{\pii}(\rvs, \rva) \right] .
\end{equation}
As before, we can optimize an approximation $\hat{\eta}(\pi)$ of $\eta(\pi)$ using the state distribution of $\mu$,
\begin{equation}
    \hat{\eta}(\pi) = \expec_{\rvs \sim d_{\mu}(\rvs)} \expec_{\rva \sim \pi(\rva|\rvs)} \left[A^{\pii}(\rvs, \rva) \right] = \sum_{i=1}^k \weighti \left( \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pi(\rva|\rvs)} \left[A^{\pii}(\rvs, \rva) \right] \right)
\end{equation}
In Appendix~\ref{app:ReplayDerivation}, we show that the update procedure in Algorithm~\ref{alg:AWR} optimizes the following objective:
\begin{align}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad & \sum_{i=1}^k \weighti \left( \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pi(\rva|\rvs)} \left[A^{\pii}(\rvs, \rva) \right] \right) \\
    \textrm{s.t.} \quad & \expec_{\rvs \sim d_\mu(\rvs)} \left[ \mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) \right] \leq \epsilon ,
\end{align}
where $\mu(\rva|\rvs) = \frac{\mu(\rvs, \rva)}{d_\mu(\rvs)} = \frac{\sum_i \weighti d_{\pii}(\rvs) \pi_i(\rva|\rvs)}{\sum_j w_j d_{\pi_j}(\rvs)}$ represents the conditional action distribution defined by the replay buffer. This objective can be solved via the Lagrangian to yield the following update:
\begin{equation}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad \sum_{i=1}^k \weighti \ \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pii(\rva | \rvs)} \left[ \mathrm{log} \ \pi (\rva | \rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \left(\mathcal{R}_{\rvs,\rva}^{\pii} - \frac{\sum_j w_j d_{\pi_j}(\rvs) V^{\pi_j}(\rvs)}{\sum_j w_j d_{\pi_j}(\rvs)} \right) \right) \right] ,
\label{eqn:AWROffPolicy}
\end{equation}
where the expectations can be approximated by simply sampling from $\mathcal{D}$ following Line 6 of Algorithm~\ref{alg:AWR}. A detailed derivation is available in Appendix~\ref{app:ReplayDerivation}. Note, the baseline in the exponent now consists of an average of the value functions of the different policies. One approach for estimating this quantity would be to fit separate value functions $V^{\pii}$ for each policy. However, if only a small amount of data is available from each policy, then $V^{\pii}$ could be highly inaccurate~\citep{fu19diagnosing}. Therefore, instead of learning separate value functions, we fit a single \emph{mean} value function $\bar{V}(\rvs)$ that directly estimates the weighted average of $V^{\pii}$'s,
\begin{equation}
\bar{V} = \mathop{\mathrm{arg \ min}}_{V} \  \sum_i \weighti \ \mathbb{E}_{\rvs, \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pii(\rva | \rvs)} \left[ \ ||\mathcal{R}_{\rvs, \rva}^{\pi_i} - V(\rvs) ||^2 \right]
\end{equation}
This loss can also be approximated by simply sampling from the replay buffer following Line~5 of Algorithm~\ref{alg:AWR}. The optimal solution $\bar{V}(\rvs) = \frac{\sum_{i} \weighti d_{\pii}(\rvs) V^{\pii}(\rvs)}{\sum_j w_j d_{\pi_j}(\rvs)}$ is exactly the baseline in Equation~\ref{eqn:AWROffPolicy}.

\subsection{Implementation Details}

Finally, we discuss several design decisions that are important for a practical implementation of AWR. An overview of AWR is provided in Algorithm~\ref{alg:AWR}. The policy update in Equation~\ref{eqn:AWRUpdate} requires sampling states from the \emph{discounted} state distribution $d_\mu(\rvs)$. However, we found that simply sampling states uniformly from $\mathcal{D}$ was also effective, and simpler to implement. This is a common strategy used in standard implementations of RL algorithms \citep{baselines}. When updating the value function and policy, Monte Carlo estimates can be used to approximate the expected return $\mathcal{R}_{\rvs,\rva}^\mathcal{D}$ of samples in $\mathcal{D}$, but this can result in a high-variance estimate. Instead, we opt to approximate $\mathcal{R}_{\rvs,\rva}^\mathcal{D}$ using TD($\lambda$) to obtain a lower-variance estimate \citep{Sutton1998}. TD($\lambda$) is applied by bootstrapping with the value function $V_{k-1}^\mathcal{D}(\rvs)$ from the previous iteration. A simple Monte Carlo return estimator can also be used though, as shown in our experiments, but this produces somewhat worse results.
To further simplify the algorithm, instead of adaptively updating the Lagrange multiplier $\beta$, as is done in previous methods \citep{Peters2007RWR,Peters2010REP,abdolmaleki2018maximum}, we find that simply using a fixed constant for $\beta$ is also effective. The weights $\omega_{\rvs, \rva}^\mathcal{D} = \mathrm{exp}\left( \frac{1}{\beta} \left( \mathcal{R}_{\rvs,\rva}^\mathcal{D} - V^\mathcal{D}(\rvs) \right) \right)$ used to update the policy can occasionally assume excessively large values, which can cause gradients to explode. We therefore apply weight clipping $\hat{\omega}_{\rvs, \rva}^\mathcal{D} = \mathrm{min}\left(\omega_{\rvs, \rva}^\mathcal{D}, \ \omega_{\max}\right)$ with a threshold $\omega_{\max}$ to mitigate issues due to exploding weights.

\section{Related Work}

Existing RL methods can be broadly categorized into on-policy and off-policy algorithms~\citep{Sutton1998}. On-policy algorithms generally update the policy using data collected from the same policy. A popular class of on-policy algorithms is policy gradient methods \citep{Williams1992,PoliGrad1999}, which have been shown to be effective for a diverse array of complex tasks \citep{HeessTSLMWTEWER17,Pathak2017,2018-TOG-deepMimic,Rajeswaran-RSS-18}.
However, on-policy algorithms are typically data inefficient, requiring a large number of interactions with the environment, making it impractical to directly apply these techniques to domains where environmental interactions can be costly (e.g. robotics and other real world applications).
Off-policy algorithms improve sample efficiency by enabling a policy to be trained using data from other sources, such as data collected from different agents or data from previous iterations of the algorithm. Importance sampling is a simple strategy for incorporating off-policy data \citep{Sutton1998,Meuleau00off,Hachiya2009}, but can introduce optimization instabilities due to the potentially large variance of the importance sampling estimator. Dynamic programming methods based on Q-function learning can also leverage off-policy data \citep{Precup2001,mnih2015humanlevel,DDPG2016,NAF16,haarnoja18b}. But these methods can be notoriously unstable, and in practice, require a variety of stabilization techniques to ensure more consistent performance \citep{Hasselt2016,WangBHMMKF16,Munos2016,RainbowDQN2017,fujimoto18a,nachum2018learning,fu19diagnosing}. Furthermore, it can be difficult to apply these methods to learn from fully off-policy data, where an agent is unable to collect additional environmental interactions~\citep{fujimoto19offpolicy, BEAR2019}.

Alternatively, policy search can also be formulated under an expectation-maximization framework. This approach has lead to a variety of EM-based RL algorithms \citep{Peters2010REP,Neumann2011,abdolmaleki2018maximum}, an early example of which is reward-weighted regression (RWR) \citep{Peters2007RWR}. RWR presents a simple on-policy RL algorithm that casts policy search as a supervised regression problem.
A similar algorithm, relative entropy policy search (REPS) \citep{Peters2010REP}, can also be derived from the dual formulation of a constrained policy search problem. RWR has a number appealing properties: it has a very simple update rule, and  since each iteration corresponds to supervised learning, it can be more stable and easier to implement than many of the previously mentioned RL methods. 
Despite these advantages, RWR has not been shown to be an effective RL algorithm when combined with neural network function approximators, as demonstrated in prior work and our own experiments~\citep{TRPOschulman15,DuanCHSA16}. In this work, we propose a number of modifications to the formulation of RWR to produce an effective off-policy deep RL algorithm, while still retaining much of the simplicity of previous methods.

The most closely related prior works to our method are REPS~\citep{Peters2010REP} and MPO~\citep{abdolmaleki2018maximum}, both of which are based on a constrained policy search formulation, and perform policy updates using supervised regression. 
The optimization problem being solved in REPS is similar to AWR, but REPS optimizes the expected return instead of the expected improvement. The weights in REPS also contains a Bellman error term that superficially resembles advantages, but are computed using a linear value function derived from a feature matching constraint. Learning the REPS value function requires minimization of a dual function, which is a complex function of the Bellman error, while the value function in AWR can be learned with simple supervised regression. REPS can in principle leverage off-policy data, but the policy iteration procedure proposed for REPS models the sampling policy using only the latest policy, and does not incorporate experience replay with data from previous iterations.
More recently, \citet{abdolmaleki2018maximum} proposed MPO, a deep RL variant of REPS, which applies a partial EM algorithm for policy optimization. The method first fits a Q-function of the current policy via bootstrapping, and then performs a policy improvement step with respect to this Q-function under a trust region constraint that penalizes large policy changes. MPO uses off-policy data for training a Q-function critic via bootstrapping and employs Retrace($\lambda$) for off-policy correction \citep{Munos2016}. In contrast, AWR is substantially simpler, as it can simply fit a value function to the observed returns in a replay buffer, and performs weighted supervised regression on the actions to fit the policy.
\citet{Neumann2009Gerhard} proposed LAWER, a kernel-based fitted Q-iteration algorithm where the Bellman error is weighted by the normalized advantage of each state-action pair. This was then followed by a soft-policy improvement step. A similar soft-policy update has also been used in more recent algorithms such as soft actor-critic \citep{haarnoja18b}. Similarly to \citep{Neumann2009Gerhard}, our method also uses exponentiated advantages to weight the policy update, but does not perform fitted Q-iteration, and instead utilizes off-policy data in a simple constrained policy search procedure.

\begin{figure}[t!]
	\centering
    \subfigure[HalfCheetah-v2]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_gym_half_cheetah.png}}
    \subfigure[Hopper-v2]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_gym_hopper.png}}\\
    \vspace{-0.25cm}
    \subfigure[LunarLander-v2]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_gym_lunarlander.png}}
    \subfigure[Walker2d-v2]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_gym_walker.png}}\\
    \vspace{-0.25cm}
\caption{Snapshots of AWR policies trained on OpenAI Gym tasks. Our simple algorithm learns effective policies for a diverse set of discrete and continuous control tasks.}
\label{fig:filmstripsGym}
\end{figure}


\section{Experiments}
\label{sec:Experiments}
Our experiments aim to comparatively evaluate the performance of AWR to commonly used on-policy and off-policy deep RL algorithms. We evaluate our method on the OpenAI Gym benchmarks~\citep{OpenAIGym}, consisting of discrete and continuous control tasks. We also evaluate our method on complex motion imitation tasks with high-dimensional simulated characters, including a 34 DoF humanoid and 82 DoF dog \citep{2018-TOG-deepMimic}. We then demonstrate the effectiveness of AWR on fully off-policy learning, by training on static datasets of demonstrations collected from demo policies. Behaviors learned by the policies are best seen in the \href{https://xbpeng.github.io/projects/AWR/}{supplementary video\footref{ft:website}}.
Code for our implementation of AWR is available at \href{https://xbpeng.github.io/projects/AWR/}{xbpeng.github.io/projects/AWR/}. At each iteration, the agent collects a batch of approximately 2000 samples, which are stored in the replay buffer $\mathcal{D}$ along with samples from previous iterations. The replay buffer stores 50k of the most recent samples. Updates to the value function and policy are performed by uniformly sampling minibatches of 256 samples from $\mathcal{D}$. The value function is updated with 200 gradient steps per iteration, and the policy is updated with 1000 steps. Detailed hyperparameter settings are provided in Appendix~\ref{sec:ExpSetup}.

\subsection{Benchmarks}
We compare AWR to a number of state-of-the-art RL algorithms, including on-policy algorithms, such as TRPO \citep{TRPOschulman15} and PPO \citep{PPOSchulmanWDRK17}, off-policy algorithms, such as DDPG \citep{DDPG2016}, TD3 \citep{fujimoto18a}, and SAC \citep{SAC18}, as well as RWR \citep{Peters2007RWR}, which we include for comparison due to its similarity to AWR.\footnote{While we attempted to compare to MPO~\citep{abdolmaleki2018maximum}, we were unable to find source code for an implementation that reproduces results comparable to those reported by \citet{abdolmaleki2018maximum}, and could not implement the algorithm such that it achieves similar performance to those reported by the authors.}
TRPO and PPO use the implementations from OpenAI baselines \citep{baselines}. DDPG, TD3, and SAC uses the implementations from RLkit \citep{rlkit}. RWR is a custom implementation following the algorithm described by \citet{Peters2007RWR}.

Snapshots of the AWR policies are shown in Figure~\ref{fig:filmstripsGym}. Learning curves comparing the different algorithms on the OpenAI Gym benchmarks are shown in Figure~\ref{fig:learningCurvesGym}, and Table~\ref{tab:gymPerf} summarizes the average returns of the final policies across 5 training runs initialized with different random seeds. Overall, AWR shows competitive performance with the state-of-the-art deep RL algorithms. It significantly outperforms on-policy methods such as PPO and TRPO in both sample efficiency and asymptotic performance. While it is not yet as sample efficient as current state-of-the-art off-policy methods, such SAC and TD3, it is generally able to achieve a similar asymptotic performance, despite using only simple supervised regression for both policy and value function updates. The complex Humanoid-V2 task proved to be the most challenging case for AWR, and its performance still lags well behind SAC. Note that RWR generally does not perform well on any of these tasks. This suggests that, although AWR is simple and easy to implement, the particular modifications it makes compared to standard RWR are critical for effective performance.
To illustrate AWR's generality on tasks with discrete actions, we compare AWR to TRPO, PPO, and RWR on LunarLander-v2. DDPG, TD3, and SAC are not easily applicable to discrete action spaces due to their need to backpropagate from the Q-function to the policy.
On this discrete control task, AWR also shows strong performance compared to the other algorithms.

\subsection{Ablation Experiments}
To determine the effects of various design decisions, we evaluate the performance of AWR when key components of the algorithm have been removed. The experiments include an on-policy version of AWR (On-Policy), where only data collected from the latest policy is used to perform updates. We also compare with a version of AWR without the baseline $V(\rvs)$ (No Baseline), which corresponds to using the standard RWR weights ${\omega_{\rvs, \rva} = \mathrm{exp}(\frac{1}{\beta}\mathcal{R}_{\rvs, \rva})}$, and another version that uses Monte Carlo return estimates instead of TD($\lambda$) (No TD($\lambda$)). The effects of these components are illustrated in Figure~\ref{fig:learningCurvesAblation}. Overall, these design decisions appear to be vital for an effective algorithm, with the most crucial components being the use of experience replay and a baseline. Updates using only on-policy data can lead to instabilities and result in noticeable degradation in performance, which may be due to overfitting on a smaller dataset. This issue might be mitigated by collecting a larger batch of on-policy data per iteration, but this can also negatively impact sample efficiency. Removing the baseline also noticeably hampers performance. Using simple Monte Carlo return estimates instead of TD($\lambda$) seems to be a viable alternative, and the algorithm still achieves competitive performance on some tasks. When combined, these different components yield substantial performance gains over standard RWR.

\begin{figure}[t]
	\centering
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_half_cheetah.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_hopper.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_lunarlander.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_walker.png}}\\
    \vspace{-0.25cm}
    \subfigure{\includegraphics[width=0.8\columnwidth]{curves/legend.png}}
\vspace{-0.25cm}
\caption{Learning curves of the various algorithms when applied to OpenAI Gym tasks. Results are averaged across 5 random seeds. AWR is generally competitive with the best current methods.}
\label{fig:learningCurvesGym}
\end{figure}

\begin{table}[t]
{ 
\centering 
\resizebox{\textwidth}{!}{
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
{\bf Task} & {\bf TRPO} & {\bf PPO} & {\bf DDPG} & {\bf TD3} & {\bf SAC} & {\bf RWR} & {\bf AWR (Ours)} \\ \hline
Ant-v2 & $2901 \pm 85$ & $1161 \pm 389$ & $ 72 \pm 1550$ & $4285 \pm 671$ & $\bm{5909 \pm 371}$ & $181 \pm 19$ & $5067 \pm 256$ \\ \hline
HalfCheetah-v2 & $3302 \pm 428$ & $4920 \pm 429$ & $\bm{10563 \pm 382}$ & $4309 \pm 1238$ & $9297 \pm 1206$ & $1400 \pm 370$ & $9136 \pm 184$ \\ \hline
Hopper-v2 & $1880 \pm 337$ & $1391 \pm 304$ & $855 \pm 282$ & $935 \pm 489$ & $2769 \pm 552$ & $605 \pm 114$ & $\bm{3405 \pm 121}$ \\ \hline
Humanoid-v2 & $552 \pm 9$ & $695 \pm 59$ & $4382 \pm 423$ & $81 \pm 17$ & $\bm{8048 \pm 700}$ & $509 \pm 18$ & $4996 \pm 697$ \\ \hline
LunarLander-v2 & $104 \pm 94$ & $121 \pm 49$ & $ - $ & $ - $ & $ - $ & $185 \pm 23$ & $\bm{229 \pm 2}$ \\ \hline
Walker2d-v2 & $2765 \pm 168$ & $2617 \pm 362$ & $401 \pm 470$ & $4212 \pm 427$ & $\bm{5805 \pm 587}$ & $406 \pm 64$ & $\bm{5813 \pm 483}$ \\ \hline
\end{tabular}
}
}
\caption{Final returns for different algorithms on the OpenAI Gym tasks, with $\pm$ corresponding to one standard deviation of the average return across 5 random seeds. In terms of final performance, AWR generally performs comparably or better than prior methods.}
\label{tab:gymPerf}
\end{table}

To better evaluate the effect of experience replay on AWR, we compare the performance of policies trained with different capacities for the replay buffer. Figure~\ref{fig:learningCurvesAblation} illustrates the learning curves for buffers of size 5k, 20k, 50k, 100k, and 500k, with 50k being the default buffer size in our experiments. The size of the replay buffer appears to have a significant impact on overall performance. Smaller buffer sizes can result in instabilities during training, which again may be an effect of overfitting to a smaller dataset. As the buffer size increases, AWR remains stable even when the dataset is dominated by off-policy data from previous iterations. In fact, performance over the course of training appears more stable with larger replay buffers, but progress can also become slower. Since the sampling policy $\mu(\rva | \rvs)$ is modeled by the replay buffer, a larger buffer can limit the rate at which $\mu$ changes by maintaining older data for more iterations. Due to the trust region penalty
in Equation~\ref{eqn:AWRLagrangian}, a slower changing $\mu$ also prevents the policy $\pi$ from changing quickly. The replay buffer therefore provides a simple mechanism to trade-off between stability and learning speed.

\begin{figure}[t]
	\centering
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_ablation_half_cheetah.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_ablation_walker.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_buffer_half_cheetah.png}}
    \subfigure{\includegraphics[height=0.184\columnwidth]{curves/curves_buffer_walker.png}}
    \vspace{-0.5cm}
\caption{\textbf{Left:} Learning curves comparing AWR with various components removed. Each component appears to contribute to improvements in performance, with the best performance achieved when all components are combined. \textbf{Right:} Learning curves comparing AWR with different capacity replay buffers. AWR remains stable with large replay buffers containing primarily off-policy data from previous iterations of the algorithm.}
\label{fig:learningCurvesAblation}
\vspace{-0.3cm}
\end{figure}

\subsection{Motion Imitation}
The Gym benchmarks present relatively low-dimensional tasks. In this section, we study how AWR can solve higher-dimensional tasks with complex simulated characters, including a 34 DoF humanoid and 82 DoF dog. The objective of the tasks is to imitate reference motion clips recorded using motion capture from real world subjects. The experimental setup follows the motion imitation framework proposed by \citet{2018-TOG-deepMimic}. Motion clips are collected from publicly available datasets \citep{CMUMocap,SFUMocap,Zhang2018MNN}. The skills include highly dynamics motions, such as spinkicks and canters (i.e. running), and motions that requires more coordinated movements of the character's body, such as a cartwheel. Snapshots of the behaviors learned by the AWR policies are available in Figure~\ref{fig:filmstripsImitation}. Table~\ref{tab:imitationPerf} compares the performance of AWR to RWR and the highly-tuned PPO implementation from \citet{2018-TOG-deepMimic}. Learning curves for the different algorithms are shown in Figure~\ref{fig:learningCurvesImitation}. AWR performs well across the set of challenging skills, consistently achieving comparable or better performance than PPO. RWR struggles with controlling the humanoid, but exhibits stronger performance on the dog. This performance difference may be due to the more dynamic and acrobatic skills of the humanoid, compared to the more standard locomotion skills of the dog.


\begin{figure}[t!]
	\centering
    \subfigure[Humanoid: Cartwheel]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_humanoid3d_cartwheel.png}}
    \subfigure[Humanoid: Spinkick]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_humanoid3d_spinkick.png}}\\
    \vspace{-0.25cm}
    \subfigure[Dog: Trot]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_dog3d_trot.png}}
    \subfigure[Dog: Turn]{\includegraphics[width=0.49\columnwidth]{figures/filmstrip_dog3d_turn.png}}\\
    \vspace{-0.25cm}
\caption{Snapshots of 34 DoF humanoid and 82 DoF dog trained with AWR to imitate reference motion recorded from real world subjects. AWR is able to learn sophisticated skills with characters with large numbers of degrees of freedom.}
\label{fig:filmstripsImitation}
\end{figure}

\subsection{Off-Policy Learning with Static Datasets}

Since AWR is an off-policy RL algorithm, it has the advantage of being able to leverage data from other sources. This not only accelerates the learning process on standard tasks, as discussed above, but also allows us to apply AWR in a fully off-policy setting, where the algorithm is provided with a static dataset of transitions, and then tasked with learning the best possible policy. To evaluate our method in this setting, we use the off-policy tasks proposed by \citet{BEAR2019}. The objective of these tasks is to learn policies solely from static datasets, without collecting any additional data from the policy that is being trained. The dataset consists of trajectories $\tau = \{\left(\rvs_0, \rva_0, r_0 \right), \left(\rvs_1, \rva_1, r_1 \right), ... \}$ from rollouts of a demo policy. Unlike standard imitation learning tasks, which only observes the states and actions from the demo policy, the dataset also provides the reward received by the demo policy at each step. The demo policies are trained using SAC on various OpenAI Gym tasks.
A dataset of 1 million timesteps is collected for each task. 

For AWR, we simply treat the dataset as the replay buffer $\mathcal{D}$ and directly apply the algorithm without additional modifications. Figure~\ref{fig:offPolicyPerf} compares AWR with other algorithms when applied to the datasets. We include comparisons to the performance of the original demo policy used to generate the dataset (Demo)
and a behavioral cloning policy (BC). The comparisons also include recent off-policy methods: batch-constrained Q-learning (BCQ) \citep{fujimoto19offpolicy} and bootstrapping error accumulation reduction (BEAR) \citep{BEAR2019}, which have shown strong performance on off-policy learning with static datasets.
Note that both of these prior methods are modifications to existing off-policy RL methods, such as TD3 and SAC, which are already quite complex. In contrast, AWR is simple and requires no modifications for the fully off-policy setting.
Despite not collecting any additional data, AWR is able to learn effective policies from these fully off-policy datasets, achieving comparable or better performance than the original demo policies. On-policy methods, such as PPO performs poorly in this off-policy setting. Q-function based methods, such as TD3 and SAC, can in principle handle off-policy data but, as discussed in prior work, tend to struggle in this setting in practice~\citep{fujimoto19offpolicy,BEAR2019}. Indeed, standard behavioral cloning (BC) often outperforms these standard RL methods.
In this fully off-policy setting, AWR can be interpreted as an \emph{advantage-weighted} form of behavioral cloning, which assigns higher likelihoods to demonstration actions that receive higher advantages. Unlike Q-function based methods, AWR is less susceptible to issues from out-of-distribution actions as the policy is always trained on observed actions from the behaviour data \citep{BEAR2019}. AWR also shows comparable performance to BEAR and BCQ, which are specifically designed for this off-policy setting and introduce considerable algorithmic overhead.

\begin{figure}[t!]
    \begin{minipage}{0.49\columnwidth}
        \centering
        \resizebox{\columnwidth}{!}{
        \begin{tabular}{|l|c|c|c|}
            \hline
            {\bf Task} & {\bf PPO} & {\bf RWR} & {\bf AWR (Ours)} \\ \hline
            \makecell[l]{Humanoid:\\Cartwheel} & $ 0.76 \pm 0.02$ & $0.03 \pm 0.01$ & $\bm{0.78 \pm 0.07}$ \\ \hline
            \makecell[l]{Humanoid:\\Spinkick} & $0.70 \pm 0.02$ & $0.05 \pm 0.03$ & $\bm{0.77 \pm 0.04}$ \\ \hline
            \makecell[l]{Dog: Canter} & $0.76 \pm 0.03$ & $0.78 \pm 0.04$ & $\bm{0.86 \pm 0.01}$ \\ \hline
            \makecell[l]{Dog: Trot} & $\bm{0.86 \pm 0.01}$ & $\bm{0.86 \pm 0.01}$ & $\bm{0.86 \pm 0.03}$ \\ \hline
            \makecell[l]{Dog: Turn} & $0.75 \pm 0.02$ & $0.75 \pm 0.03$ & $\bm{0.82 \pm 0.03}$ \\ \hline
        \end{tabular}
        }
        \captionof{table}{Performance statistics of algorithms on the motion imitation tasks. Returns are normalized between the minimum and maximum possible returns per episode.}
        \label{tab:imitationPerf}
    \end{minipage}
    \hfill
    \begin{minipage}{0.5\columnwidth}
        \centering
        \vspace{-0.25cm}
        \includegraphics[height=0.367\columnwidth]{curves/curves_humanoid_spinkick.png}
        \includegraphics[height=0.367\columnwidth]{curves/curves_dog_canter.png}\\
        \vspace{-0.25cm}
        \captionof{figure}{Learning curves on motion imitation tasks. On these challenging tasks, AWR generally learns faster than PPO and RWR.}
        \label{fig:learningCurvesImitation}
    \end{minipage}
    \vspace{-0.3cm}
\end{figure}

\begin{figure}[t]
	\centering
    \subfigure{\includegraphics[height=0.171\columnwidth]{curves/off_policy_ant.png}}
    \subfigure{\includegraphics[height=0.171\columnwidth]{curves/off_policy_half_cheetah.png}}
    \subfigure{\includegraphics[height=0.171\columnwidth]{curves/off_policy_hopper.png}}
    \subfigure{\includegraphics[height=0.171\columnwidth]{curves/off_policy_walker.png}}\\
    \vspace{-0.25cm}
\caption{Performance of various algorithms on off-policy learning tasks with static datasets. AWR is able to learn policies that are comparable or better than the original demo policies.}
\label{fig:offPolicyPerf}
\vspace{-0.25cm}
\end{figure}

\section{Discussion and Future Work}
We presented advantage-weighted regression, a simple off-policy reinforcement learning algorithm, where policy updates are performed using standard supervised learning methods. Despite its simplicity, our algorithm is able to solve challenging control tasks with complex simulated agents, and achieve competitive performance on standard benchmarks compared to a number of well-established RL algorithms. Our derivation introduces several new design decisions, and our experiments verify the importance of these components. AWR is also able to learn from fully off-policy datasets, demonstrating comparable performance to state-of-the-art off-policy methods. While AWR is effective for a diverse suite of tasks, it is not yet as sample efficient as the most efficient off-policy algorithms. We believe that exploring techniques for improving sample efficiency and performance on fully off-policy learning can open opportunities to deploy these methods in real world domains. We are also interested in exploring applications that are particularly suitable for these regression-based RL algorithms, as compared to other classes of RL techniques. A better theoretical understanding of the convergence properties of these algorithms, especially when combined with experience replay, could also be valuable for the development of future algorithms.

\section*{Acknowledgements}
We thank Abhishek Gupta and Aurick Zhou for insightful discussions. This research was supported an NSERC Postgraduate Scholarship, a Berkeley Fellowship for Graduate Study, Berkeley DeepDrive, Sony Interactive Entertainment America, Google, NVIDIA, Amazon, and the DARPA Assured Autonomy program.

\bibliography{main}
\bibliographystyle{iclr2020_conference}

\newpage

\appendix
\section{AWR Derivation}
\label{app:Derivation}

In this section, we derive the AWR algorithm as an approximate optimization of a constrained policy search problem. Our goal is to find a policy that maximize the expected \emph{improvement} $\eta(\pi) = J(\pi) - J(\mu)$ over a sampling policy $\mu(\rva | \rvs)$. We start with a lemma from \citet{Kakade2002}, which shows that the expected improvement can be expressed in terms of the advantage $A^\mu(\rvs, \rva) = \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)$ with respect to the sampling policy $\mu$, where $\mathcal{R}_{\rvs,\rva}^\mu$ denotes the return obtained by performing action $\rva$ in state $\rvs$ and following $\mu$ for the following timesteps, and $V^\mu(\rvs) = \int_\rva \mu(\rva | \rvs) \mathcal{R}_\rvs^\rva \ d\rva$ corresponds to the value function of $\mu$,
\begin{align}
    & \mathbb{E}_{\tau \sim p_\pi(\tau)} \left[ \sum_{t=0}^\infty \gamma^t A^\mu(\rvs_t, \rva_t) \right] \\
    & = \mathbb{E}_{\tau \sim p_\pi(\tau)} \left[ \sum_{t=0}^\infty \gamma^t \left(r(\rvs_t, \rva_t) + \gamma V^\mu(\rvs_{t+1}) - V^\mu(\rvs_t) \right) \right] \\
    & = \mathbb{E}_{\tau \sim p_\pi(\tau)} \left[ -V^\mu(\rvs_0) + \sum_{t=0}^\infty \gamma^t r(\rvs_t, \rva_t) \right] \\
    & = -\mathbb{E}_{\rvs_0 \sim p(\rvs_0)} \left[V^\mu(\rvs_0)\right] + \mathbb{E}_{\tau \sim p_\pi(\tau)} \left[\sum_{t=0}^\infty \gamma^t r(\rvs_t, \rva_t) \right] \\
    & = -J(\mu) + J(\pi)
\end{align}
We can rewrite Equation~\ref{eqn:appImprovementTraj} with an expectation over states instead of trajectories:
\begin{align}
    \eta(\pi) & = \mathbb{E}_{\tau \sim p_\pi(\tau)} \left[ \sum_{t=0}^\infty \gamma^t A^\mu(\rvs_t, \rva_t) \right]\label{eqn:appImprovementTraj} \\
    & = \sum_{t=0}^\infty \int_\rvs p(\rvs_t = \rvs | \pi) \int_\rva \pi(\rva | \rvs) \gamma^t A^\mu(\rvs, \rva) \ d\rva \ d\rvs \\
    & = \int_\rvs \sum_{t=0}^\infty \gamma^t p(\rvs_t = \rvs | \pi) \int_\rva \pi(\rva | \rvs) A^\mu(\rvs, \rva) \ d\rva \ d\rvs \\
    & = \int_\rvs d_\pi(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs \label{eqn:AppImprovement},
\end{align}
where $d_\pi(\rvs) = \sum_{t=0}^\infty \gamma^t p(\rvs_t = \rvs | \pi)$ represents the unnormalized discounted state distribution induced by the policy $\pi$ \citep{Sutton1998}, and $p(\rvs_t = \rvs | \pi)$ is the likelihood of the agent being in state $\rvs$ after following $\pi$ for $t$ timesteps.

The objective in Equation~\ref{eqn:AppImprovement} can be difficult to optimize due to the dependency between $d_\pi(\rvs)$ and $\pi$, as well as the need to collect samples from $\pi$. Following \citet{TRPOschulman15}, we can optimize an approximation $\hat{\eta}(\pi)$ of $\eta(\pi)$ using the state distribution of $\mu$,
\begin{equation}
    \hat{\eta}(\pi) = \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs .
\end{equation}
$\hat{\eta}(\pi)$ matches $\eta(\pi)$ to first order \citep{Kakade2002}, and provides a reasonable estimate of $\eta$ if $\pi$ and $\mu$ are similar.
Using this objective, we can formulate the following \emph{constrained} policy search problem:
\begin{align}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad & \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs \\
    \textrm{s.t.} \quad & \mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) \leq \epsilon, \quad \forall \ \rvs \label{eqn:AWRCons0Supp}\\
    & \int_\rva \ \pi(\rva | \rvs) \ d\rva = 1, \quad \forall \ \rvs \label{eqn:AWRCons1Supp}.
\end{align}
Since enforcing the pointwise KL constraint in Equation~\ref{eqn:AWRCons0Supp} at all states is intractable, we relax the constraint by enforcing it only in expectation $\int_{\rvs} d_\mu(\rvs) \mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) d\rvs \leq \epsilon$. To further simplify the optimization problem, we relax the hard KL constraint by converting it into a soft constraint with coefficient $\beta$,
\begin{equation}
\begin{aligned}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad & \left( \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs  \right) + \beta \left(\epsilon - \int_{\rvs} d_\mu(\rvs) \mathrm{D_{KL}} \left(\pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) d\rvs \right) \\
    \textrm{s.t.} \quad & \int_\rva \ \pi(\rva | \rvs) \ d\rva = 1, \quad \forall \ \rvs.
\end{aligned}
\end{equation}
Next we form the Lagrangian,
\begin{equation}
\begin{aligned}
    \mathcal{L}(\pi, \beta, \alpha) = & \left( \int_\rvs d_\mu(\rvs) \int_\rva \pi(\rva | \rvs) \left[\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs)\right] \ d\rva \ d\rvs  \right) + \beta \left(\epsilon - \int_{\rvs} d_\mu(\rvs) \mathrm{D_{KL}} \left(\pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right) d\rvs \right)\\
    & + \int_{\rvs} \alpha_\rvs \left(1 - \int_\rva \ \pi(\rva | \rvs) d\rva \right) d\rvs,
\end{aligned}
\end{equation}
with $\beta$ and $\alpha = \{\alpha_\rvs \ | \ \forall \rvs \in \mathcal{S}\}$ corresponding to the Lagrange multipliers. Differentiating $\mathcal{L}(\pi, \beta, \alpha)$ with respect to $\pi(\rva|\rvs)$ results in
\begin{equation}
\begin{aligned}
    \frac{\partial \mathcal{L}}{ \partial \pi(\rva | \rvs)} = \ d_\mu(\rvs) \left( \mathcal{R}_{\rvs, \rva}^\mu - V^\mu(\rvs) \right) - \beta \ d_\mu(\rvs) \ \mathrm{log} \pi(\rva|\rvs) + \beta d_\mu(\rvs) \mathrm{log} \mu(\rva|\rvs) - \beta d_\mu(\rvs) - \alpha_\rvs.
\end{aligned}
\end{equation}
Setting to zero and solving for $\pi(\rva|\rvs)$ gives
\begin{equation}
\begin{aligned}
    \mathrm{log} \pi(\rva|\rvs) = \frac{1}{\beta}\left( \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) + \mathrm{log} \mu(\rva|\rvs) - 1 - \frac{1}{d_\mu(\rvs)}\frac{\alpha_\rvs}{\beta}
\end{aligned}
\end{equation}
\begin{equation}
\begin{aligned}
    \pi(\rva|\rvs) = \mu(\rva|\rvs) \mathrm{exp}\left(\frac{1}{\beta}\left( \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right) \mathrm{exp}\left(- \frac{1}{d_\mu(\rvs)}\frac{\alpha_\rvs}{\beta} - 1 \right)
\end{aligned}
\end{equation}
Since $\int_\rva \pi(\rva|\rvs) \ d\rva = 1$, the second exponential term is the partition function $Z(\rvs)$ that normalizes the conditional action distribution,
\begin{equation}
\begin{aligned}
    Z(\rvs) = \mathrm{exp}\left(\frac{1}{d_\mu(\rvs)}\frac{\alpha_\rvs}{\beta} + 1 \right)
\end{aligned} = \int_{\rva'} \mu(\rva'|\rvs) \ \mathrm{exp}\left(\frac{1}{\beta}\left( \mathcal{R}_{\rvs,\rva'}^\mu - V^\mu(\rvs) \right) \right) d\rva'.
\end{equation}
The optimal policy is therefore given by,
\begin{equation}
\begin{aligned}
    \pi^*(\rva|\rvs) = \frac{1}{Z(\rvs)} \ \mu(\rva|\rvs) \ \mathrm{exp}\left(\frac{1}{\beta}\left( \mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right)
\end{aligned}
\end{equation}

If $\pi$ is represented by a function approximator, the optimal policy $\pi^*$ can be projected onto the manifold of parameterized policies by solving the following supervised regression problem
\begin{align}
    & \mathop{\mathrm{arg \ min}}_{\pi} \quad \mathbb{E}_{\rvs \sim d_\mu(\rvs)} \left[ \mathrm{D_{KL}} \left(\pi^*(\cdot  | \rvs) \middle|\middle| \pi(\cdot  | \rvs)\right) \right]\\
    = & \mathop{\mathrm{arg \ min}}_{\pi} \quad \mathbb{E}_{\rvs \sim d_\mu(\rvs)} \left[ \mathrm{D_{KL}} \left(\frac{1}{Z(\rvs)} \ \mu(\rva | \rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \left(\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right) \middle|\middle| \pi(\cdot | \rvs)\right) \right]\\
    = & \mathop{\mathrm{arg \ max}}_{\pi} \quad \mathbb{E}_{\rvs \sim d_\mu(\rvs)} \expec_{\rva \sim \mu(\rva | \rvs)} \left[ \mathrm{log} \ \pi (\rva | \rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \left(\mathcal{R}_{\rvs,\rva}^\mu - V^\mu(\rvs) \right) \right) \right] ,
\end{align}

\section{AWR Derivation with Experience Replay}
\label{app:ReplayDerivation}
In this section, we extend the derivation presented in Appendix~\ref{app:Derivation} to incorporate experience replay using a replay buffer containing data from previous policies. To recap, the sampling distribution is a mixture of $k$ past policies $\{\pi_1, \cdots, \pi_k\}$, where the mixture is performed at the trajectory level. First, we define the trajectory distribution $\mu(\tau)$, marginal state-action distribution $\mu(\rvs, \rva)$, and marginal state distribution $d_\mu(\rvs)$ of the replay buffer according to:
\begin{equation}
    \mu(\tau) = \sum_{i=1}^k \weighti d_{\pii}(\tau), \qquad \mu(\rvs, \rva) = \sum_{i=1}^k \weighti d_{\pii}(\rvs) \pii(\rva|\rvs), \quad d_\mu(\rvs) = \sum_{i=1}^k \weighti d_{\pii}(\rvs)
    \label{app_eqn:definition}
\end{equation}
where the weights $\sum_i \weighti = 1$ specify the probabilities of selecting each policy $\pii$. The conditional action distribution $\mu(\rva|\rvs)$ induced by the replay buffer is given by:
\begin{equation}
\mu(\rva|\rvs) = \frac{\mu(\rvs, \rva)}{d_\mu(\rvs)} = \frac{\sum_{i=1}^k \weighti d_{\pii}(\rvs) \pi_i(\rva|\rvs)}{\sum_{j=1}^k w_j d_{\pi_j}(\rvs)} .
\end{equation}

Next, using Lemma 6.1 from \citet{Kakade2002} (also derived in Appendix~\ref{app:Derivation}), the expected improvement of $\pi$ over each policy $\pi_i$ satisfies
\begin{equation}
    J(\pi) = J(\pii) + \expec_{\rvs \sim d_\pi(\rvs), a \sim \pi(\rva|\rvs)}\left[A^{\pii}(\rvs, \rva)\right]
    \label{app_eqn:improvement}
\end{equation}
The expected improvement over the mixture can then be expressed with respect to the individual policies,
\begin{align}
    \eta(\pi) & = J(\pi) - J(\mu) \\
    & = J(\pi) - \sum_{i=1}^k \weighti J(\pii) \\
    & = \sum_{i=1}^k \weighti \left( J(\pi) - J(\pii) \right)\\
    & = \sum_{i=1}^k \weighti \left( \expec_{\rvs \sim d_{\pi}(\rvs), \rva \sim \pi(\rva|\rvs)} \left[A^{\pii}(\rvs, \rva) \right] \right)
    \label{app_eqn:policy_improvement_buffer}
\end{align}

In order to ensure that the policy $\pi$ is similar to the past policies, we constrain $\pi$ against the conditional action distributions of the replay buffer,
\begin{equation}
    \label{app_eqn:kl_constraint}
    \expec_{\rvs \sim \mu(\rvs)}\left[ \mathrm{D_{KL}}\left(\pi(\rva|\rvs) \Big| \Big| \mu(\rva|\rvs) \right) \right] \leq \varepsilon .
\end{equation}
Note that constraining $\pi$ against $\mu(\rva|\rvs)$ has a number of desirable properties. First, the constraint prevents the policy $\pi$ from choosing actions that are vastly different from \textbf{all} of the policies $\{\pi_1, \cdots, \pi_k\}$. Second, the mixture weight assigned to each $\pi_i$ in the definition of $\mu$ depends on the marginal state density $d_{\pii}(\rvs)$ for the particular policy. This property is desirable as the policy $\pi$ is now constrained to be similar to $\pi_i$ only at states that are likely to be visited by $\pii$. This then yields the following constrained objective:
\begin{align}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad & \sum_{i=1}^k \weighti \ \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pi(\rva | \rvs)} \left[\mathcal{R}_{\rvs,\rva}^{\pii} - V^{\pii}(\rvs)\right] \\
    \textrm{s.t.} \quad & \expec_{\rvs \sim d_\mu(\rvs)} \left[\mathrm{D_{KL}} \left( \pi(\cdot |\rvs) || \mu(\cdot |\rvs) \right)\right] \leq \epsilon,\\
    & \int_\rva \ \pi(\rva | \rvs) \ d\rva = 1, \quad \forall \ \rvs.
\end{align}
The Lagrangian of the above objective is given by:
\begin{equation}
\begin{aligned}
    \mathcal{L}(\pi, \beta, \alpha) = & \left( \sum_i \weighti \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pi(\rva | \rvs)} \left[\mathcal{R}_{\rvs,\rva}^{\pii} - V^{\pii}(\rvs)\right]  \right) \\
    & + \beta \left(\epsilon - \expec_{\rvs \sim d_\mu(\rvs)} \mathrm{D_{KL}} \left(\pi(\cdot |\rvs) \middle|\middle| \frac{\sum_{i=1}^k \weighti d_{\pii}(\rvs) \pi_i(\cdot|\rvs)}{\sum_{j=1}^k w_j d_{\pi_j}(\rvs)} \right) \right)\\
    & + \int_{\rvs} \alpha_\rvs \left(1 - \int_\rva \ \pi(\rva | \rvs) d\rva \right) d\rvs,
\end{aligned}
\end{equation}
Solving the Lagrangian following the same procedure as Appendix~\ref{app:Derivation} leads to an optimal policy of the following form:
\begin{equation}
\begin{aligned}
    \pi^*(\rva|\rvs) = \frac{1}{Z(\rvs)} \ \mu(\rva|\rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \frac{\sum_i \weighti d_{\pii}(\rvs) \left(\mathcal{R}_{\rvs,\rva}^{\pii} - V^{\pii}(\rvs)\right)}{\sum_j w_j d_{\pi_j}(\rvs)} \right)
\end{aligned}
\end{equation}
Finally, if $\pi$ is represented by a function approximator, the optimal policy $\pi^*$ can be projected onto the manifold of parameterized policies by solving the following supervised regression problem
\begin{align}
    & \mathop{\mathrm{arg \ min}}_{\pi} \quad \expec_{\rvs, \sim d_\mu(\rvs)} \left[ \mathrm{D_{KL}} \left(\pi^*(\cdot  | \rvs) \middle|\middle| \pi(\cdot  | \rvs)\right) \right]\\
    = & \mathop{\mathrm{arg \ min}}_{\pi} \quad \expec_{\rvs \sim d_\mu(\rvs)} \left[ \mathrm{D_{KL}} \left(\frac{1}{Z(\rvs)} \ \mu(\rva | \rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \frac{\sum_i \weighti d_{\pii}(\rvs) \left(\mathcal{R}_{\rvs,\rva}^{\pii} - V^{\pii}(\rvs)\right)}{\sum_j w_j d_{\pi_j}(\rvs)} \right) \middle|\middle| \pi(\cdot | \rvs)\right) \right]
    \label{app_eqn:final_update}
\end{align}
One of the challenges of optimizing the objective in Equation~\ref{app_eqn:final_update} is that computing the expected return in the exponent requires rolling out multiple policies starting from the same state, which would require the environment to be resettable to any given state. Therefore, to obtain a more practical objective, we approximate the expected return across policies using a single rollout from the replay buffer,
\begin{equation}
    \frac{\sum_i \weighti d_{\pii}(\rvs) \mathcal{R}^{\pii}_{\rvs, \rva}}{\sum_j w_j d_{\pi_j}(\rvs)} \approx \mathcal{R}^{\mathcal{D}}_{\rvs, \rva} ~~ \text{such that} ~~ (\rvs, \rva) \in \mathcal{D} 
\end{equation}
This single-sample estimator results in a biased estimate of the exponentiated advantage, because the expectation with respect to the mixture weights appears in the exponent. But in practice, we find this biased estimator to be effective for our experiments.
Therefore, the objective used in practice is given by:
\begin{equation}
    \mathop{\mathrm{arg \ max}}_{\pi} \quad \sum_{i=1}^k \weighti \ \expec_{\rvs \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pii(\rva | \rvs)} \left[ \mathrm{log} \ \pi (\rva | \rvs) \ \mathrm{exp}\left(\frac{1}{\beta} \left(\mathcal{R}_{\rvs,\rva}^{\pii} - \frac{\sum_j w_j d_{\pi_j}(\rvs) V^{\pi_j}(\rvs)}{\sum_j w_j d_{\pi_j}(\rvs)} \right) \right) \right] ,
    \label{eqn:AWROffPolicyApp}
\end{equation}
where the expectations can be approximated by simply sampling from $\mathcal{D}$ following Line 6 of Algorithm~\ref{alg:AWR}. Note, the baseline in the exponent now consists of an average of the value functions of the different policies. One approach for estimating this quantity would be to fit separate value functions $V^{\pii}$ for each policy. However, if only a small amount of data is available from each policy, then $V^{\pii}$ could be highly inaccurate. Therefore, instead of learning separate value functions, we fit a single \emph{mean} value function $\bar{V}(\rvs)$ that directly estimates the weighted average of $V^{\pii}$'s,
\begin{equation}
\bar{V} = \mathop{\mathrm{arg \ min}}_{V} \  \sum_i \weighti \ \mathbb{E}_{\rvs, \sim d_{\pii}(\rvs)} \expec_{\rva \sim \pii(\rva | \rvs)} \left[ \ ||\mathcal{R}_{\rvs, \rva}^{\pi_i} - V(\rvs) ||^2 \right]
\end{equation}
This loss can also be approximated by simply sampling from the replay buffer following Line~5 of Algorithm~\ref{alg:AWR}. The optimal solution $\bar{V}(\rvs) = \frac{\sum_{i} \weighti d_{\pii}(\rvs) V^{\pii}(\rvs)}{\sum_j w_j d_{\pi_j}(\rvs)}$ is exactly the baseline in Equation~\ref{eqn:AWROffPolicyApp}.

\section{Experimental Setup}
\label{sec:ExpSetup}
In our experiments, the policy is represented by a fully-connected network with 2 hidden layers consisting of 128 and 64 ReLU units respectively \citep{NairRLU2010}, followed by a linear output layer. The value function is modeled by a separate network with a similar architecture, but consists of a single linear output unit for the value. Stochastic gradient descent with momentum is used to update both the policy and value function. The stepsize of the policy and value function are $5 \times 10^{-5}$ and $1 \times 10^{-4}$ respectively, and a momentum of 0.9 is used for both. The temperature is set to $\beta = 0.05$ for all experiments, and $\lambda = 0.95$ is used for TD($\lambda$). The weight clipping threshold $\omega_{\max}$ is set to 20. At each iteration, the agent collects a batch of approximately 2000 samples, which are stored in the replay buffer $\mathcal{D}$ along with samples from previous iterations. The replay buffer stores 50k of the most recent samples. Updates to the value function and policy are performed by uniformly sampling minibatches of 256 samples from $\mathcal{D}$. The value function is updated with 200 gradient steps per iteration, and the policy is updated with 1000 gradient steps.

\newpage
\section{Learning Curves}

\FloatBarrier
\begin{figure}[h]
	\centering
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_ant.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_half_cheetah1.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_hopper.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_humanoid.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_lunarlander.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_walker.png}}\\
    \vspace{-0.25cm}
    \subfigure{\includegraphics[width=0.9\columnwidth]{curves/legend.png}}
\vspace{-0.25cm}
\caption{Learning curves of the various algorithms when applied to OpenAI Gym tasks. Results are averaged over 5 random seeds. AWR is generally competitive with the best current methods.}
\end{figure}

\begin{figure}[h]
	\centering
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_humanoid_spinkick.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_humanoid_cartwheel.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_dog_canter.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_dog_trot.png}}
    \subfigure{\includegraphics[height=0.24\columnwidth]{curves/curves_dog_turn.png}}
\caption{Learning curves on motion imitation tasks. On these challenging tasks, AWR generally learns faster than PPO and RWR.}
\end{figure}

\end{document}
