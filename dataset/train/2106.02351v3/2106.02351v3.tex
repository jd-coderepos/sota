\documentclass{article}







\usepackage[final, nonatbib]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{subfloat}
\usepackage{float}
\usepackage{subfig}
\usepackage{xspace}
\usepackage{enumerate}



\usepackage{comment}
\usepackage{amsmath,amssymb} \usepackage{color}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage{multirow}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsthm}
\newtheorem{lemma}{Lemma}
\usepackage{float}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         

\title{SOLQ: Segmenting Objects by Learning Queries}

\author{Bin Dong \thanks{Equal contribution. This work is supported by The National Key Research and Development Program of China (No.2017YFA0700800) and Beijing Academy of Artificial Intelligence (BAAI).} \qquad Fangao Zeng $^{*}$ \qquad Tiancai Wang $^{*}$ \qquad Xiangyu Zhang \qquad Yichen Wei \\
  MEGVII Technology\\
  \texttt{{\tt\small {\{dongbin,zengfangao,wangtiancai,zhangxiangyu,weiyichen\}}@megvii.com}} \\
}

\begin{document}

\maketitle

\begin{abstract}
In this paper, we propose an end-to-end framework for instance segmentation. Based on the recently introduced DETR \cite{carion2020detr}, our method, termed SOLQ, segments objects by learning unified queries. In SOLQ, each query represents one object and has multiple representations: class, location and mask. The object queries learned perform classification, box regression and mask encoding simultaneously in an unified vector form. During training phase, the mask vectors encoded are supervised by the compression coding of raw spatial masks. In inference time, mask vectors produced can be directly transformed to spatial masks by the inverse process of compression coding. Experimental results show that SOLQ can achieve state-of-the-art performance, surpassing most of existing approaches. Moreover, the joint learning of unified query representation can greatly improve the detection performance of DETR. We hope our SOLQ can serve as a strong baseline for the Transformer-based instance segmentation. Code is available at \url{https://github.com/megvii-research/SOLQ}.
\end{abstract}

\section{Introduction}
Instance segmentation, serving as one of visual detection tasks, not only locates instances of different categories but also generates pixel-level mask for each instance. State-of-the-art instance segmentation methods \cite{he2017maskrcnn, huang2019maskscoringrcnn, chen2019hybrid, liu2018panet} follow the two-stage paradigm, which first performs object detection and then segments the masks within detected boxes by RoIAlign \cite{he2017maskrcnn}. Those methods are relatively easy to be optimized thanks to the deployment of mature object detectors \cite{ren2015faster, cai2018cascade}. However, the segmentation branch heavily relies on the detection branch, making it hard to achieve better joint learning of multiple tasks. 
Some recent works \cite{bolya2019yolact, tian2020conditional, lee2020centermask, peng2020deepsnake} build instance segmentation frameworks on top of anchor-free object detectors \cite{tian2019fcos, duan2019centernet} to remove the ROI-Cropping operation, reducing the effect of feature misalignment. For example, CondInst \cite{tian2020conditional} based on FCOS \cite{tian2019fcos} employs dynamic convolutions \cite{jia2016dynamicconv} to perform instance segmentation. YOLACT \cite{bolya2019yolact} models the instance segmentation as a combination of prototypes weighted by learned mask coefficients for each anchor. However, the weights of dynamic convolutions or the mask coefficients are still generated by instance proposals. 

Regardless of the bounding boxes, SOLO \cite{wang2020solo} introduces the notion of "instance categories" and segments objects by locations. SOLOv2 \cite{wang2020solov2} further solves the problem of inefficient mask representation by introducing dynamic convolution and so-called matrix Non-Maximum Suppression (NMS). Though SOLO directly outputs instance masks based on locations, hand-crafted post-processes, like NMS, are still required to remove duplicated predictions. Also, the performance of small objects is far from satisfactory due to the imbalance of location samples between the large and small objects. Building an end-to-end instance segmentation framework is still a remaining problem.

Our work is inspired by DETR \cite{carion2020detr}, which first proposes the end-to-end solution for object detection. In DETR, object detection is regarded as a set prediction problem and objects are represented by learnable query embeddings. How to encode the spatial binary mask into such an end-to-end system is an opening question. As shown in Fig.~\ref{fig:architecture}(a), DETR is further extended to panoptic segmentation by directly reshaping the learnable embeddings into spatial domain and building a FPN-style \cite{lin2017feature} network to produce the final mask predictions. However, both the Transformer encoder and decoder fail to model the spatial information well. Therefore, it is inappropriate to generate the spatial mask based on such query embeddings. Besides, the spatial mask labels used for supervision are of large resolutions, which results in high computation cost and makes it separated to learn the detection and mask branches\footnote{Train the object detector first and then freeze the weights of object detector to train segmentation branch.}. So we need to find one mask representation that satisfies the following conditions: 1) The representation can naturally convert object mask from spatial domain to embedding domain; 2) The process that encodes the spatial masks into embeddings should be reversible; 3) Mask embeddings encoded can keep the principle components of spatial mask. We turn to methods in literature for help and surprisingly find that classical compression coding methods (\textit{e.g.} Sparse Coding \cite{tao2014sparse}) just satisfy these conditions mentioned above. The mask embeddings can be simply generated from the learnable queries. In training phase, ground-truth spatial mask of each instance can be projected into low-dimensional mask embedding by compression coding and the mask embeddings are used to supervise the learning of predicted mask embeddings. In inference phase, binary spatial mask can be reconstructed from predicted mask embedding by the inverse process of compression coding. 

With these analysis, we explore how to better encode the spatial mask into the end-to-end object detectors in this paper. Based on DETR, our proposed method, termed SOLQ, segments objects by learning queries. In SOLQ, we formulate the instance segmentation as the joint learning of unified query representation (UQR). The UQR learned can be used to perform parallel predictions for three sub-tasks (classification, localization and segmentation) simultaneously and all predictions are obtained in a regression manner (see Fig.~\ref{fig:architecture}(b)). In this way, SOLQ directly outputs instance masks together with corresponding class confidences and box coordinates. The learning of UQR can be divided into two parts: generating instance-aware query embeddings and joint supervision of multi-task learning. Specifically, all candidate instances are initialized with several learnable queries, which interact with extracted image features in Transformer decoder to produce the instance-aware query embeddings. The instance-aware query embeddings are further input to three branches of sub-tasks, which contains several linear projection layers, to generate three sub-task vectors. For the classification and regression branches, we follow the same supervisions as in DETR \cite{carion2020detr}. For the mask branch, we conduct implicit supervision with the help of mask compression coding mentioned above. 

To summarize, our contributions are:
\begin{itemize}
\item We propose an end-to-end framework for instance segmentation based on DETR. SOLQ formulates the instance segmentation as the joint learning of UQR. In UQR, the mask representation can be converted from spatial domain into embedding domain, which is consistent with the learnable query embeddings in DETR. 
\item Experiments show that SOLQ with ResNet101 achieves 40.9\% mask AP and 48.7\% box AP on the challenging MS COCO dataset \cite{lin2014microsoft} without bells and whistles, outperforming SOLOv2 by 1.2\% mask AP and 6.1\% box AP. It is worthy noting that SOLQ can improve 2.0\% in box AP compared to DETR thanks to the joint learning of UQR.
\end{itemize}

\section{Related Work}
\textbf{Instance Segmentation}
Instance segmentation is a classic but challenging computer vision task. It is required to output each object instance in image with instance-level category label and localization, along with pixel-level mask simultaneously. Currently, there are mainly three categories of instance segmentation methods: top-down, bottom-up and directly-predict methods. Top-down approaches \cite{li2017fcis,he2017maskrcnn,bolya2019yolact,zhang2020meinst,chen2020blendmask,chen2019tensormask,huang2019maskscoringrcnn,liu2018panet,queryinst2021} follow the detect-then-segment pipeline. They first generate bounding boxes by object detectors and segment the masks by ROIAlign \cite{he2017maskrcnn} or dynamic convolutions \cite{tian2020conditional}. Bottom-up methods \cite{gao2019ssap,liu2017sgn,de2017semantic,newell2016associativeembedding} learn per-pixel embeddings via semantic label and then cluster them into instance groups. For directly-predict methods, PolarMask \cite{xie2020polarmask} employs polar coordinates to represent mask contours. Latest SOLO \cite{wang2020solo} and SOLOv2 \cite{wang2020solov2} directly segment the objects by locations without dependence on bounding boxes or embedding learning. QueryInst \cite{queryinst2021} and ISTR \cite{hu2021istr} extend the Sparse RCNN \cite{sun2021sparsercnn} to perform end-to-end instance segmentation. In this paper, we explore an end-to-end instance segmentation solution by learning an unified query representation without any post-processing procedures, like Non-Maximal Suppression (NMS). 

\textbf{Transformer in Vision}
Transformer \cite{vaswani2017attention} introduces the self-attention mechanism to model long-range dependencies, and has been widely applied in natural language processing (NLP). Recently, several works attempted to involve the Transformer architecture into various computer vision tasks and showed promising performances. The non-local block \cite{wang2018nonlocal} is first proposed to enhance video recognition by aggregating spatial information. After that, CCNet \cite{huang2019ccnet} further extends the self-attention via sparse attention in semantic segmentation. DETR \cite{carion2020detr} and Deformable DETR \cite{zhu2020deformabledetr} adopt learnable queries and Transformer architecture together with bipartite matching to perform object detection in end-to-end fashion, without any hand-crafted process such as NMS. IPT \cite{chen2020ipt} proposes a transformer-based pretrained network for low-level image processing. ViT series \cite{dosovitskiy2020vit,touvron2020deit,wang2021pvt,liu2021swin} take an image as a sequence of patches and achieve the cross-patch interactions by Transformer architecture in image classification. 

\textbf{Compression Coding in Vision}
Consider the advantage of low-dimension representation and less computation cost, some recent works have attempted to introduce compression coding methods, like Sparse Coding \cite{donoho2006compressed}, Principal Component Analysis (PCA) \cite{wold1987principal} and Discrete Cosine Transform (DCT) \cite{ahmed1974discrete}, into computer vision field. For image classification, \cite{xu2020learn_in_freq} takes the DCT coefficients obtained from RGB images as the inputs of convolutional neural networks (CNNs) to reduce the communication bandwidth between CPU and GPU. DCT-Mask \cite{shen2020dct},  based on Mask R-CNN, employs DCT supervision to produce high-quality mask representation. Analogously, \cite{lo2019exploring} performed semantic segmentation on the DCT representation and fed the rearranged DCT coefficients to CNNs. MEInst \cite{zhang2020meinst} and ISTR \cite{hu2021istr} encode binary masks into fixed-dimensional mask vectors produced by PCA.

\section{Method}
\subsection{Reviewing DETR}
Recently, DETR \cite{carion2020detr} succeed in object detection. It formulates object detection as a set prediction problem and introduces object queries, a set of learnable embeddings, to represent objects. In DETR, each object query predicts an object for a given input image and set prediction loss is adopted to achieve one-to-one matching between the predicted and ground-truth objects in training phase. Further, the transformer encoder-decoder architecture is employed to model the relation between query embeddings and instances for better one-to-one set prediction.

\textbf{Set Prediction Loss}
Let $y=(c, b)$ and $\hat{y}=(\hat{c}, \hat{b})$ denote the ground truths $y$ and the set of predictions $\hat{y}$, respectively. $c, \hat{c}\in\mathbb{R}^{J \times S}$ are the corresponding class labels and predicted class scores, where $J$ and $S$ are the object number and class number. $b, \hat{b}\in\mathbb{R}^{J \times 4}$ are the corresponding ground-truth and predicted box coordinates. $\omega \in \Omega_{J}$ is the assignment between the ground truths and predictions. Then the optimal one-to-one assignment $\omega^{*}$ can be calculated by bipartite matching \cite{kuhn1955hungarian} as:
\begin{equation}
\label{eq:bipartite_match}
\omega^{*}=\underset{\omega \in \Omega_{J}}{arg\mathrm{min}}\mathcal{L}^{det}(y,\omega(\hat{y}))
\end{equation}
where the bipartite matching loss for object detection $\mathcal{L}_{det}$ can be summarised as:
\begin{equation}
\label{eq:bipartite_cost}
\mathcal{L}_{det}(y,\hat{y}) = \lambda_{cls} \cdot \mathcal{L}_{cls}(c,\hat{c}) + \lambda_{L_{1}} \cdot \mathcal{L}_{L_{1}}(b,\hat{b}) + \lambda_{giou} \cdot \mathcal{L}_{giou}(b,\hat{b})
\end{equation}
Here $\mathcal{L}_{cls}$ denotes the focal loss \cite{lin2017focalloss} for classifications, $\mathcal{L}_{L_{1}}$ and $\mathcal{L}_{giou}$ are L1 loss and generalized IoU loss \cite{rezatofighi2019giou} for box coordinates, respectively. $\lambda_{cls}$, $\lambda_{L_{1}}$ and $\lambda_{giou}$ are corresponding coefficients. 

\textbf{Extension on Segmentation}
As shown in Fig.~\ref{fig:architecture}(a), DETR is further generalized to panoptic segmentation task by adding a multi-head attention (MHA) and FPN-style CNN after the Transformer decoder. Features from the encoder and learned query embeddings from the decoder are reshaped to spatial domain and then interact in MHA. The produced features are then gradually upsampled to the image size by the FPN-Style CNN to obtain spatial masks. It's easy to adapt this framework to perform instance segmentation by cropping instance masks within detected bounding boxes. 

\textbf{Object Representation}
In DETR, objects are represented as a set of object queries. Object queries are initialized by the learnable query embeddings and then interact with the image features in the transformer decoder to update their representation. Finally, object query, as an unified representation, is directly used to classify and localize objects. However, the representation of spatial mask is built by compulsorily reshaping the query embeddings to spatial domain in instance segmentation task. Such design leads to different representation forms compared to detection branch. Besides, the two-stage training process makes DETR fail to enjoy the benefit from multi-task learning. 

\subsection{Network Architecture}
To encode the spatial mask into the end-to-end object detector in an unified form, we present a simple but efficient framework for instance segmentation based on DETR. The unified query representation (UQR) is proposed to perform instance-level localization and pixel-level segmentation simultaneously. The compression coding is further introduced to project the spatial mask into embedding domain for high-quality and efficient mask representation. 
The overall architecture of SOLQ is showed in Fig.~\ref{fig:architecture}(b). SOLQ can be divided into three parts: feature extraction network, Transformer decoder and unified query representation. We will describe our method in detail as follows.

\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{overall.pdf}
\caption{Architecture comparison between the naive DETR and the proposed SOLQ for instance segmentation. "Res2-Res5" are different stages of ResNet \cite{he2016resnet}. "DConv" and "MHA" are deconvolution \cite{zeiler2010deconvolutional} layer and multi-head attention, respectively. "MLPs" means multi-layer perceptions and "UQR" denotes unified query representation, which is introduced in detail via Fig.~\ref{fig:vector_head}. $q^{0}$ is initial learnable object queries. "Frozen" means that train object detector firstly, and then freeze weights of the object detector to train instance segmentation branch, separately.}
\label{fig:architecture}
\end{figure}

\textbf{Feature Extraction Network}
The feature extraction network consists of the backbone and Transformer encoder. Given an image $\mathrm{I} \in\mathbb{R}^{H \times W \times 3}$, ResNet \cite{he2016resnet} is used as the backbone to extract basic feature map $x^{0}\in\mathbb{R}^{C \times \frac{H}{32} \times \frac{W}{32}}$, where $H$, $W$, $C$ are the height, width and channels of feature map, respectively. Then the basis feature $x^{0}$ is fed into $K$ Transformer encoder layers to get the refined feature map $x^{K}\in\mathbb{R}^{C \times \frac{HW}{32^{2}}}$ via $\{x^{k}=\mathcal{F}^{k}(x^{k-1})\}^{K}_{k=1}$, iteratively. Each Transformer encoder layer $\mathcal{F}^{k}(\cdot)$ is composed of a multi-head self-attention (MHSA) and a feed-forward network (FFN).

\textbf{Transformer Decoder}
Given the learnable object queries, we generate the instance-aware query embeddings for the unified query representation by the Transformer decoder. In details, a set of learnable object queries $q^{0}\in\mathbb{R}^{J \times C}$ are firstly randomly initialized. Then the initial object queries $q^{0}$ interact with the refined feature map $x^{K}$ in $K$ Transformer decoder layers to obtain instance-aware query embeddings $q^{K}\in\mathbb{R}^{J \times C}$ by $\{q^{k}=\mathcal{H}^{k}(q^{k-1}, x^{K})\}^{K}_{k=1}$. Each Transformer decoder layer $\mathcal{H}^{k}(\cdot)$ has an extra multi-head cross-attention layer compared to the Transformer encoder layer. The instance-aware query embeddings $q^{K}$ are then fed into unified query representation part to generate predictions for three sub-tasks, including classification, localization and segmentation.

\textbf{Unified Query Representation}
After Transformer decoder, each instance-aware query embedding in $q^{K}$ represents the features of corresponding instance. The supervision of three sub-tasks (classification, localization and segmentation) in an unified form (\textit{e.g.} vector) is the last piece of the puzzle to achieve parallel predictions. Fig.~\ref{fig:vector_head} shows the learning of UQR. We mainly describes the joint supervision of multi-task learning as well as the training and inference processes of mask branch.

\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{vectorhead.pdf}
\caption{The learning of the proposed unified query representation. $q^{K}$ refers to the learned instance-aware query embeddings. $\hat{c}$, $\hat{b}$, $\hat{v}$ are predicted class, box and mask vectors, respectively. $\hat{m}$ is the binary masks reconstructed. $m$ and $v$ denote ground-truth binary masks and mask vectors, correspondingly. $\mathcal{L}_{cls}$, $\mathcal{L}_{L_{1}}\&\mathcal{L}_{giou}$ and $\mathcal{L}_{vec}$ are the losses for classification, box regression and mask segmentation, respectively.}
\label{fig:vector_head}
\end{figure}

In details, UQR is learned under the supervision of classification, localization and mask branches. Both classification and localization branches are the same as in DETR \cite{carion2020detr}. The classification branch is a fully-connected (FC) layer that predicts the class confidences $\hat{c}$. The localization branch is a multi-layer perception (MLP) with hidden size 256 and predicts 4 box coordinates $\hat{b}$. Similar to localization branch, the mask branch is also a multi-layer perception with hidden size 1024 and predicts mask vectors $\hat{v}\in\mathbb{R}^{J \times n_{k}}$, $n_{k}$ is the dimension of each mask vector. During training, the mask vectors predicted are supervised by the ground-truth mask vectors $v\in\mathbb{R}^{J \times n_{k}}$ generated from spatial mask $m\in\mathbb{R}^{J \times N \times N}$ by the mask compression coding described below, $N$ is the spatial dimension of binary mask. While for the inference, the predicted mask vectors $\hat{v}$ can be used to reconstruct the spatial masks $\hat{m}$ by the inverse process of compression coding. Note that each Transformer decoder layer learns such an UQR and auxiliary supervision is adopted for better performance. 




\textbf{Mask Compression Coding}
As mentioned above, predicted mask vectors $\hat{v}$ generated by the mask branch are supervised by the ground-truth mask vectors $v$. Here, we explore three compression coding methods to transform 2D spatial binary masks into 1D mask vectors, including Sparse Coding \cite{donoho2006compressed}, Principal Component Analysis (PCA) \cite{wold1987principal} and Discrete Cosine Transform (DCT) \cite{ahmed1974discrete}. 


\textbf{\textit{Sparse Coding}} compresses the binary mask as a sparse combination of $n_{k}$ atoms from an overcomplete dictionary $\mathrm{D}\in\mathbb{R}^{n_{k} \times N^{2}}$. Ground-truth mask vectors $v$ can be obtained from $m$ through solving the minimum of Lasso \cite{tibshirani1996regression} problem:
\begin{equation}
\label{eq:spc}
(v^{*},\mathrm{D}^{*}) =  \underset{(v,\mathrm{D})}{arg\mathrm{min}}(\frac{1}{2}||m-v\mathrm{D}||_{2}^{2} + \beta||v||_{1}),~\textit{s.t.}~||\mathrm{D}_{e}||_{2}=1,~ \forall e\in[1,n_{k}]
\end{equation}
where $\beta$ is the regular coefficient. The binary masks $\hat{m}$ can be reconstructed via $\hat{m}=\hat{v}\mathrm{D}$.

\textbf{\textit{PCA}} transforms binary masks to low-dimensional mask vectors via matrix factorization. The process can be summarized as the following optimization problem:
\begin{equation}
\label{eq:pca}
\mathrm{P}^{*}=\underset{\mathrm{P}}{arg\mathrm{min}} ||m-m\mathrm{P}\mathrm{P}^{T}||^{2},~\textit{s.t.}~\mathrm{P}\mathrm{P}^{T}=\mathrm{U}_{n_{k}}
\end{equation}
where $\mathrm{P} \in \mathbb{R}^{N^{2} \times n_{k}}$ and $\mathrm{U}_{n_{k}} \in \mathbb{R}^{n_{k} \times n_{k}}$ are the projection matrix and unit matrix, respectively. Ground-truth mask vectors $v$ can be represented as $v=m\mathrm{P}$ meanwhile binary masks can be reconstructed by $\hat{m}=\hat{v}\mathrm{P}^{T}$.

\textbf{\textit{DCT}} first transforms ground-truth binary masks $m$ into frequency domain according to $f=\mathrm{A}m\mathrm{A}^{T}$, where $\mathrm{A} \in \mathbb{R}^{N \times N}$ is the transform matrix and the ($h,l$) element of $\mathrm{A}$ can be calculated by $\mathrm{A}_{h,l}=\sqrt{\frac{1+sign(h)}{N}}cos[\frac{(l+0.5)\pi}{N}h]|$. 
The ground-truth mask vectors $v$ can be encoded by sampling the low-frequency components from $f$. The binary masks $\hat{m}$ can be recovered through the inverse sampling and transformation $\hat{m}=\mathrm{A}^{-1}\hat{f}(\mathrm{A}^{T})^{-1}$, where $\hat{f}$ is the inverse sampling result from $\hat{v}$.

\textbf{Loss Function}
We extend object ground-truths with mask vectors as $y=(c,b,v)$ and corresponding predictions are $\hat{y}=(\hat{c}, \hat{b},\hat{v})$. The overall loss function for supervision can be expressed as:
\begin{equation}
\label{eq:bipartite_loss}
\mathcal{L}_{inst} = \mathcal{L}_{det} + \lambda_{vec} \cdot \mathcal{L}_{vec}(v,\hat{v})
\end{equation}
where $\mathcal{L}_{vec}$ is the mask vector loss and we use L1 loss in practice. $\lambda_{vec}$ is the corresponding weight and $\mathcal{L}_{det}$ is same as Eq.~\ref{eq:bipartite_cost}. Note that mask loss is not included in bipartite matching. The participation of mask loss may affect the global matching between the object queries and ground-truths.



\subsection{Discussion}
Whereas our SOLQ shares similarities with MEInst \cite{zhang2020meinst}, DCT-Mask \cite{shen2020dct} and ISTR \cite{hu2021istr} in the compression coding of spatial mask, the main differences are described as follows. SOLQ produces the instance masks together with the instance class and the location in a parallel way. It aims to learn an unified query representation for better multi-task learning. The predictions of three sub-tasks are all obtained in a regression manner. Also, SOLQ is an end-to-end instance segmentation framework without any post-processes, like NMS. In contrast, DCT-Mask encodes the instance masks based on the RoI features cropped by the bounding boxes from detection branch. The mask encoding in MEInst and ISTR requires extra optimization process to obtain the optimal project matrix for reconstructing spatial masks. So they are not learned in an end-to-end manner. Also, our concurrent work, QueryInst \cite{queryinst2021} performs instance segmentation in an end-to-end fashion based on Sparse RCNN \cite{sun2021sparsercnn}. The overall architecture mainly follows `detect-then-segment' paradigm. The features cropped by bounding boxes interact with the updated queries to generate the segmentation masks.

\section{Experiments}
\subsection{Dataset and Metrics}
We validate our method on COCO benchmark \cite{lin2014microsoft}. COCO contains 115k images for training, 5k for validation and 20k for testing, involving 80 object categories with instance-level segmentation annotations. We report results on COCO 2017 \textit{test-dev} set for state-of-the-art comparison and the results on COCO 2017 \textit{val} set for ablation studies. Consistent with Mask R-CNN \cite{he2017maskrcnn}, the standard COCO metrics including AP$^{box}$, AP$^{box}_{S}$, AP$^{box}_{M}$, AP$^{box}_{L}$, and AP$^{seg}$, AP$^{seg}_{S}$, AP$^{seg}_{M}$, AP$^{seg}_{L}$ are used to evaluate the performance of object detection and segmentation.

\subsection{Implementation Details}
\label{imple_detail}
For fast convergence, we build the SOLQ on top of Deformable DETR \cite{zhu2020deformabledetr} in practice. ResNet \cite{he2016deep}, pretrained on the ImageNet \cite{Russakovsky2015ImageNet} is employed as the backbone and multi-scale feature maps from C3 to C6 stages are used. For the deformable attention, the number of heads is set as 8 and the number of sampling points is set as 4. For the mask branch, $n_{k}$ is set to 256, hidden dim of MLP is 1024 and $\lambda_{vec}$ is 3.0. Following DETR, $\lambda_{cls}=2$, $\lambda_{L1}=5$, $\lambda_{giou}=2$. We train our model with Adam optimizer with momentum of 0.9 and weight decay of $1.0 \times 10^{-4}$. Models are trained for 50 epochs with the initial learning rate $2.0 \times 10^{-4}$ and decayed at $40^{th}$ epoch by a factor 0.1. Multi-scale training is adopted, where the shorter side is randomly chosen within [408, 800] and the longer side is less or equal to 1333. All experiments are conducted over 8 Tesla V100 GPUs with batch size 32 except the comparison in Sec.~\ref{uqr_vs_sqr}. Since the D-DETR with SQR can only be trained with batch size 16, we also perform the D-DETR with UQR under the same setting for fair comparison. 

\begin{table*}[h]
\center
\caption{State-of-the-art comparison on the COCO 2017 \textit{test-dev} set. All the models are trained with multi-scale and tested with single scale. `${\dagger}$' and `*' are the results reported in ISTR \cite{queryinst2021} and QueryInst \cite{queryinst2021}, respectively. For experiments with Swin-L backbone \cite{liu2021swin}, the shorter side of input is randomly chosen within [400, 1200] and the longer side is less or equal to 1536.}\vspace{-0.5mm}
\resizebox{1\textwidth}{!}{
\setlength{\tabcolsep}{1.mm}{
\begin{tabular}{c|c|c|cccc|cccc}
\hline
Method & Backbone & Epochs & AP$^{seg}$ & AP$^{seg}_{S}$ & AP$^{seg}_{M}$ & AP$^{seg}_{L}$ & AP$^{box}$ & AP$^{box}_{S}$ & AP$^{box}_{M}$ & AP$^{box}_{L}$ \\ 
\hline
Mask R-CNN$^{\dagger}$ \cite{he2017maskrcnn} & R50-FPN & 36 & 37.5 & 21.1 & 39.6 & 48.3 & 41.3 & 24.2 & 43.6 & 51.7  \\
Cascade Mask R-CNN$^{*}$ \cite{cai2018cascade} & R50-FPN & 36 & 38.6 & 21.7 & 40.8 & 49.6 & 44.5 & - & - & -  \\
HTC$^{*}$ \cite{chen2019hybrid} & R50-FPN & 36 & 39.7 & 22.6 & 42.2 & 50.6 & 44.9 & - & - & -  \\
MEInst$^{\dagger}$ \cite{zhang2020meinst} & R50-FPN &36 & 33.5 & 19.3 & 35.7 & 42.1 & 42.5 & 25.6 & 45.1 & 52.2 \\
CondInst \cite{tian2020conditional} & R50-FPN & 36 & 37.8 & 21.0 & 40.3 & 48.7 & 42.1 & 25.1 & 44.5 & 52.1 \\
BlendMask \cite{chen2020blendmask} & R50-FPN & 36 & 37.8 & 18.8 & 40.9 & 53.6 & 43.0 & 25.3 & 45.4 & 54.0 \\
SOLOv2 \cite{wang2020solov2} & R50-FPN & 72 & 38.8 & 16.5 & 41.7 & 56.2 & 40.4 & 20.5 & 44.2 & 53.9 \\
QueryInst \cite{queryinst2021} & R50-FPN & 36 & 40.6 & 23.4 & 42.5 & 52.8 & 45.6 & - & - & - \\
ISTR \cite{hu2021istr} & R50-FPN & 36 & 38.6 & 22.1 & 40.4 & 50.6 & 46.8 & 27.8 & 48.7 & 59.9 \\ \hline
{$\mathrm{\textbf{SOLQ}}$, $ours$} & R50 & 50 & 39.7 & 21.5 & 42.5 & 53.1 & 47.8 & 27.6 & 50.9 & 61.6 \\ \hline\hline
Mask R-CNN$^{\dagger}$ \cite{he2017maskrcnn} & R101-FPN & 36 & 38.8 & 21.8 & 41.4 & 50.5 & 43.1 & 25.1 & 46.0 & 54.3 \\
Cascade Mask R-CNN$^{*}$ \cite{cai2018cascade} & R101-FPN & 36 & 40.0 & 22.5 & 42.5 & 51.2 & 46.2 & - & - & -  \\
HTC$^{*}$ \cite{chen2019hybrid} & R101-FPN & 36 & 40.8 & 23.0 & 43.5 & 52.6 & 46.3 & - & - & - \\
MEInst$^{\dagger}$ \cite{zhang2020meinst} & R101-FPN & 36 & 35.3 & 20.4 & 37.8 & 44.5 & 44.5 & 26.8 & 47.3 & 54.9 \\
CondInst \cite{tian2020conditional} & R101-FPN & 36 & 39.1 & 21.5 & 41.7 & 50.9 & 43.5 & 25.8 & 46.0 & 54.1 \\
BlendMask \cite{chen2020blendmask} & R101-FPN & 36 & 39.6 & 22.4 & 42.2 & 51.4 & 44.7 & 26.6 & 47.5 & 55.6 \\
DCT-Mask \cite{shen2020dct} & R101-FPN & 36 & 40.1 & 22.7 & 42.7 & 51.8 & - & - & - & - \\
SOLOv2 \cite{wang2020solov2} & R101-FPN & 72 & 39.7 & 17.3 & 42.9 & 57.4 & 42.6 & 22.3 & 46.7 & 56.3 \\
QueryInst \cite{queryinst2021} & R101-FPN & 36 & 42.8 & 24.6 & 45.0 & 55.5 & 48.1 & - & - & - \\
ISTR \cite{hu2021istr} & R101-FPN & 36 & 39.9 & 22.8 & 41.9 & 52.3 & 48.1 & 28.7 & 50.4 & 61.5 \\
\hline
{$\mathrm{\textbf{SOLQ}}$, $ours$} & R101 & 50 & 40.9 & 22.5 & 43.8 & 54.6 & 48.7 & 28.6 & 51.7 & 63.1 \\
\hline\hline
QueryInst \cite{queryinst2021} & Swin-L & 50 & 49.1 & 31.5 & 51.8 & 63.2 & 56.1 & - & - & - \\
{$\mathrm{\textbf{SOLQ}}$, $ours$} & Swin-L & 50 & 46.7 & 29.2 & 50.1 & 60.9 & 56.5 & 37.6 & 60.0 & 70.6 \\
\hline
\end{tabular}
}
}
\label{tab:compare_sota}
\end{table*}


\subsection{Comparison with State-of-the-arts}
As shown in Tab.~\ref{tab:compare_sota}, we compare SOLQ with state-of-the-art methods on COCO \textit{test-dev} set. Our method achieves best performance on both AP$^{seg}$ and AP$^{box}$ metrics. Compared to the typical two-stage methods Mask R-CNN \cite{he2017maskrcnn} and Cascade Mask R-CNN \cite{cai2018cascade}, SOLQ with ResNet-101 surpasses in AP$^{seg}$ by 2.1\% and 0.9\%, respectively. Besides, we also compare SOLQ with state-of-the-art one-stage methods CondInst \cite{tian2020conditional} and SOLOv2 \cite{wang2020solov2}, which are built based on dynamic convolution. Our method outperforms them 1.8\% and 1.2\% in AP$^{seg}$, respectively. Further, based on the recently introduced Swin Transformer \cite{liu2021swin}, our SOLQ will serve as a fully-Transformer framework for instance segmentation and it can achieve 46.7\% AP$^{seg}$ and 56.5\% AP$^{box}$. To further validate the quality of boundary prediction, we also evaluate SOLQ using the Boundary AP \cite{cheng2021boundaryiou} in Appendix\ref{boundary_results}.

It is worthy noting that SOLQ performs well on objects of different scales, especially on small and middle scale objects. For example, SOLQ with ResNet-101 surpasses SOLOv2 by 5.2\% in AP$^{seg}_{S}$ and 0.9\% in AP$^{seg}_{M}$, respectively. It should be owing to the mask compression encoding of spatial binary mask. In SOLOv2, the mask predictions are supervised by the ground-truth mask of $1/4$ instance size so the performance of small objects are not optimized well. For our SOLQ, the mask compression encoding encodes the high-resolution binary mask (e.g. $128\times128$) into low-dimension mask vectors using the sparsity characteristic of the binary mask and keeps the principle information. 

\subsection{UQR \textit{vs.} SQR}
\label{uqr_vs_sqr}
In this section, we show the comparison between the separate query representation (SQR) (see Fig.~\ref{fig:architecture}(a)) in DETR and the UQR used in SOLQ (see Fig.~\ref{fig:architecture}(b)). As shown in Tab.~\ref{tab:fc_vs_fcn}, we surprisingly find that UQR in SOLQ can boost the detection performance of DETR with a great margin, improving AP$^{box}$ by 2.3\% and 2.0\% with ResNet50 and ResNet101. While in comparison, separate query representation (SQR) only improve the AP$^{box}$ by 0.1\% and the segmentation performance with 33.4 AP$^{seg}$ is much lower than that of UQR. The large improvement in AP$^{box}$ shows the effectiveness of our proposed UQR, owing to the unified learning of query representation. For efficiency comparison between them, please refer to the \ref{effciency_compare} in Appendix.

We also report the detection performance of both Faster R-CNN and Mask R-CNN since Mask R-CNN is built on top of Faster R-CNN. Compared to Faster R-CNN, Mask R-CNN improves AP$^{box}$ by 0.6\% and 1.1\% with ResNet50-FPN and ResNet101-FPN, respectively. As we see, multi-task learning tends to improve the performance with each other and the performance can be further improved if these sub-tasks are learned using an unified representation. SOLQ learns the UQR to perform  classification, localization and segmentation simultaneously in a regression manner. For both SQR and Mask R-CNN, full-connected layers are employed to classify the objects and regress box coordinates while the mask generated by full convolution network is supervised by 2D spatial mask.

Further, Fig.~\ref{fig:visual} shows the visualization comparison between the DETR with SQR and our SOLQ. Overall, SOLQ generates much more fine-grained masks and provides better object detection performance. We also show some failure cases in occluded environments (see Appendix \ref{visual_failed}).



\begin{table*}[h]
\center
\caption{Comparisons between Unified Query Representation (UQR) and Separate Query Representation (SQR) on the COCO 2017 \textit{val} set. D-DETR denotes Defoemable DETR and D-DETR$^{*}$ refers our reimplementment version. D-DETR$^{*}$ with SQR means that add an extra FPN-style branch as shown in Fig.~\ref{fig:architecture}(a) to perform instance segmentation on top of D-DETR$^{*}$. `${\dagger}$' and `${\ddagger}$' are the results reported in ISTR \cite{queryinst2021} and Sparse RCNN \cite{queryinst2021}, respectively.}
\resizebox{1\linewidth}{!}{
\setlength{\tabcolsep}{3.2mm}{
\begin{tabular}{l|c|c|l|lccc}
\hline
Method & Backbone & Epochs & AP$^{seg}$ & AP$^{box}$ & AP$^{box}_{S}$ & AP$^{box}_{M}$ & AP$^{box}_{L}$ \\ 
\hline
Faster RCNN$^{\ddagger}$ \cite{ren2015faster} & R50-FPN & 36 & - & 40.2 & 24.2 & 43.5 & 52.0  \\
Mask R-CNN$^{\dagger}$ \cite{he2017maskrcnn} & R50-FPN & 36 & 37.0 & 40.8~(+0.6) & 24.0 & 44.4 & 52.9  \\
\hline
D-DETR \cite{zhu2020deformabledetr} & R50 & 50 & - & 45.4 & 26.8 & 48.3 & 61.7  \\
D-DETR$^{*}$ & R50 & 50 & - & 45.5 & 27.3 & 48.7 & 62.0  \\
D-DETR$^{*}$+SQR & R50 & 50 & 32.2 & 45.6~(+0.1) & 27.2 & 48.8 & 61.5  \\
D-DETR$^{*}$+UQR & R50 & 50 & \textbf{39.5~(+7.3)} & \textbf{47.8~(+2.3)} & \textbf{28.7} & \textbf{51.1} & \textbf{63.7}
\\
\hline\hline
Faster RCNN$^{\ddagger}$ \cite{ren2015faster} & R101-FPN & 36 & - & 42.0 & 26.6 & 45.4 & 53.4  \\
Mask R-CNN$^{\dagger}$ \cite{he2017maskrcnn} & R101-FPN & 36 & 38.8 & 43.1~(+1.1) & 25.1 & 46.0 & 54.3 \\
\hline
D-DETR$^{*}$ & R101 & 50 & - & 46.3 & 28.1 & 49.7 & 62.3 \\
D-DETR$^{*}$+SQR & R101 & 50 & 33.4 & 46.4~(+0.1) & 28.1 & 49.9 & 62.2 \\
D-DETR$^{*}$+UQR & R101 & 50 & \textbf{40.2~(+6.8)} & \textbf{48.3~(+2.0)} & \textbf{29.9} & \textbf{52.1} & \textbf{64.6} \\
\hline
\end{tabular}
}}
\label{tab:fc_vs_fcn}
\end{table*}

\begin{figure}[th]
\centering
\includegraphics[width=1.0\textwidth]{visual_comp.pdf}
\caption{
Visualization comparisons between Unified Query Representation (UQR) and Separate Query Representation (SQR) on the COCO 2017 \textit{val} set. For more visualization comparison, please refer to \ref{visual_more} in Appendix. 
}
\label{fig:visual}
\end{figure}



\subsection{Ablation Studies}
\label{ablation_studies}
In this section, we also ablate several critical factors in SOLQ by progressively adjusting each factor in the system. It can be seen that each factor contributes to the final success of the SOLQ. 
Note that our ablation experiments are conducted using the single feature level with C5 and validated on the COCO 2017 \textit{val} set.

\textbf{Mask Compression Coding Methods}
We compare the impact of different compression coding methods to encode binary masks. As shown in Tab.~\ref{abs-a}, flatting the spatial masks into 1D mask vectors directly for supervision can obtain decent segmentation result while improving AP$^{box}$ by 1\%. DCT produce the best performance in both AP$^{seg}$ and AP$^{box}$ metrics. The main reason is that the loss of mask compression caused by DCT is relatively small, compared to the Sparse Coding and PCA methods. Also, DCT can be employed for each image in an online manner while Sparse Coding and PCA are performed on the whole training set to get "principal components" or "dictionary" in an offline way. Therefore, we choose DCT as our default method for mask compression coding.

\textbf{Mask Vector Loss Weight}
Tab.~\ref{abs-b} shows the effect of adjusting the weight of mask vector loss. When the weight of mask vector loss $\mathrm{\lambda}_{vec}$ is set as 3.0, SOLQ gets the best performance in both AP$^{seg}$ and AP$^{box}$. The regression dimension of DCT vector (\textit{e.g.} 256) is usually larger than that of the bounding box (\textit{e.g.} 4), so the magnitude of mask vector loss is larger than that of the regression loss. Therefore, an appropriate $\mathrm{\lambda}_{vec}$ can keep the balance between the mask branch and localization branch such that these two branches can be jointly optimized better.

\textbf{Mask Vector Loss Stage}
We also ablate the impact of the number of decoder stages enabling mask vector loss in Tab.~\ref{abs-c}. It can be seen that adding auxiliary mask vector loss on all decoders can improve by 2.9\% and 1.1\% on AP$^{seg}$ and AP$^{box}$, respectively. The experimental results show that auxiliary loss employed in multiple decoders is helpful to both mask and detection branches. Note that auxiliary loss of detection branch is enabled in all decoder stages in this ablation, so the gain of detection branch is not as large as the gain of the mask branch.

\textbf{Spatial Resolution of Binary Mask}
As mentioned above, mask compression coding projects the 2D $N \times N$ ground-truth binary masks into 1D mask vectors for supervision. In Tab.~\ref{abs-d}, we explore the impact of the spatial resolution of ground truth binary mask. The segmentation performance AP$^{seg}$ is improved from 30.8 to 32.6 as $N$ increases from 64 to 128 and AP$^{seg}$ no longer improves when $N$ is greater than 128. Ground-truth binary mask with high resolution can keep more instance details but needs high-dimension mask vectors to reconstruct. Therefore, once the number of coefficients $n_{k}$ is chosen, $N$ has the most suitable value corresponding to $n_{k}$. 

\textbf{Dimension of Mask Vector}
Similar to the spatial resolution of ground truth binary mask, there is also a suitable value $n_{k}$ for given $N$. Tab.~\ref{abs-e} shows that $n_{k}=256$ achieves the best performance in both AP$^{seg}$ and AP$^{box}$ when the spatial resolution $N$ is set as 128. Theoretically, mask vector with higher dimension should reconstruct a better binary mask. However, high-dimension mask vector will enlarge the regression dimension, making it hard to optimize the mask branch. As a result, the quality of the binary mask reconstructed reduces a lot.

\begin{table*}[h]
\caption{Ablation studies validated on the COCO 2017 \textit{val} set. All experiments use the single feature level with C5 in ResNet50.}
\center
\subfloat[Impact of different binary mask encoding-decoding methods. Flatten means that reshape the 2D binary masks (28x28) into 1D mask vectors (784) directly, then optimize with L2 and dice loss jointly. \label{abs-a}]{
    \resizebox{0.93\linewidth}{!}{
    \setlength{\tabcolsep}{3.6mm}{
    \begin{tabular}{c|cccc|cccc} 
    \hline
    Type & AP$^{seg}$ & AP$^{seg}_{S}$ & AP$^{seg}_{M}$ & AP$^{seg}_{L}$ & AP$^{box}$ & AP$^{box}_{S}$ & AP$^{box}_{M}$ & AP$^{box}_{L}$ \\
    \hline
      det	& - & - & - & - & 39.4 & 20.6 & 43.0 & 55.5 \\
    Flatten	& 29.7 & 11.6 & 33.4 & 49.3 & 40.4 & 20.2 & 44.7 & 58.8 \\
    Sparse Coding & 11.3 & 6.2 & 12.0 & 17.5 & 40.6 & 20.6 & 44.6 & 59.3 \\
    PCA	& 31.6 & 12.5 & 35.4 & 52.7 & 41.0 & 20.5 & 45.2 & 60.0 \\
    \textbf{DCT}	& \textbf{32.6}	& \textbf{12.8}	& \textbf{37.1}	& \textbf{54.5}	& \textbf{41.3}	& \textbf{20.7} & \textbf{45.4} & \textbf{60.1} \\
    \hline
    \end{tabular}
}}}\hspace{3mm}\vspace{-1mm}
\subfloat[Affect of adjusting mask vector loss weight. Mask vector loss is enabled only in the last decoder layer, $n_{k}=256$. Spatial resolution of ground truth binary mask $N=128$.\label{abs-b}]{
    \resizebox{0.45\linewidth}{!}{
    \setlength{\tabcolsep}{1mm}{
    \begin{tabular}{c|ccc|ccc} 
    \hline
    $\mathrm{\lambda}_{vec}$ & AP$^{seg}$ & AP$^{seg}_{50}$ & AP$^{seg}_{75}$ & AP$^{box}$ & AP$^{box}_{50}$ & AP$^{box}_{75}$ \\
    \hline
    0.3	& 25.2  & 51.0	& 22.2	& 39.3	& 59.9	& 41.8 \\
    0.7	& 26.7	& 52.1	& 24.4	& 39.6	& 60.1	& 42.5 \\
    1	& 27.2	& 53.4	& 24.6	& 39.7	& \textbf{61.3}	& \textbf{43.3} \\
    2	& 28.9	& \textbf{53.5}	& 27.7	& 40.0	& 60.4	& 42.8 \\
    \textbf{3}	& \textbf{29.7}	& \textbf{53.5}	& \textbf{28.4}	& \textbf{40.2}	& 60.4	& 42.8 \\
    4	& 29.6	& 52.3	& 25.6	& \textbf{40.2}	& 60.1	& 42.4 \\
    \hline
    \end{tabular}
}}}\hspace{3mm}\vspace{-1mm}
\subfloat[Ablation of the number of decoder stages enabling mask vector loss. For example, when stage is 4, it means that enable the last 4 decoder layer with mask vector loss and $\lambda_{vec}=3$, $n_{k}=256$.\label{abs-c}]{
    \resizebox{0.45\linewidth}{!}{
    \setlength{\tabcolsep}{1mm}{
    \begin{tabular}{c|ccc|ccc}
    \hline
    \textit{Num.} & AP$^{seg}$ & AP$^{seg}_{50}$ & AP$^{seg}_{75}$ & AP$^{box}$ & AP$^{box}_{50}$ & AP$^{box}_{75}$ \\
    \hline
    1 &	29.7 &	53.5 &	27.7 &	40.2 &	60.4 &	42.8 \\
    2 &	31.8 &	55.4 &	32.1 &	40.8 &	61.2 &	43.3 \\
    3 &	32.0 &	55.2 &	32.4 &	40.7 &	61.0 &	42.9 \\
    4 &	32.4 &	55.7 &	33.1 &	41.0 &	61.2 &	\textbf{43.5} \\
    5 &	32.3 &	55.3 &	33.1 &	40.9 &	60.9 &	43.4 \\
    \textbf{6} &  \textbf{32.6} &  \textbf{55.9} &	\textbf{33.4} &	\textbf{41.3} &	\textbf{61.7} &	43.4 \\
    \hline
    \end{tabular}
}}}\\
\subfloat[Effect of the spatial resolution of ground truth binary mask. Mask vector loss is enabled in all decoder layers and $\lambda_{vec}=3$, $n_{k}=256$.\label{abs-d}]{
    \resizebox{0.45\linewidth}{!}{
    \setlength{\tabcolsep}{1mm}{
    \begin{tabular}{c|ccc|ccc} 
    \hline
    $N$ & AP$^{seg}$ & AP$^{seg}_{50}$ & AP$^{seg}_{75}$ & AP$^{box}$ & AP$^{box}_{50}$ & AP$^{box}_{75}$ \\
    \hline
    64	& 30.8	& 54.8	& 30.8	& 40.5	& 61.2	& 42.7 \\
    96	& 31.5	& 55.4	& 31.8	& 40.7	& 61.4	& 43.1 \\
    \textbf{128}	& \textbf{32.6}	& \textbf{55.9}	& \textbf{33.4}	& \textbf{41.3}	& \textbf{61.7}	& \textbf{43.4} \\
    256	& 32.3	& 55.4	& 32.8	& 40.6	& 60.7	& 43.3 \\
    \hline
    \end{tabular}
}}}\hspace{3mm}\vspace{-1mm}
\subfloat[Impact of the dimension of mask vector. Mask vector loss is enabled in all decoder layers. $\lambda_{vec}=3$ and spatial resolution of binary mask $N=128$.\label{abs-e}]{
    \resizebox{0.45\linewidth}{!}{
    \setlength{\tabcolsep}{1mm}{
    \begin{tabular}{c|ccc|ccc} 
    \hline
    $n_{k}$ & AP$^{seg}$ & AP$^{seg}_{50}$ & AP$^{seg}_{75}$ & AP$^{box}$ & AP$^{box}_{50}$ & AP$^{box}_{75}$\\
    \hline
    144	& 31.5	& 55.6	& 31.6	& 40.9	& 61.3	& \textbf{43.4} \\
    \textbf{256}	& \textbf{32.6}	& \textbf{55.9}	& \textbf{33.4}	& \textbf{41.3}	& \textbf{61.7}	& \textbf{43.4} \\
    300	& 31.0	& 54.7	& 30.9	& 40.4	& 60.8	& 42.8 \\
    400	& 30.9	& 55.1	& 30.2	& 40.6	& 61.3	& 43.0 \\
    \hline
    \end{tabular}
}}} 
\label{tab:abs}
\end{table*}


\section{Conclusion}
In this paper, we present SOLQ, a new instance segmentation framework. Based on DETR, SOLQ learns an unified query representation, which is used to predict the instance masks parallel with object detection in an end-to-end manner. To make the mask representation consistent with the query embedding, SOLQ projects the high-resolution spatial masks into low-dimensional mask vectors and regards mask prediction as the regression of mask vectors. SOLQ is a truly one shot framework without any two-stage operations, like ROIAlign. On the challenging COCO dataset, SOLQ achieves state-of-the-art performance on instance segmentation task and greatly improves the detection performance of DETR thanks to the multi-task learning. We believe that SOLQ will serve as a strong baseline for instance segmentation for its excellent performance and simplicity.


{\small
\bibliographystyle{unsrt}
\bibliography{reference.bib}
}
\clearpage
\appendix

\section{Appendix A}

\subsection{Comparisons on Boundary-AP Metric}
\label{boundary_results}
To analyze the quality of boundary prediction, we also evaluate SOLQ using the Boundary AP proposed in Boundary IoU \cite{cheng2021boundaryiou} and perform the comparisons with PointRend \cite{kirillov2020pointrend} and BMask R-CNN \cite{cheng2020bmaskrcnn} in the Tab.~\ref{tab:boundary_ap}. Similar to the results on MS COCO \cite{lin2014microsoft}, SOLQ shows much better performance on the small and medium objects while is relatively inferior on large objects. Two reasons may explain the lower performance on large objects: sparse activation of object query and fixed coding length of query. For DETR-based approaches, we observed that object queries tend to sparsely focus on specific local regions in the image, so it is relatively hard for object query to capture enough receptive field for large objects. Besides, the fixed coding length of object query also constraints the representation power for large objects. Therefore, longer/dynamic coding length of queries may be developed to adapt various sized objects. The visualization of decoder attention in \ref{decoder_attention} also support our opinion.\vspace{-0.1cm}

\begin{table*}[h]
\caption{Performance comparisons under the Boundary-AP metric on COCO 2017 \textit{val} set.}
\vspace{-0.3cm}
\center
\resizebox{0.6\linewidth}{!}{
\setlength{\tabcolsep}{3mm}{
\begin{tabular}{c|ccccc} 
\hline
Method & AP & AP$_{S}$ & AP$_{M}$ & AP$_{L}$  \\
\hline
Mask-RCNN \cite{he2017maskrcnn}	& 23.1  & 18.6	& 33.4	& 22.2	 \\
PointRend \cite{kirillov2020pointrend} & \textbf{25.4}	& 19.1	& 34.8	& \textbf{26.4}	 \\
BMask R-CNN	\cite{cheng2020bmaskrcnn} & 25.4	& 19.5	& 35.2	& 26.3	 \\
SOLQ        & 25.2  & \textbf{22.8}	& \textbf{37.5}	& 23.9	 \\
\hline
\end{tabular}
}}
\label{tab:boundary_ap}
\end{table*}

\subsection{Efficiency Comparisons Between SQR and UQR}
\label{effciency_compare}
As shown in Tab.~\ref{tab:efficiency}, we further compare the number of parameters, theoretical FLOPs and FPS between the SQR and UQR. `Mask' denotes the mask branch. UQR greatly improves the SQR performance with less parameters and computation burden.\vspace{-0.1cm}

\begin{table*}[h]
\caption{Comparisons on parameters, FLOPs and FPS between SQR and UQR. All models are evaluated on single Tesla V100 GPU with 512x852 input resolution.}
\vspace{-0.3cm}
\center
\resizebox{1\linewidth}{!}{
\setlength{\tabcolsep}{2mm}{
\begin{tabular}{c|cccc}
\hline
Method & AP$^{seg}$ & Params (M) & FLOPs (G) & FPS \\
\hline
SQR & 26.3 & 41 (D-DETR)+26.11 (Mask) & 80.13 (D-DETR)+44.88 (Mask) & 19.3 \\
UQR & 37.0 & 41 (D-DETR)+1.58 (Mask) & 80.13 (D-DETR)+0.47 (Mask)+0.0005 (iDCT) & 24.1 \\
\hline
\end{tabular}
}}
\label{tab:efficiency}
\end{table*}

\subsection{Visualization on the Decoder Attentions}
\label{decoder_attention}
In DETR, decoder attention attends to object extremities in order to predict bounding box. Here, we visualize the decoder attention of SOLQ in Fig.~\ref{fig:visual_decoder_attn} and it will attend to the outline of objects. 

\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{visual_decoder_attn.pdf}
\caption{Visualization of decoder attentions on objects of different scales.}
\label{fig:visual_decoder_attn}
\end{figure}

\subsection{More Qualitative Visualizations in Various Scenes}
\label{visual_more}
We add more qualitative comparisons between SQR and UQR under various situations in Fig.~\ref{fig:visual_more}. \vspace{-0.5cm}

\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{visual_more.pdf}
\caption{More visualization comparison between UQR and SQR on COCO 2017 \textit{val} set.}
\label{fig:visual_more}
\end{figure}

\subsection{Visualizations of Failure Cases}
\label{visual_failed}
We also observed some failure cases existing in occluded environments (see Fig.~\ref{fig:visual_failed}). Since each object query is responsible for specific region, objects with high overlap may share the same object query or correspond to adjacent object queries, resulting in the siamese mask.

\begin{figure}[th]
\centering
\includegraphics[width=1.0\textwidth]{visual_failed.pdf}\vspace{-0.1cm}
\caption{Visualization of some failure cases existing in occluded scenes on COCO 2017 \textit{val} set.}
\label{fig:visual_failed}
\end{figure}

\end{document}