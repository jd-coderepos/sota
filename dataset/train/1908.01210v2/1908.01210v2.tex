\documentclass{article}

\PassOptionsToPackage{numbers}{natbib}




\usepackage[final]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage[colorlinks = true,
            linkcolor = red,]{hyperref}
\usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{caption}
\usepackage{wrapfig}

\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\wz}[1]{{\color{red}{[WZ: #1]}}}
\newcommand{\jun}[1]{{\color{blue}{[Jun: #1]}}}
\newcommand{\alec}[1]{{\bf\textcolor[rgb]{0.2,0.8,0.2}{[Alec: #1]}}}
\newcommand{\ed}[1]{{\bf\textcolor[rgb]{0.2,0.2,0.8}{[ed: #1]}}}
\newcommand{\model}{DIB-R}
\newcommand{\vertexdata}{attribute}
\newcommand{\vertexdatas}{attributes}

\title{Learning to Predict 3D Objects with an Interpolation-based Differentiable Renderer}



\author{Wenzheng Chen  \And Jun Gao\thanks{authors contributed equally}  \And Huan Ling  \And Edward J. Smith \\
\And Jaakko Lehtinen \quad \textbf{Alec Jacobson} \quad \textbf{Sanja Fidler} \vspace{6pt}\\
\small{NVIDIA\textsuperscript{1} \quad University of Toronto\textsuperscript{2} \quad Vector Institute\textsuperscript{3} \quad McGill University\textsuperscript{4} \quad Aalto University\textsuperscript{5}} \vspace{3pt}\\
\texttt{\scriptsize \{wenzchen, huling, jung, esmith, jlehtinen, sfidler\}@nvidia.com,
jacobson@cs.toronto.edu}
}
\begin{document}

\maketitle
\begin{abstract}
Many machine learning models operate on images, but ignore the fact that images are 2D projections formed by 3D geometry interacting with light, in a process called rendering. Enabling ML models to understand image formation might be key for generalization. 
However, due to an essential rasterization step involving discrete assignment operations, rendering pipelines are non-differentiable and thus largely inaccessible to gradient-based ML techniques. In this paper, we present {\emph \model}, a differentiable rendering framework which allows gradients to be analytically computed for all pixels in an image. Key to our approach is to view foreground rasterization as a weighted interpolation of local properties and background rasterization as a distance-based aggregation of global geometry. Our approach allows for accurate optimization over vertex positions, colors, normals, light directions and texture coordinates through a variety of lighting models. We showcase our approach in two ML applications: single-image 3D object prediction, and 3D textured object generation, both trained using exclusively using 2D supervision. Our project website is: \href{https://nv-tlabs.github.io/DIB-R/}{https://nv-tlabs.github.io/DIB-R/}

\end{abstract}

\vspace{-17pt}
\section{Introduction}
\vspace{-10pt}
3D visual perception contributes invaluable information when understanding and interacting with the real world. However, the raw sensory input to both human and machine visual processing streams are 2D projections (images), formed by the complex interactions of 3D geometry with light. Enabling machine learning models to understand the image formation process could facilitate disentanglement of geometry from the lighting effects, which is key in achieving invariance and robustness.
  



The process of generating a 2D image from a 3D model is called \emph{rendering}. Rendering is a well understood process in graphics with different algorithms developed over the years. Making these pipelines amenable to deep learning requires us to differentiate through them.

In~\cite{li2018differentiable}, the authors introduced a differentiable ray tracer which builds on Monte Carlo ray tracing, and can thus deal with secondary lighting effects such as shadows and indirect light. Most of the existing work focuses on rasterization-based renderers, which, while simpler in nature as they geometrically project 3D objects onto the image plane and cannot support more advanced lighting effects, have been demonstrated to work well in a variety of ML applications such as single-image 3D prediction~\cite{loper2014opendr,NMR,liu2019soft, liu2019soft_v2}. Here, we follow this line of work.

Existing rasterization-based approaches typically compute approximate gradients~\cite{loper2014opendr,NMR} which impacts performance. Furthermore, current differentiable rasterizertion methods fail to support differentiation with respect to many informative scene properties, such as textures and lighting, leading to low fidelity rendering, and less informative learning signals~\cite{NMR, liu2019soft, liu2019soft_v2} . 


\iffalse


\fi

In this paper, we present {\model }, an approach to differentiable rendering, which, by viewing rasterization as a combination of local interpolation and global aggregation, allows for the gradients of this process to be computed analytically over the entire image. When performing rasterization of a foreground pixel, similar to~\cite{genova2018unsupervised}, we define its value as a weighted interpolation of the relevant vertex attributes of the foreground face which encloses it. To better capture shape and occlusion information in learning settings we define the rasterization of background pixels through a distance-based aggregation of global face information. With this definition the gradients of produced images can be passed back through a variety of vertex shaders, and computed with respect to all influencing vertex attributes such as positions, colors, texture, light; as well as camera positions. Our differentiable rasterization's design further permits the inclusion of several well known lighting models. 





We wrap our {\model } around a simple neural network in which the properties of an initial polygon sphere are predicted with respect to some conditioning input. We showcase this framework in a number of challenging machine learning applications focusing on 3D shape and texture recovery, across which we achieve both numerical and visual state-of-the art results. 


\vspace{-7pt}
\section{Related work}
\vspace{-5pt}
\paragraph{Differentiable Rasterization:} 


 OpenDR~\cite{loper2014opendr}, the first in the series of differentiable rasterization-based renderers, approximates gradients with respect to pixel positions using first-order Taylor approximation, and uses automatic differentiation to back-propagate through the user-specified forward rendering program. In this approach, gradients are non-zero only in a small band around the edges of the mesh faces, which is bound to affect performance.~\cite{NMR} hand-designs an approximate gradient definition for the movement of faces across image pixels. The use of approximated gradients, and lack of full color information results in noisy 3D predictions, without concave surface features. To analytically compute gradients, Paparazzi~\cite{liu2018paparazzi} and~\cite{liuadvgeo2018}, propose to back-propagate the image gradients to the face normals, and then pass them to vertex positions via chain rule. However, their gradient computation is limited to a particular lighting model (Spherical Harmonics), and the use of face normals further prevents their approach to be applied to smooth shading. 
\cite{petersen2019pix2vex} designs a  smooth differetiable renderer for estimating 3D geometry, while neglecting lighting and texture. \cite{szabo2018unsupervised} supports per-vertex color and approximates the gradient near boundary with blurring, which produces wired effects and can not cover the full image. \cite{insafutdinov2018unsupervised} focus on rendering of point cloud and adopts a differentiable reprojection loss to constrain the distribution of predited point clouds, which loses point connectivity and cannot handle texture and lighting.

SoftRas-Mesh recently proposed in~\cite{liu2019soft} introduces a probabilistic formulation of rasterization, where each pixel is softly assigned to \emph{all} faces of the mesh. While inducing a higher computational cost, this clever trick allows gradients to be computed analytically. Parallel to our work, SoftRas-Color~\cite{liu2019soft_v2} extended this framework to incorporate vertex colors and support texture and lighting theoretically. However, in~\cite{liu2019soft_v2} each pixel would be influenced by all the faces and thus might have blurry problem.
The key difference between the parallel work of ~\cite{liu2019soft_v2} and ours is that, similarly to \cite{genova2018unsupervised}, we specify each foreground pixel to the most front face and compute analytic gradients of foreground pixels by viewing rasterization as interpolation of \emph{local} mesh properties. This allows our rendering effect the same as OpenGL pipeline and naturally supports optimization with respect to all vertex attributes, and additionally enables the extension of our pipeline to a variety of different lighting models.
In contrast to~\cite{genova2018unsupervised}, which also uses an interpolation-based approach, but applied to the entire image, our rasterization module allows for soft assignment of background pixels through an aggregation of global features. 





\vspace{-3pt}
\paragraph{Adverserial 3D Object Generation:}


\iffalse
A large body of machine learning research has focused on the topic of 3D generation of single objects and full scenes. This work has mainly concentrated on supervised learning tasks, wherein 3D structure and/or texture is recovered from images, depth scans, or combination the two \cite{choy20163d, wang2018pixel2mesh, tran2018nonlinear, riegler2017octnetfusion, godard2017unsupervised}. Deep learning formulations most commonly recover this structure in either voxel\cite{choy20163d,girdhar2016learning} or pointcloud\cite{fan2017point, lin2018learning}. However, due to the poor scaling properties of these representations to higher resolutions, many recent methods propose the use of alternative representation such level sets \cite{ mescheder2018occupancy,DLS},  or meshes \cite{wang2018pixel2mesh, groueix2018papier, GEOMetrics }. We continue this theme and make predictions directly in mesh space, by deforming the properties of a predefined mesh. Methods designed for 3D reconstruction task often require full 3D supervision, and take advantage of large-scale 3D datasets such as ShapeNet \cite{ShapeNet} for single objects and SceneNN \cite{hua2016scenenn} for scenes. The restrictive dataset requirements of full 3D supervision has has motivated a number of approaches which instead rely on only 2D supervision. \cite{insafutdinov2018unsupervised, henderson2018learning, NMR} predict 3D objects through in a point cloud and supervise pose and shape prediction by projecting the points into a soft silhouette image and comparing with ground truth silhouettes. Similar to our approach \cite{NMR} and \cite{liu2019soft} developed a differentiable rendering pipeline to render predicted 3D meshes. However, these approaches can only render silhouette information and so are heavily limited by the weaker learning signal this provides, and cannot regress mesh properties other then shape, such as the color, texture, and lighting information we support.
\fi

Generation of 3D shapes through deep learning has been approached using a Generative Adverserial Network (GAN)~\cite{goodfellow2014generative} in
a plethora of work
~\cite{yang20173d, achlioptas2017learning, wu2018learning, 3DIWGAN}. While these approaches require full 3D supervision, differentiable rendering frameworks allow learning 3D object distributions using only 2D supervision~\cite{henderson2018learning}. We showcase our model in the same application, where we are the first to learn a generator for both shape and texture. 





\vspace{-5pt}
\section{{\model }: Differentiable Interpolation-based  Renderer}
\vspace{-5pt}
In this section, we introduce our {\model }. Treating foreground rasterization as an interpolation of vertex attributes allows realistic images to be produced, whose gradients can be fully back-propagated through all predicted vertex \vertexdatas, while defining background rasterization as an aggregation of global information during learning allows for better understanding of shape and occlusion. 

\vspace{-7pt}
\subsection{Rendering Pipeline}
\vspace{-5pt}
Many popular rendering APIs, such as OpenGL~\cite{woo1999opengl} and DirectX3D~\cite{luna2012introduction}, decompose the process of rendering 3D scenes into a set of sequential user-defined programs, referred to as \emph{shaders}. While there exist many different shader types, the vertex, rasterization, and fragment shaders the three most important steps for establishing a complete rendering pipeline. When rendering an image from a 3D polygon mesh, first, the vertex shader projects each 3D vertex in the scene onto the defined 2D image plane. Rasterization is then used to determine which pixels are covered and in what manner, by the primitives these vertices define. Finally, the fragment shader computes how each pixel is colored by the primitives which cover it.  

The vertex and fragment shaders can easily be defined such that they are entirely differentiable. By projecting 3D points onto the 2D image plane by multiplying with the corresponding 3D model, view and projection matrices, the vertex shader operation is directly differentiable. In the fragment shader, pixel colors are decided by a combination of local properties including assigned vertex colors, textures, material properties, and lighting. While the processes through which this information are combined can vary with respect to the chosen rendering model, in most cases this can be accomplished through the application of fully differentiable arithmetic operations. All that remains for our rendering pipeline is the rasterization shader, which presents the main challenge, due to the inherently non-differentiable operations which it requires. In the following section we describe our method for rasterizing scenes such that the derivatives of this operation can be analytically determined. 

\vspace{-6pt}
\subsection{Differentiable Rasterization}
\vspace{-5pt}

\begin{wrapfigure}{R}{0.25\textwidth} 
\centering
\vspace{-14pt}
\includegraphics[width=0.25\textwidth]{figures/demo.pdf}
\vspace{-15pt}
 \label{fig:demonstrate}
 \caption{\footnotesize Illustration of our Differentiable Rasterization.}
\end{wrapfigure}
Consider first only the \textbf{foreground pixels} that are covered by one or more faces. Here, in contrast to standard rendering, where a pixel's value is assigned from the closest face that covers it, we treat foreground rasterization as an interpolation of vertex \vertexdatas  \cite{genova2018unsupervised}. For every foreground pixel we perform a z-buffering test~\cite{greene1993hierarchical}, and assign it to the closest covering face. Each pixel is influenced exclusively by this face. Shown in Fig.~1, a pixel at position  is covered by face  with three vertices , , , and each vertex has its own \vertexdatas: , , , respectively.  and   are 2D coordinates on the image plane while  are  scalars. We compute the value of this pixel, , using barycentric interpolation of the face's vertex \vertexdatas:

where weights ,  and  are calculated over the vertex and pixel positions using a differentiable functions  (provided in Appendix):\
    w_k = \Omega_k(\vec{v}_{0}, \vec{v}_{1},\vec{v}_{2}, \vec{p}_i), \quad k=0, 1, 2.
\label{equation:wfunc}
-2mm]


where  is the number of pixels covered by the face. Now consider pixels which no faces cover, which we refer to as \textbf{background pixels}. Notice that in the formulation above, the gradients from background pixels cannot back-propagate to any mesh \vertexdatas. However, the background pixels provide a strong constraint on the 3D shape, and thus the gradient from them provide a useful signal when learning geometry. Take, for example, pixel  at position  which lies outside of face , in Fig~1. We want this pixel to still provide a useful learning signal. In addition, information from occluded faces an entirely ignored despite their potential future influence.

Inspired by the silhouette rasterizetion of~\cite{liu2019soft}, we define a distance-related probability , that softly assigns face  to pixel  as:

where  is the distance function from pixel  to face  in the projected 2D space, and  is a hyper-parameter that controls the smoothness of the probability (details provided in Appendix). We then combine the probabilistic influence of all faces on a particular pixel in the following way: \
	{A_{i'}} = 1 - \prod_{j=1}^n (1-{A^j_{i'}}).
	\label{equation:diff5}

I = I_l I_c + I_s. 

I_l = k_d (\vec{L} \cdot \vec{N}), \quad   \quad I_s = k_s (\vec{R} \cdot \vec{V})^{\alpha},

I_{Phong} = I_c k_d (\vec{L} \cdot \vec{N})  + k_s (\vec{R} \cdot \vec{V})^{\alpha} . 

I_{Lambertian} = I_c k_d (\vec{L} \cdot \vec{N}). 

I_{Spherical Harmonic} = I_c  \sum_{l=0}^{n-1}\sum_{m=-l}^{l}w_l^m Y_l^m(\vec{N}),
\vspace{-5pt}
-0.9mm]
    {\footnotesize (a)}
    \end{minipage}
    \begin{minipage}[t] {0.09\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/optim/vc3target.png}\-0.9mm]
    {\footnotesize (c)}
    \end{minipage}
    \begin{minipage}[t] {0.09\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/optim/uv3opt.png}\-0.9mm]
    {\footnotesize (e)}
    \end{minipage}
    \begin{minipage}[t] {0.09\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/optim/cam2opt.png}\-0.9mm]
    {\footnotesize (g)}
    \end{minipage}
    \begin{minipage}[t] {0.09\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/optim/mat2opt.png}\
L_{IOU}(\theta) = \mathbb{E}_{\mathbb{I}} \left[1 - \frac{||S\odot \tilde{S}||_1}{||S + \tilde{S} - S\odot \tilde{S}||_1}\right],

L_{col}(\theta) = \mathbb{E}_{\mathbb{I}} \left[|| I - \tilde{I}||_1\right].

L_{1} = L_{IOU} + \lambda_{col} L_{col} + \lambda_{sm} L_{sm} + \lambda_{lap} L_{lap}.
\vspace{-5pt}

L_{adv}(\theta, \phi)= \mathop{\mathbb{E_{I}}}\left[D(I;\phi)  - D(\tilde{I};\phi)\right],\quad
L_{gp}(\phi) =\mathop{\mathbb{E_{\tilde{I}}}}\left[(||\nabla_{\tilde{I}} D(\tilde{I};\phi)||_2  - 1)^2\right].
 
L_{percep}(\phi) =  \mathop{\mathbb{E_{I}}}\left[\sum_{i=1}^{M_{V}} \frac{1}{N_i^V} || V^i(I) - V^i( \tilde{I}) ||_1  + \sum_{i=1}^{M_{D}} \frac{1}{N_i^D} || D^i(I;\phi) - D^i( \tilde{I};\phi) ||_1 \right], 

\theta^*, \phi^* = \argmin \limits_{\theta}\bigg(\argmax\limits_{\phi}\left( \lambda_{adv} L_{adv} - \lambda_{gp}L_{gp}\right) +  \lambda_{per} L_{percep}  +  L_{1}\bigg).
















\vspace{-10pt}
\subsection{3D GAN of Textured Shapes via 2D supervision}
\vspace{-5pt}
In our second application, we further demonstrate the power of our method by training a Generative Adversarial Network (GAN)~\cite{goodfellow2014generative} to produce 3D textured shapes using only 2D supervision. We train a network  to predict vertex positions and a texture map, and exploit a discriminator  to differentiate between real images, and rendered predictions. The network  is modified so as to take normally distributed noise as input, in place of an image. 

While empirically the above GAN is able to recover accurate shapes, it fails to produce meaningful textures. We suspect that disentangling both shape and texture by an image-based discriminator is a hard learning task. To facilitate texture modeling, we train a second discriminator , which operates over texture map predictions. However, as our dataset does not contain true texture maps which can be mapped onto a deformed sphere, for ground truth textures we instead use the textures produced from our network trained to predict texture and lighting from images (Sec~\ref{Single_Img_3D_rec}). To produce these texture maps, we pass every image in our training set through our texture and lighting prediction network, and extract the predicted texture. Our second discriminator then learns to differentiate between textures generated by , and the extracted learned textures. We train  via W-GAN with gradient penalty~\cite{gulrajani2017improved}, and use both discriminators to provide a learning signal.   



\vspace{-6pt}
\section{Experiments}
\vspace{-10pt}
\begin{table}[t!]
\vspace{-3mm}
	\begin{center}
	{
	\caption{Results on single image 3D object prediction reported with 3D IOU (\%) / F-score (\%).}
\label{tbl:3diou}
		\begin{adjustbox}{width=1.01\linewidth}
		\addtolength{\tabcolsep}{-3.9pt}
		\hspace{-4mm}\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
			\toprule
		    Category & Airplane & Bench & Dresser & Car & Chair &Display &Lamp & Speaker & Rifle & Sofa & Table & Phone & Vessel & Mean\\
		    \toprule
		    N3MR~\cite{NMR} &\textbf{ 58.5/80.6}&45.7/55.3&74.1/46.3&71.3/53.3&41.4/39.1&55.5/43.8&36.7/\textbf{46.4}&67.4/35.0&55.7/\textbf{83.6} & 60.2/39.2 & 39.1/46.9 & \textbf{76.2/74.2} & 59.4/\textbf{66.9} & 57.0/54.7\\
			SoftR.~\cite{liu2019soft} &58.4/71.9&44.9/49.9&73.6/41.5&77.1/51.1&49.7/40.8&54.7/41.7&39.1/39.1&68.4/29.8& \textbf{62.0}/82.8 & 63.6/39.3 & 45.3/37.1 & 75.5/68.6 & 58.9/55.4 & 59.3/49.9\\
Ours &57.0/75.7&\textbf{49.8/55.6}&\textbf{76.3/52.2}&\textbf{78.8/53.6}&\textbf{52.7/44.7}&\textbf{58.8/46.4}&\textbf{40.3}/45.9&\textbf{72.6/38.8}&56.1/82.0 & \textbf{67.7/43.1} & \textbf{50.8/51.5} & 74.3/73.3 &  \textbf{60.9}/63.2 & \textbf{61.2/55.8}\\
			\bottomrule
		\end{tabular}
		\end{adjustbox}
		}
	\end{center}
	\vspace{-6mm}
\end{table}

\vspace{-1mm}
\paragraph{Dataset: }
As in~\cite{NMR,liu2019soft,wang2018pixel2mesh}, our dataset comprises 13 object categories from the ShapeNet dataset~\cite{ShapeNet}. We use the same split of objects into our training and test set as~\cite{wang2018pixel2mesh}. We render each model from 24 different views to create our dataset of RGB images used for 2D supervision. To demonstrate the multiple rendering models which {\model } supports, we render each image with 4 different rendering models: 1) basic model without lighting effects, 2) with Lambertian reflectance, 3) with Phong shading, and 4) with  Spherical Harmonics. Further details are provided in the Appendix.


 \vspace{-6pt}
\subsection{Predicting 3D Objects from Single Images: Geometry and Color}
\vspace{-5pt}
\paragraph{Experimental settings:} In our experiments,  we set  and . We train one network on all 13 categories. The network is optimized using the Adam optimizer~\cite{kingma2014adam}, with , and . The batch size is 64, and the dimension of input image is .  We compare our method with the two most related differentiable renderers, N3MR~\cite{NMR} and SoftRas-Mesh~\cite{liu2019soft}, using the same network configurations, training data split and hyperparameters. For quantitative comparison, we first voxelize the predicted mesh into  volume using a standard voxelization tool \texttt{binvox}\footnote{http://www.patrickmin.com/binvox/} provided by ShapeNet~\cite{ShapeNet} and then evaluate using 3D IOU, a standard metric in 3D reconstruction. We additionally measure the F-score following~\cite{tatarchenko2019single} between the predicted mesh and ground truth mesh. The tolerance for F-score is set to 0.02.

\iffalse
\begin{table}
\vspace{-3mm}
    \begin{center}
    {
    \caption{3D IOU (\%)/F-score (\%) results on single image 3D reconstruction.}
\label{tbl:3diou}
        \begin{adjustbox}{width=\textwidth}
        \begin{tabular}{ccccccccc}
            \toprule
            Category & Airplane & Bench & Dresser & Car & Chair &Display &Lamp & \\
            \toprule
            N3MR~\cite{NMR} &\textbf{ 58.50/80.62}&45.66/55.31&74.11/46.25&71.29/53.26&41.37/39.11&55.50/43.78&36.70/\textbf{46.38}&\\
            SoftRas-Mesh~\cite{liu2019soft} &58.37/71.91&44.93/49.88&73.55/41.49&77.07/51.12&49.66/40.76&54.71/41.69&39.07/39.11&\\
Ours &56.93/75.89&\textbf{49.76/55.67}&\textbf{76.29/52.25}&\textbf{78.87/53.62}&\textbf{52.71/44.87}&\textbf{58.85/45.73}&\textbf{40.31}/46.07&\\
            \toprule
            Category & Speaker & Rifle& Sofa &Table &Phone &Vessel & & Mean\\
            \toprule
            N3MR~\cite{NMR} &67.36/35.03&55.67/\textbf{83.58}&60.18/39.18&39.09/46.94&\textbf{76.15/74.19}&59.40/\textbf{66.88}& & 56.99/54.66\\
            SoftRas-Mesh~\cite{liu2019soft}&68.42/29.78&\textbf{61.97}/82.82&63.56/39.29&45.25/37.12&75.48/68.57&58.90/55.36& & 59.30/49.92 \\
Ours &\textbf{72.67/38.92}&55.89/81.90&\textbf{67.75/43.37}&\textbf{50.85/51.49}&74.24/73.63&\textbf{60.86}/63.26& & \textbf{61.22/55.90}\\
            \bottomrule
        \end{tabular}
        \end{adjustbox}
        }
    \end{center}
\end{table}
\fi




\begin{figure}
    \centering
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/d1dcddb5b1d7404dd9b0c189eb58_4.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/our_02958343_d1dcddb5b1d7404dd9b0c189eb588ce6_4_blender_4.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/softras_02958343_d1dcddb5b1d7404dd9b0c189eb588ce6_4_blender_4.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth,height=0.75\linewidth, trim=100 100 100 100, clip ]{figures/blender/n3m_02958343_d1dcddb5b1d7404dd9b0c189eb588ce6_4_blender_4.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, ]{figures/airp.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/our_02691156_f986604528abe35554eefcdc602d4520_19_blender_9.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/softras_02691156_f986604528abe35554eefcdc602d4520_19_blender_9.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/n3m_02691156_f986604528abe35554eefcdc602d4520_19_blender_9.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip ]{figures/blender/e2571e4eba2d9f5eab610b0c94236463_3.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/our_04379243_e2571e4eba2d9f5eab610b0c94236463_20_blender_3.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/softras_04379243_e2571e4eba2d9f5eab610b0c94236463_20_blender_3.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 100 100 100, clip]{figures/blender/04379243_e2571e4eba2d9f5eab610b0c94236463_20_blender_7.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth,  trim=100 100 100 100, clip ]{figures/blender/df4e44114543e805fcb8d8c6d4df8143_5.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 10 100 10, clip]{figures/blender/our_03636649_df4e44114543e805fcb8d8c6d4df8143_5_blender_5.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 10 100 10, clip]{figures/blender/softras_03636649_df4e44114543e805fcb8d8c6d4df8143_5_blender_5.png}
    \end{minipage}
    \begin{minipage}[t] {0.115\textwidth}
    \centering
    \includegraphics[width=\linewidth, height=0.75\linewidth, trim=100 10 100 10, clip]{figures/blender/n3m_03636649_df4e44114543e805fcb8d8c6d4df8143_5_blender_5.png}
    \end{minipage}
    \vspace{-15pt}
    \caption{\footnotesize Qualitative results on single image 3D object prediction. First and fifth column is the ground-truth image, the second and sixth columns are the prediction from our model, the third and seventh column are results from SoftRas-Mesh~\cite{liu2019soft}, the rest two columns are results from N3MR~\cite{NMR}.} 
    \vspace{-0.0em}
    \label{fig:3d-reconstruction}
\end{figure}

\vspace{-5pt}
\paragraph{Results:} Table~\ref{tbl:3diou} provides an evaluation. Our {\model} significantly outperforms other methods, in almost all categories on both metrics. We surpass SoftRas-Mesh/N3MR with 1.92/4.23 points and 5.98/1.23 points in terms of 3D IOU and F-score, respectively. As the only difference in this experiment is the renderer, the quantitative results demonstrate the superior performance of our method. Qualitative examples are shown in Fig~\ref{fig:3d-reconstruction}. Our {\model} faithfully reconstructs both the fine-detailed color and the geometry of the 3D shape, compared to SoftRas-Mesh and N3MR. 


\vspace{-8pt}
\subsection{Predicting 3D Objects from Single Images: Geometry, Texture and Light}
\vspace{-7pt}

\paragraph{Experimental settings:}

We adopt a UNet~\cite{ronneberger2015u} architecture to predict texture maps. As we deform a mesh from a sphere template, similar to \cite{kanazawa2018learning}, we use 2D spherical coordinates as the UV coordinates. The dimension of the input image and predicted texture is .  We use a 6-layer ResNet~\cite{he2016deep} architecture to regress the XYZ directions of light at each vertex from the features at the bottleneck layer of UNet network. We only use the Lambertian model and qualitatively compare with N3MR~\cite{NMR} by measuring the reconstruction error on rendered images under identical settings. Note that SoftRas-Mesh~\cite{liu2019soft} does not support texture and lighting and so no comparison can be made. In the following sections, we only perform experiments on the car class, which has more diverse texture.



\begin{table*}
\vspace{-3.5mm}
\begin{minipage}{0.45\linewidth}
\vspace{-3mm}
    \begin{center}
{\small
        \addtolength{\tabcolsep}{-2.5pt}
        \begin{tabular}{cccc}
            \toprule
            Models &Texture&Lighting & Text. + Light \\
            \toprule
            N3MR~\cite{NMR} & 0.03640 & 23.5585 &0.02208\\
            Ours &\textbf{0.02179}&\textbf{9.7096}&\textbf{0.01362}\\
            \bottomrule
        \end{tabular}
        }
    \end{center}
    \end{minipage}
    \hspace{3mm}
    \begin{minipage}{0.52\linewidth}
        
\caption{\footnotesize Results for texture and light prediction. Texture/Texture+Light shows L-1 loss on the rendered image for texture/texture+lighting. Lighting shows the angle between predicted lighting and GT lighting. Lower is better.}
    \label{tbl:texture}
        \end{minipage}
        \vspace{-1mm}
\end{table*}


\begin{figure*}[t!]
\vspace{-4.5mm}
\includegraphics[height=1.57cm,trim=0 0 0 0, clip]{figures/change-tex.png}
\vspace{-5.5mm}
\caption{\footnotesize{Qualitative examples for 3D shape, texture and light prediction. Col. 1-3: 1) GT rendered image with texture+light, 2) texture only rendered image, 3) light map. Col 4-6: our predictions. Col: 7-9: N3MR~\cite{NMR}}}
\label{fig:comp_nm3r}
\vspace{-4mm}
\end{figure*}

\vspace{-6pt}
\paragraph{Results:} We provide results in Table~\ref{tbl:texture} and Fig~\ref{fig:comp_nm3r}. As ShapeNet does not provide ground-truth UV texture, we compute the L-1 difference on the rendered image using the predicted texture/texture+lighting and the GT image. Compared to N3MR~\cite{NMR}, we achieve significantly better results both quantitatively and qualitatively. We obtain about 40\% lower L-1  difference on texture and 60\% smaller angle difference on lighting direction than N3MR. We also obtain significantly better visual results, in terms of the shape, texture and lighting, as shown in Fig~\ref{fig:comp_nm3r} and the Appendix.

\vspace{-5pt}
\subsection{Texture and Lighting Results With Adversarial Loss}
\vspace{-5pt}
We now evaluate the effect of adding the adverserial loss to the previous experiment.  We demonstrate our DIB-Render with Phong and Spherical Harmonic lighting models. For Phong model we keep diffuse and specular reflectance constant as 1 and 0.4 respectively and predict lighting direction together with shininess constant  while for Spherical Harmonic model we predict 9 coefficients.

\vspace{-4mm}
\paragraph{Experimental settings:} We first train the model without adversarial loss for 50000 iterations then  fine-tune it with adversarial loss for extra 15000 steps. The detailed network architecture is provided in the Appendix. We set  and . We fix the learning rate for the discriminator to  and optimize using Adam~\cite{kingma2014adam}, with , and .
\vspace{-5pt}
\vspace{-3mm}
\paragraph{Qualitative Results and Separation Study:}
We show qualitative results in Fig.~\ref{fig:quantitive_results1}. Notice that the network disentangles texture and light quite well, and produces accurate 3D shape. Furthermore, the adverserial loss helps in making the predicted texture look more crisp compared to Fig~\ref{fig:comp_nm3r}. 

To further study texture and light disentanglement, we render test input images with the same car model but vary the lighting direction (Fig.~\ref{fig:quantitive_results2}). Our predictions recover the shape, texture map and  lighting directions. 
Further examples are provided in Fig.~\ref{fig:quantitive_results3}. On the left, we fix the lighting and texture but render the car in different camera views, to illustrate consistency of prediction across viewpoints. On the right of the figure, we render images with different shininess constants, but fixed lighting direction, texture and camera view. Here, we find that our model is not able to accurately predict the shininess constant. 
In this case, the texture map erroneously compensates for the shininess effect. This might be because the shininess effect is not significant enough to be learned by a neural network though 2D supervision. We hope to resolve this issue in future work.

\begin{figure*}[t!]
\addtolength{\tabcolsep}{-3.6pt}
\includegraphics[height=2.43cm,trim=0.35cm 5cm 0 5cm,clip]{figures/sh_phong_texture_results.pdf}
\vspace{-6.5mm}
\caption{\footnotesize{Qualitative examples for 3D shape, texture and light prediction, when exploiting {\bf adverserial loss}}.  {\bfseries Purple rectangle}: Input image.
{\bfseries Left Example}: Phong Lighting. {\bfseries Right Example}: Spherical Harmonics. 
{\bfseries First col}: Texture and Light. {\bfseries Second col}: Texture. {\bfseries Third col}: Light. {\bfseries Forth to Sixth col}: Texture; different views.}
\label{fig:quantitive_results1}
\vspace{-3.5mm}
\end{figure*}



\begin{figure*}[t!]
\vspace{-1mm}
\addtolength{\tabcolsep}{-3.6pt}
\hspace{-1mm}\includegraphics[width=\textwidth,trim=1cm 5.2cm 1cm 4.6cm,clip]{figures/phong_results_light_dir.pdf}\\
\vspace{-6mm}
\caption{\footnotesize{Light \& Texture Separation Study}. {\bfseries Purple rectangle}: Input image, which are rendered with the same car model but different lighting directions. Each three columns visualize \bf{Texture + Light, Texture, Light}.}
\label{fig:quantitive_results2}
\includegraphics[width=\textwidth,trim=0.2cm 5.2cm 0.2cm 4.5cm,clip]{figures/phong_results_rot.pdf}
\vspace{-6mm}
\caption{\footnotesize{Light \& Texture Separation Study}. {\bfseries Purple rect}: Input image. {\bfseries Left:} Input images are with same light and texture but vary views.  {\bfseries Right:}  Input images are with the same texture but with different shininess constants.}
\label{fig:quantitive_results3}
\vspace{-1mm}
\end{figure*}






\begin{table*}
\vspace{-3.5mm}
\begin{minipage}{0.45\linewidth}
\vspace{-3mm}
	\begin{center}
{\small
		\addtolength{\tabcolsep}{-2.5pt}
		\begin{tabular}{cccc}
			\toprule
		    Models &Texture& 2D IOU & Key Point \\
		    \toprule
		    CMR~\cite{kanazawa2018learning} & 0.043 & 0.262 &0.930\\
			Ours & 0.043 &\textbf{0.243}&\textbf{0.972}\\
			\bottomrule
		\end{tabular}
		}
	\end{center}
	\end{minipage}
	\hspace{3mm}
	\begin{minipage}{0.52\linewidth}
		
\caption{\footnotesize Results on CUB bird dataset~\cite{cub}. Texture and 2D IOU show L-1 loss and 2D IOU loss between predictions and GT, lower is better. Key point evaluates percentage of predicted key points lying in the threshold of 0.1, higher is better.}
	\label{tbl:real}
		\end{minipage}
		\vspace{-1mm}
\end{table*}


\begin{figure*}[t!]
\vspace{-2.5mm}
\includegraphics[height=1.56cm,trim=0 0 0 0, clip]{figures/bird/all.png}
\includegraphics[height=1.56cm,trim=0 0 0 0, clip]{figures/bird/car.png}
\begin{center}
\vspace{-5mm}
\begin{small}
\begin{tabular}{p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}p{11.4mm}}
\hspace{1.5mm} input & \hspace{1.8mm} ours & \hspace{1mm} CMR & \hspace{1.5mm} input & \hspace{1.8mm} ours & \hspace{1mm} CMR & \hspace{1.5mm} input & \hspace{1.8mm} ours & \hspace{1mm} CMR 
\end{tabular}
\end{small}
\end{center}
\vspace{-4.0mm}
\caption{\footnotesize{Qualitative examples on CUBbird dataset~\cite{cub}  and PASCAL3D+ Car dataset~\cite{pascal3d}}}
\label{fig:comp_cmr}
\vspace{-4.0mm}
\end{figure*}


\subsection{Real Images}
\vspace{-1.5mm}

\paragraph{Experimental settings:}  We next test our method on real images. Since real images generally do not have multiview captures for the same object, it would be very hard to infer precise light because light and texture would be entangled together. Following CMR~\cite{kanazawa2018learning}, we adopt CUB bird dataset~\cite{cub} and PASCAL3D+ car dataset~\cite{pascal3d}, predicting shape and texture from a single view image.

\vspace{-3mm}
\paragraph{Results:}
We compare our method with CMR~\cite{kanazawa2018learning}. Instead of predicting texture flow, we predict texture map directly. Both two methods use GT cameras estimated from structure from motion. Table \ref{tbl:real} provides quantitative evaluation of predicted texture and shape on CUB bird dataset. Our show better shape and key points predictions than CMR. While the loss of texture predictions are the same, Fig. \ref{fig:comp_cmr} shows qualitative improvements our method provides. Our textures are of higher fidelity and more realistic. This is because we predict a whole image as the texture map while CMR~\cite{kanazawa2018learning} adopts N3MR~\cite{NMR}, which uses face color as the texture and so the restricted face size results in blurriness. For car prediction, both two methods clearly posses poor artifacts. This is because the segmentation in PASCAL3D+ car dataset is estimated from Mask R-CNN~\cite{maskrcnn}, which is not perfect. In addition, the car textures have more details than birds, which make it very hard to learn good shape and texture. Despite these facts, the visual quality our of predictions continues to display a marked improvement. %
 

\begin{figure*}[t!]
\vspace{-0.5mm}
\centering
\includegraphics[width=\textwidth,trim=0 0 490 10,clip]{figures/GAN/GAN_2rows_nosil.png}
\vspace{-6mm}
\caption{{\footnotesize Samples from our 3D GAN trained on car images, from 2 viewpoints (shown in each column).}}
\label{GAN_sample}
\vspace{-2mm}
\end{figure*}


\begin{figure*}[t!]
\vspace{-2.5mm}
\includegraphics[width=\textwidth,trim=0 0 490 0,clip]{figures/GAN/GAN_interp_2rows.png}
\vspace{-5.5mm}
\caption{\footnotesize Renderings of objects produced by interpolating between latent codes of our 3D GAN, from 2 views}
\label{GAN_inter}
\vspace{-6mm}
\end{figure*}

\vspace{-3mm}
\subsection{3D GAN of Textured Shapes via 2D Supervision}
\vspace{-1.5mm}
\paragraph{Experimental settings:}  We first train the networks to only predict shape, by only passing gradients back through the silhouette prediction. We then fix the shape prediction and only train to produce textures. We perform this experiment on the car class. Images from 4 primary views are rendered for each predicted mesh in each training iteration, and concatenated together when passed to rendered image discriminator to force generation of objects in a canonical pose.

\vspace{-3mm}
\paragraph{Results:}
We show the results of randomly sampling from our learned distribution of car shapes and textures in Fig~ \ref{GAN_sample}. This figure demonstrates the high quality of of shape and texture generations, in addition to their diversity. We also show the result of rendering meshes produced from interpolation between latent codes in Fig~\ref{GAN_inter}, to demonstrate the robust nature of our learned distribution. 


 

\vspace{-5mm}
\section{Conclusion}
\vspace{-4mm}
In this paper, we proposed a complete rasterization-based differentiable renderer for which gradients can be computed analytically. Our framework, when wrapped around a neural network, learns to predict shape, texture, and light from single images. We further showcase our framework to learn a generator of 3D textured shapes. 


\small
\paragraph{Acknowledgement}
\vspace{-4mm}
Wenzheng Chen wants to thank the support of DARPA under the REVEAL program and NSERC under the COHESA Strategic Network.

\bibliography{main}
\bibliographystyle{plain}
\end{document}
