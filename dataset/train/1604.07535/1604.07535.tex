
\documentclass{llncs}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\pagestyle{myheadings}
\newtheorem{comment}{Comment}
\newtheorem{procedure}{Procedure}
\newtheorem{algorithm}{Algorithm}
\usepackage{lineno}
\def\linenumberfont{\normalfont\small}
\newcommand{\hide}[1]{}
\newcommand{\QED}{\hfill}
\usepackage{color}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\usepackage{soul} 

\begin{document}
\title{The -Center Problem in Tree Networks Revisited}\author{Aritra Banik \inst{1}
\and Binay Bhattacharya\inst{2}
\and Sandip Das\inst{1}
\and Tsunehiko Kameda \inst{2}
\and Zhao Song \inst{3}
}
\institute{Advanced Computing and Microelectronics Unit, Indian Stat. Inst., Kolkata, India \and School of Computing Science, Simon Fraser University, Burnaby, Canada \and Department of Computer Science, University of Texas, Austin, U.S.A.
}

\maketitle

\begin{abstract}
We present two improved algorithms for weighted discrete -center problem
for tree networks with  vertices.
One of our proposed algorithms runs in  time.
For all values of ,
our algorithm thus runs as fast as or faster than the most efficient  time
algorithm obtained by applying Cole's speed-up technique~\cite{cole1987}
to the algorithm due to Megiddo and Tamir~\cite{megiddo1983c},
which has remained unchallenged for nearly 30 years.

Our other algorithm,
which is more practical,
 runs in  time,
and when  it is faster than Megiddo and Tamir's 
time algorithm~\cite{megiddo1983c}.
\end{abstract}


\section{Introduction}\label{sec:introduction}
Deciding where to locate facilities  to minimize the communication or travel costs
is known as the {\em facility location problem}.
It has attracted much research interest since the publication of
the seminal paper on this topic by Hakimi~\cite{hakimi1964}.
For a good review of this subject, the reader is referred to \cite{hale2003}.
It can be applied to locate fire stations, distribution centers, etc.

In the {\em -center problem},
 centers are to be located in a network ,
so that the maximum (weighted) distance from
any demand point to its nearest center is minimized.
The simplest version of the problem (V/V/p) allows centers to be
located only on vertices (V), and
restricts demand points to be vertices.
Other variations allow points on edges to be demand points
(V/E/p), or points on edges (E) to be centers (E/V/p), or both (E/E/p).
The vertices of a network could be weighted,
i.e., the vertex weights can be different,
or unweighted.
In this paper we refer to weighted E/V/p as the {\em weighted discrete} -center problem ({\em WDC}).
The -center problem in a general network is NP-hard~\cite{kariv1979b}.
In this paper, we focus on  the tree networks,
on which there has been very little progress (for arbitrary ) since the mid-1980s.

\subsection{Previous work}
Megiddo~\cite{megiddo1983a} solved E/V/1 for the tree networks
in  time,
where  is the number of vertices.
Megiddo and Tamir also studied this problem~\cite{megiddo1983c}.
Kariv and Hakimi \cite{kariv1979b} presented
an  time algorithm for WDC in a general network,
where  is the number of edges.
Tamir \cite{tamir1988} improved the above bound to ,
where  is the inverse of Ackerman's function.
Recently, Bhattacharya and Shi~\cite{bhattacharya2014b} improved it to
 for ,
where  denotes the iterated logarithm of .
A recent result on Klee's measure due to Chan~\cite{chan2013} implies that
this bound can be further improved to .



Frederickson \cite{frederickson1990,frederickson1991b} solved the unweighted
V/V/p, E/V/p and V/E/p problems in  time, independently of .
For the weighted tree networks, linear time algorithms have been proposed
in the case where  is a constant~\cite{benmoshe2006,shi2008}.
For arbitrary , Kariv and Hakimi~\cite{kariv1979b} gave an exhaustive  time
algorithm.
Megiddo's linear time feasibility test~\cite{megiddo1981} can be parameterized
to solve the problem in  time,
using the idea introduced in \cite{megiddo1981}.
Megiddo and Tamir~\cite{megiddo1983c} then provided
an  time algorithm,
which can be made to run in  time using the AKS or similar
 sorting networks~\cite{ajtai1983,goodrich2014,seiferas2009},
together with Cole's improvement~\cite{cole1987}.
The  time algorithm due to Jeger and Kariv~\cite{jeger1985}
is faster than all others if .

The running time of the algorithm of Megiddo and Tamir~\cite{megiddo1983c}
is dominated by the time for computing the distance queries in their binary-search based algorithm.
Frederickson \cite{frederickson1990,frederickson1991b} used parametric search
to design optimal algorithms for the unweighted -center problem in tree networks.
In parametric search,
one first designs an {-{\em feasibility} test to see if  centers can be placed
in such a way that every vertex is within {\em cost} (=distance weighted by the weight of the vertex)
 from some center.
In general, a set of candidate values for  is explicitly or implicitly tested
as the algorithm progresses.
Eventually, the search will settle on the smallest  value, .
The ideas presented in \cite{frederickson1990,frederickson1991b} are for the unweighted case only,
and therefore cannot be extended easily to WDC.
The question of whether an algorithm which runs faster than  time
is possible for the tree networks has been open for a long time since.

To present our basic approach clearly,
we first solve WDC for balanced binary tree networks.
We then generalize it to general (unbalanced) tree networks based on {\em spine tree decomposition}~\cite{benkoczi2004,benkoczi2003}.


\subsection{Our contributions:}
Our major contributions in this paper are
(i) an  time algorithm for testing -feasibility for an arbitrary ,
with preprocessing that requires  time,
(ii) a practical  time WDC algorithm,
which outperforms the  time algorithm proposed in~\cite{megiddo1983c}
when ,
and
iii)  an  time WDC algorithm based on AKS-like sorting
networks~\cite{ajtai1983,goodrich2014,seiferas2009},
which improves upon the currently best  time algorithm~\cite{cole1987,megiddo1983c}.

The rest of the paper is organized as follows.
In Section~\ref{sec:preliminary} we first define the terms that are used throughout the paper.
We then give a rough sketch of our parametric search approach to solving WDC on balanced tree networks.
We also propose our location policy that guides the placement of the centers.
Section~\ref{sec:preproc} describes preprocessing that we perform,
in particular, the computation of upper envelopes and
a preparation for fractional cascading.
We then present in Section~\ref{sec:feasibility} the details of the feasibility test
part of parametric search for balanced tree networks.
The optimization part of parametric search is discussed in detail in Section~\ref{sec:optimal}
for balanced tree networks.
At the end of the section,
we present our results for the general (unbalanced) tree networks.

\section{Preliminaries}\label{sec:preliminary}

\subsection{Definitions}\label{sec:def}
Let  denote a tree network,
where each vertex  has weight 
and each edge  has a non-negative length.
We write , if point  lies anywhere in , be it on an edge or at a vertex.
For , 
let  denote the unique path from  to ,
and  its length.
If  or  is on an edge,
its prorated length is used.
If  is a binary rooted with root vertex ,
for any vertex , 
the subtree rooted at  is denoted by ,
and the parent of  is denoted by .

For a non-leaf vertex ,
let  (resp. ) denote its left (resp. right) child vertex,
and define the left (resp. right) {\em branch} of  by
 (resp. ).
We thus have ,
and the root of  (resp. ) is  with degree 1
in  (resp. ).

Let  and .
We define the distance between a point  and  by

The {\em cost} of a vertex  at point  is given by .
We say that point  {\em -covers} 
if .
If  is clear from the context, we may simply say that  {\em covers} .
A problem instance is said to be {\em -feasible} if there exists  centers
such that every vertex is -covered by at least one of the centers.
Those  centers are said to form a {\em p-center}~\cite{kariv1979b}. 
For a vertex  and points ,
we define the {\em upper envelope}

If , 
then vertex  is said to be an -{\em critical vertex} in  with respect to ,
and is denoted by .  
If  is clear from the context,
we may call it just a critical vertex

\subsection{Spine tree decomposition and upper envelopes}\label{sec:std}
We give a brief review of {\em spine tree decomposition}~\cite{benkoczi2004,benkoczi2003}.
The materials in this subsection is not needed until Sec.~\ref{sec:general}.
We can assume that given  is a binary tree;
otherwise we can introduce  vertices of 0 weight and  edges of
0 length to make it binary.
Thus each vertex has degree at most 3.
Let  be the root of ,
which can be chosen arbitrarily.
Traverse , starting on an edge incident to .
At each vertex visited,
move to the branch that contains the largest number of leaf vertices,
breaking a tie arbitrarily.
When a leaf vertex, , is reached, the path  is generated,
and it is called the {\em top spine}, denoted by .
We then repeat a similar traversal from each vertex on the generated spine,
to generate other spines, until every vertex of  belongs to some spine.

Let  denote the tree constructed by the spine tree decomposition of tree ,
together with the {\em search tree}  for each {\em spine} ,
whose root is denoted by ~\cite{benkoczi2004,benkoczi2003}.
Fig.~\ref{fig:uppEnvTree}  illustrates a typical structure of spine  and
its search tree .
The horizontal line represents spine ,
and we name the vertices on it   from left to right. 
\begin{figure}[ht]
\centering
\includegraphics[height=2.5cm]{figs/uppEnvTree.pdf}
\caption{Search tree  for spine .
 and . 
}
\label{fig:uppEnvTree}
\end{figure}
The triangles represent subtrees hanging from .
If a hanging subtree  is connected to vertex ,
then we call the subgraph consisting of , , and the edge connecting them a {\em branch}
of  and denote it by .
Since we assume that the vertices of  have degree at most 3,
there is at most one branch hanging from any vertex on the spine.
 
For a node\footnote{A `node' is more general than a vertex of .
A vertex is also a node, because it belongs to ,
but not every node is a vertex.}
 in ,
let  (resp. ) denotes the leftmost
(resp. rightmost)\footnote{Right (resp. left) means towards (resp. away from)
the parent spine  of .}
 vertex on  that belongs to the subtree .
We introduce upper envelope  (resp. )
for the costs
of the vertices in the branches of  that belong to ,
for point  that lies to the right (resp. left) of vertex  (resp. ). 
See Fig.~\ref{fig:uppEnvTree}.
Since  and  are upper envelopes of linear functions,
they are piecewise linear.
For each node  of  we compute  and ,
and store them at  as sequences of bending points
(their  and  coordinates).
These upper envelopes can be computed in  time
by the following lemma.
\begin{lemma}\label{lem:std}{\rm \cite{benkoczi2004,benkoczi2003}}
The path from any leaf to the root of  has  nodes on it.
\QED
\end{lemma}

\subsection{Our approach}\label{sec:approach}
Except in the last subsection of the paper,
we assume that the given tree  is balanced with respect to its root ,
so that its height is .
If not, we can use spine tree decomposition that transforms  in linear time to a structure
that has most of the properties of a balanced binary tree.
Working on a balanced binary tree network also helps us to explain the essence of our approach,
without getting bogged down in details. 
Our algorithms consist of a lower part and an upper part.
In the lower part, we test -feasibility for a given cost ,
and in the upper part we carry out Megiddo's {\em parametric search}~\cite{megiddo1979}.
To perform a feasibility test,
we first identify the -{\em peripheral centers},
below which no center needs be placed.
Once all the  -peripheral centers are identified,
we place  additional centers to -cover the vertices
that are not covered by the -peripheral centers.
If no more than  centers are used to -cover the entire tree ,
then the -feasibility test is successful.
Theorem~\ref{thm:feasibility} shows that, using fractional cascading, -feasibility can be tested
in  time
after preprocessing, which takes  time.

The second part of parametric search
finds the smallest  value, .
We work on  bottom-up, doing essentially the same thing as in the first part.
Whenever  is used in the first part,
we need to invoke an -feasibility test~\cite{megiddo1979}.
At each level of ,
we need to invoke -feasibility tests  times at level .
Therefore the total number of invocations is ,
and the total time is  after preprocessing,
yielding one of our main results stated in Theorem~\ref{thm:main}.

\subsection{Center location policy}
Suppose that we want to place a center  in a tree network  to -cover
a subset  of vertices that are connected.
We propose the following location policy.

\medskip\noindent
{\bf Root-centric policy:}
{\em Place  at the point that -covers all the vertices in  and is closest to root  of .}


It is easy to prove the following lemmas.
\begin{lemma}\label{lem:location}
If a set of  centers -covers all the vertices in ,
then there is a partition of vertex set ,
where each  is the vertex set of a connected part of ,
such that the root-centric location policy locates each center  that -covers .
\QED
\end{lemma}
\hide{\begin{proof}
Consider a set  of centers that together -covers ,
but some centers violate the root-centric location policy.
For each , 
let  be the set of vertices that are closer to  than to any other center.
If there is a tie, then the tie should be broken arbitrarily.
It is clear that  is -covered by .
We now move  towards the root  as far as possible without affecting its coverage
of .
The resulting centers  satisfy the root-centric location policy.
\end{proof}
}

\begin{lemma}\label{lem:Rcentric}
Let   be  centers obeying the root-centric policy
that together -cover .
For each center , find a vertex  with maximum cost 
that is the farthest from the root,
and name it .
Then it satisfies .
\end{lemma}
\begin{proof}
If , then  could move closer to ,
a contradiction.
\QED
\end{proof}


\section{Preprocessing}\label{sec:preproc}

\subsection{Upper envelopes}
According to our definition of upper envelope  for subtree  (see (\ref{eqn:uppEnv0})),
if  is a leaf vertex, we have

for any .
Let  (resp. ) be the left (resp. right) child vertex of a non-leaf vertex .
Then for any , we have

Function  is piecewise linear in  and can be represented by a sequence of
bending points.
In the sequence representing ,
in addition to the values of  at the bending points,
we insert the values of  evaluated at all the  vertices on .\footnote{We mix
those values among the bending points,
so that we know on which edges the bending points lie.}
\begin{lemma}\label{lem:envelope}
If  is balanced, then 
 can be computed bottom-up in  time
and  space.
\QED
\end{lemma}

In the rest of this paper we assume that the given tree  is a balanced binary tree.
If not we can use spine tree decomposition~\cite{benkoczi2004,benkoczi2003,bhattacharya2012b},
which shares many useful properties of a balanced tree.



\subsection{Fractional cascading}\label{sec:fractional}

From now on we assume that we have the bending points of
 at our disposal.
The second task of preprocessing is to merge the bending points of 
to prepare for fractional cascading~\cite{chazelle1986a}.
Again we do this bottom up, 
merge-sorting the two sequences of bending points into one at each vertex.
Since each vertex causes at most  bending points in ,
the total number of bending points is .


\section{-Feasibility}\label{sec:feasibility}

\subsection{Peripheral centers}\label{sec:Pctrs}
As a result of preprocessing,
we have the upper envelopes .
To find the peripheral centers, -peripheral 
we carry out {\em truncated} pre-order DFS (depth-first-search),
looking for the vertex-point pairs  satisfying ,
which means  is an -critical vertex in  with respect to .

\begin{procedure}{\tt Find-Peripheral-Centers}\label{proc:findPC}

~\noindent
Perform pre-order DFS, modified as follows,
where  is the vertex being visited.
\begin{enumerate}
\item
If  such that ,
return  as an -peripheral center,\footnote{We assume that the trivial case,
where one center at root  -covers the entire tree, is dealt with specially,
which is straightforward. 
}
and backtrack.
\item
If  -peripheral centers have been found, then return {\tt Infeasible} and stop.
\QED
\end{enumerate}
\end{procedure}
To carry out Step~1 efficiently,
we perform binary search with key  in the merged sequence
of bending points (of the upper envelopes) stored at the root ,
and follow the relevant pointers based on fractional cascading.

\begin{lemma}\label{lem:pathLength}
Procedure~{\tt Find-Peripheral-Centers} visits 
 vertices.
\end{lemma}
\begin{proof}
The number of vertices that Procedure~{\tt Find-Peripheral-Centers}
visits is the largest when the -peripheral centers are as low as possible
and they separate from each other as high as possible.
This extreme case is illustrated in Fig.~\ref{fig:pathLength},
where  for some integer .
\begin{figure}[h]
\centering
\includegraphics[height=2.6cm]{figs/pathLength.pdf}
\caption{Illustration for the proof of Lemma~\ref{lem:pathLength}.}
\label{fig:pathLength}
\end{figure}
The total number of edges that are traversed is given by

where the second term, , is an upper bound on the number of vertices at depth  or shallower.
\QED
\end{proof}

\begin{lemma}\label{lem:findPC}
If  
are available,
all the -peripheral centers can be found in  time.
\end{lemma}
\begin{proof}
If fractional cascading is used in Step~1 of Procedure~\ref{proc:findPC},
it runs in amortized constant time per vertex.
The rest follows from Lemma~\ref{lem:pathLength}.
\QED
\end{proof}

\subsection{-Feasibility test}\label{sec:test}
Given an  value,
suppose that we have found  -peripheral centers,
following the root-centric location policy.
We replace each -peripheral center by a {\em dummy vertex},
and define the {\em trimmed tree} .
Its vertex set  consists of two types of vertices:
the {\em first type} is a vertex that lies on the path between a dummy vertex and root , inclusive.
If any such vertex has only one child vertex among them,
then the other child vertex of  (called a vertex of the {\em second type}) is kept in 
to represent the -critical vertex in the subtree of  rooted at that vertex.
In what follows, we use  instead of  for simplicity,
since the implied  will be clear from the context.
It is easy to see that tree  contains  vertices.
Without loss of generality,
we consider each vertex of the second type as the right child of its parent.

Let  be a vertex of the second type.
Then we must have visited  during the execution of {\tt Find-Peripheral-Centers},
and no -peripheral center was placed in subtree .
At the time of this visit,
we identified the -critical vertex in ,
which implies that we can store this -critical vertex at  as a by-product of
{\tt Find-Peripheral-Centers} at no extra cost.

Later, we will be introducing more centers, in addition to -peripheral centers,
working on the trimmed tree  bottom up.
For each vertex in ,
its subtrees can be one of the following types:
\begin{enumerate}
\item[-]
-subtree: The centers in it, if any, do not -cover all the vertices in the subtree.
\item[-]
-subtree: The centers in it -cover all the vertices in the subtree, and possibly outside it.
\end{enumerate}


If  is a -subtree,
let  denote the distance from  to the highest center in 
at or below .
See the leftmost figure of Fig.~\ref{fig:covering1},
where  (resp. ) is the left (resp. right) child vertex of ,
and  (resp. ) is the highest center placed in  (resp. ).
\begin{figure}[ht]
\centering
\includegraphics[height=2.6cm]{figs/++a.pdf}
\hspace{8mm}
\includegraphics[height=2.6cm]{figs/m-a.pdf}
\hspace{8mm}
\includegraphics[height=2.6cm]{figs/+-a.pdf}
\caption{(Left)  and ; 
(Middle) A center is needed within  from ;
(Right) .
}
\label{fig:covering1}
\end{figure}
If  is a -subtree,
on the other hand,
let  denote the minimum distance from  to a point above 
within which a center must be placed to -cover the uncovered vertices in .
See the middle figure in Fig.~\ref{fig:covering1}.


Let us discuss how to process the trimmed tree ,
to introduce additional centers closer to the root in order to -cover more vertices.
We perform post-order DFS on ,
always visiting the left child of a vertex first.
Assume that we explored  first and then ,
and we are just back to ,
and that  or  (resp.  or )
are available at vertex  (resp. ).
For each dummy leaf vertex  of ,
we have .
At each vertex  visited, we have one of the following three cases.

(a) {\bf [Both are -subtrees]}
In the leftmost figure of Fig.~\ref{fig:covering1},
 (resp. ) is the highest center in  (resp. ).
We compute 

which is the distance from  to the nearest center in .
If ,
then  is -covered by  or . 
Otherwise (i.e., even the center in  that is nearer to  cannot -cover )
 must be covered by a center placed above ,
and  now becomes a -subtree of .

(b) {\bf [Both are -subtrees]} See the middle figure of  Fig.~\ref{fig:covering1}.
If ,
for example,
we need to place a center  on the edge , 
and  now becomes a -subtree,
provided  is -covered by .
If both  and  are placed this way,
we set ,
provided one of them -covers .
If no center needs to be placed on  or ,
then we compute

We need a center within  above .
These are some of the typical cases,
which illustrate kinds of necessary operations.
Procedure~{\tt Merge}, given below,
deals with the other cases as well, not mentioned here,
exhaustively.

(c) {\bf [One is a -subtree and the other is a -subtree]}
We assume without loss of generality that the left (resp. right) subtree is
a -subtree (resp. -subtree), as shown in the rightmost figure of  Fig.~\ref{fig:covering1},
and  is the highest center in .
As in Case (b),
we first test if ,
and if so place a center  on edge .
Then we have case (a).
Otherwise,
we need to test if  -covers the uncovered vertices in 
as well as .
If not, they must be covered by a new center above .

We now present a formal procedure that deals with all possible cases.
We will use it for .
\begin{procedure} {\tt Merge}\label{proc:merge}

\smallskip\noindent
{\bf Case (a):}
{\rm []}
Compute  using (\ref{eqn:updateDelta+}).
If ,
then set . 
Otherwise, make  a -subtree of  with .

\smallskip\noindent
{\bf Case (b):}
{\rm []}
If 
(resp. ),
place a center  (resp. )
on the edge , (resp. ) at distance  from 
(resp.   from ).
If  and/or  -covers ,
then make  a -subtree of  with
 ,
where  (resp. ) if
 (resp. ) is not introduced.
If neither of them covers ,
then make  a -subtree of  with .
If neither  nor  is introduced,
then compute  using (\ref{eqn:newDelta-})
and make  a -subtree of  with .


\smallskip\noindent
{\bf Case (c):}
{\rm []}\footnote{The case {\rm []}
 is symmetric.}
If ,
then place a center  on edge  at distance  from ,
set

and go to Case (a).
Otherwise,
\begin{enumerate}
\item[(i)]
If  covers  (i.e.,
),
and  also covers  (i.e.,
),
then  let .
\item[(ii)]
In all the remaining cases, set
.
\QED
\end{enumerate}
\end{procedure}

It is easy to show that
\begin{lemma}\label{lem:merge}
After preprocessing,
{\tt Merge-I} runs in constant time.
\QED
\end{lemma}

We now formally state our algorithm for testing -feasibility.
\begin{algorithm}{\tt Feasibility-Test}\label{alg:feasibility}
\begin{enumerate}
\item
Call {\tt Find-Peripheral-Centers}.
\item
Construct the trimmed tree , 
consisting of the vertices of the first type and those of the second type
and the edges connecting them.
For each vertex  of the second type,
compute the -critical vertex for .
\item
Perform a post-order depth-first traversal on ,
invoking {\tt Merge} on each vertex  visited.
\item
If a set of no more than  centers covering  has been found,
then return {\tt Feasible} and stop.
If the  centers found so far do not totally cover ,
then return {\tt Infeasible} and stop.
\QED
\end{enumerate}
\end{algorithm}

\begin{theorem}\label{thm:feasibility}
For a balanced tree network, 
{\tt Feasibility-Test} runs in  time,
excluding the preprocessing time.
\end{theorem}
\begin{proof}
Step~1 runs in  time by Lemma~\ref{lem:findPC}.
Step~2 can be carried out at the same time as Step~1 in  time.
Step~3 also runs in  time  by Lemma~\ref{lem:merge}.
Lastly, Step~4 takes constant time.
\QED
\end{proof}


\section{Optimization}\label{sec:optimal}
We will employ Megiddo's parametric search~\cite{megiddo1979},
using the -feasibility test we developed in Sec.~\ref{sec:test}.
We maintain a lower bound  and an upper bound  on ,
where .
Eventually we will end up with .
If we succeed (resp. fail) in an -feasibility test, then it means that 
(resp. ), so we update  (resp, )
to .

\subsection{Balanced tree networks}\label{sec:practical}
Based on Theorem~\ref{thm:feasibility},
the main theorem in~\cite{megiddo1979} implies
\begin{theorem}\label{thm:practical}
WDC for the balanced tree networks with  vertices can be solved in 
 time.
\QED
\end{theorem}

We propose another algorithm which performs better than the first algorithm
referred to in the above theorem for some range of values of .
For this algorithm we will show later that we need to test feasibility  times.
This fact, together with Theorem~\ref{thm:feasibility}, leads to the following theorem.
\begin{theorem}\label{thm:main}
WDC for the balanced tree networks with  vertices can also be solved in 
 time.
\QED
\end{theorem}

In the rest of this subsection we prove Theorem~\ref{thm:main}.
Let  be the {\em levels} of  from top to bottom,
where the root  is at level 1 and  the leaves are at level .
At each vertex, we need to perform a few feasibility tests.
Since there are  vertices at level  of ,
using prune and search, 
we can know the results of the feasibility tests at all the vertices of level 
after actually performing only  feasibility tests.
The total for all levels is thus ,
as claimed above.

It is easy to prove the following lemma.
\begin{lemma}\label{lem:eqCost}
Let .
\begin{enumerate}
\item[(a)]
{\rm \cite{kariv1979b}}
Vertices  and  have the equal cost

at a point .
\item[(b)]
Let , and
suppose that , and let  without loss of generality.
If  holds,
then vertices  and  have the equal cost

at a point . 
If ,
then vertex  has a higher cost than  at all points on .\footnote{In this case,
the equal cost point lies on .}
\QED
\end{enumerate}
\end{lemma}

If we let  in Case (b) in the above lemma,
 and  have the equal cost

at a point .

We now need to modify the definition of the critical vertex given in Sec.~\ref{sec:def}.
With respect to ,
we are interested in the vertex , 
such that  is maximum,
We call such a  the {\em critical vertex} with respect to  and denote it by .
The main difference of the optimization part from the feasibility test part
is that we cannot find the exact locations of the centers until the very end.
However, making use of critical vertices, it is possible to identify
the component of  that is to be -covered by each new center.
So, we will isolate/detach them one by one from ,
and repeat the process.

Let  and  be the two child vertices of a vertex  at level .
When we visit , moving up ,
we need to either isolate a subtree to be covered by a center
that lies below ,
or determine the critical vertex in  to be carried higher.
Whenever the result of an -feasibility test shows that ,
we update  and assume that  holds,
and introduce a new center (without an exact location),
as necessary.
This assumption will be justified if  is updated later.
If  is never updated thereafter,\footnote{
may be updated.}
it implies that .
See Lemma~\ref{lem:finalAlpha}.

Based on (\ref{eqn:equalcost1}), if 

we assume that , 
and cut the edge  (resp. ) to detach a new component below 
to be covered by the new center placed in it.\footnote{Note that if
, for example,
we cannot isolate a component.}
We need not know the exact position of the new center.
If two new centers are introduced this way,
vertex  must be -covered by a center placed above ,
and  becomes a (tentative) critical vertex for  with respect to  above .
If only one of the inequalities in (\ref{eqn:test10}) holds and only  (resp. ) is cut,
then either  or  (resp. ) becomes a critical vertex for ,
based on the outcome of -feasibility test.
See (\ref{eqn:equalcost4}).

Consider the remaining case,
 where neither inequality in (\ref{eqn:test10}) holds.
We need to determine a critical vertex in  with respect to  above .
\begin{figure}[ht]
\centering
\includegraphics[height=2cm]{figs/++c.pdf}
\includegraphics[height=2cm]{figs/m-c.pdf}
\caption{The cost lines of  and  intersect at 
above :
(Left) Cost  at intersection  is higher than  (); 
(Right) .
}
\label{fig:++c}
\end{figure}
To this end,
we first find the intersection  of the two cost lines
 and ,
and its cost ,
assuming the condition for
(\ref{eqn:equalcost2}) is met.
We then test -feasibility.
If , as in the left figure of Fig.~\ref{fig:++c},
then we set  (resp. )
if  (resp. ).
If , on the other hand, as in the right figure of Fig.~\ref{fig:++c},
then we set  (resp. )
if  (resp. ).
In order to find the true critical vertex  in place of ,
we need to take  into consideration as well.
This time we use  of (\ref{eqn:equalcost4}) instead of (\ref{eqn:equalcost2}).
In the future we will be testing vertices  to see if the cost of the intersection 
between  and  
is lower than  or not.
We must choose the critical vertex that gives the highest cost near ,
which is indicated by a thick line segment in Fig.~\ref{fig:++c}.

In any case, we need to perform a constant number of feasibility tests per vertex visited.
Whenever an -feasibility test in (\ref{eqn:test10})
succeeds (resp. fails),
we update  (resp. ) to .
\begin{lemma} \label{lem:finalAlpha}
The optimal cost  equals  at the end of the above steps.
\end{lemma}
\begin{proof}
It was shown by Kariv and Hakimi~\cite{kariv1979b} that  has the value
 for some pair of vertices  and .
See Lemma~\ref{lem:eqCost}(a). 
It is clear that the above steps partition the vertex set to  maximal subsets

such that each subset  can be -covered by a center.
The value of  at the end of our algorithm is
from the last -feasibility test that reduced .
Assume that  and there is a pair of
vertices  and  in the same subset such that  ,
but we haven't tested them. 
We derive a contradiction to this assumption.

Let us examine how each  was formed.
Bottom-up, we constructed the upper bound on the cost functions of the vertices.
As we moved higher, we tested (\ref{eqn:test10}) for each vertex  in ,
and  was updated as a result.
Since critical vertices  (resp. ) is used in
(\ref{eqn:test10}), this  is the smallest possible cost to cover .
 \QED
\end{proof}




\subsection{General tree networks}\label{sec:general}
We use spine tree decomposition (STD),
reviewed in Sec.~\ref{sec:std},
 for general (unbalanced) tree networks.
The counterparts to Theorems~\ref{thm:feasibility} and \ref{thm:practical} hold
with the same complexities.
\begin{theorem}\label{thm:general1}
\begin{enumerate}
\item[(a)]
We can test -feasibility in  time,
excluding the preprocessing,
which takes  time.
\item[(b)]
WDC for the general tree networks with  vertices can be solved in 
  time.
\end{enumerate}
\end{theorem}
\begin{proof}
Part(a) can be proved in essentially the same way
as we proved Theorem~\ref{thm:feasibility} in Sec.~\ref{sec:test}.
Instead of working directly on the given tree ,
we first construct  and compute upper envelopes at its nodes.
The concepts of the -subtree and -subtree can be carried
over to .
One complication is that we need to work on a group of -branches,
instead of single -subtrees,
but we can process them in the same order of time as in the balanced tree case.
Part (b) is implied by part (a) by the main theorem in Megiddo~\cite{megiddo1979}.
\QED
\end{proof}

As for the counterpart to Theorem~\ref{thm:main}, 
we need to use AKS-like sorting networks~\cite{ajtai1983,goodrich2014,paterson1990,seiferas2009},
as in~\cite{cole1987}.

\begin{theorem}\label{thm:general2}
WDC for the general tree networks with  vertices can be solved in
  time.
\end{theorem}
\begin{proof}
~[Informal]
Let us first analyze how many times we need to perform feasibility tests
when {\it STD} is used for a non-balanced tree network.
Let  be the number of vertices in the spines at level ,
so that we have ,
where  is the number of levels in {\it STD}.
We now consider one particular spine  at level .
Let  and  be two vertices on ,
from which branches  and  hang.
Assume first that both  and  are -branches,
and let  (resp. ) be the -critical vertices in
 (resp. ).
If  is at distance  from ,
then we map it onto  at distance  from .
\begin{figure}[ht]
\centering
\includegraphics[height=22mm]{figs/m-d.pdf}
\caption{ and  are each a -branch. 
}
\label{fig:--d}
\end{figure}
There can be up to two such positions on  (or its extension if it is not long enough),
and we call the lower (resp. higher)\footnote{Lower (resp. higher) means farther (resp. nearer) from/to
the root.}
one  (resp. ).
Fig.~\ref{fig:--d} illustrates  and .
In this figure each cost function 
is represented by a solid and a dashed line,
where the solid (resp. dashed) part shows its value on  (in ).
Similarly for the cost function .
In this figure, they meet at  on ,
and at this point the cost is .
This implies that ,
where  (resp. ) is the point on  where the cost of
 (resp. ) is .
This in turn means that a single center cannot -cover both 
and .
If we had ,
then a center would cover both of them.

Consider next the case where  is a -branch and  is a -branch,
as shown in Fig.~\ref{fig:+-d}.
\begin{figure}[ht]
\centering
\includegraphics[height=22mm]{figs/+-e.pdf}
\caption{
Point  is the mapped image onto  of the highest center in .
}
\label{fig:+-d}
\end{figure}
In this case, the dashed part of the cost function 
takes the value  at ,
which means that  is a -branch.
The two cost functions  and 
 intersect at  in their dashed parts,
which implies that they meet in .
Since the corresponding cost  is larger than  in this figure,
a center at  cannot -cover .

The above discussion implies that whether the cost at the intersection of two cost lines
is higher or lower than ,
which can be tested by a feasibility test, 
determines if an additional center needs to be introduced or not.
Each feasibility test determines the relative order of , etc.,
for all vertices on spine .
This is tantamount to sorting , etc.,
which we can do by a sorting network, such as the AKS sorter.
By examining the sorted sequence, 
and scanning  from its lower end,
we can determine the number of centers needed on .
 

Finally, we need to find the -critical vertex that represents the part of spine 
not covered by the centers introduced so far,
or the center that could cover additional vertices in the next higher spine.
Namely,
spine  may become a -branch or a -branch {\em vis-\`{a}-vis}
the next higher spine.
If it becomes a -branch,
there may be several candidates for the -critical vertex.
The situation is somewhat to that depicted in the left figure in Fig.~\ref{fig:++c},
where  and  are the two candidates.
The -critical vertex is whichever candidate whose cost line reaches  first,
i.e., at the lowest position.

If  becomes a -branch in the next higher spine,
we want to find the -critical vertex in  that can cover the ``farthest'' vertex
in the next higher spine.
Therefore, among the candidate critical vertices we pick the one whose cost line reaches  last,
i.e., at the highest position..

Following Megiddo~\cite{megiddo1983c},
for each spine we employ an AKS sorting network.
The number of inputs to the AKS sorting networks employed at level  is thus .
Each such AKS sorting network has  layers of comparators,
and their sorted outputs can be computed with  calls to a feasibility test
with Cole's speed up~\cite{cole1987}.
The total number of calls at all levels  with Cole's speed up is thus
.
Since ,
we have .
Since each feasibility test takes  by Theorem~\ref{thm:feasibility}
(extended to {\it STD}),
the total time spent by the feasibility tests is .
In addition, we need time to compute the median at each layer of the AKS networks,
which is  per layer and  at level .
Summing this for all levels, we get
. 
\QED
\end{proof}


\section{Conclusion and Discussion}\label{sec:conclusion}
We have presented an algorithm for the weighted discrete -center problem
for tree networks with  vertices,
which runs in  time.
This improves upon the previously best  time algorithm~\cite{cole1987}.
The main contributors to this speed up are spine tree decomposition,
which enabled us to limit the tree height to ,
and the root-centric location policy,
which made locating centers simple.
Fractional cascading helped to shave a factor of 
off the time complexity in Theorem~\ref{thm:feasibility}.
The  time algorithm~\cite{cole1987} and ours both
make use of the AKS sorting network~\cite{ajtai1983},
which is impractically large. 
However, recently AKS-like sorting networks with orders of magnitude reduced sizes
have been discovered~\cite{goodrich2014,seiferas2009},
and further size reduction in the not-so-distant future may make the above algorithms more practical.
We also presented a practical  time WDC algorithm,
which improves upon the  time algorithm~\cite{megiddo1983c}
when .

In Lemma~\ref{lem:envelope} we showed that it takes  time and space
to compute the set of bending point sequences for the upper envelopes at all the vertices.
Suppose that the weight of a vertex is increased arbitrarily,
which could influence the locations of some centers,
if the vertex becomes critical for a center.
We can test this situation without updating the upper envelopes,
and thus without increasing the time requirement.
Therefore, every -center query with the weight of one vertex
arbitrarily increased can be answered in  time.
This result realizes a sub-quadratic algorithm for the minmax regret -center problem
in tree networks~\cite{averbakh1997}.
\begin{thebibliography}{10}

\bibitem{ajtai1983}
M.~Ajtai, J.~Koml\'os, and E.~Szemer\'edi.
\newblock An  sorting network.
\newblock In {\em Proc. 15th ACM Symp. on Theory of Comput. (STOC)}, pages
  1--9, 1983.

\bibitem{averbakh1997}
I.~Averbakh and O.~Berman.
\newblock Minimax regret -center location on a network with demand
  uncertainty.
\newblock {\em Location Science}, 5:247--254, 1997.

\bibitem{benmoshe2006}
Boaz Ben-Moshe, Binay Bhattacharya, and Qiaosheng Shi.
\newblock An optimal algorithm for the continuous/discrete weighted 2-center
  problem in trees.
\newblock In {\em Proc. LATIN 2006}, volume LNCS 3887, pages 166--177, 2006.

\bibitem{benkoczi2004}
R.~Benkoczi.
\newblock {\em Cardinality constrained facility location problems in trees}.
\newblock PhD thesis, School of Computing Science, Simon Fraser University,
  Canada, 2004.

\bibitem{benkoczi2003}
R.~Benkoczi, B.~Bhattacharya, M.~Chrobak, L.~Larmore, and W.~Rytter.
\newblock Faster algorithms for -median problems in trees.
\newblock {\em Mathematical Foundations of Computer Science, Springer-Verlag},
  LNCS 2747:218--227, 2003.

\bibitem{bhattacharya2012b}
Binay Bhattacharya, Tsunehiko Kameda, and Zhao Song.
\newblock Minmax regret 1-center on a path/cycle/tree.
\newblock In {\em Proc. 6th Int'l Conf. on Advanced Engineering Computing and
  Applications in Sciences (ADVCOMP)}, pages 108--113, 2012.

\bibitem{bhattacharya2014b}
Binay Bhattacharya and Qiaosheng Shi.
\newblock Improved algorithms to network -center location problems.
\newblock {\em Computational Geometry}, 47:307--315, 2014.

\bibitem{chan2013}
Timothy~M. Chan.
\newblock Klee's measure problem made easy.
\newblock In {\em Proc. Symp. on Foundation of Computer Science (FOCS)}, pages
  410--419, 2013.

\bibitem{chazelle1986a}
Bernard Chazelle and Leonidas~J. Guibas.
\newblock Fractional cascading: {I. A} data structuring technique.
\newblock {\em Algorithmica}, 1:133--162, 1986.

\bibitem{cole1987}
R.~Cole.
\newblock Slowing down sorting networks to obtain faster sorting algorithms.
\newblock {\em J. ACM}, 34:200--208, 1987.

\bibitem{frederickson1990}
G.N. Frederickson.
\newblock Optimal algorithms for partitioning trees and locating  centers in
  trees.
\newblock Technical Report CSD-TR-1029, Purdue University, 1990.

\bibitem{frederickson1991b}
G.N. Frederickson.
\newblock Parametric search and locating supply centers in trees.
\newblock In {\em Proc. Workshop on Algorithms and Data Structures (WADS),
  Springer-Verlag}, volume LNCS 519, pages 299--319, 1991.

\bibitem{goodrich2014}
Michael~T. Goodrich.
\newblock Zig-zag sort: A simple deterministic data-oblivious sorting algorithm
  running in  time.
\newblock arXiv:1403,2777v1 [cs.DS] 11 Mar2014, 2014.

\bibitem{hakimi1964}
S.L. Hakimi.
\newblock Optimum locations of switching centers and the absolute centers and
  medians of a graph.
\newblock {\em Operations Research}, 12:450--459, 1964.

\bibitem{hale2003}
Trevor~S. Hale and Christopher~R. Moberg.
\newblock Location science research: A review.
\newblock {\em Annals of Operations Research}, 123:21--35, 2003.

\bibitem{jeger1985}
M.~Jeger and O.~Kariv.
\newblock Algorithms for finding -centers on a weighted tree (for relatively
  small ).
\newblock {\em Networks}, 15:381--389, 1985.

\bibitem{kariv1979b}
O.~Kariv and S.L. Hakimi.
\newblock An algorithmic approach to network location problems, part 1: The
  -centers.
\newblock {\em SIAM J. Appl. Math.}, 37:513--538, 1979.

\bibitem{megiddo1979}
N.~Megiddo.
\newblock Combinatorial optimization with rational objective functions.
\newblock {\em Math. Oper. Res.}, 4:414--424, 1979.

\bibitem{megiddo1983a}
N.~Megiddo.
\newblock Applying parallel computation algorithms in the design of serial
  algorithms.
\newblock {\em J. ACM}, 30:852--865, 1983.

\bibitem{megiddo1983c}
N.~Megiddo and A.~Tamir.
\newblock New results on the complexity of -center problems.
\newblock {\em SIAM J. Comput.}, 12:751--758, 1983.

\bibitem{megiddo1981}
N.~Megiddo, A.~Tamir, E.~Zemel, and R.~Chandrasekaran.
\newblock An  algorithm for the th longest path in a tree
  with applications to location problems.
\newblock {\em SIAM J. Comput.}, 10:328--337, 1981.

\bibitem{paterson1990}
M.S. Paterson.
\newblock Improved sorting networks with  depth.
\newblock {\em Algorithmica}, 5:75--92, 1990.

\bibitem{seiferas2009}
Joel Seiferas.
\newblock Sorting networks of logarithmic depth, further simplified.
\newblock {\em Algorithmica}, 53:374--384, 2009.

\bibitem{shi2008}
Q.~Shi.
\newblock {\em Efficient algorithms for network center/covering location
  optimization problems}.
\newblock PhD thesis, School of Computing Science, Simon Fraser University,
  Canada, 2008.

\bibitem{tamir1988}
A.~Tamir.
\newblock Improved complexity bounds for center location problems on networks
  by using dynamic structures.
\newblock {\em SIAM J. Discrete Mathematics}, 1:377--396, 1988.

\end{thebibliography}
\end{document}
