
\documentclass{article} \usepackage{iclr2020_conference,times}


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{array}
\usepackage{comment}
\usepackage{color}


\newcommand\pl[1]{\textcolor{red}{[PL: #1]}}



\usepackage{amsmath,amsfonts,bm}




\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{Eq.~(\ref{#1})}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\let\ab\allowbreak
 
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    

\usepackage[hidelinks]{hyperref}
\usepackage{url}            \renewcommand{\baselinestretch}{1.00}


\usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{amsmath,amsthm,amssymb,bm} \usepackage{xspace}
\usepackage{array}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{stmaryrd}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{times}
\usepackage[pdftex]{graphicx}
\usepackage{algorithm}
\usepackage{algorithmicx,algpseudocode}
\usepackage{hyperref}
\usepackage{sidecap}
\usepackage{wrapfig}
\usepackage{todonotes}
\usepackage{natbib}
\usepackage{colortbl}
\usepackage{arydshln}

\numberwithin{equation}{section}

\sidecaptionvpos{figure}{t}

\def\sint{\begingroup\textstyle\int\endgroup} 

\newcommand{\reals}{\mathbf{R}}
\newcommand{\integers}{\mathbf{Z}}
\newcommand{\naturals}{\mathbf{N}}
\newcommand{\rationals}{\mathbf{Q}}

\newcommand{\calr}{\mathcal{R}} 

\newcommand{\ind}[1]{1_{#1}} \newcommand{\pr}{\mathbb{P}} \newcommand{\ex}{\mathbb{E}} \newcommand{\var}{\textrm{Var}}
\newcommand{\cov}{\textrm{Cov}}
\newcommand{\sgn}{\textrm{sgn}}
\newcommand{\kl}{\textrm{KL}} 

\newcommand{\law}{\mathcal{L}}  \newcommand{\normal}{N} 

\newcommand{\convd}{\stackrel{d}{\longrightarrow}} \newcommand{\convp}{\stackrel{p}{\longrightarrow}} \newcommand{\convas}{\stackrel{\textrm{a.s.}}{\longrightarrow}} 

\newcommand{\eqd}{\stackrel{d}{=}} \newcommand{\conv}{\textrm{conv}} 

\newcommand{\inv}[1]{{#1}^{-1}}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\newcommand{\refalgo}[1]{Alg.~\ref{#1}}
\newcommand{\refsec}[1]{Sec.~\ref{#1}}
\newcommand{\reffig}[1]{Fig.~\ref{#1}}
\newcommand{\reftab}[1]{Tab.~\ref{#1}}
\newcommand{\refeq}[1]{Eq.~\ref{#1}}
\newcommand{\refdef}[1]{Def.~\ref{#1}}
\newcommand{\refthm}[1]{Thm.~\ref{#1}}
\newcommand{\reflem}[1]{Lemma~\ref{#1}}
\newcommand{\refcor}[1]{Corr.~\ref{#1}}

\newcommand{\bp}{\mathbb{P}}

\newcommand{\Ph}{\widehat{P}_k}
\newcommand{\PC}{P_{\cc,k}}
\newcommand{\Lc}{\widetilde{L}}
\newcommand{\Yt}{\widetilde{Y}}
\newcommand{\Pt}{\widetilde{P}}
\newcommand{\Oc}{\mathcal{O}}

\newcommand{\dist}{\kappa_{\Pi}} \newcommand{\pns}{\delta_{\Pi}} \newcommand{\epsm}{\varepsilon_{\Pi}} \newcommand{\nys}{Nystr\"om}

\newcommand{\leftgr}[1]{{#1}^{\text{lr}}} \newcommand{\rightgr}[1]{{#1}^{\text{rr}}} \newcommand{\lobatto}[1]{{#1}^{\text{lo}}} 

\newcommand{\loss}{\textrm{loss}}

\newcommand{\hide}[1]{}

\newcommand{\nlsum}{\sum\nolimits}
\newcommand{\set}[1]{\left\lbrace #1\right\rbrace}
\DeclareMathOperator{\sspan}{span}

\newcount\COMMENTs  \COMMENTs=1   \usepackage{color}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{purple}{rgb}{1,0,1}
\newcommand{\comm}[2]{\ifnum\COMMENTs=1\textcolor{#1}{#2}\fi}
\newcommand{\cli}[1]{\comm{purple}      {[CL: #1]}}
\newcommand{\ssr}[1]{\comm{cyan}     {[SS: #1]}}
\newcommand{\marinka}[1]{\comm{blue}     {[MZ: #1]}}
\newcommand{\jure}[1]{\comm{purple}      {[JL: #1]}}
\newcommand{\wh}[1]  {\comm{red}   {[WH: #1]}}
\newcommand{\bowen}[1]{\comm{orange}     {[BL: #1]}}

\newcount\REVISEs  \REVISEs=0   \usepackage{color}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{purple}{rgb}{1,0,1}
\newcommand{\commm}[2]{\ifnum\REVISEs=1\textcolor{#1}{#2}\else#2\fi}
\newcommand{\revise}[1]{\commm{purple} {#1}}

\newcommand{\single}{observation\xspace}
\newcommand{\multi}{sample\xspace}
\newcommand{\multis}{samples\xspace}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}



\usepackage{amsmath,amsfonts,bm}




\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{Eq.~(\ref{#1})}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}


\title{Strategies for Pre-training Graph Neural Networks}



\author{Weihua Hu\thanks{Equal contribution. Project website, data and code: \url{http://snap.stanford.edu/gnn-pretrain}}, \ Bowen Liu, Joseph Gomes, Marinka Zitnik, \\
{\bf Percy Liang, Vijay Pande, Jure Leskovec} \\
Department of Computer Science, Chemistry, Bioengineering, Stanford University,\\
Department of Chemical and Biochemical Engineering, The University of Iowa,\\
Department of Biomedical Informatics, Harvard University\\
\texttt{\{weihuahu,liubowen,pliang,jure\}@cs.stanford.edu},\\
\texttt{joe-gomes@uiowa.edu},\ \texttt{marinka@hms.harvard.edu},\ \texttt{pande@stanford.edu}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Many applications of machine learning require a model to make accurate predictions on test examples that are distributionally different from training ones, while task-specific labels are scarce during training. 
An effective approach to this challenge is to pre-train a model on related tasks where data is abundant, and then fine-tune it on a downstream task of interest. 
While pre-training has been effective in many language and vision domains, it remains an open question how to effectively use pre-training on graph datasets.
In this paper, we develop a new strategy and self-supervised methods for pre-training Graph Neural Networks (GNNs).
The key to the success of our strategy is to pre-train an expressive GNN at the level of individual nodes as well as entire graphs so that the GNN can learn useful local and global representations simultaneously.
We systematically study pre-training on multiple graph classification datasets. 
We find that na\"ive strategies, which pre-train GNNs at the level of either entire graphs or individual nodes, give limited improvement and can even lead to negative transfer on many downstream tasks. 
In contrast, our strategy avoids negative transfer and improves generalization significantly across downstream tasks, leading up to 9.4\% absolute improvements in ROC-AUC over non-pre-trained models and achieving state-of-the-art performance for molecular property prediction and protein function prediction. \end{abstract}

\section{Introduction}

Transfer learning refers to the setting where a model, initially trained on some tasks, is re-purposed on different but related tasks. Deep transfer learning has been immensely successful in computer vision~\citep{donahue2014decaf,girshick2014rich,zeiler2014visualizing} and natural language processing~\citep{devlin2018bert,peters2018deep,mikolov2013distributed}. Despite being an effective approach to transfer learning, few studies have generalized pre-training to graph data.

Pre-training has the potential to provide an attractive solution to the following two fundamental challenges with learning on graph datasets~\citep{pan2009survey,hendrycks2019using}: First, task-specific labeled data can be extremely scarce. This problem is exacerbated in important graph datasets from scientific domains, such as chemistry and biology, where data labeling (\eg, biological experiments in a wet laboratory) is resource- and time-intensive~\citep{zitnik2018prioritizing}. Second, graph data from real-world applications often contain out-of-distribution samples, meaning that graphs in the training set are structurally very different from graphs in the test set. Out-of-distribution prediction is common in real-world graph datasets, for example, when one wants to predict chemical properties of a brand-new, just synthesized molecule, which is different from all molecules synthesized so far, and thereby different from all molecules in the training set. 

However, pre-training on graph datasets remains a hard challenge.
Several key studies~\citep{xu2017demystifying, ching2018opportunities,wang2019data} have shown that successful transfer learning is not only a matter of increasing the number of labeled pre-training datasets that are from the same domain as the downstream task. Instead, it requires substantial domain expertise to carefully select examples and target labels that are correlated with the downstream task of interest. Otherwise, the transfer of knowledge from related pre-training tasks to a new downstream task can harm generalization, which is known as \emph{negative transfer} \citep{rosenstein2005transfer} and significantly limits the
applicability and reliability of pre-trained models.

\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{fig/pretrain-principle-v2.pdf}
\caption{
{\bf (a.i)} When only node-level pre-training is used, nodes of different shapes (semantically different nodes) can be well separated, however, node embeddings are not composable, and thus resulting graph embeddings (denoted by their classes,  and ) that are created by pooling node-level embeddings are not separable. 
{\bf (a.ii)} With graph-level pre-training only, graph embeddings are well separated, however the embeddings of individual nodes do not necessarily capture their domain-specific semantics.
{\bf (a.iii)} High-quality node embeddings are such that nodes of different types are well separated, while at the same time, the embedding space is also composable. This allows for accurate and robust representations of entire graphs and enables robust transfer of pre-trained models to a variety of downstream tasks. 
{\bf (b)} Categorization of pre-training methods for GNNs. Crucially, our methods, \ie, Context Prediction, Attribute Masking, and graph-level supervised pre-training (Supervised Attribute Prediction) enable both node-level and graph-level pre-training. 
\vspace{-5mm}
}
\label{fig:principle}
\end{figure}

{\bf Present work.}
Here, we focus on pre-training as an approach to transfer learning in Graph Neural Networks (GNNs) \citep{kipf2016semi,hamilton2017inductive,ying2018hierarchical,xu2018how,xu2018representation} for graph-level property prediction. Our work presents two key contributions. (1) We conduct the first systematic large-scale investigation of strategies for pre-training GNNs. For that, we build two large new pre-training datasets, which we share with the community: a chemistry dataset with 2 million graphs and a biology dataset with 395K graphs. We also show that large domain-specific datasets are crucial to investigate pre-training and that existing downstream benchmark datasets are too small to evaluate models in a statistically reliable way. (2) We develop an effective pre-training strategy for GNNs and demonstrate its effectiveness and its ability for out-of-distribution generalization on hard transfer-learning problems.

In our systematic study, we show that pre-training GNNs does not always help. Na\"ive pre-training strategies can lead to negative transfer on many downstream tasks. Strikingly, a seemingly strong pre-training strategy (\ie, graph-level multi-task supervised pre-training using a state-of-the-art graph neural network architecture for graph-level prediction tasks) only gives marginal performance gains. Furthermore, this strategy even leads to negative transfer on many downstream tasks (2 out of 8 molecular datasets and 13 out of 40 protein prediction tasks). 

We develop an effective strategy for pre-training GNNs. The key idea is to use easily accessible node-level information and encourage GNNs to capture domain-specific knowledge about nodes and edges, in addition to graph-level knowledge.
This helps the GNN to learn useful representations at both global and local levels (Figure~\ref{fig:principle} (a.iii)), and is crucial to be able to generate graph-level representations (which are obtained by pooling node representations) that are robust and transferable to diverse downstream tasks (Figure~\ref{fig:principle}).
Our strategy is in contrast to na\"ive strategies that either leverage only at graph-level properties (Figure~\ref{fig:principle} (a.ii)) or node-level properties (Figure~\ref{fig:principle} (a.i)).

Empirically, our pre-training strategy used together with the most expressive GNN architecture, GIN~\citep{xu2018how}, yields state-of-the-art results on benchmark datasets and avoids negative transfer across downstream tasks we tested. It significantly improves generalization performance across downstream tasks, yielding up to 9.4\% higher average ROC-AUC than non-pre-trained GNNs, and up to 5.2\% higher average ROC-AUC compared to GNNs with the extensive graph-level multi-task supervised pre-training.
Furthermore, we find that the most expressive architecture, GIN, benefits more from pre-training compared to those with less expressive power (\eg, GCN \citep{kipf2016semi}, GraphSAGE \citep{hamilton2017representation} and GAT \citep{velivckovic2017graph}), and that pre-training GNNs leads to orders-of-magnitude faster training and convergence in the fine-tuning stage.
 \section{Preliminaries of Graph Neural Networks}
\label{sec:preliminaries}
We first formalize supervised learning of graphs and provide an overview of GNNs~\citep{gilmer2017neural}. Then, we briefly review methods for unsupervised graph representation learning.

{\bf Supervised learning of graphs.}
Let  denote a graph with node attributes  for  and edge attributes  for . Given a set of graphs \{, \ldots, \} and their labels \{, \ldots, \}, the task of graph supervised learning is to learn a representation vector  that helps predict the label of an entire graph , .
For example, in molecular property prediction,  is a molecular graph, where nodes represent atoms and edges represent chemical bonds, and the label to be predicted can be toxicity or enzyme binding.

{\bf Graph Neural Networks (GNNs)}.
GNNs use the graph connectivity as well as node and edge features to learn a representation vector (\ie, embedding)  for every node  and a vector  for the entire graph . 
Modern GNNs use a neighborhood aggregation approach, where representation of node  is iteratively updated by aggregating representations of 's neighboring nodes and edges~\citep{gilmer2017neural}. After  iterations of aggregation, 's representation captures the structural information within its -hop network neighborhood. Formally, the -th layer of a GNN is: 

where  is the representation of node  at the -th iteration/layer,  is the feature vector of edge between  and , and  is a set neighbors of . We initialize . 

{\bf Graph representation learning.}
To obtain the entire graph's representation , the READOUT function pools node features from the final iteration ,

READOUT is a permutation-invariant function, such as averaging or a more sophisticated graph-level pooling function~\citep{ying2018hierarchical,zhang2018end}.






 \section{Strategies for pre-training Graph Neural Networks}
\label{sec:strategy}

At the technical core of our pre-training strategy is the notion to pre-train a GNN  \emph{both} at the level of individual nodes as well as entire graphs. This notion encourages the GNN to capture domain-specific semantics at both levels, as illustrated in Figure~\ref{fig:principle} (a.iii).
This is in contrast to straightforward but limited pre-training strategies that either only use pre-training to predict properties of entire graphs (Figure~\ref{fig:principle} (a.ii)) or only use pre-training to predict properties of individual nodes (Figure~\ref{fig:principle} (a.i)).

\hide{
Given that GNNs  obtain the representation of the entire graphs by first computing individual node representations, we propose to pre-train GNNs at the level of \emph{both} individual nodes and the entire graphs. This encourages GNNs to capture domain-specific semantics at the both scales, as illustrated in Figure~\ref{fig:principle} (a.iii).
This is in contrast to the conventional pre-training approaches, \ie, either only performing supervised pre-training to predict auxiliary properties of entire graphs \citep{ramsundar2015massively, ramsundar2017multitask, xu2017demystifying, kearnes2016modeling}, as illustrated in Figure~\ref{fig:principle} (a.ii), or only applying a node representation learning technique \citep{jaeger2018mol2vec}, as illustrated in Figure~\ref{fig:principle} (a.i).
}

In the following, we first describe our node-level pre-training approach (Section~\ref{subsec:nodelevel}) and then graph-level pre-training approach (Section~\ref{subsec:graph-level}). 
Finally, we describe the full pre-training strategy in Section~\ref{subsec:finetune}.

\begin{figure}[t]
\includegraphics[width=14cm]{fig/method.pdf}
\caption{Illustration of our node-level methods, Context Prediction and Attribute Masking for pre-training GNNs. {\bf (a)} In Context Prediction, the subgraph is a -hop neighborhood around a selected center node, where  is the number of GNN layers and is set to 2 in the figure. The context is defined as the surrounding graph structure that is between - and -hop from the center node, where we use  and  in the figure. {\bf (b)} In Attribute Masking, the input node/edge attributes (\eg, atom type in the molecular graph) are randomly masked, and the GNN is asked to predict them.}
\label{fig:method}
\end{figure}

\subsection{Node-level pre-training} \label{subsec:nodelevel}

For node-level pre-training of GNNs, our approach is to use easily-accessible unlabeled data to capture domain-specific knowledge/regularities in the graph. Here we propose two self-supervised methods, Context Prediction and Attribute Masking. 



\subsubsection{Context Prediction: Exploiting distribution of graph structure} \label{sec:context_pred}
In Context Prediction, we use subgraphs to predict their surrounding graph structures.
Our goal is to pre-train a GNN so that it maps nodes appearing in similar structural contexts to nearby embeddings~\citep{rubenstein1965contextual,mikolov2013distributed}.


{\bf Neighborhood and context graphs.}
For every node , we define 's neighborhood and context graphs as follows. 
\emph{-hop neighborhood} of  contains all nodes and edges that are at most -hops away from  in the graph. This is motivated by the fact that a -layer GNN aggregates information across the -th order neighborhood of , and thus node embedding  depends on nodes that are at most -hops away from .
We define \emph{context graph} of node  as graph structure that surrounds 's neighborhood. The context graph is described by two hyperparameters,  and , and it represents a subgraph that is between -hops and -hops away from  (\ie, it is a ring of width ). Examples of neighborhood and context graphs are shown in Figure \ref{fig:method} (a). We require  so that some nodes are shared between the neighborhood and the context graph, and we refer to those nodes as \emph{context anchor nodes}. These anchor nodes provide information about how the neighborhood and context graphs are connected with each other.

{\bf Encoding context into a fixed vector using an auxiliary GNN.}
Directly predicting the context graph is intractable due to the combinatorial nature of graphs. This is different from natural language processing, where words come from a fixed and finite vocabulary.
To enable context prediction, we encode context graphs as \emph{fixed-length vectors}.
To this end, we use an auxiliary GNN, which we refer to as the \emph{context GNN}. 
As depicted in Figure~\ref{fig:method} (a), we first apply the context GNN (denoted as GNN in Figure~\ref{fig:method} (a)) to obtain node embeddings in the context graph. We then average embeddings of \emph{context anchor nodes} to obtain a fixed-length context embedding. For node  in graph , we denote its corresponding context embedding as .

{\bf Learning via negative sampling.}
We then use negative sampling \citep{mikolov2013distributed, ying2018graph} to jointly learn the main GNN and the context GNN. The main GNN encodes neighborhoods to obtain node embeddings. The context GNN encodes context graphs to obtain context embeddings. In particular, the learning objective of Context Prediction is a binary classification of whether a particular neighborhood and a particular context graph belong to the same node:

where  is the sigmoid function, and  is the indicator function. We either let  and  (\ie, a positive neighborhood-context pair), or we randomly sample  from a randomly chosen graph  (\ie, a negative neighborhood-context pair). We use a negative sampling ratio of 1 (one negative pair per one positive pair), and  use the negative log likelihood as the loss function.
After pre-training, the main GNN is retained as our pre-trained model
 
\subsubsection{Attribute Masking: Exploiting distribution of graph attributes}
\label{sec:masking}
In Attribute Masking, we aim to capture domain knowledge by learning the regularities of the node/edge attributes distributed over graph structure. 

{\bf Masking node and edges attributes.}
Attribute Masking pre-training works as follows: We mask node/edge attributes and then we let GNNs predict those attributes \citep{devlin2018bert} based on neighboring structure. Figure \ref{fig:method} (b) illustrates our proposed method when applied to a molecular graph. Specifically, We randomly mask input node/edge attributes, for example atom types in molecular graphs, by replacing them with special masked indicators. We then apply GNNs to obtain the corresponding node/edge embeddings (edge embeddings can be obtained as a sum of node embeddings of the edge's end nodes). Finally, a linear model is applied on top of embeddings to predict a masked node/edge attribute.  
Different from \citet{devlin2018bert} that operates on sentences and applies message passing over the fully-connected graph of tokens, we operate on non-fully-connected graphs and aim to capture the regularities of node/edge attributes distributed over different graph structures. Furthermore, we allow masking edge attributes, going beyond masking node attributes.

Our node and edge attribute masking method is especially beneficial for richly-annotated graphs from scientific domains. For example, (1) in molecular graphs, the node attributes correspond to atom types, and capturing how they are distributed over the graphs enables GNNs to learn simple chemistry rules such as valency, as well as potentially more complex chemistry phenomenon such as the electronic or steric properties of functional groups. Similarly, (2) in protein-protein interaction (PPI) graphs, the edge attributes correspond to different kinds of interactions between a pair of proteins. Capturing how these attributes distribute across the PPI graphs enables GNNs to learn how different interactions relate and correlate with each other.

\subsection{Graph-level Pre-training}
\label{subsec:graph-level}

We aim to pre-train GNNs to generate useful graph embeddings composed of the meaningful node embeddings obtained by methods in Section~\ref{subsec:nodelevel}. Our goal is to ensure both node and graph embeddings are of high-quality so that graph embeddings are robust and transferable across downstream tasks, as illustrated in Figure \ref{fig:principle} (a.iii). Additionally, there are two options for graph-level pre-training, as shown in Figure \ref{fig:principle} (b): making predictions about domain-specific attributes of entire graphs (\eg, supervised labels), or making predictions about graph structure.

\subsubsection{Supervised Graph-Level Property Prediction}

As the graph-level representation  is directly used for fine-tuning on downstream prediction tasks, it is desirable to directly encode domain-specific information into . 

We inject graph-level domain-specific knowledge into our pretrained embeddings by defining supervised graph-level prediction tasks. 
In particular, we consider a practical method to pre-train graph representations: graph-level multi-task supervised pre-training to jointly predict a diverse set of supervised labels of individual graphs.
For example, in molecular property prediction, we can pre-train GNNs to predict essentially all the properties of molecules that have been experimentally measured so far. In protein function prediction, where the goal is predict whether a given protein has a given functionality, we can pre-train GNNs to predict the existence of diverse protein functions that have been validated so far. In our experiments in Section \ref{sec:experiments}, we prepare a diverse set of supervised tasks (up to 5000 tasks) to simulate these practical scenarios. Further details of the supervised tasks and datasets are described in Section \ref{subsec:dataset}.
To jointly predict many graph properties, where each property corresponds to a binary classification task, we apply linear classifiers on top of graph representations.

Importantly, na\"ively performing the extensive multi-task graph-level pre-training alone can fail to give transferable graph-level representations, as empirically demonstrated in Section \ref{sec:experiments}.
This is because some supervised pre-training tasks might be unrelated to the downstream task of interest and can even hurt the downstream performance (negative transfer). 
One solution would be to select ``truly-relevant'' supervised pre-training tasks and pre-train GNNs only on those tasks. However, such a solution is extremely costly since selecting the relevant tasks requires significant domain expertise and pre-training needs to be performed separately for different downstream tasks. 

To alleviate this issue, our key insight is that the multi-task supervised pre-training only provides graph-level supervision; thus, local node embeddings from which the graph-level embeddings are created may not be meaningful, as illustrated in Figure \ref{fig:principle} (a.ii).
Such non-useful node embeddings can exacerbate the problem of negative transfer because many different pre-training tasks can more easily interfere with each other in the node embedding space.
Motivated by this, our pre-training strategy is to first regularize GNNs at the level of individual nodes via node-level pre-training methods described in Section \ref{subsec:nodelevel}, before performing graph-level pre-training. As we demonstrate empirically, the combined strategy produces much more transferable graph representations and robustly improves downstream performance without expert selection of supervised pre-training tasks.

\subsubsection{Structural Similarity Prediction}

A second approach is to define a graph-level predictive task where the goal would be to model the structural similarity of two graphs. Examples of such tasks include modeling the graph edit distance~\citep{bai2019unsupervised} or predicting graph structure similarity~\citep{navarin2018pre}. However, finding the ground truth graph distance values is a difficult problem, and in large datasets there is a quadratic number of graph pairs to consider. Therefore, while this type of pre-training is also very natural, it is beyond the scope of this paper and we leave its investigation for future work.

\subsection{Overview: Pre-training GNNs and Fine-tuning for Downstream Tasks}
\label{subsec:finetune}

Altogether, our pre-training strategy is to first perform node-level self-supervised pre-training (Section~\ref{subsec:nodelevel}) and then graph-level multi-task supervised pre-training (Section~\ref{subsec:graph-level}).
When the GNN pre-training is finished, we fine-tune the pre-trained GNN model on downstream tasks. Specifically, we add linear classifiers on top of graph-level representations to predict downstream graph labels. The full model, \ie, the pre-trained GNN and downstream linear classifiers, is subsequently fine-tuned in an end-to-end manner. Time-complexity analysis is provided in Appendix~\ref{app:complexity}, where we show that our pre-training methods incur little computational overhead to forward computation in GNNs.
 \section{Further Related Work}
\vspace{-0.1cm}

There is rich literature on unsupervised representation learning of individual \emph{nodes} within graphs, which broadly falls into two categories. In the first category are methods that use local random walk-based objectives \citep{grover2016node2vec,perozzi2014deepwalk,tang2015line} and methods that reconstruct a graph's adjacency matrix, \eg, by predicting edge existence~\citep{hamilton2017inductive,kipf2016variational}.
In the second category are methods, such as Deep Graph Infomax~\citep{velivckovic2018deep}, that train a node encoder that maximizes mutual information between local node representations and a pooled global graph representation. All these methods encourage nearby nodes to have similar embeddings and were originally proposed and evaluated for node classification and link prediction. This, however, can be sub-optimal for graph-level prediction tasks, where capturing \emph{structural} similarity of local neighborhoods is often more important than capturing the positional information of nodes within a graph ~\citep{you2019position,ecfp2010,Yang2014egonet}.
Our approach thus considers both the node-level as well as graph-level pretraining tasks and as we show in our experiments, it is essential to use both types of tasks in order for pretrained models to achieve good performance.

A number of recent works have also explored how node embeddings generalize across tasks \citep{jaeger2018mol2vec,zhou2018learning,chakravarti2018distributed,narayanan2016subgraph2vec}.
However, all of these methods use distinct node embeddings for different substructures and do not share any parameters. Thus, they are inherently transductive, cannot transfer between datasets, cannot be fine-tuned in an end-to-end manner, and cannot capture large and diverse neighborhoods/contexts due to data sparsity. 
Our approach addresses all these challenges by developing pre-training methods for GNNs that use shared parameters to encode the the graph-level as well as node-level dependencies and structures.
 \section{Experiments}
\label{sec:experiments}

\subsection{Datasets}
\label{subsec:dataset}

We consider two domains; molecular property prediction in chemistry and protein function prediction in biology.  We release the new datasets at: \url{http://snap.stanford.edu/gnn-pretrain}. 

{\bf Pre-training datasets.} For the chemistry domain, we use 2 million unlabeled molecules sampled from the ZINC15 database \citep{sterling2015} for node-level self-supervised pre-training.
For graph-level multi-task supervised pre-training, we use a preprocessed ChEMBL dataset \citep{mayr2018large,gaulton2011chembl}, containing 456K molecules with 1310 kinds of diverse and extensive biochemical assays. For the biology domain, we use 395K unlabeled protein ego-networks derived from PPI networks of 50 species (\eg, humans, yeast, zebra fish) for node-level self-supervised pre-training. For graph-level multi-task supervised pre-training, we use 88K labeled protein ego-networks to jointly predict 5000 \emph{coarse-grained} biological functions (\eg, cell apoptosis, cell proliferation).


{\bf Downstream classification datasets.}  
For the chemistry domain, we considered classical graph classification benchmarks (MUTAG, PTC molecule datasets) \citep{kersting2016benchmark,xu2018how} as our downstream tasks, but found that they are too small (188 and 344 examples for MUTAG and PTC) to evaluate different methods in a statistically meaningful way (see Appendix \ref{sec:classical_benchmarks} for the results and discussion).
Because of this, as our downstream tasks, we decided to use 8 larger binary classification datasets contained in MoleculeNet \citep{wu2018moleculenet}, a recently-curated benchmark for molecular property prediction. 
The dataset statistics are summarized in Table \ref{table:result_molecule}.
For the biology domain, we compose our PPI networks from \citet{Zitnik2019}, consisting of 88K proteins from 8 different species, 
where the subgraphs centered at a protein of interest (\ie, ego-networks) are used to predict their biological functions. Our downstream task is to predict 40 \emph{fine-grained} biological functions\footnote{Fine-grained labels are harder to obtain than coarse-grained labels; the latter are used for pre-training.} that correspond to 40 binary classification tasks.
In contrast to existing PPI datasets \citep{hamilton2017inductive}, our dataset is larger and spans multiple species (\ie, not only humans), which makes it a suitable benchmark for evaluating out-of-distribution prediction.
Additional details about datasets and features of molecule/PPI graphs are in Appendices \ref{app:molecule-feat} and \ref{app:protein-pt}.


{\bf Dataset splitting.} In many applications, conventional random split is overly optimistic and does not simulate the real-world use case, where test graphs can be structurally different from training graphs \citep{wu2018moleculenet,Zitnik2019}. To reflect the actual use case, we split the downstream data in the following ways to evaluate the models' {\em out-of-distribution generalization}.
In the chemistry domain, we use \emph{scaffold split}~\citep{Ramsundar-et-al-2019}, where we split molecules according to their scaffold (molecular substructure). In the biology domain, we use \emph{species split}, where we predict functions of proteins from new species.
Details are in Appendix \ref{sec:data_splitting}.
Furthermore, to prevent data leakage, all test graphs used for performance evaluation are removed from the graph-level supervised pre-training datasets.



\begin{table}[t]
\centering
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|cccccccc|c|} \hline
  \multicolumn{2}{|c|}{Dataset}        & BBBP & Tox21 & ToxCast & SIDER & ClinTox & MUV & HIV & BACE & {\bf Average}\\\hline
  \multicolumn{2}{|c|}{\# Molecules}  & 2039  & 7831  &  8575  & 1427  & 1478  & 93087 & 41127 & 1513 & / \\ 
  \multicolumn{2}{|c|}{\# Binary prediction tasks}  & 1      &  12      & 617      & 27   &  2    & 17  & 1  & 1 & / \\ \hline \hline
\multicolumn{2}{|c|}{Pre-training strategy} &\multicolumn{9}{c|}{\multirow{2}{*}{Out-of-distribution prediction (scaffold split)}} \\ \cline{1-2}
Graph-level & Node-level & \multicolumn{9}{c|}{} \\ \hline
-- & -- & 65.8 4.5 & 74.0 0.8 & 63.4 0.6 & 57.3 1.6 & 58.0 4.4 & 71.8 2.5 & 75.3 1.9 & 70.1 5.4 & 67.0 \\ 
-- & Infomax  &  {\bf 68.8 0.8} & 75.3 0.5 &  \cellcolor[gray]{0.8}62.7 0.4 & 58.4 0.8 & 69.9 3.0 & 75.3 2.5 & 76.0 0.7 & 75.9 1.6 & 70.3 \\ 
-- & EdgePred & 67.3 2.4 & 76.0 0.6 & 64.1 0.6 & 60.4 0.7 & 64.1 3.7 & 74.1 2.1 & 76.3 1.0 & 79.9 0.9 & 70.3 \\ \hdashline
-- & AttrMasking  &  64.3 2.8 & 76.7 0.4 & 64.2 0.5 & 61.0 0.7 & 71.8 4.1 & 74.7 1.4 & 77.2 1.1 & 79.3 1.6  & 71.1 \\ 
-- & ContextPred  &  68.0 2.0 &  75.7 0.7 & 63.9 0.6 & 60.9 0.6 & 65.9 3.8 & 75.8 1.7 & 77.3 1.0 & 79.6 1.2 & 70.9 \\ \hline 
Supervised & --   &  68.3 0.7 & 77.0 0.3 & 64.4 0.4 & 62.1 0.5 & \cellcolor[gray]{0.8}57.2 2.5 & 79.4 1.3 & \cellcolor[gray]{0.8}74.4 1.2 & 76.9 1.0  & 70.0 \\ 
Supervised & Infomax  &   68.0 1.8 & 77.8 0.3 & 64.9 0.7 & 60.9 0.6 & {\bf 71.2 2.8} & {\bf 81.3 1.4} & 77.8 0.9 & 80.1 0.9 & 72.8 \\ 
Supervised & EdgePred  &   66.6 2.2 & {\bf 78.3 0.3} & {\bf 66.5 0.3} & {\bf 63.3 0.9} & 70.9 4.6 & 78.5 2.4 & 77.5 0.8 & 79.1 3.7 & 72.6  \\ \hdashline
Supervised & AttrMasking  & 66.5 2.5 & 77.9 0.4 & 65.1 0.3 & {\bf 63.9 0.9} & {\bf 73.7 2.8} & {\bf 81.2 1.9} & 77.1 1.2 & 80.3 0.9 & 73.2 \\ 
Supervised & ContextPred  &   {\bf 68.7 1.3} & {\bf 78.1 0.6} & 65.7 0.6 & 62.7 0.8 & {\bf 72.6 1.5} & {\bf 81.3 2.1} & {\bf 79.9 0.7} & {\bf 84.5 0.7} & {\bf 74.2} \\  \hline
\end{tabular}}
\vspace{0.2cm}
 \caption{{\bf Test ROC-AUC (\%) performance on molecular prediction benchmarks using different pre-training strategies with GIN.} The rightmost column averages the mean of test performance across the 8 datasets. The best result for each dataset and comparable results  (\ie, results within one standard deviation from the best result) are bolded. The shaded cells indicate negative transfer, \ie, ROC-AUC of a pre-trained model is worse than that of a non-pre-trained model.
 Notice that node- as well as graph-level pretraining are essential for good performance.
 }
 \label{table:result_molecule}
 \vspace{-0.2cm}
\end{table}


\subsection{Experimental Setup}
We thoroughly compare our pre-training strategy with two na\"ive baseline strategies: (i) extensive supervised multi-task pre-training on relevant graph-level tasks, and (ii) node-level self-supervised pre-training.


{\bf GNN architectures.}
We mainly study Graph Isomorphism Networks (GINs)~\citep{xu2018how}, the most expressive and state-of-the-art GNN architecture for graph-level prediction tasks. 
We also experimented with other popular architectures that are less expressive: GCN \citep{kipf2016variational}, GAT \citep{velivckovic2018deep}, and GraphSAGE (with mean neighborhood aggregation) \citep{hamilton2017representation}.
We select the following hyper-parameters that performed well across all downstream tasks in the validation sets: 300 dimensional hidden units, 5 GNN layers (), and average pooling for the READOUT function. 
Additional details can be found in Appendix \ref{app:gnn-architecture}. 

{\bf Pre-training.}
For Context Prediction illustrated in Figure \ref{fig:method} (a), on molecular graphs, we define context graphs by setting inner radius . On PPI networks whose diameters are often smaller than 5, we use , which works well empirically despite the large overlap between the neighborhood and context subgraphs.
For both molecular and PPI graphs, we let outer radius , and use a 3-layer GNN to encode the context structure. 
For Attribute Masking shown in Figure \ref{fig:method} (b), we randomly mask 15\% of node (for molecular graphs) or edge attributes (for PPI networks) for prediction.  
As baselines for node-level self-supervised pre-training, we adopt the original Edge Prediction (denoted by EdgePred) \citep{hamilton2017inductive} and Deep Graph Infomax (denoted by Infomax) \citep{velivckovic2018deep} implementations.
Further details are provided in Appendix \ref{app:furthre_setup}.

\begin{table}[t]
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
              & \multicolumn{3}{c|}{Chemistry}                                                     & \multicolumn{3}{c|}{Biology}                                                               \\ \hline
& Non-pre-trained & \begin{tabular}[c]{@{}c@{}}Pre-trained\end{tabular} & \cellcolor[gray]{0.95}Gain          & Non-pre-trained         & \begin{tabular}[c]{@{}c@{}}Pre-trained\end{tabular} & \cellcolor[gray]{0.95} Gain           \\ \hline
GIN           & 67.0            & \textbf{74.2}                            & \cellcolor[gray]{0.95} \textbf{+7.2} & 64.8  1.0          & \textbf{74.2  1.5}                                               & \cellcolor[gray]{0.95} \textbf{+9.4} \\ \hline
GCN           & \textbf{68.9}   & 72.2                                                                      &\cellcolor[gray]{0.95} +3.4          & 63.2  1.0          & 70.9  1.7                                                        & \cellcolor[gray]{0.95}+7.7           \\ \hline
GraphSAGE     & 68.3            & 70.3                                                                      & \cellcolor[gray]{0.95} +2.0          & 65.7  1.2          & 68.5  1.5                                                        & \cellcolor[gray]{0.95}+2.8           \\ \hline
GAT           & 66.8            & 60.3                                                                      & \cellcolor[gray]{0.95} -6.5          & \textbf{68.2  1.1} & 67.8  3.6                                                        & \cellcolor[gray]{0.95} -0.4           \\ \hline
\end{tabular}}
\caption{{\bf Test ROC-AUC (\%) performance of different GNN architectures with and without pre-training.} Without pre-training, the less expressive GNNs give slightly better performance than the most expressive GIN because of their smaller model complexity in a low data regime. However, with pre-training, the most expressive GIN is properly regularized and dominates the other architectures. For results split by chemistry datasets, see Table \ref{table:result_molecule_gnn_type} in Appendix \ref{app:gnn_type_comp}. Pre-training strategy for chemistry data: Context Prediction + Graph-level supervised pre-training; pre-training strategy for biology data: Attribute Masking + Graph-level supervised pre-training.}
 \label{table:gnn_type_comp}
\end{table}


\subsection{Results} 
We report results for molecular property prediction and protein function prediction in Tables~\ref{table:gnn_type_comp} and \ref{table:result_molecule} and Figure \ref{fig:bio-pair-comp}. Our systematic study suggests the following trends: 

{\bf Observation (1):} Table \ref{table:gnn_type_comp} shows that the most expressive GNN architecture (GIN), when pre-trained, achieves the best performance across domains and datasets. Compared with gains of pre-training achieved by GIN architecture, gains of pre-training using less expressive GNNs (GCN, GraphSAGE, and GAT) are smaller and can sometimes even be negative (Table \ref{table:gnn_type_comp}). This finding confirms previous observations~(\eg, \cite{erhan2010does}) that using an expressive model is crucial to fully utilize pre-training, and that pre-training can even hurt performance when used on models with limited expressive power, such as GCN, GraphSAGE, and GAT.

{\bf Observation (2):} As seen from the shaded cells of Table \ref{table:result_molecule} and highlighted region in the middle panel of Figure \ref{fig:bio-pair-comp}, the strong baseline strategy that performs extensive graph-level multi-task supervised pre-training of GNNs gives surprisingly limited performance gain and yields negative transfer on many downstream tasks (2 out of 8 datasets in molecular prediction, and 13 out of 40 tasks in protein function prediction). 

{\bf Observation (3):} From the upper half of Table \ref{table:result_molecule} and the left panel of Figure \ref{fig:bio-pair-comp}, we see that another baseline strategy, which only performs node-level self-supervised pre-training, also gives limited performance improvement and is comparable to the graph-level multi-task supervised pre-training baseline.

{\bf Observation (4):} From the lower half of Table \ref{table:result_molecule} and the right panel of Figure \ref{fig:bio-pair-comp}, we see that our pre-training strategy of combining graph-level multi-task supervised and node-level self-supervised pre-training avoids negative transfer across downstream datasets and achieves best performance. 

{\bf Observation (5):} Furthermore, from Table \ref{table:result_molecule} and the left panel of Figure \ref{fig:bio-pair-comp}, we see that our strategy gives significantly better predictive performance than the two baseline pre-training strategies as well as non-pre-trained models, achieving state-of-the-art performance. 

Specifically, in the {\bf chemistry} datasets, we see from Table \ref{table:result_molecule} that our Context Prediction + Graph-level multi-task supervised pre-training strategy gives the most promising performance, leading to an increase in average ROC-AUC of 7.2\% over non-pre-trained baseline and 4.2\% over graph-level multi-task supervised pre-trained baseline. On the HIV dataset, where a number of recent works~\citep{wu2018moleculenet,li2017learning,ishiguro2019graph} have reported performance on the same scaffold split and using the same protocol, our best pre-trained model (ContextPred + Supervised) achieves state-of-the-art performance. In particular, we achieved a ROC-AUC score of 79.9\%, while best-performing graph models in \citet{wu2018moleculenet}, \citet{li2017learning}, and \citet{ishiguro2019graph} had ROC-AUC scores of 76.3\%, 77.6\%, and 76.2\%, respectively. 

Also, in the {\bf biology} datasets, which we have built in this work, we see from the left panel of Figure \ref{fig:bio-pair-comp} that our Attribute Masking + Graph-level multi-task supervised pre-training strategy achieves the best predictive performance compared to other baseline strategies \emph{across almost all} 40 downstream prediction tasks (the right panel of Figure \ref{fig:bio-pair-comp}). On average, our strategy improves ROC-AUC by 9.4\% over non-pre-trained baseline and 5.2\% over graph-level multi-task supervised pre-trained baseline, again achieving state-of-the-art performance.

{\bf Observation (6):} In the chemistry domain, we also report performance on classic benchmarks (MUTAG, PTC molecule datasets) in Appendix \ref{sec:classical_benchmarks}. However, as mentioned in Section~\ref{subsec:dataset}, the extremely small dataset sizes make these benchmarks unsuitable to compare different methods in a statistically reliable way.

{\bf Observation (7):} Beyond predictive performance improvement, Figure \ref{fig:main-curve} shows that our pre-trained models achieve orders-of-magnitude faster training and validation convergence than non-pre-trained models. For example, on the MUV dataset, it took 1 hour for the non-pre-trained GNN to get 74.9\% validation ROC-AUC, while it took only 5 minutes for our pre-trained GNN to get 85.3\% validation ROC-AUC. The same trend holds across the downstream datasets we used, as shown in Figure \ref{fig:chem-curve-scaffold} in Appendix \ref{app:training_curves}. We emphasize that pre-training is a one-time-effort. Once the model is pre-trained, it can be used for any number of downstream tasks to improve performance with little training time.

As a final remark, in our preliminary experiments, we performed the Attribute Masking and Context Prediction simultaneously to pre-train GNNs. That approach did not improve performance in our experiments. We leave a thorough analysis of the approach for future work. 

\begin{figure}[t]
\centering
\includegraphics[width=14cm]{fig/bio-result.pdf}
\caption{{\bf Test ROC-AUC of protein function prediction using different pre-training strategies with GIN.} {\bf (Left)} Test ROC-AUC scores (\%) obtained by different pre-training strategies, where the scores are averaged over the 40 fine-grained prediction tasks. {\bf (Middle and right):} Scatter plot comparisons of ROC-AUC scores for a pair of pre-training strategies on the 40 \emph{individual} downstream tasks. Each point represents a particular individual downstream task. {{\bf (Middle):}} There are many \emph{individual} downstream tasks where graph-level multi-task supervised pre-trained model performs worse than non-pre-trained model, indicating negative transfer.
{\bf (Right):} When the graph-level multi-task supervised pre-training and Attribute Masking are combined, negative transfer is avoided across downstream tasks. The performance also improves over pure graph-level supervised pre-training.
}
\label{fig:bio-pair-comp}
\vspace{-0.2cm}
\end{figure}


\begin{figure}[t]
\includegraphics[width=14cm]{fig/convergence_main-v2.pdf}
\caption{{\bf Training and validation curves of different pre-training strategies on GINs.} Solid and dashed lines indicate training and validation curves, respectively.}
\label{fig:main-curve}
\vspace{-0.2cm}
\end{figure}


 \section{Conclusions and Future Work}
\vspace{-0.1cm}
We developed a novel strategy for pre-training GNNs. Crucial to the success of our strategy is to consider both node-level and graph-level pre-training in combination with an expressive GNN. This ensures that node embeddings capture local neighborhood semantics that are pooled together to obtain meaningful graph-level representations, which, in turn, are used for downstream tasks. Experiments on multiple datasets, diverse downstream tasks and different GNN architectures show that the new pre-training strategy achieves consistently better out-of-distribution generalization than non-pre-trained models.

Our work makes an important step toward transfer learning on graphs and addresses the issue of negative transfer observed in prior studies.
There are many interesting avenues for future work. For example, further increasing generalization by improving GNN architectures as well as pre-training and fine-tuning approaches, is a fruitful direction. 
Investigating what pre-trained models have learned would also be useful to aid scientific discovery~\citep{tshitoyan2019unsupervised}.
Finally, it would be interesting to apply our methods to other domains, \eg, physics, material science, and structural biology, where many problems are defined over graphs representing interactions of \eg, atoms, particles, and amino acids.
 
\section*{Acknowledgments}
We thank Camilo Ruiz, Rex Ying, Zhenqin Wu, Shantao Li, Srijan Kumar, Hongwei Wang, and Robin Jia for their helpful discussion.
W.H is supported by Funai Overseas Scholarship and Masason Foundation Fellowship.
J.L is a Chan Zuckerberg Biohub investigator.
We gratefully acknowledge the support of
DARPA under Nos. FA865018C7880 (ASED), N660011924033 (MCS);
ARO under Nos. W911NF-16-1-0342 (MURI), W911NF-16-1-0171 (DURIP);
NSF under Nos. OAC-1835598 (CINES), OAC-1934578 (HDR);
Stanford Data Science Initiative, 
Wu Tsai Neurosciences Institute,
Chan Zuckerberg Biohub,
JD.com, Amazon, Boeing, Docomo, Huawei, Hitachi, Observe, Siemens, UST Global. 

The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views, policies, or endorsements, either expressed or implied, of DARPA, NIH, ARO, or the U.S. Government.

The Pande Group acknowledges the generous support of Dr.  Anders G. Fr\o seth and Mr.  Christian Sundt for our work on machine learning.  The Pande Group is broadly supported by grants from the NIH (R01 GM062868 and U19 AI109662) as well as gift funds and contributions from Folding@home donors.

V.S.P is a consultant \& SAB member of Schrodinger, LLC and Globavir, sits on the Board of Directors of Apeel Sciences, Asimov, BioAge Labs, Ciitizen, Devoted Health, Freenome, Insitro, Omada Health, PatientPing, and is a General Partner at Andreessen Horowitz.


\bibliography{deepgraph}
\bibliographystyle{iclr2020_conference}


\newpage 

\appendix

\section{Details of GNN architectures}

\label{app:gnn-architecture}
Here we describe GNN architectures used in our molecular property and protein function prediction experiments. For both domains we use the GIN architecture \citep{xu2018how} with some minor modifications to include edge features, as well as center node information in the protein ego-networks.

As our primary goal is to systematically compare our pre-training strategy to the strong baseline strategies, we fix all of these hyper-parameters in our experiments and focus on relative improvement directly caused by the difference in pre-training strategies.

{\bf Molecular property prediction.}
In molecular property prediction, the raw node features and edge features are both 2-dimensional categorical vectors (see Appendix \ref{app:molecule-feat} for details), denoted as  and  for node  and edge , respectively. Note that we also introduce unique categories to indicate masked node/edges as well as self-loop edges. As input features to GNNs, we first embed the categorical vectors by

where , , , and  represent embedding operations that map integer indices to -dimensional real vectors, and  represents the index of GNN layers. At the -th layer, GNNs update node representations by

where  is a set of nodes adjacent to , and  represents the self-loop edge. Note that for the final layer, i.e., , we removed the ReLU from \eqref{eq:gin-chem} so that  can take negative values. This is crucial for pre-training methods based on the dot product, \eg, Context Prediction and Edge Prediction, as otherwise, the dot product between two vectors would be always positive.

The graph-level representation  is obtained by averaging the node embeddings at the final layer, i.e., 

The label prediction is made by a linear model on top of .

In our experiments, we set the embedding dimension  to 300. For MLPs in \eqref{eq:gin-chem}, we use the ReLU activation with 600 hidden units. We apply batch normalization \citep{ioffe2015batch} right before the ReLU in \eqref{eq:gin-chem} and apply dropout \citep{srivastava2014dropout} to  at all the layers except the input layer.

{\bf Protein function prediction.}
The GNN architecture used for protein function prediction is similar to the one used for molecular property prediction except for a few differences.
First, the raw input node features are uniform (denoted as  here) and second, the raw input edge features are binary vectors (see Appendix \ref{app:protein-feat} for the detail), which we denote as . As input features to GNNs, we first embed the raw features by 

where  and  are learnable parameters, and .
At each layer, GNNs update node representations by


where  takes two vectors as input and concatenates them. Since the downstream task is ego-network classification, we use the embedding of the center node  together with the embedding of the entire ego-network. More specifically, we obtain graph-level representation  by 

{\bf Other GNN architectures.}
For GCN, GraphSAGE, and GAT, we adopt the implementation in the Pytorch Geometric library \citep{fey2019fast}, where we set the number of GAT attention heads to be 2. The dimensionality of node embeddings as well as the number of GNN layers are kept the same as GIN.
These models do not originally handle edge features. 
We incorporate edge features into these models similarly to how we do it for the GIN; we add edge embeddings into node embeddings, and perform the GNN message-passing on the obtained node embeddings.


\section{Experiments on classic graph classification benchmarks}
\label{sec:classical_benchmarks}

In Table \ref{table:result_classical_mol} we report our experiments on the commonly-used classic graph classification benchmarks \citep{kersting2016benchmark}. Among the datasets \citet{xu2018how} used, MUTAG, PTC, and NCI1 are molecule datasets for binary classification.
Out of these three, we excluded the NCI1 dataset, because it misses edge information (\ie, bond type) and therefore, we cannot recover the original molecule information, which is necessary to construct our input representations described in Appendix \ref{app:molecule-feat}.

For fair comparison, we used exactly the same evaluation protocol as \citet{xu2018how}, \ie, report 10-fold cross-validation accuracy. All the hyper-parameters in our experiments are kept the same in the main experiments except that we additionally tuned dropout rate from  and the batch size from  at the fine-tuning stage.

While the pre-trained GNNs (especially those with Context Prediction) give competent performance, all the accuracies (including all the previous methods) are within a standard deviation with each other, making it hard to reliably compare different methods.
As \citet{xu2018how} has pointed out, this is due to the extremely small dataset size; a validation set at each fold only contains around 19 to 35 molecules for MUTAG and PTC, respectively.
Given these results, we argue that it is necessary to use larger datasets to make reliable comparison, so we mainly focus on MoleculeNet \citep{wu2018moleculenet} in this work.

\begin{table}[t]
\centering
\begin{tabular}{|c|c|cc|} \hline
  \multicolumn{2}{|c|}{Dataset}        & MUTAG & PTC \\\hline
  \multicolumn{2}{|c|}{\# Molecules}  & 188  & 344  \\ 
  \multicolumn{2}{|c|}{\# Binary prediction tasks}  & 1  &  1   \\ \hline \hline
\multicolumn{2}{|c|}{Prvious results} & \multicolumn{2}{c|}{Cross validation split}  \\  \hline
\multicolumn{2}{|c|}{WL substree \citep{douglas2011weisfeiler}} & 90.4  5.7 & 59.9  4.3  \\ 
\multicolumn{2}{|c|}{Patchysan \citep{niepert2016learning}}  &  92.6  4.2 & 60.0  4.8  \\ 
\multicolumn{2}{|c|}{GIN \citep{xu2018how}}  &  89.4  5.6 & 64.6  7.0  \\ \hline 
\multicolumn{2}{|c|}{Pre-training strategy} &\multicolumn{2}{c|}{\multirow{2}{*}{Cross validation split}} \\ \cline{1-2}
Graph-level & Node-level & \multicolumn{2}{c|}{} \\ \hline
-- & -- & 89.3  7.4 & 62.4  6.3  \\ 
-- & Infomax  &  89.8  5.6 & 65.9  3.9  \\ 
-- & EdgePred & 91.9  7.0 & 66.5  5.7  \\ \hdashline
-- & Masking  &  91.4  5.0 & 64.4  7.3  \\ 
-- & ContextPred  &  92.4  7.1 & 68.3  7.8  \\ \hline
Supervised & --   &  90.9  5.8 & 64.7  7.9  \\  
Supervised & Infomax  &   90.9  5.4 & 63.0  9.3  \\ 
Supervised & EdgePred  &   91.9  4.2 & 63.5  8.2  \\ \hdashline
Supervised & Masking  & 90.3  3.3 & 60.9  9.1  \\  
Supervised & ContextPred  & 92.5  5.0 & 66.5  5.2 \\   \hline
\end{tabular}\vspace{0.2cm}
 \caption{{\bf 10-fold cross validation accuracy (\%) on classic graph classification benchmarks using different pre-training strategies with GIN.} All the previous results are excerpted from \citet{xu2018how}.}
 \label{table:result_classical_mol}
\end{table}


\section{Details of molecular datasets} \label{app:molecule-feat}



{\bf Input graph representation.} For simplicity, we use a minimal set of node and bond features that unambiguously describe the two-dimensional structure of molecules. We use RDKit \citep{landrum2006rdkit} to obtain these features.
\begin{itemize}
  \setlength{\parskip}{0cm}
  \setlength{\itemsep}{0cm}
\item Node features: 
\begin{itemize}
  \setlength{\parskip}{0cm}
  \setlength{\itemsep}{0cm}
\item Atom number: [1, 118]
\item Chirality tag: \{unspecified, tetrahedral cw, tetrahedral ccw, other\}
\end{itemize}
\item Edge features:
\begin{itemize}
  \setlength{\parskip}{0cm}
  \setlength{\itemsep}{0cm}
\item Bond type: \{single, double, triple, aromatic\}
\item Bond direction: \{--, endupright, enddownright\}
\end{itemize}
\end{itemize}



\label{app:moleculenet}
{\bf Downstream task datasets.} 8 binary graph classification datasets from Moleculenet \citep{wu2018moleculenet} are used to evaluate model performance. 

\begin{itemize}
\item {\bf BBBP.} Blood-brain barrier penetration (membrane permeability) \citep{martins2012bayesian}.
\item {\bf Tox21.} Toxicity data on 12 biological targets, including nuclear receptors and stress response pathways \citep{TOX21}.
\item {\bf ToxCast.} Toxicology measurements based on over 600 in vitro high-throughput screenings \citep{richard2014toxcast}.
\item {\bf SIDER.} Database of marketed drugs and adverse drug reactions (ADR), grouped into 27 system organ classes \citep{kuhn2015sider}.
\item {\bf ClinTox.} Qualitative data classifying drugs approved by the FDA and those that have failed clinical trials for toxicity reasons \citep{novick2013sweetlead, AACT}.
\item {\bf MUV.} Subset of PubChem BioAssay by applying a refined nearest neighbor analysis, designed for validation of virtual screening techniques \citep{gardiner2011effectiveness}.
\item {\bf HIV.} Experimentally measured abilities to inhibit HIV replication \citep{HIV}.
\item {\bf BACE.} Qualitative binding results for a set of inhibitors of human -secretase 1 \citep{subramanian2016computational}.
\end{itemize}

\section{Details of protein datasets} 
\label{app:protein-feat}
{\bf Input graph representation.} The protein subgraphs only have edge features.
\begin{itemize}
\item Edge features:
\begin{itemize}
\item Neighbourhood: \{True, False\}
\item Fusion:  \{True, False\}
\item Co-occurrence:  \{True, False\}
\item Co-expression:  \{True, False\}
\item Experiment:  \{True, False\}
\item Database:  \{True, False\}
\item Text:  \{True, False\}
\end{itemize}
\end{itemize}

These edge features indicate whether a particular type of relationship exists between a pair of proteins:
\begin{itemize}
\item Neighbourhood: if a pair of genes are consistently observed in each others genome neighbourhood
\item Fusion: if a pair of proteins have their respective orthologs fused into a single protein-coding gene in another organism
\item Co-occurrence: if a pair of proteins tend to be observed either as present or absent in the same subset of organisms
\item Co-expression: if a pair of proteins share similar expression patterns 
\item Experiment: if a pair of proteins are experimentally observed to physically interact with each other
\item Database: if a pair of proteins belong to the same pathway, based on assessments by a human curator 
\item Text mining: if a pair of proteins are mentioned together in PubMed abstracts
\end{itemize}

\label{app:protein-pt}
{\bf Datasets.} A dataset containing protein subgraphs from 50 species is used \citep{Zitnik2019}. The original PPI networks do not have node attributes, but contain edge attributes that correspond to the degree of confidence for 7 different types of protein-protein relationships. The edge weights range from 0, which indicates no evidence for the specific relationship, to 1000, which indicates the highest confidence. The weighted edges of the PPI networks are thresholded such that the distribution of edge types across the 50 PPI networks are uniform. Then, for every node in the PPI networks, subgraphs centered on each node were generated by: (1) performing a breadth first search to select the subgraph nodes, with a search depth limit of 2 and a maximum number of 10 neighbors randomly expanded per node, (2) including the selected subgraph nodes and all the edges between those nodes to form the resulting subgraph. 

The entire dataset contains 394,925 protein subgraphs derived from 50 species. Out of these 50 species, 8 species (arabidopsis, celegans, ecoli, fly, human, mouse, yeast, zebrafish) have proteins with GO protein annotations. The dataset contains 88,000 protein subgraphs from these 8 species, of which 57,448 proteins have at least one positive coarse-grained GO protein annotation and 22,876 proteins have at least one positive fine-grained GO protein annotation. For the self-supervised pre-training dataset, we use all 394,925 protein subgraphs. 

We define \emph{fine-grained protein functions} as Gene Ontology (GO) annotations
that are leaves in the GO hierarchy, and define \emph{coarse-grained protein functions} as GO annotations that are the immediate parents of leaves \citep{ashburner2000gene, gene2018gene}. For example, a fine-grained protein function is ``Factor XII activation'', while a coarse-grained function is ``positive regulation of protein''. The former is a specific type of the latter, and is much harder to derive experimentally. The GO hierarchy information is obtained using GOATOOLS \citep{klopfenstein2018goatools}.
The supervised pre-training dataset and the downstream evaluation dataset are derived from the 8 labeled species, as described in Appendix \ref{sec:data_splitting}.
The 40-th most common \emph{fine-grained} protein label only has 121 positively annotated proteins, while the 40-th most common \emph{coarse-grained} protein label has 9386 positively annotated proteins. This illustrates the extreme label scarcity of our downstream tasks.

For supervised pre-training, we combine the train, validation, and prior sets described previously, with the 5,000 most common coarse-grained protein function annotations as binary labels. For our downstream task, we predict the 40 most common fine-grained protein function annotations, to ensure that each protein function has at least 10 positive labels in our test set.


\section{Details of dataset splitting}
\label{sec:data_splitting}
For molecular prediction tasks, following \citet{Ramsundar-et-al-2019}, we cluster molecules by scaffold (molecular graph substructure) \citep{bemis1996}, and recombine the clusters by placing the most common scaffolds in the training set, producing validation and test sets that contain structurally different molecules. Prior work has shown that this \emph{scaffold split} provides a more realistic estimate of model performance in prospective evaluation compared to random split \citep{chen2012,sheridan2013}. The split  for train/validation/test sets is 80\%:10\%:10\%. 

In the PPI network, \emph{species split} simulates a scenario where we have only high-level \emph{coarse-grained} knowledge on a subset of proteins (prior set) in a species of interest (human in our experiments), and want to predict \emph{fine-grained} biological functions for the rest of the proteins in that species (test set). For species split, we use 50\% of the protein subgraphs from human as test set, and 50\% as a prior set containing only coarse-grained protein annotations. The protein subgraphs from 7 other labelled species (arabidopsis, celegans, ecoli, fly, mouse, yeast, zebrafish) are used as train and validation sets, which are split 85\% : 15\%. The effective split ratio for the train/validation/prior/test sets is 69\% : 12\% : 9.5\% : 9.5\%. 

\section{Time complexity of pre-training}
\label{app:complexity}
Here we analyze the time complexity for processing graphs in Attribute Masking and Context Prediction.
First, the time complexity for Attribute Masking is linear with respect to the number of edges/nodes as it only involves sampling nodes/edges to be masked.
Second, the time complexity for Context Prediction is again linear with respect to the number of edges/nodes, because it involves sampling a center node per graph plus extracting -hop neighborhood and context graph. Extracting the neighborhood/context graphs is performed by the breadth-first search, which takes at most linear time with respect to the number of edges in the graph. 
In summary, the time complexity for both of our pre-training methods are at most linear with respect to the number of edges, which is as efficient as message-passing computation in GNNs, and thus, is as efficient as the ordinary supervised learning using GNNs. Also, there is almost no memory overhead as we transform data (e.g., mask input node/edge features, sample the context graphs) on-the-fly.

\section{Further details of the experimental setup}
\label{app:furthre_setup}
{\bf Optimization.}
All models are trained with Adam optimizer \citep{kingma2014adam} with a learning rate of 0.001. We use Pytorch \citep{paszke2017automatic} and Pytorch Geometric \citep{fey2019fast} for all of our implementation. We run all pre-training methods for 100 epochs.
For self-supervised pre-training, we use a batch size of 256, while for supervised pre-training, we use a batch size of 32 with dropout rate of 20\%. 

{\bf Fine-tuning.}
After pre-training, we follow the procedure in Section \ref{subsec:finetune} to fine-tune the models on the training sets of the downstream datasets. We use a batch size of 32 and dropout rate of 50\%. Datasets with multiple prediction tasks are fit jointly. On the molecular property prediction datasets, we train models for 100 epochs, while on the protein function prediction dataset (with the 40 binary prediction tasks), we train models for 50 epochs. 

{\bf Evaluation.} We evaluate test performance on downstream tasks using ROC-AUC \citep{bradley1997use} with the validation early stopping protocol, \ie, test ROC-AUC at the best validation epoch is reported. For datasets with multiple prediction tasks, we take the average ROC-AUC across all their tasks. The downstream experiments are run with 10 random seeds, and we report mean ROC-AUC and standard deviation. 

{\bf Computation time for pre-training.}
The computation time for the two stages of our pre-training is reported below.
{\bf Chemistry:} Self-supervised pre-training takes about 24 hours, while supervised pre-training takes about 11 hours.
{\bf Biology:} Self-supervised pre-training takes about 3.8 hours, while supervised pre-training takes about 2.5 hours.

\section{Comparison of pre-training with different GNN architectures}
\label{app:gnn_type_comp}
Table \ref{table:result_molecule_gnn_type} shows the detailed comparison of different GNN architectures on the chemistry datasets.
We see that the most expressive GIN architectures benefit most from pre-training compared to the other less expressive models.

\begin{table}[t]
\centering
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|cccccccc|c|} \hline
  \multicolumn{2}{|c|}{Dataset}        & BBBP & Tox21 & ToxCast & SIDER & ClinTox & MUV & HIV & BACE & {\bf Average}\\\hline
  \multicolumn{2}{|c|}{\# Molecules}  & 2039  & 7831  &  8575  & 1427  & 1478  & 93087 & 41127 & 1513 & / \\ 
  \multicolumn{2}{|c|}{\# Binary prediction tasks}  & 1      &  12      & 617      & 27   &  2    & 17  & 1  & 1 & / \\ \hline \hline
\multicolumn{2}{|c|}{Configuration} &\multicolumn{9}{c|}{\multirow{2}{*}{Out-of-distribution prediction (scaffold split)}} \\ \cline{1-2}
Architecture & Pre-train? & \multicolumn{9}{c|}{} \\ \hline
GIN & No & 65.8 4.5 & 74.0 0.8 & 63.4 0.6 & 57.3 1.6 & 58.0 4.4 & 71.8 2.5 & 75.3 1.9 & 70.1 5.4 & 67.0 \\ 
GIN & Yes &  68.7 1.3 & {\bf 78.1 0.6} & {\bf 65.7 0.6} & {\bf 62.7 0.8} & {\bf 72.6 1.5} & {\bf 81.3 2.1} & {\bf 79.9 0.7} & {\bf 84.5 0.7} & {\bf 74.2} \\
GCN & No & 64.93.0 & 74.90.8 & 63.30.9 & 60.01.0 & 65.84.5 & 73.21.4 & 75.71.1 & 73.63.0 & 68.9 \\ 
GCN & Yes &  {\bf 70.61.6} & 75.80.3 & {\bf 65.30.1} & 62.40.5 & 63.61.7 & 79.41.8 & 78.20.6 & 82.33.4 & 72.2 \\
GraphSAGE & No & 69.61.9 & 74.70.7 & 63.30.5 & 60.41.0 & 59.24.4 & 72.71.4 & 74.40.7 & 72.51.9 & 68.3 \\ 
GraphSAGE & Yes & 63.92.1 & 76.80.3 & 64.90.2 & 60.70.5 & 60.72.0 & 78.42.0 & 76.21.1 & 80.70.9 & 70.3 \\
GAT & No & 66.22.6 & 75.40.5 & 64.60.6 & 60.91.4 & 58.53.6 & 66.62.2 & 72.91.8 & 69.76.4 & 66.8 \\ 
GAT & Yes &  59.40.5 & 68.10.5 & 59.30.7 & 56.00.5 & 47.61.3 & 65.40.8 & 62.51.6 & 64.31.1 & 60.3 \\
 \hline
\end{tabular}}
\vspace{0.2cm}
 \caption{{\bf Test ROC-AUC (\%) performance on molecular prediction benchmarks with different GNN architectures.} The rightmost column averages the mean of test performance across the 8 datasets. For pre-training, we applied Context Prediction + graph-level supervised pre-training.}
 \label{table:result_molecule_gnn_type}
\end{table}


\section{Additional Training and validation curves}
\label{app:additonal_results}
{\bf Training and validation curves.}
In Figure \ref{fig:chem-curve-scaffold}, we plot training and validation curves for all the datasets used in the molecular property prediction experiments.

{\bf Additional scatter plot comparisons of ROC-AUCs.}
In Figure \ref{fig:scatter-additional}, we compare our Context Prediction + graph-level supervised pre-training with a non-pre-trained model and a graph-level supervised pre-trained model. We see from the left plot that the combined strategy again completely avoids negative transfer across all the 40 downstream tasks. Furthermore, we see from the right plot that additionally adding our node-level Context Prediction pre-training almost always improves ROC-AUC scores of supervised pre-trained models \emph{across the 40 downstream tasks}.


\label{app:training_curves}
\begin{figure}[t]
\includegraphics[width=14cm]{fig/traincurve_chem_scaffoldsplit.pdf}
\caption{{\bf Training and validation curves of different pre-training strategies.} The solid and dashed lines indicate the training and validation curves, respectively.}
\label{fig:chem-curve-scaffold}
\end{figure}

\begin{figure}[t]
\includegraphics[width=14cm]{fig/bio-supp-contextpred.pdf}
\caption{
{\bf Scatter plot comparisons} of ROC-AUC scores of our Context Prediction + graph-level supervised pre-training strategy versus the two baseline strategies (non-pre-trained and graph-level supervised pre-trained) on the 40 individual downstream tasks of predicting different fine-grained protein function labels.
}
\label{fig:scatter-additional}
\end{figure} 
\end{document}
