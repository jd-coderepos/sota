\documentclass{article}



\usepackage[final]{neurips_2019_ml4ad}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{color} 
\usepackage{xcolor,colortbl}

\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{changepage}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{multirow,booktabs,setspace,caption}
\graphicspath{{figures/}}
\def\code#1{\texttt{#1}}


\definecolor{gray.220}{RGB}{220, 220, 220}
\newcommand{\highlight}[1]{{\cellcolor{gray.220} #1}}

\title{Benchmarking Robustness in Object~Detection:\\Autonomous Driving when Winter is Coming}

\author{Claudio~Michaelis* \\
  \And
  Benjamin~Mitzkus* \\
  \And
  Robert~Geirhos* \\
  \And
  Evgenia~Rusak* \\
  \And
  Oliver~Bringmann\textsuperscript{} \\
  \And
  Alexander~S.~Ecker\textsuperscript{} \\
  \And
  Matthias~Bethge\textsuperscript{} \\
  \And
  Wieland~Brendel\textsuperscript{} \\
  University of T\"ubingen \\
  \texttt{first.last@uni-tuebingen.de} \\
}






\begin{document}

\maketitle

\begin{abstract}
    The ability to detect objects regardless of image distortions or weather conditions is crucial for real-world applications of deep learning like autonomous driving. We here provide an easy-to-use benchmark to assess how object detection models perform when image quality degrades. The three resulting benchmark datasets, termed Pascal-C, Coco-C and Cityscapes-C, contain a large variety of image corruptions. We show that a range of standard object detection models suffer a severe performance loss on corrupted images (down to 30--60\% of the original performance). However, a simple data augmentation trick---stylizing the training images---leads to a substantial increase in robustness across corruption type, severity and dataset. We envision our comprehensive benchmark to track future progress towards building robust object detection models. Benchmark, code and data are publicly available.
\end{abstract}




\begin{figure}[h!]
    \textbf{clean data\hspace{90pt}light snow\hspace{90pt}heavy snow}
    \centering
    \includegraphics[width=\linewidth]{figures/introduction/snow_figure.png}
    \caption{Mistaking a dragon for a bird (left) may be dangerous but missing it altogether because of snow (right) means playing with fire. Sadly, this is exactly the fate that an autonomous agent relying on a state-of-the-art object detection system would suffer. Predictions generated using Faster R-CNN; best viewed on screen.}
    \label{fig:teaser}
    \vspace{-0.2cm}
\end{figure}

\section{Introduction}
  \label{Introduction}
\begin{adjustwidth}{30pt}{30pt}
\textit{A day in the near future: Autonomous vehicles are swarming the streets all over the world, tirelessly collecting data. But on this cold November afternoon traffic comes to an abrupt halt as it suddenly begins to snow: winter is coming. Huge snowflakes are falling from the sky and the cameras of autonomous vehicles are no longer able to make sense of their surroundings, triggering immediate emergency brakes. A day later, an investigation of this traffic disaster reveals that the unexpectedly large size of the snowflakes was the cause of the chaos: While state-of-the-art vision systems had been trained on a variety of common weather types, their training data contained hardly any snowflakes of this size...
}\\
\end{adjustwidth}

\noindent
This fictional example highlights the problems that arise when Convolutional Neural Networks (CNNs) encounter settings that were not explicitly part of their training regime. For example, state-of-the-art object detection algorithms such as Faster R-CNN \citep{Ren2015} fail to recognize objects when snow is added to an image (as shown in Figure~\ref{fig:teaser}), even though the objects are still clearly visible to a human eye. At the same time, augmenting the training data with several types of distortions is not a sufficient solution to achieve general robustness against previously unknown corruptions: It has recently been demonstrated that CNNs generalize poorly to novel distortion types, despite being trained on a variety of other distortions \citep{Geirhos2018generalisation}. 

\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/introduction/teaser_bdd100k.jpg}
    \caption{Expect the unexpected: To ensure safety, an autonomous vehicle must be able to recognize objects even in challenging outdoor conditions such as fog, rain, snow and at night.\protect\footnotemark}
    \label{fig:outdoor_hazards}
\end{figure}
\footnotetext{Outdoor hazards have been directly linked to increased mortality rates \citep{lystad2018death}.}

On a more general level, CNNs often fail to generalize outside of the training domain or training data distribution. Examples include the failure to generalize to images with uncommon poses of objects \citep{alcorn2019strike} or to cope with small distributional changes \cite[e.g.][]{zech2018variable, touvron2019fixing}. One of the most extreme cases are adversarial examples \citep{szegedy2013intriguing}: images with a domain shift so small that it is imperceptible for humans yet sufficient to fool a DNN. We here focus on the less extreme but far more common problem of perceptible image distortions like blurry images, noise or natural distortions like snow.

As an example, autonomous vehicles need to be able to cope with wildly varying outdoor conditions such as fog, frost, snow, sand storms, or falling leaves, just to name a few (as visualized in Figure~\ref{fig:outdoor_hazards}). One of the major reasons why autonomous cars have not yet gone mainstream is the inability of their recognition models to function well in adverse weather conditions \citep{dai2018dark}. Getting data for unusual weather conditions is hard and while many common environmental conditions can (and have been) modelled, including fog \citep{Sakaridis18foggycityscapes}, rain \citep{hospach2016}, snow \citep{bernuth2019} and daytime to nighttime transitions \citep{dai2018dark}, it is impossible to foresee all potential conditions that might occur ``in the wild''.

If we could build models that are robust to every possible image corruption, it   is to be expected that weather changes would not be an issue. However, in order to assess the robustness of models one first needs to define a measure. While testing models on the set of all possible corruption types is impossible. We therefore propose to evaluate models on a diverse range of corruption types that were not part of the training data and demonstrate that this is a useful approximation for predicting performance under natural distortions like rain, snow, fog or the transition between day and night.

More specifically we propose three easy-to-use benchmark datasets termed PASCAL-C, COCO-C and Cityscapes-C to assess distortion robustness in object detection. Each dataset contains versions of the original object detection dataset which are corrupted with 15 distortions, each spanning five levels of severity. This approach follows \cite{hendrycks2018benchmarking}, who introduced corrupted versions of commonly used \textit{classification} datasets (ImageNet-C, CIFAR10-C) as standardized benchmarks. After evaluating standard object detection algorithms on these benchmark datasets, we show how a simple data augmentation technique---stylizing the training images---can strongly improve robustness across corruption type, severity and dataset.


\subsection{Contributions}
Our contributions can be summarized as follows:
\begin{enumerate}
    \item We demonstrate that a broad range of object detection and instance segmentation models suffer severe performance impairments on corrupted images.
    \item To quantify this behaviour and to enable tracking future progress, we propose the \texttt{Robust Detection Benchmark}, consisting of three benchmark datasets termed PASCAL-C, COCO-C \& Cityscapes-C.
    \item We demonstrate that improved performance on this benchmark of synthetic corruptions corresponds to increased robustness towards real-world ``natural'' distortions like rain, snow and fog.
    \item We use the benchmark to show that corruption robustness scales with performance on clean data and that a simple data augmentation technique---stylizing the training data---leads to large robustness improvements for all evaluated corruptions without any additional labelling costs or architectural changes.
   
    \item We make our benchmark, corruption and stylization code openly available in an easy-to-use fashion:
    
    \begin{itemize}
        \item Benchmark,
        \footnote{Our evaluation code to assess performance under corruption has been integrated into one of the most widely used detection toolboxes. The code can be found here: \url{https://github.com/bethgelab/mmdetection}}
        data and data analysis are available at \url{https://github.com/bethgelab/robust-detection-benchmark}.
        \item Our pip installable image corruption library is available at \url{https://github.com/bethgelab/imagecorruptions}.
        \item Code to stylize arbitrary datasets is provided at \url{https://github.com/bethgelab/stylize-datasets}.
    \end{itemize}
   
\end{enumerate}


\subsection{Related Work}

\paragraph{Benchmarking corruption robustness}
Several studies investigate the vulnerability of CNNs to common corruptions. \citet{dodge2016understanding} measure the performance of four state-of-the-art image recognition models on out-of-distribution data and show that CNNs are in particular vulnerable to blur and Gaussian noise. \citet{Geirhos2018generalisation} show that CNN performance drops much faster than human performance for the task of recognizing corrupted images when the perturbation level increases across a broad range of corruption types. \citet{azulay2018deep} investigate the lack of invariance of several state-of-the-art CNNs to small translations.
A benchmark to evaluate the robustness of recognition models against common corruptions was recently introduced by \citet{hendrycks2018benchmarking}.

\paragraph{Improving corruption robustness} One way to restore the performance drop on corrupted data is to preprocess the data in order to remove the corruption. \citet{mukherjee2018visual} propose a DNN-based approach to restore image quality of rainy and foggy images.
\citet{bahnsen2018rainremoval} and \citet{bahnsen2019rainremovalsynthetic} propose algorithms to remove rain from images as a preprocessing step and report a subsequent increase in recognition rate. A challenge for these approaches is that noise removal is currently specific to a certain distortion type and thus does not generalize to other types of distortions. 
Another line of work seeks to enhance the classifier performance by the means of data augmentation, i.e. by directly including corrupted data into the training.
\citet{Vasiljevic2016blur} study the vulnerability of a classifier to blurred images and enhance the performance on blurred images by fine-tuning on them.
\citet{Geirhos2018generalisation} examine the generalization between different corruption types and find that fine-tuning on one corruption type does not enhance performance on other corruption types.
In a different study, \citet{geirhos2019imagenettrained} train a recognition model on a stylized version of the ImageNet dataset \citep{Russakovsky2015}, reporting increased general robustness against different corruptions as a result of a stronger bias towards ignoring textures and focusing on object shape.
\citet{hendrycks2018benchmarking} report several methods leading to enhanced performance on their corruption benchmark: Histogram Equalization, Multiscale Networks, Adversarial Logit Pairing, Feature Aggregating and Larger Networks.

\paragraph{Evaluating robustness to environmental changes in autonomous driving}
In recent years, weather conditions turned out to be a central limitation for state-of-the art autonomous driving systems \citep{Sakaridis18foggycityscapes, volk2019, dai2018dark, chen2018domain, lee2018selfdrivingadverseweather}. While many specific approaches like modelling weather conditions \citep{Sakaridis18foggycityscapes, Sakaridis18foggyadaption, volk2019, bernuth2019, hospach2016, Bernuth2018RenderingPC} or collecting real \citep{Wen15detrac, yu2018bdd100k, che2019d2city, nuscenes2019} and artificial \citep{gaidon2016virtualkitti, Ros2016synthia, Richter2017vipergtav, Johnson-Roberson2017matrix} datasets with varying weather conditions, no general solution towards the problem has yet emerged.
\citet{DBLP:journals/corr/RadeckiCM16} experimentally test the performance of various sensors and object recognition and classification  models in adverse weather and lighting conditions.
\citet{Bernuth2018RenderingPC} report a drop in the performance of a Recurrent Rolling Convolution network trained on the KITTI dataset when the camera images are modified by simulated raindrops on the windshield.
\citet{pei2017towards} introduce VeriVis, a framework to evaluate the security and robustness of different object recognition models using real-world image corruptions such as brightness, contrast, rotations, smoothing, blurring and others. \citet{harshitha2018} propose a metric to evaluate the degradation of object detection performance of an autonomous vehicle in several adverse weather conditions evaluated on the Virtual KITTI dataset. 
Building upon \cite{hospach2016}, \citet{volk2019} study the fragility of an object detection model against rainy images, identify corner cases where the model fails and include images with synthetic rain variations into the training set. They report enhanced performance on real rain images.
\citet{bernuth2019} model photo-realistic snow and fog conditions to augment real and virtual video streams. They report a significant performance drop of an object detection model when evaluated on corrupted data. \section{Methods}
  \label{methods}
\subsection{Robust Detection Benchmark}
\label{meth:benchmark}
We introduce the \texttt{Robust Detection Benchmark} inspired by the ImageNet-C benchmark for object classification \citep{hendrycks2018benchmarking} to assess object detection robustness on corrupted images. 

\paragraph{Corruption types} Following \cite{hendrycks2018benchmarking}, we provide 15 corruptions on five severity levels each (visualized in Figure~\ref{fig: pascal_corrupted}) to assess the effect of a broad range of different corruption types on object detection models.\footnote{These corruption types were introduced by \cite{hendrycks2018benchmarking} and modified by us to work with images of arbitrary dimensions. Our generalized corruptions can be found at \url{https://github.com/bethgelab/imagecorruptions}
and installed via \texttt{pip3 install imagecorruptions}.} The corruptions are sorted into four groups: noise, blur, digital and weather groups (as defined by \cite{hendrycks2018benchmarking}).
It is important to note that the corruption types are \textit{not} meant to be used as a training data augmentation toolbox, but rather to measure a model's robustness against \textit{previously unseen} corruptions. Thus, training should be done without using any of the provided corruptions. For model validation, four separate corruptions are provided (Speckle Noise, Gaussian Blur, Spatter, Saturate). The 15 corruptions described above should only be used to test the final model performance.


\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/methods/corruption_types.png}
    \caption{15 corruption types from \cite{hendrycks2018benchmarking}, adapted to corrupt arbitrary images (example: randomly selected PASCAL VOC image, center crop, severity 3). Best viewed on screen.}
    \label{fig: pascal_corrupted}
    \vspace{-0.2cm}
\end{figure}

\paragraph{Benchmark datasets} The \texttt{Robust Detection Benchmark} consists of three benchmark datasets: PASCAL-C, COCO-C and Cityscapes-C. Among the vast number of available object detection datasets \citep{Everingham2010, Geiger2012, Lin2014, Cordts2016, Zhou2017, Neuhold2017, Krasin2017}, we chose to use PASCAL VOC \citep{Everingham2010}, MS COCO \citep{Lin2014} and Cityscapes \citep{Cordts2016} as they are the most commonly used datasets for general object detection (PASCAL \& COCO) and street scenes (Cityscapes).
We follow common conventions to select the tests splits: VOC2007 test set for PASCAL-C, the COCO 2017 validation set for COCO-C and the Cityscapes validation set for Cityscapes-C.

\paragraph{Metrics} Since performance measures differ between the original datasets, the dataset-specific performance (P) measures are adopted as defined below:

\noindent
where  stands for the PASCAL `Average Precision' metric at 50\% Intersection over Union (IoU) and AP stands for the COCO `Average Precision' metric which averages over IoUs between 50\% and 95\%.
On the corrupted data, the benchmark performance is measured in terms of mean performance under corruption (mPC):

\noindent
Here,  is the dataset-specific performance measure evaluated on test data corrupted with corruption  under severity level  while  and  indicate the number of corruptions and severity levels, respectively. In order to measure relative performance degradation under corruption, the relative performance under corruption (rPC) is introduced as defined below:

\noindent
rPC measures the relative degradation of performance on corrupted data compared to clean data.

\paragraph{Submissions} Submissions to the benchmark should be handed in as a simple pull request to the \texttt{Robust Detection Benchmark}\footnote{\url{https://github.com/bethgelab/robust-detection-benchmark}} and need to include all three performance measures: clean performance (), mean performance under corruption (mPC) and relative performance under corruption (rPC). While mPC is the metric used to rank models on the \texttt{Robust Detection Benchmark}, the other measures provide additional insights, as they disentangle gains from higher clean performance (as measured by ) and gains from better generalization performance to corrupted data (as measured by rPC).


\paragraph{Baseline models}
We provide baseline results for a set of common object detection models including Faster R-CNN \citep{Ren2015}, Mask R-CNN \citep{He2017}, Cascade R-CNN \citep{Cai18cascadercnn}, Cascade Mask R-CNN \citep{Chen2019hybrid}, RetinaNet \citep{Lin2017b} and Hybrid Task Cascade \citep{Chen2019hybrid}. We use a ResNet50 \citep{He2016} with Feature Pyramid Networks \citep{Lin2017} as backbone for all models except for Faster R-CNN where we additionally test ResNet101 \citep{He2016}, ResNeXt101-32x4d \citep{Xie2017resnext} and ResNeXt-64x4d \citep{Xie2017resnext} backbones. We additionally provide results for Faster R-CNN and Mask R-CNN models with deformable convolutions \citep{dai2017deformable, zhu2018deformable} in Appendix ~\ref{appendix:results}. Models were evaluated using the \texttt{mmdetection toolbox} \citep{mmdetection}; all models were trained and tested with standard hyperparameters. The details can be found in Appendix ~\ref{appendix:implementation}.

\subsection{Style transfer as data augmentation}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/methods/stylization_figure.png}
    \caption{Training data visualization for COCO and Stylized-COCO. The three different training settings are: standard data (top row), stylized data (bottom row) and the concatenation of both (termed `combined' in plots).}
    \label{fig:stylization}
    \vspace{-0.2cm}
\end{figure}

For image classification, style transfer \citep{gatys2016image}---the method of combining the content of an image with the style of another image---has been shown to strongly improve corruption robustness \citep{geirhos2019imagenettrained}. We here transfer this method to object detection datasets testing two settings: (1) Replacing each training image with a stylized version and (2) adding a stylized version of each image to the existing dataset. We apply the fast style transfer method AdaIN \citep{huang2017arbitrary} with hyperparameter \texttt{} to the training data, replacing the original texture with the randomly chosen texture information of Kaggle's \texttt{Painter by Numbers}\footnote{\url{https://www.kaggle.com/c/painter-by-numbers/}} dataset. Examples for the stylization of COCO images are given in Figure~\ref{fig:stylization}. We provide ready-to-use code for the stylization of arbitrary datasets at \url{https://github.com/bethgelab/stylize-datasets}.


\subsection{Natural Distortions}

\paragraph{Foggy Cityscapes}
Foggy Cityscapes \cite{Sakaridis18foggycityscapes} is a version of Cityscapes with synthetic fog in three severity levels (given byt he attenuation coefficient  = 0.005, 0.01 and 0.02), that was carefully designed to look as realistic as possible. 
We use Fogy Cityscapes only at test time, testing the same models as used for our experiments with the original Cityscapes dataset and report results in the same AP metric.

\paragraph{BDD100k}
BDD100k \cite{yu2018bdd100k} is a driving dataset consisting of 100 thousand videos of driving scenes recorded in varying conditions including weather changes and different times of the day\footnote{The frame at the 10th second of each video is annotated with additional information including bounding boxes which we use for our experiments}. We use these annotations to perform experiments, on different weather conditions ("clear", "rainy" and "snowy") and on the transition from day to night. Training is performed on what we would consider "clean" data - clear for weather and daytime for time - and evaluation is performed on all three splits. We use Faster R-CNN with the same hyper-parameters as in our experiments on COCO. Details of the dataset preparation can be found in Appendix~\ref{appendix:natural_distortions}. \section{Results}
  \label{results}
  
\subsection{Image corruptions reduce model performance}
In order to assess the effect of image corruptions, we evaluated a set of common object detection models on the three benchmark datasets defined in Section~\ref{methods}. Performance is heavily degraded on corrupted images (compare Table~\ref{table:results_corruption_benchmark}). While Faster R-CNN can retain roughly 60\% relative performance (rPC) on the rather simple images in PASCAL VOC, the same model suffers a dramatic reduction to 33\% rPC on the Cityscapes dataset, which contains many small objects. With some variations, this effect is present in all tested models and also holds for instance segmentation tasks (for instance segmentation results, please see Appendix~\ref{appendix:results}).

\begin{table}[t!]\footnotesize
\begin{center}
\begin{tabular}{c|c|ccc}
\multicolumn{5}{c}{PASCAL VOC} \\
\toprule
\multicolumn{2}{c}{} & clean & corrupted & relative\\
model & backbone & P [] & mPC []& rPC \small{[\%]}\\
\hline
Faster & r50 & 80.5 & 48.6 & 60.4\\
\bottomrule

\multicolumn{5}{c}{} \\
\multicolumn{5}{c}{MS COCO} \\
\toprule
\multicolumn{2}{c}{} & clean & corrupted & relative\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Faster & r50 & 36.3 & 18.2 & 50.2\\
Faster & r101 & 38.5 & 20.9 & 54.2\\
Faster & x101-32x4d & 40.1 & 22.3 & 55.5\\
Faster & x101-64x4d & 41.3 & 23.4 & 56.6\\
\hline
Mask & r50 & 37.3 & 18.7 & 50.1\\
Cascade & r50 & 40.4 & 20.1 & 49.7\\
Cascade Mask & r50 & 41.2 & 20.7 & 50.2\\
RetinaNet & r50 & 35.6 & 17.8 & 50.1\\
HTC & x101-64x4d & 50.6 & 32.7 & 64.7\\
\bottomrule

\multicolumn{5}{c}{} \\
\multicolumn{5}{c}{Cityscapes}\\
\toprule
\multicolumn{2}{c}{} & clean & corrupted & relative\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Faster & r50 & 36.4 & 12.2 & 33.4\\
Mask & r50 & 37.5 & 11.7 & 31.1\\
\bottomrule
\end{tabular}
\caption{Object detection performance of various models. Backbones indicated with  are ResNet and  ResNeXt. All model names except for  RetinaNet and HTC indicate the corresponding model from the R-CNN family.  All COCO models were downloaded from the \texttt{mmdetection} modelzoo. For all reported quantities: higher is better; square brackets denote metric.}
\label{table:results_corruption_benchmark}
\vspace{-1.0cm}
\end{center}
\end{table}


\subsection{Robustness increases with backbone capacity}
We test variants of Faster R-CNN with different backbones (top of Table~\ref{table:results_corruption_benchmark}) and different head architectures (bottom of Table~\ref{table:results_corruption_benchmark}) on COCO. For the models with different backbones, we find that all image corruptions---except for the blur types---induce a fixed penalty to model performance, independent of the baseline performance on clean data:  (compare Table~\ref{table:results_corruption_benchmark} and Appendix Figure~\ref{fig:results_Coco_backbones}). Therefore, models with more powerful backbones show a relative performance improvement under corruption.\footnote{This finding is further supported by investigating models with deformable convolutions (see Appendix~\ref{appendix:results}).} 
In comparison, Mask R-CNN, Cascade R-CNN and Cascade Mask R-CNN which draw their performance increase from more sophisticated head architectures all have roughly the same rPC of  50\%. 
The current state-of-the-art model Hybrid Task Cascade \citep{Chen2019hybrid} is in so far an exception as it employs a combination of a stronger backbone, improved head architecture and additional training data to not only outperform the strongest baseline model by 9\% AP on clean data but distances itself on corrupted data by a similar margin, achieving a leading relative performance under corruption (rPC) of 64.7\%.
These results indicate that robustness in the tested regime can be improved primarily through a better image encoding, and better head architectures cannot extract more information if the primary encoding is already sufficiently impaired.

\begin{figure}[t!]
\captionsetup[subfigure]{justification=centering}
	\centering
	\subfloat[][PASCAL-C]{\includegraphics[width=0.33\linewidth]{figures/results/pascal_corruption_overall.pdf}}
	\subfloat[][COCO-C]{\includegraphics[width=0.33\linewidth]{figures/results/coco_corruption_overall.pdf}}
	\subfloat[][Cityscapes-C]{\includegraphics[width=0.33\linewidth]{figures/results/cityscapes_corruption_overall.pdf}}
	\vspace{-0.15cm}
	\caption{Figure 5: Training on stylized data improves test performance of Faster R-CNN on corrupted versions of PASCAL VOC, MS COCO and Cityscapes which include all 15 types of corruptions shown in Figure~\ref{fig: pascal_corrupted}. Corruption severity 0 denotes clean data. Corruption specific performances are shown in the appendix (Figures~\ref{fig:results_pascal_individual},~\ref{fig:results_Coco_individual},~\ref{fig:results_cityscapes_individual}).
}
	\label{fig:results_combined}
	\vspace{-0.2cm}
\end{figure}


\subsection{Training on stylized data improves robustness}
\label{subse:stylized_training}
In order to reduce the strong effect of corruptions on model performance observed above, we tested whether a simple approach (stylizing the training data) leads to a robustness improvement. We evaluate the exact same model (Faster R-CNN) with three different training data schemes (visualized in Figure~\ref{fig:stylization}):
\begin{itemize}[leftmargin=2.6cm, nosep]
    \item[\textbf{standard:}] the unmodified training data of the respective dataset
    \item[\textbf{stylized:}] the training data is stylized completely
    \item[\textbf{combined:}] concatenation of standard and stylized training data
\end{itemize}

\noindent
The results across our three datasets PASCAL-C, COCO-C and Cityscapes-C are visualized in Figure~\ref{fig:results_combined}. We observe a similar pattern as reported by \cite{geirhos2019imagenettrained} for object classification on ImageNet---a model trained on stylized data suffers less from corruptions than the model trained only on the original clean data. However, its performance on clean data is much lower. Combining stylized and clean data seems to achieve the best of both worlds: high performance on clean data as well as strongly improved performance under corruption. From the results in Table~\ref{table:results_stylized}, it can be seen that both stylized and combined training improve the relative performance under corruption (rPC). Combined training yields the highest absolute performance under corruption (mPC) for all three datasets. This pattern is fairly consistent. Detailed results across corruption types are reported in the Appendix (Figure~\ref{fig:results_pascal_individual}, Figure~\ref{fig:results_Coco_individual} and  Figure~\ref{fig:results_cityscapes_individual}).


\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|ccc|ccc|ccc}
\toprule
 &\multicolumn{3}{c|}{PASCAL VOC []} & \multicolumn{3}{c|}{MS COCO [AP]} & \multicolumn{3}{c}{Cityscapes [AP]} \\
& clean & \highlight{corr.} & rel. & clean & \highlight{corr.} & rel. & clean & \highlight{corr.} & rel.\\
train data & P & \highlight{mPC} & rPC [\%] & P & \highlight{mPC} & rPC [\%] & P & \highlight{mPC} & rPC [\%] \\
\hline
standard & \textbf{80.5} & \highlight{48.6} & 60.4 & \textbf{36.3} & \highlight{18.2} & 50.2 & \textbf{36.4} & \highlight{12.2} & 33.4 \\
\hline
stylized & 68.0 & \highlight{50.0} & \textbf{73.5} & 21.5 & \highlight{14.1} & \textbf{65.6} & 28.5 & \highlight{14.7} & \textbf{51.5}\\
combined & 80.4 & \highlight{\textbf{56.2}} & 69.9 & 34.6 & \highlight{\textbf{20.4}} & 58.9 & 36.3 & \highlight{\textbf{17.2}} & 47.4\\
\bottomrule
\end{tabular}
\caption{Object detection performance of Faster R-CNN trained on standard images, stylized images and the combination of both evaluated on standard test sets (test 2007 for PASCAL VOC; val 2017 for MS COCO, val for Cityscapes); higher is better.}
\label{table:results_stylized}
\vspace{-0.3cm}
\end{center}
\end{table}

\subsection{Training directly on stylized data is better than using stylized data only during pre-training}

For comparison reasons, we reimplemented the object detection models from \citet{geirhos2019imagenettrained} and tested them for corruption robustness. Those models use backbones which are pre-trained with Stylized-ImageNet, but the object detection models are trained on the standard clean training sets of Pascal VOC and COCO. In contrast, we here use backbones trained on standard ``clean'' ImageNet and train using stylized Pascal VOC and COCO. We find that stylized pre-training helps not only on clean data (as reported by \cite{geirhos2019imagenettrained}) but also for corruption robustness (Table~\ref{table:results_stylized_pretraining}), albeit less than our approach of performing the final training on stylized data (compare to Table~\ref{table:results_stylized})\footnote{Note that \cite{geirhos2019imagenettrained} use Faster R-CNN without Feature Pyramids (FPN), which is why the baseline performance of these models is different from ours}.

\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|ccc|ccc}
\toprule
 &\multicolumn{3}{c|}{PASCAL VOC []} & \multicolumn{3}{c}{MS COCO [AP]}\\
& clean & \highlight{corr.} & rel. & clean & \highlight{corr.} & rel. \\
train data & P & \highlight{mPC} & rPC [\%] & P & \highlight{mPC} & rPC [\%] \\
\hline
IN & 78.9 & \highlight{45.7} & 57.4 & 31.8 & \highlight{15.5} & 48.7 \\
\hline
SIN & 75.1 & \highlight{48.2} & 63.6 & 29.8 & \highlight{15.3} & 51.3\\
SIN+IN & 78.0 & \highlight{\textbf{50.6}} & \textbf{64.2} & 31.1 & \highlight{16.0} & \textbf{51.4} \\
SIN+IN ft IN & \textbf{79.0} & \highlight{48.9} & 61.4 & \textbf{32.3} & \highlight{\textbf{16.2}} & 50.1 \\
\bottomrule
\end{tabular}
\caption{Object detection performance of Faster R-CNN pre-trained on ImageNet (IN), Stylized ImageNet (SIN) and the combination of both evaluated on standard test sets (test 2007 for PASCAL VOC; val 2017 for MS COCO); higher is better.}
\label{table:results_stylized_pretraining}
\vspace{-0.3cm}
\end{center}
\end{table}



\subsection{Robustness to natural distortions is connected to synthetic corruption robustness}

A central question is whether results on the robust detection benchmark generalize to real-world natural distortions like rain, snow or fog as illustrated in Figure~\ref{fig:outdoor_hazards}. We test this using BDD100k \citep{yu2018bdd100k}, a driving scene dataset with annotations for weather conditions. For our first experiment, we train a model only on images that are taken in ``clear'' weather. We also train models on a stylized version of the same images as well as the combination of both following the protocol from Section~\ref{subse:stylized_training}. We then test these models on images which are annotated to be ``clear'', ``rainy'' or ``snowy'' (see Appendix~\ref{appendix:natural_distortions} for details). We find that these weather changes have little effect on performance on all three models, but that combined training improves the generalization to ``rainy'' and ``snowy'' images (Table~\ref{table:results_bdd100k} Weather). It may be important to note that the weather changes of this dataset are often relatively benign (e.g., images annotated as rainy often show only wet roads instead of rain). 

A stronger test is generalization of a model trained on images taken during daytime to images taken at night which exhibit a strong appearance change. We find that a model trained on images taken during the day performs much worse at night but combined training improves nighttime performance (Table~\ref{table:results_bdd100k} Day/Night and Appendix~\ref{appendix:natural_distortions}).

As a third test of real-world distortions, we test our approach on Foggy Cityscapes \cite{Sakaridis18foggycityscapes} which uses fog in three different strengths (given by the attenuation factor  = 0.005, 0.01 or 0.2) as a highly realistic model of natural fog. Fog drastically reduces the performance of standard models trained on Cityscapes which was collected in clear conditions. The reduction is almost 50\% for the strongest corruption, see Table~\ref{table:results_foggy_cityscapes}. In this strong test for OOD (out-of-distribution) robustness, stylized training increases relative performance substantially from about 50\% to over 70\% (Table~\ref{table:results_foggy_cityscapes}).

Taken together, these results suggest that there is a connection between performance on synthetic and natural corruptions. Our approach of combined training with stylized data improves performance in every single case with increasing gains in harder conditions.

\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|c|cc|cc||c|cc}
\toprule
\multicolumn{2}{c|}{BDD100k [AP]} & \multicolumn{4}{c||}{Weather}& \multicolumn{3}{c}{Day/Night} \\
& clear & \highlight{rainy} & rel. & \highlight{snowy} & rel. & day & \highlight{night} & rel.\\
train data & P & \highlight{mPC} & rPC [\%] & \highlight{mPC} & rPC [\%] & P & \highlight{mPC} & rPC [\%] \\
\hline
clean & \textbf{27.8} & \highlight{27.6} & 99.3  & \highlight{23.6} & 84.9 & \textbf{30.0} & \highlight{21.5} & 71.7 \\
\hline
stylized & 20.9 & \highlight{21.0} & 100.5 & \highlight{18.7} & \textbf{89.5} & 24.0 & \highlight{16.8} & 70.0\\
combined & 27.7 & \highlight{\textbf{28.0}} & \textbf{101.1}  & \highlight{\textbf{24.2}} & 87.4 & \textbf{30.0} & \highlight{\textbf{22.5}} & \textbf{75.0}\\
\bottomrule
\end{tabular}
\caption{Performance of Faster R-CNN across different weather conditions and time changes when trained on standard images, stylized images and the combination of both evaluated on BDD100k (see Appendix~\ref{appendix:natural_distortions} for dataset details); higher is better.}
\label{table:results_bdd100k}
\vspace{-0.3cm}
\end{center}
\end{table}


\iffalse
\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|c|cc|cc||c|cc}
\toprule
\multicolumn{2}{c|}{BDD100k [AP]} & \multicolumn{4}{c||}{Weather}& \multicolumn{3}{c}{Day/Night} \\
& clear & \highlight{rainy} & rel. & \highlight{snowy} & rel. & day & \highlight{night} & rel.\\
train data & P & \highlight{mPC} & rPC [\%] & \highlight{mPC} & rPC [\%] & P & \highlight{mPC} & rPC [\%] \\
\hline
clean & \textbf{27.8} & \highlight{27.6} & 99.3  & \highlight{23.6} & 84.9 & \textbf{30.0} & \highlight{21.5} & 71.7 \\
\hline
combined & 27.7 & \highlight{\textbf{28.0}} & \textbf{101.1}  & \highlight{\textbf{24.2}} & \textbf{87.4} & \textbf{30.0} & \highlight{\textbf{22.5}} & \textbf{75.0}\\
\bottomrule
\end{tabular}
\caption{Performance of Faster R-CNN across different weather conditions and time changes when trained on standard images, stylized images and the combination of both evaluated on BDD100k (see Appendix~\ref{appendix:natural_distortions} for dataset details); higher is better.}
\label{table:results_bdd100k}
\vspace{-0.3cm}
\end{center}
\end{table}
\fi

\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|c|cc|cc|cc}
\toprule
\multicolumn{2}{c|}{Foggy Cityscapes [AP]} &  \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{} & \multicolumn{2}{c}{} \\
& clean & \highlight{corr.} & rel. & \highlight{corr.} & rel. & \highlight{corr.} & rel.\\
train data & P & \highlight{mPC} & rPC [\%] & \highlight{mPC} & rPC [\%] & \highlight{mPC} & rPC [\%] \\
\hline
standard & \textbf{36.4} & \highlight{30.2} & 83.0 & \highlight{25.1} & 69.0 & \highlight{18.7} & 51.4 \\
\hline
stylized & 28.5 & \highlight{26.2} & \textbf{91.9} & \highlight{24.7} & \textbf{86.7} & \highlight{22.5} & \textbf{78.9} \\
combined & 36.3 & \highlight{\textbf{32.2}} & 88.7 & \highlight{\textbf{29.9}} & 82.4 & \highlight{\textbf{26.2}} & 72.2 \\
\bottomrule
\end{tabular}
\caption{Object detection performance of Faster R-CNN on Foggy Cityscapes when trained on Cityscapes with standard images, stylized images and the combination of both evaluated on the validation set; higher is better;  is the attenuation coefficient in }
\label{table:results_foggy_cityscapes}
\vspace{-0.3cm}
\end{center}
\end{table}

\iffalse
\begin{table}[t]\footnotesize
\begin{center}
\begin{tabular}{r|c|cc}
\toprule
\multicolumn{2}{c|}{Foggy Cityscapes [AP]} &  \multicolumn{2}{c}{} \\
& clean & \highlight{corr.} & rel.\\
train data & P & \highlight{mPC} & rPC [\%] \\
\hline
standard & \textbf{36.4} & \highlight{18.7} & 51.4 \\
\hline
combined & 36.3 & \highlight{\textbf{26.2}} & \textbf{72.2} \\
\bottomrule
\end{tabular}
\caption{Object detection performance of Faster R-CNN on Foggy Cityscapes when trained on Cityscapes with standard images, stylized images and the combination of both evaluated on the validation set; higher is better;  is the attenuation coefficient in }
\label{table:results_foggy_cityscapes}
\vspace{-0.3cm}
\end{center}
\end{table}
\fi

\subsection{Performance degradation does not simply scale with perturbation size}
We investigated whether there is a direct relationship between the impact of a corruption on the pixel values of an image and the impact of a corruption on model performance. The left of Figure~\ref{fig:dAcc_rmse} shows the relative performance of Faster R-CNN on the corruptions in PASCAL-C dependent on the perturbation size of each corruption measured in Root Mean Square Error (RMSE). It can be seen that no simple relationship exists, counterintuitively robustness increases to corruption types with higher perturbation size (there is a weak positive correlation between rPC and RMSE, ). This stems from the fact that corruptions like Fog or Brightness alter the image globally (resulting in high RMSE) while leaving local structure unchanged. Corruptions like Impulse Noise alter only a few pixels (resulting in low RMSE) but have a drastic impact on model performance.

To investigate further if classical perceptual image metrics are more predictive, we look at the relationship between the perceived image quality of the original and corrupted images measured in structural similarity (SSIM, higher value means more similar, Figure~\ref{fig:dAcc_rmse} on the right). There is a weak correlation between rPC and SSIM (). This analysis shows that SSIM better captures the effect of the corruptions on model performance.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{figures/results/rpc_vs_corruptionimpact.pdf}
    \caption{Relative performance under corruption (rPC) as a function of corruption RMSE (left, higher value=greater change in pixel space) and SSIM (right, higher value=higher perceived image quality) evaluated on PASCAL VOC. The dots indicate the rPC of Faster R-CNN trained on standard data; the arrows show the performance gained via training on `combined' data. Corruptions are grouped into four corruption types: noise, blur, weather and digital.}
    \label{fig:dAcc_rmse}
\end{figure}{} \section{Discussion}
  \label{Discussion}

We here showed that object detection and instance segmentation models suffer severe performance impairments on corrupted images. This drop in performance has previously been observed in image recognition models \citep[e.g.][]{Geirhos2018generalisation, hendrycks2018benchmarking}. In order to track future progress on this important issue, we propose the \texttt{Robust Detection Benchmark} containing three easy-to-use benchmark datasets PASCAL-C, COCO-C and Cityscapes-C. We provide evidence that performance on our benchmarks predicts performance on natural distortions and show that robustness corresponds to model performance on clean data. Apart from providing baselines, we demonstrate how a simple data augmentation technique, namely adding a stylized copy of the training data in order to reduce a model's focus on textural information, leads to strong robustness improvements. On corrupted images, we consistently observe a performance increase (about 16\% for PASCAL, 12\% for COCO, and 41\% for Cityscapes) with small losses on clean data (0--2\%). This approach has the benefit that it can be applied to any image dataset, requires no additional labelling or model tuning and, thus, comes basically for free. At the same time, our benchmark data shows that there is still space for improvement and it is yet to be determined whether the most promising robustness enhancement techniques will require architectural modifications, data augmentation schemes, modifications to the loss function, or a combination of these.

We encourage readers to expand the benchmark with novel corruption types. In order to achieve robust models, testing against a wide variety of different image corruptions is necessary---there is no `too much'. Since our benchmark is open source, we welcome new corruption types and look forward to your pull requests to \url{https://github.com/bethgelab/imagecorruptions}! 
We envision our comprehensive benchmark to track future progress towards building robust object detection models that can be reliably deployed `in the wild', eventually enabling them to cope with unexpected weather changes, corruptions of all kinds and, if necessary, even the occasional dragonfire. \subsection*{Author contributions}
\begin{footnotesize}
The initial project idea for improving detection robustness was developed by E.R., R.G. and C.M. The initial idea of benchmarking detection robustness was developed by C.M., B.M., R.G., E.R. \& W.B. The overall research focus on robustness was collaboratively developed in the Bethge, Bringmann and Wichmann labs. The \texttt{Robust Detection Benchmark} was jointly designed by C.M., B.M., R.G. \& E.R.; including selecting datasets, corruptions, metrics and models. B.M. and E.R. jointly developed the pip-installable package to corrupt arbitrary images. B.M. developed code to stylize arbitrary datasets with input from R.G. and C.M.; C.M. and B.M. developed code to evaluate the robustness of arbitrary object detection models. B.M. prototyped the core experiments; C.M. ran the reported experiments. The results were jointly analysed and visualized by C.M., R.G. and B.M. with input from E.R., M.B. and W.B.; C.M., B.M., R.G. \& E.R. worked towards making our work reproducible, i.e. making data, code and benchmark openly accessible and (hopefully) user-friendly. Senior support, funding acquisition and infrastructure were provided by O.B., A.S.E., M.B. and W.B. The illustratory figures were designed by E.R., C.M. and R.G. with input from B.M. and W.B. The paper was jointly written by R.G., C.M., E.R. and B.M. with input from all other authors.
\end{footnotesize}

\subsection*{Acknowledgement}
\begin{footnotesize}
We would like to thank Alexander von Bernuth for help with Figure 1; Marissa Weis for help with the Cityscapes dataset; Andreas Geiger for helpful discussions on the topic of autonomous driving in bad weather; Mackenzie Mathis for helpful contributions to the stylization code as well as Eshed Ohn-Bar and Jan Lause for pointing us to important references. R.G. would like to acknowledge Felix Wichmann for senior support, funding acquisition and providing infrastructure.
C.M., R.G. and E.R. graciously acknowledge support by the International Max Planck Research School for Intelligent Systems (IMPRS-IS) and the Iron Bank of Braavos. C.M. was supported by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) via grant EC 479/1-1 to A.S.E.. A.S.E., M.B. and W.B. acknowledge support from the BMBF competence center for machine learning (FKZ 01IS18039A) and the Collaborative Research Center Robust Vision (DFG Projektnummer 276693517 -- SFB 1233: Robust Vision). M.B. acknowledges support by the Centre for Integrative Neuroscience Tübingen (EXC 307). O.B. and E.R. have been partially supported by the Deutsche Forschungsgemeinschaft (DFG) in the priority program 1835 ``Cooperatively Interacting Automobiles'' under grant BR2321/5-1 and BR2321/5-2. A.S.E., M.B. and W.B. were supported by the Intelligence Advanced Research Projects Activity (IARPA) via Department of Interior / Interior Business Center (DoI/IBC) contract number D16PC00003.
\end{footnotesize}
 
\bibliographystyle{unsrtnat}
\bibliography{refs}


\newpage
\renewcommand{\thesubsection}{\Alph{subsection}}
\section*{Appendix}
\appendix
\subsection{Implementation details: Model training}
\label{appendix:implementation}

We train all our models with two images per GPU which corresponds to a batch size of 16 on eight GPUs. On COCO, we resize images so that their short edge is 800 pixels and train for twelve epochs with a starting learning rate of 0.01 which is decreased by a factor of ten after eight and eleven epochs. On PASCAL VOC, images are resized so that their short edge is 600 pixels. Training is done for twelve epochs with a starting learning rate of 0.00125 with a decay step of factor ten after nine epochs. For Cityscapes, we stayed as close as possible to the procedure described in \citep{He2017}, rescaling images to a shorter edge size between 800 and 1024 pixels and train for 64 epochs (to match 24k steps at a batch size of eight) with an initial learning rate of 0.0025 and a decay step of factor ten after 48 epochs. For evaluation, only one scale (1024 pixels) is used. Specifically, we used four GPUs to train the COCO models and one GPU for all other models\footnote{In all our experiments, we employ the linear scaling rule \citep{Goyal2017linearscalingrule} to select the appropriate learning rate.} Training with stylized data is done by simply exchanging the dataset folder or adding it to the list of dataset folders to consider. For all further details please refer to the config files in our implementation (which we will make available after the end of the anonymous review period).









\subsection{Corrupting arbitrary images}
In the original corruption benchmark of ImageNet-C \citep{hendrycks2018benchmarking}, two technical aspects are hard-coded: The image-dimensions and the number of channels. To allow for different data sets with different image dimensions, several corruption functions are defined independently of each other, such as \code{make\_cifar\_c}, \code{make\_tinyimagenet\_c}, \code{make\_imagenet\_c} and \code{make\_imagenet\_c\_inception}. Additionally, many corruptions expect quadratic images. We have modified the code to resolve these constraints and now all corruptions can be applied to non-quadratic images with varying sizes, which is a necessary prerequisite for adapting the corruption benchmark to the PASCAL VOC and COCO datasets.
For the corruption type Frost, crops from provided images of frost are added to the input images. Since images in PASCAL VOC and COCO have arbitrarily large dimensions, we resize the frost images to fit the largest input image dimension if necessary.  The original corruption benchmark also expects RGB images. Our code now allows for grayscale images.\footnote{There are approximately 2--3\% grayscale images in PASCAL VOC/MS COCO.}
Both \texttt{motion\_blur} and \texttt{snow} relied on the motion-blur functionality of Imagemagick, resulting in an external dependency that could not be resolved by standard Python package managers. For convenience, we reimplemented the motion-blur functionality in Python and removed the dependency on non-Python software.




\subsection{BDD100k}
\label{appendix:natural_distortions}
We use the weather annotations present in the BDD100k dataset \cite{yu2018bdd100k} to split it in images with clear, rainy and snowy conditions. We disregard all images which are annotated to have any other weather condition (foggy, partly cloudy, overcast and undefined) to make the separation easier\footnote{It would have been great to combine the performance on natural fog with the results from Foggy Cityscapes but as there are only 13 foggy images in the validation set the results cannot be seen as representative in any way}.  We use all images from the training set which are labeled having clear weather conditions for training. For testing, we created 3 subsets of the validation set each containing 725 images in clear, rainy or snowy conditions\footnote{We will release the datasets splits at \url{https://github.com/bethgelab/robust-detection-benchmark}}. The sets were created to have the same size which was determined by the category with the least images (rainy). Having same sized test sets is important because evaluation under the AP metric leads to lower scores with increasing sequence length \citep{gupta2019lvis}.

\subsection{Additional Results}
\label{appendix:results}

\subsubsection{Instance Segmentation Results}

We evaluated Mask R-CNN and Cascade Mask R-CNN on instance segmentation. The results are very similar to those on the object detection task with a slightly lower relative performance (~1\%, see Table~\ref{table:results_instance_segmentation}). We also trained Mask R-CNN on the stylized datasets finding again very similar trends for the instance segmentation task as for the object detection task (Table~\ref{table:results_stylized_instance_segmentation}).
On the one hand, this is not very surprising as Mask R-CNN and Faster R-CNN are very similar. On the other hand, the contours of objects can change due to the stylization process, which would expectedly lead to poor segmentation performance when training only on stylized images. We do not see such an effect but rather find the instance segmentation performance of Mask R-CNN to mirror the object detection performance of Faster R-CNN when trained on stylized images.

\begin{table}[t!]
\begin{center}
\begin{tabular}{c|c|ccc}
\multicolumn{5}{c}{MS COCO} \\
\toprule
\multicolumn{2}{c}{} & clean & corr. & rel.\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Mask & r50 & 34.2 & 16.8 & 49.1\\
Cascade Mask & r50 & 35.7 & 17.6 & 49.3\\
HTC & x101-64x4d & 43.8 & 28.1 & 64.0\\
\bottomrule


\multicolumn{5}{c}{} \\
\multicolumn{5}{c}{Cityscapes} \\
\toprule
\multicolumn{2}{c}{} & clean & corr. & rel.\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Mask & r50 & 32.7 & 10.0 & 30.5\\
\bottomrule
\end{tabular}
\caption{\textbf{Instance segmentation} performance of various models. Backbones indicated with : ResNet. All model names indicate the corresponding model from the R-CNN family. All models were downloaded from the \texttt{mmdetection} modelzoo.}
\label{table:results_instance_segmentation}
\end{center}
\end{table}

\begin{table}[t!]
\begin{center}
\begin{tabular}{r|ccc|ccc}
\toprule
 & \multicolumn{3}{c|}{MS COCO} & \multicolumn{3}{c}{Cityscapes} \\
& clean & corr. & rel. & clean & corr. & rel. \\
train data & \small{[P]} & \small{[mPC]} & \small{[rPC]} & \small{[P]} & \small{[mPC]} & \small{[rPC]} \\
\hline
standard & \textbf{34.2} & 16.9 & 49.4 & \textbf{32.7} & 10.0 & 30.5\\
\hline
stylized & 20.5 & 13.2 & \textbf{64.1} & 23.0 & 11.3 & \textbf{49.2}\\
combined & 32.9 & \textbf{19.0} & 57.7 & 32.1 & \textbf{14.9} & 46.3\\
\bottomrule
\end{tabular}
\caption{\textbf{Instance segmentation} performance of Mask R-CNN trained on standard images, stylized images and the combination of both evaluated on standard test sets (test 2007 for PASCAL VOC; val 2017 for MS COCO, val for Cityscapes).}
\label{table:results_stylized_instance_segmentation}
\end{center}
\end{table}

\subsubsection{Deformable Convolutional Networks}

We tested the effect of deformable convolutions \citep{dai2017deformable, zhu2018deformable} on corruption robustness. Deformable convolutions are a modification of the backbone architecture exchanging some standard convolutions with convolutions that have adaptive filters in the last stages of the encoder. It has been shown that deformable convolutions can help on a range of tasks like object detection and instance segmentation. This is the case here too as networks with deformable convolutions do not only perform better on clean but also on corrupted images improving relative performance by 6-7\% compared to the baselines with standard backbones (See Tables~\ref{table:results_corruption_benchmark_dcn}~and~\ref{table:results_corruption_benchmark_dcn_instance_segmentation}). The effect appears to be the same as for other backbone modifications such as using deeper architectures (See Section~\ref{results} in the main paper).

\begin{table}[t!]
\begin{center}
\begin{tabular}{c|c|ccc}
\multicolumn{5}{c}{MS COCO} \\
\toprule
\multicolumn{2}{c}{} & clean & corr. & rel.\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Faster & r50-dcn & 40.0 & 22.4 & 56.1\\
Faster & x101-64x4d-dcn & 43.4 & 26.7 & 61.6\\
Mask & r50-dcn & 41.1 & 23.3 & 56.7\\
\bottomrule
\end{tabular}
\caption{\textbf{Object detection} performance of models with deformable convolutions \cite{dai2017deformable}. Backbones indicated with r are ResNet, the addition dcn signifies deformable convolutions in stages c3-c5. All model names indicate the corresponding model from the R-CNN family. All models were downloaded from the \texttt{mmdetection} modelzoo.}
\label{table:results_corruption_benchmark_dcn}
\end{center}
\end{table}

\begin{table}[t!]
\begin{center}
\begin{tabular}{c|c|ccc}
\multicolumn{5}{c}{MS COCO} \\
\toprule
\multicolumn{2}{c}{} & clean & corr. & rel.\\
model & backbone & P \small{[AP]} & mPC \small{[AP]} & rPC \small{[\%]}\\
\hline
Mask & r50-dcn & 37.2 & 20.7 & 55.7\\
\bottomrule
\end{tabular}
\caption{\textbf{Instance segmentation} performance of Mask R-CNN with deformable convolutions \citep{dai2017deformable}. The backbone indicated with  is a ResNet 50, the addition dcn signifies deformable convolutions in stages c3-c5. The model was downloaded from the \texttt{mmdetection} modelzoo.}
\label{table:results_corruption_benchmark_dcn_instance_segmentation}
\end{center}
\end{table}

\subsubsection*{Image rights \& attribution}
Figure~\ref{fig:teaser}: Home Box Office, Inc. (HBO).





\begin{figure*}[ht]
    \begin{center}
    \includegraphics[width=\linewidth]{figures/results/pascal_corruption_individual.pdf}
    \end{center}
    \vspace{-0.2cm}
    \caption{Results for each corruption type on PASCAL-C.}
\label{fig:results_pascal_individual}
\end{figure*}

\begin{figure*}[t]
    \begin{center}
    \includegraphics[width=\linewidth]{figures/results/coco_corruption_individual.pdf}
    \end{center}
    \vspace{-0.2cm}
    \caption{Results for each corruption type on COCO-C.}
\label{fig:results_Coco_individual}
\end{figure*}

\begin{figure*}[t]
    \begin{center}
    \includegraphics[width=\linewidth]{figures/results/cityscapes_corruption_individual.pdf}
    \end{center}
    \vspace{-0.2cm}
    \caption{Results for each corruption type on Cityscapes-C.}
\label{fig:results_cityscapes_individual}
\end{figure*}

\begin{figure*}[ht]
    \begin{center}
    \includegraphics[width=\linewidth]{figures/results/coco_corruption_backbones_individual.pdf}
    \end{center}
    \vspace{-0.2cm}
    \caption{Results for each corruption type using different backbones. Faster R-CNN trained on MS COCO with ResNet-50, ResNet-101 and ResNext-101\_64x4d backbones.}
\label{fig:results_Coco_backbones}
\end{figure*} 
\end{document}