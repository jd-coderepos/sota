\newif\ifFull
\Fulltrue
\ifFull
\documentclass[11pt]{llncs}
\usepackage[margin=1in]{geometry}
\newcommand{\figurescale}{0.5}
\else
\documentclass{llncs}
\newcommand{\figurescale}{0.45}
\fi
\usepackage{amsmath,amssymb}
\usepackage{graphicx,hyperref,cite}
\usepackage{microtype}

\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

\newcommand{\qcount}{\operatorname{\mathsf{count}}}
\newcommand{\qpart}{\operatorname{\mathsf{partition}}}
\newcommand{\starsub}{\operatorname{\mathsf{star}}}
\newcommand{\multsub}{\operatorname{\mathsf{multiply}}}
\newcommand{\inject}{\triangleleft}
\newcommand{\assign}{:=}
\newcommand{\threshold}{\tau}

\newtheorem{subroutine}{Subroutine}
\let\oldsubroutine\subroutine
\renewcommand{\subroutine}{\oldsubroutine\normalfont}
\newcommand{\subroutineautorefname}{Subroutine}

\title{From Discrepancy to Majority}
\author{David Eppstein and Daniel S. Hirschberg}
\institute{Department of Computer Science, University of California, Irvine\thanks{David Eppstein was supported in part by NSF grant  CCF-1228639.}}

\begin{document}
\maketitle

\begin{abstract}
We show how to select an item with the majority color from  two-colored items, given access to the items only through an oracle that returns the discrepancy of subsets of  items. We use  queries, improving a previous method by De Marco and Kranakis that used  queries. We also prove a lower bound of  on the number of queries needed, improving a lower bound of  by De Marco and Kranakis.
\end{abstract}

\section{Introduction}

A large body of theoretical computer science research concerns problems of computing a function using a minimal number of calls to an oracle for another function on small subsets of input values. Such problems include sorting with a minimum number of comparisons, as well as \emph{combinatorial group testing}, in which the goal is to identify the positions of a small set of true values among a larger number of false values using an oracle that returns the disjunction of an arbitrary subset of values~\cite{DuHwa-CGT-00,EppGooHir-SJC-07}. Other problems with this flavor include Valiant's work on computing the majority of  values by shallow circuits of 3-input majority gates~\cite{Val-JA-84} and recent work by the authors  using two-input disjunctions to identify a small number of slackers among a larger number of workers~\cite{EppGooHir-WADS-13}.

De Marco and Kranakis~\cite{DeMKra-DMAA-15} provide another interesting  class of such problems. Their input consists of  items, each having one of two colors. The goal is to select an item of the majority color or, if the input is equally balanced between colors, to report that fact rather than returning an item. The algorithm may only access the input by \emph{counting} queries on -item subsets of the input. If a subset has  black items and  white items, then the result of the query is , the size of the smaller of the two color classes. Equivalently, one may ask for the \emph{discrepancy}  of the query subset; the count can be calculated from the discrepancy or vice versa via the identity . The motivating application of De Marco and Kranakis is in fault diagnosis of distributed systems, which requires a majority of processors to be non-faulty. Their queries model tests that examine a small number of processors per test in order to determine whether the fault-free processors are indeed a majority.

The case  of this problem had been previously studied~\cite{AloReiSch-IPL-93,AloReiSch-SJC-97,SakWer-Comb-91}, and optimal bounds are known~\cite{AloReiSch-IPL-93,SakWer-Comb-91}.
De Marco and Kranakis~\cite{DeMKra-DMAA-15} provide more general solutions that apply whenever  is sufficiently smaller than~. They show that it is possible to find a majority item for even  using only  counting queries,\footnote{There is a bug in their method for odd , in Case 1 of Theorem 4.1, when .} and they prove a lower bound of  on the number of queries that are necessary for this problem for all~.

The upper bound of De Marco and Kranakis for counting queries is greater than the lower bound by a factor of~ in its leading term. In this work, we reduce this upper bound by a factor of approximately  to , matching the lower bound to within a constant factor independent of~. 

De Marco and Kranakis also considered a more powerful type of query, the \emph{output model}, in which the answer to a query is a partition of the queried set into two monochromatic subsets (not revealing the colors of each subset). For this problem De Marco and Kranakis provided an upper bound of  queries, and showed that the same  lower bound for counting queries applies also to the output model. For odd , we show that their upper bound is tight by proving a matching lower bound. For even , we slightly improve their upper bound and prove a new lower bound that is within an additive  lower-order term of the upper bound. Our new lower bounds apply both to counting queries and to the output model, and the  leading terms of the new lower bounds improve the  leading term of the previously known bound.

Our results can also be interpreted in the framework of \emph{discrepancy theory}, the study of how small the discrepancy of the sets in a set system can be made by choosing an appropriate 2-coloring of the set elements~\cite{BecChe-08}. The first stage in our counting-query algorithm, finding an unbalanced query, is equivalent to constructing a system of -element sets with discrepancy , and our results for this stage provide examples of such unbalanced -set systems.

\subsection{Notational conventions and problem statement}

We use the following shorthand notation for sets:
\begin{itemize}
\item  denotes the set  of the first  positive integers.
\item If  is a set,  is an element of , and  is not an element of ,
then  denotes the set . That is, we replace  by  in~.
\item With the same conventions, if  is a subset of  and  is disjoint from ,
then  denotes the set .
\item If  and  are two sets of numbers with , then  is the set formed from  by removing the  largest elements of  and replacing them by the elements of . The result is a set with the same size as  that forms a subset of  and a superset of .
By abuse of notation, when  is a number, we write  as a shorthand for .
\end{itemize}
To avoid confusion with the equality predicate, we use the notation  to indicate that a variable  of our algorithm should be assigned the new value .

An instance of the majority problem may be parameterized by two values,  (the number of input items) and  (the size of queries), with .
We may represent an input to the problem by an -tuple  of numbers  () where each  is a member of the set . The argument to a query made by a majority-finding algorithm may be represented by a set  with . Then we may define the results of the input queries  and  as


By extension, we allow these functions to be applied to any set, not necessarily of cardinality~, with the same definitions.

For odd  it will be convenient to partition the set  into two complementary subsets,  and~.  is the set of indices  whose associated values  equal the majority value of . (This may differ from the majority of .) Similarly,  is the set of indices  whose associated values  equal the minority value in .

We say that a query set  is \emph{homogeneous} if all of its elements have the same value; that is, it is homogeneous when  and when . We say that a query is \emph{inhomogeneous} if it is not homogeneous. We say that a query set is \emph{balanced} if it is equally partitioned between elements of the two values (or as near to equal as possible when  is odd). That is,  is balanced when its discrepancy is at most  or when . We say that  is \emph{unbalanced} when it is not balanced.

\subsection{New results}

We prove the following new results.
\begin{itemize}
\item A majority element may be found by making   queries. The best previous bound, by De Marco and Kranakis~\cite{DeMKra-DMAA-15}, was .
\item When  is odd, a majority element may be found by making   queries. This improves for some values of  the best previous upper bound, by De Marco and Kranakis~\cite{DeMKra-DMAA-15}, of .
\item Determining the majority element requires at least  queries, for odd , and  queries, for even~, regardless of whether the queries are of type  or . The best previous lower bound for both these query types, by De Marco and Kranakis~\cite{DeMKra-DMAA-15}, was .
\end{itemize}
In addition our methods prove the following discrepancy-theoretic result:
\begin{itemize}
\item For even , there exists a family of at most  sets, each having  elements, that cannot be -colored to make every set balanced. For odd , there exists a family of at most  sets with the same property.
\end{itemize}

\section{Upper bounds for counting}

For our new upper bounds for counting we use an algorithm with the following four stages:
\begin{enumerate}
\item Find an unbalanced query .
\item Use  to find a homogeneous query .
\item Use  to determine .
\item Based on the value of , find the result of the majority problem.
\end{enumerate}

We describe these four stages in the following four subsections.

\subsection{Finding an unbalanced query}
Throughout this section, when a subroutine discovers that a set  is unbalanced, we will abort the subroutine and its callers, and pass  on to the next stage of the algorithm. To indicate that this action is not simply returning to the subroutine's caller, we describe it using the Java-like pseudocode ``throw ''.

For even , we do not need to find an unbalanced set, as our algorithm for finding a homogeneous set does not require it. However, the solution below serves as a warmup for the odd- case. It maintains a homogeneous subset  of a balanced set , repeatedly doubling  until it is too large to be a subset of a balanced set. To double , we query a set ; if it is balanced, then  and  have the same composition and the doubled set  is homogeneous.
\ifFull
\newpage
\fi
\begin{subroutine}
\label{sbr:unbal-even}
to find an unbalanced set when  is even:
\begin{enumerate}
\item Set  and .
\item Repeat the following steps:
\begin{enumerate}
\item If  is unbalanced, throw .
\item Let  be a set disjoint from  with .
\item If  is unbalanced, throw .
\item Set  and then set .
\end{enumerate}
\end{enumerate}
\end{subroutine}

\ifFull
\begin{lemma}
\autoref{sbr:unbal-even} always throws an unbalanced set after at most  queries.
\end{lemma}

\begin{proof}
\fi
Throughout the loop,  remains homogeneous, and doubles in size at each iteration. The loop terminates on or before the iteration for which ,  after at most  queries,
because substituting such a large homogeneous set into  will always produce an unbalanced set. Thus,  cannot grow larger than  and cause  to become undefined.
\ifFull
\end{proof}
\fi
For the subroutine to work correctly, we must have  to ensure that  a large enough subset  disjoint from  can be chosen in step~2(b).

When  is odd we use a similar idea, doubling the size of a small unbalanced seed set until it overwhelms the whole set, but the details are more complicated. In the first place, the seed set for the doubling routine in the even case is always the set , found without any queries, but in the odd case we choose our seed more carefully to have the form  where .
To construct this seed, we choose  and  to be arbitrary indexes disjoint from  and then verify that they both belong to  by using the following subroutine:

\begin{figure}[t]
\centering
\includegraphics[scale=\figurescale]{star-swaps}\quad
\includegraphics[scale=\figurescale]{balanced-swap}
\caption{Left: the arrows connect pairs of elements swapped into and out of the queries made by . Right: if two overlapping queries (shown as ellipses) differ in a single element, and are both balanced, then either the two swapped elements have equal values (top) or they are unequal but both are in the majority for their query (bottom).}
\label{fig:ss-bs}
\end{figure}

\begin{subroutine}  (for ) verifies that  or finds an unbalanced set:
\begin{enumerate}
\item If  is unbalanced, throw .
\item For , if  is unbalanced, throw .
\end{enumerate}
\end{subroutine}
The subroutine name refers to the fact that the pairs  defining the queries form the edges of a star graph (\autoref{fig:ss-bs}, left).

\begin{lemma}
If  terminates without finding an unbalanced set, then .
\end{lemma}

\begin{proof}
There are two different possible ways that the sets  and  queried by the algorithm can both be balanced (\autoref{fig:ss-bs}, right): either  (the upper case in the figure), or  and  (the lower case). The first of these two possibilities, that , can happen only for  choices of , for otherwise too many of the members of  would be equal to  (and each other) for  to be balanced. However,  tests a larger number of pairs than that. Therefore,
if it tests all of these pairs and fails to find an unbalanced set, then it must be the case that~.
\end{proof}

We define a set  with even cardinality to be \emph{-heavy} if a majority of  belongs to , and \emph{-balanced} if  is either balanced or -heavy. Because we assume  is even, an -heavy set must contain at least  elements of , and an -balanced set must contain at least  elements of~.
\ifFull
\begin{lemma}
The disjoint union of an -heavy and an -balanced set is -heavy.
\end{lemma}

\begin{proof}
If
\else
The disjoint union of an -heavy and an -balanced set must itself be -heavy,
for if
\fi
 and~ are disjoint with  containing at least  elements of  and  containing at least  elements of , then  contains at least  elements of .
\ifFull
\end{proof}
\fi
Our algorithm for the odd case of stage~1 depends on the following result, which lets us determine an -heavy set of size double that of a previously known -heavy set using  queries.

\begin{lemma}
\label{lem:heavy-doubling}
Suppose that  and  are sets disjoint from , that  is -heavy, that , and that , , and  are all balanced. Then  is necessarily -balanced.
\end{lemma}

\begin{proof}
Let  be the set of the largest  elements of ; this is the subset of  removed to make way for  in the set  (\autoref{fig:heavy-doubling}). For  and  to be balanced,  can have at most one more member of  than  does; that is,  is -balanced. Again, for  and  to be balanced,  must have at least as many members of  as  does; therefore,  is also -balanced.
\end{proof}

Based on \autoref{lem:heavy-doubling}, we define a second subroutine  that transforms an -heavy set  into a larger -heavy set of cardinality . 
It takes as input an -heavy set , where  has even size and is disjoint from , and a positive integer  with . It either finds an unbalanced set~ (aborting the subroutine) or returns as output an -heavy set of cardinality~. We assume as a precondition for this subroutine that  has already been determined to be balanced. The subroutine uses the binary representation of~ to find its return value in a small number of doublings.
\begin{subroutine}  (where  and  are as described above) finds an unbalanced set or returns an -heavy set disjoint from  of size :
\begin{enumerate}
\item If , return .
\item If  is unbalanced, throw  .
\item Choose  disjoint from both  and  with .
\item If  is unbalanced, throw .
\item Set .
\item If  is even, return .
\item Choose  disjoint from  and from  with .
\item If  is unbalanced, throw .
\item Return .
\end{enumerate}
\end{subroutine}

\begin{figure}[t]
\centering\includegraphics[scale=\figurescale]{heavy-doubling}
\caption{The sets  (top),  (bottom), and  (middle right), and the query sets  (yellow),  (red), and  (blue), used in the proof of \autoref{lem:heavy-doubling}.}
\label{fig:heavy-doubling}
\end{figure}

\ifFull
\begin{lemma}
If  does not throw an unbalanced set, it returns an -heavy set of cardinality . Regardless of whether it throws an unbalanced set or returns an -heavy set, it performs at most  queries.
\end{lemma}
\begin{proof}
\fi
By \autoref{lem:heavy-doubling}, if  does not find an unbalanced set, then  and  must both be -balanced, and their disjoint union with an -heavy set is another -heavy set. Therefore, the set returned by this subroutine is -heavy, and
(by induction on the number of recursive calls)
has the desired cardinality. The number of levels of recursion (counting only levels that can perform queries) is ; at each level it performs either two or three queries, depending on whether  is even or odd. Therefore, in the worst case, it performs at most  queries.
\ifFull
\end{proof}
\fi

Putting  and  together, we have the following algorithm to find an unbalanced set when  is odd. It uses  twice to find a two-element -heavy set~, then uses  to expand this set to an -heavy set of  elements.
If this -heavy set together with one element  remains unbalanced, it must be the case that . After we identify two members of , we can replace them with the two known members of  to obtain an unbalanced set.

\begin{subroutine} finds an unbalanced set when  is odd:
\label{sbr:unbal-odd}
\begin{enumerate}
\item Call  and , and set .
\item Set , an -heavy set of  elements.
\item If  or  is unbalanced, throw the unbalanced set.
\item Throw .
\end{enumerate}
\end{subroutine}

\ifFull
\begin{lemma}
\autoref{sbr:unbal-odd} always throws an unbalanced set after at most  queries.
\end{lemma}
\begin{proof}
\fi
The two calls to  (after eliminating the shared query of set ) take a total of  queries. The call to  takes at most  queries. The remaining steps of the algorithm use at most two queries. Therefore, the total number of queries made in this stage of the algorithm is at most .
\ifFull
\end{proof}
\fi
In order to work, this algorithm needs  to be at least  so that it can find enough elements in the disjoint sets that it chooses.

For the algorithms in this stage, the sequence of queries made by the algorithm is non-adaptive: whenever a query finds an unbalanced set, the algorithm terminates, so the sequence of queries can be found by simulating the algorithm using an oracle that knows nothing about the input and always returns a balanced result. Eventually, the algorithm will determine that some particular set is unbalanced without querying it. The sequence of query sets together with the final unqueried and unbalanced set form a family of -sets with the property that, no matter how their elements are colored, at least one set in the family will be unbalanced. This proves the following result:

\begin{theorem}
When  is even, there exists a family of at most  sets, each having  elements, that cannot be -colored to make every set in the family be balanced. When  is odd, there exists a family of at most  sets with the same property.
\end{theorem} 

These bounds are not tight for many values of~. When ,
three -sets with pairwise intersections of size  cannot all be balanced. And for many odd values of~ our bound can be improved by using optimal addition chains. However, such improvements would make our algorithms more complex and would affect only a low-order term of our overall analysis.

\subsection{Finding a homogeneous query}

\begin{figure}[t]
\centering\includegraphics[scale=\figurescale]{homogenize}
\caption{Finding a homogeneous query. Given an unbalanced -element query  (top, yellow), we find a disjoint set  of  elements (bottom), and construct a spanning tree of the complete bipartite graph that has  and  as its two vertex sets (blue edges). We then query each set  for each spanning tree edge  and use the result to label each edge  (if ) or  (otherwise). Any two elements of  have the same value if and only if the spanning tree path connecting them has even label sum.}
\label{fig:homogenize}
\end{figure}

After the previous stage of the algorithm, we have obtained an unbalanced query~. We may also assume that we know the result of the query , for the algorithm of the previous stage will either query this number itself or it will find an unbalanced query  for which  can be determined without making a query. Our algorithm for finding a homogeneous query is based on the principle that, for any two indices  and  with  and , we can test whether  in a single additional query, by testing whether . If  then the count stays the same, clearly. However, with  unbalanced, it is not possible for the two indices to have different values while preserving the count.

\begin{subroutine} to find a homogeneous query:
\label{sbr:homogeneous}
\begin{enumerate}
\item Let  be a set of  elements disjoint from .
\item Construct a spanning tree  of the complete bipartite graph  having  and  as the two sides of its bipartition.
\item For each edge  of , with  and , query . Label the edge with the number 1 if the query value is different from  and instead label the edge with the number 0 if the two query values are equal.
\item Define two elements of  to be equivalent when the path connecting them in  has even label sum, and partition  into the two equivalence classes  and  of the resulting equivalence relation.
\item Return a subset of  elements from the larger of the two equivalence classes.\end{enumerate}
\end{subroutine}

The algorithm is illustrated in \autoref{fig:homogenize}.
This stage performs  queries and requires that .

\subsection{Finding the count}

We next use the known homogeneous query  to compute .

\begin{subroutine} to compute , given a homogeneous set :
\begin{enumerate}
\item Partition  into  subsets , each having at most  elements.
\item For each subset  of the partition, query . Since  and the remaining elements of  are homogeneous, this query determines the number of elements of  that are not the same type as~.
\item Let  be the sum of the query values, and return .
\end{enumerate}
\end{subroutine}

As well as computing , the same algorithm can determine whether  is in the majority (according to whether  or  is the minimum) and, if not, find an inhomogeneous query  for which  (any of the queries with a nonzero query value). The number of queries it needs is


\subsection{Finding the majority}

After the previous three stages of the algorithm, we have the following information:
\begin{itemize}
\item A homogeneous query .
\item The number .
\item Whether the elements of  are in the majority.
\item An inhomogeneous query  (if  is not in the majority), with .
\end{itemize}

If , we report that there is no majority. If  is a subset of the majority, we may return any element of  as the majority element. In the remaining case, we find an element of  that is not of the same type as the elements of~, using binary search:

\begin{subroutine} uses binary search to find a majority element:
\label{sbr:find-majority}
\begin{enumerate}
\item Let , a set containing an element not the same type as .
\item Let , the number of majority elements in  already determined in stage three of the algorithm.
\item While , do the following steps:
\begin{enumerate}
\item Let any subset of  elements of .
\item Query .
\item If the result of the query is nonzero, let  and let the query result. Otherwise, let  and leave  unchanged.
\end{enumerate}
\item Return any element of the remaining set . 
\end{enumerate}
\end{subroutine}

\ifFull
\begin{lemma}
\autoref{sbr:find-majority} finds a majority element using at most  additional queries.
\end{lemma}
\begin{proof}
\fi
By induction, for a given set , this algorithm uses at most  queries. The worst case occurs when  is one plus a power of two and the query result is zero, resulting in a case of the same type in the next step. Since initially , it follows that the total number of queries for this stage of the algorithm is less than .
\ifFull
\end{proof}
\fi
This bound can be improved by making a more careful choice of the set~ to ensure that the initial values in the algorithm satisfy , but this improvement is unnecessary for our results.

\subsection{Counting analysis}

By adding together the numbers of queries made in the four stages of our algorithm we obtain the following result.

\begin{theorem}
Let  and  be given integers with  and . Then it is possible to find a majority element of a set of  -colored elements, or to report that there is no majority, using at most   queries on subsets of~ elements.
\end{theorem}

\ifFull
In the next section
\else
In the full version of the paper
\fi
we remove the constraint that  by providing substitute algorithms for the case that , using  queries.

\ifFull
\section{Upper bounds for small }

Our previous algorithm for finding the majority using counting queries requires that .
Here we show how to relax that assumption by giving separate algorithms for the remaining possible values of~, using only  queries. We first consider the case that ; we will handle the case that  in a later subsection.
Our  algorithm for  has the following outline:
\begin{enumerate}
\item If  is odd then find an unbalanced query ; otherwise set .
\item Use  to determine the result of the majority problem.
\end{enumerate}
We detail these stages in the following two subsections.

\subsection{Finding an unbalanced query when  is odd}

We begin in a manner similar to what we did for the case in which  and  is odd.
As we already observed, the subroutine  used in that case can fail to find an unbalanced set, but if it does then we know that . As in the earlier algorithm, we use the pseudocode ``throw '' to indicate that the unbalanced set  should be passed to the next stage of the algorithm, terminating the subroutine and any of its callers.

\begin{subroutine} to find an unbalanced query for odd  and any :
\begin{enumerate}
\item Call  and  to verify that .
\item Let .
\item Choose  disjoint pairs of elements in . For each pair ,
      if  is unbalanced, throw .
\item Let the remaining unpaired element of , and let  be any one of the chosen pairs.
\item If  is unbalanced, throw .
\item Throw .
\end{enumerate}
\end{subroutine}

If any one of the sets  queried by the algorithm is balanced, then  must contain a member of . If all  of these sets are balanced, then (since there are only  members of  that can be included in the pairs) each pair must consist of exactly one member of  and one member of~. The remaining unpaired element  must also belong to . Therefore, one of the two final pairs  or  must be a subset of , and replacing it with  produces an unbalanced tuple.

This procedure works for all  with  and requires at most  queries.

\subsection{Partitioning the input using an unbalanced query}

Our algorithm for completing the problem of finding a majority, given an unbalanced query  (when  is odd, or an arbitrary query  when  is even) is very similar to \autoref{sbr:homogeneous} for finding a homogeneous set in the case that  is large.

\begin{subroutine} to find a majority element from an unbalanced query :
\begin{enumerate}
\item Let .
\item Construct a spanning tree  on the complete bipartite graph .
\item For each edge  of , with  and , query  and label the edge with 0 or 1 as in \autoref{sbr:homogeneous}.
\item Partition  into two subsets of vertices such that, within each subset, each pair of vertices is connected by a path in  with an even label sum.
\item Return the difference in sizes of the two subsets of vertices. 
\end{enumerate}
\end{subroutine}

After finding a  with a known value of  (unbalanced in the case that  is odd),
this method uses  additional queries.

\ifFull
\else


Our algorithm for completing the problem of finding a majority, given an unbalanced query  (when  is odd, or an arbitrary query  when  is even) uses a similar principle to \autoref{sbr:homogeneous} for finding a homogeneous set in the case that  is large: by swapping one member of  for one member of  we can determine whether the two swapped values are equal or unequal.

\begin{subroutine} to find a majority element from an unbalanced query :
\begin{enumerate}
\item Let .
\item Choose an arbitrary element  of .
\item Let  and let .
\item If  is balanced, then return an element from the larger of the two sets  and , or return that there is no majority if both sets have equal sizes.
\item If , then:
\begin{enumerate}
\item Let  be an arbitrary element of .
\item If , let . If , return ; if , return that there is no majority; and if , return .
\item Let . If , return ; if , return that there is no majority; and if , return .
\end{enumerate}
\item Use the fact that  is homogeneous to solve the remaining problem with fewer queries.
\end{enumerate}
\end{subroutine}

\fi

\subsection{Finding a majority element when }

When  there are only  possible queries to make: for each element, there is one query that omits that element. However, we can find a majority element using even fewer queries. The principle our algorithm uses is that, unless  is equally split, a query that omits a minority element will have a strictly smaller  than a query that omits a majority element. So to find a majority element, we need only try enough queries to ensure that a majority element will be one of the omitted ones, and compare the query values.

\begin{subroutine} to find a majority element when :
\begin{enumerate}
\item Let .
\item For , let .
\item If all , return that there is no majority
\item Choose  with .
\item If  then return .
\item If  then return .
\end{enumerate}
\end{subroutine}

Since  and this algorithm makes  queries, its worst case number of queries
is .
\fi

\section{Lower bounds}

In contrast to our upper bounds for counting queries, our lower bounds are simpler and tighter in the case that  is odd, so we begin with that case first.

\ifFull
\subsection{Odd query size}
\fi

Our lower bound for odd~ uses  queries, as they are the most powerful and can simulate   queries: if it is impossible to find the majority using a given number of  queries, it is also impossible with the same number of queries of the other types. We prove our lower bound by an adversary argument: we design an algorithm for answering queries that, unless enough queries are made, will be able to force the querying algorithm into making a wrong choice of answer to the majority problem.

At any point during the interaction of the querying algorithm and adversary, we define the \emph{query graph} to be a bipartite graph that has the  given set elements on one side of its bipartition and the queries made so far on the other side of the bipartition. We make each query be adjacent to the elements in it. As a shorthand, we use the word \emph{component} to refer to a connected component of the query graph. The querying algorithm can be assumed to know the results of applying the  and  functions to any subset of elements within a single component, as those results can be inferred from the queries actually performed within the component. Note also that, if any component  has discrepancy zero, the querying algorithm may safely ignore that component for the rest of the querying process, as removing its elements from the problem will not change the majority.

To simplify the task of the adversary, we restrict the querying algorithm to make only \emph{reasonable queries}, which we define as queries that never include elements from components with zero discrepancy, and that (unless the result of the query leaves at most one nonzero-discrepancy component) never include more than one element from the same pre-query component. It follows from these properties that the querying algorithm must stop making queries, and choose an output for the majority problem, if it ever reaches a state where at most one component has nonzero discrepancy.

\begin{lemma}
Any lower bound for an algorithm that makes only reasonable queries will be valid as a lower bound for all querying algorithms.
\end{lemma}

\begin{proof}
An arbitrary querying algorithm can be transformed into one that makes only reasonable queries by skipping any query whose elements belong to one component, removing query elements that come from zero-discrepancy components or that duplicate the component of another element, and replacing the removed elements by elements from new components. This modification produces components that are supersets of the original ones, from which the results of the original queries  can be inferred.
\end{proof}

By induction, with only reasonable queries for  odd, if more than one component remains, then all components have odd cardinality and therefore odd discrepancy. We design an adversary that maintains for each odd component a partition of its elements into two subsets (consistent with previous answers) that has discrepancy one. If a query produces a single component of even cardinality, we allow the adversary to choose any partition consistent with previous answers.
If a query merges multiple discrepancy-one components, then (by choosing slightly more than half of the input components to have a majority that coincides with the majority of the merged component, and slightly fewer than half of the input components to have a majority that falls into the minority of the merged component) we can always find a consistent partition with discrepancy one. Therefore, by induction, the adversary can always achieve the goals stated above.

\begin{lemma}
If a querying algorithm that makes reasonable queries does not reduce the input to a single component before producing its output, then the adversary described above can force it to compute an incorrect answer.
\end{lemma}

\begin{proof}
Unless there is one component, more than one answer to the majority problem  is consistent with the choices already made by the adversary.

In particular, if there are evenly many odd components of discrepancy one, then by choosing the majorities of all components to be the majority of the whole input, it is possible to cause the whole input to have a majority. But by choosing half of the components to have a majority of value~0 and half of the components to have a majority of value~1, it is also possible to cause the whole input to be evenly split between the two values and have no majority. Thus, regardless of whether the querying algorithm declares that there is no majority or whether it chooses a majority element, it can be made to be incorrect.

If there are an odd number of odd components, then a majority always exists. We may achieve discrepancy one for the whole input set of elements by choosing slightly more than half of the components to have majority value~1 and slightly fewer than half to have majority value~0; however, each component can be either on the majority~1 or majority~0 side, so each element can be either in the majority or in the minority. Regardless of which element the querying algorithm determines to belong to the majority, it can be made to be incorrect.
\end{proof}

\begin{theorem}
\label{thm:odd-lb}
When  is odd, any algorithm that always correctly finds the majority of  elements by making  or  queries must use at least  queries.
\end{theorem}

\begin{proof}
As above, the algorithm can be assumed to make only reasonable  queries, and must make enough queries to reduce the query graph to a single component. This graph initially has  components, and each query reduces the number of components by at most , from which the result follows.
\end{proof}

\ifFull
\subsection{Even query size}
\fi

De Marco and Kranakis showed that the majority problem on  elements may be solved using   queries on subsets of  elements, matched by the lower bound of \autoref{thm:odd-lb}. For odd , this bound may be improved to  by applying it only to the first  elements, and either returning the result (if it is a majority) or the final element (if the first  elements have no majority). However, this modification to their algorithm can reduce the number of queries only when  evenly divides , which only happens when  is even. Therefore, this improvement does not contradict \autoref{thm:odd-lb}.
When  a similar improvement can be continued recursively by pairing up elements, eliminating balanced pairs, and recursively finding the majority of a set of representative elements from each pair. The resulting algorithm uses  queries, where  is the number of nonzero bits in the binary representation of , and a matching lower bound is known~\cite{SakWer-Comb-91}. Again, this does not contradict \autoref{thm:odd-lb} because  is even.
These improvements to the upper bound of De Marco and Kranakis raise the question of whether the majority can be found with significantly fewer queries whenever  is even. However, we show
\ifFull
in this section
\else
in the full version of the paper
\fi
that the answer is no. An adversary strategy similar to the odd- strategy but more complicated than it can be used to prove a lower bound of  on the number of queries.
\ifFull

For odd~, we proved our lower bound using an adversary that (for reasonable queries) always chooses a partition of each query that gives the resulting component discrepancy exactly one. For even~, we do not wish to create components of discrepancy zero (because that would allow the querying algorithm to eliminate all the elements of the component from future consideration) but, without creating components of discrepancy zero it is not possible to bound the discrepancy that may be needed. In particular, if the querying algorithm makes queries that have the structure of a complete -ary tree of height~, then the adversary will be forced either to create a component of discrepancy zero or to use discrepancy values as large as . And it is not always a good strategy for the adversary to choose a nonzero discrepancy for every query, for in the case that  and , a complete binary tree strategy against such an adversary can succeed in answering majority queries with only  queries by creating a homogeneous component that is large enough to overwhelm the remaining unqueried elements.

Instead, we will parameterize our adversary by a threshold value , and have it follow the following strategy for each query. If it is possible to partition the query elements consistently with previous queries so that the resulting component has discrepancy at most , choose the partition that results in as small a nonzero discrepancy as possible. Otherwise, if this is not possible, choose a partition that results in discrepancy zero. The ability to follow this strategy is ensured by the following lemmas. Here, we define the query graph and its components in exactly the same way as in the odd- lower bound, and (as in that bound) we assume that all queries are reasonable.

\begin{lemma}
Suppose that a given reasonable query combines elements from a collection of components () that have nonzero discrepancies . Then it is possible to answer the query consistently with previous queries, to achieve total discrepancy  for any choice of .
\end{lemma}

\begin{proof}
Let  be the component resulting from the query.
If  choose a partition of  in which the majority elements of  are on the same side as the majority elements of , and if  choose a partition of  in which the majority elements of  are on the opposite side as the majority elements of . Then, answer the query by restricting this partition of  to the query elements.
\end{proof}

\begin{lemma}
Suppose that a given reasonable query combines elements from a collection of components  that have nonzero discrepancies , and that at least two of the discrepancies  are different from each other. Then it is possible to answer the query in such a way that the discrepancy of the resulting component is nonzero and at most .
\end{lemma}

\begin{proof}
Again, let  be the union of the query components; by the previous lemma we may choose any combination of signs for the discrepancies of these components.
We prove the lemma using induction on the number of components to be combined. We may assume without loss of generality that . If some two components different from  (without loss of generality  and ) have different discrepancies from each other, then we may combine them with opposite signs to each other (that is, we choose ), effectively replacing them by a single component with discrepancy  which is nonzero and different from~; the result follows by induction. If on the other hand all discrepancies other than  are smaller than  and equal to each other, we may cancel them in pairs (again by choosing values of  with opposite signs). If this cancellation leaves no components other than , then the discrepancy of  equals . If there is a single component~ left after this cancellation, with discrepancy , then by choosing opposite signs for  and~ we may cause the discrepancy of~ to equal .
\end{proof}

\begin{lemma}
Suppose that a given reasonable query combines elements from a collection of components  that all have the same nonzero discrepancies . Then if there are an odd number of components in the query, it is possible to answer the query in such a way that the discrepancy of the resulting component is exactly~. If there are an even number of components, it is always possible to achieve discrepancy zero, and it is also always possible to achieve discrepancy , but it is not possible to achieve any discrepancy between those two values.
\end{lemma}

\begin{proof}
To achieve discrepancy zero or~, we choose signs  that are as evenly balanced as possible between  and . To achieve discrepancy , we start with a balanced set of signs and then flip one of them.
\end{proof}

Combining these lemmas, we have the following description of the adversary's behavior.

\begin{lemma}
\label{lem:adv-strat}
For any positive even integer , it is possible for an adversary to answer reasonable partition queries in such a way that:
\begin{itemize}
\item Each query answer is consistent with the previous answers.
\item At all times, each nonzero discrepancy is at most .
\item Whenever a query results in a nonzero discrepancy , then either at least one of the components combined by the query also has discrepancy at least~, or all the pre-query components combined by the query have discrepancy exactly .
\item Whenever a query results in a zero discrepancy, then all the pre-query components combined by the query have equal discrepancy that is greater than .
\end{itemize}
\end{lemma}

We have the following bound on the sizes of the zero-discrepancy components produced by this adversary:

\begin{lemma}
If an adversary follows the strategy described by \autoref{lem:adv-strat}, and a reasonable query creates a component with discrepancy  that is not the single remaining component of nonzero discrepancy, then the number of elements in the component is at least .
\end{lemma}

\begin{proof}
For each query  of discrepancy , we can find  earlier component queries of discrepancy at least , either directly as the ones containing the elements of the component or indirectly as the set of  earlier queries of the component combined by  that has discrepancy at least .
By continuing recursively, we can find a complete -ary tree of queries, of height , whose elements are all combined in query~. There must be at least one element of  for each leaf of this tree.
\end{proof}

\begin{corollary}
\label{cor:zero-components}
If an adversary follows the strategy described by \autoref{lem:adv-strat}, and a reasonable query creates a component with discrepancy zero, then that component must contain  elements.
\end{corollary}

To complete the lower bound argument, we must also bound the sizes of the components remaining whenever a querying algorithm has compiled enough information to correctly determine the majority.

\begin{lemma}
If an algorithm for finding the majority makes a sequence of queries that leaves a set of components with the property that each nonzero component discrepancy is at most half of the total component discrepancy, then it is impossible for the algorithm to correctly choose a majority element.
\end{lemma}

\begin{proof}
If one component  has exactly half of the remaining discrepancy, then by setting all of the remaining component's signs  equal to each other, it is possible either to make no majority (when those signs are different from ) or a majority (when those signs are equal to ). Thus, regardless of whether the algorithm determines that there is or is not a majority, it may be made incorrect.

If, on the other hand, all components have discrepancy that is less than half of the total, then any element  can be made to be a majority element. If  belongs to any component (with zero or nonzero discrepancy), we choose equal signs for all other nonzero-discrepancy components in order to force a majority to exist, and then choose a sign for the component containing element~ as desired. Thus, regardless of whether the algorithm chooses that no majority exists or chooses a particular element as a representative of the majority, it can again always be made incorrect.
\end{proof}

\begin{corollary}
\label{cor:nonzero-components}
If an adversary follows the strategy described by \autoref{lem:adv-strat}, and a querying algorithm returns its answer after making a sequence of queries that leads to components with total discrepancy at least , then the adversary can choose a partition of the elements consistent with its previous answers that makes the querying algorithm incorrect.
\end{corollary}

For large values of , \autoref{cor:zero-components} implies that the components with zero discrepancy are also large, and therefore that there cannot be many such components.
For small values of , \autoref{cor:nonzero-components} implies that (when a querying algorithm is capable of determining a correct answer) the components with nonzero discrepancy have a small sum of discrepancies, and therefore that there cannot be many such components.
By choosing a value of  that balances the numbers of components of both types,
we can force any correct querying algorithm to leave only a small number of components of either type. To do this, it must make a large number of queries.

\begin{theorem}
When  is even, any algorithm that always correctly finds the majority of  elements by making  or  queries must use at least  queries.
\end{theorem}

\begin{proof}
We set , and follow the adversary strategy described above.
Then by \autoref{cor:zero-components} each component with zero discrepancy left at the end of the querying algorithm must have at least  vertices, from which it follows that there are at most  such components. By \autoref{cor:nonzero-components} the total discrepancy of the nonzero components must be less than ; since each such component has discrepancy at least one, the number of such components is also less than .

The query graph initially has  components, and ends with  components.
Each query reduces the number of components by at most , from which the result follows.
\end{proof}

In particular, for  we need at least  queries. Combining this bound with the known  lower bound for the  case~\cite{SakWer-Comb-91} shows that a lower bound of  is valid for all~.
\fi

\section{Conclusions}
We have provided new bounds for the majority problem, for  and  queries. For  queries with odd query size, our bounds are tight, and for even query size we achieve a matching leading term in our upper and lower bounds. However,  for  queries, our upper and lower bounds bounds are separated from each other by a factor of two. Reducing this gap remains open.

Recently, Gerbner et al. have given bounds for the majority problem for a different type of query that returns an element of the majority of a three-tuple~\cite{GerKesPal-EC-15}. It would be of interest to extend their results to -tuples as well.

Our work also raises the discrepancy-theoretic question of how many sets are needed in a family of -element sets that cannot be balanced. In this, also, our bounds are not tight and further improvement would be of interest.

{
\ifFull
\raggedright
\bibliographystyle{abuser}
\else
\bibliographystyle{splncs}
\fi
\bibliography{queries}}

\end{document}