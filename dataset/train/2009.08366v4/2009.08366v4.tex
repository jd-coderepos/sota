
\documentclass{article} \usepackage{iclr2021_conference,times}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} \usepackage{amssymb} 
\usepackage{amsmath}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{url}
\usepackage{multirow}
\usepackage{verbatim}
\usepackage{color}
\usepackage{wrapfig}


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \iclrfinalcopy
\usepackage{hyperref}
\usepackage{url}

\title{GraphCodeBERT: Pre-training Code Representations with Data Flow}
\author{Daya Guo\thanks{Work done while this author was an intern at Microsoft Research Asia. Contact: Daya Guo (guody5@mail2.sysu.edu.cn) } , Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Shujie Liu, Long Zhou, \\ \bf{Nan Duan, Alexey Svyatkovskiy, Shengyu Fu, Michele Tufano, Shao Kun Deng,} \\ \bf{Colin Clement, Dawn Drain, Neel Sundaresan, Jian Yin, Daxin Jiang, and Ming Zhou}  \\
School of Computer Science and Engineering, Sun Yat-sen University. \\ Beihang University,  Peking University,
Harbin Institute of Technology, \\ Microsoft Research Asia, Microsoft Devdiv, Microsoft STCA}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}



\maketitle
\vskip -0.1in
\begin{abstract}

Pre-trained models for programming language have achieved dramatic empirical improvements on a variety of code-related tasks such as code search, code completion, code summarization, etc. 
However, existing pre-trained models regard a code snippet as a sequence of tokens, while ignoring the inherent structure of code, which provides crucial code semantics and would enhance the code understanding process.
We present GraphCodeBERT, a pre-trained model for programming language that considers the inherent structure of code.
Instead of taking syntactic-level structure of code like abstract syntax tree (AST), we use data flow in the pre-training stage, which is a semantic-level structure of code that encodes the relation of ``where-the-value-comes-from'' between variables. Such a semantic-level structure is less complex and does not bring an unnecessarily deep hierarchy of AST, the property of which makes the model more efficient.
We develop GraphCodeBERT based on Transformer. In addition to using the task of masked language modeling, we introduce two structure-aware pre-training tasks. One is to predict code structure edges, and the other is
to align representations between source code and code structure.
We implement the model in an efficient way with a graph-guided masked attention function to incorporate the code structure.
We evaluate our model on four tasks, including code search, clone detection, code translation, and code refinement. Results show that code structure and newly introduced pre-training tasks can improve GraphCodeBERT and achieves state-of-the-art performance on the four downstream tasks. We further show that the model prefers structure-level attentions over token-level attentions in the task of code search.\footnote{All the codes and data are available at \url{https://github.com/microsoft/CodeBERT}.}
\end{abstract}

\section{Introduction}
Pre-trained models such as ELMo \citep{peters2018deep}, GPT \citep{radford2018improving} and BERT \citep{devlin2018bert} have led to strong improvement on numerous natural language processing (NLP) tasks.  These pre-trained models are first pre-trained on a large unsupervised text corpus, and then fine-tuned on downstream tasks.
The success of pre-trained models in NLP also promotes the development of pre-trained models for programming language.
Existing works \citep{kanade2019pre,karampatsis2020scelmo,feng2020codebert,svyatkovskiy2020intellicode,buratti2020exploring} regard a source code as a sequence of tokens and pre-train models on source code to support code-related tasks such as code search, code completion, code summarization, etc. 
However, previous works only utilize source code for pre-training, while ignoring the inherent structure of code. Such code structure provides useful semantic information of code, which would benefit the code understanding process.
Taking the expression {} as an example,  is computed from  and . Programmers do not always follow the naming conventions so that it's hard to understand the semantic of the variable  only from its name. The semantic structure of code provides a way to understand the semantic of the variable  by leveraging dependency relation between variables. 

In this work, we present GraphCodeBERT, a pre-trained model for programming language that considers the inherent structure of code. Instead of taking syntactic-level structure of code like abstract syntax tree (AST), we leverage semantic-level information of code, i.e. data flow, for pre-training. Data flow is a graph, in which nodes represent variables and edges represent the relation of ``where-the-value-comes-from" between variables. 
Compared with AST, data flow is less complex and does not bring an unnecessarily deep hierarchy, the property of which makes the model more efficient.
In order to learn code representation from source code and code structure, we introduce two new structure-aware pre-training tasks. One is data flow edges prediction for learning representation from code structure, and the other is variable-alignment across source code and data flow for aligning representation between source code and code structure.
GraphCodeBERT is based on Transformer neural architecture \citep{vaswani2017attention} and we extend it by introducing a graph-guided masked attention function to incorporate the code structure.




We pre-train GraphCodeBERT on the CodeSearchNet dataset \citep{husain2019codesearchnet}, which includes 2.3M functions of six programming languages paired with natural language documents. We evaluate the model on four downstream tasks: natural language code search, clone detection, code translation, and code refinement. Experiments show that our model achieves state-of-the-art performance on the four tasks.
Further analysis shows that code structure and newly introduced  pre-training tasks can improve GraphCodeBERT and the model has consistent preference for attending data flow.

In summary, the contributions of this paper are: (1) GraphCodeBERT is the first pre-trained model that leverages semantic structure of code to learn code representation. (2) We introduce two new structure-aware pre-training tasks for learning representation from source code and data flow. (3) GraphCodeBERT provides significant improvement on four downstream tasks, i.e. code search, clone detection, code translation, and code refinement.






\section{Related Works}




\paragraph{Pre-Trained Models for Programming Languages}
Inspired by the big success of pre-training in NLP \citep{devlin2018bert,yang2019xlnet,liu2019roberta,raffel2019exploring},  pre-trained models for programming languages also promotes the development of code intelligence \citep{kanade2019pre,feng2020codebert,karampatsis2020scelmo,svyatkovskiy2020intellicode,buratti2020exploring}. \citet{kanade2019pre} pre-train a BERT model on a massive corpus of Python source codes by masked language modeling and next sentence prediction objectives. \citet{feng2020codebert} propose CodeBERT, a bimodal pre-trained model for programming and natural languages by masked language modeling and replaced token detection to support text-code tasks such as code search. \citet{karampatsis2020scelmo} pre-train contextual embeddings on a JavaScript corpus using the ELMo framework for program repair task. \citet{svyatkovskiy2020intellicode} propose GPT-C, which is a variant of the GPT-2 trained from scratch on source code data to support generative tasks like code completion. 
\citet{buratti2020exploring} present C-BERT, a transformer-based language model pre-trained on a collection of repositories written in C language, and achieve high accuracy in the abstract syntax tree (AST) tagging task. 

Different with previous works, GraphCodeBERT is the first pre-trained model that leverages code structure to learn code representation to improve code understanding. 
We further introduce a graph-guided masked attention function to incorporate the code structure into Transformer and two new structure-aware pre-training tasks to learn representation from source code and code structure. 


\paragraph{Neural Networks with Code Structure}
In recent years, some neural networks leveraging code structure such as AST have been proposed and achieved strong performance in code-related tasks like
code completion \citep{li2017code,alon2019structural,kim2020code}, code generation \citep{rabinovich2017abstract,yin17acl,brockschmidt2018generative}, code clone detection \citep{wei2017supervised,zhang2019novel,wang2020detecting}, code summarization \citep{alon2018code2seq,hu2018deep} and so on \citep{nguyen2015graph,allamanis2018learning,hellendoorn2019global}. \citet{nguyen2015graph} propose an AST-based language model to support the detection and suggestion of a syntactic template at the current editing location. \citet{allamanis2018learning} use graphs to represent programs and graph neural network to reason over program structures. \citet{hellendoorn2019global} propose two different architectures using a gated graph neural network and Transformers for combining local and global information to leverage richly structured representations of source code.
However, these works leverage code structure to learn models on specific tasks from scratch without using pre-trained models. In this work, we study how to leverage code structure for pre-training code representation. 
\section{Data Flow}
\label{data flow}

In this section, we describe the basic concept and extraction of data flow. In next section, we will describe how to use data flow for pre-training. 

Data flow is a graph that represents dependency relation between variables, in which nodes represent variables and edges represent where the value of each variable comes from.
Unlike AST, data flow is same under different abstract grammars for the same source code.
Such code structure provides crucial code semantic information for code understanding. 
Taking {} as an example, programmers do not always follow the naming conventions so that it is hard to understand the semantic of the variable. Data flow provides a way to understand the semantic of the variable   to some extent,  i.e. the value of  comes from  and  in data flow.
Besides, data flow supports the model to consider long-range dependencies induced by using the same variable or function in distant locations. Taking Figure \ref{figure-data-flow} as an example, there are four variables with same name (i.e. , ,  and ) but with different semantic. The graph in the figure shows dependency relation between these variables and supports  to pay more attention to  and  instead of . Next, we describe how to extract data flow from a source code.


\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{data-flow.pdf}
		\caption{The procedure of extracting data flow given a source code. The graph in the rightmost is data flow that represents the relation of "where-the-value-comes-from" between variables.}
		\label{figure-data-flow}
	\end{center}

\end{figure}

Figure \ref{figure-data-flow} shows the extraction of data flow through a source code.
Given a source code , we first parse the code into an abstract syntax tree (AST) by a standard compiler tool\footnote{\url{https://github.com/tree-sitter/tree-sitter}}. The AST includes syntax information of the code and terminals (leaves) are used to identify the variable sequence, denoted as .  
We take each variable as a node of the graph and an direct edge  from  to  refers that the value of -th variable comes from -th variable.
Taking  as an example, edges from all variables in  to  are added into the graph. We denote the set of directed edges as  and the graph  is data flow used to represent dependency relation between variables of the source code . 



\section{GraphCodeBERT}
\label{GraphCodeBERT}

In this section, we describe GraphCodeBERT, a graph-based pre-trained model based on Transformer for programming language. 
We introduce model architecture, graph-guided masked attention and pre-training tasks including standard masked language model and newly introduced ones. More details about model pre-training setting are provided in the Appendix A.


\begin{figure}[t]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{model.pdf}
		\caption{An illustration about GraphCodeBERT pre-training. The model takes source code paired with comment and the corresponding data flow as the input, and is pre-trained using standard masked language modeling \citep{devlin2018bert} and two structure-aware tasks. One structure-aware task is to predict where a variable is identified from (marked with orange lines) and the other is data flow edges prediction between variables (marked with blue lines).   }
		\label{figure-model}
	\end{center}

\end{figure}

\subsection{Model Architecture}
Figure \ref{figure-model} shows the model architecture of GraphCodeBERT. We follow BERT \citep{devlin2018bert} and use the multi-layer bidirectional Transformer \citep{vaswani2017attention} as the model backbone.
Instead of only using source code, we also utilize paired comments to pre-train the model to support more code-related tasks involving natural language such as natural language code search \citep{feng2020codebert}.
We further take data flow, which is a graph, as a part of the input to the model.


Given a source code  with its comment , we can obtain the corresponding data flow  as discussed in the Section \ref{data flow}, where  is a set of variables and  is a set of direct edges that represent where the value of each variable comes from.
We concatenate the comment, source code and the set of variables as the sequence input  , where  is a special token in front of three segments and  is a special symbol to split two kinds of data types.

GraphCodeBERT takes the sequence  as the input and then converts the sequence into input vectors . For each token, its input vector is constructed by summing the corresponding token and position embeddings. We use a special position embedding for all variables to indicate that they are nodes of data flow. The model applies N transformer layers over the input vectors to produce contextual representations . Each transformer layer contains an architecturally identical transformer that applies a multi-headed self-attention operation \citep{vaswani2017attention} followed by a feed forward layer over the input  in the -th layer.



where  is a multi-headed self-attention mechanism,  is a two layers feed forward network, and  represents a layer normalization operation. 
For the -th transformer layer, the output  of a multi-headed self-attention is computed via:



where the previous layer's output  is linearly projected to a triplet of queries, keys and values using model parameters ,,, respectively.  is the number of heads,  is the dimension of a head, and  is the model parameters.  is a mask matrix, where  is 0 if -th token is allowed to attend -th token otherwise .


\subsection{Graph-guided Masked Attention}
To incorporate the graph structure into Transformer, we define a graph-guided masked attention function to filter out irrelevant signals. 
The attention masking function could avoid the key  attended by the query  by adding the attention score  an infinitely negative value so that the attention weight becomes zero after using a softmax function.
To represent dependency relation between variables, a node-query  is allowed to attend to a node-key  if there is a direct edge from the node  to the node  (i.e. ) or they are the same node (i.e. ). Otherwise, the attention is masked by adding an infinitely negative value into the attention score.
To represent the relation between source code tokens and nodes of the data flow, we first define a set , where  if the variable  is identified from the source code token . We then allow the node  and code  attend each other if and only if  .
More formally, we use the following graph-guided masked attention matrix as the mask matrix  in the equation \ref{eq:score}:




\subsection{Pre-training Tasks}
We describe three pre-training tasks used for pre-training GraphCodeBERT in this section. 
The first task is masked language modeling \citep{devlin2018bert} for learning representation from the source code.
The second task is data flow edge prediction for learning representation from data flow, where we first mask some variables' data flow edges and then let GraphCodeBERT predict those edges.
The last task is variable-alignment across source code and data flow for aligning representation between source code and data flow, which predicts where a variable is identified from.

\paragraph{Masked Language Modeling}
We follow \citet{devlin2018bert} to apply masked language modeling (MLM) pre-training task. Specially, we sample randomly 15\% of the tokens from the source code and paired comment. We replace them with a [MASK] token 80\% of the time, with a random token 10\% of the time, and leave them unchanged 10\% of the time.  The MLM objective is to predict original tokens of these sampled tokens, which has proven effective in previous works \citep{devlin2018bert,liu2019roberta,feng2020codebert}.
In particular, the model can leverage the comment context if the source code context is not sufficient to infer the masked code token, encouraging the model to align the natural language  and programming language representations.


\paragraph{Edge Prediction}
To learn representation from data flow, we introduce a pre-training task of data flow edges prediction. The motivation is to encourage the model to learn structure-aware representation that encodes the relation of ``where-the-value-comes-from" for better code understanding. Specially, we randomly sample 20\% of nodes  in data flow, mask direct edges connecting these sampled nodes by add an infinitely negative value in the mask matrix, and then predict these masked edges . Taking the variable  in Figure \ref{figure-model} for an example, we first mask edges  and  in the graph and then let the model to predict these edges.  Formally, the pre-training objective of the task is calculated as Equation \ref{edgepred}, where  is a set of candidates for edge prediction,  is 1 if  otherwise 0, and the probability  of existing an edge from -th to -th node is calculated by dot product following a sigmoid function using representations of two nodes from GraphCodeBERT. To balance positive-negative ratio of examples, we sample negative and positive samples with the same number for .




\paragraph{Node Alignment}
To align representation between source code and data flow, we introduce a pre-training task of node alignment across source code and data flow, which is similar to data flow edge prediction. 
Instead of predicting edges between nodes, we predict edges between code tokens and nodes.
The motivation is to encourage the model to align variables and source code according to data flow. 
Taking  Figure \ref{figure-node-alignment-task} for an example, we first mask edges between the variable  in data flow and code tokens, and then predict which code token the variable  in data flow is identified from. As we can see, the model could predict that the variable  is identified form the variable  in the expression ``return x" according to data flow information (i.e. the value of  comes from  or ).
\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{node-aligment-task.pdf}
		\caption{An example of the Node Alignment task.}
		\label{figure-node-alignment-task}
	\end{center}
	\vskip -0.1in
\end{figure}

Specially, we randomly sample 20\% nodes  in the graph, mask edges between code tokens and sampled nodes, and then predict masked edges . The pre-training objective of this task is similar to Equation \ref{edgepred}, where  is a set of candidates for node alignment. Similarly, we also sample negative and positive samples with the same number for .







\section{Experiments}
\label{experiments}


We evaluate our model on four downstream tasks, including code search, clone detection, code translation and code refinement.
Detailed experimental settings can be found in the Appendix.

\subsection{Natural Language Code Search}\label{section:experiment-code-search}
Given a natural language as the input, the task aims to find the most semantically related code from a collection of candidate codes.
We conduct experiments on the CodeSearchNet code corpus \citep{husain2019codesearchnet}, which includes six programming languages.
Different from the dataset and the setting used in the \citet{husain2019codesearchnet}, we filter low-quality queries by handcrafted rules and expand 1000 candidates to the whole code corpus, which is closer to the real-life scenario. 
We use Mean Reciprocal Rank (MRR) as our evaluation metric and report results of existing methods in the Table \ref{table-codesearchnet-result}. We provide more details about the filtered dataset and also give results using the same setting of \citet{husain2019codesearchnet}  in the Appendix B.


\begin{table*}[h]
	\begin{center}
		\begin{small}
				\begin{tabular}{lccccccc}
					\toprule
model & Ruby & Javascript & Go & Python & Java & Php & Overall\\
					\midrule
NBow &0.162 & 0.157 & 0.330& 0.161 & 0.171 & 0.152 & 0.189\\
					CNN & 0.276 & 0.224 & 0.680 &  0.242 & 0.263 & 0.260 & 0.324\\	
					BiRNN  & 0.213& 0.193 & 0.688& 0.290 & 0.304 & 0.338 & 0.338\\
					selfAtt  & 0.275& 0.287 & 0.723& 0.398 & 0.404 & 0.426 & 0.419\\
					\hline
					RoBERTa  & 0.587& 0.517 & 0.850&   0.587 & 0.599& 0.560 &0.617 \\
					RoBERTa (code)   & 0.628& 0.562 &0.859 & 0.610 & 0.620 & 0.579 &0.643\\
					CodeBERT  & 0.679& 0.620 & 0.882& 0.672 & 0.676 & 0.628 & 0.693\\
					GraphCodeBERT   & \bf{0.703}& \bf{0.644} & \bf{0.897}& \bf{0.692} & \bf{0.691} & \bf{0.649} & \bf{0.713}\\
					\bottomrule
				\end{tabular}
    \caption{Results on code search. GraphCodeBERT outperforms other models significantly (). }
    	\label{table-codesearchnet-result}
		\end{small}
	\end{center}
\end{table*}


All models calculate inner product of code and query encodings as relevance scores to rank candidate codes.
We follow \citet{husain2019codesearchnet} to implement four methods as baselines  in the first group to obtain the encodings, including bag-of-words, convolutional neural network, bidirectional recurrent neural network, and multi-head attention.
The second group is the results of pre-trained models. Roberta \citep{liu2019roberta} is a pre-trained model on text corpus with MLM learning objective, while \textbf{RoBERTa (code)} is pre-trained only on code.
\textbf{CodeBERT} \citep{feng2020codebert} is pre-trained on code-text pairs with MLM and replaced token detection learning objectives.
As we can see, \textbf{GraphCodeBERT} that leverages code structure for pre-training brings a 2\% gain of MRR, achieving the state-of-art performance. We also conducted t-test between our GraphCodeBERT and other baselines, and the results show the improvements are significant with .





\subsection{Code Clone Detection}\label{section:experiment-clone detection}
Code clones are multiple code fragments that output similar results when given the same input. 
The task aims to measure the similarity between two code fragments, which can help  reduce the cost of software maintenance and prevent bugs.
We conduct experiments on the BigCloneBench dataset \citep{svajlenko2014towards} and report results in the Table \ref{table-code-clone-detection}. 


\textbf{Deckard}  \citep{jiang2007deckard} is to compute vectors for structural information within ASTs and then a Locality Sensitive Hashing (LSH) \citep{datar2004locality} is used to cluster similar vectors for detection.
\textbf{RtvNN} \citep{white2016deep} trains a recursive autoencoder to learn representations for AST. 
\textbf{CDLH} \citep{wei2017supervised} learn representations of code fragments via AST-based LSTM and 
hamming distance is used to optimize the distance between the vector representation of AST pairs. 
\begin{wraptable}{r}{7.2cm}
\centering
\small
		\begin{tabular}{l|c|c|c}
			\hline 
			Model & Precision & Recall & F1 \\
\hline 
			Deckard&0.93&0.02&0.03\\
			RtvNN&0.95&0.01&0.01\\
			CDLH&0.92&0.74&0.82\\
			ASTNN&0.92&0.94&0.93\\
			FA-AST-GMN&{\bf0.96}&0.94&0.95\\
			\hline 
RoBERTa (code)&0.949&0.922&0.935 \\
CodeBERT&0.947&0.934&0.941 \\
GraphCodeBERT & 0.948&{\bf 0.952}&{\bf 0.950}\\
			\hline 
		\end{tabular}
	\caption{Results on code clone detection. GraphCodeBERT outperforms other pre-trained methods significantly ().}

	\label{table-code-clone-detection}

\end{wraptable}
\textbf{ASTNN} \cite{zhang2019novel} uses RNNs to encode AST subtrees for statements, then feed the encodings of all statement trees into an RNN to learn representation for a program.
\textbf{FA-AST-GMN} \citep{wang2020detecting} uses GNNs over a flow-augmented AST to leverages explicit control and data flow information for code clone detection.
Results show that our \textbf{GraphCodeBERT} that leverages code structure information significantly outperforms other methods with , which demonstrates the effectiveness of our pre-trained model for the task of code clone detection.


\subsection{Code Translation}\label{section:experiment-code translation}
Code translation aims to migrate legacy software from one programming language in a platform to another. Following \citet{nguyen2015divide} and \citet{chen2018tree}, we conduct experiments on a dataset crawled from the same several open-source projects as them and report results in the Table \ref{table-code-translation}.


The \textbf{Naive} method is directly copying the source code as the translation result. \textbf{PBSMT} is short for phrase-based statistical machine translation \citep{koehn2003statistical}, and has been exploited in previous works \citep{nguyen2013lexical,karaivanov2014phrase}. 
As for the \textbf{Transformer}, we use the 
\begin{wraptable}{r}{7.5cm}
\centering
\small
        \begin{tabular}{l|cc|cc}
        \hline
        \multirow{2}*{Method} & \multicolumn{2}{c|}{JavaC\#} & \multicolumn{2}{c}{C\#Java}\\
        \cline{2-5}
        & BLEU & Acc & BLEU & Acc\\
        \hline
        Naive & 18.54 & 0.0 & 18.69 & 0.0 \\
        PBSMT & 43.53 & 12.5 & 40.06 & 16.1 \\
        Transformer & 55.84 & 33.0 & 50.47 & 37.9 \\
        \hline
    	RoBERTa (code) & 77.46 & 56.1 & 71.99 & 57.9 \\
		CodeBERT & 79.92 & 59.0 & 72.14 & 58.8 \\
		GraphCodeBERT & {\bf 80.58} & {\bf 59.4} & {\bf 72.64} & {\bf 58.8}\\
		\hline
        \end{tabular}
        \caption{Results on code translation.}
        	\label{table-code-translation}
\end{wraptable}
same number of layers  and hidden size as pre-trained models.
To leverage the pre-trained models for translation, we initialize the encoder with pre-trained models and randomly initialize parameters of the decoder and the source-to-target attention. 
Results show that the models initialized with pre-trained models (i.e the second group) outperform PBSMT and Transformer models. Among them, \textbf{
GraphCodeBERT} achieves state-of-art performance, which demonstrates the effectiveness of our model for code translation. 


\subsection{Code Refinement }\label{section:experiment-code refinement }
Code refinement aims to automatically fix bugs in the code, which can contribute to reducing the cost of bug-fixes. We use the dataset released by \citet{tufano2019empirical} and report results in the Table \ref{table-code-refinement}.


The \textbf{Naive} method  directly copies the buggy code as the refinement result. For the \textbf{Transformer}, we use the same number of layers and hidden size as the pre-trained models. Same as the Section \ref{section:experiment-code translation}, we initialize the encoder with pre-trained models and randomly initialize parameters of the decoder 
\begin{wraptable}{r}{8cm}
\centering
\small
        \begin{tabular}{l|cc|cc}
        \hline
        \multirow{2}*{Method} & \multicolumn{2}{c|}{small} & \multicolumn{2}{c}{medium}\\
        \cline{2-5}
        & BLEU & Acc & BLEU & Acc\\
        \hline
        Naive & 78.06 & 0.0 & 90.91 & 0.0 \\
        LSTM & 76.76 & 10.0 & 72.08 & 2.5 \\
        Transformer & 77.21 & 14.7 & 89.25 & 3.7 \\
        \hline
    	RoBERTa (code) & 77.30 & 15.9 & 90.07 & 4.1 \\
		CodeBERT & 77.42 & 16.4 & 91.07 & 5.2 \\
		GraphCodeBERT  & {\bf 80.02} & {\bf 17.3} & {\bf 91.31} & {\bf 9.1}\\
		\hline
        \end{tabular}
        \caption{Results on code refinement.}
	\label{table-code-refinement}
\end{wraptable}
and the source-to-target attention. Then we use the training data to fine-tune the whole model. In the table, we see that the \textbf{Transformer} significantly
outperforms \textbf{LSTM}. Results in the second group shows that pre-trained models outperform Transformer models further, and \textbf{GraphCodeBERT} achieves better performance than other pre-trained models on both datasets, which shows leveraging code structure information are helpful to the task of code refinement.

\subsection{Model Analysis }\label{section:model analysis}
\paragraph{Ablation Study }\label{section:ablation study}
We conduct ablation study on the task of natural language code search to understand various components in our approach impact overall performance. We remove two pre-training tasks and data flow, respectively, to analyze their contribution.
Table \ref{ablation_stdudy_search} shows that the overall performance drops from 71.3\% to 70.3\%70.7\% when removing Node Alignment and Edge Prediction pre-training tasks, respectively, which reveals the importance of two structure-aware pre-training tasks. After ablating the data flow totally, we can see that the performance drops from 71.3\% to 69.3\%, which means leveraging data
flow to learn code representation could improve GraphCodeBERT.

\begin{table}[h]
	\begin{center}
		\begin{small}
			\begin{tabular}{lccccccc}
				\toprule
Methods & Ruby & Javascript & Go & Python & Java & Php & Overall\\
				\midrule
				GraphCodeBERT    & \bf{0.703}& \bf{0.644} & \bf{0.897}& \bf{0.692} & \bf{0.691} & \bf{0.649} & \bf{0.713} \\	
				 \ -w/o EdgePred   &0.701 &0.632 &0.894 & 0.687&0.688 &0.640 & 0.707
				\\				
				 \ -w/o  NodeAlign& 0.685 & 0.635& 0.887& 0.682& 0.690&0.640 &0.703
				\\
				 \ -w/o Data Flow   & 0.679& 0.620 & 0.882& 0.672 & 0.676 & 0.628 & 0.693				\\				

				\bottomrule
			\end{tabular}
        	\caption{Ablation study on natural language code search}
	\label{ablation_stdudy_search}
		\end{small}
	\end{center}
	\vskip -0.2in
\end{table}


\paragraph{Node-vs. Token-level Attention}
Table \ref{attention_distribution} shows how frequently a special token  that is used to calculate probability of correct candidate attends to code tokens (Codes) and variables (Nodes). We see that although the number of nodes account for 5\%20\%, attentions over nodes overwhelm node/code ratio (around 10\% to 32\%) across all programming languages. The results indicate that data flow plays an important role in code understanding process and the model pays more attention to nodes in data flow than code tokens. 
\begin{table}[h]
	\begin{center}
		\begin{small}
			\begin{tabular}{lcccccc}
				\toprule
& Ruby & Javascript & Go & Python & Java & Php\\
				\midrule
				Codes/Nodes   & 90.1/9.9 & 94.6/5.4 &95.0/5.03 & 80.6/19.4 &93.2/6.8 & 87.5/12.5\\		
				Codes/Nodes   & 82.3/17.7 & 89.7/10.3 &91.0/9.0 & 67.7/32.3 &87.8/12.2 &79.4/20.6\\
				\bottomrule
			\end{tabular}
	\caption{Attention distribution (\%) between code tokens (codes) and variables (nodes) across different programming language on natural language code search test sets. The first row is the ratio of the number of code tokens to nodes, and the second row is attention distribution of  token.}
	\label{attention_distribution}
		\end{small}
	\end{center}
	\vskip -0.2in	
\end{table}

\paragraph{Comparison between AST and Data Flow}
Figure \ref{figure-plot} shows MRR score with respect to input sequence length on the validation dataset of Ruby programming language for the task of code search. 
{\bf AST Pre-order Traversal} regards AST as a sequence by linearizing all AST nodes using pre-order traversal algorithm. {\bf AST Subtree Masking} regards AST as a tree and introduce subtree masking \citep{nguyen2019tree} for self-attention of the Transformer. In subtree masking, 
each node-query in AST attends only to its own subtree descendants, and each leaf-query only attends to leaves of AST.
Transformer  has  a self-attention component with  time and memory complexity where  is the input sequence length, and thus is not efficient to scale to long inputs. 
\begin{wrapfigure}{r}{8.9cm}
\centering
\centerline{\includegraphics[width=0.43\textwidth]{plot.pdf}}
\caption{ MRR score on the validation dataset of Ruby for code search with varying length of input sequence.}
\label{figure-plot}
\vskip -0.2in
\end{wrapfigure}
We observe that injecting AST even hurts the performance when the sequence length is short (e.g. shorter than 128), while 
GraphCodeBERT consistently brings performance boost on varying sequence length and obtains better MRR score than AST-based methods. 
The main reason is that data flow is less complex and the number of nodes account for  (see Table \ref{attention_distribution}), which does not bring an unnecessarily deep hierarchy of AST and 
makes the model more accurate and efficient.


\paragraph{Case Study}
We also give a case study to demonstrate that data flow would enhance the code understanding process. Given a source code and a comment, we use GraphCodeBERT with and without data flow to predict whether the comment correctly describes the source code. Results are given in Figure \ref{case-study}. We can see that both models make correct prediction in the original example, where the threshold is 0.5 (left panel).
To study the code understanding ability of models, we change the source code (center panel) and the comment (right panel), respectively.
Although we make a small change on the source code () and the comment (), the semantic of the source code and the comment are completely different and  corresponding gold labels change from 1 to 0.
As we can see in the figure, GraphCodeBERT without using data flow fails these tests and still outputs high probability for negative examples. 
After leveraging data flow, GraphCodeBERT better understands the semantic of source code and makes correct predictions on all tests, which demonstrates that data flow could improve the code understanding ability of the model.



\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{case-study.pdf}
		\caption{We take a comment and a source code as the input (first row), and use GraphCodeBERT with and without data flow to predict the probability of the source code matching the comment (third row). The label is 1 if the comment correctly describes the source code otherwise 0 (second row). }
		\label{case-study}
	\end{center}
\end{figure}

\section{Conclusion}
In this paper, we present GraphCodeBERT that leverages data flow to learn code representation. To the best of our knowledge, this is the first pre-trained model that considers code structure for pre-training code representations. We introduce two structure-aware pre-training tasks and show that GraphCodeBERT achieves state-of-the-art performance on four code-related downstream tasks, including code search, clone detection, code translation and code refinement.
Further analysis shows that code structure and newly introduced pre-training tasks boost the performance. Additionally, case study in the task of code search shows that applying data flow in the pre-trained model improves code understanding.

\subsubsection*{Acknowledgments}
Daya Guo and Jian Yin are supported by the Research Foundation of Science and Technology Plan Project in Guangdong Province (2017B030308007).

\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\appendix
\section{Pre-training Details}
GraphCodeBERT includes 12 layers Transformer with 768 dimensional hidden states and 12 attention heads. 
For fair comparison, we use the same dataset as CodeBERT \citep{feng2020codebert} to pretrain our model. The dataset is the CodeSearchNet dataset\footnote{\url{https://github.com/github/CodeSearchNet}}  \citep{husain2019codesearchnet}, which includes 2.3M functions with document pairs for six programming languages. 
We train the model on two DGX-2 machines, each having 16 NVIDIA Tesla V100 with 32GB memory. We set the max length of sequences and nodes as 512 and 128, respectively. We use the Adam optimizer to update model parameters with 1,024 batch size and 2e-4 learning rate. To accelerate
the training process, we adopt the parameters of
CodeBERT released by \cite{feng2020codebert} to initialize the model. The model is trained with 200K batches and costs about 83 hours.

At each iteration, we alternate EdgePred and NodeAlign objectives in combination with MLM to pre-train the model. And we follow \citet{lample2019cross} to sample each batch from the same programming language according to a multinomial distribution with probabilities , where  is number of examples for -th programming language and =0.7. Sampling with this distribution could alleviates the bias towards high-resource languages.


\section{Natural Language Code Search}
Given a natural language as the input, code search aims to find the most semantically related code from a collection of candidate codes.
We conduct experiments on the CodeSearchNet code corpus \citep{husain2019codesearchnet} and follow \citet{husain2019codesearchnet} to take the first paragraph of the documentation as the query for the corresponding function. 
However, we observe that some queries contain content unrelated to the code, such as a link ``http://..." that refers to external resources. 
Therefore, we filter following examples to improve the quality of the dataset. 

\ (1) Examples whose code could not be parsed into abstract syntax tree.

\ (2) Examples whose query tokens number is  shorter than 3 or larger than 256.

\ (3) Examples whose query contains special tokens such as ``http://".

\ (4) Examples whose query is empty or not written in English.

Different from the setting of \citet{husain2019codesearchnet}, the answer of each query is retrieved from the whole development and testing code corpus instead of 1,000 candidate codes. 
We list data statistics about the filtered dataset in Table \ref{table-codesearchnet-data-statistic}.
\begin{table}[h]
	\begin{center}
		\begin{tabular}{l|c|c|c|c}
			\hline 
			Code Search & Training examples& Dev queries& Testing queries & Candidate codes \\
\hline 
			Go&167,288&7,325&8,122&28,120\\
			Java&164,923&5,183&10,955&40,347\\
			JavaScript&58,025&3,885&3,291&13,981\\
			PHP&241,241&12,982&14,014&52,660\\
			Python&251,820&13,914&14,918&43,827\\
			Ruby&24,927&1,400&1,261&4,360\\
			\hline 
		\end{tabular}
	\caption{Data statistics about the filtered dataset. For each query in the development and testing sets, the answer is retrieved from the whole candidate codes (i.e. the last row).}
	\label{table-codesearchnet-data-statistic}
	\end{center}
\end{table}

We use GraphCodeBERT to separately encode query and source code with data flow, and calculate inner product of their representations of the special token  as relevance scores to rank candidate codes.  In the fine-turning step, we set the learning rate as 2e-5, the batch size as 32, the max sequence length of queries and codes as 128 and 256, and the max number of nodes as 64. We use the Adam optimizer to update model parameters and perform early stopping on the development set.

We also report the results using the same setting of \citet{husain2019codesearchnet} in Table \ref{table-codesearchnet-result-origianl}. In this setting, models are required to retrieve an answer for a query from 1000 candidates. The results show that GraphCodeBERT also achieves the state-of-the-art performance.
\begin{table*}[h]
	\begin{center}
		\begin{small}
				\begin{tabular}{lccccccc}
					\toprule
model & Ruby & Javascript & Go & Python & Java & Php & Overall\\
					\midrule
NBow & 0.429 & 0.461 & 0.641& 0.581 & 0.514 & 0.484 & 0.518\\
					CNN & 0.245 & 0.352 & 0.627 & 0.571 & 0.527 & 0.529 & 0.475\\
					BiRNN & 0.084 & 0.153 & 0.452 & 0.321 & 0.287 & 0.251 & 0.258\\
					selfAtt & 0.365 & 0.451 & 0.681 & 0.692& 0.587 & 0.601 & 0.563\\
					\hline
					RoBERTa & 0.625 & 0.606 & 0.820 & 0.809 & 0.666 & 0.658 & 0.697 \\
					RoBERTa (code)  & 0.661& 0.640&0.819& 0.844&0.721 & 0.671& 0.726\\
					CodeBERT& 0.693 & 0.706 &0.840 & 0.869 &0.748 & 0.706 & 0.760\\
					GraphCodeBERT  & \bf{0.732} & \bf{0.711} &\bf{0.841} & \bf{0.879} &\bf{0.757} & \bf{0.725} & \bf{0.774}\\
					\bottomrule
				\end{tabular}
    \caption{Results on natural language code search using the setting of \citet{husain2019codesearchnet}. }
    	\label{table-codesearchnet-result-origianl}
		\end{small}
	\end{center}
	\vskip -0.2in
\end{table*}



\section{Code Clone Detection}
Code clone detection aims to measure the similarity between two code fragments. We use BigCloneBench dataset \citep{svajlenko2014towards}, which contains over 6,000,000 true clone pairs and 260,000 false clone pairs from 10 different functionalities. We follow the settings in \citet{wei2017supervised}, discarding code fragments without any tagged true and false clone pairs and using 9,134 remaining code fragments. Finally, the dataset provided by \citet{wang2020detecting} includes 901,724/416,328/416,328 examples for training/validation/testing.
We treat the task as a binary classification to fine-tune GraphCodeBERT, where we use source code and data flow as the input. The probability of true clone is calculated by dot product from the representation of .  In the fine-turning step, we set the learning rate as 2e-5, the batch size as 16, the max sequence length as 512 the max number of nodes as 128. We use the Adam optimizer to update model parameters and tune hyper-parameters and perform early stopping on the development set.

We give a case of the GraphCodeBERT output for this task in Figure \ref{example_clone_detection}. In this example, two Java source codes both download content from a given URL and convert the type of the content into string type. Therefore, two codes are semantically similar since they output similar results when given the same input. As we can see, our model gives a high score for this case and the pair is classified as true clone pair.
\begin{figure}[h]
\begin{center}
		\includegraphics[width=1\columnwidth]{example_clone_detection.pdf}
		\caption{A case of GraphCodeBERT output for the code clone detection task. }
		\label{example_clone_detection}
	\end{center}
	
\end{figure}

\section{Code Translation}
Code translation aims to migrate legacy software from one programming language in a platform to another. We conduct experiments on a dataset crawled from the same several open-source projects as \citet{nguyen2015divide} and \citet{chen2018tree}, i.e. Lucene\footnote{http://lucene.apache.org/}, POI\footnote{http://poi.apache.org/}, JGit\footnote{https://github.com/eclipse/jgit/}  and Antlr\footnote{https://github.com/antlr/}. We do not use Itext\footnote{http://sourceforge.net/projects/itext/} and JTS\footnote{http://sourceforge.net/projects/jts-topo-suite/} as they do because of the license problem.  
Those projects have both Java and C\# implementation. We pair the methods in the two languages based on their file names and method names. After removing duplication and methods with null function body, the total number of method pairs is 11,800, and we split 500 pairs from them as the development set and another 1,000 pairs for test.
To demonstrate the effectiveness of GraphCodeBERT on the task of code translation, we adopt various pre-trained models as encoders and stay hyperparameters consistent. We set the learning rate as 1e-4, the batch size as 32, the max sequence length as 256 and the max number of nodes as 64. We use the Adam optimizer to update model parameters and tune hyper-parameters and perform early stopping on the development set. 

We give a case of the GraphCodeBERT output for this task in Figure \ref{example_translation}. In this example, the model successfully translates a piece of Java code into its C\# version. The differences include the type name (from ``boolean" to ``bool") and the usage of getting a string value of a bool variable (from ``String.valueOf(b)" to ``b.ToString()").  

\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.8\columnwidth]{example_translation.png}
		\caption{A case of GraphCodeBERT output for the code translation task.}
		\label{example_translation}
	\end{center}
\end{figure}
 
\section{Code Refinement} 
Code refinement aims to automatically fix bugs in the code. We use the dataset released by \citet{tufano2019empirical}. The source is buggy Java functions while the target is the according fixed ones. Almost all the names of variables and custom methods are normalized. The dataset contains two subsets based on the code length. For the \textit{small} dataset, the numbers of training, development and test samples are 46,680, 5,835 and 5,835. For the \textit{medium} dataset, the numbers are 52,364, 6,545 and 6,545. We also use the sequence-to-sequence Transformer model to conduct the experiments. In the fine-tuning step, we adopt various pre-trained models as encoders. We set the learning rate as 1e-4, the batch size as 32, the max sequence length as 256 and the max number of nodes as 64. We use the Adam optimizer to update model parameters and perform early stopping on the development set. 

We give two cases of the GraphCodeBERT output for this task in Figure \ref{example_refinement}. In the first example, the model successfully fixes the operation bug (from ``*" to ``+") to match the function name ``add". In the second case, the source function and type names are normalized. The return type of this function is ``void" but the buggy code gives a return value. Our model successfully removes the ``return" word so that the return type of the function matches its declaration. 

\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.8\columnwidth]{example_refinement.png}
		\caption{Two cases of GraphCodeBERT output for the code refinement task.}
		\label{example_refinement}
	\end{center}
\end{figure}




\section{Case Study}
\subsection{Natural Language Code Search}
We give a case study to illustrate retrieved results by GraphCodeBERT on the natural language code search task, with a comparison to CodeBERT and RoBERTa (code) models. Two examples are given in Figure \ref{fig:code-search-case-study} and we can see that GraphCodeBERT successfully retrieves correct source codes for given queries on both examples. As we can see in the first case, incorporating data flow will help Graph-CodeBERT better understand the complicated expression ``[(k, v)\ for k, v in self.items() if v is not self.EMPTY]" by leveraging dependency relation among variables in data flow graph. In the second case, the terminology ``\%Y-\%m-\%d" in Python program language is a format of date time. GraphCodeBERT and CodeBERT both successfully search the correct function. Compared with RoBERTa (code), the second case shows that utilizing natural language descriptions for pre-training helps models do better semantic matching between source codes and queries on the code search task.
\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{code-search-case-study.pdf}
		\caption{Two examples on code search task and retrieved results from different models.}
		\label{fig:code-search-case-study}
	\end{center}
\end{figure}

\iffalse 
\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.7\columnwidth]{code-search-error-case.pdf}
		\caption{Error cases of GraphCodeBERT on natural language code search.}
		\label{fig:code-search-error-case}
	\end{center}
\end{figure}
\fi 

\subsection{Code Clone Detection}
We give a case study to compare GraphCodeBERT with CodeBERT and RoBERTa (code) models on code clone detection task. An example is shown in Figure \ref{fig:clone-detection-case-study}. The  first source code is to return the HTML content from a given URL, while the second source code is to return the last line from a fixed URL ``http://kmttg.googlecode.com/svn/trunk/version". Their semantics are not similar due to their different outputs.
Data flow could help GraphCodeBERT better understand that the return value ``pageHTML" in first source code comes from ``pageHTML.append(line); pageHTML.append(``rn'');" instead of ``bufferedWriter.write(pageHTML.toString());" and the return value ``version" in the second source code comes from ``version = inputLine" or ``version = null;".
Although two source codes are highly overlapped (marked in yellow), GraphCodeBERT  successfully predict the gold label compared with other models without data flow. 
\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.9\columnwidth]{clone-detection-case.pdf}
		\caption{An examples on code clone detection task and model prediction from different models. Overlapped code snippets between two source codes are marked in yellow.}
		\label{fig:clone-detection-case-study}
	\end{center}
\end{figure}




\subsection{Code Translation and Code Refinement}
We give a case study to compare GraphCodeBERT with Transformer without using data flow on code generation tasks, including code translation and code refinement. We list three cases in Table \ref{tab:trans_good_case} and Table \ref{tab:refine_good_case}, respectively. [src] represents the source input, [ref] represents the reference, [sys] represents Transformer without data flow and [ours] represents GraphCodeBERT. We can see that the Transformer ([sys]) baseline makes several mistakes, including repeating tokens, logic errors and syntax errors, while GraphCodeBERT ([ours]) as a encoder could improve the generation.



\begin{table*}[h!]
\small
\begin{center}
\begin{tabular}{c|l}
\toprule 
\multicolumn{2}{c}{Case1: Transformer outputs repeating tokens} \\
\midrule
\ [src] & public static final WeightedTerm[] getTerms(Query query)\{return getTerms(query,false);\} \\
\hline
\ [ref] & public static WeightedTerm[] GetTerms(Query query)\{return GetTerms(query, false);\} \\
\hline
\ [sys] & public static WeightedTerm[] GetTerms(Query query)\{return GetTerms(false, new static  \\ 
& static static static static static WeightTerms);\} \\
\hline
\ [ours] & public static WeightedTerm[] GetTerms(Query query)\{return GetTerms(query, false);\}\\
\midrule
\multicolumn{2}{c}{Case2: Transformer outputs codes with severe logic and syntax errors} \\
\midrule
\ [src] & public long skip(long n)\{int s = (int) Math.min(available(), Math.max(0, n));ptr += s;return s;\} \\
\hline
\ [ref] &public override long Skip(long n)\{int s = (int)Math.Min(Available(), Math.Max(0, n));\\
& ptr += s;return s;\} \\
\hline
\ [sys] &public override long Skip(long n)\{int s = Math.Min(n) == 0 ? Math.Min(00.0 : \\
& Math.Min(n, s.Length);return s;\} \\ 
\hline
\ [ours] &public override long Skip(long n)\{int s = (int)Math.Min(Available(), Math.Max(0, n));\\
& ptr += s;return s;\}\\
\midrule
\multicolumn{2}{c}{Case3: Transformer uses the wrong variable as a parameter.} \\
\midrule
\ [src] & public UnbufferedCharStream(int bufferSize)\{n = 0;data = new int[bufferSize];\} \\
\hline
\ [ref] & public UnbufferedCharStream(int bufferSize)\{n = 0;data = new int[bufferSize];\} \\
\hline
\ [sys] & public UnbufferedCharStream(int bufferSize)\{data = new int[data];\} \\
\hline
\ [ours] & public UnbufferedCharStream(int bufferSize)\{n = 0;data = new int[bufferSize];\} \\
\bottomrule
\end{tabular}
\end{center}
\caption{\label{tab:trans_good_case} Three examples that translate from Java to C\# programming language on code translation task. [src] represents the source input, [ref] represents the reference, [sys] represents Transformer without data flow and [ours] represents GraphCodeBERT.}
\end{table*}


\begin{table*}[h!]
\small
\begin{center}
\begin{tabular}{c|l}
\toprule 
\multicolumn{2}{c}{Case1: Transformer adds redundant parameters (android.view.View view)} \\
\midrule
\ [src] & public void METHOD\_1 ( ) \{ android.content.Intent VAR\_1 = new android.content.Intent \\ 
& ( VAR\_2 ) ; METHOD\_2 ( VAR\_1 , 0 ) ; android.content.Intent i = new android.content.Intent \\
& ( this , VAR\_3 class ) ; METHOD\_3 ( i ) ; \} \\
\hline
\ [ref] & public void METHOD\_1 ( ) \{ android.content.Intent VAR\_1 = new android.content.Intent \\ 
& ( VAR\_2 ) ; METHOD\_2 ( VAR\_1 , 0 ) ; \} \\
\hline
\ [sys] & public void METHOD\_1 ( android.view.View view ) \{ android.content.Intent VAR\_1 = \\
& new android.content.Intent ( VAR\_2 ) ; METHOD\_2 ( VAR\_1 , 0 ) ; \} \\
\hline
\ [ours] & public void METHOD\_1 ( ) \{ android.content.Intent VAR\_1 = new android.content.Intent \\ 
& ( VAR\_2 ) ; METHOD\_2 ( VAR\_1 , 0 ) ; \}\\
\midrule
\multicolumn{2}{c}{Case2: Transformer outputs codes with severe logic or irrelevant codes} \\
\midrule
\ [src] & public java.util.Date METHOD\_1 ( ) \{ return VAR\_1 . METHOD\_1 ( ) . METHOD\_2 ( ) ; \} \\
\hline
\ [ref] & public java.util.Date METHOD\_1 ( ) \{ if ( ( VAR\_1 . METHOD\_1 ( ) ) != null ) \\
& \{ return VAR\_1 . METHOD\_1 ( ) . METHOD\_2 ( ) ; \} else \{ return null ; \} \} \\
\hline
\ [sys] & public java.util.Date METHOD\_1 ( ) \{ if ( ( VAR\_1 ) == null ) \\
& \{ return new java.util.Date ( ) ; \} return VAR\_1 . METHOD\_1 ( ) . METHOD\_2 ( ) ; \} \\ 
\hline
\ [ours] & public java.util.Date METHOD\_1 ( ) \{ if ( ( VAR\_1 . METHOD\_1 ( ) ) != null ) \\
& \{ return VAR\_1 . METHOD\_1 ( ) . METHOD\_2 ( ) ; \} else \{ return null ; \} \}\\
\midrule
\multicolumn{2}{c}{Case3: Transformer makes no change} \\
\midrule
\ [src] & public java.lang.String METHOD\_1 ( TYPE\_1 VAR\_1 ) \{ if ( VAR\_1 == null ) return null ; \\
& return VAR\_1 . METHOD\_2 ( ) . getText ( ) ; \} \\
\hline
\ [ref] & public java.lang.String METHOD\_1 ( TYPE\_1 VAR\_1 ) \{ return VAR\_1 . METHOD\_2 ( ) . \\
& getText ( ) ; \} \\
\hline
\ [sys] & public java.lang.String METHOD\_1 ( TYPE\_1 VAR\_1 ) \{ if ( VAR\_1 == null ) return null ; \\
& return VAR\_1 . METHOD\_2 ( ) . getText ( ) ; \} \\
\hline
\ [ours] & public java.lang.String METHOD\_1 ( TYPE\_1 VAR\_1 ) \{ return VAR\_1 . METHOD\_2 ( ) . \\
& getText ( ) ; \} \\
\bottomrule
\end{tabular}
\end{center}
\caption{\label{tab:refine_good_case} Three examples on code refinement task. [src] represents the source input, [ref] represents the reference, [sys] represents Transformer without data flow and [ours] represents GraphCodeBERT.}
\end{table*}


\section{Error Analysis}
We also conduct error analysis and summary two main classes of errors for both code understanding and generation tasks. 

Figure \ref{fig:code-search-error-case} gives three error cases of GraphCodeBERT on the natural language code search task. We observe that GraphCodeBERR mainly fails to retrieve those source code that involves functions of the library like ``tf" (Tensorflow) in the first case and `` GoogleCloudStorageHook" in the second case. It's difficult for GraphCodeBERR to understand meanings of APIs like ``tf.io.read\_file" and ``tf.image.decode\_image" without relevant information. A potential direction to mitigate the problem is to incorporate definitions of the library.
The other major problem is that there are some terminologies like ``unistr" in the query (corresponding to ``decode(`utf-8')" in Python code) in third case.  Incorporating more text-code pairs for pre-training might alleviate this problem. 

As for the code generation task, Table \ref{tab:trans_bad_case} shows two cases of GraphCodeBERT on the code translation task. We find that the major problems include semantic errors like identifiers from nowhere in the first case and syntax errors like missing a ``\}" symbol before ``return n" in the second case.
This problem might be mitigated by incorporating a dedicated decoder that takes into account grammar of programming languages and different generation paradigm like generating a sequence of production rules \citep{yin17acl, Guo2018DialogtoActionCQ,Guo2019CouplingRA} in a context-free grammar manner. 
\begin{figure}[h]
\begin{center}
		\includegraphics[width=0.8\columnwidth]{code-search-error-case.pdf}
		\caption{Error cases of GraphCodeBERT on the natural language code search.}
		\label{fig:code-search-error-case}
	\end{center}
\end{figure}


\begin{table*}[h!]
\small
\begin{center}
\begin{tabular}{c|l}
\toprule 
\multicolumn{2}{c}{Case1: semantic error -- identifiers from nowhere.} \\
\midrule
\ [src] & public String toString() \{return getKey() + ``: " + getValue(); \} \\
\hline
\ [ref] & public override string ToString()\{return GetKey() + ``: " + GetValue();\} \\
\hline
\ [ours] & public override string ToString()\{return Name + ``: " + GetValue();\}\\
\midrule
\multicolumn{2}{c}{Case2: syntax errors -- missing a ``\}" before ``return n")} \\
\midrule
\ [src] & public static int numNonnull(Object[] data) \{int n = 0;if ( data == null ) return n;\\
& for (Object o : data) \{if ( o!=null ) n++;\}return n;\} \\
\hline
\ [ref] & public static int NumNonnull(object[] data)\{int n = 0;if (data == null)\{return n;\}\\
& foreach (object o in data)\{if (o != null)\{n++;\}\}return n;\} \\
\hline
\ [ours] & public static int NumNonNull(object[] data)\{int n = 0;if (data == null)\{return n;\}\\
&foreach (object o in data)\{if (o != null)\{n++;\}return n;\}\\
\bottomrule
\end{tabular}
\end{center}
\caption{\label{tab:trans_bad_case} Error cases of GraphCodeBERT on the code translation task.  [src] represents the source input, [ref] represents the reference and [ours] represents GraphCodeBERT.}
\end{table*}


\iffalse 
\begin{table*}[h!]
\small
\begin{center}
\begin{tabular}{c|l}
\toprule 
\multicolumn{2}{c}{Case1: identifiers from nowhere (the ``Name" in our output)} \\
\midrule
\ [src] & public String toString() \{return getKey() + ``: " + getValue(); \} \\
\hline
\ [ref] & public override string ToString()\{return GetKey() + ``: " + GetValue();\} \\
\hline
\ [ours] & public override string ToString()\{return Name + ``: " + GetValue();\}\\
\midrule
\multicolumn{2}{c}{Case2: syntax errors -- mismatch of the brace (lost a ``\}" before ``return n")} \\
\midrule
\ [src] & public static int numNonnull(Object[] data) \{int n = 0;if ( data == null ) return n;\\
& for (Object o : data) \{if ( o!=null ) n++;\}return n;\} \\
\hline
\ [ref] & public static int NumNonnull(object[] data)\{int n = 0;if (data == null)\{return n;\}\\
& foreach (object o in data)\{if (o != null)\{n++;\}\}return n;\} \\
\hline
\ [ours] & public static int NumNonNull(object[] data)\{int n = 0;if (data == null)\{return n;\}\\
&foreach (object o in data)\{if (o != null)\{n++;\}return n;\}\\
\midrule
\multicolumn{2}{c}{Case3: syntax errors -- missing a ``)" after ``(\_lastRow = row"} \\
\midrule
\ [src] & public final boolean contains(int row, int col) \{return \_firstRow = row \&\& \_lastRow = row\&\& \\
& \_firstColumn = col \&\& \_lastColumn = col;\} \\
\hline
\ [ref] & public bool Contains(int row, int col)\{return \_firstRow = row \&\& \_lastRow = row \&\& \\
& \_firstColumn = col \&\& \_lastColumn = col;\} \\
\hline
\ [ours] & public bool Contains(int row, int col)\{return (\_firstRow = row) \&\& (\_lastRow = row \&\& \\
& (\_firstColumn = col) \&\& (\_lastColumn = col);\} \\
\midrule
\multicolumn{2}{c}{Case4: Missing statements (the condition of ``c == `+'")} \\
\midrule
\ [src] & public static boolean isValidSchemeChar(int index, char c) \{if ((c = `a' \&\& c = `z')  \\
& (c = `A' \&\& c = `Z')) \{return true;\}if (index  0 \&\& ((c = `0' \&\& c = `9')  \\
& c == `+'  c == `-'  c == `.')) \{return true;\}return false;\} \\
\hline
\ [ref] & public static bool isValidSchemeChar(int index, char c) \{if ((c = `a' \&\& c = `z')  \\
& (c = `A' \&\& c = `Z')) \{return true;\}if (index  0 \&\& ((c = `0' \&\& c = `9')  \\
& c == `+'  c == `-'  c == `.')) \{return true;\}return false;\} \\
\hline
\ [ours] & public static bool isValidSchemeChar(int index, char c) \{if ((c = `a' \&\& c = `z')  \\
& (c = `A' \&\& c = `Z')) \{return true;\}if (index  0 \&\& ((c = `0' \&\& c = `9')  \\
& c == `-'  c == `.')) \{return true;\}return false;\} \\
\bottomrule
\end{tabular}
\end{center}
\caption{\label{tab:trans_bad_case} Bad cases of code translation.}
\end{table*}

\subsection{Code Refinement}
\begin{table*}[h!]
\small
\begin{center}
\begin{tabular}{c|l}
\toprule 
\multicolumn{2}{c}{Case1: changing the return type} \\
\midrule
\ [src] & private int METHOD\_1 ( ) \{ return this . VAR\_1 ; \} \\
\hline
\ [ref] & public int METHOD\_1 ( ) \{ return this . VAR\_1 ; \} \\
\hline
\ [ours] & public long METHOD\_1 ( ) \{ return this . VAR\_1 ; \}\\
\midrule
\multicolumn{2}{c}{Case2: no function body} \\
\midrule
\ [src] & public static void main ( java.lang.String [ ] args ) \{ TYPE\_1 VAR\_1 = TYPE\_2 . \\
& METHOD\_1 ( STRING\_1 ) ; java.lang.System.out.println ( VAR\_1 . METHOD\_2 ( ) ) ; \} \\
\hline
\ [ref] & public static void main ( java.lang.String [ ] args ) \{ TYPE\_1 VAR\_1 = TYPE\_2 . \\
& METHOD\_1 ( STRING\_1 ) ; java.lang.System.out.println ( VAR\_1 . toString ( ) ) ; \} \\
\hline
\ [ours] &public static void main ( java.lang.String [ ] args ) \{ \}\\
\bottomrule
\end{tabular}
\end{center}
\caption{\label{tab:refine_bad_case} Bad cases of code refinement.}
\end{table*}
\fi 


\end{document}
