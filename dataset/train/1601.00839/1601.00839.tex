\documentclass[11pt]{article}
\usepackage{a4wide}
\usepackage{amsthm}
\usepackage{epsfig}
\usepackage{color}
\usepackage{amssymb}
\usepackage{amsmath}
\newcommand{\bm}[1]{\mbox{\boldmath }}
\def\polylog{\operatorname{polylog}}
\def\poly{\operatorname{poly}}
\def\nca{\operatorname{nca}}
\def\succ{\operatorname{succ}}
\def\pred{\operatorname{pred}}
\def\left{\operatorname{left}}
\def\right{\operatorname{right}}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{Cor}{Corollary}
\newtheorem{Def}{Definition}


\begin{document}

\title{Approximate Distance Oracles for Planar Graphs with Improved Query Time-Space Tradeoff}
\author{Christian Wulff-Nilsen
        \footnote{Department of Computer Science,
                  University of Copenhagen,
                  \texttt{koolooz@di.ku.dk},
                  \texttt{http://www.diku.dk/koolooz/}}}

\date{}

\maketitle
\begin{abstract}
We consider approximate distance oracles for edge-weighted -vertex undirected planar graphs. Given fixed , we present a -approximate distance oracle with  space and  query time. This improves the previous best product of query time and space of the oracles of Thorup (FOCS , J.~ACM ) and Klein (SODA ) from  to .
\end{abstract}

\section{Introduction}\label{sec:Intro}
Given an -vertex edge-weighted undirected planar graph , a distance oracle for  is a data structure that can efficiently answer distance queries  between pairs of vertices  in . One way of achieving this is to simply store an -distance matrix where  is the number of vertices. Each query can be answered in constant time but the space requirement is large.

If one is willing to settle for approximate distances, much more compact oracles exist. It has been shown that for any , there is a -approximate distance oracle for  of size  which for any query pair  outputs in time  an estimate  such that  (Thorup~\cite{OraclePlanarThorup} and Klein~\cite{OraclePlanarKlein}).

The oracles of Thorup and of Klein both rely on a recursive decomposition of  using shortest path separators from a shortest path tree : first  is decomposed into two subgraphs with such a separator and then the two subgraphs are recursively decomposed. An important observation is that for any vertex  and any shortest path separator , there is a size  set  of so called portals on  which are vertices such that for any , there exists a  such that . Thus, to get an approximate distance from  to any  only  distances  need to be stored in addition to distances in . The oracle stores distances from  to portals on each of the  separators above  in the recursive decomposition tree, giving a total space of . To answer a -query, the oracle identifies the nearest common ancestor separator  of  and  in the recursive decomposition. As  separates  and , distances from  and from  to their respective portal sets on  can be combined to obtain a -approximate distance estimate in  time.

Additional oracles for planar graphs have since been presented. Kawarabayashi, Klein, and Sommer~\cite{LinSpaceOraclesPlanar} showed how to improve space to  at the cost of an increase in query time to  and gave generalizations to bounded-genus and minor-free graphs. Kawarabayashi, Sommer, and Thorup~\cite{CompactOraclesPlanar} focused on improving the space-query time tradeoff and gave an oracle with  space and  query time, where  hides  and  factors, thereby essentially improving the query time-space product from  to . They also showed that if the average edge weight is poly-logarithmic,  space and  query time can be obtained.

Except for planar graphs with poly-logarithmic average edge weights, every oracle presented so far has a query time-space product of order  (ignoring the dependency on ). We finally break this barrier by giving an oracle with  space and  query time. The exact bounds are given in the following theorem.
\begin{theorem}\label{Thm:Main}
Let  be an -vertex undirected edge-weighted planar graph. For any , there is a -approximate distance oracle of  with query time  and space .
\end{theorem}
Our dependency on  in the query time-space product is worse than in~\cite{OraclePlanarKlein, OraclePlanarThorup} but still only a low-degree polynomial in ; it is roughly  when  and roughly  otherwise, compared to  in~\cite{OraclePlanarKlein, OraclePlanarThorup}. Focus in this paper is on improving the dependency on  and not  which we regard as fixed. Our data structure uses randomization due to hashing and fast integer sorting. Space and query time for hashing can be made worst-case with expected construction time. For sorting, we use the algorithm of Han and Thorup~\cite{IntegerSorting} to get the bound in Theorem~\ref{Thm:Main}. To make our data structure deterministic, we can use a standard optimal comparison sort or the slightly faster deterministic integer sorting algorithm of Fredman and Willard~\cite{DetIntSorting}. With the latter, we get a deterministic query time of our data structure of .

A main difference between our oracle and those of Thorup and of Klein is that we do not store distances from each vertex  to portals on all  separators above . Instead we save space by introducing a shortcutting system to the recursive decomposition tree so that we can get from  to any separator above it using  shortcuts. Each shortcut corresponds to a pair of separators on a root-to-leaf path in the tree and we essentially store approximate distances from vertices on one separator to portals on the other separator closer to the root of the recursive decomposition tree. This complicates the query algorithm and its analysis since approximate distances are found in  steps instead of just one.

\subsection{Related work}
Thorup~\cite{OraclePlanarThorup} also gave an oracle for planar \emph{digraphs} which for polynomially bounded edge weights achieves  space and close to  query time. Exact oracles for planar digraphs with tradeoff between space and query time have been studied but require near-quadratic space for constant or near-constant query time~\cite{ExactOraclePlanarMozesSommer,CWNPHD}.

For a general undirected -vertex graph , Thorup and Zwick showed that for any parameter , there is a -approximate distance oracle for  with  space and  query time which is believed to be essentially optimal due to a girth conjecture of Erd\H{o}s~\cite{Erdos}. Variations and slight improvements have since been presented; see, e.g.,~\cite{ChechikOracleGeneral,MendelNaor,PatrascuRoditty,CWNOracleGeneral1,CWNOracleGeneral2}.

\subsection{Organization of the paper}
In Section~\ref{sec:Prelim}, we give some basic definitions, notation, and a variant of a standard recursive decomposition of planar graphs with shortest path separators. We then present our oracle in Sections~\ref{sec:PhaseI} and~\ref{sec:PhaseII}. Section~\ref{sec:PhaseI} presents the first phase of the query algorithm. This phase computes approximate distances from query vertices  and  to certain portals on the nearest common ancestor separator  of  and  in the recursive decomposition tree but where approximate shortest paths are restricted to the child regions of  in the recursive decomposition. The second phase in Section~\ref{sec:PhaseII} uses the output of the first phase to then find approximate distances from  and  to portals on  in the entire graph . A main challenge is that the vertices of  are not represented explicitly on all recursion levels but on various levels on the path from  to the root of the recursive decomposition; the second phase traverses this path to find the desired approximate distances and portals. From the output of Phase II, obtaining an approximate -distance can then be done efficiently, as we show in Section~\ref{sec:ApproxDist}. Finally, we make some concluding remarks in Section~\ref{sec:ConclRem}.

\section{Preliminaries}\label{sec:Prelim}
For a graph , denote by  and  its vertex set and edge set, respectively. When convenient, an edge  with weight  is denoted . For a rooted tree  and two nodes , denote by  the nearest common ancestor of  and  in . For a path  and for two vertices ,  denotes the subpath of  between  and . As in previous papers on approximate distance oracles for planar graphs, we assume the Word-RAM model with standard instructions.

\subsection{Recursive Decomposition}\label{subsec:RecDecomp}
In the following,  denotes an -vertex, undirected, edge-weighted planar embedded graph and  is a shortest path tree in  rooted at a source vertex . By performing vertex-splitting, we may assume that  has degree three.

The oracle of Thorup keeps a recursive decomposition of  consisting of shortest path separators. Our oracle obtains a similar decomposition but we need it to have some additional properties which we focus on in the following.

Denote by  an arbitrary triangulation of  where edges of  are called \emph{pseudo-edges} and are given infinite weight. A shortest path separator of  w.r.t.~an assignment of weights to triangles of  consists of a (possibly non-simple) cycle  defined by two shortest paths  and  in  and a non-tree edge ; the total weight of triangles on each side of  is at most  of the total weight of all triangles of . See~\cite{LiptonTarjan,OraclePlanarThorup} for details.

First, we decompose  into two subgraphs enclosed by ; both subgraphs inherit the edges and vertices of , for a suitable weight function on triangles. Degree two vertices  are removed from each subgraph by replacing their incident edges  and  with a single edge  whose weight is the sum of weights of  and . Then the two subgraphs are recursively decomposed until constant-size subgraphs are obtained.

For each subgraph  obtained in the above recursive procedure, we form a \emph{region}  as follows. Subgraph  contains  separators of the form , namely those formed from the root of the recursion down to . These are separators formed from the root of the recursion down to . Region  is obtained from  by removing pseudo-edges, except those contained in the separators that formed , and then removing degree two vertices as above. Let  be the faces of  containing vertices/edges of  not belonging to . Each  is a separator  (possibly with some degree two vertices removed) and we call  a \emph{hole} (of ). Ancestor/descendant relations between regions are defined according to their nesting in the recursive decomposition tree which we denote by . In Section~\ref{subsec:ConstructRecDecomp}, we show how to pick shortest path separators such that
\begin{enumerate}
\item there are  regions in total each having  holes,
\item for each child  of each region , every hole of  (regarded as the closed set of the plane inside the hole) is fully-contained in a hole of ,
\item the height of  is .
\end{enumerate}
When we refer to a recursive decomposition in the following, we assume it has these properties. Observe that for all regions  and  where  is a descendant of , . This follows since  is obtained from  by eliminating subgraphs of  and degree two vertices.

\subsection{Constructing a recursive decomposition}\label{subsec:ConstructRecDecomp}
In the following, refer to the triangulated subgraphs obtained when recursively decomposing  as \emph{-regions}; holes of -regions are defined to be the holes of the corresponding regions with pseudo-edges added to form the triangulation. We now show how to pick the separators so that the following \emph{region conditions} are satisfied:
\begin{enumerate}
\item each -region of even resp.~odd depth in  has at most three resp.~four holes,
\item for each -region of even depth in , if it contains exactly  faces of , each of its grandchildren contain at most  faces of ,
\item for each child  of each -region , every hole of  (regarded as the closed set of the plane inside the hole) is fully-contained in a hole of .
\end{enumerate}
Furthermore, we show that the number of regions is  and that the height of  is . This gives the desired properties for a recursive decomposition, as stated above.

All separators are formed from shortest path tree . The recursion stops once -regions with at most two faces of  are obtained. For a -region  of even depth in , assume it has at most three holes (this trivially holds for  at the root of ). We assign a unit of weight to each face of  that is also a face of . All other faces of  are given weight . Using the subtree of  in , we find a balanced shortest path separator w.r.t.~this weight function. If  is the number of faces of  in  then each of the subgraphs formed contain at most  of these faces. Furthermore, each of these subgraphs have at most four holes since at most one new hole is formed when removing one side of the separator.

Now consider a -region  of odd depth in  and assume it has at most four holes. If  has at most two holes, we decompose it as described above for even-depth -regions; the sub--regions formed will have at most three holes. Otherwise, we define a different weight function than that above: for each hole  of , exactly one of the triangles of  contained in  is given unit weight. All other triangles of  are given weight . The shortest path separator w.r.t.~this weight function ensures that each of the two sub--regions of  formed will have at most three holes, namely at most  holes inherited from  and one hole formed by removing one side of the separator.

It is now clear that the first region condition holds. The second region condition holds as well from the above and from the fact that each child of an odd-depth -region  cannot contain more faces of  than .

Assume for the sake of contradiction that the third region condition does not hold for some -region  and one of its children. Then the separator that was used to decompose  must have used one of the pseudo-edges in the triangulated hole  of . Since the boundary of  consists of two shortest paths from  and a single pseudo-edge, one of the children of  must be fully contained in , which for both choices of weight function above gives an unbalanced separator, a contradiction. We conclude that the third region condition holds.

The number of -regions is asymptotically bounded by the number of leaves of the recursive decomposition tree. Each leaf -region has a parent with at least three faces of . For any two distinct -regions  and  that are parents of leaf -regions, no face of  belongs to both  and . It follows that there are only  parents of leaf -regions. Since the decomposition tree  is binary, the total number of leaf -regions is . This implies that the total number of -regions, and hence regions, is .

It follows from the second region condition and the termination condition for the recursion that  has height .

\subsection{Region boundary structure}
Let  be a path in  from  to some vertex. For any subpath  of , let  be those interior vertices of  having an incident edge of  emanating to the left of  when looking in the direction from  to . We order the vertices such that . The \emph{left side} of  is the -path with edges  where each edge has weight equal to the weight of the corresponding subpath of . We define the \emph{right side} of  similarly.

For a region , denote by  the \emph{boundary} of  which is the subgraph of  contained in the  holes of . For each hole , it will be convenient to regard the two shortest paths in  bounding  as disjoint in  by replacing one path with its left side and the other with its right side; vertices shared by the original two paths are regarded as distinct in the two new paths, see Figure~\ref{fig:EulerTour}. Note that  represented in this way is now a single face of .
\begin{figure}\centerline{\scalebox{0.7}{\begin{picture}(0,0)\includegraphics{EulerTour.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5355,2133)(1062,-6295)
\put(1765,-5047){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4096,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}Copy of }}}}}
\put(2296,-6226){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5041,-6226){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1531,-4651){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2342,-5727){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3021,-5191){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3323,-5011){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2387,-4628){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1311,-5424){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{(a): A region R with  bounding holes . Corners are shown as white vertices. (b): Representation of  obtained by ``cutting open'' each hole.}
\label{fig:EulerTour}
\end{figure}
Cutting open each hole like this ensures that paths in  do not cross its boundary.

A vertex (edge) of  that is not contained in  is called \emph{interior}. Denote by  the  shortest paths from the shortest path tree  that bound . A vertex which is an endpoint of a path in  is called a \emph{corner} of ; see Figure~\ref{fig:EulerTour}. We let  denote the set of  corners of . In some places, we will instead consider the face  obtained from  by replacing each edge with its corresponding path in . The following lemma gives the structure of .
\begin{lemma}\label{Lem:deltaR}
For any region ,  consists of  subpaths each of which is either a single (possibly pseudo-)edge between two corners, an edge corresponding to a path in  from  to some corner of , or the left or right side of a path in .
\end{lemma}
\begin{proof}
Consider partitioning  into subpaths each starting and ending in a corner and with no interior corner vertices. There are only  such subpaths and each of them is either an edge or pseudo-edge ending in corners or the subpath corresponds to a path in  incident to one or two holes. If it is incident to one hole, it is the left or right side of a path in  and if it is incident to two holes, it is a single edge corresponding to a path ending in .
\end{proof}

When convenient, we identify regions with their corresponding nodes in . For two regions  and , denote by  the simple path from  to  in .

\subsection{Portals}
Let  be an undirected edge-weighted (not necessarily planar) graph, let , and let  be a shortest path in . Thorup~\cite{OraclePlanarThorup} showed that for any given ,  contains a set  of  \emph{portals} such that for any , there is a  such that .

Let  be a region and let . Given a value , a vertex , and an undirected (possibly non-planar) graph  with  where every edge  in  corresponds to a path  in  of the same weight. Then  is a \emph{-portal set of } if for any , there exists a vertex  such that . We call  a \emph{portal} (of ). Applying the portal construction of Thorup~\cite{OraclePlanarThorup} (see also the proof of Lemma~\ref{Lem:Portal}) to each path in  gives a -portal set of  of size . Define -portal set of  similarly; its size is  as well.

We need a slightly more general result regarding portals than that of Thorup which we state in the following somewhat technical lemma. It roughly says that if we have a graph  representing some subgraph of  such that distances in  from a vertex  to a shortest path  in  are approximated well in , then we can pick a small number of portals from  along  such that these distances are also approximated well with shortest paths in  from  to  through these portals.
\begin{lemma}\label{Lem:Portal}
Let  be a shortest path in an edge-weighted undirected graph  and let  and  be given. Let  be an undirected graph with  such that for any , . Assume that for any , there is a  such that . Then there is a subset  of  of size  such that for any  there is a  such that .
\end{lemma}
\begin{proof}
The construction is similar to that of Thorup. The first portal  added to  is the vertex  minimizing . Let  be an endpoint of . We show how to construct ; the same construction is done for the other subpath of .

Let  be the latest portal added to  and traverse  towards  until encountering a vertex  such that . Portal  is then the next portal added to . The process stops when reaching the vertex of  closest to ; this vertex is added as the final portal  to .

Let  be given. By assumption, there is a  such that . The above construction ensures that there is a  such that


It remains to prove that . By symmetry, it suffices to show . For any , define potential . For ,

so the potential is reduced by

Since  and  (because ), we have , implying that .
\end{proof}

\section{The First Phase}\label{sec:PhaseI}
Our data structure answers a query for vertex pair  in two phases, \emph{Phase I} and \emph{Phase II}. In this section, we describe the preprocessing for Phase I and then the query part. The output and performance of Phase I applied to  is stated in the following lemma ( is symmetric). Phase I starts with  which is an arbitrary region  (among at most two choices) such that  and  where  is the parent of  in . Region  is defined similarly.
\begin{lemma}\label{Lem:PhaseI}
Phase I for vertex  can be implemented to run in  time using  space. For the output , we have that for all , there is a  such that  where  is the child of  on the path in  from  to . Furthermore, .
\end{lemma}
Note that any -path of  must intersect . Phase I computes approximate distances to this separator but with the restriction that paths must be contained in . Phase II is considered in Section~\ref{sec:PhaseII} and it extends the output of Phase I to approximate distances to  in the entire graph .

\subsection{Preprocessing}
We start by constructing a recursive decomposition of  and the associated decomposition tree . In order to traverse leaf-to-root paths of  efficiently, we set up a shortcutting system for . For any region , let  be the largest integer such that the depth of  in  is divisible by . For any integer  between  and , we add a pointer from  to the ancestor   levels above . We refer to this pointer as a \emph{shortcut} and denote it by . We can get from any region  to any proper ancestor  of  by traversing only  shortcuts: first traverse the shortcut  where  is the closest region to  which is either  or one of its descendants. Then recurse on pair  until reaching .



Before describing the preprocessing for Phase I, we need the following lemma. For any vertex , define  as the set of regions  where .
\begin{lemma}\label{Lem:RegionPath}
For all , regions of  form a subpath of a leaf-to-root path in .
\end{lemma}
\begin{proof}
Let  be a region in . Non-corner vertices of shortest paths in  have degree three in  (otherwise, their incident edges would have been merged into one in the construction of ) so  must be incident to an interior edge  of . This edge cannot be a pseudo-edge since  but must be an edge of . The same cannot be true for both child regions of  in  since  has degree three so at most one of these regions belongs to .
\end{proof}
We sometimes regard  as the subpath from the lemma.

For any shortcut , define  as the set of  vertices  such that  is the last vertex from  on a path of  satisfying ; see Figure~\ref{fig:PhaseIData}.

For each shortcut  and each , we construct and store a size  -portal set  of  together with distances  for each  (Figure~\ref{fig:PhaseIData});  will be specified precisely in Section~\ref{subsec:TimeStretch} below. This completes the description of the preprocessing.
\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{PhaseI.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3880,2129)(1304,-8587)
\put(3500,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4810,-7584){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1319,-8143){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3867,-7438){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3798,-7810){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1836,-6997){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2341,-8381){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3632,-8518){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2918,-6713){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3577,-7180){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Regions,  and  for shortcut . To simplify the figure, each region has only one hole and it is embedded on the infinite face. For every  (circle vertices), a -portal set  is stored during preprocessing. In the th iteration of the query algorithm,  contains edges from  to  and edges  (one shown in figure) with  for .}
\label{fig:PhaseIData}
\end{figure}
\begin{lemma}\label{Lem:TypeIPortalSet}
The total space required for Phase I is .
\end{lemma}
\begin{proof}
It suffices to give an  bound on the total size of portal sets defined above. Let  be given. By Lemma~\ref{Lem:RegionPath}, there can only be  shortcuts  where  and . Hence there are only  shortcuts  where . The total number of sets  and the total number of corners of  over all shortcuts  is  and . As each set  has size , total size of portal sets is .
\end{proof}

\subsection{Query}\label{subsec:Query}
In this subsection, we present Phase I for query vertices  and . Figure~\ref{fig:PhaseIData} is useful to consult in the following. We assume that starting regions  and  are not on the same leaf-to-root path in . As we will see later, the other case is easily handled. Pseudocode for vertex  can be found in Figure~\ref{fig:PhaseI}; the same call is made with  replaced by .
\begin{figure}[!ht]
\begin{tabbing}
\rule{\linewidth}{\arrayrulewidth}\\
d\=dd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\textbf{Phase I} for :\\\\
\>1. \>\>let  be the shortcuts from  to \\
\>2. \>\>let \\
\>3. \>\>for each , let \\
\>4. \>\>for  to \\
\>5. \>\>\>let \\
\>6. \>\>\>let \\
\>7. \>\>\>let  be face  restricted to vertices that are either in  or\\
\>   \>\>\>are incident to edges in \\
\>8. \>\>\>construct the graph  consisting of the edges \\
\>9. \>\>\>for each , let \\
\>10.\>\>\>if , construct -portal set  of  of size \\
\>11.\>\>construct -portal set  of  of size \\
\>12.\>\>output , where \\
\rule{\linewidth}{\arrayrulewidth}
\end{tabbing}
\caption{Pseudocode for Phase I applied to . Region  is defined as in Lemma~\ref{Lem:PhaseI}.}\label{fig:PhaseI}
\end{figure}

Let  be defined as in Lemma~\ref{Lem:PhaseI} ( is defined similarly for ). Let  denote the sequence of shortcuts from  to . To simplify the code, we assume ; the other case is straightforward. Note that .

In lines  and , we obtain the precomputed portal set  as well as distances  for each portal . Note that  is well-defined by definition of .

In the th iteration of the for-loop, we are given  constituting portals for  and we form a graph  containing  and a subset of  such that all distances from  to  in  can be approximated by going through  and then along . An illustration of  can be seen in Figure~\ref{fig:HiPhaseIData}.
\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{HiPhaseI.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3808,2073)(1411,-8544)
\put(3500,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4810,-7584){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3867,-7438){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1836,-6997){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1792,-8387){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3261,-6721){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4236,-7061){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4406,-8132){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Illustration of graph  from Figure~\ref{fig:PhaseI}. Edges of  are solid and boundaries  and  are dotted. Black circles are starting points of edges of , squares are their endpoints, and all other vertices of  are white circles.}
\label{fig:HiPhaseIData}
\end{figure}

Edges of  in line  are added to  and these represent the approximate distances to  in  found in the previous iteration. To have  approximate distances from  in , we add another edge set , defined in line ; for every vertex in , we add to  the edge  for every , representing a shortest -path in . To allow  to traverse , we add  in line . This is a compact representation of face  restricted to a subset of its vertices; each subpath of  between two consecutive vertices in this subset is a single edge of the same weight in .

We show below that distances in  from  to  approximate distances from  to  in . In order to avoid an explosion in the size of future portal sets, we form a -portal set  of  of size only  in line  which is then used in the next iteration.

Line  is identical to line  except that we use a value  instead of . We shall pick  which gives a much smaller portal set  output in line ; this will help speed up Phase II. We do not use  inside the for-loop in line  since the approximation error builds up over each iteration so we need the smaller value  there.

Lemma~\ref{Lem:PhaseI} follows from the following invariant for the for-loop in lines --:
\begin{description}
\item[Invariant:] At the start of the th iteration of the for-loop in lines -- of Figure~\ref{fig:PhaseI}, for all , there is a  such that , and .
\end{description}

Note that the invariant holds initially when  since  is a -portal set of  and its size is .

\paragraph{Maintenance of invariant:} Let  be given and assume the invariant holds at the beginning of the th iteration of the for-loop. We show that it also holds at the beginning of the th iteration. Let  be a shortest path in  from  to a vertex . We show that there is a  such that  approximates the weight of  up to a factor of . The second inequality of the invariant will then follow from Lemma~\ref{Lem:Portal}. The first inequality follows since  is the weight of an actual path in  from  to  for each .

Let  be the last vertex on  such that the subpath of  from  to  is contained in . In particular, . By the invariant at the beginning of the th iteration, there is a portal  such that .

Assume first that . Then  is contained in  and  approximates the distance from  to  up to a factor of  with the path starting with  and followed by edges of .

Now assume that . Consider first the case where
 (Figure~\ref{fig:PhaseIData} with  playing the role of ). We have the precomputed portal set  and it contains a portal  such that . Hence,


Now consider the other case where  and . Then a shortest path from  to  in  contains a vertex  and the subpath from  to  is contained in . We have a precomputed portal set  containing a portal  such that . This gives

as desired.

\paragraph{Termination:} The invariant shows that at the beginning of the th iteration, for all , there is a  such that . Line  is identical to line  for  except that  is replaced by  so line  increases the approximation by a factor of . Below we choose  and  such that . This will imply Lemma~\ref{Lem:PhaseI}.



\subsection{Bounding query time and stretch}\label{subsec:TimeStretch}
Obtaining shortcuts in line  can be done in  time. Lines  and  take  time as  and distances  for  are precomputed.

We first show how a single iteration  of the for-loop in lines -- can be implemented to run in  time. Then we show how to improve it to . Finding  takes  time. As ,  can be found in time . Face  is obtained in  time by sorting the vertices according to their cyclic ordering in an Euler tour of face . Graph  and distances  for  can then be obtained in  time. To obtain , apply the portal construction algorithm in the proof of Lemma~\ref{Lem:Portal} to each shortest path in  restricted to . This takes  time. Line  takes  time.

We improve the time bound to  by avoiding the sorting step above. Instead, we omit adding edges of  to  and apply a variant of the portal construction algorithm in the proof of Lemma~\ref{Lem:Portal} to each shortest path  restricted to . We describe this variant in the following.

First observe that  can be partitioned into  subsets  where each subset  is either a singleton set consisting of a vertex in , a singleton set consisting of an endpoint of an edge in , or a set  for each . Assume that each set  is sorted along  in non-decreasing distance from the source  in shortest path tree ; this sorting can be done in the preprocessing step.

The first portal  to be added to  is the vertex  minimizing . We can identify  in  time. Let  be the vertex of  farthest from . As in the proof of Lemma~\ref{Lem:Portal}, we only describe the algorithm for adding portals to ; adding portals along  is symmetric.

For each set , we keep a pointer to the first vertex in its sorted order. We then make a single pass over the sets  and for each of them move its pointer forward to the first vertex in  (if any) for which the distance to it cannot be approximated by going through the previously added portal , i.e., the first vertex  such that . Among the vertices with pointers to them, the one closest to  in  is then added to  as the next portal, and  is updated to this vertex. Additional passes are made until the pointers have moved past all vertices of their respective  sets.

Correctness follows since the set of portals formed is the same as that obtained by the portal-construction algorithm of Thorup. Running time is . To see this, note that each pass (except possibly the last) adds at least one portal to  so the number of passes is . Furthermore, each pass takes  time where  is the total number of vertices visited in that pass over all sets . Since the total number of vertices visited over all passes is , the time bound follows.

We can obtain a stretch of  for the approximate distances obtained in the final iteration of Phase I as follows. Since  when , we pick  to obtain  which is at most  when . Picking  gives
 for  smaller than some positive constant. This shows Lemma~\ref{Lem:PhaseI}.

\section{The Second Phase}\label{sec:PhaseII}
Phase II takes as input the sets  and  with associated approximate distances  and  that were output by Phase I. The output of Phase II has the properties stated in the following lemma. Denote by  the shortest path separator in  that separates  into  and . In Section~\ref{sec:ApproxDist}, we efficiently obtain from this output an approximate -distance.
\begin{lemma}\label{Lem:PhaseII}
Phase II for  can be implemented to run in  time using  space, given the output from Phase I. For the output  from Phase II, we have  and for any , there is a vertex  such that .
\end{lemma}

\subsection{Preprocessing}
The preprocessing for Phase II consists of the following four steps:

\paragraph{Step :} For each  and each of the at most two regions  with  and  where  is the parent of  in , we form a -portal set  of . From this we form and store a subset  of . This subset contains . In addition, for every  and every left or right side  (see Section~\ref{subsec:RecDecomp}) such that  and  are contained in the same path of ,  contains the successor and predecessor (if any) of  on ; Figure~\ref{fig:Pw} gives an illustration.
\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{Pw.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3773,2229)(1411,-8687)
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3096,-7136){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4369,-7614){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3366,-7767){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3914,-8618){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4687,-8604){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1445,-7972){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Step  of the preprocessing for Phase II. White vertices belong to  and black and white vertices belong to . Edges of  incident to  and edges of path  are solid. The predecessor and successor on  of a vertex of  belong to .}
\label{fig:Pw}
\end{figure}
Note that  so . For any  there is a  with . Since  the shortest path in  from  to  intersects . Hence there is a  which is either , the successor or predecessor of  on , or a corner in  such that . We also have .



\paragraph{Step :} For each shortcut  and each , store a -portal set  of  of size ; Call this a \emph{type 1} portal set.

\paragraph{Step :} For any shortcut , \emph{dual portal set}  is the set of vertices  for which a vertex  exists with , , such that ; see Figure~\ref{fig:PhaseIIData}.
Define . Note that . For each , store a -portal set  of  of size  together with distances  for each . Refer to it as a \emph{type 2} portal set.

The definition of type 2 portal sets is rather technical so let us give the high-level idea for introducing them; see Figure~\ref{fig:PhaseIIData} in the following. As in Phase I, we jump along shortcuts  in Phase II; a detailed description is given in the next subsection. In Phase II, we need approximate distances in  from certain portals  in  to . However,  might also be present in . In this case, we cannot afford to associate portal sets with  and shortcut  since  may occur in several regions of  (see Lemma~\ref{Lem:RegionPath}). However, vertices  for which  is sandwiched in between  and  can pay for dual portal set  and the associated type 2 portal sets. As we show below, we can obtain an approximate distance from  to any  by first going along  from  to a nearby , then along a shortest path in  from  to a portal  in the type 2 portal set of , and finally from  to  along .

Using hashing, we can access each type 1 and type 2 portal set in  time from the vertex and the shortcut defining it.

\paragraph{Step :} For each shortcut  and for any shortest path , we keep a vEB-tree, allowing us to find the successor/predecessor of any vertex of  in the subset  in  time. With hashing, space required for the vEB-tree is ~\cite{Predecessor,RangeQueries}. As mentioned in~\cite{Predecessor}, both space and query bounds can be made deterministic.
\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{PhaseII.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4325,2480)(1241,-8747)
\put(3500,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4658,-7589){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3218,-8527){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3233,-7172){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4004,-7590){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1448,-8258){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5188,-7590){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1256,-6968){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Region  sandwiched in between  and  for shortcut . Curves from  end in . If a vertex is in  (square vertices) and in  then it is in .}
\label{fig:PhaseIIData}
\end{figure}
\begin{lemma}\label{Lem:TypeIIAndIIIPortalSet}
The total space required for Phase II is .
\end{lemma}
\begin{proof}
The total size of portal sets  over all  is . A proof similar to that of Lemma~\ref{Lem:TypeIPortalSet} shows that the total size of all type  portal sets is .

To bound the size of type 2 portal sets, consider two shortcuts  and . By Lemma~\ref{Lem:RegionPath},  and  are disjoint if  and  are not contained in the same leaf-to-root path  in . For any , there are only  shortcuts  where . Hence  summed over all shortcuts  is . Hence, the total size of all dual portal sets , and hence also the total size of all vEB trees, is . Recall that the number of regions is . Each region has  corners and each set  has constant size so the total size of all sets  is . Each element of these sets has a type 2 portal set of size .
\end{proof}

\subsection{Query}
Let  be the path from  to the root  of . In the following, for any vertex , denote by  the region (if any) such that , , and  where  is the parent of  in . Observe that . Phase II for  takes the output from Phase I and produces output satisfying Lemma~\ref{Lem:PhaseII}.
\begin{figure}[!ht]
\begin{tabbing}
\rule{\linewidth}{\arrayrulewidth}\\
d\=dd\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\quad\=\kill
\>\textbf{Phase II} for :\\\\
\>1. \>\>let  be the shortcuts from  to \\
\>2. \>\>let  (portal set output from Phase I)\\
\>3. \>\>let  be the graph initially consisting of edges  for all \\
\>4. \>\>for  to \\
\>5. \>\>\>add to  edges  for all  and \\
\>6. \>\>\>for each  and each \\
\>7. \>\>\>\>add to  edge  for all \\
\>8. \>\>\>let \\
\>9. \>\>output \\
\rule{\linewidth}{\arrayrulewidth}
\end{tabbing}
\caption{Pseudocode for Phase II applied to . Here,  resp.~ denotes the final region resp.~portal set reached in Phase I and  is the shortest path separator in  that separates  into  and . In line ,  resp.~ refers to the successor resp.~predecessor of  in .}\label{fig:PhaseII}
\end{figure}
We give a high-level description of Phase II before going into details.  Pseudocode can be seen in Figure~\ref{fig:PhaseII}. The algorithm traverses shortcuts  from  to the root  of  and incrementally constructs a graph  which at termination will satisfy Lemma~\ref{Lem:PhaseII}. In line , edges of  represent approximate paths found in Phase I. These paths correspond to subpaths of the final full paths in  (corresponding to the final ) and the subpaths are prefixes of these full paths that are contained in . Consider the th iteration of the for-loop. In line , we check if any subpath endpoint  disappears as a boundary vertex when jumping from  to . If so, we can extend the subpath to full paths  for each . The other interesting case is when . Then we do not have a type  portal set associated with  and  but it might be that some separator vertices  of  that are present in  are no longer present in  and we need to ensure that there is a good path in  from  to . This case is handled in lines  and  where we ensure such a good path from  to  by using the type  portal sets associated with vertices of  that are close to .


To show correctness, i.e., that the set output in line  satisfies Lemma~\ref{Lem:PhaseII}, let  be any vertex on  and let  be a shortest path in  from  to . Let  be the last vertex on  such that  is contained in . Note that . By Lemma~\ref{Lem:PhaseI}, there is a  such that . Since , we have . Since , we also have . Let  and  be the shortcuts such that , , and , . We consider two cases in the following:  and .

\paragraph{Case ,  (Figure~\ref{fig:Case1}):}\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{Case1.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4401,2234)(1411,-8594)
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4689,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5301,-7595){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2479,-7894){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3774,-7289){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3403,-7361){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2261,-7824){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3475,-7663){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3640,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Case  in the correctness proof for Phase II; here  and . The first and last part of a shortest -path in  through  is shown. Curves from  end in vertices of .}
\label{fig:Case1}
\end{figure}
Consider iteration  of the for-loop. Since , we have . Since , it follows that . Hence, the final  contains an edge  for each portal  (line ). Since  and since , we must have  so there is a portal  satisfying . Note that . The path in the final graph  consisting of edges  and  followed by the path in  from  to  has weight at most

\paragraph{Case ,  (Figure~\ref{fig:Case2}):}
\begin{figure}\centerline{\scalebox{0.85}{\begin{picture}(0,0)\includegraphics{Case2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4401,2240)(1411,-8600)
\put(1426,-7620){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4689,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5301,-7595){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3403,-7361){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3475,-7663){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3640,-7594){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3881,-7843){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2331,-7394){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2784,-7275){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4133,-7854){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{Case  in the correctness proof for Phase II; here  and . The first and last part of a shortest -path in  through  is shown. Dashed curves from  end in vertices of  one of which is . Solid curves from  end in .}
\label{fig:Case2}
\end{figure}
Consider iteration  of the for-loop. Since , there is a portal  such that  (see step  of the preprocessing). If  then . Otherwise, there is a vertex  such that the path in  from  to  contains . Hence,


It follows from the above that there is a vertex  such that . Thus, for one of the two choices of  in line , we have

For that choice of , let  be the portal in  such that . The path in  consisting of edges  (added in line ) and  (added in line ) followed by the path in  from  to  has weight at most


To show Lemma~\ref{Lem:PhaseII}, note that  is at most  for any  less than some positive constant. As for query time, lines  and  can be executed in  time. By Lemma~\ref{Lem:PhaseI}, adding edges to  in line  can be done in  time. The total time to find successors and predecessors over all iterations of the for-loop is . The additional time spent in the for-loop is bounded by the number of edges added to . The total number of edges added in line  is . Note that every  considered in line  is not included in  in line . Hence, we add a total of  edges in line .

\section{Obtaining the approximate distance}\label{sec:ApproxDist}
In this section, we show how to obtain an approximate -distance within the time and space stated in Theorem~\ref{Thm:Main}, given the output of Phase II.

We execute Phase II for both  and , getting outputs  and , respectively. To find an approximate -distance, assume first that . Let  be one of the two shortest paths from  in  bounding  and sort the vertices of  along . To do the sorting efficiently, we make a DFS traversal of  during preprocessing and label each vertex with an integer time stamp denoting when it was first visited in the traversal. Now, sorting the vertices of  along  corresponds to integer sorting their precomputed labels. With the algorithm of Han and Thorup~\cite{IntegerSorting}, this takes  time. We then remove all  for which there is another  such that . This can be done in  time with two linear scans over , one in sorted order and the other in reverse sorted order; the first resp.~second scan removes  if there is a  before resp.~after  in the order considered such that the inequality holds. Let  be the resulting subset and form a similar subset  of .

Let  be the minimum of  over all pairs  where  has no interior vertices belonging to . This takes  time. Compute a similar value  for the other shortest path  of  bounding . The approximate distance output is .

We need to show . Pick  such that  and assume that ; the case where  is symmetric. By Lemma~\ref{Lem:PhaseII}, there are vertices  and  such that  and . Pick a pair  belonging to  such that they occur on this path in the order  and such that  has no interior vertices belonging to . Then

showing the desired. Above, we assumed that . If this is not the case, we modify  as follows. Partition  into maximal-size groups where in each group , all vertices  have the same nearest neighbor  in  belonging to . Replace vertices of  by  in  and instead of approximate distances  for , use instead  for the approximate distance for . A similar update is done to , ensuring that . It is easy to see that the above analysis still carries through.

We have shown Theorem~\ref{Thm:Main} in the case where  and  are not on the same leaf-to-root path in . If instead, say,  then  and Phase I and II for  gives a portal set of . Our algorithm above is modified to find the portal  nearest to  on  and outputs , giving the desired stretch. This shows Theorem~\ref{Thm:Main} in the remaining case where  and  are on the same leaf-to-root path.

\section{Concluding Remarks}\label{sec:ConclRem}
We gave a -approximate distance oracle for undirected -vertex planar graphs and fixed  with  space and  query time which improves the previous best query time-space product from  to .

We have not focused on preprocessing time. With a simple implementation, we should get near-quadratic preprocessing time and it is possible that the exact space-efficient oracle in~\cite{ExactOraclePlanarMozesSommer} can speed this up further to  as the number of precomputed distances required by our oracle is only . With techniques from, e.g.,~\cite{OraclePlanarKlein, OraclePlanarThorup}, we can likely get down to .

The dependency on  in the query time-space product is slightly worse; it is roughly  ( when ) compared to  in~\cite{OraclePlanarKlein, OraclePlanarThorup} and roughly  in~\cite{CompactOraclesPlanar} (where the latter has a slightly worse dependency on  than~\cite{OraclePlanarKlein, OraclePlanarThorup}). Using mainly Monge properties, we believe it should be possible to replace at least one  factor by . Getting  query time and  space for some constant  seems problematic with our techniques due to the  bottleneck from the use of vEB trees when answering queries.

Extension to planar digraphs seems promising due to similarities between our structure and that for digraphs in~\cite{OraclePlanarThorup}. Extension to minor-free graphs would also be interesting.

\begin{thebibliography}{99}
\bibitem{ChechikOracleGeneral}
  S.~Chechik.
  Approximate distance oracle with constant query time.
  STOC', pp.~--.
\bibitem{Erdos}
  P.~Erd\H{o}s.
  Extremal problems in graph theory.
  In Theory of Graphs and its Applications (Proc.~Sympos.~Smolenice, ),
  Czechoslovak Acad.~Sci., Prague, , pp.~--.
\bibitem{DetIntSorting}
  M.~L.~Fredman and D.~E.~Willard.
  Surpassing the information theoretic bound with fusion trees.
  Journal of Computer and System Sciences, ():--, . 
\bibitem{IntegerSorting}
  Y.~Han and M.~Thorup.
  Integer sorting in  expected time and linear space.
  Proc.~rd Annual Symposium on Foundations of Computer Science (FOCS), pp.~--, .
\bibitem{LinSpaceOraclesPlanar}
  K.~Kawarabayashi, P.~N.~Klein, and C.~Sommer.
  Linear-space approximate distance oracles for planar, bounded-genus, and minor-free graphs.
  In th International Colloquium on Automata, Languages and Programming (ICALP), pp.~--, .
\bibitem{CompactOraclesPlanar}
  K.~Kawarabayashi, C.~Sommer, and M.~Thorup.
  More Compact Oracles for Approximate Distances in Undirected Planar Graphs.
  In th ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{OraclePlanarKlein}
  P.~N.~Klein.
  Preprocessing an undirected planar network to enable fast approximate distance queries.
  In th ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{LiptonTarjan}
  R.~J.~Lipton and R.~E.~Tarjan.
  A separator theorem for planar graphs.
  SIAM Journal on Applied Mathematics, ():--, .
\bibitem{MendelNaor}
  M.~Mendel and A.~Naor.
  Ramsey partitions and proximity data structures.
  Journal of the European Mathematical Society, ():--, . Announced at FOCS'.
\bibitem{ExactOraclePlanarMozesSommer}
  S.~Mozes and C.~Sommer.
  Exact distance oracles for planar graphs.
  In rd ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{PatrascuRoditty}
  M.~P\u{a}tra\c{s}cu and L.~Roditty.
  Distance oracles beyond the Thorup-Zwick bound.
  In st IEEE Symposium on Foundations of Computer Science (FOCS), .
\bibitem{Predecessor}
  M.~P\u{a}tra\c{s}cu and M.~Thorup.
  Time-space trade-offs for predecessor search.
  Proc.~th Annual ACM Symposium on Theory of Computing (STOC), pp.~--, .
\bibitem{OraclePlanarThorup}
  M.~Thorup.
  Compact oracles for reachability and approximate distances in planar digraphs.
  Journal of the ACM, ():--, . Announced at FOCS .
\bibitem{ThorupZwick}
  M.~Thorup and U.~Zwick.
  Approximate distance oracles.
  Journal of the ACM, ():--, . Announced at STOC'.
\bibitem{RangeQueries}
  D.~E.~Willard.
  Log-logarithmic worst-case range queries are possible in space .
  Information Processing Letters, ():--, .
\bibitem{CWNPHD}
  C.~Wulff-Nilsen.
  Algorithms for Planar Graphs and Graphs in Metric Spaces.
  PhD thesis, University of Copenhagen, .
\bibitem{CWNOracleGeneral1}
  C.~Wulff-Nilsen.
  Approximate Distance Oracles with Improved Preprocessing Time.
  In rd ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\bibitem{CWNOracleGeneral2}
  C.~Wulff-Nilsen.
  Approximate Distance Oracles with Improved Query Time.
  In th ACM-SIAM Symposium on Discrete Algorithms (SODA), pp.~--, .
\end{thebibliography}

\end{document}
