\documentclass{LMCS}

\usepackage{amsmath,amssymb,amsthm}
\usepackage[T1]{fontenc}
\usepackage{lmodern}\usepackage{mathpartir}\usepackage{stmaryrd,hyperref}
\usepackage{helvet,cclicenses}

\theoremstyle{plain}
\newtheorem{theorem}[thm]{Theorem}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{principle}[thm]{Principle}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\newtheorem{exercise}[thm]{Exercise}
\newtheorem{notation}[thm]{Notation}
\newtheorem*{note*}{Note}
\newtheorem*{notes*}{Notes}
\newtheorem*{null*}{}
\newtheorem{remark}[thm]{Remark}

\newcommand{\act}{\mathbin{\mbox{\boldmath}}}
\newcommand{\aeq}{=_{\alpha}}
\newcommand{\ALT}{\mathrel{\kw{|}}}
\newcommand{\AND}{\kw{and}}
\newcommand{\ar}[1][\sigma]{#1}
\newcommand{\arity}{\mathit{arity}}
\newcommand{\Arity}{\mathit{Arity}}
\newcommand{\AS}{\mathbin{\kw{as}}}
\newcommand{\atm}[1][a]{#1}
\newcommand{\ATM}{\kw{atm}}
\newcommand{\Atom}{\mathbb{A}}
\newcommand{\atoms}{\mathit{atom}}
\newcommand{\bij}{\cong}
\newcommand{\bimp}{\Leftrightarrow}
\newcommand{\BIND}{\kw{bind}}
\newcommand{\BINDTY}{\kw{bnd}}
\newcommand{\BINDVAL}[2]{\mathopen{\text{\normalfont\guillemotleft}}#1
  \mathclose{\text{\normalfont\guillemotright}}#2}
\newcommand{\BOOL}{\kw{bool}}
\newcommand{\CASE}{\kw{case}}
\newcommand{\comp}{\circ}
\newcommand{\CON}[1][C]{\kw{#1}}
\newcommand{\Con}{\mathcal{C}}
\newcommand{\config}[3]{\langle#1, #2, #3\rangle}
\renewcommand{\conj}{\wedge}
\newcommand{\CR}[1]{\mathrel{\widehat{#1}}}
\newcommand{\defeq}{\triangleq}
\newcommand{\den}[1]{\llbracket#1\rrbracket}\newcommand{\DIVERGE}{\kw{diverge}}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\dty}{\delta}
\newcommand{\Dty}{\mathcal{D}}
\newcommand{\ELSE}{\mathrel{\kw{else}}}
\newcommand{\ent}{\vdash}
\newcommand{\enty}{\vdash}
\newcommand{\EQ}{\mathbin{\kw{=}}}
\newcommand{\er}{\mathrel{\mathcal{E}}}
\newcommand{\es}{\mathit{Id}}
\renewcommand{\exp}[1][e]{#1}
\newcommand{\Exp}{\mathit{Exp}}
\newcommand{\FALSE}{\kw{false}}
\newcommand{\fmap}{\stackrel{\mathrm{fin}}{\rightarrow}}
\newcommand{\FRESH}{\kw{fresh}}
\newcommand{\FST}{\kw{fst}}
\newcommand{\fun}{\rightarrow}
\newcommand{\FUN}{\kw{fun}}
\newcommand{\FUNTY}{\mathbin{\rightarrow}}
\newcommand{\fv}{\mathit{fv}}
\newcommand{\IF}{\mathop{\kw{if}}}
\newcommand{\imp}{\Rightarrow}
\newcommand{\IN}{\mathrel{\kw{in}}}
\newcommand{\INT}{\kw{int}}
\newcommand{\LET}{\mathop{\kw{let}}}
\newcommand{\LP}{\mathopen{\kw{(}}}
\newcommand{\kw}[1]{\mathsf{#1}}
\newcommand{\MATCH}{\kw{match}}
\newcommand{\NAT}{\kw{nat}}
\newcommand{\NNO}{\mathbb{N}}
\newcommand{\Obs}{\mathcal{O}}
\newcommand{\OBS}[1][obs]{\kw{#1}}
\newcommand{\OF}{\mathbin{\kw{of}}}
\newcommand{\ofty}{:}
\newcommand{\OFTY}{\mathrel{\kw{:}}}
\newcommand{\opeq}{\cong}
\newcommand{\opeqo}{\cong^{\circ}}
\newcommand{\ords}{\olessthan}\newcommand{\PAIR}[2]{\LP#1\mathbin{\kw{,}}#2\RP}
\newcommand{\Perm}{\mathbb{P}}
\newcommand{\PRODTY}{\mathbin{\kw{*}}}
\newcommand{\PROJ}{\kw{proj}}
\newcommand{\rename}[2]{\{#2/#1\}}
\newcommand{\rep}[1]{\ulcorner#1\urcorner}
\newcommand{\RP}{\mathclose{\kw{)}}}
\newcommand{\ruleref}[1]{(\RefTirName{#1})}\newcommand{\SND}{\kw{snd}}
\newcommand{\State}{\mathit{State}}
\newcommand{\s}[1][a]{\vec{#1}}
\newcommand{\stk}[1][S]{#1}
\newcommand{\Stk}{\mathit{Stk}}
\newcommand{\sub}[2]{{[#2/#1]}}
\newcommand{\supp}{\mathit{supp}}
\newcommand{\swap}[2]{(#1\;#2)}
\newcommand{\SWAP}{\kw{swap}}
\newcommand{\TERM}{\kw{term}}
\newcommand{\terminates}[1][]{{\downarrow_{#1}}}
\newcommand{\THEN}{\mathrel{\kw{then}}}
\newcommand{\TO}{\mathbin{\rightarrow}}
\newcommand{\trans}{\longrightarrow}
\newcommand{\TRUE}{\kw{true}}
\newcommand{\ty}{\tau}
\newcommand{\Ty}{\mathit{Typ}}
\newcommand{\TYPE}{\kw{type}}
\newcommand{\TYVAR}{\alpha}
\newcommand{\UNBIND}{\kw{unbind}}
\newcommand{\UNIT}{\kw{unit}}
\newcommand{\UNITVAL}{\LP\RP}
\newcommand{\val}[1][v]{#1}
\newcommand{\Val}{\mathit{Val}}
\newcommand{\VAL}{\kw{val}}
\newcommand{\vid}[1][x]{#1}
\newcommand{\Vid}{\mathbb{V}}
\newcommand{\w}[1][w]{#1}
\newcommand{\WITH}{\mathbin{\kw{with}}}
\newcommand{\World}{\mathit{World}}

\listfiles


\def\doi{4 (1:4) 2008}
\lmcsheading {\doi}
{1--33}
{}
{}
{Apr.~19, 2007}
{Mar.~18, 2008}
{}   

\begin{document}

\title[Generative Unbinding of Names]{Generative Unbinding of
Names\rsuper *}

\author[A.M.~ Pitts]{Andrew M.~Pitts\rsuper a}	\address{{\lsuper a}University of Cambridge Computer Laboratory\\
Cambridge CB3 0FD, UK}	\email{Andrew.Pitts@cl.cam.ac.uk}  \thanks{{\lsuper a}Research supported by UK~EPSRC grant EP/D000459/1.}	

\author[M.R.~Shinwell]{Mark R.~Shinwell\rsuper b}	\address{{\lsuper b}CodeSourcery, Ltd}	\email{mark@three-tuns.net}  



\keywords{Abstract syntax, binders, alpha-conversion, meta-programming} 

\subjclass{D.3.1, D.3.3, F.3.2}

\titlecomment{{\lsuper *}This paper is a revised and expanded version of
  \cite{PittsAM:genun}.}




\begin{abstract}
  \noindent This paper is concerned with the form of typed name
  binding used by the FreshML family of languages. Its characteristic
  feature is that a name binding is represented by an abstract
  (name,value)-pair that may only be deconstructed via the generation
  of fresh bound names.  The paper proves a new result about what
  operations on names can co-exist with this construct.  In FreshML
  the only observation one can make of names is to test whether or not
  they are equal.  This restricted amount of observation was thought
  necessary to ensure that there is no observable difference between
  alpha-equivalent name binders.  Yet from an algorithmic point of
  view it would be desirable to allow other operations and relations
  on names, such as a total ordering.  This paper shows that, contrary
  to expectations, one may add not just ordering, but almost any
  relation or numerical function on names without disturbing the
  fundamental correctness result about this form of typed name binding
  (that object-level alpha-equivalence precisely corresponds to
  contextual equivalence at the programming meta-level), so long as
  one takes the state of dynamically created names into account.
\end{abstract}

\maketitle

\section{Introduction}

FreshML and the language systems that it has inspired provide some
user-friendly facilities within the context of strongly typed
functional programming for computing with syntactical data structures
involving names and name binding.  The underlying theory was presented
in~\cite{PittsAM:metpbn,PittsAM:frepbm} and has been realised in the
Fresh patch of Objective Caml~\cite{ShinwellMR:freona}. FreshML has
also inspired Pottier's Cml tool~\cite{PottierF:ovec} for
Objective Caml and Cheney's FreshLib library~\cite{CheneyJ:scryn} for
Haskell. The approach taken to binding in all these works is
``nominal'' in that the user is given access to the names of bound
entities and can write syntax manipulating programs that follow the
informal practice of referring to -equivalence classes of
terms via representatives.  However, in FreshML the means of access to
bound names is carefully controlled by the type system.  It has been
shown~\cite{ShinwellMR:freafp,PittsAM:monsf} that its static and
dynamic properties combine to guarantee a certain ``correctness of
representation'' property: data structures representing
-equivalent syntactical terms (that is, ones differing only in
the names of bound entities) always behave the same in any program. So
even though programs can name names, as it were, -equivalence
of name bindings is taken care of automatically by the programming
language design.

\begin{figure}
  \centering
  
  \caption{A signature for name binding.}
  \label{fig:signb}
\end{figure}

Of course such a correctness of representation property depends rather
delicately upon which operations on bound names are allowed. At the
heart of this approach to binding is an operation that we call
\emph{generative unbinding}.  To explain what it involves, consider a
simplified version of Fresh Objective Caml with a single type 
of bindable names and a parametric family of types 
classifying abstractions of single names over values of type .
To explain: both  and  are abstract types that
come with the signature of operations shown in Figure~\ref{fig:signb}.
The closed values of type  are drawn from a countably infinite
set  of symbols that we call \emph{atoms}. Programs only get
access to atoms by evaluating the expression  to get a
fresh one; and hence program execution depends upon a state recording
the atoms that have been created so far. Given a type , closed
values of type  are called \emph{atom bindings} and are
given by pairs  consisting of an atom
 and a closed value .  Atom bindings are
constructed by evaluating . Fresh Objective
Caml provides a very convenient form of generative pattern-matching
for deconstructing atom bindings. To keep things simple, here we will
avoid the use of pattern-matching and consider an equivalent mechanism
for deconstructing atom binding via an  function carrying out
generative unbinding:  evaluates by
first evaluating  to obtain a fresh atom  and
then returning the pair ,
where in general  denotes the value obtained
from  by renaming all occurrences of  to be . The
instance of renaming that arises when evaluating
 is special: the fresh atom 
does not occur in  and so  is
equivalent to the result of applying to  the semantically better
behaved operation of \emph{swapping}  and . Although
implementing such an atom swapping operation on all types of values is
the main extension that the Fresh patch makes to Objective Caml, we
have not included a 
operation in the signature of Figure~\ref{fig:signb}. This is because
it is possible for users to define atom swapping themselves for
specific types on a case-by-case basis.  Although this approach has
some limitations, is enough for our purposes here.  (The approach is
more useful in the presence of Haskell-style type
classes---see~\cite{CheneyJ:scryn}.)

The type  is used in data type declarations in the
argument type of value constructors representing binders. To take a
familiar example, the terms of the untyped -calculus (all
terms, whether open or closed, with variables given by atoms
)

can be represented by closed values of the type 
given by the declaration

The value  representing a -term  is
defined by

and satisfies:
\begin{quote}
  \textbf{Correctness of Representation}: \emph{two -terms
    are -equivalent, , iff  and
     are contextually equivalent closed values of type
    , i.e.~can be used interchangeably in any well-typed Fresh
    Objective Caml program without affecting the observable results of
    program execution.}
\end{quote}
Since it is also the case that every closed value of type  is
of the form  for some -term , it follows that
there is a bijection between -equivalence classes of
-terms and contextual equivalence classes of closed values of
type .  The Correctness of Representation property is not easy
to prove because of the nature of contextual equivalence, with its
quantification over all possible program contexts. It was established
in~\cite{ShinwellMR:freafp,PittsAM:monsf} using denotational methods
that take permutations of atoms into account. The same methods can be
used to generalise from the example of -terms to terms over
any \emph{nominal signature} in the sense of~\cite{PittsAM:nomu-jv}.

\subsection*{Contribution of this paper.}

For the signature in Figure~\ref{fig:signb}, the only operation on
atoms apart from  is a test for equality: 
evaluates to  if  and  are the same atom and to
 otherwise. Adding extra operations and relations for atoms
may well change which program phrases are contextually equivalent.  Is
it possible to have some relations or operations on atoms in addition
to equality without invalidating the above Correctness of
Representation property? For example it would be very useful to have a
linear order , so that
values of type  could be used as keys in efficient data
structures for finite maps and the like. We show that this  is
possible, and more.  This is a rather unexpected result, for the
following reason.

The proof of the Correctness of Representation property given
in~\cite{ShinwellMR:freafp,PittsAM:monsf} relies upon
\emph{equivariant} properties of the semantics, in other words ones
whose truth is invariant under permuting atoms.  Atom equality is
equivariant: since a permutation is in particular bijective, it
preserves and reflects the value of . At first it seems
that a linear order on atoms cannot be equivariant, since if
 is true, then applying the permutation
swapping  and  we get , which
is false. However, equivariance is a global property: when considering
invariance of the truth of a property under permutations, it is
crucial to take into account all the parameters upon which the
property depends. Here there is a hidden parameter: \emph{the current
  state of dynamically created atoms}. So we should permute the atoms
in this state as well as the arguments of the relation. We shall see
that it is perfectly possible to have a state-dependent equivariant
ordering for the type  without invalidating the Correctness of
Representation property.  Indeed we prove that \emph{one can add any
  -ary function from  to numbers \emph{(or to booleans, for
    that matter)} whose semantics is reasonable \emph{(we explain what
    is reasonable in Section~\ref{sec:observations-atoms})}, without
  invalidating the Correctness of Representation property for any
  nominal signature.}

We have to work quite hard to get this result, which generalises the
one announced in \cite{PittsAM:frepbm} (with a flawed proof sketch)
and finally proved in~\cite{PittsAM:monsf,ShinwellMR:freafp}; but
whereas those works uses denotational techniques, here we use an
arguably more direct approach based on the operational semantics of
the language. We obtain the correctness result
(Theorem~\ref{thm:corr}) as a corollary of more general result
(Propositions~\ref{prop:ext-bind-1} and \ref{prop:ext-bind-2}) showing
that, up to contextual equivalence, the type  behaves
like the atom-abstraction construct
of~\cite[Sect.~5]{PittsAM:newaas-jv}.  Along the way to these results
we prove a Mason-Talcott-style ``CIU''~\cite{MasonIA:equfle}
characterisation of contextual equivalence for our language
(Theorem~\ref{thm:ciu}).  This is proved using Howe's
method~\cite{HoweDJ:procbf} applied to a formulation of the
operational semantics with Felleisen-style evaluation
contexts~\cite{FelleisenM:revrst}, via an abstract machine with frame
stacks~\cite{PittsAM:opespe}. The proof technique underlying our work
is rule-based induction, but with the novel twist that we exploit
semantic properties of freshness of names that are based on the use of
name permutations and that were introduced in \cite{PittsAM:newaas-jv}
and developed
in~\cite{PittsAM:nomlfo-jv,UrbanC:fortbv,PittsAM:alpsri}.

\section{Generative Unbinding}
\label{sec:generative-unbinding}


We use a version of FreshML that provides the signature in
Figure~\ref{fig:signb} in the presence of higher order recursively
defined functions on user declared data structures. Its syntax is
given in Figure~\ref{fig:lans}.

\begin{figure}\small
  \centering
  \jot]
    \text{\emph{Values}} 
    &\val\in\Val &\!\!\!\!::=\\
    &\makebox[0pt][r]{variable} &\vid\\
    &\makebox[0pt][r]{unit} &\UNITVAL\\
    &\makebox[0pt][r]{pair} &\PAIR{\val}{\val}\\
    &\makebox[0pt][r]{recursive function} &\FUN(\vid[f]\,\vid\EQ \exp)\\
    &\makebox[0pt][r]{data construction} &\CON\,\val\\
    &\makebox[0pt][r]{atom} &\atm\\
    &\makebox[0pt][r]{atom binding} &\BINDVAL{\val}{\val}\\jot]
    \text{\emph{Frame stacks}} 
    &\stk\in\Stk &\!\!\!\!::=\\
    &\makebox[0pt][r]{empty} &\es\\
    &\makebox[0pt][r]{non-empty} &\stk\comp(\vid.\exp)\\
    \text{\emph{States}}
    &\s\in\State &\!\!\!\!\defeq \text{finite lists of distinct atoms}\\
    \makebox[0pt][l]{\text{\emph{Machine configurations}}}
    &&\config{\s}{\stk}{\exp}\\jot]
    \text{\emph{Initial basis}} &&\\
    &\makebox[0pt][r]{natural numbers} &\NAT \in\Dty\\
    &\makebox[0pt][r]{zero} &(\CON[Zero]\OFTY\UNIT\FUNTY\NAT) \in\Con\\
    &\makebox[0pt][r]{successor} &(\CON[Succ]\OFTY\NAT\FUNTY\NAT) \in\Con\\
    &\makebox[0pt][r]{atom equality} & \OBS[eq] \in\Obs\quad (\arity=2)
  \end{array}
  
  \label{eq:72}
  \exp\sub{\vid,\ldots}{\val,\ldots}

    (\exp,\exp') &\defeq \LET\vid\EQ\exp\IN\LET\vid'\EQ\exp'\IN
    (\vid,\vid')
    &&(\vid\notin\fv(\exp'), \vid'\not=\vid)\\
    \lambda \vid.\,\exp &\defeq \FUN(\vid[f]\,\vid \EQ \exp)
    &&(\vid[f]\notin\fv(\exp),\vid[f]\not=\vid)\\
     k\,\exp &\defeq \LET\vid\EQ\exp\IN k\,\vid
    &&(k=\CON,\FST,\SND)\\
     \BINDVAL{\exp}{\exp'} &\defeq \LET\vid\EQ\exp\IN\LET\vid'\EQ\exp'\IN
    \BINDVAL{\vid}{\vid'}
    &&(\vid\notin\fv(\exp'), \vid'\not=\vid)\\
    \exp\,\exp' &\defeq \LET\vid\EQ\exp\IN\LET\vid'\EQ\exp'\IN
    \vid\,\vid'
    &&(\vid\notin\fv(\exp'), \vid'\not=\vid)\\
    \MATCH\ \exp \WITH (\cdots) &\defeq \LET\vid\EQ\exp\IN\MATCH\
    \vid\WITH(\cdots)
    &&(\vid\notin\fv(\cdots))\\
    \IF \exp \THEN\exp' \ELSE \exp''
    &\defeq 
    \begin{array}[t]{@{}l}
      \MATCH\ \exp \WITH {}\\
      \quad (\CON[Zero]()\TO\exp' \ALT \CON[Succ]\,\vid\TO\exp'')
    \end{array}
    &&(\vid\notin\fv(\exp'')\\
    \FRESH\ \vid\IN \exp &\defeq \LET\vid\EQ\FRESH()\IN\exp\\
    \LET {\BINDVAL{\vid_1}{\vid_2}\EQ\exp} \IN \exp' &\defeq
    \begin{array}[t]{@{}l}
      \LET\vid\EQ\exp\IN\\
      \LET\vid'\EQ\UNBIND\,\vid\IN\\
      \LET\vid_1\EQ\FST\,\vid'\IN\\
      \LET\vid_2\EQ\SND\,\vid'\IN \exp'
    \end{array}
    &&
    (\begin{array}[t]{@{}l}
      \vid,\vid'\notin\fv(\exp')\\
      \vid'\not=\vid, \vid_1\not=\vid_2)
    \end{array}\\
     \OBS\,\exp_1\cdots\exp_n &\defeq
    \begin{array}[t]{@{}l}
      \LET\vid_1\EQ\exp_1\IN\\
      \cdots\\
      \LET\vid_n\EQ\exp_n\IN\OBS\,\vid_1\cdots\vid_n
    \end{array}
    &&
    (\begin{array}[t]{@{}l}
      \vid_1,\ldots,\vid_n\notin\fv(\exp_1,\ldots,\exp_n)\\
      \vid_1,\ldots,\vid_n\ \text{distinct}).
    \end{array}
  
  \LET {\BINDVAL{\vid_1}{\vid_2}\EQ [-]\,\atm} \IN
  \OBS[eq]\,\vid_1\,\vid_2
  
  \label{eq:dec}
  \begin{array}{lr@{\;}c@{\;}l}
    \TYPE & \dty_1 & \EQ & 
    \CON_{1,1}\OF\ty_{1,1} \ALT \cdots \ALT \CON_{1,n_1}\OF\ty_{1,n_1}\\
    & & \vdots & \\
    \AND & \dty_m & \EQ & 
    \CON_{m,1}\OF\ty_{m,1} \ALT \cdots \ALT \CON_{m,n_m}\OF\ty_{m,n_m}\;.
  \end{array}

    \label{eq:82}
    \mathit{swap}_{\ATM} \defeq \lambda \vid.\lambda \vid[y].
    \lambda \vid[z].\, \IF {\OBS[eq]\,\vid[z]\,\vid} \THEN \vid[y]
    \ELSE {\IF {\OBS[eq]\,\vid[z]\,\vid[y]} \THEN \vid
    \ELSE \vid[z]}.
  
    \label{eq:84}
    \mathit{swap}_{\UNIT} &\defeq \lambda \vid.\lambda \vid[y].
    \lambda \vid[z].\, \vid[z]\\
    \label{eq:85}
    \mathit{swap}_{\ty_1\PRODTY\ty_2} &\defeq \lambda \vid.\lambda
    \vid[y].\lambda
    \vid[z].\,(\mathit{swap}_{\ty_1}\vid\,\vid[y]\,(\FST\,\vid[z]),
    \mathit{swap}_{\ty_2}\vid\,\vid[y]\,(\SND\,\vid[z]))\\
    \label{eq:71}
    \mathit{swap}_{\ty_1\FUNTY\ty_2} &\defeq \lambda \vid.\lambda
    \vid[y].\lambda \vid[z].\lambda \vid_1.\,
    \mathit{swap}_{\ty_2}\vid\,\vid[y]\,(\vid[z]\,
    (\mathit{swap}_{\ty_1}\vid\,\vid[y]\,\vid_1))\\
    \label{eq:73}
    \mathit{swap}_{\ty\,\BINDTY} &\defeq \lambda \vid.\lambda
    \vid[y].\lambda \vid[z].\,\LET
    {\vid[z]\EQ\BINDVAL{\vid[z]_1}{\vid[z]_2}} \IN
    \BINDVAL{\mathit{swap}_{\ATM}\vid\,\vid[y]\,\vid[z]_1}
    {(\mathit{swap}_{\ty}\vid\,\vid[y]\,\vid[z]_2)}.
  
    \label{eq:74}
    \mathit{swap}_{\NAT} &\defeq \lambda \vid.\lambda \vid[y].
    \FUN(\vid[f]\,\vid[z] \EQ {\MATCH\ \vid[z]\ \WITH (\CON[Zero]()
      \TO \CON[Zero]() \ALT \CON[Succ]\,\vid[z]_1 \TO
      \CON[Succ](\vid[f]\,\vid[z]_1))})\\
    \label{eq:75}
    \mathit{swap}_{\TERM} &\defeq \lambda \vid.\lambda \vid[y].
    \FUN(\vid[f]\,\vid[z] \EQ \MATCH\ \vid[z]\ \WITH 
    \begin{array}[t]{@{}l@{}l}
      ( & \CON[V]\,\vid[z]_1 \TO 
      \CON[V](\mathit{swap}_{\ATM}\vid\,\vid[y]\,\vid[z]_1)\\
      \ALT & \CON[L]\,\vid[z]_1 \TO 
      \begin{array}[t]{@{}l}
        \LET {\BINDVAL{\vid[z]_2}{\vid[z]_3}\EQ \vid[z]_1} \IN \\
        \quad \CON[L](\BINDVAL{\mathit{swap}_{\ATM}\vid\,\vid[y]\,\vid[z]_2}
        {(f\,\vid[z]_3)})
      \end{array}\\
      \ALT & \CON[A]\,\vid[z]_1 \TO 
      \CON[A](f(\FST\,\vid[z]_1), f(\SND\,\vid[z]_1))\,)).       
      \end{array}
  
  \label{eq:64}
  \atoms(\stk,\exp)\subseteq\atoms(\s).

  \label{eq:1}
  \den{\OBS}_{\s}(\atm_1,\ldots,\atm_k) = 
  \den{\OBS}_{\pi\act\s}(\pi(\atm_1),\ldots,\pi(\atm_k))\;.

    {\config{\s}{\stk}{\exp}\trans
      \config{\s'}{\stk'}{\exp'}} \;\imp\;
    {\config{\pi\act\s}{\pi\act\stk}{\pi\act\exp}\trans
      \config{\pi\act\s'}{\pi\act\stk'}{\pi\act\exp'}}\;.
  
    \intertext{\emph{Equality},  ():}
    \den{\OBS[eq]}_{\s}(\atm,\atm') &\;\defeq\;
    \begin{cases}
    0 &\text{if ,}\\
    1 &\text{otherwise.}
  \end{cases}\\
  \intertext{\emph{Linear order},  ():}
  \den{\OBS[lt]}_{\s}(\atm,\atm') &\;\defeq\;
  \begin{cases}
    0 &\text{if  occurs to the left of  in the list ,}\\
    1 &\text{otherwise.}
  \end{cases}\\
  \intertext{\emph{Ordinal},  ():}
  \den{\OBS[ord]}_{\s}(\atm) &\;\defeq\;
  \text{, if  is the th element of the list .}\\
  \intertext{\emph{State size},  ():}
  \den{\OBS[card]}_{\s}() &\;\defeq\; \text{length of the list .}
  
    \label{eq:70}
    \emptyset\ent_{\w} \exp\opeqo\exp'\ofty\ty \;\bimp\;
  {}\ent_{\w}\exp\opeq\exp'\ofty\ty\;.
  
    \label{eq:2}
    \config{\s}{\stk}{\exp}\terminates \;\bimp\; 
    \config{\s}{\es}{\stk{[\exp]}}\terminates
  
    \label{eq:3}
    \begin{array}[c]{rcl}
      \es[\exp] &\defeq& \exp\\
      \stk\comp(\vid.\exp')[\exp] &\defeq& \stk{[\LET {\vid\EQ\exp} \IN
        \exp']}\;.
    \end{array}
  
    \label{eq:7}
    \Gamma\ent_{\w}\exp\opeqo\exp'\ofty\ty
    \;\conj\;
    \w\subseteq\w'
    \;\imp\;
    \Gamma\ent_{\w'}\exp\opeqo\exp'\ofty\ty\;.   
  
    \label{eq:6}
    \Gamma\ent_{\w'}\exp\opeqo\exp'\ofty\ty \;\conj\;
    \atoms(\exp,\exp')\subseteq\w\subseteq\w'
    \;\imp\; \Gamma\ent_{\w}\exp\opeqo\exp'\ofty\ty
  
  \label{eq:12}
    \begin{array}{lr@{\;}c@{\;}l}
  \TYPE & \dty_1 & \EQ & 
  \CON_{1,1}\OF\ty_{1,1} \ALT \cdots \ALT \CON_{1,n_1}\OF\ty_{1,n_1}\\
  & & \vdots & \\
  \AND & \dty_m & \EQ & 
  \CON_{m,1}\OF\ty_{m,1} \ALT \cdots \ALT \CON_{m,n_m}\OF\ty_{m,n_m}\;.
  \end{array}

    \label{eq:9}
    \ar\in\Arity 
    ::= \UNIT 
    \mid \ar\PRODTY\ar 
    \mid \dty 
    \mid \ATM 
    \mid \ar\,\BINDTY
  
    \label{eq:13}
    {}\ent_{\w} \val\aeq\val'\ofty \ar \;\bimp\; 
    {}\ent_{\w} \val \opeq\val'\ofty\ar\;.
  
    {}\ent_{\w} \val\aeq\val'\ofty \ar &\;\imp\; \forall
    \s.\;\w\subseteq\atoms(\s)\imp\exists\s'.\;
    \config{\s}{\es}{\mathit{aeq}_{\ar}\val\,\val'}\trans^*
    \config{\s'}{\es}{\CON[Zero]()}\\
    {}\ent_{\w} \val\not\aeq\val'\ofty \ar &\;\imp\; \forall
    \s.\;\w\subseteq\atoms(\s)\imp\exists\s'.\;
    \config{\s}{\es}{\mathit{aeq}_{\ar}\val\,\val'}\trans^*
    \config{\s'}{\es}{\CON[Succ](\CON[Zero]())}.
  
    {} &\ent_{\w} \DIVERGE \not\opeq \val \ofty \ty\\
    {} &\ent_{\w} \PROJ_{i,j}\,(\CON_{i,j}\,v) \opeq v \ofty \ty_{i,j}\\
    {} &\ent_{\w} \PROJ_{i,j}\,(\CON_{i,j'}\,v) \opeq \DIVERGE \ofty
    \ty_{i,j} \quad \text{if }
  
    \DIVERGE &\;\defeq\; \FUN(f\,x\EQ f\,x)\UNITVAL\\
    \PROJ_{i,j}\,\val &\;\defeq\; \MATCH\ \val \WITH (\CON_{i,1}\vid_1 \TO
    \exp[d]_{j,1} \ALT \cdots \ALT \CON_{i,n_i}\,\vid_{n_i} \TO
    \exp[d]_{j,n_i})\\
    \intertext{where}
    \exp[d]_{j,j'} &\;\defeq\;
    \begin{cases}
      \vid_j &\text{if ,}\\
      \DIVERGE &\text{if .}
    \end{cases}
  
    \label{eq:14}
    {}\ent_{\w\cup\{\atm''\}}\val\rename{\atm}{\atm''} \opeq
    \val'\rename{\atm'}{\atm''} \ofty \ty
  
    \label{eq:15}
    {}\ent_{\w}\BINDVAL{\atm}{\val} \opeq \BINDVAL{\atm'}{\val'}
    \ofty\ty\,\BINDTY\;. 
  
    \label{eq:16}
    \den{\OBS}_{\atm'\ords\s}(\atm_1,\ldots,\atm_k) 
    = \den{\OBS}_{\s}(\atm_1,\ldots,\atm_k)\;. 
  
    \label{eq:15-1}
    {}\ent_{\w}\BINDVAL{\atm}{\val} \opeq \BINDVAL{\atm'}{\val'}
    \ofty\ty\,\BINDTY
  
    \label{eq:14-1}
    {}\ent_{\w\cup\{\atm''\}}\val\rename{\atm}{\atm''} \opeq
    \val'\rename{\atm'}{\atm''} \ofty \ty\;.
    
    \label{eq:17}
    \config{\s}{\stk}{\val\rename{\atm}{\atm''}}\terminates \;\bimp\;
    \config{\s}{\stk}{\val'\rename{\atm'}{\atm''}}\terminates\;.
  
    \label{eq:18}
    \s = \s'\ords \atm''\ords \atm_0\ords\cdots\ords \atm_{n-1}
  
    \label{eq:20}
    \begin{array}{l@{}l}
      \stk' \;\defeq\; 
      \es\comp (\vid[z].\, &\LET {\BINDVAL{\vid}{\vid[y]_0}\EQ \vid[z]} \IN\\
      &\LET {\BINDVAL{\vid_0}{\vid[y]_1}\EQ\BINDVAL{\atm[b]_0}{\vid[y]_0}} \IN\\
      &\;\vdots\\
      &\LET {\BINDVAL{\vid_{n-1}}{\vid[y]_n}\EQ
        \BINDVAL{\atm[b]_{n-1}}{\vid[y]_{n-1}}} \IN{}\\
      &\stk\rename{\atm'',\atm_0\ldots,\atm_{n-1}}{\vid,\vid_0,\ldots,\vid_{n-1}}[\vid[y]_n])
    \end{array}
  
    \label{eq:69}
    \s[b]' \;\defeq\; \atm[b]_0\ords\cdots\ords\atm[b]_{n-1}\ords\s'\;.
  
  \config{\s[b]'}{\stk'}{\pi\act(\BINDVAL{\atm}{\val})}\terminates
    \;\bimp\;\\
    \config{\s[b]'\ords\atm''\ords\atm_0\ords\cdots\ords\atm_{n-1}}{\stk}
    {(\pi\act(\val\rename{\atm}{\atm''}))
      \rename{\atm[b]_0,\ldots,\atm[b]_{n-1}}
      {\atm_0,\ldots,\atm_{n-1}}}\terminates\;.
  
          &(\pi\act(\val\rename{\atm}{\atm''}))
          \rename{\atm[b]_0,\ldots,\atm[b]_{n-1}}
          {\atm_0,\ldots,\atm_{n-1}}\\
    {}={} &((\val\rename{\atm}{\atm''})
    \rename{\atm_0,\ldots,\atm_{n-1}}
    {\atm[b]_0,\ldots,\atm[b]_{n-1}})
    \rename{\atm[b]_0,\ldots,\atm[b]_{n-1}}
    {\atm_0,\ldots,\atm_{n-1}}\\
    {}={} &\val\rename{\atm}{\atm''}\;;
  
    \label{eq:23}
    \config{\s[b]'}{\stk'}{\pi\act\BINDVAL{\atm}{\val}}\terminates
    \;\bimp\;
    \config{\atm[b]_0\ords\cdots\ords\atm[b]_{n-1}\ords\s}{\stk}{\val\rename{\atm}{\atm''}}\terminates\;.  
  
    \label{eq:24}
    \config{\s[b]'}{\stk'}{\pi\act\BINDVAL{\atm'}{\val'}}\terminates
    \;\bimp\;
    \config{\atm[b]_0\ords\cdots\ords\atm[b]_{n-1}\ords\s}{\stk}{\val'\rename{\atm'}{\atm''}}\terminates\;.  
  
  \config{\s[b]'}{\stk'}{\pi\act\BINDVAL{\atm}{\val}}\terminates
  \;\bimp\;
  \config{\s[b]'}{\stk'}{\pi\act\BINDVAL{\atm'}{\val'}}\terminates\;.
  
    \label{eq:22}
    \config{\atm[b]_0\ords\cdots\ords\atm[b]_{n-1}\ords\s}{\stk}{\val\rename{\atm}{\atm''}}\terminates
    \;\bimp\;
    \config{\atm[b]_0\ords\cdots\ords\atm[b]_{n-1}\ords\s}{\stk}{\val'\rename{\atm'}{\atm''}}\terminates\;.
  
    \val &\;\defeq\; \FUN(\vid[f]\,\vid\EQ\vid[f]\,\vid)\\
    \val' &\;\defeq\; \FUN(\vid[f]\,\vid\EQ \MATCH\ {\OBS[ord]\,\atm}
    \WITH (\CON[Zero]\TO\UNITVAL \ALT
    \CON[Succ]\,\vid[y]\TO\val\UNITVAL))
  
    {} &\ent_{\{\atm\}} \BINDVAL{\atm}{\val} \opeq
    \BINDVAL{\atm}{\val'}
    \ofty (\UNIT\FUNTY\UNIT)\BINDTY\label{eq:19}\\
    \intertext{but that for any } {}
    &\ent_{\{\atm,\atm'\}} \val\rename{\atm}{\atm'}\not\opeq
    \val'\rename{\atm}{\atm'}\ofty \UNIT\FUNTY\UNIT\;.\label{eq:21}
  
  \label{eq:4}
  \inferrule{\Gamma\ent_{\w} \exp \CR{\opeq^*} \exp' \ofty\ty\\
    \Gamma\ent_{\w} \exp' \opeqo \exp'' \ofty \ty
  }{\Gamma\ent_{\w} \exp \opeq^* \exp''\ofty\ty
  }\;.

  \stk_{\atm} \;\defeq\; \es\comp(\vid.\,
  \begin{array}[t]{@{}l@{}}
    \LET {\vid[y]\EQ\OBS[eq]\,\vid\,\atm} \IN\\
    \MATCH\ \vid[y] \WITH 
    (\CON[Zero]\TO \UNITVAL\ALT \CON[Succ]\,\vid[z]\TO\DIVERGE))\;.
  \end{array}
  
     \config{\s}{\stk}{\UNBIND\,\val}\terminates
     &\;\bimp\; \config{\s}{\stk\comp(\vid.\,\UNBIND\,\vid)}{\val}\terminates
     &&\text{by definition of }\\
     &\;\bimp\; \config{\s}{\stk\comp(\vid.\,\UNBIND\,\vid)}{\val'}\terminates
     &&\text{since }\\
     &\;\bimp\; \config{\s}{\stk}{\UNBIND\,\val'}\terminates
     &&\text{by definition of }
   
    \label{eq:5}
    \emptyset\ent_{\w} \stk \CR{\opeq^*} \stk' \ofty \ty\FUNTY\ty'
    \;\conj\; \emptyset\ent_{\w}\exp\opeq^*\exp'\ofty\ty \;\conj\;
    \atoms(\s)=\w \;\conj\;
    \config{\s}{\stk}{\exp}\terminates[n]\\
    \;\imp\; \config{\s}{\stk'}{\exp'}\terminates\;.
  
    &\emptyset\ent_{\w} \stk\CR{\opeq^*}\stk'\ofty\ty\FUNTY\ty'\label{eq:26}\\
    &\emptyset\ent_{\w} \exp \opeq^* \exp'\ofty\ty\label{eq:27}\\
    &\atoms(\s) = \w\label{eq:25}\\
    &\config{\s}{\stk}{\exp}\trans\config{\s_1}{\stk_1}{\exp_1}\label{eq:28}\\
    &\config{\s_1}{\stk_1}{\exp_1}\terminates^n\label{eq:29} 
  
    \{\vid\ofty\ty\} &\ent_{\w} \exp_2\opeq^* \exp_2'\ofty\ty_2\label{eq:30}\\
    \emptyset &\ent_{\w}
    \stk_1\CR{\opeq^*}\stk_1'\ofty\ty_2\FUNTY\ty'\label{eq:31}
  
    \emptyset &\ent_{\w} \val \opeq^* \val'\ofty\ty\label{eq:32}\\
    {} &\ent_{\w} \val'\opeq \exp'\ofty\ty\label{eq:33}
  
    \label{eq:34}
    \emptyset\ent_{\w} \exp_2\sub{\vid}{\val} \opeq^* 
    \exp_2'\sub{\vid}{\val'}\ofty \ty_2\;.
  
    \emptyset &\ent_{\w} \exp_1 \opeq^*
    \exp_1'\ofty\ty_1\label{eq:35}\\
    \{\vid\ofty\ty_1\} &\ent_{\w} \exp_2 \opeq^*
    \exp_2'\ofty \ty\label{eq:36}\\
    {} &\ent_{\w} (\LET\ {\vid\EQ \exp_1'} \IN \exp_2')\opeq
    \exp'\ofty\ty\label{eq:37}\\
    \intertext{and then from \eqref{eq:26} and \eqref{eq:36} we get}
    \emptyset &\ent_{\w} \stk\comp(\vid.\,\exp_2) \CR{\opeq^*}
    \stk'\comp(\vid.\,\exp_2') \ofty \ty_1\FUNTY\ty'\;.\label{eq:38}
  
    \emptyset &\ent_{\w} \val_i\opeq^* 
    \val_i'\ofty\ty_i\quad\text{(for )} \label{eq:39}\\
    {} &\ent_{\w} \PAIR{\val_1'}{\val_2'}\opeq
    \exp'\ofty\ty_1\PRODTY\ty_2 \label{eq:40}
  
    \{\vid[f]\ofty\ty_1\FUNTY\ty, \vid\ofty\ty_1\} &\ent_{\w}
    \exp_2\opeq^* \exp_2'\ofty\ty \label{eq:41}\\
    \emptyset &\ent_{\w} \val_2\opeq^* \val_2'\ofty\ty_1 \label{eq:42}\\
    {} &\ent_{\w} \FUN(\vid[f]\,\vid\EQ \exp_2')\,\val_2' \opeq
    \exp'\ofty\ty_1\FUNTY\ty\;. \label{eq:43}
  
   \label{eq:44}
    {}\ent_{\w} \FRESH\UNITVAL\opeq \exp'\ofty\ATM\;.
  
    \emptyset &\ent_{\w} \val \opeq^* \val'\ofty\ty_1 \label{eq:45}\\
    {} &\ent_{\w} \UNBIND\,\BINDVAL{\atm}{\val'}\opeq 
    \exp' \ofty \ATM\PRODTY\ty_1\;. \label{eq:46}
  
    \label{eq:79}
    \emptyset\ent_{\w\cup\{\atm_1\}} 
    \PAIR{\atm_1}{\val\rename{\atm}{\atm_1}} \opeq^*
    \PAIR{\atm_1}{\val'\rename{\atm}{\atm_1}} \ofty\ATM\PRODTY\ty_1\;.
  
  \emptyset\ent_{\w\cup\{\atm_1\}} \stk\CR{\opeq^*}\stk'
  \ofty\ATM\PRODTY\ty_1\FUNTY\ty'\;.
  
    \label{eq:48}
    {}\ent_{\w} \OBS\,\atm_1\ldots\atm_k \opeq e'\ofty \NAT\;.
  
  \Gamma\ent_{\w}\exp\opeq^*\exp'\ofty\ty \;\imp\;
  \Gamma\ent_{\w}\exp' \mathrel{(\opeq^*)^{+}} \exp\ofty\ty\;.
  
  \label{eq:47}
  \emptyset\ent_{\w} \exp\opeq^*\exp' \ofty\ty \;\imp\; 
  {}\ent_{\w} \exp\opeq \exp'\ofty\ty\;.

  \label{eq:49}
  \emptyset\ent_{\w} \exp\opeq^* \exp' \ofty\ty \;\imp\; \forall
  \s,\stk,\ty'.\; \w\cup\atoms(\stk)\subseteq\atoms(\s) \;\conj\;
  \emptyset\enty\stk\ofty\ty\FUNTY\ty' \;\conj\;
  \config{\s}{\stk}{\exp}\terminates \\
  \;\imp\; \config{\s}{\stk}{\exp'}\terminates\;.

  \emptyset\ent_{\w} \exp\mathrel{{\opeq^*}^+} \exp' \ofty\ty \;\imp\;
  \forall \s,\stk,\ty'.\; \w\cup\atoms(\stk)\subseteq\atoms(\s) \;\conj\;
  \emptyset\enty\stk\ofty\ty\FUNTY\ty' \;\conj\;
  \config{\s}{\stk}{\exp}\terminates\\
  \;\imp\; \config{\s}{\stk}{\exp'}\terminates

  \label{eq:50}
  \{\}\ent_{\w} \exp\opeq^* \exp' \ofty\ty \;\imp\; \forall
  \s,\stk,\ty'.\; (\w\cup\atoms(\stk)\subseteq\atoms(\s) \;\conj\;
  \emptyset\enty\stk\ofty\ty\FUNTY\ty' \;\conj\;
  \config{\s}{\stk}{\exp'}\terminates\\
  \;\imp\; \config{\s}{\stk}{\exp}\terminates\;.

  \label{eq:8}
  \inferrule{\atm''\notin\w \subseteq\atoms(\atm,\val,\atm',\val')\\
    {}\ent_{\w\cup\{\atm''\}} \val\rename{\atm}{\atm''} \opeq 
    \val'\rename{\atm'}{\atm''} \ofty \ty
    }{\emptyset\ent_{\w} \BINDVAL{\atm}{\val} \er \BINDVAL{\atm'}{\val'} \ofty
    \ty\,\BINDTY}
  \qquad
  \inferrule{\Gamma\ent_{\w} \exp \CR{\er} \exp' \ofty \ty
  }{\Gamma\ent_{\w} \exp \er \exp' \ofty \ty}    

    \label{eq:51}
    \emptyset\ent_{\w} \stk \CR{\er} \stk' \ofty \ty\FUNTY\ty'
    \;\conj\; \emptyset\ent_{\w}\exp\er\exp'\ofty\ty \;\conj\;
    \atoms(\s)=\w \;\conj\;
    \config{\s}{\stk}{\exp}\terminates[n]
    \;\imp\; \config{\s}{\stk'}{\exp'}\terminates\;.
  
    &\emptyset\ent_{\w} \stk\CR{\er}\stk'\ofty\ty\FUNTY\ty'\label{eq:53}\\
    &\emptyset\ent_{\w} \exp \er \exp'\ofty\ty\label{eq:54}\\
    &\atoms(\s) = \w\label{eq:52}\\
    &\config{\s}{\stk}{\exp}\trans\config{\s_1}{\stk_1}{\exp_1}\label{eq:55}\\
    &\config{\s_1}{\stk_1}{\exp_1}\terminates^n\label{eq:56}
  
    \{\vid\ofty\ty\} &\ent_{\w} \exp_2\er
    \exp_2'\ofty\ty_2 \label{eq:57}\\
    \emptyset &\ent_{\w}
    \stk_1\CR{\er}\stk_1'\ofty\ty_2\FUNTY\ty'\label{eq:58}
  
    \label{eq:59}
    \emptyset\ent_{\w} \exp_2\sub{\vid}{\val} \er  
    \exp_2'\sub{\vid}{\val'}\ofty \ty_2\;.
  
    \{\} &\ent_{\w} \exp_1\er \exp_1'\ofty \ty_1\label{eq:60}\\
    \{x\ofty\ty_1\} &\ent_{\w} \exp_2 \er \exp_2'\ofty \ty\;.
    \label{eq:61}
  
   \label{eq:62}
    \begin{array}{rl}
      \text{either (a):} & \atm=\atm'\;\conj\;
      \emptyset\ent_{\w} \val\er \val'\ofty\ty_1\\
      \text{or (b):} & \exists \atm''\notin\w.\; 
      {}\ent_{\w\cup\{\atm''\}} \val\rename{\atm}{\atm''} \opeq 
      \val'\rename{\atm}{\atm''} \ofty\ty_1
    \end{array}
  
    \label{eq:63}
    {}\ent_{\w\cup\{\atm''\}} \PAIR{\atm''}{\val\rename{\atm}{\atm''}}
    \opeq
    \PAIR{\atm''}{\val'\rename{\atm}{\atm''}} \ofty\ATM\PRODTY\ty_1 
  
  \label{eq:67}
  {}\ent_{\w\cup\{\atm''\}}\val\rename{\atm}{\atm''} \opeq
  \val'\rename{\atm'}{\atm''} \ofty \ty

  \label{eq:65}
  \emptyset\ent_{\w} \BINDVAL{\atm}{\val} \er \BINDVAL{\atm'}{\val'}
  \ofty \ty\,\BINDTY\;. 

  \label{eq:66}
  \emptyset\ent_{\w'} \stk\CR{\er} \stk\ofty
\ty\FUNTY\ty'

  \label{eq:68}
  \emptyset\ent_{\w'} \BINDVAL{\atm}{\val} \er \BINDVAL{\atm'}{\val'}
  \ofty \ty\,\BINDTY

\config{\s}{\stk}{\BINDVAL{\atm}{\val}}\terminates
\;\imp\;
\config{\s}{\stk}{\BINDVAL{\atm'}{\val'}}\terminates\;.

\config{\s}{\stk}{\BINDVAL{\atm'}{\val'}}\terminates \;\imp\;
\config{\s}{\stk}{\BINDVAL{\atm}{\val}}\terminates\;.

Thus \eqref{eq:67} implies that  and
 are operationally equivalent, as required.
\qed

\end{document}
