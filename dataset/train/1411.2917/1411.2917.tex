\documentclass[11pt,final,microtype]{scrartcl}

\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{subcaption}
\usepackage{circuitikz}
\usepackage{tikz}

\usepackage[top=1in, bottom=1.2in, left=1in, right=1in]{geometry}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\ld}{\log_{2}}
\newcommand{\loq}{\log_{\varphi}}
\newcommand{\delay}{\mathrm{delay}}
\newcommand{\depth}{\mathrm{depth}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\sset}[1]{\left\{#1\right\}}
\newcommand{\vare}{\varepsilon}

\definecolor{darkRed}{rgb}{0.6,0,0}
\definecolor{lightRed}{rgb}{1,0.75,0.75}
\definecolor{darkGreen}{rgb}{0,0.5,0}
\definecolor{PineGreen}{rgb}{0.01,0.5,0.45}
\definecolor{darkBlue}{rgb}{0,0,0.75}
\definecolor{CornflowerBlue}{rgb}{0.15,0,0.7}
\definecolor{lightBlue}{rgb}{0.75,0.75,1}
\definecolor{grey}{rgb}{0.5,0.5,0.5}
\definecolor{black}{rgb}{0,0,0}
\definecolor{red}{rgb}{1,0,0}
\definecolor{green}{rgb}{0,1,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{yellow}{rgb}{1,1,0}
\definecolor{orange}{rgb}{1,0.6,0}
\definecolor{cyan}{rgb}{0,0.7,1}
\definecolor{purple}{rgb}{0.5,0,0.8}

\usetikzlibrary{shapes}
\usetikzlibrary{shapes.gates.logic.US,shapes.gates.logic.IEC,backgrounds}

\makeatletter \tikzset{circle split part fill/.style args={#1,#2}{alias=tmp@name, 
    postaction={insert path={ \pgfextra{\pgfpointdiff{\pgfpointanchor{\pgf@node@name}{center}}{\pgfpointanchor{\pgf@node@name}{east}}\pgfmathsetmacro\insiderad{\pgf@x} \fill[#1]
          (\pgf@node@name.base)
          ([xshift=-\pgflinewidth]\pgf@node@name.east) arc
          (0:180:\insiderad-\pgflinewidth)--cycle; \fill[#2]
          (\pgf@node@name.base)
          ([xshift=\pgflinewidth]\pgf@node@name.west) arc
          (180:360:\insiderad-\pgflinewidth)--cycle; }}}}}
\makeatother

\newcommand{\tikzfigs}[3]{
  \begin{figure}[!tb]\centering{\resizebox{#2\linewidth}{!}{\begin{tikzpicture}
          \input{#3}
        \end{tikzpicture}}\caption{#1}\label{fig:#3}}\end{figure}}
\newcommand{\tikzfig}[2]{
  \tikzfigs{#1}{1}{#2}
}

\newcommand{\tikzc}[3]{
  \centering{
    \resizebox{#2\linewidth}{!}{
      \begin{tikzpicture}
        \input{#3}
      \end{tikzpicture}
    }
    \caption{#1}
    \label{fig:#3}}
}
\title{Fast Prefix Adders\\ for Non-Uniform Input Arrival Times}
\author{Stephan Held and Sophie Theresa Spirkl \\
\normalsize {\tt \{held,spirkl\}@or.uni-bonn.de}\\
  Research Institute for Discrete Mathematics, University of Bonn}
\date{}
\begin{document}

\maketitle

\begin{abstract}
\noindent {\bf  Abstract}

  We consider the problem of constructing fast and small parallel
  prefix adders for non-uniform input arrival times. This problem
  arises whenever the adder is embedded into a more complex circuit,
  e.\ g.\ a multiplier.
  
  Most previous results are based on representing binary
  carry-propagate adders as so-called parallel prefix graphs, in which pairs of
  generate and propagate signals are combined using complex gates
  known as prefix gates. Adders constructed in this model usually
  minimize the delay in terms of these prefix gates. However, the delay
  in terms of logic gates can be worse by a factor of two.
  
  In contrast, we aim to minimize the delay of the underlying logic
  circuit directly.  We prove a lower bound on the delay of a carry
  bit computation achievable by any prefix carry bit circuit and
  develop an algorithm that computes a prefix carry bit circuit with
  optimum delay up to a small additive constant. Furthermore, we use
  this algorithm to construct a small parallel prefix adder.

  Compared to existing algorithms we simultaneously improve the delay
  and size guarantee, as well as the running time for constructing
  prefix carry bit and adder circuits.
\end{abstract}

\section{Introduction }

The addition of binary numbers is one of the most fundamental
computational tasks performed by computer chips.
Given two binary addends  and ,
where index  denotes the most significant bit, their sum 
has  bits. For each position , we compute a
\emph{generate signal}  and a \emph{propagate signal}
, which are defined as follows:

where  and  denote the binary \textsc{And} and
\textsc{Xor} functions.  The \emph{carry bit} at position  can be
computed recursively as  \cite{Kno01,WS58}.
From the carry bits, we can compute the output  via  for  and .

For two pairs  and  of generate and propagate
signals, we define a binary \emph{prefix operator} as


This operator is associative, and it can be used to compute the
carry bit  using the identity
 

The prefix operator allows us to simplify notation by combining
generate and propagate signals into a single term  and
computing  as the first component of .  Figure~\ref{fig:pfx-to-gate3} shows a prefix gate computing  for the prefix operator in (\ref{eqn:prefix-operator}) on
the left and its underlying logic circuit on the right.

\tikzfigs{Prefix gate and underlying logic circuit}{0.4}{pfx-to-gate3}

Formally, a \emph{logic circuit} is a non-empty connected acyclic
directed graph consisting of nodes that are either \emph{inputs} with
at least one outgoing edge and no incoming edges, \emph{outputs} with
exactly one incoming edge and no outgoing edges, or \emph{gates} with
one or two incoming edges representing one of the 2-bit logical
functions \textsc{And} (), \textsc{Or} (), \textsc{Xor}
(), \textsc{Not} and their negations.
The number of gates is the \emph{size} of the
circuit. The \emph{(maximum) fan-out of the circuit} is the maximum
fan-out (out-degree) of its nodes. The \emph{depth of the
  circuit} is the maximum number of gates on a directed path.

A logic circuit with inputs  is called 
a \emph{prefix carry bit circuit}  if it  computes   and , 
it is built from prefix operator gadgets in Figure~\ref{fig:pfx-to-gate3}, and the subcircuit computing  is a tree.
Similarly, a \emph{prefix adder}  is a logic circuit built using the gadgets in Figure~\ref{fig:pfx-to-gate3}
that computes    and  for all  at its  outputs.


A graph that arises from a prefix carry bit circuit by contracting
each gadget into a \emph{prefix gate} as in
Figure~\ref{fig:pfx-to-gate3}, and by contracting all input pairs
 into  and the output pair
, is called a \emph{prefix tree}.
Likewise, a \emph{parallel prefix graph} arises from a prefix adder by
contracting each gadget, all input pairs  and output
pairs  for all .
For inputs , a prefix tree computes the last
carry bit of an addition , while a
\emph{parallel prefix graph} computes  for
all , i.\ e.\ all carry bits of an addition.

When aiming for a bounded fan-out, we allow the use of repeater gates
with fan-in one (a single incoming edge) and fan-out at least two in
all types of circuits and graphs.

An example of the transition between parallel prefix graphs and prefix
adders is given in Figure~\ref{fig:transition}. On the left the serial
parallel prefix graph with depth 3 is replaced by an
\textsc{And-Or}-path with logic circuit depth 6 known as the
ripple-carry adder. For the Kogge-Stone parallel prefix graph
\cite{kogge-stone} on the right, the depth increases from two to four
and the maximum fan-out increases from two to three.
\begin{figure}[tbh]
  \centering
  \begin{subfigure}[b]{.19\linewidth}
    \tikzc{Serial prefix graph}{1}{serial-small}
  \end{subfigure}
  \begin{subfigure}[b]{.21\linewidth}
    \tikzc{\textsc{And-Or}-path}{1}{and-or-path}
  \end{subfigure}
  \quad\quad
  \begin{subfigure}[b]{.23\linewidth}
    \tikzc{Kogge-Stone prefix graph}{1}{kogge-small}
  \end{subfigure}
  \begin{subfigure}[b]{.29\linewidth}
    \tikzc{Kogge-Stone logic circuit}{1}{kogge-logic}
  \end{subfigure}
  \caption{Prefix graphs as logic circuits}
  \label{fig:transition} 
  \label{fig:kogge-transition} 
\end{figure}

Additions are typically not performed as isolated
tasks, but the input signals result from preceding computational
stages and become available at different fixed \emph{arrival times}
 ), e.\ g.\ when used within a
multiplier.  Here we make the simplifying assumption that  and
 have the same arrival time at the inputs, which is essentially
fulfilled if they are generated as in
(\ref{eqn:generate-and-propagat}).  We define the delay of a directed
path in a  logic circuit starting at an input as its depth plus its input
arrival time.  The delay of a vertex is the maximum delay of a path
ending in the vertex and the \emph{delay of the circuit} is the
maximum delay of its outputs. Depth and delay coincide if all input arrival times are zero.
Paths and outputs attaining the delay of
the circuit are called \emph{critical}.  The delay of all vertices can
be computed in linear time by a longest path computation in an acyclic
network. 

\begin{figure}[tbh]
  \centering
  \begin{subfigure}[b]{.28\linewidth}
    \tikzc{Arrival times 0, 0, 0, 0, 0; delay 4}{1}{example1}
  \end{subfigure}
  \begin{subfigure}[b]{.28\linewidth}
    \tikzc{Arrival times 4, 3, 2, 1, 0; delay 6}{1}{example2}
  \end{subfigure}
  \begin{subfigure}[b]{.28\linewidth}
    \tikzc{Arrival times 0, 1, 2, 3, 4; delay 7}{1}{example3}
  \end{subfigure}
  \caption{Different arrival times profiles and their optimum prefix trees}
  \label{fig:at-ex}
\end{figure}

In Figure~\ref{fig:at-ex}, we show an example with five inputs and its
optimum solutions for different arrival time patterns. Each tree is
optimal for neither of the other two arrival times sequences.

We aim for a prefix carry bit circuits and adders with close to minimum delay
and small size. 

A minimum-depth prefix graph for uniform input arrival times is given
by \cite{kogge-stone, ladner} and has depth  in
terms of prefix gates, but a non-minimal depth of  as a logic circuit. For non-uniform arrival times, these
circuits might be by a factor of three worse than the lower bound, for
example for the arrival time pattern  and . In Figure~\ref{fig:kogge-small}, if  has arrival time
two and all other arrival times are zero, the delay of
Figure~\ref{fig:kogge-logic} is . 


Parallel prefix graphs minimizing the overall prefix graph delay for
special input arrival time patterns that occur mostly in certain
multipliers were presented in \cite{zimmermann,okl}.

An algorithm for constructing optimum-delay parallel prefix graphs for
arbitrary non-uniform input arrival times is given in \cite{choi},
however this approach may require  gates for a full
-bit adder.  In \cite{roy} parallel prefix adders are enumerated
with heuristic pruning to achieve good performance-area tradeoffs in
practice.  All these approaches minimize the delay of the prefix graph
rather than the underlying logic circuit.  As the prefix operator
contains two subsequent gates, the resulting delay of the underlying
circuit may be worse by a factor of two.

As it is common practice in logic synthesis
\cite{kogge-stone,ladner,bonnlogic,roy}, we use a simple technology-independent circuit and delay model in this work.  In
hardware, the delay of a gate certainly depends on its physical
structure.
In CMOS technology, \textsc{Nand}/\textsc{Nor} gates are faster than
\textsc{And}/\textsc{Or} gates and efficient implementations exist for
integrated multi-input {\sc And-Or}-Inversion gates and {\sc Or-And}-Inversion
gates. 
We assume that circuits are re-mapped into logically equivalent circuits
based on technology specific delays in a {\it technology mapping} step
\cite{keutzer88,Chatterjee+techmap2006} after logic synthesis.
Despite its simplicity, the simple circuit and delay model is
successfully used in practice for re-optimizing carry bit functions
even late in the design flow \cite{bonnlogic}.



\subsection{Our contribution}
We will use the delay properties of the prefix operator
(\ref{eqn:prefix-operator}) aiming to minimize the delay of logic
circuits for additions instead of the corresponding prefix
graphs. This idea was used by \cite{bonn1}, who proposed a cubic-time
dynamic programming algorithm to compute a fast carry bit circuit.

With a deeper structural analysis of near-optimum prefix trees in
Section~\ref{sec:bl-core}, we can construct a carry bit circuit with a
better delay bound, size, and running time as shown in the
rows with type ``Carry'' of Table~\ref{tbl:bl-improve}.

In Section~\ref{sec:bl-adder}, we apply the carry bit algorithm to
substantially improve the delay bound given in \cite{bonn2} for a full
-bit adder with input arrival times . The result is listed in the rows with type ``Adder'' in
Table~\ref{tbl:bl-improve}.

\begin{table}[!b]
\small
  \begin{center}
  {\begin{tabular}{|c|c|c|c|c|c|}
        \hline
                     & \textbf{Type}  & \textbf{Delay} & \textbf{Size} & \textbf{Fan-out} & \textbf{Running Time} \\
        \hline
        \cite{bonn1}       & Carry  &  &  &   &   /  \\
\textbf{Here} & Carry &  &  &  &   /  \\
        \hline
        \cite{bonn2}       & Adder  &  &  &   &  / \\
        \textbf{Here} & Adder  & 
        &  &   &  /  \\
        \hline
      \end{tabular}
}
\end{center}
\caption{Improvements over \cite{bonn1,bonn2}, where  is a lower bound for the delay. Running times 
assume  constant/linear time for binary addition.}
\label{tbl:bl-improve}
\end{table} 


Finally, in Section~\ref{sec:lb}, we prove a lower bound on the delay
of any prefix carry bit circuit, which shows that our carry bit
algorithm is delay-optimal up to an additive constant of 5.


\section{Algorithm for Single Carry Bit Circuits} \label{sec:bl-core} 

We start with a method that given a parallel prefix graph allows us to
compute the delay of the underlying logic circuit up to an
additive error of one.

\begin{proposition} \label{lem:pfx-to-logic} Given a parallel prefix graph
  or prefix tree, we propagate the arrival times (which might all be
  zero) through the prefix gates so that the delay  of a gate with
  left input (higher indices)  and right input (lower indices) 
  with delay  and , respectively, is defined as  Let  be the maximum delay computed with
  this procedure, maximized over all gates, inputs and outputs, then
  the delay  of the logic circuit corresponding to the given prefix
  graph or prefix tree satisfies
  
\end{proposition}
\begin{proof}
  This is a  consequence of a longest path computation in acyclic networks.
  We construct a logic circuit from the prefix graph. For every input
  pair  corresponding to an input with arrival time , we
  set the arrival time of  and  to be  and ,
  respectively. We prove by induction that for every signal pair  corresponding to a signal  computed in the prefix graph, 
  has delay at least one more than , and if  is not an input,
  the delay of  is the maximum of two plus the delay of the
  generate signal of its right predecessor and one plus the delay of
  the generate signal of its left predecessor. This is clear for
  inputs. Now consider a signal  as in
  Figure~\ref{fig:pfx-to-gate3}. Let  and
   denote the delay of  and ,
  respectively. By induction hypothesis, 
  and . Therefore,  has delay . Furthermore, , which proves that 
  is indeed by at least one time unit earlier. 

  Inductive application of the argument above yields that the generate
  signal of every output arrives at time  under the assumption
  that all propagate signals of the inputs arrive one time unit
  earlier than their actual arrival time. Shifting all computed delays
  up by one time unit yields that the delay of the logic circuit for
  the actual arrival times is at most .

  To show that , consider only the generate signals, i.\ e.\
  using the notation of Figure~\ref{fig:pfx-to-gate3}, consider a
  logic circuit  in which all gates of type  and inputs 
  computing propagate signals are removed, and gates of type  are
  replaced by repeaters. It follows that for every output , the
  subcircuit of  which consists of all ancestors of  is a
  tree. This is certainly true in the parallel prefix graph, and after
  the removal of propagate signals, every prefix gate internally
  corresponds to a tree as well. Removing gates and inputs from a
  circuit does not increase its delay, because a critical path in 
  is also a path in the original circuit.

  Computing the delay of a signal in a tree is easy: when combining
  the generate signals of two inputs, one of them has to pass through
  two gates (a repeater instead of , and  and the other has to
  pass through only one (namely ). This shows that the given method
  for computing  indeed yields a lower bound.
\end{proof}
For uniform arrival times, , but for arbitrary arrival times,
 is possible, for example by choosing the arrival times of
 and  in Figure~\ref{fig:pfx-to-gate3} as 1 and 0, respectively. 

The prefix graph and its underlying logic circuit can
vary greatly in depth and delay. For example, a prefix graph of
optimal depth  as in Figure~\ref{fig:kogge-small}
contains a balanced binary tree computing its last output, therefore
its logic circuit depth is . However, the depth only
doubles for the lower (right) input of a prefix gate by
Lemma~\ref{lem:pfx-to-logic}, which we exploit in the following.

For a single carry bit computation with arrival times, Rautenbach et
al.\ \cite{bonn1} give a dynamic programming algorithm with cubic
running time.  The algorithm restructures an \textsc{And-Or}-path
similar to a prefix tree. Here the right-to-left ordering of the
leaves of this tree is fixed as , because  is
not commutative. The algorithm recursively splits the sequence of
inputs into two parts at an index  attaining the minimum in the
recursive delay function

This solution can be computed for every subsequence  of indices
via dynamic programming by choosing the -optimum position
 at which to split the sequence, which yields the following
result. 
\begin{theorem}[{\cite{bonn1}}] \label{thm:bl-main} For  input pairs  for 
  with arrival times , there is a logic circuit computing the carry bit  with
 This circuit can be
  constructed in  time. It has size at most , and its maximum fan-out is bounded by two at all gates and
  bounded by three at all inputs.
\end{theorem}
Using our definition of a prefix tree, the size of the carry bit circuit can be reduced by .
\begin{lemma} \label{lem:small-bl} Any prefix tree computing a single
  carry bit has an underlying  logic circuit  size of at most  and an underlying 
  maximum fan-out of two.
\end{lemma} 
\begin{proof}
  This is clear as any   prefix tree for  inputs  has exactly  prefix gates. 
\end{proof}
To analyze the structure of fast prefix carry bit circuits we
begin with a well-known definition: let  be the -th
\emph{Fibonacci number}, where  and . The exact formula for computing the -th Fibonacci number
is , where  is the golden section and .

We first prove a similar delay bound to \cite{bonn1}, but instead of
bounding the recursive function , we explicitly construct
our solution and obtain useful structural information about it.

\begin{lemma} \label{lem:fib-pfx} Let  be a sequence of input arrival times for inputs , and let  be the first Fibonacci number that is
  at least as large as . Then there
  is a prefix tree computing  with
  logic gate delay at most .
\end{lemma} 

\begin{proof}
Throughout the proof, we implicitly assume that every propagate signal
actually arrives by at least one time unit earlier than the
corresponding generate signal, i.\ e.\  has arrival time 
and  has arrival time at most , thus prefix gates have
depth two for the input with smaller indices and depth one for the
input with larger indices. Under this assumption, we prove that the
delay is at most . Adding one to all arrival times and delays
yields a circuit with delay  under the assumption that  is
available at time  and  at time , which is true for
the given input arrival times. For signal pairs  with
arrival times satisfying this assumption, we say that they have
\emph{skewed arrival times}.\index{arrival time!skewed}

  The proof has two main parts. In the first part, we construct a
  binary tree  with  leaves in such a way that if we consider
  its internal nodes as prefix gates and its leaves as inputs with
  arrival time 0, then its overall delay is . During the second
  step, we replace sections of consecutive leaves and the
  corresponding subtrees of  with our original inputs so that the
  arrival time of the input does not exceed the depth of the subtree.

  Let  be a tree constructed by starting at the root  and
  recursively constructing a binary tree with  leaves on the
  left and one with  leaves on the right as in
  Figure~\ref{fig:fib-tree}. We refer to  as a \emph{Fibonacci
    tree} for .

  \tikzfigs{Fibonacci tree  for }{0.55}{fib-tree}

  Replacing all non-leaf nodes with prefix gates and leaves with new
  inputs (with arrival time 0 and unrelated to the original inputs) as
  well as adding an output at the root yields a prefix tree for 
  inputs with logic gate depth . This can be seen inductively; it
  is certainly true for  and thus for , the left tree
  has depth , the right tree has depth , and the last prefix
  gate has delay . The minimum depth of a
  prefix tree with  leaves is at most  if and only if .

  Now we show how to replace parts of the tree by inputs with skewed
  arrival times  without increasing the delay. We
  start by subdividing the leaves of the tree: from right to left, the
  first  leaves are assigned to the first input, the next
   leaves are assigned to the second input, and input 
  gets leaves  up to . Our choice of  ensures that every input 
  gets  successive leaves assigned to it; leftover
  leaves can be deleted without increasing the delay. The ordering of
  the inputs is preserved within the tree.

  We define a subtree of size  to be a tree obtained by taking a
  vertex  and all its successors with  leaves in total. By
  construction, every subtree of size  must be a Fibonacci tree for
  some  with . Furthermore, for every  with , we can find subtrees of  of size . A vertex  in 
  is the root of a subtree of size  if and only if  has
  depth . For , we know that  and 
  has depth .

  Our goal is to show that every input  with arrival time 
  owns all the leaves of a subtree of size . In order to
  see this, we remove all edges connecting a vertex with depth at most
   to a vertex with depth more than  from the tree. This
  separates the tree into a connected component containing the root
  and several subtrees of size at most . For example, if
  , then Figure~\ref{fig:fib-tree} would contain the
  component containing the root as well as subtrees indicated by the
  coloring of size  in that order. In general, since every
  gate has depth 1 or 2, each root of such a tree has depth  or
  , therefore the subtrees can only have size 
  or . Our next goal is to prove that this ordered
  \emph{subtree sequence} has a special structure. Since only the
  roots of ``big'' subtrees of size  can be replaced by
  input  without increasing the delay, we show that there are few
  small subtrees of size .

  Due to the fact that the depth difference between a node and its
  left child is always one, the leftmost root in the subtree sequence
  of a Fibonacci tree for some  has depth  and its
  parent has depth . Therefore, the subtree rooted here has
  size . We will now show that in a Fibonacci tree, the
  ordered subtree sequence of the trees of size  and size
   never contains two consecutive subtrees of size
  . For , this is clear. For ,
  there are only two subtrees, and the left one has size
  . For , the subtree sequence of a Fibonacci
  tree for  corresponds to the concatenation of the subtree
  sequences corresponding to a tree for  and a tree for . As
  those satisfy the claim by induction hypothesis and each sequence
  starts with a tree of size , the Fibonacci tree for 
  has the stated property as well.

  We know that input  owns  consecutive leaves. In the
  subtree sequence, at most the first  leaves belonging to
  input  are part of subtrees of which  does not own the first
  (rightmost) leaf. Of the remaining leaves, the first 
  might cover a subtree of that size. This accounts for  leaves. The next  leaves are
  owned by  as well, so at that point, at the latest, there must be
  a subtree of size  of which  owns all leaves. For , we can replace the root of this subtree with one input with
  arrival time . By construction, this does not increase the
  delay.

  Here we used that  to give a lower bound of the
  depth of the owned subtree. The only exception from this is the case
  , which can be treated analogously: every input with
   owns two leaves, and by similar arguments as for the subtree
  sequence, one of them must be at depth 1 in the Fibonacci tree. 

  After removing all leaves that have not been replaced by any
  original input, we obtain a prefix tree computing  with delay . All of these arguments used the
  assumption of skewed arrival times also for the inputs, which can be achieved in such a
  way that the actual delay of the circuit increases to at most .
\end{proof}

\begin{figure}[!t]
  \centering
  \begin{subfigure}[b]{.1\linewidth}
    \tikzc{ for }{1}{fib-t}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{.12\linewidth}
    \tikzc{Prefix tree}{1}{fib-pfx}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{.2\linewidth}
    \tikzc{Logic circuit}{1}{fib-logic}
  \end{subfigure}
  \caption{A tight example}
  \label{fig:fib-tight} 
\end{figure}
The upper bound of  is tight for the final logic circuit as
evident from the example , where , so  (see
Figure~\ref{fig:fib-tight}).

For this arrival time profile, the algorithm will (implicitly)
construct the Fibonacci tree  and assign leaves to the inputs as in
Figure~\ref{fig:fib-t}, where the colored vertices represent the
positions at which the inputs will actually be inserted into the
tree. These do not have to be leaves in general. After deleting
redundant inputs, we obtain a prefix tree (Figure~\ref{fig:fib-pfx})
and a corresponding logic circuit (Figure~\ref{fig:fib-logic}). Note
that  has arrival time  and the red path contains four gates,
hence the logic circuit has delay .

From the proof of Lemma~\ref{lem:fib-pfx}, it is easy to see how to
avoid the enumeration of all potential splitting positions
 in (\ref{eqn:bl-dp}). Since there are  leaves
in the left subtree of  and  in the right subtree, let  and , then  counts how many leaves belonging to input 
are part of the right subtree, and  is the only input that might
have leaves in both subtrees. Since in our decomposition the leftmost
 leaves of the right subtree belong to a Fibonacci tree of
size ,  should be on the right side of the decomposition
if and only if . Otherwise, there are at least
 leaves on the left side, hence in our sequence of subtrees
 might own all leaves of a subtree of size , but the
remaining leaves must belong to and cover a subtree of size
, hence  should be on the left side. Note that it is
never optimal to assign all leaves to the same side, thus this
partition can always be assumed as proper without increasing the
delay. After updating the number of leaves belonging to  on the
side it is assigned to, this yields a recursive procedure that
terminates when there is only one index left for a subtree.

\begin{lemma}\label{lem:fast-bl}
  Given input arrival times , let
   be the first Fibonacci number that is at least as large as
  . A prefix tree for these input
  arrival times with delay at most  can be found with running time
   under the
  assumption that we can perform additions and multiplications by a
  constant on numbers of arbitrary size in constant time (an
  assumption we will show how to avoid later). If  for all , then the running time is
  .
\end{lemma}

\begin{proof} We have already argued that the algorithm achieves the stated delay
  bound. We show that this partitioning strategy will ensure that
  every input  is substituted for a subtree of size at least
  .

  If there is only one index  remaining, it was either the
  rightmost (lowest) or leftmost (highest) index in the previous
  step. If it was the rightmost index, then the subtree previously
  contained  of its leaves as well as at least one more
  leaf, hence  and the right subtree has size at least
  , so replacing this subtree by input  leads to the
  claimed delay by the argument used in Lemma~\ref{lem:fib-pfx}. If it
  was the leftmost index, a similar argument applies.

  For the running time estimate, we compute the indices assigned to
  every leaf and the delay bound  in time . There are  recursive
  partitioning steps, during each of which we find the input  as
  the input index to own leaves in the left subtree. This can be done
  in logarithmic time using binary search in the sorted array of the
  indices of the first leaf belonging to every input.
\end{proof}
\begin{figure}[htb]
  \centering
  \begin{subfigure}[b]{0.5\linewidth}
    \tikzc{Algorithm for input arrival times }{1}{core-ex}
  \end{subfigure}
  \begin{subfigure}[b]{0.16\linewidth}
    \tikzc{Prefix tree}{1}{core-tree}
  \end{subfigure}
  \caption{Example of the algorithm}
  \label{fig:alg-ex}
\end{figure}

Figure~\ref{fig:core-ex} shows how the algorithm works for the
sequence of input arrival times . The number of leaves
we need is , therefore  suffices. We
number the leaves from right to left as . After the
first split,  light blue leaves are in the left subtree, hence the
corresponding input is assigned to the left subtree.  Note that for
the orange leaves, we end up assigning them to a subtree that does not
contain any orange leaves in the beginning in order to ensure a proper
partition. We obtain the result shown in Figure~\ref{fig:core-tree}.

\begin{lemma} \label{lem:reduction}
  We can construct a prefix tree with the delay bound of
  Lemma~\ref{lem:fib-pfx} for any instance  by
  constructing a prefix tree for an instance 
  with .
\end{lemma}
This follows from the fact that the longest path from any input to the
output contains at most  prefix gates. The maximum delay
difference can be assumed as , since any input with earlier
arrival time will never be critical.

\begin{theorem} \label{thm:my-pfx} For  inputs with arrival times
    , the algorithm finds a prefix
    carry bit circuit for  with  
    The constructed logic circuit has size at most  and
    maximum fan-out two at all logic gates and inputs. Furthermore,
    the delay is at most
    
  \end{theorem}
  \begin{proof}
  The size and fan-out bounds follow from Lemma~\ref{lem:small-bl}.
  The delay of the
  constructed circuit is . By choice of , we know that
  . With ,  and the exact formula
  , it follows that
   and for ,
  .

  Now  can only be true if there is only one input. In this
  case, the stated delay bound is trivially true. Otherwise, we obtain
  the estimate:
  
  which proves the first claim. 

  For a single input, the second delay bound is trivially
  true.  Furthermore, for , . We obtain the estimate:
  
\end{proof}

Our proof allows an improvement over the delay bound of \cite{bonn1}
due to a refined analysis.  A running time of 
follows from Lemma~\ref{lem:fast-bl} assuming that we can add numbers
of linear size and multiply them by a constant in constant time.
Under the more practical assumption that these operations take linear
time with respect to the number of digits, the algorithm has
super-quadratic running time, which can be avoided as follows:

\begin{theorem} \label{thm:fast-pfx} For any fixed , a
  prefix carry bit circuit as in the setting of
  Theorem~\ref{thm:my-pfx} with  can be found in  time
  assuming linear-time addition and multiplication with constants.  It
  satisfies
  
\end{theorem}
\begin{proof}
  By Lemma~\ref{lem:reduction} and Theorem~\ref{thm:my-pfx}, we can
  solve instances with 
  in  time with linear-time addition.

  Given an instance , we set  and compute a circuit for the modified
  instance in . When reverting to the original
  arrival times, the delay of this solution does not increase, because
  none of the arrival times do. Therefore, 
  
  and . For the dual logarithm-based delay bound, we
  have
  
  and . 
\end{proof}


For , the additional error decreases with growing . Since the algorithm
is only useful if , choosing a sufficiently large constant
 yields the delay bound  with running time . 

\section{Algorithm for Prefix Adder Circuits}\label{sec:bl-adder}
The na\"{\i}ve parallel prefix graph construction, in which all carry
bits are computed separately by a carry bit circuit, might contain a quadratic
number of gates. Therefore, Rautenbach et al.\  also developed a parallel prefix graph construction
computing all carry bits \cite{bonn2}.

\begin{theorem}[{\cite{bonn2}}] \label{thm:bl-ppfx} Given  and arrival times , there is a
  parallel prefix graph for  inputs of size  with logic delay 
\end{theorem}

The primary objective in \cite{bonn2} is to minimize the delay of the
prefix graph instead of the underlying logic circuit.  We will improve
the performance guarantee for a similar construction as in
\cite{bonn2} by using a carry bit circuit as in
Section~\ref{sec:bl-core} as a subroutinte.

Given inputs , we partition the set 
into  subsets , each containing
 or  consecutive indices. Let ,
where  is computed by a circuit constructed by the carry bit
algorithm. This is shown in green, labeled ``Best'', in
Figure~\ref{fig:bl-pfx}. The parallel prefix graph construction is
applied recursively to compute prefixes for all groups without their
highest index as well as for the  inputs 
(which corresponds to the red boxes labeled ``Recursion'' in
Figure~\ref{fig:bl-pfx}), i.\ e.\ we build  parallel prefix
graphs, each with at most  inputs. As a final step, we combine
all prefixes from group  with the -th prefix of the 
and add one more prefix gate combining  with the -th
prefix of the . This yields a parallel prefix graph.

\tikzfigs{Prefix graph construction}{0.8}{bl-pfx}

The following two lemmas analyze the size of the resulting parallel prefix graph
and the running time of its construction.

\begin{lemma} \label{lem:bl-ppfx-size-app}
  The parallel prefix graph in \cite{bonn2} and the modified
  construction above  have the same size; for
  , it is bounded by  in terms of prefix gates
  and  in terms of logic gates.
\end{lemma}
\begin{proof}
  Consider Figure~\ref{fig:sqrt} and proceed by induction on the
  number of inputs. On a level with  inputs, the number of green
  gates and the number of yellow gates are both at most . The total
  number of inputs of recursion blocks can be bounded by  as well:
  if there are  groups, then  original inputs are inputs of
  recursion blocks; one further recursion block has  inputs. For
  small , the correctness follows from Figure~\ref{fig:sqrt}, e.\
  g.\ for , the size bound is  and  gates are required.

  Let  be the groups, , then by induction
  hypothesis, the prefix gate size is bounded by
  
  For logic gates, the size increases by a factor of three. 
\end{proof}

\begin{lemma} \label{lem:rt-app}
  The parallel prefix graph above can be
  computed in  time. 
\end{lemma}
\begin{proof}
  As in Theorem~\ref{thm:fast-pfx}, we round all running times up to
  at least  for a fixed . For this arrival time profile, we have already shown that
  
  Therefore, we can use the rounded arrival time profile to achieve a
  delay guarantee of 
   for . This means that all numbers in the computations have size at
  most , thus it remains to bound the number of
  operations by . 

  For each level  of the recursion, we have a
  partition of the  inputs into groups, where the maximum group
  size is bounded by . Therefore, the prefix trees for the
   can be computed in 
  time. All  require time , because this
  is a geometric series. All remaining gates are prefix gates; they
  have fixed positions, thus each of them requires only constant time
  to compute, and there are  such gates in
  total.
\end{proof}

The new parallel prefix graph construction is summarized in the
following theorem.
\begin{theorem} \label{thm:my-ppfx} Given  and
  arrival times , our algorithm
  finds a parallel prefix graph with logic gate delay at most

It can be implemented with running time  and
the computed circuit has size at most  in terms of logic gates. 
\end{theorem}


This theorem implies that for  sufficiently large, we have a
-approximation algorithm in terms of the delay for a prefix
adder. The algorithm of \cite{bonn2} has a running time of
, which the use of our carry bit algorithm improves to a
near-linear running time, even with linear-time addition.


To prove the delay bound, we assume that all arrival
times are skewed by one time unit. Under this assumption, let , and let  denote the maximum
delay for a circuit constructed as above with  inputs and an
arrival time profile leading to the same . Then  is
an upper bound on the delay of the constructed circuit, and we have:

\begin{lemma} \label{lem:delay-bl-pfx} For  input pairs with skewed arrival
  times , let . Then we have
  
\end{lemma}
\begin{proof}
  We may assume that the given arrival time profile achieves the
  maximum delay, i.\ e.\ for , the construction
  actually has a delay of .
 
  By Theorem~\ref{thm:my-pfx} and using the assumption that the
  propagate signals arrive earlier than the generate signals, we can
  compute  with delay . Therefore, their prefix graph has delay
  at most  For each of the groups 
  containing  or  inputs, the
  prefix graph of all but its last input (highest index) has delay at
  most  as  is monotonically increasing
  in  and . Therefore, the combination of a prefix of one of the
   and the corresponding prefix of the  has logic gate delay
  at most . 

  We prove the absolute delay estimate by induction on . For ,  for all input
  sequences with this parameter  as . Therefore, for ,  is bounded by
  
\end{proof}

Without assuming skewed arrival times, we achieve a delay bound
of . For , an example is shown in
Figure~\ref{fig:sqrt}. Gates are colored by the part of the recursion
they represent; in this special case, some gates can be used to compute
the  as well as the group prefixes, hence they are both red and
green.

\tikzfigs{Parallel prefix graph for uniform arrival times}{0.8}{sqrt}

The construction in \cite{bonn2} and our variant of it both have a
very high fan-out; for  inputs, the fan-out is at least
. In a physical implementation such a high fanout
induces a significant delay and requires the insertion of
duplicate gates into the interconnect to repeat the signals. The high
fan-outs occur precisely at the -prefixes, therefore they
accumulate on a critical path. For  inputs, the fan-out can be
redistributed to duplicate gates with fan-out 2 using depth
; this will lead to an overall increase
in delay of  for a given path
\cite{bonn2}. Therefore, we obtain a -approximation algorithm if
the fan-out is bounded by , improving the -approximation
achieved by \cite{bonn2} in this scenario.

\section{A Lower Bound for Prefix Adders} \label{sec:lb}
Lemma~\ref{lem:pfx-to-logic} shows that a lower bound for the delay of
a prefix tree for a single carry bit is given by an optimal binary
tree with depth one for the left child and depth two for the right
child in which the leaves represent inputs and their right-to-left
order corresponds to the ordering of the inputs. For zero arrival
times, this is achieved by a Fibonacci tree. Rautenbach et al.\
\cite{code-trees} observed that this a special case of a more general
concept: alphabetic code trees with unequal letter costs. These can be
used to obtain general lower bounds, which we improve and state
explicitly by using the specific properties of our application.

\begin{lemma}\label{lem:bl-lb}
  Given  inputs with integral arrival times , a prefix tree computing their carry bit  has
  logic gate delay at least
  
\end{lemma}
\begin{proof}
  In Section~\ref{sec:bl-core} we saw that  inputs with
  arrival time zero can be combined with depth . Therefore, an
  optimal prefix tree for inputs with arrival times 
  of delay  can be restructured into a prefix tree with
   inputs with depth  by replacing input
   by a Fibonacci tree for . If there is only one input,
  the lemma is trivially true, thus we may assume . But a tree of depth  has at most 
  leaves, hence  and

and  as
claimed. 
\end{proof}
This lemma shows that  the  single carry bit circuits in Section~\ref{sec:bl-core} 
have  optimum delay up to an additive margin of .

\bibliographystyle{plain}

\begin{thebibliography}{10} 

\bibitem{Chatterjee+techmap2006}
S. Chatterjee, A. Mishchenko, R. Brayton, X. Wang, and T. Kam.
\emph{Reducing structural bias in technology mapping.}
IEEE Transactions on Computer Aided Design of Integrated Circuits and Systems 25.12,2894--2903, 2006.


\bibitem{choi} Youngmoon Choi. 
  \emph{Parallel prefix adder design.} Dissertation, University of Texas at Austin, 2004.

\bibitem{keutzer88}
Keutzer, Kurt. 
\emph{DAGON: technology binding and local optimization by DAG matching.} 
Papers on Twenty-five years of electronic design automation, ACM, 617--624, 1988.


\bibitem{Kno01} Simon Knowles.
\emph{A family of adders}.
 Proceedings of the 15th IEEE Symposium on Computer Arithmetic (ARITH-15) (2001): 277--81.

\bibitem{kogge-stone} 
Peter M. Kogge and Harold S. Stone. \emph{A parallel algorithm for the efficient solution of a
    general class of recurrence equations.}  IEEE
  Transactions on Computers 100.8 (1973): 786--793.

\bibitem{ladner} 
Richard E. Ladner and Michael  J. Fischer. \emph{Parallel prefix computation.} Journal of the ACM
  (JACM) 27.4 (1980): 831--838.


\bibitem{okl} Vojin G. Oklobdzija. \emph{Design and analysis of
fast carry-propagate adder under non-equal input signal arrival
profile.} Conference Record of the Twenty-Eighth Asilomar Conference
on Signals, Systems and Computers, Vol. 2. IEEE, 1994.

\bibitem{bonn1} Dieter Rautenbach, Christian Szegedy and J\"urgen
  Werber. \emph{Delay optimization of linear depth boolean circuits
    with prescribed input arrival times.} Journal of Discrete
  Algorithms 4.4 (2006): 526--537.

\bibitem{bonn2} Dieter Rautenbach, Christian Szegedy and J\"urgen
  Werber. \emph{The delay of circuits whose inputs have specified
    arrival times.} Discrete Applied Mathematics 155.10 (2007):
  1233--1243.

\bibitem{code-trees} Dieter Rautenbach, Christian Szegedy and
  J\"urgen Werber. \emph{On the cost of optimal alphabetic code trees
  with unequal letter costs.} European Journal of Combinatorics 29.2
  (2008): 386--394.

\bibitem{roy} Subhendu Roy, Mihir Choudhury, Ruchir Puri, and David
Z. Pan.
\emph{Towards optimal performance-area trade-off in adders by
synthesis of parallel prefix structures.} Proceedings of the 50th
Annual Design Automation Conference (2013).

\bibitem{WS58} Arnold Weinberger and James L. Smith.
  \emph{ A logic for high-speed addition}
  Nat. Bur. Stand. Circ, 591, 3--12,  1958.

\bibitem{bonnlogic} J\"urgen Werber, Dieter Rautenbach and
  Christian Szegedy. \emph{Timing optimization by restructuring long
    combinatorial paths.} Proceedings of the 2007 IEEE/ACM
  international conference on Computer-aided design. IEEE Press, 2007.


\bibitem{zimmermann} Reto Zimmermann. \emph{Binary adder
    architectures for cell-based VLSI and their synthesis.}
  Dissertation, ETH Zurich, Hartung-Gorre, 1998.
\end{thebibliography}
 
\end{document}
