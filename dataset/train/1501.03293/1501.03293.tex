\documentclass[envcountsect,envcountsame]{llncs}

\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{listings}
\lstset{
         language=Haskell,
        showstringspaces=false,
        tabsize=4
}
\usepackage[all]{xy}
\SelectTips{cm}{} 
\newcommand{\atms}{\mathrm{Atm}}
\newcommand{\condzero}{\mathrm{C0}}
\newcommand{\condone}{\mathrm{C1}}
\newcommand{\condtwo}{\mathrm{C2}}
\newcommand{\eqref}[1]{(\ref{#1})}
\newcommand{\forces}{\Vdash}
\newcommand{\gtr}{\mathrm{GT}}
\newcommand{\iimp}{\twoheadrightarrow}
\newcommand{\implist}[5]{#2_{#4} #1 {#3}_{#4} , \cdots ,  #2_{#5}
  #1 {#3}_{#5}}
\newcommand{\lcnxt}{\mathrm{KM}_{lin}}
\newcommand{\lgcpl}{\mathrm{Cpl}}
\newcommand{\lggl}{\mathrm{GL}}
\newcommand{\lgglpt}{\mathrm{GL.3}}
\newcommand{\lgiint}{\mathrm{iInt}}
\newcommand{\lgint}{\mathrm{Int}}
\newcommand{\lggrz}{\mathrm{Grz}}
\newcommand{\lggrzpt}{\mathrm{Grz.3}}
\newcommand{\lgkm}{\mathrm{KM}}
\newcommand{\lglc}{\mathrm{LC}}
\newcommand{\lgsf}{\mathrm{S4}}
\newcommand{\lgsfpt}{\mathrm{S4.3}}
\newcommand{\limp}{\rightarrow}
\newcommand{\mprulename}{\small mp}
\newcommand{\nxt}{\rhd}
\newcommand{\later}{\nxt}
\newcommand{\nxtlist}[2]{\nxt {#1}_{1} , \cdots ,  \nxt {#1}_{#2}}
\newcommand{\oplist}[4]{#1 {#2}_{#3} , \cdots ,  #1 #2_{#4}}
\newcommand{\opset}[2]{{#2}^{#1}}
\newcommand{\opsetmi}[3]{\opset{#1}{#2}_{-#3}}
\newcommand{\rel}{R}
\newcommand{\releq}{R^{=}}
\newcommand{\res}[2]{r^{#1}_{#2}}
\newcommand{\seq}{\vdash}
\newcommand{\seqlcnxt}{\mathrm{SKM}_{lin}}
\newcommand{\seqkm}{\mathrm{SKM}}
\newcommand{\trees}{\mathcal{S}}
\newcommand{\wbx}{\Box}
\newcommand{\wdi}{\lozenge}

\newcommand{\toprightrulename}{\small \top \mathrm{R}}
\newcommand{\toprule}{
\AxiomC{}
\LeftLabel{}
\UnaryInfC{}
\DisplayProof
}

\newcommand{\idrulename}{\small id}
\newcommand{\idrule}{
\AxiomC{}
\LeftLabel{\idrulename}
\UnaryInfC{}
\DisplayProof
}

\newcommand{\botleftrulename}{\small \bot \mathrm{L}}
\newcommand{\botrule}{
\AxiomC{}
\LeftLabel{}
\UnaryInfC{}
\DisplayProof
}

\newcommand{\orleftrulename}{\small \lor \mathrm{L}}
\newcommand{\orleftrule}{
\AxiomC{}
\AxiomC{}
\LeftLabel{}
\BinaryInfC{}
\DisplayProof
}

\newcommand{\orrightrulename}{\small \lor \mathrm{R}}
\newcommand{\orrightrule}{
\AxiomC{}
\LeftLabel{}
\UnaryInfC{}
\DisplayProof
}

\newcommand{\andrightrulename}{\small \land \mathrm{R}}
\newcommand{\andrightrule}{
\AxiomC{}
\AxiomC{}
\LeftLabel{}
\BinaryInfC{}
\DisplayProof
}

\newcommand{\andleftrulename}{\small \land \mathrm{L}}
\newcommand{\andleftrule}{
\AxiomC{}
\LeftLabel{}
\UnaryInfC{}
\DisplayProof
}

\newcommand{\impleftrulename}{\small \limp\!\!\mathrm{L}}
\newcommand{\impleftrule}{
\AxiomC{}
\AxiomC{}
\LeftLabel{}
\BinaryInfC{}
\DisplayProof
}

\newcommand{\imprightrulename}{\small \limp\!\!\mathrm{R}}
\newcommand{\imprightrule}{
\AxiomC{}
\AxiomC{}
\LeftLabel{}
\BinaryInfC{}
\DisplayProof
}

\newcommand{\steprulename}{\textsc{step}}
\newcommand{\newsteprulename}{\textsc{step}}

\newcommand{\newsteprulenewversion}{
   \begin{tabular}[c]{l@{\extracolsep{2cm}}l}
   \multicolumn{2}{c}{
   \AxiomC{}
   \LeftLabel{}
\RightLabel{}
   \UnaryInfC{}
   \noLine
   \UnaryInfC{
     \begin{tabular}[c]{lll}
     \\ 
      & 
      & 
   \2px]

      &
  
   \2px]

   \5px]
   \multicolumn{2}{l}{
   where  means that the conditions ,  
   and  below must hold
  }
\2px]
   \multicolumn{2}{l}{
()    
     and  and 
    
   }
   \5px]
   \multicolumn{2}{l}{
   Explanations for the conditions:}
   \2px]
   \multicolumn{2}{l}{
   () none of the rules
        
       are applicable to the conclusion}
   \
  Stream \cong \mathbb{Z} \times \nxt Stream
\label{eq:sLob}
  (\nxt\tau\limp\tau)\to\tau

  \lambda x.\langle 0,x\rangle:\nxt Stream\to \mathbb{Z}\times \nxt Stream
\xymatrix{
  A_1 \ar[d]_{f_1} & A_2  \ar[l]_{a_1} \ar[d]_{f_2} & A_3  \ar[l]_{a_2}  \ar[d]_{f_3} & \cdots & A_j  \ar[d]_{f_j} & A_{j+1}  \ar[l]_{a_j} \ar[d]_{f_{j+1}} \\
  B_1 & B_2 \ar[l]^{b_1} & B_3 \ar[l]^{b_2} & \cdots & B_j & B_{j+1} \ar[l]^{b_j}
}
  \varphi & ::= &
      p \mid
     \top \mid
     \bot \mid
      \varphi\land\varphi \mid
     \varphi\lor\varphi \mid
     \varphi\limp\varphi \mid
     \varphi\iimp\varphi \mid
     \nxt\varphi
\begin{array}{ll}
  \eta,j\forces p &\mbox{iff } \\
  \eta,j\forces \top & \mbox{always} \\
  \eta,j\forces \bot & \mbox{never} \\
  \eta,j\forces \varphi\land\psi \quad &
    \mbox{iff }\eta,j\forces\varphi\mbox{ and }\eta,j\forces\psi \\
  \eta,j\forces \varphi\lor\psi \quad &
    \mbox{iff }\eta,j\forces\varphi\mbox{ or }\eta,j\forces\psi \\
  \eta,j\forces \varphi\limp\psi \quad &
    \mbox{iff . }
    \eta,k\forces\varphi\mbox{ implies }\eta,k\forces\psi \\
  \eta,j\forces \varphi\iimp\psi \quad &
    \mbox{iff . }
    \eta,k\forces\varphi\mbox{ implies }\eta,k\forces\psi \\
  \eta,j\forces \later\varphi &
    \mbox{iff . }
    \eta,k\forces\varphi
\end{array}\label{eq:limp_via_imp}
    j\forces\varphi\limp\psi
      \mbox{ \ iff \ ( implies ) and }

\mathrm{if~} 
w \in \vartheta(p) 
\mathrm{~and~}
w \rel x
\mathrm{~then~}
x \in \vartheta(p) 
\begin{array}{ll}
  M,w\forces p &\mbox{iff } \\
M,w\forces \varphi\limp\psi \quad &
    \mbox{iff } \forall x.\,w\releq x\mbox{ and }
    M,x\forces\varphi\mbox{ implies }M,x\forces\psi \\
  M,w\forces \varphi\iimp\psi \quad &
    \mbox{iff } \forall x.\,w\rel x\mbox{ and }
    M,x\forces\varphi\mbox{ implies }M,x\forces\psi \\
  M,w\forces \later\varphi &
    \mbox{iff } \forall x.\,w\rel x\mbox{ implies }
    M,x\forces\varphi
\end{array}15px]
    \orleftrule &  \orrightrule
\15px]
    \impleftrule & \imprightrule
\
  \AxiomC{}
  \RightLabel{\idrulename}
 \UnaryInfC{}
 \AxiomC{}
  \RightLabel{\idrulename}
 \UnaryInfC{}
  \RightLabel{}
 \BinaryInfC{}
 \DisplayProof
  15px]
   \AxiomC{}\RightLabel{\mprulename}
   \UnaryInfC{}
   \RightLabel{}
   \UnaryInfC{}
   \AxiomC{}\RightLabel{\idrulename}
   \UnaryInfC{}
   \RightLabel{}
   \BinaryInfC{}
   \AxiomC{}
   \RightLabel{}
   \BinaryInfC{}
   \DisplayProof   
  \caption{ proof of the strong L\"ob axiom}
  \label{fig:sLob}
\end{figure}

\begin{figure}[t]
  \centering
  \def\ScoreOverhang{2.7pt}
  \AxiomC{}\RightLabel{\idrulename}
  \UnaryInfC{}
  \AxiomC{}\RightLabel{\idrulename}
  \UnaryInfC{}
  \RightLabel{}
  \UnaryInfC{}
  \RightLabel{}
  \BinaryInfC{}
  \AxiomC{}
  \UnaryInfC{}
  \RightLabel{}
  \BinaryInfC{}
  \DisplayProof
 \
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{}
  \DisplayProof 
\qquad
  \AxiomC{}
  \AxiomC{}
  \BinaryInfC{}
  \DisplayProof 
15px]
    \multicolumn{2}{l}{
      where  means that the following conditions hold:}
    \2px]
    \multicolumn{2}{l}{
    ():  and  contain only atomic
    formulae (\textit{i.e.} the conclusion is saturated)}
  \end{tabular}
  \caption{Transitional rules for logic }
  \label{fig:step-rules-logic-KH}
\end{figure*}

The backward proof-search strategy is the same as that of
Sec.~\ref{Sec:Proof_Search}, except the transitional rule
applications now reads as below:
\begin{quote}
  \textbf{transition:} else choose a - or -formula from the
  succedent and apply  or
  , backtracking over these choices until a
  derivation is found or all choices of principal formula 
  have been exhausted.
\end{quote}

So if the given sequent is

and 

contains  formulae
and

contains  formulae,
then in the worst case we must explore
 premise instances of 
 and
  premise instances of 
.


\begin{theorem}\label{km-soundness}
  The rules
   
  and
  
  are \emph{sound} for the logic
  . 
\end{theorem}
\begin{proof}
Suppose the conclusion of rule  
is refutable at world 
in some model . Thus there is a strict -successor  of 
which is a last refuter for : that is,  and  and
. The other formulae from the antecedent
of the conclusion are also true at  by truth-persistence,
and for every -formula
true at , we also have its -version true at , and likewise for
-formulae.
The proof for the  rule is similar.
\end{proof}


Termination follows using the
same argument as for .
However the new rules are not semantically invertible, since we have to choose
a particular - or -formula from the succedent of the
conclusion and discard all others when moving to the premise, yet a
different choice may have given a derivation of the conclusion. Thus these rules
require the backtracking which is built into the new \textbf{transition}
part of our proof search strategy.




\begin{lemma}\label{lemma:existential-inversion}
If a sequent 
obeys the  conditions and every premise instance obtained by
applying the rules  and 
backwards to  is not derivable, then the sequent  is refutable.
\end{lemma}
\begin{proof}
  We proceed by induction on the maximum number  of applications of the
  transitional rules in any branch of backward proof search for .

  Base case : if  obeys the  conditions but contains no
  -formulae and contains no -formulae in its succedent,
  then no rule at all is applicable to  and so  is
  refutable as already shown in the proof of
  Thm.~\ref{thm:completeness}.

  Base case : if  obeys the  conditions and the proof-search involves
  at most one application of the transitional rules in any branch,
  then each premise instance of  leads upwards to at least one
  non-derivable leaf sequent to which no rule is applicable. This leaf
  is again refutable as shown in the proof of
  Theorem~\ref{thm:completeness}. The Inversion Lemmas then allow us
  to conclude that the premise instance itself is refutable since all
  rule applications in this branch must be static rules.
Thus each
  premise instance  of  under the transitional rules is
  refutable in some world  in some model . Let  be a
  new world and put  for every  and put  for
  each  which is an -successor of any  in any model
  , and put  iff  is in the antecedent
  of . The new world  makes every atomic formula in the antecedent
  of  true and makes every atomic formula in the succedent of 
  false.  There are no conjunctions or disjunctions or -formulae in
  . 
Every  in the antecedent of  appears in the
  antecedent of every premise instance  as , so each
   makes  true, and hence  makes
   true.
Every  in the antecedent of  appears in the
  antecedent of every premise instance  and so does , so
  each  makes   true, and hence  makes 
   true.
For every -formula  in
  the succedent of , the premise instance  corresponding to a
  -rule application with 
  as the principal formula will contain  in its antecedent 
  and contain  in its succedent. The corresponding world 
  will make  true and make 
  false, meaning that  will falsify .
  Similarly, for every -formula  in the succedent of
  , the world  obtained from a -rule
  application with  as the principal formula will falsifiy
  , meaning that  will falsify . Thus  will
  refute  as claimed.

  Induction case  for : The induction hypothesis is that the
  lemma holds for all sequents
   that obey the -conditions and whose proof-search
  involves at most  applications of the transitional rules in
  any branch.

  Now suppose that  obeys the -conditions and the
  backward proof search for  contains  applications of the
  transitional rules. Consider the bottom-most application of the
  transitional rules (if any) along any branch ending at a premise instance
   of . Suppose the conclusion sequent of this bottom-most
  application is . This
  application falls under the induction hypothesis and so  must be
  falsifiable in some model. The rules between  and  are all
  static rules, if any, and so are semantically invertible, meaning
  that the sequent  must be falsifiable in some model. 
  Thus each
  premise instance  of  under the transitional rules is
  refutable in some world  in some model . The same
  construction as in the base case for  suffices to deliver a
  model and a world that refutes  as claimed.
\end{proof}





\begin{corollary}
 If the end-sequent  is not derivable using
 backward proof search according to our strategy then 
  is refutable.
\end{corollary}


\begin{corollary}\label{km-completeness}
If  is -valid then
 is -derivable.
\end{corollary}

As for , our proofs yield the finite model property for  as an immediate
consequence, although for  this is already known~\cite{Muravitsky:Logic}.


\section{Related Work}


Ferrrari~et~al~\cite{DBLP:journals/jar/FerrariFF13} 
give sequent calculi for 
intuitionistic logic using
a compartment  in
the antecedents of their
sequents . This 
compartment contains
formulae that are not necessarily true now, but are true 
in all strict successors.
Fiorino~\cite{DBLP:journals/corr/abs-1206-4458} gives a sequent calculus using
this compartment for .
This yields linear depth derivations, albeit requiring a semantic check which is quadratic.
Both~\cite{DBLP:journals/jar/FerrariFF13,DBLP:journals/corr/abs-1206-4458} build in
aspects of G\"{o}del-L\"{o}b logic by allowing (sub)formulae to
cross from the succedent of the conclusion into the
compartment .
Our calculus differs by giving syntactic
analogues  and  for these meta-level features,
and by requiring no compartments, but
it should be possible to adapt these authors' work to 
design sequent calculi for  with linear depth derivations.

Restall~\cite{restall-subintuitionistic-logics} investigates
``subintuitionistic logics'' where each of the conditions on Kripke frames of
reflexivity, transitivity and persistence can be dropped. The logic of our novel
connective  can be seen as the logic bka, which lacks reflexivity, but
has the additional conditions of linearity and converse well-foundedness, which Restall
does not consider. 
The models studied by Restall all require a root world, and thus
they disallow sequences  
which are permitted by -models.
Ishigaki and Kikuchi~\cite{DBLP:conf/tableaux/IshigakiK07} 
give ``tree-sequent'' calculi for the first-order versions of
some of these subintuitionistic logics. 
Thus ``tree-sequent'' calculi
for  and  are possible, but our calculi require no labels.

Labelled sequent calculi for 
and  are possible by extending the work of 
Dyckhoff and Negri~\cite{DBLP:journals/aml/DyckhoffN12} but
termination proofs and complexity results
for labelled calculi are significantly harder than
our proofs. 

Garg et al~\cite{DBLP:conf/lics/GargGN12} give labelled
sequent
calculi for intuitionistic modal logics and general conditions on
decidability. Their method relies on a first-order
characterisation of the underlying Kripke relations, but
converse well-foundedness is not first-order definable.
Labelled calculi can handle converse well-founded frames 
by allowing formulae to ``cross'' sides as in our
calculus, but it is not clear whether the method of 
Garg et al~\cite{DBLP:conf/lics/GargGN12} then applies.






Our complexity results follow directly from our calculi; a possible alternative
may be to adapt the polynomial encoding
of  into
classical satisfiability~\cite{chagrov-zakharyaschev-modal-logic}.


\section{Conclusion}

We have seen that 
the internal \emph{propositional} logic of the topos
of trees is . Indeed it may be tempting to think that 
is just , as both are sound and complete with respect to the
class of finite sequences of reflexive points, but note that we cannot
express the modality  in terms of the connectives of .

Linear frames seem concordant with the \emph{step-indexing} applications of later,
based as they are on induction on the natural numbers rather than any
branching structure, but seem less natural from a \emph{types} point of
view, which tend to build on intuitionistic logic. For a possible type-theoretic
intepretation of linearity see Hirai's -calculus for  with applications to `waitfree' computation~\cite{Hirai:Lambda}. More broadly our work provides a
proof-theoretical basis for future research into computational aspects of intuitionistic
G\"{o}del-L\"{o}b provability logic.

The topos of trees, which generalises some previous models, has itself been
generalised as a model of guarded recursion in several ways~\cite{Birkedal:First,Birkedal:Intensional,Milius:Guard}. These categories do not all
correspond to ; some clearly fail to be linear. The logical content of these
general settings may also be worthy of study.

The most immediate application of our proof search algorithm may be to provide
automation for program logics that use
later~\cite{Hobor:Oracle,Bengtson:Verifying,Clouston:Programming}. Support for
a richer class of connectives, such as first and higher order quantifiers, would be
desirable. We in particular note the `backwards looking box' used
by Bizjak and Birkedal~\cite{Bizjak:Model} in sheaves over the first uncountable
ordinal , and subsequently in the topos of trees by Clouston et
al~\cite{Clouston:Programming} to reason about
coinductive types.

\subsubsection*{Acknowledgments}
We gratefully acknowledge helpful discussions with Lars Birkedal,
Stephan\'e Demri, Tadeusz Litak, and Jimmy Thomson, and the comments
of the reviewers of this and a previous unsuccessful submission.

\bibliographystyle{splncs03}
\bibliography{original-blbl}

\end{document}
