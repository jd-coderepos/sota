






\documentclass[submission,copyright,creativecommons]{eptcs}









\usepackage{amssymb}




\usepackage{hyperref}



\usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{color}
\usepackage{graphicx}
\usepackage{fontenc}
\usepackage{url}
\usepackage{breakurl}             \usepackage{psfrag}
\usepackage{listings}
\usepackage{rotating}
\usepackage{latexsym,epsfig}
\usepackage{bm}

\usepackage{diagrams}


\usepackage{ifthen}












\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{property}[theorem]{Property}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}

\newenvironment{proof}[1][\!\!\,]{\vspace{1ex}\noindent\textbf{Proof #1: }}{\hfill\vspace{2ex}}


\newcommand{\refeq}[1]{(\ref{#1})}



\newcommand\Notation{\vspace{1ex}\noindent\textbf{\itshape Notation:}\hspace{1ex}}
\newcommand\RemarkJ{\vspace{1ex}\noindent\textbf{\itshape Remark:}\hspace{1ex}}
\newcommand\RemarksJ{\vspace{1ex}\noindent\textbf{\itshape Remarks:}\hspace{1ex}}
\newcommand\Remarks{
}
\newcommand\Remark{
}


\newcommand{\cp}[1]{}


\newcommand{\notforsubmission}[1]{}
\newcommand{\private}[1]{\notforsubmission}
\newcommand{\futureIdeas}[1]{{\color{blue}#1 CP}}
\newcommand{\notforotherstosee}[1]{}
\newcommand{\unclearAppendix}[1]{}




\newcommand{\myproof}[1]{\par\noindent {\bf Proof:}\ \ \ #1 \hfill\vspace{1ex}} 

\newcounter{case}
\renewcommand{\thecase}{\arabic{case}}



\newcommand{\mycase}[2]{\refstepcounter{case} \vspace{1ex}\par\noindent{\bf Case \thecase{}#1.} \hspace{1ex} #2\vspace{1ex}} 
\newcommand{\mycasetwo}[2]{\vspace{0.5ex}\par\noindent {\bf Case} given by #1. #2\vspace{1ex}}

\newcommand{\notion}[1]{\vspace{0.5ex}\paragraph[\hspace{-8ex} #1]{\bf #1}\vspace{0.5ex}}

\newcommand\Base{\vspace{1ex}\textit{Base case}: }
\newcommand\Induction{\vspace{1ex}\textit{Inductive step}: }


\newcommand\cat[1]{\ensuremath{\mathbf{#1}}}
\newcommand\dualCat[1]{\ensuremath{\cat{#1}^{op}}}
\newcommand\cubicalComplexCat{\ensuremath{\square}}
\newcommand\naturalTransf{\ensuremath{\eta}}

\newcommand\valuation{\ensuremath{\mathcal{V}}}
\newcommand\evlist[1]{\ensuremath{\overrightarrow{#1}}}
\newcommand\labelc{\ensuremath{\lambda}}
\newcommand\extends{\ensuremath{\vartriangleright}}
\newcommand\labelH{\ensuremath{l}}
\newcommand\executing{\ensuremath{\frac{1}{2}}}
\newcommand\hystory[1]{\ensuremath{\downarrow\!\!#1}}
\newcommand\concdegup[1]{\ensuremath{|#1|_{uc}}}
\newcommand\concdegdown[1]{\ensuremath{|#1|_{dc}}}
\newcommand\closure[1]{\ensuremath{\mathcal{C}(#1)}}
\newcommand\startUniv[2]{\ensuremath{[\hspace{-2.5px}\{#1\}\hspace{-2.5px}]#2}}
\newcommand\terminateUniv[2]{\ensuremath{[ #1] #2}}
\newcommand\start[2]{\ensuremath{\{#1\}#2}}
\newcommand\terminate[2]{\ensuremath{\langle #1\rangle #2}}
\newcommand\startbackUniv[2]{\ensuremath{\overline{[\hspace{-2.5px}\{#1\}\hspace{-2.5px}]}#2}}
\newcommand\terminatebackUniv[2]{\ensuremath{\overline{[ #1]} #2}}
\newcommand\startback[2]{\ensuremath{\overline{\{#1\}}#2}}
\newcommand\terminateback[2]{\ensuremath{\overline{\langle #1\rangle}#2}}
\newcommand\terminatei[2]{\ensuremath{\langle \rangle^{#1} #2}}
\newcommand\starti[2]{\ensuremath{\{\}^{#1}#2}}
\newcommand\HDML{\ensuremath{\mathit{HDML}}}
\newcommand\hHDML{\ensuremath{\mathit{hHDML}}}
\newcommand\HDA{\ensuremath{\mathit{HDA}}}
\newcommand\HDAs{\ensuremath{\mathit{HDAs}}}
\newcommand\hdamodel[1]{\ensuremath{\mathcal{#1}}}
\newcommand\modelH{\ensuremath{\mathcal{H}}}
\newcommand\CL{\ensuremath{\mathcal{CL}}}
\newcommand\Cmu{\ensuremath{\mathcal{C}\mu}}
\newcommand\CAT{\ensuremath{\mathcal{CAT}}}
\newcommand\CA{\ensuremath{\mathcal{CA}}}
\newcommand\KA{\ensuremath{\mathcal{KA}}}
\newcommand\SKA{\ensuremath{\mathcal{SKA}}}
\newcommand\SKAT{\ensuremath{\mathcal{SKAT}}}
\newcommand\ARCS{\ensuremath{\mathcal{ARCS}}}
\newcommand\DLS{\ensuremath{DLS}}
\newcommand\RT{\ensuremath{\mathcal{RT}}}
\newcommand\RTpruned{\ensuremath{\mathcal{RT}_{pruned}}}
\newcommand\hatIca{\ensuremath{\hat{I}_{\mathcal{A}}}}
\newcommand\hatIcat{\ensuremath{\hat{I}_{\SKAT}}}
\newcommand\hatIIca{\ensuremath{\hat{I}^{-1}_{\mathcal{CA}}}}
\newcommand\Ica{\ensuremath{I}}
\newcommand\Icat{\ensuremath{I_{\SKAT}}}
\newcommand\IIca{\ensuremath{I^{-1}_{\mathcal{CA}}}}
\newcommand\NA{\ensuremath{N}}
\newcommand\TM{\ensuremath{T\NA}}
\newcommand\actEq{\ensuremath{\equiv}}
\newcommand\simnod{\ensuremath{\,\mathcal{S}\,}}
\newcommand\simnodpart{\ensuremath{\,\tilde{\mathcal{S}}\,}}
\newcommand\simnodstrong{\ensuremath{\,\hat{\mathcal{S}}\,}}
\newcommand\simwrtnod[2]{\ensuremath{\,{#1\!}_{#2}\,}}
\newcommand\AD{\ensuremath{\mathcal{A}^{\mathcal{D}}}}
\newcommand\AB{\ensuremath{\mathcal{A}_{B}}}
\newcommand\ABconc{\ensuremath{\mathcal{A}_{B}^{\conc}}}
\newcommand\tests{\ensuremath{\mathcal{A}^{?}}}
\newcommand\basictests{\ensuremath{\mathcal{A}^{?}_{B}}}
\newcommand\abrel{\ensuremath{<_{\conc }^{ab}}}
\newcommand\demrel{\ensuremath{<_{\conc }}}
\newcommand\demreleq{\ensuremath{\leq_{\conc }}}
\newcommand\prefrel{\ensuremath{\mathop{\leq_{+}}}}
\newcommand\eqrel[1]{\ensuremath{\mathop{=_{#1}}}}
\newcommand\unifprob{\ensuremath{\mathop{=^{?}}}}
\newcommand\rewrel[2]{\ensuremath{\mathop{\rightsquigarrow^{#2}_{#1}}}}
\newcommand\narrowrel[3]{\ensuremath{\mathop{\stackrel{#2}{\rightsquigarrow^{#3}}_{#1}}}}
\newcommand\treeisomor{\ensuremath{\mathop{\doteq}}}
\newcommand\conc{\ensuremath{\!\times\!}}
\newcommand\defequal{\ensuremath{\stackrel{\vartriangle}{=}}}
\newcommand\conflict{\ensuremath{\,\#\,}}
\newcommand\concurrel{\ensuremath{\,co\,}}
\newcommand\notconflict{\ensuremath{\,\diagup\hspace{-1.9ex}\#\,}}
\newcommand\notconcurrel{\ensuremath{\,\diagup\hspace{-1.9ex} co\,}}
\newcommand\compat{\ensuremath{\sim_{\mathcal{C}}}}
\newcommand\mazur{\ensuremath{\equiv_{\AB}}}
\newcommand\automtests[1]{\ensuremath{\lceil#1\rceil}}
\newcommand\atomicformulas{\ensuremath{\Phi_{B}}}
\newcommand\formulas{\ensuremath{\Phi}}
\newcommand\limbo{\ensuremath{\varLambda}}
\newcommand\markers{\ensuremath{\Psi}}
\newcommand\obligmark[1]{\ensuremath{\circ_{#1}}}
\newcommand\forbidmark[1]{\ensuremath{\bullet_{#1}}}
\newcommand\constantprops{\ensuremath{\Phi_{B}}}
\newcommand\canf{\textit{canf.}}
\newcommand\chu[2]{\ensuremath{(#1,#2)}}
\newcommand\C{\ensuremath{\mathsf{C}}}
\newcommand\E{\ensuremath{\mathsf{E}}}
\newcommand\allC{\ensuremath{\mathbb{C}}}
\newcommand\ST{\ensuremath{\mathsf{ST}}}
\newcommand\allST{\ensuremath{\mathbb{ST}}}
\newcommand\allHDA{\ensuremath{\mathbb{HDA}}}
\newcommand\STC{\ensuremath{\mathsf{STC}}}
\newcommand\allSTC{\ensuremath{\mathbb{STC}}}
\newcommand\allEv{\ensuremath{\mathbb{E}}}
\newcommand\cancellation{\ensuremath{\times}}
\newcommand\stepTransConfGlabbeek{\ensuremath{\rightarrow_{C}}}
\newcommand\stepTransEvGlabbeek{\ensuremath{\rightarrow_{E}}}
\newcommand\stepST{\ensuremath{\rightarrow_{st}}}
\newcommand\enableRelEv{\ensuremath{\vdash}}
\newcommand\eventRestriction[2]{\ensuremath{#1\!\!\downharpoonright_{#2}}}
\newcommand\concSTC{\ensuremath{||}}
\newcommand\seqSTC{\ensuremath{\cdot}}
\newcommand\choiceSTC{\ensuremath{+}}
\newcommand\emptySTC{\ensuremath{\mathbf{1}}}
\newcommand\finalSTC[1]{\ensuremath{\checkmark(#1)}}
\newcommand\singleE[1]{\ensuremath{\mathbf{#1}}}
\newcommand\frestrict[1]{\ensuremath{\upharpoonright_{#1}}}
\newcommand\reffun{\ensuremath{\mathit{ref}}}
\newcommand\refinement[1]{\ensuremath{\widetilde{#1}}}
\newcommand\isomorphic{\ensuremath{\cong}}
\newcommand\isomorphicHDA{\ensuremath{\cong}}
\newcommand\eventsST[1]{\ensuremath{\mathit{Ev}(#1)}}
\newcommand\parallelSet[1]{\ensuremath{||(#1)}}
\newcommand\pomset[1]{\ensuremath{\mathit{pomset}(#1)}}
\newcommand\stintoh{\ensuremath{\mathsf{H}}}
\newcommand\stintosculpture{\ensuremath{\stintoh^{\mathsf{s}}}}
\newcommand\hintost{\ensuremath{\mathsf{ST}}}
\newcommand\unfolding{\ensuremath{\mathsf{U}}}
\newcommand\equiatingEvents[1]{\ensuremath{\mathsf{Eq}^{#1}}}
\newcommand\sculpintost{\ensuremath{\mathsf{ST}_{\!\mathsf{s}}}}
\newcommand\hintostScultures{\ensuremath{\mathsf{ST}_{\!\mathsf{b}}}}
\newcommand\cintost{\ensuremath{\mathsf{ST}}}
\newcommand\cintostSecond{\ensuremath{\mathsf{ST}_{\hspace{-0.4ex}2}}}
\newcommand\cintostThird{\ensuremath{\mathsf{ST}_{\hspace{-0.4ex}3}}}
\newcommand\stintoc{\ensuremath{\mathsf{C}}}
\newcommand\stintoe{\ensuremath{\mathsf{E}}}
\newcommand\eintost{\ensuremath{\cintost}}
\newcommand\STofC[1]{\ensuremath{\cintostSecond(#1)}}
\newcommand\stEnc{\ensuremath{\ST}}
\newcommand\evEnc{\ensuremath{\mathsf{E}}}
\newcommand{\chuPrat}{\ensuremath{\mathsf{Chu}}}
\newcommand\counit{\ensuremath{\epsilon}}

\newcommand\minFix[2]{\ensuremath{\mu#1.(#2)}}
\newcommand\maxFix[2]{\ensuremath{\nu#1.(#2)}}

\newcommand\restrictedToSet[1]{\ensuremath{\!\!\upharpoonright_{#1}}}
\newcommand\quotientofwrt[2]{\ensuremath{#1\!/\!_{#2}}}
\newcommand\applyChainList[2]{\ensuremath{#1[#2]}}
\newcommand\sculpture[2]{\ensuremath{#1^{#2}}}
\newcommand\alphachain[1]{\ensuremath{\alpha_{#1}}}
\newcommand\embedMorphism{\ensuremath{\mathit{em}}}
\newcommand\finishPath[1]{\ensuremath{\mathit{en}(#1)}}
\newcommand\startPath[1]{\ensuremath{\mathit{st}(#1)}}
\newcommand\eventEquivHDAs{\ensuremath{\stackrel{\mathsf{ev}}{\sim}}}
\newcommand\eventEquivHDAsculpture{\ensuremath{\overset{\mathsf{ev}}{\underset{\mathsf{b}}{\sim}}}}
\newcommand\eventEquivFromBulk[1]{\ensuremath{\underset{\mathsf{#1}}{\sim}}}
\newcommand\chainEquivHDAsculpture{\ensuremath{\overset{\mathsf{c}}{\sim}}}
\newcommand\cellEquivBulk{\ensuremath{\underset{\mathsf{b}}{\sim}}}
\newcommand{\equivClass}[2][]{\ensuremath{[#2]\ifthenelse{\equal{#1}{}}{}{_{#1}}}}
\newcommand\homotopyClass[1]{\ensuremath{\overleftrightarrow{[#1]}}}
\newcommand\adjacentHDA{\ensuremath{\!\stackrel{adj}{\longleftrightarrow}\!}}
\newcommand\ladjacentHDA[1]{\ensuremath{\!\stackrel{#1}{\longleftrightarrow}\!}}
\newcommand\homotopicHDA{\ensuremath{\!\stackrel{hom}{\longleftrightarrow}\!}}
\newcommand\ccequiv{\ensuremath{\stackrel{cc}{\sim}}}
\newcommand\hhequiv{\ensuremath{\stackrel{hh}{\sim}}}
\newcommand\hequiv{\ensuremath{\stackrel{h}{\sim}}}
\newcommand\modalequiv{\ensuremath{\stackrel{\hHDML}{\sim}}}
\newcommand\notmodalequiv{\ensuremath{\stackrel{\hHDML}{\not\sim}}}
\newcommand\concurr{\ensuremath{||}}
\newcommand\causes{\ensuremath{<}}
\newcommand\causeseq{\ensuremath{\leq}}
\newcommand\ststruct{\ensuremath{\ST}}
\newcommand\sttrace[1]{\ensuremath{\mathit{st}(#1)}}
\newcommand\sttraceGlabbeek[1]{\ensuremath{\mathit{st}^{G}(#1)}}
\newcommand\categoryST{\ensuremath{\allST}}
\newcommand\categorySTC{\ensuremath{\allSTC}}
\newcommand\categoryHDA{\ensuremath{\allHDA}}
\newcommand\categoryC{\ensuremath{\allC}}

\newcommand{\transition}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\transitions}[1]{\ensuremath{\xrightarrow[s]{#1}}}
\newcommand{\transitiont}[1]{\ensuremath{\xrightarrow[t]{#1}}}
\newcommand{\transitionUpDown}[2]{\ensuremath{\xrightarrow[#2]{#1}}}
\newcommand{\homotopic}[1]{\ensuremath{\stackrel{#1}{\longleftrightarrow}}}
\newcommand{\maxK}[2]{\ensuremath{N_{max}^{#1,#2}}}
\newcommand{\remK}[2]{\ensuremath{N_{rem}^{#1,#2}}}


\newcommand{\no}[1]{\overline{#1}}
\newcommand{\noa}{\overline{a}}
\newcommand{\nob}{\overline{b}}
\newcommand{\noc}{\overline{c}}

\newcommand{\reduce}{\,\rightarrow\,}
\newcommand{\imply}{\ensuremath{\,\rightarrow\,}}
\newcommand{\equivalent}{\ensuremath{\,\leftrightarrow\,}}
\newcommand{\prove}{\ensuremath{\,\vdash}}
\newcommand{\bottom}{\perp}
\newcommand{\inc}{\sharp}
\newcommand{\diam}[1]{\langle #1 \rangle}
\newcommand\until{\ensuremath{\, \mathcal{U} \,}}
\newcommand\concat{\ensuremath{\widehat{\phantom{i}}}}





\begin{document}




\title{Extensions of Configuration Structures}

\author{Cristian Prisacariu
\institute{Dept. of Informatics, University of Oslo, \ -- \ P.O.\ Box 1080 Blindern, N-0316 Oslo, Norway.}
\email{cristi@ifi.uio.no}
}
\def\titlerunning{Extensions of Configuration Structures}
\def\authorrunning{C.~Prisacariu
}


\maketitle


\begin{abstract}
The present paper defines ST-structures (and an extension of these, called STC-structures). The main purpose is to provide concrete relationships between highly expressive concurrency models coming from two different schools of thought: the higher dimensional automata, a \textit{state-based} approach of Pratt and van Glabbeek; and the configuration structures and (in)pure event structures, an \textit{event-based} approach of van Glabbeek and Plotkin. In this respect we make comparative studies of the expressive power of ST-structures relative to the above models. Moreover, standard notions from other concurrency models are defined for ST(C)-structures, like steps and paths, bisimilarities, and action refinement, and related results are given.
These investigations of ST(C)-structures are intended to provide a better understanding of the \textit{state-event duality} described by Pratt, and also of the (a)cyclic structures of higher dimensional automata.
\end{abstract} 

\tableofcontents


\section{Introduction}\label{sec:intro}






The geometric model of concurrency, studied by Pratt and van Glabbeek \cite{pratt91hda,Pratt00HDArev,Glabbeek06HDA}, is of high expressive power, thus providing a general framework for studying the differences and common features of various other models of concurrency (as done in \cite{Glabbeek06HDA} and \cite{Goubault12Category_Cubical}). This model was named Higher Dimensional Automata (\HDA) by Pratt \cite{pratt91hda}. An attractive aspect of \HDA\ is the automata-like presentation, which emphasizes the \textit{state} aspect of the modeled system (and transitions between states). This aspect is opposed to the event-based models of concurrency, like (prime, flow, (non-)stable) event structures \cite{NielsenPW79eventstructures,BoudolC88flowEventStruct,Winskel86} or configuration structures and (in)pure event structures \cite{GlabbeekP95config,GlabbeekP09configStruct}.

We see the notion of \textit{configuration} (in its various guises \cite{NielsenPW79eventstructures,GlabbeekP09configStruct,HoareMSW11CKA_foundationsJLAP}) as fundamental to event-based models.
The configuration structures, introduced in \cite{GlabbeekP95config}, are a rather general model of concurrency based on sets of events (forming the configurations of the modeled system). A thorough study of the generality and expressiveness of configuration structures is carried out in \cite{GlabbeekP09configStruct} where relations with general forms of event structures are made (where the \textit{pure event structures} are the more well behaved, instances of which are found in the literature).
The configuration structures lend themselves easily to action refinement, as studied in \cite{GlabbeekG01refinement}, which makes them an ideal candidate for incremental development of concurrent systems where the system architect starts with an abstract model which is subsequently refined to more concrete instances.

We are interested in studying such models based on sets of events, but in relation to the state-based model of higher dimensional automata. This study of event-state duality is argued for by Pratt \cite{Pratt02duality}, and the model of Chu spaces has been developed in response \cite{gupta94phd_chu,pratt95chu}. Here we take the challenge of Pratt, with insights from Chu spaces, and develop models based on sets of events, in the spirit of van Glabbeek and Plotkin \cite{GlabbeekP09configStruct}. We call this model \textit{ST-structures}. We investigate the expressiveness and relationships of this new model with the ones we mentioned above  (i.e., with (in)pure event structures and configuration structures of \cite{GlabbeekP09configStruct} and with the triadic event structures, Chu spaces, and \HDA\ of Pratt). 
We also investigate how definitions that one finds for configuration structures are extended to this new setting. 
In particular, we define for ST-structures a hereditary history preserving bisimulation, which in \cite{GlabbeekG01refinement} is the most expressive equivalence presented for configuration structures.
We also investigate the notion of action refinement (and properties of this) for ST-structures.  


We point out shortcomings in the expressiveness of the ST-structures using examples from the literature. We then present an extension with the notion of \textit{cancellation}, advocated by Pratt \cite{Pratt03trans_cancel}. In this extension, called \textit{STC-structures}, we are able to investigate closer the \HDA\ with cycles. This extended model opens the way to tackling the problem posed by Pratt in \cite{Pratt00HDArev} about the expressive power of \HDAs\ with cycles wrt.\ event-based models.






The notion of an ST-configuration  has been used in \cite{GlabbeekV97splitting} to define ST-bisimulation and in \cite{Glabbeek06HDA} in the context of \HDA. But the model of \textit{ST-structures}, as we define here for capturing concurrency, does not appear elsewhere.\footnote{I am thankful for having been made aware of the invited talk of van Glabbeek at CONCUR'99 \cite{Glabbeek99invitedCONCUR} where it is mentioned (at the end of Sec.1) as future work the investigation, on the same lines as the work of \cite{GlabbeekP95config}, of ``translations between arbitrary Petri nets and ST-structures, showing that also these models are equally expressive''; nevertheless, their recent work \cite{GlabbeekP09configStruct} does not present such an investigation yet.} We think that a main characteristic of higher dimensional automata is captured by ST-structures, opposed to the standard configuration structures; this is the power to look at the currently executing concurrent events (not only observe their termination). 
In other words, we can now talk about what happens \emph{during} the concurrent execution of one or more events. This is opposed to standard models that talk only about what happens \emph{after} the execution (which may have duration and complex structure, apparent only after subsequent refinements of an initial abstract model).





\section{ST-structures}\label{sec_st_configs}

We define ST-structures, showing in Section~\ref{subsec_expressST} that they are a natural extension of configuration structures \cite{GlabbeekP09configStruct}, and define related notions that stem from the latter. 
The classical notions of concurrency, causality, and conflict are not interdefinable as in the case of event structures or stable configuration structures; but are more loose, as is the case with \HDAs.
In Section~\ref{subsec_expressST} we relate ST-structures also to \HDAs\ by identifying a corresponding class of ST-structures, i.e., with the particular property of \textit{adjacent-closure}. We also define the class of stable ST-structures and relate this with their counterpart in stable configuration structures. 
We define the (hereditary) history preserving bisimulation in the context of ST-structures, which when \textit{stability} is imposed on adjacent-closed ST-structures it corresponds to the same bisimulation for stable configuration structures. 
In Section~\ref{subsec_actref} we define action refinement for ST-structures and investigate properties of it, like being preserved under the above bisimulation, or that it preserves the properties of the refined ST-structures.



\begin{definition}[ST-configuration]\label{def_STconfig}
An \emph{ST-configuration} is a pair of finite sets  
 of events (i.e., ) 
respecting the property:
\begin{center}
(start before terminate)\ \ .
\end{center}
\end{definition}

Intuitively  contains the events that have \textit{started} and  the events that have \textit{terminated}.
Define the \emph{dimension} of an ST-configuration to be .

\begin{definition}[ST-structures]\label{def_st_structs}
An \emph{ST-configuration structure} (also called \emph{ST-structure}) is a tuple  with  a set of ST-configurations satisfying the \emph{constraint}:

and   a labelling function with  the set of labels.
We often omit the set of events  from the notation when there is no danger of confusion.
\end{definition}

The constraint \refeq{eq_ST_constraint} above is a closure, ensuring that we do not represent events that are started but never terminated. The set of all ST-structures is denoted \allST.


\begin{definition}[stable ST-structures]\label{def_stableST}
An ST-structure  is called:
\begin{enumerate}
 \item\label{def_stableST_rooted} \emph{rooted} iff ;
\item\label{def_stableST_connected} \emph{connected} iff\ \, for any non-empty , either  or ;
\item \emph{closed under bounded unions} iff for any  if  then ;
\item \emph{closed under bounded intersections} iff for  if  then .
\end{enumerate}
An ST-structure is called \emph{stable} iff it is rooted, connected, and closed under bounded unions and intersections.
\end{definition}

ST-structures have a natural \textit{computational interpretation} (on the same lines of configuration structures) as \textit{steps} between ST-configurations, and \textit{paths}. Results below, like Theorem~\ref{th_configtoSTsteps}, show that this computational interpretation is more fine-grained than for  other models we compare with. 
Intuitively, opposed to standard event-based models, the computational interpretation of ST-structures naturally captures the ``during'' aspect of the events, i.e., what happens while an event is executing (before it has finished). Action refinement and bisimulation are well behaved wrt.\ this interpretation. The model of \HDAs\ do the same job but in the state-based setting.
Besides, ST-structures exhibit a natural \textit{observable information} (on the same lines as for \HDAs) as \textit{ST-traces}, which, cf.~\cite[Sec.7.3]{Glabbeek06HDA}, constitute the best formalization of observable content.


\begin{definition}[ST steps]\label{def_STsteps}
A step between two ST-configurations is defined as either:
\begin{description}
\item[s-step]  when , ,  and ; or
\item[t-step]  when , ,  and .
\end{description}
When the type is unimportant we denote a step by \,  \, for \, .
\end{definition}



\begin{definition}[paths and traces]\label{def_pathstrace}
A \emph{path} of an ST-structure, denoted , is a sequence of steps, where the end of one is the beginning of the next, i.e.,

A path is \emph{rooted} if it starts in .\footnote{We generally work with rooted paths.}
The \emph{ST-trace of a rooted path }, denoted , is the sequence of labels of the steps of  where each label is annotated as  if it labels an s-step or as  if it labels a t-step, where  is determined by counting the number of steps until the s-step that has added the event  to the  set, with  being the event that has been added to  in the current t-step.
\end{definition}

For rooted and connected ST-structures the notion of \emph{ST-trace} conforms with the one defined in \cite[def.2.5]{GlabbeekV97splitting} or \cite[sec.7.3]{Glabbeek06HDA}.

\cp{
\begin{proposition}\label{prop_STtrace}
For a rooted and connected \ststruct\ and a path , the notion of \emph{ST-trace}  
conforms with
the one defined in \cite[def.2.5]{GlabbeekV97splitting} or \cite[sec.7.3]{Glabbeek06HDA}.
\end{proposition}


\begin{proof}
The correspondence that the proposition asserts is based on the correspondence between the respective formalisms in the following sense. Take from \cite[sec.7.3]{Glabbeek06HDA} the definition of ST-trace for higher dimensional automata and take the class of acyclic and non-degenerate \HDAs. The proposition then asserts a correspondence between the definitions of ST-trace in \cite[sec.7.3]{Glabbeek06HDA} for this class and the definition of ST-trace for ST-structures that are rooted, connected and adjacent-free; i.e., . I have denoted by  the function of \cite[sec.7.3]{Glabbeek06HDA} for returning an ST-trace for paths in higher dimensional automata.

The function  is defined on paths  and returning values in , i.e., sequences of labels annotated with natural numbers.
\cp{Finish up this proof and connect it with the pomsets definition also, not only with the HDA.}
\end{proof}
}

\cp{
We can define for ST-structures the notion of \textit{ST-trace equivalence} \cite{GlabbeekV97splitting} and \textit{ST-bisimulation} \cite{Glabbeek06HDA} and investigate if these are preserved by action refinement (not done in this paper though).

\begin{definition}[ST-trace equivalence]\label{def_ST_equiv}
Two ST-structures are ST-trace equivalent iff\ \ they have the same set of ST-traces.
\end{definition}
}

\begin{proposition}[connectedness through paths]\label{prop_connectPaths}\ 
\begin{enumerate}
\item\label{prop_connectPaths_1} For a rooted ST-structure  the following are equivalent:
\begin{enumerate}
\item\label{prop_connectPaths_1a} \ST\ is connected;
\item\label{prop_connectPaths_1b} For any  there exists a rooted path ending in .
\end{enumerate}
\item\label{prop_connectPaths_2} For a rooted  that is closed under bounded unions the following are equivalent:
\begin{enumerate}
\item\label{prop_connectPaths_2a} \ST\ is connected;
\item\label{prop_connectPaths_2b} For any two ST-configurations s.t.\ , there exists a path starting in  and ending in .
\end{enumerate}
\end{enumerate}
\end{proposition}

\begin{proof}
To prove the implication (\ref{prop_connectPaths_1a})(\ref{prop_connectPaths_1b}) use induction on the dimension of  applying subsequently to smaller ST-configurations the connectedness property of Definition~\ref{def_stableST}.\ref{def_stableST_connected}.

To prove the implication (\ref{prop_connectPaths_1b})(\ref{prop_connectPaths_1a}) is easier by using the definition of a path which implies the connectedness Definition~\ref{def_stableST}.\ref{def_stableST_connected}.

The proof of (\ref{prop_connectPaths_2a})(\ref{prop_connectPaths_2b}) makes unions of the ST-configurations on the two rooted paths corresponding to  respectively . Since the paths evolve through simple steps (i.e., which remove one event at a time) and since  includes  we slowly reach configurations that include events not part of . Union with these intermediate configurations will make up the configurations on the path we are looking for.

To prove the implication (\ref{prop_connectPaths_2b})(\ref{prop_connectPaths_2a}) observe that (\ref{prop_connectPaths_2b}) implies (\ref{prop_connectPaths_1b}).
\end{proof}

\begin{proposition}\label{prop_pathsEqualLength}
For any ST-configuration , all the rooted paths ending in   have the same length.
\end{proposition}

\begin{proof}
Each single step adds one single new event to either the  or the  sets. Therefore, since the number of events in the goal ST-configuration  is fixed, no matter the order of adding these events, there will be the same number of steps, or event addition operations, that can be performed from the root.
\end{proof}


\begin{definition}[concurrency and causality]\label{def_ConcCausal}\ 

For a particular ST-configuration  define the relations of \emph{concurrency} and \emph{causality} on the events in  as:
\begin{description}
\item[concurrency] for  then  iff \, exists  s.t.\  and ;
\item[causality] for  then  iff \,  and for any  s.t.\ , is the case that .
 \end{description}
\end{definition}

ST-structures represent \textit{concurrency} in a way that is different than other event-based models in the sense that each ST-configuration gives information about the currently concurrent events, and this information is persistent throughout the whole execution.
Two events are considered concurrent wrt.\ a particular ST-configuration if and only if at some point in the past (i.e., in some sub-configuration) both events appeared as executing (i.e., in ) and none was terminated yet (i.e., not in ); they were both executing concurrently.
In event structures or configuration structures in order to decide whether two events are concurrent one needs to look at many configurations or many events to decide this. For example, in event structures the concurrency is defined as not being dependent nor conflicting; which requires to inspect all configurations to decide.
An ST-configuration does not give complete information about the concurrency relation in the whole system. In consequence one could view the information about concurrency that an ST-configuration provides as being sound but not complete.

The above two notions of concurrency and causality are defined for one particular ST-configura\-tion; in consequence one could emphasize this by indexing the relation symbol by the particular ST-configuration (similar to what is done in \cite[Sec.5.3]{GlabbeekG01refinement}), but the aesthetics would not be so nice in our case.
The above two notions are lifted naturally to the whole ST-structure.

An event \textit{ is a cause of } 
iff in all the past  is never started without  having terminated. In other words, whenever in the past the event  is to be started (i.e., ), the event  on which it depends must have terminated already (i.e., ).

This is a specific notion of causality, that comes from the tradition of viewing causality as a partial order (in fact this definition makes a partial order only when the structure is rooted and connected). The definition of event structures from \cite{GlabbeekP09configStruct} define a \textit{dependency relation} that can characterize \textit{conjunctive causality} in the sense that one event depends on several events (i.e., not a binary relation any more). Besides this (rather common) causality as dependency, there is a notion of \textit{disjunctive causality} which is nicely exemplified by the ``parallel switch of Winskel'' (see Example~\ref{ex_Winskel_switch_resolved_conflict} and Figure~\ref{fig_ex_winskel} on page~\pageref{fig_ex_winskel}) where an event  is caused by either of the two events  or  having happened.

On arbitrary ST-structures the concurrency and causality are not interdefinable (in a standard way e.g.\ \cite[Def.5.6]{GlabbeekG01refinement} where concurrency is the negation of causality). Nevertheless, concurrency and causality are disjoint on every ST-configuration of an arbitrary ST-structure.
For the more well behaved stable ST-structures the concurrency and causality are interdefinable. Even more, results similar to the ones in \cite[Sec.5.3]{GlabbeekG01refinement} can be stated and proven about stable ST-structures and their causality partial order.




\begin{proposition}\label{prop_concDisjCausal}
On arbitrary ST-structures 
\begin{enumerate}
\item concurrency and causality are \emph{disjoint};
\item concurrency and causality are \emph{not interdefinable} (in a standard way e.g.\ \cite[Def.5.6]{GlabbeekG01refinement} where concurrency is the negation of causality).
\end{enumerate}
\end{proposition}

\begin{proof}
The counterexample for the second part of the proposition consists of the empty square from Figure~\ref{fig_ex_hda}(middle-right) 

with the upper right ST-configuration . For this configuration the two events  and  are not causal in any order, because of the existence of the two ST-configurations  and . The two events  and  are neither concurrent, because the ST-configuration  is missing. Moreover, the two events are not conflicting in the sense of the Definition~\ref{def_conflict}.

This counterexample clearly shows how \HDAs\ and ST-structures model a notion that is eluding the standard notions of causality, concurrency, or conflict. I would call this notion \textit{interleaving} (i.e., events  and  are interleaving) and in such models, using this example, interleaving is thus different than concurrency, i.e., making it a standalone notion. The empty square of Pratt proves once again very good at exemplifying true concurrency, and the ST-structures and the above notions, only use it in a new light.

To show disjointness one can notice that if two events are concurrent then they cannot be causally depended in any order. The witnessing ST-configuration is exactly the configuration that witnesses the concurrency, i.e., the  with . This configuration breaks the  because  and ; and analogous for .
\end{proof}



\begin{proposition}\label{prop_concCausalStable}
Let \ST\ be a \emph{stable} ST-structure. For some  and two events  we have: 

\centerline{ if not .}
\end{proposition}


\begin{proof}
Knowing that  and  we show the existence of some ST-configuration  for which , hence that .

The two assumptions are equivalent to 
\begin{itemize}
\item ; and
\item .
\end{itemize}
From the fact that \ST\ is connected and closed under bounded unions, using Proposition~\ref{prop_connectPaths} we know that  and . This means that from  we can reach a configuration  where  contains both  but still . The same for some  s.t.\  and . This implies that , and that  and . Because \ST\ is closed under bounded intersections it means that we have found  which is an ST-configuration of \ST\ that is included in the original  and which satisfies .
\end{proof}


The notion of conflicting events is not definable for a specific ST-configuration because it is a general notion definable only on the whole ST-structure. Essentially, conflicting events can never appear in the same configuration.

\begin{definition}[conflict]\label{def_conflict}
For an ST-structure  the notion of \emph{global conflict} is defined as a predicate over sets of events : 

\centerline{\,\ iff\ \, with .}
\end{definition}

The standard notion of binary conflict is an instance of the above, where .
Moreover, a particular ST-configuration cannot contain conflicting events.


\begin{proposition}[partial order causality]\label{prop_partialOrderCausality}
The causality relation of Definition~\ref{def_ConcCausal} when extended with equality is a partial order iff the ST-structure \ST\ from which the ST-configuration  on which \causes\ is defined, is rooted and connected.
\end{proposition}

\begin{proof}
Extend the causality relation with equality by defining .

Clearly \causeseq\ is reflexive.

To prove that \causeseq\ is transitive take three events  and show . The proof is immediate when any two of the three events are equal. Thus work with the assumption . By applying two times Definition~\ref{def_ConcCausal} we have that  a ST-configuration of \ST\ then ; thus having the desired result.

To prove antisymmetry assume  and . Applying two times the Definition~\ref{def_ConcCausal} we get that  a ST-configuration of \ST\ . But this contradicts that fact that \ST\ is rooted and connected, which implies that there is a rooted path to . Hence this path coming from the root through single steps must necessarily pass through an ST-configuration that has  started by not terminated.
\end{proof}



We can define a notion of equivalence that extends that of pomset-trace equivalence of \cite{GlabbeekV97splitting,GlabbeekG01refinement} to the setting of general ST-structures. This notion of equivalence, when interpreted over stable ST-structures becomes exactly the pomset-trace equivalence of \cite{GlabbeekG01refinement}.

\begin{definition}[cc-equivalence]\label{def_cc_equiv}
For an ST-configuration  of some \ST\ define:
\begin{itemize}
\item the \emph{pomset} as  the isomorphism class of the set  where the causal relation  of  is preserved and the labeling function of the ST-structure \ST\ is restricted to .

\item the \emph{parallel set} as .
\end{itemize}
Two ST-configurations are cc-equivalent, written , iff

\centerline{ and .}

\noindent We say that one ST-structure \ST\ cc-simulates another  iff\ \ . Two structures are cc-equivalent, written  iff\ \ they cc-simulate each other.
\end{definition}


\begin{definition}[adjacent-closure]\label{def_adj_ST}
We call an ST-structure \ststruct\ \emph{adja\-cent-closed} if the following are respected:
\begin{enumerate}
  \item if , with , then ;
  \item if , with , then ;
\item if , then ;
  \item if , with , then .
\end{enumerate}
\end{definition}

Anticipating the definition of higher dimensional automata (see \cite{pratt91hda,Pratt00HDArev,Glabbeek06HDA} and the Definition~\ref{def_hda} on page~\pageref{def_hda}) one can see a correlation of the above definition of adjacent-closure on ST-structures and the cubical laws of higher dimensional automata. This correlation is even more visible in the definition of \textit{adjacency} of \cite[Def.19]{Glabbeek06HDA} which is used to define homotopy over higher dimensional automata (see Definition~\ref{def_history_HDA} on page~\pageref{def_history_HDA}). Since homotopy classes essentially define histories, then the above adjacent-closure on ST-structures intuitively makes sure that the histories of ST-configurations are not missing anything.



\begin{definition}[closure under single events]\label{def_closeSingleEv}
An ST-structure \ststruct\ is called \emph{closed under single events} 
iff 
\begin{enumerate}
\item  and
\item .
\end{enumerate}
\end{definition}


\begin{proposition}[equivalent with adjacent-closure]\label{prop_adj_equiv}
A rooted and connected ST-con\-figuration structure 


\centerline{is closed under single events\ \ iff\ \ is adjacent-closed.}
\end{proposition}

\begin{proof}
The left-to-right implication is simple. For the first condition in Def.~\ref{def_adj_ST} use the second restriction of this proposition. For the second condition we may use any of the two restrictions, as we know that .  For the third and forth condition use the first restriction, knowing that .

The right-to-left implication is more involved.

We first use induction on the reachability path to show that: 
\begin{itemize}
\item[] for every ST-configuration  with  then all the immediately lower ST-configurations that can reach  through an s-step exist in \ststruct, i.e., 

\end{itemize}
This would prove the second requirement for closure under single events.

Since the ST-structure that we work with is rooted and connected, then every ST-configuration is reachable from the root  through a series of single steps, i.e., through a rooted path, cf.\ Proposition~\ref{prop_connectPaths}. 


Because of Proposition~\ref{prop_pathsEqualLength} we can use induction on the reachability path, because there exists at least one such path, and any other path has the same distance.

\textit{Base step:} is for reachability paths of distance . This means when ; trivial.

For the \textit{Induction case} use the proof principle \textit{reductio ad absurdum} and assume for some  the ST-configuration . From connectedness we know that   is reachable through either an s- or a t-step from an ST-configuration that has lower reachability distance.

Assume that  is reachable through an s-step, thus  s.t\  and . Since  we may apply the induction hypothesis to  to get that . We now can apply the first adjacent-closure requirement of Definition~\ref{def_adj_ST} to get that , which is a contradiction.

Assume now that no s-steps are possible, and thus only a t-step is possible from some  with , hence . By applying the induction hypothesis to  we get that , since . We can now apply the second condition for adjacent-closure to get that , which is a contradiction.

It remains to show that the first requirement of closure under single events is satisfied.
Thus, for some arbitrary  we use induction on the dimension of  to show that 

We could also use induction on the reachability path (as before).

\textit{Base step} is for , i.e., when  for some . By the definition of ST-structures we have that for our  there also exists .

For the inductive case, i.e., when  distinct, we know from the previous step of the proof that for all  we have . Pick one of these which is different than , as at least one exists . Since  is smaller than the initial  we can apply the induction hypothesis to obtain that for  we have . We may now apply the third requirement in the definition of adjacent-closure to obtain that also .
\end{proof}



One may assume to work with rooted and connected structures, not only because these are natural, but also because we can obtain them using the notion of \textit{reachability}.



\begin{definition}[reachable part]\label{def_reachability}
An ST-configuration  is said to be \emph{reachable} iff there exists a rooted path ending in . The \emph{reachable part} of some arbitrary ST-structure is formed of all and only the reachable configurations. 
\end{definition}

The reachable part of a structure is connected, cf.~Prop.~\ref{prop_connectPaths}.\ref{prop_connectPaths_1}. Therefore, assuming connectedness is the same as assuming to work with the reachable part of a structure. 



\begin{definition}[morphisms of ST-structures]\label{def_morphism_ST}
A \emph{morphism}  between two ST-structures  and  with the sets of events as in Definition~\ref{def_st_structs}, is defined as a partial function on the events  which: 
\begin{itemize}
\item 
preserve ST-configurations, if  then ,
\item 
preserve the labeling when defined, i.e.,  if  is defined for , and 
\item
are locally injective, i.e., for any  the restriction  is injective.
\end{itemize}
\end{definition}

Note that if  then .

\begin{proposition}
The morphisms of Definition~\ref{def_morphism_ST} preserve steps.
\end{proposition}

\begin{proof}
We prove that for a step  then  can make an s-step with the event  into the corresponding ST-configuration . Since  then  is also a configuration in  and thus  is defined for . Since  (by definition of an s-step) it means that  is different than any other event  from , and by the injective property of  it means that . Moreover, the label is preserved. Therefore we have the s-step in  with the same label and the corresponding event, .
\end{proof}

We can define a \textit{category \categoryST} to have objects ST-structures and the morphisms from Definition~\ref{def_morphism_ST} because composition of morphism is well defined and for any ST-structure there exists a unique identity morphism which is the total function taking an event to itself.

\begin{definition}[isomorphic ST-structures]\label{def_isomorphism}
A function  is an \emph{isomorphism} of two ST-configurations \,\ iff\,\  is an isomorphism of  and  that agrees on the sets  and  (i.e., ).
Two ST-structures  and  are isomorphic, denoted , iff there exists a bijection  on their events that is also a morphism between the two ST-structures; in particular,  takes an ST-configuration into an isomorphic ST-configuration, and agrees on the labeling.
\end{definition}


\begin{definition}[hh-bisimulation for ST-structures]\label{def_hh_ST}\ 

For two ST-structures  and , a relation  is called a history preserving bisimulation between  and  iff  and whenever 

\begin{enumerate}
\item  is an isomorphism between  and ; and
\item if  then exists  and  extending  (i.e., ) with  and  ; and
\item if  in  then exists  and  extending  with  and .
\end{enumerate}
 is moreover called \emph{hereditary} if the following back condition holds:
\begin{enumerate}
\setcounter{enumi}{3}
\item if  in  then exists  and  with  and  and  .
\item if  in  then exists  and  with ) and  and  .
\end{enumerate}
A history preserving bisimulation between two ST-structures is denoted , and a hereditary one is denoted . We usually abbreviate to hh-bisimulation.
\end{definition}

Because of symmetry of the requirements for history preserving bisimulation (i.e., the points 2 and 3 above), the two conditions for hereditary are redundant together, and we could well use only one of them. In our proofs we will consider only condition 4.



\begin{figure}[tp]
\psfrag{ee}{{\scriptsize  }}
\psfrag{ae}{{\scriptsize }}
\psfrag{be}{{\scriptsize }}
\psfrag{0e}{{\scriptsize }}
\psfrag{1e}{{\scriptsize }}
\psfrag{01e}{{\scriptsize }}
\psfrag{00}{{\scriptsize }}
\psfrag{010}{{\scriptsize }}
\psfrag{0101}{{\scriptsize }}
\psfrag{011}{{\scriptsize }}
\psfrag{11}{{\scriptsize }}
\psfrag{b11}{{\scriptsize }}
\psfrag{b1b1}{{\scriptsize }}
\psfrag{b01b1}{{\scriptsize }}
\psfrag{b0101}{{\scriptsize }}
\psfrag{b010}{{\scriptsize }}
\psfrag{b01b0}{{\scriptsize }}
\psfrag{b01b01}{{\scriptsize }}
\psfrag{b011}{{\scriptsize }}
\psfrag{b00}{{\scriptsize }}
\psfrag{b0b0}{{\scriptsize }}
\psfrag{b}{{\scriptsize }}
\psfrag{a}{{\scriptsize }}
\psfrag{c}{{\scriptsize }}
\psfrag{bc0}{{\scriptsize }}
\psfrag{ac0}{{\scriptsize }}
\psfrag{s}{{\scriptsize }}
\psfrag{t}{{\scriptsize }}
\psfrag{E}{{}}
\psfrag{F}{{}}
\begin{center}
    \includegraphics[height=4.5cm]{figures/figure3}
  \end{center}
\caption{ST-structures (and acyclic \HDAs) representing, on the left, the ``parallel switch'' of Winskel \cite[Ex.1.1.7]{Winskel86} (not closed under intersections) and, on the right, the ``resolved conflict'' of \cite[Ex.2]{GlabbeekP09configStruct} (not closed under unions).}
\label{fig_ex_winskel}
\end{figure}

\begin{example}\label{ex_Winskel_switch_resolved_conflict}
The parallel switch of Winskel \cite[Ex.1.1.7]{Winskel86} consists of an event  (lighting a light bulb) that depends on either of the two parallel switches being closed (i.e., the two events  and ). This example emphasizes \textit{disjoint causality}, where event  depends on either  or , and hence the fact that there is no \textit{unique causal history}, as opposed to \textit{stable structures}.
The ST-structure for this example, in Figure~\ref{fig_ex_winskel}(left and middle), is adjacent-closed and closed under unions, but not closed under intersections, i.e., the ST-configurations  but . 

The resolved conflict of \cite[Ex.2]{GlabbeekP09configStruct}, pictured in Figure~\ref{fig_ex_winskel}(right), represents the fact that the initial conflict of the two actions  and  is resolved as soon as the action  has finished (i.e.,  and  may run concurrently as soon as  has finished). The corresponding ST-structure of Figure~\ref{fig_ex_winskel}(right) is adjacent-closed and closed under intersections but not closed under unions:  .
Both examples can be pictured as three sides of a \HDA\ cube (middle and right) whereas on (left) is an ST-structure. In several cases we use the more clean \HDA\ presentation for ST-structures because of the results below (see the Definition~\ref{def_hda} of a \HDA).
The standard example of a square with the empty inside, as pictured in Fig.~\ref{fig_ex_hda}(middle-right) on page~\pageref{fig_ex_hda}, is adjacent-closed but not closed under unions nor under intersections.
\end{example}


\begin{example}\label{ex_not_adjacent_stable}
For an example of ST-structure that is not adjacent-closed but is stable take the example of the filled square of  but where the triangle above the diagonal is removed as in Fig.~\ref{fig_ex_hda}(right) on page~\pageref{fig_ex_hda}. Intuitively, this models a system where both  and  may run concurrently but  is always faster than  (hence starts and also terminates first); in other words  cannot start before  has started and cannot finish before  has finished. 
The event  may be a resource allocation mechanism that  may need for running, and thus  must be running when  can start. But  may run concurrently with , e.g., while  finishes all the resource allocation work (like logging or lock setting). Nevertheless,  must wait for all this resource allocation work to properly finish (having all logging in place, etc.) before itself can finish (and maybe do some more logging and lock releasing).
\end{example}

These examples lead to the results in the next section where we isolate the class of ST-structures that corresponds to a popular class of \HDAs, that of acyclic and non-degenerate \HDAs, which are expressive enough to faithfully represent the various examples used in papers like \cite{GlabbeekV97splitting,GlabbeekG01refinement,BaldanC10concur,phillips11express} which studied bisimulations for true concurrency. Nevertheless, towards the end of this paper we give examples that challenge the expressiveness of this class of \HDAs\ (and ST-structures also), and thus justify an extension which we will call \textit{STC-structures} in Section~\ref{sec_STCstruct}. 



\section{Expressiveness of ST-structures and correspondences}\label{subsec_expressST}



\subsection{Correspondence with configuration structures}\label{subsec_configStruct}

We investigate the relationship of ST-structures with the configuration structures of \cite{GlabbeekP95config,GlabbeekP09configStruct} and show that ST-structures are a natural extension of the later. This extension also holds when their respective computational aspects are considered, i.e., the concurrent step interpretations are related.

\begin{definition}[{cf.~\cite[Def.5.1]{GlabbeekG01refinement}\cite[Def.1.1]{GlabbeekP09configStruct}}]\label{def_configurationStruct}\ 

A \textit{configuration structure} , is formed of a set  of \textit{events} and a set of configurations which are subsets of events . A \emph{labeled} configuration structure also has a labeling function of its events, .
\end{definition}


\begin{definition}[\allC\ to\ \allST]\label{def_confInST}
Define a mapping  that associates to every configuration structure \C\ an ST-structure  as follows.
Associate to each configuration  an ST-configuration . No other ST-configurations are part of . 
The labeling function is just copied.
\end{definition}

\begin{definition}[morphisms for \allC]\label{def_morphisms_C}
A \emph{morphism} between two labeled configuration structures  and  is a partial map  between their events that: 
\vspace{-1ex}\begin{itemize}
\item 
preserves the configurations; i.e., if  then ,
\item 
preserves the labeling when defined, i.e.,  if  is defined for , and 
\item
is locally injective, i.e., for any  the restriction  is injective.
\end{itemize} 
Two configurations structures are called \emph{isomorphic}, denoted , iff there exists a morphism  that is bijective on the events.
\end{definition}

The set of labeled configurations together with the morphisms form a category, which we will denote the same \allC.

\begin{proposition}\label{prop_functorExtension_cintost}
The mapping \cintost\ can be extended to a functor between the categories \allC\ and \allST\ by defining its application on the morphisms as .
\end{proposition}

\begin{proof}
The application of \cintost\ to morphisms is correct because for some configuration  the events are preserved through the mapping . Therefore for some morphism  the morphism  is well defined from the events of  to the events of .

The proof that  preserves ST-configurations and the labeling, and is local injective, follows from the same properties of the morphism  on the configuration structures.
\end{proof}



\begin{proposition}[\cintost\ is embedding]\label{prop_embeding_CtoST}
\ 

\begin{enumerate}
\item The map \cintost\ from Definition~\ref{def_confInST} preserves isomorphic configuration structures and does not identify non-isomorphic configuration structures.

\item There are ST-structures that are not the image of any configuration structure.
\end{enumerate}
\end{proposition}

\begin{proof}
The categorical claim that the functor  between the two categories \allC\ and \allST\ is embedding can be seen from the fact that the morphisms between two configuration structures are the same as those between their associated ST-structures. More precisely, for any two configuration structures the function  that associates to each morphism  the morphism  is bijective. Injectivity is easy to see since for two different morphisms  between  and  the function  associates the morphisms  and , which following the definition from Proposition~\ref{prop_functorExtension_cintost} are different. For surjectivity one has to check that for any morphisms  between  and , which is a partial map between their events, the same partial map between the events of  and  also respects the conditions of being a morphism in \allC.

To show that \cintost\ preserves isomorphic configuration structures consider the bijective morphism  that witnesses the isomorphism of  and . This same function between the events of  and  is also a bijection and a morphism between the two ST-structures. Checking that  preserves ST-configurations, the labeling, and is local injective is easy based on its properties on the configuration structures.

To show that non-isomorphic configuration structures are not identified by \cintost\ for some arbitrary  assume that there exists a bijective morphisms  witnessing the isomorphism of their translations . It is easy to show that this same function between the events of  and  makes these isomorphic as it preserves configurations, the labeling and is locally injective.

For the part (2) of the proposition just take any ST-structure that has ST-configurations of concurrency degree non-zero; these are not the image through the \cintost\ in Definition~\ref{def_confInST} of any configuration structure.
\end{proof}

\begin{definition}[\allST\ to\ \allC]\label{def_STtoC}
Define a mapping  that associates to every ST-structure  a configuration structure by keeping only those ST-configu\-rations that have ; i.e., , which preserves the labeling.
\end{definition}



\begin{proposition}\label{prop_ST_config_connect}
If an ST-structure  is rooted, connected, or closed under bounded unions, or intersections, then the corresponding  is respectively rooted, connected, closed under bounded unions, or intersections.
\end{proposition}

\begin{proof}
A configuration structure is rooted if it contains the configuration . The definitions of bounded union and intersection for configuration structures are the natural simplification of the respective definitions for ST-structures from Definition~\ref{def_stableST}. Proving the rootedness and closure properties is immediate. 
A configuration structure is connected (cf.\ \cite[Def.5.5]{GlabbeekG01refinement}) if for every configuration  exists an event  s.t.\  is also a configuration in the structure. For connectedness note that any connected ST-structure is also rooted (and the same holds for configuration structures). Therefore, for any configuration  there exists the ST-configuration  from which it was obtained. Since  is connected it means that there is a sequence of ST-configurations, each one event smaller than the previous, which reach the root . This means that on this sequence there must eventually be an ST-configuration  with . By the constraint of the ST-structures it means that also the ST-configuration  and therefore also the configuration .
\cp{!!Do this proof with the weaker constraint, so the last line needs redoing.}
\end{proof}



But there is not a one to one correspondence between ST-structures and the configuration structures because there can be several ST-structures that have the same configuration structure. The example is of one \HDA\ square that is filled in and one that is not; both have the same set of corners and hence the same configuration structure. But the two ST-structures are not isomorphic and also not hh-bisimilar (in the sense of Definition~\ref{def_hh_ST}).


\begin{proposition}[\stintoc\ is forgetful]\label{prop_forget_STtoC}
\ 

\begin{enumerate}
\item The map \stintoc\ from Definition~\ref{def_STtoC} preserves isomorphic ST-structures. 

\item The map \stintoc\ may identify non-isomorphic ST-structures (in fact non-hh-bisimilar).
\end{enumerate}
\end{proposition}

\begin{proof}
The part (1) is proven easily, similar to what we did for Proposition~\ref{prop_embeding_CtoST}.

For part (2) take the empty square and the filled-in concurrency square examples. These two are translated in the same configuration structure; i.e., their corners only. But as ST-structures these two examples are not isomorphic and neither hh-bisimiar.
\end{proof}



Next we show that the \textit{asynchronous concurrent step interpretation} of configuration structures is captured by ST-structures (cf.~\cite[Def.2.1]{GlabbeekP09configStruct}, an asynchronous step is defined between two configurations  iff  and ).

\begin{lemma}\label{lemma_morph_preserve_steps}
\ 

\begin{enumerate}
\item\label{lemma_morph_preserve_steps_1} Morphisms of \allC\ preserve asynchronous concurrent steps. 

\item\label{lemma_morph_preserve_steps_2} Morphisms of \allST\ preserve (s-/t-)steps.
\end{enumerate}
\end{lemma}

\begin{proof}
For part \refeq{lemma_morph_preserve_steps_1} we take an arbitrary  and an arbitrary step  and show that . The definition of an asynchronous step says that  which by the local injectivity of  it means that . Moreover, the injectivity on the larger set  makes  bijective between  and  which means that any subset of  is the image of some subset of . The asynchronous step says that all subsets  are configurations  and since  preserves configurations it means that . These are all possible subsets , therefore we have the expected step .

The proof of part \refeq{lemma_morph_preserve_steps_2} is easy since the steps in ST-structures involve single events. The proof again uses the fact that the morphisms are locally injective.
\end{proof}



\begin{theorem}\label{th_configtoSTsteps}
Define a mapping  by extending the one in Definition~\ref{def_confInST} s.t.\ for each asynchronous step  add also an ST-configuration .
This map \cintostSecond\ preserves the asynchronous concurrent steps of the configuration structure, i.e., for each asynchronous step  there is a chain of single steps in the ST-structure  that passes through  (thus signifying the concurrent execution of all events in ).
\end{theorem}

\begin{proof}
Take  to be some configuration structure and  the corresponding ST-structure that we construct for it.
The construction extends the simple encoding from before which associated with each configuration  an ST-configuration . 
The function \STofC{.}\ is applied to the configurations of \C\ and does not introduce new events. Thus the labeling of the structures is just copied.

We show that for any  we have  in . We do this using induction on the number of concurrent events in the concurrent step between the configurations. 

The base case is for  (we ignore the reflexive steps that are assumed for each configuration in \cite{GlabbeekP09configStruct}).
Essentially, in terms of \HDAs, the \cintostSecond\ adds also the transition between the two states of the \HDA. 
In  we have one s-step from  to  and one t-step from  to , where  as .

Take , thus . 
We use the property of asynchronous steps in configuration structures from \cite[Def.2.1]{GlabbeekP09configStruct} which says that if  then . This also implies that there are asynchronous steps from  and , and both have fewer number of concurrent events. 
We can apply the inductive hypothesis in the following two instances:
(1) ; and (2) . From (1) we get the chain of single steps . Since  was added by  we have . By the induction hypothesis on (2) we have . 
Because  and  we have also the transition .
Thus we have the conclusion that there exists the chain of single steps  that passes through .

Intuitively, thinking in terms of acyclic \HDAs, for each transition  we build the \HDA\ cube of dimension  with all the faces filled in.
\end{proof}


\begin{corollary}\label{cor_adjacent}
An ST-structure  generated as in Theorem~\ref{th_configtoSTsteps} is adja\-cent-closed (though not necessarily closed under bounded unions nor intersections).
\end{corollary}

\begin{proof}
Since we work with rooted configurations structures, the \cintostSecond\ function clearly preserves rootedness.

From a connected configuration structure for any sequence of transitions  we find a sequence of single steps in the associated ST-structure. This is easy to see from Theorem~\ref{th_configtoSTsteps}. Each individual transition has a corresponding sequence of single steps in the ST-structure.

From the proof of Theorem~\ref{th_configtoSTsteps} we see that an ST-configuration  with , is introduced only when there is a concurrent transition between the configurations  and . With this observation it is easy to prove the four adjacency restrictions. Take as example the first restriction (leaving the others as exercise) and infer from  that there is the transition  and thus from the \cite[Def.2.1]{GlabbeekP09configStruct} it means that  then  is also a configuration. Also we have  and . To prove that  it is enough to show that there is a transition . This is easy from the definition \cite[Def.2.1]{GlabbeekP09configStruct} and the fact that .

It is easy to check that the parallel switch of Winskel \cite{Winskel86} (not closed under bounded intersections) and the resolved conflict example of \cite[Ex.2]{GlabbeekP09configStruct} (not closed under bounded unions) are expressible as configuration structures.
\end{proof}



\begin{corollary}\label{cor_counit_C_ST}
In an ST-structure  generated as in Theorem~\ref{th_configtoSTsteps} the ST-con\-figurations with  correspond exactly to the configurations of . That is to say that .
\end{corollary}

\cp{The above equivalence should also be proven as an adjunction between the two categories.}

One can now check that the map \stintoc\ can be lifted to a functor between \allST\ and \allC\ the same as we did in Proposition~\ref{prop_functorExtension_cintost}.

\begin{proposition}
The new map \cintostSecond\ from Theorem~\ref{th_configtoSTsteps} can be lifted to a functor by defining its application on morphisms to be . This is the right adjoint to the functor \stintoc.
\end{proposition}

\begin{proof}
Translating configuration structures into ST-structures does not change the set of events nor the labeling function, therefore it is easy to see that  preserves the labeling.

To show that  preserves the ST-configurations consider some  and take two cases cf.\ the definition of \cintostSecond\ from Theorem~\ref{th_configtoSTsteps}.

Case when  which means that  is a configuration, and since  preserves configurations it means that  and thus we have the desired result that , i.e., .

Case when  means that  comes from a transition . This means that  are configurations preserved by , hence . Since by Lemma~\ref{lemma_morph_preserve_steps}  preserves also asynchronous steps we have the step  which implies that this is translated into the ST-configuration , i.e., .

It is easy to see that  is local injective.

To show that \cintostSecond\ is right adjoint to \stintoc\ we exhibit the co-unit  to be the isomorphism from Corollary~\ref{cor_counit_C_ST}.

\newlength{\parindentoutsidemini}
\setlength{\parindentoutsidemini}{\parindent}
\noindent\begin{minipage}[l]{0.70\textwidth}
\setlength{\parindent}{\parindentoutsidemini}
\vspace{0.5ex}
We have to show that for any object \C\ of \allC\ and any morphism  in \allC\ there exists a unique morphism  for which the diagram on the right commutes.
The map \stintoc\ preserves events then the events of \ST\ are the same as those of ; the same holds for  meaning that the events of \C\ are the same as the events of . 
Therefore, we can take  to be , and the functor returns .
\end{minipage}
\hspace{-1ex}\begin{minipage}[r]{0.3\textwidth}
\vspace{-4ex}\begin{diagram}
\stintoc\circ\cintostSecond(\C) & \rTo^{\counit_\C} & \C \\
\uDashto^{\stintoc(g^{\#})} & \ruTo_g &  \\
\stintoc(\ST) &  &  \\
\end{diagram}
\vfill
\end{minipage}

It is easy to see that the diagram commutes: for any  we have that  because the isomorphism  from Corollary~\ref{cor_counit_C_ST} is the identity.

To show the uniqueness of  assume the existence of another  for which the diagram commutes but for some event  it is different . This means to say that  and that . But then the composition with the counit would again result in , i.e., a contradiction.
\end{proof}






\begin{corollary}[filled-in]\label{cor_cubicalProp_configST}
The ST-structure obtained in Th.~\ref{th_configtoSTsteps} is \emph{``filled in''}, in the sense that any cube is filled in. 
By a \textit{``cube''} it is meant an initial ST-configuration , a final , where  is a nonempty set of events, together with all the ST-configurations  from the subsets . 
To be \textit{``filled in''} means that the intermediate ST-configuration  exists.
\end{corollary}

\begin{proof}
We call \textit{``corners''} the ST-configurations where  and  are equal. 
By a \textit{``cube''} it is meant an initial corner  and a final corner  where  is a nonempty set of events that are meant to be executed concurrently; thus the dimension of  makes the \textit{``higher dimension''} of the cube. The subsets  are the rest of the corners of the cube. 
To be \textit{``filled in''} means that the intermediate ST-configuration  exists, and hence reachable and with all intermediate ST-configurations.


The definition of a ``cube'' between some  and  implies that all the corners of the cube come from configurations . This means that in the configuration structure there exists the asynchronous step . Therefore, by the definition of \cintostSecond\ from Theorem~\ref{th_configtoSTsteps}, this asynchronous step is translated into the ST-configuration .
\end{proof}

\begin{proposition}\label{prop_stableSTconf}
For stable and adjacent-closed ST-structures and stable configuration structures there is a one-to-one correspondence. (The adjacency is necessary.)
\end{proposition}

\cp{This result could be proven also as a result of equivalence of categories!? Moreover, the proof below makes heavy use of the condition of ST-structures; does the proof go through with the weaker constraint?}

\begin{proof}
We use the mapping \stintoc\ from Definition~\ref{def_STtoC}.

Since the input \ST\ is stable, by Proposition~\ref{prop_ST_config_connect}, the output  is also stable.

Define a map  by extending that from Definition~\ref{def_STtoC} which associates to each configuration  an ST-configuration , and for each pair of configurations  and  add also the intermediate ST-configuration . 
We then close the resulting ST-structure under bounded unions and intersections.


\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} The ST-structure generated by  is stable if \C\ is stable.
\vspace{0.5ex}

The  is rooted, and also closed under bounded unions and intersections, by its definition. We need to show it is connected.

Also from the definition of \cintostThird\ and the connectedness of the input \C\ structure, we see that all ST-configurations of concurrency degree 0 or 1 are reachable. It remains to show that any ST-configuration of concurrency degree more than 1 is reachable; these are those ST-configurations coming from the closures. Since the generated ST-structure is rooted, then by Proposition~\ref{prop_connectPaths} we can work with paths and show reachability of all ST-configurations.

Since the dimension of a ST-configuration is the same as the length of the rooted paths that reach it, we can use this measure in an inductive reasoning. The inductive hypothesis is that for two reachable ST-configurations  and  which enter the requirements of the closure under bounded unions, then their union , which is also an ST-configuration, is also reachable.
At least one of the two ST-configurations is not empty, thus take  to be reachable from some , i.e., through an s-step (the argument for a t-step is analogous). By the closure it means that also the union  is an ST-configuration of . Moreover this has degree one lower, coming from two ST-configurations reachable through shorter paths. Therefore we may apply the induction hypothesis to obtain a path reaching this smaller . But from this we can make an s-step, with the event  to reach the initial union ST-configuration , thus finding the desired path.

For the closure under bounded intersections a similar inductive reasoning on the length of the path goes through.


\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} The ST-structure generated by  respects the constraint from Definition~\ref{def_st_structs}.

\vspace{1ex}
It is not difficult to check that the claim holds for ST-configurations of concurrency degree 1. 

For any two ,  satisfying the constraint, i.e.,  we show that their union ST-configuration also respects the constraint when this is indeed an ST-configuration from . 
Respecting the conditions for closure under bounded unions means that there exists  s.t.\  and  also satisfies the constraint of Definition~\ref{def_st_structs}, i.e., . But in this case we see that the two ST-configurations  respect too the conditions of closure under bounded unions, which implies that their union is an ST-configuration also , which is our desired result.


\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} The map  does not introduce corners  which do not have correspondent .
\vspace{0.5ex}

Any new corners can come only from unions or intersections. Assume two  that respect the conditions for closure under bounded unions and their union is a new corner . But by the previous claim there exist also the ST-configurations  and  which are both smaller than (i.e., included in) , To these the inductive hypothesis says that are not new, but come from \C, i.e., . Since \C\ is also closed under bounded unions it means that , our desired result.

\vspace{1ex}
To show the one-to-one correspondence we show two results.

One is that for some stable configuration structure \C\ we have that the application of the two association functions above results in an isomorphic configuration structure; i.e., 

\centerline{.}

This result is easy to establish because, intuitively, the first map \cintostThird\ adds information which is then forgotten by the application of \C. It is easy to see that \cintostThird\ does not introduce new events; and the same for \stintoc. Therefore exhibiting the isomorphism is done by the identity function between the events of \stintoc\ and . We need to show that it preserves configurations, which means to show that for any configuration  then the same configuration is found in the right structure, i.e., . Any configuration is translated into a corner . By the previous claim, no other corners exist. Then each corner is translated into an appropriate configuration .

\vspace{1ex}
More difficult is to establish that for some stable and adjacent-closed ST-structure \ST\ we have that the application of the two association functions above results in an isomorphic ST-structure; i.e., 

\vspace{-1ex}\centerline{.}

Note that only the requirement of stable is not enough for this result. A counterexample is given by the stable ST-structure from Fig.~\ref{fig_ex_hda}(right-most) which is not adjacent closed and for which the above isomorphism is not the case.

The proof has two parts: first we show that any ST-configuration  has an isomorphic version in ; second is to show that the function applications  does not introduce new ST-configurations.

For the first part, if  then it is easy to see that .

When  then let . Because the input \ST\ is stable (hence rooted and connected) and adjacent-closed it means it is closed under single events, cf.~Proposition~\ref{prop_adj_equiv}. Therefore,  for all . With a simple inductive argument using the above closure under single events one can easily show that  we have . Therefore, together with the requirement on ST-structures that  exists for any , it means we have all configurations , for . By the definition of the association function  for all pairs of configurations  and , for all , the function adds an ST-configuration . When closing under bounded unions all these ST-configurations we obtain the desired .

For the second part, assume some  then we show that . If  then this ST-configuration must come from a configuration  (cf.\ the previous claim about no new corners), which in turn only comes from an ST-configuration .

Assume  comes from the existence of two configurations  and  in ; i.e., . But this means that in \ST\ there exist the ST-configurations  and . From the fact that \ST\ is stable it means that  is reachable from  through a path of single event steps. Assume we do not remove the event  from the second set of the pair immediately (for otherwise we already have our desired result) and thus there is a series of single steps that remove single events different than  gradually, first removing from the second set. But eventually we must reach a point when we remove  from the second set and not from the first set yet. This means we reach an ST-configuration  with  containing , and . We can apply the property of closed under bounded unions for  and  to obtain .

Assume that  comes from closure under bounded union of two smaller  and . By induction these are in \ST\ which is closed under bounded unions, hence it also contains . 
The basis of the induction is essential here. We check it for ST-configurations of concurrency degree 1. Take two  and show that their union is . By the previous argument we know that  which because  is closed under bounder unions delivers the expected result.
\end{proof}



The results in this section also apply to \textit{pure event structures} because these are shown in \cite[Th.2 and Prop.2.2]{GlabbeekP09configStruct} to be equivalent to configuration structures under their respective computational interpretations, i.e., asynchronous steps are preserved through translations.

\cp{
\begin{proposition}
Two stable and adjacent-closed ST-structures are hh-bisimilar iff their corresponding (cf.~Proposition~\ref{prop_stableSTconf}) stable configuration structures are, cf.~\cite[def.9.6]{GlabbeekG01refinement}.
\end{proposition}

\begin{proof}
The proof is tedious.
\end{proof}

}

\subsection{Correspondence with the event structures of Plotkin and van Glabbeek}

We relate the ST-structures with the \textit{(inpure) event structures} of \cite[Def.1.3]{GlabbeekP09configStruct} and the asynchronous transition relation associated to them in \cite[Def.2.3]{GlabbeekP09configStruct}.
An \textit{event structure} (which we call \textit{inpure} since their definition in \cite[Def.1.3]{GlabbeekP09configStruct} is different than standard event structures and also the restriction of being pure is not imposed) is , a set of events with an \textit{enabling relation} defined between sets of events . An event structure can be associated with its set of configurations, cf.\ \cite[Def.1.4]{GlabbeekP09configStruct}, . Asynchronous transitions between these configurations are then defined in \cite[Def.2.3]{GlabbeekP09configStruct} as  iff  and .

\begin{theorem}[\allEv\ to\ \allST]\label{th_inpureEv_to_ST}
An inpure event structure can be encoded into an ST-structure s.t.\ any asynchronous concurrent step transition (cf.\ \cite[Def.2.3]{GlabbeekP09configStruct})  is matched by an appropriate path that passes through the ST-configu\-ration .
The encoding is done with the mapping  defined similarly to the one for configuration structures of~Theorem~\ref{th_configtoSTsteps}, considering the set  of left-closed configurations \cite[Def.1.4]{GlabbeekP09configStruct} of the event structure; i.e.,  for  and for any transition  add also the ST-configuration .
\end{theorem}


\begin{proof}
The above property that the theorem requires on the generated ST-structure captures the concurrency that the event structure transition embodies.


The proof uses induction on the dimension of the asynchronous transitions, i.e., on , noting the fact that .
The proof is similar to what we did in Theorem~\ref{th_configtoSTsteps} and is facilitated by the Corollary~\ref{cor_ev_intermediaryTrans}.

The basis for  is easy, for .

The induction case for  means we can consider two different events . After we prove that  and  are also part of  we can use Corollary~\ref{cor_ev_intermediaryTrans} two times, with  and with , to get asynchronous transitions of shorter length respectively  and , which we can use inductively.

To show that  we must show that . 
This can be shown from the existence of the transition  which says that , hence for our  also, there exists  with the property . But since  we have found the  that we needed.

A similar argument is carried to prove that .

Now having the transition  of lower dimension we can apply the inductive hypothesis to obtain that there is a sequence of single steps in the ST-structure  between the ST-configurations . The existence of  is guaranteed by the construction, thus having also a single step . Using induction with the other asynchronous transition we get that . Thus, we get the sequence of single steps we were looking for because .
\end{proof}


\begin{corollary}[from {\cite[Def.2.3]{GlabbeekP09configStruct}}]\label{cor_ev_intermediaryTrans}
For some transition  all the intermediate smaller transitions exist (i.e., going between any two subsets ).
\end{corollary}

\begin{proof}
By intermediary smaller transitions we mean the transitions that go between some two subsets . Thus, knowing that  we prove that . From \cite[Def.2.3]{GlabbeekP09configStruct} of the step transition relation \stepTransEvGlabbeek\ on inpure event structures we have that:  and . We prove that . We have that all  and therefore , and since  we found our  to be .
\end{proof}


Intuitively, one can view this last corollary as the opposite of the ``filled in'' property that was observed in Corollary~\ref{cor_cubicalProp_configST} for the ST-structures produced from a configuration structure. The ST-structures associated to the inpure event structures are not ``filled in''; i.e., the opposite direction of this last corollary does not hold.

\begin{proposition}\label{prop_evnST_adjacentclosed}
The ST-structures generated from inpure event structures as in Theorem~\ref{th_inpureEv_to_ST} are adjacent-closed (and rooted and connected if the event structure is rooted and connected).
\end{proposition}


\begin{proof}
We show first rootedness and connectedness.

Assume the event structure  is rooted and prove that the resulting ST-structure  is also rooted.
The event structure to be rooted means that , which is equivalent to , by the definition of left-closed configurations  from \cite[Def.1.4]{GlabbeekP09configStruct}.
The translation function \eintost\ from Theorem~\ref{th_inpureEv_to_ST} adds the ST-configuration , therefore making it also rooted.

Assume now that \E\ is connected, i.e., all  are reachable from the root  through a sequence of asynchronous steps  with  and . But Theorem~\ref{th_inpureEv_to_ST} says that for each of these steps there exists a path  that goes from  to , for . These paths can be concatenated (in the right order) to obtain a path from  to  thus making any ST-configuration from  that is of the form  reachable.

Note now that the definition of \eintost\ from the proof of Theorem~\ref{th_inpureEv_to_ST} adds one ST-configuration  for each configuration  and one ST-configuration  for each asynchronous step from \E. It adds no other ST-configurations than these. This implies that any ST-configuration in  either it comes from a configuration in  or it comes from an asynchronous step in \E.
It is therefore, an easy consequence of Theorem~\ref{th_inpureEv_to_ST} that for any ST-configuration  there is a path from  to  that passes through  (i.e., reaches it). Since  is reachable from the root, then also  is reachable from . Thus we have connectedness for the rooted .



We check each restriction for adjacency. 
\begin{enumerate}
\item Assuming  as ST-configurations it means that these should come from the transitions , , , where . To prove the conclusion that  is also an ST-configuration we prove that there is a transition . By the definition we have that ; therefore it also holds that , which is the desired transition.

\item Assuming  as ST-configurations it means that these should come from the transitions , , , where  and . To prove the conclusion that  is also an ST-configuration we prove that there is a transition . By the definition we have that ; therefore it also holds that , which is the desired transition.

\item Assuming  as ST-configurations it means that these should come from the transitions , , , where  and . To prove the conclusion that  is also an ST-configuration we prove that there is a transition . 
We may use the Corollary~\ref{cor_ev_intermediaryTrans} to obtain the desired transition.

\item Assuming  as ST-configurations it means that these should come from the transitions , , , where . To prove the conclusion that  is also an ST-configuration we prove that there is a transition  using the Corollary~\ref{cor_ev_intermediaryTrans}.
\end{enumerate}
\end{proof}



\begin{proposition}[\allST\ to \allEv]\label{prop_st_to_ev}
Any rooted, connected, and adjacent-closed ST-structure can be translated into an inpure event structure, s.t.\ the transitions of the event structure capture the concurrency embodied by the ST-structure.
\end{proposition}


\begin{proof}
The translation of the ST-structure ensures that all the concurrency is captured in the resulting event structure, in the sense that if the ST-structure expresses that a set of events can be done concurrently, then there is a transition with that set of events in the generated event structure.

The ST-structure expresses that some set of events  are done in parallel whenever we have an ST-configuration where  (cf.\ Definition~\ref{def_ConcCausal}).

The adjacency constraint ensures that Corollary~\ref{cor_ev_intermediaryTrans} holds.

Define a translation function  similar to what we did in Section~\ref{subsec_configStruct} and Proposition~\ref{prop_ST_config_connect} when embedding ST-structures into configuration structures. Essentially, \stintoe\ keeps only the corners of the ST-structure and uses the rest of the ST-configurations to build the enabling relation of the event structure s.t.\ the transitions that result correspond exactly to those in the ST-structure (i.e., no new transitions are introduced). 

The corners are exactly those ST-configurations where .
Since the ST-structure is connected and rooted, for every two immediately close corners  and  there is also the intermediary ST-configuration . Since the ST-structure is adjacent-closed, for every reachable ST-configuration  we also find all the intermediary ST-configurations corresponding to the faces of the corresponding cube, cf.~Proposition~\ref{prop_adj_equiv}.

We build the enabling relation \enableRelEv\ recursively starting with the root, which is translated into the empty set. To have the empty set as an admissible left-closed configuration of the event structure we must have . Since we work with a connected ST-structure then the way we build \enableRelEv\ to ensure that the transitions are respected will also make sure that the reachable sets of events respect the restriction of being left-closed; so all our built sets of events will be left-closed configurations of the event structure.

For a single step transition coming from a sequence of ST-configurations like   add to \enableRelEv\ the following:  for all .

Because of adjacency, and thus because for steps with more events all the intermediary single steps exist, it is enough to extend the above to sets of events  as follows: for every ST-configuration  add   for all  and for all .

This construction is enough because of connectedness of the ST-structure we started from, which implies that the  was already reached through a transition in the event structure we have built earlier. Therefore, we need to consider only the new subsets. More precisely, to prove that  we need to prove that . From the fact that  is reachable it means that we have that . It means that to get the desired result we need to consider also all the sets formed by adding some part of  to any of these subsets  of .

We are creating redundancy in \enableRelEv, as the transition relation would require less pairs in the relation \enableRelEv. But this redundancy is artificial four our purpose of capturing the transition relations and the configurations of the two structures (i.e., inpure event structures and adjacent-closed ST-structures).



One can now check that no transitions are introduced in the event structure that are not present in the original ST-structure. Moreover, since we take all the single steps of the ST-structure, as well as all the ST-configurations of higher dimensions, we are translating all the possible transitions from the ST-structure into the event structure.

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} For any  a left-closed configuration of  then .
\vspace{0.5ex}

This means that . In particular, for  exists  s.t.\ . 
By the definition of  this last enabling must come from some  with  divided into  with  and . This also says that , hence  and . From , , and  we have that , and hence . This means that the above ST-configuration is actually  for which . Since \ST\ is closed under single events and connected it means that we can remove the events in  to reach smaller ST-configurations; in particular we remove only the events in  thus obtaining . But by the property of \ST\ we then have that also .

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} For any  in  then .
\vspace{0.5ex}

This means that  and . In particular, for  exists  s.t.\ . 
By the definition of  this last enabling must come from some  with  divided into  with  and . This also says that , hence  and . From , , and  we have that , and hence . This means that the above ST-configuration is actually  for which  and hence . This means that . Since \ST\ is closed under single events and connected it means that we can add the events from  to  to reach ST-configurations of smaller concurrency degree; in particular we add only the events in  thus obtaining . We can also remove elements from ; in particular, removing the elements from  we obtain now , i.e., the desired result.
\end{proof}

\cp{Can prove categorical results like equivalence of categories \allST\ and \allEv; in fact their respective sub-categories of rooted connected and adjacent-closed. Or one can look for adjoints since  and .}

\subsection{Correspondence with higher dimensional automata}

We recall the definition of higher dimensional automata (\HDA) following the terminology of \cite{Glabbeek06HDA,Pratt03trans_cancel}, defining also additional notions including the restriction to acyclic and non-degenerate \HDAs.


\begin{figure}[tp]
\psfrag{ee}{{\scriptsize  }}
\psfrag{ae}{{\scriptsize }}
\psfrag{be}{{\scriptsize }}
\psfrag{aa}{{\scriptsize  }}
\psfrag{bb}{{\scriptsize }}
\psfrag{bab}{{\scriptsize }}
\psfrag{baa}{{\scriptsize }}
\psfrag{baba}{{\scriptsize }}
\psfrag{bae}{{\scriptsize }}
\psfrag{q11}{}
\psfrag{q12}{}
\psfrag{q13}{}
\psfrag{q14}{}
\psfrag{q21}{}
\psfrag{q22}{}
\psfrag{q23}{}
\psfrag{q24}{}
\psfrag{a}{\small }
\psfrag{b}{\small }
\psfrag{s1}{\small }
\psfrag{t1}{\small }
\psfrag{s2}{\small }
\psfrag{t2}{\small }
\psfrag{inQ2}{}
\psfrag{inQ1}{}
\psfrag{inQ0}{}
\psfrag{alpha}{\small \color{red}}
\psfrag{A}{}
\psfrag{B}{}
\psfrag{C}{}
\psfrag{q3}{}
\psfrag{s}{{\scriptsize }}
\psfrag{t}{{\scriptsize }}
\begin{center}
\includegraphics[height=3.6cm]{figures/figure2}
  \end{center}
\caption{Example of a \HDA\ with two concurrent events labeled by  and : with an instance of cubical laws (left-most), and a more geometrical picturing (middle-left); an ST-structure and its \HDA\ (middle-right) for interleaving, which is not stable but adjacent-closed; and (right-most) a stable ST-structure that is not adjacent-closed.}
\label{fig_ex_hda}
\end{figure}

For an intuitive understanding of the \HDA\ model consider the standard example \cite{Pratt03trans_cancel,Glabbeek06HDA} pictured in Figure~\ref{fig_ex_hda}(middle-left). It represents a \HDA\ that models two concurrent events which are labeled by  and  (we can also have the same label  for both events, giving rise to the notion of \emph{autoconcurrency}). The \HDA\ has four states,  to , and four transitions between them. This would be the standard picture for interleaving, but in the case of \HDA\ there is also a square . Traversing through the interior of the square means that both events are executing. When traversing on the lower transition it means that event one is executing but event two has not started yet, whereas, when traversing through the upper transition it means that event one is executing and event two has finished already. In the states there is no event executing; in particular, in state  both events have finished, whereas in state  no event has started yet.

Similarly, \HDAs\ allow to represent three concurrent events through a cube, or more events through hypercubes. Causality of events is modelled by sticking such hypercubes one after the other. For our example, if we omit the interior of the square (i.e., the grey  is removed) we are left with a description of a system where there is the choice between two sequences of the same two events, i.e., .
This last \textit{interleaving choice} example can be seen as obtained by sticking together four cubes of dimension 1 by identifying their endpoints; whereas the true concurrency example is just one single cube of dimension 2.

\begin{definition}[higher dimensional automata]\label{def_hda}\ 

A \emph{cubical set}  is formed of a family of sets  with all sets  disjoint, and for each , a family of maps , with , which respect the following \emph{cubical laws}:

In , the  and  denote the collection of all the maps from all the families (i.e., for all ).
A \emph{higher dimensional automaton}  over an alphabet  is a cubical set together with a \emph{labelling function}  which respects  for all  and ; and with  \emph{initial} and  \emph{final} cells.
\end{definition}


We call the elements of  respectively \textit{states}, \textit{transitions}, \textit{squares}, and \textit{cubes}, whereas the general elements of  are called \textit{cells} (also known as n-cells, n-dimensional cubes, or hypercubes).
For a transition  the  and  represent respectively its source and its target cells (which are \textit{states} from  in this case). Similarly for a general n-cell  there are  source cells and  target cells all of dimension . 

Intuitively, an n-dimensional cell  represents a configuration of a concurrent system in which  events are performed at the same time, i.e., concurrently. A source cell  represents the configuration of the system before the starting of the  event, whereas a target cell  represents the configuration of the system immediately after the termination of the  event. We call all these source and target cells the \emph{faces} of .
A cell of  represents a configuration of the system in which a single event is being performed.
The cubical laws account for the \textit{geometry} (concurrency) of the \HDAs, with four kinds of cubical laws depending on the instantiation of  and ; Figure~\ref{fig_ex_hda}(left) presents one such instantiation.






\begin{definition}[isomorphism of \HDAs]\label{def_isomorphismHDA}
A \emph{morphism} between two \HDAs,  is a dimension preserving map between their cells , such that:
\begin{enumerate}
\item\label{def_isomorphismHDA_1} the initial cell is preserved: ,
\item\label{def_isomorphismHDA_2} the labeling is preserved:  for all ,
\item\label{def_isomorphismHDA_3} the mappings are preserved, for any  and :
\begin{itemize}
\item  and
\item .
\end{itemize}
\end{enumerate}
When a morphism is bijective we call it \emph{isomorphism}. Two \HDAs\ are isomorphic, denoted , whenever there exists an isomorphism between them.
\end{definition}

The above definition of isomorphism conforms with that in \cite[Def.2]{Glabbeek06HDA} and whereas the definition of morphism conforms with that of \cite[Sec.1.1]{Goubault12Category_Cubical}.



\begin{definition}[paths in \HDAs]\label{def_paths_HDA}
A \emph{single step} in a \HDA\ is either  with  or  with , where  and  and . A \emph{path}  is a sequence of single steps , with . 
We say that  iff  appears in one of the steps in . 
The first cell in a path is denoted  and the ending cell in a finite path is . 
\end{definition}

Note that the marking of the steps by  can be deduced from the fact that the step goes from a lower cell to a higher cell for s-steps (and the opposite for t-steps). It is though useful in many of the proofs to have easily visible the exact map (i.e., the index also) that the step uses, instead of explicitly assuming it every time.

\begin{definition}[histories for \HDA\ -- from {\cite[Sec.7]{Glabbeek06HDA}}]\label{def_history_HDA}\ 

In a \HDA\ two paths are \emph{adjacent}, denoted  if one can be obtained from the other by replacing, for  and ,
\begin{enumerate}
\item a segment  by , or
\item a segment  by , or
\item a segment  by , or
\item a segment  by .
\end{enumerate}
Two finite paths are \textit{l-adjacent}  when the segment replacement happens at position ; i.e.,  is the  cell in the path.
\emph{Homotopy} is the reflexive and transitive closure of adjacency. Two paths that are homotopic, denoted , share their respective start and end cells. All homotopic rooted paths that have the same end cell  are said to be a \emph{history of } and is denoted  when this is unique. We use the same notation for the homotopy class of a rooted path, , which is also used when a cell has more than one history, as is the case with the interleaving square HDA from Figure~\ref{fig_ex_hda}.
\end{definition}

Above, homotopy is defined for all paths (opposed to the definition in \cite[Sec.1.6]{Goubault12Category_Cubical}) and thus also a cell of higher dimension, like the inside of a square, has a history, not only the state cells of dimension  that form the corners of the square.

Inspired by the definition of history unfolding for process graphs from \cite[Sec.3]{glabbeek96histUnfold} we define the same notion for HDAs (the present author is not aware of this notion being defined for HDAs anywhere else).

\begin{definition}[history unfolding for HDAs]\label{def_unfolding_history}\ 

The \emph{history unfolding}  of a higher dimensional automaton  is given by:
\begin{itemize}
\item  is the set of histories that end up in cells on level  of ,
\item has the same labeling as  and initial cell the empty rooted history,
\item the  maps are built from the corresponding maps between the end cells of the histories; i.e.,  iff .
\end{itemize}

\end{definition}


\begin{definition}[hh-bisimulation]\label{def_hhbisim}
Two higher dimensional automata  and  (with  and  the initial cells) are \emph{hereditary history-preserving bisimulation equivalent} (hh-bisimilar), denoted , if there exists a binary relation  between their paths starting at  respectively  that respects the following:
\begin{enumerate}
\item if  and  then  with  and ;
\item if  and  then  with  and ;
\item\label{hh_HDM_l1} if  and  then  with  and ;
\item\label{hh_HDM_l2} if  and  then  with  and ;
\item if  and  then  with  and ;
\item if  and  then  with  and .
\end{enumerate}
\end{definition}

A corollary from \cite{Glabbeek06HDA} strengthens the above conditions~\ref{hh_HDM_l1} and \ref{hh_HDM_l2} to \textit{unique} existence.

\begin{corollary}[cf.~{\cite[sec.7.5]{Glabbeek06HDA}}]\label{cor_unique_adjacent}
For a path  and a point  there exists a unique path  that is -adjacent with .
\end{corollary}





Many of the results in this paper work with \emph{acyclic} and \emph{non-degenerate} \HDAs\ in the following sense. Such \HDAs\ are often considered in the literature on concurrent systems and are more general than most of the true concurrency models \cite{Pratt03trans_cancel,Glabbeek06HDA}.

\begin{definition}[acyclic and non-degenerate \HDAs]\label{def_acyclic}\ 

A \HDA\ is called \emph{acyclic} if no path visits a cell twice. 
A \HDA\ is called \emph{non-degenerate} if for any cell  all its faces exist and are different, in the sense of , and no two transitions with the same label share both their end states.
\end{definition}

The restriction on \HDAs\ that we call here ``non-degenerate'' is close to that of Cattani and Sassone \cite[Def.2.2]{CattaniSassone96HDTS} and that of van Glabbeek \cite[p.10]{Glabbeek06HDA}. The second constraint of non-degeneracy is close to the notion of strongly labeled of \cite[Def.1.13]{Goubault12Category_Cubical}.
Note that the non-degeneracy still allows for two opposite s and t-maps to be equal, i.e., it is allowed . But when the \HDA\ is also required to be acyclic then this is also ruled out since it would create a cycle.
In this paper we usually work with non-degenerate \HDAs; and moreover we silently assume all the s/t-maps to be total.





\begin{definition}[\allST\ to \allHDA]\label{def_STtoHDA}
We define a mapping  from ST-structures into HDAs which for a  with the events linearly ordered as a list  (i.e., each event being indexed by a natural number) returns the HDA  which
\begin{itemize}
\item has cells ;

\item for any two cells  and  add the map entry  where  is the index of the event  in the listing ;

\item for any two cells  and  add the map entry  where  is the index of the event  in the listing ;

\item has labeling  for any .
\end{itemize}
More precisely, by  we represent the listing of the events in , i.e., a list of dimension  obtained from the original listing  by removing all other events. This new listing has the events of  in the same original order but with new indexes attached (ranging from  to ).
\end{definition}

\begin{theorem}\label{th_stintohda}
For a rooted, connected, and adjacent-closed ST-structure \ST\ the mapping \stintoh\ associates a  which is a higher dimensional automaton respecting all cubical laws and is acyclic and non-degenerate.
\end{theorem}

\begin{proof}
We first show that  is a HDA in the sense of Definition~\ref{def_hda}.
For any cell  all immediately lower cells  and , with  exist because the ST-structure is rooted, connected, and adjacent-closed, and by Proposition~\ref{prop_adj_equiv} is closed under single events, therefore all ST-configurations  and  exist and thus have the above associated cells. 
Consider for now that each immediately lower cell  is linked through . Note that the s-maps are not indexed as in the definition, but are indexed by an event. We will replace these event indexes by numbers. Link these cells also to  through . 

To get the cubical laws right we must use a discipline in replacing the event indexes for the s and t maps by numbers. This is what the Definition~\ref{def_STtoHDA} does (inspired from \cite{Glabbeek06HDA}). 
The listing of the events that the ST-structure comes with provides a bijective indexing map  from  to . For a specific ST-configuration  this indexing map becomes a map from  to , with , that respects the original ordering of the events from the listing of . Call this indexing .
For the cell  replace  by  and  by . For each immediately lower cell, like , which is linked as , their corresponding indexing maps look like .
The relationship between these two maps  and  is easy to see; for simplicity of notation denote the two maps respectively by  and . The indexing map  is defined on  as  if , and  if .  The same holds for .

One can check that the cubical laws hold. This is easier done by keeping in mind an intuitive association between each cubical law and the corresponding adjacent-closure constraint.
As an example:  for two events  under the assumption that .

The labeling of the \HDA\ is obtained from the labeling of the ST-structure. Each  is labeled with  where  is the single event that is concurrent in .

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} The  is acyclic and non-degenerate.
\vspace{0.5ex}

To prove \textit{non-degeneracy} one can notice that for showing that any cell has all its faces distinct it is enough to recall how the faces of some cell  have been built. One s-face is a cell  that is obtained from an ST-configuration that can immediately reach  through an s-step in \ST, and which adds the event ; hence the labeling of the corresponding s-map by . Since we added one such map and face for each distinct event from , then all the resulting cells are distinct. The same for the t-maps.

A note is in order. In the definition and the argumentation above, two generated cells  and  are considered equal (respectively different) iff  (respectively ).

We now finis proving non-degeneracy. For two transitions, i.e., cells of dimension one, hence obtained as  and  with  (respectively ) with  assume they have the same source. This implies that  and thus the two transitions are  and . Since these two transitions are assumed different then it implies that . The target of the first transition thus becomes  and of the second  which are different.

To prove that the obtained \HDA\ is acyclic note first that each step in the ST-structure is matched precisely by a corresponding single step of the same type in the \HDA. Moreover, one step in the ST-structure increases strictly the dimension of the ST-configuration (since it adds one new event to one of the two sets).
Because each cell in the resulting \HDA\ is labeled by an ST-configuration to which it corresponds, we can define a weight for each cell to be the dimension of the ST-configuration that it is labeled with. With this we can define a weight for each finite path to be the weight of the cell it ends in.

Each path in the \HDA\ is matched by one path in the ST-structure. Since each extension of a path reaches an ST-configuration of strictly larger dimension, it means that each extension of a path in the \HDA\ will have strictly larger weight. To have a cycle, the \HDA\ must have one path that visits the same cell twice; say . This means that an initial segment of this path that ends in , which has weight , is extended to another path that ends in the same cell, hence having he same weight. But this is a contradiction, since any extension strictly increases the weight.
\vspace{1ex}
\end{proof}

The next lemma ensures that it is immaterial which listing of the events is picked in the definition of the mapping \stintoh.

\begin{lemma}\label{lemma_listings_different}
For some \ST\ and two listings  of the events , the \HDAs\ resulting from the application of \stintoh\ with each listing are isomorphic up to reindexing of the maps.
\end{lemma}

\begin{proof}
Take the two generated \HDAs\ to be respectively   and . Since  and  are two listings of the same set then we get a permutation  of their indexes, in the sense that if  is on position  in  then the same event is on position  in .

The two generated \HDAs\ are isomorphic through the identity morphism . The only thing to check is that it preserves the mappings up to the reindexing of the maps according to the above permutation; i.e., instead of showing that  we show that .

In  we have that  with  having index  in the listing , thus making the whole right-hand side of the equality . On the left side,  returns the same  in ; and  where  is the event on index  in the listing . By the notation  we mean the restriction of the permutation  to  in the following sense. We have  defined as  if  with .
It is easy to see that  and hence the desired result.
\end{proof}


\begin{figure}[tp]
\psfrag{e}{\scriptsize }
\psfrag{d}{\scriptsize }
\psfrag{f}{\scriptsize }
\psfrag{00}{{\scriptsize }}
\psfrag{d0}{{\scriptsize }}
\psfrag{e0}{{\scriptsize }}
\psfrag{ee}{{\scriptsize }}
\psfrag{dd}{{\scriptsize }}
\psfrag{ded}{{\scriptsize }}
\psfrag{dede}{{\scriptsize }}
\psfrag{dfd}{{\scriptsize }}
\psfrag{dfdf}{{\scriptsize }}
\psfrag{0}{{\scriptsize }}
\psfrag{0d}{{\scriptsize }}
\psfrag{0e}{{\scriptsize }}
\psfrag{0ed}{{\scriptsize }}
\psfrag{sd0}{{\small \begin{rotate}{125}\end{rotate}}}
\psfrag{se0}{{\small \begin{rotate}{45}\end{rotate}}}
\psfrag{sed}{{\small \begin{rotate}{45}\end{rotate}}}
\psfrag{hh}{{\scriptsize }}
\psfrag{iso}{{\scriptsize }}
\psfrag{niso}{{\scriptsize }}
\psfrag{ST}{{\scriptsize on STs}}
\psfrag{HDA}{{\scriptsize on \HDAs}}
  \begin{center}
    \includegraphics[height=2.5cm]{figures/figure4}
  \end{center}
\caption{\textit{Strong asymmetric conflict}  as inpure event structure (left), and ST-structure (middle). Related isomorphic \HDAs\ give rise to non-isomorphic ST-structures (middle and right).}
\label{fig_ex_asymconflict1}
\end{figure}

\begin{example}[Strong asymmetric conflict]\label{example_asym_confl}
This example, taken from \cite[Ex.3]{GlabbeekP09configStruct} (called \textit{strong} in \cite[p.22]{Pratt03trans_cancel}), shows the gain in expressive power of the ST-structures. Asymmetric conflict cannot be captured in the \emph{pure event structures} of \cite[Def.1.5]{GlabbeekP09configStruct}, hence not by the configuration structures. Asymmetric conflict can be captured by the inpure event structures of \cite{GlabbeekP09configStruct}, and thus, also by the adjacent-closed ST-structure of Fig.~\ref{fig_ex_asymconflict1}(middle).

The example has no concurrency and involves two events, imposing the only restriction that once event  happens, event  cannot happen any more.

Within \HDAs\ it is more cumbersome to represent this example because \HDAs\ are not good at identifying the particular events. \HDAs\ abstract from the concrete events and concentrate only on the labels. 
One way of identifying events is by equivalence classes of transitions, where two transitions are equivalent when they are parallel in the border of a filled square (i.e., what we assumed until now in our \HDAs\ examples).


Applying this technique to the \HDA\ in Fig.~\ref{fig_ex_asymconflict1}(middle) would not result in the corresponding 2-events ST-structure (which is what we want), but would result in the 3-events ST-structure of Fig.~\ref{fig_ex_asymconflict1}(right), and these two ST-structures are not isomorphic.
On the other hand, the two representations of \HDA\ from Fig.~\ref{fig_ex_asymconflict1}(middle and right) are isomorphic. 
Nevertheless, if we are interested in representing systems only up to hh-bisimulation, then both \HDAs\ and ST-structures are as good, because the different representations of ST-structures (with 2 or 3 events) would be equated by the hh-bisimulation.
\end{example}



\begin{proposition}\label{prop_stintoh_iso}
\ 

\begin{enumerate}
\item\label{prop_stintoh_iso_1} The mapping \stintoh\ from Definition~\ref{def_STtoHDA} preserves isomorphism; i.e., for  then .

\item\label{prop_stintoh_iso_collapse} The mapping \stintoh\ may collapse non-isomorphic ST-structures into isomorphic \HDAs.
\end{enumerate}
\end{proposition}

\begin{proof}
For the second part of the proposition consider the two ST-structures from Figure~\ref{fig_ex_asymconflict1} which are not isomorphic as the left one is defined on two events whereas the right one is on three events. But the \HDAs\ that the mapping \stintoh\ associates are isomorphic.

\vspace{1ex}
For the first part of the proposition consider two isomorphic ST-structures  with  their respective isomorphism. To show that  we build an isomorphism between the two generated \HDAs\ as  given by . We prove that  is a dimension preserving isomorphism of the two  and  as in Definition~\ref{def_isomorphismHDA}.

Because of Lemma~\ref{lemma_listings_different}, if for the translation of \ST\ we pick some listing of , then for the translation of  we pick the listing of  such that the order of the events is preserved; i.e., if  in the listing of  then also  in the listing of . Since  is a bijection this means that if  is on position  in the listing of  then  we find  on the same position  in the listing of .

For  which was generated from the , the isomorphism of ST-structures ensures that , which means that the mapping will associate the cell . This makes  well defined. Moreover, because the isomorphism  preserves the concurrency degree of the ST-configurations, i.e., , then  preserves the dimension of the cells.
It is easy to see that  preserves the initial cell.
 also preserves the labeling since , where the equality (1) comes from the Definition~\ref{def_STtoHDA} of the \stintoh\ map and (2) comes from the Definition~\ref{def_isomorphism} of isomorphism for ST-structures; and since , we obtain the requirement \ref{def_isomorphismHDA_2} of Definition~\ref{def_isomorphismHDA}.

It remains to show that  preserves the mappings, i.e., . (The case for t-maps is analogous.) By the Definition~\ref{def_STtoHDA} of the \stintoh,  for  with index  in the listing of the events , and thus . Since , by Definition~\ref{def_STtoHDA},  for   the event with index  in the listing of the events . If we choose the listing of the events of  such that the isomorphisms  preserves their order, as we explained before, then the event  is exactly . Therefore, we have the equality we are looking for; .
\end{proof}

A corollary of Proposition~\ref{prop_stintoh_iso}\refeq{prop_stintoh_iso_collapse} is that \stintoh\ in not an embedding from \allST\ to \allHDA\ since it looses information, i.e., the events.

Nevertheless, the mapping \stintoh\ preserves hh-bisimulation.



\begin{definition}[\allHDA\ to\ \allST]\label{def_hdaTOst}\ 

Consider a non-degenerate \HDA\ .
Define a relation  on transitions as 

for some  and .
Consider the reflexive and transitive closure of the above relation, and denote it the same. This is now an equivalence relation on . Consider an equivalence class  to be all  equivalent with .
Such an equivalence class is called \emph{an event}.

Define a map  which builds an ST-structure  by associating to each rooted path  an ST-configuration as follows.
\begin{enumerate}
\item\label{hintost_1} for the minimal rooted path which ends in  associate ;

\item\label{hintost_2} for any path  which ends in a transition  then 
\begin{enumerate}
\item\label{hintost_21} add the ST-configuration  with ;

\item\label{hintost_22} add the ST-configuration ;
\end{enumerate}

\item\label{hintost_3} for any path  which ends in a higher cell , with , then add the ST-configuration , with , , and .
\end{enumerate}
\end{definition}

Note that in the case~\refeq{hintost_3} above the paths  always exist because we work with non-degenerate \HDAs. The same goes for the path  used in \refeq{hintost_21}.

\cp{
The definition above is based on the following lemma.

\begin{lemma}
Two homotopic paths  are translated in the same ST-configuration:

\centerline{.}
\end{lemma}

\begin{proof}

\end{proof}
}

\begin{proposition}\label{prop_hdaintost}
For an acyclic and non-degenerate \HDA\ the resulting ST-structure  is rooted, connected, and adjacent-closed.
\end{proposition}

\begin{proof}
Rootedness is easy because it corresponds to the minimal rooted path of the \HDA, i.e., the initial cell.

Connectedness is satisfied when the \HDA\ that we translate is connected. This is the case because we work with \HDAs\ that are closed under reachable parts. This means that we consider only those cells that are reachable from the initial cell, as we stated before.

In a non-degenerate \HDA\ every  cell has exactly one  and one  map. This means that every path  with  there exists exactly one path  which can reach  through an s-step. Moreover, for  there is exactly one continuation by a t-step, and this reaches a  state cell; this motivates in the definition the consideration of the paths . In fact any state cell  can be reached through such a path.

In a non-degenerate \HDA, every higher dimensional cell , with , has at least two source maps which enter a cubical law , and with . There are uniquely corresponding paths for the original  and the cells involved and for this cubical law, these paths being connected through the corresponding s-steps. This motivates the last point in the definition.

Connectedness is proven using induction on the length of the paths that are used to generate the ST-configurations.
It is easy to see that the ST-configuration introduced in \ref{hintost_21} is connected to the ST-configuration of the immediately shorter path through adding one new event to the  set. This event is new because the \HDA\ is acyclic, and thus the path  never goes through a cell twice; in particular it has never been through the  that is used in the definition.
Similarly, the ST-configuration introduced in \ref{hintost_22} is connected to the the ST-configuration of the immediately shorter path through a t-step, i.e., terminating the event .

For a higher dimensional cell  we show that the associated ST-configuration differs from each immediately lower paths reaching it through an s-step by only one event in the  set; thus ensuring connectedness.
For this we show that for any two transitions  entering the cubical law , with  and  they cannot be equivalent, i.e., not denote the same event.



To show adjacent-closure we use Proposition~\ref{prop_adj_equiv} because the ST-structure is rooted and connected. Therefore it is enough to show closure under single events. 
\cp{
We base the rest of the proof on the following.

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} .
\vspace{0.5ex}

The second property of Definition~\ref{def_closeSingleEv} is obtained from the above fact that in the extension step the ST-configuration that we introduce differs in exactly one event; and since we have chosen two arbitrary s-maps, we obtain the result for all the concurrent events. Showing the first constraint of Definition~\ref{def_closeSingleEv} is simple from the completion step and the above, since this step considers each and all the s-maps, where each such map corresponds to one of the concurrent events.
\cp{Redo this last paragraph!!!}
}
\end{proof}

\cp{
\begin{proposition}\label{prop_Hpreserveshh}
For two acyclic and non-degenerate \HDAs,  and , their corresponding rooted, connected and adjacent-closed ST-structures  and  are hh-bisimilar (cf.~Def.~\ref{def_hh_ST}) iff the original higher dimensional automata are hh-bisimilar.
\end{proposition}


\begin{proof}[sketch]
Intuitively, the -adjacency steps for HDA correspond to the restriction 1 in Def.~\ref{def_hh_ST} of -isomorphism together with the adjacent-closure properties for ST-structures.
\end{proof}
}


\begin{proposition}\label{prop_hintost_iso}
\ 

\begin{enumerate}
\item\label{prop_hintost_iso_1} The mapping \hintost\ from Definition~\ref{def_hdaTOst} preserves isomorphism of reachable parts; i.e., for  then .

\item\label{prop_hintost_collapse} The mapping \hintost\ may collapse non-isomorphic \HDAs\ into isomorphic ST-structures.
\end{enumerate}
\end{proposition}



\begin{figure}[tp]
\psfrag{a}{\scriptsize }
\psfrag{b}{\scriptsize }
\psfrag{c}{\scriptsize }
\psfrag{d}{\scriptsize }
\psfrag{e}{\scriptsize }
\psfrag{I}{{\scriptsize }}
\psfrag{ab}{{\scriptsize }}
\psfrag{dfd}{{\scriptsize }}
\psfrag{F}{{\scriptsize }}
\psfrag{hh}{{\scriptsize }}
\psfrag{nhh}{{\scriptsize }}
\psfrag{iso}{{\scriptsize }}
\psfrag{niso}{{\scriptsize }}
\psfrag{ST}{{\scriptsize on STs}}
\psfrag{HDA}{{\scriptsize on \HDAs}}
\psfrag{with}{{\scriptsize with }}
  \begin{center}
    \includegraphics[height=3.5cm]{figures/figure7}
  \end{center}
\caption{Identifying of non-isomorphic and non-hh-bisimilar \HDAs\ through \hintost.}
\label{fig_ex_Glabbeek}
\end{figure}

\begin{proof}
For the second part of the proposition consider the two \HDAs\ from Figure~\ref{fig_ex_Glabbeek} without the two dotted transitions, which are translated into the same ST-structure by \hintost. Even when the dotted transitions are added, they are mapped to the same ST-structure.

For the first part we build an isomorphism  between   and  starting from the isomorphism  between  as follows. Take 

\cp{Finish proof for part 1!!}
\end{proof}




We can define the \emph{category} \categoryHDA\ to have objects \HDAs\ and morphisms defined as in Definition~\ref{def_isomorphismHDA}.


\begin{proposition}
The mapping \stintoh, from Definition~\ref{def_STtoHDA}, can be lifted to a functor between the categories \categoryST\ and \categoryHDA\ by defining its application to morphisms as follows: for  have  with  for any .
\end{proposition}

\begin{proof}
Since the morphism  preserves ST-configurations, we have  and thus  making  well defined as a function from the cells of  to . The rest of the proof that  is a morphism of \HDAs\ goes as in the proof of Proposition~\ref{prop_stintoh_iso}(\ref{prop_stintoh_iso_1}).

It is easy to see that \stintoh\ preserves the identity morphisms.

We are left to show that \stintoh\ preserves composition; i.e., .
\cp{Finish!!}
\end{proof}


\begin{proposition}
The mapping \hintost, from Definition~\ref{def_hdaTOst}, can be lifted to a functor between the categories \categoryHDA\ and \categoryST\ by defining its application to morphisms as follows: for some morphism of \HDAs\  have  with  for any  an event generated by .
\end{proposition}

\begin{proof}
From the statement is clear that  is defined over all events of . Since for any  the  is reachable by some path  it means that the equivalence class  will be used in building some ST-configuration of , in the case \ref{hintost_21} of Definition~\ref{def_hdaTOst}, and therefore  will be an event of , thus making the codomain of  to be ; i.e., .

To show that  is well defined we show the following:

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} For two \HDAs\ related by a morphism  and for any two cells  we have 

\vspace{0.5ex}
Since  then it means that , with  and . Since  preserves the mappings we have  and . This means we have found  that witnesses that .

To show that  preserves ST-configuration consider an  which means that it was obtained from some path . But since  preserves the maps ti means that the path  corresponds to a path  with the same maps and indexes and where each cell on this path is the -image of the corresponding cell on . This means that if  then  and that . We show by induction on the length of the paths that , therefore implying that it is an ST-configuration from . The base case for the empty path is easy. We then take cases depending on the cell that the path ends in, according to Definition~\ref{def_hdaTOst}.
When  then case~\ref{hintost_21} applies, which means that . When  is applied to this ST-configuration we have . By the induction hypothesis , and by the definition of  we have . These imply, by the same case~\ref{hintost_21} of Definition~\ref{def_hdaTOst}, the desired result that .
When  then case~\ref{hintost_22} applies and a similar argument as before is used.
When  then case~\ref{hintost_3} applies, and thus . By the induction hypothesis, since the twp paths are of shorter length, we have  and  which is  which is equal to ; analogous  with . Therefore, by the same case of Definition~\ref{def_hdaTOst} we have .

To show that  is locally injective we use induction on the length of the path, since the ST-configura\-tions are build in Definition~\ref{def_hdaTOst} from paths shorter with one step. We show that for any ST-configuration  obtained from some path as  and for any two equivalence classes  we have  which is the same as . In other words, if for two transition cells that have been added by \hintost\ on some path  which are not equivalent in the sense of  then their corresponding cells through  are also not equivalent, .
When we treat the case~\ref{hintost_22} for when  it is trivial because it follows from the inductive hypothesis since we only add to the  set of the ST-configuration.
The case~\ref{hintost_21} for when  assumes that  is locally injective as  and from the definition . Therefore we look only at the situation when .
The case~\ref{hintost_3} needs some more care and it goes through using the cubical law that the two shorter paths enter into.

It remains to show that \hintost\ preserves identity morphisms and respects composition of morphisms.
It is not difficult to show that , since .
We show that . We know that . On the other side, , which is the desired result.
\end{proof}


\begin{remark}[no adjoint]
For the two functors \stintoh\ and \hintost\ between the categories \categoryST\ and \categoryHDA\ we cannot find a unit to make \stintoh\ the left adjoint of \hintost\ because of the example of the ST-structure of Figure~\ref{fig_ex_asymconflict1}(middle). For this ST-structure there is no way to associate a morphism to its translation through , which is the ST-structure from Figure~\ref{fig_ex_asymconflict1}(right). There is also not possible to get the adjunction the other way, because of the example of Figure~\ref{fig_ex_interleaving_triangle}(right) showing unfolding of the triangle \HDA. For this \HDA\ there is no way to associate a morphism to its translation through , which is unfolded.
\end{remark}


\cp{What is the category of sculptures? And what is its relation with the category of \HDAs?
Sculptures are special morphisms (together with their respective objects) from the category of \HDAs. If we take such morphisms as objects, then what are the morphisms between sculptures?

Note that a bulk is a sculpture wrt.\ all other bulks of higher dimension. So there are many such morphism with the origin in a bulk. We are interested only in those sculpture morphisms which are \textit{simplistic}. What is their categorical characterization in the category \categoryHDA?
}


\section{Sculpting}\label{subsec_sculpting}

There are several issues with the above mappings that we want to address in this section using the method of \textit{sculpting}, which is much like what Pratt has used in \cite{Pratt96reconcilingevent,Pratt00HDArev}.
The mapping \hintost\ works like an unfolding since it works with paths; in fact it is more close to the \textit{history unfolding} of the \HDA\ that it manipulates (cf.\ Definition~\ref{def_unfolding_history}). This is obvious from the example in Figure~\ref{fig_ex_interleaving_triangle}(right) where the right structure is the unfolding of the left triangle-like \HDA. But history unfolding is hh-bisimilar to the original structure, so we could try to check if \hintost\ is good up to hh-bisimulation. The example of Figure~\ref{fig_ex_Glabbeek}, disregarding the two dotted transitions, also shows two hh-bisimilar \HDAs\ the left being the history-unfolding of the right one, and which are mapped into the same ST-structure. So we could try to show that for \HDAs\ that are not hh-bisimilar the \hintost\ would map them to not hh-bisimilar ST-structures. But this is dismissed by the example of Figure~\ref{fig_ex_Glabbeek}, this time considering also the dotted transitions. These two \HDAs\ are not hh-bisimilar, but they are mapped to isomorphic ST-structures, hence hh-bisimilar.


\begin{figure}[tp]
\psfrag{ee}{{\scriptsize  }}
\psfrag{ae}{{\scriptsize }}
\psfrag{be}{{\scriptsize }}
\psfrag{aa}{{\scriptsize  }}
\psfrag{bb}{{\scriptsize }}
\psfrag{bab}{{\scriptsize }}
\psfrag{baa}{{\scriptsize }}
\psfrag{baba}{{\scriptsize }}
\psfrag{bae}{{\scriptsize }}
\psfrag{q11}{\small }
\psfrag{q12}{\small }
\psfrag{q13}{\small }
\psfrag{q15}{\small }
\psfrag{q14}{\small }
\psfrag{q21}{}
\psfrag{q22}{}
\psfrag{q23}{}
\psfrag{q24}{}
\psfrag{a}{\small }
\psfrag{b}{\small }
\psfrag{c}{\small }
\psfrag{d}{\small }
\psfrag{H1}{}
\psfrag{H2}{}
\psfrag{H3}{}
\psfrag{H4}{}
\psfrag{different}{}
\psfrag{hh}{{\scriptsize }}
\psfrag{nhh}{{\scriptsize }}
\psfrag{iso}{{\scriptsize }}
\psfrag{niso}{{\scriptsize }}
\psfrag{ST}{{\scriptsize on STs}}
\psfrag{HDA}{{\scriptsize on \HDAs}}
\psfrag{STH1}{{\scriptsize }}
  \begin{center}
    \includegraphics[height=3.9cm]{figures/figure8}
  \end{center}
\caption{Unfoldings of \HDAs\ through \hintost.}
\label{fig_ex_interleaving_triangle}
\end{figure}

The above issues are related to the fact that it is not clear how to identify the events in a \HDA. The best example for this is the fact that the mapping \hintost\ destroys the interleaving square; which is exactly due to the fact that our method of identifying events in a \HDA\ by equivalent transitions opposite in a filled square fails for this \textit{unfilled} square; see Figure~\ref{fig_ex_interleaving_triangle}(left). This same issue about events is also the one that causes the problem for the other mapping \stintoh\ where we could not say in the \HDA\ that was generated whether this was representing two or three events.



These issues are solved through sculpting since this will allow us to identify the events in a \HDA\ in the same way as ST-structures work with events. We will see that ST-structures capture \HDAs\ which can be seen as \textit{sculptures}. At first the sculpting method seams orthogonal to the history-unfolding aspect because:

\begin{enumerate}
\item There are \HDAs\ which are sculptures but for which their history unfolding is not a sculpture. This is the example of van Glabbeek~\cite[Fig.11]{Glabbeek06HDA}, pictured here in Figure~\ref{fig_ex_Glabbeek}, with the cube with one face missing, and its strange looking unfolding where the corner is split into two.

\item There are \HDAs\ which are not sculptures, but for which their history unfolding is a sculpture. 
Consider the example from Figure~\ref{fig_ex_interleaving_triangle}(right) with the triangle where the end state is reached either through one event or through a sequence of two events.

\item There are \HDAs\ which are sculptures, and also their history-unfolding is a sculpture (of a different dimension though). 
Consider the example from Figure~\ref{fig_ex_interleaving_triangle}(left) of the interleaving square.

\item There are \HDAs\ which are not sculptures and also their history-unfoldings are not sculptures either. This is the example of the game of the angelic vs.\ demonic choice from Example~\ref{ex_game_angelic_vs_demonic}, on page~\pageref{ex_game_angelic_vs_demonic}, that depends on the speed of the players.
\end{enumerate}


\begin{definition}[bulks]\label{def_bulks}
We call a \HDA\ \emph{a bulk} iff there exists a unique cell of highest concurrency (i.e.,  for all ) and all other cells from  are just the faces of this cell . A bulk is simply a single (possibly infinitely-dimensional) cube, and thus denoted  or just  when no confusion can appear.
We work with acyclic and non-degenerate bulks only.
\end{definition}

\begin{definition}[sculptures]\label{def_sculptures}
We say that a  can be \emph{sculpted} from a bulk  whenever there exists an embedding morphism, i.e., injective morphism, , which means that the cells of this \HDA\ are just a subset of the cells of the bulk and the rest of the notions are just restrictions to this subset. 
We call a \emph{sculpture}, a \HDA\ together with a bulk and an embedding morphism. Since a bulk can be equated with its dimension, we will denote a sculpture as .
\end{definition}

It is easy to see that if a \HDA\ can be sculpted from a bulk  of dimension  then it can also be sculpted from any bulk of dimension higher than . This is because any bulk  can be seen as a sculpture from a bulk , with , by taking the trivial embedding  which associates to  any of the cells of  of dimension  and to all the other cells just the corresponding faces. We say that a sculpture  can be over-complicated to become the sculpture  of higher dimension by taking the .
Therefore, we are interested in the minimal bulks, when they exist. We call a sculpture \emph{simplistic} if it cannot be simplified, i.e., has a minimal bulk. A sculpture  can be \emph{simplified} when  and  is also an embedding into the smaller bulk, i.e., .


\begin{definition}[isomorphism of sculptures]\label{def_iso_sculptures}
Two sculptures  and  are isomorphic iff their respective simplistic versions have the same dimension and  and  are isomorphic as \HDAs.
\end{definition}

We can give an equivalent definition without the notion of simplistic versions. We need to over-complicate one sculpture to have the same dimensions. After this we take the obvious isomorphism of the two bulks. If this isomorphism when restricted becomes an isomorphism of the two underlying \HDAs\ then the sculptures are considered isomorphic. 


\begin{remark}
One \HDA\ can be seen as two different sculptures, e.g., from two different dimensional bulks, in both cases being a simplistic sculpture (i.e., it all depends on the embedding morphism). Then this \HDA\ object enters as source object of several sculpture morphisms (as seen in Figure~\ref{fig_ex_asymconflict1}). Because of this we cannot determine from a \HDA\ alone in which sculpture it enters.

Working with history unfoldings is not not particularly good either. The interleaving square from Figure~\ref{fig_ex_interleaving_triangle}(left) can be seen as a sculpture from 2, but its history unfolding can be seen as a sculpture from 3 or from 4; we cannot decide which.
\end{remark}




\begin{proposition}\label{prop_HgivesSculptures}
The mapping \stintoh\ from Definition~\ref{def_STtoHDA} generates \HDAs\ which can be seen as sculptures.
\end{proposition}


But the mapping \stintoh\ from Definition~\ref{def_STtoHDA} does not tell exactly which sculpture it generates, i.e., which is the dimension of the sculpture and the embedding.
The next definition shows how this can be done, thus also giving the proof for Proposition~\ref{prop_HgivesSculptures}.

\begin{definition}[\allST\ to sculptures]\label{def_stintosculptures}
Define the mapping \stintosculpture\ the same as in Definition~\ref{def_STtoHDA} to generate the \HDA\ , only that it also returns a bulk and an embedding, thus a sculpture, as follows.

For  build the bulk , with , by adding one cell  and all its faces are added as in Definition~\ref{def_STtoHDA} for the \HDA\ part using the same listing of the events as used to generate the \HDA. Each cell of the bulk corresponds to a pair of subsets of , i.e.,  with , corresponds to a possible ST-configuration. 
The embedding  is defined as .
We obtain .
\end{definition}

\begin{proposition}
The mapping \stintosculpture\ from Definition~\ref{def_stintosculptures} does not collapse non-isomorphic ST-structures; i.e., for  then  in the sense of Definition~\ref{def_iso_sculptures}.
\end{proposition}

\begin{proof}[sketch]
We prove the contrapositive, i.e., if  then . We show the existence of an isomorphism over the ST-structures, knowing the isomorphism over their translations as sculptures, making use of a fixed listing of events that the maps \stintosculpture\ and \stintoh\ work with.
The rest is tedious details.
\end{proof}


\begin{definition}[sculptures to \allST]\label{def_sculptures_to_ST}
Define a mapping  only over sculptures, which for a sculpture  associates the ST-structure  as follows.
Take a linearly ordered set  (of events) of cardinality as the dimension of the bulk cell . The ST-configurations of  are obtained from the cells of , i.e., .
One ST-configuration  is obtained as  for . The \emph{-chain}  is a sequence of s/t-maps applications (with correct indexes)  where  is either an s-map or a t-map of some correct index . The application of the -chain to a cell returns another cell. We abuse the notation in  and apply an -chain to an ST-configuration w.r.t.\ a predefined listing , which is defined as:  with 

thus returning an ST-configuration.

\end{definition}

Intuitively, for the bulk cell  associate the ST-configuration . For any other cell  of the bulk take a descending chain of s/t maps that reach it from the bulk cell. Build a ST-configuration  starting with  by removing from , if an , respectively adding to the , if a , the corresponding event , where at each level of descent a renumbering of the events is made by removing the  from the list. In the beginning, i.e., at the highest level of the bulk cell and the ST-configuration , the listing of events is in correspondence with the s/t mappings of the bulk cell, i.e.,  corresponds to  (this is kept all throughout the descent).
The mapping \sculpintost\ keeps only those ST-configurations that correspond to cells from the sculpture.

Since a sculpture has finite concurrency then \sculpintost\ returns only finite ST-configurations, even if the bulk may be of infinite concurrency.

\cp{Prove the next!}
\begin{enumerate}
\item The main property to use to prove that the example of van Glabbeek cannot be a sculpture is: In a bulk, for a cell and its unique history, for any two paths in this history and two different states, each on one of these paths, then the two states have associated different sets of events.

\item If a \HDA\ is a sculpture, then the mapping \hintost\ associates to every cell exactly one ST-configuration; in particular, it associates to every state exactly one set of events.

\end{enumerate}



\begin{remark}
Since the ST-structures and Chu spaces over 3 are isomorphic, cf.~Proposition~\ref{prop_STstructChu3}, and since ST-structures capture sculptures \HDAs, which are a strict subset of the \HDAs, we can conclude that the Chu spaces over 3 is not enough to capture all \HDAs, not even the acyclic ones. This observation is supplementing the results of Pratt, and is motivating our investigation in Section~\ref{sec_STCstruct} where we ask how STC-structures and Chu spaces over 4 are capturing non-sculptures and acyclic \HDAs.
\end{remark}

When applied to a sculpture  the mapping \hintost\ from Definition~\ref{def_hdaTOst} can use the extra information that the sculpture gives to determine the events in the \HDA\ correctly.

\begin{definition}[\hintost\ from sculptures]\label{def_hdaTOst_sculptures}
For sculptures  extend the mapping \hintost\ from Definition~\ref{def_hdaTOst} such that instead of using as events the equivalence classes of  cells as defined in Definition~\ref{def_hdaTOst}, it uses the following equivalence classes (as coming from the bulk); denote this mapping \hintostScultures.

Define the relation  with  which is from the sculpture , as 

for some  and , and  part of the bulk. The reflexive and transitive closure of this relation generates equivalence classes denoted as before  and representing the \emph{events}.
\end{definition}

After giving some results on \textit{-chains} we will be able to prove the following theorem.
This theorem intuitively says that if we use the bulk to determine correctly all the cells that are equivalent, i.e., determine the events correctly, then both ways of translating sculptures are correct, i.e., either by using the unfolding method, , or by sculpting out from the bulk directly, \sculpintost.

\begin{theorem}\label{th_on_scultures}
For a sculpture  we have

\end{theorem}


An -chain is a sequence of applications of s/t-maps  of correct indexes, where one member of the chain can be identified with its position in the chain as . This example of -chain has \emph{length} . The -chains are thus meant to be applied to cells, and depending on which cell these are applied to the indexes  must be correctly bounded wrt.\ the dimension of the cell. To an -chain it is natural to associate the list of its indexes as . We define an equivalence relation on -chains that is motivated by the equivalence relation in a bulk on the transition cells, as we gave in Definition~\ref{def_hdaTOst_sculptures}, and also motivated by the cubical laws which apply to such -chains and determine that different chains applied to the same cell give the same resulting cell. We denote this relation on -chains as \chainEquivHDAsculpture.

\begin{definition}
Define \chainEquivHDAsculpture\ on -chains to be reflexive and transitive and respecting the following:
\begin{itemize}
\item[]  iff both have the same length and either
\begin{enumerate}
\item their list of indexes is the same, i.e., ; or


\item they are different by two consecutive maps which satisfy a cubical law: i.e., for some  have .
\end{enumerate}
\end{itemize}
\end{definition}

\begin{definition}
Inside a bulk  define a relation on any two cells  in the following coinductive manner:
\begin{enumerate}
\item ;

\item  iff  for some  (i.e., have the same dimension) and  for some .
\end{enumerate}
\end{definition}

\begin{lemma}
Inside a bulk  if two transition cells are  then the cells are also .
\end{lemma}

\cp{Give Proof!!}


\begin{lemma}\label{lemma_chains_equiv}
Inside a bulk  we have the following double implication:

\end{lemma}

\begin{proof}
We assume  for otherwise it is trivial.

We prove the \textit{left-to-right} implication.
From the definition we have that  iff 
.
If  are the same then we have found the requirements for the right-side of the implication of the claim, i.e., take  and , , i.e., of length , and we have the desired  since their list of indexes is the same.
Otherwise, when , we apply the definition again to obtain that  iff  
 and 
.
Again, if the two cells are the same,  then we can stop the recursive reasoning and exhibit the required elements for the right-side of the implication; i.e.,  and ,  of length  being equivalent  since their list of indexes is the same.
This recursive reasoning always eventually stops in the unique cell  of the bulk.

We prove the \textit{right-to-left} implication.
The two -chains being equivalent have the same length: . From this, two cases are distinguished: one when the lists of indexes are the same; and another when there is a sequence of -chains each pair in the sequence having chains different by a cubical law.

(1) Having  and  using the definition for \cellEquivBulk\ for the base case (i.e., when we work with the same cell) we have . We then use the definition with the standard case and obtain after applying it  times the expected .

(2) There exists a sequence of -chains  each differing from the other by a cubical law instance; in particular, for  and  there exist two indexes  s.t.\ for all other indexes we have  for , and  as a cubical law. Since it does not matter for the equivalence which exact maps the -s are, we assume all these to be the same s-map.
This means that  which by the cubical law means that  to which we apply the rest of the maps to obtain the same cell. This is done for all the -chains in the sequence, obtaining  and by reflexivity we have the result.
\end{proof}


From Lemma~\ref{lemma_chains_equiv} we obtain the following.

\begin{corollary}
Any two chains which are equivalent, , when applied to the bulk cell  result in equivalent cells. 
\end{corollary}

In particular, for a bulk of dimension , any two -chains of dimension  that are equivalent reach the same equivalence class of  transition cells; and also all -chains that reach such an equivalence class are equivalent. Therefore, there is a one-to-one correlation of the equivalence classes of transition cells (i.e., the events of the \hintostScultures) and the equivalence classes of -chains of dimension .
The question is how many equivalence classes of -chains of dimension  are? For our purposes these should be as many as the number of events of \sculpintost.

\begin{lemma}\label{lemma_on_scultures_equalEventSets}
For a listing  of cardinality  and two -chains  of length less than  we have

\end{lemma}

\begin{proof}
The notation  is close to what we used in Definition~\ref{def_sculptures_to_ST} but here we are only interested in the lists of events obtained by removing from the initial list  the events at the indexes corresponding to the chain steps. More precisely, for  of length , define  as  where for one element of the chain the application is defined as  to be the list of length one less than  which is the same as  but with the element on index  removed (in other notation: ).

We prove the \textit{left-to-right} implication.
Having  we assume there is a sequence of -chains each different than the other by a cubical law, i.e.,  with the indexes of  the same as with those of  with the exception of two consecutive ones which enter a cubical law.
(The case when the indexes are the same is trivial.)

Take the first equivalence in the chain , i.e.,  with two consecutive indexes for , with , s.t.\  for  and . Because of this it means that these applied to some list  return the same list, i.e., , and therefore we have .

Now for the  and  we know that they enter a cubical law, which means that  and  (the case for when  has the same argument). It is easy to see that for a list  when removing first an element on a position  higher than a position  which we remove afterwards, it is the same as first removing the element from this lower position  and then removing the element on the position one-lower than , since all the before higher positions than  have been decreased by one after the first removal; i.e., . Therefore, . 
To this last one when we apply the remainder of the two -chains that have the same indexes we obtain the same list, thus the desired result.


We prove the \textit{right-to-left} implication.
Given two -chains of some dimension  their application to the list  is defined as before and results in the same list . Knowing that from an -dimensional list  we obtain the list  of dimension  lower we can view the two -chains and how they are applied to the initial list as a table. Take the rows of the table to correspond to the indexes of the initial list  and take the columns to stand for the element in the -chain; i.e., we have a  matrix. Each application of one element of the -chain removes one different element from the list. The matrix represents the operation of removing the elements by the particular -chain by putting a  value on the position where the element of the -chain is removing the respective element of the list; the rest of the matrix is filled with . In consequence we have a single   on each column (since a chain element is applied only once, and all chain elements remove some element of the list) and on each row (since an element is removed only once) that corresponds to a removed event; all rows corresponding to the events in the remaining list  are completely filled with . 

Each -chain that is applied to the list  and returns the list  is represented by one such matrix with the rows corresponding to the events of  completely filled with . If we remove these empty rows we are left with a square matrix of  which is a \textit{permutation matrix}.

We want to show that . If their corresponding matrices are the same it means that they have the same indexes and the result is trivial.
Otherwise we show that there is a sequence of -chains each different than the previous by a cubical law. Let us understand what it means a cubical law difference in terms of the corresponding matrices. All the indexes are the same with the exception of two adjacent ones. This means that the matrices are the same with the exception of two columns that correspond to the two indexes. The cubical law on these indexes then means the swapping of the two rows of the matrix that have the value  on the two corresponding columns.
See this through the example in Figure~\ref{fig_ex_matrix}.



\begin{figure}[tp]
\begin{tabular}{lll}

&

&
\\
\end{tabular} 

\caption{}
\label{fig_ex_matrix}
\end{figure}



This cubical law change corresponds on the matrices to a \textit{adjacent transposition} on the corresponding permutations. In other words, if two -chains are different by a cubical law then their matrices are different in a adjacent transposition of their corresponding permutation; and each adjacent transposition corresponds to a cubical law change.

Take now the tables of the two given -chains . Since these -chains return the same list then we are in the situation above where we associate to each -chain a square matrix that corresponds to one permutation. It is a known result that any two permutations can be obtained one from the other by a sequence of adjacent transpositions. This means that there is a sequence of matrices that differ only in a cubical law manner, hence the equivalence of the initial -chains.
\end{proof}


\begin{proof}[of Theorem~\ref{th_on_scultures}]
We must exhibit a bijective map  between the events generated by \sculpintost\ and those generated by \hintostScultures, and show that it respects Definition~\ref{def_isomorphism} of being a morphism. 

The set of events generated by \sculpintost\ is , having the cardinality the same as the dimension of the bulk , i.e., , and being linearly ordered. The linear order coincides with the indexes of the mappings from the bulk cell . 

The map \hintostScultures\ generates events which are the equivalence classes given by the relation \eventEquivHDAsculpture\ from Definition~\ref{def_hdaTOst_sculptures} which comes from the bulk .


Intuitively, we define  to associate to each event in , which can be seen as obtained from an application of an -chain, i.e., , an equivalence class which is obtained using the same -chain from the bulk cell . Note that the length of the -chain is related to the cardinality of .
The Lemma~\ref{lemma_on_scultures_equalEventSets} ensures that the definition of the function on events as  is a bijection.

We show that  preserves ST-configurations, i.e., for  then .
By Definition~\ref{def_sculptures_to_ST},  means that  (with  from the sculpture ) reachable in the bulk from the bulk cell by some -chain, , which this -chain determines the ST-configuration, .
Therefore, we want to show that , which amounts to showing that .

We show the following claim, which implies the above expected result.

\vspace{1ex}
\noindent\textit{Claim:}\hspace{1ex} For any  with  and any -chain with  then 

\vspace{0.5ex}

There are three cases to consider depending on , which correspond to the three ways of generating ST-configurations by \hintostScultures\ in Definition~\ref{def_hdaTOst}.

Note that the order on the events in  that \sculpintost\ is considering in Definition~\ref{def_sculptures_to_ST} is the same as the indexes of the maps of the  bulk cell. This is the same as the order of the events the \hintostScultures\ generates since these are the equivalence classes on the  cells of the bulk, which are the same as the equivalence classes of -chains, cf.\ the above results on the correspondence of equivalence of -chains and events. An equivalence class of -chains  is on position  in the listing of the events generated by \hintostScultures\ iff no -chain in this equivalence ends in index .

Since any -chain in an equivalence class generates equivalent cells (when applied to the bulk cell) all these cells will be associated to ST-configurations exhibiting the same set of concurrent events. In particular, any two -chains from an equivalence class that have the same number of s- and t-maps but differ only through cubical laws interchange of their indexes, reach the same cell. All such -chains when applied to the  generate the same ST-configuration. Therefore, we are free to work with any such -chain (not necessarily with the one from the claim); in particular the -chains that are of the form  are of interest, where  and  are, possibly empty, sequences of only s- respectively t-maps.


In a bulk every cell has only one history. 
Nevertheless, in the sculpture a cell may have several histories.
In a history all paths have the same length.
For a cell in the sculpture and for any of its histories, then all the paths in this history are included in the paths of the uniques history corresponding to this cell in the bulk.
The mapping \hintostScultures\ works with the paths in the sculpture, and two such paths there may be from two different histories of the same cell. Nevertheless, in the bulk both paths are homotopic, therefore they will involve the same equivalence classes of  cells, as given by \cellEquivBulk. We are thus free to work in this proof with any path leading to a cell, which may very well not be from the sculpture since the same ST-configuration would be generated. This is not the case for a non-sculpture and the mapping \hintost; all the above are due to the fact that \hintostScultures\ works inside a bulk.
In particular we are interested in paths of the form  where  may be empty, but not .

With the definition of events that \hintostScultures\ uses, if two transitions denote the same event in the sculpture, then they denote the same event in the bulk also. 
The bulk may equate more transitions as the same event; in other words, two events which are considered different in the sculpture may be collapsed in the bulk.

We use induction on the length of the path that reaches the cell that is used to build the current ST-configuration.
The base case is for the initial cell which \sculpintost\ translates into ; to which when  is applied results in the same ST-configuration which is also one of the configurations generated by \hintostScultures. It is easy to see this because in  the initial cell is reachable only through -chains of length  and of only s-maps. The application of such a chain to  results in the root ST-configuration .

Recall that  and that we work with -chains in the form . For the case when we look at a cell of dimension  then we work with an -chain of at most dimension  (with  the dimension of the bulk). So, for the cell  we look at . Taking the application of -chains from Definition~\ref{def_sculptures_to_ST} we have that  with  and ; we thus have  where we denote the two sets involved as . Note that we have used the application of the -chains to lists, as we defined earlier.

Since  has at least two concurrent events, then it also has at least two s-maps; take any two different . The two cells reachable through these two maps are closer to the initial cell and are reachable through paths of length one shorter than the path reaching . Take the two non-equivalent chains that reach these cells to be  and . The ST-configurations that \sculpintost\ associates are  and  and the function  is applied to these in a previous induction step. The application results in:  and ; denote the two new sets as  and .

But  is the same as  but with one event missing, i.e., the one removed by the  map; call this event  and . The same for  where  but with  and . This means that . Therefore, ; i.e., .

By the induction hypothesis we have , for any  reaching , and  for  reaching . Since  were two arbitrary s-maps of , we have the desired result  for any  reaching .

The case for cells  works with -chains of length .
There is a base case for the cells  reachable in one step from the initial cells; these are also reachable only through -chains of only s-maps, denoted . Then  which by the definition of  is .
\end{proof}

\cp{
Can I give results relating the sculptures with configuration deterministic and configuration unique and configuration preserving properties on \HDAs\ as given by van Glabbeek?

Looks like the following:
\begin{enumerate}
\item All sculptures are configuration preserving.
\item All sculptures are configuration deterministic.
Are there \HDAs\ that are configuration deterministic, or configuration preserving but are not sculptures?
\item The example of the interleaving square as a \HDA\ is not configuration unique. But if we see it as a sculpture and take events as equivalence classes from the bulk then it becomes configuration unique.
\end{enumerate}

}

The above proof indicates the following definition and result.

\begin{definition}
Define  to take an ST-structure  and an equivalence relation on its events , and return the ST-structure  with ,  where  is the quotient of  wrt.\ , and  for some .

For a sculpture  the function  applies the equivalence relation \eventEquivFromBulk{n} which is defined over equivalence classes , coming from the Definition~\ref{def_hdaTOst}, as: 

with \eventEquivHDAsculpture\ defined for \sculpture{H}{n} as in Definition~\ref{def_hdaTOst_sculptures}.
\end{definition}



\begin{proposition}\label{prop_eqcircst}
For a sculpture  we have

\end{proposition}

\begin{proof}
Note that in the example of Figure~\ref{fig_ex_asymconflict1} the two \HDAs\ are isomorphic but their sculpture versions are not. Because it preserves isomorphism, the \hintost\ will map the left \HDA\ into the ST-structure on the right over three events, instead of the desired left ST-structure only over two events. But when seen as sculptures, even if \hintost\ maps to isomorphic ST-structures, the equating of the events that  does will transform the left ST-structure into the corresponding two events ST-structure we are expecting, thus breaking the artificial isomorphism induced by \hintost.

\cp{Finish proof!!}
\end{proof}


The following results show a one-to-one correspondence between the ST-structures and sculptures.

\begin{proposition}\label{prop_stSculptst}
For an arbitrary ST-structure \ST\ we have

\end{proposition}



\begin{proposition}
For a sculpture \sculpture{H}{n} we have

\end{proposition}

\begin{corollary}
For an arbitrary ST-structure \ST\ we have

\end{corollary}

\begin{proof}
Proposition~\ref{prop_eqcircst} gives us  which by Theorem~\ref{th_on_scultures} becomes , where the sculpture  that we work with is given by . Finally, the Proposition~\ref{prop_stSculptst} gives the desired result , where the  is the one from the sculpture  obtained from the ST-structure.
\end{proof}



\begin{corollary}
\ 

\begin{enumerate}
\item For any two \HDAs\ where one  cannot be a sculpture and  can be sculpted, then .

\item For any acyclic and non-degenerate  that cannot be sculpted there exists some sculpture  s.t.\ .
\end{enumerate}
\end{corollary}

\begin{proof}
For part 2 the sculpture that we are looking for is given by the application of the mapping \stintosculpture; i.e., take  to be .
\end{proof}

We end this section by making two conjectures related to history unfolding of a HDA. 

For any non-degenerate \HDA\  we have






\notforsubmission{
\cp{
\section{History-aware Higher Dimensional Modal Logic}
}

\cp{
The termination predicate of \cite[def.9.6]{GlabbeekG01refinement} can be defined for ST-structures also, and for \HDAs\ using the set of final states/cells. The \hHDML\ can also express if these are \textit{maximal} using  or  to say that no more events can be started or terminated in a cell/ST-configuration. 
}


\cp{!!!Maybe leave this for a journal version.}

\cp{

\begin{definition}[\hHDML\ interpreted over ST-structures]\label{def_sem_hHDML_ST}
The \emph{history-aware higher dimensional modal logic (\hHDML)} formulas are given by the syntax

with  the atomic formulas and  labels parameterizing the modalities. These formulas are interpreted over an ST-configuration structure in a particular ST-configuration. The modalities  and  are called \emph{during modalities}, and are moving on the s-steps, forward respectively backward; whereas the modalities  and  are called \emph{after modalities}, and move on the t-steps. A representative part of the semantics is:
\begin{center}
\begin{tabular}{@{\hspace{0ex}}r@{\hspace{0.5ex}}c@{\hspace{0.5ex}}l@{\hspace{1ex}}c@{\hspace{1ex}}l}
 &  &  & iff &  s.t.\  an s-step and  \\
 &  &  & iff &  s.t.\  a t-step and 
\end{tabular}\end{center}
\end{definition}


Intuitively, a formula  states that one new event labeled with  should be added to the set of started events  s.t.\ the resulting ST-configuration is part of the ST-structure we are working with, and the formula  should hold.

To prove the Theorem~\ref{th_hhSTmodal} we use the following result.

\begin{lemma}\label{lemma_hhMimicsSteps}
For two structures  and two ST-configurations , with  the required isomorphism given by \hhequiv, when  makes a step as in Def.\ref{def_hh_ST}(2) then if this is an \emph{s-step} (respectively a \emph{t-step}) the corresponding existing step from  is also an \emph{s-step} (rsp.\ \emph{t-step}). The same holds for the backward steps of Def.\ref{def_hh_ST}(4).
\end{lemma}

\begin{proof}
From Def.\ref{def_hh_ST}(2) we have that  is an isomorphism of ST-configurations and that for the s-step (rsp.\ t-step)  (rsp.\ ) there exist an isomorphism of ST-configurations  extending  (i.e., ) and there exists a step  with  an isomorphism of  and  (because ). Since  and  then , and thus . Since  and  then , and hence  and  must be new in  since  is an isomorphism. Therefore we have . This shows that we have an s-step . When we work with a t-step we have that  implies ; and  implies , making , which is a correct ST-configuration since  and  agreeing with  on  make .

For Def.\ref{def_hh_ST}(4) we have that  and  is isomorphism between  and  (which both configurations have a step to the initial configurations and for the not primed versions this step is clearly an s-step) and is the restriction of  to . Since  then  thus . Since  then , which is the same as  and thus  which is the same as  (because of  being an isomorphism). Since  we have that  is a correct ST-configuration that has a t-step to the configuration .
\end{proof}
}

\cp{!!!Maybe leave this for a journal version.}

\cp{
\begin{theorem}[modal equivalence and\ \ \hhequiv]\label{th_hhSTmodal}
For rooted, connected, and adjacent-closed ST-structures, the modal equivalence induced by \hHDML\ coincides with \hhequiv\ when considering image-finite structures of finite concurrency.
\end{theorem}

\begin{proof}
The easy part of the proof is to show that . This means showing that for two structures  and two ST-configurations , with  the required isomorphism given by \hhequiv, we have that  iff , for any \hHDML\ formula . The proof is by induction on the structure of the formula  where the base case and the propositional logical operators are easy. We argue for the four modalities.

When  the fact that  is equivalent by semantics of Def.\ref{def_sem_hHDML_ST} to the fact that there exists an s-step  with . Where from the hh-equivalence of the two configurations we have that there exists also a step  with , which by Lemma~\ref{lemma_hhMimicsSteps} is also an s-step. Now using the inductive hypothesis with  and  we get that , hence by the semantic definition being equivalent to .

The arguments for the remaining three cases are analogous, working with the respective forward or backward steps of Def.\,\ref{def_hh_ST} and using Lemma~\ref{lemma_hhMimicsSteps} to account for the fact that these are indeed s- or t-steps, depending on the case.



To show the inclusion  we show that for any two ST-structures, , we can always construct from \modalequiv\ a relation  with the properties of Definition~\ref{def_hh_ST} of being a  between the two ST-structures, and thus . The construction is done in stages, each stage dealing with all the ST-configurations reachable within a certain number of steps from the initial . The first stage considers reachability within 1 step, the second stage considers ST-configurations reachable in 2 steps, etc. The reasoning at one stage is carried out inductively using the results at the previous stages.

Since we work with rooted structures we consider that the initial configurations are related by , with an empty isomorphism. These are modal equivalent.

Each pair of configurations that will be in the  relation are also modal equivalent. This will be part of the inductive reasoning, where the initial empty configurations make up the basis of induction. This is true because  implies that the initial empty configurations are modal equivalent.

We will now consider configurations that are reachable from the initial configuration \textit{only} through s-steps.
In fact, only such configurations can be found at the first stage. Only starting from the second stage we may find configurations also reachable through t-steps.

For the requirements 2 and 3 of Definition~\ref{def_hh_ST} we use a standard modal argument based on the fact that the ST-structures that we consider are \textit{finitely branching}. This fact will also be used later to arrive at contradictions when using a \textit{reductio ad absurdum} proof technique. We will also use the fact that the ST-structures that we consider have \textit{finite concurrency}.

No induction is needed here, but we will have to keep in mind all the possibilities of achieving the requirements 2 and 3. For the final part we will use induction and show that we can find one of these possibilities to respect the requirement 4 of Definition~\ref{def_hh_ST}.

For the requirement 2 of Definition~\ref{def_hh_ST} take  with  a configuration from \ST\ and . For any s- or t-step  (where  and , with , if we look at an s-step, or  and , with ) in  we must show that there exists a corresponding step in \ST' with .

The modal argument is as follows. Assume the step in \ST\ is an s-step (an analogous arguments is given for a t-step)and thus  therefore  saying that in \ST'\ is also found a corresponding a-labeled s-step to some . From the image-finite assumption there are finitely many reachable  in this way. Assume that none of them is modally equivalent to . This means that there would be one formula  which holds in  but not in the corresponding . This means that the original  whereas in \ST\ we have . Since the two initial configurations are modal equivalent, satisfying the two formulas above results in a contradiction.

So there exists at least one step in \ST'\ reaching a modally equivalent configuration; there may be several. For each such configuration  and its pair  we can construct an isomorphism by extending the original . If we were dealing with an s-step then make the new isomorphism  be the same as  with the addition of  for the new event  and the corresponding one in the step of . 

If it were a t-step we do not need to do anything to  but we must make sure that the step in \ST'\ corresponds to the right restriction of . Assuming a contradiction, we can always change the isomorphism to account for the correct events. This is similar to the way we change the isomorphism in the following.
\cp{This step needs more elaboration.}

We now proceed to show how from all the possibilities offered by the choice of isomorphisms in the above arguments we can always find one isomorphism that would satisfy also the last requirement 4 of Definition~\ref{def_hh_ST}.

The basis case for configurations reachable from the empty configuration in one step is easy. The only possible step is an s-step. And thus, the only possible backward step reaches the empty configurations which are modal equivalent. Any isomorphism would be good because by removing the single event we remain with the empty isomorphism.

Consider now configurations at stage 2, reachable through a path of the form , where we consider only s-steps. The labels are not essential for the proofs, so we may always write the same label on the transitions. There is one other back step from  to . The initial path is modal equivalent to  in \ST', and in  we have .
The adjacent-closure tells us that  and  are the only alternatives, therefore they must by modally equivalent for the requirement 4 to hold.

\end{proof}

For rooted, connected, and adjacent-closed ST-structures, the \hHDML\ modal equivalence coincides with \hhequiv\ (cf.~Def.~\ref{def_hh_ST}).


The notion of \textit{concurrent step} \cite[def.7.1]{GlabbeekG01refinement} can be defined over ST-structures (or \HDAs) and captured in the \hHDML\ logic by restricting the language of the logic to using only syntactic definitions of the form  interpreted in the states (cells of dimension ) of the \HDAs. The syntactic definition for a multiset of labels  is  where  is  with  (analogous for ). The concurrent steps of \cite[def.7.1]{GlabbeekG01refinement} become just  with  and  for , if the ST-configuration  is reachable from  through a sequence of only s-steps. The standard Hennessy-Milner logic formulas and the transitions in labeled transition systems are the restriction of concurrent steps and formulas from above to  being a singleton set.

}

}





\section{Action refinement for ST-structures}\label{subsec_actref}

We define the notion of \textit{action refinement} \cite{GlabbeekG01refinement} for ST-structures  using a \textit{refinement function} . The  is a non-empty ST-structure which is to replace each and all events that are labeled with . In this way, what before was abstracted away into a single event, now using action refinement, can be given more (concurrent) structure. The definition of \reffun\ is over all action labels of , but normally only a (small) subset of actions is refined, whereas the rest should remain the same. For all such actions just refine with a singleton ST-structure labeled the same 
(i.e.,  with  a new event).

\begin{definition}[action refinement]\label{def_actref}
Consider  over  an \emph{ST-structure to be refined} by a \emph{refinement function} . We call the pair of sets  \emph{a refinement of an ST-config\-uration  by \reffun} iff:

where each  is a non-empty and non-maximal ST-configuration from  and each  is a maximal ST-configuration from .
The refinement of\,\ \ST\ is defined as  with
\begin{itemize}
\item ;
\item .
\end{itemize}
\end{definition}

Note that because of the closure restriction in the definition of ST-structures, any maximal ST-configuration, wrt.\ set inclusion, must have both  and  equal.

\begin{proposition}[refinement is well defined]\label{prop_ref1}\ 

For two isomorphic ST-structures  and two isomorphic refinement functions, i.e.\ , we have: 

\begin{enumerate}
\item  is also an ST-structure;
\item ; and
\item .
\end{enumerate}
\end{proposition}

\begin{proof}
We first have to show that every set  is a well defined ST-configuration. This is easy to see because we use unions in the definition of  and in the right-most unions the resulting  and  sets are the same, whereas in the left unions all events in the  sets are also in the  sets because they are build from ST-configurations , i.e., . Union of sets preserves set inclusion.

We need to show now that for any set  there is the case that . Assume that  is a refinement of some  and assume there are some events  and that we have used some ST-configuration  from .
(Otherwise, when  it implies, by construction, that also .)
Because the refinement function uses only ST-structures then it means that in  there is also an ST-configuration . 
If  is maximal, then the refinement of  that uses it will result in the desired .
Otherwise, when  is not maximal, by the Definition~\ref{def_actref} it means we eventually build another refinement of  using this . Therefore, we would have both the  and  sets the same. These arguments must be carried for all events  to obtain the desired .

The final step is to show that the new labeling function  is correctly build in the sense that for each new event it assigns some label, in fact the correct label coming from the refining ST-structures given by \reffun. The definition of  is for every new event  where  is from the old ST-structure and  is from the new refining structures. The new label is the same as the corresponding label in the ST-structure where the  comes from.

The refinement operation is well defined also wrt.\ isomorphic structures.
\begin{itemize}
\item For a \ST\ and two isomorphic refinement functions  and , i.e.\ , then .
\item For two isomorphic ST-structures  and some refinement function  we have that \linebreak .
\end{itemize}

The proof uses the fact that isomorphic ST-structures agree on the labeling functions, and uses similar arguments as above.
\end{proof}


\begin{proposition}[preserving properties]\label{def_ref3}\ 

The refinement operation preserves the properties of the refined structure, i.e., for some  and :
\begin{itemize}
\item If\,\ \ST\ is rooted then  is rooted.
\item If\,\ \ST\ is connected and all  are connected then  is connected.
\item If\,\ \ST\ and all  are adjacent-closed then  is adjacent-closed.
\item If\,\ \ST\ and all  are closed under bounded unions (or intersections) then  is closed under bounded unions (rsp.\ intersections).
\end{itemize}
\end{proposition}


\begin{proof}
The property of being rooted is easy. 

For connectedness consider some non-empty  which is a refinement of some (non-empty) . The fact that is non-empty it implies that  an event, which by the definition of refinement it means that  comes from . Therefore  is also non-empty. By the connectedness of the original  it means that there exists some  s.t.\ either (1)  or (2) .

Assume that (1)  and take a refinement of it where for all events different than  we take the same ST-configurations  as we did in the refinement . This means that  has all the events of  and on top it has some more events coming from the refinement of . If there is only one such event , as for example coming from refinement with a , then the proof is finished since we found this event which if removed from  we obtain a new ST-configuration which is also in . Therefore, consider the case when there are more events  as coming from some chosen ST-configuration . Since  is also connected it mean that we can find some event  s.t.\ either  or . No matter which is the case we have the following: one refinement of  is  using  and another refinement of the same  uses all the same ST-configurations except for , in place of which another ST-configuration is used which has exactly one less event. This concludes this case, as we found the single event  which can be removed to obtain another refinement.

Assume (2)  and take the refinement of  the same as that for . This is possible because before, in ,  was part of  and thus it was refined using some maximal configuration . But since now  we can refine with any configuration from , and hence also with the maximal one . Because  is connected then there exists some event  in the maximal configuration  s.t.\ . Use this configuration to refine  instead of the one  used to obtain . In this way we obtain a refinement configuration in  that differs from  by one single event .

For bounded unions and intersections the proof should be similar to that in \cite[Prop.5.6]{GlabbeekG01refinement} and should use argument specific to ST-structures as we used above.

We concentrate on the new property of adjacent closure. 
One can prove this directly using Definition~\ref{def_adj_ST} of adjacent-closure and take (more tedious) cases.
We will take the alternative route through Proposition~\ref{prop_adj_equiv} and use the closure under single events. This results in fewer cases to consider.

Therefore, we want to show that for some arbitrary , being a refinement of some  we have
\begin{enumerate}
\item  and
\item .
\end{enumerate}
Since  it means that  and , where  is the chosen ST-configuration. Because  is closed under single events, the first requirement then says that also . Take now another refinement of  that is the same as before only that in place of  uses . Clearly this new refinement has all the event of the old refinement with the exception that now the event  is also contained in . This proves the first requirement.

To show the second requirement consider the existence of  and the same argument applies as before. The only difference is that the new  may in fact be . In this case we use the fact that the original  is closed under single events and thus, for the  we can find . Take the refinement of this which will have all the event of the old one, except the one  which is not in  anymore.
\end{proof}

Single steps in the new structure relate to steps in the old structure, before the refinement, and the refining structures given by \reffun. A single s-step in the refined structure comes either from a single s-step in the old structure, and thus coupled with an initial step in \reffun\ (i.e., one like ) or only from an s-step in the \reffun\ (with the ST-configuration unchanged). \cp{What about t-steps??}

\begin{proposition}\label{prop_hhPreserved}
The hh-bisimulation is preserved under action refinement; i.e., 

\centerline{for \ \ then\ \ .}
\end{proposition}


\begin{proof}
We consider given a hereditary history preserving bisimulation (hh-bisimulation)  that relates the two initial ST-configurations of  and . We construct a relation  between the refinements  and  which will also equate their initial empty configurations, and we show that it respects the restrictions of Definition~\ref{def_hh_ST} of being a hh-bisimulation.

We will also show that the proof works also when we consider  to be only history preserving bisimulation. Moreover, we point out how the proof can be changed to show a result where we do not refine with the same refinement function, but with refinement functions that are also hh-bisimilar (or only h-bisimilar in the other case).

Define  as:

 iff  s.t.
\begin{enumerate}
\item  is a refinement of ;

\item  is a refinement of  that uses the same choices as doe for ;

\item  is defined as .
\end{enumerate}

When we want to prove the result for hh-bisimilar refinement functions  then we need to complicate the definition of  by adding one more requirement:
\begin{enumerate}
\setcounter{enumi}{3}
\item , with  the refining configuration that makes ,  s.t.\ , with  being the hh-bisimulation relating the refinement choices for the label  for ;
\end{enumerate}
and we also need to change the requirement 3 above to satisfy .

It is not difficult to see from the definition above that because  then also  .
It remains to prove the restrictions of Definition~\ref{def_hh_ST}.

\begin{enumerate} 
\item We prove that  is an isomorphism of  and . Since  is an isomorphism between  and  then, by Definition~\ref{def_isomorphism},  is an isomorphism of  and  that agrees on the  and that preserves the labeling. In consequence, when the refinement  involves some event  then the isomorphic image  has the same label, hence it is refined with the same ST-structure . Here is where the constraint 2.\ in the definition of  says to make the same choice of .
By the definition of , this is also an isomorphism of  and  since we use the same events . It is easy to see that  agrees on . The  also preserves the labeling function of the new refinements because the new events get the label of the second component  which is related to the label of either  of , which are the same.

When proving the proposition for two bisimilar refining functions then the argument above works because of the extra requirement 4. This gives an equivalent configuration to pick when obtaining , i.e., pick . Then in the definition of  we use not the same  but an isomorphism , therefore the  is also an isomorphism.

\item We prove the second requirement of Definition~\ref{def_hh_ST} and assume there is a step  in the refinement , for . This is equivalent to saying that we have  satisfying the three requirements from before, i.e., that  is a refinement of ,  is a refinement of  with the same choices, and that .
We take cases depending on what kind and how did this step get formed.
\begin{enumerate}
\item When we work with an s-step which is formed from an s-step in the refinement and the same  in the original \ST.
The s-step comes from a configuration  corresponding to refining some . More precisely, if  and knowing that the above s-step is in  and therefore also in , since the isomorphism  preserves labeling, the the s-step we are assuming, i.e.,  is obtained by having  also a refinement of  with the same choices as for  with one difference: . Which means that one new event is added to , and that is .
Knowing that  is a refinement of  which is in relation  with  and , then we take another refinement of , the same as  in all respects except that for the event  we take the configuration  (which we know from before that it exists, because the above step exists in ). Denote this new refinement as  which has the difference in the ST-configuration , i.e., the single step that we are looking for adds the new event . Clearly there is a single s-step . Moreover, the new configurations are in the relation we built  where  extends  with .
It is easy to show this last statement, using the definition for  above. Just take the same , and thus have that  is a refinement of  by construction, and  a refinement of  using the same choices (in particular choosing  for refining ). It is easy to see that  respects the condition 3 since is extends  which does.

\vspace{1ex}We are interested how the proof changes when working with two refinement functions. Because the refining configurations are hh-bisimilar it means that instead of the same configuration as before, we find a bisimilar one which comes as an s-step extension of the old one; i.e., we find . In consequence the isomorphism is extended with .

\vspace{1ex}The rest of the three cases are similar and we skip their details.\vspace{1ex}

\item When we work with an s-step which is formed from an s-step in the original \ST, and a minimal s-step in the refinement.
More precisely, this step comes from the step  and some initial step  in  in the following way. Take  to be the refinement of  which is exactly like  on the sub-configuration  and for the new event  it uses the above ST-configuration , which is non-empty. This new ST-configuration refinement has extra to  the event .
Because  then a matching step exists  , where  extends  and is also an isomorphism, hence preserving the label of .
In consequence, we can find the refinement  of  to be the same as  and for the new event  choose the same non-empty minimal ST-configuration .
One can show that  and  extends , from the unrefined case. All the restrictions from the definition of  are satisfied and the extension of the isomorphism is the case because .

\item When we work with a t-step which is formed from a t-step in the refinement and the same  in the original \ST.

\item When we work with a t-step which is formed from a t-step in the original \ST, and a maximal t-step in the refinement.
\end{enumerate}

\item The third requirement of Definition~\ref{def_hh_ST} is symmetric to the one above.

\vspace{1ex}By this point we have proved that the history preserving bisimulation alone is preserved under action refinement, because in the proof we did not make reference to the backwards step requirements on the original . Moreover, in when working with two bisimilar refinement functions we again did not make reference to the backwards steps.

\item Proving the forth requirement of Definition~\ref{def_hh_ST}, i.e., for backwards steps.
Similar arguments as before are used only that we remove events, instead of adding. The same cases need to be considered depending on what kind of steps we are working with.
\end{enumerate}
\end{proof}

From the proof of the above proposition one gets also that the history preserving bisimulation is preserved under refinement. The proof can also be extended to show that these bisimulations are congruences for action refinement.


\cp{
\begin{proposition}
ST-trace equivalence and cc-equivalence are preserved under action refinement.
\end{proposition}

\begin{proposition}
Action refinement for higher dimensional automata is defined by replacing transitions by new \HDAs. This result should be deducible from the refinement on adjacent-closed ST-structures.
\end{proposition}
}


\section{STC-structures}\label{sec_STCstruct}


We extend ST-structures (following Pratt \cite{Pratt03trans_cancel}) to include the notion of \textit{cancellation}, and call this extension \textit{STC-structures}. These are richer than ST-structures, acyclic \HDAs, or the inpure event structures of \cite{GlabbeekP09configStruct}. 
STC-structures overcome several shortcomings of ST-structures: the inability to associate a natural \textit{termination predicate}, as Example~\ref{ex_termination} illustrates;  they do not properly capture the behavior of \textit{\HDAs\ with cycles}, cf.~Example~\ref{ex_shutdown}; and cannot distinguish the angelic vs.\ demonic choices, cf.~Example~\ref{ex_agelicdemon}. Some kind of cycles can be captured by ST-structures alone, but some more convoluted cyclic \HDAs\ require notions of cancellation also, as Example~\ref{ex_shutdown} illustrates. 
Note also that STC-structures model well the two examples of \HDAs\ from Figure~\ref{fig_ex_Glabbeek} when the dotted transitions are added. But without these transitions, i.e., only over the three events, the STC-structures also equate the two example \HDAs. Therefore STC-structures do not manage to distinguish that one is a sculpture and the other is not.

\begin{definition}[STC-structures]\label{def_STCstructures}\ 

An \emph{STC-configuration} over  is a set triple , with  finite, respecting the following restrictions:
\begin{center}
\begin{tabular}{rl}
(start before terminate) & ;\\
(cancellation) & .\\
\end{tabular} 
\end{center}
An \emph{STC-structure} is a tuple , with  a set of \emph{STC-configurations} over , the labeling function  defined as for ST-structures, and satisfying:

\end{definition}

\begin{proposition}
ST-structures are strictly included in the STC-structures.
\end{proposition}

\begin{proof}
For an arbitrary ST-configuration associate the STC-configuration with the same S and T sets and .
The simple Example~\ref{ex_agelicdemon} shows the strictness.
\end{proof}


\begin{example}[angelic vs.\ demonic choice]\label{ex_agelicdemon}
The simple example, used by Pratt \cite[sec.3.3]{Pratt03trans_cancel}, of angelic vs.\ demonic choice at the level of the events (not actions) cannot be captured in the general event structures of \cite{GlabbeekP09configStruct}. 
This example involves three events, with  and  conflicting (i.e., a choice between them is made) and are causally depending on . Branching semantics normally distinguish two systems, depending on when the choice is made. Their STC-structures are given in Figure~\ref{fig_ex_angelicdemonic} where the (left) makes a late choice and the (right) an early choice. But when removing the third component  of all the STC-configurations, the two resulting ST-structures are the same. No ST-structure over three events can make this distinction between the two kinds of choices.
As \HDAs, the angelic choice can be seen as a sculpture from a 3-bulk, but the demonic choice cannot be seen as a sculpture.
\begin{figure}[tp]
\psfrag{000}{{\scriptsize }}
\psfrag{a00}{{\scriptsize }}
\psfrag{aa0}{{\scriptsize }}
\psfrag{a0b}{{\scriptsize }}
\psfrag{a0c}{{\scriptsize }}
\psfrag{aab}{{\scriptsize }}
\psfrag{aac}{{\scriptsize }}
\psfrag{acab}{{\scriptsize }}
\psfrag{abac}{{\scriptsize }}
\psfrag{acacb}{{\scriptsize }}
\psfrag{ababc}{{\scriptsize }}
  \begin{center}
    \hspace{-2ex}\includegraphics[height=1.2cm]{figures/figure5}
  \end{center}
\caption{Angelic vs.\ demonic choice at the level of the events , not actions.}
\label{fig_ex_angelicdemonic}
\end{figure}
\end{example}



For STC-structures the computational interpretation simply extends the s- and t-steps from ST-structures by not changing the  component. Moreover, two \textit{cancellation steps} are added. There are several kinds of cancellation steps, but in all of them progress must be made, hence the start or termination of a single event must occur. A cancellation step may cancel only one or more events, or may both cancel and enable events.

\begin{definition}[cancellation steps]\label{def_c_steps}\ 

A \emph{cancellation step} between two STC-configurations is denoted , with , and defined as:
\begin{enumerate}
\item Single event and canceling only:
\begin{description}
\item[cs-step:] , , , ,  and ;
\item[ct-step:] , , , ,  and .
\end{description}

\item Multiple events and canceling only:
\begin{description}
\item[cs-step:] , , , ,  and ;
\item[ct-step:] , , , ,  and .
\end{description}

\item Multiple events and both canceling and enabling:
\begin{description}
\item[cs-step:] , , , , , and ;
\item[ct-step:] , , ,  and .
\end{description}
\end{enumerate}
\end{definition}


The single event cancellation steps are not enough to model the cyclic structures, where an event cancels all remaining events of a repetition, like in Example~\ref{ex_shutdown}. This would motivate the cancellation steps where more events may be canceled at once. But the Example~\ref{ex_game_angelic_vs_demonic} suggests that such cancellation steps may not be enough, and the preferred would be those that also enable events.

Note also the extra condition in the \textbf{cs-step} which ensures that currently canceled events cannot be started. This condition is implicit (deducible) in the other kinds of steps, but for this particular kind of step it may be that the same event that is started belongs to the canceled events and is removed (enabled) in the current step; this would result in a correct STC-configuration. We disallow such steps.

Moreover, if we choose to work with \textbf{cs-step} we need to relax the constraint on STC-structures so that it no longer requires , the set of canceled event to increase.

We could even give a very general form of steps, to include s/t steps and cancellation steps. We just need to relax the first two kinds of cancellation steps to allow for the set of canceled events to not increase (i.e., be  respectively ). Or we could just combine these first two into one single s/t step that can cancel , or several events. We can generalize this even more by enabling events, and thus include the third kind of cancellation too.

For pedagogical reasons we prefer to stick with the clearly split definition from above.

\begin{example}[game of angelic vs.\ demonic speed]\label{ex_game_angelic_vs_demonic}
Consider the following game of two players, where the ``demon'' player and the ``angel'' player each are having a task to do, i.e., the respective events labeled by  respectively . If the angel finishes first she gets to choose the next action to do, whereas if the demon finishes first he gets his initial choice. Both the demon and the angel are starting at the same time and their tasks are going in parallel. The two choice that are to be made are  (good) and  (evil); with  being the winning preference of the angel and  the preference of the demon.

This example is nicely depicted as a \HDA\ which is not a sculpture and is non-degenerate and acyclic (see Figure~\ref{fig_ex_angelicdemonic_game}(left)). Moreover, this \HDA\ is also its own history-unfolding. This \HDA\ puts together the angelic and demonic choice patterns in a single system. This example is not representable as ST-structures.
But it is representable as an STC-structure.
The computational steps in this STC-structure involve cancellation of both angelic and demonic kind. It is not enough to use simple cancellation steps because when the  event finishes then the canceled events must be removed so to give the appropriate angelic choice. Events must be enabled again in such a step.

\begin{figure}[tp]
\psfrag{000}{{\scriptsize }}
\psfrag{a00}{{\scriptsize }}
\psfrag{aa0}{{\scriptsize }}
\psfrag{a0b}{{\scriptsize }}
\psfrag{a0c}{{\scriptsize }}
\psfrag{aab}{{\scriptsize }}
\psfrag{aac}{{\scriptsize }}
\psfrag{acab}{{\scriptsize }}
\psfrag{abac}{{\scriptsize }}
\psfrag{acacb}{{\scriptsize }}
\psfrag{ababc}{{\scriptsize }}
  \begin{center}
    \hspace{-2ex}\includegraphics[height=3.2cm]{figures/figure9}
  \end{center}
\caption{The game of angelic vs.\ demonic speed (on the left) as a non-sculpture. \newline On the right is a related sculpture which does not capture the example, not even when spiting the events.
}
\label{fig_ex_angelicdemonic_game}
\end{figure}
\end{example}



\begin{example}[termination]\label{ex_termination}
Instead of considering any maximal configuration to be terminal we want to have a more general \textit{termination predicate} over ST-configurations, as is done in \cite[Def.4.1\&Def.5.1]{GlabbeekG01refinement} for event structures and configuration structures. But there a configuration can be terminal only if it is maximal, which is a natural requirement that we want to stick with.
Take now the ST-structure for asymmetric conflict from Fig.~\ref{fig_ex_asymconflict1}(middle) where both ST-configurations  and  should be final, but only  is maximal. The same issue appears for the ST-structures that we discuss below for the two cyclic \HDAs\ from Fig.~\ref{fig_ex_STC_structs}(middle-right and right). But note though that it is very natural to assign \textit{final cells} to these two \HDAs: they are  respectively .

STC-structures make it natural for maximal STC-configurations to be terminal. Take the STC-structure for asymmetric conflict from Fig.~\ref{fig_ex_STC_structs}(left) where both  and  are maximal.
\begin{figure}[tp]
\psfrag{e}{\scriptsize }
\psfrag{d}{\scriptsize }
\psfrag{f}{\scriptsize }
\psfrag{00}{{\scriptsize }}
\psfrag{d0}{{\scriptsize }}
\psfrag{e0}{{\scriptsize }}
\psfrag{de0}{{\scriptsize }}
\psfrag{ee}{{\scriptsize }}
\psfrag{dd}{{\scriptsize }}
\psfrag{ded}{{\scriptsize }}
\psfrag{dede}{{\scriptsize }}
\psfrag{dfd}{{\scriptsize }}
\psfrag{dfdf}{{\scriptsize }}
\psfrag{001}{{\scriptsize }}
\psfrag{d01}{{\scriptsize }}
\psfrag{e01}{{\scriptsize }}
\psfrag{ee1}{{\scriptsize }}
\psfrag{dd1}{{\scriptsize }}
\psfrag{ded1}{{\scriptsize }}
\psfrag{dede1}{{\scriptsize }}
\psfrag{q11}{}
\psfrag{q12}{}
\psfrag{q13}{}
\psfrag{q131}{}
\psfrag{q14}{}
\psfrag{q141}{}
\psfrag{q21}{\scriptsize }
\psfrag{q22}{\scriptsize }
\psfrag{q23}{\scriptsize }
\psfrag{q24}{\scriptsize }
\psfrag{q3}{}
\psfrag{0}{{\scriptsize }}
\psfrag{0d}{{\scriptsize }}
\psfrag{0e}{{\scriptsize }}
\psfrag{0ed}{{\scriptsize }}
\psfrag{sd0}{{\small \begin{rotate}{125}\end{rotate}}}
\psfrag{se0}{{\small \begin{rotate}{45}\end{rotate}}}
\psfrag{sed}{{\small \begin{rotate}{45}\end{rotate}}}
\psfrag{hh}{{\scriptsize }}
\psfrag{iso}{{\scriptsize }}
\psfrag{niso}{{\scriptsize }}
\psfrag{i}{i}
\psfrag{ii}{ii}
\psfrag{iii}{iii}
\psfrag{iv}{iv}
\psfrag{v}{v}
  \begin{center}
    \includegraphics[height=2.9cm]{figures/figure6}
  \end{center}
\caption{STC-structure for \textit{asymmetric conflict}  (i); ST-structure for shutdown-backup Ex.~\ref{ex_shutdown} (ii), and a cyclic \HDA\ for its cyclic extension (iii); a cyclic \HDA\ for  (iv); a cyclic and degenerate \HDA\ for . Maximal configurations and final cells (i.e., from the set ) are in bold.}
\label{fig_ex_STC_structs}
\end{figure}
\end{example}


\cp{
The \HDA\ from Figure~\ref{fig_ex_STC_structs}(v) can be expressed with STC-structure but under the multiple-cancellation steps since the  temporarily cancels all the  events except the current  until both  and   (which can run in parallel) are finished; after this all the  events are enabled again to run as a Kleene-star.
}

\begin{example}[shutdown-backup]\label{ex_shutdown}
Initially one may model a linux-like system abstractly using two events labeled  for \textit{shutdown} and  for \textit{backup}. At later, more concrete stages these actions may be refined in processes with more structure, eg., part of a shutdown various actions are performed, like closing web or database services. 
The  and  are considered as being done concurrently, but at this abstract level of modeling the only clear constraint that we have is that  must wait for  to finish, before itself may finish. 
This does not mean that we first perform the  and after it is finished we start the . 

This example is modeled in Fig.~\ref{fig_ex_STC_structs}(middle-left) as the three sides of the square for the asymmetric conflict but with the inside filled in, to model the fact that the two actions can happen concurrently. 
This example cannot be captured in the event structures of \cite{GlabbeekP09configStruct}, nor configuration structures, nor adjacent-closed ST-structures, nor non-degenerate \HDAs.
This example is not adjacent-closed. As a \HDA\ this is \textit{degenerate} because one of the  maps of the inside cell is missing. Moreover, this example is not closed under unions nor intersections, but it is rooted and connected.



This example is naturally extended to one involving cycles in \HDAs.
We now say that the system performs \textit{backup on a constant basis}, in a loop. But the shutdown may be issued at any time point. Therefore, we model the shutdown as happening concurrently with all the backup events. As soon as a shutdown is started, the currently running backup (if any) is allowed to finish, but no other backups may start before the system shuts down. (Naturally, no more backup can be performed after a shutdown).

This is not a simple parallel composition , which is modeled by the cyclic \HDA\ of Fig.~\ref{fig_ex_STC_structs}(right), but it is modeled as the cyclic \HDA\ from Fig.~\ref{fig_ex_STC_structs}(middle-right) which is like the parallel square but with the two lower corners   equated.
Both these \HDAs\ are non-degenerate. The (right) one can be encoded as an ST-structure over the set of events  by thinking of unfolding the cylinder \HDA\ into infinitely many copies of the parallel square attached one after the other.
An unfolding for the (middle-right) example is not easy to see. But it is naturally encoded as an STC-structure over the same set of events, but where the  component of the STC-configurations takes care of the cancellation of infinitely many copies of the backup events. The complete description is given in the Appendix, but intuitively, whenever the  is executed it cancels all the remaining backup events, i.e., those that do not appear already in the  or  sets; until then  events can happen in sequence.

Essential is that when removing the  component from the above STC-structure we obtain an ST-structure isomorphic to the one for the . Therefore, the two cyclic \HDAs\ cannot be distinguished using ST-structures, even before thinking of termination.
 


We describe the set of STC-configurations that form the STC-structure over the events  which describes the shutdown-backup example pictured as the cyclic \HDA\ of Figure~\ref{fig_ex_STC_structs}(middle-right). We define this set as a union of sets  with  used just for notation purposes, and  used as an index correlated with the index of the  events, as we see further.











But note that  since  is the same as .
Each set from above contains STC-configurations that have a pattern in the sens that in an unfolding of the cyclic \HDA\ these STC-configurations would always represent the same corner. For example, the set  contains the root of the STC-structure, when  since the STC-configuration is just , but it also contains another starting corner  which is the STC-configuration after one backup has happened and at which point the same parallel behavior of  with the next backup event can start.

There are steps between these STC-configurations that can be viewed as between  sets, i.e., as between appropriate STC-configurations from those sets. These are \textbf{cs-steps} labeled by  between STC-configurations of  and ; \textbf{s-steps} labeled by  between  and ; and \textbf{s-steps} labeled  between  and .
There are now \textbf{t-steps} between  and ; these would contribute to forming the fix-point. Note that this last step goes to the next iteration level since one backup event has terminated and we may now start all the process again, but with the other remaining backups, hence working from .
As we can see cancellation happen in the step above on the start of the shutdown event, cancellation can also happen on the termination of  as with \textbf{ct-steps} labeled by  between  and .

The \textit{final} cells of the \HDA\ now correspond to \textit{maximal} STC-configurations, and these are exactly those from .

The example with the cyclic \HDA\ the is pictured as a cylinder in Figure~\ref{fig_ex_STC_structs}(right) can be captured only using the ST-structures. Even more, this example can be obtained from the above when transforming an STC-structure into an ST-structure by removing (making empty) the  component. From the above one can see that after such a translation (i.e., remove the third part) the sets  and  would become the same; and the same happens to  and . But this is natural when looking at the cyclic \HDA: there, when going from the \HDA\ of Figure~\ref{fig_ex_STC_structs}(middle-right) to the one in Figure~\ref{fig_ex_STC_structs}(right) two more identifications of cells are made, i.e., the two upper corners and the left with the right transitions.
\end{example}


\subsection{Correspondences with Chu spaces}

We first show the correspondence between ST-structures and the Chu spaces over 3 of Pratt \cite{Pratt00HDArev}. The latter can be represented in terms of the 3-2 logic over , the set of events. Instead of two values for each event,  not started and  finished (or before and after), the 3-valued case introduces the value of \executing\ to stand for \textit{during}, or \textit{in transition}. These values are ordered as , which extends to the whole .

Note that configuration structures \cite{GlabbeekP95config,GlabbeekP09configStruct} correspond to Chu spaces over 2.

A \textit{Chu space over K} is a triple  with  and  sets and  is an arbitrary function called the matrix of the Chu space, and K is in our examples a set with a partial order on it. Chu spaces can be viewed in various equivalent ways. For our setting we can take the view of  as the set of events and the  as the set of configurations. The set  is representing the possible values the events may take: when  is the classical case of an event being either not started or terminated, where an order of  would be used to define the steps in the system. In general, the order on  will be used to define \textit{the meaningful steps} in the Chu space.

The Chu space can be viewed as a matrix with entries from  and rows representing the events of  and columns representing the configurations of . As an example, an entry  says that the event  is not started yet in the configuration .

In consequence, a Chu space can also be viewed as the structure  where . This very much resembles the configuration structures when  is .

\begin{proposition}[ST-structures and Chu spaces over 3]\label{prop_STstructChu3}
ST-structures \\and \emph{Chu spaces over 3} (cf.\ \cite[Sec.3]{Pratt00HDArev}) are isomorphic. 
\end{proposition}

\begin{proof}[sketch]
We provide an association between Chu spaces over 3 and ST-structures.
For an ST-structure  construct the associated Chu space over 3  with  the set of events from  and  states of the system formed of valuations of the events into the set  as follows. For one ST-configuration  build a state  by assigning to each : 
\begin{itemize}
\item  iff ;
\item  iff ;
\item  iff .
\end{itemize}
The possibility  is dismissed by the requirement  of ST-structures.
\end{proof}



STC-structures can be put into one-to-one correspondence with the Chu spaces over 4; or in other words, are isomorphic to the 4-2 logic (or functions ), cf.\ \cite{Pratt03trans_cancel}.
The order on the 4 values  extends that on three values by making  and incomparable with  and . As for ST-structures, this order gives the possible steps in an STC-structure. The same s-step and t-step are defined as for ST-structures. The cancellation steps are then added, where the two kinds defined for STC-structures always take into the cancellation set only events that have not been started yet. 
To also allow for steps that enable event we need to extend with ; but not comparable with the other two values so that we cannot jump from canceled events directly to them being in execution or terminated.


\begin{proposition}[STC and Chu spaces over 4]\label{prop_STC_Chu4}
STC-structures are {iso}-\\{morphic} to \emph{Chu spaces over 4}.
\end{proposition}

\begin{proof}[sketch]
We provide a translation of an STC-structure into a Chu space over 4, denoted . Take  to be the events of \STC. For each STC-configuration  construct a state  by giving the following assignment to the events :
\begin{itemize}
\item  iff ;
\item  iff ;
\item  iff ;
\item  iff .
\end{itemize}
One can check that these four choice of membership for  are the only ones, as the rest are discarded by the first or the second restrictions of an STC-configuration.
\end{proof}




\section{Conclusion}\label{sec_conclusion}

The work reported here was started in \cite{P12turing} where the notion of ST-structures was first defined. Nevertheless, the work in \cite{P12turing} is mostly concerned with investigations into the higher dimensional modal logic with past modalities and its relations to \HDAs\ and their bisimulations; whereas ST-structures get only little attention. In contrast, the present paper concentrates solely on ST(C)-configuration structures, investigating their expressiveness and relationship with existing concurrency formalisms, including \HDAs\ \cite{pratt91hda,Glabbeek06HDA}, configurations structures \cite{GlabbeekP95config,GlabbeekG01refinement}, and general (or inpure as we call them) event structures \cite{GlabbeekP09configStruct}. We gave definitions of various notions for ST(C)-structures like steps and paths, bisimulations, or action refinement, and discussed their relationships with similar notions for existing models of concurrency.

Having a good understanding of ST-structures (and their extension STC-structures) would help tackle the problem posed by Pratt in \cite{Pratt00HDArev} of getting a better understanding of the cyclic structure of \HDAs\ wrt.\ event based models. This in turn would give a better understanding of the state-event duality in concurrency models described in \cite{Pratt02duality,Pratt03trans_cancel}.

Interesting further investigations will ask how the correlations of Sections~\ref{subsec_expressST} and \ref{sec_STCstruct} can be expressed with category theory, following the works of Winskel and Nielsen \cite{winskel95modelsCategory} and of Cattani and Sassone \cite{CattaniSassone96HDTS}; also trying to see the connections with the category of Chu spaces of Gupta \cite{gupta94phd_chu} and the categorical work on cubical sets of Goubault and Mimram \cite{Goubault12Category_Cubical}.

The results in Section~\ref{subsec_expressST} reveal connections and distinctions between the existing concurrency models of \HDAs, configuration structures, pure event structures, and inpure event structures (and eventually general Petri nets). Some of these results are useful because they show existing knowledge in the new light given by the ST-structures.
In particular, the Corollary~\ref{cor_cubicalProp_configST} shows the difference between configuration structures and inpure event structures to be the fact that configuration structures are filled-in in essence, whereas inpure event structures are not. This also explains the counter example of the filled in concurrency square and the empty version, where the latter cannot be captured by pure event structures, but only by the impure case.
But both pure and impure event structures are adjacent-closed. Because of this, when dropping the adjacent-closure constraint the ST-structures become more expressive, and the example from Fig.~\ref{fig_ex_winskel}(right) models a natural concurrent system that falls into this category.
Moreover, the correspondence between acyclic and non-degenerate \HDAs\ and ST-structures that are adjacent-closed comes to say that non-degeneracy and adjacent-closure are close connected. Moreover, coupled with the above it comes to say that these \HDAs\ can capture the impure event structures, as well as suggesting a tighter correlation between these two by allowing acyclic and non-degenerate \HDAs\ to be encoded into impure event structures.

There are thought various examples that break either the acyclic constraint (as the ones in the last part of the paper) or that break the non-degeneracy constraint (as the one from Fig.~\ref{fig_ex_hda}(right-most) or from Figure~\ref{fig_ex_STC_structs}(ii)). These examples find natural representations as ST-structures or as STC-structures. The geometric interpretation of these examples is still very natural, only that the geometric objects fall outside the definition of \HDAs\ as we gave here in either the sense that we do not work with cubes any more but with triangles, or the geometric objects are open as boundaries are missing. It would be useful to investigate more these degenerate or cyclic geometric structures in the same line as started here, by looking at the \HDA\ state-based model which is close to the standard finite state machines used in computer science, and looking at the event-based models of ST(C)-structures and the related configuration and event structures.

Another point that ST-structures and the results in Section~\ref{subsec_expressST} make (especially Corollary~\ref{cor_ev_intermediaryTrans} and the results relating to impure event structures) is that ST-structures make the transitions more fine-grained. This says that if for impure event structures a concurrent transition implies that all the possible interleavings exist, for ST-structures a concurrent transition just says that the respective events are running at the same time, i.e., they overlap at least on some part of their execution (this is represented by the fact that those events are in the started stage but not terminated yet). On top of this concurrency aspect more constraints can be put on which events start first and which end before which. Such fine-graining cannot be achieved with the other concurrency models that we compare with in this paper.


\subsection{Further remarks}



\begin{remark}\label{remark_weak_ST_constraint}
The constraint imposed on ST-structures in Definition~\ref{def_st_structs} can be seen as rather strong, and one may think of a weaker constraint with the similar intuitive purpose of ensuring that events that are started eventually are terminated. Such a weaker version of the constraint would be:

Many of the results in the paper use the constraint of Definition~\ref{def_st_structs}. It is not clear if (or which of) these results would still hold under the above weaker constraint.
\end{remark}


The following is a natural example, with a natural geometric interpretation, that breaks the constraint of Definition~\ref{def_st_structs} but respects the above weaker constraint.

\begin{example}\label{example_weakerConstraint_on_ST}
Consider two events  and  which may run concurrently but which are constrained such that the event  should run ``inside'' event . Intuitively, the event  is like an environment providing resources (like an operating system), whereas event  is a process that is to use resources from the environment provided by . Action refinement would provide more structure to these two events, and thus give a more concrete description of this concurrent system. But for now, abstractly, the fact that  is to run ``inside''  should be understood as:  cannot start unless  has started already, and  cannot terminate unless  has terminated already. But both events are allowed to run concurrently.

An ST-structure representing this would be: 

This structure is rooted and connected though not adjacent-closed. Moreover, this structure breaks the constraint of Definition~\ref{def_st_structs}, but one can easily check that the weaker version of this constraint is respected.

There is also a natural geometric formalization of the above example. Take the filled in square of Figure~\ref{fig_ex_hda}(middle-left). Remove the left and right borders of the square, leaving the inside filled in, as well as all the corners and the two remaining upper and lower borders. This space is directed as before, and a path through this space can be taken as before, only that there are many paths missing now: all those paths that start with  (i.e., on the left border first) and all those paths that end  before  (i.e., reaching the right border before reaching the final upper-right corner). This is not a closed geometric shape any more, as two borders are missing. This shape does not fit the definition of non-degenerate \HDA\ as we gave it here because we required that the source and target be \textit{maps}, whereas here we would require them to be only \textit{partial}. 
\end{example}



\begin{remark}\label{remark_redundancy}
There is an apparent redundancy in the definition of adjacent-closure because the forth constraint was never used in the proof of Proposition~\ref{prop_adj_equiv}. This too is due to the strong constraint on the definition of ST-structures, which is clearly visible in the second part of this proof.
Under the weaker version of this constraint on ST-structures (see Remark~\ref{remark_weak_ST_constraint}) the proof of this proposition still holds but the second part of the proof needs to be redone, using induction on the reachable path. All four constraints are then necessary in this proof.

We did not go for these complications; and moreover, the definition that we gave for adjacent-closure highlights more explicitly the properties of adjacent-closure. 
\end{remark}


\vspace{1ex}\noindent\textbf{Acknowledgements: }
The work on ST-structures started from a fruitful conversation with Luca Aceto.
Olaf Owe and reviewers from FoSSaCS'\!13 and CONCUR'\!13 helped improve this draft.








\bibliographystyle{eptcs}
\bibliography{bib}



\end{document}
