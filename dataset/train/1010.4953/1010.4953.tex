\documentclass[9pt,executive]{article}
\linespread{1.0}
\usepackage[left=1in,top=1in,right=1in,head=1in,foot=1in]{geometry}
\usepackage{times}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{color}
\usepackage{colortbl}
\definecolor{mygrey}{rgb}{0.82,0.82,0.82}
\newtheorem{defn}{\bf Definition}
\newtheorem{theorem}{\bf Theorem}
\def\presp{PRES\textsuperscript{+}}
\def\fsmd{FSMD}
\def\fsmdb{(FSMD)}
\def\algofunction{constructSetOfTransitions}
\pagestyle{empty}
   
\def\presp{PRES\textsuperscript{+}}
\def\fsmd{FSMD}
\def\fsmdb{(FSMD)}
\def\algofunction{constructSetOfTransitions}
\pagestyle{empty}
\begin{document}                                                      
\begin{center}
{\bf \LARGE  Equivalence Checking in Embedded Systems Design Verification}
\end{center}
\vspace*{24pt}
\begin{center}
 {\Large \bf Soumyadip Bandyopadhyay}\\
\vspace*{12pt} 
{\Large \bf soumyadip@cse.iitkgp.ernet.in}
\end{center}
\vspace*{24pt}


\section{Introduction}
In this paper we focus on some aspects related to modeling and formal verification of embedded systems.
Many models have been proposed to represent embedded systems \cite{sedwads} \cite{peles}. 
These models encompass a broad range of styles, characteristics, and application domains and include 
the extensions of finite state machines, data flow graphs, communication processes and Petri nets. 
In this report, we have used a {\presp} model (Petri net based Representation for Embedded Systems)
as an extension of classical Petri net model that captures concurrency, timing behaviour of
embedded systems; it allows systems to be representative in different levels of
abstraction and improves expressiveness by allowing the token to carry information
\cite{zebo}. This modeling formalism has a well defined semantics so that it supports
a precise representation of system. As a first step, we have taken an untimed {\presp}
model which captures all the features of {\presp} model except the time behaviour which have 
reported in earlier report.

   A typical synthesis flow of complex systems like VLSI circuits or embedded systems
comprises several phases. Each phase transforms/refines the input behavioural
specification (of the systems to be designed) with a view to optimize time and
physical resources. Behavioural verification involves demonstrating the equivalence
between the input behaviour and the final design which is the output of the last phase.
In computational terms, it is required to show that all the computations represented
by the input behavioural description, and exactly those, are captured by the output
description. 


  Modeling using {\presp}, as discussed above, may be convenient for specifying the input
behaviour because it supports concurrency. However, there is no equivalence checking
method reported in the literature for {\presp} models to the best of our knowledge.
In contrast, equivalence checking of {\fsmd} models exist \cite{ChandanKarfa}. Although
Transformation procedure from non-pipelined version {\presp} to pipelined version {\presp} is reported \cite{zebo}. 
As a first step, we seek to hand execute our reported algorithm on a real life example and we have to translate 
two versions of {\presp} models to {\fsmd} models. 

  The rest of the paper is organized as follows. 
 Section \ref{description} presents the definition of {\presp} and {\fsmd} models.
 Section \ref{algorithm} presents Proposed algorithm for conversion from an untimed {\presp} models to an {\fsmd} models. 
 Section \ref{real life example}  presents notion of equivalence, abstraction. In this section we have also presented the
 working principal of an example of real life embedded systems.  
 Section \ref{results} verify the equivalence between initial and transformed behaviour using {\fsmd} equivalence checking method. 
 Finally, some future works are identified in Section \ref{future-work}
\section{Brief description of {\presp} and {\fsmd} model}\label{description}
Before the conversion mechanism we discuss the design representation of {\presp} models.
\subsection{ Description of {\presp} models}
  A {\presp} model is a seven tuple ,
where the members are defined as follows. The set 
is a finite non-empty set of places; : the set of variables. A place  is associated with a variable ; 
therefore, . Every place is capable of holding a token having a value. 
A token value may be of any type, such as, Boolean, integer, etc., or a user-defined type of any 
complexity (for instance, a structure, a set, or a record). The set  denotes the set of all possible token types. 
Thus,  is a set of sets. The set   is a finite non-empty set of transitions; 
 is a finite non-empty set of input arcs which define the flow relation from places to 
transitions  ``input'' with respect to transitions;  is a finite non empty set of output arcs 
which define the flow relation from transitions to places. A marking   is the assignment of tokens to places of the net; 
hence, . The marking of a place , denoted , is either   or . For a particular marking M, 
a place p is said to be marked iff .  is the initial marking of the net, depicting the places having tokens initially. 
  
  The type function :  associates every place 
with a token type. 

  The pre-set   of a transition  is the set of input  places of .
Thus, . Similarly, the post-set  
of a transition  is the set of output  places of . So,  and  and . The subset  is the set of variables associated with places from which input
arcs lead to the transition . Similarly, the pre-set   and the post-set    of a place  are given by  and , respectively. 

  For every transition , there exists a transition  function  associated
with ; that is, for all , : , where  and
. The functions 's are used to capture the functional transforms that take place of the variable associated with the output places of the transitions i.e, .

  A transition  may have a guard  associated with it. The guard of a
transition  is a predicate : , where  over the
variable set . 
\subsection { Description of {\fsmd} model}
 A finite state machine with data path {\fsmdb} is a universal specification model. An
{\fsmd} is defined as an ordered tuple  where 

  is a finite set of control states.
  is the reset state.
  is the set of primary input signals.
  is the set of storage variables.
  is the set of primary output signals, .
 :  is the state transition function.
 :  is the update function of the output and the storage variables, where S and U are as defined below
  is the set of boolean literals of the form  or ,  is a boolean variable and ; its represent the set of status expression over , where  represents a set of arithmetic expression over  of input and storage variables and  is any arithmetic relation. .
   and  represent set of storage or output assignment. 
  

\section{Proposed algorithm for conversion from an untimed {\presp} models to an {\fsmd} models}\label{algorithm}
 Let the input {\presp} model be  and the generated {\fsmd} model be . For simplicity, we assume that all tokens are of integer type. i.e  =  for all .

The first step of our algorithm computes the following entities in the {\fsmd} model:   and .
 The algorithm then goes on to compute : the set of states; : the state transition function and : the update function. Symbolic simulation of the {\presp} model is used to compute these entities starting from the initial marking .
\begin{itemize}
 
 \item 
At each step of the simulation, starting from a present marking  the algorithm enumerates all the possible sets of transitions of  from ; for
each of these sets of possible transitions, it constructs the next state  of 
from the new marking  of the {\presp} model .
 \item 
 Obtain the transition from  to  in  .     
 \item
 \begin{figure}[htbp]
\centerline{\epsfig{figure=guards.eps,height=50mm}}
\caption{Places and transitions in a {\presp} model}
\label{fig:guards}
\end{figure}
For example, consider the scenario given in Figure \ref{fig:guards}. Let ; so the set  of all transitions emanating from the places in M is given by . The possible sets of transitions are  leading to the marking  and  leading to the marking . The {\fsmd} transition  is associated with the guard condition  and the {\fsmd} transition  is associated with the guard condition , i.e,  and .  and .  and . 
 








 \end{itemize}


{\bf Algorithm}

\noindent
{\it Steps:}\\
{\bf Step 1:} Given {\presp} model\\
\hspace*{0.42in} ;\\
\hspace*{0.42in}  \{ Variables associated with ;\\
\hspace*{0.42in}  \{Variables associated with ;\\ 
\hspace*{0.42in} //  is the set of variables  associated with places from which no arcs are input 
\hspace*{0.42in} // to any transition. Therefore \\
\hspace*{0.42in}  \{Variable associated with ;\\
\hspace*{0.42in} //  is obtain from transition function of {\presp} model and variable associated
\hspace*{0.42in} // with post set of that transition. Therefore,\\ 
\hspace*{0.42in}  is the function associated with  
\hspace*{0.48in} ,  and ;\\ 
\hspace*{0.42in} //  is obtained from the guard conditions  of the {\presp} models. Therefore,\\
\hspace*{0.42in} ;\\ 
{\bf Step 2:} ; ; ;\\
{\bf Step 3:}  \\
\newpage
\hspace*{0.25in}{\bf Step 3.1:}  ;    ;\\
\hspace*{0.81in} {\algofunction} ; // , the set of possible\\
\hspace*{2.84in} // transitions.\\
\hspace*{0.81in}, empty set, //: the set of next states generated \\
\hspace*{2.01in} // depending on  mutually exclusive\\
\hspace*{2.01in} // depending on guard condition\\ 
\hspace*{2.01in} // associated with member of .\\  
\hspace*{0.25in}{\bf Step 3.2:} \\ 
\hspace*{0.35in} {\bf Step 3.2.1:} ; ;\\             
\hspace*{0.35in} {\bf Step 3.2.2:} Let  be the set of guards associated with . In the table\\
\hspace*{1.04in} of the function , insert entry\\
\hspace*{1.04in} \\
\hspace*{0.35in}{\bf Step 3.2.3:} Let  be the set of assignments of the form\\
\hspace*{1.06in}\\
\hspace*{2.36in} and  is the function associated with  \}; \\
\hspace*{1.06in} In the table of the function , insert the entry ;\\ 
\hspace*{1.06in} // members of  are carried out in parallel\\ 
\hspace*{0.35in}{\bf Step 3.2.4:} ; \\        
{\bf Step 4:} // Any new state generated \\
\hspace*{0.42in}   ;\\
\hspace*{0.42in} if   exit;\\
\hspace*{0.48in} else \{ ; ; ;\\
\hspace*{0.83in} goto {\it Step 3}\\
\hspace*{0.75in} \}\\

\begin{figure}[htbp]
\centerline{\epsfig{figure=pres+.eps,height=70mm}}
\caption{{\presp} model to be converted into {\fsmd} model}
\end{figure}
            
\begin{figure}[htbp]
\centerline{\epsfig{figure=fsmdf.eps,height=60mm}}
\caption{{\fsmd} model equivalent to the {\presp} model of Figure 1}

\end{figure}
 
\section{Notion of equivalence and Real life example} \label{real life example}

\subsection{Notion of equivalence between two {\presp} models}

In the synthesis process there are a  number of refinement phase. System model is transformed in each phases. 
So the validity of this transformation  depends on the equivalence between the input behaviour and the output behaviour of each phase. 
Literature \cite{zebo} has propounded three notion of equivalence - cardinality equivalence, functional equivalence, and time equivalence;
the two {\presp} models are totally equivalence iff they satisfies all these equivalence. We are dealing with untimed {\presp} hence, 
there is no need to show time equivalence.
Two {\presp} models   and  are cardinality equivalence iff:
 \begin{enumerate}
   \item There exist a  one to one correspondence between the in-ports and the out-ports of  and  
      i.e :    and  :   .
   \item The Initial markings  and  of  and  are the same.
   \item After execution of  and  if the tokens are accumulated at out-ports of the each nets, there is 
         a one to one correspondence of marking at their out-ports. 
 \end{enumerate}
 For example in  Figure \ref{fig:n} in = \{, \}, out = \{, , \}, 
in = \{, \} out = \{, , \} and  and  are defined by
() = , () = , () = , () =  and () = .
Second condition also satisfies the two nets.  and  also satisfies third condition i.e after execution of  and  
all out-ports of  and  contains token and they are one to one correspondence. Hence two {\presp}  and  are cardinality 
equivalence. 
 \begin{figure}[htbp]
\centerline{\epsfig{figure=n.eps,height=50mm}}
\caption{Cardinality equivalence nets}
\label{fig:n}
\end{figure}
 
 Two nets {\presp}  and  are functionally equivalent iff:
\begin{enumerate}
 \item  and  are cardinality equivalent,
 \item The token values in out-ports in  and  are the same.
\end{enumerate}
 
 \begin{figure}[htbp]
\centerline{\epsfig{figure=t.eps,height=63mm}}
\caption{Functional equivalence nets}
\label{fig:t}
\end{figure}
 For example in Figure \ref{fig:t}  and  are cardinality equivalence. If  of  and  of  contain token whose values are 2.
then after execution of  and  the out-port of  and  contains token whose values are 5. Hence two nets are totally equivalence.


\subsection{Modeling of a real life example}
Non-pipelined pipelined version of {\presp} model for a jammer is reported \cite{zebo}. Transformation technique from non-pipelined version of {\presp} model 
to pipeline version of {\presp} model also have been reported \cite{zebo}.
Non-pipelined and pipelined version of {\presp} models are shown in  Figure \ref{fig:nonp} and Figure \ref{fig:papline} respectively.

 \begin{figure}[htbp]
\centerline{\epsfig{figure=jammer.eps,height=150mm}}
\caption{A non pipelined {\presp} model for a jammer}
\label{fig:nonp}
\end{figure}
\clearpage
\begin{figure}[htbp]
\centerline{\epsfig{figure=pipeline.eps,height=88mm}}
\caption{A pipelined {\presp} model for a jammer}
\label{fig:papline}
\end{figure}
\section{Experimental results}\label{results}

We have reported a translation algorithm from untimed {\presp} model to {\fsmd} model. Hand execution of
this translation algorithm we have get {\fsmd}  model of the jammer from non pipelined {\presp} model. 
The {\fsmd} model is given Figure \ref{fig:jfsmd} and transition function is given in Table \ref{F:comp1}.
\begin{figure}[htbp]
\centerline{\epsfig{figure=jammerfsmd.eps,height=50mm}}
\caption{A non pipelined {\fsmd} model for a jammer}
\label{fig:jfsmd}
\end{figure}
\begin{table}[t]
  \begin{center}
    \small\addtolength{\tabcolsep}{-5pt}
\begin{tabular}{|c|c|} \hline 
\emph{State}                           & \emph{Transition function}              \\
               
\hline
 ,           &  in-Copy, Thresold-copy, trigerselect-Copy, opMode-Copy,  modParLib-Copy and delayPerLib-copy   \\ 
 \hline                                              
 ,           &  detectEnv                                                                 \\ 
\hline
 ,           &   detectAmp                                                                                  \\  
\hline
 ,           &  thresold-keepVal, copy                                                                               \\    
\hline
 ,           &  getAmp, pwPricnt                                                                              \\             
\hline
 ,           & getT                           \\ 
\hline
 ,           & head                                                                \\ 
\hline
 ,            & f                                                                                                       \\
\hline 
 ,           & getKPS            \\
\hline
 ,            & FFT                      \\
\hline
 ,            & getPer\\
\hline
 ,          & getType \\
\hline 
 ,         & trigSelect-keepVal, getScenario\\
\hline 
 ,          &trigSelect-copy, opMode-keepVal, extractN, extractN \\
\hline 
 ,           & opmode-copy, delayPerLib-keepVal, modPerLib-keepVal, adjustdelay\\
\hline 
 ,            & delayPerLib-copy, modPerLib-copy, doMod\\
\hline
  ,           & sumsig\\
\hline
\end{tabular}
\end{center}
\caption{Transition function for {\fsmd} model obtain from normal {\presp} model of a jammer}
\label{F:comp1}
\end{table}
Similarly, the {\fsmd} generated from the pipelined {\presp} model  is shown in Figure \ref{fig:pjammer} and the 
state transition function given in Table \ref{F:comp3}
\begin{figure}[htbp]
\centerline{\epsfig{figure= pipeliefsmd.eps,height=50mm}}
\caption{A pipelined {\fsmd} model for a jammer}
\label{fig:pjammer}
\end{figure}

\begin{table}[t]
  \begin{center}
    \small

\begin{tabular}{|c|c|} \hline 
\emph{State}                           & \emph{Transition function}              \\
              
\hline
 ,           &  in-Copy  detectEnv                                                                          \\ 
 \hline                                              
 ,           &  Thresold-copy  keepVal  detectAmp                                                                 \\ 
\hline
 ,           &   in-Copy  getAmp                                                                                   \\  
\hline
 ,           &  pwPriCnt  getT  head                                                                                \\    
\hline
 ,           &  f  getKPS  FFT  getPer                                                                              \\             
\hline
 ,           &trigerselect-Copy  keepVal  getType  opMode-Copy  keepVal  getScenario                            \\ 
\hline
 ,           &modParLib-Copy  keepVal  extractN  and delayParLibCopy  keepVal extranctN  adjustDelay         \\ 
\hline
 ,           &  doMod  sumsig                                                                                                       \\
\hline 
 ,           & emit \\
\hline
\end{tabular}
\end{center}
\caption{Transition function for {\fsmd} model obtain from pipelined {\presp} model of a jammer}
\label{F:comp3}
\end{table}
\clearpage

Here the {\fsmd} equivalence checking is very straightforward. Two versions of {\fsmd}s have only one path and the data transformation 
which have been shown in Table \ref{F:comp1} and Table \ref{F:comp3} are same. Hence two {\fsmd} models are equivalent.

\section{Plan of Future work}\label{future-work}
 Carrying out analysis for correctness of technique, complexity analysis, etc. Direct equivalence checking between two {\presp} models
 Generalization of {\fsmd} models to timed {\fsmd} models.
 We will generalize an {\fsmd} model to timed {\fsmd} model which can capture data path as well as timing behaviour and
 Conversion of {\presp} models to timed {\fsmd} models.


































































\bibliographystyle{ieeetr}
\bibliography{reff}

\end{document}
