\documentclass[a4paper,12pt]{article}
\usepackage{tikz}
\usetikzlibrary{positioning,shadows,arrows}
\usepackage{appendix}
\usepackage{times}
\usepackage{color}
\newcommand{\sss}[1]{\subsubsection{#1}}
\usepackage{microtype}\usepackage{url}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{alltt}
\usepackage{complexity}
\usepackage{algorithmic} 
\usepackage{gensymb}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsthm}
\bibliographystyle{plain}
\usepackage{hyperref}
\newcommand{\emphdex}[1]{\index{#1}\emph{#1}}
\usepackage{latexsym}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{notation}[theorem]{Notation}
\DeclareMathOperator{\texp}{texp}
\newclass{\NPFP}{NPFP}
\newclass{\APFP}{APFP}
\newclass{\NIFP}{NIFP}
\newclass{\AIFP}{AIFP}
\newclass{\PFP}{PFP}
\newclass{\AnH}{AnH}
\newcommand{\ATIME}[2]{\ensuremath{\Sigma_{#2}\TIME(#1)}}
\newcommand{\coATIME}[2]{\ensuremath{\Pi_{#2}\TIME(#1)}}
\newcommand{\ASPACE}[2]{\ensuremath{\Sigma_{#2}\SPACE(#1)}}
\newclass{\LFP}{LFP}
\newclass{\LOG}{L}
\newclass{\IFP}{IFP}
\newclass{\HO}{HO}
\renewcommand{\phi}{\varphi}

\newclass{\MHO}{MHO}
\newclass{\MSO}{MSO}
\newclass{\VO}{VO}
\newclass{\KROM}{KROM}
\newclass{\HORN}{HORN}
\newclass{\SO}{SO}
\newcommand{\hoa}[1]{\ensuremath{\HO^{#1}}}
\newcommand{\N}{\ensuremath{\mathbb N}}
\newcommand{\hob}[2]{\ensuremath{\Sigma^{#1}_{#2}}}
\newcommand{\hod}[2]{\ensuremath{\HO^{#1,#2}}}
\newcommand{\hoc}[3]{\ensuremath{\Sigma^{#1,#3}_{#2}}}
\newcommand{\cohoa}[1]{\ensuremath{\co\HO^{#1}}}
\newcommand{\cohob}[2]{\ensuremath{\Pi^{#1}_{#2}}}
\newcommand{\cohod}[2]{\ensuremath{\co\HO^{#1,#2}}}
\newcommand{\cohoc}[3]{\ensuremath{\Pi^{#1,#3}_{#2}}}
\newcommand{\mhoa}[1]{\ensuremath{\MHO^{#1}}}
\newcommand{\mhob}[2]{\ensuremath{\M\Sigma^{#1}_{#2}}}
\newcommand{\mhod}[2]{\ensuremath{\MHO^{#1,#2}}}
\newcommand{\mhoc}[3]{\ensuremath{\M\Sigma^{#1,#3}_{#2}}}
\newcommand{\comhoa}[1]{\ensuremath{\co\MHO^{#1}}}
\newcommand{\comhob}[2]{\ensuremath{\M\Pi^{#1}_{#2}}}
\newcommand{\comhod}[2]{\ensuremath{\co\MHO^{#1,#2}}}
\newcommand{\comhoc}[3]{\ensuremath{\M\Pi^{#1,#3}_{#2}}}
\newcommand{\ex}[1]{\ensuremath{\exp_{2}^{#1}(n^{O(1)})}}
\DeclareMathOperator{\bit}{bit}
\DeclareMathOperator{\suc}{succ}
\DeclareMathOperator{\pow}{pow}
\DeclareMathOperator{\infe}{inf}
\DeclareMathOperator{\plu}{plus}
\DeclareMathOperator{\plum}{plus_{m}}
\DeclareMathOperator{\ifte}{if}
\DeclareMathOperator{\thent}{then}
\DeclareMathOperator{\elset}{else}
\newcommand{\mc}{\mathcal}
\newcommand{\eh}[1]{th exponential hierarchy}
\newcommand{\mf}{\mathfrak}
\newcommand{\ol}{\overline}
\newcommand{\olmc}[1]{\overline{\mathcal{#1}}}
\newcommand{\ed}{=_{\mathrm{def}}}
\usepackage{authblk}
\date{}
\title{A Note on Higher Order and Variable Order Logic over Finite
  Models
}
\author{Arthur MILCHIOR}
\affil{{LIAFA, Université Paris 7 - Denis Diderot, France\\
 CNRS UMR 7089, Université Paris Diderot - Paris 7, Case 7014\\
 75205 Paris Cedex 13\\
 {\tt Arthur.Milchior@liafa.univ-paris-diderot.fr}
\\LACL, UPEC, Créteil, France\\
LACL, Département d'Informatique\\
Faculté des Sciences et Technologie\\
61 avenue du Général de Gaulle\\
94010 Créteil Cedex
\footnote{Work done in an internship at
University of Massachusetts Amherst under the direction of
Prof. David Mix Barrington.}}}
\begin{document}
\maketitle

\begin{abstract}
  We show that descriptive complexity's result extends in High Order
  Logic to capture the expressivity of Turing Machine which have a finite
  number of alternation and whose time or space is bounded by a finite
  tower of exponential. Hence we have a logical characterisation of
  \ELEMENTARY. We also consider the expressivity of some fixed
  point operators and of monadic high order logic.

  Finally, we show that Variable Order logic over finite structures, a
  notion introduced by \cite{lauri} contain the Analytical Hierarchy.





\end{abstract}

\tableofcontents

\section{Introduction}
\emph{Descriptive complexity} is a field of \emph{computational
  complexity}. It studies the relation between logical formalisms and
complexity classes. For a given complexity class, what logic do we
need to express languages in this class; for a formula in a given
logic, what is the complexity of checking the truth value of this
formula, over finite structures, as a function of the cardinality of the
structure.

The relation between complexity classes and descriptive classes is
strong, since a lot of well known complexity classes, such as
\AC, \LOG, \NL, \P, \NP, \PSPACE, \EXP\TIME{} and \EXPSPACE{}, are
exactly equal to some descriptive classes using first and second order
relations, with either syntactic restrictions (Monadic relations, Horn
and Krom formulae) or with operators like `` fixed point'' and
``transitive closure'' (see \cite{imm,libkin}).

These issues in terms of capturing complexity classes are well
understood in agreed upon notation for first and second-order logic,
but beyond that there were open questions and a need for clarity and
standardization of notation. 
The extension of those results to higher order logic began with
\cite{leivant}, and was followed more recently by
\cite{lauri,arity,kolo}. It is also called ``Complex object'' in
database theory \cite{database}.  




The article \cite{lauri} also introduced the so-called ``Variable-order logic'',
extending the high-order logic where the order of a quantified
variable is not fixed in the formulae. They stated that it is at least
Turing-hard but did not give an upper bound for the expressivity of this
language.

\paragraph{}
The main contributions of this paper are the following:
\begin{itemize}
\item We give a definition of High-Order logic which is less
  restrictive than the usual one,
\item we prove a normal-form theorem which respects the expressivity of
  the logic,
\item we prove the equality between some subclasses of the High-Order
  logic and some complexity classes below \ELEMENTARY{},
\item we prove that any formula in the analytical hierarchy can be
  written as a formula in Variable Order logic.
\end{itemize}





\section{Definition}\label{def}

\subsection{The core of the language}
Let  be an integer. We will begin by defining the syntax of the
th order logic (\hoa r) and its semantics over finite
structures. First Order (\FO) and Second Order (\SO) are the special
cases \hod{1}{} and \hod{2}{}.


\begin{definition}[Universe]
  A \emphdex{universe}  is the set .
\end{definition}
\begin{definition}[Type]\label{type}
  A \emphdex{type} of order 1 is just the element , and a type of
  order  is a tuple of types of order at most .
\end{definition}
\begin{example}For example,  is the
  type of a ternary relation of order 4 whose first and last elements
  are elements of the universe, and whose second one is a binary
  relation of order 3 whose first element is a monadic relation of
  order 2 and the second an element of the universe.
\end{example}
\begin{definition}[Relation]
  A \emphdex{relation} of type  is an element of the universe,
  and a relation of type , where the 's
  are types, is a subset of the Cartesian product of the relations of
  type .

   is the set of all relations of type  over the
  universe .
\end{definition}
\begin{notation}
  In this article , where  is any symbol, will
  always be a variable of type . Hence  is a
  first-order variable or a constant.

  For ,  (resp.  ) is the special case
  of the relation of type  that is always
  true (resp. false). 
\end{notation}

By extension, if 
is a tuple of variables, then we say that  is
the type of . 

\begin{definition}[Vocabulary]
  A \emphdex{vocabulary}  is a set of
  relation symbols.   It is a vocabulary of order
   if the type of every relation is of order at most .

  We denote by  a relation symbol of type . A relation
  symbol of type  is called a constant. We sometimes omit the
  type-superscripts of variables and relations when this information
  is redundant. 
\end{definition}
For example, in , it is clear that the second occurence of  is also of
type , that  and  are of type  and that
 is a predicate of type .

Our definition is not standard in that a vocabulary may include
relations whose type has order greater than 2.

In \cite{lauri} the types are restricted to what we will call arity
normal form in subsection \ref{sec:arity}. We use the more general
definition of types from \cite{arity}, and we will show in subsection
\ref{sec:arity} that our choice is equivalent to their choice (at
least for the complexity classes that we study).
\begin{definition}[Structure]
\label{structure}
For any type , a \emphdex{-structure } is a tuple such that  is a nonempty universe and
each .



When  and  are a variable and a relation of the same
type, then we write  to speak
of the -structure such that  and  if .

By extension, if  and  are
tuples of variables and of relations of the same type then  is syntactic sugar for .
\end{definition}

\begin{definition}[Formula]
  A \emphdex{high-order formula}  is defined recursively as
  usual, such that if  and  are formulae then
   and  are also formulae. Here 
  is the type of .

  Finally, for types ,  and  are the two kinds of atomic formulae.
\end{definition}
\begin{definition}[\HO, \hoa{r}, \hob{r}{j} and \hoc{r}{j}{f}]
  The set \emphdex{} contains every formulae with high order
  quantifiers, then \emphdex{} is the subset of 
  formulae whose quantified variables are of order at most . Hence
   is the set of quantifier-free formulae.

  The set \emphdex{\hob{r}{j}}(resp. \emphdex{}) for
   is the class of formulae containing
  \cohob{r}{j-1}(resp. ) and closed by conjunction,
  disjunction and existential (resp. universal) quantification of
  variables of order at most . We have \hob{r}{0}=\hoa{r-1}.

  The \emphdex{normal form} of \hob{r}{j}(resp. ), where
  , is the set of formulae as in equation \ref{hob} with  in normal form and the types  are of order at
  most  (resp. the same kind of formulae, exchanging  and
  ).

  

  We will prove in Subsubsection \ref{sec:normalform} that any formula
  in \hob{r}{j} is equivalent to a formula in normal form.


  Finally \emphdex{\hod rf} (resp. \emphdex{\hoc rjf}) is the subset
  of \hoa r (resp. \hob rj) without any free variables of order more
  than .  This definition is different from the one of \cite{arity}
  where  denotes the maximum arity of high order relations.
\end{definition}
The classes of formulae for  and  are well studied
since  is the set of quantifier-free formulae,
 and .

\begin{definition}[Semantics]
  For ,  if and only if
  

   if , when the last
  equality is an equality of sets. It is decidable since the sets are
  well-founded.

  Satisfaction for  and  are
  defined in the usual way.

   is true if and
  only if for all , . 

   is true if and only
  if there exists some , .
\end{definition}
\subsection{Operators}
In this section, if  is a logic class and  is an operator, then
\emphdex{} is the set  that contains the formulae of , closed
by the operator .

\sss{Transitive closure}
\begin{definition}[Transitive closure]


  Let  be an -tuple
  and let  and  be three other
  -tuples of the same type and let  be a -formula in .

  Then  is a
  -formula in . The operator \TC{}Xe is called the
  ``Transitive Closure'' operator.

\end{definition}
\begin{definition}[Semantics of \TC]
   is true if and only
  if  or if there exists an -tuple 
  of type  such that  and .\end{definition}



\begin{example}
  Let the universe be a directed graph and let the vocabulary contain
  only  such that  is true if there is an edge from  to
  . Then  is a relation of type
   such that  is true if and only if there
  is a path  in the directed graph from  to .
\end{example}

\sss{Fixed Point}
\begin{definition}[Fixed Point]
  Let  be a tuple of
  type  and  be another tuple of the same type ,
  let  be a variable of type , and let
   and  be some -formulae. Then ,
  , , 
  , ,  are -formulae in
  \emphdex{}, \emphdex{}, \emphdex{},
  \emphdex{}, \emphdex{} and \emphdex{}
  respectively. The letters ``N'' and ``A'' stands for
  ``nondeterministic'' and ``Alternating'' respectively, ``I'' and
  ``P'' for ``Inflationary'' and ``Partial'', and ``FP'' stands for
  ``Fixed Point''.



  We restrict the formulae of  and \NPFP{} such that there are no
  negation applied outside of a non-deterministic fixed-point
  operator.
\end{definition}

\begin{definition}[Semantics of \PFP]
  Let  be a formula. Then we can
  define the relations  by recursion on .

  For each ,  is false and
   is true if and only if . Hence the property  is true on
  the input  if  is true on input  when the
  variable  is replaced by the relation .

  Then, either this process leads to a fixed point, i.e. there exists
   such that  and then  is true if and only if  or the set of
  relation of  has a cycle of size strictly greater than 1 and
  then .
\end{definition}

\begin{definition}[Semantics of \IFP]
  Using the notation of the last definition, let . Then we can define
   as . Another equivalent way to define it is to define  as the
  predicate that is always false, and .
\end{definition}

We should note that to decide if the desired fixed point for  exists we
must run the definition step by step and check whether  for .  The
definition of \IFP{} makes the operator monotonically increasing so a
fixed point will alway be reached within  steps.

\paragraph{}
The nondeterministic fixed points and alternating fixed points are
introduced in \cite{nfp}. We choose not to use their notation
``'', but instead to use
 to be coherent
with the notation for  as defined in \cite{imm}.

\begin{definition}[Semantics of  and \NIFP]\label{dnpfp}
  Let  be two vectors of the same type ,
   be a variable of type , and   and  be
  -formulae.

  We can define the relations , where  is
  a list of bit. For each ,  is false, and by induction for ,  is true
  iff .
  

  Then  is true if and only if there exists an  such that  and .

  This means that  is the union of the
  relations which are fixed points  for both  and
  such that  is accessible by applying the  a finite
  number of time to .

  We could also consider this as a directed graph  without self-loop, with a node from every relation  to
  . Then  is
  the union of the leaves reachable from the relation . 

  The semantic of  is to  what  is to . This
  means that for every relations ,  and
  . It is also possible to define  as syntactic sugar for . The graph
  defined above is then acyclic.
\end{definition}
\begin{figure}
\begin{tikzpicture}[
    node/.style={rectangle, draw=black,
        text centered, anchor=north},
    level distance=0.5cm, growth parent anchor=south
]
\node  (Node01) [node] {} [sibling distance=4cm]
child{
  node (Node02) [node] {}
  child{[sibling distance=2.8cm]
    node (Node05) [node] {}
    child{
      node (Node03) [node] {}
      child{
        node (Node06) {\vdots}
      }
    }
    child{
      node (Node04) [node] {}
      child{
        node (Node07) {\vdots}
      }
    }
  }
}
;
\end{tikzpicture}
\caption{A part of an alternating tree, with
   and }
\end{figure}
\begin{definition}[Semantics of  and ]
  We use the notations of definition \ref{dnpfp}.

  Let  be a function from strings of bits to bits.  Let  be
  a vocabulary,  be a -structure and  and 
  be -formulae. Then we define the
  tree  whose nodes are labelled by relations
  of type . The root is the relation , and for , a list of
  bits that indicates a path from the root in the tree, we define the
  label of  as , as in definition \ref{dnpfp}. If
   then  is a leaf, else if the depth of 
  is even then its children are the nodes with labels  and
   that are not equal to , else its only child is
  . We assume that  else we consider
  that the tree  does not exist.

  A \emphdex{local alternating fixed point}  is a
  relation such that  if
  and only if for every label  that are leaves of an existing tree
   we have . This
  means that a tuple is accepted by the tree if and only if it is
  accepted by every relations of its leaves.

  The \emphdex{alternating fixed point},  is a
  relation such that  if
  and only if there exist an  such that .

  Then  is true if
  and only if .

   is to  what  is to .
\end{definition}

This is almost the definition of \cite{nfp}, except that
,  and  are not named and  is not considered, but having a name for
those values will help the proof of \ref{eqab}. On page 8 they speak
of the ``length of the longest branch'', and it seems that they assume
that the tree is of finite size. They do not seem to explain why this
assumption can be true without loss of generality and without
considering that the tree is instead a graph; it is easy to imagine a
branch which repeats itself an infinite number of times when
 is cyclic. Hence we think it is interesting to
give another definition of alternating fixed point where we can always
give an answer in a finite time .

\begin{definition}[]
We will write  for  and  for .

Let  be a tree where each node's label is a pair
with either  or  as first element and a relation as second
element, and where the root is . The children of  are  and   except if  in
which case this node is a leaf. If in a branch we find two nodes with
the same label , we remove the second occurrence and its
descendants.

We recursively define the output of the tree as the relation of the
label if the tree is a leaf, else as  applied to the output of its
children. By extension we write  instead of its
output relation. It will be clear by the context if we mean the tree
or its output.
\end{definition}
\begin{proposition}\label{eqab}
  
\end{proposition}
\begin{proof}
  Let  be an tuple. We are going to prove that .

  \paragraph{} Let us assume that . Then there exists some function  such that
  . It then suffices to see that on
  every node  of  with label  we can
  keep only the child whose number is , and we obtain a tree
  that is a subset of . Since there is no
  negation in the tree, if we remove an element of an union we can not
  add any elements in the output of the tree, hence there is no loss
  of generality in doing that. We now have a tree  whose only
  gates' label are .  It is trivial to see that any element
   is in the output of  if and only if it is in every
  leaf. Since in the construction of  we only
  removed nodes that are copies of nodes higher in the tree, then
   is also in any leaf of , hence
   is in the output of .

  \paragraph{} Let us assume that . We will define a function  such that . Note that  if  is a string
  of odd size, since then the value of  does not matter in
  . Let  be the shortest string such that
   is not defined. Then  is of even length, hence by
  hypothesis over ,  is in the node .
  Either  is a union node, in which case there is a child  such
  that  is in , and we define  as  and for every
  finite string ,  as  since those values do not
  matter. Else  is a leaf. If it is because 
  then  since this value does not matter. Else it is because
  its children were already seen in this branch, in which case let  be the
  other occurrence of a node with the same relation,  and for
  every  we define  as , by hypothesis over  it is
  well defined, since  is the shortest non defined string, and
  's length is strictly positive.
\end{proof}

When we cut in , it was because the child
was an infinite repetition of itself, and we  can define the
function  in  with the same repetition. It
is then trivial to see that  is indeed in every leaf of
, hence in .
\begin{claim}\label{AFP}
  In fact, the same proof would work for a tree bigger than
  , choosing to cut later in the branches would not
  remove anything since there are no  gates, and would not add
  anything in the output since the later  gates would remove the
  eventual new elements of the set.
\end{claim}
This will be useful since it means we will not have to remember the
set of relations seen on a branch, and we only have to count until we
have seen more nodes than the number of relations.

\sss{Operator normal form}\label{opnorm}

It was proved in \cite{imm} that the transitive closure and
deterministic fixed points can be in normal form without loss of
generality. In fact algorithms were given to obtain equivalent formulae
in normal form. Furthermore, \cite{nfp} states that this normal form extends to
alternating fixed points, and to nondeterministic fixed points that
are not under negation (which is impossible by definition).

Those normal forms are  and
 where  is a fixed point operator and
 a formulae in  or , it is trivial that this result
extends to high order.

\subsection{Mathematics definitions and notations}

\sss{Mathematics functions}
\begin{definition}[Iterated exponential] Using the standard notation for the tetration operator, we define :
   and . That is
   with  exponentiations of
  .
We will also write 
  and .
\end{definition}

\begin{definition}[Elementary function]
  Let  be a function from  to , it is an elementary
  function if , that is, there is a constant
   such that . We denote by  the
  set of languages decidable in elementary time.
\end{definition}

Finally, we introduce some complexity classes that we will use.
\begin{definition}
  Let  be a function from  to  and .


  Let  be the set of languages accepted by an alternating
  Turing machine halting in  steps on input of size . The
  restriction with at most  alternation between universal and
  existential states, beginning by existential, ,
  in particular  is denoted by . The
  definition of  is similar, but every steps are
  deterministic, and so on for  and , where
  the limit is not on the number of step but on the number of cells
  used by the machine for the computation.

  
\end{definition}

We could also define \ELEMENTARY{} using space or bounded alternation
since we have .

\sss{Syntactic sugar in logic}
\begin{notation}
  Let  be a quantifier, we will define ``''.  We
  write``'' for ``'' and
  ``'' for ``''.

  When we define a language  from a language , we will always
  assume that ``1'' is a letter that is not in the alphabet of .
\end{notation}


Some formulae will be used often in this article, hence we are going
to define some syntactic sugar in this subsubsection.

,

,

and .

On ordered set we define ,
, and  where
 is the free variable of the formula ``\texttt{card}'' to means
that  is 0, 1 or max. We will assume that we can use those constants
without having to explicitly quantify them in the formulae.

Finally,  is syntactic sugar for .

-

































\subsection{Normal form}
In this subsection, we are going to discuss two ways to normalize the
language and see that the definition we choose does not change the
expressivity of the language. Hence we will be able to choose the more
restrictive one to prove theoretical results, and the more expressive
one to express queries.  These results are on the syntax of the
formula, hence they also extend as results for general logic, with
finite or infinite models.


\sss{Types of fixed arity}\label{sec:arity}
We are going to restrain type to a special form and prove that it does
not change the expressivity of the language.

\begin{definition}[Arity relation]
  For each , we define \emphdex{}to be the type
   if , with  copy of 
  and we define  to be . We write  for
  ,   the set of relations of type .

  We say that a formula is in \emphdex{arity normal form}
  (\emphdex{ANF}) if all of its types respect the arity
  definition. Let us define  to be the set of formulae in
  ANF.
\end{definition}

\begin{proposition}
  The class of queries of  is exactly the class of
  queries of . Formally for every formula
   we can find an equivalent formula
  .
\end{proposition}
\begin{proof} The side  is trivial, since the definition of
   is a restriction of the definition of . Indeed ``'' as
  a type is defined as ``'' if  and as
  ``'' where  is considered as a
  type.

  To show , let  and define  to be
  the size of the bigger tuple, defined this way: size(1)1 and
  size. There are two problems that we need to
  correct. First we need to change the type of every relation such
  that a type of order  contains only type of order , and such
  that all relations of those types have the same arity.

  \paragraph{Step normal form}Let us define \emphdex{step normal form}
  (\emphdex{SNF}) to be the formulae that respect the first of these
  properties, that a type of order  contains only types of order
  .  We are going to show that each formula is equivalent to a
  formula in SNF. To do this, the encoding in order  of a relation
   of order , when , will be a relation of order
   whose type contains only one elements of arity , whose type
  contains only one elements, and so on until the one element of order
   which is of course .

  Let us define a formula  with  pair of parenthesis, that
  is true if and only if  is interpreted  as explained in the
  last paragraph.
  
It now suffices to replace every instance of an atomic proposition
like  by
.  An
easy induction shows us that we obtain an equivalent formula, and it
is clear that it is in SNF.

\paragraph{From SNF to arity normal form:}
From now on we will assume that every type in the vocabulary respects
ANF.

We will make sure that every quantified relation is of arity , and
we will do it so that in every relation of arity , the last
element will be copied  times. We need to check that, when
relations are quantified, they respect this property.






We will assume that  is in SNF.  Syntactically we will replace
every occurrence of  by

To be more precise, we don't really need the quantification of the
 to be just after the quantification of . Since the  only interacts with , we can
put the quantifiers anywhere after the quantification of . Hence if  is in decreasing normal
order as defined in the next section (the orders of the quantified variables
decrease) we can postpone the quantifications in  to put them at
the right place of the list. Then we can, without loss of generality,
extract the quantifiers of  to put them after the quantification
of the . This way if  was in decreasing normal form,
it will remain in normal form.

We will replace every atomic formula  by  where 
means that the last element is repeated  times.

It is clear that those formulae are equivalent and in arity normal
form.





\end{proof}

\paragraph{Increasing arity of input structure}
Even if we can not accept an input structure with relations using
``type'', we must at least accept the relation respecting the
``arity'' constraint, which creates a problem when we change the
syntax of our formula. Let say that  is an input structure of order
 and arity , and we want to have a copy  of it of arity
. Then we can state that  is a good copy with

Let  and let
 be a -formula. When we apply the rules of the last
paragraph to extend  into an equivalent formula  of arity
 we must in fact transform it into:

\paragraph{Respecting order of quantifiers}
In the next subsubsection we will take care of the order of the
quantifiers, and we will need an algorithm for this normal form, hence
here we must emphasize a few details. Both in the proof of step normal
form and of arity normal form, we did not create any new
quantification of order  or higher, so we respected the global form
of the formula when we consider only th order quantifiers. Now, let
us suppose that we respect the decreasing normal form as in Definition
\ref{dnf}. Then we can see that the new quantifiers of our formula do
not have to be exactly where we put them -- we can postpone them to be
at the good place in the sequence, and postpone the new quantifier-free
part to be with the quantifier-free part of the formula. Hence if the
input is formula in decreasing normal form, the output is also a
formula in decreasing normal form.


Then, as we stated, the normal form equivalent formula is indeed in
.

In this article, we will only use formulae in arity normal form,
and this will simplify our proofs, and  will be a
syntactic sugar for .

\sss{Order of the quantifiers}
\label{sec:normalform}
As stated earlier, there is a normal form for  and we will
give an algorithm to obtain that normal form. The difference between
this algorithm and the ``folklore'' one as given in
\cite{lauri,Leivant94higherorder} (the latter is about high order in
general and not in finite structures) is that the folklore algorithm
sends  to  but does not respect the number of
alternations. On the other hand, our algorithm sends  to
. We should note that our algorithm does not respects the
the maximal arity.


\paragraph{Prefix normal form:}
\begin{definition}[Prefix normal form]
  A formula is in \emphdex{prefix normal} form (\emphdex{PNF}) if it begins with a
  sequence of quantifications and ends with a quantifier-free formula.
\end{definition}
\begin{lemma}\label{pnf}
  Every formula in  is equivalent to a formula in prefix
  normal form. 
\end{lemma}
We will assume that there are not two variables of the same
  name. Thanks to -conversion this creates no loss of
  generality.
\begin{notation}
   will be a meta variable for quantifiers, A for atomic formula,
   for disjunction or conjunction and  for a polarity
  symbol (+ or -), where applying - to a symbol will give its dual
  while + will not change it. Hence  and we can even apply a polarity symbol
  to a polarity symbol,  and . On the other hand
   and .
\end{notation}
\begin{proof}(of Lemma \ref{pnf}) We will do a constructive proof, by
  giving an algorithm to transform the formula. We will use three
  auxiliary recursive functions.

\begin{texttt}
  PrefixNormalForm(:=Aux(
\end{texttt}

The result of the Aux function is such that negations are only on
atomic predicates, so it must remember the parity of the number of
 it met. This is the information of the last argument. It will
give an output in prefix normal form with as little alternation as
possible and that is why it must know what was the last quantifier of
order . That is what its third argument is for.  Since we want a
normal form for \hob r j, we assume that the formula begins with an
existential quantification of order , and hence we can give an
 quantifier as argument.

If Aux meets a quantifier, it will write the very same quantifier and
work inductively on the formula. If it meets a negation it will switch
its polarity and continue inductively. Finally if it finds a
conjunction or disjunction, it will act inductively on both parts to
put them in prefix normal form, and then will combine them with
.

\begin{alltt}
Aux(:=match  with
  |let =(if 
     then Aux
     else Aux  in 
  | Aux
  |AA   if A is atomic where -AA.
  |let Aux and Aux  in
    Aux'
\end{alltt}

Of course when we have  on the left of the arrow and 
on the right of the arrow, we assume that both  are of the same
type. This assumption will be true until the end of this proof.

Aux' will take two inputs in prefix normal form, and a parameter to
know if we must consider its conjunction or its disjunction. Then it
will extract from them as many quantifiers of order  of the last
seen polarity as possible. When  and  begin with
quantifiers of the other polarity of order , we will switch the
polarity we want to extract. Finally when one formula has no more
quantifiers (by the prefix normal form we have by induction, we know
it is then a quantifier free formula) we will extract all predicates
of the other formula using .  Finally we
will link the two quantifier free parts of the formula with the
 relation.
\begin{alltt}
Aux:= match  with 
  |if  or  then .Aux else
    match  with
      |if  or  then .Aux
        else Aux'
      |\_Aux
  |\_Aux
Aux:= match  with 
  |Aux
  |
\end{alltt}
An easy induction over  and
 shows that the number of alternations in the
output is the larger number of alternations of the two elements of the
input.  Then an induction over Aux shows that its output respects the
same property. It is trivial to see that if the input was a formula of
order , so is the output.
\end{proof}

This algorithm gives a normal form for  only, as it does not
promise in general to give the smallest number of alternations. For
example:

\texttt{PrefixNormalForm}

The formula with the smaller number of alternations is . But since this formula begins with a
, it is still an  formula.

We can easily change the algorithm to obtain a normal form for
, as it is given by
\texttt{Aux}. Finally, if we want an algorithms to obtain the smaller number of
alternation, it suffices to run both algorithm and choose the formula
with the smallest number of alternation.



\paragraph{Decreasing normal form:}
\begin{definition}[Decreasing normal form]\label{dnf}
  An  formula, for , is in \emphdex{decreasing
    normal form} (\emphdex{DNF}) if it is in the form  where each
   is a quantifier and  is an  formula in
  decreasing normal form.
\end{definition}

\begin{definition}[Normal form]     
  An  formula is in normal form (NF) if it is in both
  arity normal form and decreasing normal form, and hence also in
  prefix normal form and step normal form. A formula in , where  is an operator, is in normal form if it is in
  operator's normal form and its subformula in  is also in
  normal form.
\end{definition}


\begin{theorem}
  Every formula  is equivalent to a formula
   in normal form. 

  And in each group of quantifiers of order , the number of
  quantifiers in  is not greater than the number of quantifiers
  of that order in .
\end{theorem}
\begin{proof}
  Let  be a formula. Thanks to property \ref{pnf}, we can assume
  it to be in prefix normal form and it will be straightforward that,
  while we transform it, it will remain in prefix normal form.

  The proof will be by induction over the order . It is trivial if
   or  because a quantifier free formula and a first order
  formula in prefix normal form are in normal form. Hence we will
  assume that  and that the property is true for all . Now
  we will prove the property by induction over the number  of
  relations of order . If  then it is a formula of order
  , and hence the property is true by induction. So we will
  suppose that  and that the property is true for every . We
  will prove this property by induction over the number  of
  quantifications. It is true if  because it is then a
  quantifier-free formula, which is in normal form; we will assume
   and that the property is true for any formula with 
  quantifications.

  Then , and by induction over the number of
  quantifiers if , or over the number of quantifiers of order 
  if , there exists a formula  in normal form equivalent
  to  . If , then  is in normal form
  and equivalent to , and hence the property is true.

  We will now assume that . If  contains fewer quantifiers
  of order , then  is a formula, equivalent
  to , with fewer quantifiers of order . Hence by the
  induction property over this number we can find an equivalent
  formula in normal form.

  We will then assume that there are at least the same number of
  quantifiers of order  in  as in , and since the
  induction hypothesis tells us that there is not more quantification,
  we will assume that the number of quantifications is the same. Since
   is in normal form and contains a quantifiers of order ,
  then  and we can now write  as
   where  is the tuple whose
  first element is  and whose other elements are the elements of
  . Let us assume for now that this formula is equivalent to
  .  is a formula with fewer quantifiers
  of order  than in  and hence it has got a normal form
   equivalent to , and then  is a formula in normal form equivalent to .

  Here with  we have lost the normal form of last
  section, so let  be equivalent to  and in arity
  normal form. We proved that it is possible, we just need to consider
  the free variables of  that are quantified in the entire
  formula as elements of the vocabulary of , which is coherent
  with our definition. And, as we explained at the end of last
  subsubsection, since  is in decreasing normal form it will
  remain in this normal form.

  \subparagraph{} Now, it remains to prove that  is equivalent
  to  in the last case, which means that  is equivalent to  with . There are four
  different cases, for the four possible values of the couple
  . We are going to make a proof for ;
  the three other cases use the same idea.

  Let  and
  . We are
  going to prove their equivalence, first by proving that the truth of
  the first formula implies the truth of the second one.  Let 
  be a structure, and suppose that , then for any
  relation  there exists a relation  such that , so
  let . Then, for any value of  , , and by
  induction over , we have .

  Now we will show that the truth of the second statement implies the
  truth of the first. Suppose that . Then there
  exists an  such that for all value of 
  we have . Let  be an arbitrary relation, then let , then , and by induction over
   we have .

\end{proof}

\paragraph{Infinite structures}
As stated in the beginning of this subsection, every proof only used
information about the formulae and there is not any use of the
``structure''. Hence this normal form also applies to formulae in
high-order over infinite structures.
\section{High-order queries}\label{hoq}
\subsection{Number of relations}
\begin{definition}Let  be positive integers. We define 
  to be the maximum cardinality of a relation of , 
  to be the number of relations in it,  is the number of
  -tuples of relations and  is the number of bits necessary to
  describe such a relation. These relations are also defined
  without the ``'', for example .\end{definition}
\begin{lemma}
  We have the following equalities:
  \label{size}
  \begin{itemize}
  \item 
  \item
  \item 
  \item 
  \end{itemize}
\end{lemma}
This lemma is similar to the one stated in \cite{lauri} but corrects a
minor error there. We need the ``big O'' to be inside of the exponent
and not around it. 
\begin{proof}Indeed,  is the size of the Cartesian product of  sets
  of  elements each, so
  .

  By induction, supposing the properties are true up to order
  :
  \begin{itemize}
  \item{}An -ary relation of order  is a subset of the tuples of
    -ary relations of order  so
    .
  \item{}Hence the number of -ary relations of order  is the
    number of subsets of the -tuples of -ary relations of order
    , so
    .
  \item The number of -tuples of -ary relations of order  is
    the size of Cartesian product of  copies of the set of -ary
    relations of order , so
    .
\end{itemize}
The proof for  will be the subject of the next subsection.
\end{proof}
\subsection{Encoding relations}\label{code}
In this subsection we will explain how high order relations can be
used and checked in a space-efficient way such that queries of these
relations are also efficient.

Since there are  relations of order 
and arity , we need at least
 bits to encode a relation
 as a string of bits. The last equality is not a surprise,
because all the information one needs to know the relation 
explicitly is the set of -tuples of relations of order  in
; except for the special case , where relations are on
the elements of the universe, but in this case it is well known that
one needs  bits. Since our code will use exactly
this number of bits, it is impossible to find a more space efficient
general encoding.

We will show that this is an exact bound when  by creating a
one-to-one encoding function  from a relation of order  and
arity  onto a string of bits of length . Let
 be a bit position of . As a binary number  is a string
of length , so
inductively, it can be considered as an -tuple of codes of -ary
relations of order . The description will then be that the th
bit will be one if and only if this -tuple encodes an element of
.


It is clear that this is a one-to-one relation and that this encoding
contains all the relevant information, and thus that the equality of
relations is just an equality of strings of bits. It also gives us a
canonical order over relations, which is the order over the binary
code of the relation.



\subsection{Encoding input}\label{acc}
In subsection \ref{code} we explained how to encode high order
relations in a space efficient way. But it is efficient in the worst
case; in graph theory it would be equivalent to the matrix encoding.
But, as in graph theory, it can also be interesting to consider other
codes for the input, especially for non-dense relations.

An example of a possible code would be a circuit such that the leaves
are elements of the universe, the nodes of height  are a relations
of order  and the nodes of height  are -tuples of
relations of order . There is an edge from an -tuple into a
relation if this tuple is an element of the relation, and the
-tuples are of in-degree , where there is an order on the edges,
the  predecessors being of course the  elements of the tuple.

Since many different encodings could be imagined, depending on the
assumptions about the problem one wants to solve, we are going to
speak of a more general property.

\begin{definition}[acceptable code]
  An encoding of a -structure  is said to be
  acceptable if for every relation  and -tuple  the property  is decidable in time
  polynomial in the size of the description of  and .
\end{definition}


\begin{definition}[reasonable input]\label{reasonable}
  A set of input is reasonable for a given code if the size of the
  code of the structures of this classes is bounded by a polynomial in
  the size of the structure.
\end{definition}
By cardinality, it is clear that the class of every structure of order
at least 3 can not be ``reasonable''.

\begin{claim}
  The circuit encoding and the encoding of section \ref{code} are
  acceptable, and they are reasonable for inputs of order 2.
\end{claim}

\subsection{Reducing the order of the input}
Since we mostly want to study the formulae in \hod r2 we are going to
show how to reduce the order of the structures. That is, for a formula
in \hod {r+1}{f+1} for , how to obtain an equivalent formula in
\hod {r}{f} over an equivalent vocabulary of order , for a precise
definition of ``equivalent".

We will define the function ,
and the function  from vocabularies  of order  and
-formulae into vocabularies of order , such that if 
is an -formula then  is a -formula and the
function  is from -structures into -structures such
that .

The encoding will be such that . We
consider that this size is acceptable since an th order relation is
encoded with  bits, and after we apply those
functions we will have a structure with relations of order up to
.  Hence the new size of the encoding of the input will be
 bits.

Let  be a symbol of order  and arity . We define
 as a symbol of order  and arity .

Let ,  a -formula, let  be the
highest arity of a quantified variable of , let
aa'V\phi, then
. If  is a -structure of
cardinality  where  is interpreted as a total order over the
universe\footnote{There is no loss of generality since in high-order
  we can always create a linear order.}, then  contains exactly
 elements where the first  elements represent the 
elements of , and the first  elements, with , represent the second-order -ary relations, the exact
representation being the same as in subsection \ref{code}. The 
will be the same constants,  will be the th element and represents
the size of the input of the former universe,
 will be true if 
represents a second-order -ary relation  and the
 represent elements of the universe, and if
. 

This means that the same elements of the structures may represent both
a first-order element and second order -ary elements for any
. The exact meaning is known only when the variable is queried.
The former th order -ary relations now become
th order -ary relations, the only other change is that
when , we assume that the relation does not accept any
first-order element which is not the representation of a former second
order -ary relation.



\paragraph{} We must define what it means for a relation  to
be a correct encoding of a -ary relation of order . We will do
it with  which means that it contains no first
order elements that are not encodings of second order elements.

Here  is a constant of the new vocabularies which represents the size of
the former universe, we could either  add  to the
input, or define  as  if , else as
 and of course  as .

\begin{lemma}\label{lem:lower}
  For any high-order relation  we have
  . If  is true then
  there is some  such that .
\end{lemma}
\begin{proof}
  The first part is by construction of , and the second one is a
  trivial induction over the order.
\end{proof}

Now we need to define , and we will do it recursively. We assume
without loss of generality that there is no  or . The algorithm is in
table \ref{f}. In this algorithm, when  is a tuple of
variables we denote , 
and if  is a variable whose type is equivalent to  then
's type is equivalent to .
\begin{table*}\label{f}
\begin{tabular}{|l|l|}
  \hline
  &\\
  \hline
  &\\
  &\\
  &\\
  & \\
  &\\
  &\\
  &\\
  &\\
  &\\
  &\\
  &\\
  \hline
\end{tabular}
\caption{F}
\end{table*}
\begin{theorem}
  If  (resp. ) and  then
   (resp ).  For any
  vocabulary , -structure  and -formula
  , .
\end{theorem}
\begin{proof}
  For the first statement, as we can see, the only new quantifiers are
  of order lower than  (resp. of order 1), hence the number of
  alternations of the th order quantification in  is the same
  as the number of th order quantifiers in .
\paragraph{}
For the second statement, we do the proof by induction over
. For the atomic formulae it is by construction, and for the
negation, conjunction and disjunction it is trivial.

\paragraph{}So assume that , and let us prove . If  then there is some  such that , by induction  and
since , then  is true.

For , if  then there is some 
such that , of course then
, hence  and by induction , hence
.
 
\paragraph{The case } 

Let us prove  by induction over the number  of steps
of the transitive closure. If  it is trivial, let us suppose that
 and it is true for . Then there exists  equivalent
to  such that  and  and then by the induction hypothesis
over , we have  hence  and by lemma
\ref{lem:lower},  and by the induction
hypothesis over , .

Now, let us prove , it is also an induction over the number
of steps  that close . If  then it is trivial,
else there exists some  equivalent to  such that
 hence by lemma
\ref{lem:lower} there is some  such that  and by the induction hypothesis over  we have  , which ends the
proof.

The proofs for the fixed points are similar, with induction on the size
of the fixed point.
\end{proof}
\begin{claim}\label{highstructure}
  In this article we will give results for formulae over structures of
  order . In general, if the input structure is of order  and
  hence contains at least one relation of order  and no relation of
  higher order, the time and space bound will decrease, by 
  applications of the logarithm over the bound. In particular, a
  corollary will be that queries in  are computable in
  polynomial time, as proven in \cite{complex}.
\end{claim}


\section{Arithmetic predicates}\label{arith}
\subsection{Predicates over relations}
In finite model theory, the arithmetic predicates are important,
especially in first order, where even partial fixed points can not
express the parity of the size of the universe without an order
relation. In next sections we will often use either bit predicates or
addition over high order relations, so in this section we will first
explain how to obtain those relations.

As it is already known, a linear order can be specified by a second
order binary relation, hence, contrary to what happens in the
first-order case, we will not make any statement about the
existence or the absence of an order relation in the vocabulary.

We intend to show that the usual predicates that we may ask over first
order, bit, plus, times, <, are redundant in high-order; all of these
predicates can be defined thanks to a first-order total order.

We will speak of some arithmetic operations both over predicates and
over tuples of predicates, as both will be useful in this article. To
distinguish them, we adopt the convention that ``predicate''
refers to a predicate over relations and ``predicate'' refers
to a predicate over tuples of relations.

\begin{notation}
  In this section, ``'' will always be an -tuple of
  relations of arity  and order , .
\end{notation}

\begin{claim}[arity of predicate]\label{mon-pred}
  As we will see, to define a predicate over relations of arity ,
  quantification is over variables of arity , and hence there is no
  increase of arity of the formula because of the arithmetic
  predicate. In particular, those predicates over monadic relations
  are monadic formulae.
\end{claim}

\sss{Equality predicate}
If there is a binary first-order equality predicate, then every other
equality predicate can be defined in the logic. Define  to be
the equality predicate over relation of order  and arity , and
then we can define it recursively as: . And of course .

\sss{Order relation}\label{order}
Suppose that we have an order relation on first-order variables,
. Then we can recursively encode a formula
 over relations of arity
 and order  considered as binary numbers.



Here  is a relation over -tuples of relations of order 
defined as: 


\sss{Bit predicate}\label{bit}
It is usual in descriptive complexity to use a ``bit'' relation,
taking two first order variables  and , such that  is
true if and only if the th bit of the binary expression of  is
1.


For high order it is easier; since a relation  is equivalent
to a string of  bits, we can write the  as  relations
of order , and then
\\.

\sss{Addition}

The addition of relations is defined as addition over the
corresponding strings of bits.

 

Here  is syntactic sugar for , and
 is
true if there is a carry propagated in position  in the
addition of  and .



\sss{Addition + Multiplication}
In first-order, it is well-known that addition + multiplication
 bit, and the proof does not specify that the predicate must
be over a first-order object, so the very same proof works for higher
order logic.

Hence, addition + multiplication over first-order elements is
equivalent to the bit predicate over first-order elements, which
extends over higher-order relations as seen in subsubsection
\ref{bit}, which is then equivalent to addition + multiplication over
higher order relations.

\subsection{Addition over tuples}
We will also need to add tuples of elements, and in this subsection we
will show how to do it. Let us define .
\paragraph{Overflow:}
We will define  over -tuples of relations of arity 
and order . First, let  be a
predicate indicating that the addition of  and 
overflows .

This just means that there is no value  such that ,
so .
\paragraph{Addition modulo }
Now we also need to speak of addition modulo , but using only
numbers strictly smaller than .  If the addition does not overflow,
it suffices to test the addition. If it overflows, we can
existentially quantify  and  such that:

\begin{tabular}{ll}
  &\\
  & \\
  &\\
& \\
  &\\
\end{tabular}

We can then see that if  then each variable has exactly
one possible value which is less then . It is trivial for  and
, and for  it is enough to see that, since  and  then , so ;  since , and a fortiori
.

The exact equation of plus modulo () is then:
\\
\paragraph{Addition of tuples:}
We can consider an -tuple of numbers as a number of length  in
base , so addition extends naturally on it. Let us write
 for the addition of -tuples of -ary relations of
order . The idea is the same as the addition of string of bits,
with the difference that propagating overflows can be done in
different ways. The creation of an overflow at position  happens
only if  overflows, and then it
propagates at position  if . But since, if
 then we have , we can
consider that the overflow was created at position . Hence we
consider that the only way for a overflowing bit to propagate itself
is when :




\section{Relations between High-Order queries and complexity classes}\label{equ}
As stated in Section \ref{def}, we have decided to accept high-order
vocabularies. For the logic of order  we accept formulae with
quantifiers of order up to , but the vocabularies can contain
relations of any order. We may usually assume that the order of the
vocabulary is at most , which is coherent with \FO{} which
contains second order relations as its input. This is because, a
relation of order , can only be used with relation of order 
which could not be quantified, hence those relations are in the
structure, and those relations could be replaced by their truth
value without loss of generality.

\subsection{High Order and Bounded Alternating Time}

\begin{theorem}\label{atimeorder} For , 
   for  with
  a reasonable input, as defined in Section \ref{acc}.
\end{theorem}

This theorem is true for  since
\cite{lauri,kolo} proved that
. They did
not write the ``2'' since in their definitions every formulae are over
structures of order 2.

We will then prove the theorem directly for queries over high-order
structures.
\begin{proof}
  Since  , then \hoc rj2 is at least as
  expressive as the definition of \cite{lauri}, so we have this side for
  free: .

  We now want to prove ; let  be a query in
  , so then  where . We
  can begin by existentially guessing , which asks us
  to write  bits for each
  variable of . Then we can universally choose a value
  for , and so on. This takes time and space
   and  alternations. 

    Now everything we will do will use
  deterministic time. There are a finite number of variables, let us
  say  variables, of order up to . Hence each variables can
  take at most  values, and there are then
   possible values for the 
  variables. Writing one of the possible values of those  variables
  on the tape will take , so writing
  all of the possible tuples will take
  
  deterministic time and space.

  Finally we want to check the quantifier-free part of the formula,
  and it is clear that every relation, either quantified relations or
  relations of the structure of order up to , can be checked in
  time at most  thanks to the
  ``acceptable encoding'' assumption. We will check those formulae at
  most  times, so we will spend at most
  
  times checking the quantifier-free part. If we use relations of
  order , to check  we need to use
  random-access, to check if the  bit of  is 1 or not.

  When we consider the total time, we see that it is indeed in
  , and we used  alternations, so
  the theorem is true.
\end{proof}
Taking the union of every classes considered in Theorem
\ref{atimeorder}, we have the following corollary:
\begin{corollary}
  Over any structure, we have .
\end{corollary}

\subsection{Operators on \HO}
In this section, we will prove that the properties we obtain while
adding operators to first and second order logic, relating those
logics to space complexity and deterministic time complexity, extend
naturally over \HO.

In the paper \cite{nfp}, where the nondeterministic and alternating
fixed points are introduced, a characterization of the expressivity of
first order logic with operators was given in term of ``relational
machines''. The reason is the Turing machine model implies an order
over the input, which is avoided by the relational machines, so that
they are better simulations of general first order formulae. Since in
second order we can quantify an order over the universe, and this
order then extends over high order relations there is no loss of
generality in working with Turing machines.

As explained in Subsubsection \ref{opnorm}, there is a normal form for
the formulae with operators. Every formula can be assumed to be
either like  or like , where  is a fixed point operator and  a
formula in . So in this subsection we are always going to assume
that the formulae are in this form.

The table \ref{opnumber} summarizes the maximum number of steps an operator
can make without looping, and the number of bits of information
accessible at each state. There is no information about non
deterministic and alternating computation since it does not change
those numbers.
\begin{table*}\caption{Numbers of the fixed point.}
\label{opnumber}
  \centering
    \begin{tabular}{|l|l|l|}
      \hline
      &Maximal number of step &Number of
      bits \\
      \hline
      &&\\
      &&\\
      &&\\
      \hline
    \end{tabular}
\end{table*}

\sss{Inflationary fixed point and alternating partial fixed point}
It is already known that  over ordered structures, and similarly
\EXP=\SO(\IFP).  In \cite{nfp} it was proved that {} is \NP{} over first
order with an order relation.  They are special cases of the theorem:

\begin{theorem}\label{tifp}
  Over reasonable input we have .
\end{theorem}

The article \cite{DETH} proved
 assuming an order over
the structure and a vocabulary of order 2. Our proof is similar, but
we begin by constructing order and arithmetic relations thanks to
second-order relation.

\begin{proof}
  It has been proven in \cite{alternation} that when  is a function
  greater than the logarithm,  hence
  .


 \paragraph{ Proof of
   }
 Let , such that . Suppose that , then there are
  sets of tuples of relations
 equivalent to , hence we find the fixed point after at most
  steps. Since  we know that
  for some  where ``''
 is an oracle in . This class is a subset of
 , and since there are at most
  elements in  it can still be coded with
 a string of bits, and then checked in time
 . Since in time 
 there are at most  queries to the oracle,
 then checking  takes time
 .

  During the th step we will check for every tuple of relation
   if , applying  with input
  . Since there are up to 
  possible relations, each step will take time
  . Finally,
  since there are at most  steps, the entire
  computation will take time
  ,
  which ends this side of the proof.


 \paragraph{ Proof of
   }
  Let , 

  We are going to use an inflationary fixed point to create the tree
  . We will associate the label of every node to its
  path in .

  Since there is at most  values that  can take
  then there is at most  paths of such length.
  But it is correct since  can also take  values.

  Since by Claim \ref{AFP} the tree  can be cut once we met twice
  the same relation in a branch, and that there is at most 
  relations, we can cut the tree at depth , hence using a
  simple fixed point is not a problem. 



  Then with a second fixed point, we recursively calculate the output
  of the circuit. We consider the leaves that are not a fixed point to
  be the relation , the leaves which are fixed points we
  consider the relation in their label. Then we do union and
  intersection of the gates when we know their children's value.



 \paragraph{ Proof of
   }
 The proof for  was given in \cite{nfp}. The same proof works for
 , except that we can construct an arbitrary order as explained
 above. 





\end{proof}

Once again, accepting that the input contains high order relations does
not change the expressivity, if we consider acceptable input, and that the
input size is the size of the structure and not the size of the
description. And since we have time  and not
, we can even check element of relation of
order .

\sss{(Non)deterministic partial fixed point, Transitive
  closure, Alternating inflationary fixed point and Space complexity}
It is already known that
 over ordered
structures. These equality are special cases of  Theorem
\ref{space}:
\begin{theorem}\label{space}
  Over reasonable input we have  .
\end{theorem}
We are going  to transform formulae from one
formalism to another one without going through machines, giving a
pattern of algorithms for the transformation.
There will be an exception for  that we only know how
to transform into a space bounded TM, the equality using Savitch's
theorem \cite{Savitch}.

The result for  is not a surprise if we consider that  is
time and  is alternations, so that this theorem is similar to
.

\begin{proof}Proof of : Let , .
  Then the fixed point can be obtained with at most 
  iterations since it is inflationary, and there is at most
   paths.

  We are going to transform  in an  formula.  In
   we can do  steps, which is enough to test
  every path. We will make a relation  which has 3 arguments. The
  first one is a path  in the tree , {\it i.e.} a
  string of bits such that the th bit is 0 if the th step in
   was  else 1. When the second argument is 0 then the
  third argument is the relation , else if the second argument
  is 1 then the third argument is 0 to mean that the relation 
  was defined.

  For first step, we let  and  be true. During the
  next step if  is true then we set  and
   to be  true. Finally we end the
  computation when for every ,  is true, then we have
  the  level of the tree , and every
  relation  can be checked in . We check if there is
  one of those relations that is a fixed point, and that contains . If yes, we accept , else . We can not miss a
  fixed point; since it is inflationary, we see it at or before step , and if we discovered the fixed point sooner, it is not a
  problem if we continue to apply  or . (We still have got
  the fixed point, by the very definition of fixed points.)

  If there is  with  which is true, then we
  accept only  so we indeed have got a fixed point, and we
  accept only if  is in the output of this . This ends
  the proof.


\paragraph{Proof of  :}
Let . By the normal form property we can
assume that
. We
also assume that  contains only th order variable and
 is in \hod {r+1}{r+1}. Then

Here   is syntactic sugar for .

\paragraph{Proof of }
Let . We suppose that  is in normal form,
hence  with
. Let us say that  and , so that the
transitive path from  to  can take up to 
steps. We are of course going to do a divide and conquer method,
existentially guessing the middle  of the path, and
universally checking both sides, that there is both a path from
 to , and from  to
, and so on.  Hence we need to make at most
 guesses. For each choice there are
 possibles choices. In \AIFP{} we can only choose one
element of two ( or ) so we will need to guess the
relation in the middle of the path bit by bit, so it will take
 guesses of bit; we use a counter to find when
we have guessed every bit, while there are bits to guess the universal
choice does not do anything. In total this makes
 existential guesses and  universal ones. This is possible in .

Finally we existentially guess when the path is one step long, then we
just check that indeed  is true.
\paragraph{Proof of :} This is trivial,
it suffices to transform a formula of  into normal form,
so that no negation are applied to the operator, and then transform
 to .

\paragraph{Proof of  :}
Let , such that . We are going to give an algorithm in
, which can be simulated in
 by Savitch Theorem.

Suppose that . Then there are
 sets of tuples of type , and hence
writing a value of  takes  bits. We
begin by writing , and we loop so that when we know
 we guess if it is a fixed point, then we look if
 and if ; if yes we
accept, else we reject. Else we guess if we need to apply  or
 to obtain , where the th bit is  if the th
relation equivalent to  is true. We can then loop over every
possible relation of type  to see if it is in ,
enumerating these relations take space ,
and it is already known that testing  is in
. Once  is known we can
forget , so there is no need of more space.

\paragraph{Proof of :}
As we already know, we can encode a configuration of a TM in
 and using space
 using relations of order ; of course
our relation will be . We now only need to be able to decide if one
configuration is the successor of another one.

If we encode a configuration as a string of bits, 00 for 0, 01 for 1,
and 1 for the head of the Turing machine in state , then to
decide the value of the bit  at time , we only need to look at
up to  bits on the left and on the right of a bit at time
. Since we have a ``'' relations over high-order relation we can
easily do it in  (because  is a constant for a given
TM). This let us speak of the next step of the Turing machine.



We can assume without loss of generality that there is only one
accepting configuration, with empty tape, and that the Turing machine
loops on this configuration. Then the formula will check if the
description of this configuration is accessible.
\end{proof}


Once again, accepting that the input contains high order relations does
not change the expressivity, if we consider only acceptable input, and that the
input size is the size of the structure and not the size of the
description. And since we have space  and
not , we can even check elements of relations
of order .

\sss{Nondeterministic inflationary fixed point}
In \cite{nfp} it was proved that {} is \NP{} over first
order with an order relation. This is a special case of Theorem
\ref{tnifp}

\begin{theorem}\label{tnifp}
  Over reasonable input we have .
\end{theorem}
  \begin{proof} Let  with . Then we
    will existentially guess a relation  whose type is a pair of
    's type. The first half of the arguments is a time-stamp,
    such that  is the relation  where 
    is considered as a number.

  Since  is an inflationary point, it can take at most
   iterations; since the counter, which consists of
  variables of order , can count up to  we can
  indeed encode every steps in one relation.

  We then just need to check if  is in  for
  some  such that  is a fixed point for both
   and .

\paragraph{Proof of :}
Let  with . We will
nondeterministically guess every bit of ; there are  such bits and we can do  steps in an
inflationary fixed point. 

We will create a relation  that takes three arguments. The second
one is a time-stamp . If the first argument is 0 then the
last argument is the string of bits that we are constructing. Else if
the first argument is  then the third argument is ; this means
that the string of bits at time  was already defined.

When  we must have , and when , if
 is defined and  is not, then the values of
 is either multiplied by 2, in , or by  and
incremented by . Finally, when the string of bits is completed,
we check if  is true when  is replaced by
.

If it is true, we accept the arguments , else nothing. Since
nothing else changes, this is a fixed point, and  will be true
if and only if  is verified by this string of bits.

\end{proof}


We think that this is an equality (at least for  it is one), but the
other side of the relation seems harder to prove.
\subsection{Horn and Krom formulae }\label{horn}
Another important result in descriptive complexity theory is that
 and . We will discuss the problem of
extending these results to higher-order.

\begin{definition}[Horn and Krom formula]A literal is an atomic predicate
  or its negation, the first one is called a positive literal and the last
  one a negative literal. A disjunction of literals is a clause, and a
  conjunction of clauses is a quantifier free formula in conjunctive
  normal form (CNF). A CNF formula is then a formula , where the  are
  quantifiers and  is a quantifier-free CNF formula.

  A Horn formula is a CNF formula such that in each clause there is
  exactly one positive quantified literal. A Krom formula is a CNF
  formula such that in each clause there are at most two literals.
\end{definition}

Over second order, the proof of the equality begins by proving that
those classes have a normal form where every second order quantifier
in existential. Over higher order, it is not easy to see what this
normal form would be. For example in \hoa{3} we can not require
the second order quantifiers to both all be universal and all be existential. And if we
accept the first order to be also existential then problems like
``clique'', which are known to be NP-complete, can be coded in
\SO(\HORN), so finding the good restriction over quantifiers is
mandatory to have an interesting result.


\subsection{Monadic High-Order Logic (MHO)}
\label{sec:mho}
Monadic Second Order  is a well-studied logic, we intend to
study the monadic restriction of logic of order at least 3, as we will
see the theory is really different.

\begin{definition}
The set of monadic relations of order  is the th
  power set of the universe, ; where we define  and  and  is
  the usual power set operation. 

  The \emphdex{Monadic High-Order Logic of order  } (\mhoa{r}) is
  defined as the subset of queries of  where all quantified
  relations are monadic. The definitions of 
  and  are straightforward extensions of the \HO{} and
   definitions.
\end{definition}
The definition only restricts the arity of quantified relation, and so
the vocabulary of a formula may contain many-ary relations.

It is well known that one of the main problem with  is that one
can not create an order over the structure. But in Monadic Third Order
one can quantify a set of the form  and use this
as a linear order over the structure. This let us create addition with
the set  and multiplication with the set
, hence we can define a ``bit'' predicate
and simulate Turing Machine. 

It is important to realize that Theorem \ref{atimeorder} assumed that
we can increase the arity to obtains more space and time. Since we can
not do it anymore we see that the big  is not anymore in the top of
the tower of exponential, but in the second floor. Hence we
obtain similarly  Theorem  \ref{mho_t}

\begin{theorem}\label{mho_t}
   for  with a
  reasonable input.
\end{theorem}









\section{Conditional relations among the classes}\label{cond}
In this section, we will discuss theorems of the form ``If 
then '' where  and  are complexity classes or
theories over finite models.  Most results use a padding argument
or are corollaries of theorems known on lower complexity classes. What
will be more interesting is to study the results that seems intuitive
but that we do not know how to prove.

There are conjectures in high complexity classes which seem to be copy
of theorem over polynomial classes, we will explain why the known
proof for polynomial classes fails on higher classes.

We are going to work mostly with Turing Machine, and we will also
translate the results are descriptive complexity's theorem or
question.

We also should emphasize the fact that when we do not explicitly state
any assumptions over the function classes, then they could contains
only one function, hence we also obtain theorem over complexity time
bounded by a function.

\subsection{The th exponential hierarchy}
It is known that , the polynomial time hierarchy, and
 is the th level of the
polynomial hierarchy. We are going to extend this hierarchy to higher
order.
\begin{definition}[th exponential hierarchy]
  Let  be the th exponential hierarchy, and
   be the th level of the th exponential
  hierarchy.
\end{definition}
We choose the name such that the (alternating) time of th
exponential hierarchy has  exponential under the .  We have the
polynomial hierarchy as the th exponential
hierarchy. Our definition is different from the ``Exponential
hierarchy'' of \cite{pap} in that his hierarchy is
, and in each of
our levels we also consider alternations.

\begin{definition}[Collapsing]
  For a class of function  we say that  collapses to the th
  level if , .  By extension we
  say that \hoa r (resp. \hod rf) collapses to the th level if for
  all   (resp.  
  \hoc{r}{j}{f}=\hoc{r}{k}{f}).
\end{definition}
\subsection{General classes of functions}
\begin{lemma}\label{lem:alt}
  Let  be a class of function, and , if
   then
  .
\end{lemma}
\begin{proof}
  The proof is almost identical to the one of the polynomial
  hierarchy, which is the special case . If
   then their complement are also equals,
  so we have  hence
  .
\end{proof}
\begin{theorem}\label{atimehigher}
  Let  and  be classes of functions such that for all 
  there exists a function  computable in time (resp. space
  , resp. space ) and  such that
   and for all  there exists
   such that . Let  and
  assume that  then
   (resp. assume that
   then , resp. assume
  that  then
  ).
\end{theorem}
\begin{proof}
  Let  and  a language decided by a TM
  (resp. , resp ) and let
  . It can be decided by a TM (resp. , resp. )
  which tests whether there is a correct number of  and then
  simulates  (it is possible in our bound since  and  is constructible  in
  ), hence by our assumption there is  such that
   can be decided by a TM  (resp. id.,
  resp. ). Then  can be decided by a TM 
  which, on input , writes down , which takes time
   (resp. space , resp time ), and then
  simulates  on , which takes , and by
  hypothesis there exists  such that
  (resp. id, resp. ), hence we indeed have
  
  (resp. ,
  resp. ). The proof of  is
  trivial since .
\end{proof}
\begin{corollary}
  Let  be integer functions such that there exists a function ,
  computable in time , such that . Then for
  all   implies
  ,  implies
   and  implies
  .
\end{corollary}
It is surprising that we do not know how to prove that if
 then  collapses to level . But we
think that it must be true, or at least that it would be really hard
to prove it to be false. First because if it was false it would imply
, and also because it would be surprising that, for
some complexity classes, having  or  alternations is as
expressive, but having  alternations is strictly more expressive.



\begin{lemma}\label{hocollapse}
  Let  and .  Then  implies
  that ,   implies
   and    implies
  .
\end{lemma}
\begin{proof}
  Let  and ,
  the condition of Theorem \ref{atimehigher} are respected since, for
  all  , ,
  we have  and for all  let
   it is easy to see that  hence
  .

  By Theorem \ref{atimeorder}  is equal to
   and by Theorem \ref{space}
   is equal to . Then the corollary
  is just a translation of Theorem \ref{atimehigher} in a descriptive
  complexity setting.
\end{proof}

\subsection{Polynomial hierarchy and exponential hierarchies}
First we are going to prove that hypothesis on the polynomial
hierarchy and polynomial space imply results on the exponential
hierarchy. Hence we may prove some interesting result on polynomial
classes by proving them in exponential hierarchy.

\begin{theorem}\label{little_collapse}
  Let  be a class of functions which contains at least every linear
  function and let  be a class of time-constructible functions
  closed under addition and such that . If  or
   then  and if
   then .
\end{theorem}
Here we use a definition of TM with one reading tape and one working
tape, this way the linear time function can at least verify their
bounds.
\begin{proof}
  The first assumption implies the second one by Lemma \ref{lem:alt},
  hence we are only going to suppose that
   without loss of generality. We will do
  the proof by induction over , for , we want to prove that
  .  We will only prove 
  because  will be true by symmetry. It is only a padding
  argument, let  and  decided by a TM ,
  then .  can be decided by a TM 
  in  hence in  for some ,
  then  can be decided by a TM 
  which writes  ``1'' on his working tape and simulates . By
  our assumption on  we then have that ,
  hence .

  Now, let  and suppose that the property is true for , that
  is that  and let 
  be a language accepted by a TM  with . Then on input  of size , we may assume without loss of
  generality that  makes  existential steps writing 
  symbols on the tape, and then make  alternations. Let us say
  that this first part is done by a TM . Then  make a second
  part in  where  is  or 
  depending on the parity of , let us call  the TM that
  ends the computation of , since it's input tape is of size
  , . There is some  such that there is a
  TM  (where  and
  ) equivalent to , now we create a TM 
  which begin by simulating  and then ; we indeed have
  only  alternations, and the time of the computation is
   which is in  by our assumptions, hence  is also
  accepted by  where the last
  equality is by the induction hypothesis. We obtain the result
   by symmetry.
\paragraph{}
The result about space is a corollary of theorem \ref{atimehigher}
when we take  and . We always take  and
for any   by the closure
assumption.
\end{proof}
\begin{corollary}\label{cor:collapse} 
  If the polynomial (resp. linear) hierarchy collapses to the th
  level then every exponential hierarchy collapses to the th
  level. If  then
  .
\end{corollary}
\begin{proof}We apply theorem \ref{little_collapse} with 
  (resp. ) and  for . It is easy to see that
   is closed under  and under addition.
\end{proof}





































\subsection{Classes of formulae}
Now we will give results for the formula formalism, there may
not be corollary of the results over general classes of formulae
because of the order of the vocabularies of the formulae, something
which does not have any exact translation in the TM setting.

\begin{lemma}\label{lem:collapse}For :
  \begin{enumerate}
  \item if  with  then
    .
  \item If  with (resp. )
    then
    
    for all  (resp. ).
\item If  or
     for  (resp ) then
    \hod rk collapses to the th level for  (resp ).
  \end{enumerate}
\end{lemma}

The proofs are almost identical to the one for the polynomial
hierarchy which is the special case .

\begin{proof}(of the lemmas) 
  For the first point, if  then their
  complements are also equals, so we have
   hence
  .

  For the second point, let  with 
  (resp. ), then  where
   (resp. \cohoc{r}{j}{r+1}), then there
  exists  (resp. \hoc{r}{c}{r+1}) equivalent to
  , then  is equivalent to
   and is in , hence
  .  By symmetry we also have
  . The other side,
  , is trivial, and by transitivity
  .

  For the third point, by the first point of the lemma the first
  condition implies the second one, hence we are only going to use
  this condition, that  for 
  (resp ). By induction over , we will prove that
   for 
  (resp. ). For  this is the second point of the lemma, so
  assume that  and that the property is true for , by the
  second part of the lemma we have 
  , and
  the last equality is true by induction.
\end{proof}

What is surprising is that it seems that we do not have a proof that if
 then \hod{r}{2} collapses to level
. This is because, if , then  with  and not in \hoc r{j}2; and we
have no hypothesis about this class.  Lemma \ref{lem:collapse} is
almost what we would have wanted, but in the lemma we must bootstrap
the property with an assumption over formulae with a free variable of
order , and in the theorem with a formula whose highest
free-variable is of degree 2. This is the descriptive complexity
translation of the question raised in \cite{sky}: if two levels of the
\eh r are equal, does the \eh r collapse? The proofs used for the
polynomial hierarchy do not work because exponentials are not closed
under composition.

\section{Variable order}\label{vo}
Variable order (\VO{}) is an extension of high-order where the orders
of the relations are not fixed any more but are variable. It was defined
in \cite{lauri}, and it was proved there that it is ``complete''; and in
fact more expressive than Turing machines, because it can decide the
halting problem, and hence also its complement.

One problem with \VO{} is that two -equivalent formula are not
always equivalent. \\ is false while  is true.

In this section we first give a new definition of
``\emphdex{Variable order}'' logic, equivalent to that of
\cite{lauri}, but that we consider easier to use, at least because it
respects the equivalence of -equivalent formulae.  Then we
prove that \VO{} contains the analytical hierarchy.

\subsection{A new definition}


\begin{definition}[Sequence of relations]
  A sequence of relations (of arity ) is such that the relation
  number  of the sequence is of arity  and order .

  We will write  to
  mean `` is a sequence of arity ''.
\end{definition}
\begin{definition}[Variable-order (\VO{})]Now the vocabularies will be
  over two sorts, the positive integers and the sequence of relations.
  The quantifiers of our logic will be over one of those two
    sorts.

  A variable-order formula  is defined recursively as usual,
  such that if  and  are formulae then  and  are also
  formula; where  are sequences of relations and  is an
  order variable taking values in 

  Finally , ,  and  are the atomic formulae where 
  and  are variable orders and  and the  are
  untyped relation variables.

  The closed formulae are defined as usual.
\end{definition}

\begin{definition}[Semantics of \VO{}]
  We will write  to speak of the element of order  of
  the sequence .  
  and  have their usual meaning.
  \begin{itemize}
  \item  if and only if 
  \item  if and only if 
  \item 
    if and only if  and 
  \item  if and only if 
  \item  (resp.  ) if and only if for all sequences (resp. if
    and only if there exists one sequence)  of -ary relation of every
    positive order: 
  \item  (resp.  ) if and only if for all (resp. if and only if there exist
    one) : 

  \end{itemize}
\end{definition}
We are now going to define , which is the ``variable order'' as
defined in \cite{lauri} and prove that our definition is equivalent to
theirs.

\begin{definition}
  We have an infinite number of order variables
  , of first order variables
  , and of untyped relation variables . As in , there are quantification
  over order variables, but there is also quantification over
  first-order variables, and the quantification over relations
  ``associates'' with it a non-free order variable. The atomic formula
  are then 
  where the exponent is associated with the relation variable, and the
  value of the exponent variable is the value of this variable in the
  scope of this formula.

  We emphasize that the value of an order variable associated
  with an untyped relation variable can change between the association
  and the atomic formula if the variable is quantified again.
\end{definition}
\begin{theorem}\label{vovo}
  \VO{} is equivalent to .
\end{theorem}
\begin{proof}Every formula in  is also a formula in \VO{} and
  its semantics is the same, so \VO{} is at least as expressive that
  .

  Let  be an \VO{} formula over the vocabulary , let
   be the variables of  and let
   be  new order variable. We will
  create an  formula  such that  is equivalent to .

   is  where the  are replaced by  and the atomic formulae containing  will be
  replaced this way:
  \begin{itemize}
  \item  is replaced by ``''
  \item{} is
    replaced by ``'' where
    ``'' is a syntactic sugar for ``''.
  \item{} is replaced by ``''.

  \end{itemize}

  \begin{lemma}Let  be a vocabulary,  a formula over
     such that there are  relation variables,  a
    set distinct of  of cardinality ,  a
    -structure and  an extension of  over
    vocabulary . Then .
\end{lemma}
This lemma implies that  will be such
that .

\begin{proof}Of the lemma
  
  The proof for  and  is an easy induction.
  \begin{itemize}
  \item If  is , then .  Then  if and only if for all sequences of relations , , and since  is a
    -structure which is an extension
    of the -structure  by
    induction we indeed have .
  \item If  is  the proof by induction is the
    same.
  \item If  is , then . Then  if and only if for all positive integer , , and
    since  is a -structure which
    is an extension of the -structure ,
    then by induction  we indeed have .
  \item If  is  the proof by induction is the
    same.
  \item If  is  then . We
    will show  by
    two implication.

     by definition  means that , so  is a correct value for both
     and  such that , hence  is true.

     it is clear that if  is
    true, then  must be true
    when , so .

    The important point in this case is that the value of  in
     has no importance.
  \item If 
    or  then  and a
    similar proof can be done, showing that the equality in 
    will make that the value in  has no importance, and will
    end the proof.
  \end{itemize}
\end{proof}
\end{proof}
There is in fact one last difficulty not treated in this proof, \VO{}
accepts that the variable order can be free and that its value can be
given in the vocabulary, which is forbidden in . For inductive
proofs it is easier to just consider that we can have order variables
in the vocabulary. And even if we reject the free order variable in
the formulae, we will see in section \ref{fvo} how to encode them with
relational variables in \VO.  

\subsection{Arithmetic on order variables}\label{iter-rel}
Let  and  be order variable, we will show that we can define
both  and . In this definition we will assume that
there is at least 2 elements in the universe.

\begin{notation}
  In this section  will means that the variable  is
  of arity .
\end{notation}
We cannot write  as an exponent since exponent are used for order
variables. But since in the proofs we will not use list of variable
there will be non confusion.

Also in this section `` contains '' means that . We will use many straightforward syntactic sugar:

In equation \ref{plusconst}  is a constant. In \ref{iter-rel} the
relation can also be <,  or =.

\sss{Variable order as input}\label{fvo}
We will first need to be able to take number as input, and create a
formula  such that the number of variable satisfying a monadic
second order predicate  is equal to the the order variable
. Formally we want that  is the only
value such that  is true. We will not use a binary
encoding but this unary one for clarity; since we intend to prove
calculability results and not complexity one, there is no difference.

The idea we will use is to create a class of binary high-order
relation; let us call this class ``\emphdex{unique}''.

\begin{definition}
  The binary relation  is \emph{unique up to level } if every
  element of the sequence  of order at most  contains only
  one relation, which is the precedent element of the sequence
  repeated twice, and the elements of order greater than  are
  empty. This imply that  contains exactly  elements.

\end{definition}
We will then state that there is a bijection between the elements of
 and the variable  that respect some property , this
will create the wanted relation between the order (of ) and the
elements satisfying .

A bijection will be a set  of couple of elements 
(with ), one of the element of the couple will be an element of
 and the other one will be an  such that . By
definition of , if  then for all ,
, hence we will use a more precise definition; we
will say that  is an element of  if  is the biggest
order  such that .
 

 It is easy to obtain such an element, we define a list 
 this way; , , and for every
   is the only relation of  where  is the ``false'' relation. It is then clear
 that  and that .

 Of course, every element  of the set  will contain
 at most two elements, one element  and a  verifying
 .  can contains also one element if . The fact
 that there are exactly one elements satisfying  in 
 can be called ``surjection''. 



And we must also check that every element of  and every 
such that  is an element of  is contained in an  of  . It is here that it is important that 
contains at most one element at each level, this way we are sure that
there is exactly one element of first order in , if this
element is an element of  then we will assume it is in bijection
with itself; and there is no other element of  that could imply
that a first order element , which verify  is in . The fact that every element has got an image in 
can be called the ``injection''.

Defining the bijection is just the conjunctions of injection and
surjection.


Assuming that there is at least one  verifying  we can tell
that there are  elements  verifying , with this formula.

Here  means that  is going to be the free
variable of the property used in the formula of ``bijection''.

\paragraph{}The problem here was that there is no relation of order 0,
we are then going to encode them. We will do it this way: (1,1) means
0, (,2) means  and (,) for  or ( and )
means nothing.



\begin{theorem}
  \VO{} is not more expressive if the formula can have free degree
  variable .
\end{theorem}
\begin{proof}
  Let  be an integer, 
  and  be sets of  order variables and
  monadic second order relations, let  be a finite universe, let
   be a vocabulary distinct from  and , let
   be a -structure and let  the
  -structure such that for  , and for  we have , let  be a formula over
  vocabulary . Then .
\end{proof}
\sss{Addition}
We now want to be able to add order variables. The idea will be the
same,  if there is a bijection between a relation of order 
and the union of a relation of order  and a relation of order .
We will do it by having  be in , and quantify a
bijection between elements of  and the elements of 
of order higher than .

We need to make sure that the bijection between elements of 
and the one of  is correct by checking that there is no element
that are both in  and  , this is the point of
different.











Finally, using the code for 0 and positive integers of the last
subsection, we can define the addition of .

\sss{Multiplication}
Finally we want to code the multiplication of order, once again the
formula  will choose relations  and ,
unique up to order  and  respectively, such that there is a
bijection between the elements of  and the Cartesian product of
the elements of  and of the elements of .

Of course we now can extend the multiplication over every non negative
integers.


\sss{Set of natural numbers}
We can define any set  in \VO{} as a sequence of
relation  such that if  then  else
. We can of course assert that  is a correct
code with

and that  with 



\subsection{VO contains the analytical hierarchy}






\begin{definition}[Analytical hierarchy(\AnH)]
  Let  where
  the  are constant natural numbers and the  are constant
  sets of natural numbers. Let  be a -structure over the
  universe  such that every arithmetical operation has
  its usual meaning.

  Then let  be the set of
  formula with quantification only on first order variables. The
  formula  is in  if it is in the form
   where  is in , ``'' is a quantification over the subset of .  A
  formula is in  if it is the negation of a formula in
  . Let ,
   is the th level of the analytical hierarchy.

  The analytical hierarchy (\AnH) is equal to the union of the
  ; .
\end{definition}




\begin{theorem}
We have
\end{theorem}\label{anhvo}
\begin{proof}This section explained how to transform input into order
  variable, and how to add and multiply order variable; it also
  explained how to quantify sets of natural numbers, and express that
  a number is inside of the set.  Then every formula of \AnH{} can be
  easily encoded into \VO.







\end{proof}
\section{Open problems}\label{open}

\paragraph{Direct equality between classes}
When many classes are equal, it may be interesting to find a way to
directly transform the formulae without needing to encode a Turing
machine. So we may want to find a direct translation from  to ,  or . We
also would like to prove that .


\paragraph{\eh r}Is  a strict subset of  ?
For  this question is: ``Does the polynomial hierarchy collapse
to the th level ?''. And as we saw in theorem \ref{cor:collapse} if
we can prove that there is at least one  such that the \eh r does
not collapse to the th level, then the same result is true for all
. This may eventually be a way to prove that the polynomial
hierarchy does not collapse to some level, hence that .

We also wonder if  is strictly contained in
, for  it is the question .

More surprising, we leave as open the question: If ( or ), for , does \hod rf collapse to
the the th level ? In general, for a class of function  what is
the condition over  such that  or
 implies that the class 
collapse to the ( ?) level. We gave sufficient condition but
can not prove that they are necessary. We think that those implication
must be true, because for them to be false we must have that, for some
,  or  alternation does not change the expressivity, but 
for some ,  alternations is more expressive; this seems to make
no sens.

\paragraph{Relational machines}

Relational machines where introduced in \cite{AbVi}, and extended in
\cite{nfp}; they are an extension of the Turing machines with relation
register. The input are given in the register and not on the tape,
which remove the implicit order that Turing machines usually has on
the input. The machine can, as usual, write on the tapes, read the
tapes, but can also apply boolean operations to the registers and
check if a register is empty. The input is then measured as the number
of different types of elements in the input; because the size of the
input can not be known by relational machines.

It was proven that relational-\P, relational-\NP{}, relational-\PSPACE{}
and relational-\EXP{} are equivalent to , ,
 and , and that two relational classes are
equivalent if and only if the usual classes are equivalent.

We think that it may be interesting to find a correct extension to
those relational machines to simulate high-order formulae. In
particular it may give let us transform the ``reasonable input''
assumption into something more formal over those relational machines.

\paragraph{Fixed arity high-order}
We discussed Monadic High Order, which is the special case of
``maximal-arity'' beeing 1 as defined in \cite{arity}. It may be
interesting to give a better caracterisation of expressivity of logics
in function of maximal-arity, basic-arity \cite{kolo} or other
restriction of arity.

\paragraph{Restrictions}Is there a good way to define Horn and Krom
formulae in high-order ? As stated in section \ref{horn}, finding a
correct definition with good properties seems to be not trivial. 
Finally, over high-order, is there some other syntactic restriction
which give interesting properties?

\paragraph{Games}
In first and second order logic, games, like the Ehrenfeucht-Fraïssé
(see chapter 4 of \cite{libkin}) ones, are tools to prove that some
queries are not expressible in a given logic. It would be interesting
to extend these games over the high order classes.  We might even define a game
for every class, which would let us prove that some queries are not
elementary.

Those games would be very hard to win for the duplicator, so it would
then be interesting to try to find easier games.

\paragraph{Other extensions}
What would be the effect of adding counting quantifiers, or unary
quantifiers, over high order logic? How would the different
infinitary logics be more expressive with high order? (The definition
of those logic can be found in chapter 8 of \cite{libkin}.)

\paragraph{Variable order}
What is the exact upper bound on the expressivity of variable
order? We give the analytical hierarchy as a lower bound,
, and we conjecture this to be an equality, but
coding a variable order formula into the analytical hierarchies seems
to be a nontrivial technical task.

What would be the expressivity of  if the order variables could not be
quantified many times? Since the variable should be quantified before
the formula it is associated to is quantified, it could be a severe
restriction to the expressivity of the language. The author thinks
that this would express exactly the class of functions computable in
elementary time. (This class is at least a lower bound, since this
version of  would be a superset of  for any value of
).

The idea behind this assumption is that with a finite number of order
of variable it is impossible to find difference between two relations
of order sufficiently high, if we can decide what is the exact bound
for a given number of order variable, let us say , then we can
replace every  by , hence the language is
decidable and it seems that this kind of formulae can be written as
formulae in (with  differents value of order from 1 to  for
every relation variables).

\bibliography{fo}

\end{document}
