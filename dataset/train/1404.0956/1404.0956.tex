\documentclass{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{times}
\usepackage{txfonts}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{code}
\setlength\hfuzz{3pt}
\usepackage{mathrsfs}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\let\mathpzc\mathscr
\let\mathpzc\mathcal
\def\BNF{\ \  | \ \  }
\def\bondi{{\bf bondi}}
\def\ltrans{[\![}
\def\rtrans{]\!]}


\usepackage{prooftree}
\usepackage{macros}



\pagestyle{plain} 

\sloppy



\renewcommand{\beq}{\simeq}
\renewcommand{\rew}{\redar}
\newcommand{\xangle}[1]{\langle #1 \rangle}

\newcommand{\edited}[1]{#1}

\newcommand{\withproof}[1]{#1}

\newcommand{\withrw}[1]{#1}


\title{Expressiveness via Intensionality and Concurrency}
\titlerunning{Expressiveness via Intensionality and Concurrency}
\author{Thomas Given-Wilson
\thanks{This work has been partially supported by the project ANR-12-IS02-001 PACE.}}
\authorrunning{T. Given-Wilson}
\institute{INRIA, Paris, France\\
\email{thomas.given-wilson@inria.fr}}

\begin{document}
\makeatactive

\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\to}
\makeatother
\makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash=}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}

\maketitle  

\vspace{-0.4cm}

\begin{abstract}
Computation can be considered by taking into account two dimensions:
extensional versus intensional,
and sequential versus concurrent.
Traditionally sequential extensional computation can be captured by
the -calculus. However, recent work shows that there are more
expressive intensional calculi such as -calculus.
Traditionally process calculi capture computation by encoding the 
-calculus, such as in the -calculus.
Following this increased expressiveness via intensionality, other
recent work has shown that concurrent pattern calculus is more
expressive than -calculus.
This paper formalises the relative expressiveness of all four of these
calculi by placing them on a square whose edges are irreversible
encodings.
This square is representative of a more general result:
that expressiveness increases with both intensionality and concurrency.
\end{abstract} 


\section{Introduction}
\label{sec:intro}

\vspace{-0.1cm}


Computation can be characterised in two dimensions:
{\em extensional} versus {\em intensional};
and {\em sequential} versus {\em concurrent}.
Extensional sequential computation models are those whose {\em functions} cannot distinguish the internal structure of their {\em arguments}, here characterised by the -calculus \cite{Barendregt85}.
However, Jay \& Given-Wilson show that -calculus does not support all sequential computation \cite{JayGW11}.
In particular, there are intensional Turing-computable functions, characterised by {\em pattern-matching}, that can be represented within -calculus but not within -calculus \cite{JayGW11}.
Of course -calculus can encode Turing computation, but this is a weaker claim.
Ever since Milner et al.~showed that the -calculus generalises -calculus \cite{90426,milner.parrow.ea:calculus-mobile},
concurrency theorists expect process calculi to subsume sequential computation as represented by -calculus \cite{90426,milner.parrow.ea:calculus-mobile,citeulike:500640}.
Following from this, here extensional concurrent computation is characterised by process calculi that
do not communicate terms with internal structure, and, at least, support -calculus.
Intensional concurrent computation is represented by process calculi whose communication
includes terms with internal structure, and reductions that depend upon the internal structure
of terms.
Here intensional concurrent computation is demonstrated by {\em concurrent pattern calculus} (CPC) that not only generalises intensional pattern-matching from sequential computation to {\em pattern-unification} in a process calculus, but also increases the {\em symmetry} of interaction \cite{GivenWilsonGorlaJay10,givenwilson:hal-00987578}.
 
These four calculi form the corners of a {\em computation square}
\vspace*{-0.3cm}
\begin{center}
\begin{picture}(250,65)(0,0)
\put(5,43){\mbox{-calculus}}
\put(125,43){\mbox{\ \ \ \ \ \ \ \ \ \ \ \ \ -calculus}}
\put(5,5){\mbox{~-calculus}}
\put(123,5){\mbox{concurrent pattern calculus}}
\put(68,45){\vector(1,0){80}}
\put(68,8){\vector(1,0){45}}
\put(34,35){\line(0,-1){5}}
\put(34,26){\vector(0,-1){8}}
\put(183,35){\line(0,-1){5}}
\put(183,26){\vector(0,-1){8}}
\end{picture}
\end{center}
where the left side is merely extensional and the right side also intensional;
the top edge is sequential and the bottom edge concurrent.
All arrows are defined via valid encodings \cite{G:CONCUR08}.
The horizontal (solid) arrows are {\em homomorphisms} in that they also preserve {\em application} or {\em parallel composition}.
The vertical (dashed) arrows are {\em parallel encodings} in that application is mapped to a parallel composition (with some machinery).
Each arrow represents increased expressive power with CPC completing the square.

This paper presents the formalisation of these expressiveness results for the four calculi above.
This involves adapting some popular definitions of encodings \cite{G:IC08,G:DC10,G:CONCUR08}
and then building upon various prior results
\cite{Curry58combinatorylogic,90426,milner.parrow.ea:calculus-mobile,GivenWilsonGorlaJay10,JayGW11,GivenWilsonPHD}.
These can be combined to yield the new expressiveness results here captured by the
computation square.

The organisation of the paper is as follows.
Section~\ref{sec:encoding} reviews prior definitions of encodings and defines the ones used in this paper.
Section~\ref{sec:sec} reviews -calculus and combinatory logic while introducing common definitions.
Section~\ref{sec:sic} summarises intensionality in the sequential setting and formalises the arrow across the top of the square.
Section~\ref{sec:cec} begins concurrency through -calculus and its parallel encoding of -calculus.
Section~\ref{sec:cic} recalls concurrent pattern calculus and completes the results of the computation square.
Section~\ref{sec:conclusions} draws conclusions, \withrw{considers related work,} and discusses future work.

\section{Encodings}
\label{sec:encoding}

This section recalls valid encodings \cite{G:CONCUR08}
for formally relating process calculi and adapts the definition to define homomorphisms and
parallel encodings.
The validity of valid encodings in developing expressiveness studies emerges from the
various works \cite{G:IC08,G:DC10,G:CONCUR08}, that have also recently inspired similar works
\cite{LPSS10,LVF10,gla12}.
Here the adaptations are precise definitions of homomorphisms that give stronger positive
results (the negative results are not required to be as strong).
Also, parallel encodings are defined to
account for the mixture of sequential and concurrent languages considered.


An {\em encoding} of a language  into another language  is a pair
 where  translates every -term into
an -term and  maps every name (of the source language) into a tuple
of  names (of the target language), for .
The translation  turns every term of the source language into a term of the
target; in doing this, the translation may fix some names to play a precise r\^ole 
or may translate a single name into a tuple of names. This can be obtained
by exploiting .

Now consider only encodings that satisfy the following properties.
Let a {\em -ary context}  be a term with 
holes  that appear exactly once each.
Moreover, denote with  and  
the relations  (reduction relation) and
 (the reflexive transitive closure of ) in language ;
denote with  an infinite sequence of reductions in .
Moreover,
let  denote the structural equivalence relation for a language , and
 denote the reference behavioural equivalence for language .
For simplicity the notation  denotes that there exists 
such that  and , and may also be used with 
or . Also, let  mean that there exists  such that  and ,
for some  where  is a specific process to indicate success.
Finally, to simplify reading, let  range
over terms of the source language (viz., ) and  range
over terms of the target language (viz., ).

\begin{definition}[Valid Encoding (from \cite{G:CONCUR08})]
\label{def:ve}
An encoding  of  into 
is {\em valid} if it satisfies the following five properties:
\begin{enumerate}
\item {\em Compositionality:} for every -ary operator  of 
and for every subset of names ,
there exists a -ary context  of 
such that, for all  with , it holds
that .

\item {\em Name invariance:}
for every  and name substitution , it holds that

where  is such that 

for every name .

\item {\em Operational correspondence:}
\begin{itemize}
\item for all , it holds that ;
\item for all , there exists  such that  
and .
\end{itemize}

\item {\em Divergence reflection:}
for every  such that 
, it holds that 
\linebreak  \mbox{}.

\item {\em Success sensitiveness:}
for every , it holds that  if and only if .
\end{enumerate}
\end{definition}

Observe that the definition of valid encoding is very general and, with the exception
of success sensitiveness, can apply to sequential languages such as -calculus
as well as process calculi.
(On the understanding that a name substitution for sequential
calculi is a mapping from names/variables to names/variables {\em not} terms.)
However, the relations presented in this work bring together a variety of
prior results and account for them in a stronger and more uniform manner.
To this end, the following definitions support the results.
The first two define homomorphism in the sequential and concurrent settings.

\begin{definition}[Homomorphism (Sequential)]
\label{def:homo-seq}
A {\em (sequential) homomorphism} is
a translation  from one language to another that satisfies:
compositionality, name invariance, operational correspondence, and divergence reflection;
and that preserves application, i.e.~where .
\end{definition}

\begin{definition}[Homomorphism (Concurrent)]
\label{def:homo-con}
A {\em (concurrent) homomorphism} is a valid encoding whose translation preserves parallel composition,
i.e.~.
\end{definition}

The next is for encoding sequential languages into concurrent languages and
exploits
that  indicates
an encoding from source terms to target terms that is parametrised by a name .

\begin{definition}[Parallel Encoding]
\label{def:pe}
An encoding  of  into 
is a {\em parallel encoding} if it satisfies the first four properties of a valid encoding
(compositionality, name invariance, operational correspondence, 
and divergence reflection)
and the following additional property.
\begin{enumerate}
\setcounter{enumi}{4}
\item {\em Parallelisation:} 
      The translation of the application  is of the form
      
      where  is a process parametrised by  and  and .
\end{enumerate}
\end{definition}


Parallelisation is a restriction on the more general compositionality criteria.
Here this ensures that in addition to compositionality, the translation must allow
for independent reduction of the components of an application.
As the shift from sequential to concurrent computation can exploit this to support parallel
reductions, the definition of parallel encoding 
encourages more flexibility in reduction since components can be reduced independently.

The removal of the success sensitiveness property is for simplicity when using prior
results.
It is not difficult to include success sensitiveness, this involves adding the success
primitive to the sequential languages and defining , e.g.~ means that
.
Additionally, this requires adding a test process  to the definition of parallel encoding
with success sensitiveness defined by:
``for every , it holds that  if and only if .
However, since adding the success state  to -calculus and combinatory
logics\footnote{The results for intensional combinatory logics require that success
behaves as a {\em constructor} as discussed for various combinatory logics in \cite{JayGW11}.}
would require redoing many existing results, it is easier to avoid the added
complexity since no clarity or gain in significance is made by adding it.

Encodings from concurrent languages into sequential ones have not been defined specifically
here since they prove impossible. The proof of these results relies merely on the
requirement of operational correspondence, and so shall be
done on a case-by-case basis.

\section{Sequential Extensional Computation}
\label{sec:sec}

Both -calculus and traditional combinatory logic base reduction rules upon the application of a function to one or more arguments.
Functions in both models are extensional in nature, that is a function does not have direct access to the internal structure of its arguments.
Thus, functions that are extensionally equal are indistinguishable within either model even though they may have different normal forms.

The relationship between the -calculus and traditional combinatory logic is closer than sharing application-based reduction and extensionality.
There is a homomorphism from call-by-value -calculus into any combinatory logic that supports the combinators  and  \cite{Curry58combinatorylogic,Barendregt85}.
There is also a homomorphism from traditional combinatory logic to a -calculus with more generous operational semantics \cite{Curry58combinatorylogic,Barendregt85}.

\subsection{-calculus}
\label{ssec:lambda}

The {\em term} syntax of the -calculus is given by

The {\em free variables} of a term are defined in the usual manner.
A {\em substitution}  is defined as a partial function from variables to terms.
The {\em domain} of  is denoted ;
the free variables of , written , is given by the union of the sets  where .
The {\em variables} of , written , are .
A substitution  {\em avoids} a variable  (or collection of variables ) if  (respectively ).
Note that all substitutions considered in this paper have finite domain.
The application of a substitution  to a term  is defined as usual, as is -conversion .

There are several variations of the -calculus with different operational semantics.
For construction of the computation square by exploiting the results of Milner et al.~\cite{90426}, it is necessary to choose an operation semantics, such as {\em call-by-value} -calculus or {\em lazy} -calculus.
The choice here is to use call-by-value -calculus, although the results can be reproduced for lazy -calculus as well.
In addition a more generous operation semantics for -calculus will be presented for later discussion and relations.

To formalise the reduction of call-by-value -calculus requires a notion of {\em value} . These are defined in the usual way, by

consisting of variables and -abstractions.

Computation in the -calculus is through the -reduction rule

When an abstraction  is applied to a value  then substitute  for  in the body .
The {\em reduction relation} (also denoted ) is the smallest that satisfies the following rules

The transitive closure of the reduction relation is denoted  though the star may be elided if it is obvious from the context.

The more generous operational semantics for the -calculus allows any term to be the argument when defining -reduction. Thus the more generous -reduction rule is

where  is any term of the -calculus.
The reduction relation  and the transitive closure thereof  are obvious adaptations from those for the -calculus.
Observe that any reduction  of -calculus is also a reduction  of -calculus.

\subsection{Traditional Combinatory Logic}
\label{ssec:sk}

A {\em combinatory calculus} is given by a finite collection  of {\em operators} (meta-variable ) that are
used to define the -{\em combinators} (meta-variables
) built from these by application

The {\em -combinatory calculus} or {\em -calculus}
is given by the combinators plus their reduction rules.


Traditional combinatory logic can be represented by two combinators  and  \cite{Curry58combinatorylogic} so the -calculus has {\em reduction rules}

The combinator  duplicates  as the argument to both  and
.  The combinator  eliminates  and returns .
The {\em reduction relation}  is 
as for -calculus.


Although this is sufficient to provide a direct account of functions in the style
of -calculus, an alternative is to consider the representation
of arbitrary computable functions that act upon combinators.

A {\em symbolic function} is defined to be an -ary partial
function  of some combinatory logic, i.e.~a function of
the combinators that preserves their equality, as determined by the
reduction rules.  That is, if  for  then

if both sides are defined.  A symbolic function is {\em restricted} to
a set of combinators, e.g.\ the normal forms, if its domain is within
the given set.

A combinator  in a calculus {\em represents}  if

whenever the right-hand side is defined.  For example, the symbolic
functions
 and

are represented by  and , respectively, 
in -calculus.
  Consider the
symbolic function
. 
In -calculus where  has the rule

then  is represented by . In both -calculus and
-calculus,  is represented by any combinator of the
form  since

For convenience define the {\em identity combinator}  in -calculus to be .


\subsection{Relations}
\label{sec:lambda=SK}



One of the goals of combinatory logic is to give an equational account
of variable binding and substitution, particularly as it appears in
-calculus.
In order to represent -abstraction, it is necessary to have some
variables to work with. Given  as before, define the
{\em -terms} by 

where  is as in -calculus.
Free variables, substitutions, and symbolic computations are defined
just as for -calculus.

Given a variable  and term  define a symbolic function  on terms by 

Note that if  has no free variables other than  then 
is also a symbolic computation of the combinatory logic.  If every
such function  on -combinators is representable then the
-combinatory logic is {\em combinatorially complete} in the
sense of Curry \cite[p.~5]{Curry58combinatorylogic}.


Given  and  then  above can be
represented by a term  given by



The following lemmas are central results of combinatory logic
\cite{Curry58combinatorylogic} and Theorem~2.3 of \cite{JayGW11}. This is sufficient
to show there is a homomorphism from -calculus to any combinatory calculus 
that represents  and .

\begin{lemma}
\label{lem:beta*}
For all terms  and  and variables  there is a reduction
.
\end{lemma}

\begin{lemma}
\label{lem:lambda2SK}
  Any combinatory calculus that is able to represent  and 
  is combinatorially complete.
\end{lemma}


\begin{theorem}
\label{thm:lambda2SK}
There is a homomorphism (Definition~\ref{def:homo-seq}) from -calculus into -calculus.
\end{theorem}
\begin{proof}
Compositionality, name invariance, and preservation of application hold by construction.
Operational correspondence and divergence reflection can by proved via Lemma~\ref{lem:lambda2SK}.
\end{proof}


Below is a standard translation from -calculus into -calculus that
preserves reduction and supports the following lemma \cite{Curry58combinatorylogic,Barendregt85}.




\begin{lemma}[Theorem~2.3.3 of \cite{GivenWilsonPHD}]
\label{lem:SKinLambda}
Translation from -calculus to -calculus preserves the reduction relation.
\end{lemma}

\begin{theorem}
\label{thm:SK2lambda}
There is a homomorphism (Definition~\ref{def:homo-seq}) from -calculus into -calculus.
\end{theorem}
\begin{proof}Compositionality and preservation of application hold by construction. Name invariance is trivial.
Operational correspondence and divergence reflection are proved via Lemma~\ref{lem:SKinLambda}.
\end{proof}







Although the top left corner of the computation square is populated by -calculus, the arrows out allow for either -calculus or -calculus to be used.
Indeed, the homomorphisms in both directions between -calculus and -calculus allow these two calculi to be considered equivalent.


\section{Sequential Intensional Computation}
\label{sec:sic}

Intuitively intensional functions are more expressive than merely extensional functions,
however populating the top right corner of the computation square requires more formality than intuition.
The cleanest account of this is by considering combinatory logic.

Even in -calculus there are Turing-computable functions defined upon the combinators that cannot be represented within -calculus.
For example, consider the function that reduces any combinator of the form  to .
Such a function cannot be represented in -calculus, or -calculus, as all combinators of the form  represent the identity function. However, such a function is Turing-computable and definable upon the combinators.
This is an example of a more general problem of {\em factorising} combinators that are both applications and stable under reduction.

Exploiting this factorisation is -calculus \cite{JayGW11} that is able to support intensional functions on combinators including a structural equality of normal forms.
Thus -calculus sits at the top right hand corner of the computation square.
The arrow across the top of the square is formalised by showing a homomorphism from -calculus into -calculus. The lack of a converse has been proven by showing that the intensionality of -calculus cannot be represented within -calculus, or -calculus \cite{JayGW11}.

\subsection{Symbolic Functions}
\label{sec:SF-sym}

Symbolic functions need not be merely extensional, indeed it is possible to define symbolic functions that consider the structure of their arguments.
Observe that each operator  has an {\em arity} given by the minimum number of arguments it requires to
instantiate a rule. Thus,  has arity  while  has arity . A
{\em partially applied operator} is a combinator of the form
 where  is less than the arity of .  An operator
with a positive arity is an {\em atom} (meta-variable ).  A
partially applied operator that is an application is a {\em compound}.
Hence, the partially applied operators of -calculus are the atoms
 and , and the compounds ,  and  for any  and
.

Now define a {\em factorisation function}  on
combinators by



\begin{lemma}[Theorem~3.2 of \cite{JayGW11}]
\label{lem:noFinSK:1}
Factorisation of -combinators is a symbolic computation that is
not representable within -calculus.
\end{lemma}
\begin{proof}
  Suppose that there is an -combinator  that represents
  .  Then, for any combinator  it follows that
. Translating this to -calculus as in Lemma~\ref{lem:beta*} yields
 and also
. Hence, by confluence of reduction in -calculus, all  share a reduct with  but this is  impossible since
 and  are distinct normal forms.
Hence  cannot be represented by an  -combinator. 
\end{proof}

\subsection{-calculus}
\label{ssec:computation:sec:factor}

When considering intensionality in a combinatory logic it is tempting to specify
a factorisation combinator  as a representative for .
However,  is defined using partially applied operators,
which cannot be known until all reduction rules are given,
including those for .
This circularity of definition is broken by beginning with a syntactic
characterisation of the combinators that are to be factorable.
 
The -calculus \cite{JayGW11} has {\em factorable forms} given by

and {\em reduction rules} 


The expressive power of -calculus subsumes that of -calculus
since  is here defined to be  and  is defined to be 
as before.

\begin{lemma}
\label{lem:SK2SF}
There is a homomorphism (Definition~\ref{def:homo-seq}) from -calculus into -calculus.
\end{lemma}

\begin{theorem}
\label{thm:lambdav2SF}
There is a homomorphism (Definition~\ref{def:homo-seq}) from -calculus to -calculus.
\end{theorem}
\begin{proof}
By Theorem~\ref{thm:lambda2SK} and Lemma~\ref{lem:SK2SF}.
\end{proof}


\begin{lemma}
\label{lem:noSF2lambda}
There is no reduction preserving translation  from -calculus to -calculus.
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:noFinSK:1}.
\end{proof}

\begin{theorem}
\label{thm:noSF2lambda}
There is no homomorphism (Definition~\ref{def:homo-seq}) from -calculus to -calculus.
\end{theorem}
\begin{proof}
Lemma~\ref{lem:noSF2lambda} shows that operational correspondence is impossible.
\end{proof}

This completes the top edge of the computation square by showing that
-calculus subsumes -calculus and that the subsumption is
irreversible.
Indeed, these results hold for -calculus \cite[Theorem~5.2.6]{GivenWilsonPHD} and
-calculus (by Lemma~\ref{lem:noFinSK:1}) as well.




\section{Concurrent Extensional Computation}
\label{sec:cec}

The bottom left corner of the computation square considers extensional concurrent computation,
here defined to be extensional process calculi that subsume -calculus.
The -calculus \cite{milner.parrow.ea:calculus-mobile} holds a pivotal r\^ole amongst process
calculi due to popularity, being the first to represent topological changes, and subsuming
-calculus \cite{90426}.
Note that although there are many -calculi, the one here is that used by Milner so as to 
more easily exploit previous results \cite{90426} (and here augmented with a success process ).


The processes for the -calculus are given as follows and exploit a class of names (denoted  similar to variables in the -calculus):

The names of the -calculus are used for channels of communication and for information being communicated. 
The {\em free names} of a process  are as usual. 
{\em Substitutions} in the -calculus are partial functions that map names to names,
with domain, range, free names, names, and avoidance, all straightforward adaptations from
substitutions of the -calculus.
The application of a substitution to a process is defined in the usual manner.
Issues where substitutions must avoid restricted or input names are handled by -conversion  that is the congruence relation defined in the usual manner.
The general {\em structural equivalence relation}  is defined by:


The -calculus has one {\em reduction rule} given by

The reduction rule is then closed under parallel composition, restriction and structural equivalence to yield the reduction relation  as follows:


Now that the -calculus and process calculus concepts are recalled, it remains to
demonstrate that Milner's encoding \cite{90426} can meet the criteria for a parallel encoding.
As the -reduction rule depends upon the argument being a value the translation into -calculus must be able to recognise values. Thus, Milner defines the following

Also the following translation of -terms


\begin{lemma}
\label{lem:l2pi-red}
The translation  preserves and reflects reduction.
That is:
\begin{enumerate}
\item If  then ;
\item if  then there exists  and  such that
       and  and either  or .
\end{enumerate}
\end{lemma}
\begin{proof}
The first part can be proved by exploiting Milner's Theorem~7.7 \cite{90426}.
The second is by considering the reduction  which must arise
from the encoding of an application. It is then straightforward to show that either:
the reductions  correspond only to translated applications and thus
; or
the reductions are due to a -abstraction and thus
 and .
\end{proof}

\begin{theorem}
\label{thm:lambda2pi}
The translation  is a parallel encoding (Definition~\ref{def:pe}) from -calculus to -calculus.
\end{theorem}
\begin{proof}
Compositionality, parallelisation, and name invariance hold by construction.
Operational correspondence follows from Lemma~\ref{lem:l2pi-red}.
Divergence reflection can be proved by observing that the only reductions introduced
in the translation that do not correspond to reductions in the source language are
from translated applications, and these are bounded by the size of the source term.
\end{proof}


There is some difficulty in attempting to define the analogue of a parallel encoding or
homomorphism from a language with a parallel composition operator into a language without.
However, this difficulty can be avoided by observing that any valid encoding, parallel
encoding, or homomorphism must preserve reduction.
Reduction preservation can then be exploited to show when an encoding is impossible.
Here this is by exploiting Theorem~14.4.12 of Barendregt \cite{Barendregt85}, showing that
-calculus is unable to render concurrency or support concurrent computations.


\begin{theorem}
\label{thm:no-pi2lambda}
There is no reduction preserving encoding of -calculus into -calculus.
\end{theorem}
\begin{proof}
Define the parallel-or function and show that it can be represented in -calculus
but not -calculus.
The parallel-or function is a function  that satisfies the following three rules
 and 
 and

where  represents non-termination and {\texttt T} represents true.
Such a function is trivial to encode in -calculus by
.
Consider  in parallel with two processes  and  that output their result on 
and , respectively.
If either  or  outputs {\texttt T} then  will also output {\texttt T} along .
Clearly -calculus can represent the parallel-or function, and since Barendregt's
Theorem~14.4.12 shows that -calculus cannot, there cannot be any reduction preserving
encoding of -calculus into -calculus.
\end{proof}



\section{Concurrent Intensional Computation}
\label{sec:cic}

Intensionality in sequential computation yields greater expressive power so it is natural to consider intensional concurrent computation.
Intensionality in CPC is supported by a generalisation of pattern-matching to symmetric {\em pattern-unification} that provides the basis for defining interaction.



\subsection{Concurrent Pattern Calculus}
\label{ssec:cpc}


The {\em patterns} (meta-variables )
are built using a class of {\em names} familiar from -calculus and
have the following forms

Binding names  denote an input sought by the pattern.
Variable names   may be output or tested for equality.
Protected names  can only be tested for equality.
A compound combines two patterns  and , its {\em components}, into a pattern  and is left associative.
The {\em atoms} are patterns that are not compounds and the atoms  and  are defined to {\em know} .
The binding names of a pattern must be pairwise distinct.

A {\em communicable} pattern contains no binding or protected names.
Given a pattern , the
binding names ,
variable names ,
and protected names ,
are as expected, with the free names  being the union of variable and protected names.


A {\em substitution}  (also denoted
) is a partial function
from names to communicable patterns.
Otherwise substitutions and their
properties are familiar from earlier sections and are applied to patterns
in the obvious manner.
(Observe that protection can be extended to a communicable pattern by
 in the application of a
substitution to a protected name.)

The {\em symmetric matching} or {\em unification}  of
two patterns  and  attempts to unify  and  by generating
substitutions upon their binding names. When defined, the result is
some pair of substitutions whose domains are the binding names of 
and of , respectively.
The rules to generate the substitutions are:

Two atoms unify if they know the same name. A binding name unifies with any communicable pattern to
produce a binding for its underlying name.  Two compounds unify if
their corresponding components do; the resulting substitutions are
given by taking unions of those produced by unifying the components.
Otherwise the patterns cannot be unified and the unification is undefined.


The processes of CPC are the same as -calculus except the
input and output are replaced by the {\em case}  with pattern  and body .
A case with the null process as the body  may also be written  when no
ambiguity may occur.

The free names of processes, denoted , are defined as
usual for all the traditional primitives and

for the case. As expected the binding names of the pattern bind their free occurrences in the body.
The application  of a substitution  to a process  is defined in the usual
manner to avoid name capture. For cases this ensures that substitution avoids the binding names in the pattern:
 if  avoids .
Renaming via -conversion is defined in the usual manner
\cite{GivenWilsonGorlaJay10,GivenWilsonPHD,givenwilson:hal-00987578}.
The general {\em structural equivalence relation}  is defined
just as in -calculus.



\label{sec:reduction-new}
CPC has one {\em interaction axiom} given by

It states that if the unification of two patterns  and  is
defined and generates , then apply the
substitutions  and  to the bodies  and ,
respectively.  If the matching of  and  is undefined then no
interaction occurs.
The interaction rule is then closed under
parallel composition, restriction and structural equivalence in the usual manner.
The reflexive and transitive closure of  is denoted .
Finally, the reference behavioural equivalence relation  for CPC is already
well detailed \cite{GivenWilsonPHD,GivenWilsonGorla13,givenwilson:hal-00987578}.


\subsection{Completing the Square}
\label{ssec:completing}

Support for both intensionality and concurrency places CPC at the bottom right corner of the computation square.
This section shows how -calculus and -calculus can both be subsumed by CPC, and thus completes the computation square.


Down the right side of the square there is a parallel encoding from -calculus into CPC that also maps the combinators  and  to reserved names  and , respectively.
The impossibility of finding a parallel encoding of CPC into -calculus is proved in the same manner as the relation between -calculus and -calculus.
Interestingly, in contrast with the parallel encoding of -calculus into -calculus,
the parallel encoding of -calculus into CPC does {\em not} fix a reduction strategy for -calculus.
This is achieved by exploiting the intensionality of CPC to directly encode the reduction rules for -calculus into an -reducing process, or -machine.
In turn, this process can then operate on translated combinators and so support reduction and rewriting.

The square is completed by showing a homomorphism from -calculus into CPC, and by showing that there cannot be any homomorphism (or indeed a more general valid encoding) from CPC into -calculus.


\subsubsection*{-calculus.}
\label{sssec:SF2CPC}

The -calculus combinators  can be easily encoded into patterns by defining the {\em construction} , exploiting reserved names  and , as follows

Observe that the first two rules map the operators to the same names. The third rule maps application to a compound of the components  and .

By representing -calculus combinators in the pattern of a CPC case,
the reduction is driven by cases that recognise a reducible structure and perform the appropriate operations.
The reduction rules can be captured by matching on the structure of the left hand side of the rule and reducing to the structure on the right. So (considering each possible instance for the  reduction rules) they can be encoded by cases as follows
\small

\normalsize
These processes capture the reduction rules, matching the pattern for the left hand side and transforming it to the structure on the right hand side.
Of course these process do not capture the possibility of reduction of a sub-combinator, so further rules are required.
Rather than detail them all, consider the example of a reduction  that can be captured by

This process unifies with a combinator  where  is reducible (observable from the structure), here binding the components of  to four names , ,  and . These four names are then shared as a pattern, which can then be unified with another process that can perform the reduction. The result will then (eventually) unify with  and be substituted back into  to complete the reduction.

\begin{figure}[t]

\caption{The -reducing process .}
\label{fig:SF-red-paper}
\end{figure}

To exploit these processes in constructing a parallel encoding requires the addition of a name,
used like a channel, to control application. Thus, prefix each pattern that matches the structure
of an -combinator with a binding name  and add this to the result, e.g.
.
Now the processes that handle each possible reduction rule can be placed under a replication
and in parallel composition with each other. This yields the -reducing process 
as shown in Figure~\ref{fig:SF-red-paper} where the last four replications capture reduction of
sub-combinators.

The translation  from -combinators into CPC processes is here parametrised by a name  and combines application with a process .
This is similar to Milner's encoding from -calculus into -calculus
and
 allows the parallel encoding to exploit compositional encoding of sub-terms as processes and thus parallel reduction, while preventing confusion of application.


The translation  of -combinators into CPC, exploiting the -reducing process  and reserved names  and , is defined as follows:



The following lemmas are at the core of the operational correspondence and divergence
reflection components of the proof of valid encoding, similar to Milner's Theorem~7.7 \cite{90426}.
Further, it provides a general sense of how to capture the reduction of combinatory logics or
similar rewrite systems.
(Note that the results exploit that  to
remove redundant copies of  \cite[Theorem~8.7.2]{GivenWilsonPHD}.)

\begin{lemma}
\label{lem:SF2CPC-construct}
Given an -combinator  the translation  has a reduction sequence to a process of the form .
\end{lemma}
\begin{proof}
The proof is by induction on the structure of .
\end{proof}


\begin{lemma}[Theorem~7.1.2 of \cite{GivenWilsonPHD}]
\label{lem:SF2CPC-red}
Given an -combinator  the translation  preserves reduction.
\end{lemma}
\begin{proof}
The proof is routine 
by considering each reduction rule and Lemma~\ref{lem:SF2CPC-construct}.
\end{proof}

\begin{lemma}
\label{lem:sf2cpc-red}
The translation  preserves and reflects reduction. That is:
\begin{enumerate}
\item If  then ;
\item if  then there exists  and  such that
       and  and either  or .
\end{enumerate}
\end{lemma}
\begin{proof}
The first part can be proved by exploiting Lemmas~\ref{lem:SF2CPC-construct} and \ref{lem:SF2CPC-red}.
The second is by considering the reduction  which must arise
from the encoding of an application.
It is then straightforward to show that either:
the reductions  correspond only to rebuilding the structure as in
Lemma~\ref{lem:SF2CPC-construct}; or
the reductions correspond to a reduction  and .
\end{proof}


\begin{theorem}
\label{thm:SF2CPC}
The translation  is a parallel encoding from -calculus to CPC.
\end{theorem}
\begin{proof}
Compositionality, parallelisation, and name invariance hold by construction.
Operational correspondence follows from Lemma~\ref{lem:SF2CPC-red}.
Divergence reflection can be proved by observing that the only reductions introduced
in the translation that do not correspond to reductions in the source language are
from translated applications, and these are bounded by the size of the source term.
\end{proof}


The lack of an encoding of CPC (or even -calculus) into -calculus can be
proved in the same manner as Theorem~\ref{thm:no-pi2lambda} for showing no encoding
of -calculus into -calculus.

\begin{theorem}
\label{thm:noCPC2SF}
There is no reduction preserving encoding from CPC into -calculus.
\end{theorem}


It may appear that the factorisation operator  adds some expressiveness that could
be used to capture the parallel-or function .
Perhaps use  to switch on the result of the first function so that (assuming true
is some operator {\tt T} then)  is represented by  that reduces to
 when  and to  when  that somehow is factorable but
not terminating.
However, this kind of attempt is equivalent to exploiting factorisation to detect termination 
and turns out to be paradoxical as demonstrated in the proof of Theorem~5.1 of \cite{JayGW11}.




This completes the arrow down the right side of the computation square. The rest of this section discusses some properties of translations and the diagonal from the top left to the bottom right corner of the square.

\medskip

Observe that the parallel encoding from -calculus into CPC does not require the choice of a reduction strategy, unlike Milner's encodings from -calculus into -calculus.
The structure of patterns and peculiarities of pattern-unification allow the reduction relation to be directly rendered by CPC.
In a sense this is similar to the approach in \cite{givenwilson:hal-00987594} of encoding the -combinators as the tape
of a Turing Machine, the pattern ,
and providing another process that reads the tape and performs operations upon it, the -reducing process
.
This approach can also be adapted in a straightforward manner to support a parallel encoding of
-calculus into CPC, that like the encoding of -calculus does not fix a reduction strategy.

\begin{theorem}
\label{thm:SK2CPC}
There is a translation  that is a parallel encoding from -calculus into CPC.
\end{theorem}


The translation from -calculus to CPC presented here is designed to map application to 
parallel composition (with some restriction and process ) so as to meet the
compositionality
and parallelisation
criteria for a parallel encoding.
However, the construction  can be used to provide a cleaner translation if 
these are not required
(while still supporting the other criteria).
Consider an alternative translation  parametrised by a name  as usual and defined by
.


\subsubsection*{-calculus.}
\label{subsec:pi}


Across the bottom of the computation square there is a homomorphism from -calculus into CPC.
The converse separation result can be proved multiple ways \cite{GivenWilsonGorlaJay10,GivenWilsonPHD,givenwilson:hal-00987578}.


The translation  from -calculus into CPC is homomorphic on all process forms except for the input and output which are translated as follows:

Here  is a fresh name (due to the renaming policy to avoid all other
names in the translation) that prevents the introduction of new reductions due to CPC's unification.

\begin{lemma}[Corollary~7.2.3 of \cite{GivenWilsonPHD}]
\label{lem:pi2cpc-valid}
The translation  from -calculus into CPC is a valid encoding.
\end{lemma}

\begin{theorem}
\label{thm:pi2cpc-hom}
There is a homomorphism (Definition~\ref{def:homo-con}) from -calculus into CPC.
\end{theorem}

Thus the translation provided above is a homomorphism from -calculus into CPC.
Now consider the converse separation result.

\begin{lemma}[Theorem~7.2.5 of \cite{GivenWilsonPHD}]
\label{lem:nocpc2pi-1}
There is no valid encoding of CPC into -calculus.
\end{lemma}
\begin{proof}[Sketch]
Define the {\em self-reducing} CPC process .
Observe that  and .
However, for every -calculus process  such that  it holds that .
This is sufficient to show contradiction of any possible valid encoding.
\end{proof}

\begin{theorem}
\label{thm:noCPC2pi}
There is no homomorphism (Definition~\ref{def:homo-con}) from CPC into -calculus.
\end{theorem}




\section{Conclusions and Future Work}
\label{sec:conclusions}


This work illustrates that there are increases in expressive power by shifting along two
dimensions from: extensional to intensional, and sequential to concurrent. This is
seen in
the computation square relating -calculus, -calculus,
-calculus, and CPC 
\vspace*{-0.4cm}
\begin{center}
\begin{picture}(250,65)(0,0)
\put(5,43){\mbox{-calculus}}
\put(125,43){\mbox{\ \ \ \ \ \ \ \ \ \ \ \ \ -calculus}}
\put(5,5){\mbox{~-calculus}}
\put(123,5){\mbox{concurrent pattern calculus}}
\put(68,45){\vector(1,0){80}}
\put(68,8){\vector(1,0){45}}
\put(34,35){\line(0,-1){5}}
\put(34,26){\vector(0,-1){8}}
\put(183,35){\line(0,-1){5}}
\put(183,26){\vector(0,-1){8}}
\end{picture}
\end{center}
\vspace*{-0.2cm}
where the left side is extensional,
the right side intensional,
the top side sequential,
and the bottom side concurrent.
The horizontal arrows are homomorphisms that map application/parallel composition to itself. The vertical arrows are parallel encodings that map application to parallel composition
(with some extra machinery). Further, there are no reverse arrows as each arrow signifies an increase in expressive power.

Such a square identifies relations that are more general than simply the choice of calculi here.
The top left corner could be populated by -calculus or -calculus with minimal changes to the proofs. Alternatively, choosing -calculus or -calculus may also hold, although a parallel encoding into -calculus requires some work.
The top right corner could be populated by any of the structure complete combinatory logics 
\cite{JayGW11,GivenWilsonPHD}. It may also be possible to place a pattern calculus \cite{JK09,pcb}, at the top right.
The bottom left corner is also open to many other calculi: monadic/polyadic synchronous/asynchronous -calculus could replace -calculus with no significant changes to the results \cite{GivenWilsonPHD,givenwilson:hal-00987578}. 
Similarly there are, and will be, other process calculi that can take the place of CPC at the bottom right.
For Spi calculus \cite{gordon1997ccp} an encoding of -calculus is delicate due to correctly handling reduction and not introducing infinite reductions or blocking on Spi calculus primitives and reductions. For Psi calculi \cite{BJPV11} the encoding can be achieved very similarly to CPC, although the implicit computation component of Psi calculi could simply allow for -calculus with the rest being moot.
Although multiple process calculi may populate the bottom right hand corner,
the elegance of CPC's intensionality is illustrated by the construction  for combinatory logics and \cite{givenwilson:hal-00987594}. 


\withrw{
\vspace*{-0.3cm}
\subsubsection*{Related Work}

The choice of relations here is influenced by existing approaches.
Homomorphisms in the sequential setting are typical \cite{Curry58combinatorylogic,Barendregt85,Felleisen199135}.
Valid encodings are popular \cite{G:IC08,G:DC10,G:CONCUR08,LPSS10,LVF10,gla12}
albeit not the only approach as other ways to relate process calculi are also used
that vary on the choice to map parallel composition to parallel composition (i.e.~homomorphism here)
\cite{journals/corr/cs-PL-9809008,journals/iandc/BusiGZ00,DeNicola:2006:EPK:1148743.1148750,DBLP:journals/corr/abs-1011-6436,gla12}.
Since the choice here is to build on prior results, valid encodings are the obvious
basis 
but no doubt this could be formalised
under different criteria.
Finally, the definition of parallel encodings here is to exploit the existing
encodings in the literature. 
However, other approaches are possible
\cite{90426,parrow.victor:fusion-calculus} and
many more as encoding -calculus into process calculi is common
\cite{96717,milner.parrow.ea:calculus-mobile,1998:MobileAmbients,citeulike:500640}.

The separation results here build upon results already in the literature.
For showing the inability to encoding concurrent languages into sequential, the
work of Abramsky \cite{Abramsky90thelazy} and Plotkin \cite{Plotkin97fullabstraction} can also be considered.
The impossibility of encoding CPC into -calculus can be proved by using
matching degree or symmetry \cite[proofs for Theorem~7.2.5]{GivenWilsonPHD}.

}


\vspace*{-0.3cm}
\subsubsection*{Future Work}
Future work may proceed along several directions.
The techniques used to encode -calculus (here) and Turing Machines \cite{givenwilson:hal-00987594}
into CPC can be generalised for any combinatory logic,
indeed perhaps a general result can be proved for all similar rewrite systems.
Another path of exploration is to consider intensionality in concurrency with full results in a general manner,
this could include formalising the intensionality (or lack of) of Spi calculus, Psi calculi, and other popular process calculi.

\vspace*{-0.3cm}
\bibliographystyle{abbrv}
\bibliography{short}

\end{document}