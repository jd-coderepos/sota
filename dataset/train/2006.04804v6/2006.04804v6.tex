\def\year{2022}\relax
\documentclass[letterpaper]{article} \usepackage{aaai22}  \usepackage{times}  \usepackage{helvet}  \usepackage{courier}  \usepackage[hyphens]{url}  \usepackage{graphicx} \urlstyle{rm} \def\UrlFont{\rm}  \usepackage{natbib}  \usepackage{caption} \DeclareCaptionStyle{ruled}{labelfont=normalfont,labelsep=colon,strut=off} \frenchspacing  \setlength{\pdfpagewidth}{8.5in}  \setlength{\pdfpageheight}{11in}  \usepackage{algorithm}
\usepackage{algorithmic}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         

\usepackage{subfigure}
\usepackage{enumitem}
\usepackage{url}            \usepackage{braket} 
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage[toc,page]{appendix}
\usepackage{amsthm}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{multirow}
\usepackage{arydshln}
\usepackage{cleveref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newcommand{\x}{{\mathbf x}}
\newcommand{\uu}{{\mathbf u}}
\newcommand{\h}{{\mathbf h}}
\newcommand{\m}{{\mathbf m}}
\newcommand{\e}{{\mathbf e}}
\newcommand{\W}{{\mathbf W}}
\newcommand{\A}{{\mathbf A}}
\newcommand{\B}{{\mathbf B}}
\newcommand{\T}{{\mathbf T}}
\newcommand{\X}{{\mathbf X}}
\newcommand{\Y}{{\mathbf Y}}
\newcommand{\Q}{{\mathbf Q}}
\newcommand{\RR}{{\mathbf R}}
\newcommand{\Real}{{\mathbb R}}
\newcommand{\p}{{\mathbf p}}
\newcommand{\q}{{\mathbf q}}
\newcommand{\Was}{{\mathcal W}}
\newcommand{\GW}{\mathcal{GW}}

\makeatletter
\newcommand{\printfnsymbol}[1]{\textsuperscript{\@fnsymbol{#1}}}
\makeatother

\usepackage{newfloat}
\usepackage{listings}
\lstset{basicstyle={\footnotesize\ttfamily},numbers=left,numberstyle=\footnotesize,xleftmargin=2em,aboveskip=0pt,belowskip=0pt,showstringspaces=false,tabsize=2,breaklines=true}
\floatstyle{ruled}
\newfloat{listing}{tb}{lst}{}
\floatname{listing}{Listing}


\nocopyright
\pdfinfo{
/Title (Optimal Transport Graph Neural Networks)
/Author (Gary Becigneul, Octavian-Eugen Ganea, Regina Barzilay, Tommi Jaakkola)
/TemplateVersion (2022.1)
}



\setcounter{secnumdepth}{1} 







\title{Optimal Transport Graph Neural Networks}
\author{
    Benson Chen \textsuperscript{\rm 1}\thanks{Equal contribution. Correspondence to:
Benson Chen \textless bensonc@csail.mit.edu \textgreater and Octavian Ganea \textless oct@csail.mit.edu\textgreater.}, Gary B{\'e}cigneul \textsuperscript{\rm 1}\printfnsymbol{1}, Octavian-Eugen Ganea \textsuperscript{\rm 1}\printfnsymbol{1}, Regina Barzilay\textsuperscript{\rm 1}, Tommi Jaakkola\textsuperscript{\rm 1}
}
\affiliations{
\textsuperscript{\rm 1} CSAIL, Massachusetts Institute of Technology


}

\begin{document}

\maketitle

\begin{abstract}
Current graph neural network (GNN) architectures naively average or sum node embeddings into an aggregated graph representation---potentially losing structural or semantic information. We here introduce \textsc{OT-GNN}, a model that computes graph embeddings using parametric prototypes that highlight key facets of different graph aspects. Towards this goal, we  successfully combine optimal transport (OT) with parametric graph models. Graph representations are obtained from Wasserstein distances between the set of GNN node embeddings and ``prototype'' point clouds as free parameters. We theoretically prove that, unlike traditional sum aggregation, our function class on point clouds satisfies a fundamental universal approximation theorem. Empirically, we address an inherent collapse optimization issue by proposing a noise contrastive regularizer to steer the model towards truly exploiting the OT geometry. Finally, we outperform popular methods on several molecular property prediction tasks, while exhibiting smoother graph representations.
\end{abstract}


\section{Introduction} 
Recently, there has been considerable interest in developing learning algorithms for structured data such as graphs. For example, molecular property prediction has many applications in chemistry and drug discovery \citep{yang2019analyzing,vamathevan2019applications}. Historically, graphs were decomposed into features such as molecular fingerprints, or turned into non-parametric graph kernels \citep{vishwanathan2010graph,shervashidze2011weisfeiler}. More recently, learned  representations via graph neural networks (GNNs) have achieved state-of-the-art on graph prediction tasks \citep{duvenaud2015convolutional,NIPS2016_6081,kipf2016semi,yang2019analyzing}.

Despite these successes, GNNs are often underutilized in whole graph prediction tasks such as molecule property prediction. Specifically, GNN node embeddings are typically aggregated via simple operations such as a sum or average, turning the molecule into a single vector prior to classification or regression. As a result, some of the information naturally extracted by node embeddings may be lost.  

Departing from this simple aggregation step, \cite{togninalli2019wasserstein} proposed a kernel function over graphs by directly comparing non-parametric node embeddings as point clouds through optimal transport (Wasserstein distance). Their \textit{non-parametric} model yields better empirical performance over popular graph kernels, but this idea hasn't been extended to the more challenging parametric case where optimization difficulties have to be reconciled with the combinatorial aspects of OT solvers.

\begin{figure}
  \centering
  \includegraphics[width=0.50\textwidth]{images/introfig2.png}
  \caption{Our OT-GNN prototype model computes graph embeddings  from Wasserstein distances between (a) the set of GNN node embeddings and (b) prototype embedding sets. These distances are then used as the molecular representation (c) for supervised tasks, e.g. property prediction. We assume that a few prototypes, e.g. some functional groups, highlight key facets or structural features of graphs relevant to a particular downstream task at hand. We express graphs by relating them to these abstract prototypes represented as free point cloud parameters.}
  \label{fig:ot_protos}
\end{figure}

Motivated by these observations and drawing inspiration from prior work on prototype learning, we  introduce a new class of GNNs where the key representational step consists of comparing each input graph to a set of abstract prototypes (\cref{fig:ot_protos}). Our desire is to learn prototypical graphs and represent data by some form of distance (OT based) to these prototypical graphs; however, for the OT distance computation it suffices to directly learn the point cloud that represents each prototype, so learning a graph structure (which would be difficult) is not necessary. In short, these prototypes play the role of basis functions and are stored as point clouds as if they were encoded from real graphs.  Each input graph is first encoded into a set of node embeddings using any existing GNN architecture. The resulting embedding point cloud is then compared to the prototype embedding sets, where the distance between two point clouds is measured by their Wasserstein distance.  The prototypes as abstract basis functions can be understood as keys that highlight property values associated with different graph structural features. In contrast to previous kernel methods, the prototypes are learned together with the GNN parameters in an end-to-end manner. 

Our notion of prototypes is inspired from the vast prior work on prototype learning (see \cref{sec:rel}). In our case, prototypes are not required to be the mean of a cluster of data, but instead they are entities living in the data embedding space that capture helpful information for the task under consideration. The closest analogy are the centers of radial basis function networks \citep{chen1991orthogonal,poggio1990networks}, but we also inspire from learning vector quantization approaches \citep{kohonen1995learning} and prototypical networks \citep{snell2017prototypical}.

Our model improves upon traditional aggregation by explicitly tapping into the full set of node embeddings without collapsing them first to a single vector. We theoretically prove that, unlike  standard GNN aggregation, our model defines a class of set functions that is a universal approximator.

Introducing prototype points clouds as free parameters trained using combinatorial optimal transport solvers creates a challenging optimization problem. Indeed, as the models are trained end-to-end, the primary signal is initially available only in aggregate form. If trained as is, the prototypes often collapse to single points, reducing the Wasserstein distance between point clouds to Euclidean comparisons of their means. To counter this effect, we introduce a contrastive regularizer which effectively prevents the model from collapsing, and we demonstrate its merits empirically. 

\textbf{Our contributions.} First, we introduce an efficiently trainable class of graph neural networks enhanced with OT primitives for computing graph representations based on relations with abstract prototypes. Second, we train parametric graph models together with combinatorial OT distances, despite optimization difficulties. A key element is our noise contrastive regularizer that prevents the model from collapsing back to standard summation, thus fully exploiting the OT geometry. Third, we provide a theoretical justification of the increased representational power compared to the standard GNN aggregation method. Finally, our model shows consistent empirical improvements over previous state-of-the-art on molecular datasets, yielding also smoother graph embedding spaces.


\section{Preliminaries} \label{sec:prelim}
\subsection{Directed Message Passing Neural Networks (D-MPNN)} \label{sec:dmpnn}
We briefly remind here of the simplified D-MPNN \citep{dai2016discriminative} architecture which was  adapted for state-of-the-art molecular property prediction by \cite{yang2019analyzing}. This model takes as input a directed graph $G=(V,E)$, with node and edge features denoted by $\x_v$ and $\e_{vw}$ respectively, for $v$, $w$ in the vertex set $V$ and  $v\to w$ in the edge set $E$. The parameters of D-MPNN are the matrices $\{\W_i, \W_m, \W_o\}$. It keeps track of \textit{messages} $\m_{vw}^t$ and \textit{hidden states} $\h_{vw}^t$ for each step $t$, defined as follows. An initial hidden state is set to $\h_{vw}^0:= ReLU(\W_i\mathrm{cat}(\x_v,\e_{vw}))$ where ``$\mathrm{cat}$'' denotes concatenation. Then, the updates are:\begin{equation}
\begin{split}
\m_{vw}^{t+1}=\sum_{k\in N(v)\setminus\{w\}} \h_{kv}^t, \quad\quad \h_{vw}^{t+1}=ReLU(\h_{vw}^0+\W_m \m_{vw}^{t+1})
\end{split}
\end{equation}
where $N(v)=\{k\in V|(k,v)\in E\}$ denotes $v$'s incoming neighbors. After $T$ steps of message passing, node embeddings are obtained by summing edge embeddings:
\begin{equation}
\m_v = \sum_{w\in N(v)} \h^T_{vw}, \quad \h_v = ReLU(\W_o\mathrm{cat}(\x_v,\m_v)).
\end{equation}
A final graph embedding is then obtained as $\h=\sum_{v\in V}\h_v$, which is usually fed to a multilayer perceptron (MLP) for classification or regression. 
 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{images/OT_Distances_cropped.png}
    \caption{We illustrate, for a given 2D point cloud, the optimal transport plan obtained from minimizing the Wasserstein costs;  $c(\cdot,\cdot)$ denotes the Euclidean distance.
  A higher dotted-line thickness illustrates a greater mass transport.}
    \label{fig:ot_dist}
\end{figure}


\subsection{Optimal Transport Geometry} 

Optimal Transport \citep{peyre2019computational} is a mathematical framework that defines distances or similarities between objects such as probability distributions, either discrete or continuous, as the cost of an optimal transport plan from one to the other. 

\iffalse
\begin{figure}[ht]
\centering
\includegraphics[scale=0.18]{images/OT_Distances.png}
\caption{We illustrate, for the same 2D point cloud, the optimal transport plans obtained respectively from minimizing the Wasserstein and the Gromov-Wasserstein costs.  $c(\cdot,\cdot)$ denotes the Euclidean distance (top) or squared difference (bottom). $\A,\B$ are the Euclidean distance matrices obtained from point clouds $\X,\Y$. A higher dotted-line thickness illustrates a greater mass transport.}
\label{fig:ot_dist}
\end{figure}
\fi

\textbf{Wasserstein distance for point clouds. } Let a \textit{point cloud $\X=\{\x_i\}_{i=1}^n$ of size $n$} be a set of $n$ points $\x_i\in\mathbb{R}^d$. Given point clouds $\X,\Y$ of respective sizes $n,m$, a \textbf{\textit{transport plan}} (or \textbf{\textit{coupling}}) is a matrix $\T$ of size $n\times m$ with entries in $[0,1]$, satisfying the two following \textit{marginal constraints}: $\T \mathbf{1}_m=\frac{1}{n}\mathbf{1}_n$ and $\T^T \mathbf{1}_n=\frac{1}{m}\mathbf{1}_m$. Intuitively, the marginal constraints mean that $\T$ preserves the mass from $\X$ to $\Y$. We denote the set of such couplings as $\mathcal{C}_{\X\Y}$.

Given a cost function $c$ on $\mathbb{R}^d \times \mathbb{R}^d$, its associated \textbf{\textit{Wasserstein discrepancy}} is defined as
\begin{equation}
\Was(\X,\Y) = \min_{\T\in\mathcal{C}_{\X\Y}} \sum_{ij}T_{ij}c(\x_i,\mathbf{y}_j).
\end{equation} 



\section{Model \& Practice}\label{sec:method}
\subsection{Architecture Enhancement}\label{sec:arch}

\textbf{Reformulating standard architectures. } The final graph embedding $\h=\sum_{v\in V}\h_v$ obtained by aggregating node embeddings is usually fed to a  multilayer perceptron (MLP) performing a matrix-multiplication whose i-th component is $(\RR \h)_i = \langle \mathbf{r}_i,\h\rangle$, where $\mathbf{r}_i$ is the i-th row of matrix $\RR$. Replacing $\langle\cdot,\cdot\rangle$ by a distance/kernel $k(\cdot,\cdot)$ allows the processing of more general graph representations than just vectors in $\mathbb{R}^d$, such as point clouds or adjacency tensors. 

\textbf{From a single point to a point cloud. } We propose to replace the aggregated graph embedding $\h=\sum_{v\in V}\h_v$ by the point cloud (of unaggregated node embeddings) $\mathbf{H}=\{\h_v\}_{v\in V}$, and the inner-products $\langle \h,\mathbf{r}_i\rangle$ by the below written \textbf{\textit{Wasserstein discrepancy}}:
\begin{equation}
\Was(\mathbf{H}, \Q_i):=\min_{\T\in\mathcal{C}_{\mathbf{H} \Q_i}}\sum_{vj}T_{vj}c( \h_v, \q_i^j),
\label{eq:wkernel}
\end{equation}
where $\Q_i=\{\q_i^j\}_{j \in \{1,\ldots,N\}}, \forall i \in \{1,\ldots,M\}$ represent $M$ prototype point clouds each being represented as a set of $N$ embeddings as free trainable parameters, and the cost is chosen as $c=\Vert\cdot - \cdot\Vert_2^2$ or $c = - \langle \cdot,\cdot\rangle$. Note that both options yield identical optimal transport plans.

\textbf{Greater representational power. } We formulate mathematically that this kernel has a strictly greater representational power than the kernel corresponding to standard inner-product on top of a sum aggregation, to distinguish between different point clouds. 


\textbf{Final architecture. } Finally, the vector of all Wasserstein distances in \cref{eq:wkernel} becomes the input to a final MLP with a single scalar as output. This can then be used as the prediction for various downstream tasks, depicted in \cref{fig:ot_protos}.


\begin{figure*}[h]
  \subfigure[No regularization]{\includegraphics[scale=0.40]{images/nce_0_new.png}} \hspace{15mm}
  \subfigure[Using regularization ($0.1$)]{\includegraphics[scale=0.40]{images/nce_1_new.png}} \hspace{15mm}
  \subfigure{\includegraphics[scale=0.30]{images/nce_legend_new.png}}
  \caption{2D embeddings of prototypes and of a real molecule with and without contrastive regularization for same random seed runs on the ESOL dataset. Both prototypes and real molecule point clouds tend to cluster when no regularization is used (left). For instance, the real molecule point cloud (red triangle) is much more dispersed when regularization is applied (right) which is desirable in order to interact with as many embeddings of each prototype as possible.}
  \label{fig:nce_embeddings}
\end{figure*}

\vspace{-0.2cm}
\subsection{Contrastive Regularization}\label{sec:reg}

What would happen to $\Was(\mathbf{H},\Q_i)$ if all points $\q_i^j$ belonging to point cloud $\Q_i$ would collapse to the same point $\q_i$? All transport plans would yield the same cost, giving for $c=-\langle\cdot,\cdot\rangle$:
\begin{equation}\label{eq:collapsed}
    \Was(\mathbf{H},\Q_i) = -\sum_{vj}T_{vj}\langle \h_v ,\q_i^j \rangle = -\langle\h,\q_i /|V| \rangle.
\end{equation}
In this scenario, our proposition would simply over-parametrize the standard Euclidean model.\\


\noindent\textbf{A first obstacle and its cause.} Empirically, OT-enhanced GNNs with only the Wasserstein component sometimes perform similarly to the Euclidean baseline in both train and validation settings, in spite of its greater representational power. Further investigation revealed that the Wasserstein model would naturally displace the points in each of its prototype point clouds in such a way that the optimal transport plan $\T$ obtained by maximizing $\sum_{vj}T_{vj}\langle \h_v ,\q_i^j \rangle$ was not \textit{discriminative}, \textit{i.e.} many other transports would yield a similar Wasserstein cost. Indeed, as shown in \cref{eq:collapsed}, if each point cloud collapses to its mean, then the Wasserstein geometry collaspses to Euclidean geometry. In this scenario, any transport plan yields the same Wasserstein cost. However, partial or local collapses are also possible and would still result in non-discriminative transport plans, also being undesirable.

Intuitively, the existence of multiple optimal transport plans implies that the same prototype can be representative for distinct parts of the molecule. However, we desire that different prototypes disentangle different factors of variation such as different functional groups.


\textbf{Contrastive regularization. } To address this difficulty, we add a regularizer which encourages the model to displace its prototype point clouds such that the optimal transport plans would be discriminative against chosen \textit{contrastive transport plans}. Namely, consider a point cloud $\Y$ of node embeddings and let $\T^{i}$ be an optimal transport plan obtained in the computation of $\Was(\Y,\Q_i)$. For each $\T^{i}$, we then build a set $Neg(\T^i)\subset \mathcal{C}_{\Y\Q_i}$ of \textit{noisy/contrastive} transports. If we denote by $\Was_{\T}(\X,\Y):= \sum_{kl}T_{kl}c(\x_k,\mathbf{y}_l)$ the Wasserstein cost obtained for the particular transport $\T$, then our contrastive regularization consists in maximizing the term:
\begin{equation}\label{eq:nce}
   \sum_i \log\left(\dfrac{e^{ -\Was_{\T^i}(\Y,\Q_i) }}{e^{ -\Was_{\T^i}(\Y,\Q_i) }+\sum_{\T\in Neg(\T^i)} e^{ - \Was_\T(\Y,\Q_i)}}\right),
\end{equation}
which can be interpreted as the log-likelihood that the correct transport $\T_i$ be (as it should) a better minimizer of $\Was_\T(\Y,\Q_i)$ than its negative samples. This can be considered as an approximation of $\log(\mathrm{Pr}(\T_i\mid \Y,\Q_i))$, where the partition function is approximated by our selection of negative examples, as done e.g. by \cite{nickel2017poincare}. Its effect is shown in \cref{fig:nce_embeddings}.

\textbf{Remarks. } The selection of negative examples should reflect the trade-off: \textit{(i)} not be too large, for computational efficiency while \textit{(ii)} containing sufficiently meaningful and challenging contrastive samples. Details about our choice of contrastive samples are in the experiments section. Note that replacing the set $Neg(\T^i)$ with a singleton $\{\T\}$ for a contrastive random variable $\T$ lets us rewrite (\cref{eq:nce}) as\footnote{where $\sigma(\cdot)$ is the sigmoid function.} $\sum_i\log\sigma(\Was_\T-\Was_{\T^i})$, reminiscent of noise contrastive estimation \citep{gutmann2010noise}.


\subsection{Optimization \& Complexity}\label{sec:opt}
Backpropagating gradients through optimal transport (OT) has been the subject of recent research investigations: \cite{genevay2017learning} explain how to unroll and differentiate through the Sinkhorn procedure solving OT, which was extended by \cite{schmitz2018wasserstein} to Wasserstein barycenters. However, more recently,  \cite{xu2019gromovfactor} proposed to simply invoke the envelop theorem \citep{afriat1971theory} to support the idea of keeping the optimal transport plan fixed during the back-propagation of gradients through Wasserstein distances. \textit{For the sake of simplicity and training stability, we resort to the latter procedure: keeping $\T$ fixed during back-propagation.} We discuss complexity in \cref{apx:complexities}. 

\section{Theoretical Analysis} \label{sec:theory}

In this section we show that the standard architecture lacks a fundamental property of \textit{universal approximation} of functions defined on point clouds, and that our proposed architecture recovers this property. We will denote by $\mathcal{X}_d^n$ the set of point clouds $\X=\{\x_i\}_{i=1}^n$ of size $n$ in $\mathbb{R}^d$.

\subsection{Universality}\label{ssec:univ}

As seen in \cref{sec:arch}, we have replaced the sum aggregation $-$ followed by the Euclidean inner-product $-$ by Wasserstein discrepancies. How does this affect the function class and representations?

A common framework used to analyze the geometry inherited from similarities and discrepancies is that of kernel theory. A kernel $k$ on a set $\mathcal{X}$ is a symmetric function $k:\mathcal{X}\times\mathcal{X}\to\mathbb{R}$, which can either measure similarities or discrepancies. An important property of a given kernel on a space $\mathcal{X}$ is whether simple functions defined on top of this kernel can approximate any continuous function on the same space. This is called \textit{universality}: a crucial property to regress unknown target functions.

\noindent\textbf{Universal kernels.} A kernel $k$ defined on $\mathcal{X}_d^n$ is said to be \textbf{\textit{universal}} if the following holds: for any compact subset $\mathcal{X}\subset\mathcal{X}_d^n$, the set of functions in the form\footnote{For $m\in\mathbb{N}^*$, $\alpha_j\beta_j\in\mathbb{R}$ and $\theta_j\in\mathcal{X}_d^n$.} $\sum_{j=1}^m \alpha_j \sigma(k(\cdot,\theta_j) + \beta_j)$ is dense in the set $\mathcal{C}(\mathcal{X})$ of continuous functions from $\mathcal{X}$ to $\mathbb{R}$, w.r.t the sup norm $\Vert\cdot\Vert_{\infty,\mathcal{X}}$, $\sigma$ denoting the sigmoid.

Although the notion of universality does not indicate how easy it is in practice to learn the correct function, it at least guarantees the absence of a fundamental bottleneck of the model using this kernel.

In the following we compare the aggregating kernel $\mathfrak{agg}(\X,\Y):=\langle \sum_i \x_i  , \sum_j \mathbf{y}_j \rangle$ (used by popular GNN models) with the Wasserstein kernels defined as 
 \begin{equation}
     \Was_{\mathrm{L2}}(\X,\mathbf Y) := \min_{\T\in \mathcal{C}_{\X\mathbf Y}}\sum_{ij} T_{ij}\Vert \x_i-\mathbf y_j\Vert_2^2
\end{equation}

\begin{equation}
     \Was_{\mathrm{dot}}(\X,\mathbf Y) := \max_{\T\in\mathcal{C}_{\X\mathbf Y}}\sum_{ij} T_{ij}\langle \x_i,\mathbf y_j\rangle.
 \end{equation}


\begin{theorem} 
\label{thm:univ}
We have that: i) the Wasserstein kernel $\Was_{\mathrm{L2}}$ \textbf{is universal}, while ii) the aggregation kernel $\mathfrak{agg}$ \textbf{is not universal}. 
\end{theorem}
\textit{Proof:} See \cref{sec:proof-univ}. Universality of the $\Was_{\mathrm{L2}}$ kernel comes from the fact that its square-root defines a metric, and from the axiom of separation of distances: \textit{if $d(x,y)=0$ then $x=y$.}

\textbf{Implications. } Theorem \ref{thm:univ} states that our proposed OT-GNN model is strictly more powerful than GNN models with summation or averaging pooling. Nevertheless, this implies we can only distinguish graphs that have distinct multi-sets of node embeddings, e.g. all Weisfeiler-Lehman distinguishable graphs in the case of GNNs. In practice, the shape of the aforementioned functions having universal approximation capabilities gives an indication of how one should leverage the vector of Wasserstein distances to prototypes to perform graph classification -- e.g. using a MLP on top like we do.


\subsection{Definiteness}

For the sake of simplified mathematical analysis, similarity kernels are often required to be \textit{positive definite} (p.d.), which corresponds to discrepancy kernels being \textit{conditionally negative definite} (c.n.d.). Although such a property has the benefit of yielding the mathematical framework of Reproducing Kernel Hilbert Spaces, it essentially implies \textit{linearity}, \textit{i.e.} the possibility to embed the geometry defined by that kernel in a linear vector space. 

We now discuss that, interestingly, the Wasserstein kernel we used does not satisfy this property, and hence constitutes an interesting instance of a universal, non p.d. kernel. Let us remind these notions.

\noindent\textbf{Kernel definiteness.} A kernel $k$ is \textbf{\textit{positive definite}} \textit{\textbf{(p.d.)}} on $\mathcal{X}$ if for $n\in\mathbb{N}^*$, $x_1,...,x_n\in\mathcal{X}$ and $c_1,...,c_n\in\mathbb{R}$, we have $\sum_{ij}c_i c_j k(x_i,x_j)\geq 0$. It is \textbf{\textit{conditionally negative definite}} \textit{\textbf{(c.n.d.)}} on $\mathcal{X}$ if for $n\in\mathbb{N}^*$, $x_1,...,x_n\in\mathcal{X}$ and $c_1,...,c_n\in\mathbb{R}$ such that $\sum_i c_i=0$, we have $\sum_{ij}c_i c_j k(x_i,x_j)\leq 0$. 

These two notions relate to each other via the below result \cite{boughorbel2005conditionally}:

\begin{proposition}\label{prop:cnd} Let $k$ be a symmetric kernel on $\mathcal{X}$, let $x_0\in\mathcal{X}$ and define the kernel:
\begin{equation}
\tilde{k}(x,y):=-\frac{1}{2}[k(x,y)-k(x,x_0)-k(y,x_0)+k(x_0,x_0)].
\end{equation}
Then $\tilde{k}$ \textbf{is p.d. if and only if $k$ is c.n.d.} Example: $k=\Vert\cdot-\cdot\Vert_2^2$ and $x_0=\textbf{0}$ yield $\tilde{k}=\langle\cdot,\cdot\rangle$.
\end{proposition}


One can easily show that $\mathfrak{agg}$ also defines a p.d. kernel, and that $\mathfrak{agg}(\cdot,\cdot)\leq n^2 \Was(\cdot,\cdot)$. However, the Wasserstein kernel is not p.d., as stated in different variants before (e.g. \cite{vert2008optimal}) and as reminded by the below theorem. We here give a novel proof in \cref{sec:proof-pd}.



\begin{theorem}
\label{thm:pd}
We have that: i) The (similarity) Wasserstein kernel $\Was_{\mathrm{dot}}$ \textbf{is not positive definite}, and ii) The (discrepancy) Wasserstein kernel $\Was_{\mathrm{L2}}$ \textbf{is not conditionally negative definite}.
\end{theorem}

\section{Experiments} \label{sec:exp}

\begin{table*}
\begin{center}
  \begin{tabular}{c|p{3.2cm}|p{2.18cm}|p{2.08cm}|p{2.08cm}|p{2.08cm} }
 & & ESOL (RMSE)  & Lipo (RMSE)  & BACE (AUC)  & BBBP (AUC) \\
& Models \ & \# grphs $=1128$ & \# grphs$=4199$ & \# grphs$=1512$ & \# grphs$=2039$ \\  
 \hline \hline
\parbox[t]{2mm}{\multirow{3}{*}{\rotatebox[origin=c]{90}{Baselines \,}}} & Fingerprint+MLP \qquad & .922 $\pm$ .017& .885 $\pm$ .017 & .870 $\pm$ .007 & .911 $\pm$ .005 \\ 
& $\mathrm{GIN}$ \qquad & .665 $\pm$ .026 & .658 $\pm$ .019 & .861 $\pm$ .013 & .900 $\pm$ .014 \\ 
& $\mathrm{GAT}$ \qquad & .654 $\pm$ .028 & .808 $\pm$ .047 & .860 $\pm$ .011 & .888 $\pm$ .015 \\ 
& D-MPNN \qquad & .635 $\pm$ .027& .646 $\pm$ .041 & .865 $\pm$ .013 & .915 $\pm$ .010 \\ 
& D-MPNN+SAG Pool \qquad & .674 $\pm$ .034 & .720 $\pm$ .039 & .855 $\pm$ .015 & .901 $\pm$ .034 \\
& D-MPNN+TopK Pool \qquad & .673 $\pm$ .087 & .675 $\pm$ .080 & .860 $\pm$ .033 & .912 $\pm$ .032 \\
 \hline \hline
\parbox[t]{2mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{Ours}}} & $\mathrm{ProtoS\text{-}L2}$\qquad\ \ \ \ \ \ \  & .611 $\pm$ .034 & \textbf{.580 $\pm$ .016}& .865 $\pm$ .010 & .918 $\pm$ .009 \\ 
& $\mathrm{ProtoW\text{-}Dot}$ \textit{(no reg.)} & .608 $\pm$ .029 & .637 $\pm$ .018 & .867 $\pm$ .014 & .919 $\pm$ .009 \\
& $\mathrm{ProtoW\text{-}Dot}$\quad\ \ \ \ \ \,   & \textbf{.594 $\pm$ .031} & .629 $\pm$ .015 & .871 $\pm$ .014 & .919 $\pm$ .009 \\
 
& $\mathrm{ProtoW\text{-}L2}$ \textit{(no reg.)}\ \ & .616 $\pm$ .028 & .615 $\pm$ .025 & \underline{.870 $\pm$ .012} & \underline{.920 $\pm$ .010} \\
& $\mathrm{ProtoW\text{-}L2}$\qquad\quad \ \ \ \ \ & \underline{.605 $\pm$ .029} & \underline{.604 $\pm$ .014} & \textbf{.873 $\pm$ .015} & \textbf{.920 $\pm$ .010} \\
  \end{tabular}
 
\caption{Results on the property prediction datasets. \textbf{Best} model is in bold, \underline{second} best is underlined. Lower RMSE and higher AUC are better. Wasserstein models are by default trained with contrastive regularization as described in \cref{sec:reg}. GIN, GAT and D-MPNN use summation pooling which outperforms max and mean pooling. SAG and TopK graph pooling methods are also used with D-MPNN. }
\label{tab:1}
\end{center}
\end{table*}

\subsection{Experimental Setup}
We experiment on 4 benchmark molecular property prediction datasets \citep{yang2019analyzing} including both regression (ESOL, Lipophilicity) and classification (BACE, BBBP) tasks. These datasets cover different complex chemical properties (e.g. ESOL - water solubility, LIPO - octanol/water distribution coefficient, BACE - inhibition of human $\beta$-secretase, BBBP - blood-brain barrier penetration). 

\noindent\textbf{$\mathbf{Fingerprint + MLP}$} applies a MLP over the input features which are hashed graph structures (called a molecular fingerprint). \textbf{$\mathbf{GIN}$} is the Graph Isomorphism Network from \citep{xu2018powerful}, which is a variant of a GNN. The original GIN does not account for edge features, so we adapt their algorithm to our setting. Next, \textbf{$\mathbf{GAT}$} is the Graph Attention Network from \citep{velivckovic2017graph}, which uses multi-head attention layers to propagate information. The original GAT model does not account for edge features, so we adapt their algorithm to our setting. More details about our implementation of the GIN and GAT models can be found in the \cref{sec:appendix-baseline}. 

\textbf{Chemprop - D-MPNN} \citep{yang2019analyzing} is a graph network that exhibits state-of-the-art performance for molecular representation learning across multiple classification and regression datasets. Empirically we find that this baseline is indeed the best performing, and so is used as to obtain node embeddings in all our prototype models. Additionally, for comparison to our methods, we also add several graph pooling baselines. We apply the graph pooling methods, \textbf{SAG pooling} \citep{lee2019self} and \textbf{TopK pooling} \citep{gao2019graph}, on top of the D-MPNN for fair comparison. 

\begin{figure}[t]
    \centering
  \subfigure[ESOL D-MPNN]{\includegraphics[scale=0.11]{images/sol_gcn.png}}
  \subfigure[ESOL ProtoW-L2]{\includegraphics[scale=0.11]{images/sol_wass.png}}  
  \subfigure[LIPO D-MPNN]{\includegraphics[scale=0.11]{images/lipo_gcn.png}}
  \subfigure[LIPO ProtoW-L2]{\includegraphics[scale=0.11]{images/lipo_wass.png}}  
  \caption{2D heatmaps of T-SNE projections of molecular embeddings (before the last linear layer) w.r.t. their associated predicted labels on test molecules. Comparing (a) vs (b) and (c) vs (d), we can observe a smoother space of our model compared to the D-MPNN baseline.  \vspace{-0.3cm}}
    \label{fig:embedding_space}
\end{figure}

\begin{figure}[t]
    \centering
  \subfigure[ESOL D-MPNN]{\includegraphics[scale=0.20]{images/r_coef_gnn.png}}
  \subfigure[ESOL ProtoW-L2]{\includegraphics[scale=0.20]{images/r_coef_w.png}}  
  \caption{Comparison of the correlation between graph embedding distances (X axis) and label distances (Y axis) on the ESOL dataset.}\label{fig:r_coef}
\end{figure}

\begin{figure}\centering
  {\begin{tabular}{ |c|c|c| } 
 \hline
& Spearman $\rho$ & Pearson $r$  \\
 \hline
 D-MPNN & .424 $\pm$ .029 & .393 $\pm$ .049 \\ 
 \hline
 $\mathrm{ProtoS\text{-}L2}$ & .561 $\pm$ .087& .414 $\pm$ .141 \\ 
 \hline
 $\mathrm{ProtoW\text{-}Dot}$ & .592 $\pm$ .150 & .559 $\pm$ .216  \\
 \hline
 $\mathrm{ProtoW\text{-}L2}$  & \textbf{.815 $\pm$ .026} & \textbf{.828 $\pm$ .020} \\
 \hline
 \end{tabular}
  }
{\caption{The Spearman and Pearson correlation coefficients on the ESOL dataset for the $\mathrm{D-MPNN}$ and $\mathrm{ProtoW\text{-}L2}$ model w.r.t. the pairwise difference in embedding vectors and labels.}\label{tab:2}}
\end{figure}

\par Different variants of our OT-GNN prototype model are described below: 

\noindent\textbf{$\mathbf{ProtoW\text{-}L2/Dot}$} is the model that treats point clouds as point sets, and computes the Wasserstein distances to each point cloud (using either L2 distance or (minus) dot product cost functions) as the molecular embedding. \textbf{$\mathbf{ProtoS\text{-}L2}$} is a special case of $\mathbf{ProtoW\text{-}L2}$, in which the point clouds have a \textit{single} point and instead of using Wasserstein distances, we just compute simple Euclidean distances between the aggregated graph embedding and point clouds. Here, we omit using dot product distances since such a  model is mathematically equivalent to the GNN model.

We use the the POT library \citep{flamary2017pot} to compute Wasserstein distances using the Earth Movers Distance algorithm. We define the cost matrix by taking the pairwise L2 or negative dot product distances. As mentioned in \cref{sec:opt}, we fix the transport plan, and only backpropagate through the cost matrix for computational efficiency. Additionally, to account for the variable size of each input graph, we multiply the OT distance between two point clouds by their respective sizes. More details about experimental setup are presented in \cref{sec:appendix-exp}. 

\subsection{Experimental Results} \label{sec:contrastive-samples}
We next delve into further discussions of our experimental results. Specific experimental setup details, model sizes, parameters and runtimes can be found in \cref{sec:experimental-details}.

\textbf{Regression and Classification. } Results are shown in \cref{tab:1}. Our prototype models outperform popular GNN/D-MPNN baselines on all 4 property prediction tasks. Moreover, the prototype models using Wasserstein distance ($\mathbf{ProtoW\text{-}L2/Dot}$) achieve better performance on 3 out of 4 of the datasets compared to the prototype model that uses only Euclidean distances ($\mathbf{ProtoS\text{-}L2}$). This indicates that Wasserstein distance confers greater discriminative power compared to traditional aggregation methods. We also find that the baseline pooling methods perform worse than the D-MPNN, and we attribute this to the fact that these models were originally created for large graphs networks without edge features, not for small molecular graphs. 



\textbf{Noise Contrastive Regularizer. } Without any constraints, the Wasserstein prototype model will often collapse the set of points in a point cloud into a single point. As mentioned in \cref{sec:reg}, we use a contrastive regularizer to force the model to meaningfully distribute point clouds in the embedding space. We show 2D embeddings in \cref{fig:nce_embeddings}, illustrating that without contrastive regularization, prototype point clouds are often displaced close to their mean, while  regularization forces them to nicely scatter. Quantitative results in \cref{tab:1} also highlight the benefit of this regularization.

\textbf{Learned Embedding Space. } We further examine the learned embedding space of the best baseline (i.e. D-MPNN) and our best Wasserstein model. We claim that our models learn smoother latent representations. We compute the pairwise difference in embedding vectors and the labels for each test data point on the ESOL dataset. Then, we compute two measures of rank correlation, Spearman correlation coefficient ($\rho$) and Pearson correlation coefficient ($r$). This is reminiscent of evaluation tasks for the correlation of word embedding similarity with human labels \citep{luong2013better}.


Our $\mathrm{ProtoW\text{-}L2}$ achieves better $\rho$ and $r$ scores compared to the D-MPNN model (\cref{tab:2}) indicating that our Wasserstein model constructs more meaningful embeddings with respect to the label distribution, which can be inferred also from \cref{fig:r_coef}. Our $\mathrm{ProtoW\text{-}L2}$ model, trained to optimize distances in the embedding space, produces more meaningful representations w.r.t. the label of interest.


Moreover, as qualitatively shown in \cref{fig:embedding_space}, our model provides more robust molecular embeddings compared to the baseline, in the following sense: we observe that a small perturbation of a molecular embedding corresponds to a small change in predicted property value -- a desirable phenomenon that holds rarely for the baseline D-MPNN model. Our Proto-W-L2 model yields smoother heatmaps.

\section{Related Work} \label{sec:rel}
\textbf{Related Work on Graph Neural Networks. }  Graph Neural Networks were introduced by \cite{gori2005new} and \cite{scarselli2008graph} as a form of recurrent neural networks. Graph convolutional networks (GCN) appeared later on in various forms.  \cite{duvenaud2015convolutional,atwood2016diffusion} proposed a propagation rule inspired from convolution and diffusion, but these methods do not scale to graphs with either large degree distribution or node cardinality. \cite{niepert2016learning} defined a GCN as a 1D convolution on a chosen node ordering.  \cite{kearnes2016molecular} also used graph convolutions to generate high quality molecular fingerprints. Efficient spectral methods were proposed by \cite{bruna2013spectral,NIPS2016_6081}. \cite{kipf2016semi} simplified their propagation rule, motivated from spectral graph theory \citep{hammond2011wavelets}. Different such architectures were later unified into the message passing neural networks (MPNN) framework by \cite{gilmer2017neural}. A directed MPNN variant was later used to improve state-of-the-art in molecular property prediction on a wide variety of datasets by \citep{yang2019analyzing}. Inspired by DeepSets \cite{zaheer2017deep}, \cite{xu2018powerful} propose a  simplified, theoretically powerful, GCN architecture. Other recent approaches modify the sum-aggregation of node embeddings in the GCN architecture to preserve more information \cite{kondor2018covariant,hongbin2020geomgcn}. In this category there is also the recently growing class of hierarchical graph pooling methods which typically either use deterministic and non-differentiable
node clustering \citep{NIPS2016_6081,jin2018junction}, or differentiable pooling \citep{ying2018hierarchical,noutahi2019towards,gao2019graph}. However, these methods are still strugling with small labelled graphs such as molecules where global and local node interconnections cannot be easily cast as a hierarchical interaction. Other recent geometry-inspired GNNs include adaptations to  non-Euclidean spaces \citep{liu2019hyperbolic,chami2019hyperbolic,bachmann2019constant, fey2020deep}, and different metric learning on graphs \citep{riba2018learning, bai2019simgnn, li2019graph}, but we emphasize our novel direction in learning prototype point clouds.


\textbf{Related Work on Prototype Learning.}  Learning prototypes to solve machine learning tasks started to become popular with the introducton of generalized learning vector quantization (GLVQ) methods \citep{kohonen1995learning,sato1995generalized}. These approaches perform classification by assigning the class of the closest neighbor prototype to each data point, where Euclidean distance function was the typical choice. Each class has a prototype set that is jointly optimized such that the closest wrong prototype is moved away, while the correct prototype is brought closer. Several extensions  \citep{hammer2002generalized,schneider2009adaptive,bunte2012limited} introduce feature weights and parameterized input transformations to leverage more flexible and adaptive metric spaces. Nevertheless, such models are limited to classification tasks and might suffer from extreme gradient sparsity.

Closer to our work are the radial basis function (RBF) networks \citep{chen1991orthogonal} that perform classification/regression based on RBF kernel similarities to prototypes. One such similarity vector is used  with a shared linear output layer to obtain the final prediction per each data point. Prototypes are typically set in an unsupervised fashion, e.g. via k-means clustering, or using the Orthogonal Least Square Learning algorithm, unlike being learned using backpropagation as in our case.

Combining non-parametric kernel methods with the flexibility of deep learning models have resulted in more expressive and scalable similarity functions, conveniently trained with backpropagation and Gaussian processes \citep{wilson2016deep}. Learning parametric data embeddings and prototypes was also investigated for few-shot and zero-shot classification scenarios \citep{snell2017prototypical}. Last, \citet{duin2012dissimilarity} use distances to prototypes as opposed to p.d. kernels. 

In contrast with the above line of work, our research focuses on learning parametric prototypes for graphs trained jointly with graph embedding functions for both graph classification and regression problems. Prototypes are modeled as sets (point clouds) of embeddings, while graphs are represented by sets of unaggregated node embeddings obtained using graph neural network models. Disimilarities between prototypes and graph embeddings are then quantified via set distances computed using optimal transport. Additional challenges arise due to the combinatorial nature of the  Wasserstein distances between sets, hence our discussion on introducing the noise contrastive regularizer.

\section{Conclusion}
We propose $\mathbf{OT\text{-}GNN}$: one of the first parametric graph models that leverages optimal transport to learn graph representations. It learns abstract prototypes as free parametric point clouds that highlight different aspects of the graph. Empirically, we outperform popular baselines in different molecular property prediction tasks, while the learned representations also exhibit stronger correlation with the target labels. Finally, universal approximation theoretical results enhance the merits of our model.

\appendix

\clearpage

\section{Further Details on Contrastive Regularization}
\subsection{Motivation}\label{sec:discussion-nce}

One may speculate that it was locally easier for the model to extract valuable information if it would behave like the Euclidean component, preventing it from exploring other roads of the optimization landscape. To better understand this situation, consider the scenario in which a subset of points in a prototype point cloud ``collapses", i.e. points become close to each other (see \cref{fig:nce_embeddings}), thus sharing similar distances to all the node embeddings of real input graphs. The submatrix of the optimal transport matrix corresponding to these collapsed points can be equally replaced by any other submatrix with the same marginals (\textit{i.e.} same two vectors obtained by summing rows or columns), meaning that the optimal transport matrix is not discriminative. In general, we want to avoid any two rows or columns in the Wasserstein cost matrix being proportional. 

\paragraph{An optimization difficulty.} An additional problem of point collapsing is that it is a non-escaping situation when using gradient-based learning methods. The reason is that gradients of all these collapsed points would become and remain identical, thus nothing will encourage them to ``separate" in the future.

\paragraph{Total versus local collapse.} Total collapse of all points in a point cloud to its mean is not the only possible collapse case. We note that the collapses are, in practice, mostly local, i.e. some clusters of the point cloud collapse, not the entire point cloud. We argue that this is still a weakness compared to fully uncollapsed point clouds due to the resulting non-discriminative transport plans and due to optimization difficulties discussed above.

\subsection{On the Choice of Contrastive Samples}\label{sec:contrastive-samples}

Our experiments were conducted with ten negative samples for each correct transport plan. Five of them were obtained by initializing a matrix with uniform \textit{i.i.d} entries from $[0,10)$ and performing around five Sinkhorn iterations \citep{cuturi2013sinkhorn} in order to make the matrix satisfy the marginal constraints. The other five were obtained by randomly permuting the columns of the correct transport plan. The latter choice has the desirable effect of penalizing the points of a prototype point cloud $\Q_i$ to collapse onto the same point. Indeed, the rows of $\T^i\in\mathcal{C}_{\mathbf{H} \Q_i}$ index points in $\mathbf{H}$, while its columns index points in $\Q_i$. 

\section{Theoretical Results}

\subsection{Proof of \cref{thm:univ}}\label{sec:proof-univ}

\paragraph{1.} Let us first justify why $\mathfrak{agg}$ is not universal. Consider a function $f\in\mathcal{C}(\mathcal{X})$ such that there exists $\X,\mathbf Y\in\mathcal{X}$ satisfying both $f(\X)\neq f(\mathbf Y)$ and $\sum_k \x_k=\sum_l \mathbf y_l$. Clearly, any function of the form $\sum_i \alpha_i\sigma(\mathfrak{agg}(\mathbf W_i,\cdot)+\theta_i)$ would take equal values on $\X$ and $\mathbf Y$ and hence would not approximate $f$ arbitrarily well.

\paragraph{2.} To justify that $\mathcal{W}$ is universal, we take inspiration from the proof of universality of neural networks \cite{cybenko1989approximation}.

\paragraph{Notation.} Denote by $M(\mathcal{X})$ the space of finite, signed regular Borel measures on $\mathcal{X}$. 

\paragraph{Definition.} We say that $\sigma$ is discriminatory w.r.t a kernel $k$ if for a measure $\mu\in M(\mathcal{X})$, $$\int_{\mathcal{X}} \sigma(k(\mathbf Y,\X)+\theta)d\mu(\X) = 0$$ for all $\mathbf Y\in\mathcal{X}^n_d$ and $\theta\in\mathbb{R}$ implies that $\mu \equiv 0$.

We start by reminding a lemma coming from the original paper on the universality of neural networks by Cybenko \cite{cybenko1989approximation}.\\

\paragraph{Lemma.} If $\sigma$ is discriminatory w.r.t. $k$ then $k$ is universal.\\

\textit{Proof:} Let $S$ be the subset of functions of the form $\sum_{i=1}^m\alpha_i\sigma(k(\cdot,\Q_i)+\theta_i)$ for any $\theta_i\in\mathbb{R}$, $\Q_i\in\mathcal{X}_d^n$ and $m\in\mathbb{N}^*$ and denote by $\bar{S}$ the closure\footnote{W.r.t the topology defined by the sup norm $\Vert f\Vert_{\infty,\mathcal{X}}:=\sup_{X\in\mathcal{X}}\vert f(X)\vert$.} of $S$ in $\mathcal{C}(\mathcal{X})$. Assume by contradiction that $\bar{S} \neq \mathcal{C}(\mathcal{X})$. By the Hahn-Banach theorem, there exists a bounded linear functional $L$ on $\mathcal{C}(\mathcal{X})$ such that for all $h\in \bar{S}$, $L(h)=0$ and such that there exists $h'\in\mathcal{C}(\mathcal{X})$ s.t. $L(h')\neq  0$. By the Riesz representation theorem, this bounded linear functional is of the form:
$$L(h)= \int_{\X\in\mathcal{X}} h(\X)d\mu(\X),$$
for all $h\in\mathcal{C}(\mathcal{X})$, for some $\mu\in M(\mathcal{X})$. Since $\sigma(k(\Q,\cdot)+\theta)$ is in $\bar{S}$, we have  $$\int_{\mathcal{X}} \sigma(k(\Q,\X)+\theta)d\mu(\X) = 0$$ for all $\Q\in\mathcal{X}^n_d$ and $\theta\in\mathbb{R}$. Since $\sigma$ is discriminatory w.r.t. $k$, this implies that $\mu=0$ and hence $L\equiv0$, which is a contradiction with $L(h')\neq  0$. Hence $\bar{S} = \mathcal{C}(\mathcal{X})$, \textit{i.e.} $S$ is dense in $\mathcal{C}(\mathcal{X})$ and $k$ is universal.
\begin{flushright}
$\square$
\end{flushright}

\noindent Now let us look at the part of the proof that is new.

\paragraph{Lemma.} $\sigma$ is discriminatory w.r.t. $\mathcal{W}_{\mathrm{L2}}$.\\

\textit{Proof:} Note that for any $\X,\mathbf Y,\theta,\varphi$, when $\lambda\to+\infty$ we have that $\sigma(\lambda(\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)+\theta)+\varphi )$ goes to 1 if $\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)+\theta>0$, to 0 if $\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)+\theta<0$ and to $\sigma(\varphi)$ if $\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)+\theta=0$. 

Denote by $\Pi_{\mathbf Y,\theta}:=\{\X\in\mathcal{X}\mid \mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)-\theta = 0\}$ and $B_{\mathbf Y,\theta}:=\{\X\in\mathcal X \mid \sqrt{\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)} < \theta \}$ for $\theta\geq 0$ and $\emptyset$ for $\theta<0$. By the Lebesgue Bounded Convergence Theorem we have: 
\begin{align*}
0 &= \int_{\X\in\mathcal{X}} \lim_{\lambda\to +\infty} \sigma(\lambda(\mathcal{W}_{\mathrm{L2}}(\X,\mathbf Y)-\theta)+\varphi)d\mu(\X)\\
&= \sigma(\varphi)\mu(\Pi_{\mathbf Y,\theta})+\mu(\mathcal{X}\setminus B_{\mathbf Y,\sqrt{\theta}}).
\end{align*}


Since this is true for any $\varphi$, it implies that $\mu(\Pi_{\mathbf Y,\theta})=\mu(\mathcal{X}\setminus B_{\mathbf Y,\sqrt{\theta}})=0$. From $\mu(\mathcal{X})=0$ (because $B_{\mathbf Y,\sqrt{\theta}}=\emptyset$ for $\theta <0$), we also have $\mu(B_{\mathbf Y,\sqrt{\theta}})=0$. Hence $\mu$ is zero on all balls defined by the metric $\sqrt{\Was_{\mathrm{L2}}}$.

From the Hahn decomposition theorem, there exist disjoint Borel sets $P,N$ such that $\mathcal{X}=P\cup N$ and $\mu=\mu^+ - \mu^-$ where $\mu^+(A):=\mu(A\cap P)$, $\mu^-(A):=\mu(A\cap N)$ for any Borel set $A$ with $\mu^+,\mu^-$ being positive measures. Since $\mu^+$ and $\mu^-$ coincide on all balls on a finite dimensional metric space, they coincide everywhere \cite{hoffmann1976measures} and hence $\mu \equiv 0$.



\begin{flushright}
$\square$
\end{flushright}

Combining the previous lemmas with $k=\mathcal{W}_{\mathrm{L2}}$ concludes the proof. 
\begin{flushright}
$\square$
\end{flushright}




\subsection{Proof of \cref{thm:pd}}\label{sec:proof-pd}


\paragraph{1.} We build a counter example. We consider $4$ point clouds of size $n=2$ and dimension $d=2$. First, define $\uu_i = (\lfloor i/2\rfloor, i\%2)$ for $i\in\{0,...,3\}$. Then take $\X_1=\{\uu_0,\uu_1\}$, $\X_2=\{\uu_0,\uu_2\}$, $\X_3=\{\uu_0,\uu_3\}$ and $\X_4=\{\uu_1,\uu_2\}$.
On the one hand, if $\Was(\X_i, \X_j)=0$, then all vectors in the two point clouds are orthogonal, which can only happen for $\{i,j\}=\{1,2\}$. On the other hand, if $\Was(\X_i,\X_j)=1$, then either $i=j=3$ or $i=j=4$. This yields the following Gram matrix
\begin{equation}
(\Was(\X_i,\X_j))_{0\leq i,j\leq 3}=
\begin{pmatrix}
1 & 0 & 1 & 1 \\
0 & 1 & 1 & 1 \\
1 & 1 & 2 & 1 \\
1 & 1 & 1 & 2
\end{pmatrix}
\end{equation}
whose determinant is $-1/16$, which implies that this matrix has a negative eigenvalue.


\paragraph{2.} This comes from proposition \cref{prop:cnd}. Choosing $k=\Was_{\mathrm{L2}}$ and $x_0=\mathbf{0}$ to be the trivial point cloud made of $n$ times the zero vector yields $\tilde{k} = \Was_{\mathrm{dot}}$. Since $\tilde{k}$ is not positive definite from the previous point of the theorem, $k$ is not conditionally negative definite from proposition \cref{prop:cnd}.

\begin{flushright}
$\square$
\end{flushright}





\subsection{Shape of the optimal transport plan for point clouds of same size}\label{sec:proof-permu}
The below result describes the shape of optimal transport plans for point clouds \textbf{of same size}, which are essentially permutation matrices. For the sake of curiosity, we also illustrate in \cref{fig:ot_dist} the optimal transport for point clouds of different sizes. However, in the case of different sized point clouds, the optimal transport plans distribute mass from single source points to multiple target points. We note that non-square transports seem to remain relatively sparse as well. This is in line with our empirical observations.

\begin{proposition}\label{thm:permu}
For $\X,\Y\in\mathcal{X}_{n,d}$ there exists a rescaled permutation matrix $\frac{1}{n}(\delta_{i\sigma(j)})_{1\leq i,j\leq n}$ which is an optimal transport plan, i.e. \begin{equation}
     \Was_{\mathrm{L2}}(\X,\Y) =\dfrac{1}n\sum_{j=1}^n\Vert\x_{\sigma(j)}-\mathbf{y}_j\Vert_2^2
 \end{equation}
 \begin{equation}
     \Was_{\mathrm{dot}}(\X,\Y) =\dfrac{1}n\sum_{j=1}^n\langle\x_{\sigma(j)},\mathbf{y}_j\rangle.
 \end{equation}
\end{proposition}
\begin{proof}
It is well known from Birkhoff's theorem that every squared doubly-stochastic matrix is a convex combination of permutation matrices. Since the Wasserstein cost for a given transport $\T$ is a linear function, it is also a convex/concave function, and hence it is maximized/minimized over the convex compact set of couplings at one of its extremal points, namely one of the rescaled permutations, yielding the desired result.
\end{proof}




\section{Complexity} \label{apx:complexities}
\subsection{Wasserstein}
Computing the Wasserstein optimal transport plan between two point clouds consists in the minimization of a linear function under linear constraints. It can either be performed exactly by using network simplex methods or interior point methods as done by \citep{pele2009fast} in time $\Tilde{\mathcal{O}}(n^3)$, or approximately up to $\varepsilon$ via the Sinkhorn algorithm \citep{cuturi2013sinkhorn} in time $\Tilde{\mathcal{O}}(n^2/\varepsilon^3)$. More recently, \citep{dvurechensky2018computational} proposed an algorithm solving OT up to $\varepsilon$ with time complexity $\Tilde{\mathcal{O}}(\min\{n^{9/4}/\varepsilon,n^2/\varepsilon^2\})$ via a primal-dual method inspired from accelerated gradient descent.


In our experiments, we used the Python Optimal Transport (POT) library \citep{flamary2017pot}. We noticed empirically that the Earth Mover Distance (EMD) solver yielded faster and more accurate solutions than Sinkhorn for our datasets, because the graphs and point clouds were small enough ($< 30$ elements). As such, we our final models use EMD.

Significant speed up could potentially be obtained by rewritting the POT library for it to solve OT in batches over GPUs. In our experiments, we ran all jobs on CPUs.

\section{Further Experimental Details}\label{sec:experimental-details}

\paragraph{Model Sizes}

Using MPNN hidden dimension as 200, and the final output MLP hidden dimension as 100, the number of parameters for the models are given by \cref{tab:num_params}. The fingerprint used dimension was 2048, explaining why the MLP has a large number of parameters. The D-MPNN model is much smaller than GIN and GAT models because it shares parameters between layers, unlike the others. Our prototype models are even smaller than the D-MPNN model because we do not require the large MLP at the end, instead we compute distances to a few small prototypes (small number of overall parameters used for these point clouds). The  dimensions of the prototype embeddings are also smaller compared to the node embedding dimensions of the D-MPNN and other baselines. We did not see significant improvements in quality by increasing any hyperparameter value.

Remarkably, our model outperforms all the baselines using between 10 to 1.5 times less parameters.

\begin{table*}[h]
\centering
\begin{tabular}{ c|p{1.39cm}|p{0.9cm}|p{1.0cm}|p{1.25cm}||p{1.39cm}|p{0.9cm}|p{1.0cm}|p{1.25cm}| } 
  \cline{2-9} 
 & \multicolumn{4}{c||}{Average Train Time per Epoch (sec)} & \multicolumn{4}{c|}{Average Total Train Time (min)} \\
 \cline{2-9} 
  & D-MPNN & ProtoS & ProtoW & \begin{tabular}{@{}c@{}}ProtoW +\\ NC reg\end{tabular} & D-MPNN & ProtoS & ProtoW & \begin{tabular}{@{}c@{}}ProtoW +\\ NC reg\end{tabular} \\ 
 \hline
 \multicolumn{1}{|l|}{ESOL} & 5.5 & 5.4 & 13.5  & 31.7 & 4.3 & 5.3 & 15.4 & 30.6  \\ 
 \multicolumn{1}{|l|}{BACE} & 32.0 & 31.4 & 25.9  & 39.7 & 12.6 & 12.4 & 25.1 & 49.4\\
 \multicolumn{1}{|l|}{BBBP} & 41.8 & 42.4 & 51.2 & 96.4 & 12.6 & 13.2 & 31.5 & 62.2 \\
 \multicolumn{1}{|l|}{LIPO} & 33.3 & 35.5 & 27 & 69.4 & 28.6 & 31.8 & 74.7 & 146.9 \\
 \hline
\end{tabular}
\caption{Training times for each model and dataset  in \cref{tab:1}.}
\label{tab:runtimes}
\end{table*}


\begin{table}[h]
\begin{tabular}{ |c|c|c|c|c|c| } 
 \hline
  MLP & GIN & GAT & D-MPNN & ProtoS & ProtoW \\ 
 \hline
 401k & 626k & 671k & 100k & 65k & 66k  \\ 
 \hline
\end{tabular}
\caption{Number of parameters per each model in \cref{tab:1}. Corresponding hyperparameters are in \cref{sec:appendix-exp}.}
\label{tab:num_params}
\end{table}

\paragraph{Runtimes.}
We report the average total training time (number of epochs might vary depending on the early stopping criteria), as well as average  training epoch time for the D-MPNN and our prototype models in \cref{tab:runtimes}. We note that our method is between 1 to 7.1 times slower than the D-MPNN baseline which mostly happens due to the frequent calls to the Earth Mover Distance OT solver.


\subsection{Setup of Experiments} \label{sec:appendix-exp}

Each dataset is split randomly 5 times into 80\%:10\%:10\% train, validation and test sets. For each of the 5 splits, we run each model 5 times to reduce the variance in particular data splits (resulting in each model being run 25 times). We search hyperparameters described in \cref{tab:3} for each split of the data, and then take the average performance over all the splits. The hyperparameters are separately searched for each data split, so that the model performance is based on a completely unseen test set, and that there is no data leakage across data splits. The models are trained for 150 epochs with early stopping if the validation error has not improved in 50 epochs and a batch size of 16. We train the models using the Adam optimizer with a learning rate of 5e-4. For the prototype models, we use different learning rates for the GNN and the point clouds (5e-4 and 5e-3 respectively), because empirically we find that the gradients are much smaller for the point clouds. The molecular datasets used for experiments here are small in size (varying from 1-4k data points), so this is a fair method of comparison, and is indeed what is done in other works on molecular property prediction \cite{yang2019analyzing}.

\begin{table*}\centering
    \caption{The parameters for our models (the prototype models all use the same GNN base model), and the values that we used for hyperparameter search. When there is only a single value in the search list, it means we did not search over this value, and used the specified value for all models.}
  \label{tab:3}
  \vskip 0.10in
  \begin{tabular}{|l|c|l|}
  \hline
 Parameter Name & Search Values & Description \\  [0.3ex]
 \hline
 n$\_$epochs & $\{150\}$ & Number of epochs trained \\ [0.3ex]
 batch$\_$size & $\{16\}$ & Size of each batch \\ [0.3ex]
 lr & $\{$5\text{e}-4$\}$ & Overall learning rate for model \\ [0.3ex]
 lr$\_$pc & $\{$5\text{e}-3$\}$ & Learning rate for  the prototype embeddings \\ [0.3ex]
 n$\_$layers & $\{5\}$ & Number of layers in the GNN \\ [0.3ex]
 n$\_$hidden & $\{50, 200\}$ & Size of hidden dimension in GNN \\ [0.3ex]
 n$\_$ffn$\_$hidden & $\{1\text{e}2, 1\text{e}3, 1\text{e}4\}$ & Size of the output feed forward layer \\ [0.3ex]
 dropout$\_$gnn & $\{0.\}$ & Dropout probability for GNN \\ [0.3ex]
 dropout$\_$fnn & $\{0., 0.1, 0.2\}$ & Dropout probability for feed forward layer \\ [0.3ex]
 n$\_$pc (M)& $\{10, 20\}$ & Number of the prototypes (point clouds) \\ [0.3ex]
 pc$\_$size (N)& $\{10\}$ & Number of points in each prototype (point cloud) \\ [0.3ex]
 pc$\_$hidden (d)& $\{5, 10\}$ & Size of hidden dimension of each point in each prototype \\ [0.3ex]
 nc$\_$coef & $\{0., 0.01, 0.1, 1\}$ & Coefficient for noise contrastive regularization \\ [0.3ex]
 \hline
  \end{tabular}
  \vskip -0.10in
\end{table*}

\subsection{Baseline models} \label{sec:appendix-baseline}

Both the GIN \citep{xu2018powerful} and GAT \citep{velivckovic2017graph} models were originally used for graphs without edge features. Therefore, we adapt both these algorithms to our use-case, in which edge features are a critical aspect of the prediction task. Here, we expand on the exact architectures that we use for both models. 

First we introduce common notation that we will use for both models. Each example is defined by a set of vertices and edges $(V, E)$. Let $v_i \in V$ denote the $i$th node in the graph, and let $e_{ij} \in E$ denote the edge between nodes $(i, j)$. Let $h_{v_i}^{(k)}$ be the feature representation of node $v_i$ at layer $k$. Let $h_{e_{ij}}$ be the input features for the edge between nodes $(i, j)$, and is static because we do updates only on nodes. Let $N(v_i)$ denote the set of neighbors for node $i$, not including node $i$; let $\hat{N}(v_i)$ denote the set of neighbors for node $i$ as well as the node itself.

\textbf{GIN} 

The update rule for GIN is then defined as:

\begin{equation}
    h_{v_i}^k = \text{MLP}^{(k)} \big( (1+\epsilon^{(k)}) + \sum_{v_j \in N(v_i)} [h^{(k-1)}_u + W_b^{(k)} h_{e_{ij}}] \big) 
\end{equation}

As with the original model, the final embedding $h_G$ is defined as the concatenation of the summed node embeddings for each layer.

\begin{equation}
    h_G = \text{CONCAT}\Big[ \sum_{v_i} h_{v_i}^{(k)} | k = 0, 1, 2 ... K \Big]
\end{equation}

\textbf{GAT}

For our implementation of the GAT model, we compute the attention scores for each pairwise node $\alpha^{(k)}_{ij}$ as follows.

\begin{equation}
\alpha^{(k)}_{ij} = \frac{\exp f(v_i, v_j)}{\sum_{v_{j'} \in \hat{N}(v_i)} \exp f(v_i, v_{j'}) }, \quad \text{where}
\end{equation}

\begin{equation*}
    f(v_i, v_j) = \sigma(a^{(k)} \Big[W_1^{(k)} h_{v_i}^{(k-1)} || W_2^{(k)} [h_{v_j}^{(k-1)} + W_b^{(k)} h_{e_{ij}} ]\Big])
\end{equation*}

where $\{W_1^{(k)}, W_2^{(k)}, W_b^{(k)}\}$ are layer specific feature transforms, $\sigma$ is LeakyReLU, $a^{(k)}$ is a vector that computes the final attention score for each pair of nodes. Note that here we do attention across all of a node's neighbors as well as the node itself.

The updated node embeddings are as follows:

\begin{equation}
    h_{v_i}^{k} = \sum_{v_j \in \hat{N}(v_i)} \alpha^{(k)}_{i,j}h_{v_j}^{(k-1)}
\end{equation}

The final graph embedding is just a simple sum aggregation of the node representations on the last layer ($h_G = \sum_{v_i} h_{v_i}^{K}$). As with \citep{velivckovic2017graph}, we also extend this formulation to utilize multiple attention heads.


\section{What types of molecules do prototypes capture ?} \label{apx:interp}

To better understand if the learned prototypes offer interpretability, we examined the ProtoW-Dot model trained with NC regularization (weight 0.1). For each of the 10 learned prototypes, we computed the set of molecules in the test set that are closer in terms of the corresponding Wasserstein distance to this prototype than to any other prototype. While we noticed that one prototype is closest to the majority of molecules, there are other prototypes that are more interpretable as shown in \cref{fig:interpr}.

\begin{figure}[h]
    \centering
    \includegraphics[width=.5\textwidth]{images/interpretability.png}
    \caption{The closest molecules to some particular prototypes in terms of the corresponding Wasserstein distance. One can observe that some prototypes are closer to insoluble molecules containing rings (Prototype 2), while others prefer more soluble molecules (Prototype 1).  } 
    \label{fig:interpr}
\end{figure}

\bibliography{biblio}

\end{document}
