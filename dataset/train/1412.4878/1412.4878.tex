\documentclass{eptcs}
\providecommand{\event}{TFPIE 2014} \usepackage{breakurl}             \usepackage[noxcolor]{pstricks}
\usepackage{pst-node}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{stfloats}
\usepackage{multido}
\usepackage{setspace}
\usepackage{textcomp}

\definecolor{LightBlue}{rgb}{0.68,0.85,0.9}

\definecolor{PaleGreen}{rgb}{0.88,1,0.88}

\title{Functional Automata \\ \large{Formal Languages for Computer Science Students}}
\author{Marco T. Moraz\'an
\institute{Seton Hall University}
\email{morazanm@shu.edu}
\and
Rosario Antunez
\institute{City College of New York}
\email{mrantunez@gmail.com}
}
\def\titlerunning{Functional Automata}
\def\authorrunning{M. T. Moraz\'an \& R. Antunez}
\begin{document}
\maketitle

\begin{abstract}
An introductory formal languages course exposes advanced undergraduate and early graduate students to automata theory, grammars, constructive proofs, computability, and decidability. Programming students find these topics to be challenging or, in many cases, overwhelming and on the fringe of Computer Science. The existence of this perception is not completely absurd since students are asked to design and prove correct machines and grammars without being able to experiment nor get immediate feedback, which is essential in a learning context. This article puts forth the thesis that the theory of computation ought to be taught using tools for actually building computations. It describes the implementation and the classroom use of a library, \textsf{FSM}, designed to provide students with the opportunity to experiment and test their designs using state machines, grammars, and regular expressions. Students are able to perform random testing before proceeding with a formal proof of correctness. That is, students can test their designs much like they do in a programming course. In addition, the library easily allows students to implement the algorithms they develop as part of the constructive proofs they write. Providing students with this ability ought to be a new trend in the formal languages classroom.
\end{abstract}

\section{Introduction}
An introductory formal languages course exposes advanced undergraduate and early graduate students to automata theory, grammars, constructive proofs, computability, and decidability. Programming-oriented students find these topics to be challenging or, in many cases, overwhelming and on the fringe of Computer Science. The existence of this perception is not completely absurd since students are asked to design and prove correct machines/grammars without being able to experiment nor get immediate feedback, as they do in any programming course, which is essential in a learning context and needs to be timely (the sooner the better) \cite{Race}. Computer Science students are accustomed to immediate feedback as they routinely use compilers and interpreters that provide error messages and warnings. Moreover, machines/grammars are representations of programs. Thus, in essence, designing machines and grammars without being able to test them goes against the grain of what students have learned in programming courses. The same holds true when arguing that a problem is decidable. In our experience, the inability to implement state machines and grammars results in inexperienced students submitting solutions that are incorrect even when an exercise is relatively simple. Experimentation and immediate feedback are key components to learning that are seldom found in the automata theory classroom.

Rarely do formal languages textbooks (e.g., \cite{Lewis,Martin,Sipser}), unlike programming textbooks, offer any software infrastructure for students to experiment with their ideas and designs. This omission has an impact on how well students understand constructive proofs. In essence, a constructive proof spells out an algorithm to build a machine/grammar. For example, algorithms are outlined by the proof that nondeterministic finite-state machines and deterministic finite-state machines are equivalent and by the proof that context-free languages are closed under union. Computer Science students are taught that algorithms need to be implemented and tested. This is especially true when the student has an intuition of how an algorithm ought to proceed, but is uncertain of all the details--the typical case when a student starts thinking about a constructive proof. Without feedback obtained from implementation and testing, it is common for students to try to prove the correctness of a machine/grammar that is incorrect. This leads to their work being marked down by an instructor and, in turn, to frustration and apathy for the material. The reader can contrast this scenario with a programming course in which the student can experiment with an implementation. Formal languages textbooks that reference software support (e.g., \cite{Linz}) fail to integrate the use of the software as a part of the textbook. Instead, it is left as a recommendation. More worrisome, however, is that the support software is not easily extendible by students to integrate the algorithms they develop as part of their own constructive proofs. In other words, students are required to design algorithms that are not to be implemented.

Given that it is reasonable for Computer Science students to be able to experiment with and get feedback on the algorithms they develop, a decision must be made as to how to engage programming students. One solution, of course, is to have students implement the algorithms from scratch in their favorite programming language without providing any software support. Although possible, this approach is likely to be too time-consuming within the confines of one semester. A more reasonable approach is to provide students with a library (or a programming language) that allows them to quickly implement and test\footnote{Tests provide a form of immediate feedback that either confirms or challenges the understanding of a student.} the machines/grammars they design and the algorithms they develop. This article describes a \textsf{Racket} library, \textsf{FSM}, designed to provide students with the opportunity to implement and to test their designs using finite-state machines, regular expressions, regular grammars, pushdown automata, context-free grammars, Turing machines, and context-sensitive grammars much like they experiment when writing programs in a programming course. In addition, the \textsf{FSM} library easily allows students to implement the algorithms they develop as part of the constructive proofs they write. In essence, this article puts forth that the theory of computation ought to be taught using tools for actually building computations. Providing this ability should be a new trend in the formal languages classroom and in the development of software to support such courses. This software support allows students to receive immediate feedback on their work and, thus, the learning experience is enhanced. Furthermore, it is likely to provide significant help to instructors that commonly need to grade contrived machine designs for which determining correctness is difficult. This approach ties in nicely with other topics in a Computer Science curriculum, such as programming languages and compilers, by exposing students to programming with the data representation of programs.

The library provides the ability to replace pencil-and-paper designs with programming by making it an integral part of an Automata Theory course. Students use the library to implement and test all their designs and algorithms. The library has been implemented in \textsf{Racket}, because the resulting machines/grammars descriptions are concise.  Furthermore, most of our students are familiar with the language syntax and with list-based processing. The reader can note that the library is also useful for students not familiar with \textsf{Racket} as only a minimal amount of syntax needs to be learned. Knowledge of functional programming is not a prerequisite to use \textsf{FSM}.

The article is organized as follows. Section 2 highlights the interface and the implementation of the \textsf{FSM} library to provide the framework needed by any reader that desires to implement the library using a different programming language. Section 3 provides examples of how the library has been used in practice and highlights the usefulness of immediate feedback in the formal languages classroom. Section 4 describes and contrast \textsf{FSM} with related work. Finally, Section 5 presents concluding remarks and directions for future work.

\section{Interface and Implementation}
The \textsf{FSM} library presents the user with a generic interface to construct and manipulate state machines and grammars. The interface is presented to facilitate its reproduction in any modern programming language. Constructors are divided into two categories: primitive constructors and transformers. Primitive constructors build a state machine or a grammar from a formal description provided by the programmer. Transformers build a state machine or a grammar from existing machines or grammars exploiting algorithms obtained from constructive proofs. Observers are divided into three categories: accessors, applicators, and testers. Accessors return a specified component used to build a grammar or a state machine. Applicators apply a given machine or grammar to a word. Testers allow for machines and grammars to be tested with words provided by the programmer or with randomly generated words by the software. The latter two provide students with immediate feedback on the validity (not the verification) of their designs and implementations.

\subsection{State Machines}
A state machine (sm) is either:
 \begin{enumerate}
   \item Deterministic finite-state machine (\textsf{dfa})
   \item Nondeterministic finite-state machine (\textsf{ndfa})
   \item Pushdown automata (\textsf{pda})
   \item Turing machine (\textsf{tm})
 \end{enumerate}

Every state machine has the user explicitly provide a finite set of states (), a tape alphabet (), a starting state (), a set of final states (), and a set of transition rules (). The transition rules must describe a function for a \textsf{dfa} while simply a relation for the other machines. Finally, a \textsf{pda} also requires a stack alphabet ().  denotes the representation of a regular expression or a machine/grammar of type . The corresponding primitive constructors for machines with explicit rules have the following signatures\footnote{ represents the empty string and  represents a blank tape space.}:
\begin{enumerate}
   \item \textbf{make-dfa}:       , \newline  where  and 
   \item \textbf{make-ndfa}:       , \newline  where  and 
   \item \textbf{make-pda}:        , \newline  where , , and \newline   \{non-empty list of -symbols\} 
   \item \textbf{make-tm}:       , \newline  where  and 
\end{enumerate}
State machines are represented as functions that dispatch to the appropriate observer given some input.

\textsf{FSM} also employs a more general notion of a machine. A machine () is either:
 \begin{enumerate}
   \item A state machine
   \item Combined Turing machine (\textsf{ctm})\footnote{In terms of computational power there is no difference between a Turing Machine and a combined Turing machine. The latter is simply an abstraction that simplifies the design of Turing machines built from existing Turing Machines.}.
 \end{enumerate}
A \textsf{ctm} is not defined by providing a formal description. Instead, the user provides a \textsf{ctm} description () and . A \textsf{ctm} description uses other Turing machines as building blocks. In essence, a \textsf{ctm} represents an iterative algorithm with conditional branches and gotos that changes the state of the machine.  A  is described by the following grammar:\\ \\
\begin{centering}
\begin{tabular}{rcl}
 &  &  \\
   &  & (\textsf{tm} ) \\
   &  & ( ) \\
   &  &  (\textsf{label} ) \\
   &  & (\textsf{BRANCH} \{\textsf{symbol} \}) \\
   &  & (\textsf{GOTO} \textsf{label}) \\
   &  & ((\textsf{VAR} symbol) ) \\
\end{tabular}
\end{centering}\\

\noindent Informally, the varieties of s are described as follows. The simplest s are either: empty, a \textsf{tm} followed by a , a  followed by a , or a label (used by a goto) followed by a . More complex s, can either start with a branch, a goto, or a variable. A branch defines options for the machine to execute based on the alphabet symbol being read. A goto unconditionally branches to a label that must be defined. Finally, to aid in the development of these machines, the library allows for branches to abstract over the symbol being read. A variable (not an alphabet symbol) captures the read symbol. This variable is used as a constant, whose value  can be written to the tape, in the \textsf{ctm} that follows it\footnote{In programming languages, this is akin to -conversion.}.

The constructor signature for a \textsf{ctm} is: \textbf{combine-tms}:    \textsf{ctm}. The observer \textbf{apply-ctm} takes as input a \textsf{ctm}, a tape configuration (akin to a word), and a head position and returns a Turing machine configuration (i.e., a state, a tape, and the position of the head on the tape). A \textsf{ctm} is represented as a function that returns a Turing machine configuration. In this manner, \textsf{ctm} and \textsf{ctm} can be composed as the resulting tape and head position of \textsf{ctm} is used to build the initial configuration for \textsf{ctm}.

The state-machine transformers build new machines from existing machines, from grammars, or from a regular expression. These constructors implement algorithms from constructive proofs typically covered in an introductory formal languages course. They include:
\begin{description}
   \item [(regexpfsa )] Transforms a regular expression into a finite-state machine.

   \item [(ndfadfa )] Transforms a \textsf{ndfa} into a \textsf{dfa}.

   \item [(rename-states-sm  )] Renames the states of the given \textsf{sm} such that the intersection of the new names and the given list of states (i.e., symbols) is empty\footnote{In programming languages, this is akin to -conversion.}. This function is useful when combining two state machines requires that the intersection of the set of states of both machines be empty like, for example, when creating a machine using closure under union.

   \item [(union-sm  )] Builds an \textsf{sm} that accepts the union of the languages of the two given \textsf{sm}s of the same kind. If the inputs are \textsf{tm}s, they must be language recognizers.

   \item [(concat-sm  )] Builds an \textsf{sm} that accepts the concatenation of the languages of the two given \textsf{sm}s of the same kind. If the inputs are \textsf{tm}s, they must be a language recognizers.

   \item [(kleenestar-sm )] Builds an \textsf{sm} that accepts the Kleene star of the given \textsf{sm}'s language. If the input is a \textsf{tm}, it must be a language recognizer.

   \item [(complement-sm )] Builds an \textsf{sm} that accepts the complement of the language of the given \textsf{sm}. The given \textsf{sm} cannot be a \textsf{pda}. If the input is a \textsf{tm}, it must be a language recognizer.

   \item [(intersection-sm  )] Builds an \textsf{sm} that accepts the intersection of the languages of the two given \textsf{sm}s of the same kind. The given \textsf{sm}s cannot be \textsf{pda}s. If the inputs are \textsf{tm}s, they must be language recognizers.

   \item [(grammarsm )] Builds an \textsf{sm} for the language of the given grammar.
\end{description}

The observers to return a given component of an \textsf{sm} take as input an \textsf{sm} and return the desired component. The interesting observers are:
\begin{description}
  \item [(apply-sm   )] Runs the given \textsf{sm} assuming the given word is on the tape and the head of the \textsf{sm} is on position 0 of the tape. If the optional natural number is provided, the head starts at that position. The returned value is either \textquotesingle accept or \textquotesingle reject. The given \textsf{sm} is simulated by performing a breadth-first search of all the possible paths it can take by consuming the given word.

  \item [(show-transitions-sm   )] Similar to \textsf{apply-sm}, but returns the path followed by the \textsf{sm}. For a nondeterministic \textsf{sm}, it returns an empty path if all possible paths end in a non-accepting state.
\end{description}

The testers for state machines offer the user the ability to experiment with the machines they create and provide immediate feedback. There are three testers provided:
\begin{description}
  \item [(same-result-sm?   )] Determines if both of the given \textsf{sm}s produce the same result for the given word.

  \item [(test-equiv-sm   )] Determines if both of the given \textsf{sm}s produce the same result on 100 randomly generated words. If the optional natural number is provided, then that number of random tests are performed. The function returns true or a list of words for which the given machines produce a different result. If a \textsf{tm} is provided as input, it must be a language recognizer.

  \item [(test-sm  )] Generates 100 (or the given optional number of) random words and returns a list of the words with the results obtained from the given \textsf{sm}. If a \textsf{tm} is provided as input, it must be a language recognizer.
\end{description}

\subsection{Grammars}
A grammar is either:
 \begin{enumerate}
   \item Regular grammar (\textsf{rg})
   \item Context-free grammar (\textsf{cfg})
   \item Context-sensitive grammar (\textsf{csg})
 \end{enumerate}
Every grammar is composed of a set of terminal and nonterminal symbols (), a set of terminal symbols (), a set of of production rules (), and a starting nonterminal symbol . The left hand side of production rules for an \textsf{rg} and a \textsf{cfg} must only have a single nonterminal. The left hand side of production rules for a \textsf{csg} must contain at least one nonterminal. The right hand side of a production rule for a \textsf{rg} must have either a terminal symbol, a terminal symbol followed by a nonterminal symbol, or, if the left hand side is ,  (the empty string). The right hand side of a production rule for a \textsf{cfg} and a \textsf{csg} may be  or may have one or more members of . The primitive constructors for grammars are:
\begin{enumerate}
  \item \textbf{make-rg}:     , \newline  where  and 

  \item \textbf{make-cfg}:     , \newline  where  and 

  \item \textbf{make-csg}:    symbol  , \newline  where  and 
\end{enumerate}

The transformers for grammars build new grammars from either existing grammars, existing state machines, or an existing regular expression. They include:
\begin{description}
  \item[(smgrammar )] Transforms a state machine into a grammar. If the input is a \textsf{tm}, it must be a language recognizer.

  \item[(grammar-rename-nts  )] Renames the nonterminals of the given grammar to symbols not contained in the given list. This function is useful when the intersection of the nonterminals of two grammars must be empty.
\end{description}

The observers to return a given component of a grammar take as input a grammar and return the desired component. The interesting observer is:
\begin{description}
  \item [(deriv  )] If the given word is in the language of the given grammar, the derivation of the word is returned. Otherwise, a string stating that the word is not a member of the language of the grammar is returned.
\end{description}

The testers for grammars offer students the ability to experiment with the grammars they create and offer immediate feedback. There are three testers provided:
\begin{description}
  \item [(both-deriv?   )] Determines if both of the given grammars derive the given word.

  \item [(test-equiv-grammar   )] Determines if both of the given grammars produce the same result when attempting to derive 100 randomly generated words. If the optional natural number is provided, then that number of random tests are performed. The function returns true or a list of words for which the given grammars produce a different result.

  \item [(test-grammar  )] Generates 100 (or the given optional number of) random words and returns a list of the words with the results obtained from trying to use the given grammar to derive them.
\end{description}

\subsection{Regular Expressions}
Let  be an alphabet of symbols. A regular expression () is a string  that is either
\begin{enumerate}
  \item  (the empty string)
  \item 
  \item , where  and  are 
  \item , where  and  are 
  \item 
\end{enumerate}
There is a constructor for each of the above. There is a single transformer, (\textbf{fsaregexp} ), that converts an \textsf{ndfa} to a regular expression. There is a single observer, (\textbf{printable-regexp} r), that takes as input a regular expression and that returns a string representing the given regular expression.

\section{The \textsf{FSM} Library in Practice}
This section presents examples of the \textsf{FSM} library in practice using problems that students have faced in an introductory formal languages course. The examples highlight how students and instructors make the use of the library relevant to both and how immediate feedback enhances the learning experience.

\subsection{Write a Program to Recognize a Regular Language}
\label{dfa}
Let . Consider the problem of recognizing the regular language:
\begin{quote}
 \emph{w starts and ends with an a}.
\end{quote}
It is not uncommon for a student to submit the automaton in Figure \ref{SampleDFA1} which is clearly incorrect and earns the student a poor grade. The poor grade usually leads a student to experience frustration and apathy for the material. This frustration stems from realizing that the design has what they consider a small bug that experimentation and immediate feedback easily uncovers.

\newcommand{\DFA}{
\begin{psmatrix}[rowsep=.5cm,colsep=.2cm,mnode=circle,fillstyle=solid,fillcolor=LightBlue]
             & & & & & & & & [name=N4] ds  \\
             & & & & [name=N1] q \\
             & & & & & & & & [name=N2] q  & & & & & &  [name=N3] q\\
             & & & &
\end{psmatrix}

\psset{arrows=->,linecolor=black,arcangle=30,arrowsize=4pt
2,labelsep=2pt}}

\newcommand{\DFAc}{
\begin{psmatrix}[rowsep=.5cm,colsep=.2cm,mnode=circle,fillstyle=solid,fillcolor=LightBlue]
             & & & & & & & & [name=N5] ds  \\
             & & & & [name=N6] q \\
             & & & & & & & & [name=N7] q  & & & & & &  [name=N8] q\\
             & & & &
\end{psmatrix}

\psset{arrows=->,linecolor=black,arcangle=30,arrowsize=4pt
2,labelsep=2pt}}

\begin{figure}[t]
\begin{minipage}[b]{0.5\linewidth} \begin{tabular}{l}
  \DFA
  \rput(-4.47,2.1){\psframebox*[framearc=.1]{}}
  \cnode(-.45,0.86){.28}{""}
  \ncarc {N1}{N4}
  \Aput{b}
  \ncarc{N2}{N3}
  \Aput{a}
  \ncarc{N3}{N2}
  \Aput{b}
  \psset{arrows=<-}
  \ncarc{N2}{N1}
  \Aput{a}
  \nccircle{->}{N4}{.35}
  \nbput{a,b}
  \nccircle{->}{N2}{.35}
  \nbput{b}
  \nccircle{->}{N3}{.30}
  \nbput{a}
\end{tabular}
\caption{Buggy Finite-State Automaton for .}
\label{SampleDFA1}
\end{minipage}
\begin{minipage}[b]{0.5\linewidth} \begin{tabular}{l}
  \DFAc
  \rput(-4.48,2.1){\psframebox*[framearc=.1]{}}
  \cnode(-2.37,0.86){.28}{""}
  \ncarc {N6}{N5}
  \Aput{b}
  \ncarc{N7}{N8}
  \Aput{b}
  \ncarc{N8}{N7}
  \Aput{a}
  \psset{arrows=<-}
  \ncarc{N7}{N6}
  \Aput{a}
  \nccircle{->}{N8}{.30}
  \nbput{b}
  \nccircle{->}{N5}{.35}
  \nbput{a,b}
  \nccircle{->}{N7}{.35}
  \nbput{a}
\end{tabular}
\caption{Correct Finite-State Automaton for .}
\label{SampleDFA2}
\end{minipage}
\end{figure}


If the student has access to the \textsf{FSM} library, an implementation of their design looks as follows:
\begin{quote}
\begin{verbatim}
(define sol1-dfa (make-dfa  '(q0 q1 q2 ds)
                             '(a b)
                             'q0
                             '(q2)
                             '((q0 a q1)
                               (q0 b ds)
                               (q1 a q2)
                               (q1 b q1)
                               (q2 a q2)
                               (q2 b q1)
                               (ds a ds)
                               (ds b ds))))
\end{verbatim}
\end{quote}
The student can now test this machine as follows:
\begin{quote}
\begin{verbatim}
> (test-sm sol1-dfa)
'(((b b a a b b b b a b a b b b b a b) reject)
  ((b a b a a a b a b a a a a a b b b a b) reject)
  ((a a b a b a a b a a b b b b) reject)
  ((a b a a b b a b b b a) accept)
  ((a b b a) accept)
  ...
  ((a) reject)
  ...
  ((b a a a b b b b a a b b b a b) reject)
  ((b a b a a b b b) reject))
\end{verbatim}
\end{quote}
The tests reveal that the word \textsf{'(a)} is rejected, but this word is an element of . The student can now refine the solution to the one displayed in Figure \ref{SampleDFA2}. The corresponding implementation is:
\begin{quote}
\begin{verbatim}
(define sol1-dfa (make-dfa  '(q0 q1 q2 ds)
                             '(a b)
                             'q0
                             '(q1)
                             '((q0 a q1)
                               (q0 b ds)
                               (q1 a q1)
                               (q1 b q2)
                               (q2 a q1)
                               (q2 b q2)
                               (ds a ds)
                               (ds b ds))))
\end{verbatim}
\end{quote}

This example may seem deceptively simple, but it does have a significant impact on a student's attitude. The immediate feedback provided by the \textsf{FSM} library assists students to find errors in their designs and to avoid the frustration of receiving a poor grade. Furthermore, the experience encourages both the student and the instructor resulting in an enhanced learning experience by eliminating the need to spend time on low-level bugs and allowing for more time to be dedicated to harder material.

\subsection{The Reverse of a Regular Language}
Proving that the reverse of a regular language, , is regular requires a constructive proof that students in an introductory formal languages course are commonly asked to write. Typically, students are confused about how to tackle this kind of problem. They understand that they must show how to build a finite-state automaton, , for , but feel frustrated if their algorithm is not correct. In a programming course, students can implement and experiment with their proposed solution. The same ought to be true for a course in formal languages and this is made possible by \textsf{FSM}.

\newcommand{\reverse}{
\begin{psmatrix}[rowsep=.5cm,colsep=.2cm,mnode=circle,fillstyle=solid,fillcolor=LightBlue]
             [name=N10] q & & & & &  [name=N11] q  & & & & & &  [name=N12] q & & & & & &  [name=N13] ds \\
             & & & & & & & & & & & & & & & & & & & & & & &
\end{psmatrix}

\psset{arrows=->,linecolor=black,arcangle=30,arrowsize=4pt
2,labelsep=2pt}}
\begin{figure}[t]
\begin{center}
\begin{tabular}{l}
  \reverse
  \rput(-7.8,0.85){\psframebox*[framearc=.1]{}}
  \cnode(-3.55,.85){.28}{""}
  \ncline{N11}{N12}
  \Aput{a}
  \ncline{N12}{N13}
  \Aput{a}
  \ncline{N10}{N11}
  \Aput{b}
  \psset{arrows=<-}
  \ncarc{N13}{N11}
  \Aput{b}
  \nccircle{->}{N10}{.30}
  \nbput{a}
  \nccircle{->}{N12}{.30}
  \nbput{b}
  \nccircle{->}{N13}{.30}
  \nbput{a,b}

\end{tabular}
\caption{A \textsf{dfa} for .}
\label{Ldfsa}
\end{center}
\end{figure}

\newcommand{\reversec}{
\begin{psmatrix}[rowsep=.7cm,colsep=.2cm,mnode=circle,fillstyle=solid,fillcolor=LightBlue]
             & & & & [name=N14]  \\
             & & & & [name=N18] q & & & & &  [name=N17] q  & & & & & &  [name=N15] q & & & & [name=N16] ds \\
             & & & & & & & & & & & & & & & & & & & & & & &
\end{psmatrix}

\psset{arrows=->,linecolor=black,arcangle=30,arrowsize=4pt
2,labelsep=2pt}}

\newcommand{\reversef}{
\begin{psmatrix}[rowsep=.7cm,colsep=.2cm,mnode=circle,fillstyle=solid,fillcolor=LightBlue]
             & & & & & & & & [name=N22]  \\
            & & & &  & & & & [name=N19] q & & & & &  [name=N20] q  & & & & & &  [name=N21] q
           \\
             & & & & & & & & & & & & & & & & & & & & & & &

\end{psmatrix}

\psset{arrows=->,linecolor=black,arcangle=30,arrowsize=4pt
2,labelsep=2pt}}


\begin{figure}[t]
\begin{minipage}[b]{0.5\linewidth} \begin{tabular}{l}
  \reversec
  \cnode(-6.4,1.055){.28}{""}
  \rput(-7.01,2.6){\psframebox*[framearc=.1]{}}
  \ncline{N17}{N18}
  \nbput{b}
  \ncline{N14}{N15}
  \Aput{}
  \ncline{N15}{N17}
  \nbput{a}
  \ncline{N16}{N15}
  \Aput{a}
\ncarc{N16}{N17}
  \Aput{b}
  \nccircle{->}{N16}{.30}
  \nbput{a,b}
  \nccircle{->}{N15}{.30}
  \nbput{b}
  \nccircle{->}{N18}{.30}
  \nbput{a}
\end{tabular}
\caption{ from Theorem Version I.}
\label{reva}
\end{minipage}
\begin{minipage}[b]{0.5\linewidth} \begin{tabular}{l}
  \reversef
  \cnode(-4.875,1.055){.28}{""}
  \rput(-5.5,2.6){\psframebox*[framearc=.1]{}}
  \ncline{N20}{N19}
  \nbput{b}
  \ncline{N22}{N21}
  \Aput{}
  \ncline{N21}{N20}
  \nbput{a}
\nccircle{->}{N21}{.30}
  \nbput{b}
  \nccircle{->}{N19}{.30}
  \nbput{a}
\end{tabular}
\caption{ from Theorem Version II.}
\label{revb}
\end{minipage}
\end{figure}


A common proposed solution is to build  from a deterministic finite-state automaton, , for . Intuitively,  has 's set of states and a new starting state, 's alphabet, 's transition rules reversed,  -transitions from the new starting state to each final state of , and the starting state of  as its only final state. More formally students define  in their proposed version I of the theorem as follows:
\begin{quote}
, where
\begin{itemize}
  \item  the states of 
  \item  is the unique symbol for the starting state of 
  \item  the alphabet of 
  \item  contains two types of rules:
  \begin{enumerate}
     \item (, , ) such that  the final states of 
     \item (, , ) such that (, , ) 
  \end{enumerate}
  \item  is the starting state of 
\end{itemize}
\end{quote}

The above algorithm is implemented and tested by students using \textsf{FSM}. Consider applying the proposed theorem to a deterministic finite-state automaton for  depicted in Figure \ref{Ldfsa}. The resulting \textsf{ndfa} is depicted in Figure \ref{reva}. Students can observe that the state  is inaccessible and, therefore, ought not be part of the transformed machine. This observation suggests a refinement that eliminates the dead states of  and any transitions involving a dead state. Using this refinement, the resulting \textsf{ndfa} for  is given in Figure \ref{revb}. An \textsf{FSM} implementation of this second version of the proposed theorem is displayed in Figure \ref{mrev}. Once testing makes students confident that their solution is correct, they can proceed to write the formal proof.

\begin{figure}[t]
\begin{verbatim}
  ; dfa --> ndfa
  (define (reverse-dfa m1)

    ;symbol (listof rules)--> boolean
    (define (deadstate? s rules)
      (let  ((fromrules (filter (lambda (r) (eq? s (smrule-fromstate r)))
                                rules)))
             (andmap (lambda (r) (eq? s (smrule-tostate r))) fromrules)))

    (let* ((newfinal (sm-getstart m1))
           (mstates (sm-getstates m1))
           (newStart(gen-symbol 'S mstates))
           (deadsts (remove-duplicates
                      (filter (lambda (a) (deadstate? a (sm-getdeltas m1)))
                              mstates)))
           (newQ (cons newStart (filter (lambda (q) (not (member q deadsts)))
                                mstates)))
           (addedrules (map (lambda (s) (list newStart EMP s))
                            (sm-getfinals m1)))
           (changedrules
             (map reverse
                  (filter (lambda (r) (and (not (member (smrule-tostate r)
                                                        deadsts))
                                           (not (member (smrule-fromstate r)
                          deadsts))))
                          (sm-getdeltas m1)))
          (newrules (append addedrules changedrules)))
      (make-ndfa newQ (sm-getsigma m1) newStart (list newfinal) newrules)))
\end{verbatim}
\caption{Proposed solution to build }
\label{mrev}
\end{figure}

Observe that in \textsf{FSM} new constructors are easily defined by students by simply writing a function. The code in Figure \ref{mrev} only uses primitive functions on lists, -expressions, and list-based higher-order functions (e.g., \textsf{map}, \textsf{filter}, and \textsf{andmap}). Thus, the coding of this constructor ought to be well within the reach of both advanced undergraduate and beginning graduate Computer Science students. Students uncomfortable or unfamiliar with -expressions and higher-order functions can, instead, omit their use by explicitly defining functions for -expressions and by explicitly defining recursive functions to perform the necessary list-processing done by the higher-order functions.


\subsection{Determining if a Context-Free Language is Empty}

\begin{figure}
\begin{verbatim}
  ; cfg --> boolean
  (define (Lcfg-isempty? g)
    ; cfg-rule (listof symbol) --> (listof cfg-rule)
    (define (only-accum-elems? rule accum)
      (and (not (member (cfg-rule-lhs rule) accum))
           (andmap (lambda (s) (member s accum)) (cfg-rule-rhs rule))))
    ; (listof cfg-rules) nonterminal (listof symbol) --> boolean
    (define (isempty? rls S accum)
      (cond [(member S accum) #f]
            [else
             (let ((newmembers (map cfg-rule-lhs
                                    (filter (lambda (r)
                                              (only-accum-elems? r accum))
                                            rls))))
               (cond [(empty? newmembers) #t]
                     [else (isempty? rls S (append newmembers accum))]))]))
    (let ((rls (cfg-get-the-rules g))
          (S (cfg-get-start g))
          (sigma (cfg-get-alphabet g)))
      (isempty? rls S (cons EMP sigma))))
\end{verbatim}
\caption{A Function to Determine if the Language of a CFG is Empty.}
\label{cfge}
\end{figure}

Students also face exercises to prove that a problem is decidable. If a problem is decidable, then there is an algorithm to determine if an instance of a given problem fulfills stipulated conditions. Students can propose an algorithm for decidability, but without the ability to test their solution they remain unsure about its validity. Testing their algorithm increases their confidence and brings their Computer Science education as programmers to bear in a formal languages course. We do not want students, however, to implement decidability algorithms using Turing machines. That would simply be too unwieldy. Instead, students ought to be able to use a library like \textsf{FSM} to implement and test their algorithms.

For example, consider the problem of deciding if the language, , of a context-free grammar, , is empty. Students realize that  is not empty if there exists a derivation for any word formed by elements of the alphabet of . Usually, they must be guided to realize that what they need is an algorithm to detect the existence of a derivation by creating any backward derivation to 's starting symbol starting from the elements of the alphabet of  and . The algorithm accumulates  and the left hand sides of rules (i.e., nonterminal symbols) whose right hand sides only contain symbols in the accumulator. If at any step, 's starting symbol is in the accumulator then  is not empty. If at any step, there are no new symbols to add to the accumulator then  is empty. Otherwise, the new symbols are added to the accumulator and the process recursively proceeds.

Figure \ref{cfge} displays the implementation of this algorithm using the \textsf{FSM} library. Notice, that this code demonstrates that observers are easily added by simply writing a function. This observer only utilizes \textsf{FSM} provided functions and list-processing functions. Thus, once again, putting it well within the grasp of Computer Science graduate and advanced undergraduate students. Nonetheless, students tend to make mistakes at first and their algorithm requires refinement. The most common mistake is to not include  in the initial value of the accumulator which is easily discovered once implemented.

\subsection{Computing with Turing Machines}
Although Turing machines are not the most attractive programming abstraction, it is important for students to understand their power and the reason the abstraction is less than attractive. The best way for students to begin to understand the power of Turing machines is to have them design Turing machines. Implementing formal descriptions of Turing machines in \textsf{FSM} is similar to developing the finite-state automatons in Section \ref{dfa}. Such descriptions are best for language recognizers and operations that do not involve assignment (i.e., altering of the tape). For instance, the following Turing machine moves the head to the right of the current position of the head.

\begin{verbatim}
(define RI (make-tm  '(s h)
                     '(I add1 sub1)
                      (list
                       (list (list 's 'I) (list 'h RIGHT))
                       (list (list 's 'add1) (list 'h RIGHT))
                       (list (list 's 'sub1) (list 'h RIGHT))
                       (list (list 's BLANK) (list 'h RIGHT)))
                      's
                      '(h)))
\end{verbatim}

Computations with Turing machines, however, may require assignment and, thus, care during their development. In such a setting, offering abstractions is critical  to keep students engaged. Many textbooks on formal languages develop a notation that is graphical and more transparent. In essence, the notation connects Turing machines, not states, using conditional branches and gotos. This allows for progressively more complex Turing machines to be designed from simpler Turing machines.

Consider the student having to add or subtract 1 from a non-zero unary number. The first step is to state the precondition and the postcondition for the Turing Machine. For example, the algorithm can be designed assuming the machine starts in the following configuration: (   \underline{}), where  is either \textsf{add1} or \textsf{sub1},  denotes a blank space, and the head is on the first blank after the number. The machine stops in the following configuration: (   \underline{}), where  is the result of the computation. Assume that in addition to \textsf{RI} above the following simpler machines are also defined:
\begin{quote}
\begin{description}
  \item [LI] Moves the head one space to the left.
  \item [I] Writes I to the tape.
  \item [BL] Writes  to the tape.
  \item [RB] Moves the head to the first blank to the right of the head.
  \item [LB] Moves the head to the first blank to the left of the head.
\end{description}
\end{quote}

\begin{figure}[t]
1.5cm]
\Rnode{f}{RB\ I\ RI}
\end{array}
\psset{nodesep=5pt,arrows=->}
\everypsbox{\scriptstyle}
\ncLine{d}{e}\Aput{sub1}
\ncLine{d}{f}\Bput{add1}

\setlength{\arraycolsep}{1cm}
\def\tX{\tilde{\tilde{X}}}
\begin{array}{cc}
\Rnode{a}{LB\ LI} & \Rnode{b}{RB\ RB\ LI\ BL } \
\caption{Turing Machine to add or subtract 1 from a non-zero unary number.}
\label{correcttm}
\end{figure}
\begin{verbatim}
(define addorsub (combine-tms (list LB LI (list BRANCH (list 'sub1 RB RB LI BL)
                                                       (list 'add1 RB RB I RI)))
                              '(I sub1 add1)))
\end{verbatim}
The tests are repeated and the student gets the following results:
\begin{quote}
 (apply-sm  (list add1 \_ I I I I \_) 6)\\
(tmconfig 'h 7 '(add1 \_ I I I I I \_))\\
 (apply-sm  (list sub1 \_ I I I I I I I \_) 9)\\
(tmconfig 'h 8 '(sub1 \_ I I I I I I \_ \_))
\end{quote}
With successful tests, the student can now proceed to develop arguments for correctness. This development establishes that the feedback provided by testing Turing machines is an important part of the design process in a formal languages course.

\section{Related Work}
JFLAP \cite{Rodger} was designed to experiment with state machines and grammars as well as to experiment with constructive proofs. JFLAP allows the user to create and simulate several types of state machines, to create and parse strings in the language of a grammar, and to experiment with proof constructions such as converting a nondeterministic finite automaton to a deterministic finite automaton and then to a regular expression or regular grammar \cite{Rodger}. A study concluded that students felt more engaged and enjoyed a formal languages course more when using JFLAP \cite{Rodger}. JFLAP provides all the primitive and transformation constructors found in \textsf{FSM}. In contrast, however, the graphical nature of JFLAP does not offer the ability to easily add new observers and constructors to the software neither does JFLAP generate random testing.

The jFAST \cite{White} library assists beginners to design state machines. It uses a graphical interface just as JFLAP, but unlike JFLAP it provides no functionality for regular expressions and grammars. Like JFLAP and, in contrast to \textsf{FSM}, there is no support for students to add the constructive algorithms they develop and prove. The FSA Simulator allows the user to work and experiment with finite-state automata offering the ability to compare the languages of two finite-state automatons \cite{Grinder}. That is, it provides testing facilities for the equivalence of two finite-state automatons as \textsf{FSM}. The FSA comparison feature lets the software give students feedback about the accuracy of their work much as intended by \textsf{FSM} for all types of state machines. RegeXeX \cite{Brown} is an interactive system to write regular expressions. In contrast to \textsf{FSM}, it provides testing facilities for regular expressions. The feedback provided by RegeXeX includes strings that ought to be accepted and ought to be rejected much like \textsf{FSM} provides testing facilities for state machines.

\section{Conclusions and Future Work}
The \textsf{FSM} library provides users the necessary facilities to design and experiment with state machines, grammars, and regular expressions. It supports the view that the existence of a machine or grammar is proven by developing a constructive proof. This means that the proof presents an algorithm that can be implemented using \textsf{FSM}. Students and instructors no longer have to rely solely on paper-and-pencil traces to build confidence or discover bugs in a design. Instead, they can use \textsf{FSM} testing facilities to generate tests that provide immediate feedback. This leads students to actively reason and learn about formal languages as well as to reinforce their Computer Science education by implementing and developing unit tests for their constructive algorithms. The library has received positive feedback by students and has provided the examples presented in the article. It is our expectation that the proposed approach, namely teaching the theory of computation with tools to build computations, be widely adopted by Computer Science programs.

Future work includes expanding the library to include more constructors particularly those for state minimization. We will also extend the library to include a graphical interface. Unlike the interfaces described in the related work, we do not wish to have students create machines and grammars using a graphical interface. Instead, our goal is to have students continue to write code to create machines and grammars that are then rendered using graphics to animate execution and visualize their structure. Additionally, more support for regular expressions and extensions of Turing machines will be offered. The latter machines, although not computationally more powerful than a standard Turing Machine, are likely to make certain designs easier to implement by students. Finally, a goal is to convert the library into a pedagogy-friendly embedded DSL (e.g., using Racket's hygienic macros \cite{AutomataMacros}) where it is possible to machine check the proofs (e.g., using tools like DrACuLa \cite{Eastlund} and Coq \cite{Coq}).


\bibliographystyle{eptcs}
\bibliography{fsm}
\end{document}
