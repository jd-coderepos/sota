\documentclass{sig-alternate}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{float}
\usepackage{pgf}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{calc} \newcommand{\argmin}{\operatornamewithlimits{argmin}}
\newcommand{\argmax}{\operatornamewithlimits{argmax}}




\usepackage{color}
\usepackage{bbm}
\usepackage{xspace}


\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{lemma*}{Lemma}
\newtheorem{example}[theorem]{\noindent Example}{}
\newtheorem{exercise}[theorem]{\noindent Exercise}{}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{model}[theorem]{Model}
\newtheorem{hypothesis}[theorem]{Hypothesis}
\newtheorem{question}[theorem]{Question}
\newtheorem{remark}[theorem]{Remark}

\newcommand {\lra}   {\longrightarrow}
\newcommand {\Lra}   {\Longrightarrow}

\newcommand {\I}   {\mathbb I}
\newcommand {\Id}   {\mathbbm 1}
\newcommand {\R}   {\mathbb R}
\newcommand {\K}   {\mathbb K}
\newcommand {\Kbar}   {\overline{\mathbb K}}
\newcommand {\Qbar}   {\overline{\mathbb Q}}
\newcommand {\C}   {\mathbb C}
\newcommand {\A}   {\mathbb A}
\newcommand {\D}   {\mathbb D}
\newcommand {\F}   {\mathbb F}
\newcommand {\Z}   {\mathbb Z}
\newcommand {\N}   {\mathbb N}
\newcommand {\Q}   {\mathbb Q}
\newcommand {\Sk}   {\mathbb{S}_k}
\newcommand {\Sg}   {\mathbb{S}}
\newcommand {\T}   {\mathbb T}
\renewcommand {\P}   {\mathbb P}
\newcommand{\calB}   {\mathcal B}
\newcommand{\calC}[0]{\mathcal C} 
\newcommand{\calG}   {\mathcal G}
\newcommand{\calR}   {\mathcal R}
\newcommand{\calT}   {\mathcal T}
\newcommand{\pt}[1]{\ensuremath{\mathbf{ #1}}}
\newcommand{\norm}[1]{\ensuremath{\| #1 \|}}
\newcommand{\sqrfree}{\tmop{sqrfree}}
\newcommand{\Lc}{\tmop{Lc}}
\newcommand{\lcm}{\tmop{lcm}}
\newcommand{\cont}{\tmop{Cont}}
\newcommand{\prim}{\tmop{Primpart}}


\newcommand{\OO}{\ensuremath{{{O}}}}
\newcommand{\OB}{\ensuremath{{{O}_B}}}
\newcommand{\sO}{\ensuremath{\widetilde{{O}}}}
\newcommand{\sOB}{\ensuremath{\widetilde{{O}}_B}}
\newcommand{\bitsize}{\ensuremath{\mathcal{L}}}

\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand {\V}   {\mbox{{\boldmath V}}}
\newcommand{\op}[1]{#1}

\newcommand{\LL}{\ensuremath{\mathcal{L}}}
\newcommand{\MM}{\ensuremath{\mathrm{M}}}

\newcommand{\maple}{\textsc{maple}\xspace}
\newcommand{\our}{\textsc{isotop}\xspace}
\newcommand{\rs}{\textsc{rs}\xspace}


\newcommand{\makeremark}[2]{
  \newcommand{#1}[1]
    {
\color{blue}
      \textsc{#2: }
     ##1
     
    \color{black}
    }
}    



\newcommand{\red}[1]{\color{red}#1\color{black}\xspace}
\newcommand{\blue}[1]{\color{blue}#1\color{black}\xspace}
\renewcommand{\red}[1]{#1\xspace}
\renewcommand{\blue}[1]{#1\xspace}

\makeremark{\SL}{SL}
\makeremark{\FR}{Fabrice says}
\makeremark{\MP}{Marc says}
\makeremark{\ET}{Elias says}
\makeremark{\LP}{Luis shouts}
\makeremark{\YB}{Yacine says}

\definecolor{1ST}{rgb}{1,0,0}\definecolor{2ND}{rgb}{1,0.5,0}\definecolor{3RD}{rgb}{1,0,1}\newcommand{\colorF}[1]{{\color{1ST} #1}}
\newcommand{\colorM}[1]{{\color{1ST} #1}}
\newcommand{\colorS}[1]{{\color{1ST} #1}}
\newcommand{\colorY}[1]{{\color{1ST} #1}}
\newcommand{\colorFM}[1]{{\color{2ND} #1}}
\newcommand{\colorFS}[1]{{\color{2ND} #1}}
\newcommand{\colorFY}[1]{{\color{2ND} #1}}
\newcommand{\colorMF}[1]{{\color{2ND} #1}}
\newcommand{\colorMS}[1]{{\color{2ND} #1}}
\newcommand{\colorMY}[1]{{\color{2ND} #1}}
\newcommand{\colorSF}[1]{{\color{2ND} #1}}
\newcommand{\colorSM}[1]{{\color{2ND} #1}}
\newcommand{\colorSY}[1]{{\color{2ND} #1}}
\newcommand{\colorYF}[1]{{\color{2ND} #1}}
\newcommand{\colorYM}[1]{{\color{2ND} #1}}
\newcommand{\colorYS}[1]{{\color{2ND} #1}}
\newcommand{\colorFMS}[1]{{\color{3RD} #1}}
\newcommand{\colorFMY}[1]{{\color{3RD} #1}}
\newcommand{\colorFSM}[1]{{\color{3RD} #1}}
\newcommand{\colorFSY}[1]{{\color{3RD} #1}}
\newcommand{\colorFYM}[1]{{\color{3RD} #1}}
\newcommand{\colorFYS}[1]{{\color{3RD} #1}}
\newcommand{\colorMFS}[1]{{\color{3RD} #1}}
\newcommand{\colorMFY}[1]{{\color{3RD} #1}}
\newcommand{\colorMSF}[1]{{\color{3RD} #1}}
\newcommand{\colorMSY}[1]{{\color{3RD} #1}}
\newcommand{\colorMYF}[1]{{\color{3RD} #1}}
\newcommand{\colorMYS}[1]{{\color{3RD} #1}}
\newcommand{\colorSFM}[1]{{\color{3RD} #1}}
\newcommand{\colorSFY}[1]{{\color{3RD} #1}}
\newcommand{\colorSMF}[1]{{\color{3RD} #1}}
\newcommand{\colorSMY}[1]{{\color{3RD} #1}}
\newcommand{\colorSYF}[1]{{\color{3RD} #1}}
\newcommand{\colorSYM}[1]{{\color{3RD} #1}}
\newcommand{\colorYFM}[1]{{\color{3RD} #1}}
\newcommand{\colorYFS}[1]{{\color{3RD} #1}}
\newcommand{\colorYMF}[1]{{\color{3RD} #1}}
\newcommand{\colorYMS}[1]{{\color{3RD} #1}}
\newcommand{\colorYSF}[1]{{\color{3RD} #1}}
\newcommand{\colorYSM}[1]{{\color{3RD} #1}}





\newcommand{\func}[1]{\textsc{#1}}
\newcommand{\ideal}[1]{\langle #1 \rangle }

\newcommand{\shutup}[1]{}

\renewcommand{\leq}{\leqslant}  \renewcommand{\geq}{\geqslant}

\makeatletter
\def\cramped                           {\parskip0pt\@topsep0pt       \itemsep0pt\parsep0pt
}        
\makeatother


\usepackage{stmaryrd}
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\newcommand{\Isotop}{{\text{\scshape{Isotop}}}} \newcommand{\IsotopDeux}{{\text{\scshape{Isotop2}}}}    
\usepackage{verbatim}
\newcommand {\comp}{\ensuremath{\sO_B(d^8+d^7\tau+d^5\tau ^2)}}


\title{Improved  algorithm for computing separating linear forms for bivariate systems}
\numberofauthors{5}
\author{
\alignauthor
Yacine Bouzidi\\
       \affaddr{INRIA Nancy Grand Est}\\
       \affaddr{LORIA, Nancy, France}\\
        \email{Yacine.Bouzidi@inria.fr}
\alignauthor
Sylvain Lazard\\
      \affaddr{INRIA Nancy Grand Est}\\
       \affaddr{LORIA, Nancy, France}\\
        \email{Sylvain.Lazard@inria.fr}
\alignauthor 
Guillaume Moroz\\
      \affaddr{INRIA Nancy Grand Est}\\
       \affaddr{LORIA, Nancy, France}\\
         \email{Guillaume.Moroz@inria.fr}
\and
\alignauthor 
Marc Pouget\\
      \affaddr{INRIA Nancy Grand Est}\\
       \affaddr{LORIA, Nancy, France}\\
         \email{Marc.Pouget@inria.fr}
\alignauthor 
Fabrice Rouillier\\
       \affaddr{INRIA Paris-Rocquencourt  IMJ, Paris, France}\\
       \email{Fabrice.Rouillier@inria.fr}
}

\begin{document}
\conferenceinfo{ISSAC'14}{July 23--25, 2014, Kobe, Japan.}
\CopyrightYear{2014}
\crdata{978-1-4503-2501-1/14/07}
\maketitle
\begin{abstract}
We address the problem of computing a  linear separating form of  a system of two bivariate
polynomials with integer coefficients, that is a linear combination of the variables that takes
different values when evaluated at the distinct  solutions of the system.
The computation of such linear forms is at the core of most
  algorithms that solve algebraic systems by computing rational
  parameterizations of the solutions and this  is the bottleneck of these algorithms in terms of worst-case bit
  complexity.
We present for this problem a new algorithm of worst-case bit complexity 
where  and  denote respectively the maximum degree and bitsize of the input
(and where  refers to the complexity where
  polylogarithmic factors are omitted and  refers to the bit complexity).
This
algorithm simplifies and  decreases by a factor  the worst-case
bit complexity presented for this problem  by Bouzidi et al.
\blue{\cite{bouzidiJSC2014a}}.
This algorithm also yields, for this problem, a probabilistic Las-Vegas algorithm  of expected bit complexity  .
\end{abstract}





\section{Introduction}\label{sec:intro}

A classical approach for solving a system of
polynomials with a finite number of solutions is to compute 
a rational parameterization of its solutions. 

A rational parameterization is a representation of the (complex) solutions 
by a set of univariate polynomials and associated rational one-to-one mappings that send
the roots of the univariate polynomials to the solutions of the system.
Such representations enable to reduce computations on the system to
computations with univariate polynomials and thus ease, for instance, the
isolation of the solutions or the evaluation of other polynomials at the
solutions.

At the core of the algorithms that compute such 
paramete\-rizations (see for example
\cite{ABRW,bostan2003fast,det-jsc-2009,GLS01,VegKah:curve2d:96,Rou99} and references therein), is
the computation of a so-called \emph{linear separating form} for the solutions, that is  a linear combination of the coordinates that takes different values when evaluated at different solutions of the system.
Since a random linear form is
separating with probability one, 
probabilist Monte-Carlo algorithms can overlook this issue.
However, when it comes to deterministically computing a linear separating
  form, or even to check that an arbitrary chosen form is separating, this, surprisingly, turns out to be the bottleneck in the computation of rational parameterizations, in particular for bivariate systems as discussed below. This explains why, among the many algorithms that compute rational parameterizations, seldom search deterministically for a separating linear form. 

Considering systems of two bivariate polynomials of
  total degree bounded by  with integer coefficients of bitsize bounded by
  , one approach for computing a separating linear form together with a rational parameterization of the solutions has been presented by Gonzalez-Vega and El Kahoui \cite{VegKah:curve2d:96} and its bit complexity analyzed in~\cite{det-jsc-2009}. The analysis of this approach shows a bit complexity in  for computing a separating form and a bit complexity in  for computing the corresponding rational parameterization. The computation of a separating linear form was thus the bottleneck in the computation of the rational parameterization.  This is still true even
  when considering the additional phase of computing isolating boxes of the
  solutions (from the rational parameterization), which state-of-the-art
  complexity is in 
   
\blue{\cite[Prop. 35]{bouzidiJSC2014a}}.



More recently, Bouzidi et al.~\blue{\cite{bouzidiJSC2014a}} presented a new
algorithm for computing a separating linear form that reduces the previous bit complexity to
.
The same authors also showed that, given such a
separating linear form, an
alternative rational parameterization called RUR \cite{Rou99} can be computed using
 bit operations~\blue{\cite[Thm. 22]{bouzidiJSC2014a}}
and that isolating boxes
of the solutions can be computed from this RUR in  \cite[Thm. 6.1.2]{bouzidi:thesis}.
Consequently, despite the complexity improvement brought to the separating form computation, this step was still the bottleneck in the computation of a rational parameterization of a bivariate system and more generally in the whole solving process, i.e. including the numerical isolation phase. 


In addition, although the problem of searching deterministically for a separating form is interesting from the theoretical point of view, in practice, a preferable approach would be to design a Las-Vegas algorithm that chooses randomly  a linear form and then checks that the latter is separating. However up to now, the problem of checking that an arbitrary linear form is separating has not been shown to be easier (at least in terms of asymptotic bit complexity) than the deterministic computation of a separating linear form.


\smallskip

\noindent{\bf Main results.}\quad
Our main contribution is a new deterministic algorithm of worst-case bit
complexity  for computing a separating linear form of a zero-dimensional system of two
bivariate polynomials of total degree at most  and integer coefficients of
bitsize at most  (Theorem~\ref{thm:final}). 

This algorithm is simpler than the one presented by Bouzidi et al.~\blue{\cite{bouzidiJSC2014a}} 
and it
decreases by a factor  its complexity. This 
brings the complexity of solving bivariate systems by computing a rational parameterization to . 

A second contribution is a Las-Vegas algorithm for computing a separating linear form with an expected bit complexity in  (Theorem~\ref{thm:las-vegas}). This Las-Vegas algorithm stems naturally from the previous algorithm replacing the deterministic version of the univariate gcd computation by a Las-Vegas one.
Recall that, \blue{in Las-Vegas algorithms, the result is always correct and only the running time is probabilistic.}


 \section{Overview}
 \label{sec:overview}

Our algorithm is based on the one presented by Bouzidi et
al.  \blue{\cite{bouzidiJSC2014a}} on the same problem. For clarity, we briefly
recall the essence of that algorithm. It  first computes the number of distinct (complex) solutions of the input system  as well as a
prime number  such that the input system considered modulo  has the same number of
distinct solutions. This first step has worst-case bit complexity . 
All polynomials and computations are thereafter considered modulo
. The algorithm then considers iteratively
a candidate separating element  with an integer   incrementing  from 0. 
The input polynomials are considered through a  \blue{shearing} of
the coordinate system , and the degree of the squarefree
part of their resultant (with respect to ) is computed; 
in other words, the algorithm computes the number of
distinct solutions after  projection along the direction of the line . The algorithm stops
when a value  is found such that the number of distinct projected solutions equals that of the
system. This step trivially computes a separating element  of the input system considered modulo
 but the proof that this form is also separating of the  input system is not straightforward. 
This second step of the algorithm is presented in \blue{\cite{bouzidiJSC2014a}} with the same 
worst-case bit complexity as the first step  but we show \blue{in Section~\ref{sec:sep-form}} that it is straightforward to slightly  modify it so
that it has complexity \blue{.}

We present in this paper an improvement of the above algorithm using the following two
ingredients. First, we
show \blue{in Section~\ref{sec:PQ_curve}}  that computing a separating linear form for a system  is essentially equivalent (in terms of
asymptotic bit complexity) to computing a separating linear form for the critical points of a curve.
Second, 
we present \blue{in Section~\ref{sec:curve}}  a rather simple algorithm of worst-case bit complexity  for computing the number of critical points of a
curve, as well as a prime number  such that the curve modulo  has the same number of
 critical points. In essence, given a curve of equation , this algorithm first computes a subresultant-based
triangular decomposition \cite{VegKah:curve2d:96} of the
system  and the sum of the degrees of the resulting systems; the same
computation is done for the system  and we show that the
difference of these two sums of degrees is equal to the number of critical points of the 
curve . We then perform the same computation modulo some prime numbers  until the same
number of critical points is obtained. Finally, given this number of solutions and a
corresponding prime , we obtain a separating linear form for the input system by  applying  the
\blue{variant presented in Section~\ref{sec:sep-form} of the} algorithm of 
\blue{\cite{bouzidiJSC2014a}} for computing a separating linear form for the critical points of the
curve.





\blue{Furthermore, we show in Section~\ref{sec:Las-Vegas} how this algorithm naturally extends to a Las-Vegas algorithm of
  expected bit complexity .}









\section{Notation and preliminaries}\label{sec:prelim}






We introduce notation and recall some classical material. Most of the material in this section is
taken literally from~\blue{\cite{bouzidiJSC2014a}}. 

 The bitsize of an integer  is the number of bits needed to represent it, that
is  ( refers to the logarithm in base 2). 
The bitsize of a polynomial with integer
coefficients is the \emph{maximum} bitsize of its coefficients. As mentioned
earlier,  refers to the bit complexity and  and  refer to
complexities where polylogarithmic factors are omitted, see \cite[Def.
25.8]{vzGGer2} for details. 




In the following,  is a prime number and we denote by  the quotient
.  We denote by :  the reduction
modulo , and extend this definition to the reduction of polynomials with
integer coefficients.  We denote by  a unique factorization domain,
typically , , ,  or . We also denote by
  a field, typically , , or  and by
  the fraction field of .

For any polynomial , let  denote its leading coefficient
with respect to the variable  and
 its degree with respect to .
For any curve defined by , we call the critical points of  with respect to  or more shortly the critical point of , the points that are solutions of the system .
In this paper, 
the solutions of a system of polynomial are always considered in the algebraic closure of
. 


\smallskip
\noindent{\bf Subresultant sequences.}\quad
We first recall the concept of
\emph{polynomial determinant} of a matrix which is used in the definition of subresultants.
Let  be an  matrix with  and  be the square submatrix of  consisting of the first  columns
and the -th column of , for . The \emph{polynomial determinant} of  is the polynomial
defined as .



Let  and  be two polynomials
in  and assume without loss of generality that . The Sylvester
matrix of  and ,  is the -square matrix whose rows are
 considered as vectors in the basis
. 


\begin{definition}\label{def:sub-resultant}(\cite[\S 3]{Kahoui03}). 
  For , let  be the  matrix obtained from  by deleting the  last rows of the
  coefficients of , the  last rows of the coefficients of , and the 
  last columns.
 
  For , the -th polynomial subresultant of  and
  , denoted by  is the polynomial determinant of
  .  When , the -th polynomial subresultant of  and 
  is .\end{definition}


 has degree at most  in , and the coefficient of its
monomial of degree  in , denoted by , is called the
-th \emph{principal subresultant coefficient}.  Note that  is the \emph{resultant} of  and  with respect to
, which we also denote by .  





\smallskip
We state below a fundamental property of subresultants which is instrumental in
the triangular decomposition algorithm used in Section~\ref{sec:nb-critical}. For
clarity, we state this property for bivariate polynomials  and  in , with .
Note that this property is often stated with a stronger assumption that is that
\emph{none} of the leading terms  and  vanishes.  This
property is a direct consequence of the specialization property of subresultants
and of the gap structure theorem; see for instance \cite[Lemmas 2.3, 3.1 and
Cor. 5.1]{Kahoui03}.

\begin{lemma}\label{lem:fund-prop-subres}
  For any  such that  and  do not both vanish,
  the first  (for  increasing) that does not
  identically vanish is of degree  and it is the gcd of  and
   (up to a nonzero constant in the fraction field of
  ).
\end{lemma}




\noindent{\bf Complexity.}\quad
We recall complexity results, using fast algorithms, on subresultants and
gcd computations. 

\begin{lemma}[{\cite[Prop. 8.46]{BPR06} \cite[\S 8]{Reischert1997} \cite[Cor. 11.15]{vzGGer2}}]
  \label{complexity:subresultant}
  Let  and  be in  ( fixed) with
  coefficients of bitsize at most  
such that their degrees in  are bounded by
   and their degrees in the other variables are bounded by~. 
  \begin{itemize}\cramped
  \item The coefficients of  have bitsize in
    . 
  \item The degree in  of  is at most
    . 
  \item Any subresultant  as well as the sequence of principal subresultant coefficients  can be computed in
 arithmetic operations, 
    and  bit operations. 
\end{itemize}
\end{lemma}    

In the sequel, we often consider the gcd of two univariate polynomials  and
 and the gcd-free part of  with respect to , that is, the divisor 
of  such that . Note that, when ,  the latter is the
squarefree part of~, \blue{provided that the characteristic of the
  coefficient ring is zero or sufficiently large (e.g., larger than the degree of~)}. 

\begin{lemma}[{\cite[Rem. 10.19]{BPR06}}]
\label{complexity:gcd}
  Let  and  in  of degree at most . 
or the gcd-free part of  with respect to  can be computed with
   operations in~.
\end{lemma}




\section{Separating linear form}
\label{sec:sep-form}


As mentioned in the overview, our approach for computing a separating form of a zero-dimensional
system    is similar to the one
in \blue{\cite{bouzidiJSC2014a}} \blue{once we know} the number of distinct solutions and a
so-called lucky prime . \blue{Such a  lucky prime} is, roughly speaking, a prime such
that  \blue{has} the same number of distinct solutions as its 
\blue{image modulo .}
Before presenting Algorithm \ref{alg:sep-elem}, \blue{which computes a separating linear form in
this context,} we introduce  the following notation and  formally define lucky primes.







Given the two input polynomials  and , 
we  consider the ``generic'' change of variables , and define the
 ``sheared'' polynomials , ,
 and their resultant with respect to , 

We introduce the following notation for the leading coefficients of these polynomials; 

Note that these polynomials do not depend on .



\begin{definition}[{\cite[Def. 8]{bouzidiJSC2014a}}]\label{def:lucky-nb-roots}
 A prime number  is said to be {\em \bf lucky} for a zero-dimensional system   if
  and  have the same  number of distinct 
solutions and if    and

\end{definition}


\blue{Note that we consider  in  in Definition~\ref{def:lucky-nb-roots}  because,
in Algorithm~\ref{alg:sep-elem},  we want to ensure
that there exists, for the system  (resp. ), a separating form  {with }
(resp.  in ). The constant 2 in
the bound  is an overestimate, which simplifies some  proofs in \blue{\cite{bouzidiJSC2014a}}.}


Recall that we consider we know the number of distinct (complex) solutions of  system  and a
lucky prime  for that system. 
Algorithm~4 
of~\blue{\cite{bouzidiJSC2014a}} 
computes a separating linear form for  by
considering iteratively linear forms , where  is an integer incrementing from 0
and by  computing the degree of the squarefree part of the reduction modulo  of  until
this degree is equal to the (known) number of distinct solutions of the system and such that
. 

Doing so, the algorithm computes a separating form for the system modulo ,
which, under the hypothesis of the luckiness of , has been proven to be
also separating for the system .  In Algorithm \ref{alg:sep-elem}, we
follow the same approach except that we perform the computations in a slightly
different way\footnote{\small \blue{Namely, in Algorithm \ref{alg:sep-elem}, we
    first compute the reduction modulo  of the input polynomials  and
     (Line~\ref{alg:sep3}) and then, for every value of , the resultant of
    their sheared images through the change of variables 
    (Line~\ref{alg:sep6}), while in \cite[Algorithm~4]{bouzidiJSC2014a}, we
    first compute the reduction modulo  of the resultant  and then,
    for every value of , its specialization at .}} so that the
complexity is in  (instead of  in
\blue{\cite{bouzidiJSC2014a}}).  






\begin{algorithm}[t]
  \caption{Separating form for }
\label{alg:sep-elem}
\begin{algorithmic}[1]
  \REQUIRE{  in  of total degree at most  and defining a zero-dimensional
system,  its number  of  distinct (complex) solutions and a lucky prime  of bitsize
  \blue{}}
  \ENSURE{A separating linear form  for , with }

\STATE Compute  and  
\label{alg:sep1}
\STATE Compute \label{alg:sep2}
\STATE Compute  and \label{alg:sep3}
\STATE \label{alg:sep4}
\REPEAT \label{alg:sep5}
\STATE Compute ,  and their resultant
\label{alg:sep6}
\STATE \label{alg:sep7}Compute the degree  of the squarefree part of 
\STATE  
\UNTIL \footnotemark and  \label{alg:sep9}
\RETURN The linear form \label{alg:sep10}
\end{algorithmic}
\end{algorithm}
\footnotetext{\small  and we consider   in .}



\begin{proposition}\label{prop:sep-elem-comp}
Algorithm~\ref{alg:sep-elem}  computes a separating linear form  for  with
 with a bit complexity  . 
\end{proposition}


\begin{proof}
We first prove the correctness of Algorithm~\ref{alg:sep-elem}  which essentially follows from 
\blue{\cite[Algorithm~4]{bouzidiJSC2014a}}. The latter algorithm computes the degree of the
squarefree part of  until the condition of Line~\ref{alg:sep9} is satisfied, and
it returns the corresponding form .
It is thus sufficient to argue that . 

Denoting by  the morphism that evaluates a polynomial at , and  the
resultant with respect to , we have 

by the specialization property of the resultants 
since the leading coefficients of  and  (with respect to ) do not vanish through
 when the condition  is
satisfied in  Line~\ref{alg:sep9}. Furthermore,  and similarly for , which
implies that the right-hand side  of the equation is equal to . This concludes the proof
of correctness. Note that this correctness includes the property that the output
integer  is less than .




We now prove the complexity of our algorithm. 
It is
straightforward that,  in Line~\ref{alg:sep1}, the sheared polynomials  and
 can be computed  in bit complexity
 and that their bitsizes are in  (see e.g. \blue{\cite[Lemma 7]{bouzidiJSC2014a}}). In Lines \ref{alg:sep2} and \ref{alg:sep3}, the polynomials, in one or two variables, have degree at most  and bitsize . The reduction of each of their  coefficients modulo  can be done in a bit complexity that is softly linear in the
 maximum bitsizes \cite[Thm. 9.8]{vzGGer2}, that is  in a total bit complexity of . 
In Line  \ref{alg:sep6}, computing the polynomials  and  is performed using
 bit operations (see e.g. the proof \blue{\cite[Lemma 7]{bouzidiJSC2014a}}) and similarly for their resultant  according to
Lemma~\ref{complexity:subresultant}. 
In Line  \ref{alg:sep7}, the squarefree part of  can also be computed in 
bit operations by Lemma~\ref{complexity:gcd}, since the resultant has degree .
We have shown that the loop stops with , thus the whole  loop has complexity
, which concludes the proof.
\end{proof}


\section{From a system to a curve}\label{sec:PQ_curve}

In this section, we consider two polynomials  of total degree at most  and maximum bitsize  and show that it is essentially equivalent from an asymptotic worst-case bit
complexity point of view to compute a separating linear form for a system  and  to compute a
separating linear form for the critical points of a curve.  For simplicity, we refer to the latter
as a separating linear form for a curve.  

By definition, the critical points of a
curve of equation  are the solutions of the system , thus
computing a separating linear form for a curve amounts by definition to computing a
separating linear form for a system of two equations. Conversely, a separating linear form for the curve  is also separating for
the system  since any solution of  is also solution of  and of
. 

However, it may happen that the curve  admits no separating linear form even
if  admits one. Indeed,  can be zero-dimensional while  is
not squarefree (and such that the infinitely many critical points cannot be
separated by a linear form).  Nevertheless, if  and  are coprime and
squarefree, then  is squarefree and thus it has finitely many singular
points.
\blue{Still the curve  may contain vertical lines, and thus infinitely many
critical points, but this issue can easily be handled by shearing the coordinate
system.}

\begin{lemma}
\label{lem:system2curve}
Given a zero-dimensional system of two polynomials  and  in  of maximum degree  and maximum
bitsize , we can compute in complexity  a \blue{shearing} of the coordinate system
 ( integer in ) and a polynomial  in  of degree at most  and bitsize   so
that the system  is zero-dimensional and any separating linear
form for that system is also separating for  after being sheared back. 
\end{lemma}
\begin{proof}
As discussed above, we  first compute the squarefree part of \blue{each polynomial  and }, which can be
done in complexity  \cite[Lemma 13]{sagraloff2013}. \blue{Let  denote
  their product, which is squarefree since  and  are coprime.}
We then consider a generic \blue{shearing} of the
coordinate system  in order to find a value  so that the sheared
curve  has no vertical asymptote \blue{ and thus no
vertical line.}
The leading coefficient of  (seen as a polynomial in ) is a polynomial of degree at
most  in  ( does not appear in the leading
term); furthermore an expanded form of   can  be computed in complexity
 and the coefficients have 
bitsize  (see e.g. \blue{\cite[Lemma 7]{bouzidiJSC2014a}}). Finding an integer value  where the leading coefficient does not vanish can thus be done in 
evaluations of complexity  each \blue{\cite[Lemma 6]{bouzidiJSC2014a}} and such   can be found in \blue{ }. Then, computing    can be done by evaluating
each of the coefficients of  at , which can again be done with 
evaluations of  complexity  each. 
Thus, we can shear the curve in complexity  so that the leading coefficient of the resulting polynomial  (seen
as a polynomial in ) is a constant.


Modulo the \blue{shearing}, all solutions of  are solutions of the system . Indeed, a solution  of  is such that
 is solution of  with
 equal to the squarefree part of  and similarly for
; thus  is solution of  and of . Thus, any separating linear form for   is also separating for  modulo the \blue{shearing}. Finally,  is zero-dimensional since, by construction,
 is squarefree and contains no vertical
line.
Renaming  by , this concludes the proof.
\end{proof}


\section{The case of a curve}
\label{sec:curve}

In this section, we consider an arbitrary curve defined by   of degree  and bitsize
, with a constant leading
coefficient in , and such that  has a finite number of critical points, i.e., the system
 is zero-dimensional. We show in the following that  (i) computing the number of the critical points of
 and (ii) computing a lucky prime for  (see Definition~\ref{def:lucky-nb-roots}) can be done in a bit complexity in . 
Combined with the results of the previous sections, this will yield that we can compute a separating
linear form for an arbitrary zero-dimensional system  in the same complexity.


\subsection{Number of critical points}\label{sec:nb-critical}

Our algorithm for computing  the number of (complex) critical points of a curve is based on  
a classical algorithm for computing a triangular decomposition of
a system of two bivariate polynomials. We first recall this algorithm and then show how it can be slightly modified and used to compute the number of critical points of a curve. 


\smallskip
\noindent{\bf Triangular decomposition.}\quad
Let  and  be two polynomials in  of degree at most .
A decomposition  of the system  using the
subresultant sequence appears in the theory of triangular sets
\cite{Li-modpn-11} and for the computation of the topology of curves
\cite{VegKah:curve2d:96}. 


The idea is based on Lemma~\ref{lem:fund-prop-subres} which states that, after
specialization at , the first (with respect to increasing ) nonzero
subresultant  is of degree  and is equal to the
gcd of  and .  This induces a decomposition 
into triangular subsystems   where a solution
 of  is such that the system 
admits exactly  roots (counted with multiplicity), which are exactly those of
.  Furthermore, these triangular subsystems are
regular chains, i.e., the leading coefficient of the bivariate polynomial (seen
in ) is coprime with the univariate polynomial.  For clarity and
self-containedness, we recall this decomposition in
Algorithm~\ref{alg:tri-dec-mod}. 
Note that this algorithm performs  arithmetic operations in  (see e.g. \blue{\cite[Lemma 15]{bouzidiJSC2014a}}).  We also state the following properties which directly follow from the algorithm and Lemma~\ref{lem:fund-prop-subres}.

\begin{lemma}[{\cite{VegKah:curve2d:96,Li-modpn-11}}]\label{lem:tridec-correctness}
   Algorithm~\ref{alg:tri-dec-mod} computes a triangular decomposition 
    such that 

\begin{itemize}\cramped
  \item the set of solutions of  is the disjoint union  of the sets of solutions of the
  , 
  \item  is  squarefree, 
  \item for any root  of ,   
       is of degree  and is equal to   . 
\end{itemize}
\end{lemma}


\begin{algorithm}[t]
  \caption{Triangular decomposition \cite{VegKah:curve2d:96,Li-modpn-11}} 
\label{alg:tri-dec-mod}
\begin{algorithmic}[1]
  \REQUIRE{  in  coprime such that  and  are
    coprime, }
  \ENSURE{Triangular decomp. 
   such that the set of solutions of  is the disjoint union
  of the sets of solutions of }
\STATE Compute the subresultant sequence of  and  with respect to : 
\STATE   and  \label{line2-algo1}
\FOR { \TO }
\STATE  \label{line4-algo1}

\STATE  \label{line5-algo1}
\STATE if , add  to  
\ENDFOR
\RETURN 
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[t]
  \caption{Degree of the triangular decomposition } 
\label{alg:tri-dec-mod2}
\begin{algorithmic}[1]
  \REQUIRE{  in  coprime such that  and  are
    coprime, }
  \ENSURE{The degree of the triangular decomposition of }
\STATE Compute the principal subresultant sequence of  and  with respect to : 
\STATE   
\FOR { \TO }
\STATE \label{line4-algo2}

\ENDFOR
\RETURN 
\end{algorithmic}
\end{algorithm}



\smallskip
\noindent{\bf Degree of the triangular decomposition.}\quad
We call the \emph{degree of the triangular decomposition of ,} 
the sum of the degrees of the triangular systems computed
by Algorithm~\ref{alg:tri-dec-mod}, that is,
 where  refers to the degree of the
polynomial with respect to  and similarly for .
As we will see below, we only need the degree of the  triangular decomposition of some systems for computing the
number of critical points of . 

We present in Algorithm~\ref{alg:tri-dec-mod2}  a slight variation of the triangular
decomposition algorithm in which we only compute the degree of the decomposition. 
Instead of computing the subresultant sequence  of
 and  as in Algorithm~\ref{alg:tri-dec-mod}, we only compute  the sequence of principal
subresultant coefficients of
 and  (that is, the sequence of coefficients of the monomials of degree  in  in
), which is sufficient for computing the degree of the decomposition. As we will
see, this decreases by a factor   the arithmetic complexity in  of the algorithm, which is
critical for our global algorithm.\footnote{\small Note that, while  this complexity improvement does not
impact the bit complexity of computing the number of critical points of a curve  over , it is
critical when computing a lucky prime for  where the number
of critical points is computed for  systems defined over distinct    (Proposition~\ref{prop:comp-lucky}).}



\begin{lemma}\label{lem:tridec_pair}
Algorithm~\ref{alg:tri-dec-mod2} computes the degree of the triangular decomposition of .
If  have degree at most , the algorithm performs  arithmetic
operations in . If 
 () have degree at most  and bitsize at most ,
the algorithm performs  bit 
operations in . 
\end{lemma}

\begin{proof}
The correctness of Algorithm~\ref{alg:tri-dec-mod2} directly follows from
Lemma~\ref{lem:tridec-correctness}. Concerning the complexity, the resultant and the sequence of the principal subresultant coefficients of  and  can be computed in
   arithmetic operations, and each of these principal subresultants (including the
  resultant) has degree in , by  Lemma \ref{complexity:subresultant} (note that this lemma is stated for
  the coefficient ring , but the arithmetic complexity is the same for any
  field ).
  The algorithm performs at most  gcd computations between these polynomials. 
  The arithmetic complexity of one such gcd computation is softly
  linear in their degrees, that is 
  (Lemma~\ref{complexity:gcd}). Hence the complexity of computing 
  all the gcds is in . 
The bit complexity over  Algorithm~\ref{alg:tri-dec-mod2} is bounded by that of
  Algorithm~\ref{alg:tri-dec-mod} which is in  according to the proof of
  \cite[Thm. 19]{det-jsc-2009}.\footnote{\small Note that this bound is not an obvious overestimate because  known bounds yield a complexity of  for all the gcd computations
  in Line~\ref{line4-algo1} of Algorithm~\ref{alg:tri-dec-mod}, which is the
  same for Line~\ref{line4-algo2} of Algorithm~\ref{alg:tri-dec-mod2}.}
\end{proof}




\begin{lemma}\label{lem:mult} 
The degree of the triangular decomposition of  is equal to the sum, over all distinct
solutions  of ,  of the multiplicities of  in . 
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:tridec-correctness}, the sets of solutions of the systems of the triangular decomposition of
Algorithm~\ref{alg:tri-dec-mod} are disjoint and polynomials  are squarefree. The degree of the
triangular decomposition of  is thus 

where  is the set of solutions of  and  denotes the multiplicity of  in .
The result follows since   by Lemma~\ref{lem:tridec-correctness}.
\end{proof}


\noindent{\bf Number of critical points of .}\quad
Algorithm~\ref{alg:rad-tri-dec} computes the number of critical points of   as the difference between the
degree of the triangular decompositions of the systems  and . We first prove the correctness of this algorithm and then its complexity. 

\begin{algorithm}[t]
  \caption{Number of critical points of }
\label{alg:rad-tri-dec}
\begin{algorithmic}[1]
  \REQUIRE{ in  squarefree such that }
  \ENSURE{ The number of critical points of }

\smallskip
\RETURN  Algo \ref{alg:tri-dec-mod2}  - Algo \ref{alg:tri-dec-mod2}  


\end{algorithmic}
\end{algorithm}




\begin{proposition}\label{prop:proof-correctness}
  Algorithm \ref{alg:rad-tri-dec} computes the number of critical points of .
If  has degree , the algorithm performs  arithmetic
operations in . If 
 () has degree  and bitsize ,
the algorithm performs  bit 
operations in . 

\end{proposition}

\begin{proof}
We first prove that for any critical point  of , the multiplicity of  in
 is greater by one than the
multiplicity of  in   . 
Since  is a critical point of , it is  solution of both the systems  and . This implies that  is a root of both  and . If   is the multiplicity of  in  then  has multiplicity  in  and thus, that it has multiplicity  in . It follows that
 has multiplicity  in  and
 in  because , that is
, since
 is solution of .

We denote  the multiplicity of  in   as .
Summing 
over all the critical points of  and noticing that the set   of distinct solutions of  is the same as that of , we obtain that the number of critical points is

which is equal, by Lemma~\ref{lem:mult},  to the difference of the degrees of the decompositions of  and . These degrees are  computed by Algorithm \ref{alg:tri-dec-mod2}, which
  concludes the proof of correctness of Algorithm~\ref{alg:rad-tri-dec}.




The complexity analysis of the algorithm directly follows from Lemma~\ref{lem:tridec_pair} noticing that
 and  have degrees at most 
(and bitsizes in  when defined over ) and that  can be computed from
 in 
complexity  (and  when defined over ) \cite[Cor. 8.28]{vzGGer2}.
\end{proof}





\subsection{Lucky prime}

In Algorithm~\ref{algo:lucky}, we compute a lucky prime for  (see Definition
\ref{def:lucky-nb-roots}) in a straightforward manner by first computing the number of distinct
solutions of the system and then by computing the number of solutions
of its image modulo distinct prime numbers  until the same number of solutions is found (and
checking that some leading coefficients do not vanish modulo ). Note that
Algorithm~\ref{algo:lucky} is a simplified variant of \blue{\cite[Algorithm 3]{bouzidiJSC2014a}} where we use here   the knowledge of the number of critical points of 
to avoid  computing an explicit bound on
the number of unlucky primes. 


\begin{algorithm}[t]
  \caption{Lucky prime for  } 
\label{algo:lucky}
\begin{algorithmic}[1]

  \REQUIRE{  in  such that }

\ENSURE{A lucky prime  for the system }

\STATE = Algorithm~\ref{alg:rad-tri-dec} () \label{line-distinct}

\STATE Compute  and 
\label{alg:nbrootZ1}

\STATE 

\WHILE {true} \label{alg:nbrootZ3}

\STATE Compute the set  of the first  primes  

\FORALL { in }

\STATE Compute the reduction mod.  of , , ,  \label{alg:nbrootZ6.1}

\IF{   \label{alg:nbrootZ4}} 
 \STATE Compute   Algorithm \ref{alg:rad-tri-dec}\label{alg:nbrootZ5}
 \IF {\label{alg:nbrootZ6}} 
 \RETURN 
 \ENDIF
   \ENDIF
\ENDFOR
 
\STATE  the largest prime in   

\ENDWHILE 

\end{algorithmic}
\end{algorithm}


\begin{proposition}\label{prop:comp-lucky}
Given  of degree  and bitsize , 
Algorithm~\ref{algo:lucky} computes a lucky prime  for  using  bit operations.
\end{proposition}
\begin{proof}
The correctness of Algorithm~\ref{algo:lucky} follows directly from the fact that the number of unlucky primes is finite 
(see~\blue{\cite[Prop. 13]{bouzidiJSC2014a}}). 

We now analyze the complexity of the algorithm. Computing the number of critical points of
 in Line~\ref{line-distinct} has complexity  by
Proposition~\ref{prop:proof-correctness}.
It is
straightforward that the computations in Line~\ref{alg:nbrootZ1} can be done in bit complexity
 (see e.g. \blue{\cite[Lemma 7]{bouzidiJSC2014a}}). There are \blue{} iterations of the loop in Line~\ref{alg:nbrootZ3} because there are
 unlucky primes \blue{\cite[Prop. 13]{bouzidiJSC2014a}}. Each iteration of this loop consists in testing, for
the  
primes in , the non-vanishing of the reduction of the two polynomials
 and  and the equality between the number of
solution over  and its analogue over .



Polynomials , ,  and  are of degree at most  in one or two variables and
they have bitsize at most  (see e.g. \blue{\cite[Lemma 7]{bouzidiJSC2014a}}).
The reduction of all their  coefficients modulo all the primes in  can be computed via a remainder tree in a bit
  complexity that is soft linear in the total bitsize of the input
\cite[Thm. 1]{moenck1974}, which is dominated by the sum of the
    bitsizes of the  primes 
 in  each being of bitsize
     \blue{} (since there are \blue{} iterations of the loop in Line~\ref{alg:nbrootZ3}). Hence, the bit complexity of  Line~\ref{alg:nbrootZ6.1} is~.

Finally, the arithmetic complexity of
     Algorithm \ref{alg:rad-tri-dec} is in , 
by Lemma~\ref{prop:proof-correctness},  thus its bit complexity is also in 
     since \blue{}.  Hence, the total bit complexity of Line~\ref{alg:nbrootZ5} is
     , and so is the bit complexity of one iteration of the loop in
     Line~\ref{alg:nbrootZ3}. Since at most \blue{} iterations are performed, this yields an
     overall bit complexity for Algorithm \ref{algo:lucky} in .
\end{proof}


\section{Wrap up}
The results of the previous sections can easily be combined in the following theorem.

\begin{theorem}\label{thm:final}
Let  of total degree at most  and maximum bitsize . A separating linear form  for  with  an integer of bitsize in \blue{}  can be computed using  bit operations.
\end{theorem}


\begin{proof}
According to Lemma~\ref{lem:system2curve}, we can compute in complexity  a
\blue{shearing} , , and a polynomial  of total degree at most
 and bitsize   such that  is
zero-dimensional and such that  is separating for
 if  is separating for . The result follows since by
Propositions~\ref{prop:sep-elem-comp},~\ref{prop:proof-correctness}
and~\ref{prop:comp-lucky}, since an
 integer  in  such that  separates  can be computed using   bit operations.
\end{proof}


\section{\blue{Las-Vegas algorithm}} \label{sec:Las-Vegas}



\blue{In this section, we present a Las-Vegas version of the algorithm presented in the
previous sections, whose expected bit complexity is  
(Theorem~\ref{thm:las-vegas}).}



The Las-Vegas version of our algorithm is the same as the deterministic one except that we use
Las-Vegas algorithms for gcd computations and that we choose randomly candidates for a separating linear
form and a lucky prime
 in Algorithms~\ref{alg:sep-elem} and \ref{algo:lucky}.


 More precisely, \blue{in the Las-Vegas version of}
 Algorithm~\ref{alg:sep-elem}, the separating linear form is computed by
 choosing at random an integer  in  until a candidate satisfying the
 condition of Line~\ref{alg:sep9} is found. There are at most  integers
 that do not satisfy this condition,\footnote{\small Indeed,  is of
   degree at most  and the system  has at most 
   solutions which define at most  directions in which two
   solutions are aligned. Furthermore  (for ).}  thus a good candidate is chosen with probability at least ,
 and so at most 2 candidates are chosen on average.

\blue{In the Las-Vegas version of} Algorithm~\ref{algo:lucky}, we  first compute a set  of  prime numbers where  is an
upper bound on the number of unlucky primes for ; such 
a set  can be computed in bit complexity  (see the proof of~\blue{\cite[Lemma 18]{bouzidiJSC2014a}}).  Then, we iteratively choose at random a prime number  in  until the conditions of
Algorithm~\ref{algo:lucky} are satisfied (Lines~\ref{alg:nbrootZ4} and \ref{alg:nbrootZ6}). 
The primes not satisfying these conditions are the unlucky ones, by definition, thus a lucky prime
is found with probability at least , and so at most 2 candidates are
chosen on average. 


It remains to prove that the expected bit complexity of Algorithms~\ref{alg:sep-elem},
\ref{alg:rad-tri-dec}, and \ref{algo:lucky}, as well as the initial \blue{shearing} of
the coordinate systems, are in .
Our analysis is based on the following result on the expected complexity  of gcd computations.


\begin{lemma}[{\cite[Cor. 11.11]{vzGGer2}}]\label{lem:expected-gcd}
Let  of degree at most  and maximum bitsize . The  of  and  can be computed using an expected number of  bit operations.
\end{lemma}


\begin{lemma}\label{lem:sep-elem-comp-exp}
Given   of total degree at most  and maximum bitsize ,
the Las-Vegas version of Algorithm~\ref{alg:sep-elem}  computes a separating linear form  for  with
 with an expected bit complexity in  . 
\end{lemma}
\begin{proof}
  In the proof of Proposition~\ref{prop:sep-elem-comp}, we proved that the complexity of the algorithm
  is  plus  times the number of considered choices of integer . As
  argued above, at most two candidate integers are considered on average, which yields the lemma.
\end{proof}



\begin{lemma}\label{lem:lem:tridec_pair-exp}
Given   of total degree at most  and maximum bitsize ,
Algorithm~\ref{alg:tri-dec-mod2} computes the degree of the triangular decomposition of  
with an expected bit complexity in . 
\end{lemma}
\begin{proof}
According to Lemma~\ref{complexity:subresultant}, the sequence of the principal subresultant
coefficients ,  can be computed in   bit operations,
and each of these principal subresultants (including the resultant) has degree  and bitsize
. The algorithm then performs  at most  gcd computations between these polynomials
(including the computation of the squarefree part of the resultant). By Lemma~\ref{lem:expected-gcd}
and using Mignotte's bound~\cite[Cor. 10.12]{BPR06}, each of these gcds can be computed in  an
expected bit complexity . Hence computing  such
gcds can be done with expected bit complexity , which concludes the proof.
\end{proof}

\begin{lemma}\label{lem:proof-correctness-exp}
Given   of total degree at most  and maximum bitsize ,
  Algorithm \ref{alg:rad-tri-dec} 
computes the number of critical points of  
with an expected bit complexity in . 
\end{lemma}
\begin{proof}
As seen in the proof of Proposition~\ref{prop:proof-correctness}, Algorithm \ref{alg:rad-tri-dec}
computes  and  in bit complexity
 and calls Algorithm~\ref{alg:tri-dec-mod2} on two systems of degrees  and
bitsizes . The result follows from Lemma~\ref{lem:lem:tridec_pair-exp}.
\end{proof}


\begin{lemma}\label{lem:lucky-exp}
Given  of total degree  and bitsize , 
the Las-Vegas version of Algorithm~\ref{algo:lucky} computes a lucky prime  for  with an expected bit complexity in  .
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:proof-correctness-exp}, the first call to Algorithm \ref{alg:rad-tri-dec} has
an expected bit complexity in . As shown in the proof of Proposition~\ref{prop:comp-lucky}, the
bit complexity of shearing  and , as well as the reductions modulo
 have  bit complexity . Finally, by Proposition~\ref{prop:proof-correctness}, the calls  in  to Algorithm
\ref{alg:rad-tri-dec} have arithmetic complexity  and thus bit complexity 
(since ). This concludes the proof since, as discussed above,  the expected number of such calls is
at most 2.
\end{proof}


Combining the above results, we obtain the following theorem.


 \begin{theorem}\label{thm:las-vegas}
Let  of total degree at most  and maximum bitsize . A separating linear form  for  with  an integer of bitsize in   can be computed using an expected number of  bit operations.
\end{theorem}

\begin{proof}
As in the proof of Theorem~\ref{thm:final}, Lemmas~\ref{lem:sep-elem-comp-exp},
\ref{lem:proof-correctness-exp} and \ref{lem:lucky-exp} yield the result once we prove, as in
Lemma~\ref{lem:system2curve}, that we can compute with the right complexity a
\blue{shearing}
 , , and a polynomial  of total degree at most
 and bitsize   such that  is
zero-dimensional and such that, if  is separating for , then 
 is separating for .
 
According to the proof of Lemma~\ref{lem:system2curve}, we only need to prove that the computation of the squarefree part of  can be done with an expected bit complexity in . Replacing in the proof of \cite[Lemma 13]{sagraloff2013} the bit complexity of computing a univariate gcd by the one in Lemma~\ref{lem:expected-gcd} yields the result.  
\end{proof}







\section{Conclusion}

This paper focuses on the computation of separating linear forms for bivariate systems.  First, we
proved that the computation of such a separating form can be done with a bit complexity
 in the worst case.  As mentioned in the introduction, this result directly
yields, within the same worst-case bit complexity, the rational parameterization of Gonzalez-Vega et
al. \cite{VegKah:curve2d:96,det-jsc-2009} and 
 that of Rouillier
\cite{Rou99,bouzidiJSC2014a}. Second, we proved that the computation of a separating linear
form can be done in a Las-Vegas setting using an expected number of  bit
operations.  As a consequence, the computation in this setting of a separating linear form now becomes
non-dominant in the whole process of computing a rational parameterization; \blue{indeed, given a
separating linear form, computing Gonzalez-Vega et al. and 
Rouillier's parameterizations both have bit
complexity in  even in the Las-Vegas setting.


It should be mentioned that the best known upper bound for the total bitsize of the parameterization
of Gonzalez-Vega et al. is .\footnote{\small Indeed, the approach of Gonzalez-Vega
  et al. first applies a linear change of variables to the input polynomials, which increases the
  bitsize of the polynomials to , and then computes rational parameterizations
  of the solutions of the  systems of the triangular decomposition
  (Algorithm~\ref{alg:tri-dec-mod}). The rational parameterizations are ratios of coefficients of
  the polynomial subresultants (seen as polynomials in ) which have degrees  and bitsize
   (Lemma~\ref{complexity:subresultant}). The total bitsize of the
   parameterizations is thus .}  Thus, some progress on this upper bound
would be required before any further progress on the computation of a separating linear form in the
Las-Vegas setting could impact that of computing this parameterization.  However, note that the
situation is slightly different for the Rational Univariate Representation (RUR) of Rouillier
\cite{Rou99} whose total bitsize is ~\cite[Theorem 22]{bouzidiJSC2014a}.


Finally, we note that, for computing a separating linear form of an
\emph{arbitrary} system ,  the algorithm presented here is likely purely theoretical
because considering the system  instead  essentially doubles the
degree of the input polynomials, which is likely not efficient in practice. However, for the problem
of computing the critical points of a curve, there is some
good hope that our  algorithm is efficient in practice.}





     









\small
\bibliographystyle{abbrv}
 \bibliography{bib-algcurves}

\end{document}
