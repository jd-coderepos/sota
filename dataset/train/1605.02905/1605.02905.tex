\documentclass[proceedings]{aofa}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb,comment,xspace}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}

\usepackage{multirow}

\usepackage{url}

\newcommand{\R}{\mathcal{R}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\N}{\mathcal{N}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\T}{\mathcal{T}}

\newcommand{\Xrnr}{\mathcal{X}^{\bullet\circ}}
\newcommand{\Xnrr}{\mathcal{X}^{\circ\bullet}}
\newcommand{\Xad}{\mathcal{X}^{\nearrow\searrow}}
\newcommand{\Xda}{\mathcal{X}^{\searrow\nearrow}}


\newcommand{\InsertSort}{\textsc{InsertionSort}\xspace}

\newcommand{\EE}{\mathbb{E}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\RR}{\mathbb{R}}

\newcommand{\stcomp}[1]{{#1}^{\mathsf{c}}}
\renewcommand{\inf}[1]{{\mathbf{Inf}({#1})}}
\renewcommand{\sup}[1]{{\mathbf{Sup}({#1})}}
\newcommand{\card}[1]{{\mathbf{Card}({#1})}}
\newcommand{\wqotk}[2]{\weight^{\quotient}_{#1}(#2)}


\DeclareMathOperator{\sym}{\mathfrak{S}}
\DeclareMathOperator{\weight}{w}
\DeclareMathOperator{\quotient}{q}
\DeclareMathOperator{\Weight}{W}
\DeclareMathOperator{\cyc}{cycle}
\DeclareMathOperator{\rec}{record}
\DeclareMathOperator{\len}{length}
\DeclareMathOperator{\minrec}{min-record}
\DeclareMathOperator{\norm}{norm}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\desc}{desc}
\DeclareMathOperator{\inv}{inv}
\DeclareMathOperator{\below}{below}
 
\DeclareMathOperator{\lmax}{lmax}
\DeclareMathOperator{\Id}{Id}
\newcommand{\rfact}[2]{#1^{(#2)}}
\newcommand{\symin}[2]{\sym_{#1 \text{\,in\,} #2}}   

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}




\newenvironment{remark}{\noindent{\bf Remark:} }{\hfill}





\author{Nicolas Auger\addressmark{1}
  \and Mathilde Bouvel\addressmark{2}\thanks{Supported by a Marie Heim-Vögtlin grant of the Swiss National Science Foundation.}
  \and Cyril Nicaud\addressmark{1}
  \and Carine Pivoteau\addressmark{1}}



\title[Analysis of Algorithms for Biased Permutations]{Analysis of Algorithms for Permutations Biased by Their Number of Records}

\address{
\addressmark{1} Universit\'e Paris-Est, LIGM (UMR 8049), F77454 Marne-la-Vall\'ee, France\\
\addressmark{2} CNRS and Institut f\"ur Mathematik, Universit\"at Z\"urich, Zurich, Switzerland}

\keywords{permutation, Ewens distribution, random generation, analysis of algorithms}



\begin{document}
\maketitle
\begin{abstract}
The topic of the article is the parametric study of the complexity of algorithms on arrays of pairwise distinct integers. 
We introduce a model that takes into account the non-uniformness of data, 
which we call the Ewens-like distribution of parameter  for records on permutations: 
the weight  of a permutation depends on its number  of records. 
We show that this model is  meaningful for the notion of presortedness, while still being mathematically tractable.
Our results describe the expected value of several classical permutation statistics in this model, 
and give the expected running time of three algorithms: the Insertion Sort, and two variants of the Min-Max search. 
\end{abstract}




\section{Introduction}\label{sec:intro}
A classical framework for analyzing the average running time of algorithms is to consider uniformly distributed inputs. 
Studying the complexity of an algorithm under this uniform model usually gives a quite good understanding of the algorithm. 
However, it is not always easy to argue that the uniform model is relevant, when the algorithm is used on a specific data set. 
Observe that, in some situations, the uniform distribution arises by construction, from the  randomization of a deterministic algorithm. 
This is the case with Quick Sort for instance, when the pivot is chosen uniformly at random.
In other situations, the uniformity assumption may not fit the data very well, 
but still is a reasonable first step in modeling it, which  makes the analysis mathematically tractable.

In practical applications where the data is a sequence of values, 
it is not unusual that the input is already partially sorted, depending on its origin. 
Consequently, assuming that the input is uniformly distributed, or shuffling the input as in the case of Quick Sort, may not be a good idea.  
Indeed, in the last decade, standard libraries of well-established languages have switched to sorting algorithms that take advantage of the ``almost-sortedness'' of the input. 
A noticeable example is Tim Sort Algorithm, used in Python (since 2002) and Java (since Java 7): it is particularly efficient to process data consisting of long increasing (or decreasing) subsequences.

In the case of sorting algorithms, the idea of taking advantage of some bias in the data towards sorted sequences dates back to Knuth~\cite[p. 336]{Knuth98}. 
It has been embodied by the notion of \emph{presortedness}, which quantifies how far from sorted a sequence is. 
There are many ways of defining measures of presortedness, and it has been axiomatized by Mannila~\cite{Mannila1985} (see Section~\ref{sec:presortedness} for a brief overview). 
For a given measure of presortedness , the classical question is to find a sorting algorithm that is optimal for , meaning that it minimizes the number of comparisons as a function of both the size of the input and the value of~. 
For instance, Knuth's Natural Merge Sort~\cite{Knuth98} is optimal for the measure ``number of runs'' , with a worst case running time of  for an array of length . 

Most measures of presortedness studied in the literature are directly related to basic statistics on permutations. 
Consequently, it is natural to define biased distributions on permutations that depend on such statistics, 
and to analyze classical algorithms under these non-uniform models. 
One such distribution is very popular in the field of discrete probability: the Ewens distribution. 
It gives to each permutation~ a probability that is proportional to ,
where  is a parameter and  is the number of cycles in . 
Similarly, for any classical permutation statistics , 
a non-uniform distribution on permutations may be defined by giving to any  a probability proportional to . 
We call such distributions \emph{Ewens-like distributions}. 
Note that the Ewens-like distribution for the number of inversions is quite popular, under the name of \emph{Mallows distribution}~\cite[and references therein]{Gladkich}. 
 


In this article, we focus on the Ewens-like distribution according to  number of records (a.k.a. \emph{left to right maxima}). 
The motivation for this choice is twofold. 
First, the number of records is directly linked to the number of cycles by the fundamental bijection (see Section~\ref{sec:permutations}). 
So, we are able to exploit the nice properties of the classical Ewens distribution, and have a non-uniform model that remains mathematically tractable. 
Second, we observe that the number of non-records is a measure of presortedness. 
Therefore, our distribution provides a model for analyzing algorithms which is meaningful for the notion of presortedness, 
and consequently which may be more realistic than the uniform distribution. 
We first study how this distribution impacts the expected value of some classical permutation statistics, depending on the choice of~. 
Letting  depend on , we can reach different kinds of behavior. 
Then, we analyze the expected complexity of Insertion Sort under this biased distribution, 
as well as the effect of branch prediction on two variants of the simultaneous minimum and maximum search in an array.


\section{Permutations and Ewens-like distributions}\label{sec:def}

\subsection{Permutations as words or sets of cycles}\label{sec:permutations}

For any integers~ and~, let  and for every integer , let . 
By convention . 
If  is a finite set, let  denote the set of all permutations on , \emph{i.e.}, of bijective maps from  to itself. 
For convenience,  is written  in the sequel. 
Permutations of  can be seen in several ways (reviewed for instance in~\cite{Bona}). 
Here, we use both their representations as words and as sets of cycles. 

A permutation  of  can be represented as a word  containing exactly once each symbol in : 
by simply setting  for all . 
Conversely, any sequence (or word) of  distinct integers can be interpreted as representing a permutation of . 
For any sequence  of~ distinct integers, the rank  of  is defined as
the number of integers appearing in  that are smaller than or equal to .
Then, for any sequence  of  distinct integers, the \emph{normalization}  of~ is the
unique permutation  of  such that . For instance, .

Many permutation statistics are naturally expressed on their representation as words. 
One will be of particular interest for us: the number of records. 
If  is a permutation of  and ,
there is a \emph{record} at position  in  (and subsequently,  is a record) if  for every . 
In the word representation of permutations, records are therefore elements that have no larger elements to their left. 
This equivalent definition of records naturally extends to sequences of distinct integers, and 
for any sequence  of distinct integers, the positions of the records in  and in  are the same. 
A position that is not a record is called a \emph{non-record}.

A cycle of size~ in a permutation  is a subset  of  such that 
. 
It is written . 
Any permutation can be decomposed as the set of its cycles. 
For instance, the cycle decomposition of  represented by the word  is . 

These two ways of looking at permutations (as words or as set of cycles) are rather orthogonal, 
but there is still a link between them, provided by the so-called \emph{fundamental bijection} or \emph{transition lemma}. 
The fundamental bijection, denoted , is the following transformation: 
\begin{enumerate}\setlength\itemsep{-1mm}
\item Given  a permutation of size , consider the cycle decomposition of . 
\item Write every cycle starting with its maximal element, 
and write the cycles in increasing order of their maximal (i.e., first) element. 
\item Erasing the parenthesis gives . 
\end{enumerate}
Continuing our previous example gives . 
This transformation is a bijection, and transforms a permutation as set of cycles into a permutation as word. 
Moreover, it maps the number of cycles to the number of records. 
For references and details about this bijection, see for example~\cite[p. 109--110]{Bona}. 

\subsection{The number of non-records as a measure of presortedness}\label{sec:presortedness}

The concept of presortedness, formalized by Mannila~\cite{Mannila1985}, naturally arises when studying sorting algorithms which efficiently sort sequences already almost sorted. 
Let  be a totally ordered set. 
We denote by  the set of all nonempty sequences of distinct elements of , 
and by  the concatenation on . 
A mapping  from   to  is a \emph{measure of presortedness} if it satisfies:
\begin{enumerate}
\setlength\itemsep{-1mm}
\item if  is sorted then ;
\item if  and  are two elements of  having same length, and such that for every ,
 then ;
\item if  is a subsequence of  then ;
\item if every element of  is smaller than every element of  then ;
\item for every symbol  that does not occur in , .
\end{enumerate}
Classical measures of presortedness~\cite{Mannila1985} are the number of inversions, the number of swaps, \ldots 
One can easily see, checking conditions 1 to 5, that  number of non-records in  number of records in  
defines a measure of presortedness on sequences of distinct integers. 
Note that because of condition 2, studying a measure of presortedness on  is not a restriction with respect to studying it on sequences of distinct integers. 

Given a measure of presortedness , we are interested in optimal sorting algorithms with respect to . 
Let . 
A sorting algorithm is \emph{-optimal} (see~\cite{Mannila1985} and~\cite{Petersson95} for more details) 
if it performs in the worst case  comparisons when applied to  such that , uniformly in . 
There is a straightforward algorithm  that is -optimal. First scan  from left to right and put the records in one (sorted) list  and the non-records in another list . Sort  using a  algorithm, then merge it with
. The worst case running time of this algorithm is  for 
permutations  of  such that .
Moreover,  for any , 
since it contains the  permutations of the form  for . 
Consequently, , proving -optimality. 

\subsection{Ewens and Ewens-like distribution}

The Ewens distribution on permutations (see for instance~\cite[Ch. 4 \& 5]{Arratia}) is a generalization of the uniform distribution on : 
the probability of a permutation depends on its number of cycles. 
Denoting  the number of cycles of any permutation , 
the Ewens distribution of parameter  (where  is any fixed positive real number) 
gives to any  the probability . 
As seen in~\cite[Ch. 5]{Arratia}, the normalization constant  is , 
where the notation  (for any real ) denotes the \emph{rising factorial} defined by
 (with the convention that ).

Mimicking the Ewens distribution, it is natural (and has appeared on several occasions in the literature, see for instance~\cite[Example 12]{Borodin}) 
to define other non-uniform distributions on , 
where we introduce a bias according to some statistics . 
The Ewens-like distribution of parameter  (again  is any fixed positive real number) 
for statistics  
is then the one that gives to any  the probability . 
The classical Ewens distribution corresponds to  number of cycles. 
Ewens-like distributions can be considered for many permutations statistics, like the number of inversions, of fixed points, of runs,~\dots 
In this article, we focus on the distribution associated with  number of \emph{records}. 
We refer to it as the Ewens-like distribution for records (with parameter ).
For any , we let  denote the number of records of , and define the \emph{weight} of  as . 
The Ewens-like distribution for records on  gives probability  to any , 
where . 
Note that the normalization constant is , like in the classical Ewens distribution: 
indeed, the fundamental bijection reviewed above 
shows that there are as many permutations with  cycles as permutations with  records. 
Fig.~\ref{fig:Ewens} shows random permutations under the Ewens-like distribution for records, for various values of . 


\begin{figure}[ht]
\includegraphics[scale=.18]{gsn100m10000t1.png}\includegraphics[scale=.18]{gsn100m10000t50.png}\includegraphics[scale=.18]{gsn100m10000t100.png}\includegraphics[scale=.18]{gsn100m10000t500.png}
\caption{Random permutations under the Ewens-like distribution on  with, from left to right,  (corresponding to the uniform distribution) and . For each diagram,  the darkness of a point  is proportional 
to the number of generated permutations  such that , for a sampling of 10000 random permutations.\label{fig:Ewens}}
\end{figure}

\subsection{Linear random samplers}
Efficient random samplers have several uses for the analysis of algorithms in general. 
They allow to estimate quantities of interest (even when their computation with a theoretical approach is not feasible), 
and can be used to double-check theoretical results. 
They are also a precious tool to visualize the objects under study (the diagrams in Fig.~\ref{fig:compare} were obtained in this way), 
allowing to define new problems on these objects (for example: can we describe the limit shape of the diagrams shown in Fig.~\ref{fig:compare}?).

As mentioned in~\cite[\S 2.1]{Valentin}, one can easily obtain a linear time and space algorithm to generate a random permutation according to the Ewens distribution (for cycles), using a variant of the Chinese restaurant process reviewed in what follows. 
To generate a permutation of size~, we start with an empty array\footnote{Note that our array starts at index~1.}~ of length~ that is used to store the values of the~'s. For~ from~1 to~, we choose to either create a new cycle containing only~ with probability~ or to insert  in one of the existing cycles with probability~. To create a new cycle, we set . To insert~ in an existing cycle, we choose uniformly at random an element~ in~ to be the element following~ in its cycle, and we set  and . To avoid searching for~ in the array , we only need to keep  in a second array while adding the elements in .

Starting from this algorithm, we can easily design a linear random sampler for permutations according to the Ewens-like distribution for records, using the fundamental bijection. The first step is to generate a permutation  in~ with the above algorithm. Then, we write the cycles of~ in reverse order of their maximum, as sequences, starting from the last element and up to exhaustion of the cycle: . Each time we write an element~, we set~ and each time a cycle is finished, we search the next value of~ such that  to start the next cycle. This new cycle will be written before the one that has just been written. Note that all these operations can be performed in time complexity~ using doubly linked lists for the resulting permutation. In the end, the cycles will be written as sequences starting by their maximum, sorted in increasing order of their maximum, which is the fundamental bijection.

Note that there exists another branching process, known as the {\em Feller coupling}, to generate permutations according to the Ewens distribution (see for instance~\cite[p.16]{Arratia}). 
Although it is less natural than with the Chinese restaurant process, it is also possible to infer linear random samplers from it. 
Details will be provided in an extended version of this work. 

\section{Average value of statistics in biased random permutations}\label{sec:stats}

Let  be any fixed positive real number. 
In this section, we study the behavior of several statistics on permutations, 
when they follow the Ewens-like distribution for records with parameter . 
Our purpose is mostly to illustrate methods to obtain precise descriptions of the behavior of such statistics. 
Such results allow a fine analysis of algorithms whose complexity depends on the studied statistics.

Recall that, for any ,  
and the probability of  is , with . 
Recall also that the records of any sequence of distinct integers are well-defined.  
For any such sequence  we subsequently set 
 to be the number of records of  and . 
Note that for any such sequence , , 
because the positions (and hence the number) of records do not change when normalizing. 

\subsection{Technical lemmas}

Seeing a permutation of  as a word, it can be split (in many ways) 
into two words as  for the usual concatenation on words. 
Note that here~ and~ are not normalized permutations:   belongs to the set~ of all sequences of  distinct integers in  where~, and  belongs to~.
The weight function  behaves well with respect to this decomposition, as shown in the following lemmas. 

\begin{lemma}\label{lem:weight prime}
Let  be an integer, and  be a sequence of  distinct integers in . 
Denote by  the number of records in  whose value is larger than the largest element of  which does not appear in ,
and define  as . 
For all , if , then .
\end{lemma}

For instance, the definition of  gives  ( and  are records of  larger than ) 
and  (there are no records in  larger than ). 

We extend the weight function  to subsets  of  as . 
For any sequence  of  distinct integers in , the right-quotient of  with  is . 
Since  for all sequences  of distinct integers, 
we have  for all  and  as above 
(As expected,  means ).



For , we say that  is \emph{quotient-stable for } if  
 is constant when  runs over . When  is quotient-stable for , we denote  the common value of  for  as above. 
For instance,  is quotient-stable for . Indeed, 



Note that  is quotient-stable for all : 
indeed, for any  of size ,  so that  for all  of size . 
It follows that . 

\begin{lemma}\label{lem:qot}
Let  be quotient-stable for . Then 
.
\end{lemma}

A typical example of use of~Lemma~\ref{lem:qot} is given in the proof of Theorem~\ref{lem:records}.

\begin{remark}
Lemma~\ref{lem:qot} is a combinatorial version of a simple probabilistic property: Let  be the set of elements of  that end with . If  is an event on  and if the probability of  given  is the same for every , then it is equal to the probability of , by the law of total probabilities.
\end{remark}

\subsection{Summary of asymptotic results}

The rest of this section is devoted to studying the expected behavior of some permutation statistics, 
under the Ewens-like distribution on  for records with parameter . 
We are especially interested in the asymptotics in  when  is constant or is a function of . 
The studied statistics are: number of records, number of descents, first value, and number of inversions. 
A summary of our results is presented in Table~\ref{table:asymptotics}. 
The asymptotics reported in Table~\ref{table:asymptotics} follow from Corollaries~\ref{thm:nb_of_records}, \ref{thm:nb_of_descents}, \ref{thm:first_value}, \ref{thm:nb_of_inversions} 
either immediately or using the so-called \emph{digamma} function. 
The digamma\footnote{For details, see \url{https://en.wikipedia.org/wiki/Digamma_function} (accessed on April 27, 2016).} function is defined by . 
It satisfies the identity , 
and its asymptotic behavior as  is . We also define , so that  for any positive integer .
In Table~\ref{table:asymptotics} and in the sequel,
we use the notations  (resp. ) to denote 
the probability of an event  (resp. the expected value of a statistics )   
under the Ewens-like distribution on  for records.
 
\begin{table}[ht]\label{table:asymptotics}
\begin{center}
\begin{tabular}{l|l|l|l|l|l|c}
&  & fixed  & ,  & , & , &See \\
& {\small (uniform)}& & {\small  }& {\small } & {\small  }&Cor.\\
\hline 
 &  &  &  &  &  & \ref{thm:nb_of_records}\\
 &  &  &  &  &  & \ref{thm:nb_of_descents}\\
 &  &  &  &  &  & \ref{thm:first_value}\\
 &  &  &  &  &  & \ref{thm:nb_of_inversions}\\
\end{tabular}
\end{center}
\caption{Asymptotic behavior of some permutation statistics under the Ewens-like distribution on  for records.  
We use the shorthand .
All the results in this table are asymptotic equivalents.
}
\end{table}

\begin{remark}
To some extent, our results may also be interpreted on the classical Ewens distribution, via the fundamental bijection. 
Indeed the number of records (resp. the number of descents, resp. the first value) of  
corresponds to the number of cycles (resp. the number of anti-excedances\footnote{An anti-excedance of  is  such that . 
The proof that descents of  are equinumerous with anti-excedances of  is a simple adaptation of the proof of Theorem 1.36 in~\cite{Bona}, p. 110--111.}
, resp. the minimum over all cycles of the maximum value in a cycle) 
of . 
Consequently, Corollary~\ref{thm:nb_of_records} is just a consequence of the well-known expectation 
of the number of cycles under the Ewens distribution (see for instance~\cite[\S 5.2]{Arratia}).  
Similarly, the expected number of anti-excedances (Corollary~\ref{thm:nb_of_descents}) can be derived easily from the results of~\cite{Valentin}. 
Those results on the Ewens distribution do not however give access to results as precise as those stated in Theorems~\ref{lem:records} and~\ref{lem:descent i}, 
which are needed to prove our results of Section~\ref{sec:mispredictions}. 
Finally, to the best of our knowledge, the behavior of the third statistics (minimum over all cycles of the maximum value in a cycle) has not been previously studied, 
and we are not aware of any natural interpretation of the number of inversions of  in . 
\end{remark}


\subsection{Expected values of some permutation statistics}

We start our study by computing how the value of parameter  influences the expected number of records.

\begin{theorem}\label{lem:records}
Under the Ewens-like distribution on  for records with parameter , 
for any , 
the probability that there is a record at position  is: 
.
\end{theorem}

\begin{proof}
We prove this theorem by splitting permutations seen as words after their -th element, as shown in Fig.~\ref{fig:record}.
Let  denote the set of permutations of  having a record at position . 
We claim that the set~ is quotient-stable for , and that . 
It will immediately follow that .
We now prove the claim. 
Let  be any sequence in . 
Observe that . 
Since the number of records is stable by normalization, it follows that . 
By definition,  is in  if and only if . Thus  in the word representation of permutations. 
Hence, , since the last element is a record by definition. 
This yields  for any , 
proving that  is quotient-stable for , 
and that . 
 By Lemma~\ref{lem:qot}, it follows that 
.
\end{proof}

\begin{figure}[ht]
\begin{minipage}[]{.45\textwidth}
\includegraphics[scale=.32]{pitau}
\end{minipage}
\begin{minipage}[]{.54\textwidth}
\caption{The decomposition used to compute the probability of having a record at . 
This record has weight  and thus, for any fixed , the weights of all possible  sum to .\label{fig:record}}
\end{minipage}
\end{figure}


\begin{corollary} \label{thm:nb_of_records}
Under the Ewens-like distribution on  for records with parameter , the expected value of the number of records is: 
.
\end{corollary}

\medskip

Next, we study the expected number of descents. 
Recall that a permutation  of  has a \emph{descent} at position  if
. We denote by  the number of descents in . 
We are interested in descents as they are directly related to the number of increasing runs in a permutation 
(each such run but the last one is immediately followed by a descent, and conversely). 
Some sorting algorithms, like Knuth's Natural Merge Sort, use the decomposition into runs.

The following theorem is proved using Lemmas~\ref{lem:weight prime} and~\ref{lem:qot} and the decomposition of Fig.~\ref{fig:desc}.
\begin{theorem}\label{lem:descent i}
Under the Ewens-like distribution on  for records with parameter , 
for any , 
the probability that there is a descent at position  is: 
. 
\end{theorem}
\begin{figure}[ht]
\begin{minipage}{.49\textwidth}
\includegraphics[scale=.35]{descrecord}
\end{minipage}
\begin{minipage}{.49\textwidth}
\includegraphics[scale=.35]{descnorecord}
\end{minipage}
\caption{The two cases for the probability of having a descent at . 
We decompose  as , and we let .
On the left, the case where  is a record, that is, : there are  possibilities for . 
On the right, the case where  is not a record: there are  possibilities for the values of  and . 
In both cases, once the images of  by  have been chosen, the weight of all possible beginnings sum to .\label{fig:desc}}
\end{figure}

\begin{corollary}\label{thm:nb_of_descents}
Under the Ewens-like distribution on  for records with parameter , the expected value of the number of descents is: 
.
\end{corollary}
In the second row of Table~\ref{table:asymptotics}, remark that the only way of obtaining a sublinear number of descents is to take very large values for .


\medskip

Finally, we study the expected value of . 
We are interested in this statistic to show a proof that differs from the ones for
the numbers of records and descents: the expected value of the first element of a permutation is not obtained using Lemma~\ref{lem:qot}. 

\begin{lemma}\label{lem:first_value>k}
Under the Ewens-like distribution on  for records with parameter , 
for any , 
the probability that a permutation starts with a value larger than  is: 
. 
\end{lemma}

\begin{proof}
Let  denote the set of permutations of  such that . 
Such a permutation can uniquely be obtained by choosing the preimages of the elements in 
in , then by mapping bijectively the remaining elements to
. Since none of the elements in  is a record and since
the elements of  can be ordered in all possible ways, we get
that . Indeeed,there are
 ways to position and order the elements of , and the total weight of the elements larger than  is .
Hence, .
\end{proof}


\begin{theorem}\label{cor:first_value=k}
Under the Ewens-like distribution on  for records with parameter , 
for any , 
the probability that a permutation starts with  is: 
.
\end{theorem}

\begin{corollary}\label{thm:first_value}
Under the Ewens-like distribution on  for records with parameter , the expected value of the first element of a permutation is: 
.
\end{corollary}

\begin{remark}
Our proof of Corollary~\ref{thm:first_value} relies on calculus, but gives a very simple expression for . 
We could therefore hope for a more combinatorial proof of Corollary~\ref{thm:first_value}, but we were not able to find it.
\end{remark}

\subsection{Number of inversions and expected running time of \InsertSort}\label{sec:insertion}

Recall that an \emph{inversion} in a permutation  is a pair  such that  and . 
In the word representation of permutations, this corresponds to a pair of elements in which the largest is to the left of the smallest. 
This equivalent definition of inversions naturally generalizes to sequences of distinct integers. 
For any , we denote by  the number of inversions of , 
and by  the number inversions of the form  in , for any . 
More formally, .


\begin{theorem}\label{lem:inversion_at_j}
Under the Ewens-like distribution on  for records with parameter , 
for any  and , 
the probability that there are  inversions of the form  is: 
 if  
and  if . 
\end{theorem}

\begin{corollary}\label{thm:nb_of_inversions}
Under the Ewens-like distribution on  for records with parameter , the expected value of the number of inversions is: 
.
\end{corollary}

Recall that the \InsertSort algorithm works as follows: at each step
, the first  elements are already sorted, and the
-th element is then inserted at its correct place, by swapping the needed elements. 

It is well known that the number of swaps performed by \InsertSort when applied to  is equal to the number of inversions  of . 
Moreover, the number of comparisons  performed by the algorithm satisfies  
(see~\cite{CoLeRi01} for more information on \InsertSort).

As a direct consequence of Corollary~\ref{thm:nb_of_inversions} and the asymptotic estimates of the fourth row of Table~\ref{table:asymptotics}, 
we get the expected running time of \InsertSort:
\begin{corollary}\label{cor:insert sort}
Under the Ewens-like distribution for records with parameter , the expected running time of \InsertSort is , like under the uniform distribution. 
If  with , it is . If , it is .
\end{corollary}

\section{Expected Number of Mispredictions for the Min/Max Search}\label{sec:mispredictions}

\subsection{Presentation}\label{sec:presentation}
In this section, we turn our attention to a simple and classical problem: computing both the minimum and the maximum of an array of size~. The straightforward approach (called {\em naive} in the sequel) is to compare all the elements of the array to the current minimum and to the current maximum, updating them when it is relevant. This is done\footnote{Note that, for consistency, our arrays start at index~1, as stated at the beginning of this paper.} in Algorithm~\ref{algo:naiveMinMax} and uses exactly  comparisons.
A classical optimization is to look at the elements in pairs, and to compare the smallest to the current minimum and the largest to the current maximum (see Algorithm~\ref{algo:32MinMax}). This uses only  comparisons, which is optimal.
However, as reported in~\cite{AuNiPi16}, with an implementation in~C of these two algorithms, the naive algorithm proves to be the fastest on uniform permutations as input. The explanation for this is a trade-off between the number of comparisons involved and an other inherent but less obvious factor that influences the running time of these algorithms: the behavior of the branch predictor.
\SetKw{KwBy}{by} 

\noindent
\begin{minipage}{.41\textwidth}
\begin{small}
\begin{algorithm}[H]
\DontPrintSemicolon
  \;
  \;
  \smallskip
  \For{ i  2 \KwTo  }{    \nllabel{line:naiveFor1}
    \If{  }{              \nllabel{line:naiveIf1}
      
    }
    \If{  }{              \nllabel{line:naiveIf2}
      
    }
  }                                   \nllabel{line:naiveFor2}

  \Return 
\caption{ \textsc{naiveMinMax} \label{algo:naiveMinMax}}
\end{algorithm}
\end{small}

\medskip
\end{minipage}  
\hfill
\begin{minipage}{.54\textwidth}
\vspace{0pt}  
\begin{algorithm}[H]
\begin{small}
\DontPrintSemicolon
  \;
  \For{ i  2 \KwTo  \KwBy  }{
    \If{  }{                       \nllabel{line:3demiIfPrincipal}
	        
    }
    \lElse{
      
    }
    \smallskip
    \lIf{  }{ }   \nllabel{line:3demiIfMin}
    \smallskip
	\lIf{  }{ }   \nllabel{line:3demiIfMax}  
  }
  \Return 
\caption{ \textsc{3/2-MinMax} \label{algo:32MinMax}}
\end{small}
\end{algorithm}
\medskip
\end{minipage}

In a nutshell, when running on a modern processor, the instructions that constitute a program are not executed strictly sequentially but instead, they usually overlap one another since most of the instructions can start before the previous one is finished. This mechanism is commonly described as a {\em pipeline} (see~\cite{HePa11} for a comprehensive introduction on this subject). However, not all instructions are well-suited for a pipelined architecture: this is specifically the case for branching instructions such as an \emph{if} statement. When arriving at a branch, the execution of the next instruction should be delayed until the outcome of the test is known, which stalls the pipeline. To avoid this, the processor tries to predict the result of the test, in order to decide which instruction will enter the pipeline next.
If the prediction is right, the execution goes on normally, but in case of a {\em misprediction}, the pipeline needs to be flushed, which can significantly slow down the execution of a program.

There is a large variety of branch predictors, but nowadays, most processors use {\em dynamic} branch prediction: 
they remember partial information on the results of the previous tests at a given \emph{if} statement, 
and their prediction for the current test is based on those previous results.
These predictors can be quite intricate, but in the sequel, we will only consider local {\em 1-bit predictors} which are state buffers associated~to each \emph{if} statement: they store the last outcome of the test and guess that the next outcome will be the same. 

Let us come back to the problem of simultaneously finding the minimum and the maximum in an array. 
We can easily see that, for Algorithm~\ref{algo:naiveMinMax}, the behavior of a 1-bit predictor when updating the maximum (resp. minimum) 
is directly linked to the succession of records (resp. min-records\footnote{
A \emph{min-record} (a.k.a. left to right minimum) is an element of the array such that no smaller element appears to its left.}) 
in the array. 
As we explain later on, for Algorithm~\ref{algo:32MinMax}, this behavior depends on the ``pattern'' seen 
in four consecutive elements of the array, this ``pattern'' indicating not only which elements are records (resp. min-records), 
but also where we find descents between those elements. 
As shown in~\cite{AuNiPi16}, for uniform permutations, Algorithm~\ref{algo:naiveMinMax} outerperforms Algorithm~\ref{algo:32MinMax}, 
because the latter makes more mispredictions than the former, compensating for the fewer comparisons made by Algorithm~\ref{algo:32MinMax}. 
This corresponds to our Ewens-like distribution for . 
But when  varies, the way records are distributed also changes, influencing the performances of both Algorithms~\ref{algo:naiveMinMax} and~\ref{algo:32MinMax}. 
Specifically, when , we have a linear number of records (as opposed to a logarithmic number when ). 
The next subsections provide a detailed analysis of the number of mispredictions in Algorithms~\ref{algo:naiveMinMax} and~\ref{algo:32MinMax}, 
under the Ewens-like distribution for records, with a particular emphasis on 
(which exhibits a very different behavior w.r.t. the uniform distribution -- see Fig.~\ref{fig:compare}). 


\subsection{Expected Number of Mispredictions in NaiveMinMax}\label{sec:naive}

\begin{theorem} \label{thm:misprediction_naive}
Under the Ewens-like distribution on  for records with parameter , 
the expected numbers of mispredictions at lines~\ref{line:naiveIf1} and~\ref{line:naiveIf2} of Algorithm~\ref{algo:naiveMinMax} satisfy respectively
 and 
.
\end{theorem}
Consequently, with our previous results on , 
the expected number of mispredictions at line~\ref{line:naiveIf1} is  when  (\emph{i.e.}, when  is constant or larger). 
Moreover, using the asymptotic estimates of the digamma function, 
the asymptotics of the expected number of mispredictions at line~\ref{line:naiveIf2} is such that (again, for ,  and ): 
\begin{center}
\begin{tabular}{c|c|c|c|c}
& fixed  &   &  &  \\
\hline 
 &  &  &  & 
\end{tabular}
\end{center}
In particular, asymptotically, the expected total number of mispredictions of Algorithm~\ref{algo:naiveMinMax} is given by  
(up to a constant factor when  is constant). 

\subsection{Expected Number of Mispredictions in \texorpdfstring{}-MinMax}\label{sec:optimal}

Mispredictions in Algorithm~\ref{algo:32MinMax} can arise in any of the three \emph{if} statements. 
We first compute the expected number of mispredictions at each of them independently. 
We start with the \emph{if} statement of line~\ref{line:3demiIfPrincipal}, which compares  and . For our 1-bit model, there is a misprediction whenever
there is a descent at  and an ascent at , or an ascent at  and a descent at . A tedious study of all possible cases gives:

\begin{theorem}\label{thm:32-first-if}
Under the Ewens-like distribution on  for records with parameter , 
the expected number of mispredictions at line~\ref{line:3demiIfPrincipal} of Algorithm~\ref{algo:32MinMax} satisfies

As a consequence,
if , then . 
\end{theorem}


\begin{theorem}\label{thm:32-second-if}
Under the Ewens-like distribution on  for records with parameter , 
the expected number of mispredictions at line~\ref{line:3demiIfMin} of Algorithm~\ref{algo:32MinMax} satisfies
. As a consequence, if , then . 
\end{theorem}

We now consider the third \emph{if} statement of Algorithm~\ref{algo:32MinMax}. 
If there is a record (resp. no record) at position  or , then there is a misprediction when there is no record (resp. a record) at position  or . Studying all the possible configurations at these four positions gives the following result. 
\begin{theorem}\label{thm:32-third-if}
Under the Ewens-like distribution on  for records with parameter , 
the expected number of mispredictions at line~\ref{line:3demiIfMax} of Algorithm~\ref{algo:32MinMax} satisfies

As a consequence,
if , then .
\end{theorem}
It follows from Theorems~\ref{thm:32-first-if},~\ref{thm:32-second-if} and~\ref{thm:32-third-if} that:
\begin{corollary}
Under the Ewens-like distribution on  for records with parameter , 
the total number of mispredictions of Algorithm~\ref{algo:32MinMax} is 

\end{corollary}

Fig.~\ref{fig:compare} shows that, unlike in the uniform case (), Algorithm~\ref{algo:32MinMax} is more efficient than Algorithm~\ref{algo:naiveMinMax} 
under the Ewens-like distribution for records with , as soon as  is large enough.
\begin{figure}[ht]
\begin{minipage}{.35\textwidth}
\vspace*{0.5em}
\includegraphics[scale=.98]{compare}
\end{minipage}
\begin{minipage}{.63\textwidth}
\caption{The expected number of mispredictions produced by the naive algorithm () and for -minmax (), when . We have
 for , 
and there are fewer mispredictions on average with -minmax as soon as .
However, since -minmax performs  fewer comparisons than the naive algorithm, it becomes more efficient before . 
For instance, if a misprediction is worth  comparisons, -minmax is the most efficient as soon as .\label{fig:compare}}
\end{minipage}
\end{figure}


\paragraph{Acknowledgments} Many thanks to Valentin Féray for providing insight and references on the classical Ewens distribution and to the referees whose comments helped us clarify the presentation of our work.

\bibliographystyle{plain}
\begin{small}
\bibliography{aofa2016_aubonipi}
\end{small}

\end{document}
