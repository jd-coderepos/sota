\documentclass{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} 



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

\newcommand{\form}{FORM \xspace}
\newcommand{\gail}{GAIL \xspace}

 
\usepackage{hyperref}


\usepackage{authblk}

\usepackage{appendix}

\usepackage{float}

\newcommand{\theHalgorithm}{\arabic{algorithm}}

\usepackage[accepted]{arxiv2021}

\arxivtitlerunning{Perceiver: General Perception with Iterative Attention}

\begin{document}

\newcommand{\mycomment}[3]{{\textcolor{#3}{#1 #2}}}
\newcommand{\drewmarker}[1]{\textcolor{blue}{\emph{Drew:} #1}}
\newcommand{\tododrew}[1]{\textcolor{blue}{\emph{TODO(Drew):} #1}}

\newcommand{\joaomarker}[1]{\textcolor{blue}{\emph{Joao:} #1}}
\newcommand{\todojoao}[1]{\textcolor{blue}{\emph{TODO(Joao):} #1}}

\newcommand{\felixmarker}[1]{\textcolor{magenta}{\emph{Felix:} #1}}
\newcommand{\todofelix}[1]{\textcolor{magenta}{\emph{TODO(Felix):} #1}}

\definecolor{orange}{RGB}{244, 122, 47}
\definecolor{my_green}{RGB}{74, 184, 72}
\definecolor{my_blue}{RGB}{23, 117, 187}


\twocolumn[
\arxivtitle{Perceiver: General Perception with Iterative Attention}

\arxivsetsymbol{equal}{*}

\begin{arxivauthorlist}
\arxivauthor{Andrew Jaegle}{dm}
\arxivauthor{Felix Gimeno}{dm}
\arxivauthor{Andrew Brock}{dm}
\arxivauthor{Andrew Zisserman}{dm}
\arxivauthor{Oriol Vinyals}{dm}
\arxivauthor{Joao Carreira}{dm}
\end{arxivauthorlist}

\arxivaffiliation{dm}{DeepMind -- London, UK}

\arxivcorrespondingauthor{Andrew Jaegle}{drewjaegle@google.com}

\arxivkeywords{Perceiver, Transformer, Attention, Cross-attention, Image Transformers, Vision Transformer, Multimodal, ImageNet, AudioSet, ModelNet}

\vskip 0.3in
]





\printAffiliationsAndNotice{}

\begin{abstract}
Biological systems understand the world by simultaneously processing high-dimensional inputs from modalities as diverse as vision, audition, touch, proprioception, etc.
The perception models used in deep learning on the other hand are designed for individual modalities, often relying on domain-specific assumptions such as the local grid structures exploited by virtually all existing vision models. These priors introduce helpful inductive biases, but also lock models to individual modalities.
In this paper we introduce \textit{the Perceiver} -- a model that builds upon Transformers and hence makes few architectural assumptions about the relationship between its inputs, but that also scales to hundreds of thousands of inputs, like ConvNets. The model  leverages an asymmetric attention mechanism to iteratively distill inputs into a tight latent bottleneck, allowing it to scale to handle very large inputs. We show that this architecture performs competitively or beyond strong, specialized models on classification tasks across various modalities: images, point clouds, audio, video and video+audio. The Perceiver obtains performance comparable to ResNet-50 on ImageNet without convolutions and by directly attending to 50,000 pixels. It also surpasses state-of-the-art results for all modalities in AudioSet.
\end{abstract}

\section{Introduction}
\label{submission}

Inductive biases such as spatial locality in early vision are clearly valuable and are famous for drastically increasing the efficiency of learning perceptual models. But, given the increasingly large datasets available to learn from, is the choice to bake such biases into our models with hard architectural decision the correct one? Or are we better off building in as much flexibility as possible, and encouraging the data to speak for itself~\cite{lecun2015deep}?

One glaring issue with strong archiectural priors is that they are often modality-specific. For example, if we have a single image, a 2D grid will capture the geometry and make it possible to rely on efficient convolutional operations. But if we move to a stereo pair, we are faced with a range of possible choices around how to connect the pixels from both sensors, for example early vs late fusion~\cite{karpathy2014largescale} or summing vs concatenating features. If we move to raw audio inputs, then the merits of a 2D grid are no longer as clear and a different type of model, such as 1D convolutions or an LSTM~\cite{hochreiter1997long,6638947}, may be warranted instead. If we want to incoporate a Lidar sensor, which returns point clouds, then fixed grids introduce additional problems, and so on. Essentially, we currently need to tailor the model to each possible input configuration.

\begin{figure*}[t]
    \centering
    \includegraphics[keepaspectratio,width=1\linewidth]{imgs/architecture.pdf}
    \vspace{-10pt}
    \caption{The Perceiver is an architecture based on attentional principles that scales to high-dimensional inputs such as images, videos, audio, point-clouds (and multimodal combinations) without making any domain-specific assumptions. The Perceiver uses a cross-attention module to project an input high-dimensional byte array to a fixed-dimensional latent bottleneck () before processing it using a stack of transformers in the low-d latent space. The Perceiver iteratively attends to the input byte array by alternating cross-attention and latent transformer blocks.}
    \label{fig:architecture}
    \vspace{-8pt}
\end{figure*}

In this paper we introduce the \textit{Perceiver}, a model that aims to deal with arbitrary configurations of different modalities using a single transformer-based architecture. Transformers~\cite{vaswani2017attention} are very flexible architectural blocks that make few assumptions about their inputs, but that also scale quadratically with the number of inputs in terms of both memory and computation. Recent work has shown impressive performance using transformers on images, but by relying on the pixels' grid structure to reduce computational complexity, either by grouping pixels into patches~\cite{dosovitskiy2020image,touvron2020training}, by factorizing the image into columns and rows~\cite{ho2019axial, child2019generating}, or by aggressive subsampling~\cite{chen2020generative}. Instead we propose a mechanism that makes it possible to deal with high-dimensional inputs, while retaining the expressivity and flexibility to deal with arbitrary input configurations.

Our core idea is to introduce a small set of latent units that forms an attention bottleneck through which the inputs must pass (Fig.~\ref{fig:architecture}). This avoids the quadratic scaling problem of all-to-all attention of a classical transformer.
By attending to the inputs iteratively, the Perceiver can channel its limited capacity to the most relevant inputs, informed by previous steps -- the model can be seen as performing a fully end-to-end clustering of the inputs, with the latent units as the cluster centres,  leveraging a highly asymmetric cross-attention layer. Spatial or temporal information is crucial for many modalities, and we compensate for the lack of explicit grid structures in our model by associating Fourier feature encodings -- recently made popular in both language and vision~\cite{vaswani2017attention, mildenhall2020nerf} -- with every input element (e.g.\ every pixel, or each audio sample). This can be viewed as a way of tagging input units with a position, similar to the labeled lined strategy used to construct topographic maps in biological neural networks by associating the activity of a specific unit with a spatial or semantic location \cite{kandel2012principles}.

We demonstrate performance comparable to strong models such as ResNet-50 when training on ImageNet for classification; state-of-the-art performance on the AudioSet sound event classification benchmark (using raw audio, video, or both); and strong performance relative to comparable approaches on ModelNet-40 point cloud classification. 

\section{Related Work}
\label{sec:related}

\begin{figure*}[t]
\centering
\includegraphics[width=1.0\textwidth]{imgs/datasets.pdf}
\vspace{-12pt}
\caption{We train the Perceiver architecture on images from ImageNet~\cite{deng2009imagenet} (left), video and audio from AudioSet~\cite{gemmeke2017audio} (considered both multi- and uni-modally) (center), and 3D point clouds from ModelNet40~\cite{wu20153d} (right). Essentially no architectural changes are required to use the model on a diverse range of input data.}
\label{fig:modalities}
\vspace{-8pt}
\end{figure*}

ConvNets~\cite{fukushima1980selforganizing, lecun1998gradient, ciresan2011highperformance, krizhevsky2012imagenet} have been the dominant family of architectures for perceptual tasks for nearly the past full decade, thanks to their good performance and scalability. They can handle high-resolution images because of their local type of computation -- convolutions. However, as discussed in the previous section, they offer limited flexibility when combining multiple signals, unlike self-attention based models dominant in language processing -- e.g.\  Transformers~\cite{vaswani2017attention}.

\noindent \textbf{Transformers.}  Transformers are amazingly flexible but scale poorly with the input size because they compare all pairs of inputs. Nevertheless they have been quickly percolating into perception, often as pieces of otherwise convolutional models, such as for images~\cite{bello2019attention,cordonnier2019relationship, srinivas2021bottleneck} and videos~\cite{wang2018non,girdhar2019video}. Among purer transformers some subsample heavily the input~\citealt{chen2020generative}; others self-attend independently on rows and columns ~\cite{ho2019axial,wang2020axial}; others replace convolution with patchwise self-attention \cite{parmar2018image, ramachandran2019standalone, zhao2020exploring}. Most recently the Vision Transformer (ViT)~\cite{dosovitskiy2020image,touvron2020training} shown impressive ImageNet results when pre-training on a giant image dataset, using a BERT-like encoder on  image patch inputs. A number of scalable self-attention variants have also been proposed ~\cite{katharopoulos2020transformers,peng2021random,child2019generating,tay2020long, tay2020efficient, bello2021lambdanetworks}, but they may be insufficient by themselves to achieve good performance on high-dimensional perceptual tasks~\cite{tay2020long}.

\noindent \textbf{Multimodal architectures.}
Currently, separate feature extractors are used for each modality~\cite{kaiser2017one,arandjelovic2018objects,wang2020makes,chen2019uniter,alayrac2020self,lee2020making,xiao2020audiovisual} -- it is not sensible to concatenate an audio spectrogram or a raw audio sequence with an image and pass it through a  ConvNet. A variety of choices then arises such as in which layer to fuse features. Some modalities (e.g. LIDAR) return point clouds and for those there exist specialized models~\cite{qi2017pointnet++,guo2020pct}. The Perceiver aims to handle any combination of inputs out of the box even if they come from very different modalities, including high-bandwidth ones such as images and audio (Fig.~\ref{fig:modalities}).

\noindent \textbf{Bottom-up and top-down processing.} The Perceiver also leverages top-down processing / feedback which has a long history in computer vision~\cite{borenstein2004combining,kumar2005obj,carreira2016human,hu2016bottom} and is theorized to be an important component of human vision~\cite{olshausen1993neurobiological}. Attention to the full set of inputs is influenced by a latent array produced by previous iterations of the model, so it can focus on subsets of inputs that are most promising, in a soft way~\cite{zoran2020towards}. The Perceiver also performs global computations starting from the first layer, which is related to Gestalt-based ideas~\cite{kohler1967gestalt,shi2000normalized}.

\section{Methods}
\label{sec:methods}

\subsection{The Perceiver architecture}

\noindent \textbf{Overview.} We build our model using two architectural components: (i) a cross-attention module that maps a byte array (e.g.\ a pixel array) and a latent array to a latent array, and (ii) a transformer tower that maps a latent array to a latent array. The size of the byte array is determined by the input data and is generally large (e.g.\ ImageNet images at resolution 224 have 50176 pixels), while the size of the latent array is a hyperparameter of the model which is typically much smaller (e.g.\ we use 1024 latents on ImageNet). Our model alternates application of the cross-attention module and the transformer. This corresponds to repeatedly projecting the higher-dimensional byte array through a lower-dimensional attentional bottleneck, before processing it with a deep transformer. Because we share weights between each instance of the transformer tower (and between some instances of the cross-attention module), our model can be interpreted as a recurrent neural network (RNN) (unrolled in depth to the same input, rather than in time to different inputs). All attention modules in the Perceiver are non-causal: we use no masks. The Perceiver architecture is illustrated in Fig.~\ref{fig:architecture}.

\noindent \textbf{Taming quadratic complexity with cross-attention.} We structure our architecture around attention because it is both generally applicable (making less restrictive assumptions about the structure of the input data than e.g.\ ConvNets; it's all you need) and powerful in practice. The main challenge addressed by our architecture's design is taming the quadratic complexity of the attention operation. Both cross-attention and transformer modules are structured around the use of query-key-value (QKV) attention \cite{graves2014neural,weston2014memory,bahdanau2015neural}. QKV attention applies three networks -- the query, key, and value networks, which are typically multi-layer perceptrons (MLPs) -- to each element of an input array, producing three arrays that preserve the index dimensionality (or \textit{sequence length})  of their inputs. The main difficulty of using transformers on images is that the time complexity of QKV self-attention is quadratic in the input index dimensionality, but the index dimensionality of images is typically very large ( for  ImageNet images). The challenge is similar for audio -- 1 second of audio at standard sampling rates corresponds to around 50,000 raw audio samples -- and it becomes much more dramatic for multi-modal data.

For this reason, prior work that uses attention to process images avoids directly applying standard QKV attention to the input pixel array (see section \ref{sec:related} for an overview of the various ways this has been done). Here, we apply attention directly to the inputs by introducing an asymmetry to the attention operation. To see how this works, first note that for   and  the time complexity of the QKV attention operation --  -- is , as it involves two matrix multiplications with matrices of large dimension .\footnote{We ignore the contributions of the channel dimensions  and  here, as they are generally small relative to .} So we introduce asymmetry: while  and  are derived from the input byte array,  is derived from a learned latent array with index dimensionality , where  is a hyperparameter. The resulting cross-attention operation has complexity .

\noindent \textbf{Latent transformer.}
The output of the cross-attention module is dependent only on the input to the Q network: that is, the cross-attention layer induces a bottleneck. Thanks to this bottleneck, we can freely increase the expressiveness of the network by building a deep transformer in the latent space for the low cost of . In practice, this design property allows us to build much deeper transformers than would be otherwise accessible in vision without resorting to an approximation to the (empirically very-well established) QKV attention operation. This design also allows Perceiver-based architectures to make use of much deeper transformers: considered as a function of depth  in addition to index dimensionality, a transformer built on bytes has time complexity  while a latent transformer has complexity . This is key: for example, on ImageNet, our best results use a network with a depth of 48 latent transformer blocks.

Our latent transformer uses the GPT-2 architecture \cite{radford2019language}, which itself is based on the decoder of the original transformer architecture \cite{vaswani2017attention}. In our experiments, we use values of , which makes our latent transformer comparable in dimensionality to models in wide-spread use in the language community. The latent array uses a learned position embedding \cite{gehring2017convolutional}.

\noindent \textbf{Iterative attention.}
The size of the latent array allows us to directly model pixels and to build deeper transformers, but the severity of the bottleneck may restrict the network's ability to capture all of the necessary details from the input signal. To hedge against this effect, the Perceiver is structured with multiple byte-attend layers, which allows the latent array to iteratively extract information from the input image as it is needed (this is related to a skip connection in residual networks). This allows us to tune the model to balance expensive, but informative byte-attends against cheaper, but potentially redundant latent self-attends. Finally, in virtue of the iterative structure of the resulting architecture, we can increase the parameter efficiency of the model by sharing weights between the corresponding blocks of each latent transformer and/or between byte-attend modules. In our ImageNet experiments, weight sharing results in an approximately 10x reduction in the number of parameters, while reducing overfitting and boosting validation performance. The resulting architecture has the functional form of an RNN with a cross-attentional input projection, a bottlenecked latent dimensionality, and a latent transformer recurrent core.

\subsection{Positional encodings}

\begin{table}[t]
\centering
\begin{tabular}{|l|l|}
\hline
\textcolor{red}{ResNet-50 \cite{he2016deep}}            & \textcolor{red}{76.9}          \\ 
\textcolor{red}{ViT-B-16 \cite{dosovitskiy2020image}}   & \textcolor{red}{\textbf{77.9}} \\ \hline
\textcolor{red}{ResNet-50 (RGB+FF)}                     & \textcolor{red}{73.5}          \\ 
\textcolor{red}{ViT-B-16 (RGB+FF)}                      & \textcolor{red}{76.7}          \\ \hline
\textcolor{blue}{Transformer (64x64)}                    & \textcolor{blue}{57.0}          \\ 
\textcolor{blue}{Perceiver}                              & \textcolor{blue}{76.4}          \\ \hline
\end{tabular}
\caption{Top-1 validation accuracy (in \%) on ImageNet. Methods shown in \textcolor{red}{red} exploit domain-specific grid structure, while methods in \textcolor{blue}{blue} do not. The first block reports standard performance from pixels -- these numbers are taken from the literature. The second block shows performance when the inputs are RGB values concatenated with Fourier features (FF) of the xy positions -- the same that the Perceiver receives. This block uses our implementation of the baselines. The Perceiver is competitive with standard baselines on ImageNet while not relying on domain-specific architectural assumptions.}
\label{tab:imagenet}
\vspace{-10pt}
\end{table}

\begin{table}[t]
\centering
\begin{tabular}{|l|l|l|l|l|l|}
\hline
                                       & Fixed          & Random    & Rec. Field   \\ \hline
ResNet-50 (RGB+FF)                     & 39.4           & 14.3      &  49  \\ 
ViT-B-16 (RGB+FF)                      & 61.7           & 16.1      &  256  \\ 
Transformer (64x64)                    & 57.0           & 57.0      &  4,096  \\ \hline
Perceiver                              &  \textbf{76.4} & \textbf{76.4} & 50,176 \\ \hline
\end{tabular}
\vspace{-8pt}
\caption{Top-1 validation accuracy (in \%) on \textbf{permuted} ImageNet. ``Fixed'' = permuted with a constant permutation for all images over the dataset. ``Random'' = random, per-example permutation. Methods that make strong assumptions about the structure of 2D data fare poorly when this structure is removed. All methods receive identical input features (RGB+FF). We also show the receptive field of the input units for each model on the right, in pixels. Note that both Transformer and Perceiver have a global view of all inputs in each first layer unit. ResNet-50 starts with a 7x7 convolution, hence each unit sees 49 pixels, and ViT-B-16 inputs 16x16 patches, hence 256 pixels are seen by each first layer unit.}
\label{tab:imagenet_permuted}
\vspace{-12pt}
\end{table}


\noindent \textbf{Permutation invariance and positional information.} Attention is a permutation-invariant operation, and this property is preserved by the Perceiver and related models \cite{lee2019set}. A purely attentional model will return the same output regardless of the order of its inputs, leaving no trace of the input's ordering on its outputs. This property makes attention-based architectures well-suited for many types of data, as they make no assumptions about which spatial relationships or symmetries to prioritize. In contrast, the ConvNets that are typically used in image processing (\textit{inter alia}, the family of residual networks, or ResNets \cite{he2016deep}) bake in 2D spatial structure in several ways, including by using filters that look only at local regions of space (which makes it easier to capture the relationship between nearby pixels than between distant pixels), by sharing weights across both spatial dimensions (which helps to model data with statistics that are invariant to translation), and by repeatedly applying small filters (which helps to model data with statistics that are invariant to scale).

But permutation invariance means that the Perceiver's architecture cannot in and of itself exploit spatial relationships in the input data. Spatial relationships are essential for sensory reasoning \cite{kant1781critique} and this limitation is clearly unsatisfying. In the attentional literature, positional information is typically injected by tagging \textit{positional encodings} onto the input features \cite{vaswani2017attention}, and this is the strategy we pursue here. While positional information is typically used to encode sequence position in the context of language, it may be used to encode spatial, temporal, and modality identity as well.

\noindent \textbf{Scalable Fourier features.} Here, we use a strategy that has recently gained renewed prominence, both in language and in vision: Fourier feature positional encodings \cite{stanley2007compositional, vaswani2017attention, parmar2018image, tancik2020fourier, mildenhall2020nerf}. We use a parameterization of Fourier features that allows us to (i) directly represent the positional structure of the input data (preserving 1D temporal or 2D spatial structure for audio or images, respectively, or 3D spatiotemporal structure for videos), (ii) control the number of frequency bands in our positional encoding independently of the cutoff frequency, and (iii) log-uniformly sample all frequencies up to a target resolution. 

We parametrize the frequency encoding to take the values , where the frequencies  is the  band of a bank of frequencies spaced log-linearly between 1 and .  can be naturally interpreted as the Nyquist frequency \citep{nyquist1928certain} corresponding to a target maximum resolvable frequency . For example, by allowing the network to resolve the maximum frequency present in an input array, we can encourage it to learn to compare the values of bytes at any positions in the input array.  is the value of the input position along the  dimension (e.g.\ for images  and for video ).  takes values in  for each dimension. We concatenate the raw positional value  to produce the final representation of position. This results in a positional encoding of size .

This parameterization is related to the NeRF positional encoding scheme \cite{mildenhall2020nerf}, which is built around frequency bands with increasing powers of two (the  band has frequency ). This leads to very high frequencies for even modest numbers of bands, and in some experiments, we encountered numerical instability when using this parameterization beyond around  bands. 

In language modelling, transformer inputs are typically produced by adding a positional encoding to the input encoding (the size of the positional encoding is tailored to the encoding used). We found it beneficial to instead concatenate the positional and input features before passing them into the Perceiver. This difference is perhaps explained by the fact that input features in language tend to be larger than the modalities considered here.

\noindent \textbf{Positional encodings are generally applicable.} Does the use of positional encodings undermine our claim to be moving from a more domain-specific architecture built to exploit 2D structure to a more general ones? No, for three reasons. \textbf{First,} while the architectural imposition of positional information hard codes a specific positional prior, the feature-based approach allows the network to learn how to use (or ignore) the positional structure. This is in accord with the idea that greater generality follows from making as much of a system learnable as possible \cite{sutton2019bitter}. \textbf{Second,} it is possible to redesign architectural priors for data domains with different structures, such as videos (e.g. \citealt{tran2015learning} or audio~\cite{ford2019deep}, or for groups other than the group of linear translations (e.g. \citealt{cohen2016group, bronstein2017geometric, esteves2018learning})); this however often requires a tremendous amount of researcher time and expertise. In contrast, a positional encoding can be easily adapted to a new domain: Fourier features are trivial to adapt as long as the input dimensionality is relatively small and known. In the broader transformer literature, simple learned positional encoding have proven to be sufficient for good results in many settings. \textbf{Third,} positional encodings can be naturally extended to multimodal data: each domain can use a positional coding with the correct dimensionality for its data, with categorical positional encodings used to distinguish domains.

\section{Experiments}

The next few subsections are organized according to modalit\{y, ies\} used (illustrated in Fig.~\ref{fig:modalities}). We evaluate model ablations on ImageNet classification in the supplement (Sec.~\ref{sec:supp_ablations}). As baselines we consider ResNet-50~\cite{he2016deep}, possibly one of the closest things so far to a general perceptual architecture as it is widely used for both vision and audio. We also consider two transformer variants, the recent ViT-B~\cite{dosovitskiy2020image}, and a stack of Transformers~\cite{vaswani2017attention}.

\subsection{Images -- ImageNet}

\begin{figure*}
    \centering
    \includegraphics[keepaspectratio,width=0.9\linewidth]{imgs/attention_maps.pdf}
    \vspace{-12pt}
    \caption{Attention maps from the \textbf{\textcolor{my_blue}{first}}, \textbf{\textcolor{my_green}{second}}, and \textbf{\textcolor{orange}{eighth}} (final) cross-attention layers of our best-performing model on ImageNet (see Table \ref{tab:imagenet}). Cross-attention modules 2-8 share weights in this model. \textbf{Row 1:} Original image and close-ups of one attention map from each of these layers. \textbf{Rows 2-4:} Overview of the attention maps of the cross-attention modules. Attention maps appear to scan the input image using tartan-like patterns at a range of spatial frequencies. The visualized attention maps are \textit{not} overlaid on the input image: any apparent image structure is present in the attention map itself (the input dog is clearly visible in several of the first module's attention maps).}
    \label{fig:attention_map}
    \vspace{-12pt}
\end{figure*}

First, we consider the task of single-image classification using the ILSVRC 2012 split of the ImageNet dataset \cite{deng2009imagenet}. ImageNet has been a crucial bellwether in the development of architectures for image recognition~\cite{krizhevsky2012imagenet,simonyan2014very,szegedy2015going,he2016deep} and, until recently, it has been dominated by ConvNet architectures. Each image on ImageNet has a single label so we use softmax outputs and a cross-entropy loss to train for the classification task. As is standard practice, we evaluate our model and all baselines using the top-1 accuracy on the held-out validation set (the test set is not publicly available). We train our model using images sampled by Inception-style preprocessing \cite{szegedy2015going}, including standard  pixel crops. Additionally, we augment all images using RandAugment \cite{cubuk2020randaugment} at training time.

\noindent \textbf{Positional encodings.} We generate positional encodings by first using the (x, y) positions on the  input crop. (x, y) coordinates are standardized to [-1, 1] for each dimension of a crop. In Inception-style preprocessing, the raw crop can have a non-uniform aspect ratio, which may lead to aspect ratio distortion in both the input crop and in the (x, y) coordinates used to generate the positional encoding. In early experiments, we tried using image coordinates rather than crop coordinates as the basis of the positional encoding, but we found that this led to model overfitting. We suspect that this occurs because the Perceiver's architecture may allow it to memorize training-set image by latching onto a small number of input pixels, if they are always associated with the same (RGB, position) feature. By using crops, we effectively introduce augmentation in both position and aspect ratio, which breaks correlations between RGB values and positional features and makes it much harder to associate an image label with a small number of pixels.

\noindent \textbf{Optimization and hyperparameters.} Although it is typical to train convolutional networks on ImageNet using SGD, we found it easier to optimize Perceiver models using the Lamb optimizer \cite{you2020large}, which was developed for optimizing transformer-based models. We trained models for 120 epochs with an initial learning rate of 0.004, decaying it by a factor of 10 at 84, 102, and 114 epochs. The best-performing Perceiver we identified on ImageNet attends to the input image 8 times, each time processing the full 50,176-pixel input array using a cross-attend module and a latent transformer with 6 blocks. The cross-attend module employs only a single head. The dense subblock of each transformer block included no bottleneck, using the same number of channels throughout. We used a latent array with 1024 indices and 512 channels, and positional encodings generated with 64 bands and a maximum resolution of 224 pixels. On ImageNet, we found that models of this size overfit without weight sharing, so we use a model that shares weights for all but the first cross-attend and latent transformer modules. The resulting model has  million parameters, making it comparable in size to convolutional models used on ImageNet.

\noindent \textbf{Standard ImageNet.} As shown in Table~\ref{tab:imagenet}, the Perceiver model we trained on ImageNet obtains results that are competitive with models specifically designed for processing images. To account for the Perceiver's use of Fourier features at input, we trained versions of the benchmark models with this input as well and found that it produced comparable, if slightly worse, performance to results from these models on solely RGB input. Additionally, we tested the performance of a pure transformer model. Because transformers cannot handle ImageNet-scale data, we first downsampled the input images to  before passing it into the transformer (we obtained similar results using 96x96 inputs, which however is much slower to train and more memory-intensive so we could not use as many layers). The transformer model we consider has the same architecture as the latent transformer of the Perceiver, differing only in hyperparameters (we swept each model independently), for more details please consult the supp. material.

\noindent \textbf{Permuted ImageNet.} To evaluate how important domain-specific assumptions about grid structure are to the performance of the benchmark methods, we evaluate all methods on two permuted versions of ImageNet. In the first, we use a single permutation on all images, which potentially allows models to exploit correlations based on where they are placed in the permuted image. In the second, we randomly permute all pixels on each image independently. This effectively prevents architectures from exploiting any spatial information  (such as local patch structure) not present in the positional encoding. The results of this experiment are shown in Table~\ref{tab:imagenet_permuted} We find that the performance of both ViT and ResNet models suffer dramatically in these conditions. As the transformer and Perceiver effectively treat any input as a permuted input, their results are not affected. Both ViT and ResNet models perform better on fixed permutation conditions, suggesting their architectures are still able to exploit the structure present in this data, even though it no longer conveys spatial information in the usual sense. 

On the face of it, this experiment may appear contrived -- we know the grid structure, so why don't we use it ? --  but it provides a convenient model of the challenges presented by certain modalities (e.g. point clouds are not trivially to map to a 2D grid and we consider this modality in a later subsection), or in combining modalities -- e.g. what is the right grid structure when combining audio and video, or touch sensors and smell sensors?


\noindent \textbf{Attentional maps.} Fig.~\ref{fig:attention_map} visualizes the attention maps at several cross-attentional modules for a few example images. Each attentional map shows the output of the  operation along one of the model's 512 channels at each input pixel. This model uses unshared weights in its initial cross-attention and latent transformer modules, but shares weights for all subsequent layers. The initial and later cross-attentional layers produce qualitatively different attention maps: while the early modules shows clear traces of the input image (the input dog pops out in many attention maps), the attention maps of later modules manifest as high-frequency plaid lattices. Note that while the attention maps for modules 2 and 7 show similar structure, the specific details of corresponding maps do vary, which suggests the network attends to different sets of pixels at subsequent stages. The banded, variable-frequency structure of the attention maps appears to reflect the spatial frequency structure of the Fourier feature positional encodings used on ImageNet.

\subsection{Sound and video -- AudioSet}

We experimented with audio event classification in video using the AudioSet dataset~\cite{gemmeke2017audio} -- a large dataset with 10s long 1.7M training videos and 527 classes. Videos may have multiple labels so we use a sigmoid cross entropy loss and evaluate using mean average precision (mAP). We evaluate the Perceiver separately on raw audio, video, and raw audio + video inputs. We sample 32-frame clips (1.28s at 25fps) in training; for evaluation we split the videos into 8 32-frame clips, to cover the whole 10s, and average the scores. To augment, we randomly flip and crop to 256x256 resolution. For audio we simply sample in time, consistently with the video sampling.

Given the scale of the dataset we used a faster version of the ImageNet model with only 2 attention iterations instead of 8, but 8 transformer blocks per iteration instead of 6 -- also no weight sharing to compensate for smaller size. We experimented briefly with temporal unrolling -- e.g. one iteration per frame -- which is more efficient and seemed fine for video, but hurt performance for audio. Audio may require longer attentional context.

\begin{table*}[]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
Model / Inputs                                      & Audio        & Video         & A+V            \\ \hline
Benchmark~\cite{gemmeke2017audio}                   & 31.4         &  -            &  -             \\ 
Attention~\cite{kong2018audio}                      & 32.7         & -             & -              \\ 
Multi-level Attention ~\cite{yu2018multi}           & 36.0         & -             & -              \\ 
ResNet-50~\cite{ford2019deep}                       & 38.0         &  -            &  -             \\ 
CNN-14~\cite{kong2020panns}                         & 43.1         &  -            &  -             \\
CNN-14 (no balancing \& no aug) ~\cite{kong2020panns} & 37.5       &  -            &  -             \\ \hline
G-blend~\cite{wang2020makes}                        & 32.4         & 18.8          & 40.2           \\
Attention AV-fusion~\cite{fayek2020large}           & 38.4         & 25.7          & 46.2           \\ \hline
Perceiver                                           & \textbf{44.9} & \textbf{38.0} & \textbf{47.3} \\ \hline
\end{tabular}
\caption{Perceiver performance on AudioSet, compared to state-of-the-art models (mAP, larger is better). Best current results in bold.}
\label{tbl:audioset}
\vspace{-8pt}
\end{table*}

\noindent \textbf{Raw audio.} We use audio sampled at 48Khz, resulting in 61,440 inputs to the Perceiver, over 1.28s of video. The model performs the two byte-attend iterations over all of those inputs. We observed improvements by using Fourier features not just on the time dimension (mapped from -1 to 1) but also on the audio magnitude (which also takes values in -1 to 1)  -- this produced mAP boosts of up to 1.0\%. 

\noindent \textbf{Video.} A full 32 frame clip at 256x256 resolution has more than 2 million pixels, which would at best make our model very slow. Here we experimented using tiny space-time patches with dimensions 2x4x4, resulting in a total of 65,536 inputs to the Perceiver. Fourier features are computed for horizontal, vertical and time coordinates (scaled to -1,1), and concatenated with the RGB values. The exact same model is used as for audio, also performing two iterations of attention but now over the space-time patches.

\noindent \textbf{Raw audio + video.} In this experiment we feed  the Perceiver with both of the previous inputs: 65,536 space-time patches + 61,440 audio samples for a total of 126,976 inputs. Since the fusion of the modalities happens at the input, we need them to have the same dimensionality. We achieve this by concatenating an extra modality-specific learned embedding of different sizes to each -- we fix the video extra embedding to be of size 8 and the audio embedding to be as large as needed for the input dimensionalities to be the same. This worked better than simply passing the audio embedding through a linear layer with as many outputs as the dimensionality of the video inputs.

\noindent \textbf{Results.} Table~\ref{tbl:audioset} shows that the Perceiver obtains state-of-the-art results by a good margin on the video-only experiment and  also gets the best results on audio. On audio+video the improvement is smaller but still state-of-the-art. On audio the Perceiver gets 44.9, better than the CNN-14 model ~\cite{kong2020panns} which gets 43.1 mAP -- note that, unlike ~\cite{kong2020panns} we did not use SpecAugment~\cite{park2019specaugment} nor AugMix~\cite{hendrycks2019augmix}, nor did we class-balance the data -- we hope to do so in future work. Without these improvements the CNN-14 model underperforms the Perceiver by a considerable margin (37.5 mAP). 

We visualize video and audio attention maps of our best model in Figs.~\ref{fig:video_attention_map} and \ref{fig:audio_attention_map} (see Appendix Sec.~\ref{sec:audiovisual_viz} for a discussion).

\subsection{Point clouds -- ModelNet40}

ModelNet40~\cite{wu20153d} is a dataset of point clouds derived from 3D triangular meshes spanning 40 man-made categories. The task is to predict the class of each object, given the coordinates of ~2000 points in 3D space. It is small compared to other datasets used in our experiments: it has 9,843 examples for training and 2,468 for testing, each example has 2048 points with 3D coordinates. We preprocess point clouds by zero-centering them. To augment in training we apply random per-point scaling (between 0.99 and 1.01) and per-point translation (between -0.02 and 0.02), followed by zero-mean and unit-cube normalization and random point-cloud rotation.

\begin{table}[t]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
                                                      & Accuracy                         \\ \hline
\textcolor{red}{PointNet++~\cite{qi2017pointnet++}}   &  \textcolor{red}{\textbf{91.9}}  \\ \hline
\textcolor{blue}{ResNet-50 (FF)}                      &  \textcolor{blue}{66.3}          \\        
\textcolor{blue}{ViT-B-2 (FF)}                        &  \textcolor{blue}{78.9}          \\        
\textcolor{blue}{ViT-B-4 (FF)}                        &  \textcolor{blue}{73.4}          \\        
\textcolor{blue}{ViT-B-8 (FF)}                        &  \textcolor{blue}{65.3}          \\        
\textcolor{blue}{ViT-B-16 (FF)}                       &  \textcolor{blue}{59.6}          \\        
\textcolor{blue}{Transformer (44x44)}                 &  \textcolor{blue}{82.1}          \\ \hline
\textcolor{blue}{Perceiver}                           &  \textcolor{blue}{\textbf{85.7}} \\ \hline

\end{tabular}
\caption{Top-1 test-set classification accuracy (in \%) on ModelNet40. Higher is better. We report best result per model class, selected by test-set score. There are no RGB features nor a natural grid structure on this dataset. We compare to the generic baselines considered in previous sections with fourier feature embeddings of positions, as well as to a specialized model: PointNet++~\cite{qi2017pointnet++}. \textcolor{red}{PointNet++} uses extra geometric features and performs more advanced augmentations that we did not consider here and are not used for the models in \textcolor{blue}{blue}. 
\label{modelnet40}}
\vspace{-12pt}
\end{table}

We found that the Perceiver positional encoding benefited from a higher maximum frequency on ModelNet40 (256) than for image data. Unlike video or audio, we did not set this value according to the sample rate of the data, but by sweeping different resolutions. Values higher than 256 generally led to more severe overfitting.

Note that state-of-the-art methods on this benchmark are quite small and also perform much more sophisticated data augmentation / feature engineering procedures, including fitting surfaces to the point clouds and using face normals as additional points~\cite{qi2017pointnet++}. Here we are mostly interested in comparing to more generic models such as the ImageNet baselines and to assess how the various models deal with data that does not conform to a grid. Results of the Perceiver compared to the baselines are shown in table~\ref{modelnet40}. We arrange each point cloud into a 2D grid randomly, then feed it through each model. For ViT we experimented varying the patch size that the model assumes at the input.

\section{Discussion}

We have presented the Perceiver, a transformer-based model that scales to more than a hundred thousand inputs. This opens new avenues for general perception architectures that make few assumptions about their inputs and that can handle arbitrary sensor configurations, while enabling fusion of information at all levels -- in bottom-up and top-down fashion.

With great flexibility comes great overfitting, and many of our design decisions were made to mitigate this. In future work, we would like to pre-train our image classification model on very large scale data~\cite{dosovitskiy2020image}. Our clearest results were obtained on the large AudioSet dataset, which has 1.7M examples and where the Perceiver performed above strong and recent state-of-the-art entries on audio, video and both combined. On ImageNet the model is essentially on par with ResNet-50. When comparing these models across all different modalities and combinations considered in the paper, the Perceiver does best overall. 

While we reduced the amount of modality-specific prior knowledge in the model, we still employ modality-specific augmentations and positional embeddings. End-to-end modality-agnostic learning remains an interesting research direction. 

\section*{Acknowledgements}

We are grateful to Sander Dieleman and Matt Botvinick for reviewing drafts of the paper, to Adri\`{a} Recasens Continente and Luyu Wang for help with AudioSet, and to Chris Burgess, Fede Carnevale, Mateusz Malinowski, Lo\"{i}c Matthey, Evan Shelhamer, Greg Wayne, Chen Yan, Daniel Zoran and others at DeepMind for helpful conversations and suggestions.

\bibliography{perceiver}
\bibliographystyle{arxiv2021}

\appendix
\appendixpage

\section{Ablations}
\label{sec:supp_ablations}

\begin{figure}[]
    \centering
    \subfigure[Crop-relative coordinates]{\label{fig:a}\includegraphics[width=0.23\textwidth]{imgs/cropped_b.pdf}}
    \subfigure[Image-relative coordinates]{\label{fig:b}\includegraphics[width=0.23\textwidth]{imgs/cropped_a.pdf}}
    \caption{For ImageNet experiments, we generate positional encodings using [-1, 1]-normalized (x, y)-coordinates drawn from (a) crops rather than from the (b) raw images, as we find the latter leads to overfitting.}
    \label{fig:cropping}
    \vspace{-6pt}
\end{figure}

For ablations we considered a small Perceiver base model and swept a number of options around it. Unlike ConvNets, each module in a Perceiver-based architecture has a view on the full input byte array: this makes it possible to sweep processing hyperparameters (e.g.\ depth, capacity, etc.), without reducing the effective receptive field size of the network as a whole. The base model did not reuse transformer nor cross-layer parameters, used 8 heads per transformer block, 4 transformers per byte-attend, performed 2 byte-attends per image and has 512 latents -- each 512-dimensional. Results are reported as top-1 accuracy. We used a small batch size of 64 across 32 TPUs to make sure all models fit comfortably in memory no matter how extreme the parameters. We trained all models for 5 million steps using a similar optimization procedure as in the main paper. 

Results are shown in Fig.~\ref{fig:plots} and suggest that increasing the size of the model tends to  be generally valuable. The exception in this experiment was the number of latent dimensions --  optimization seemingly became unstable when using 1024 dimensions.


\section{Architectural details}

\begin{figure*}[t]
    \centering
\includegraphics[keepaspectratio,width=0.24\linewidth]{imgs/supp_latent_dimensions.pdf}
    \includegraphics[keepaspectratio,width=0.24\linewidth]{imgs/supp_latents.pdf}
    \includegraphics[keepaspectratio,width=0.24\linewidth]{imgs/supp_attends.pdf}
    \includegraphics[keepaspectratio,width=0.24\linewidth]{imgs/supp_transformers_per_attend.pdf}
\caption{Ablations around a basic Perceiver architecture. Increasing the number of latents, attends and transformers per attends always seems to help.}
    \label{fig:plots}
\end{figure*}

The Perceiver consists of two modules: a cross-attention module and a transformer. In the cross-attention module, inputs are first processed with layer norm \cite{ba2016layer} before being passed through linear layers to produce each of the query, key, and value inputs to the QKV cross-attention operation. The output of attention is passed through an additional linear layer. We apply dropout to this linear layer.

In the self-attention block, inputs are processed with layer norm and passed through query, key, and value layers before being used to compute QKV self-attention. The output is passed through another linear layer, to which dropout is applied.

Each cross-attention and self-attention block is followed by a dense (multi-layer perceptron) block. In the dense block, inputs are processed with layer norm, passed through a linear layer, activated with a GELU nonlinearity \cite{hendrycks2016gelu}, and passed through a final linear layer (to which dropout is applied).


All linear layers (including query, key, and value layers and dense block layers) preserve the dimensionality of their inputs and are tiled over input index dimensions (i.e. applied as a 1  1 convolution).

As with other transformer architectures, the Perceiver's transformer has a fully residual design, and its input is always added to its output for further processing. This applies to cross-attention modules as well: the latent component of the input is added to its output. We give details on the hyperparameters used on different datasets in the main paper.




\section{Positional encodings and Fourier features}

\noindent \textbf{Crop-relative coordinates.} As described in the main paper, we found that generating positional coordinates using cropped data rather than on the raw data was important to prevent excessive overfitting. We illustrate the cropping procedure on ImageNet in Fig.~\ref{fig:cropping}.

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
                                                                 \hline
                  & Valid         & Train       & Params   \\ \hline
No weight sharing & 72.9          & 87.7        & 331.3M         \\ \hline
W/ weight sharing & \textbf{76.4} & 79.7        & 43.9M \\ \hline
\end{tabular}
\caption{Weight sharing mitigates overfitting and leads to better validation performance on ImageNet. We show results (top-1 accuracy) for the best-performing ImageNet architecture (reported in Tables 1-2 of the main paper) on train and validation sets. This architecture uses 8 cross-attends and 6 blocks per latent transformer. The model labeled ``W/ weight sharing'' shares weights between cross-attention modules 2-8 and between the corresponding blocks of latent transformers 2-8. The first cross-attention module and transformer use their own, unshared weights.}
\label{tab:weight_sharing}
\end{table}

\noindent \textbf{Fourier Feature parameterizations.} We choose the Fourier feature parameterization described in section 3.2 of the paper to allow us to intuitively set the maximum band when the sample rate of the input signal is regular and known. By setting the number of bands independently, we allow it be easily controlled in line with a computational budget: we generally found that more bands helped for a given architecture (assuming it fits in memory). For signals with irregular or very fine sampling, such as ModelNet40 point clouds, the maximum band can also be treated as a hyperparameter. This is in contrast to the parameterization used in NeRF \cite{mildenhall2020nerf}, which produces very high frequencies if a moderate number of bands are used (e.g. the  band would have a frequency of ). Rather than tying the maximum frequency to the number of bands, our parameterization samples the spectrum more densely as more bands are added. Our parameterization is identical to the parameterization described in the original Transformer paper, except we express each band in terms of its frequency rather than its wavelength (we find this more natural in the context of signals like images) and we assume that input positions are in  rather than  for a sequence of length .


\noindent \textbf{Relationship between Fourier features and spectrograms.} On AudioSet, we found it beneficial to compute Fourier features on the audio magnitude feature as well as the positional features. This produces a audio feature that is related to the discrete Fourier transform used to compute spectrograms. To see this, note that for an input signal , the  band of a spectrogram is computed using a term of the form , while the sinusoidal component of the corresponding Fourier feature uses a term of the form . The interpretation of these two objects is somewhat different. As noted by \cite{tancik2020fourier}, training a neural network using Fourier feature inputs can be viewed as performing approximate kernel regression. In the case of audio features, the Fourier feature encoding corresponds to computing the Fourier transform of a kernel function applied to the audio signal \cite{rahimi2007random, tancik2020fourier}. In contrast, the spectrogram is computed using the Fourier transform of the audio signal itself.

\section{Audiovisual attention maps}
\label{sec:audiovisual_viz}

In Fig.~\ref{fig:video_attention_map} and Fig.~\ref{fig:audio_attention_map}, we visualize video and audio attention maps (respectively) for the first cross-attention module of a multimodal Perceiver model trained on AudioSet. 

We visualize video attention maps similarly to static image attention maps (Fig.~\ref{fig:attention_map}), but with the addition of a time dimension: each column of Fig.~\ref{fig:video_attention_map} shows the attention to the full image at a time step of the video. Because the AudioSet Perceiver takes space-time patches of shape time 2  height 4  width 4, the same attention is applied to pairs of subsequent frames. For visualization purposes, we show every other frame of the input video and attention maps: each attention map is applied to two video frames.

All attention maps of this network appear to be sensitive to both static and dynamic features of the input video. Interestingly, the most clearly static features of the maps consistently appear on the last timestep of the attention map, for all attention maps in this network (compare the final column of each row of Fig.~\ref{fig:video_attention_map}). At the final timestep, the network appears to deploy attention maps similar to those seen on ImageNet. At previous timesteps, attention maps exhibit spatiotemporal structure reminiscent of the filters seen in spatiotemporal image processing \cite{adelson1985spatiotemporal, simoncelli1998model}. Because the Perceiver uses learned attention rather than a fixed bank of spatiotemporal filters, it can adapt its attention to the input content. The qualitative split between the attention to the last frames and the attention to previous frames may indicate that the network processes the video by reasoning about changes in image content over time, starting from the end of the clip. This strategy may occur in part because the video clips are relatively short (32 frames). 

We visualize audio attention maps by plotting attention as a function of time, for each attention map (Fig.~\ref{fig:audio_attention_map}). Audio attention maps are dominated by a shared low-frequency oscillatory structure (Fig.~\ref{fig:audio_attention_map}). Individual attention maps display different high frequency structure, and this high frequency structure appears to vary over time (note that many of the oscillations in the attention maps become thicker or thinner over time). This high frequency structure may by analogous to the content modulation visible in image attention, but the content modulation is less clearly interpretable than in the case of images.


\begin{figure*}
    \centering
    \includegraphics[keepaspectratio,width=1.0\linewidth]{imgs/video_attention.png}
    \vspace{-12pt}
    \caption{Video attention maps from the first cross-attention module on our best performing model on AudioSet. The first row shows the input video, while subsequent rows show each attention map over time: each frame of the attention map is applied to the frame of the input video shown in its column. We show every other frame of the video and attention maps to make it easier to visualize temporal changes in each attention map. Note that the qualitative difference between attention to the final frame (which resembles ImageNet attention maps) and attention to antecedent frames (which more closely resembles spatiotemporal filtering) is present in the raw data.}
    \label{fig:video_attention_map}
\end{figure*}

\begin{figure*}
    \centering
    \includegraphics[keepaspectratio,width=1.0\linewidth]{imgs/audio_attention.pdf}
    \vspace{-12pt}
    \caption{Audio attention maps from the first cross-attention module on our best performing model on AudioSet. The audio input to the network is shown in \textcolor{blue}{blue} in the subplot in the top left corner (this audio corresponds to the video shown in Fig.~\ref{fig:video_attention_map}. The remaining subplots show the first 35 audio attention maps. We visualize the attention to the audio signal as the attention magnitude as a function of time: this is analogous to how we visualize attention maps for images and videos as the magnitude of the attention at each pixel. The overall scale varies considerably between attention maps, so we normalize each attention map for easier visualization.}
    \label{fig:audio_attention_map}
\end{figure*}

\end{document}