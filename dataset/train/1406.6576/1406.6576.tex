\documentclass{llncs}
\usepackage{amsmath,amssymb}
\usepackage[dvipdfmx]{graphicx}
\usepackage[dvipdfmx]{color}

\pagestyle{plain}
\thispagestyle{plain}

\topmargin=0cm
\oddsidemargin=1true cm
\evensidemargin=1true cm
\textwidth=14cm
\textheight=22.5cm




\newcommand{\msize}[1]{{\left|#1\right|}}
\newcommand{\Nei}[2]{N(#1,#2)}
\newcommand{\Neiclosed}[2]{N[#1, #2]}
\newcommand{\Tsub}[2]{T_{#1}^{#2}}

\newcommand{\bfI}{I}



\newcommand{\calS}{{\cal S}}


\newcommand{\onestep}{\leftrightarrow}
\newcommand{\sevstep}{\leftrightsquigarrow}
\newcommand{\onestepT}[1]{\overset{#1}{\onestep}}
\newcommand{\sevstepT}[1]{\overset{#1}{\sevstep}}

\newcommand{\DPfun}{\phi}

\newcommand{\ImSet}[1]{{\sf R}(\bfI_{#1})}
\newcommand{\ImSetp}{{\sf R}(\bfI^\prime)}
\newcommand{\Forest}{F}
\newcommand{\numq}{q}

\newcommand{\bfIstar}{\bfI^*}
\newcommand{\bfIp}{\bfI^{\prime}}

\newcommand{\dist}{\mathsf{dist}}

\newcommand{\Tminus}{\bar{T}}
\newcommand{\Tmsub}[2]{\Tminus_{#1}^{#2}}
\newcommand{\Iminus}{\bar{I}}



\newenvironment{listing}[1]{\begin{list}{*}{\settowidth{\labelwidth}{#1}\setlength{\leftmargin}{\labelwidth}\advance \leftmargin by 12pt
\setlength{\itemsep}{0pt}\setlength{\parsep}{0pt}\setlength{\topsep}{0pt}\setlength{\parskip}{0pt}}}{\end{list}}

\newcounter{one}
\setcounter{one}{1}
\newcommand{\one}{{\rm \roman{one}}}
\newcounter{two}
\setcounter{two}{2}
\newcommand{\two}{{\rm \roman{two}}}
\newcounter{three}
\setcounter{three}{3}
\newcommand{\three}{{\rm \roman{three}}}
\newcounter{four}
\setcounter{four}{4}
\newcommand{\four}{{\rm \roman{four}}}
\newcounter{five}
\setcounter{five}{5}
\newcommand{\five}{{\rm \roman{five}}}
\newcounter{six}
\setcounter{six}{6}
\newcommand{\six}{{\rm \roman{six}}}




\definecolor{lightblue}{rgb}{0.5,0.5,1.0}
\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}

\newcommand{\todo}[1]{\textcolor{darkgreen}{[#1]}}
\newcommand{\yota}[1]{\textcolor{red}{[Yota says: #1]}}
\newcommand{\alert}[1]{\textcolor{red}{#1}}

 
\begin{document}
\title{Linear-Time Algorithm for Sliding Tokens on Trees}

\author{
Erik D.~Demaine\inst{1} \and
Martin L.~Demaine\inst{1} \and 
Eli Fox-Epstein\inst{2} \and 
Duc A.~Hoang\inst{3} \and \\
Takehiro Ito\inst{4} \and 
Hirotaka Ono\inst{5} \and
Yota Otachi\inst{3} \and 
Ryuhei Uehara\inst{3} \and 
Takeshi Yamada\inst{3}
}

\institute{
    MIT Computer Science and Artificial Intelligence Laboratory,\\
    32 Vassar St., Cambridge, MA 02139, USA.\\
	\email{\{edemaine,~mdemaine\}@mit.edu}
\and
	Department of Computer Science, Brown University, \\
	115 Waterman Street, Providence, RI 02912-1910, USA. \\
	\email{ef@cs.brown.edu}
\and
    School of Information Science, JAIST, \\
    Asahidai 1-1, Nomi, Ishikawa 923-1292, Japan.\\
    \email{\{hoanganhduc, otachi, uehara, tyama\}@jaist.ac.jp}
\and
	Graduate School of Information Sciences, Tohoku University, \\
    Aoba-yama 6-6-05, Sendai, 980-8579, Japan.\\
	\email{takehiro@ecei.tohoku.ac.jp}
\and	
	Faculty of Economics, Kyushu University, \\
	Hakozaki 6-19-1, Higashi-ku, Fukuoka, 812-8581, Japan. \\
	\email{hirotaka@econ.kyushu-u.ac.jp}
}

\maketitle

\begin{abstract}
Suppose that we are given two independent sets  and  of 
a graph such that , 
and imagine that a token is placed on each vertex in . 
Then, the {\sc sliding token} problem is to determine whether 
there exists a sequence of independent sets which transforms  
into  so that each independent set in the sequence results from 
the previous one by sliding exactly one token along an edge in the graph. 
This problem is known to be PSPACE-complete even for planar graphs, and also for bounded treewidth graphs. 
In this paper, we thus study the problem restricted to trees, and give the following three results:
(1)~the decision problem is solvable in linear time; 
(2)~for a yes-instance, we can find in quadratic time an actual sequence of independent sets between  and  whose length (i.e., the number of token-slides) is quadratic; and 
(3)~there exists an infinite family of instances on paths for which any sequence requires quadratic length.
\end{abstract}



\section{Introduction}

Recently, {\em reconfiguration problems} attract the attention 
in the field of theoretical computer science. 
The problem arises when we wish to find a step-by-step transformation between 
two feasible solutions of a problem such that 
all intermediate results are also feasible and 
each step abides by a fixed reconfiguration rule 
(i.e., an adjacency relation defined on feasible solutions of the original problem).
This kind of reconfiguration problem has been studied extensively 
for several well-known problems, including 
{\sc independent set}~\cite{BB14,Bon14,BKW14,HearnDemaine2005,HearnDemaine2009,IDHPSUU,ItoKaminskiOnoSuzukiUeharaYamanaka2014,KaminskiMedvedevMilanic2012,MNRSS13,MNRW14,Wro14}, 
{\sc satisfiability}~\cite{Kolaitis,MTY11}, 
{\sc set cover}, {\sc clique}, {\sc matching}~\cite{IDHPSUU}, 
{\sc vertex-coloring}~\cite{BJLPP14,BC09,CHJ11,Wro14},
{\sc list edge-coloring}~\cite{IKD09,IKZ11},
{\sc list -labeling}~\cite{IKOZ_isaac},
{\sc subset sum}~\cite{ID11}, 
{\sc shortest path}~\cite{Bon13,KMP11}, and so on.

\subsection{{\sc Sliding token}}
The {\sc sliding token} problem was introduced by Hearn and Demaine~\cite{HearnDemaine2005} 
as a one-player game, which can be seen as a reconfiguration problem for {\sc independent set}. 
Recall that an {\em independent set} of a graph  is a vertex-subset of  in which 
no two vertices are adjacent. 
(Figure~\ref{fig:example} depicts five different independent sets in the same graph.)
Suppose that we are given two independent sets  and  of a graph 
 such that , 
and imagine that a token (coin) is placed on each vertex in . 
Then, the {\sc sliding token} problem is to determine 
whether there exists a sequence 
 of independent sets of  such that
\begin{listing}{aaa}
\item[(a)] , , 
 and  for all , ; and 
\item[(b)] for each , , 
 there is an edge  in  such that  
 and , 
 that is,  can be obtained from  by sliding exactly 
 one token on a vertex  to its adjacent vertex  along .
\end{listing}
Such a sequence is called a {\em reconfiguration sequence} between  and . 
Figure~\ref{fig:example} illustrates a reconfiguration sequence 
 of independent sets 
which transforms  into . 
Hearn and Demaine proved that {\sc sliding token} is PSPACE-complete for planar graphs, 
as an example of the application of their powerful tool, 
called the nondeterministic constraint logic model, 
which can be used to prove PSPACE-hardness of 
many puzzles and games~\cite{HearnDemaine2005}, \cite[Sec.~9.5]{HearnDemaine2009}. 

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\textwidth]{fig/example.eps}
\end{center}
\vspace{-1em}
\caption{A sequence  of independent sets of the same graph, where the vertices in independent sets are depicted by large black circles (tokens).}
\label{fig:example}
\end{figure}

\begin{figure}[b]
\begin{center}
\includegraphics[width=0.4\textwidth]{fig/rules.eps}
\end{center}
\vspace{-1em}
\caption{A yes-instance for {\sc ISReconf} under the TJ rule, 
which is a no-instance for the {\sc sliding token} problem.}
\label{fig:rules}
\end{figure}


\subsection{Related and known results}

As the (ordinary) {\sc independent set} problem is a key problem among thousands of NP-complete problems,
{\sc sliding token} plays a very important role since 
several PSPACE-hardness results have been proved using reductions from it.
Indeed, {\sc sliding token} is one of the most well-studied reconfiguration problems.  

	In addition, reconfiguration problems for {\sc independent set} ({\sc ISReconf}, for short) have been studied under different reconfiguration rules, as follows.
\smallskip

	\begin{listing}{aaa}
	\item[]{\em Token Sliding} (TS rule)~\cite{BC09,BKW14,HearnDemaine2005,HearnDemaine2009,KaminskiMedvedevMilanic2012,Wro14}: 
      This rule corresponds to {\sc sliding token}, that is, 
      we can slide a single token only along an edge of a graph.
							\smallskip
	
	\item[] {\em Token Jumping} (TJ rule)~\cite{BKW14,ItoKaminskiOnoSuzukiUeharaYamanaka2014,KaminskiMedvedevMilanic2012,Wro14}: 
      A single token can ``jump'' to any vertex (including non-adjacent one) 
      if it results in an independent set.
							\smallskip
							
	\item[] {\em Token Addition and Removal} (TAR rule)~\cite{BB14,Bon14,IDHPSUU,KaminskiMedvedevMilanic2012,MNRSS13,MNRW14,Wro14}: 
      We can either add or remove a single token at a time 
      if it results in an independent set of cardinality at least a given threshold minus one. 
      Therefore, under the TAR rule, independent sets in the sequence do not have the same cardinality.
	\end{listing}
\smallskip

\noindent
 	We note that the existence of a desired sequence depends deeply on the reconfiguration rules. 
 (See \figurename~\ref{fig:rules} for example.) 
	However, {\sc ISReconf} is PSPACE-complete under any of the three reconfiguration rules for planar graphs~\cite{BC09,HearnDemaine2005,HearnDemaine2009}, for perfect graphs~\cite{KaminskiMedvedevMilanic2012}, and for bounded bandwidth graphs~\cite{Wro14}.
	The PSPACE-hardness implies that, unless , there exists an instance of {\sc sliding token} which requires a super-polynomial number of token-slides even in a minimum-length reconfiguration sequence. 
In such a case, tokens should make ``detours'' to avoid violating independence.
(For example, see the token placed on the vertex  in \figurename~\ref{fig:example}(a);
it is moved twice even though .)


	We here explain only the results which are strongly related to this paper, that is, {\sc sliding token} on trees;
see the references above for the other results.  
\medskip

\noindent
{\bf Results for TS rule ({\sc sliding token}).}

	Kami\'nski et al.~\cite{KaminskiMedvedevMilanic2012} gave a linear-time algorithm to solve {\sc sliding token} for cographs 
(also known as -free graphs). 
	They also showed that, for any yes-instance on cographs, two given independent sets  and  have a reconfiguration sequence such that no token makes detour. 

	Very recently, Bonsma et al.~\cite{BKW14} proved that {\sc sliding token} can be solved in polynomial time for claw-free graphs. 
	Note that neither cographs nor claw-free graphs contain trees as a (proper) subclass. 
	Thus, the complexity status for trees was open under the TS rule. 
\medskip


\noindent
{\bf Results for trees}.

	In contrast to the TS rule, it is known that {\sc ISReconf} can be solved in linear time under the TJ and TAR rules for even-hole-free graphs~\cite{KaminskiMedvedevMilanic2012}, which include trees. 
	Indeed, the answer is always ``yes'' under the two rules when restricted to even-hole-free graphs.
Furthermore, tokens never make detours in even-hole-free graphs under the TJ and TAR rules.

	On the other hand, under the TS rule, tokens are required to make detours even in trees.
(See \figurename~\ref{fig:example}.)
	In addition, there are no-instances for trees under TS rule.
(See \figurename~\ref{fig:rules}.)
	These make the problem much more complicated, and we think they are the main reasons why {\sc sliding token} for trees was open, despite the recent intensive algorithmic research on {\sc ISReconf}~\cite{BB14,Bon14,BKW14,ItoKaminskiOnoSuzukiUeharaYamanaka2014,KaminskiMedvedevMilanic2012,MNRW14}. 

\subsection{Our contribution}

	In this paper, we first prove that the {\sc sliding token} problem is solvable in  time for any tree  with  vertices. 
	Therefore, we can conclude that {\sc ISReconf} for trees is in P (indeed, solvable in linear time) under any of the three reconfiguration rules.
	
	It is remarkable that there exists an infinite family of instances on paths for which any reconfiguration sequence requires  length, although we can decide it is a yes-instance in  time. 
	As the second result of this paper, we give an -time algorithm which finds an actual reconfiguration sequence of length  between two given independent sets for a yes-instance.
	
	Since the treewidth of any graph  can be bounded by the bandwidth of , the result of~\cite{Wro14} implies that {\sc sliding token} is PSPACE-complete for bounded treewidth graphs. 
(See~\cite{Bod98} for the definition of treewidth.)
	Thus, there exists an instance on bounded treewidth graphs which requires a super-polynomial number of token-slides even in a minimum-length reconfiguration sequence unless .
	Therefore, it is interesting that any yes-instance on a tree, whose treewidth is one, has an -length reconfiguration sequence even though trees require to make detours to transform.


\subsection{Technical overview}
\label{subsec:highlight}

	We here explain our main ideas;
formal descriptions will be given later. 

	We say that a token on a vertex  is ``rigid'' under an independent set  of a tree  if it cannot be slid at all, that is,  holds for {\em any} independent set  of  which is reconfigurable from .
(For example, four tokens in \figurename~\ref{fig:rules} are rigid.)
	Our algorithm is based on the following two key points. 
	\begin{listing}{aaa}
	\item[(1)] In Lemma~\ref{lem:rigid}, we will give a simple but non-trivial characterization of rigid tokens, based on which we can find all rigid tokens of two given independent sets  and  in time . 
	Note that, if  and  have different placements of rigid tokens, then it is a no-instance (Lemma~\ref{lem:step1}).
	\item[(2)] Otherwise, we obtain a forest by deleting the vertices with rigid tokens together with their neighbors (Lemma~\ref{lem:step2}).
	We will prove in Lemma~\ref{lem:secondkey} that the answer is ``yes'' as long as each tree in the forest contains the same number of tokens in  and . 
	\end{listing}


\section{Preliminaries}

In this section, we introduce some basic terms and notation. 

\subsection{Graph notation}

In the {\sc sliding token} problem, 
we may assume without loss of generality that graphs are simple and connected.
For a graph , we sometimes denote by  and  the vertex set and edge set of , respectively. 

	In a graph , a vertex  is said to be a {\em neighbor} of a vertex  if . 
	For a vertex  in , let , and let .
	For a subset , we simply write . 
	For a vertex  of , we denote by  the degree of  in , that is, .
	For a subgraph  of a graph , we denote by  the subgraph of  induced by the vertices in . 

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.3\textwidth]{fig/subtree.eps}
\end{center}
\vspace{-1em}
\caption{Subtree  in the whole tree .}
\label{fig:subtree}
\end{figure}

	Let  be a tree. 
	For two vertices  and  in , the unique path between  and  is simply called the {\em -path} in . 
	We denote by  the number of edges in the -path in .
	For two vertices  and  of a tree , let  be the subtree of  obtained by regarding  as the root of  and then taking the subtree rooted at  which consists of  and all descendants of .
(See \figurename~\ref{fig:subtree}.)
	It should be noted that  is not contained in the subtree . 

\subsection{Definitions for {\sc sliding token}}

Let  and  be two independent sets of a graph  such that . 
If there exists exactly one edge  in  such that  
and , 
then we say that  can be obtained from  by {\em sliding} 
the token on  to its adjacent vertex  along the edge , 
and denote it by . 
We note that the tokens are unlabeled, while the vertices in a graph are labeled.
	We sometimes omit to say (the label of) the vertex on which a token is placed, and simply say ``a token in an independent set .''

A {\em reconfiguration sequence} between two independent sets  and  of  
is a sequence  of 
independent sets of  such that  for .
We sometimes write  if an independent set  of  appears in the reconfiguration sequence . 
We write  if there exists a reconfiguration sequence  between  and  such that all independent sets  satisfy .
The {\em length} of a reconfiguration sequence  is defined as 
the number of independent sets contained in .
For example, 
the length of the reconfiguration sequence in \figurename~\ref{fig:example} is . 

Given two independent sets  and  of a graph , the {\sc sliding token} problem is to determine whether  or not.
We may assume without loss of generality that ; 
otherwise the answer is clearly ``no.'' 
Note that {\sc sliding token} is 
a decision problem asking for the existence of a reconfiguration sequence 
between  and , and hence it does not ask for an actual reconfiguration sequence. 
We always denote by  and  the {\em initial} and {\em target} independent sets of , 
respectively.



	\section{Algorithm for Trees}
	\label{sec:algorithm}
	
	In this section, we give the main result of this paper. 
	\begin{theorem} \label{the:tree}
	The {\sc sliding token} problem can be solved in linear time for trees. 
	\end{theorem}
	
	As a proof of Theorem~\ref{the:tree}, we give an -time algorithm which solves {\sc sliding token} for a tree with  vertices. 


	
	\subsection{Rigid tokens}
	
	In this subsection, we formally define the concept of rigid tokens, and give their nice characterization. 
\smallskip
	
	Let  be a tree, and let  be an independent set of . 
	We say that a token on a vertex  is \emph{-rigid} if  holds for \emph{any} independent set  of  such that . 
	Conversely, if a token on a vertex  is not -rigid, then it is \emph{-movable};
in other words, there exists an independent set  such that  and . 
	For example, in \figurename~\ref{fig:rigidexample}, the tokens  are -rigid, while the tokens  are -movable. 
	Note that, even though  and  cannot be slid to any neighbor in  under , we can slide them after sliding  downward. 
	
	We then extend the concept of rigid/movable tokens to subtrees of . 
	For any subtree  of , we denote simply .
	Then, a token on a vertex  is \emph{-rigid} if  holds for \emph{any} independent set  of  such that .
	For example, in \figurename~\ref{fig:rigidexample}, tokens  and  are -rigid even though they are -movable in the whole tree . 
	Note that, since independent sets are restricted only to the subtree , we cannot use any vertex (and hence any edge) in  during the reconfiguration. 
	Furthermore, the vertex-subset  does not necessarily form an independent set of the whole tree . 
\medskip

\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.4\textwidth]{fig/rigidexample.eps}
	\end{center}
	\vspace{-1em}
	\caption{An independent set  of a tree , where  are -rigid tokens and  are -movable tokens. For the subtree , tokens  are -rigid.}
	\label{fig:rigidexample}
\end{figure}


 \begin{figure}[b]
\begin{center}
	\includegraphics[width=0.78\textwidth]{fig/rigid.eps}
	\end{center}
	\vspace{-1em}
	\caption{(a) A -rigid token on , and (b) a -movable token on .}
	\label{fig:rigidmovable}
\end{figure}

	We now give our first key lemma, which gives a characterization of rigid tokens. 
(See also \figurename~\ref{fig:rigidmovable}(a) for the claim (b) below.)
	\begin{lemma} \label{lem:rigid}
	Let  be an independent set of a tree , and let  be a vertex in .
	\begin{listing}{aaa}
	\item[{\rm (}a{\rm )}] Suppose that . Then, the token on  is -rigid.
	\item[{\rm (}b{\rm )}] Suppose that . 
					Then, a token on  is -rigid if and only if, 
					for every neighbor , there exists a vertex 
					such that the token on  is -rigid.
	\end{listing}
	\end{lemma}
	\begin{proof}
	Obviously, the claim (a) holds.
	In the following, we thus assume that  and prove the claim (b).

	We first show the if-part.
	Suppose that, for every neighbor , there exists a vertex  such that the token on  is -rigid.
(See \figurename~\ref{fig:rigidmovable}(a).)
	Then, we will prove that the token  on  is -rigid. 
	Since we can slide a token only along an edge of , if  is not -rigid (and hence is -movable), then it must be slid to some neighbor .
	By the assumption,  is adjacent with another token  placed on , and hence we first have to slide  to one of its neighbors other than .
	However, this is impossible since the token  on  is assumed to be -rigid and hence  holds for any independent set  of  such that . 
	We can thus conclude that  is -rigid. 

	We then show the only-if-part by taking a contrapositive. 
	Suppose that  has a neighbor  such that either  or all tokens on  are -movable.
(See \figurename~\ref{fig:rigidmovable}(b).)
	Then, we will prove that the token  on  is -movable;
in particular, we can slide  from  to . 
	Since any token  on a vertex  is -movable, we can slide  to some vertex in  via a reconfiguration sequence  in . 
	Recall that only the vertex  is adjacent with a vertex in  and .
	Therefore,  can be naturally extended to a reconfiguration sequence  in the whole tree  such that  holds for any independent set  of . 
	Apply this process to all tokens on vertices in , and obtain an independent set  of  such that .
	Then, we can slide the token  on  to . 
	Thus,  is -movable. 
\qed
\end{proof}







	The following lemma is useful for proving the correctness of our algorithm in Section~\ref{subsec:correctness}.
	\begin{lemma} \label{lem:atmostone}
	Let  be an independent set of a tree  such that all tokens are -movable, and let  be a vertex such that . 
	Then, there exists at most one neighbor  such that the token on  is -rigid. 
	\end{lemma}
	\begin{proof}
	Suppose for a contradiction that there exist two neighbors  and  in  such that the tokens on  and  are -rigid and -rigid, respectively.
(See \figurename~\ref{fig:atmostone}.)
Since the token  on  is -rigid but is -movable, there is a reconfiguration sequence  starting from  which slides  to . 
	However, before sliding  to ,  must slide the token  on  to some vertex in . 
	This contradicts the assumption that  is -rigid.
	\qed
	\end{proof}
\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.25\textwidth]{fig/atmostone.eps}
	\end{center}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:atmostone}.}
	\label{fig:atmostone}
\end{figure}

	
	\subsection{Linear-time algorithm}
	\label{subsec:algorithm}
	
	In this subsection, we describe an algorithm to solve the {\sc sliding token} problem for trees, and estimate its running time;
the correctness of the algorithm will be proved in Section~\ref{subsec:correctness}. 
\smallskip

	Let  be a tree with  vertices, and let  and  be two given independent sets of . 
	For an independent set  of , we denote by  the set of all vertices in  on which -rigid tokens are placed. 
	Then, the following algorithm determines whether  or not.
\smallskip

	\begin{listing}{{\bf Step~2.}}
	\item[{\bf Step~1.}] Compute  and .
								Return ``no'' if ; otherwise go to Step 2.
\smallskip

	\item[{\bf Step~2.}] Delete the vertices in  from , and obtain a forest  consisting of  trees . 
								Return ``yes'' if  holds for every ; otherwise return ``no.''
	\end{listing}
\smallskip

	We now show that our algorithm above runs in  time. 
	Clearly, Step~2 can be done in  time, and hence we will show that Step~1 can be executed in  time.
\smallskip
	
	We first give the following property of rigid tokens on a tree, which says that deleting movable tokens does not affect the rigidity of the other tokens.
	\begin{lemma} \label{lem:removing-movable-tokens}
	Let  be an independent set of a tree .
	Assume that the token on a vertex  is -movable.
	Then, for every vertex , the token on  is -rigid if and only if it is -rigid.
	\end{lemma}
	\begin{proof}
	The if-part is trivially true, because we cannot make a rigid token movable by adding another token.
	We thus show the only-if-part by contradiction.

	Let .
	Suppose that  is the closest vertex to  such that its token is -rigid but -movable.
	We assume that  is contained in a subtree  for a neighbor  of . 
(See \figurename~\ref{fig:removing_movable_tokens}.)
	Note that  since .
	Since the token  on  is -rigid, by Lemma~\ref{lem:rigid} the vertex  has at least one neighbor  such that the token  on  is -rigid.
	Indeed,  is -rigid, because  is assumed to be -rigid.
	Thus, we know that  since the token  on  is -movable.

	First, consider the case where  is contained in a subtree  for some neighbor  of  other than . 
(See \figurename~\ref{fig:removing_movable_tokens}(a).)
	Then, .
	Since  is -rigid, it is also -rigid.
	Therefore, by Lemma~\ref{lem:rigid} the token  is -rigid.
	This contradicts the assumption that  is -movable.


	We thus consider the case where . 
(See \figurename~\ref{fig:removing_movable_tokens}(b).)
	Recall that  is obtained by deleting only  from . 
	Then, since  is -rigid but -movable, it must be slid from  to . 
	However, before executing this token-slide, we have to slide  to some vertex in .
	Thus,  is -movable, and hence it is also -movable.
	Since  is -rigid and  is strictly closer to  than , this contradicts the assumption that  is the closest vertex to  such that its token is -rigid but -movable.
\qed
\end{proof}

\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.75\textwidth]{fig/lineartime.eps}
	\end{center}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:removing-movable-tokens}.}
	\label{fig:removing_movable_tokens}
\end{figure}

	Then, the following lemma proves that Step~1 can be executed in  time.  
	\begin{lemma} \label{lem:all-rigid-tokens}
	For an independent set  of a tree  with  vertices,  can be computed in  time.
	\end{lemma}
	\begin{proof}
	Lemma~\ref{lem:removing-movable-tokens} implies that the set  of all -rigid tokens in  can be found by removing all -movable tokens in .
	Observe that, if  contains -movable tokens, then at least one of them can be immediately slid to one of its neighbors.
	That is, there is a token on  which has a neighbor  such that .
	Then, the following algorithm efficiently finds and removes such tokens iteratively.
	\smallskip

	\begin{listing}{{\bf Step~B.}}
	\item[{\bf Step~A.}] Define and compute  for all vertices .
	\smallskip

	\item[{\bf Step~B.}] Define and compute .
	\smallskip
	       
	\item[{\bf Step~C.}] Repeat the following steps (\one)--(\three) until .
		\begin{listing}{{\bf (\three)}}
		\item[{\bf (\one)}] Select an arbitrary vertex , and remove it from  and .
		\item[{\bf (\two)}] Update  for each neighbor .
		\item[{\bf (\three)}]  If  becomes one by the update (\two) above, then add the vertex  into .
		\end{listing}
  \smallskip

  \item[{\bf Step~D.}] Output  as the set .
\end{listing}
\smallskip

	Clearly, Steps A, B and D can be done in  time.
	We now show that Step~C takes only  time.
	Each vertex in  can be selected at most once as  at Step~C-(\one).
	For the selected vertex , Step~C-(\two) takes  time for updating  of its neighbors .
	Each vertex in  can be selected at most once as  at Step~C-(\three).
	For the selected vertex , Step~C-(\three) takes  time for finding .
	Therefore, Step~C takes  time in total.
\qed
\end{proof}

	Therefore, Step~1 of our algorithm can be done in  time, and hence the algorithm runs in linear time in total.



	\subsection{Correctness of the algorithm}
	\label{subsec:correctness}

	In this subsection, we prove that the -time algorithm in Section~\ref{subsec:algorithm} correctly determines whether  or not, for two given independent sets  and  of a tree .
\smallskip
	
	We first show the correctness of Step~1.
	\begin{lemma} \label{lem:step1}
	Suppose that  for two given independent sets  and  of a tree . 
	Then, it is a no-instance.
	\end{lemma}
	\begin{proof}
	By the definition of rigid tokens,  holds for \emph{any} independent set  of  such that . 
	Therefore, there is no reconfiguration sequence between  and  if .
	\qed
	\end{proof}

	We then show the correctness of Step~2. 
	We first claim that deleting the vertices with rigid tokens together with their neighbors does not affect the reconfigurability. 
	\begin{lemma} \label{lem:step2}
	Suppose that  for two given independent sets  and  of a tree , and let  be the forest obtained by deleting the vertices in  from .
	Then,  if and only if .
	Furthermore, all tokens in  are -movable, and all tokens in  are -movable.
	\end{lemma}
	\begin{proof}
	We first prove the if-part. 
	Suppose that , and hence there exists a reconfiguration sequence  between  and . 
	Then, for each independent set  of , the vertex-subset  forms an independent set of  since  is obtained by deleting all vertices in . 
	Therefore,  can be extended to a reconfiguration sequence between  and  of . 
	We thus have . 
	
	We then prove the only-if-part. 
	Suppose that , and hence there exists a reconfiguration sequence  between  and . 
	Then, for any independent set , we have  and , and hence by the definition of rigid tokens  holds. 
	Furthermore,  is a vertex-subset of  since no token can be placed on any neighbor of . 
	Therefore,  forms an independent set of . 
	For two consecutive independent sets  and  in , let  and . 
	Since  and , neither  nor  are in .
	Therefore, we have , and hence the edge  is in . 
	Then, we can obtain a reconfiguration sequence between  and  by replacing all independent sets  with . 
	We thus have . 
\smallskip
	
	We finally prove that all tokens in  are -movable.
(The proof for the tokens in  is the same.)
	Notice that each token  on a vertex  in  is -movable; otherwise . 
	Therefore, there exists an independent set  of  such that  and . 
	Then,  as we have proved above, and hence  is -movable.
	\qed
	\end{proof}


	Suppose that  for two given independent sets  and  of a tree .
	Let  be the forest consisting of  trees , which is obtained from  by deleting the vertices in . 
	Since we can slide a token only along an edge of , we clearly have  if and only if  for all .
	Furthermore, Lemma~\ref{lem:step2} implies that, for each , all tokens in  are -movable;
similarly, all tokens in  are -movable. 
\medskip

	We now give our second key lemma, which completes the correctness proof of our algorithm. 
	\begin{lemma} \label{lem:secondkey}
	Let  and  be two independent sets of a tree  such that all tokens in  and  are -movable and -movable, respectively.
	Then,  if and only if . 
\end{lemma}
	
	The only-if-part of Lemma~\ref{lem:secondkey} is trivial, and hence we prove the if-part.
	In our proof, we do \emph{not} reconfigure  into  directly, but reconfigure both  and  into some independent set  of . 
Note that, since any reconfiguration sequence is reversible,  and  imply that .


	We say that a degree- vertex  of  is \emph{safe} if its unique neighbor  has at most one neighbor  of degree more than one.
(See \figurename~\ref{fig:safe}.) 
	Note that any tree has at least one safe degree- vertex. 
\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.23\textwidth]{fig/safe.eps}
	\end{center}
	\vspace{-1em}
	\caption{A degree- vertex  of a tree  which is safe.}
	\label{fig:safe}
\end{figure}



	As the first step of the if-part proof, we give the following lemma. 
	\begin{lemma} \label{lem:degree1}
	Let  be an independent set of a tree  such that all tokens in  are -movable, and let  be a safe degree- vertex of . 
	Then, there exists an independent set  such that  and .
\end{lemma}
	\begin{proof}
	Suppose that ; otherwise the lemma clearly holds. 
	We will show that one of the closest tokens from  can be slid to .
	Let .
	Let  be an arbitrary vertex in , and let  be the -path in .
(See \figurename~\ref{fig:nearest}.)
	If  and hence , then we can simply slide the token on  to . 
	Thus, we may assume that . 

	We note that no token is placed on the vertices  and the neighbors of , 
because otherwise the token on  is not closest to . 
	Let .
Since , by Lemma~\ref{lem:atmostone} there exists at most one vertex  such that the token on  is -rigid. 
	We choose such a vertex  if it exists, otherwise choose an arbitrary vertex in  and regard it as . 
	
	Since all tokens on the vertices  in  are -movable, we first slide the tokens on  to some vertices in .
	Then, we can slide the token on  to  along the path . 
	In this way, we can obtain an independent set  such that  and .
	\qed
	\end{proof}
\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.35\textwidth]{fig/nearest.eps}
	\end{center}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:degree1}.}
	\label{fig:nearest}
\end{figure}



	We then prove that deleting a safe degree- vertex with a token does not affect the movability of the other tokens. 
(See also \figurename~\ref{fig:delete1}.) 
	\begin{lemma} \label{lem:delete1}
	Let  be a safe degree- vertex of a tree , and let  be the subtree of  obtained by deleting , its unique neighbor , and the resulting isolated vertices.
	Let  be an independent set of  such that  and all tokens are -movable.
	Then, all tokens in  are -movable.
	\end{lemma}
	\begin{proof}
	Since  consists of a single vertex , the token on  is -rigid. 
	Therefore, no token is placed on degree- neighbors of  other than  (see \figurename~\ref{fig:delete1}), because otherwise it contradicts to Lemma~\ref{lem:atmostone};
recall that all tokens in  are assumed to be -movable.


	Let . 
	Suppose for a contradiction that there exists a token in  which is -rigid.
	Let  be such a vertex closest to , and let  be the vertex on the -path right before .
\smallskip

\begin{figure}[b]
\begin{center}
	\includegraphics[width=0.85\textwidth]{fig/delete1.eps}
	\end{center}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:delete1}.}
	\label{fig:delete1}
\end{figure}


\noindent
	{\bf Case (1):} . (See \figurename~\ref{fig:delete1}(a).)

	Recall that the token on  is -movable, but is -rigid. 
	Therefore, by Lemma~\ref{lem:atmostone} the token on  must be -movable.
	However, this contradicts the assumption that  is -rigid, because  and  in this case. 
\medskip

\noindent
	{\bf Case (2):} . (See \figurename~\ref{fig:delete1}(b).)

	Let  be the neighbor of  on the -path other than ; 
let .
	We note that the subtree  contains the deleted star  centered at .

	We first note that the token  on  is -rigid, because otherwise  can be slid to some vertex in  and hence it is -movable. 
	Since  and , the token  is also -rigid. 
	
	For each  with , since  is -rigid and all tokens in  are -movable, by Lemma~\ref{lem:atmostone} each token  on  is -movable. 
	Then, since  and , the token  is -movable. 
	Therefore, if  or the token  on  is -movable, then we can slide  from  to  after sliding each token  in  to some vertex of the subtree .
	This contradicts the assumption that  is -rigid. 
	
	Therefore, we have  and a token  on  is -rigid. 
	However, since  is -rigid, this implies that  is -rigid. 
	Since  is on the -path in , this contradicts the assumption that  is the -rigid token closest to .  
\qed
\end{proof}



\smallskip

\noindent
	{\bf Proof of the if-part of Lemma~\ref{lem:secondkey}.}
	
	We now prove the if-part of the lemma by the induction on the number of tokens . 
	The lemma clearly holds for any tree  if , because  has only one token and hence we can slide it along the unique path in . 
	
	We choose an arbitrary safe degree- vertex  of a tree , whose unique neighbor is . 
	Since all tokens in  are -movable, by Lemma~\ref{lem:degree1} we can obtain an independent set  of  such that  and . 
	By Lemma~\ref{lem:delete1} all tokens in  are -movable, where  is the subtree defined in Lemma~\ref{lem:delete1}. 
	Similarly, we can obtain an independent set  of  such that ,  and all tokens in  are -movable. 
	Apply the induction hypothesis to the pair of independent sets  and  of .
	Then, we have .
	Recall that both  and  hold, and  is the unique neighbor of  in .
	Furthermore, . 
	Therefore, we can extend the reconfiguration sequence in  between  and  to a reconfiguration sequence in  between  and . 
	We thus have . 
	
	This completes the proof of Lemma~\ref{lem:secondkey}, and hence completes the proof of Theorem~\ref{the:tree}.
\qed





	\subsection{Length of reconfiguration sequence}
	\label{subsec:length}
	
	In this subsection, we show that an actual reconfiguration sequence can be found for a yes-instance on trees, by implementing our proofs in Section~\ref{subsec:algorithm}.
	Furthermore, the length of the obtained reconfiguration sequence is at most quadratic. 
	\begin{theorem} \label{the:length}
	Let  and  be two independent sets of a tree  with  vertices. 
	If , then there exists a reconfiguration sequence of length  between  and , and it can be output in  time. 
	\end{theorem}
	
	We note that a reconfiguration sequence  can be represented by a sequence of edges on which tokens are slid. 
	Therefore, the space for representing  can be bounded by a linear in the length of . 
	
	By Theorem~\ref{the:tree} we can determine whether  or not in  time. 
	In the following, we thus assume that . 
	Furthermore, suppose that all tokens in  are -movable, and that all tokens in  are -movable;
otherwise we obtain the forest by deleting the vertices in  from , and find a reconfiguration sequence for each tree in the forest, according to Lemma~\ref{lem:step2}. 

	As in the if-part proof of Lemma~\ref{lem:secondkey}, we choose an arbitrary safe degree- vertex  of , and obtain an independent set  of  such that  and , as follows.
	\begin{listing}{aaa}
	\item[(a)] Find a vertex  which is closest to , and let  be the -path in .
					Let .
					(See also \figurename~\ref{fig:nearest}.)
	\item[(b)] Choose a vertex  such that the token on  is -rigid if it exists, otherwise choose an arbitrary vertex in  and regard it as . 
	\item[(c)] Slide each token on  to some vertex in , and then slide the token on  to .
	\end{listing}
	In Lemma~\ref{lem:degree1} we have proved that such a reconfiguration sequence from  to  always exists. 
	We apply the same process to , and repeat until we obtain the same independent set  of  such that  and . 
	Note that, since any reconfiguration sequence is reversible, this means that we obtained a reconfiguration sequence between  and . 
	
	Therefore, to prove Theorem~\ref{the:length}, it suffices to show that the algorithm above runs in  time for one safe degree- vertex  and the reconfiguration sequence for sliding one token to  is of length . 
	In particular, the following lemma completes the proof of Theorem~\ref{the:length}. 
	\begin{lemma} \label{lem:moving_root}
	Let  be an independent set of a tree , and let . 
	For a neighbor , suppose that the token on  is -movable. 
	Then, there exists a reconfiguration sequence  of length  from  to an independent set  of  such that  and  for all . 
	Furthermore,  can be output in  time.
	\end{lemma}
	\begin{proof}
	We prove the lemma by the induction on the depth of , where the depth of a tree is the longest distance from its root to a leaf.
	If the depth of  is zero (and hence  consists of a single vertex ), then the token on  is -rigid; 
this contradicts the assumption. 
	Therefore, we may assume that the depth is at least one.
	If the depth of  is exactly one, then  is a star centered at , and no token is placed on any neighbor of . 
	Thus, we can slide the token on  by   token-slides.
	Then, the lemma holds for trees with depth one.

	Assume that the depth of  is , and that the lemma holds for trees with depth at most .
	Since  is -movable, by Lemma~\ref{lem:rigid} there is a vertex  such that all tokens on the vertices  in  are -movable. 
(See \figurename~\ref{fig:length}.)
	Then, we can obtain a reconfiguration sequence which (1) first slides all tokens on the vertices  in  to some vertices in , and (2) then slide the token on  to the vertex .
	By applying the induction hypothesis to each subtree , this reconfiguration sequence is of length 
	
and can be output in time . 
	Note that  holds for the obtained independent set  of .
	Thus, the lemma holds for trees with depth . 
	\qed
	\end{proof}

\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.38\textwidth]{fig/length.eps}
	\end{center}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:moving_root}.}
	\label{fig:length}
\end{figure}


It is interesting that there exists an infinite family of instances on paths
for which any reconfiguration sequence requires  length,
where  is the number of vertices. 
For example, consider a path  with  vertices for any positive integer , and
let  and .
In this yes-instance, any token must be slid  times, 
and hence any reconfiguration sequence requires  length to slide them all.




\section{Concluding Remarks}

	In this paper, we have developed an -time algorithm to solve the {\sc sliding token} problem for trees with  vertices, based on a simple but non-trivial characterization of rigid tokens. 
	We have shown that there exists a reconfiguration sequence of length  for any yes-instance on trees, and it can be output in  time. 
	Furthermore, there exists an infinite family of instances on paths for which any reconfiguration sequence requires  length.

	The complexity status of {\sc sliding token} remains open for chordal graphs and interval graphs.
	Interestingly, these graphs have no-instances such that all tokens are movable. 
(See \figurename~\ref{fig:interval} for example.) 

\begin{figure}[t]
\begin{center}
	\includegraphics[width=0.37\textwidth]{fig/interval.eps}
	\end{center}
	\vspace{-1em}
	\caption{No-instance for an interval graph such that all tokens are movable.}
	\label{fig:interval}
\end{figure}



\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{Bod98}
Bodlaender, H.L.:
A partial -arboretum of graphs with bounded treewidth.
Theoretical Computer Science 209, pp.~1--45 (1998)

\bibitem{BB14}
Bonamy, M., Bousquet, N.:
Reconfiguring independent sets in cographs.
{\tt arXiv:1406.1433} (2014)
   
\bibitem{BJLPP14}
Bonamy, M., Johnson, M., Lignos, I., Patel, V., Paulusma, D.: 
Reconfiguration graphs for vertex colourings of chordal and chordal bipartite graphs. 
J.~Combinatorial Optimization 27, pp.~132--143 (2014)

\bibitem{Bon13}
Bonsma, P.: 
The complexity of rerouting shortest paths. 
Theoretical Computer Science 
510, pp.~1--12 (2013)

\bibitem{Bon14}
Bonsma, P.: 
Independent set reconfiguration in cographs. 
To appear in WG 2014, also available at {\tt arXiv:1402.1587} (2014)

\bibitem{BC09}
Bonsma, P., Cereceda, L.: 
Finding paths between graph colourings: PSPACE-completeness and superpolynomial distances. 
Theoretical Computer Science 
410, pp.~5215--5226 (2009)  

\bibitem{BKW14}
Bonsma, P., Kami\'nski, M., Wrochna, M.: 
Reconfiguring independent sets in claw-free graphs.
Proc.~of SWAT 2014, LNCS 8503, pp.~86--97 (2014)


\bibitem{CHJ11}
Cereceda, L., van den Heuvel, J., Johnson, M.:  
Finding paths between 3-colourings. 
J.~Graph Theory 67, pp.~69--82 (2011)

\bibitem{Kolaitis}
Gopalan, P., Kolaitis, P.G., Maneva, E.N., Papadimitriou, C.H.:
The connectivity of Boolean satisfiability: computational and structural dichotomies.
SIAM J.~Computing 38, pp.~2330--2355 (2009)  

\bibitem{HearnDemaine2005}
Hearn, R.A., Demaine, E.D.: 
PSPACE-completeness of sliding-block puzzles and other problems through the nondeterministic constraint logic model of computation. 
Theoretical Computer Science 
343, pp.~72--96 (2005) 

\bibitem{HearnDemaine2009}
Hearn, R.A., Demaine, E.D.: 
Games, Puzzles, and Computation.
A K Peters (2009)

\bibitem{ID11}
Ito, T., Demaine, E.D.:
Approximability of the subset sum reconfiguration problem.
To appear in J.~Combinatorial Optimization, DOI \url{10.1007/s10878-012-9562-z}

\bibitem{IDHPSUU}
Ito, T., Demaine, E.D., Harvey, N.J.A., Papadimitriou, C.H., Sideri, M., Uehara, R., Uno, Y.: 
On the complexity of reconfiguration problems.
Theoretical Computer Science 
412, pp.~1054--1065 (2011)

\bibitem{IKD09}
Ito, T., Kami\'nski, M., Demaine, E.D.: 
Reconfiguration of list edge-colorings in a graph. 
Discrete Applied Mathematics 160, pp.~2199--2207 (2012)

\bibitem{ItoKaminskiOnoSuzukiUeharaYamanaka2014}
Ito, T., Kami\'nski, M., Ono, H., Suzuki, A., Uehara, R., Yamanaka, K.:
On the parameterized complexity for token jumping on graphs.
Proc.~of TAMC 2014, 
LNCS 8402, 
pp.~341--351 (2014)

\bibitem{IKOZ_isaac}
Ito, T., Kawamura, K., Ono, H., Zhou, X.: 
Reconfiguration of list -labelings in a graph. 
To appear in 
Theoretical Computer Science. 
{\tt DOI: 10.1016/j.tcs.2014.04.011}

\bibitem{IKZ11}
Ito, T., Kawamura, K., Zhou, X.: 
An improved sufficient condition for reconfiguration of list edge-colorings in a tree. 
IEICE Trans.~on Information and Systems E95-D, pp.~737--745 (2012) 

\bibitem{KMP11}
Kami\'nski, M., Medvedev, P., Milani, M.: 
Shortest paths between shortest paths.
Theoretical Computer Science 
412, pp.~5205--5210 (2011)

\bibitem{KaminskiMedvedevMilanic2012}
Kami\'nski, M., Medvedev, P., Milani, M.: 
Complexity of independent set reconfigurability problems.
Theoretical Computer Science 
439, pp.~9--15 (2012)

\bibitem{MTY11}
Makino, K., Tamaki, S., Yamamoto, M.:
An exact algorithm for the Boolean connectivity problem for -CNF.
Theoretical Computer Science 
412, pp.~4613--4618 (2011)

\bibitem{MNRSS13}
Mouawad, A.E., Nishimura, N., Raman, V., Simjour, N., Suzuki, A.: 
On the parameterized complexity of reconfiguration problems.
Proc.~of IPEC 2013, 
LNCS 8246, 
pp.~281--294 (2013)

\bibitem{MNRW14}
Mouawad, A.E., Nishimura, N., Raman, V., Wrochna, M.: 
Reconfiguration over tree decompositions.
{\tt arXiv:1405.2447}

\bibitem{Wro14}
Wrochna, M.:
Reconfiguration in bounded bandwidth and treedepth.
{\tt  arXiv:1405.0847} (2014)
\end{thebibliography}
\end{document}
