\documentclass[11pt]{article}\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[hypertexnames=false]{hyperref}
\usepackage{graphicx,cite}
\usepackage{epsfig}
\usepackage{color}
\usepackage{enumerate,dsfont}
\usepackage{verbatim}
\usepackage{amsthm, amssymb}
\usepackage{amsmath}



\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}
\newtheorem{invariant}{Invariant}
\newcommand{\bm}[1]{\mbox{\boldmath }}
\newcommand{\intDDG}{\ensuremath{\mathit{int}\mathrm{DDG}}}
\newcommand{\extDDG}{\ensuremath{\mathit{ext}\mathrm{DDG}}}
\newcommand{\into}[1]{\ensuremath{\mathit{int}(#1)}}
\newcommand{\exto}[1]{\ensuremath{\mathit{ext}(#1)}}
\newcommand{\intc}[1]{\ensuremath{\overline{\mathit{int}}(#1)}}
\newcommand{\extc}[1]{\ensuremath{\overline{\mathit{ext}}(#1)}}
\newcommand{\lca}[2]{\ensuremath{\mathit{lca}(#1,#2)}}
\newcommand{\jump}{\ensuremath{\mathit{jump}}}
\def\polylog{\operatorname{polylog}}

\addtolength{\textheight}{.5in}






\title{Min -Cut Oracle for Planar Graphs with Near-Linear Preprocessing Time}
\author{Glencora Borradaile\thanks{Oregon State University} \and
      Piotr Sankowski\thanks{University of Warsaw}
      \and
        Christian Wulff-Nilsen
        \thanks{University of Copenhagen                 }}

\iffalse

\documentclass[prodmode,acmtalg]{acmsmall} 

\usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

\acmVolume{0}
\acmNumber{0}
\acmArticle{00}
\acmYear{0000}
\acmMonth{0}

\usepackage{graphicx,amsmath,amssymb,dsfont,cite}
\newdef{invariant}[theorem]{Invariant}
\newcommand{\intDDG}{\ensuremath{\mathit{int}\mathrm{DDG}}}
\newcommand{\extDDG}{\ensuremath{\mathit{ext}\mathrm{DDG}}}
\newcommand{\into}[1]{\ensuremath{\mathit{int}(#1)}}
\newcommand{\exto}[1]{\ensuremath{\mathit{ext}(#1)}}
\newcommand{\intc}[1]{\ensuremath{\overline{\mathit{int}}(#1)}}
\newcommand{\extc}[1]{\ensuremath{\overline{\mathit{ext}}(#1)}}
\newcommand{\lca}[2]{\ensuremath{\mathit{lca}(#1,#2)}}
\newcommand{\jump}{\ensuremath{\mathit{jump}}}
\def\polylog{\operatorname{polylog}}



\begin{document}

\title{Min -Cut Oracle for Planar Graphs with Near-Linear
  Preprocessing Time\footnote{
  This material is based upon work supported by the National Science
  Foundation, under Grant No.\ CCF-0964037, by the Polish Ministry of
  Science, under Grant No.\ 206 355636, and by the European Research
  Council, under Project PAAl no.\ 259515.}}
\author{GLENCORA BORRADAILE
\affil{Oregon State University}
PIOTR SANKOWSKI
\affil{University of Warsaw}
CHRISTIAN WULFF-NILSEN
\affil{University of Copenhagen}}


\markboth{G. Borradaile et al.}{Min -Cut Oracle for Planar Graphs}

\fi
\begin{document}






\maketitle

\begin{abstract}
  For an undirected -vertex planar graph  with non-negative edge-weights,
  we consider the following type of query: given two vertices  and
   in , what is the weight of a min -cut in ? We show how
  to answer such queries in constant time with 
  preprocessing time and  space.  We use a Gomory-Hu tree
  to represent all the pairwise min cuts implicitly. Previously,
  no subquadratic time algorithm was known for this problem.  Since
  all-pairs min cut and the minimum cycle basis are dual problems in
  planar graphs, we also obtain an implicit representation of a
  minimum cycle basis in  time and  space. Additionally, an
  explicit representation can be obtained in  time and space where
   is the size of the basis.

  These results require that shortest paths are unique. This can be
  guaranteed either by using randomization without overhead, or
  deterministically with an additional  factor in the
  preprocessing times.
\end{abstract}

\section{Introduction}



A minimum cycle basis is a minimum-cost representation of all the
cycles of a graph and the all-pairs min cut problem asks to find all
the minimum cuts in a graph.  In planar graphs the problems are
intimately related (in fact, equivalent~\cite{HM94}) via planar
duality. In this paper, we give the first sub-quadratic algorithm for these problems; it
runs in  time. This result is randomized, but can be
made deterministic by paying an additional  factor in the
running time. In the following, we consider connected, undirected graphs with
non-negative edge weights.

\subsubsection*{All-pairs minimum cut}

In the {\em all-pairs min cut problem} we need to find the minimum -cut
for every pair  of vertices in a graph . Gomory and Hu~\cite{GH61}
showed that these minimum cuts can be represented by an edge-weighted tree such that:
\begin{itemize}
\item the nodes of the tree correspond one-to-one with the vertices of ,
\item for any distinct vertices  and , the minimum-weight edge
  on the unique -to- path in the tree has weight equal to the
  min -cut in , and
\item removing this minimum-weight edge from the tree
  creates a partition of
  the nodes into two sets
  corresponding to a min -cut in .
\end{itemize}
We call such a tree a {\em Gomory-Hu} tree or GH tree -- it is also referred
to as cut-equivalent and cut tree in the literature. Gomory and Hu
 showed how to find such a tree with  calls to a minimum cut
algorithm.  Up to date, this is the best known method for general graphs
and gives an -time algorithm for planar graphs
using the best-known algorithm for min -cuts in undirected planar
graphs~\cite{INSW11}. There exists an algorithm for unweighted,
general graphs that beats the  times minimum cut time
bound~\cite{BHPT07}; the corresponding time for unweighted planar graphs is,
however,  time.

\subsubsection*{Minimum cycle basis}

A cycle basis of a graph is a maximum set of independent cycles.  Viewing a
cycle as an incidence vector in , a set of cycles is
independent if their vectors are independent over .  The weight
of a set of cycles is the sum of the weights of the cycles.  The {\em
  minimum-cycle basis (MCB) problem} is to find a cycle basis of
minimum weight.  This problem dates to the electrical circuit theory
of Kirchhoff~\cite{Kirchhoff1847} in  and has been used in the
analysis of algorithms by Knuth~\cite{Knuth68}.  For a complete survey,
see \citen{Horton87}.  The best known algorithm in general graphs takes
 time where  is the exponent for matrix
multiplication~\cite{AIJKR09}.

The best MCB algorithms for planar graphs use basic facts of planar
embeddings. Hartvigsen and Mardon~\cite{HM94} prove that if  is
planar, then there is a minimum cycle basis whose cycles are simple
and nested in the drawing in the embedding.  ({\em Nesting} is defined
formally in Section~\ref{sec:iso}.) As such, one can represent a
minimum cycle basis of a planar embedded graph as an edge-weighted
tree, called the {\it MCB tree}, such that:
 \begin{itemize}
 \item the nodes of the tree correspond one-to-one with the faces of
   the planar embedded graph, and
 \item each edge in the tree corresponds to a cycle in the basis,
   namely the cycle that separates the faces in the components
   resulting from removing this edge from the tree.
 \end{itemize}
Hartvigsen and Mardon also gave an -time algorithm for
the problem that was later improved to  by Amaldi et~al.~\cite{AIJKR09}.


\subsubsection*{Equivalence between MCB and GH trees}

In planar graphs, the MCB and GH problems are related via planar
duality.  Corresponding to every connected planar embedded graph 
(the {\em primal}) there is another connected planar embedded graph
(the {\em dual}) denoted . The faces of  are the vertices of
 and vice versa. There is a one-to-one correspondence between the
edges of  and the edges of : for each edge  in , there
is an edge  in  whose endpoints correspond to the faces of 
incident to .  Dual edges inherit the weight of the corresponding primal edge; namely, .

We define {\it a simple cut} to be a cut such that both sides of the
cut are connected. This definition allows us to show that cycles and
cuts are equivalent through duality:
\begin{quote}
  In a connected planar graph, a set of edges forms a cycle in the
  primal iff it forms a simple cut in the dual.~\cite{Whitney1933}
\end{quote}
Just as cuts and cycles are intimately related via planar duality, so
are the all-pairs minimum cut and minimum cycle basis problems.  In fact,
Hartvigsen and Mardon showed that they are equivalent in the following sense:
\begin{theorem}[Corollary 2.2 from \citen{HM94}]\label{thm:cycle-basis-dual-GH}
  For a planar embedded graph , a tree  represents a minimum
  cycle basis of  if and only if  is a Gomory-Hu tree for 
  (after mapping edges to their duals and the node-face relationship
  to a node-vertex relationship via planar duality).
\end{theorem}
\noindent It follows that the  algorithm due to Amaldi
et~al.~\cite{AIJKR09} to find an MCB tree is also an algorithm to find
a GH tree.

\paragraph{Techniques} Herein, we focus on the frame of reference of the
minimum cycle basis.  In the remainder of this section, we highlight
the tools and techniques that we use in our algorithm and analysis.
Our algorithm, at a very high level, works by (iterative) finding a
minimum-weight cycle that separates two as-yet unseparated faces 
and .  The order in which we separate pairs of faces is guided by a
bottom-up traversal of a hierarchical planar separator
(Section~\ref{sec:sepintro}).  We find each separating cycle by a
modification of Reif's algorithm (Section~\ref{sec:reifintro}) which
does so by way of shortest-path computations.  In order to achieve a
sub-quadratic running time, we will precompute many of the distances
for these shortest-path computations using a method developed by
Fakcharonphol and Rao (Section~\ref{sec:DenseDistGraph}).  To
guarantee that the cycles we find, using these precomputed distances,
will be nesting, we rely on shortest paths being unique
(Section~\ref{sec:iso}).  We represent a partially built solution with
something we call a {\em region tree} (Section~\ref{sec:region-tree}).
After we have defined these structures and tools, we will give a more
detailed overview of our algorithm and analysis
(Section~\ref{sec:overview}) before diving into the technical details
in the remainder of the paper.

\subsection{Planar graphs and simplifying assumptions} \label{sec:defs}

An embedded planar graph is a mapping of the vertices to distinct
points and edges to non-crossing curves in the plane.  A face of the
embedded planar graph is a maximal open connected set of points that
are not in the image of any embedded edge or vertex. Exactly one face,
the {\em infinite face} is unbounded. We identify a face with the
embedded vertices and edges on its boundary.

For a simple cycle  in a planar embedded graph , let 
denote the open bounded subset of the plane defined by .  Likewise
define  for corresponding unbounded subset. We refer to the
closure of these sets as  and , respectively.  We
say that a pair of faces of  are \emph{separated} by  in  if
one face is contained in  and the other face is contained in
.  A set of simple cycles of  is called \emph{nested} if
mapping of this set  is also nesting.  A simple cycle  is
said to \emph{cross} another simple cycle  if the cycles are not
nested.


\subsubsection*{Unique shortest paths} Our algorithm relies on the fact
that each new cycle we add to the basis nests with previously added
cycles.  To guarantee this (Section~\ref{sec:iso}), we will assume
that in all the graphs we consider ( and graphs obtained from ),
there is a unique shortest path between any pair of vertices.  By
adding a small, random perturbation to the weight of each edge, one
can make the probability of having non-unique shortest paths
arbitrarily small. For example, if we take a random perturbation from
the set , then by the Isolation Lemma
due to Mulmuley et al.~\cite{MVV87} the probability that all shortest
paths are unique is at least .  

In Section~\ref{sec:unique-short-paths}, we give a more robust,
deterministic way to ensure the uniqueness of shortest paths.  We must
impose the structural simplifications presented below before
considering applying this more robust method.  The idea, based on the
technique used by Hartvigsen and Mardon~\cite{HM94}, is to break ties
consistently, thus imposing uniqueness on the shortest paths so the
above two lemmas hold.  Unfortunately, in order to do so, we require a
-increase in the running time of our algorithm.

\subsubsection*{3-regular with small, simple faces} The separators that we
use will require that the boundaries of the faces be small and simple
(each vertex appears only once on the boundary of the face).
Three-regularity (each vertex having degree 3) greatly simplifies the
analysis of our algorithm.  We can modify the input graph to satisfy
both these properties simultaneously by triangulating the primal with
infinite-weight edges and then triangulating the dual with zero-weight
edges using a {\em zig-zag triangulation}.  In a zig-zag
triangulation~\cite{KB92}, each face is triangulated using a simple
path, adding at most two edges per face adjacent to each vertex.

\paragraph{Triangulating the primal} For each face  of the original
graph, identify a face  of the triangulated graph that is enclosed
by  in the inherited embedding.  The minimum -separating cycle
in the original graph maps to an -separating cycle of the same
weight and so will not use any infinite-weight edge: the set of cycles
in a minimum cycle basis in the original graph are mapped to the set
of finite-weight cycles in a minimum-cycle basis of the finite-weight
cycles of the triangulated graph.

\paragraph{Triangulating the dual} Before the zig-zag triangulation,
each vertex in the dual has degree 3.  The zig-zag triangulation adds
at most 6 edges (2 for every adjacent face) to each vertex.
Therefore, the faces in the primal have size at most 9 and are still
simple.  Clearly, the primal is 3-regular after triangulating the
dual.  As in the triangulation of the primal, we can map between
minimum cycle bases and min cuts in the original graph and the
degree-three graph. Each vertex  in the original graph is mapped to
a path  of zero-weight edges in the degree-three graph.


\subsection{Reif's algorithm for minimum separating cycles} \label{sec:reifintro}


Reif gave an algorithm for finding minimum cuts by way of finding
minimum separating cycles in the dual graph~\cite{Reif83}.  

Let  be the shortest path between any vertex on the boundary of 
and any vertex on the boundary of .  Since  is a shortest path,
there is a minimum -separating cycle, , that crosses  only
once.  Paths  and  cross if there is a quadruple of faces
adjacent to  and  that cover the set product PPQQ.  Let  be the graph obtained from  by {\em cutting
  along} path : duplicate every edge of  and every internal
vertex of  and create a new, simple face whose boundary is composed
of edges of  and their duplicates.

The following result is originally due to Itai and
Shiloach~\cite{IS79} but we state it as it was given by
Reif~\cite{Reif83}.
\begin{theorem}[Proposition~3 from~\cite{Reif83}]\label{thm:cross-cycle}
  Let  be the shortest -to- path.  For each vertex ,
  let  be the minimum weight cycle that crosses  exactly once
  and does so at .  Then  is a minimum
  -separating.  Further,  is the shortest path between
  duplicates of  in .
\end{theorem}
This theorem is algorithmic: the shortest paths between duplicates of
vertices on  in  can be found in  time using
Klein's multiple-source shortest path algorithm~\cite{Klein05} or by
using the linear-time shortest-path algorithm for planar
graphs~\cite{HKRS97} and divide and conquer.  In our algorithm we will
emulate the latter method: start with the midpoint, , of  in
terms of the number of vertices, and recurse on the subgraphs obtained
by cutting along .

\subsection{Isometric cycles} \label{sec:iso}




A cycle  in a graph is said to be \emph{isometric} if for
any two vertices , there is a shortest path in the graph
between  and  which is a subpath of . A set of cycles is said
to be isometric if all cycles in the set are isometric. 
\begin{lemma}[Proposition 4.4 from \citen{HM94}]
Any minimum cycle basis of a graph is isometric.
\end{lemma}

The following lemma will allow us to find isometric cycles by
composing shortest paths. Further, these isometric cycles will be
nesting and so can be represented with a tree which is precisely the
MCB tree.
\begin{lemma}\label{Lem:Isometric}
  Let  be a graph in which shortest paths are unique.  The
  intersection between an isometric cycle and a shortest path in 
  is a (possibly empty) shortest path. The intersection between two
  distinct isometric cycles  and  in  is a (possibly empty)
  shortest path; in particular, if  is a planar embedded graph, 
  and  do not cross.
\end{lemma}
\begin{proof}
  Let  be an isometric cycle and let  be a shortest path
  intersecting . Let  and  be the first and last vertices of
   that are in . Since  is isometric, there is a shortest
  path  in  between  and . Since shortest paths are
  unique,  is the subpath of  between  and .  Hence,
  , giving the first part of the lemma.

  Let  and  be distinct isometric cycles.  For any two distinct
  vertices , let  be the shortest -to-
  path.  Since  and  are isometric and shortest paths are
  unique, .
\end{proof}



\subsection{Planar separators} \label{sec:sepintro}

A \emph{decomposition} of a graph  is a set of subgraphs
 such that the union of vertex sets of these subgraphs
is the vertex set of  and such that every edge of  is contained
in a unique subgraph. We call  the \emph{pieces} of
the decomposition. The \emph{boundary vertices}  of a
piece  is the set of vertices  in that piece such that there
exists an edge  in  with . We recursively
decompose the graph to get a {\em recursive subdivision}.  A piece 
is decomposed into subpieces called the children of ; the boundary
vertices of a child are the boundary vertices inherited from  as
well as the boundary vertices introduced by the decomposition of .
We use Miller's Cycle Separator for this decomposition: the introduced
boundary vertices form simple cycles~\cite{Miller86}.  This
decomposition requires that the sizes of the faces be bounded by a constant.

Fixing an embedding of , a piece inherits its embedding from 's
embedding. A {\it hole} in a piece is a bounded face containing
boundary vertices.  While it is not possible to guarantee that holes
are not introduced by the balanced recursive subdivision, it is
possible to guarantee that each piece has a constant number of
holes~\cite{INSW11,KMS13}.  Further, we will ensure that pieces are
connected; we give the details of ensuring connectivity in
Section~\ref{sec:sep}.

In summary, we use the following recursive decomposition:
\begin{definition}[Balanced recursive subdivision] \label{def:sep} A
  decomposition of  such that a piece  is divided into a
  constant number of subpieces,  each of which
  is connected, has  holes, and contains at most 
  vertices, at most  boundary vertices
  inherited from , and at most  additional boundary
  vertices.
\end{definition}

We define the  \emph{levels} of the recursive subdivision
in the natural way: level  consists of one piece () and level
-pieces are obtained by applying the Cycle Separator Theorem to
each level -piece. We represent the recursive subdivision as a
binary tree, called the \emph{subdivision tree (of )}, with level
-pieces corresponding to vertices at level  in the subdivision
tree. Parent/child and ancestor/descendant relationships between
pieces correspond to their relationships in the subdivision tree.  For
notation simplicity, we assume that the subdivision tree is binary;
generalizing this to a constant number of children is straightforward.

We prove the following in Section~\ref{sec:sep}:
\begin{theorem}\label{thm:sumPiece}
  Let  be the set of pieces in a recursive subdivision of
  .  Then  and
  .
\end{theorem}

\subsection{Precomputing distances}\label{sec:DenseDistGraph}

For a piece , the \emph{internal dense distance graph of } or
 is the complete graph on the set of boundary vertices of
, where the weight of each edge  is equal to the shortest
path distance between  and  in . The union of internal dense
distance graphs of all pieces in the recursive subdivision of  is
the \emph{internal dense distance graph (of )}, or simply
.  Fakcharoenphol and Rao showed how to compute  in
 time~\cite{FR06}.  (Using the multiple-source shortest
path algorithm due to Klein, this can be improved to
~\cite{Klein05}; however, this improvement is not
compatible with, deterministically imposing unique
shortest paths or generalizing to external distances, so we do not use it.)

Consider a piece  with  holes.  The \emph{external dense
  distance graph of } or  is the union of 
complete graphs: one for each hole and one for the external face.  For
two vertices  on the boundary of a common hole or on the boundary
of the external face, the weight of edge  is the shortest path
distance between  and  in the component of 
that contains  and .  The \emph{external dense distance graph of
  } or  is the union of all external dense distance graphs
of the pieces in the recursive subdivision of .  As a consequence
of Theorem~\ref{thm:sumPiece}, both  and  have size
.

Fakcharoenphol and Rao give an implementation of Dijkstra's algorithm,
{\em FR-Dijkstra}, that finds a shortest path tree in a graph composed
of dense distance graphs in  time, where  is the total
number of boundary vertices, counted with multiplicity~\cite{FR06}.

\begin{theorem}\label{thm:ExtDenseDistGraph}
    The external dense distance graph of 
   can be computed in  time.
\end{theorem}
\begin{proof}
  Fakcharoenphol and Rao compute  via a leaves-to-root
  traversal of the recursive subdivision of  by applying
  FR-Dijkstra to obtain  for a piece  from the internal
  dense distance graphs of its two children.  Consider the external
  distances for the external face of : these can be computed by
  FR-Dijkstra from the external dense distance graph of the parent of
   and the internal dense distance graph of the sibling(s) of
  .  

  Consider a hole  of a child  of  and let us compute
   restricted . Observe that (the subgraph of 
  restricted to)  is the union of certain sibling pieces of 
  and certain holes of . Given internal dense distance graphs of
  all children of  and external dense distance graphs of all holes
  of , it follows that  restricted to  can be
  obtained efficiently with FR-Dijkstra. 

  Therefore, we can obtain  with a root-to-leaves traversal
  of the recursive subdivision given . The running time is
  the same as that for finding .
\end{proof}

\subsection{The region tree} \label{sec:region-tree}

We build the minimum cycle basis iteratively, adding cycles to a
partially constructed basis that separated two as-yet unseparated
faces.  We represent the partially constructed basis with a tree that
we call the {\em region tree}.  Each node of a region tree either
represents a {\em region} (defined below) or a face of the graph.  Adjacency
represents enclosure.  We take the region tree to be rooted at a root
 which always corresponds to the special region that represents the
entire plane.  Initially the tree is a star centered at a root 
with each leaf corresponding to a face in the graph (including the
infinite face).

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.7]{region-tree.pdf}
  \caption{A graph with faces  through ; four nesting cycles
     through  (left).  A region tree for cycles
    , and  (center).  A region tree for cycles 
    through  (right).  }
  \label{fig:region-tree-update}
\end{figure}

We update the tree to reflect the cycles that we add to the basis.
This process is illustrated in Figure~\ref{fig:region-tree-update}.
When a first cycle  is found, we create a new node  for the
tree, make  a child of the root, and make all the faces that 
encloses children of .  Node  defines a \emph{region} :
the subgraph of  contained in the closed subset of the plane
defined by the interior of  and not enclosed in the interior of any
children of . We say that  is {\em bounded} by , that  is
a \emph{bounding cycle} of , and that  {\em contains} the child
regions and/or child faces defined by the tree.  If two faces 
are unseparated, they are children of a common region node ; to add
a cycle  that separates  and ,  will become a child of
 and 's common parent.  As we will only add cycles which nest
with those we have already found, the updates to the region tree are
well defined.  The most technically challenging part of the algorithm
is in how to update the region tree (Section~\ref{sec:UpdateRegionTree}).

In the final tree, after all faces have been separated, each face is
the only face-child of a region.  We call such a region tree a {\em
  complete region tree}.  Mapping each face to its unique parent
creates a tree with one node for each face in the graph; this is the
MCB-tree.

\paragraph{Region tree data structure} We represent the region tree
using the top tree data structure~\cite{AHLT05}. This will allow us to
find the lowest common ancestor  of two vertices  and
, and determine whether one vertex is a descendant of another in
logarithmic time.  Top trees also support the operation
, which for two vertices  and , finds the vertex
that is  edges along the path from  to  in logarithmic time.
Top trees can also find the weight of the simple path between two
given endpoints in logarithmic time.

\subsection{Region subpieces}

The \emph{region subpieces} of a piece  are the subgraphs defined
by the non-empty intersections between  and regions defined by the
region tree. We say that a region  and a region subpiece  are
associated with each other.  The boundary vertices  of
 are inherited from : .
These constructions are illustrated in Figure~\ref{fig:region-subpiece}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{region-subpieces.pdf}
  \caption{The dotted edges are the edges belonging to the boundaries
    of a piece  and 's children  and .   is a face
    of  and  is a face of .  The solid black edges are
    the bounding cycle of a region .  The three shaded regions are
    three child regions of .  The thick grey edges are the edges of
    region subpiece . (The remaining edges of the graph are the
    thin, grey edges.)  The intersection of a minimum separating cycle
    for  and  with  uses only edges of .}
  \label{fig:region-subpiece}
\end{figure}

The order in which we separate faces is guided in a bottom-up fashion
by the recursive subdivision of .  Starting with a piece  at the
deepest level of the recursive subdivision, we separate all pairs of
faces of  that have an edge in common with , allowing us to
maintain the following invariant:

\begin{invariant}\label{inv:one-pair}
  For each region subpiece  of , at most one pair of faces
  needs to be separated.
\end{invariant}

\begin{proof}
  Suppose we have added (nesting) separating cycles to the region tree
  that separate all pairs of faces sharing an edge with a descendant
  piece of . Suppose two faces  and  of  both sharing
  edges with  have not yet been separated. Let  and  be
  the two child pieces of  in the recursive subdivision. Since all
  pairs of faces sharing edges with  and all pairs of elementary
  faces sharing edges with  have already been separated,
  w.l.o.g.~ only shares edges with .

  Since  and  have not been separated, they must belong to a
  common region  in the region tree. For a contradiction, if there
  is a third face  that is unseparated from  or , 
  w.l.o.g.~shares edges with . However, all pairs of faces
  sharing edges with  have already been separated.
\end{proof}


\subsection{Overview of the algorithm and analysis}\label{sec:overview}

Our algorithm for computing an MCB tree is:
\begin{quote}
Find a balanced recursive decomposition of the input graph.

Compute the internal and external dense distance graphs. 

Initialize the region tree that represents an empty set of cycles.

Considering each piece  of the recursive decomposition, according
to a bottom-up order, determine the region subpieces of .

For each region subpiece  that contains a pair of unseparated
faces:
\begin{itemize}
\item Find the minimum -separating cycle .
\item Add  to the collection of cycles and update the region tree accordingly.
\end{itemize}
\end{quote}

We present the remaining details for the balanced, recursive
decomposition (Definition~\ref{def:sep}), namely, ensuring that the
pieces remain connected and the proof of Theorem~\ref{thm:sumPiece},
in Section~\ref{sec:sep}.  We have already discussed computing the
dense distance graphs (Section~\ref{sec:DenseDistGraph}) and
initializing the region tree (Section~\ref{sec:region-tree}).

\bigskip

In Section~\ref{sec:RegionSubpieces}, we show, given a piece
 and the current set of regions represented by the region tree,
what the region subpieces for  are and which edges of the graph are
in each of the region subpieces.  Formally, we will prove:
\begin{theorem}\label{thm:RegionSubpiece}
  The region subpieces of a piece  can be identified in  time, where  is the set of boundary vertices of
  the children of the piece.
\end{theorem}
\noindent Summing over all region
subpieces, appealing to Theorem~\ref{thm:sumPiece}, the time spent by
the algorithm identifying the region subpieces is .

\bigskip

We have already seen that by considering the pieces in bottom-up
order, each region subpiece has at most one pair  of
unseparated faces (Invariant~\ref{inv:one-pair}).  In
Section~\ref{sec:SepFacePair}, we show how to find a minimum
-separating cycle  by emulating Reif's algorithm.  To do so, we
must implicitly cut open the graph along the shortest -to- path
and modify the dense distances to reflect the change in the graph's
shortest path metric.  We will prove:
\begin{theorem}\label{thm:separate}
  The minimum -separating cycle for a region subpiece  can be found in time .  
\end{theorem}
\noindent Therefore, the time spent by the algorithm finding minimum separating cycles is .

\bigskip

We show how to update the region tree to reflect our addition of cycle
 to the basis.  For each region  in the region tree we store a
{\em compact representation}  where vertices with degree 2 are
removed by merging the adjacent edges creating {\em super edges}. For
each super edge we store the first and the last edge on the
corresponding path. We show how to maintain compact representations of
regions in Section~\ref{sec:UpdateRegionTree}.  Formally, we will prove:
\begin{theorem}\label{thm:updateregiontree}
  We can update the region tree to reflect that region  is split
  into regions  and  by the addition of  in time
  
  where  are the children of  in the region tree after the
  update.
\end{theorem}
\noindent Using the lemma below, the total time spent by the algorithm
in updating the region tree is .  Combining with the
above running times, this gives an overall running time of .

\begin{lemma}\label{Lem:Merge}
  Consider a set of objects , a weight function  and a merging operation that replaces distinct objects
   and  by a new object whose weight is at most 
  in time at most  for some . Then
  repeatedly merging objects until one object remains takes  time.
\end{lemma}
\begin{proof}
  We may suppose w.l.o.g.\ that initially all objects have weight .
  The run-time for a sequence of merges that results in an object of
  weight  satisfies the recurrence
  
  for some constant c.  It is easy to see that the right-hand side is
  maximized when , giving , as desired.
\end{proof}

\subsubsection*{Results} Recall that these running times are stated with
the uniqueness-of-shortest-paths assumption (guaranteed by suitable
randomization) and that we will show how to achieve this uniqueness
deterministically while incurring an additional  factor
in the running times.  Our algorithm computes the complete region tree
in  time.  As argued in Section~\ref{sec:region-tree},
this can be used to obtain the MCB tree; by planar duality, the same algorithm can be used to find the GH tree.  Therefore, we get: 

\begin{theorem}
  The minimum cycle basis or Gomory-Hu tree of an undirected and
  unweighted planar graph can be computed in  time and
   space.
\end{theorem}

In order to find a minimum -cut using the GH tree, we need to find
the minimum weight edge on the -to- path in the tree.  With an
additional  preprocessing time, one can answer such
queries in  time using a tree-product data
structure~\cite{KS08}, giving:

\begin{theorem}\label{Thm:MinCutOracle}
  With  time and  space for preprocessing,
  the weight of a min -cut between for any two given vertices 
  and  of an -vertex planar, undirected graph with non-negative
  edge weights can be reported in constant time.
\end{theorem}

In Section~\ref{sec:MinCutReport}, we will show how to explicitly find
the cycles given the complete region tree, giving the following results:

\begin{theorem} \label{thm:mincuts} Without an increase in
  preprocessing time or space, the min -cut oracle of
  Theorem~\ref{Thm:MinCutOracle} can be extended to report cuts in
  time proportional to their size.
\end{theorem}

\begin{theorem}\label{Thm:CycleBasisExplicit}
  The minimum cycle basis of an undirected planar graph with non-negative
  edge weights can be computed in  time and  space,
  where  is the total size of the cycles in the basis.
\end{theorem}

\section{Separating a pair of faces}\label{sec:SepFacePair}

In this section we prove Theorem~\ref{thm:RegionSubpiece}, we show how
to find the minimum -separating cycle for the unique pair of
unseparated faces  in a region subpiece .  We emulate the
minimum-separating cycle algorithm due to Reif~\cite{Reif83}
(Section~\ref{sec:reifintro}).  Recall that Reif's algorithm finds the
minimum -separating cycle by first cutting the graph  open
along the shortest -to- path , creating , and then
computing shortest paths  between a vertex  and its copy
in .   is a cycle that crosses  exactly once; the min
-separating cycle is the minimum over all such cycles.
 
We cannot afford to work in  or  and wish to find
shortest paths by using the precomputed distances in the dense
distance graphs using the adaptation of Dijkstra's algorithm to these
dense distance graphs developed by Fakcharonphol and Rao, FR-Dijkstra.
In order to make use of FR-Dijkstra and the precomputed distances, we
must deal with the following peculiarities:
\begin{itemize}
\item  corresponds to distances in , not .  We compute
  modified dense distance graphs to account for this in
  Section~\ref{sec:modify-dense-dist}.
\item For a vertex ,  may not be contained by
  .  We call such cycles \emph{internal cycles}.  We show how to
  find these cycles in Section~\ref{sec:find-intern-cycl}.
\item  is not contained entirely in .  For a vertex , we will compute  by composing distances in
   and  between restricted pairs of boundary
  vertices of .  We call such cycles \emph{external cycles}.  We
  show how to find these cycles in Section~\ref{sec:find-extern-cycl}.
\end{itemize}
Internal and external cycles are illustrated in
Figure~\ref{fig:min-separating-cycle}.  The minimum length cycle over
all internal and external cycles is the minimum -separating cycle
in .

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{ext-int-cycles.pdf}
  \caption{An external and internal cycle separating faces  and 
    in a region subpiece, whose boundary is dashed.}
  \label{fig:min-separating-cycle}
\end{figure}

\subsection{Modifying the external dense distance graph}
\label{sec:modify-dense-dist}

We use  to compute , the dense distance graph that
corresponds to distances between boundary vertices of  when the
graph is cut open along . However, we do not compute 
explicitly; rather, we determine its values as needed.  Recall the
 is really a set of dense distances graphs, one for each hole
of  and one for the outer boundary of .  We do the following for
each dense distance graph in the set.

Let  be the set of boundary vertices of  corresponding to a
hole or outer boundary of .  Cutting  open along  duplicates
vertices of  that are in , creating .   can be
represented as a table of distances between every pair of vertices of
:


We describe how to determine if  and  are separated in 
outside .  The portions of  that appear outside  form a
parenthesis of (a subset of) the boundary vertices, illustrated in
Figure~\ref{fig:parenthesis}.  By walking along  we can label the
start and endpoints of these parentheses.  By walking along the
boundary of the subpiece we can label a group of boundary vertices
that are not separated by  by pushing the vertices onto a stack
with a label corresponding to the start of a parenthesis and popping
them off when the end of the parenthesis is reached, labelling the
boundary vertices with the corresponding parenthesis.  Two boundary
vertices are not separated if they have the same parenthesis label.
Hence, whenever we are asked for a distance in  we
return  if  and  are not in the same parenthesis and
return  otherwise.  Computing the parentheses for all
the external dense distance graphs (corresponding to the holes and
outer boundary of ) takes  time.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.3]{parenthesis.pdf}
  \caption{Modifying the external dense distance graph.  (Left)  is
    given by the solid line and the boundary of the subpiece is given
    by the dotted line.  The parts of  outside the subpiece form a
    parenthesis.  (Right) In , the only finite distances from 
    in  correspond to the thick lines.  The shaded area
    represents the new face created by cutting along .}
  \label{fig:parenthesis}
\end{figure}


\subsection{Finding internal cycles}
\label{sec:find-intern-cycl}

Consider  according to the order of the vertices
along .  For each vertex , we compute the shortest
-to- paths in  where  is the copy of  in .  We
do this using (standard) Dijsktra's algorithm on the cut-open graph
induced by the vertices in  (i.e.~) and the modified
dense distance graph: .  Each cycle can then be found in
 time.  Let  be the
midpoint vertex of  according to the order inherited from .
 splits  and  into two parts (not necessarily
balanced). Recursively finding the cycles through the midpoint in each
graph part results in  levels for a total of  time to find all the internal cycles.  In order
to properly bound the running time, one must avoid reproducing long
paths in the subproblems: in a subproblem resulting from divide and
conquer, we remove degree-two vertices by merging the adjacent edges
(in the same way as Reif does~\cite{Reif83}).

\subsection{Finding external cycles}
\label{sec:find-extern-cycl}

In the lemma below, we show that every external cycle is composed of a
single edge  in the {\em unmodified}  and a shortest path
 between boundary vertices of  in  that does not
cross .  Given  and , a shortest path tree in
 rooted at a vertex of  can be
found in  time using the FR-Dijkstra
algorithm.  Therefore all shortest paths, , can be found in
 time.

We can find  in 
time by cutting open  and using the recursive internal dense
distance graph algorithm of Fakcharoenphol and Rao.  We compute
 from scratch because  has been cut open and because
 is no longer a subgraph of  due to the compact representation
we present in Section~\ref{sec:SharedEdges}.

In order to compute all the external cycles, one enumerates over all
pairs  of vertices, 
summing the weight of  and the weight of edge  in
.  Since there are  boundary vertices,
there are  pairs to consider. The minimum-weight
external cycle then corresponds to the pair with minimum weight. By
the above, this cycle can be found in  time.

It remains to prove the required structure of the external cycles.

\begin{lemma}
\label{lemma-single-edge}
  The shortest external cycle is composed of a single edge  in the
  {\em unmodified}  and a shortest path  between
  boundary vertices of  in  that does not cross .
\end{lemma}

\begin{proof}
  Let  be the shortest external cycle that separates faces  and
   -- as illustrated in Figure~\ref{fig:external}. By Theorem~\ref{thm:cross-cycle},  is a cycle that crosses
   exactly once, say at vertex .  Further,  is a shortest
  path  between duplicates of  in the graph .  Since  must
  separate  and ,  must enter .  Starting at  and
  walking along  in either direction from , let  and  be
  the first boundary vertices that  reaches.  Let  be the
  -to- subpath of  that does not cross .  Since  is a
  shortest path in ,  is the shortest path between
  boundary vertices as given in the theorem.

  Let  be the -to- subpath of  that does cross .
  By definition of  and ,  contains no vertices of 
  except  and .
  Further,  must be the shortest such path, as otherwise,  would not be the shortest
  -separating cycle. Note that every path from  to  that does not
  contain other vertices from  has to cross  at least once.
  Therefore,  must correspond to the edge  in .
\end{proof}

\begin{figure}[ht]
   \centering
   \includegraphics[scale=0.8]{external.pdf}
   \caption{The shortest external cycle  that separates faces  and .
   The figure illustrates the proof of Lemma~\ref{lemma-single-edge}.}
   \label{fig:external}
 \end{figure}




\section{Finding region subpieces}\label{sec:RegionSubpieces}

In Section~\ref{sec:overview}, we defined the region subpieces of a
piece as the intersection between a region and a piece
(Figure~\ref{fig:region-subpiece}).  In this section, we show how to
identify the region subpieces and the edges that are in them so that
we may use the min-separating cycle algorithm presented in the
previous section.  We
start by identifying the set of regions  whose
corresponding region subpieces of piece  each contain a pair of
unseparated faces (Section~\ref{sec:ident-region}).  For each region
 we initialize the corresponding region subpiece
 as an empty graph.  For each edge  of  we determine to
what region subpieces  belongs using lowest common-ancestor and
ancestor-descendent queries in the region tree
(Section~\ref{sec:ident-edges}).
We show how to do all this in  time (Section~\ref{sec:SharedEdges}), proving Theorem~\ref{thm:RegionSubpiece}.


\subsection{Identifying region subpieces}\label{sec:ident-region}

Since each edge is on the boundary of two faces, we start by marking
all the faces of  that share edges with  in  time.  Since
a pair of unseparated faces in  are siblings in the region tree, we
can easily determine the regions that contain unseparated faces. So,
in  time we can identify , the set of regions with
unseparated faces in .  The intersection of a bounding cycle of a
region in  and  are subpaths between pairs of
boundary vertices of .  We call these paths {\em cycle paths}.  We
will need the following bound on the size of  in our
analysis, illustrated in Figure~\ref{fig:bound}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{region-subpiece-bound.pdf}
  \caption{A piece  is given by the boundaries (dotted) by its two
    child pieces  and .   is a nesting set
    (solid cycles), each containing a pair of unseparated faces
    (grey).  Since these faces must be separated by the child pieces,
    each bounding cycle (except for one outer cycle) in 
    must cross the dotted lines, resulting in a bound on .}
  \label{fig:bound}
\end{figure}

\begin{lemma}\label{Lem:Root-r-subproblems}
  .
\end{lemma}
\begin{proof}
  Let  be the set of boundary vertices in  and . Let  be
  the set of faces containing edges of  and not
  edges of  and let  be the set of faces
  containing edges of  and not edges of .

  Any region  must contain at least
  one face of each  and . So, if  is
  the cycle bounding , either  contains  or 
  {\it crosses} , i.e., crosses the bounding faces of  or .

  If  contains  then we claim that no
  other cycle bounding a region in  has this property.
  To see this, suppose for the sake of contradiction that there is
  another such cycle  bounding a region .
  The cycles have to nest, i.e., either  or
  . Assume w.l.o.g.\ the former. Then all
  faces of  are contained in the interior of a face of
  . But this contradicts the assumption that  contains at
  least one face from .

  We may therefore restrict our attention to regions  whose bounding cycle  crosses .

  Consider two vertices  and  in  we and let  be the
  set of regions with cycle-paths from  to . By Lemma~\ref{Lem:Isometric}
  we know that if two isometric cycles share two vertices, then they share a path
  between these vertices as well. Hence, all cycles bounding regions in  
  share a path  from  to . As a result at most two of the regions
  in  can contain a face adjacent to .

  By Lemma~\ref{Lem:Isometric} no bounding cycles of regions in  cross, so
  each cycle going through non-consecutive boundary vertices splits the set of boundary
  vertices into two parts -- inside and outside.  By a ``chocolate-breaking''
  argument there cannot be more than  such pairs of non-consecutive vertices used by cycles.
  Moreover, there are no more than  consecutive pairs possible. As argued
  above each of these pairs cannot be used by more than two regions that contain a vertex
  inside , so there are no more than  regions in .
\end{proof}

\subsection{Identifying edges of region subpieces}\label{sec:ident-edges}

Region subpieces are composed of two types of edges: {\em internal
  edges} and {\em boundary edges}.  Let  be a region and let  be
the bounding cycle of .  An edge  is an internal edge of a
region subpiece  if the faces on either side of  are enclosed by
.  An edge  is a boundary edge of  if  is an edge of .
Every edge is an internal edge for exactly one region subpiece and we
can identify this region (Lemma~\ref{Lem:EdgeLCA}).  We can
also determine if an edge is a boundary edge for some region
(Lemma~\ref{Lem:ExtFaceLCA}).  While an edge can be a boundary edge
for several region subpieces, we can bound the potential blow-up in
running time due to this (Section~\ref{sec:SharedEdges}).

\begin{lemma}\label{Lem:EdgeLCA}
  Let  be an edge of  and let  and  be the faces
  adjacent to .  Then  is an internal edge of a region  iff
   is the lowest common ancestor of  and  in the region
  tree.
\end{lemma}

\begin{proof}
  There must exist some region  for which  is an internal edge. Let  be
  its bounding cycle.  Then both  and  are contained in
   and it
  follows that  must be a common ancestor of  and . If
   is another common ancestor and  is an ancestor of ,
  then  is contained in a face of , so  cannot belong to
  , a contradicting the choice of .
\end{proof}

Iterating over each edge  of , we can identify the region 
for which  is an internal edge and, if , the
corresponding region subpiece .  The total time required is .




\begin{lemma}\label{Lem:ExtFaceLCA}
  Let  be an edge of  and let  and  be the faces
  adjacent to .  Let  be the lowest common ancestor of  and
   in the region tree.  Then  is a boundary edge of a region 
  iff  is a descendant of  and exactly one of  is a descendant
  of .
\end{lemma}
\begin{proof}
  Assume first that , where  is the cycle bounding
  . Then w.l.o.g.\  and . Then
   is a descendant of  and, since  is not,  must be a
  descendant of .

  Now assume that  is a descendant of  and that, say,  is a descendant of . Then  is not a
  descendant of  since otherwise,  could not be an ancestor of . This implies that .
\end{proof}

Let  be a region in  and let  be the bounding
cycle of .  Let  and  be the children of  and let 
be the union of boundary vertices of  and . 
Consider the following algorithm to find starting points of cycle paths.
\begin{description}
\item[Cycle path starting points identification algorithm]
  Pick a boundary vertex .  For every edge  adjacent to 
  (there are at most three such edges), check to see if  is a
  boundary edge of .  If there is
  no such edge, then there is no cycle path through .
  Otherwise, mark  as a starting point of a cycle path for .
  Repeat this process for every vertex in .
\end{description}
Using Lemma~\ref{Lem:ExtFaceLCA} and the top tree, this process
takes  time for each region  since a constant number of
tree queries for every vertex in . By
Lemma~\ref{Lem:Root-r-subproblems}, repeating this
for all regions in  takes  time.

After identifying starting points for cycle-path we can find all edges belonging to
them using {\it linear search}, i.e., the next edge on the cycle  is found by
looking at the endpoint of the previous edge and checking which of the two remaining
edges belongs to .  If the cycles are edge-disjoint over all regions ,
then the cycle paths will also be edge-disjoint. In such a case the time to find all the
region subpieces using linear search is .
However, the cycles are not necessarily edge disjoint.  We overcome this complication
in the next section.


\subsection{Efficiently identifying boundaries of region
  subpieces}\label{sec:SharedEdges}

Since cycles will share edges, the total length of cycle paths over
all cycles can be as large as .  However, we can maintain
the efficiency of the cycle path identification algorithm by using a
compact representation of each cycle path.  The compact representation
consists of edges of  and {\em cycle edges} that represent paths in
 shared by multiple cycle paths.

View each edge of  as two oppositely directed darts and view the
cycle bounding a region as a clockwise cycle of darts.  The following is
a corollary of Lemma~\ref{Lem:Isometric}.

\begin{corollary}\label{Lem:SharedEdges}
  If two isometric cycles  and  of  share a dart, then
  either  or .
\end{corollary}

Let  be the forest representing the ancestor/descendant
relationship between the bounding cycles of regions in . By Lemma~\ref{Lem:Root-r-subproblems}, there are 
bounding cycles and, since we can make descendent queries in the region
tree in  time per query, we can find  in  time. Let  be
the maximum depth of a node in  (roots have depth
). For , let  be the set of cycles
corresponding to nodes at depth  in . By
Corollary~\ref{Lem:SharedEdges} and
Lemma~\ref{Lem:SharedEdges}:
\begin{corollary}\label{Lem:DisjointCycles}
  For any , every pair of cycles in 
  are pairwise dart-disjoint.
\end{corollary}

\subsubsection*{Bottom-up algorithm}

We find cycle paths for cycles in , then , and so on.  The cycles in  are dart disjoint,
so any edge appears in at most two cycles of .  We find
the corresponding cycle paths using the cycle path identification
algorithm in near-linear time.  While
Corollory~\ref{Lem:DisjointCycles} ensures that the cycles in
 are mutually dart-disjoint, they can share darts
with cycles in .  In order to efficiently walk along subpaths
of cycle paths  that we have already discovered, we use a balanced binary
search tree (BBST) to represent . We augment the BBST to store in each node
the length of the subpath it represents. Now, given two nodes in , the
length of the corresponding subpath of  can be determined in logarithmic time.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{alt-bin-lin-search.pdf}
  \caption{Finding a cycle path (highlighted straight line) for a
    cycle  between boundary vertices of  and
     (grey dashed lines) is found by alternating linear (solid)
    and binary (dotted) searches.  Binary searches corrrespond to
    cycle paths of region subpieces (shaded) bounded by cycles in
    .}
  \label{fig:alt-search}
\end{figure}


To find the cycle paths of a cycle  that bounds
a region , we emulate the cycle path identification algorithm:
start walking along a cycle path  of , starting from a vertex of
, and stop if you reach an edge  that has already been
visited {\em (linear search)}.  In this case,  must be an edge of a
cycle path  of a cycle .  By
Lemma~\ref{Lem:Isometric}, the intersection of  and  is a
single subpath and so we can use the BBST to find the last vertex 
common to  and  {\em (binary search)}.  We add to  an edge
 of length equal to the length of the -to- subpath of  to
compactly represent this subpath. If , we stop our walk along
.  Otherwise we continue walking (and adding edges to the
corresponding region subpiece) in a linear fashion, alternating
between linear and binary searches until a boundary vertex is
reached.  See Figure~\ref{fig:alt-search}.


We have shown how to obtain region subpieces for cycles in  and in . In order to repeat the above idea to
find cycle paths for cycles in , we need to build
BBSTs for cycle paths of cycles in .  Let  be one
such cycle path.   can be decomposed into subpaths , where  are paths obtained with linear
searches and  are paths obtained with binary
searches (possibly  and/or  are empty). To obtain a binary
search tree  for , we start with  the BBST
for .  We extract a BBST for  from the BBST we used to find
 and merge it into . We continue merging with BBSTs
representing the remaining subpaths.

Once BBSTs have been obtained for cycle paths arising from
, we repeat the process for cycles in .

\subsubsection*{Running time}
We now show that the bottom-up algorithm runs in  time
over all region subpieces, proving Theorem~\ref{thm:RegionSubpiece}. We have already described how to identify
boundary vertices that are starting points of cycle paths within this time bound.
It only remains to bound the time required for linear and
binary searches and BBST construction.

A subpath identified by a linear search consists only of edges that
have not yet been discovered.  Since each step of a linear search
takes  time, the total time for linear searches is .

The number of cycle paths corresponding to a cycle  is bounded by the
number of boundary vertices, .  We consider three types of
cycle paths.  Those where
\begin{enumerate}
\item all edges are shared by a single child of  in ,
\item no edges are shared by a child, and
\item some but not all edges are shared by a single child.
\end{enumerate}
Cycle paths of the first type are identified in a single binary search
which, by Lemma~\ref{Lem:Root-r-subproblems}, sums up to a
total of  binary searches over all cycles .  Cycle paths of the second type do not require binary search.  For
a cycle path  in the third group,  can only share one subpath
with each child (in ) cycle by Lemma~\ref{Lem:Isometric};
hence, there can be at most two binary searches per child.  Summing over all such
cycles, the total number of binary searches is  by
Lemma~\ref{Lem:Root-r-subproblems}.

In total there are  binary searches.  Each BBST has  nodes.
In traversing the binary search tree, an edge is checked for
membership in a given cycle path using Lemma~\ref{Lem:ExtFaceLCA} in
 time.  Each binary search therefore takes  time so the total time spent performing binary
searches is .

It remains to bound the time needed to construct all BBSTs.  We merge BBSTs 
and  in  time by inserting elements from the
smaller tree into the larger.

When forming a BBST for a cycle path of a cycle , it may be
necessary to delete parts of cycle paths of children of . By
Lemma~\ref{Lem:Isometric}, these parts intersect  and will
not be needed for the remainder of the algorithm. The total number of
deletions is  and they take  time to execute.  So,
ignoring deletions, notice that paths represented by BBSTs are pairwise
dart disjoint (due to Corollary~\ref{Lem:DisjointCycles}).  Applying
Lemma~\ref{Lem:Merge} with  and  then gives
Theorem~\ref{thm:RegionSubpiece}.


\section{Adding a separating cycle to the region
  tree}\label{sec:UpdateRegionTree}

Above, we showed how to find a compact representation of a minimum cycle  separating a pair of faces in a region .
This cycle should be added to the basis we are constructing and in this section, we show how to update the region tree
 accordingly. As in the previous section, let  be the
region subpiece  of piece  associated with region .

When  is added to the partial basis,  is split into two regions,
 and .  Equivalently, in ,  will be replaced
by two nodes  and . The children  of  will
be partitioned into children  of  and
 of .  Define  to be the region as defined
by the children of  that are contained to the left of  (and
symmetrically define ).  We describe an algorithm that finds
 and detects whether  is contained
by  or .  Finding  is symmetric.
The algorithms take  and  time and so we can identify the smaller side of the
partition in  time, as required for
Theorem~\ref{thm:updateregiontree}.

Given the smaller side of the partition, we use cut-and-link
operations to update  in  additional time, thus proving
Theorem~\ref{thm:updateregiontree}.  See
Figure~\ref{fig:region-tree-update} for an illustration.  Assume,
w.l.o.g., that  is the smaller set. If  is contained by  then update  by:
cutting the edges between  and each element in ,
linking each element in  to , making  the
parent of , identifying  with . If 
is contained by  then update  by: cutting the
edges between  and each element in , linking each
element in  to a new node , making  the parent
of ; identifying  with  and  with .

\subsection{Partitioning the faces}

 is represented compactly: vertices in  of degree 2 are
removed by merging the adjacent edges creating {\em super edges}.
Each super edge is associated with the first and last edge on the
corresponding path.  In addition to partitioning the faces, we must
find the compact representation for the two new regions,  and
.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{partition-inside.pdf}
  \caption{If  (bold cycle) is a counterclockwise cycle, then
     is contained by . The children of  (boundary
    given by thin cycle) adjacent and to the right of  are grey.
    In this example,
    the edges to the left of  (and not on ) will never reach a
    boundary edge of : therefore the left of  forms .
    Vertices of  are given by dark circles.}
  \label{fig:partition-faces}
\end{figure}


The algorithm for finding  starts with an empty set and
consists of three steps:
\begin{description}
\item[Left root vertices] Identify the set  of vertices  on 
  having an edge emanating to the left of ; also identify, for each
  , the two edges on  incident to  (in , not the
  compact representation).  (Details will be given in
  Section~\ref{subsec:Step1}.)
\item[Search] Start a search in  from each vertex of .  During
  this search, avoid
  edges of  and edges that emanate to the right of .
  For each super edge
   of  visited, find the first (or last) edge  on the
  path represented by . 
\item[Add] For each searched edge and for each pair of faces 
  adjacent to this edge, find the
  two children of  in  having  and  as
  descendants, respectively. Add those nodes that are also descendants
  of  to . 
\end{description}

This algorithm correctly builds : The algorithm visits
all super edges  that are strictly inside  and on the left
side of .  Let  and  be the children of  that are
added corresponding to edge .   is a region or a face of : let
 be the bounding cycle.  Since  is a descendent of ,
 is contained by .  Since  is in  and :
so must .  and  are therefore the child regions of  on either
side of .


The algorithm can easily determine if  is contained by
 or , by noting whether a searched edge ever
belongs to the cycle bounding .  Given a searched edge  and
adjacent edges , we can determine whether  is in the bounding
cycle of  (Lemma~\ref{Lem:ExtFaceLCA}).  The search can only the
boundary of  if  is contained by .  (See Figure~\ref{fig:partition-faces}.)

\subsubsection*{Analysis}
The above-described algorithm can be implemented in  time. Finding the left-root
vertices is the trickiest part; while ,
 could be much smaller than the
number of vertices in , even in the compact representation. We give
details in Section~\ref{subsec:Step1}.  Assuming that left-root vertices
can be found quickly, we analyze the remaining steps.

\begin{lemma}
The number of super edges in  that are searched inside  is .
\end{lemma}
\begin{proof}
  Since  is degree three and all faces and isometric cycles in 
  are simple, the compact representation of  is also degree three.
  Since there are no degree-two vertices,  is 3-regular.
  Therefore .  Since, by Euler's
  formula,  we get, .
\end{proof}

\paragraph{Search step}
As we can identify if an edge belongs to 
(Lemma~\ref{Lem:ExtFaceLCA}) in  time, we can avoid edges
of  during the search.  Since  is degree three, we will never
encounter edges emanating from the right of .  The search can be
done by DFS or BFS in linear time, starting with vertices of .
Given a super edge  found by this search, we find the first or
last edge  (of ) on the path the super edge represents in 
time, since  is associated with .  The search takes
.



\paragraph{Add step}
Checking if  is contained by  or
) takes  time per searched edge
(Lemma~\ref{Lem:ExtFaceLCA}) given the adjacent faces  and 
(which can be identified using the original graph).  Finding the
children of  that are ancestors of  and  also takes
 time using the operations  and
 in the top tree for .  The total time
spent adding is .


\subsection{Finding left-root vertices}\label{subsec:Step1}

We show how to find the set  of left-root vertices along  in
 time where  is the number
of super edges in the compact representation of .  Recall from
Section \ref{sec:SepFacePair} that  has 
super edges and they are of three different types: edges in
, edges in , and edges and cycle paths in .  We
will show how to use binary search to prune certain super edges of 
that do not contain vertices of .  We first assume that each super
edge is on the boundary of a child region (as opposed to a child face)
of  that is to the left of .  We relax this
assumption in Section~\ref{sec:face-assumption}.

The following lemma is the key to using binary search along :
\begin{lemma}\label{Lem:BinSearch}
  Let  be the shortest -to- path in  that is also a
  subpath of . For , let  be the edge of  that is incident
  to  and let  be the child-region of  that is left of
   and  bounded by . Then  if and only if no
  interior vertex of  belongs to .
\end{lemma}
\begin{proof}
  The reverse direction is trivial.

  By our assumption,  and  are regions, not faces.  Their
  bounding cycles must therefore be isometric.  If , then
  by Lemma~\ref{Lem:Isometric},  is a subpath of the boundary of
  : no interior vertex of  could belong to  in this
  case. This proves the forward direction.
\end{proof}


\subsubsection*{Shortest path covering}\label{subsubsec:SPCovering}
In order to use Lemma~\ref{Lem:BinSearch}, we cover the left-root vertices
of  with two shortest paths  and .  Let  be a vertex that
is the endpoint of a super edge of .  Since  is isometric, there
is a unique edge  such that  is the union of  and two
shortest paths  and  between  and the endpoints of .
Note that  could be in the interior of a super edge of .  The
paths  and  that we use to cover  are prefixes of  and .


To find , we first find , the super edge that contains .
Since  and  are shortest paths and shortest paths are
unique, the weight of each path is at most half the weight of the
cycle.  To find , simply walk along the super edges of  and
stopping when more than half the weight is traversed:  is the
last super edge on this walk.

Given , we continue this walk according to the type of super
edge that  is.  If  corresponds to a cycle path, then,
by definition, all the interior vertices of  have degree two
in  and so cannot contain a left-root vertex; there is no need to
continue the walk.  and  are simply the paths along  from 
to 's endpoints.  This takes  time.

If  is an edge of  or , we continue the
walk.  We describe the process for  as  is
similar: we continue the walk started above through the subdivision
tree of  that is used to find .   is given
by a path of edges in the internal dense distance graph of 's
children in the subdivision tree.  We may assume that we have a top
tree representation of the shortest path tree containing this path and so we can find the child super
edge  that contains ; using binary search this takes  time.  Recursing through the subdivision tree finds a cycle path
or edge that contains  for a total of  time.

When we are done,  and  are paths of super edges from  
or .    and  each have  super
edges and they are found in  time.



\subsubsection*{Building }
Using Lemma~\ref{Lem:BinSearch}, we will decompose  into maximal
subpaths  such that no interior vertex of a
subpath belongs to . Each subpath  will be associated with the
child region of  to the left of  that is bounded (partly) by
.  We repeat this process for  and find  in  time by
testing the endpoints of the subpaths.

Let  be one of the  super edges of .
 is either an edge of  or .  Suppose
 is in .  We can apply Lemma~\ref{Lem:BinSearch}
to the first and last edges on the path that  represents, and
stop if there are no vertices of  in the interior of the path.
Otherwise, with the top tree representation of the shortest path tree containing the
shortest path representing , we find the midpoint of this path
and recurse.  If  is in , the process is similar.
Adjacent subpaths may still need to be merged after the above process,
but this can be done in time proportional to their number.

How long does it take to build ?  Let  be a super edge
representing subpath  of  and let  be the number of
interior vertices of  belonging to .  Then there are
 leaves in the recursion tree for the search applied to . We claim that the height of the recursion tree is .
Let  be some root-to-leaf path in the recursion tree.  If 
is in ,  is split into  subpaths, one for
each level of the subdivision tree; in each level, the corresponding
subpath is halved  times before reaching a single edge. If
 is in , the search may go root-wards in the
subdivision tree but once we traverse down, we are in  and
will thus not go up again. The depth of the recursion tree is still
.

At each node in the recursion tree, we apply two top tree operations
to check the condition in Lemma~\ref{Lem:BinSearch} and one top tree
operation to find the midpoint of a path for a total of 
time.  The total time spent finding the  vertices of  in  is
 time.   If , we still need  time to
check the condition in Lemma~\ref{Lem:BinSearch}. Summing over
all super edges of , the time required to identify  is
,
as desired.

\subsubsection*{Handling faces}\label{sec:face-assumption}
We have assumed that every child of  incident to and left of  is
a region, not a face.  Lemma~\ref{Lem:BinSearch} is only true for this
case: boundaries of faces need not be isometric, and so the
intersection between a face and shortest path may have multiple
components.  However, notice that after the triangulation of the
primal followed by the triangulation of the dual, every face  of  is bounded by a simple
cycle of the form  where , , and 
are edges and , , and  are tiny-weight shortest paths (see Section~\ref{sec:defs}).
Call the six endpoints of edges  the \emph{corners
of }. We associate each edge of  with the
path containing it among the six paths , , , , , and .

We present a stronger version of Lemma~\ref{Lem:BinSearch} which
implies the correctness of the left-root vertex finding algorithm even
when children of  are faces, not regions:
\begin{lemma}\label{Lem:BinSearchElementary}
  Let  be the shortest -to- path in  that is also a
  subpath of . For , let  be the edge on  incident
  to  and let  be the child of  to the left of  and
  containing .
\begin{enumerate}
\item If neither  nor  are faces, then  if and
  only if no interior vertex of  belongs to .
\item If exactly one of  is a face, then some interior vertex
  of  belongs to .
\item If both  and  are faces and , then some interior vertex
  of  belongs to .
\item If both  and  are faces, , and  and  are
  associated with different subpaths of , then some interior vertex of  is
  a corner of  or belongs to .
\item If both  and  are faces, , and  and  are
  associated with the same subpath of , then no interior vertex of  belongs to .
\end{enumerate}
\end{lemma}
\begin{proof}
  Part~1 is Lemma~\ref{Lem:BinSearch} and parts~2 and~3 are trivial. For
  part~4, we may assume that  is fully contained in the boundary of 
  since otherwise, some interior vertex of  belongs to . Since  and
   are associated with different subpaths of , it follows that
  some interior vertex of  is a corner of .
  For part~5, we may assume that . Then  and  are
  on the same (tiny weight) shortest path in  so  must be
  contained in the boundary of . It follows that no interior vertex of 
  belongs to .
\end{proof}

Using Lemma~\ref{Lem:BinSearchElementary} instead of
Lemma~\ref{Lem:BinSearch}, our -finding algorithm will also
identify corners of faces incident to . Since
each face has only 6 corners but contributes at least two vertices to
, this will not increase the asymptotic running time.

\subsection{Obtaining new regions}

While we have found the required partition of the children of  and
updated the region tree accordingly, it remains to find compact
representations of the new regions  and .  Recall that we
only explicitly find one side of the partition, w.l.o.g., .

To find , start with an initially empty graph. In the {\em search}
step, we explicitly find all the super edges of  that are not on
the boundary of .  Remove these edges from  and add them to
.  The remaining super edges are simply subpaths of  between
consecutive vertices of .  These edges can be added to  {\em
  without} removing them from .

The super edges left in  are exactly those in .  However,
there may be remaining degree-two vertices that should be removed by
merging adjacent super edges.  All such vertices, by construction,
must be in , and so can be removed quickly.

That super edges are associated with the first and last edges on their
respective paths is easy to maintain given the above construction.
The entire time required to build the new compact representation is
.


\section{Reporting min cuts}\label{sec:MinCutReport}

By Theorem~\ref{Thm:MinCutOracle}, we can report the weight of any
minimum -cut in constant time.  We extend this to report a minimum
separating cycle for a given pair of faces in  in time
proportional to the number of edges in the cycle. By duality of the
min cuts and min separating cycles, this will prove
Theorem~\ref{thm:mincuts}.

In this section, we do not assume that the graph is 3-regular.  The
edges added to achieve 3-regularity may increase the number of edges in a
cycle.  However, we can still compute , the region tree of
, with the degree-3 assumption.  We will rely only on the
relationship between faces in , which did not change in the
construction for the degree-3 assumption.  Since cycles in the min cycle
basis are boundaries of regions represented by , the region tree
also reflects the ancestor/descendant relationships between cycles in
the min cycle basis.

Recall that we view a cycle  as a clockwise cycle of {\em darts}
(Section~\ref{sec:SharedEdges}).  It follows from
Lemma~\ref{Lem:ExtFaceLCA} that the set of darts
in  that are not also in a cycle  that is an ancestor of  forms a path (possibly equal
to ). Further, the set of darts in  that are not also in {\em
  any} strict ancestor of  also form a path, denoted . Using
the next lemma, we can succinctly represent any cycle using these
paths.  See Figure~\ref{fig:succinct-cycle} for an illustration.

\begin{lemma}\label{lem:cycle-decomp}
  Let  be the ancestral path to the root of
   for .   can be written as the concatenation of
  the path , prefixes of , a
  subpath of  and suffixes of  and in that order.
\end{lemma}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{succinct-cycle}
  \caption{A succinct representation of a cycle in the min cycle
    basis.}
  \label{fig:succinct-cycle}
\end{figure}

\begin{proof}
  Let  be the root-most cycle that shares a dart  with :
   is in .  By Lemma~\ref{Lem:ExtFaceLCA}, the intersection
  of  with  is a single path: it must be a subpath  of
  .  Let .  By the definition of
  , the start of  must be the start of  and
  the end of  must be the end of .  The remainder of
  the proof follows with a simple induction.
\end{proof}

Let  be the last dart of  before  and let  be
the first dart of  after .  Suppose additionally that we
know, for every dart , the cycle  for which .

\subsection{Finding a min-separating cycle}

If we are given , , and  for every cycle (node)
in  and  for every dart , we can find a minimum
-separating cycle  in  time by the following procedure.
First we can find the node in  corresponding to  in
 time using the oracle (Theorem~\ref{Thm:MinCutOracle}).  To
find , walk along , starting with , until you reach the
end.  Let  and walk along  starting with
.  Suppose we are at dart  along .  Let .
Walk along  until either you reach its end or you hit
dart .  In the first case, continue the process with
.  In the second case, continue the process with the first
dart of .  By Lemma~\ref{lem:cycle-decomp}, this process
will eventually reach the start of .


\subsection{Preprocessing step}

It remains to show how to precompute , ,  for
every cycle in  and  for every dart.  We find these
using the top tree representation of  with 
preprocessing time.

Let  and  be the faces to the left and right of a dart
.  Then it follows easily from Lemma~\ref{Lem:ExtFaceLCA} and the
clockwise orientation  that  is the bounding cycle of
region  and can be found in
 time.

We can easily construct  from the set of darts with
.  The ordering can be found just using the endpoints of
these darts so that we can walk along  as required in the
previous section.

To find  and , we work from leaf to root in  as in the bottom-up algorithm of Section~\ref{sec:SharedEdges}.  We
will show how to find .  Finding  is symmetric.  For
cycle  we can easily find the last dart  of .
Consider the darts  leaving the endpoint of  in
counterclockwise order, in the embedding, starting with the reverse of
, we test if  is on the boundary of  using
Lemma~\ref{Lem:ExtFaceLCA} in  time.  As we test darts we
remove them from further consideration as they will be in the interior
of all ancestor cycles.  In total, this takes  time.


\section{A detailed presentation of planar separators} \label{sec:sep}

In this Section, we show how to find separators satisfying
Definition~\ref{def:sep}, that is, we show how to ensure that Miller's
cycle separator theorem applied to a connected piece yields connected
subpieces.  We also give the proof of Theorem~\ref{thm:sumPiece} which
bounds the size of the pieces and the sum of the squares of their
boundaries in a recursive decomposition.  Although this result has
been required of previous results, specific details, to our knowledge,
is not anywhere else in the literature.  We have included a formal
proof of Theorem~\ref{thm:sumPiece} for completeness.


\subsection{Ensuring Connected Pieces}\label{section-dis}

Now, we show how to ensure that Miller's cycle separator theorem applied
to a connected piece yields connected subpieces. To find a cycle separator
 of the desired size, faces need to be of constant size which we ensure
by triangulating the piece temporarily. Having found , the triangulating
edges are removed and the remaining edges of  induce a separation of the
piece into child pieces. The problem with this approach is that  may cross
a hole multiple times by using the added triangulating edges, giving a
child piece consisting of multiple connected components.

To avoid this problem we triangulate the piece in such a way that  uses
at most two triangulating edges from each hole. We triangulate each hole with
a star centered at a new vertex embedded inside the hole. (This introduces a
high-degree vertex, contradicting our constant-degree assumption, but as we only use
the triangulating edges to find the separator, we still have child
pieces that have constant degree.) The same is done for the external face of the
piece if that face is not a triangle.


Formally, let  be a connected piece with holes and let  be the
triangulation of  as described above.  Let  be the simple cycle
separator.  Since
 is simple it can use at most two triangulating edges per hole and both
of these edges (if any) are consecutive along .  Let
 and  be the two closed regions of the plane bounded by .
The child pieces are  and .  Note
that the child pieces share the edges of  that are in .  The
endpoints of these shared edges are separator vertices and so the size
of the decomposition is still bounded by
Lemmas~\ref{Lem:LevelPieceSize}
and~\ref{Lem:LevelPieceBoundariesSquared} and
Theorem~\ref{thm:sumPiece}.

Since  is connected, the boundary of each hole is a (not
necessarily simple) cycle.  We argue that since a separating cycle 
uses at most two triangulating edges from each hole, both incident
to the star center, the child pieces
as defined are connected.  Consider, w.l.o.g., child piece .
Suppose  uses triangulating edges  and , where
 denotes the star center, for a hole (or the external face) of  with (connected)
boundary . Let .  Since  uses no other
triangulating edges from this hole,  connects  and 
and is in .  The connectivity of  then follows from the connectivity of .

To find a recursive subdivision consisting of connected pieces using the approach in~\cite{INSW11} (which is based
on the approach in~\cite{FR06}), the vertex-weighted variant of Miller's cycle separator theorem is applied and we need to handle
the following three cases when applying the theorem to :
\begin{enumerate}
\item  and  should each contain at most a constant fraction of the vertices of ,
\item  and  should each contain at most a constant fraction of the boundary vertices of ,
\item  and  should each contain at most a constant fraction of the holes of .
\end{enumerate}
The first resp.\ second case can be handled by distributing vertex weights evenly on the vertices
resp.\ boundary vertices of  and assigning weight  to newly
introduced 'hole' vertices.
For the third case, we distribute vertex weights evenly on the newly
introduced 'hole' vertices and assign weight
zero to all vertices of . Alternating between these cases will
achieve all three properties within a few separations. (see~\cite{INSW11} and~\cite{FR06} for details.)

Note that the top-level piece  is trivially connected. The above
combined with results from~\cite{INSW11} and from~\cite{FR06} then
imply that we can find a recursive subdivision in  time
where all pieces are connected.

\subsection{Bounds on sizes of pieces and boundaries}

The running time of our algorithm depends on the total size of all the
pieces as well as on the sum of squares of piece boundary sizes. This
is also the case for the algorithm of Fakcharoenphol and Rao. They
make the simplifying assumption that a piece of size  has  boundary vertices. Although their construction ensures that piece
sizes and boundary sizes go down geometrically along any root-to-leaf
path in the recursive subdivision tree, the two quantities need not go
down by the same rate since some applications of Miller's separator
theorem may give more unbalanced splits than others. Thus in their
construction, a piece of size  may have more than 
boundary vertices. Theorem~\ref{thm:sumPiece} bounds the total size of
pieces as well as the sum of squares of boundary sizes.

We observe that only the new boundary vertices are replicated among
the child pieces and we get:

where  is some constant that depends on the constant in Miller's
Cycle Separator Theorem.

\begin{lemma}\label{Lem:LevelPieceSize}
  Let  be the set of pieces in level  of a
  recursive subdivision of .  Then .
\end{lemma}

\begin{proof}
  Let  be the constant such that pieces of size at most
   are not subdivided further in a recursive subdivision.
  We may assume that no piece has size less than .
  Let  denote the total number of vertices (counted with
  multiplicity) in the leaf-pieces of the recursive subdivision of an
  -vertex piece .  We will show that  for suitable constants  and .  The lemma
  will follow since the number of vertices (counting multiplicity) in
  any level of the recursive subdivision is dominated by the number of
  vertices in the leaves; this is bounded by  which is .

  We prove that  by induction.  In the
  base cases, in which a piece of size  is a leaf of the recursive
  subdivision (so ), .  This
  is bounded by  so long as .  Setting  guarantees this.

  Now consider a piece  of size .  Assume inductively
  that the claim holds for all values smaller than . Let  be
  the size of the  child of ;  has  children.
  By the inductive hypothesis we get:
  
  We lower bound  by observing that  can only be as small as allowed by ,  (see Definition~\ref{def:sep}).
  The minimum value occurs when two of the 's are equal to  and all
  others are zero, giving:
  
  Combining Equations~(\ref{eq:2}),~(\ref{eq:1}), and~(\ref{eq:3}), we
  get that 
  This completes the induction for  sufficiently larger than .
\end{proof}

\begin{lemma}\label{Lem:LevelPieceBoundariesSquared}
  Let  be the set of pieces in level  of a
  recursive subdivision of .  Then .
\end{lemma}
\begin{proof}
We may assume that, by adding dummy boundary vertices that do not
contribute to children,

where  is a constant that we will pick below.
We will show that for any piece  with children :

The lemma follows from this because, by summing over all pieces in a level we get,

Since  has only dummy boundary vertices, , which is , as desired.

We now prove Equation~(\ref{eq:SumOfSquares}). In the next equation, the first and second
inequalities follow from Definition~\ref{def:sep} and
Equation~(\ref{eq:4}), respectively:


This completes the proof.
\end{proof}


Since the depth of the recursive subdivision is ,
Lemmas~\ref{Lem:LevelPieceSize}
and~\ref{Lem:LevelPieceBoundariesSquared} imply
Theorem~\ref{thm:sumPiece}.


\section{Lexicographic-shortest paths} \label{sec:unique-short-paths}

In this section we show how to impose uniqueness of shortest paths by breaking ties in a consistent manner, deterministically.  This will prove:

\begin{theorem}\label{thm:lex}
  The algorithms of Theorems~\ref{Thm:MinCutOracle}
  through~\ref{Thm:CycleBasisExplicit} can be made deterministic with
  only an additional  factor in the preprocessing time.
\end{theorem}

\noindent Let  be the weight function on the
edges of . Index the vertices of  from  to . For a
subgraph , define  as the smallest index of vertices in
. Hartvigsen and Mardon~\cite{HM94} showed that there is another
weight function  on the edges of  such that for any pair
of vertices in , (i) there is a unique shortest path between them
w.r.t.\  and (ii) this path is also a shortest path w.r.t.\
. Furthermore, for two paths  and  between the same pair of
vertices in ,  exactly when one of
the following three conditions is satisfied:
\begin{enumerate}
\item .
\item  and .
\item ,  and
      .
\end{enumerate}
A shortest path w.r.t.\  is called a \emph{lex-shortest path} and a shortest path tree w.r.t.\  is called
a \emph{lex-shortest path tree}.
The properties of  allow us to use  instead
of  in our algorithm. In the following, we show how to do so
efficiently.

We first use a small trick from Hartvigsen and Mardon~\cite{HM94}: for
function , we add a sufficiently small  to the weight
of every edge. This allows us to disregard the second condition
above. When comparing weights of paths, we may treat 
symbolically so we do not need to worry about precision issues. The
tricky part is efficiently testing the third condition.

We need to make modifications to every part of our algorithm in which
the weights of two shortest paths are compared. All such comparisons
occur when we (1)~use Fakcharonphol and Rao's variant of Dijkstra's
algorithm, FR-Dijkstra \cite{FR06} and (2)~find a shortest path
covering of an isometric cycle  in
Section~\ref{subsubsec:SPCovering}.


\subsection{FR-Dijkstra}
Let us first adapt FR-Dijkstra to compute lex-shortest paths. The type
of shortest path weight comparisons in FR-Dijkstra are of the form
, where , , , and  are
vertices,  and  are the distances from the root of the
partially built tree to  and , respectively, and  and
 are the lengths or weights of edges  and
. Note that an edge can be an edge of  (in which case
) or be a cycle edge (Section~\ref{sec:SharedEdges})
or an edge of an external or internal dense distance graph (in which
case  is the length of the path the edge represents).

For simplicity, assume first that all edges considered by FR-Dijkstra
belong to ; we test whether  as
follows. Let  be the partially built shortest path tree rooted at a
vertex  and let  and  be the -to- and  paths in
, respectively. If the first two lex-shortest conditions are
inconclusive, we need to check if .

Let  be the least-common ancestor of  and  in .  Then  is the -to- subpath of , excluding . It
follows from this that, by representing  as a top tree, we can find
the smallest index in the two sets in logarithmic time.  Using top
trees, we can also similarly handle a cycle edge , by keeping the
smallest index of 's interior vertices. These indices can be found
during the construction of region subpieces in
Section~\ref{sec:ident-region} without an increase in running time.


\subsection{Internal dense distances}\label{sec:FRint}
We also need to handle edges from internal and external dense distance graphs. Let us first consider the problem of computing
lex-shortest path trees in . As before, we compute shortest path trees for pieces bottom-up. Let  be a piece with
children  and  and assume that we have computed lex-shortest path trees in both of them. Assume also that every
edge in  is associated with the smallest index of interior vertices on the path in  that the
edge represents. This information can be computed bottom-up during the construction of  without increasing running time.

Let  be a partially-built shortest-path tree in .  With the
above definitions, consider the problem of testing whether . Let  and  be the first
edges on  and , respectively, with  defined as
earlier.  Define  and  as the paths in  represented by
 and , respectively. Let , , , and
. By definition of ,
 and  are vertex-disjoint. We need to
compute these indices and check if .

Each edge of  belongs to  and is thus associated with the smallest index of interior vertices
on the path in  represented by the edge. Top tree operations on  as above then allow us to find  and  in
logarithmic time.

To find  and , we consider two cases:  and
 belong to the internal dense distance graph for the same
child of  or they belong to different graphs. In the first case, assume that, say, .
Then we can decompose these two edges into shortest paths in the same shortest path tree in  and we can recursively
find  and . In the second case, assume that, say,  and . Since the
lex-shortest paths representing these edges in  and  are edge-disjoint and since  is a partially
built lex-shortest path tree in ,  and   share no vertices except . Thus, 
is the smallest index of vertices in  and we can obtain this index in constant time from the index of
 and the index associated with edge  which is the smallest index of interior vertices on . Similarly,
we can find  in constant time.

Since the subdivision tree has  height, the recursion depth of the above algorithm is , implying that we
can determine whether  in  time. Hence, lex-shortest path trees in  can
be computed in a total of  time.

\subsection{External dense distances}
Computing lex-shortest path trees in  within the same time bound is very similar so we only highlight the differences.
Having computed lex-shortest path trees in  bottom-up, we compute lex-shortest path trees in  top-down.
For a piece , we obtain lex-shortest path trees from lex-shortest path trees in its sibling and parent pieces. We can then
use an algorithm similar to the one above to find lex-shortest path trees in . At each recursive step, we either go up
one level in  or go to . It follows that the recursive depth is still  so
lex-shortest path trees in  can be found in  time.

\subsection{FR-Dijkstra in Reif's algorithm}
We also use FR-Dijkstra in Section~\ref{sec:SepFacePair} to emulate
Reif's minimum separating cycle algorithm.  First, we computed a
shortest path  between two faces of the region subpiece using
FR-Dijkstra. With an algorithm similar to the one above, we can
instead compute a lex-shortest path between the two faces with an
 time overhead.  Next, we cut open the region subpiece
along this path.  The handling of external distances in the cut-open
graph does not change, but the internal distances are recomputed.  We
recompute these as in Section~\ref{sec:FRint}.



\subsection{Shortest path coverings}
In Section~\ref{subsubsec:SPCovering}, we gave an algorithm to find the unique edge  on isometric cycle  such that
the two shortest paths from a fixed vertex  on  to  and to  cover all vertices of  and all edges except .
We showed how to do this in  time, where  is
the size of the compact representation of  obtained in
Section~\ref{sec:SepFacePair}. We need to modify the algorithm to do so with respect to lex-shortest paths.

Recall that to find , a linear search of the super edges of 
from  was first applied to find the super edge  of  such
that the shortest path in  representing  contains . As
above, we may assume that every super edge of  is associated with
the smallest index of interior vertices on the path it
represents. Hence, by keeping track of the smallest interior vertex
index for super edges visited so far in the linear search as well as the
smallest interior vertex index for edges yet to be visited, we can
find  in  time w.r.t.\ lex-shortest paths.

Having found , we need to apply binary search on a path
representing  in a lex-shortest path tree. We do this by
first finding the midpoint of this path as in Section~\ref{subsubsec:SPCovering}. If the two halves have the same weight
and the same number of edges, we can use a top tree operation on each half to determine which half has the smallest index.
It follows that all binary searches to find  take  time. The total time to find  is thus ,
which matches the time in Section~\ref{subsubsec:SPCovering}.


\bibliographystyle{plain}
\bibliography{all-gh}

\end{document}
