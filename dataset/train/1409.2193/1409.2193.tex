\documentclass[a4wide]{article}






\usepackage{amsthm} 

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{times}
\usepackage{mathrsfs}
\usepackage{amscd}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{authblk}



\usepackage{circle} 






\usepackage{version}
 
\includeversion{full}


\frenchspacing
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}

\setcounter{secnumdepth}{3}



\newcommand{\commentout}[1]{~\\***CUT[\\ #1 ~\\exists x(\lid{\strat(j)}{x} \land K_i \lid{\strat(j)}{x})\phi \equiv p ~|~\neg \phi~|~\phi_1 \lor \phi_2~|
~A\phi ~|~\nxt\phi ~|~\phi_1 \until \phi_2 ~
|~ \existsg{x}\phi~ |~ \lid{i}{x}~ | ~D_G\phi~|~C_G\phi\always( \neg \exists x( K_{\Low} (\neg  
\lid{\High}{x}
))~. \exists x( K_{\Low}( \neg \lid{\High}{x}))  ~~\equiv~~ \bigvee_{h \in L_{\High}}  K_{\High} ( \neg  \phi_h) \langle s,k,c\rangle \ptrans{a} \langle s',k',c'\rangle\ECTL(\Ags\cup \strat(\Ags), \Prop, \SVar)~.\CTLsK(
\Ags
\cup \strat(\Ags), \Prop, \SVar)\mathit{NonDed}= \always( \neg \existsg{x}( K_{\Low} (\neg  \lid{HS}{x}))~\mathit{Ded}(G) = \sometimes( \existsg{x}( D_{G} ( \lid{HS}{x}))~\langle s,k,\bot\rangle \langle s,k,s\oplus k\rangle^\inftyr_{\Low}(0)  = O_{\Low}(\langle s,k,\bot\rangle )  =  \bot = O_{\Low}(\langle \overline{s},\overline{k},\bot\rangle )  = r'_{\Low}(0) 
r_{\Low}(n) &  = O_{\Low}(\langle s,k,s\oplus k \rangle )\\
&  =  s\oplus k \\
& =  \overline{s}\oplus \overline{k} \\
& = O_{\Low}(\langle \overline{s},\overline{k},\overline{s} \oplus \overline{k}\rangle ) \\
& =  r'_{\Low}(n)
r'_{HR}(m) =  O_{HR}(\langle s', k', s'\oplus k'\rangle) = \langle k', s'\oplus k' \rangle~. D_\emptyset \forallg{x}(\neg K_{\Low}(\neg \lid{\strat(\High)}{x}))~.\phi \equiv p ~|~\neg \phi~|~\phi_1 \lor \phi_2~|~\atlop{G}\nxt\phi ~|~~\atlop{G}\always\phi ~|~\atlop{G}(\phi_1 \until \phi_2)  \neg K_{e} \neg D_{\{e\} \cup \strat(G)}  \phi~. 
& \trl{p} = p \\
 &  \trl{(\neg \phi)} = \neg \trl{\phi} \\
 & \trl{(\phi_1\land \phi_2)} = \trl{\phi_1} \land \trl{\phi_2} \\ 
& \trl{(\atlop{G}\phi)} = \neg K_e \neg D_{\{e\} \cup \strat(G)}  \trl{\phi} \\
& \trl{(\nxt \phi)} = \nxt \trl{\phi} \\ 
& \trl{(\always \phi)} = \always \trl{\phi}\\ 
& \trl{(\phi_1 \until \phi_2)} = \trl{\phi_1} \until \trl{\phi_2} 
\GStrats = \{ \langle \alpha_i\rangle_{i\in G}~|~G\subseteq \Ags,~\forall i\in G~(\alpha_i \in \GStrats_i)\} \neg D_{e} \neg (( \neg D_{\{e\} \cup \strat(\Ags)} \neg \sometimes p) \land (D_{\{e\} \cup \strat(G)} \always q))  \atlop{A} \always ( p \land \atlop{A,B} \sometimes q)~. \neg D_{e} \neg D_{\{e,\strat(A)\} }\,( \always p \land  \neg \mathbf{D_{e}} \neg D_{\{e,\strat(A),\strat(B)\} } \,\sometimes q)~. \neg D_{e} \neg D_{\{e,\strat(A)\} }\,( \always p \land  \neg \mathbf{D_{\{e,\strat(A)\}}}\, \neg D_{\{e,\strat(A),\strat(B)\} } \, \sometimes q)~. 
(~\langle\cdot H \cdot\rangle\phi ~)^{G} = 
  \neg D_{\{e,\strat(G\setminus H)\}}\, \neg 
D_{\{e,\strat(G\cup H)\} } \, 
\phi^{G\cup H}
   (~ \cdot\rangle H \langle\cdot\phi ~ )^G = 
\phi^{G\setminus H}~.
 D_{\{e\} \cup \sigma(\Ags \setminus \{i\})}( 
\lid{\strat(i)}{x}
\rimp  \phi^{+\strat(i)})\phi \equiv p ~|~\neg \phi~|~\phi_1 \lor \phi_2~|~\atlop{G}\nxt\phi ~|~~\atlop{G}\always\phi ~|~\atlop{G}(\phi_1 \until \phi_2) ~|~K_i\phi~|~D_G\phi~| ~C_G\phi
 
&  \trl{(K_i\phi)} = K_i \trl{\phi} ~~~~~~\trl{(D_G\phi)} = D_G \trl{\phi}~~~~~~~\trl{(C_G\phi)} = C_G\trl{\phi} 

E, s\models^\GStrats 
\atlop{G}^\bullet_{\mathcal{ K}(H)}\phi 
&~~~ \parbox[t]{3.5in}{if there exists a 
locally 
uniform 
group strategy  
for group 
such that for all states  with , 
and  for all paths  from  that are consistent with , 
we have that .
} 
 \neg K_{e} \neg D_{H\cup\strat(G)} \phi~. \neg K_{e} \neg \bigwedge_{i\in H} D_{\{i\}\cup\strat(G)} \phi~.C_{H}(\lid{\strat(G)}{x} \rimp \phi) \existsg{x}  C_{H}(\lid{\strat(G)}{x} \rimp \phi)~. \Env, Q \models p ~~\text{ if for all states  we have . }  \Env, Q \models \hat{\K}_G\phi ~~\text{ if  
 }  \existsg{x}  \K^1_{G_1} ... \K^n_{G_n}(\lid{\strat(H)}{x} \rimp \phi)~. 
\phi \equiv p ~|~\neg \phi~|~ \phi \land \phi ~|~ \nxt \phi~|~\phi \until \phi~|~\atlop{v}\phi~|~\atluop{v}\phi~|~(i,v)\phi
 
 & \trlsl{\assignedAgents}{p} = p \\
 &  \trlsl{\assignedAgents}{(\neg \phi)} = \neg \trlsl{\assignedAgents}{\phi} \\
 & \trlsl{\assignedAgents}{(\phi_1\land \phi_2)} = \trlsl{\assignedAgents}{\phi_1} \land \trlsl{\assignedAgents}{\phi_2} \\ 
 & \trlsl{\assignedAgents}{(\nxt \phi)} = \nxt \trlsl{\assignedAgents}{\phi} \\ 
 & \trlsl{\assignedAgents}{(\phi_1 \until \phi_2)} = \trlsl{\assignedAgents}{\phi_1} \until \trlsl{\assignedAgents}{\phi_2} \\
& \trlsl{\assignedAgents}{(\atlop{v_i}\phi)} = \exists v_i \trlsl{\assignedAgents}{\phi} \\
& \trlsl{\assignedAgents}{(\atluop{v_i}\phi)} = \forall v_i \trlsl{\assignedAgents}{\phi} \\
& \trlsl{\assignedAgents}{((i,v_i)\phi)} = D_{e\cup\strat(\Ags \setminus \{i\}) } ( \lid{\strat(i)}{v_i} \rimp  \trlsl{\assignedAgents}{\phi} ) \\
 
& \trlsl{\assignedAgents}{(\exists x.\phi)} = \exists 
x 
\trlsl{\assignedAgents}{\phi} \\
& \trlsl{\assignedAgents}{(\forall x.\phi)} = \forall 
x
\trlsl{\assignedAgents}{\phi} \\
& \trlsl{\assignedAgents}{(\phi(x,y))} = D_{e} ( 
\lid{\strat(1)}{x}\land \lid{\strat(2)}{y} 
\rimp  \trlsl{\assignedAgents}{\phi} ) \\
U_i(v)= \nxt(u_i=v)BR_i(v) =  U_i(v)\land K_{\strat(-i)}\bigwedge_{v'\in V_{i}}(U_{i}(v')\rimp 
v'\leq v)BR_i = \bigvee_{v\in V_i} BR_i(v)\Env_\mathcal{ G}, \Strat^{\unif, \detstrat}(\Env_\mathcal{ G})\models  \neg D_\emptyset \neg (BR_0\land BR_1)~.BU_i(v) =  D_\emptyset \left( \bigwedge_{v'\in V_i}((BR_{-i} \land U_i(v')) \rimp 
v'\leq v)\right)BU_i =  \bigvee_{v\in V_i} (U_i(v) \land BU_i(v))\Env_\mathcal{ G}, \Strat^{\unif, \detstrat}(\Env_\mathcal{ G})
\models \neg D_\emptyset \neg ( BU_0 \land BU_1 ) 
\neg D_\emptyset \neg  (  \done \land  \bigvee_{x\in \CCN}  K_{P} (  \cc \neq  x)) 
 
\neg D_\emptyset \neg  (  \done \land  \neg \exploited \land 
E\Diamond
\bigvee_{x\in \CCN}  D_{\{ A, \strat(A)\}} (  \cc \neq x)) 
P_i = {\bf do} ~\phi^i_1 \rightarrow a^i_1~ [] ~ \ldots [] ~\phi^i_{n_i } \rightarrow a^i_{n_i}~{\bf od} \sgy_i(s) = \{ a^i_j ~|~  1\leq j\leq n_i,~~\I_\sgy,s \models \phi^i_j\}~. 
& \trlk{p} = p \\ 
&  \trlk{(\neg \phi)} = \neg \trlk{\phi} \\
& \trlk{(\phi_1\land \phi_2)} = \trlk{\phi_1} \land \trlk{\phi_2} \\ 
&  \trlk{(D_G\phi)}  = D_{G\cup \strat(\Ags)}\, \trlk{\phi}  \\ 
& 
\trlk{(A \phi)} = A \trlk{\phi} \\
& 
\trlk{ (\nxt \, \phi) } = \nxt ~ \trlk{\phi} \\
& \trlk{(\phi_1 \until \phi_2)} =  (\trlk{\phi_1}\,  \until \, \trlk{\phi_2})
{\bf imp}(P) = D_{\strat(\Ags)} ( \bigwedge_{i \in \Ags, j =1 \ldots n_i} ((\phi^i_j)^\PP\sgy\Envr\I(E,\Strat^\unif(E))\sgyr(0) = (s, \alpha)sm\in \nat\sgyP\Env\I\I(E,\Strat^\unif(E))\phi\I,(r,m) \models \trlk{\phi}\I_\alpha, (r,m) \models \phir(m) = (s,\alpha)\phi\phi = A\psi\trlk{(A\psi)} = A(\trlk{\psi})rr'\Ir[0\ldots m] = r'[0\ldots m]rr'\alpha = r_{\strat(\Ags)}(0)\I,(r,m) \models A(\trlk{\psi})\I,(r',m)\models \trlk{\psi}r'\Ir[0\ldots m] = r'[0\ldots m]\I,(r',m)\models \trlk{\psi}r'\I_\alphar[0\ldots m] = r'[0\ldots m]\I_\alpha,(r',m)\models \psir'\I_\alphar[0\ldots m] = r'[0\ldots m]\I_\alpha,(r,m) \models A\psi\I,(r,m) \models \trlk{(A\psi)}\I_\alpha,(r,m) \models A\psi\phi = D_G\psi\trlk{(D_G\psi)} = D_{G\cup \strat(\Ags)} (\trlk{\psi})(r,m)(r',m')\I(r,m) \sim_{G\cup\strat(\Ags)}  (r',m')rr'\alpha = r_{\strat(\Ags)}(0)(r,m) \sim_{G}  (r',m')(r,m)(r',m')\I_\alpha\alpha(r,m) \sim_{G}  (r',m')(r,m) \sim_{G\cup\strat(\Ags)}  (r',m')\I,(r,m) \models D_{G\cup \strat(\Ags)} (\trlk{\psi})\I,(r',m')\models \trlk{\psi}(r',m')\I(r,m) \sim_{G\cup\strat(\Ags)}  (r',m')\I,(r',m')\models \trlk{\psi}(r',m')\I_\alpha(r,m) \sim_{G}  (r',m')\I_\alpha,(r',m')\models \psi(r',m')\I_\alpha(r,m) \sim_{G}  (r',m')\I_\alpha,(r,m) \models D_G\psi(r,m)r(m) = (s,\alpha)\alpha^i_ji\I,(r,m) \models E\nxt \did_i(a^i_j)a^i_j \in \alpha_i(s)\alphaPE(r,m)\Ir(m) = (s,\alpha)\I,(r,m) \models \mathbf{imp}(P)(r',m')(r',m') \sim_{\strat(\Ags)} (r,m)\I,(r',m') \models  \bigwedge_{i \in \Ags, j =1 \ldots n_i} ((\phi^i_j)^\.
From  it follows that  for some state  of . 
Thus, from what was noted above,  iff . 
Since  is an implementation of  in , this holds iff 
. By the claim proved above,  is 
equivalent to .
Thus, we have that  . 
It follows that . 

Conversely, suppose that , and let . 
We show that  is an implementation of  in . Let
 be any -reachable state, with, in particular,  a point of  
with . 
We need to show that for all agents , we have 

i.e., that for all  we have  iff .
Note that , so we have that 

As in the previous paragraph, 
 iff , 
which is equivalent to  , 
and by the claim proved above, equivalent to 
 , 
 i.e.,  . 
 Thus  iff , for all , which is what we needed
 to prove.  
\end{proof} 

In particular, as  a consequence of this result, it follows that several properties 
of knowledge-based programs  (that do not make use of common knowledge operators)
can be expressed in the system 
: 
\be 
\item The statement that there exists an implementation of  in  can be expressed by 
 
 \item The statement that  all implementations of  in  
 guarantee that formula  of  (which may contain knowledge operators) holds at all times can be expressed 
 by  
 \ee 


We remark that as a consequence of these encodings and 
Theorem~\ref{mcCTLsK} (in section~\ref{sec:mc} below) that 
 
model checking 
in strategy space 
is in PSPACE,  
we obtain the following result: 

\begin{cor} \label{cor:kbpcomplex}
The following are in PSPACE: 
\begin{enumerate} 
\item Given a finite environment  and a knowledge based program , determine if  has an implementation in . 
\item Given a finite environment  and a knowledge based program  and a    formula , 
determine if  for all implementations  of  in . 
\end{enumerate} 
\end{cor} 



For testing existence 
(part 1 of Corollary~\ref{cor:kbpcomplex}), 
this result was known \cite{FHMV1997}, 
but the result on verification 
(part 2 of Corollary~\ref{cor:kbpcomplex}), 
has not previously been noted
(though it  could also have been shown using 
the techniques in~\cite{FHMV1997}.)  

One might expect that Proposition~\ref{prop:kbp} can be extended to 
knowledge based programs in which formulas may contain common knowledge 
operators, simply by adding the condition  
 
to the transformation of formulas. However, this does not
work, because the interpretation of  in a subsystem  
is based on  chains of points , 
such that  is a run of joint strategy  for all . 
By contrast, the semantics  of  in  
involves chains of points which are not required to preserve the joint strategy: 
rather each step preserves the local state of one of the agents in  \emph{or} the strategy of one of the agents.  
Neither does it work to use the translation 

since the operator  similarly does not preserve the joint strategy, and it is not 
enough to test only at the end of the chain that the joint strategy has been preserved. 

It is not clear that the translation we require for common knowledge 
is expressible in . What would work is to generalize the common knowledge 
operator to the form , where  is a set of sets of agents (instead of a set of agents), 
and to define the semantics of this more general form as the greatest fixpoint of equation 
  
We could then use the translation 
 
Here the semantics involves chains of points in which we preserve
the joint strategy and one of the agents in . 
While this is an interesting extension, that we consider worthy of study, we do not pursue 
this as an ad hoc extension here, leaving it for future consideration in a broader context, such as a logic that
extends  by mu-calculus operators. 
   
\section{Model Checking}\label{sec:mc}

\newcommand{\stratdesc}{sd}
\newcommand{\stratconf}{\gamma}

Model checking is the problem of computing  whether a formula of a logic holds in a given model. 
We now consider the problem of model checking ESL and various of its fragments. 


The model checking problem is to  determine whether  for a finite state environment , a set  of strategies 
and a context , where   is an  formula. 



For purposes of results concerning the complexity of model checking, we need a measure
of the size of a finite environment. Conventionally, the size of a model is taken to be the 
length of a string that lists its components, and typically, this is polynomial in the 
number of states of the model. 
We note that in the 
case of environments, the set of labels  of the transition relation 
is an -fold cartesian product, where , so 
(if the number of agents is a variable in the class of environments we consider) the size of the transition relation 
may be exponential in the number of 
agents.\footnote{
For certain classes of environments, we could address this 
by allowing  that the transition relation  is presented in some notation with the property
that (1) given states  and a joint action , 
the representation of  has size polynomial in the size of  and , 
and (2) 
determining whether  is 
in PTIME
given  and the representation of . 
One example of a presentation format with this property is the 
class of {\em turn-based environments}, where at each state , there exists an 
agent  such that if  for a joint action , then for all joint actions 
with  we have . That is,  the set of states reachable
in a single transition from  depends only on the action performed by agent . 
In this case, the transition relation can be presented more succinctly 
as a subset of . 
While it would be interesting to consider the effect of such optimized representations on 
our complexity results, we do not pursue this here.}


However there is a more severe issue with respect to the parameter  
of the model checking problem. A strategy for a single agent is a mapping from 
states to sets of actions of the agent. Hence the number of strategies we may need to 
list to describe   explicitly could be exponential in the 
number of \emph{states} of the environment, even in the case of a single agent. 
To address this issue, we abstract 
the strategy set 
  to a parameterized 
class such that for each environment , the set  is a set of strategies for . 
When  is a complexity class, 
we say that the parameterized class   {\em can be presented in }, 
 if the problem of determining,  
given an 
environment   and a joint strategy  for  , whether  ,  is in complexity class . 
For example, the class 
 of all strategies for   can be PTIME-presented, as can ,   and  . 

We first consider the complexity of model checking the full language .
The following result gives an upper bound of EXPSPACE for this problem. 


\begin{theorem}\label{mcESLupper}
Let   be a parameterized   class of strategies 
that can be presented in  EXPSPACE.
The complexity of deciding, given an environment , an \ESL\ formula  
and a context  for 
, defined on the free variables of ,  
whether , is in EXPSPACE. 
\end{theorem}

\begin{proof} 
The problem can be reduced to that of model checking the temporal epistemic logic  
obtained by omitting the constructs  and  from the language . 
This is known to be PSPACE-complete.\footnote{The result is stated explicitly in \cite{EGM2007:LFCS}, but techniques sufficient for a 
proof (involving guessing a labelling of states by knowledge  subformulas in order
to reduce the problem to LTL model checking and also verifying the guess
by LTL model checking) were already present in \cite{Vardi96tark-kbp}.
The branching operator  can be treated as a knowledge operator for purposes of the proof.} 
The reduction 
involves 
an exponential blowup of size of both the formula and the environment, 
so we obtain an EXPSPACE upper bound. 

Model checking for temporal epistemic logic takes as input a formula and a
structure that is like an environment, except that its transitions are not based on 
a set of actions for the agents. More precisely, 
an \emph{epistemic transition system} for a set of agents  
is a tuple , 
where  is a set of states,  is the set of initial states, 
 is a state transition relation, for 
each , component  is a 
function giving an observation in some set  for the agent  at each state, 
and  is a propositional assignment. 
A {\em run} of  is a sequence 
such that  and  for all . 
To ensure that every partial run can be completed to a run, we assume that 
the transition relation is {\em serial}, i.e., that for all states  there exists a 
state  such that .


Given an epistemic transition system , we define an interpreted system   
as follows. For a run  of , define the lifted run  (here ), by 
 and   for . Then we take  to be the set of 
lifted runs  with  a run of . The assignment  is given by . 
The model checking problem for temporal epistemic logic 

is to decide, 
given an epistemic transition system  and a formula 
, 
whether 
  for all  runs  of . 


We now show how to reduce  model checking to  model checking. 
Given an environment 
for  
, we first introduce a set of new propositions

which will be interpreted at global states of the generated interpreted system. 
Each proposition  will be true only at the global state .
These propositions will help to eliminate the constructs  and . 
We then define the epistemic transition system 

for the language 
, 
in which the propositions have been extended by the set 
, as follows: 
\be
\item 
sE\alpha, 

\item , 
\item  iff  
(in )
for some joint action  
and , 
\item  
and , 
for ,

\item .  
\ee 
We can treat the states  as tuples indexed by 
 by taking 
 and   for , and . 

Note that  a joint strategy for an environment  can be represented in space 
, 
and the number of strategies is exponential in the space requirement. 
Thus, the size of  is . 
Note also that the construction of  can be done in EXPSPACE
so long as verifying whether an individual strategy  is in  
can be done in EXPSPACE. 



We also need a transformation of the formula. 
Given a formula  of  and a context  for , 
we define a formula , inductively, by 
\be
\item , for , 
\item   
\item , ~ , 
\item , ~  
\item , ,
\item . 
\ee 
Plainly the size of  is , and this
formula is in . 
A straightforward inductive argument based on the semantics shows that \\
 iff . 
It therefore follows from the fact that  model checking  
with respect to the observational semantics for knowledge is in 
PSPACE that  model checking is in EXPSPACE. 
\end{proof} 


The following result shows that a restricted version of the model checking problem, 
where we consider systems with just one agent and uniform deterministic strategies is already EXPSPACE hard. 

\newcommand{\blnk}{\bot}  

\begin{theorem}\label{mcESLlower}
The problem  of deciding,  given an environment  for a single agent, and an \ESL\ sentence , 
whether , is EXPSPACE-hard. 
\end{theorem}
 
\begin{proof} 
We show how polynomial size inputs to the problem can simulate exponential space deterministic Turing machine computations. 
Let  be a one-tape Turing machine solving an EXPSPACE-complete problem, 
with states , initial state , final (accepting) state , 
final (rejecting) state , 
input alphabet , tape alphabet , 
and transition function .   We assume that  runs in space 
  for a polynomial , and that the transition relation is defined so that the machine idles in 
 its final state 

 on accepting, and idles in 
state 
 on rejecting. The tape alphabet  is assumed to 
 contain the blank symbol . 
 
Define
  to be the set of ``cell-symbols'' of . 
We may represent a configuration of  as a finite sequence 
over the set , containing exactly one element  of , 
representing a cell containing symbol  where the machine's head 
is positioned, with the machine in state .  For technical reasons, 
we pad configurations with a blank symbol to the left and right (so configurations 
take space ), so that the initial configuration has the head at the second tape cell 
and,  without loss of generality, assume that the machine is designed so that it never moves the head to the initial 
or final 
padding blank. 
This means that the transition function  can also be represented as a set of 
tuples 
, 
such that  iff, whenever the machine is in a configuration 
with  at cells at positions , respectively, the next configuration has  at the cell at position . 

Given the TM   and a number  
(for some polynomial ) 
we construct an environment  such that
for every input word , with ,  
there exists a sentence   of size polynomial in  
such that  iff  accepts . 
The idea of the simulation,  
depicted in Figure~\ref{fig:EXPSPACE}, 
is to represent a 
computation 
of the Turing machine, using space , 
by representing the  sequence of configurations of  for the computation consecutively along a run 
of the environment . 
(These runs travese a set of states we call -states.) 
Each cell of a configuration will be encoded as a  block of 
 consecutive moments of time in .
In a block, the first of these moments represents the cell-symbol of the cell, and the 
remaining  moments represent the position of the cell in the configuration, in binary. 
Not all runs of  will correctly
encode a computation of the machine, so we use the formula to 
check whether a 
computation 
of  has been correctly encoded in a given
run of . 
In order to do so, the main difficulty is to check that corresponding cells of successive configurations represented along a run are updated correctly according to the 
yields relation of the Turing machine. For this, we need to be able to identify these corresponding cells, i.e. the cells with the same position number in the binary representation. 
For this, we use the behaviour of a strategy on an additional set of states (-states) to give an alternate representation of a binary number, 
one that may be accessed in a formula by means of existential quantification. The formula then compares the representations of the binary number at two locations in the 
the -run with the representation of the binary number in the strategy, in order to check that the numbers represented at the two locations in the -run are the same. 
Details are given below. 


\begin{figure}[h]  
\centerline{\includegraphics[height=12cm]{EXPSPACE.pdf} } 
\caption{Structure of the encoding
\label{fig:EXPSPACE}}
\end{figure} 

\newcommand{\cbit}{\mathtt{c}} 

The environment  has propositions 
.  
Propositions from 
 are used to represent cell  elements, 
and  is used to represents the bits of a counter that indicates
the position of the cell being represented. In particular, 
 a cell in a configuration,  at position 
, in binary, and containing symbol 
, 
will be represented by a sequence of  states,  
the first of which satisfies proposition , such that for , 
element  of the sequence satisfies  iff . 
(Thus, low order bits are represented to the left in the run.) 

We take the set of states of the environment to be 
 
The set of initial states of the environment is defined to be . 
We define the assignment  so that 
 for 
, 
, 
and  and . 


We take the set of actions of the single agent to be the set .
The transition relation  is defined so that for 
the only transitions are 

for   and  
 and   . 
Intuitively, this forces the runs starting at state  to alternate between selecting 
a symbol from  and a sequence of bits  
for the counter. 
Note that for every sequence  in , 
and for every strategy  for the single agent, 
there exists a run  with  and . 
For each 
, 
the 
states of the form  for  
form an isolated component in the 
transition relation, and are used to ensure that there is a sufficiently rich 
set of strategy choices for strategies to encode counter values. 




The length of the counter sequence segments of a run generated by this transition
system can vary within the run, but we can use a formula of length 

to state that these segments always 
have length  wherever they appear in the run; let  be the formula  

where we write  for . 
By definition of the transition relation, this formula holds on  a run starting in state  just when 
it consists of states of the form  alternating with sequences of states of the form 
of length exactly . 

The transition system generates arbitrary such sequences of states  of length , intuitively constituting
a guess for the correct counter value. 
Note that a temporal formula of length  can say that these guesses for the
counter values are correct, in that the counter values encoded along the run are  (etc). 
Specifically, this is achieved by the following formula : 
5pt] 
\bigwedge_{i=1\ldots N} ((\nxt c \land \ldots \nxt^{i-1} c \land \nxt^i \neg c) \rimp \\ 
~~~~~~~~~~~~~~~~~
\nxt^{N+1} ( \nxt \neg c \land \ldots  \land \nxt^{i-1} \neg c \land  \nxt^i c)  \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\land\bigwedge_{j=i+1\ldots N} ( (\nxt^j c) \dimp (\nxt^{j+N+1} c)))\\ 

\end{array}\right )  
\end{array}\right ) 
 \blnk \land \nxt^{N+1} ((q_0,a_1) \land \nxt^{N+1}( a_2 \land  \nxt^{N+1} (\ldots  \nxt^{N+1} (a_n \land \nxt \, 
((\alpha_{T,Q} \rimp (\blnk\land \neg \phi_{zero})) 
\until (\alpha_{T,Q}\land \phi_{zero})))\ldots )) 
\Box ((\alpha_{T,Q} \land ( \phi_{zero} \lor \phi_{max})) \rimp \bot )

\alpha_{T,Q} \land \bigwedge_{i=0\ldots N-1} (\nxt^{i+1} c) \dimp \neg D_\emptyset \neg ( \lid{\sigma(1)}{x} \land t_i \land \nxt c) 

  \Box \left(
  \begin{array}{l} 
  \bigwedge_{(a,b,c,d) \in \Delta} 
  (a \land \neg \phi_{max} \land \nxt^{N+1} (b \land \neg \phi_{max} \land 
\nxt^{N+1} c))
  \rimp \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~
   \nxt^{N+1} \exists x \, [\phi_{num}(x) \land  \nxt \, ( (\neg \phi_{num}(x)) \until (\phi_{num}(x) \land d )]
   \end{array}
   \right)
\Env_{T,N} \models (\phi^N_{clock} \land \phi^N_{count} \land  \phi^w_{init} \land  \phi_{trans}) \rimp  \phi_{accept}  Q_1x_1...Q_nx_n(\gamma)
\begin{array}{cl} 
s_0 \ptrans{(j',k')} s_{1,j',k'} \\ 
s_{t,j,k}  \ptrans{(j',k')} s_{t+1,j',k'} &  \text{~~~for } \\
s_{n,j,k}  \ptrans{(j',k')} s_{n,j,k}~.
\end{array} 
\pi(s_{t,j,k})= \{p_t \}\cup \{q_1 ~|~j=1\}\cup  \{q_2~|~k=1\} \bigwedge_{j=1\ldots m} D_{\{\strat(1), \strat(2)\}}(p_{j-1} \rimp (
E\nxt
(q_1) \dimp 
E\nxt 
(q_2))) 
This says that the assignments encoded by the strategies of the two agents agree on the values
of the variables .  
Assuming, without loss of generality, that  is even, 
and that the quantifier sequence in  is , 
given the QBF formula , 
define the formula  to be 
\begin{tabbing} 
\= \\ 
\> \=  \\ 
\>\>\= \\ 
\>\> \> \=  \\ 
\>\>\> \>  \\
\>\>\>\> 
\end{tabbing}
where  is the formula obtained by replacing each 
occurrence of a variable  in  by the formula . 
Intuitively, the first operator 
existentially chooses a value for variable , encoded in , the
next operator 
 
remembers this strategy while
encoding a universal choice of value for variable  in , and
the formula  checks that the existing choice for  
is preserved in . Continued alternation between the
two strategies adds universal or existential choices 
for variable values while preserving previous choices. 
It can then be shown that the QBF formula  is true 
iff . 
\end{proof} 

Combining Theorem~\ref{mcESLminus} and Theorem~\ref{mcCTLKlower}, we obtain the following: 

\begin{cor} 
Let  be a PSPACE-presented class of strategies. 
The problem of deciding if ,  
given an environment , a formula  of 
and a context  for the free variables of  relative to  and , 
is PSPACE complete. 
\end{cor} 




Since PSPACE is strictly contained in EXPSPACE, this result shows a strict improvement in 
complexity as  a result of the restriction to the CTL-based fragment. 
We remark that, by a trivial generalization of the standard state labelling algorithm for model 
checking \CTL\ to handle the knowledge operators, 
the problem of model checking the logic  
in the system 
 
generated by an epistemic 
transition system 
 is in PTIME. Thus, there is a jump in complexity from \CTLK\  
as a result of the move to the strategic setting, even without the addition of the operators  and .  
However, this jump is not so large as the jump to the  the full logic . 

An orthogonal restriction of  is to retain the  temporal basis, i.e., to allow full use of 
LTL operators, but to 
allow
epistemic operators and 
strategy 
indices, 
but omit use of the operators  and . This gives the logic 
. For this logic we also see an improvement in the complexity of model 
checking compared to full , as is shown in the following result. 

\begin{theorem} \label{mcCTLsK}
Let  be a PSPACE presented class of strategies for environments .  
The complexity of deciding, given an environment 
and a \CTLsK\ formula  for agents 
, 
whether , is PSPACE-complete. 
\end{theorem}
\begin{proof} The lower bound is straightforward from the fact that linear time temporal logic LTL is a 
sublanguage of \CTLsK, and model checking LTL is already PSPACE-hard \cite{SistlaC85}. 
For the upper bound, we describe an alternating PTIME algorithm, and invoke the fact that APTIME = PSPACE \cite{alternation}. 
We abbreviate  to . 

For a formula , write  for the maximal epistemic subformulas of , defined to be the 
set of subformulas of the form  or 
 or  for some set  of basic and strategic 
indices, 
which are themselves not a subformula of a larger subformula of  of one of these forms. 
Note that  can be taken to be epistemic because it is equivalent to ; 
in the following we assume that  is written in this form. 
Also note that for epistemic formulas , satisfaction at a point depends 
only on the global state, i.e.,  for all  points  and  of , we have
that if  then  iff . 
Thus, for global states   of 
,
we may write 
to mean that   for some point  with . 

Define a  {\em -labelling} of  to be a mapping , 
giving a truth value for each maximal epistemic subformula of . 
A -labelling can be represented in space . 
Note that if we treat the maximal epistemic subformulas of  as if they were atomic 
propositions, evaluated at the states of  using the -labelling , 
then  becomes an LTL formula, evaluable on any path in  
with respect to the labelling . 
Verifying that all -paths from a state  satisfy  with respect to  
is then exactly the problem of LTL model checking, for which there exists an 
APTIME procedure 
since model checking LTL is in PSPACE \cite{SistlaC85} and APTIME = PSPACE \cite{alternation}. 
For this to correspond to model checking in , 
we require that 
the -labelling 
 gives the correct answers for the truth value of the formula
at each state , i.e., 
that  iff . 
 We handle this by means of a guess and verify technique. 

To handle the verification, an alternating PTIME algorithm    is defined, for 
 an epistemic formula, such that  returns TRUE 
iff  .  The definition is recursive and uses a call to the  procedure ASAT. 
Specifically, 
 operates as follows: 
\be 
\item universally guess a state  of  and a joint strategy  in , then 


\item  verify that  is reachable in  using joint strategy , 
that , and that  is in , then 

\item existentially guess a -labelling  of ,  then 

\item universally, 
\be \item 
call , and 
\item for each state  and formula , 
call .  
\ee
\ee
Note that  step 4(b) verifies that the 
-labelling  is correct. 

For , 
the procedure is similar, except that instead of verifying that  in the 
second step, we need to verify that . 
This is  easily handled in APTIME by a standard recursive procedure that guesses a midpoint of the 
path 
and branches 
universally to verify the existence of the left and right halves of the chain. 
(See the proof of Theorem~\ref{mcESLminus} for some further discussion on this point.) 

To solve the model checking problem in , 
we can now apply the following alternating procedure: 
\be 
\item universally guess a global state  of , then 
branch existentially to the following cases: 
\be 
\item if  is an initial state of  return FALSE, else return TRUE, 
\item if , return FALSE, else return TRUE, 
\item call . 
\ee 
\ee
Evidently, each of the alternating procedures runs in polynomial time internally, 
and the number of recursive calls is . It follows that the entire
computation is in APTIME = PSPACE. 
\end{proof}

It is interesting to note that, although  is  significantly richer than the temporal logic LTL, 
the added expressiveness comes without an increase in complexity: model checking LTL is already PSPACE-complete \cite{SistlaC85}. 




\section{Conclusion}\label{sec:concl}

We now discuss some related work and remark upon some questions for future research. 
The sections above have already made some references and 
comparisons to related work on each of the  topics that we cover. 
Beside these references, the following are also worth mentioning. 


Semantics that explicitly encode strategies in runs  have been used 
previously in the literature 
on knowledge in information flow security
\cite{HalpernOneill}; what is novel in our approach is
to develop a logic that enables explicit reference  to these strategies.



A variant of propositional dynamic logic (PDL) for describing strategy profiles 
in normal form games subject to preference relations is introduced in 
\cite{vanEijck13}. This work does not cover temporal aspects as we have done 
in this paper. Another approach based on PDL is given in 
\cite{RamSimon08}, which describes strategies by means of formulas. 

A very rich generalization of ATEL for probabilistic environments is described in \cite{Schnoor10}. 
This proposal includes variables that refer to {\em strategy choices}, and  strategic operators that may 
refer to these variables, so that statements of the form ``when coalition A runs the strategy represented
by variable S1, and coalition B runs the strategy represented by variable S2, 
and the remaining agents behave arbitrarily, then the probability that  holds
is at least '' can be expressed. Here a strategy choice maps each 
state, coalition and formula to a uniform imperfect recall strategy for the coalition. 
There are a number of syntactic restrictions compared to our logic. 
The epistemic operators in this approach  apply only to 
state formulas rather than path formulas (in the sense of this distinction from .) 
Moreover, the strategic variables may be quantified, but only in the prefix of the formula. 
These constraints imply  that notions such as ``agent  knows that there exists a strategy by which it can achieve
'' and  ``agent  knows that it has a winning response to every strategy chosen by agent '' 
cannot be naturally expressed. 

The extended temporal epistemic logic  we have introduced, of which our epistemic 
strategy logic  is an instantiation with respect to a particular semantics, uses constructs that 
resemble constructs  from {\em hybrid logic} \cite{BS98}.
Hybrid logic is an approach to the extension of modal logics that 
uses ``nominals'', i.e., propositions  that hold at a 
single world. These can be  used in combination with operators
such as  , which marks an arbitrary world
as the unique world at which nominal  holds. Our construct  is 
closely related to the hybrid construct  , but we work in a setting
that is richer in both syntax and semantics than previous works. 
There have been a few works using hybrid logic ideas in the context of epistemic logic \cite{Hansen11,Roy09a} 
but none are  concerned with temporal logic. Hybrid temporal logic has seen a larger
amount of study \cite{BozzelliL10,FranceschetRS03,FranceschetR06,SchwentickW07}, 
with variances in the semantics used for the model checking problem. 

We note that if we were to view the variable  in our logic as a propositional constant, 
it would be true at a set of points in the system , hence not a nominal in that system.
Results in \cite{BozzelliL10}, where a hybrid linear time temporal logic
formula is checked in all paths in a given model, suggest that 
a variant of  in which  is treated  as a nominal in 
would have a complexity of model checking at least non-elementary, compared to 
our EXPSPACE and PSPACE complexity results. 

Our PSPACE model checking result for  seems to be more closely related to the 
result in \cite{FranceschetR06} that 
model checking a logic HL is PSPACE-complete. 
Here  is essentially a branching  time future operator and  is a universal operator (similar to 
our ), the construct  says that  holds at the world marked by the 
nominal , and  says that  holds after marking some world by . 
The semantics in this case does not unfold the model 
into either a tree or a set of linear structures before checking the formula, 
so the semantics of the hybrid existential  is close to our idea
of quantifying over global states. Our language, however, has a richer set of 
operators, even in the temporal dimension, and introduces the strategic dimension in the 
semantics. It would be an interesting question for future work to 
consider fragments of our language to obtain 
a more precise statement of the
relationship with hybrid temporal logics. 

Strategy Logic \cite{CHP10} is a (non-epistemic) generalization of  ATL for perfect information 
strategies in which strategies may be explicitly named and quantified. 
Strategy logic  has a non-elementary model checking problem. Work on identification of more efficient variants 
of quantified strategy logic includes \cite{MogaveroMV10}, who formulate a variant 
with a 2-EXPTIME-complete model checking problem. In both cases, strategies are perfect recall strategies, rather than the imperfect recall 
strategies that form the basis for our PSPACE-completeness result for model checking. 


Most closely related to this paper are a number of independently developed 
works that consider epistemic extensions of variants 
of strategy logic.  Belardinelli \cite{Belardinelli14} develops a logic, 
based on linear time temporal logic with epistemic operators, that adds an operator 
, the semantics of which existentially modifies the 
strategy associated to agent  in the current strategy profile. 
It omits the binding operator from \cite{MogaveroMV10}, so 
provides no other way to refer to the variable . 
The logic is shown to have nonelementary model checking 
complexity. This complexity is higher than the results we have presented
because the semantics for strategies allows agents to have perfect 
information and perfect recall (though the semantics for the 
knowledge operators is based on imperfect information 
and no recall), whereas we have assumed imperfect information 
and no recall for strategies.  

Another extension of strategy logic with epistemic operators has been 
independently developed by \v{C}erm\'{a}k et al \cite{CLMM2014,Cermak}. 
Their syntax and semantics differs from ours in a number of respects. 
Although the syntax appears superficially in the
form of an extension of LTL, it is more like CTL in some regards. 
The transition relation is deterministic in the 
sense that for each joint action, each state has a unique successor
when that action is performed. 
Strategies are also assumed to be deterministic (whereas we allow nondeterministic strategies.)  
This means that, like CTL, the semantics of a formula
depends only on the current global state and the current strategy profile, 
whereas for LTL it is generally the case that the future structure of the run from a given global state can vary, and 
the truth value of the formula depends on how it does so. 
Although it seems that non-determinism could be modelled, as is commonly done, through the choice of actions 
of the environment, treated as an agent, the fact that strategies are deterministic, uniform and 
memoryless means that the environment must choose the 
same alternative each time a global state occurs in a run. This means
that this standard approach to modelling of non-determinism does not work for this 
logic. The syntax of the logic moreover prevents epistemic operators
from being applied to formulas with free strategy variables, whereas we
allow fully recursive mixing of the constructs of our logic. 
Consequently, epistemic notions from our logic like ,  expressing an agent's knowledge 
about the effects of its own strategy, which are used in 
several of our applications, do not appear to be expressible in this logic.  
Finally, the notion of ``interpreted system'' in this work, which corresponds
most closely to our notion of ``environment'', also seems less general than our notion of 
environment because it  defines the accessibility relations for the knowledge operators in a way that makes the 
environment state known to all agents. 

In another paper ~\cite{AAAI2014}, we have implemented a symbolic algorithm that handles model checking 
for the fragment , which, as shown above, encompasses the expressiveness of ATEL. 
Existing algorithms described in the literature for ATEL model checking~\cite{MCMASATL2006,CSS2010,BPQR2013} 
are based either on  explicit-state model checking or are only partially symbolic in that they
iterate over all strategies, explicitly represented.  Our 
experimental results in~\cite{AAAI2014} show that by comparison with the partially-symbolic 
approach, a fully-symbolic algorithm can greatly improve the performance and therefore scalability of model checking. 
The approach to model checking epistemic strategy logic implemented in \cite{CLMM2014,Cermak} 
is fully symbolic, but as already mentioned, this logic has a more limited expressive
power than ours and its semantics does not permit representation of a nondeterministic environment. 
(It does not seem that the semantics could be extended to allow nondeterminism while retaining correctness
of their algorithm.) 

Our focus on this paper has been on an observational, or imperfect recall, 
semantics for knowledge. Other semantics for knowledge are also 
worth considering, 
but are left for future work. 
We note one issue in relation to the connection to ATEL that we
have established, should we consider a perfect recall version of our logic. 
ATEL operators effectively allow reference to situations in which agents switch their strategy
after some actions have already been taken, whereas in our model an agent's strategy is fixed for the 
entire run. When switching to a new strategy, there is the possibility that the given state is not 
reachable under this new strategy. 
We have handled this issue in our translation by assuming that all states are initial, so that 
the run can be reinitialized if necessary to make the desired state reachable. 
This is consistent with an imperfect recall interpretation of ATEL, but it is not
clear that this approach is available on a perfect recall interpretation. 
We leave a resolution of this issue to future work.  

\bibliographystyle{plain}
\bibliography{atl}

\end{document}
