\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{bm}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{array}
\usepackage{booktabs} \usepackage{multirow}



\title{SNAS: stochastic neural architecture search}





\author{Sirui Xie, Hehui Zheng, Chunxiao Liu, Liang Lin\\
SenseTime \\
\texttt{\{xiesirui, zhenghehui, liuchunxiao\}@sensetime.com} \\
\texttt{linliang@ieee.org}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\dc}{\color{black}}
\newcommand{\tomodify}{\color{black}}
\newcommand{\zh}{\color{black}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
    We propose \textit{Stochastic Neural Architecture Search} (SNAS), an economical \textit{end-to-end} solution to Neural Architecture Search (NAS) that trains neural operation parameters and architecture distribution parameters in same round of back-propagation, while maintaining the completeness and {\zh differentiability} of the NAS pipeline. In this work, NAS is reformulated as an optimization problem on parameters of a joint distribution for the search space in a cell. To leverage the gradient information in generic differentiable loss for architecture search, a novel search gradient is proposed. We prove that this search gradient optimizes the same objective as reinforcement-learning-based NAS, but assigns credits to structural decisions more efficiently. This credit assignment is further augmented with locally decomposable reward to enforce a resource-efficient constraint. In experiments on CIFAR-10, SNAS takes {\zh fewer} epochs to find a cell architecture with state-of-the-art accuracy than non-differentiable evolution-based and reinforcement-learning-based NAS, which is also transferable to ImageNet. It is also shown that child networks of SNAS can maintain the validation accuracy in searching, with which attention-based NAS requires parameter retraining to compete, exhibiting potentials to stride towards efficient NAS on big datasets. 
\end{abstract}

\section{Introduction}
The trend to seek for state-of-the-art neural network architecture automatically has been growing since \citet{zoph2016neural}, given the enormous effort needed in scientific research. Normally, a Neural Architecture Search (NAS) pipeline comprises architecture sampling, parameter learning, architecture validation, credit assignment and search direction update. 

There are basically three existing frameworks for neural architecture search. Evolution-based NAS like NEAT \citep{stanley2002evolving} employs evolution algorithm to simultaneously optimize topology alongside with parameters. However, it takes enormous computational power and could not leverage the efficient gradient back-propagation in deep learning. To achieve the state-of-the-art performance as human-designed architectures, \citet{real2018regularized} takes 3150 GPU days for the whole evolution. Reinforcement-learning-based NAS is \textit{end-to-end} for gradient back-propagation, among which the most efficient one, ENAS \citep{pham2018efficient} learns optimal parameters and architectures together just like NEAT. However, as NAS is modeled as a Markov Decision Process, credits are assigned to structural decisions with temporal-difference (TD) learning \citep{sutton1998reinforcement}, whose efficiency and interpretability suffer from delayed rewards \citep{arjona2018rudder}. To get rid of the architecture sampling process, DARTS \citep{liu2018darts} proposes deterministic attention on operations to analytically calculate expectation at each layer. After the convergence of the parent network, it removes operations with relatively weak attention. Due to the pervasive non-linearity in neural operations, it introduces untractable bias to the loss function. This bias causes inconsistency between the performance of derived child networks and converged parent networks, thus parameter retraining comes up as necessary. A more efficient, more interpretable and less biased framework is in desire, especially for future full-fledged NAS solutions on large datasets.

In this work, we propose a novel, efficient and highly automated framework, \textit{Stochastic Neural Architecture Search} (SNAS), that trains neural operation parameters and architecture distribution parameters in same round of back propagation, while maintaining the completeness and {\zh differentiability} of the NAS pipeline. One of the key motivations of SNAS is to replace the feedback mechanism triggered by \textit{constant rewards} in reinforcement-learning-based NAS with more efficient gradient feedback from \textit{generic loss}. We reformulate NAS with a new stochastic modeling to bypass the MDP assumption in reinforcement learning. To combine architecture sampling with computational graph of arbitrary differentiable loss, the search space is represented with a set of one-hot random variables from a fully factorizable joint distribution, multiplied as a mask to select operations in the graph. Sampling from this search space is made differentiable by relaxing the architecture distribution with \textit{concrete distribution} \citep{maddison2016concrete}. We name gradients \textit{w.r.t} their parameters \textit{search gradient}. From a global view, we prove that SNAS optimizes the same objective as reinforcement-learning-based NAS, except the training loss is used as reward. Zooming in, we provide a policy gradient equivalent of this \textit{search gradient}, showing how gradients from the loss of each sample {\zh are} used to assign credits to structural decisions. By interpreting this credit assignment as Taylor Decomposition \citep{montavon2017explaining}, we prove SNAS's efficiency over reinforcement-learning-based NAS. Additionally, seeing that existing methods \citep{liu2018darts} manually design topology in child networks to avoid complex architecture, we propose a global resource constraint to automate it, augmenting the objective with feasiblity concerns. This global constraint could be linearly decomposed for structural decisions, hence the proof of SNAS's efficiency still applies.

In our experiments, SNAS shows strong performance compared with DARTS and all other existing NAS methods in terms of test error, model complexity and searching resources. Specifically, SNAS discovers novel convolutional cells achieving 2.850.02\% test error on CIFAR-10 with only 2.8M parameters, which is better than 3.000.14\%-3.3M from 1st-order DARTS and 2.89\%-4.6M from ENAS. It is also on par with 2.760.09\%-3.3M from 2nd-order DARTS with {\zh fewer} parameters. With a more aggressive resource constraint, SNAS discovers even smaller model achieving {\zh 3.100.04\%} test error on CIFAR-10 with 2.3M parameters. During the architecture search process, SNAS obtains a validation accuracy of 88\% compared to around 70\% of ENAS in {\zh fewer} epochs. When validating the derived child network on CIFAR-10 without finetuning, SNAS maintains the search validation accuracy, significantly outperforming 54.66\% by DARTS. These results validate our theory that SNAS is less biased than DARTS. The discovered cell achieves 27.3\% top-1 error when transferred to ImageNet (mobile setting), which is comparable to 26.9\% by 2nd-order DARTS. We have released our implementation at https://github.com/SNAS-Series/SNAS-Series. 

\begin{figure}[h]
  \centering
  \includegraphics[width=13cm]{snas.pdf}
  \caption{A conceptual visualization for a forward pass within SNAS. Sampled from ,  is a matrix whose rows  are one-hot random variable vectors indicating masks multiplied to edges  in the DAG. Columns of this matrix correspond to operations . In this example, there are 4 operation candidates, among which the last one is \textit{zero}, i.e. removing that edge. The objective is the expectation of generic loss  of all \textit{child graphs}.}
  \label{fig:sampling}
\end{figure}

\section{Methodology}
The main initiative of SNAS is to build an efficient and economical \textit{end-to-end} learning system with as little compromise of the NAS pipeline as possible. In this section, we first describe how to sample from the search space for NAS in a cell, and how it motivates a stochastic reformuation for SNAS (Section 2.1). A new optimization objective is provided and the attention-based NAS's inconsistency is discussed. Then in Section 2.2, we introduce how this discrete search space is relaxed to be continuous to let gradients back-propagate through. In Section 2.3, the search gradient of SNAS is connected to the policy gradient in reinforcement-learning-based NAS \citep{zoph2016neural, pham2018efficient}, interpreting SNAS's credit assignment with contribution analysis. At last, we introduce in Section 2.4 how SNAS automates the topology search to reduce the complexity of child netowrk, as well as how it decomposes this global constraint in the context of credit assignment. 

\subsection{Search Space and Architecture Sampling}
Searching for structure of a cell that is later stacked as building blocks for a deep architecture is an \textit{ad hoc} solution to trade-off search efficiency and result optimality \citep{zoph2017learning, liu2017progressive, real2018regularized, pham2018efficient, liu2018darts}. As shown in the left of Figure \ref{fig:sampling}, the search space, \textit{i.e.} a cell, is represented using a directed acyclic graph (DAG), which is called \textit{parent graph}. Nodes  in this DAG represent latent representation{\zh ,} whose dimensions are simply ignored to avoid abuse of notations. In convolutional networks, they are feature maps. Edges  represent information flows and possible operations  to be selected between two nodes  and . To make the skip operation included, nodes are enforced to be ordered, while edges only point from lower indexed nodes to higher ones. Thus we have intermediate nodes

where  is the selected operation at edge . Analog to ENAS, SNAS search for operations and topology of this cell {\zh at} the same time. Rather than using two distributions, this is done by introducing a \textit{zero} operation, as in DARTS. Same as ENAS and DARTS, each cell is designed to have two inputs from the output of previous cells. The output of a cell is the concatenate of intermediate nodes.

Thanks to the fact that the volume of structural decisions, which pick  for edge , is generally tractable in a cell, we represent it with a distribution . Multiplying each one-hot random variable  to each edge  in the DAG, we obtain a \textit{child graph}, whose intermediate nodes are
 

In terms of how to parameterize and factorize , SNAS is built upon the observation that NAS is a task with \textit{fully delayed rewards} in a \textit{deterministic environment}. That is, the feedback signal is only ready after the whole episode is done and all state transition distributions are delta functions. Therefore, a Markov Decision Process assumption as in ENAS may not be necessary. In SNAS, we simply assume that  is fully factorizable, whose factors are parameterized with  and learnt along with operation parameters . In Appendix A we connect the probability of a trajectory in the MDP of ENAS and this joint probability . 

Following the setting in \citet{zoph2016neural}, the objective of SNAS is also

While the difference is that rather than using a constant reward from validation accuracy, we use the training/testing loss directly as reward, , such that the operation parameters and architecture parameters can be trained under one generic loss: 


The whole process of obtaining a Monte Carlo estimate of this objective is shown in Figure \ref{fig:sampling}. An intuitive interpretation of this objective is to \textit{optimize the expected performance of architectures sampled with }. This differentiates SNAS from attention-based NAS like DARTS, which avoids the sampling process by taking analytical expectation at each edge over all operations. In Appendix B we illustrate the inconsistency between DARTS's loss and this objective, explaining its necessity of parameter finetuning or even retraining after architecture derivation. Resembling ENAS, SNAS does not have this constraint. We introduce in next subsection how SNAS calculates gradients \textit{w.r.t}  and . 

\subsection{Parameter Learning for Operations and Architectures}
Though the objective (\ref{eq:objective}) could be optimized with black-box gradient descent method as in \citet{ranganath2014black}, it would suffer from the high variance of likelihood ratio trick \citep{williams1992simple} and could not make use of the differentiable nature of . {\zh Instead}, we use \textit{concrete distribution} \citep{maddison2016concrete} here to relax the discrete architecture distribution to be continuous and differentiable with reparameterization trick:

where  is the softened one-hot random variable for operation selection at edge ,  is the th \textit{Gumbel} random variable,  is a uniform random variable.  is the architecture parameter, which could depend on predecessors  if  is a conditional probability.  is the temperature of the softmax, which is steadily annealed to be close to zero in SNAS. In \citet{maddison2016concrete}, it is proved that , making this relaxation unbiased once converged. 

The full derivation of  is given in Appendix C. Here with the surrogate loss  for each sample, we provide its gradient \textit{w.r.t} ,  and : 


We name  \textit{search gradient} similar {\zh to} the one in \citet{wierstra2008natural}, even though no policy gradient is involved. This renders SNAS a differentiable version of evolutionary-strategy-based NAS.

\subsection{Credit Assignment}
With the equivalence of  in SNAS and  in ENAS from Section 2.1 and the \textit{search gradient} of SNAS from Section 2.2, we discuss in this subsection what credits SNAS \textit{search gradients} assign to each structural decision. 

To assign credits to actions both temporally and laterally is an important topic in reinforcement learning \citep{precup2000eligibility, schulman2015high, tucker2018mirage, xu2018meta}. In ENAS, proximal policy optimization (PPO) \citep{schulman2017proximal} is used to optimize the architecture policy, which distributes credits with TD learning and generalized advantage estimator (GAE) \citep{schulman2015high}. However, as the reward of NAS task is only obtainable after the architecture is finalized and the network is tested for accuracy, it is a task with \textit{delayed rewards}. As proved by \citet{arjona2018rudder}, \textit{TD learning has bias with reward delay and corrects it exponentially slowly}. 

Different from ENAS, there is no MDP assumption in SNAS, but the reward function is made differentiable in terms of structural decisions. From Section 2.2 we can derive the expected \textit{search gradient} for architecture parameters at edge :

where  emphasizes  is constant for the gradient calculation \textit{w.r.t.} . A full derivation is provided in Appendix D. Apparently, the search gradient is equivalent to a policy gradient for distribution at this edge whose credit is assigned as 


From a decision-wise perspective, this reward could be interpreted as contribution analysis of  with Taylor Decomposition \citep{montavon2017explaining}, which distributes importance scores among nodes in the same effective layer. Given the presence of skip connections, nodes may be involved into multiple effective layers, credits from which would be integrated. This integrated credit of a node  is then distributed to edges  pointing to it, weighted by . Details are given in Appendix E. Thus \textit{for each structural decision, no delayed reward exists, the credits assigned to it are valid from the beginning}. This proves why SNAS is more efficient than ENAS. Laterally at each edge, credits are distributed among possible operations, adjusted with random variables . At the beginning of the training,  is continuous and operations share the credit, the training is mainly on neural operation parameters. With the temperature goes down and  becomes closer to one-hot, credits are given to the chosen operations, adjusting their probabilities to be sampled. 

\subsection{Resource Constraint}
Apart from training efficiency and validation accuracy, forwarding time of the child network is another concern in NAS in order for its feasible employment. In SNAS, this could be taken into account as a regularizer in the objective:

where  is the cost of time for the child network associated with random variables . Rather than directly estimating the forwarding time, there are three candidates from the literature \citep{gordon2018morphnet, ma2018shufflenet} that can be used to approximately represent it: 1) the parameter size ; 2) the number of float-point operations (FLOPs); and 3) the memory access cost (MAC). Details about  in SNAS could be found in Appendix F. 

However, not like ,  is not differentiable \textit{w.r.t.} either  or . A natural problem to ask is, whether efficient credit assignment from  could be done with similar decomposition introduced above, such that the proof of SNAS's efficiency still applies. And the answer is positive, thanks to the fact that  is linear in terms of all one-hot random variables : 

mainly because the size of feature maps at each node is not dependent on the structural decision. That is, the distribution at each edge  is optimized with local penalty, which is the conservative decomposition of the global cost, consistent with the credit assignment principle in SNAS. 

In SNAS,  is fully factorizable, making it possible to calculate  analytically with sum-product algorithm \citep{kschischang2001factor}. Unfortunately, this expectation is non-trivial to calculate, we optimize the Monte Carlo estimate of the final form from sum-product algorithm

with policy gradients.



\section{Experiments}

Following the pipeline in DARTS, our experiments consist of three stages. First, SNAS is applied to search for convolutional cells in a small parent network on CIFAR-10 and we choose the best cells based on their search validation accuracy. Then, a larger network is constructed by stacking the learned cells (\textit{child graphs}) and is retrained on CIFAR-10 to compare the performance of SNAS with other state-of-the-art methods. Finally, we show that the cells learned on CIFAR-10 is transferable to large datasets by evaluating their performance on ImageNet.

\subsection{Architecture Search on CIFAR-10}

\paragraph{Motivation}

We apply SNAS to find convolutional cells on CIFAR-10 for image classification. Unlike DARTS, which evaluates the performance of child networks during the searching stage by training their snapshots from scratch, we directly take the search validation accuracy as the performance evaluation criterion. This evaluation method is valid in SNAS since the searching is unbiased from its objective, as introduced in Section 2.1. 

\begin{figure}[h]
  \centering
  \subfigure[]
  {
    \begin{minipage}{0.4\textwidth}
    \centering
    \includegraphics[width=5cm]{normal.pdf}
    \end{minipage}
  }
  \subfigure[]
  {
    \begin{minipage}{0.55\textwidth}
  	\centering
  	\includegraphics[width=8cm]{reduction.pdf}
     \end{minipage}
  }
  \caption{Cells (\textit{child graphs}) SNAS (mild constraint) finds on CIFAR-10. (a) Normal cell. (b) Reduction cell.}
  \label{fig:normal_reduction}
\end{figure}

\paragraph{Dataset}

CIFAR-10 dataset \citep{krizhevsky2009learning} is a basic dataset for image classification, which consists of 50,000 training images and 10,000 testing images. Data transformation is achieved by the standard data pre-processing and augmentation techniques (see Appendix G.1).

\paragraph{Search Space}

Our setup follows DARTS, where convolutional cells (\textit{parent graphs}) of 7 nodes are stacked for multiple times to form a network. The input nodes, \textit{i.e.} the first and second nodes, of cell  are set equal to the outputs of cell  and cell , respectively, with 1  1 convolutions inserted as necessary, and the output node is the depthwise concatenation of all the intermediate nodes. Reduction cells are located at the 1/3 and 2/3 of the total depth of the network to reduce the spatial resolution of feature maps. Therefore the architecture distribution parameters is (), where  is shared by all the normal cells and  is shared by all the reduction cells. Details about all operations included are shown in Appendix G.1.

\paragraph{Training Settings}

In the searching stage, we train a small network stacked by 8 cells (\textit{parent graphs}) using SNAS with three levels of resource constraint for 150 epochs. This network size is determined to fit into a single GPU. Single-level optimization is employed to optimize  and  over the same dataset as opposed to bilevel optimization employed by DARTS. The rest of the setup follows DARTS (Appendix G.1). The search takes 32 hours\footnote{The batch size of SNAS is 64 and that of ENAS is 160.} on a single GPU\footnote{All the experiments were performed using NVIDIA TITAN Xp GPUs}.

\paragraph{Searching Process}

{\tomodify The normal and reduction cells learned on CIFAR-10 using SNAS with mild resource constraint are shown in Figure \ref{fig:normal_reduction}.} In Figure \ref{fig:valid_acc}, we give the validation accuracy during the search of SNAS, DARTS and ENAS with 10 Randomly Generated Seeds. Comparing with ENAS, SNAS takes {\zh fewer} epochs to converge to higher validation accuracy. Though DARTS converges faster than SNAS, this accuracy is inconsistent with the child network. Table \ref{t:search_cifar} presents their comparison of the validation accuracy {\zh at} the end of search and after architecture derivation without fine-tuning. While SNAS can maintain its performance, there is a huge gap between those two in DARTS.
\begin{table}[h]
\caption{Search validation accuracy and child network validation accuracy of SNAS and DARTS. Results marked with * were obtained using the code publicly released by \citet{liu2018darts}.}
\label{t:search_cifar}
\begin{center}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\resizebox{\textwidth}{!}{
\begin{tabular}{lccc}
\multicolumn{1}{c}{\bf Architecture}  &\multicolumn{1}{c}{\tabincell{c}{\bf Search Valid.\\\bf Acc (\%)}}  &\multicolumn{1}{c}{\tabincell{c}{\bf Child Net\\\bf Valid. Acc (\%)}} &\multicolumn{1}{c}{\tabincell{c}{\bf Search Cost\\%)}}  &\multicolumn{1}{c}{\tabincell{c}{\bf Params\GPU days)}} &\multicolumn{1}{c}{\bf Search Method} &\multicolumn{1}{c}{\tabincell{c}{\bf NAS Pipeline\\ \bf Completeness}}
\\ \hline \vspace{-0.2cm}\\
DenseNet-BC \citep{huang2017densely}  &3.46    &25.6   &-   &manual   &-
\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
NASNet-A + cutout \citep{zoph2017learning}  &2.65 	&3.3   &1800    &RL &complete\\
AmoebaNet-A + cutout \citep{real2018regularized}    &3.34  0.06 &3.2   &3150  &evolution &complete\\
AmoebaNet-B + cutout \citep{real2018regularized}   &2.55  0.05  &2.8 &3150 &evolution &complete\\
Hierarchical Evo \citep{liu2017hierarchical}   &3.75  0.12  &15.7 &300 &evolution &complete\\
PNAS \citep{liu2017progressive}   &3.41  0.09   &3.2     &225   &SMBO &complete\\
ENAS + cutout \citep{pham2018efficient}   &2.89     &4.6   &0.5    &RL &complete\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
Random search baselineâ€¡ + cutout \citep{liu2018darts}	&3.29  0.15 	&3.2 	&1 	&random 	&-\\
DARTS (1st order bi-level) + cutout \citep{liu2018darts}   & 3.00  0.14  &3.3   &0.4  &gradient-based &incomplete\\
DARTS (2nd order bi-level) + cutout \citep{liu2018darts}   & 2.76  0.09   &3.3   &1  &gradient-based &incomplete\\
DARTS (single-level) + cutout \citep{liu2018darts}      & 3.56  0.10   &3.0   &0.3  &gradient-based &incomplete
\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
SNAS (single-level) + mild constraint + cutout   &2.98    &2.9     &1.5  &gradient-based &complete \\
SNAS (single-level) + moderate constraint + cutout   &2.85  0.02    &2.8  &1.5  &gradient-based &complete \\
SNAS (single-level) + aggressive constraint + cutout  &{\zh 3.10  0.04}    &2.3      &1.5  &gradient-based &complete
\vspace{0.1cm}
\\ \hline
\vspace{-0.5cm}
\end{tabular}}
\end{center}
\end{table}


\paragraph{Results}

The CIFAR-10 evaluation results are presented in Table \ref{t:eval_cifar}. The test error of SNAS is on par with the state-of-the-art RL-based and evolution-based NAS while using three orders of magnitude less computation resources. Furthermore, with slightly longer wall-clock-time, SNAS outperforms 1st-order DARTS and ENAS by discovering convolutional cells with both a smaller error rate and {\zh fewer} parameters. It also achieves a comparable error rate compared to 2nd-order DARTS but with {\zh fewer} parameters. With a more aggressive resource constraint, SNAS can sparsify the {\zh architecture} even further to distinguish from ENAS and DARTS with only a slight drop in performance, which is still on par with 1st-order DARTS. It is interesting to note that with same single-level optimization, SNAS significantly outperforms DARTS. Bilevel optimization could be regarded as a data-driven meta-learning method to resolve the bias proved above, whose bias from the exact meta-learning objective is still unjustified due to the ignorance of separate child network derivation scheme.

\subsection{Architecture Transferability Evaluation on ImageNet}

\paragraph{Motivation}

Since real world applications often involve much larger datasets than CIFAR-10, transferability is a crucial criterion to evaluate the potential of the learned cells (\textit{child graphs}) \citep{zoph2017learning}. To show whether the cells learned on by SNAS CIFAR-10 can be generalized to larger datasets, we apply the same cells evaluated in Section 3.2 to the classification task on ImageNet.

\paragraph{Dataset}

The \textit{mobile} setting is adopted where the size of the input images is  and the number of multiply-add operations in the model is restricted to be less than 600M.

\paragraph{Evaluation Settings}

We stack a network of 14 cells using the same cells designed by SNAS (mild constraint) and evaluated on CIFAR-10 (Section 3.2) and train it for {\zh 250} epochs with other hyperparameters following DARTS (see Appendix G.3). The training takes 12 days on a single GPU.

\begin{table}[t]
\caption{Classification errors of SNAS and state-of-the-art image classifiers on ImageNet.}
\label{t:eval_imagenet}
\begin{center}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\resizebox{\textwidth}{!}{
\begin{tabular}{lcccccll}
\multicolumn{1}{c}{\bf Architecture}  &\multicolumn{2}{c}{\tabincell{c}{\bf Test Error (\%) \\ \hline top-1 \quad top-5}}  &\multicolumn{1}{c}{\tabincell{c}{\bf Params\GPU days)}} &\multicolumn{1}{c}{\bf Search Method}    &\multicolumn{1}{c}{\tabincell{c}{\bf NAS Pipeline\\ \bf Completeness}}
\\ \hline \vspace{-0.2cm}\\
Inception-v1 \citep{szegedy2015going}  &30.2  &10.1  &6.6   &1448  &-   &manual   &-\\
MobileNet \citep{howard2017mobilenets}  &29.4  &10.5  &4.2   &569  &-   &manual &-\\
ShuffleNet 2 (v1) \citep{zhang1707shufflenet}  &26.4  &10.2  &5   &524  &-   &manual &-\\
ShuffleNet 2 (v2) \citep{ma2018shufflenet}  &25.1  &10.1  &5   &591  &-   &manual &-
\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
NASNet-A \citep{zoph2017learning}  &26.0 &8.4 &5.3   & 564 &1800    &RL &complete\\
NASNet-B \citep{zoph2017learning}  &27.2 &8.7 &5.3   & 488 &1800    &RL &complete\\
NASNet-C \citep{zoph2017learning}  &27.5 &9.0 &4.9   & 558 &1800    &RL &complete\\
AmoebaNet-A \citep{real2018regularized}   &25.5 &8.0 &5.1  &555 &3150  &evolution &complete\\
AmoebaNet-B \citep{real2018regularized}   &26.0 &8.5 &5.3  &555 &3150 &evolution &complete\\
AmoebaNet-C \citep{real2018regularized}   &24.3 &7.6 &6.4  &570 &3150 &evolution &complete\\
PNAS \citep{liu2017progressive}   &25.8  &8.1  &5.1 &588  &225   &SMBO &complete
\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
DARTS \citep{liu2018darts}   &26.9 &9.0  &4.9  &595   &1  &gradient-based  &incomplete
\vspace{0.1cm}
\\ \hline \vspace{-0.2cm}\\
SNAS (mild constraint)   &27.3  &9.2  &4.3     &522     &1.5  &gradient-based   &complete
\vspace{0.1cm}
\\ \hline
\vspace{-0.5cm}
\end{tabular}}
\end{center}
\end{table}

\paragraph{Results}

Table \ref{t:eval_imagenet} presents the results of the evaluation on ImageNet and shows that the cell found by SNAS on CIFAR-10 can be successfully transferred to ImageNet. Notably, SNAS is able to achieve competitive test error with the state-of-the-art RL-based NAS using three orders of magnitude less computation resources. And with resource constraints added, SNAS can find smaller cell architectures that achieve competitive performance with DARTS.

\section{Related works}
Improving the efficiency of NAS is a prerequisite to {\zh extending} it to more complicated vision tasks like detection, as well as larger datasets. In the complete pipeline of NAS, parameter learning is a time-consuming one that attracts attention from the literature. Ideas to design auxiliary mechanisms like performance prediction \citep{baker2017accelerating, deng2017peephole}, iterative search \citep{liu2017progressive}, hypernetwork generated weights \citep{brock2017smash} successfully accelerate NAS to certain degrees. Getting rid of these auxiliary mechanism{\zh s}, ENAS \citep{pham2018efficient} is the state-of-the-art NAS framework, proposing parameter sharing among all possible \textit{child graphs}, which is followed by SNAS. In Section 2 we introduced SNAS's relation with ENAS in details. Apart {\zh from} ENAS, we are also inspired by \citet{louizos2017learning} to use continuous distribution for structural decision at each edge and optimize it along with an  complexity regularizer.

The most important motivation of SNAS is to leverage the gradient information in generic differentiable loss to update architecture distribution, which is shared by DARTS \citep{liu2018darts}. In Section 2 and Appendix B we have introduced SNAS's advantage over DARTS, a reward for maintaining the completeness of the NAS pipeline. Actually, the idea to make use of this gradient information to improve the learning efficiency of a stochastic model has been discussed in the literature of generative model \citep{gu2015muprop,maddison2016concrete} and reinforcement learning \citep{schmidhuber1990making, arjona2018rudder}. But as far as we known, we are the first one to combine the insights from these two fields to discuss possible efficiency improvement of NAS. 

\section{Conclusion}
In this work, we presented SNAS, a novel and economical \textit{end-to-end} neural architecture search framework. The key contribution of SNAS is that by making use of gradient information from generic differentiable loss without sacrificing the completeness of NAS pipeline, stochastic architecture search could be more efficient. This improvement is proved by comparing the credit assigned by the \textit{search gradient} with reinforcement-learning-based NAS. Augmented by a complexity regularizer, this \textit{search gradient} trades off testing error and forwarding time. Experiments showed that SNAS searches well on CIFAR-10, whose result could be transferred to ImageNet as well. As a more efficient and less-biased framework, SNAS will serve as a possible candidate for full-fledged NAS on large datasets in the future. 

\bibliography{iclr2019_conference}
\bibliographystyle{iclr2019_conference}

\appendix
\section{connecting  in snas and  in enas}
In ENAS, the NAS task is defined as an MDP, where the observation . Thus the transition probability 

With the policy of RNN controller denoted as , the joint probability of a trajectory  in this MDP is

where  is a vector of all structural decisions, which is denoted as  in SNAS. So we have

Note that if we factorize  with conditional probability to have Markovian property as in Equation \ref{eq:tau}, we have the factor 


\section{difference between snas and darts}
We take a search space with three intermediate nodes for example to exhibit the difference between SNAS and DARTS \citep{liu2018darts}, as shown in Figure \ref{fig:snas_vs_darts}. This search space could be viewed as a unit search space whose property could be generalized to larger space since it contains nodes in series and in parallel. 

The objective of a NAS task is 

where  is the distribution of {\zh architectures}, which is previously solved with reinforcement learning. In both SNAS and DARTS, the reward function is made differentiable using the training/testing loss, , such that the {\zh architecture} learning could leverage information in the gradients of this loss and conduct together with operation parameters training:

As introduced in Appendix A, SNAS solves (\ref{eq:objappx}) with a novel type of factorization, without relying on the MDP assumption. Though independent assumption between edges would restrict the probability distribution, there is no bias introduced. 

However, to avoid the sampling process and gradient back-propagation through discrete random variables, DARTS takes analytical expectation at the input of each node over operations at incoming edges and optimizes a relaxed loss with deterministic gradients. Take the cell in Figure \ref{fig:snas_vs_darts} as a base case, the objective before this relaxation is

DARTS relaxed this objective to 

{\zh Considering} that  are \textit{ReLU-Conv-BN} stacks as in ENAS \citep{pham2018efficient}, which are non-linear, this transformation introduces unbounded bias. Though it will not be perceivable in training, where the complete graph is used for accuracy validation, consistent this loss, the derived graph is never validated during training. Hence the training is inconsistent with the true objective \textit{maximizing the expected {\zh performance} of derived {\zh architectures}}. After an {\zh architecture} derivation introduced in DARTS, the performance falls enormously and the parameters need to be retrained.

\begin{figure}[h]
  \centering
  \includegraphics[width=13cm]{gradients.png}
  \caption{A comparison for gradients in DARTS and SNAS. (a) Deterministic gradients in DARTS; (b) Stochastic gradients in SNAS. Solid lines denote deterministic nodes, while dashed lines denote stochastic nodes. Black {\zh dotted} lines denote compounded gradients, purple lines for parameter gradients in SNAS, red for \textit{search gradients}. }
  \label{fig:snas_vs_darts}
\end{figure}

\section{gradients in snas}
Figure \ref{fig:snas_vs_darts}(b) gives an illustration of a base three-intermediate-node unit in SNAS, where each edge has three operations (indexed by ) to choose from. In the search space of SNAS, intermediate nodes take input from all previous nodes. We have 

Let  be the parameters in , we have 


As we use \textit{concrete disctribution} here to make the sampling differentiable with reparametrization trick:

where  is the th \textit{Gumbel} random variable,  is a uniform random variable, the gradient \textit{w.r.t.}  is:

The partial derivative  is

Substitute it back to (\ref{eq:searchgrad}), we obtain

We can also derive  for chain rule connection:

Thus the gradient from the surrogate loss  to ,  and  respectively are






\section{credit assignment for equivalent policy gradient}
From Appendix C we can see that the expected \textit{search gradient} for architecture parameters at each edge is:

where  denotes  is a constant for the gradient calculation \textit{w.r.t.} . Note that in this derivation we stop the gradient from successor nodes, with an independence assumption enforced in back-propagation. 

\section{taylor decomposition for {\zh contribution} analysis}
With  neurons (pixels)  in the same layer of a deep neural network, whose output is , \citet{montavon2017explaining} decomposes  as a sum of individual credits for . This decomposition is obtained by the first-order Taylor expansion of the function at some root point  for which : 

where the individual credits

are first-order terms and  is for higher-order information. When ReLU is chosen as the activation function,  can be omitted \citep{montavon2017methods}. Thus ones can always find a root point  that incidentally lies on the same linear region as point , in which case the function can be written as


Noticing the similarity between (\ref{eq:reward}) and (\ref{eq:taylor}), we try using Taylor Decomposition to interpret the credit assignment in SNAS. Given a sample , ones can iterate all effective layers of the DAG and distribute credits from network output  among nodes  in each layer. In Figure \ref{fig:sampling} for example,  has 2 effective layers, while  has 3 effective layers. Given the presence of the skip connection, nodes may be involved into multiple layers and thus obtain integrated credits
 
\textit{e.g.}  in DAG(2) integrates credits from  and . According to (\ref{eq:operation}), {\zh multiple} edges  are pointing to , which decompose (\ref{eq:nodecredit}) as:

Adjusting the weight of this sample with  and taking the optimization direction into account, we have


\section{candidates for local resource constraints}

In the case of a convolutional layer, ,  and ,  correspond to the output spatial dimensions and the filter dimensions respectively and we use ,  to denote the number of input and output channels. Since group convolution is also adopted in this paper to reduce the computational complexity,  is the number of groups.

Thus, the parameter size and the number of float-point operations (FLOPs) of a single convolutional layer is




By assuming the computing device has enough cache to store the feature maps and the parameters, we can simplify the memory access cost (MAC) to be the sum of the memory access for the input/output feature maps and kernel weights \citep{ma2018shufflenet}.


In SNAS, because all the operations on a single edge share the same output spatial dimensions and the input/output channels, FLOPs of a convolutional operation is directly proportional to its parameter size. And although the memory access cost for the input/output feature maps  does not depend on the parameter size, since both are positively correlated to the number of layers used in the operation, we may say there is a positive correlation between MAC and the parameter size. Thus, when only considering the convolution operations, solely using the parameter size as the resource constraint is sufficient. However, in SNAS, we also have the pooling operation and the skip connection, which are parameter free. The equations to calculate the resource criteria of a pooling operation or a skip connection are as follows.

FLOPs of pooling:


FLOPs of skip connection:


MAC of pooling and skip connection:


We can see that MAC is the same for pooling and skip connection since they need to access the same input/output feature maps, therefore, to distinguish between pooling and skip connection, FLOPs need to be included in the resource constraint. Similarly, to distinguish between skip connection and none (free, no operation), MAC also need to be included.

In conclusion, to construct a resource constraint which fully distinguishes the four types of operations, all three locally decomposable criteria, the parameter size, FLOPs and MAC, need to be combined.

\section{detailed settings of experiments}

\subsection{architecture search on CIFAR-10}

\paragraph{Data Pre-processing and Augmentation Techniques}

We employ the following techniques in our experiments: centrally padding the training images to  and then randomly cropping them back to ; randomly flipping the training images horizontally; normalizing the training and validation images by subtracting the channel mean and dividing by the channel standard deviation.

\paragraph{Implementation Details of Operations}

The operations include: 3  3 and 5  5 separable convolutions, 3  3 and 5  5 dilated separable convolutions, 3  3 max pooling, 3  3 average pooling, skip connection and \textit{zero} operation. All operations are of stride one (excluded the ones adjacent to the input nodes in the reduction cell, which are of stride two) and the convolved feature maps are padded to preserve their spatial resolution. Convolutions are applied in the order of ReLU-Conv-BN, and the depthwise separable convolution is always applied twice \citep{zoph2017learning, real2018regularized, liu2017progressive, liu2018darts}.

\paragraph{Detailed Training Settings}

We follow the training settings as in \citet{liu2018darts}. The neural operation parameters  are optimized using momentum SGD, with initial learning rate  (annealed down to zero following a cosine schedule), momentum 0.9, and weight decay . The architecture distribution parameters  are optimized by Adam, with initial learning rate , momentum  and weight decay . The batch size employed is 64 and the initial number of channels is 16.

\subsection{architecture evaluation on CIFAR-10}

\paragraph{Additional Enhancement Techniques}

Following existing works \citep{zoph2017learning, liu2017progressive, pham2018efficient, real2018regularized, liu2018darts}, we employ the following additional enhancements: cutout \citep{devries2017improved}, path dropout of probability 0.2 (same as DARTS in the code publicly released by its authors) and auxiliary towers with weight 0.4.

\subsection{architecture transferability evaluation on CIFAR-10}

\paragraph{Detailed Training Settings}

The network is trained with batch size 128, weight decay  and initial SGD learning rate 0.1, which is decayed by a factor of 0.97 after each epoch. Auxiliary towers with weight 0.4 are adopted as additional enhancements.

\section{cells learned by SNAS with a moderate resource constraint}

\begin{figure}[h]
  \centering
  \subfigure[]
  {
    \begin{minipage}{0.4\textwidth}
    \centering
    \includegraphics[width=5cm]{normal_moderate.pdf}
    \end{minipage}
  }
  \subfigure[]
  {
    \begin{minipage}{0.4\textwidth}
  	\centering
  	\includegraphics[width=5cm]{reduction_moderate.pdf}
     \end{minipage}
  }
  \caption{Cells (\textit{child graphs}) SNAS (moderate constraint) finds on CIFAR-10. (a) Normal cell. (b) Reduction cell.}
  \label{fig:normal_reduction_moderate}
\end{figure}

\end{document}
