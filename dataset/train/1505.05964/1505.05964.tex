\RequirePackage{fix-cm}
\documentclass[smallcondensed]{svjour3}     

\makeatletter
\def\makeheadbox{{\hbox to0pt{\vbox{\baselineskip=10dd\hrule\hbox
to\hsize{\vrule\kern3pt\vbox{\kern3pt
\hbox{\bfseries\@journalname\ 2015}
\hbox{DOI 10.1007/s00236-015-0221-6 }
\kern3pt}\hfil\kern3pt\vrule}\hrule}\hss}}}
\makeatother


\smartqed  \usepackage{graphicx}
\usepackage{xspace}
\usepackage{hyperref,breakurl}
\usepackage{amsmath,amsfonts,amssymb}
\DeclareSymbolFont{frenchscript}{OMS}{ztmcm}{m}{n}
\DeclareMathSymbol{\A}{\mathord}{frenchscript}{65}   \DeclareMathSymbol{\B}{\mathord}{frenchscript}{66}   \DeclareMathSymbol{\FS}{\mathord}{frenchscript}{70}  \DeclareMathSymbol{\HC}{\mathord}{frenchscript}{72} \DeclareMathSymbol{\K}{\mathord}{frenchscript}{75}   \DeclareMathSymbol{\OA}{\mathord}{frenchscript}{79}  \DeclareMathSymbol{\pow}{\mathord}{frenchscript}{80} \newcommand{\denote}[1]{[\hspace{-1.4pt}[#1]\hspace{-1.4pt}]}  \newcommand{\NN}{\ensuremath{\mathop{\rm I\mkern-2.5mu N}\nolimits }}
\newcommand{\T}{{\rm T}}                             \newcommand{\SC}{{\rm G}}                            \newcommand{\E}{P}                                   \newcommand{\F}{Q}                                   \newcommand{\G}{\cal G}
\newcommand{\AI}{A}                                  \newcommand{\dom}{{\it dom}}                         \makeatletter
\def\moverlay{\mathpalette\mov@rlay}
\def\mov@rlay#1#2{\leavevmode\vtop{\baselineskip\z@skip \lineskiplimit-\maxdimen
   \ialign{\hfil\hfil\cr#2\crcr}}}
\newcommand{\charfusion}[3][\mathord]{
    #1{\ifx#1\mathop\vphantom{#2}\fi
        \mathpalette\mov@rlay{#2\cr#3}
      }
    \ifx#1\mathop\expandafter\displaylimits\fi}
\makeatother
\newcommand{\dcup}{\charfusion[\mathbin]{\cup}{\mbox{\Large}}}



\newcommand{\plat}[1]{\raisebox{0pt}[0pt][0pt]{#1}}  \def\precond#1{{\vphantom{#1}}^\bullet #1}
\def\postcond#1{{#1}^\bullet}
\newcommand{\monus}{\mathrel{\raisebox{-0pt}[0pt][0pt]{\cdot-}}}
\makeatletter
\spn@wtheorem{observation}{Observation}{\bfseries}{\rmfamily}
\makeatother
\providecommand{\urlalt}[2]{\href{#1}{#2}}
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}
\makeatletter
\def\comesfrom{\@transition\leftarrowfill}
\def\goesto{\@transition\rightarrowfill}
\def\ngoesto{\@transition\nrightarrowfill}
\def\Goesto{\@transition\Rightarrowfill}
\def\nGoesto{\@transition\nRightarrowfill}
\def\xmapsto{\@transition\mapstofill}
\def\nxmapsto{\@transition\nmapstofill}
\def\@transition#1{\@@transition{#1}}
\newbox\@transbox
\newbox\@arrowbox
\newbox\@downbox
\def\@@transition#1#2{\setbox\@transbox\hbox
      {\vrule height 1.5ex depth .9ex width 0ex\hskip0.25em\hskip0.25em}
   \ifdim\wd\@transbox<1.5em
      \setbox\@transbox\hbox to 1.5em{\hfil\box\@transbox\hfil}\fi
   \setbox\@arrowbox\hbox to \wd\@transbox{#1}
   \ht\@arrowbox\z@\dp\@arrowbox\z@
   \setbox\@transbox\hbox{}
   \dp\@transbox\z@\ht\@transbox 10pt
   \mathrel{\box\@transbox}}
\def\nrightarrowfill{\mkern-2mu\mathord-\mkern-2mu}
\def\Rightarrowfill{\mkern-2mu\mathord=\mkern-2mu}
\def\nRightarrowfill{\mkern-2mu\mathord=\mkern-2mu}
\def\mapstofill{\mkern-2mu\mathord-\mkern-2mu}
\def\nmapstofill{\mkern-2mu\mathord-\mkern-2mu}
\makeatother \newcommand{\ar}[1]{\mathrel{\goesto{#1}}}            \newcommand{\nar}[1]{\mathrel{\ngoesto{#1\;}}}        \newcommand{\dar}[1]{\mathrel{\Goesto{\raisebox{.08em}{\scriptsize}}}}
\newcommand{\Thm}[1]{Theorem~\ref{thm:#1}}
\newcommand{\Cor}[1]{Corollary~\ref{cor:#1}}
\newcommand{\Prop}[1]{Proposition~\ref{prop:#1}}
\newcommand{\Lem}[1]{Lemma~\ref{lem:#1}}
\newcommand{\Def}[1]{Definition~\ref{df:#1}}
\newcommand{\Ex}[1]{Example~\ref{ex:#1}}
\newcommand{\Rem}[1]{Remark~\ref{rem:#1}}
\newcommand{\Part}[1]{Part {\ref{part:#1}}}
\newcommand{\Sect}[1]{Section~\ref{sec:#1}}
\newcommand{\SSect}[1]{Section~\ref{ssec:#1}}
\newcommand{\SSSect}[1]{Section~\ref{sssec:#1}}
\newcommand{\Pro}[1]{Pro.~\ref{pro:#1}}
\newcommand{\Fig}[1]{Figure~\ref{fig:#1}}
\newcommand{\Tab}[1]{Table~\ref{tab:#1}}
\newcommand{\Eq}[1]{\eqref{eq:#1}}
\newcommand{\mylabel}[1]{\hypertarget{lab:#1}{\ \mbox{{\scriptsize\sc (#1)}}}}
\newcommand{\myref}[1]{\hyperlink{lab:#1}{\sc (#1)}\xspace}
\vfuzz.4pt \newcommand{\skipped}[1]{}
\renewcommand{\inf}{^{\omega}}
\newcommand{\mand}{\&\xspace}



\makeatletter
\newcounter {part}
\renewcommand\thepart{\@Roman\c@part}
\def\part#1#2{\vspace{6ex}
\noindent {\Large\bf\boldmath Part \refstepcounter{part}\thepart\ \ \ #1\label{part:#2}}

\vspace{-3.5ex}
}

\makeatother

\newcounter{Hequation}
\renewcommand{\theHequation}{\arabic{Hequation}}
\makeatletter
\g@addto@macro\equation{\stepcounter{Hequation}}
\makeatother


\journalname{Acta Informatica}
\begin{document}

\title{CCS: It's not Fair!\thanks{NICTA is funded by the Australian Government through the
    Department of Communications and the Australian Research Council
    through the ICT Centre of Excellence Program.
}
}
\subtitle{Fair Schedulers cannot be implemented in CCS-like languages even under progress and certain fairness assumptions}

\author{
    Rob van Glabbeek \and 
    Peter H\"ofner
}

\institute{
    R.\,J.\ van Glabbeek \at
	    NICTA and UNSW.
        \email{rvg@cs.stanford.edu} \and
    P.\ H\"ofner \at
	    NICTA and UNSW.
	\email{Peter.Hoefner@nicta.com.au}
}

\date{~}



\maketitle

\begin{quote}\it
It is our great pleasure to dedicate this paper to Walter Vogler on the occasion of his 60th birthday.
We have combined two of Walter's main interests: Petri nets and process algebra. 
In fact, we proved a result about Petri nets that had been proven before by Walter, but in a restricted form, 
as we discovered only after finishing our proof. 
We also transfer this result to the process algebra CCS.
Beyond foundational research in the theory of concurrent systems, Walter achieved excellent results in related subjects such 
as temporal logic and efficiency.
In addition to being a dedicated researcher, he is also 
meticulous in all of his endeavours, including his writing.
As a consequence his scientific papers tend to contain no flaws,
which is just one of the reasons that makes reading them so enjoyable.

It's fair to say: ``CCS Walter!''---Congratulations and Continuous Success!

\end{quote}

\begin{abstract}
In the process algebra community it is sometimes suggested that,
on some level of abstraction, any distributed system can be
modelled in standard process-algebraic specification formalisms like CCS\@.
This sentiment is strengthened by results testifying that CCS,
like many similar formalisms, is Turing powerful and provides a mechanism for 
interaction.
This paper counters that sentiment by presenting a simple fair
scheduler---one that in suitable variations occurs in many
distributed systems---of which no implementation can be
expressed in CCS, unless CCS is enriched with a fairness assumption.

Since  Dekker's and Peterson's mutual exclusion protocols implement fair schedulers,
it follows that these protocols cannot be rendered correctly in CCS
without imposing a fairness assumption. Peterson expressed this algorithm correctly in pseudocode
without resorting to a fairness assumption, so it furthermore follows that  CCS lacks the expressive
power to accurately capture such pseudocode.
\end{abstract}

\part{Motivation \& Discussion}{one}
\section{Background}

In the process algebra community it is
generally taken for granted
that, on some level of abstraction, any distributed system can be
modelled in standard process-algebraic specification formalisms like CCS~\cite{Mi89}.

Of course, if a distributed system has features related to time, probability, broadcast communication
or anything else that is not innately modelled in CCS, yet essential to adequately describe the
distributed system under consideration, appropriate extensions are needed,
such as timed process algebras (e.g., \cite{ReedRoscoe86,HennessyRegan95,BB96,LV01,CVJ02}),
probabilistic process algebras (e.g., \cite{HJ90})
or calculi for broadcast communication (e.g., \cite{CBS}).
This paper is not concerned with such features.

The relative expressiveness of process algebras is a well-studied subject \cite{Va93,Parrow08,Gorla10a},
 and in this area CCS-like process algebras are considered far from universally expressive.
In \cite{vG12} for instance it is pointed out that the parallel composition operator of CSP \cite{BHR84,Ho85} cannot
be expressed in CCS\@.
The priority operator of \cite{BBK87b}
is a good example of an
operator that cannot be expressed in any of the standard process algebras such as CCS, CSP, ACP~\cite{BK86} or LOTOS \cite{BB87}.
These results focus, however, on the possibility of expressing \emph{operators}---composing a process out of
one or more components---as CCS-contexts; they cast no doubt on the possibility of expressing actual
processes in CCS\@.

Beside operators, it has also be shown that there exist examples of process \emph{specifications} that cannot be faithfully rendered in
CCS-like formalisms (cf.~\cite{vG05d}). We will illustrate this in \SSect{spec vs implementation}. In
this paper we distinguish process specifications from actual processes that could in principle be implemented and executed.
Again, the evidence presented casts no doubt on the possibility of expressing actual processes in CCS\@.


Incorporating these clarifications of our meaning, we expect that many concurrency experts feel that,
up to an adequate level of abstraction, any reactive system can be rendered in CCS\@.
This sentiment is strengthened by results testifying that CCS,
like many similar formalisms, is Turing powerful~\cite{Mi89}.
As a manifestation of this, any computable partial function  over some
finite alphabet  can be modelled by a CCS context , such that,
for any input word , encoded as a CCS expression
 featuring an end-of-input marker , the process  computes
forever without performing any visible actions if  is undefined, and otherwise performs the
sequence of visible actions , followed by an end-of-output marker .

It is sometimes argued that Turing machines are an inadequate formalism to capture interactive
behaviour as displayed by today's computers~\cite{Wegner97,LW01}.
The main
argument is that Turing machines are function-based and 
calculate, for a given finite input, one output;
this paradigm does not do justice to the ongoing interactions between a reactive system and its
environment.
To add ongoing interactivity to Turing machines, \emph{interaction machines} are proposed in
\cite{Wegner97}, and formalised in \cite{GSAS04} as \emph{persistent Turing machines}. Likewise,
\cite{BLT11} proposes \emph{reactive Turing machines}.
Since standard process algebras like CCS are already equipped with interaction primitives,
they can surely also model computations on persistent or reactive Turing machines.
All this strengthens the feeling
that standard process algebras, such as CCS,
are powerful enough to specify any distributed system.

\section{Fairness Assumptions}{\label{sec:fairness}}


Before presenting evidence that CCS and related formalisms cannot correctly specify every distributed system,
some explanation is in order on our understanding of `correctly'. This is best illustrated by an example.
\advance\textheight 1pt

Consider the CCS agent identifier  with defining equation \plat{}.
The question is whether this is a good rendering of a process that is guaranteed to eventually
perform the action . The answer depends on whether we incorporate a fairness assumption in the
semantics of CCS\@. A \emph{strong fairness} assumption requires that if a task (here ) is enabled
infinitely often, but allowing interruptions during which it is not enabled, it will eventually be
scheduled \cite{GPSS80,LPS81}.
Making such an assumption allows us to infer that indeed the process  will eventually do a .\footnote{In \cite{BBK87a} a form of reasoning using a particularly strong global fairness assumption
was integrated in the axiomatic framework of ACP, and shown to be compatible with the notion of
weak bisimulation commonly taken as the semantic basis for CCS\@.}

\advance\textheight -1pt
It depends on the context of the application of CCS whether it is appropriate to make such fairness assumptions.
For the verification of the alternating bit protocol, for instance, fairness assumptions are
indispensable \cite{BergstraKlop85}. But in some situations they allow us to reach conclusions that are
patently false. In the example above for instance, let  be an unsuccessful attempt to dial a
number or an unreliable mobile phone, and  a successful one. The system  simply
retries after each unsuccessful attempt. Whether it ever succeeds in performing  depends very
much on how unreliable the phone is. If there is a fixed positive probability on success,
the strong fairness assumption appears warranted. Yet, if the phone is completely dead, it is not,
and the conclusion that we eventually succeed in dialling is false.
In fact, when assuming strong fairness we loose the expressiveness to describe by a finite
recursive specification like  a system such as the above interaction with the unreliable 
telephone that \emph{does} allow an infinite run with only s.

As evidence that not every distributed system can be rendered correctly in CCS, we will describe a
\emph{fair scheduler} as a counterexample. Yet, our fair scheduler can be rendered in CCS very
easily, if only we are willing to postulate a fairness property to support its correctness.
However, considering the above example and the fact that we 
may reach wrong conclusions, this is a price we are not willing to pay.

Our fair scheduler is not merely an `artificial' CCS specification; it is implemented in many working distributed systems, and (unlike the alternating bit
protocol) its correctness should not be contingent on any fairness assumption whatsoever.
This is another reason why we do not want to invoke fairness to achieve a correct rendering in CCS\@.

Yet, we do find it reasonable to equip CCS with two assumptions that are weaker than strong fairness,
namely \emph{progress} and \emph{justness}. A progress assumption is what is needed to infer that
the CCS process  will eventually do a , and a justness assumption allows us to infer that
the parallel composition  with \plat{} will eventually do a .
If our task is to specify in CCS a process  that will eventually do a ,
then, when assuming strong fairness,
the processes~,   and  are acceptable implementations of .
If we assume justness, but not fairness, this selection shrinks to  and , and if we only
assume progress, we have to give up on  as well. When not even assuming progress, 
cannot be rendered in CCS at all.
Assuming progress and justness only,  models a process that will
eventually do a , whereas  can be used to characterise the above mentioned interaction with the unreliable telephone,
which allows an infinite sequence of s only.

So, when we claim that a fair scheduler cannot be implemented in CCS, we mean that it
cannot be implemented in CCS+justness, CCS+progress or CCS without any progress assumption.
It can be implemented in CCS+strong fairness, however. 

To pinpoint the borderline, 
consider a \emph{weak fairness} or \emph{justice} assumption~\cite{GPSS80,LPS81}. This assumption
requires that if a task, from some point onwards, is
perpetually enabled, it will eventually be scheduled. What this means depends on our interpretation
of `perpetual'. If `perpetual' simply means `in each state', then a weak fairness assumption
is all that is needed to assure that the process  will eventually do a .\footnote{The process
   with {\plat{}} on the other hand really needs
  strong fairness.} A weak fairness assumption in this
sense is enough to correctly render a fair scheduler in CCS\@. If, on the other hand, the execution
of the -transition of  counts as a (short) interruption of the enabledness of , then
justice can be shown to coincide with justness \cite{GH14}; as we will show,
this is not enough to render a fair scheduler in CCS\@.

\section{Specifications versus Actual Processes}\label{ssec:spec vs implementation}


Consider the system specification  expressed in\vspace{2pt}
CCS as  with \plat{} and \plat{},
but with the added requirement that all infinite executions should have infinitely many occurrences
of  as well as . Here  and  could be seen as two tasks that need to be scheduled again
and again. The left-hand component  of the parallel composition tries to perform task 
infinitely often, and the right-hand component tries to perform task  infinitely often.
The process  by itself, as specified in CCS,\vspace{2pt} is normally deemed equivalent to the process ,
defined by \plat{}, and---in the absence of a justness or
fairness assumption---offers no guarantee that a single 
will ever happen. It could be that, due to unfortunate scheduling, at each time a choice is made, task 
is chosen. The challenge in specifying the fair version  of this process in CCS is 
how to ensure that sooner or later a  will happen, without simply invoking a fairness or justness
assumption, and without setting any fixed limit on the number of s that can happen beforehand.

Accordingly, solutions have appeared in the literature that change the operational semantics of CCS
in such a way that  will surely do a  eventually. In~\cite{Plotkin82} for instance,
parallel operators  are used that, each time a  occurs, nondeterministically select a
number  and guarantee that from that point onwards at most  occurrences of  happen
before the next . Another solution along these lines is proposed in \cite{CS84}, whereas
\cite{CBV06} solves the problem by harvesting the power added by the treatment of time in the timed
process algebra PAFAS \cite{CVJ02}.

In relation to the above challenge it would be trivial to specify \emph{some} process that makes
sure that tasks  and  are each scheduled infinitely often; a particularly simple way to
achieve this is through the CCS specification ,\vspace{2pt} given by
\plat{}; that is, to alternate each of the two tasks.
This is a \emph{round-robin} solution.
It could be seen as a particular implementation of .
The reason that such a solution is not chosen is that it fails to capture the full generality of
the original specification, in which arbitrary many s may come between any two s.

Any real-life implementation of  on a physical computer is unlikely to capture the full
generality of its specification, but rather goes a few steps towards the round-robin solution.
For this reason, one could argue that  does not constitute an example of a distributed system
that cannot be rendered in CCS, but rather one of a \emph{specification} that
cannot be rendered in CCS\@. As such, it falls out of the scope of this paper.

\section{Our Contributions}\label{ssec:contribution}


This paper counters the sentiment that CCS-like process algebras are powerful
enough to represent arbitrary distributed systems by presenting a particularly simple system of which no
implementation can be expressed in CCS. 
The reason we use CCS is that it is among the most well-known standard process algebras, while having a fairly easy to explain
syntax and semantics. However, we believe the same result, with
essentially the same proof, could be obtained for COSY \cite{LTS79}, CSP \cite{BHR84,Ho85},
ACP \cite{BK86}, LOTOS \cite{BB87}, CRL \cite{GP95}, the -calculus \cite{MPW92}, etc.

Our system is a \emph{fair scheduler}. It can receive two
kinds of requests  and  from its environment on separate channels, and is guaranteed to perform a
task---\emph{granting} the request---in response. Our fairness requirement rules out a scheduler that
may fail to ever grant a request of type  because it is consistently busy granting requests .

Such schedulers occur
(in suitable variations)
in many distributed systems.
Examples are \emph{First in First out}\footnote{Also known as First Come First Served (FCFS)},
\emph{Round Robin}, and
\emph{Fair Queueing} 
scheduling algorithms\footnote{\url{http://en.wikipedia.org/wiki/Scheduling_(computing)}}
as used in network routers~\cite{rfc970,Nagle87} and operating systems~\cite{Kleinrock64},
or the \emph{Completely Fair Scheduler},\footnote{\url{http://en.wikipedia.org/wiki/Completely_Fair_Scheduler}}
which is the default scheduler of the Linux kernel since version 2.6.23.

If  stands for the most general specification of our scheduler, our claim entails that 
 cannot be rendered in CCS\@. However, accurately expressing  in CCS can
be seen as a luxury problem. Here we would accept \emph{any} implementation of , under the
broadest definition of implementation that makes sense for this problem---a round-robin solution for
instance would be totally acceptable---and what we show is that even that is
impossible.

As is common, we employ a version of CCS that allows the use of arbitrary sets of recursive equations to define processes.
As is trivial to show, \emph{any} labelled transition system, computable or 
not, can be modelled up to strong bisimulation equivalence as an expression in this
language. Hence, our result implies that no implementation of the fair scheduler  can be modelled as
a labelled transition system modulo strong bisimulation equivalence.

In this paper we will use a semantics of CCS incorporating a justness assumption. It distinguishes the strongly bisimilar systems 
and  mentioned above, on grounds that  can be understood to always perform infinitely many
s as well as s, whereas  might perform an infinite sequence of s while discarding the
-option all the time. This semantics increases the power of CCS in specifying fair schedulers,
and thereby strengthens our result that no implementation of the fair scheduler  can be
expressed. It thereby becomes stronger than the result that no implementation of  can be
rendered as a labelled transition system modulo strong bisimulation equivalence.

To prove our result, we show that our fair scheduler cannot be expressed in terms of  safe
Petri nets. The result for CCS then follows by reduction: an adequate Petri net semantics of CCS shows that
if the scheduler could be expressed in CCS, it could also be expressed as a Petri net.

The reason we resort to Petri nets to prove our main theorem is that Petri nets offer a structural
characterisation of what it means for a transition to be continuously enabled in a run of the
represented system from some state onwards. This is exploited in the proofs of
Lemmas~\ref{lem:one step embellishment}--\ref{lem:extension to complete path}.
It would be much harder to prove their counterparts directly in terms of the
labelled transition system of CCS\@.

In different formulations, our impossibility result for Petri nets was established earlier by
Vogler in \cite{Vogler02} and by Kindler \mand Walter in \cite{KW97}, but in both cases side
conditions were imposed that inhibit lifting these results to CCS\@.
The proof of \cite[Lemma 6.1]{Vogler02} considers only finite Petri nets.
The argument would extend to finitely branching nets, but not to all Petri nets that arise as the
semantics of CCS expressions. The proof of \cite{KW97} is restricted to Petri nets that interact
with their environment through an interface of a particular shape, and it is not a priori clear that
this does not cause a loss of generality. However, in \Sect{characterisation} we study a similar interface in
the context of CCS and show that it does not limit generality.

Although our fair scheduler cannot be expressed in a standard process algebra like CCS,
we believe there are many extensions in the literature in which this can be done quite easily.
In \Sect{fair spec} for instance, we specify it in a formalism that could be called CCS+LTL.
The use of a priority operator appears to be sufficient as well.\vspace{-6pt}

\section{Peterson's and Dekker's Mutual Exclusion Protocols}


Since Peterson's and Dekker's mutual exclusion protocols yield instances of our fair scheduler,
it follows that these protocol cannot be rendered correctly in CCS
without imposing a fairness assumption. Nevertheless, implementations of these algorithms in CCS
or similar formalisms occur frequently in the literature, and almost never a fairness assumption is invoked.
Moreover, for each of these two protocols, its various renderings differ only in insignificant details.
Our result implies that these common renderings cannot be correct.
Usually, only safety properties of these protocols are shown: never are two processes simultaneously in
the critical section. The problem is with the liveness property: any process that is ready to enter
the critical section will eventually do so. We found four papers that claim to establish essentially this
property, of which only one invokes a fairness assumption.
We will indicate in which way the other three do not establish the right liveness property.

Peterson expressed his protocol correctly in pseudocode
without resorting to a fairness assumption, although progress and justness are assumed implicitly.
It follows that Peterson's pseudocode does not admit an accurate translation into CCS\@.
We pinpoint the problem in this paper.

\section{Overview}


In \Part{one} we discussed (informally) the goal we set out to achieve, and 
why we believe it is important and surprising at the same time.

\Part{two} formalises our results, while providing explanations of the choices made in this formalisation.
In particular, \Sect{fair scheduler} presents an informal description of our fair
scheduler .  \Sect{CCS} presents CCS\@.
\Sect{progress} makes a 
progress assumption on the semantics of CCS and argues that it is
useful to set apart a set of non-blocking actions.
\Sect{justness} formalises the justness assumption discussed above and presents a semantics of CCS in which a process
 is modelled as a state in a labelled transition system together with a set of (possibly
infinite) paths in that transition system starting from  that model its valid runs.
 \Sect{fair spec} gives a formal specification of .
Since we aim to show that no implementation of  can be
specified in CCS, the specification of  cannot be given in CCS
either.  Instead we specify  as a CCS expression augmented
with a \emph{fairness specification}.  This follows the traditional
approach of TLA~\cite{TLA} and other formalisms \cite{Fr86}, ``in which
first the legal computations are specified, and then a fairness notion
is used to exclude some computations which otherwise would be legal'' \cite{AFK88}.
In \Sect{no fair scheduler} we state our main result, saying that no fair scheduler---that is: no
implementation of ---can be expressed in CCS\@.
\Sect{characterisation} reformulates this result, so that it is
independent of the concept of an action being perpetually enabled in a run of the represented system.
In \Sect{discussion} we conclude that mutual exclusion
protocols, like the algorithms from Dekker or Peterson, cannot be
rendered correctly in CCS without imposing a fairness condition.
We also investigate the apparent contradiction with the fact that
several research papers claim to achieve exactly this.
We end this section with a result by Corradini, Di Berardini \mand Vogler,
showing where a fairness assumption is needed for a rendering
of Dekker's protocol in a process algebra to be correct.

\Part{three} deals with proving our main result.
In \Sect{nets} we formulate our claim that no fair scheduler can be modelled as a 
safe Petri net. This claim is proven in \Sect{proof PN}.
In \Sect{operational PN} an operational Petri net semantics of CCS is
presented, following the work of Degano, De Nicola \mand Montanari.
From this, the proof of our main result is obtained in \Sect{proof conclusion}.
A few concluding remarks are made in \Sect{conclusion}.


\part{Formalisation}{two}


\section{A Fair Scheduler}\label{sec:fair scheduler}


Our fair scheduler is a reactive system with two input channels: one
on which it can receive requests  from its environment and
one on which it can receive requests . We allow the scheduler to
be too busy shortly after receiving a request  to accept another
request  on the same channel. However, the system will always
return to a state where it remains ready to accept the next request 
until  arrives. In case no request arrives it 
remains ready forever. The environment is under no
obligation to issue requests, or to ever stop issuing requests.
Hence for any numbers  and  there is at least one run of the system in
which exactly that many requests of type  and  are received.

Every request  asks for a task  to be executed.
The crucial property of the fair scheduler is that it will eventually
grant any such request. Thus, we require that in any run of the system
each occurrence of  will be followed by an occurrence of .
In Linear-time Temporal Logic (LTL)~\cite{Pnueli77} this can be stated as

\noindent
Note that it may happen that the environment issues request 
three times in a row before the scheduler got a change to schedule
task . In that case the scheduler may fulfil its obligation by
scheduling task  just once. Hence it need not keep a counter of
outstanding requests.\footnote{This relaxed requirement only
  serves to increase the range of acceptable schedulers, thereby
  strengthening our impossibility result. It by no means rules out a
  scheduler that schedules task  exactly once for each request
   received.}

We are not interested in implementations of the scheduler that just
schedule both tasks infinitely often without even listening to the
requests. Hence we require that in any partial run of the scheduler
there may not be more occurrences of  than of , for .

The last requirement is that between each two occurrences of  and
 for  an intermittent activity  is
scheduled.\footnote{Our specification places no restrictions on the
  presence or absence of any additional occurrences of . This again
  increases the range of acceptable implementations.}
This requirement will rule out fully concurrent implementations, in
which there are parallel components for task  and task  that do not
interact in any way.

\section{The Calculus of Communicating Systems}\label{sec:CCS}


\begin{table}[t]
\normalsize
\begin{center}
\framebox{}
\end{center}
\caption{Structural operational semantics of CCS}
\label{tab:CCS}
\end{table}

The Calculus of communicating systems (CCS) \cite{Mi89} is parametrised with sets  of {\em names} and  of {\em agent identifiers};
\vspace{2pt}each  comes with a defining equation \plat{}
with  being a CCS expression as defined below.
The set  of {\em co-names} is , and 
the set  of \emph{handshake actions} is 
\plat{}, the disjoint union of the names and co-names.
The function  is extended to  by declaring
a. Finally, \plat{} is the set of
{\em actions}. Below, , ,  range over ,
,  over  and  over .
A \emph{relabelling} is a function  satisfying
; it extends to  by .
The set  of CCS expressions is the smallest set including:
\begin{center}
\begin{tabular}{@{}l@{~~}l@{\qquad\quad}l@{~~}l@{\qquad\quad}l@{~~}l@{}}
 &  \emph{agent identifier} &
  & \emph{prefixing}&
  & \emph{choice} \\
 & \emph{parallel composition}&
  & \emph{restriction} &
 &  \emph{relabelling} \\
\end{tabular}
\end{center}
\noindent for , index sets , and relabellings .
We write  for  if , and  if .
The semantics of CCS is given by the labelled transition relation
, where the transitions 
\plat{}
are derived from the rules of \Tab{CCS}.
The pair  is called the \emph{labelled transition system} (LTS)
of CCS\@.

\section{The Necessity of Output Actions}\label{sec:progress}


\newcommand{\D}{\ensuremath{F}}
\newcommand{\Do}{\ensuremath{F_{0}}}
Before attempting to specify our scheduler in CCS, let us have a look at a
simpler problem: the same scheduler, but with only one type of request ,
and one type of task  to be scheduled. A candidate CCS
specification of such a scheduler is the process , defined by\vspace{-1ex}

As stated in Section~\ref{sec:fair scheduler}, the scheduler is called fair if 
every request  is eventually followed by the requested task ; so we 
want to ensure the property
.\footnote{When assuming that this formula holds,
   trivially satisfies the other properties required in \Sect{fair scheduler}:
the system will always return to a state where it remains ready to
accept the next request  until it arrives; in any partial run there are no more
occurrences of  than of , and between each two occurrences of
 the action  is scheduled.}
However, we cannot guarantee that this property actually holds for process .
The reason is that the process might remain in the state  
reached by taking transition  without ever performing the 
action . In any formalism that allows to remain in a state
even when there are enabled actions, no useful liveness property about
processes can ever be guaranteed. One therefore often makes a \emph{progress assumption},
saying that the system will not idle as long as it can make progress.
Armed with this assumption, it appears fair to say that the process  satisfies the required
property .

However, by symmetry, the same line of reasoning would allow us to derive that  satisfies
, i.e.\ each execution of  will be followed by a new
request. Yet, this is something we specifically do not want to assume: the action  is meant to be
fully under the control of the environment, and it may very well happen that at some point the
environment stops making further requests. A particular instance of this is when the environment is modelled by
a CCS context such as ; in this context the process  will
receive the request  only once.

Hence, we reject the validity of  based on environments
such as .
However, the same reasoning allows environments such as 
that do not allow the task  to be executed more than once. The existence of such environments
totally defeats our scheduler, or any other one.

Thus, for a fair scheduler to make sense, we need to consider environments that have full control
over the action  but cannot sabotage the mission of our scheduler by disallowing
tasks  and . We formalise this by calling  and  \emph{output actions}.
An \emph{output action}~\cite[Section 9.1]{TR13} is
an activity of our system that cannot be stopped by its environment; or, equivalently, considering
an action  to be \emph{output} means that we choose not to consider environments that can block .
In our schedulers,  and  are output actions, whereas  is not.

Let CCS be the variant of CCS that is parametrised not only by sets  of names and
 of agent identifiers, but also by a set  of output actions. The only further
difference with CCS of \Sect{CCS} is that \plat{}, and a relabelling 
extends to  by  for all .
CCS can be seen as an extension of CCS with output actions, but it can just as well be seen as a
restriction of CCS in which for some of the names there are no co-names and no restriction operators.

It should be noted that CCS already features the concept of an \emph{internal} action, namely
, of which it is normally assumed that it cannot be blocked by the environment.
Yet, for the purpose of specifying our scheduler, the r\^ole of the output action  cannot be played
by , for the internal action is supposed to be unobservable and is easily
abstracted away. Output actions share the feature of internal actions that whether they
occur or not is determined by the internal work of the specified system only; yet at the same
time they are observable by the environment in which the system is running.\footnote{The output
    and internal actions of CCS are similar to the output and internal action of I/O automata \cite{LT89}.
    However, the remaining actions of I/O automata are \emph{input actions} that are totally under
    the control of the environment of the modelled system. In CCS, on the other hand, the default type
    of action is a \emph{synchronisation} that can happen only in cooperation between a system and
    its environment.}
An action in ---so an output or internal action---is also called a \emph{non-blocking} action.

Now we formulate our \emph{progress assumption}\cite{TR13,GH14}:


LTL formulas are deemed to hold for a process  if they hold for all \emph{complete
paths} of  in the labelled transition system of CCS. Here a \emph{path} of
 is an alternating sequence of states and transitions, starting from the state  and
either being infinite or ending in a state, such that each transition in the sequence goes from the
state before to the state after it, and a finite path is complete iff it does not end in a state that
enables a non-blocking action; completeness of infinite paths is discussed in the next
sections. For further details, see \cite[Section 9.1]{TR13} or~\cite{GH14}.

Assuming progress,
the scheduler  
satisfies  because on each complete
  path every  is followed by a . Hence  is fair w.r.t.\ the simpler problem.

\section{A Just Semantics of Parallelism}\label{sec:justness}


In the previous section we considered a scheduler\vspace{2pt} that was significantly simpler than the one of
\Sect{fair scheduler}, and were able to specify it in CCS by \plat{}, with output actions  and . 
However, in order to ensure that our
specification was formally correct, we needed to introduce the concept of an output action, and made
a progress assumption on the semantics of the language.

In this section, we consider again a simplification of the scheduler of \Sect{fair scheduler}, and
once more succeed in specifying it in CCS. Again we need to make an assumption about the semantics
of CCS in order to ensure that our specification is formally correct.

Both assumptions increase the range of correct CCS specifications and thereby make the promised
result on the absence of any CCS specification of a scheduler as described in \Sect{fair scheduler}
more challenging.

Consider a scheduler as described in \Sect{fair scheduler}, but without the last requirement about
the intermittent activity .  A candidate CCS specification is the process , defined by\vspace{-2ex}

Here, and throughout this paper,  (like ) is an output action and  is not.
For this scheduler to be fair, it has to satisfy
 for .\footnote{When assuming that these formulas hold,
   trivially satisfies the other properties required of it:
  the system will always return to a state where it remains ready to
  accept the next request  until it arrives---hence for any numbers  and
   there is at least one run of the system in which exactly that many
  requests of type  and  are received---and in any partial run there are no more
  occurrences of  than of .}
By the reasoning of the previous section the process
 satisfies the temporal formula  for .
It is tempting to conclude that obviously their parallel composition  satisfies both of
these requirements. Yet, the system run \linebreak[1]---that after performing one action
from  performs infinitely many actions from  without interleaving any further actions from
---could be considered a counterexample.

Here we take the point of view that no amount of activity of  can prevent  from making
progress. The system  simply does not have a run .
The corresponding path from the state  in the LTS of CCS is no
more than an artifact of the use of interleaving semantics. In general, we make the following
\emph{justness assumption} \cite{GH14}: 

Thus justness guarantees progress of all components in a parallel composition, and of all
combinations of such components.\vspace{2pt} In the CCS expression  
with  
\plat{}, 
\plat{} and 
\plat{}
 for
instance
there is a state where  admits an action  with  and  admits an action
. Thereby, the combination of these components admits an action . Our justness
assumption now requires that either  or  will eventually
partake in an action.
This could be the -action obtained from synchronising  and , but it also could be
any other action involving  or . In each case the system will (at least for an instant) cease to be in a state where that
synchronisation between  and  is enabled.
Note that progress is a special case of justness, obtained by considering any process as the
combination of all its parallel components.

In \cite{GH14} we formalised the justness assumption as follows.\newline
Any transition \plat{} derives, through the
rules of \Tab{CCS}, from
\vspace{-1ex}
\begin{itemize}
\item a transition \plat{} and a state , where \,,
\item two transitions \plat{ and }, where \,,
\item or from a state  and a transition \plat{}, where .
\vspace{-1ex}
\end{itemize}
This transition/state, transition/transition or state/transition pair is called a \emph{decomposition}
of \plat{}; it need not be unique, as we will show in \Ex{not unique} below.
Now a \emph{decomposition} of a path  of  into paths  and  of
 and , respectively, is obtained by \hypertarget{hr:decomp}{decomposing}\label{pg:decomp} each transition in the path, and
concatenating all left-projections into a path of  and all right-projections into a
path of .
Here it could be that  is infinite, yet either  or  (but not both) are finite.
Again, decomposition of paths need not be unique.

Similarly, any transition \plat{} stems from a transition \plat{},
where  and .
This transition is called a decomposition of \plat{}. A \emph{decomposition}
of a path  of  is obtained by decomposing each transition in the path, and
concatenating all transitions so obtained into a path of .
A decomposition of a path of  is defined likewise.

\begin{definition}\label{df:just path}\rm
\emph{-justness}, for ,\footnote{By definition  does not contain non-blocking action.}
 is the largest family of predicates on the paths in the LTS of CCS such that
\begin{itemize}
\vspace{-1ex}
\item a finite -just path ends in a state that admits actions from  only;
\item a -just path of a process  can be decomposed into an -just path of  and a -just
  path of  such that  and ---here
  ;
\item a -just path of
   can be decomposed into a -just path of ;
\item a -just path of  can be decomposed into an
  -just path of ; 
\item and each suffix of a -just path is -just.
\vspace{-1ex}
\end{itemize}
A path  is \emph{just} if it is -just for some .
It is \emph{-enabled} for an action  if  for all  such that  is -just.
\end{definition}
Intuitively, a -just path models a run in which  is an upper~bound of the set of labels of
abstract transitions\footnote{The CCS process  has two transitions labelled , namely
\plat{} and \plat{}. The only difference between these two transitions
  is that one occurs before the action  is performed by the parallel component and the other
  afterwards. In \cite{GH14} we formalise a notion of an \emph{abstract transition} that
  identifies these two concrete transitions.} that from some point onwards are continuously enabled but never taken.
Here an {abstract transition} with a label from  is deemed to be continuously enabled but never
taken iff it is enabled in a parallel component that performs no further actions.
Such a run can actually occur if the environment from some point
onwards blocks the actions in .

The last clause in the second requirement prevents an -just path of  and a -just path of
 to compose into an -just path of  when  contains an action  and 
the complementary action~. The reason is that no environment can block both actions for
their respective components, as nothing can prevent them from synchronising with each other.
The fifth requirement helps characterising processes of the form  and , with  \plat{}.
Here, the first transition `gets rid of' the choice and of the leading action , respectively, 
and reduces the justness of paths of such processes to their suffixes.

A complication in understanding \Def{just path} is that a single path could be seen as
modelling different system runs of which one could be considered just, respectively -enabled, and the other not.
\begin{example}\label{ex:not unique}
Consider the process  defined by \plat{}.
The only transition of this process is \plat{}, so  has exactly one infinite path ,
obtained by repeating this transition infinitely often. Assuming that  is an output action, one
may wonder if  should count as being just. In case all transitions in  originate
from the left component, the -transition of the right component is continuously enabled but
never taken. This does not correspond to a (just) run of the represented system.
However, in case  alternates transitions from each component, it does model a (just) run.
The mere fact that a -transition is enabled on every state of 
has no bearing on the matter. Now \Def{just path} considers  just, on grounds of the fact that
it models some (just) run.

If in this example  is a handshake action, the path  models a (just) run in which a
-labelled abstract transition is continuously enabled but never taken; but it also models a
(just) run in which no transition is continuously enabled but never taken.
According to \Def{just path},  counts as -just, and thus is not deemed -enabled.
Intuitively, a path is -enabled iff on all runs modelled by that path a transition labelled 
is continuously enabled but never taken.
\qed
\end{example}

Now a just path, as defined above, is our default definition of a complete path, as contemplated at
the end of \Sect{progress}. Indeed, a finite path is just iff it does not
end in a state from which a non-blocking action is possible \cite{GH14}.

Thus, our semantics of a CCS process  consists of the state  in the LTS of
CCS together with the set of complete paths in that LTS starting from  \cite{TR13,GH14}.
LTL formulas \emph{hold} for  iff they are valid on all complete paths of .

Here we employ a just semantics of CCS by taking the just paths to be the complete ones.
This way  is a correct specification of the scheduler required in \Sect{progress} and 
is a correct specification of the scheduler required above. 

\section{Formal Specification of the Fair Scheduler}\label{sec:fair spec}
 
\renewcommand{\d}[1]{c_{#1}}
\newcommand{\db}[1]{c_{{#1}}!}
\newcommand{\dr}[1]{c_{#1}?}
\newcommand{\tb}[1]{t_{#1}}
\newcommand{\tr}[1]{t_{#1}?}
\newcommand{\e}{e}
\newcommand{\BB}[1]{B_{#1}}

We now provide a formal specification of the scheduler described in \Sect{fair scheduler}.
Since the aim of this paper is to show that this cannot be done in CCS (and thus certainly not
in CCS) we need a different formalism for this task. Here we follow the
traditional approach of TLA~\cite{TLA} and several other frameworks \cite{Fr86}, ``in which
first the legal computations are specified, and then a fairness notion
is used to exclude some computations which otherwise would be legal'' \cite{AFK88}.
Following \cite{GH14}, we use CCS for the first step and LTL for the second.

Thus, in this section we specify a process as a pair of a CCS expression  and a set  of LTL
formulas, called a \emph{fairness specification}. The semantics of  consists of the state  in
the LTS of CCS together with the set of just paths in that LTS starting from . 
The formulas of  are evaluated on the paths of  and any path that satisfies all
formulas of  is called \emph{fair}. Now the semantics of the entire specification  is the
state  in the LTS of CCS together with the set of \emph{complete paths} of ,
defined as those paths that are both just and fair.
In \cite{TR13,GH14} a consistency requirement is formulated that should hold between  and .

Now a fair scheduler as described in \Sect{fair scheduler} can be specified by the CCS process
, 
where\1mm]
augmented with the fairness specification
.

Here the first requirement of \Sect{fair scheduler} is satisfied by locating the two
channels receiving the requests  and  on different parallel components  and .
This way, after performing, say, , the system---component  to be precise---will always return
to a state where it remains ready to accept the next request  until it arrives, independent of
occurrences of .
The (non-output) actions  are used to communicate the request from the processes  to 
a central component , which then performs the requested action .

The second requirement of \Sect{fair scheduler} is enforced by the fairness specification,
and the last two requirements of \Sect{fair scheduler} are met by construction:
in any partial run there are no more occurrences of  than of ,
and between each two occurrences of  and  for  the intermittent action  is scheduled.

\section[Fair Schedulers Cannot be Rendered in CCS---Formalisation]
        {Fair Schedulers Cannot be Rendered in CCS---Formalisation}\label{sec:no fair scheduler}


In this section we formulate the main result of the paper, namely that no scheduler as described in
Sections~\ref{sec:fair scheduler} and~\ref{sec:fair spec} can be specified in CCS. Since we already showed that it \emph{can} be
specified in CCS augmented with a fairness specification, here, and in the rest of the paper, we
confine ourselves to CCS without fairness specifications. Thus, our notion of a
complete path is (re)set to that of a just path, as specified in \Def{just path}.

\begin{theorem}\rm\label{thm:no fair scheduler}
There does not exist a CCS expression  such that:
\vspace{-1ex}
\begin{enumerate}
\item any complete path of  that has finitely many occurrences of  is -enabled;\label{enabled}
\item on each complete (= just) path of , each  is followed by a ;\label{fair}
\item on each finite path of  there are no more occurrences of  than of ;\label{patient} and
\item between each two occurrences of  and  () an action  occurs.\label{coordinated}
\end{enumerate}
\end{theorem}
Requirements \ref{enabled}--\ref{coordinated} exactly formalise the
four requirements described in \Sect{fair scheduler}. We proceed to show that none of them can be skipped.

The CCS process  of \Sect{justness}
satisfies Requirements \ref{enabled}, \ref{fair} and \ref{patient}.
It does not satisfy Requirement \ref{coordinated}, due to the partial run .
\vspace{2pt}

The CCS process  with \plat{} for  and
\plat{}
satisfies Requirements \ref{enabled}, \ref{fair} and \ref{coordinated}.
It does not satisfy Requirement \ref{patient}, due to the partial run consisting of the single action .

The CCS process  satisfies
Requirements \ref{enabled}, \ref{patient} and \ref{coordinated}, but not \ref{fair}.
\vspace{2pt}

Finally, the process  given by
\plat{}
satisfies Requirements \ref{fair}, \ref{patient} and \ref{coordinated}. However, it does not
satisfy Requirement \ref{enabled}, because it allows the -just path 
with no occurrences of . This path models a run in which the system never reaches a state where
it \emph{remains} ready to accept the next request .

The proof of \Thm{no fair scheduler} will be the subject of
\Part{three}.

\section[A Characterisation of Fair Schedulers without enabling]{A Characterisation of Fair Schedulers without -enabling}\label{sec:characterisation}


Below we will show that without loss of generality we may assume
any fair scheduler to have a specific form. If it has that form,
Requirement~\ref{enabled} is redundant. Hence Requirement~\ref{enabled} can be replaced by
requiring that the scheduler is of that form.
This variant of our result appeared as a conjecture in \cite{GH14}.

For any CCS expression , let 
with \plat{} for ,
where  is an injective relabelling with  for , and
.
By the definition of relabelling (cf. Section~\ref{sec:progress}),  and .

\begin{theorem}\rm\label{thm:no fair scheduler2}
A process  meets Requirements \ref{enabled}--\ref{coordinated} of \Thm{no fair scheduler} iff
 meets these requirements, which is the case iff
 meets Requirements \ref{fair}--\ref{coordinated}.
\end{theorem}
\begin{proof}
Suppose  satisfies Requirements \ref{enabled}--\ref{coordinated}.
\begin{enumerate}
\item To show that  satisfies Requirement \ref{enabled} (with ; the other case
  follows by symmetry), it suffices to show that each occurrence of  in a just path of
  \plat{}, which corresponds to an occurrence of  in the subprocess , is followed by
  an occurrence of  in .

  So assume, towards a contradiction, that on a just path  of \plat{} an
  occurrence of  is not followed by an occurrence of  in the subprocess .
  By \Def{just path}  must be -just for some .
  So  can be decomposed into an -just path  of , a -just path  of
   and a -just path  of  for certain . By assumption, .
  Moreover,  can be decomposed into an -just path  of .
  Since in \plat{} the  of  requires synchronisation with the
   of , and  has only finitely many occurrences of ,
  it follows that  has only finitely many occurrences of , and thus that
   has only finitely many occurrences of .
  Since  satisfies Requirement~\ref{enabled}, saying that the system will always
  return to a state where it remains ready to accept the next request  until it arrives,
  . Hence .
  By \Def{just path}, this contradicts the justness of .
\item Above we have shown that each occurrence of  in a just path of
  \plat{}, which corresponds to an occurrence of  in the subprocess , is followed by
  an occurrence of  in . This occurrence of  in  must be a
  synchronisation with an occurrence of  in , and by Requirement~\ref{fair} for  each
  occurrence of  in  is followed by an occurrence of  in , and hence in .
\item By Requirement~\ref{patient} for , on each finite path from  there are no more
  occurrences of  than of . Moreover, on each finite path from  there are no more
  occurrences of  than of . Since in  each occurrence of  in  needs to
  synchronise with an occurrence of   in , it follows that on each finite path from
    there are no more occurrences of  than of .
\item Requirement~\ref{coordinated} holds for  because it holds for .
\end{enumerate}
Now assume that  satisfies Requirements \ref{fair}--\ref{coordinated}.
\begin{enumerate}
\item Suppose that  would fail Requirement~\ref{enabled}, say for . Then it has a -just
  path with . Therefore  has an -just path with .
  This path can be synchronised with a -just path of  into a just path of 
  in which an occurrence of  follows the last occurrence of , thereby violating
  Requirement~\ref{fair} for .
\item Suppose that  would fail Requirement~\ref{fair}, say for . Then it has a just
  path with an occurrence of  past the last occurrence of . Therefore  has a -just
  path with  and an occurrence of  past the last occurrence of .
  This path can be synchronised with a -just path of  into a just path of 
  in which an occurrence of  follows the last occurrence of , thereby violating
  Requirement~\ref{fair} for .
\item Suppose  had a finite path with more occurrences of  than of , then through
  synchronisation a finite path of  could be constructed with more occurrences of  than of .
\item Requirement~\ref{coordinated} holds for  because it holds for .
\qed
\end{enumerate}
\end{proof}
Recall that , given by ,
satisfies Requirements \mbox{\ref{fair}--\ref{coordinated}}. 
Converting this  to the process  of the form  , as defined above, results in the specification of \Sect{fair spec}
without the additional fairness specification, and hence in the loss of Requirement \ref{fair}.

\section{\hspace{-0.4pt}(\hspace{-0.1pt}In\hspace{-0.1pt})\hspace{-0.4pt}Correct\hspace{-0.4pt} Correctness\hspace{-0.4pt} Proofs\hspace{-0.4pt} of\hspace{-0.4pt} Peterson's\hspace{-0.4pt} and\hspace{-0.4pt} Dekker's\hspace{-0.4pt} Protocols}\label{sec:discussion}


It is widely accepted that Peterson's mutual exclusion protocol~\cite{Peterson81} implements a fair
scheduler, and that implementing Peterson's algorithm in a CCS-like language should be easy.
In fact Peterson's algorithm has been specified in CCS-like languages several times, e.g.\
\cite{Walker89,Bouali91,Valmari96,AcetoEtAl07}.   All these papers present essentially the same rendering of Peterson's algorithm
in CCS or some other progress algebra, differing only in insignificant implementation details.
This seems to contradict our main result (Theorem~\ref{thm:no fair scheduler}).
\newcommand{\procA}{{\rm A}\xspace}
\newcommand{\procB}{{\rm B}\xspace}

Peterson's Mutual Exclusion Protocol deals with two concurrent processes \procA and \procB that want to
alternate critical and noncritical sections. Each of these processes
will stay only a finite amount of time in its critical section,
although it is allowed to stay forever in its noncritical section.
The purpose of the algorithm is to ensure that they are never
simultaneously in the critical section, and to guarantee that both
processes keep making progress. 
Pseudocode is depicted in \Fig{peterson}.

\begin{figure}
1ex]
{\bf repeat~forever}\\
\left\{\begin{array}{ll}
\ell_1 & {\bf noncritical~section}\\
\ell_2 & readyA := true	\\
\ell_3 & turn := B \\
\ell_4 & {\bf await}\,(readyB = false \vee turn = A) \\
\ell_5 & {\bf critical~section}\\
\ell_6 & readyA := false \\
\end{array}\right.
\end{array}
~~~~~~
\begin{array}{@{}l@{}}
\underline{\bf Process~B}\
\caption{Peterson's algorithm (pseudocode)}
\label{fig:peterson}
\end{figure}

The processes use three variables. The Boolean variable  can be
written by process \procA and read by process \procB, whereas  can be
written by \procB and read by \procA. By setting  to , process
\procA signals to process \procB that it wants to enter the critical
section. The variable  is a shared variable: it can be written
and read by both processes. Its use is the brilliant part of the algorithm.
Initially  and  are both  and .

Peterson's algorithm implements a mutual exclusion protocol and hence 
should satisfy the safety property that at any time only one process accesses the critical system, i.e.\

Here,  and  refer to line numbers of the pseudocode (\Fig{peterson}). 
As convention we assume that line numbers refer to a state in the execution of the code where the 
command of the line has already been executed.
Most papers, including \cite{Bouali91,AcetoEtAl07},  
concentrate on the issue of mutual
exclusion only, and that is done correctly in the CCS rendering.
When safety properties are considered only, no fairness or progress assumption is needed: 
in the worst case some (or all) processes do not progress and hence never enter the critical section---the safety property still holds. 

As usual, a safety property should therefore be accompanied with a liveness property.
In case of Peterson's protocol such a property is that any process
that wants to enter the critical section will at
some point reach the critical section. We consider two possibilities to characterise this property:

\footnotetext{We only give the liveness property for process \procA; the one for process \procB is similar.}Both properties have the form ---the property discussed in this paper--- indicates that the process enters the critical section. Both  and  could 
play the r\^ole of the grant request .
Although it seems surprising, we will show that there is a fundamental difference between these two formulas.

To show how Peterson's algorithm yields an instance of our fair scheduler, we consider the
action  to be taken when an execution passes through state , thereby interpreting  as
granting access to the critical section. The action  is taken when the execution passes through state
, marking the \emph{exit} of the critical section. Peterson's code, in combination
with the mutual exclusion property, ensures that Requirement~\ref{coordinated} of our fair scheduler
is satisfied. We consider  to be taken when an execution passes through state , so that the
liveness property  ensures Requirement~\ref{fair}.
Requirement \ref{enabled} is satisfied, because as soon as the environment of the protocol leaves
the noncritical section, thereby getting ready to enter the critical one, the protocol is considered
to take the action . Finally, Requirement~\ref{patient} is obviously ensured by Peterson's code.

In combination with this insight, our main result (\Thm{no fair scheduler}) entails that
the rendering of Peterson's algorithm in CCS found in the literature cannot be correct, as long as the semantics of CCS
is fortified with at most justness.
To prove liveness of Peterson's protocol,
 at least weak fairness  is required.\footnote{Whether weak fairness suffices depends on the interpretation of enabledness (cf.\ \Sect{fairness})}
In the literature we found only two papers that investigate
liveness properties of this protocol:
\cite{Walker89} and \cite{Valmari96}. Neither of these papers employs fairness or justness properties.

Walker~\cite{Walker89} tries to prove the correctness of Peterson's algorithm by automatic methods.
He succeeds for the safety property, but could not establish the liveness property
in full generality; however Walker succeeded in
proving it when restricting attention to runs in which infinitely many
visible actions occur. This appears to be Walker's method of imposing a progress assumption.
Although this is strictly speaking not in
contradiction with our results, our proofs trivially extend to the
case of considering only runs in which infinitely many visible actions
occur. Hence Walker's result seems to be in contradiction to 
\Thm{no fair scheduler}.
A detailed analysis reveals that Walker uses line  as request action to indicate 
interest to enter the critical section.
So he shows that .
That means that the \emph{shared variable}  must 
be set---only then  evaluates to true.
His request action is set right after
setting this variable. 
However, following our proof, the reason that
the CCS rendering of Peterson does not work, is that it is possible that
process \procA never gets a change to set the shared variable  to true, because the
other process is too busy reading it all the time (even when it
enters the critical section between any two reads). 
So, it is a possible scenario that process \procA will never execute line , although 
it wants to enter the critical section.

In Peterson's
original thinking, process \procB could not prevent process \procA
from writing by reading a shared variable; but in the CCS model this is
quite possible: the read action can only be represented as a transition that is in conflict with the write action;
only after this transition is taken does the process return to a state where the write is enabled.
So when Walker~\cite{Walker89} establishes 
he merely shows that when the first hurdle is taken successfully
the process will surely enter the critical section. What he cannot establish
is that a process that is ready to enter the
critical section will succeed in setting . 
The correct modelling of Peterson's liveness property
thus places action  \emph{before} setting the variable  to true, i.e.\

In terms of our description of a fair scheduler, the action  of
Walker (at position ) does not meet Requirement~\ref{enabled}.

The analysis of the work of Walker shows that there is a fine line between 
correct and incorrect modelling. In fact it looks reasonable to prove 
 instead of 
. There is
no formal way to avoid such mistakes; only careful (informal) reasoning.

Roughly the same modelling, but in which the
request  is \emph{identified}
with setting the shared variable  to true,
occurs in Valmari \mand Set\"{a}l\"{a}~\cite{Valmari96}.
The consequences are the same.

Dekker's mutual exclusion protocol~\cite{EWD35,EWD123} is another well-known algorithm that implements a fair
scheduler. We found two papers in the literature that analyse liveness of this protocol.

Esparza \mand Burns~\cite{EsparzaBruns96}
follow in the footsteps of Walker and prove the correctness of
Dekker's mutual exclusion algorithm in the Box Calculus without
  postulating a fairness assumption. According to our results, this
is impossible as well. Indeed, as in \cite{Valmari96}, Esparza \mand Burns model the request 
to be the action of setting a shared variable, which again violates the property
that a process that wants to enter the critical section can always
succeed at least in making a request to that effect.

Corradini, Di Berardini \mand Vogler~\cite{CorradiniEtAl09}
specify Dekker's algorithm in the CCS-like process algebra PAFAS. 
They also prove the correctness 
of the algorithm. This paper models the relevant liveness properties correctly, as far
as we can see, but explicitly makes different assumptions on the driving
force that keeps the system running. First they consider a notion of
`fairness of actions' that appears to be similar to our
justness assumption,\footnote{It differs in a crucial way,
    however, namely by treating each action as output. As a
    consequence, under fairness of actions the process  of
    \Sect{justness} is guaranteed to perform each of the actions 
    and  infinitely often.  To model a protocol where the action
     is not forced to occur, a -loop is inserted 
    at each location where  is enabled.}
    and they show that their model of Dekker's protocol fails
to have the required liveness property. This result is entirely
consistent with ours. In fact we generalise their negative result
about the correctness of a particular rendering in PAFAS of a
particular protocol for mutual exclusion to a general statement
quantifying of all renderings of all such protocols.

Next they consider a stronger notion of fairness called `fairness
of components', stemming from \cite{CS87}, and, under this assumption, establish the correctness of
the algorithm.\footnote{Fairness of components is a form of weak fairness,
requiring that if a \emph{component} from some point onwards is enabled in each state, an action
from that component will eventually be scheduled.
Here a component is enabled if an action from that component is enabled, possibly in synchronisation
with an action from outside that component.\vspace{2pt} Under this notion of fairness, the system 
from \Sect{fairness}, defined by \plat{}, is not ensured to do
a  eventually. However, the composition  is ensured to do a 
eventually, because the component  is enabled in every state.}
The present paper augments this result by saying that a fairness notion as strong as `fairness
of components' is actually needed. 

In \Part{one} we pointed out that our result holds for CCS+justness, CCS+progress and CCS without any progress assumption. 
However a fair scheduler can be implemented when a fairness assumption is assumed; fairness of
components appears to be sufficient. 


\part{Proofs}{three}
\section{Fair Schedulers Cannot be Rendered in Petri Nets---Formalisation}\label{sec:nets}


\newcommand{\Act}{Act}
This section introduces Petri nets and rephrases \Thm{no fair scheduler} in terms of Petri nets.
We inherit the sets  of actions and  of handshaking communications from \Sect{CCS},
and the set  of output actions from \Sect{progress}.

A {\em multiset} over a set  is a function ,
i.e.\ .
The function , given by
   for all , is the \emph{empty} multiset over .\\
 is an \emph{element of} , notation , iff .\\
For multisets  and  over  we write  iff
 \mbox{} for all ;
\\  denotes the multiset over  with ,
\\  denotes the multiset over  with , and
\\  is only defined if  and then denotes the multiset over  with 
.
\\ A multiset  with  for all  is identified with the (plain) set .\begin{definition}
  A (\emph{labelled}) \emph{Petri net} (\emph{over }) is a tuple
   with
  \begin{list}{{\bf --}}{\leftmargin 18pt
                        \labelwidth\leftmargini\advance\labelwidth-\labelsep
                        \topsep 0pt \itemsep 0pt \parsep 0pt}
    \item  and  disjoint sets (of \emph{places} and \emph{transitions}),
    \item 
      (the \emph{flow relation} including \emph{arc weights}),
    \item  (the \emph{initial marking}), and
    \item \plat{} (the \emph{labelling function}).
  \end{list}
\end{definition}

\noindent
When a Petri net represents a concurrent
system, a global state of this system is given as a \emph{marking},
a multiset  of places. 
The initial state is .

The behaviour of a Petri net is defined by the possible moves between
markings  and , which take place when a transition  \emph{fires}.  In that case,
 consumes  tokens from each 
place .  Naturally, this can happen only if  makes all these
tokens available in the first place.  Moreover,  produces  tokens
in each .  \Def{firing} formalises this notion of behaviour.

\begin{definition}\label{df:firing}
Let  be a Petri net and .
The multisets  are given by  and
 for all ;\footnote{Here, we slightly deviate from
  standard notation \cite{Re85}, where  and  are usually plain sets,
obtained from our multisets by abstracting from the multiplicities of their elements. 
We prefer to retain this information, so as to shorten various formulas.}
the elements of  and  are
called \emph{pre-} and \emph{postplaces} of , respectively.
Transition  is \emph{enabled} from the marking ---notation
---if .
In that case firing  yields the marking 
\linebreak[3]---notation .
\end{definition}
A \emph{path}  of a Petri net  is an alternating sequence  of markings and
transitions, starting from the initial marking  and either being infinite or ending in a
marking , such that  for all .
An action  \emph{occurs} on a path  if there is a transition  with .
A marking is \emph{reachable} if it occurs in such a path.
The Petri net  is
\emph{safe} if all reachable markings  are plain sets, meaning that  for all places .
It is a \emph{structural conflict net} \cite{GGS11} if  for all reachable markings  and all transitions  and .
Note that any safe Petri net is a structural conflict net.
In this paper we restrict attention to structural conflict nets with the additional assumptions that  for no transition , 
and that all reachable markings are finite.
In the remainder we refer
to these structures as \emph{nets}. For the purpose of establishing \Thm{no fair scheduler} we could
just as well have further restricted attention to
safe Petri nets whose reachable markings are finite.

On a path  a transition  is \emph{continuously enabled from position  onwards} if
 and  for all .
This implies that  for all .
If such a transition  exists we say that  is -enabled.
A path is \emph{just} or \emph{complete} if it is -enabled for no non-blocking action .

Now we have all the necessary definitions to state that our fair scheduler cannot be realised as a net.

\begin{theorem}\rm\label{thm:no fair PN scheduler}
There does not exist a net  such that:
\vspace{-1ex}
\begin{enumerate}
\item any complete path of  that has finitely many occurrences of  is -enabled;\label{enabled PN}
\item on each complete (= just) path of , each  is followed by a ;\label{fair PN}
\item on each finite path of  there are no more occurrences of  than of ;\label{patient PN} and
\item between each two occurrences of  and  () an action  occurs.\label{coordinated PN}
\end{enumerate}
\end{theorem}
In the proof of this theorem we do not use the restriction that  is a structural conflict net.
However, for general Petri nets our definition of a transition that from some points onwards is
continuously enabled is not convincing. A better definition would replace the requirement 
 for all  by
 for all .
On structural conflict nets the two definitions are equivalent.
On general
Petri nets with finite reachable markings and  \Thm{no fair PN scheduler}
still holds when employing our earlier definition of being continuously enabled, but that definition
arguably leads to Requirement~\ref{enabled PN} being an overly restrictive formalisation of the first requirement
of \Sect{fair scheduler}.

In \cite{Vogler02} and in \cite{KW97} \emph{mutex problems} are presented that cannot be solved
in terms of Petri nets. These results are almost equivalent to \Thm{no fair PN scheduler}, but,
as discussed in the \SSect{contribution}, lack the generality needed to infer \Thm{no fair scheduler} from \Thm{no fair PN scheduler}.


\section{Fair Schedulers Cannot be Rendered in Petri Nets---Proof}
\label{sec:proof PN}


In this section we suppose that there exists a net 
meeting the requirements of \Thm{no fair PN scheduler}.
We establish various results about this hypothetical net , ultimately leading to a
contradiction. This will constitute the proof of \Thm{no fair PN scheduler}.

\subsection{Embellishing Paths into Complete Paths}

\newcommand{\fs}{\mbox{\sc fs}}
\newcommand{\ph}{\mbox{\sc ph}}
A \emph{firing sequence} of  is a sequence  of transitions such that
there exists a path  of . Note that  is uniquely
determined by~ (and ); we call it . Likewise,  is determined by , and
we call it .

A firing sequence  \emph{embellishes} a firing sequence 
iff  can be obtained out of  through insertion of non-blocking transitions;
that is, if there exists a monotone increasing function ---thus satisfying ---with  for all  and  for any
index  not of the form . A path  \emph{embellishes} a path  iff 
embellishes .

Given a firing sequence  of length  and a transition~, let
 denote the sequence  obtained by
inserting  in  at position .

\begin{lemma}\label{lem:one step embellishment}
Let  be a firing sequence of length  and  a transition that on  is continuously
enabled from position  onwards. Then  is a firing sequence.
\end{lemma}
\begin{proof}
Let . Define
 for . Then
 is again a path of ,
using that  and  for all .
\qed
\end{proof}
If  is a path and  a transition that on  is continuously enabled from position 
onwards, then  abbreviates .

A path  of  is \emph{-incomplete} if  is the
smallest number such that there is a transition  with ---called a \emph{witness} of the
-incompleteness of ---that is continuously enabled from position  onwards, and  is
the number of places  of  such that
 for a witness  of the -incompleteness of .
Since the reachable marking  is always finite, so are the numbers .
Note that a path is -incomplete for some finite  and  iff it is not complete;
henceforth we call a complete path \emph{-incomplete}.
If a path  is -incomplete, and a path  is -incomplete, then we call
 \emph{less incomplete} than  if  has the same prefix up to position 
as  and either  or .

\begin{lemma}\label{lem:less incomplete}
Let ,  be a -incomplete path of the net  with at least 
transitions, and  a witness of the -incompleteness of . Then  is less incomplete than .
\end{lemma}
\begin{proof}
Suppose  is -incomplete with , and let  be a witness of the
-incompleteness of .
Then on  the transition  is continuously enabled from position  onwards.
Let  be the marking occurring at position~ in , or equivalently in .
Then  and \mbox{} for all transitions
 occurring in  past position . This includes all transitions  occurring
in  past position , so  is continuously enabled from position  onwards also on .
It follows that  and any witness of the -incompleteness of  is also a
witness of the witness of the -incompleteness of .
Moreover, , and since
 this implies .
\qed
\end{proof}

\begin{lemma}\label{lem:embellishment by complete path}
Any infinite path in  is embellished by a complete path.
\end{lemma}

\begin{proof}
Let  be the given path.
We build a sequence  of paths in  that all embellish , such that, for all ,
 is less incomplete than  and the first  transitions of  and  are the same.

We start by taking  to be .
If at any point we hit a path  that is complete, our work is done.
Otherwise, given the -incomplete path , for some  and ,
pick a witness  of the -incompleteness of  and take .
This path exists by \Lem{one step embellishment}, since  is continuously enabled from position
 onwards, and hence also from position  onwards.
By construction  embellishes  and hence .
By \Lem{less incomplete}  is less incomplete than .
Moreover, the first  transitions of  and  are the same.

If at no point we hit a path  that is complete, let .
This limit clearly exists: for any  the first  transitions of  are the first
 transitions of  (and thus also of  for any ).
We show that  is complete and embellishes~.

For the latter property, the  transition  of  must also occur in , and
no further than at position , for  is an embellishment of  obtained by adding only
 transitions. As in the sequence  past index  no further changes occur
in the first  transitions, the transition  also occurs in .
Given the construction, this implies that  embellishes .
The same argument shows that  embellishes  for each .

Now suppose that  is incomplete. Then there is a non-blocking transition 
that on , from some position  onwards, is continuously enabled.
Let  be an index such that  is -incomplete for some .
Such an  must exist, as the members of  become less incomplete with
increasing .
Let  be the marking occurring at position~ in .
Then  also occurs at position~ in , as the first  transitions of 
are the same for all  with , and thus for .
Now  and \mbox{} for all transitions
 occurring in  past position . Since  embellishes , this includes all transitions  occurring
in  past position , so  is continuously enabled from position  onwards also on ,
contradicting the -incompleteness of .
\qed
\end{proof}

\begin{lemma}\label{lem:extension to complete path}
Any finite path in  can be extended to a complete path in , such that all transitions in the
extension have labels in .
\end{lemma}
\begin{proof}
This is a simpler variant of the previous proof.
Let  be the given path.
We build a sequence  of paths in  that all extend , such that, for all ,
 is less incomplete than  and extends  by one transition.

We start by taking  to be .
If at any point we hit a path  that is complete, our work is done.
Otherwise, given the -incomplete path , for some  and ,
pick a witness  of the -incompleteness of 
and obtain 
by appending transition  to .
By construction  extends  by one non-blocking transition and hence extends .
By \Lem{less incomplete}  is less incomplete than .

If at no point we hit a path  that is complete, let .
Clearly,  extends . That  is complete follows exactly as in the previous proof.
\qed
\end{proof}

\subsection{Paths of the Hypothetical Fair Scheduler}

\begin{lemma}\label{lem:PN1}
  Our hypothetical net  has a path with no occurrences of (transitions labelled) , but infinitely many occurrences
  of .
\end{lemma}
\begin{proof}
We construct an infinite sequence  of finite paths of ,
such that  has no occurrences of  and exactly  occurrences
of , and such that  is a prefix of  for all .
The limit of this sequence will be the required path.

 is  the trivial path, consisting of the initial marking  only.

Now assume we have constructed a path  as required.
By \Lem{extension to complete path}  can be extended into a complete path  that has no occurrences of  and
exactly  occurrences of . Since  is complete, it must be -enabled by Requirement~\ref{enabled PN}.
Hence there is a finite prefix  of , still extending , such that a
transition~ with  is enabled in the last state of .
Obtain  by extending  with~.
\qed
\end{proof}

\begin{lemma}\label{lem:PN2}
   has a path with exactly one occurrence of , none of , and infinitely many occurrences of .
\end{lemma}
\begin{proof}
Let  be the path found by \Lem{PN1}.
By \Lem{embellishment by complete path} this path is embellished by a complete path ,
that thus has no occurrences of  and infinitely many of .
By Requirement~\ref{fair PN}  has infinitely many occurrences of ,
and by Requirement~\ref{patient PN} it has no occurrences of .
By Requirement~\ref{enabled PN}  is -enabled.
Let  be a transition labelled  that is on  is continuously enabled from position  onwards.
By \Lem{one step embellishment}  has a path , obtained from  by inserting
transition  in position . That path has exactly one occurrence of , none of , and infinitely many of .
\qed
\end{proof}

\begin{lemma}\label{lem:PN3}
   has a -enabled path with infinitely many occurrences of .
\end{lemma}

\begin{proof}
Let  be the path found by \Lem{PN2}.
We build a sequence  of paths in  that all embellish  and do not contain , such that, for all ,
 is less incomplete than  and the first  transitions of  and  are the same.
Since the  embellish , they have exactly one occurrence of , and infinitely many of .
Moreover, by Requirement~\ref{fair PN}, none of the  can be complete.

We start by taking  to be .
If at any point we hit a path  that is -enabled, our work is done.
Otherwise, given the -incomplete path , for some  and ,
pick a witness  of the -incompleteness of  and take .
This path exists by \Lem{one step embellishment}, since  is continuously enabled from position
 onwards, and hence also from position  onwards.
Note that , since  is not -enabled.
Hence  does not contain .
By construction  embellishes  and hence .
By \Lem{less incomplete}  is less incomplete than .
Moreover, the first  transitions of  and  are the same.

If at no point we hit a path  that is -enabled, let .
Exactly as in the proof of \Lem{embellishment by complete path} it follows that
 is complete and embellishes . Since  does not occur on any of the , it does
not occur on . However,  does occur on , since it occurred on .
This is in contradiction with Requirement~\ref{fair PN}.
Therefore, the assumption that at no point we hit a path  that is -enabled must be wrong.
\qed
\end{proof}

\begin{trivlist}
\item[\hspace{\labelsep}{\bf Proof of \Thm{no fair PN scheduler}}]
Let  be the path found in \Lem{PN3}.
It must have a finite prefix  ending with an occurrence of , such that a transition 
labelled  is enabled it the last state of .
Extending  with  yields a finite path of  violating Requirement~\ref{coordinated PN}.
\qed
\end{trivlist}

\section{An Operational Petri Net Semantics of CCS}\label{sec:operational PN}


\newcommand{\weg}[1]{}
\newcommand{\src}{{\it src}}
\newcommand{\target}{{\it target}}
\newcommand{\shar}[1]{\mathord{\stackrel{#1}{\rightarrow}}}
\renewcommand{\myref}[1]{\hyperlink{lab:#1}{\sc (#1)}}

This section presents an operational Petri net semantics of CCS, following
Degano, De Nicola \mand Montanari \cite{DDM87}.
It associates a Petri net  with each CCS expression .
We establish that this Petri net is safe, all its reachable marking are
finite, and there are no transitions  with ;
hence it is one of the nets considered in \Sect{nets}. In \Sect{proof conclusion}
we will show that if a CCS expression  satisfies the four requirements of \Thm{no fair scheduler}
then the Petri net  satisfies the four requirements of \Thm{no fair PN scheduler}.
As a result, \Thm{no fair scheduler} will follow from \Thm{no fair PN scheduler}.

The standard operational semantics of CCS, presented in \Sect{CCS}, yields one big labelled
transition system for the entire language. Each individual CCS expression  appears as a state in
this LTS\@.  If desired, a \emph{process graph}---an LTS enriched with an initial state---for 
can be extracted from this system-wide LTS by appointing  as the initial state, and optionally
deleting all states and transitions not reachable from . In the same vein, an operational Petri
net semantics yields one big Petri net for the entire language, but without an initial marking.
We call such a Petri net {\em unmarked}. Each
process  corresponds to a marking  of that net. If desired, a Petri net
for  can be extracted from this system-wide net by appointing  as its initial marking,
and optionally deleting all places and transitions not reachable from .

The set  of places in the net---the \emph{grapes} of \cite{DDM87}---is the smallest set including:
\vspace{-12pt}
\begin{center}
\begin{tabular}{@{}l@{~~}l@{\qquad}l@{~~}l@{\qquad}l@{~~}l@{}}
&& &  \emph{agent identifier}\\
  & \emph{prefixing}&
  & \emph{choice}&
  & \emph{restriction}\\
 & \emph{left parallel component}&
 & \emph{right component} &
 &  \emph{relabelling} \\
\end{tabular}
\end{center}
\noindent for , ,
 , , , index sets , and relabellings~.
The mapping  decomposing
a process expression into a set of grapes is inductively defined by:

Here , ,  and  are understood element by element; e.g.\
. Moreover the binding is important, meaning that .

We construct the unmarked Petri net  of CCS
with , specifying the triple  as a ternary relation
.
An element \plat{} of this relation denotes a transition  with 
such that  and .
The transitions \plat{} are derived from the rules of \Tab{PN-CCS}.
\begin{table}[ht]
\normalsize
\begin{center}
\framebox{}
\end{center}
\caption{Operational Petri net semantics of CCS}
\label{tab:PN-CCS}
\end{table}

Henceforth, we write , for markings  and
, if there exists a transition  with  and .
In that case \plat{} and \plat{} for multisets of places  with \plat{}.

The following theorem says that function  is a strong bisimulation (\cite{Mi89}) between the LTS and the unmarked
Petri net of CCS. Since markings of the form  are plain sets (rather than multisets), it also
follows that the Petri net of each CCS expression is safe.\begin{theorem}\rm\label{thm:bisimulation}
If  for  and  then .
Moreover, if  then there is a  with  and .
\end{theorem}
\begin{proof}
The first statement follows by induction on the derivability of the transition
\plat{} from the rules of \Tab{CCS}. We only spell out two representative cases;
the others are similar or straightforward.
\begin{itemize}
\item Suppose  because .
By induction .
Hence \plat{} and \plat{} for (multi)sets  with \plat{}.
By \Tab{PN-CCS} we obtain \plat{}. Hence

\item Suppose  and  since .
By induction . Hence  \plat{} and
\plat{} for sets  with \plat{}.
By \Tab{PN-CCS}, \plat{}.
\end{itemize}
The second statement can be reformulated as
\begin{quote}
if  with \\ then there is a  with  and .
\end{quote}
for  and .
We prove it by induction on the derivability of the transition \plat{} from the rules of \Tab{PN-CCS}.
\begin{itemize}
\item Suppose . Since the only set  containing
   is , we have ,  and .  Take .
\item Suppose  because .
  Then  must have the form , so that , and  must have the form .\linebreak[4]
  Thus \plat{}, and by induction there is a  with
  \plat{} and . By \Tab{CCS}, \plat{}.
  Moreover, .
\item The case for restriction proceeds likewise.
\item Suppose  because .
  Then  must have the form , and , where .
  Thus \plat{}, so by induction there is a  with
  \plat{} and .  By \Tab{CCS}, \plat{}.
  Moreover, .
\item Suppose  because  and .
  Then  has the form , and , where
   and .
  Thus \plat{} and \plat{}, so by induction
  there are  with \plat{}, ,
  \plat{} and .  By \Tab{CCS}, \plat{}.
  Moreover, .
\item The case for the last rule for parallel composition follows by symmetry.
\item Suppose  because 
  for some .
  Since the only set  containing  is ,
  we have  and .
  By induction, there is a  with \plat{}
  and .
  By \Tab{CCS}, \plat{}.
\item The case
  for recursion (agent identifiers) goes likewise.
\qed
\end{itemize}
\end{proof}

A trivial induction shows that there are no transitions without preplaces.
The following lemma implies that all reachable markings are finite, so
that the Petri nets of CCS expressions
have all the properties of nets imposed in \Sect{nets}.
\begin{lemma}
For any  the set  is finite.
\end{lemma}
\begin{proof}
A straightforward induction.
\qed\end{proof}

The above operational Petri net semantics of CCS has the disadvantage that initial concurrency
in expressions of the form  or  is not represented~\cite{DDM87}.
Although this Petri net semantics matches the LTS semantics of CCS up
to strong (interleaving) bisimilarity---and thereby also the standard denotational
Petri net semantics of CCS-like operators \cite{GV87}---, it
does not match the standard denotational Petri net semantics up to semantic equivalences that take
concurrency explicitly into account. For this reason Olderog~\cite{Old91} provides an alternative
operational Petri net semantics that is more accurate in this sense. However, the work of Olderog
does not generalise in a straightforward way to the infinite sum construct of CCS, and to unguarded
recursion. 
In fact, a safe Petri net that accurately models the concurrent behaviour of the CCS process
 would need an uncountable initial marking, and hence falls outside
the class of nets we handle in \Sect{nets}. Since the accurate modelling of concurrency is not
essential for this paper, we therefore use the semantics of \cite{DDM87}.

\section[Fair Schedulers Cannot be Rendered in CCS---Proof]
        {Fair Schedulers Cannot be Rendered in CCS---Proof}
\label{sec:proof conclusion}

\begin{lemma}\label{lem:injective}
The mapping  is injective.
\end{lemma}
\begin{proof}
A straightforward induction on the structure of the elements in .
\qed
\end{proof}

\begin{lemma}\label{lem:path transfer}
Let .
For any path  in the unmarked Petri net of CCS
there is a unique path \plat{} of the same (finite or infinite) length in the LTS of CCS with  and  for
all .
\end{lemma}
\begin{proof}
A straightforward induction on , using \Thm{bisimulation} and \Lem{injective}.
\qed
\end{proof}

\noindent
The following observations are based directly on \Tab{PN-CCS} and the definition of .\begin{observation}\label{obs:decompose parallel}\rm Let .
Then  has the form  and either
\begin{itemize}
\vspace{-1ex}
\item  and  for a  with ,
   and ,
\item  and  for a  with ,
   and ,
\item or  and  for
   with , ,
   and .
\end{itemize}
\end{observation}
For each such transition , the transitions  and  discovered above are called the left- and
right-projections of , respectively, when they exist.
Hence any path  starting from a marking  can be uniquely decomposed into a 
path  starting from  and a path  starting from , notation . 
The path  fires all existing left-projections of the transitions in , in order, and
 its right-projections.

\begin{lemma}\label{lem:enabled path}
If  and  is -enabled, then so is . 
\end{lemma}
\begin{proof}
Let  be -enabled. Then there is a  and a transition  with
 such that  and  for all .
Let . 
Let  be such that  is the sequence of existing left-projections of .
The marking  has the form  with .
Since , by \Tab{PN-CCS} there exists a transition  with
 and . So .
Moreover, since  for all  we have  for all .
It follows that  is -enabled.
\qed
\end{proof}

\begin{lemma}\label{lem:enabled path 2}
If ,  is -enabled and  is
-enabled, for some , then  is -enabled.
\end{lemma}
\begin{proof}
Let . Since ,
each marking  has the form .
By the same reasoning as in the previous proof, there is a  and a transition  with  such that
 and  for all .
Likewise, there is a  and a transition  with  such that
 and  for all .

Let . By the fourth rule of \Tab{PN-CCS} there is a transition  with
 and  and
 for all . So  is -enabled.
\qed
\end{proof}

\begin{observation}\label{obs:decompose restriction}\rm
Let .
Then  has the form  and we have
 for a  with ,
 and .
\end{observation}
For each such transition , the transition  discovered above is called the projection of .
Hence any path  starting from a marking  can be uniquely decomposed into a 
path  starting from , notation . 
The path  fires all the projections of the transitions in , in order.

\begin{lemma}\label{lem:enabled path 3}
If  and  is -enabled with , then  is -enabled.
\end{lemma}
\begin{proof}
Let  be -enabled. Then there is a  and a transition  with
 such that  and  for all .
Let . 
The marking  has the form  with .
Since  and , by \Tab{PN-CCS} there exists a transition  with
 and . So .
Moreover, since  for all  we have  for all . It follows that  is -enabled.
\qed
\end{proof}

\begin{observation}\label{obs:decompose relabelling}\rm
Let .
Then  has the form  and we have
 for a  with ,
 and .
\end{observation}
For each such transition , the transition  discovered above is called a projection of ---it
need not be unique.
Hence any path  starting from a marking  can be decomposed into a 
path  starting from , notation . 
The path  fires projections of the transitions in , in order.

\begin{lemma}\label{lem:enabled path 4}
If  and  is -enabled, then  is -enabled.
\end{lemma}
\begin{proof}
Just as the proof of \Lem{enabled path 3}.
\qed
\end{proof}

\begin{observation}\label{obs:decompose projection}\rm
Let  be a path in the unmarked Petri net of CCS.\\
Then  implies 
{that   is a decomposition of  (c.f.\ Page~\hyperlink{hr:decomp}{\pageref*{pg:decomp}})}.
\\
Likewise, if  or  then  is a
decomposition of .
\end{observation}

\begin{proposition}\label{prop:enabled just}
Let  be a path in the unmarked Petri net of CCS.
If  includes all actions  for which  is -enabled, and ,
then  is -just.
\end{proposition}

\newcommand{\ejustn}{just}
\newcommand{\ejust}{just\ }
\newcommand{\Obs}[1]{Observation~\ref{obs:#1}}
\begin{proof}
  Define a path  in the LTS of CCS to be -\emph{\ejustn}, for ,
  if  has the form  for  a path in the unmarked Petri net of CCS, and
   includes all actions  for which  is -enabled.
  Note that if  is -\ejustn, it is also -\ejust for any .
  We show that the family of predicates -justness, for ,
  satisfies the five requirements of \Def{just path}.
  
  \begin{itemize}
  \item Let  be a finite -\ejust path. Suppose the last state  of  admits an action ,
  Then, using \Thm{bisimulation}, the last marking  of  enables a
  transition labelled . Thus  is -enabled, contradicting the -justness of .

  \item Suppose  is a -\ejust path of a process  {with }.
  Then  includes all actions  for which  is -enabled.
  Let  and  be the paths such that .
  By \Obs{decompose projection}  can be decomposed into the paths  of  and  of .
  Let  be the set of actions  for which  is -enabled,
  and let  be the set of actions  for which  is -enabled.
  By definition,  is -\ejust and  is -\ejustn. 
  
  If  is -enabled then  is -enabled by \Lem{enabled path}.
  This implies that .
  In the same way it follows that .
  Now suppose .
  Then  is -enabled and  is -enabled, for some .
  So, by \Lem{enabled path 2},  is -enabled, in contradiction with .
  We therefore conclude that .

  \item Suppose  is a -\ejust path of a process .
  Then  includes all actions  for which  is -enabled.
  Let  be the path such that .
  By \Obs{decompose projection}  is a decomposition of the path  of .
  Let  be the set of actions  for which  is -enabled.
  If  is -enabled with  then  is -enabled by \Lem{enabled path 3}.
  This implies that  and hence .
  It follows that  is -\ejustn, and hence -\ejustn.

  \item Suppose  is a -\ejust path of a process .
  Then  includes all actions  for which  is -enabled.
  Let  be a path such that .
  By \Obs{decompose projection}  is a decomposition of the path  of .
  Let  be the set of actions  for which  is -enabled.
  If  is -enabled then  is -enabled by \Lem{enabled path 4}.
  This implies that .
  It follows that  is -\ejustn, and hence -\ejustn.

  \item Suppose  is a suffix of an -\ejust path .
  Then  includes all actions  for which  is -enabled, and
  thus all  for which  is -enabled. Hence  is -\ejustn.
  \end{itemize}
  Since -justness is the largest family of
  predicates that satisfies those requirements, -justness implies -justness.
\qed\end{proof}

\begin{corollary}\label{cor:enabling transfer}
Let  be a path starting from  in the unmarked Petri net of CCS.
If  is complete, then so is .
Moreover, if  is -enabled, for , then so is .
\qed
\end{corollary}

\noindent
\textbf{Proof of \Thm{no fair scheduler}}~
Suppose there \emph{does} exist a CCS expression  as considered in \Thm{no fair scheduler}.
Then it suffices to show that  is a net  as considered in \Thm{no fair PN scheduler}.
Thus, we show that  satisfies the four properties of \Thm{no fair PN scheduler}.
\begin{enumerate}
\item Let  be a complete path of  that has finitely many occurrences of .
  By \Lem{path transfer}  is a path of  that has finitely many occurrences of .
  By \Cor{enabling transfer} it is complete. By Requirement 1 of \Thm{no fair scheduler}, 
  is -enabled. So by \Cor{enabling transfer},  is -enabled.
\item Let  be a complete path of . Then  is a complete path of .
  By Requirement 2 of \Thm{no fair scheduler}, on  each  is followed by a .
  Using \Lem{path transfer}, the same holds for .
\item Let  be a finite path of .
  Then  is a path of .
  By Requirement 3 of \Thm{no fair scheduler}, on , and thus on , are no
  more occurrences of  than of .
\item Let  be a path of , featuring two occurrences of  and  ().
  These occurrences also occur on .
  By Requirement 4 of \Thm{no fair scheduler}, an action  occurs between them.
\qed
\end{enumerate}

\section{Concluding Remarks}\label{sec:conclusion} 
\newcommand{\prio}{\mathbin{\rhd}}
This paper presented a simple fair scheduler---one that in suitable variations occurs in many
distributed systems---of which no implementation can be expressed in CCS\@.
In particular, Dekker's and Peterson's mutual exclusion protocols cannot be rendered correctly in CCS.
These conclusions remain true if CCS is extended with progress and certain fairness assumptions, namely justness as presented in this paper.
However, as shown in~\cite{CorradiniEtAl09}, it is possible to correctly render Dekker's
protocol---and thereby a fair scheduler---in CCS enriched with a stronger fairness assumption. 
We argue, however, that such fairness assumptions should not be made lightly, as in certain contexts they
allow the derivation of false results.

It does not appear hard to extend CCS with an operator that enables expressing this fair
scheduler without relying on a fairness assumption.
In \cite{GH14} for instance we give a simple specification of a fair scheduler in an extension of
CCS with broadcast communication. In \cite{CDV09} it is shown that it suffices (for the correct specification
of Dekker's algorithm) to extend a CCS-like process algebra with non-blocking reading actions.
A priority mechanism \cite{CLN01} would also be sufficient.

Let  for instance be a +-like operator that schedules an action from its left argument if
possible, and otherwise runs its right argument. Then , with

appears to be a fair scheduler. Here
 is the CCS-context specified in \Sect{characterisation}.

 is basically a round-robin scheduler which checks whether  is enabled; if so, it performs
the sequence ; if not, it does an internal action and tries to perform .

An interesting question is what kind of extension of CCS is needed to enable specifying all
processes of this kind. It appears that the formalism CCS+LTL that we employed in \Sect{fair spec} to
specify our fair scheduler can be used to specify a wide range of similar systems.
Such a specification combines a CCS specification with a fairness component, consisting
of a set of LTL formulas that narrows down the complete paths of the specified process.
An intriguing challenge is to find an extension of CCS, say by means of extra operators,
that makes the fairness component redundant, i.e.\ an extension such that any CCS+LTL process can be expressed in
the extended CCS without employing a fairness component.


For certain properties of the form 
where the  and  are action occurrences---hence for specific strong fairness properties---one can
define a \emph{fairness operator} that
transforms a given LTS into a LTS that satisfies the property~\cite{PuhakkaValmari01}.
This is done by eliminating all the paths that do not satisfy the property via a carefully designed parallel composition. 
The fairness operator can be expressed in a variant of the process algebra CSP\@.
The question above asks whether something similar can be done, in a more expressive process algebra,
for arbitrary LTL properties, or perhaps for a larger class of fairness properties.

 \begin{acknowledgements}
We gratefully thank the anonymous referees. Their reports showed deep insights in the
material, and helped a lot to improve the quality of the paper. In particular, the link between our fair
scheduler and Peterson's mutual exclusion protocol was made by one of the referees.
 \end{acknowledgements}

\newcommand{\Ruediger}{-R.}
\def\SSort#1{}\def\NSort#1{}
\begin{thebibliography}{10}
\providecommand{\url}[1]{{#1}}
\providecommand{\urlprefix}{URL }
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{DOI~\discretionary{}{}{}#1}\else
  \providecommand{\doi}{DOI~\discretionary{}{}{}\begingroup
  \urlstyle{rm}\Url}\fi

\bibitem{AcetoEtAl07}
Aceto, L., Ing\'{o}lfsd\'{o}ttir, A., Larsen, K.G., Srba, J.: Modelling mutual
  exclusion algorithms.
\newblock In: Reactive Systems: Modelling, Specification and Verification, pp.
  142--158. Cambridge University Press (2007).
\newblock \doi{10.1017/CBO9780511814105.008}

\bibitem{AFK88}
Apt, K.R., Francez, N., Katz, S.: Appraising fairness in languages for
  distributed programming.
\newblock Distributed Computing \textbf{2}(4), 226--241 (1988).
\newblock \doi{10.1007/BF01872848}

\bibitem{BB96}
Baeten, J.C.M., Bergstra, J.A.: Discrete time process algebra.
\newblock Formal Aspects of Computing \textbf{8}(2), 188--208 (1996).
\newblock \doi{10.1007/BF01214556}

\bibitem{BBK87a}
Baeten, J.C.M., Bergstra, J.A., Klop, J.W.: On the consistency of {Koomen's}
  fair abstraction rule.
\newblock Theoretical Computer Science \textbf{51}(1/2), 129--176 (1987).
\newblock \doi{10.1016/0304-3975(87)90052-1}

\bibitem{BBK87b}
Baeten, J.C.M., Bergstra, J.A., Klop, J.W.: Ready-trace semantics for concrete
  process algebra with the priority operator.
\newblock Computer Journal \textbf{30}(6), 498--506 (1987).
\newblock \doi{10.1093/comjnl/30.6.498}

\bibitem{BLT11}
Baeten, J.C.M., Luttik, B., van Tilburg, P.: Reactive {Turing} machines.
\newblock In: O.~Owe, M.~Steffen, J.A. Telle (eds.) Fundamentals of Computation
  Theory, pp. 348--359 (2011).
\newblock \doi{10.1007/978-3-642-22953-4\_30}

\bibitem{BK86}
Bergstra, J.A., Klop, J.W.: Algebra of communicating processes.
\newblock In: J.W. de~Bakker, M.~Hazewinkel, J.K. Lenstra (eds.) Mathematics
  and Computer Science, CWI Monograph 1, pp. 89--138. North-Holland (1986)

\bibitem{BergstraKlop85}
Bergstra, J.A., Klop, J.W.: Verification of an alternating bit protocol by
  means of process algebra.
\newblock In: W.~Bibel, K.P. Jantke (eds.) Mathematical Methods of
  Specification and Synthesis of Software Systems '85, \emph{\rm LNCS}, vol.
  215, pp. 9--23. Springer (1986).
\newblock \doi{10.1007/3-540-16444-8\_1}

\bibitem{BB87}
Bolognesi, T., Brinksma, E.: Introduction to the {ISO} specification language
  {LOTOS}.
\newblock Computer Networks \textbf{14}, 25--59 (1987).
\newblock \doi{10.1016/0169-7552(87)90085-7}

\bibitem{Bouali91}
Bouali, A.: Weak and branching bisimulation in {Fctool}.
\newblock Research Report RR-1575, Inria-Sophia Antipolis (1992).
\newblock \urlprefix\url{https://hal.inria.fr/inria-00074985/document}

\bibitem{BHR84}
Brookes, S.D., Hoare, C.A.R., Roscoe, A.W.: A theory of communicating
  sequential processes.
\newblock J. ACM \textbf{31}(3), 560--599 (1984).
\newblock \doi{10.1145/828.833}

\bibitem{CLN01}
Cleaveland, R., L{\"u}ttgen, G., Natarajan, V.: Priority in process algebra.
\newblock In: J.A. Bergstra, A.~Ponse, S.A. Smolka (eds.) Handbook of Process
  Algebra, chap.~12, pp. 711--765. Elsevier (2001).
\newblock \doi{10.1016/B978-044482830-9/50030-8}

\bibitem{CBV06}
Corradini, F., {Di Berardini}, M.R., Vogler, W.: Fairness of actions in system
  computations.
\newblock Acta Informatica \textbf{43}(2), 73--130 (2006).
\newblock \doi{10.1007/s00236-006-0011-2}

\bibitem{CorradiniEtAl09}
Corradini, F., Di~Berardini, M.R., Vogler, W.: Liveness of a mutex algorithm in
  a fair process algebra.
\newblock Acta Informatica \textbf{46}(3), 209--235 (2009).
\newblock \doi{10.1007/s00236-009-0092-9}

\bibitem{CDV09}
Corradini, F., {Di Berardini}, M.R., Vogler, W.: Time and fairness in a process
  algebra with non-blocking reading.
\newblock In: M.~Nielsen, A.~Kucera, P.B. Miltersen, C.~Palamidessi, P.~Tuma,
  F.D. Valencia (eds.) Theory and Practice of Computer Science ({SOFSEM}'09),
  \emph{\rm LNCS}, vol. 5404, pp. 193--204. Springer (2009).
\newblock \doi{10.1007/978-3-540-95891-8\_20}

\bibitem{CVJ02}
Corradini, F., Vogler, W., Jenner, L.: Comparing the worst-case efficiency of
  asynchronous systems with {PAFAS}.
\newblock Acta Informatica \textbf{38}(11/12), 735--792 (2002).
\newblock \doi{10.1007/s00236-002-0094-3}

\bibitem{CS84}
Costa, G., Stirling, C.: A fair calculus of communicating systems.
\newblock Acta Informatica \textbf{21}, 417--441 (1984).
\newblock \doi{10.1007/BF00271640}

\bibitem{CS87}
Costa, G., Stirling, C.: Weak and strong fairness in {CCS}.
\newblock Information and Computation \textbf{73}(3), 207--244 (1987).
\newblock \doi{10.1016/0890-5401(87)90013-7}

\bibitem{DDM87}
Degano, P., {De Nicola}, R., Montanari, U.: {CCS} is an (augmented) contact
  free {C/E} system.
\newblock In: M.V. Zilli (ed.) Mathematical Models for the Semantics of
  Parallelism, \emph{\rm LNCS}, vol. 280, pp. 144--165. Springer (1987).
\newblock \doi{10.1007/3-540-18419-8\_13}

\bibitem{EWD35}
Dijkstra, E.W.: Over de sequentialiteit van procesbeschrijvingen (1962 or
  1963).
\newblock \urlprefix\url{http://www.cs.utexas.edu/users/EWD/ewd00xx/EWD35.PDF}.
\newblock Circulated privately

\bibitem{EWD123}
Dijkstra, E.W.: Cooperating sequential processes.
\newblock In: F.~Genuys (ed.) Programming Languages: NATO Advanced Study
  Institute, pp. 43--112. Academic Press (1968)

\bibitem{EsparzaBruns96}
Esparza, J., Bruns, G.: Trapping mutual exclusion in the box calculus.
\newblock Theoretical Computer Science \textbf{153}(1-2), 95--128 (1996).
\newblock \doi{10.1016/0304-3975(95)00119-0}

\bibitem{TR13}
Fehnker, A., van Glabbeek, R.J., H{\"o}fner, P., McIver, A.K., Portmann, M.,
  Tan, W.L.: A process algebra for wireless mesh networks used for modelling,
  verifying and analysing {AODV}.
\newblock Tech. Rep. 5513, NICTA (2013).
\newblock Available at \url{http://arxiv.org/abs/1312.7645}

\bibitem{Fr86}
Francez, N.: Fairness.
\newblock Springer (1986).
\newblock \doi{10.1007/978-1-4612-4886-6}

\bibitem{GPSS80}
Gabbay, D.M., Pnueli, A., Shelah, S., Stavi, J.: On the temporal analysis of
  fairness.
\newblock In: P.W. Abrahams, R.J. Lipton, S.R. Bourne (eds.) Principles of
  Programming Languages {(POPL '80)}, pp. 163--173. ACM (1980).
\newblock \doi{10.1145/567446.567462}

\bibitem{vG05d}
van Glabbeek, R.J.: On specifying timeouts.
\newblock In: L.~Aceto, A.D. Gordon (eds.) {\rm Short Contributions from the
  Workshop on} Algebraic Process Calculi: The First Twenty Five Years and
  Beyond, \emph{\rm ENTCS}, vol. 162, pp. 112--113. Elsevier (2005).
\newblock \doi{10.1016/j.entcs.2005.12.083}

\bibitem{vG12}
van Glabbeek, R.J.: Musings on encodings and expressiveness.
\newblock In: B.~Luttik, M.A. Reniers (eds.) {\rm Proceedings Combined 19th
  International Workshop on} Expressiveness in Concurrency {\rm and 9th
  Workshop on} Structured Operational Semantics, \emph{\rm EPTCS}, vol.~89, pp.
  81--98. Open Publishing Association (2012).
\newblock \doi{10.4204/EPTCS.89.7}

\bibitem{GGS11}
van Glabbeek, R.J., Goltz, U., Schicke, J.W.: Abstract processes of
  place/transition systems.
\newblock Information Processing Letters
  \textbf{\hspace{-1pt}111\hspace{-1pt}}(\hspace{-1pt}13\hspace{-1pt}),
  626--633 (\hspace{-1pt}2011\hspace{-1pt}).
\newblock \doi{10.1016/j.ipl.2011.03.013}

\bibitem{GH14}
van Glabbeek, R.J., H{\"o}fner, P.: Progress, fairness and justness in process
  algebra.
\newblock CoRR \textbf{{\normalfont abs/1501.03268}} (2015).
\newblock \urlprefix\url{http://arxiv.org/abs/1501.03268}

\bibitem{GV87}
van Glabbeek, R.J., Vaandrager, F.W.: Petri net models for algebraic theories
  of concurrency.
\newblock In: J.W.d. Bakker, A.J. Nijman, P.C. Treleaven (eds.) Parallel
  Architectures and Languages Europe (PARLE'97), Vol. II: Parallel Languages,
  \emph{\rm LNCS}, vol. 259, pp. 224--242. Springer (1987).
\newblock \doi{10.1007/3-540-17945-3\_13}

\bibitem{GSAS04}
Goldin, D.Q., Smolka, S.A., Attie, P.C., Sonderegger, E.L.: Turing machines,
  transition systems, and interaction.
\newblock Information and Computation \textbf{194}(2), 101--128 (2004).
\newblock \doi{10.1016/j.ic.2004.07.002}

\bibitem{Gorla10a}
Gorla, D.: Towards a unified approach to encodability and separation results
  for process calculi.
\newblock Information and Computation \textbf{208}(9), 1031--1053 (2010).
\newblock \doi{10.1016/j.ic.2010.05.002}

\bibitem{GP95}
Groote, J.F., Ponse, A.: The syntax and semantics of {CRL}.
\newblock In: A.~Ponse, C.~Verhoef, S.F.M. {van Vlijmen} (eds.) Algebra of
  Communicating Processes '94, Workshops in Computing, pp. 26--62. Springer
  (1995).
\newblock \doi{10.1007/978-1-4471-2120-6\_2}

\bibitem{HJ90}
Hansson, H., Jonsson, B.: A calculus for communicating systems with time and
  probabitilies.
\newblock In: Real-Time Systems Symposium (RTSS '90), pp. 278--287. IEEE
  Computer Society (1990).
\newblock \doi{10.1109/REAL.1990.128759}

\bibitem{HennessyRegan95}
Hennessy, M., Regan, R.: A process algebra for timed systems.
\newblock Information and Computation \textbf{117}(2), 221--239 (1995).
\newblock \doi{10.1006/inco.1995.1041}

\bibitem{Ho85}
Hoare, C.A.R.: Communicating Sequential Processes.
\newblock Prentice Hall, Englewood Cliffs (1985)

\bibitem{KW97}
Kindler, E., Walter, R.: Mutex needs fairness.
\newblock Inf. Process. Lett. \textbf{62}(1), 31--39 (1997).
\newblock \doi{10.1016/S0020-0190(97)00033-1}

\bibitem{Kleinrock64}
Kleinrock, L.: Analysis of a time-shared processor.
\newblock Naval Research Logistics Quarterly \textbf{11}(1), 59--73 (1964).
\newblock \doi{10.1002/nav.3800110105}

\bibitem{TLA}
Lamport, L.: The temporal logic of actions.
\newblock ACM Trans. Programming Languages and Systems \textbf{16}(3), 872--923
  (1994).
\newblock \doi{10.1145/177492.177726}

\bibitem{LTS79}
Lauer, P.E., Torrigiani, P.R., Shields, M.W.: {COSY} - a system specification
  language based on paths and processes.
\newblock Acta Informatica \textbf{12}, 109--158 (1979).
\newblock \doi{10.1007/BF00266047}

\bibitem{LW01}
van Leeuwen, J., Wiedermann, J.: Beyond the {Turing} limit: Evolving
  interactive systems.
\newblock In: L.~Pacholski, P.~Ruzicka (eds.) Theory and Practice of
  Informatics (SOFSEM '01), \emph{\rm LNCS}, vol. 2234, pp. 90--109. Springer
  (2001).
\newblock \doi{10.1007/3-540-45627-9\_8}

\bibitem{LPS81}
Lehmann, D.J., Pnueli, A., Stavi, J.: Impartiality, justice and fairness: The
  ethics of concurrent termination.
\newblock In: S.~Even, O.~Kariv (eds.) Automata, Languages and Programming
  (ICALP), \emph{\rm LNCS}, vol. 115, pp. 264--277. Springer (1981).
\newblock \doi{10.1007/3-540-10843-2\_22}

\bibitem{LV01}
L\"{u}ttgen, G., Vogler, W.: A faster-than relation for asynchronous processes.
\newblock In: K.G. Larsen, N.~M. (eds.) Concurrency Theory (CONCUR '01),
  \emph{\rm LNCS}, vol. 2154, pp. 262--276. Springer (2001).
\newblock \doi{10.1007/3-540-44685-0\_18}

\bibitem{LT89}
Lynch, N., Tuttle, M.: An introduction to input/output automata.
\newblock CWI-Quarterly \textbf{2}(3), 219--246 (1989).
\newblock {C}entrum voor Wiskunde en Informatica, Amsterdam, The Netherlands

\bibitem{Mi89}
Milner, R.: Communication and Concurrency.
\newblock Prentice Hall (1989)

\bibitem{MPW92}
Milner, R., Parrow, J., Walker, D.: A calculus of mobile processes, {Part I +
  II}.
\newblock Information and Computation \textbf{100}(1), 1--77 (1992).
\newblock \doi{10.1016/0890-5401(92)90008-4}

\bibitem{rfc970}
Nagle, J.: On packet switches with infinite storage.
\newblock RFC 970, Network Working Group (1985).
\newblock \urlprefix\url{http://tools.ietf.org/rfc/rfc970.txt}

\bibitem{Nagle87}
Nagle, J.: On packet switches with infinite storage.
\newblock IEEE Trans. Communications \textbf{35}(4), 435--438 (1987).
\newblock \doi{10.1109/TCOM.1987.1096782}

\bibitem{Old91}
Olderog, E.{\Ruediger}.: Nets, Terms and Formulas: Three Views of Concurrent
  Processes and their Relationship.
\newblock No.~23 in Cambridge Tracts in Theoretical Computer Science. Cambridge
  University Press (1991)

\bibitem{Parrow08}
Parrow, J.: Expressiveness of process algebras.
\newblock \rm ENTCS \textbf{209}, 173--186 (2008).
\newblock \doi{10.1016/j.entcs.2008.04.011}

\bibitem{Peterson81}
Peterson, G.L.: Myths about the mutual exclusion problem.
\newblock Information Processing Letters \textbf{12}(3), 115--116 (1981).
\newblock \doi{10.1016/0020-0190(81)90106-X}

\bibitem{Plotkin82}
Plotkin, G.D.: A powerdomain for countable non-determinism (extended abstract).
\newblock In: M.~Nielsen, E.M. Schmidt (eds.) Automata, Languages and
  Programming (ICALP '82), \emph{\rm LNCS}, vol. 140, pp. 418--428. Springer
  (1982).
\newblock \doi{10.1007/BFb0012788}

\bibitem{Pnueli77}
Pnueli, A.: The temporal logic of programs.
\newblock In: Foundations of Computer Science {(FOCS '77)}, pp. 46--57. IEEE
  (1977).
\newblock \doi{10.1109/SFCS.1977.32}

\bibitem{CBS}
Prasad, K.V.S.: A calculus of broadcasting systems.
\newblock Science of Computer Programming \textbf{25}(2-3), 285--327 (1995).
\newblock \doi{10.1016/0167-6423(95)00017-8}

\bibitem{PuhakkaValmari01}
Puhakka, A., Valmari, A.: Liveness and fairness in process-algebraic
  verification.
\newblock In: K.G. Larsen, M.~Nielsen (eds.) Concurrency Theory (CONCUR'01),
  \emph{\rm LNCS}, vol. 2154, pp. 202--217. Springer (2001).
\newblock \doi{10.1007/3-540-44685-0\_14}

\bibitem{ReedRoscoe86}
Reed, G.M., Roscoe, A.W.: A timed model for communicating sequential processes.
\newblock In: L.~Kott (ed.) Automata, Languages and Programming (ICALP '86),
  \emph{\rm LNCS}, vol. 226, pp. 314--323. Springer (1986).
\newblock \doi{10.1007/3-540-16761-7\_81}

\bibitem{Re85}
Reisig, W.: Petri nets -- an introduction.
\newblock {EATCS} Monographs on Theoretical Computer Science, Volume 4.
  Springer (1985).
\newblock \doi{10.1007/978-3-642-69968-9}

\bibitem{Va93}
Vaandrager, F.W.: Expressiveness results for process algebras.
\newblock In: J.W. de~Bakker, W.P. de~Roever, G.~Rozenberg (eds.) Proceedings
  REX Workshop on Semantics: Foundations and Applications, \emph{\rm LNCS},
  vol. 666, pp. 609--638. Springer (1993).
\newblock \doi{10.1007/3-540-56596-5\_49}

\bibitem{Valmari96}
Valmari, A., Set\"{a}l\"{a}, M.: Visual verification of safety and liveness.
\newblock In: M.~Gaudel, J.~Woodcock (eds.) Industrial Benefit and Advances in
  Formal Methods (FME'96), \emph{\rm LNCS}, vol. 1051, pp. 228--247. Springer
  (1996).
\newblock \doi{10.1007/3-540-60973-3\_90}

\bibitem{Vogler02}
Vogler, W.: Efficiency of asynchronous systems, read arcs, and the
  {MUTEX}-problem.
\newblock Theor. Comput. Sci. \textbf{275}(1-2), 589--631 (2002).
\newblock \doi{10.1016/S0304-3975(01)00300-0}

\bibitem{Walker89}
Walker, D.J.: Automated analysis of mutual exclusion algorithms using {CCS}.
\newblock Formal Aspects of Computing \textbf{1}(1), 273--292 (1989).
\newblock \doi{10.1007/BF01887209}

\bibitem{Wegner97}
Wegner, P.: Why interaction is more powerful than algorithms.
\newblock Commununications of the ACM \textbf{40}(5), 80--91 (1997).
\newblock \doi{10.1145/253769.253801}

\end{thebibliography}

\end{document}
