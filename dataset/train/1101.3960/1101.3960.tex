\documentclass[11pt]{article}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{comment}
\usepackage{anysize}
\usepackage{epic}
\usepackage{eepic}
\usepackage{xcolor}
\usepackage{booktabs}

\usepackage[all,color,frame,import]{xy}
\newcommand{\tab}{\hspace{.25in}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{fact}{Fact}[section]
\newtheorem{observation}{Observation}[section]

\newcommand{\qed}{\hfill\mbox{}}
\newcommand\QED{\ifhmode\allowbreak\else\nobreak\fi
\quad\nobreak\medbreak}

\newcommand{\proofstart}{\par\noindent \emph{Proof:} }
\newcommand{\proofend}{\QED\par}
\newenvironment{proof}{\proofstart}{\proofend}

\usepackage[letterpaper,hmargin=1in,vmargin=1in]{geometry}



\bibliographystyle{habbrv}



\newcommand{\opti}{\mbox{OPT}}
\newcommand{\heui}{\mbox{HEU}}
\newcommand{\peqnp}{\mbox{{P}~~{NP}}}
\newcommand{\alga}{\mbox{}}


\long\gdef\boxit#1{\vspace{5mm}\begingroup\vbox{\hrule\hbox{\vrule\kern5pt
\vbox{\kern5pt#1\kern5pt}\kern0pt\vrule}\hrule}\endgroup}

\begin{document}

\title{Speedup in the Traveling Repairman Problem with Constrained Time Windows}
\author{Greg N. Frederickson\thanks{Dept. of Computer Sciences, Purdue University, West Lafayette,
    IN 47907. {\tt gnf@cs.purdue.edu}} \and Barry Wittman\thanks{Dept. of Computer Science, Elizabethtown College, Elizabethtown,
    PA 17022. {\tt wittmanb@etown.edu}}
}

\maketitle




\begin{abstract}
A bicriteria approximation algorithm is presented for the unrooted traveling repairman problem, realizing increased profit in return for increased speedup of repairman motion.  The algorithm generalizes previous results from the case in which all time windows are the same length to the case in which their lengths can range between l and 2.  This analysis can extend to any range of time window lengths, following our earlier techniques \cite{Frederickson6}.
This relationship between repairman profit and speedup is applicable over a range of values that is dependent on the cost of putting the input in an especially desirable form, involving what are called ``trimmed windows.''  For time windows with lengths between 1 and 2, the range of values for speedup  for which our analysis holds is .  In this range, we establish an approximation ratio that is constant for any specific value of .\\

\noindent\emph{Key words:} Approximation algorithms, time windows, traveling repairman, TSP
\end{abstract}

\section{Introduction}

In this paper we present an approximation algorithm for a practical time-sensitive routing problem, the unrooted traveling repairman problem with time windows.  The input to this problem is a speed at which a repairman can travel and a list of {\em service requests}.  Each service request is located at a node in a weighted metric graph, whose edges give the travel distance between nodes.  Each service request also has a specific time window during which it is valid for service.  The goal of the problem is to plan a route called a {\em service run} that, starting at any service request at any time, visits as many service requests as possible during their respective time windows.

Because the problem is NP-hard, our only hope for an efficient approach seems to be an approximation algorithm.
In the real world, a repairman may have some flexibility in choosing speed.  As a consequence, our earlier approximation algorithms \cite{Frederickson5} and this paper are parameterized by speedup , so that we can characterize how much closer to optimal the repairman can do if he or she travels a factor of  faster than a hypothetical repairman traveling along an optimal route at the baseline speed.  This type of approximation based on resource augmentation is well known in the scheduling community as shown by Bansal et al.~\cite{Bansal2}, Kalyanasundaram and Pruhs \cite{Kalyanasundaram}, and Phillips et al.~\cite{Phillips}.

The algorithms in this paper build on our earlier work \cite{Frederickson3, Frederickson6}, in which we introduced the first polynomial-time algorithms that give constant approximations to the traveling repairman problem when all the time windows are the same length.  As a counterpoint to the repairman problem, we also introduced the speeding deliveryman problem in \cite{Frederickson3, Frederickson6}, with an alternative optimization paradigm, namely speedup.  The input to the speeding deliveryman problem is the same as the input to the traveling repairman problem, but the goal is to find the minimum speed necessary to visit {\em all} service requests during their time windows and thus collect all profit.  In \cite{Frederickson6} we also gave constant-factor polynomial-time approximation algorithms for both problems when the time windows have lengths in some fixed range.

In both the repairman and deliveryman problems, our algorithms \cite{Frederickson3, Frederickson6} rely on {\em trimming} windows so that the resulting time windows are pairwise either identical or non-overlapping .  We trim time windows by repeatedly making divisions in time after a fixed amount of time has passed, starting at a specified time.  We define a {\em period} to be the time interval that starts at a particular division and continues up to the next division.  When time windows are unit length, we choose a period length of .5 time units.  Because we define periods so that no window starts on a period boundary, each time window will completely overlap exactly one period and partially overlap its two neighboring periods.  Trimming then removes those parts of each window that fall outside of the completely overlapped period.

In this simpler case where time windows all have the same length, the penalty for trimming the repairman is a reduction by a factor of  in the number of requests serviced, 
and the penalty for the deliveryman is an increase by a factor of 4 in the speed needed to service all requests.
In \cite{Frederickson5}, we showed that, for unit time windows, a spectrum of performance is possible between these two extremes.
For some speedup  greater than 1 but less than 4, we showed how to achieve an increase in the number of serviced requests,
proportional in some sense to .  The approximation is also a function of graph property , where  for a tree and  is no more than  for a metric graph, for any constant .  A more complete explanation of  is given in Sect.~\ref{section:trimming}.

In this paper, we extend our algorithms and analysis to the more challenging case in which time windows have lengths in some fixed range, specifically between 1 and 2.
We present an algorithm that finds approximations parameterized by speedup  and property .
To prove these approximation bounds, our analysis establishes and takes advantage of the \textbf{existence} of an ensemble of runs that move backward and forward along the path of an (unknown) optimal run, similar to our work in \cite{Frederickson5}.  These runs are analyzed based on several different starting points for trimming.  To handle windows of different lengths (i.e., between 1 and 2),
we orchestrate several complementary trimming schemes, run our approximation algorithm on each combination,
and choose the best result.

On the surface, the approach we use to orchestrate trimming schemes is similar to our approach in \cite{Frederickson6}, which extended our earlier approximation algorithms from \cite{Frederickson3} to achieve a constant approximation on time windows whose lengths were between 1 and 2.  However, the similarity of the algorithms belies the fundamental difference in the analysis, whose complexity increases by at least an order of magnitude in the process of uniting speedup with non-uniform time windows.  The key to our algorithm remains using a different period length for each trimming scheme, with each subsequent scheme using a progressively longer period length.  Intuitively, by selecting the most profitable run found in any scheme, the algorithm adapts to different distributions of window sizes.  If most of the windows are short, a scheme of trimming to shorter lengths will be effective.  If most of the windows are long, a scheme of trimming to longer lengths will be effective.  Because the output of each trimming scheme is a set of trimmed windows of equal length, our speedup algorithms from \cite{Frederickson5} can then be applied directly.  As with the case of no speedup, we bound the approximation guarantee of our algorithm by  accounting for a variety of distributions of windows, but the tool needed to bound each distribution is now a considerably richer set of hypothetical runs.

The major contributions of this paper are two additional techniques needed to extend the analysis for speedup on unit-time windows to windows with non-uniform length.  The first technique is a significantly more complex design of ensembles to achieve good coverage, using a greater variety of runs, some of which have longer repeating patterns.  Once we select an appropriate ensemble, we use a symbolic description of the coverage of the runs in the ensemble to demonstrate good coverage for all speedups in the range of speedups under consideration.  The second technique is an approach for designing and coordinating together the different bounds of approximation as a function of speedup for different window lengths.  Using averaging arguments, we will show that any convex combination of the approximation guarantees for each trimming scheme is a lower bound on the profit of the best run produced by our algorithm.  For each range of speedups in question, we determine the best choices of weightings for a convex combination of the approximation bounds we have found.  By using the best convex combination of bounds from each scheme, we guarantee a good bound of approximation.  The details of these techniques are given for the case when window size is between 1 and 2, but other ranges of window size can be accommodated in a similar way.

As a result, we can still produce polynomial-time approximation algorithms with constant-factor approximations for a given  over a significant speedup range.
Our process of combining together different approximation bounds, as a function of the speedup , gives a final result in Table~\ref{table:speedupw12rats} that is more involved than our results in \cite{Frederickson5}.  The ratio has more piecewise ranges and its inverse is primarily nonlinear, even though the inverse of the ratio in each range is fairly close to a linear function.  Note that approximation ratios are typically defined to be at least 1, and so these approximation ratios will give the reciprocal of the fraction of profit collected at a given speedup.  For ease of presentation, most of the analysis in this paper will instead be in terms of the fraction of profit collected.

\medskip

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{cc}
\underline{Upper Bound on Approximation Ratio} & \underline{Speedup} \medskip \\
 &

\end{tabular}\\
\caption{Approximation ratios for speedup  when time window lengths are between 1 and 2.}
\label{table:speedupw12rats}
\end{center}
\end{table}

Our results are recent developments in time-sensitive routing problems, which have received a lot of attention from the algorithms community in the last decade.  As with our particular problem, these problems typically identify the locations to be visited and the cost of traveling between them as the nodes and edges, respectively, of a weighted graph.  For example, the orienteering problem considered by Arkin et al.~\cite{Arkin}, Bansal et al.~\cite{Bansal}, Blum et al.~\cite{Blum3}, Chekuri et al.~\cite{Chekuri2}, and Chen and Har-Peled \cite{Chen} seeks to find a path that visits as many nodes as possible before a global time deadline.  The deadline traveling salesman problem which was also considered by Bansal et al.~\cite{Bansal} generalizes this problem further by allowing each location to have its own deadline.  Our traveling repairman problem can be viewed as a further generalization from a deadline to a time window.  


A great deal of work by Bansal et al.~\cite{Bansal}, Bar-Yehuda et al.~\cite{Bar-Yehuda}, Chekuri and Kumar \cite{Chekuri}, Karuno et al.~\cite{Karuno3}, Tsitsiklis \cite{Tsitsiklis}, and the authors \cite{Frederickson6} has been done on the traveling repairman problem, although much of the preceding literature, including that from Bansal et al.~\cite{Bansal} and  Bar-Yehuda et al.~\cite{Bar-Yehuda}, considers the rooted version of the problem, in which the repairman starts at a specific location at a specific time. 

For general time windows in the rooted problem, an -approximation is given by Bansal et al.~\cite{Bansal}.  An -approximation is given by Chekuri and Korula \cite{Chekuri3}, for the case that all time window start and end times are integers, where  is the length of the longest time window.  In contrast, a constant approximation is given by Chekuri and Kumar \cite{Chekuri},
but only when there are a constant number of different time windows.  Our earlier work \cite{Frederickson6} and work by Chekuri and Korula \cite{Chekuri3} give -approximations to the unrooted problem with general time windows, where  is the ratio of the length of largest time window to the length of the smallest.  Polylogarithmic approximation algorithms for the directed traveling salesman problem with time windows have also been given by Chekuri et al.~\cite{Chekuri2} and Nagarajan and Ravi \cite{Nagarajan2}.

\section{Trimming Time Windows and the Associated Loss}
\label{section:trimming}

In our earlier work \cite{Frederickson6, Frederickson5}, we trimmed time windows of unit length by first making divisions in time every  time units, starting at time 0.  We generalize the process for time windows with different lengths by instead making divisions every  time units, where , , or  for the range of time window lengths .
Define a {\em period} to be the time interval that starts at a particular division and continues up to the next division.  In the case of unit time windows, each time window will completely overlap exactly one period and partially overlap its two neighboring periods, because we allow no window to start on a period boundary.  In the case of longer time windows, there will be different patterns of overlapping.  If a window completely overlaps with only one period, trimming will remove those parts of each window that fall outside of the completely overlapped period.  If a window completely overlaps with more than one period, one trimming scheme will remove all those parts of each such window that fall outside of the first completely overlapped period.  Another separate trimming scheme will remove all those parts of each such window that fall outside of the second completely overlapped period.  For long period sizes, some time windows may not completely overlap {\em any} full periods and will vanish in the process of trimming.  In each case, because periods do not overlap and a time window is trimmed to at most one period, trimmed time windows will be pairwise either identical or non-overlapping.  Our repairman algorithm in \cite{Frederickson6} identifies a variety of good paths inside each separate period and then uses dynamic programming to select and paste these paths together into a variety of longer good paths and ultimately a good service run for the whole problem.

To describe our results for both trees and general metric graphs, we use the graph property , where  for a tree, derived in our earlier paper \cite{Frederickson6}, and  for a metric graph, derived by Chekuri et al.~\cite{Chekuri2}, for any constant .  To describe the running time for these repairman algorithms we use , where  is  for a tree and  for a metric graph.  The value of  and running time of  are dependent on the approximation bounds for finding maximum profit paths within a specific period on a specific class of graph.  Although the available results only give  values and  running times for trees and metric graphs, other classes of graphs, such as outerplanar or Euclidean graphs, may have intermediate values of  and .  

In \cite{Frederickson6} we showed that, for unit time windows with no speedup, the reduction due to trimming still allows us to visit at least  of the pre-trimming optimal and, with a speedup of 4, we can visit at least  of the pre-trimming optimal.  In \cite{Frederickson5} we filled in the gap between these two extremes with an -approximation for speedup in the range  and a -approximation for speedup in the range .  We continue to demonstrate the flexibility of trimming in the realm of speedup by extending these results to time windows with different lengths.


\section{The Ensemble Approach for Analyzing Performance}
\label{section:ensemble}

Given an instance of the repairman problem on unit time windows, our previous work \cite{Frederickson5} presented algorithms for rational speedup  in the range  that take  time, where  is the number of distinct periods.  Since the approximation function is smooth and continuous, those algorithms work for any real speedup , in the same range, in   time.  

The analysis of these algorithms uses a number of different service runs on trimmed time windows that are based on moving backward and forward along an optimal tour .  We rely on averaging over a suitable ensemble of runs to establish that some run  on trimmed time windows does well.  Because we will build on this technique and, indeed, use some of the same runs from our earlier work \cite{Frederickson5} in ensembles for variable length windows, we will review our notation for describing these runs.

We define unit speed to be some reference speed.  Traveling with  is traveling at unit speed.  Our results will hold whenever unit speed is no faster than the slowest speed at which an optimal service run is able to visit all locations during their time windows.  Intuitively, this restriction means that we are focusing on those cases when unit speed is low enough that speeding up our service runs will actually give some benefit.
Let  be an optimal service run at unit speed originally starting at time 0.

In our analysis
we use the term {\em racing} to describe movement, forwards and backwards, along  at a speedup of  times unit speed.  Note that our analysis of run coverage is described on a period length of  even though, in Sect.~\ref{section:performance of speedupw12}, we will apply this analysis to our algorithm, which uses three different period lengths.

Define service run  as follows.  Start run  at time  at the location that  has at time .  Then run  follows a pattern of racing forward along  for  period, racing backward along  for  periods, and then racing forward along  for  periods.  Note that the pattern of movement for run  repeats every 2 periods.

Considering the problem in which windows have length between 1 and 2, let  be an upper bound on the number of periods fully contained in a window. Define , the ``\emph{reverse}'' of , as follows.  When run on a set of requests whose windows each fully contain at most  periods, run  starts at time  at the location that  has at time .  Then run  follows a repeating pattern of racing forward along  for  periods, racing backward along  for  periods, and then racing forward along  for  period.  Figure \ref{figure:s=2} shows examples of runs  and  with a speedup of 2 when .

\begin{figure}[!hbt]
\centering
\begin{xy}
\xyimport(397, 155){\includegraphics[width=.75\textwidth]{2speedup.eps}}
(2,60)*!R\txt\footnotesize{Run };
(-5,4)*!R\txt\footnotesize{Optimal Run };
(-5,106)*!R\txt\footnotesize{Run };
(41,104)*\txt\scriptsize{};
(120,107)*\txt\scriptsize{};
(120,136)*\txt\scriptsize{};
(196,126)*\txt\scriptsize{};
(276,116)*\txt\scriptsize{};
(276,144)*\txt\scriptsize{};
(352,153)*\txt\scriptsize{};
(196,58)*\txt\scriptsize{};
(196,90)*\txt\scriptsize{};
(276,77)*\txt\scriptsize{};
(352,89)*\txt\scriptsize{};
(352,118)*\txt\scriptsize{};
(80,8)*\txt\footnotesize{};
(157,5)*\txt\footnotesize{};
(236,18)*\txt\footnotesize{};
(314,15)*\txt\footnotesize{};
(-4,-7)*\txt\footnotesize{};
(392,28)*\txt\footnotesize{};
(1,78)*\txt\scriptsize{};
(164,104)*\txt\scriptsize{};
(158,127)*\txt\scriptsize{};
(324,130)*\txt\scriptsize{};
(314,149)*\txt\scriptsize{};
(157,57)*\txt\scriptsize{};
(150,79)*\txt\scriptsize{};
(314,80)*\txt\scriptsize{};
(302,100)*\txt\scriptsize{};
\end{xy}
\caption{Examples of runs  and  with a speedup of 2 when  based on an optimal run.  Times are labeled on the optimal run as well as runs  and .  Segments of each run are also designated , , and  depending on which subset of runs they add coverage to.  This subset naming scheme will be fully explained in Sect.~\ref{section:lengths12}.}
\label{figure:s=2}
\end{figure}

For the purposes of analyzing our run , number the periods , , , and so on by the integer multiples of  that give their starting times.  Run  repeats every 2 periods, and its coverage varies depending on whether the period number is even or odd.  To balance this asymmetry we define  and , shifted versions of  and , respectively.  Run  follows the same pattern as  but starts the pattern at time  at the location  has at time 0.  Run  follows the same pattern as  but starts the pattern at time  at the location  has at time .

Our analysis will require several versions of  that have different starting points.  To simplify notation, for any given rational speedup , let a {\em hop} be the amount of distance traveled in  time at unit speed.  Let  be the run  moved forward  hops and let run  be the run  moved backward  hops. Run  follows the same pattern of movement as run  but starts at time  at the location that  has at  time .  Run , the reverse of , follows the same pattern of movement as  but starts at  at the location that  has at .  These reversed and shifted versions of  were required to establish the performance of our algorithms in \cite{Frederickson5} on unit length windows.  Although run  with its 2-period repeating pattern is sufficient for those cases, we will introduce additional runs which repeat after 3 or 4 periods in order to handle windows of longer length.

If a service request  is serviced by a run  during the period that the time window of  has been trimmed into, we say that  {\em covers} .
Let  be a subset of service requests.  Define the {\em coverage} of  by a run , written , to be the number of requests in  covered by  divided by the number of requests in .  Define the coverage of  by a set  of runs, written , to be the average of  for every run .

We will still rely on our Average Coverage Proposition from our earlier work \cite{Frederickson5}:

\begin{proposition}[Average Coverage] \label{proposition:averaging}  Let  be a collection of sets of service requests such that  gives all the service requests serviced by  on untrimmed windows.  Let  be a set of service runs.  If , then there is at least one service run  such that profitprofit.
\end{proposition}

The Average Coverage Proposition formalizes the following intuition.  Let a group of service runs achieve some coverage over a set of requests.  Let us also say that we have divided those requests into many different subsets, some of which may overlap, but the union of all the subsets is the original set of requests.  If we take the subset of requests with the worst average coverage, some service run in the group covers a fraction of total requests no smaller than that worst average coverage.  Otherwise, the average coverage of all subsets would be worse than the coverage of the worst covered subset, which is a contradiction.

Given a way of dividing requests into subsets, we wish to prove that some set of service runs achieves some lower bound on average coverage.  The following section will describe the algorithm we will use to find a service run and the analytical techniques we will use to establish a lower bound on its performance.  This analysis will depend on carefully showing an average coverage for various subsets of requests defined with respect to periods induced by trimming. 


\section{Algorithm for Windows with Lengths between 1 and 2}
\label{section:lengths12}

In \cite{Frederickson6}, we describe algorithms for  that achieve constant approximations when window sizes are not necessarily uniform
but are close to being uniform.
We extend that approach for our speedup problem,
but specifically for windows whose lengths differ by at most a factor of 2.  From \cite{Frederickson5}, we give an algorithm called SPEEDUP that, for unit windows, finds a run of approximately optimal profit at speedup .
Our approach is to modify SPEEDUP  and run it with three different sizes of period : .5, .75, and 1.

For each period size, we will consider multiple starting points for a set of periods, each spaced .25 apart.  
We modify SPEEDUP appropriately so that no window starts at the beginning of a period, for periods of size .5, .75, or 1.  This modified algorithm is called SPEEDUPW12 and is specified below.
In this algorithm, sets of periods whose  is .5, .75, or 1 can have 2, 3, or 4 unique starting positions, respectively.  
Depending on a given period size  and starting point, a window will partially fill 2 periods 
and fully fill 0, 1, 2, or 3 periods between the 2 partial periods.  For  and a specified value of , let  be the set of windows
that completely fill exactly  subintervals and partially overlap with two more of them.

\begin{table}[!htb]
\begin{tabular}{l}
\toprule
\textbf{SPEEDUPW12}\\
\midrule
\tab {\it PHASE 1:}\\
\tab Set  to .5 and identify windows for sets , , and .\\
\tab For  from  to ,\\
\tab \tab Set the starting point for the periods to .\\
\tab \tab For  from  to 2,\\
\tab \tab \tab For  from  to 3,\\
\tab \tab \tab \tab Trim each window in  to its  subinterval.\\
\tab \tab \tab \tab Trim each window in  to its  subinterval.\\
\tab \tab \tab \tab Trim each window in  to its  subinterval.\\
\tab \tab \tab \tab Run SPEEDUP and retain the best result so far.\\
\tab {\it PHASE 2:}\\
\tab Reset  to .75 and then identify windows for  and .\\
\tab For  from  to ,\\
\tab \tab Set the starting point for the periods to .\\
\tab \tab For  from  to 2,\\
\tab \tab \tab Trim each window in  to its  subinterval.\\
\tab \tab \tab Trim each window in  to its  subinterval.\\
\tab \tab \tab Run SPEEDUP and retain the best result so far.\\
\tab {\it PHASE 3:}\\
\tab Reset  to 1 and then identify windows for .\\
\tab For  from  to ,\\
\tab \tab Set the starting point for the periods to .\\
\tab \tab Trim each window in  to its  subinterval.\\
\tab \tab Run SPEEDUP and retain the best result so far.\\
\bottomrule
\end{tabular}
\end{table}


When trimming, we choose from several choices of which single full subinterval to keep for each window.  For example, for periods of length .5 and for windows in  which would have three full subintervals, the choices for trimming will be to trim the window down to either the first, second, or third full subinterval.  Combining these choices with the two choices associated with windows in  and the single choice in windows in  yields 6 trimmings.

The performance for speedup for windows in  in the range  is the same as the unit time window results given by our work in \cite{Frederickson5}.  In Sect.~\ref{section:performance W_2}, we give the performance for speedup for windows in  in the range .  In Sect.~\ref{section:performance W_3}, we give the performance for speedup for windows in  in the range .  Note that the SPEEDUP subroutine works for any real number ; however, our analysis will assume that  is a rational number such that .  In the case that  is irrational, our analysis holds in the limit because the functions we find that bound performance in terms of  are piecewise smooth and continuous.  It is worth repeating that our analysis uses only a period size of .5 but can still bound the performance of our algorithm with its three different period lengths by using careful accounting of subset coverage.


When dealing with windows of unit length in a previous paper \cite{Frederickson5}, we defined a partition of requests into three sets, based on which period a request was trimmed into versus which period an optimal run  serviced the request in. Set  consists of requests serviced by  in the same period, set  consists of requests serviced by  in the preceding period, and set  consists of requests serviced by  in the following period.  For windows of length between 1 and 2, we need to extend this approach.  We will use a superscripted  to designate that a request that was serviced by  in either the first, second, third, fourth, or fifth periods with which a request overlaps.
For requests in , the sets , , and  will be renamed , , and , respectively.  For requests in  and , we will go further and use designations  through  and  through , respectively. Set  consists of requests serviced by  two periods before the period into which those requests were trimmed, and  consists of those requests serviced three periods earlier.
In the same earlier work \cite{Frederickson5}, we further partitioned , , and  into , , and  for .
In a similar way, we will partition sets , , , , and  into  equal-length divisions, subsets , , , , and , for any given , .

Let  be any time window, where .  Let  be the smallest integer multiple of  that is greater than .  We designate subintervals , , , ,  by , , , , .  For windows of length between 1 and 2 with a given choice of period starting times, all windows fall into set , , or .  In our analysis, there is always an implied factor of  that accounts for the difference between the approximation on a tree and on a metric graph.

We now define a procedure called CREATE-TABLE- that describes the process of determining coverage for a particular speedup  for a particular run moved forward  hops.  This procedure is a generalization of our CREATE-TABLE procedure from \cite{Frederickson5} to .  (Recall that  is an upper bound on the number of periods fully contained in a window.) Note that CREATE-TABLE- is not an algorithm that is run in the process of finding an approximation to a repairman problem with speedup.  Rather, it provides a template that can be used to produce the tables used in analyzing the performance of such approximations.  So that the treatment here is self-contained, we repeat much of our discussion of table construction from \cite{Frederickson5}, modifying it as necessary so that it can also handle the additional types of runs that we will introduce.

Before CREATE-TABLE- can be completely defined, it is necessary to explain the pattern of coverage generated by a run.  For the kind of runs we have seen so far, type  runs, this pattern takes one of two forms.  Let  be a rational number such that .  Type  runs repeat every two periods and thus can be represented with a pattern of coverage that uses a 1 to signify a subset covered every period and a 1/2 to signify a subset covered every other period.

Observe the movement of type  runs, noting that, during its first period, such a run moves forward the same distance that an optimal run moves during  subintervals.  During its second period of time, it moves backward the same distance than an optimal run moves during  subintervals and then forward the same distance than an optimal run moves during  subintervals. Then, the pattern repeats.  When , run , during the first period in its pattern, covers  successive subsets as it moves forward, while in its second period covers  subsets as it moves forward.  Note that those subsets covered as  moves backwards add nothing additional to the coverage.  Thus, this pattern of coverage is represented as  repetitions of 1 and  repetitions of 1/2.  When , run , during the first period in its pattern, covers  subsets subintervals, while in its second period covers  subsets backwards but no new subsets forward.  This pattern of coverage is represented as  repetitions of 1 and  repetitions of 1/2. 

\begin{table}[!hbt]
\begin{tabular}{l}
\smallskip \\
\toprule
\textbf{CREATE-TABLE-(hops )} \\
\midrule
\tab Let the first element of the coverage pattern be indexed at 0.\\
\tab Number the subsets 0 through .\\
\tab Define function  based on the coverage pattern, such that:\\
\tab \tab  \\
\tab Define function  on integers , where :\\
\tab \tab .\\
\tab Define function  on the same domain:\\
\tab \tab .\\
\tab The final coverage function defined by the table is given by .\\
\bottomrule
\end{tabular}
\end{table}

The values that  can take on are dependent on the types of runs used.  For type  runs,  can be 0, 1/2, or 1.  Runs introduced later will have a larger range of values, but it is always the case that .  Note that the functions  and  given in CREATE-TABLE- are piecewise linear functions with ranges dependent on the fundamental pattern of coverage.  Due to its construction, the combination  is also a piecewise linear function and symmetrical.  Thus, only the range  need be listed in tables.\\

Although CREATE-TABLE- gives a procedure for creating a table for a given speedup, we need tables expressed symbolically to prove coverage for a range of speedups.  Instead of using specific numbers, we can leave the basic patterns of subset coverage for a given style of run (such as type  runs) with its shifted version in terms of  and .  By shifting this pattern  times and summing the results together, we account for the different alignments a time window might have with respect to the various subintervals.  This sum is the function , which can be expressed as a piecewise linear function.  Function , which describes reversed runs, can be similarly described.  To combine the two functions symbolically, we sort the end points of the subset ranges from both descriptions together.  If, for the given range of speedups being considered, there are two end points which cannot be ordered, we subdivide the range of speeds so that, in each new speed range, the two end points in question can be ordered.  Once the end points of each subset range have been sorted, combining the descriptions from the normal and reversed functions of the runs is achieved by simply summing each range.  We give an example of this process in Sect.~\ref{subsection:1<s<2 W_2}.


\section{Speedup Performance for Windows in Set }
\label{section:performance W_2}

Recall that  is the set of windows that completely fill exactly two periods.
We will now explore the speedup-performance trade-off for windows in  for all speedups .  For set , our analysis must consider subsets  through .  Throughout our analysis, we will we assign a 1 for full coverage and a  for half coverage of any subset.  When examining the subsets for a given range of speedup values, the values are symmetrical around  when  is even and symmetrical after  when  is odd.  Thus, the tables and proofs we use will not list contributions for subset  where ,  since the contribution at  in these higher ranges is the same as the corresponding contribution at , by symmetry.

\subsection{Speedup  for Windows in Set }
\label{subsection:1<s<2 W_2}

For the range , we can represent any rational speedup  in the form  with integers  and .  For this analysis, we consider service runs , , , , , and , noting that .  Similar to  for , run  covers set  well, run  covers set  well, and the remaining four runs plug the holes left in the spotty coverage of sets  and .

We will pass over the simpler case for  runs and use  runs to give an example of how we construct symbolic coverage tables.  For speedup  where  and , type  runs have a fundamental pattern of coverage of  subsets covered every period followed by  subsets covered every other period.  Adjusting for the offset of  and making  shifted, this pattern yields the values for  and  given in Table \ref{table:F functions for A_r-k runs}.


\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rll}
 &  &

\\ \\
 &  &

\end{tabular}
\end{center}
\caption{Separate coverage functions for  and  in  when .}
\label{table:F functions for A_r-k runs} 
\end{table}


Because  is symmetric about  if  is even and after  if  is odd, we are only interested in the range .  In this range, the sub-ranges  and  for  overlap with the sub-ranges  and  for .  When , then .  In that case, for , , as in the last interval of the middle set of contributions in Table \ref{table:lowcontributions W_2}. When , then .  In that case, for , , as in the last interval of the middle set of contributions in Table  \ref{table:highcontributions W_2}.

Similar analysis for runs  and  and runs  and  produce the rest of Tables \ref{table:lowcontributions W_2} and \ref{table:highcontributions W_2}.  The combined coverages of runs , , , , , , and all of their respective shifted versions are all given in Table \ref{table:lowcontributions W_2} when  and in Table \ref{table:highcontributions W_2} when .

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:lowcontributions W_2}
\end{center}
\end{table}

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = & 
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:highcontributions W_2}
\end{center}
\end{table}

\begin{lemma}\label{lemma:lowestinterval W_2}
If the contributions from  and  are weighted by a factor of 2 and the contributions from , , , and  are weighted by a factor of 1, the yield for all intervals is at least .
\end{lemma}

\begin{proof}
We first consider the case when , consulting Table \ref{table:lowcontributions W_2}.

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is greater than .

If , then the yield for  is , which is at least , since .

If , then the yield for  is .

\noindent We now consider the case when , consulting Table \ref{table:highcontributions W_2}.  

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since .

If , then the yield for  is .

If , then the yield for  is also .
\end{proof}

\begin{theorem}
For , SPEEDUPW12 finds an -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval W_2}, our analysis gives no yield less than .  Since we use two copies each of  and  and a single copy each of , , , and , averaged over  different sets of periods, we apply the Average Coverage Proposition over  runs.  Thus, the fraction of optimal profit obtained is .
\end{proof}

\subsection{Speedup  for Windows in Set }

For the range , we can represent any rational speedup  in the form  with integers  and .  For this analysis, we consider service runs , , , and , noting that .  We will use three copies each of  and  and a single copy each of  and .  Because the generation of the tables and the case analysis needed to show the coverage are involved and of a similar form as Lemma \ref{lemma:lowestinterval W_2}, we have moved these details to Appendix \ref{appendix:2<s<3 W_2}.

\begin{theorem}
For , SPEEDUPW12 finds an -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval 2<s<5/2 W_2}, the yield is at least .  Since three copies each of  and  and a single copy each of  and  are used, averaged over  different sets of periods, the Average Coverage Proposition is applied over  runs.  Thus, the fraction of optimal profit obtained is at least .
\end{proof}

\begin{observation}
\label{observation:speedup}
Given a speedup , we can always simulate with speedup  the runs used in the analysis of speedup  by introducing delays at appropriate points in each run.  Thus, an approximation ratio of  at speedup  is an upper bound on the approximation ratio at speedup .
\end{observation}

By Observation \ref{observation:speedup}, the -approximation for  implies at most a constant -approximation to the repairman problem on windows in set  when .

\subsection{Speedup  for Windows in Set }

For set  with  where , we consider runs , , and their shifts, noting that .
When , runs  and  give full coverage for service requests in subsets of  and  and partial coverage of service requests in , while runs  and  give full coverage for service requests in subsets of  and  and partial coverage of .  When , runs  and  go further by also giving full coverage for service requests in subsets of , while runs  and  also give full coverage for service requests in subsets of .  When , runs  and  give full coverage for service requests in subsets of , , and  and partial coverage of service requests in , while runs  and  give full coverage for service requests in subsets of ,  and  and partial coverage of .  Since the contributions of the  and  runs and their shifted versions tend to balance each other, we can analyze this balance between the two over all possible sets of periods to find a lower bound on the total profit after trimming.

\begin{theorem}
For , SPEEDUPW12 finds a -approximation for windows  in  time.
\end{theorem}

\begin{proof}
For runs  and ,  earns a 1 (denoting full coverage) for each of the  sets of periods where , giving a total of  for each such .  For each , the total decreases by  from the total for .   For runs  and ,  gets 1 for each of the  sets of periods where , giving a total of  for each such .  For each , the total decreases by  from the total for .

The combined contributions of runs , , and their shifted versions is  for .  Contributions from run  are constant, and contributions from run  only increase or stay constant for  where .  Contributions for  for all runs sum to  for .  Thus, the yield for all  is at least .  Since two runs averaged over  different sets of periods are used, the fraction of optimal profit obtained is at least .
\end{proof}


\section{New Types of Runs to Handle Windows in Set }
\label{section:runs for W_3}

In addition to type  runs, which repeat every 2 periods, our analysis of windows in  defines type  and type  runs which repeat every 3 or every 4 periods, respectively.  We define  and  runs only in the range .  Let .

Start run  at  at the location that  has at time .  From there, run  follows a repeating pattern of racing forward along  for  periods, racing backward along  for  periods, and racing forward along  for  periods.  As for run , also start it at  at the location that  has at time .  From there, run  follows a repeating pattern of racing forward along  for  periods and racing backward along  for  periods.

Similar to , we also define  and , the ``reverses'' of runs  and , respectively.  Both runs  and  start at  at the location that  has at time .  From its starting point, run  follows a repeating pattern of racing forward along  for , racing backward along  for  periods, and racing forward along  for  periods.  From its starting point, run  follows a repeating pattern of racing backward along  for  periods and forward along  for  periods.  As with , let  and , respectively, be runs  and  moved forward  hops, and let runs  and , respectively, be runs  and  moved backward  hops.  Runs  and , respectively, follow the same patterns of movement as runs  and  but start at  at the location that  has at  .  Their reverses  and , respectively, follow the same patterns of movement as  and  but start at  at the location that  has at .

As there is for type  runs, there are unique patterns of coverage corresponding to type  and  runs and their reverses.   Recall that .  Note that, for analysis of  and  runs, we choose the smallest values of  and  such that  is even.  Since the number of subsets is determined by , it is necessary for  and  runs to have an even  in order to keep the coverage defined in terms of complete rather than partial subsets.  A type  run moves forward during its first two periods of time the same distance that an optimal run moves during  subintervals.  During its third period of time, it moves backward the same distance that an optimal run moves during  subintervals and then forward the same distance that an optimal run moves during  subintervals.  Then, the pattern repeats.

We recall the list of subsets: ,   ,   ,   ,   ,   .
When , run , during the first period in its pattern, covers  successive subsets as it moves forward.  In the second period, it covers another  subsets moving forward.  Finally, in its third period, it covers  subsets backward but no new subsets forward, since the subsets covered forward were already covered backward.    We see that only the first period in the pattern covers the first  subsets.  Then the first and third period in the pattern cover the next  subsets.  All three periods cover the next  subsets.  The second and third periods cover the next  subsets, and only the second period covers the final  subsets.  This pattern of coverage is represented as  repetitions of 1/3,  repetitions of 2/3,  repetitions of 1,  repetitions of 2/3, and  repetitions of 1/3.

Figure \ref{figure:bspeeds} gives two examples of type  runs for speedups in the range , the only range for which our analysis will employ type  runs.  Observe that the run for  uses the form  in order to conform with the restriction for our analysis that  must be even.  Unlike  runs which repeat every two periods, both the runs in this figure arrive at the same corresponding position at the beginning of every third period, namely at times  and so on.  Portions of runs servicing requests in , , , , and  or various subsets are identified: subsets , , , , and   mapping to quarter periods of  for  and subsets , , , , , , and  mapping to a fifth of a period of  for .  Focusing on the example of  where  and , note that, during a three-period section, subsets  through  are covered a single time, subsets , , and  are covered twice, subsets , , , and  are covered all three times, subsets  and  are covered twice, and subsets  through  are covered a single time.  This pattern of 3 repetitions of 1/3, 3 repetitions of 2/3, 4 repetitions of 1, 2 repetitions of 2/3, and 4 repetitions of 1/3 exactly corresponds to the repeating pattern of subset coverage described in the previous paragraph.


\begin{figure}[!hbt]
\centering
\begin{xy}
\newxycolor{white}{1 gray}
\xyimport(533, 208){\includegraphics[width=.80\textwidth]{bspeeds.eps}}
(-24,135)*!R\txt\footnotesize{Run  for};
(-24,117)*!R{\large s = {5\over 2} = {10 \over 4}};
(-24,62)*!R\txt\footnotesize{Run  for};
(-24,44)*!R{\large s = {13 \over 5}};
(-24,8)*!R\txt\footnotesize{Optimal};
(-24,-4)*!R\txt\footnotesize{Run };
(-6,-10)*\txt\footnotesize{};
(76,4)*\txt\footnotesize{};
(149,1)*\txt\footnotesize{};
(225,13)*\txt\footnotesize{};
(300,10)*\txt\footnotesize{};
(374,23)*\txt\footnotesize{};
(449,25)*\txt\footnotesize{};
(523,19)*\txt\footnotesize{};
(1,116)*\txt\scriptsize{};
(187,146)*\txt\scriptsize{};
(383,164)*\txt\scriptsize{};
(225,176)*\txt\scriptsize{};
(411,190)*\txt\scriptsize{};
(448,205)*\txt\scriptsize{};
(1,45)*\txt\scriptsize{};
(193,78)*\txt\scriptsize{};
(397,94)*\txt\scriptsize{};
(225,105)*\txt\scriptsize{};
(419,118)*\txt\scriptsize{};
(448,133)*\txt\scriptsize{};
(40,142)*\txt\scriptsize{};
(115,154)*\txt\scriptsize{};
(197,131)*\txt\tiny{};
(213,137)*\txt\tiny{};
(160,124)*\txt\tiny{};
(179,124)*\txt\tiny{};
(210,175)*\txt\tiny{};
(263,133)*\txt\scriptsize{};
(263,151)*\txt\scriptsize{};
(263,169)*\txt\scriptsize{};
(339,144)*\txt\scriptsize{};
(339,160)*\txt\scriptsize{};
(339,177)*\txt\scriptsize{};
(423,171)*\txt\tiny{};
(438,169)*\txt\tiny{};
(384,185)*\txt\tiny{};
(399,187)*\txt\tiny{};
(437,206)*\txt\tiny{};
(488,166)*\txt\scriptsize{};
(488,184)*\txt\scriptsize{};
(488,201)*\txt\scriptsize{};
(40,71)*\txt\scriptsize{};
(115,83)*\txt\scriptsize{};
(263,62)*\txt\scriptsize{};
(263,80)*\txt\scriptsize{};
(263,97)*\txt\scriptsize{};
(339,73)*\txt\scriptsize{};
(339,89)*\txt\scriptsize{};
(339,106)*\txt\scriptsize{};
(203,62)*\txt\tiny{};
(218,68)*\txt\tiny{};
(158,54)*\txt\tiny{};
(173,51)*\txt\tiny{};
(188,55)*\txt\tiny{};
(210,103)*\txt\tiny{};
(383,79)*\txt\tiny{};
(426,99)*\txt\tiny{};
(440,97)*\txt\tiny{};
(382,113)*\txt\tiny{};
(395,115)*\txt\tiny{};
(408,117)*\txt\tiny{};
(437,134)*\txt\tiny{};
(488,95)*\txt\scriptsize{};
(488,113)*\txt\scriptsize{};
(488,130)*\txt\scriptsize{};
\end{xy}
\caption{Examples of type  runs for two different speedups in the range , namely at  and .}
\label{figure:bspeeds}
\end{figure}

A type  run moves forward during its first two periods of time the same distance that an optimal run moves during  subintervals.  During its third period of time, it moves forward the same distance that an optimal run moves during  subintervals and then backward the same distance that an optimal run moves during  subintervals.  During its fourth period of time, it moves backward the same distance that an optimal run moves during  subintervals.  Then, the pattern repeats.  

When , run , during the first period in its pattern, covers  successive subsets as it moves forward.  In its second period, it covers another  subsets moving forward.  In its third period, it covers  subsets forward but no new subsets backward.  Finally, in its fourth period, it covers  subsets moving backward.  We see that only the first period in the pattern covers the first  subsets.  Then, the first and fourth period in the pattern cover the next  subsets.  The first, second, and fourth periods cover the next  subsets.  The second and fourth periods cover the next  subsets.  The second, third, and fourth periods cover the next  subsets.  Only the second and the third period cover the next  subsets, and only the third period covers the final  subsets.  This pattern of coverage is represented as  repetitions of 1/4,  repetitions of 1/2,  repetitions of 3/4,  repetitions of 1/2,  repetitions of 3/4,  repetitions of 1/2, and  repetitions of 1/4.  Just as with type  runs, we will use the patterns for  and  runs in conjunction with CREATE-TABLE- to construct tables showing bounds on average coverage.

Figure \ref{figure:cspeeds} gives two examples of type  runs for speedups in the range , the only range for which our analysis will employ type  runs.  Observe that the run for  uses the form  in order to conform with the restriction for our analysis that  must be even.  Unlike  and  runs with, respectively, repeating patterns of two and three periods, both the runs in this figure arrive at the same position at the beginning of every fourth period, namely at times , , and so on.  Portions of runs servicing requests in , , , , and  or various subsets are identified: no separate subsets for  but subsets , , , , , , , , and  mapping to a fifth of a period of  for .  Focusing on the example of  where  and , note that, during a four-period section, subsets  through  are covered a single time, subset  is covered twice, subsets  through  and  are covered three times, subset  is covered twice, subsets  through  and  are covered three times, subset  is covered twice, and subsets  through  and  and  are covered a single time.  This pattern of 5 repetitions of 1/4, 1 repetition of 1/2, 5 repetitions of 3/4, 1 repetition of 1/2, 4 repetitions of 3/4, 1 repetition of 1/2, and 5 repetitions of 1/4 exactly corresponds to the repeating pattern of subset coverage described in the previous paragraph.


\begin{figure}[!hbt]
\centering
\begin{xy}
\newxycolor{white}{1 gray}
\xyimport(534, 210){\includegraphics[width=.80\textwidth]{cspeeds.eps}}
(-24,137)*!R\txt\footnotesize{Run  for};
(-24,119)*!R{\large s = 2 = {4 \over 2}};
(-24,71)*!R\txt\footnotesize{Run  for};
(-24,53)*!R{\large s = {11 \over 5}};
(-24,8)*!R\txt\footnotesize{Optimal};
(-24,-4)*!R\txt\footnotesize{Run };
(-6,-11)*\txt\footnotesize{};
(76,3)*\txt\footnotesize{};
(149,0)*\txt\footnotesize{};
(225,12)*\txt\footnotesize{};
(300,9)*\txt\footnotesize{};
(374,22)*\txt\footnotesize{};
(449,24)*\txt\footnotesize{};
(523,18)*\txt\footnotesize{};
(1,116)*\txt\scriptsize{};
(149,128)*\txt\scriptsize{};
(301,139)*\txt\scriptsize{};
(461,170)*\txt\scriptsize{};
(292,165)*\txt\scriptsize{};
(449,199)*\txt\scriptsize{};
(1,54)*\txt\scriptsize{};
(164,62)*\txt\scriptsize{};
(329,64)*\txt\scriptsize{};
(496,98)*\txt\scriptsize{};
(292,101)*\txt\scriptsize{};
(465,149)*\txt\scriptsize{};
(40,145)*\txt\scriptsize{};
(115,159)*\txt\scriptsize{};
(190,151)*\txt\scriptsize{};
(265,157)*\txt\scriptsize{};
(339,148)*\txt\scriptsize{};
(339,169)*\txt\scriptsize{};
(339,188)*\txt\scriptsize{};
(414,160)*\txt\scriptsize{};
(414,181)*\txt\scriptsize{};
(414,201)*\txt\scriptsize{};
(489,195)*\txt\scriptsize{};
(40,81)*\txt\scriptsize{};
(115,95)*\txt\scriptsize{};
(159,84)*\txt\tiny{};
(174,83)*\txt\tiny{};
(189,88)*\txt\tiny{};
(204,96)*\txt\tiny{};
(219,102)*\txt\tiny{};
(265,93)*\txt\scriptsize{};
(308,78)*\txt\tiny{};
(322,81)*\txt\tiny{};
(339,84)*\txt\tiny{};
(353,86)*\txt\tiny{};
(367,88)*\txt\tiny{};
(339,105)*\txt\scriptsize{};
(339,124)*\txt\scriptsize{};
(414,97)*\txt\scriptsize{};
(414,117)*\txt\scriptsize{};
(414,137)*\txt\scriptsize{};
(457,92)*\txt\tiny{};
(471,91)*\txt\tiny{};
(457,112)*\txt\tiny{};
(457,132)*\txt\tiny{};
(471,131)*\txt\tiny{};
(486,129)*\txt\tiny{};
(501,128)*\txt\tiny{};
(516,126)*\txt\tiny{};
\end{xy}
\caption{Examples of type  runs for two different speedups in the range , namely at  and .}
\label{figure:cspeeds}
\end{figure}


\section{Speedup Performance for Windows in Set }
\label{section:performance W_3}

We will now explore the speedup-performance trade-off for windows in  for all speedups .  For set , our analysis must consider subsets  through .  As before, we will assign a 1 for full coverage and a  for half coverage of any subset.  Because of the coverage patterns of  and  runs, we will also assign values of , , , and  for corresponding proportions of coverage.  For the subsets for a given range of speedup values for , the values are symmetrical around .  Thus, our tables and proofs will not list contributions for subset  where .

\subsection{Speedup  for Windows in Set }

For this analysis, we consider service runs , , , , , , , and , noting that .  We will use two copies each of  and  and a single copy each of , , , , , and .  We have moved the generation of the tables and the case analysis needed to show the coverage to Appendix \ref{appendix:1<s<2 W_3}.

\begin{theorem}
For , our algorithm finds a -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval W_3}, our analysis gives no yield less than .  Since two copies each of  and  and a single copy each of , , , , , and  are used, averaged over  different sets of periods, the Average Coverage Proposition is applied over  runs.  Thus, the fraction of optimal profit obtained is at least .
\end{proof}

\subsection{Speedup  for Windows in Set }

For the range , any rational speedup  can be represented in the form  with integers  and .  For this analysis, we consider service runs , , , and , noting that .  We will use a single copy each of  and  and two copies each of  and .  We have moved the  generation of the tables and the case analysis needed to show the coverage to Appendix \ref{appendix:2<s<7/3 W_3}.

\begin{theorem}
For , algorithm SPEEDUPW12 finds a -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval 2<s<7/3 W_3}, our analysis gives no yield less than .  Since 1 copy of each of  and  and 2 copies each of  and  were used, averaged over  different sets of periods, the Average Coverage Proposition is applied over  runs.  Thus, the fraction of optimal profit obtained is at least .
\end{proof}


\subsection{Speedup  for Windows in Set }

For the range , any rational speedup  can be represented in the form  with integers  and .  For this analysis, we consider service runs , , , and , noting that .  We will use  copies each of  and  and  copies each of  and .  We have moved generation of the tables and the case analysis needed to show the coverage to Appendix \ref{appendix:7/3<s<17/7 W_3}.

\begin{theorem}
For , algorithm SPEEDUPW12 finds an -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval 7/3<s<17/7 W_3}, our analysis gives no yield less than .  Since  copies of each of  and  and  copies each of  and  were used, averaged over  different sets of periods, the Average Coverage Proposition is applied over  runs.  Thus, the fraction of optimal profit obtained is at least .
\end{proof}

\subsection{Speedup  for Windows in Set }

For the range , any rational speedup  can be represented in the form  with integers  and .  For this analysis, we consider service runs , , , and , noting that . We will use  copies each of  and  and  copies each of  and .  We have moved the generation of the tables and the case analysis needed to show the coverage to Appendix \ref{appendix:17/7<s<3 W_3}.

\begin{theorem}
For , algorithm SPEEDUPW12 finds a -approximation to the repairman problem on windows in set  in  time.
\end{theorem}

\begin{proof}
By Lemma \ref{lemma:lowestinterval 17/7<s<3 W_3}, our analysis gives no yield less than .  Since  copies of each of  and  and  copies each of  and  were used, averaged over  different sets of periods, the Average Coverage Proposition is applied over  runs.  Thus, the fraction of optimal profit obtained is at least .
\end{proof}

By Observation \ref{observation:speedup}, the -approximation for  implies at most a constant -approximation to the repairman problem on windows in set  when .

\subsection{Speedup  for Windows in Set }

For set  with  where , we consider runs  and , noting that .
When , run  and its shift give full coverage in subsets of , , and , and partial coverage in subsets of  and , while run  and its shift give full coverage in subsets of , , and  and partial coverage in subsets of  and .  When , runs  and  give full coverage in subsets of , , , and  and partial coverage in subsets of , while runs  and  give full coverage in subsets of , , , and  and partial coverage in subsets of  and .  Since the contributions of the  and  runs and their shifted versions tend to balance each other, we can analyze this balance between the two over all possible sets of periods to find a lower bound on the total profit after trimming.


\begin{theorem}
For , our algorithm finds a -approximation for windows  in  time.
\end{theorem}

\begin{proof}
A 1 is assigned for any subset which is covered every period, and a  is assigned for any subset covered every other period.  For runs  and ,  earns a 1 for all  sets of periods where , giving a total of  for each such .  For each , the total decreases by  from the total for .   For runs  and ,  gets 1 for all  sets of periods where , giving a total of  for each such .  For each , the total decreases by  from the total for .

Now, we take the total over all sets of periods for both runs.  For runs  and , we get a total of  for .  For runs  and , we get a total of .  Summing these together, we get a yield of  for .  By symmetry, the total for  is also .  Contributions from  and  are constant and contributions from  and  only increase or stay constant for .  Contributions for  for all runs sum to  for .   Thus, the yield for all other  in all cases is at least .  Since  sets of periods for the two pairs of runs cost a total of  sets of periods to average over, the fraction of profit after trimming is at least .  Multiplying the reciprocal by  gives a -approximation.
\end{proof}

\section{Performance of SPEEDUPW12}
\label{section:performance of speedupw12}

Now that we have characterized the performance of our speedup algorithms on windows in sets , , and , we bound the performance of SPEEDUPW12 by combining our results as follows.
Let  be an optimal service run for a repairman instance with time window lengths from 1 up to 2.
Consider a new set of periods with duration . Partition windows into the sets , , , , and , such that for , a window is put in  if it completely contains exactly  of these new periods of length .25.  Let the total fraction of profit in an optimal solution coming from windows in set  be .  Thus, .


We use these subintervals when analyzing the performance of the algorithm run on periods of length , , and .  Consider set  of windows,  and period length , for .
The number of full subintervals of a window in  that are covered when the period length is  is either
 or 
depending on which set of periods is used.

For , let  be the fraction of optimal profit earned for SPEEDUPW12
applied to requests with windows in .  Recall that coverage of windows in  is defined using period size .5.  To apply this coverage to the three period sizes used in the algorithm, we establish:

\begin{lemma}
\label{lemma:phase1}
The first phase of SPEEDUPW12 yields a run  with 
profitprofit\\
\hspace*{.2in}.
\end{lemma}

\begin{proof}
Windows from  contribute  in both sets of periods.  Windows from  contribute  in one set of periods and  in the other.  Windows from  contribute  in both sets of periods.  Windows from  windows contribute  in one set of periods and  in the other.  Finally, windows from set  windows contribute  in both sets of periods.
\end{proof}

\begin{lemma}
\label{lemma:phase2}
The second phase of SPEEDUPW12 yields a run  with profitprofit\\
\hspace*{.2in}.
\end{lemma}

\begin{proof}
Windows from  contribute  in one set of periods and nothing in the other two.  Windows from  contribute  in two sets of periods and nothing in the other one.  Window from  contribute  in all three sets of periods.  Windows from  contribute  in two sets of periods and  in the other one.  Windows from  contribute  in one set of periods and  in the other two.\end{proof}

\begin{lemma}
\label{lemma:phase3}
The third phase of SPEEDUPW12 yields a run  with profitprofit\\
\hspace*{.2in}.
\end{lemma}

\begin{proof}
Windows from  contribute nothing in all four sets of periods.  Windows from   contribute  in one set of periods and nothing in the other three.   Windows from  contribute  in two sets of periods and nothing in the other two.  Windows from  contribute  in three sets of periods and nothing in the other one.  Windows from  contribute  in all four sets of periods.\end{proof}


\begin{comment}
\begin{theorem}
In  time,
SPEEDUPW12 finds a run  such that profit \\
profit

\hspace{.1in}\\
\hspace*{.3in}
\hspace{.1in}\\
\hspace*{.3in}
\hspace{.1in}\hspace{.1in}

\label{thm:LP}
\end{theorem}
\end{comment}

From Lemmas \ref{lemma:phase1}, \ref{lemma:phase2}, and \ref{lemma:phase3}, we isolate the coefficients  of the variables , for , 4, 5, 6, 7.  Weighting them by , , and  to correspond to those lemmas, respectively, leads to the following definitions of five functions of , , , and .


\begin{theorem}
In  time,
SPEEDUPW12 finds a run  such that profit \\
profit for , , , ,  .
\label{thm:LP}
\end{theorem}

\begin{proof}
By Lemmas \ref{lemma:phase1}, \ref{lemma:phase2}, and \ref{lemma:phase3}, {\it profit}{\it profit}, , .
Then, for any convex combination of , , , (i.e.,  and ), we have 


Thus, the expression for  is given by setting  and , where , and summing , , and , weighted by , , and , respectively.  In this way, we can account for a problem instance being dominated by any set  for .  No problem instance will be worse than a convex combination of all the bounds.  

Algorithm SPEEDUPW12 runs SPEEDUP a total of 12 times in the first phase, 6 times in the second phase, and 4 times in the third phase, for a total of 22 times.  We have shown that the running time of SPEEDUP is .
\end{proof}

We give a description of , , and  in Table~\ref{table:Wratios}.
Function  comes from our work in \cite{Frederickson5}.  Function  comes from Sect.~\ref{section:performance W_2}.  Function  comes from Sect.~\ref{section:performance W_3}.

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rll}
 & 
 &

\\ \\
 &
 &

\\ \\
 &
 &

\end{tabular}\\
\caption{Lower bounds on fractions of optimal profit collected for the sets , , and , ignoring the factor of .}
\label{table:Wratios}
\end{center}
\end{table}


We produced the results in Table~\ref{table:speedupw12rats} by solving the linear programs of Theorem~\ref{thm:LP} for particular values of 
within each range, inferring the pattern for each range, and then proving the inferred pattern. 
Note that all but one of the reciprocals of the resulting ratios in terms of  are nonlinear functions!

\begin{theorem}
\label{theorem:1<s<6}
For speedup  in the range 
and window lengths between 1 and 2,
algorithm SPEEDUPW12 produces a service run  for the repairman problem
with approximation ratio profitprofit upper-bounded as in Table~\ref{table:speedupw12rats}.
\end{theorem}

\begin{proof}
For each possible speedup range, we show that  times the convex combinations of the functions given in Table \ref{table:Wratios} are never less than the reciprocals of the approximation ratios listed in Table \ref{table:speedupw12rats}.\\

\noindent When , choose . Then, .\\\bigskip

\noindent When , choose .\medskip

\noindent Then, .\\\bigskip

\noindent When , choose , \medskip 

\noindent and .  Then, .\\\bigskip

\noindent When , choose ,\medskip

\noindent and . Then, .\\\bigskip

\noindent When , choose , \medskip

\noindent and .  Then, .\\\bigskip

\noindent When , choose .\medskip

\noindent Then, .\\\bigskip

\noindent When , choose .\medskip

\noindent Then, , and , whenever .\medskip

\noindent This follows since whenever ,  holds if and only if , which is always true.\medskip

\noindent Finally, bound  whenever . \medskip

\noindent This follows since whenever ,  holds if and only if , which is always true.\\\bigskip

\noindent When , choose .\medskip

\noindent Then, , and  whenever .\medskip

\noindent Finally,  which is at least   whenever .
\end{proof}


\section{Conclusion}

This paper has demonstrated the surprising versatility of the technique of trimming. Even with time windows whose lengths are not all the same, it is possible to simplify the structure of many time-constrained route-planning problems and apply an ordering that allows dynamic programming to work well.  For unrooted problems, the cost of this additional order is at most a constant reduction in the profit a run can earn.  We have extended results from our previous paper \cite{Frederickson5} so that we can characterize the way in which this reduction in profit can be offset, in part or in whole, by speedup over a hypothetical optimal benchmark when the lengths of time windows are not all uniform.  The key idea needed for this extension is to consider a diverse set of trials with a number of different period lengths for trimming and then choose the best result among all those found.  This approach makes trimming adapt to various distributions of window lengths.

We have given techniques that achieve an approximation ratio parameterized only by speedup when the ratio between the longest time window and the shortest time window is no greater than 2, but these techniques can be extended to other ranges of time window lengths.  For the general case, in which the ratio between the longest and the shortest time windows is , the approximation ratio will worsen by a factor of , using an approach similar to the one we used in \cite{Frederickson6} for general length time windows without speedup.

It is worth mentioning that we have achieved approximation bounds for a few specific ranges of  which are slightly better than the ones listed in Table \ref{table:speedupw12rats}.  While trying to accommodate these ranges into a coherent scheme, our analysis became so much more complex that we chose to give a more complete and readable presentation of results which are nearly as strong as the best we found.  The fact that better values are possible shows that there is potential in these techniques.

\bibliographystyle{amsplain}
\bibliography{bibliography}

\appendix

\section{Coverage of Windows in Set  when }
\label{appendix:2<s<3 W_2}

Analysis of set  when  is done by considering service runs , , , and , noting that .  The combined coverages of runs , , , , and all of their respective shifted versions are given in Table \ref{table:lowcontributions 2<s<5/2 W_2} when  and in Table \ref{table:highcontributions 2<s<5/2 W_2} when .  
The combined coverage of the pair  and  is exactly the same for all values of  and are only listed in Table \ref{table:lowcontributions 2<s<5/2 W_2}.  These and all other tables in the Appendices are generated by using CREATE-TABLE- for each different run type, using the appropriate value of  (2 for  or 3 for ), and specific values for  determined by the number of hops each run has been moved.

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:lowcontributions 2<s<5/2 W_2}
\end{center}
\end{table}

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = & 
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:highcontributions 2<s<5/2 W_2}
\end{center}
\end{table}

\begin{lemma}\label{lemma:lowestinterval 2<s<5/2 W_2}
If the contributions from  and  are weighted by a factor of 3 and the contributions from  and  are weighted by a factor of 1, the yield for all intervals is at least .
\end{lemma}

\begin{proof}
We first consider the case when , consulting Table \ref{table:lowcontributions 2<s<5/2 W_2}.

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is greater than .

If , then the yield for  is , which is at least , since .

If , then the yield for  is .

We now consider the case when , consulting Tables \ref{table:lowcontributions 2<s<5/2 W_2} and \ref{table:highcontributions 2<s<5/2 W_2}.  The algebra for the cases when , , and  gives exactly the same results as the first, third, and fourth ranges from the previous part of the proof.  If ,  then the yield for  is , since  when .
\end{proof}

\section{Coverage of Windows in Set  when }
\label{appendix:1<s<2 W_3}

Analysis of set  when  is done by considering service runs , , , , , , , and , noting that .  

The combined coverages of runs , , , , , , , , and all of their respective shifted versions are given in Table \ref{table:lowcontributions W_3} when  and in Table \ref{table:highcontributions W_3} when .  The combined coverages of the pair  and  and the pair  and  are exactly the same for all values of  and are only listed in Table \ref{table:lowcontributions W_3}.

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and  
\end{tabular}
& = &
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:lowcontributions W_3}
\end{center}
\end{table}

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when  and .}
\label{table:highcontributions W_3}
\end{center}
\end{table}


\begin{lemma}\label{lemma:lowestinterval W_3}
If the contributions from  and  are weighted by a factor of 2 and the contributions from , , , , , and  are weighted by a factor of 1, the yield for all intervals is at least .
\end{lemma}

\begin{proof}
We first consider the case when , consulting Table \ref{table:lowcontributions W_3}.  The algebra for the cases when  gives the same results the first, second, and third cases in Lemma \ref{lemma:lowestinterval W_2}, at least   in each case.  If , then the yield for  is .

We now consider the case when , consulting Tables  \ref{table:lowcontributions W_3} and \ref{table:highcontributions W_3}.  The algebra for the cases when  gives the same results as the proof of Lemma \ref{lemma:lowestinterval W_2} for , at least  in each case.  If , then the yield for  is again .
\end{proof}



\section{Coverage of Windows in Set  when }
\label{appendix:2<s<7/3 W_3}

Analysis of set  when  is done by considering service runs , , , and , noting that . The combined coverages for these runs are listed in Table \ref{table:2<s<7/3 W_3} assuming that  is even.  When  is not even, we can achieve an identical speed by multiplying both by 2.\\

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = & 
 &

\\ \\
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when .}
\label{table:2<s<7/3 W_3}
\end{center}
\end{table}


\begin{lemma}\label{lemma:lowestinterval 2<s<7/3 W_3}
If the contributions from  and  are weighted by a factor of 1 and the contributions from  and  are weighted by a factor of 2, the yield for all intervals is at least .
\end{lemma}

\begin{proof}
Consulting Table \ref{table:2<s<7/3 W_3}, we first consider the case when , which implies .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is greater than .

If , then the yield for  is , which is at least , since  and .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since   and .

If , then the yield for  is , which is at least , since .

If , then the yield for  is .

Next, we consider the case when , again consulting Table \ref{table:2<s<7/3 W_3}.

The first case gives the same result as above but for the range .  

If , then the yield for  is , which is at least , since .

The third case gives the same result as above but for the range .  The fourth, fifth, and sixth cases above give identical results when .
\end{proof}


\section{Coverage of Windows in Set  when }
\label{appendix:7/3<s<17/7 W_3}

Analysis of set  when  is done by considering service runs , , , and , noting that . The combined coverages for runs  and  are listed in Table \ref{table:2<s<7/3 W_3}, and the combined coverages for runs  and  are listed in Table \ref{table:7/3<s<17/7 W_3}, assuming that  is even.\\

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when .}
\label{table:7/3<s<17/7 W_3}
\end{center}
\end{table}


\begin{lemma}\label{lemma:lowestinterval 7/3<s<17/7 W_3}
If the contributions from  and  are weighted by a factor of  and the contributions from  and  are weighted by a factor of , the yield for all intervals is at least .
\end{lemma}

\begin{proof}
Consult Tables \ref{table:2<s<7/3 W_3} and \ref{table:7/3<s<17/7 W_3}.

If , then the yield for  is .

If , then the yield for  is , which is greater than , since .

If , then the yield for  is , which is at least , since  and .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since  .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since  when .
\end{proof}



\section{Coverage of Windows in Set  when }
\label{appendix:17/7<s<3 W_3}

Analysis of set  when  is done by considering service runs , , , and , noting that .  The combined coverages for runs  and  are listed in Table \ref{table:2<s<7/3 W_3}, and the combined coverages for runs  and  are listed in Table \ref{table:17/7<s<5/2 W_3} when  and in Table \ref{table:5/2<s<3 W_3} when , assuming in both cases that  is even.\\

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular} 
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when .}
\label{table:17/7<s<5/2 W_3}
\end{center}
\end{table}

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{rcll}
\begin{tabular}{r}
Combined contributions\\
for  and 
\end{tabular}
& = &
 &

\end{tabular}\\
\caption{Contributions of runs for windows in  when .}
\label{table:5/2<s<3 W_3}
\end{center}
\end{table}


\begin{lemma}\label{lemma:lowestinterval 17/7<s<3 W_3}
If the contributions from  and  are weighted by a factor of  and the contributions from  and  are weighted by a factor of , the yield for all intervals is at least .
\end{lemma}

\begin{proof}
In the case that , consult Tables \ref{table:2<s<7/3 W_3} and \ref{table:17/7<s<5/2 W_3}.

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is greater than , since , , and .

If , then the yield for  is , which is greater than , since , , and .

If , then the yield for  is , which is greater than , since , , and .

If , then the yield for  is , which is at least , since  .

If , then the yield for  is , which is at least , since .

If , then the yield for  is , which is at least , since  and .

In the case that , consult Tables \ref{table:2<s<7/3 W_3} and \ref{table:5/2<s<3 W_3}.  For this range .

If , then the yield for  is , which is at least , since  and .

If , then the yield for  is , which is at least , since  and .

If , then the yield for  is , which is at least , since .

All other ranges are identical to some yield when .
\end{proof}


\end{document}
