\documentclass{sigplanconf}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage{times}
\usepackage{shading}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage[dvips]{graphicx}
\usepackage{color}










\newenvironment{defn}{\begin{tabbing}
  \hspace{1.5em} \= \hspace{.20\linewidth - 1.5em} \= \hspace{1.5em} \= \kill
  }{
  \end{tabbing}}
\newenvironment{defn2}{\begin{tabbing}
  \hspace{1.5em} \= \hspace{.295\linewidth - 1.5em} \= \hspace{1.5em} \= \kill
  }{
  \end{tabbing}}

\newcounter{ctr:list1}
\newcounter{ctr:list2}
\newenvironment{list1}
    {\setcounter{ctr:list1}{0}
    \begin{list}{{\bf\Roman{ctr:list1}}.}{\usecounter{ctr:list1}\setlength{\leftmargin}{0.3cm}}}
    {\end{list}}
\newenvironment{list2}
    {\setcounter{ctr:list2}{0}
    \begin{list}{(\roman{ctr:list2})}{\usecounter{ctr:list2}\setlength{\leftmargin}{0.7cm}}}
    {\end{list}}
\newenvironment{list2'}
    {\setcounter{ctr:list2}{0}
    \begin{list}{(\roman{ctr:list2})}{\usecounter{ctr:list2}\setlength{\leftmargin}{0.3cm}}}
    {\end{list}}

\newenvironment{blist}[1]
    {\begin{list}{#1}{\setlength{\leftmargin}{0.3cm}}}
    {\end{list}}
	
\makeatletter 
\def\overbracket#1{\mathop{\vbox{\ialign{##\crcr\noalign{\kern3\p@} \downbracketfill\crcr\noalign{\kern3\p@\nointerlineskip} \crcr}}}\limits} 
\def\underbracket#1{\mathop{\vtop{\ialign{##\crcr \crcr\noalign{\kern3\p@\nointerlineskip} \upbracketfill\crcr\noalign{\kern3\p@}}}}\limits} \def\overparenthesis#1{\mathop{\vbox{\ialign{##\crcr\noalign{\kern3\p@} \downparenthfill\crcr\noalign{\kern3\p@\nointerlineskip} \crcr}}}\limits} 
\def\underparenthesis#1{\mathop{\vtop{\ialign{##\crcr
	\crcr\noalign{\kern3\p@\nointerlineskip} \upparenthfill\crcr\noalign{\kern3\p@}}}}\limits} 
\def\downparenthfill{} 
\def\upparenthfill{} 
\def\upbracketfill{} 
\def\downbracketfill{}
\def\equalsfill{\!\mathord=\!}  
\makeatother 

\newcommand{\cenv}[3]{\begin{flushleft}
\parbox{8.3cm}{{\bf #1} }
\\
\vspace{-0.1cm}
\parbox{8.3cm}{\downbracketfill}
\\
\vspace{-0.3cm}
\end{flushleft}
#3
\begin{flushleft}
\vspace{-0.2cm}
\parbox{8.3cm}{\upbracketfill}
\end{flushleft}}

\newcommand{\cenvv}[3]{\begin{flushleft}
\parbox{17.7cm}{{\bf #1} }
\\
\parbox{17.7cm}{\downbracketfill}
\\
\vspace{-0.2cm}
\end{flushleft}
#3
\begin{flushleft}
\parbox{17.7cm}{\upbracketfill}
\end{flushleft}}

\newcommand{\cenvvv}[3]{\vspace{0.8mm}
\begin{flushleft}
\parbox{8.4cm}{{\bf #1} }
\\
\parbox{8.4cm}{\downbracketfill}
\\
\vspace{-0.2cm}
\end{flushleft}
#3
\begin{flushleft}
\parbox{8.4cm}{\upbracketfill}
\end{flushleft}}

\newcommand{\entry}[2]{\>\>\>#2}
\newcommand{\clause}[2]{\>\>#2}
\newcommand{\mycategory}[2]{\clause{#1::=}{#2}}


\newcommand{\lab}{\mathsf L}
\newcommand{\labp}{\mathsf P}
\newcommand{\labo}{\mathsf O}
\newcommand{\labb}{\mathsf S}
\newcommand{\labt}{\mathsf E}
\newcommand{\labc}{\mathsf C}


\newcommand{\func}[1]{{\bf #1}}
\newcommand{\clk}{\mathsf{Clk}}
\newcommand{\op}{{\it op}}
\newcommand{\adm}{{\it adm}}
\newcommand{\tup}[1]{\langle #1\rangle}
\newcommand{\pause}{.\:}
\newcommand{\snd}[3]{\overline{#1}\tup{#2}\pause #3}
\newcommand{\asnd}[2]{\overline{#1}\tup{#2}}
\newcommand{\rcv}[3]{#1(#2)\pause #3}
\newcommand{\parl}[2]{#1\:|\:#2}
\newcommand{\new}[2]{(\nu #1)\:#2}
\newcommand{\nnew}[3]{(\nu_{#1}~#2)~(#3)}
\newcommand{\cond}[4]{\mathsf{if}\:#1=#2\:\mathsf{then}\:#3\:\mathsf{else}\:#4}
\newcommand{\symb}[1]{{\bf #1}}
\newcommand{\key}{\mathrm K}
\newcommand{\capb}{\symb{mac}(\tup{\op,T,b},\key_b)}
\newcommand{\sep}{\:|\:}
\newcommand{\col}{\!:}
\newcommand{\ccol}{\!:\!}
\newcommand{\palpha}{\alpha^\bullet}
\newcommand{\Req}{\mathsf{Req}}
\newcommand{\App}{\mathsf{App}}
\newcommand{\PReq}{\mathsf{PReq}}
\newcommand{\Ret}{\mathsf{Ret}}
\newcommand{\AReq}{\mathsf{AReq}}
\newcommand{\DAReq}{\mathsf{DAReq}}
\newcommand{\DPReq}{\mathsf{DPReq}}
\newcommand{\DReq}{\mathsf{DReq}}
\newcommand{\action}[1]{\stackrel{#1}{\longrightarrow}~}
\newcommand{\fn}{\mathtt{fn}}
\newcommand{\bn}{\mathtt{bn}}
\newcommand{\fv}{\mathtt{fv}}
\newcommand{\bv}{\mathtt{bv}}
\newcommand{\fileop}[4]{\mathsf{fileop}_#1~#3/#2;~#4}
\newcommand{\polmod}[3]{\mathsf{admin}_#1~#2;~#3}
\newcommand{\auth}[4]{\mathsf{auth}_#1~#2~\mathsf{for}~#3;~#4}
\newcommand{\dfileop}[4]{\mathsf{fileopauth}_#1~#3/#2;~#4}
\newcommand{\ord}[1]{#1^{\scriptsize \mbox{th}}}
\newcommand{\pre}[2]{\prec_{#1}^{#2}}
\newcommand{\defq}{\stackrel{\mathtt{def}}=}
\newcommand{\at}{\:@\:}
\newcommand{\no}{{\not \exists}}
\newcommand{\cs}{\item[Case]}
\newcommand{\inferc}[1]{\infer[(#1)]}

\newcommand{\seq}{\widetilde}
\newcommand{\callsec}[1]{Section~\ref{#1}}
\newcommand{\callprop}[1]{Proposition~\ref{#1}}
\newcommand{\callthm}[1]{Theorem~\ref{#1}}
\newcommand{\calllem}[1]{Lemma~\ref{#1}}
\newcommand{\calldef}[1]{Definition~\ref{#1}}
\newcommand{\df}{\stackrel{\tiny\mbox{def}}=}

\newcommand{\proc}[1]{\mathsf{Process}(#1)}
\newcommand{\rsrc}[1]{\mathsf{Resource}(#1)}
\newcommand{\conf}[3]{\mathcal #1 ~\|~ \mathcal #2 ~\|~ \mathcal #3}
\newcommand{\fork}[2]{#1\Rsh\:\!#2}
\newcommand{\eval}[3]{\mathsf{let}~#1=#2~\mathsf{in}~#3}
\newcommand{\store}[1]{\stackrel{#1}\mapsto}
\newcommand{\lctx}[2]{\mathcal E_\lab[\![#1]\!]_{#2}}
\newcommand{\llctx}[3]{\mathcal E_{#1}\llbracket#2\rrbracket_{#3}}


\newcommand{\aprx}[1]{\{\!| #1 |\!\}}

\newcommand{\hl}[2]{\mbox{\fbox{#1}}}

\newcommand{\subs}[2]{\{\!\!\{#1/#2\}\!\!\}}
\newcommand{\subch}[2]{\{\!\!\{#1/\!\!/#2\}\!\!\}}
\newcommand{\actsub}[1]{\stackrel{#1;\sigma}{\longrightarrow}~}
\newcommand{\sctx}[2]{\mathcal E_{\lab;\sigma}\llbracket#1\rrbracket_{#2}}
\newcommand{\sctxr}[2]{\mathcal E_{\labp;\sigma}\llbracket#1\rrbracket_{#2}}

\newcommand{\actioni}[1]{\stackrel{#1}{\rightarrowtriangle}~}

\newcommand{\trule}[1]{(\textbf{Typ #1})}
\newcommand{\srule}[1]{\textbf{Struct #1}}
\newcommand{\rrule}[1]{\textbf{Reduct #1}}

\newcommand{\dom}{\mathtt{dom}}
\newcommand{\con}{\mathtt{const}}

\newcommand{\rem}[1]{#1}

\newenvironment{compact}
        {\begin{list}{}{
}}
        {\end{list}}

\newcounter{compactenumc}

\newenvironment{compactenum}
        {\begin{list}{\arabic{compactenumc}.}{
        \usecounter{compactenumc}
        \setlength{\itemsep}{-0.1cm}
        \setlength{\topsep}{0.1cm}
        \setlength{\leftmargin}{0.6cm}
        \setlength{\labelwidth}{\leftmargin}
        }}
        {\end{list}}



\newenvironment{compactenum2}
        {\begin{list}{(\roman{compactenumc})}{
        \usecounter{compactenumc}
\setlength{\leftmargin}{7mm}
        \setlength{\labelwidth}{\leftmargin}
        }}
        {\end{list}}

\newenvironment{compactenum3}
        {\begin{list}{(\arabic{compactenumc})}{
        \usecounter{compactenumc}
\setlength{\leftmargin}{6mm}
        \setlength{\labelwidth}{\leftmargin}
        }}
        {\end{list}}


\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{algo}[definition]{Algorithm}
\newtheorem{observation}[definition]{Observation}
\newtheorem{example}[definition]{Example}
\renewcommand{\qedsymbol}{}



\title{A Type System for Data-Flow Integrity on Windows Vista}
\authorinfo
        {Avik Chaudhuri}
        {University of California at Santa Cruz}
        {avik@cs.ucsc.edu}
\authorinfo
        {Prasad Naldurg \and Sriram Rajamani}
        {Microsoft Research India}
        {\{prasadn,sriram\}@microsoft.com}



\begin{document}
\conferenceinfo{PLAS'08,} {June 8, 2008, Tucson, Arizona, USA.}
\CopyrightYear{2008}
\copyrightdata{978-1-59593-936-4/08/06}
\maketitle







\begin{abstract} 


The Windows Vista operating system implements an interesting model of multi-level integrity.  
We observe that in this model, trusted code can be blamed for any information-flow attack; thus, it is possible to eliminate such attacks by static analysis of trusted code. We formalize this model by designing a type system 
that can efficiently enforce data-flow integrity on Windows Vista. Typechecking guarantees that objects whose
contents are statically trusted never contain untrusted values, regardless of
what untrusted code runs in the environment. 
Some of Windows Vista's runtime access checks are necessary for soundness; others are redundant and can be optimized away. 
\end{abstract}



\category{D.4.6}{Operating Systems}{Security and Protection}[Access controls, Information flow controls, Verification]
\category{D.2.4}{Software Engineering}{Program Verif\-ication}[Correctness proofs]
\category{F.3.1}{Logics and Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}[Specification techniques, Invariants, Mechanical verification]


\terms
Security, Verification, Languages, Theory

\keywords
dynamic access control, data-flow integrity, hybrid type system, explicit substitution

\section{Introduction}\label{intro}

Commercial operating systems are seldom designed to prevent information-flow attacks. Not surprisingly, such attacks are the source of many serious security problems in these systems \cite{sabelfeld}. Microsoft's Windows Vista operating system implements an integrity model that can potentially prevent such attacks. In some ways, this model resembles other, classical models of multi-level integrity~\cite{biba}---every process and object\footnote{In this context, an object may be a file, a channel, a memory location, or indeed any reference to data or executable code.} 
 is tagged with an integrity label, the labels are ordered by levels of trust, and access control is enforced across trust boundaries. In other ways, it is radically different. While Windows Vista's access control prevents
low-integrity processes from writing to high-integrity objects, it does not prevent high-integrity processes from reading low-integrity objects.
Further, Windows Vista's integrity labels are
dynamic---labels of processes and objects can change at runtime. This model allows
processes at different trust levels to communicate, and allows dynamic access control. At the same time, it admits various information-flow attacks. Fortunately, it turns out that such attacks require the participation of trusted processes, and can be eliminated by code analysis.

In this paper, we provide a formalization of Windows Vista's integrity model. In particular, we specify an information-flow property called {\em data-flow integrity} (DFI), and present a static type
system that can enforce DFI on Windows Vista. Roughly, DFI prevents any flow of data from the environment to
objects whose contents are trusted. Our type system relies on Windows Vista's
runtime access checks for soundness. The
key idea in the type system is to 
maintain a static lower-bound label~ for each object. While the dynamic label of an object can change at runtime, the type system ensures that it
never goes below~, and the object never contains a value that
flows from a label lower than~.  The label  is
declared by the programmer. Typechecking requires no other annotations, and can be mechanized by an efficient algorithm.



By design, DFI does not prevent implicit flows \cite{denningcert}. Thus DFI is weaker than noninterference~\cite{nonintf}.
Unfortunately, it is difficult to enforce noninterference on a commercial operating system such as Windows Vista. Implicit flows abound in such systems. Such
flows arise out of frequent, necessary interactions between trusted code
and the environment. They also arise out of covert control channels
which, given the scope of such systems, are impossible to model
sufficiently. Instead, DFI focuses on explicit flows~\cite{denningcert}. This focus buys a reasonable compromise---DFI prevents a definite class of attacks, and can be enforced efficiently on Windows Vista. Several successful tools for malware detection follow this approach  \cite{castro,panorama,suh,vogt,dytan,perl}, and a similar approach guides the design of some recent operating systems~\cite{asbestos,histar}. 








Our definition of DFI is dual to standard definitions of
secrecy based on explicit flows---while secrecy prevents sensitive values from
flowing to the environment, DFI prevents the flow of values from the environment to sensitive objects.  Since
there is a rich literature on type-based and logic-based analysis for such definitions of secrecy~\cite{secgp,sectyplog,runtimeprin,ChaudhuriConcur06}, it
makes sense to adapt this analysis for DFI. Such an adaptation works, but requires some care.
Unlike secrecy, DFI cannot be enforced without runtime checks. In particular, access checks play a crucial role by
restricting untrusted processes that may run in the environment.  
Further, while secrecy prevents any flow of high-security information to the environment,  
DFI allows certain flows of low-security information from the environment. We need to introduce new technical devices for this purpose, including a technique based on \emph{explicit
substitution}~\cite{abadi90explicit} to track precise sources of values. This device is required not only to
specify DFI precisely but also to prove that our type system
enforces DFI.


We design a simple higher-order process calculus that simulates Windows Vista's security environment \cite{bppvista,symantec,uac}. In this language,  processes can fork new processes, create new objects, change the labels of processes and objects, and read, write, and execute objects in exactly the same ways as Windows Vista allows. 
Our type system exploits Windows Vista's runtime access checks to enforce DFI, and can recognize many correct programs. At the same time, our type system subsumes Windows Vista's execution controls, allowing them to be optimized away.


\subsection{Summary of contributions} To sum up, we make the following main contributions in this paper:\begin{compact}
\item
We propose DFI as a practical multi-level integrity property in the setting of Windows Vista, and formalize DFI using a semantic technique based on explicit substitution.
\item
We present a type system that can efficiently enforce DFI on Windows Vista. Typechecking guarantees DFI regardless 
of what untrusted code runs in the environment. \item
We show that while most of Windows Vista's runtime access checks are required to enforce DFI, Windows Vista's execution controls are redundant and can be optimized away.
\end{compact}

\subsection{Outline} The rest of this paper is organized as follows. 
In Section~\ref{overview},
we introduce Windows Vista's security environment, and show how DFI may be violated in that environment. 
In Section~\ref{calc}, we design a calculus that simulates Windows Vista's security environment, equip the calculus with a semantics based on explicit substitution, and formalize DFI in the calculus. 
In Section~\ref{typ}, we
present a system of integrity types and effects for this calculus.  In
Section~\ref{Results}, we prove soundness and other properties of typing. 
Finally, in Section~\ref{concl}, we
discuss limitations and contributions with respect to related work and
conclude. 
Supplementary material, including proof details and an efficient typechecking algorithm, appear in the appendix. 
















\section{Windows Vista's integrity model}\label{overview} 

In this section, we provide a brief overview of Windows Vista's integrity model.\footnote{Windows Vista further implements a discretionary access control model, which we ignore in this paper.} In particular, we introduce Windows Vista's security environment, and show how DFI may be violated in that environment. We observe that such attacks require the participation of trusted processes.

\subsection{Windows Vista's security environment} In Windows Vista, every process and object is tagged with a dynamic integrity label. We indicate such labels in
brackets  below. Labels are related by a total order , meaning ``at most as trusted as". 
Let  range over processes,  over objects, and  over labels. Processes can fork new processes, create new objects, change the labels of processes and objects, and read, write, and execute objects. In particular, a process with label  can:
\begin{compactenum2}
\item fork a new process ; \item create a new object ; \item lower its own label; \item change the label of an object  to  iff ; \item read an object ;
\item write an object  iff ;
\item execute an object  by lowering its own label to .
\end{compactenum2} 
Rules (i) and (ii) are straightforward. 
Rule (iii) is guided by the principle of least
privilege~\cite{protection}, and is used in Windows Vista to implement a feature called \emph{user access control}
(UAC)~\cite{uac}. This feature lets users execute
commands with lower privileges when appropriate. For example, when a system administrator opens a new shell (typically with label 
), a new process is forked with label 
; the shell is then run by the new
process. When an Internet browser is opened, it is always run by a
new process whose label is lowered to ; thus any code
that gets run by the browser gets the label ---by Rule (i)---and any file that is downloaded by the browser gets the label ---by Rule~(ii).   

Rules (iv) and (v) are useful in various ways, but can be dangerous if not used carefully. (We show some attacks to illustrate this point below.) In particular, Rule (iv) allows unprotected objects to be protected by trusted processes by raising
their labels, and Rule~(v) allows processes to read objects at lower trust levels. At the same time, Rule (iv) facilitates dynamic access
control, and Rule (v) facilitates communication across trust boundaries. 

Rule (vi) protects objects from being written by processes at lower trust levels. Thus, for example, untrusted code
forked by a browser cannot affect local user files. User code cannot modify registry keys protected by a system administrator. 
Rule (vii) is part of UAC; it 
prevents users from accidentally launching less trusted executables with higher privileges. For example, a virus downloaded from the Internet cannot run
in a trusted user shell. Neither can system code dynamically link
user libraries.


\subsection{Some attacks}\label{vista}
We now show some attacks that remain possible in this environment. Basically, these attacks exploit Rules (iv) and (v) to bypass Rules (vi) and (vii). \begin{description}
\item[{\rm (}Write and copy{\rm )}] By Rule (vi),  cannot
  modify  if . However,  can modify 
  some object , and then some process  can copy 's content to . Thus, Rule (iv) can be exploited to bypass Rule (vi).
\item[{\rm (}Copy and execute{\rm )}] By Rule (vii),  cannot
  execute  at  if . However,  can copy 's content to some object  and then execute . Thus, Rule (iv) can be exploited to bypass Rule (vii).
\item[{\rm (}Unprotect, write, and protect{\rm )}] By Rule (vi),  cannot
  modify  if . However, some process 
  can unprotect  to , then  can modify 
   , and then  can protect  back to . Thus, Rule (v) can be exploited to bypass Rule (vi).
\item[{\rm (}Copy, protect, and execute{\rm )}] By Rule (vii),  cannot
  execute  at  if . However, some process  can copy 's content to an object , and then  can protect
   to  and execute . Thus, Rules (iv) and (v) can be exploited to bypass Rule (vii).
\end{description}
Next, we show that all of these attacks can violate DFI. At the same time, we observe that access
control forces the participation of a trusted process (one with the higher label) in
any such attack. 
\begin{itemize}
\item In ({\bf Write and copy}) or ({\bf Unprotect, write, and protect}), suppose that the contents of  are trusted, and  is the label of untrusted code,  with . Then data can flow from  to , violating DFI, as above. Fortunately, some process  can be blamed here.
\item In ({\bf Copy and execute}) or ({\bf Copy, protect, and execute}), suppose that the contents of some object  are trusted, and  is the label of untrusted code, with . Then data can flow from some process   to , violating DFI, as follows:  packs code to modify  and writes the code to , and  unpacks and executes that code, as above. Fortunately,  can be blamed here.
\end{itemize}
Our type system can eliminate such attacks by restricting trusted processes (Section \ref{typ}).
(Obviously, the type system cannot restrict untrusted code running in the environment.) Conceptually, this guarantee can be cast as Wadler and Findler's ``\emph{well-typed programs can't be blamed}"~\cite{blame}. 
We rely on the fact that a trusted process can be blamed for any violation of DFI; it follows that if all trusted processes are well-typed, there cannot be any violation of DFI. 


\section{A calculus for analyzing DFI on Windows Vista}\label{calc}
To formalize our approach, we now design a simple higher-order process calculus that simulates Windows Vista's security environment. We first introduce the syntax and informal semantics, and present some examples of programs and attacks in the language. We then present a formal semantics, guided by a precise characterization of explicit flows. 

\subsection{Syntax and informal semantics}

Several simplifications appear in the syntax of the language. We describe processes by their code. We use variables as object names, and let objects contain packed code or names of other objects. We enforce a mild syntactic restriction on nested packing, which makes typechecking significantly more efficient (Appendix \ref{algo}; also see below). 
Finally, we elide conditionals---for our purposes, the code 

can be conservatively analyzed by composing  and  in parallel. (DFI is a \emph{safety property} in the sense of \cite{alpernschneider}, and the safety of the latter code implies that of the former. We discuss this point in more detail in Section \ref{introDFI}.) 

Values include variables, , and packed expressions. Expressions include those for forking new processes, creating new objects, changing the labels of processes and objects, and reading, writing, and executing objects. 
They also include standard expressions for evaluation and returning
results (see Gordon and Hankin's concurrent object calculus \cite{gordon98concurrent}).  
\begin{defn}
\mycategory{f,g}{expression} \\
\entry{\fork f g}{fork} \\
\entry{t}{action} \\
\entry{\eval x f g}{evaluation} \\
\entry{r}{result} \\
\mycategory{t}{action} \\
\entry{\mathsf{new}(x\mbox{ \# }\labb)}{create object} \\
\entry{[\labp]~a}{change process label} \\
\entry{\langle\labo\rangle~\omega}{change object label}\\
\entry{!\omega}{read object} \\
\entry{\omega := x}{write object} \\
\entry{\mathsf{exec}~\omega}{execute object} \\
\mycategory{r}{result} \\
\entry{x,y,z,\dots,\omega}{variable} \\
\entry{\mathsf{unit}}{unit} \\
\\
\mycategory{a,b}{process} \\
\entry{\fork a b}{fork} \\
\entry{t}{action}  \\
\entry{\eval x a b}{evaluation} \\
\entry{u}{value} \\
\mycategory{u,v}{value} \\
\entry{r}{result} \\
\entry{\mathsf{pack}(f)}{packed expression} 
\end{defn}
Syntactically, we distinguish between processes and expressions: while every expression is a process, not every process is an expression. For example, the process  is not an expression, although the process  is. Expressions can be packed, but processes in general cannot. In particular, a process cannot be of the form . (Such a process can, however, be written as .) The benefits of this distinction become clear in Section \ref{Results}, where we discuss mechanical typechecking. However, for the bulk of the paper, the reader may ignore this distinction; indeed, neither the semantics nor the type system are affected by this distinction. 


Processes have the following informal meanings. 
\begin{compact}
\item  forks a new process  with the current process label and continues as  (see Rule (i)).
\item  creates a new object  with the current process label,  initializes  with , and returns  (see Rule~(ii)); the annotation  is used by the type system (Section \ref{typ}) and has no runtime significance. 
\item  changes the current process label to  and
  continues as
  ; it blocks if the current process label is lower than  (see Rule~(iii)).
\item  changes 's label to  and returns ; it
  blocks if   is not bound to an object at runtime, or the current process label is lower than 's label or  (see Rule (iv)).
\item  returns the value stored in ; it blocks if
   is not bound to an object at runtime (see Rule (v)).
\item  writes the value  to  and returns ; it blocks if
   is not bound to an object at runtime, or if the current process label is lower than 's label (see Rule (vi)).
\item  unpacks the value stored in  to a
  process , lowers the current process label with 's label, and executes
  ; it blocks if  is not bound to an object
 at runtime or if the value stored in  is not a packed expression (see Rule (vii)).
\item  executes , binds the value returned by  to , and
  continues as
   with  bound.
\item  returns itself.
\end{compact}


\subsection{Programming examples}


We now consider some programming examples in the language. We assume that , , , and  are labels, ordered in the obvious way. We assume that the top-level process always runs with , which is the most trusted label. 

\begin{example}\label{eg:1} \rm Suppose that a  user opens an Internet browser  with 
privileges (recall UAC), and clicks on a  that contains ; the virus contains code to overwrite
the command shell executable , which has label . 
This code may eventually reduce to 

However, at this point the write to  blocks due to
access control. (Recall that a process with label  cannot write to an
object with label .)
\end{example}

\begin{example}\label{eg:2} \rm
Next, consider the following attack, based on the ({\bf Copy, protect, and execute}) attack in Section \ref{vista}. 
A  user 
downloads a virus from the Internet that contains code to erase the user's home directory (), and saves it by default in . A 
administrator protects and executes .

This code may eventually reduce to 

The user's home directory may be erased at this point.  (Recall that access control does not prevent a process with label  from writing to an
object with label .)
\end{example}

\subsection{An overview of DFI}\label{introDFI}
Informally, DFI requires that objects whose contents are trusted at some label  never contain values that flow from labels lower than . In Example~\ref{eg:1}, we trust the contents of  at label , as declared by the static annotation . DFI is \emph{not} violated in this example, since access control prevents the flow of data from  to . On the other hand, in Example \ref{eg:2}, we trust the contents of  at label . DFI \emph{is} violated in this example, since the value  flows from  to . 

By design, DFI is a safety property  \cite{alpernschneider}---roughly, it can be defined as a set of behaviors such that for any behavior that not in that set, there is some finite prefix of that behavior that is not in that set. To that end, DFI considers only \emph{explicit} flows of data. Denning and Denning characterizes explicit flows~\cite{denningcert} roughly as follows: a flow of  is explicit if and only if the flow depends abstractly on  (that is, it depends on the existence of , but not on the value ). Thus, for example, the violation of DFI in Example \ref{eg:2} does not depend on the value ---\emph{any} other value causes the same violation. Conversely,  is not dangerous in itself. Consider the reduced process 
in Example \ref{eg:2}. Without any knowledge of execution history, we cannot conclude that DFI is violated in . Indeed, it is perfectly legitimate for a -process to execute the code  
intentionally, say as part of administration. However, in Example~\ref{eg:2}, we know that this code is executed by unpacking some code designed by a -process. The violation of DFI is \emph{due to this history}. 

It follows that in order to detect violations of DFI, we must distinguish between various instances of a value, and track the sources of those instances during execution. 
We maintain this execution history in
the operational semantics (Section \ref{semantics}), by a technique based on explicit substitution \cite{abadi90explicit}. 

Before we move on, let us ease the tension between DFI and conditionals. In general, conditionals can cause implicit flows~\cite{denningcert}; a flow of  can depend on the value  if  appears in the condition of some code that causes that flow. For example, the code

causes an implicit flow of  to  that depends on the value . We can abstract away this dependency by interpreting the code  as the code . Recall that DFI is a safety property. Following \cite{lamport77}, the safety of  can be expressed by the logical formula , where  is the formula that expresses the safety of , and  is the formula that expresses the safety of . Likewise, the safety of  can be expressed by the formula . Clearly, we have  , so that the code  is a refinement of the code . It is well-known that safety is preserved under refinement \cite{lamport77}.

But implicit flows are of serious concern in many applications; one may wonder whether focusing on explicit flows is even desirable. Consider the code above; the implicit flow from  to  violates noninterference, if  is an untrusted value and the contents of  are trusted. In contrast, DFI is \emph{not} violated in the interpreted code 

if  and  are trusted values. Clearly, DFI ignores the implicit flow from  to . But this may be fine---DFI can be used to prove an invariant such as ``the contents of  are always boolean values". Note that the code

does not maintain this invariant, since  may be an arbitrary value. Thankfully, DFI \emph{is} violated in this code. 


\subsection{An operational semantics that tracks explicit flows}\label{semantics}
\begin{figure}
\cenvvv{Local reduction}{a \actsub{\labp} b\textcolor{white}{p}}{
({\bf Reduct evaluate})\vspace{-1mm}

~

({\bf Reduct new})\vspace{-1mm}

~

({\bf Reduct read})\vspace{-2.5mm}

~

({\bf Reduct write})\vspace{-1mm}

~

({\bf Reduct execute})\vspace{-1mm}

~

({\bf Reduct un/protect})\vspace{-1mm}

}
\vspace{-2mm}
\cenvvv{Structural equivalence}{a \equiv b}{
({\bf Struct bind})\vspace{-1mm}

~

({\bf Struct substitution})\vspace{-0mm}

~

({\bf Struct fork})\vspace{-1mm}

~

({\bf Struct store})\vspace{-1mm}

~

({\bf Struct equiv})\vspace{-2.5mm}

}
\vspace{-2mm}
\cenvvv{Global reduction}{a \actsub{\labp} b\textcolor{white}{p}}{
({\bf Reduct context})\vspace{-1mm}

~

({\bf Reduct congruence})\vspace{-1mm}

}
\end{figure}
We now present a chemical-style operational semantics for the language, that tracks explicit flows.\footnote{This presentation is particularly convenient for defining and proving DFI; of course, a concrete implementation of the language may rely on a lighter semantics that does not track explicit flows.}
We begin by extending the syntax with some auxiliary forms.
\begin{defn}
\mycategory{a,b}{process} \\
\entry{\cdots}{source process}\\
\entry{\omega \store{\labo} x}{store} \\
\entry{\new {x/\mu@{\labp}} a}{explicit substitution}  \\
\mycategory{\mu}{substituted value} \\
\entry{u}{value}\\
\entry{\mathsf{new}(x\mbox{ \# }\labb)}{object initialization}
\end{defn} 
The process  asserts that the object  contains  and is protected with label . A key feature of the semantics is that objects store values ``by instance"---only variables may appear in stores. 
We use explicit substitution to track and distinguish
between the sources of various instances of a substituted value. 
Specifically, the process  creates a fresh variable , records that  is bound to  by a
process with label , and continues as  with  bound. Here  is an \emph{instance} of  and  is the \emph{source} of . If  is a value, then this process is behaviorally equivalent to  with  substituted by . For example, in Example \ref{eg:2} the source of the instance of  in  is ; this fact is described by rewriting the process  as 

DFI prevents this particular instance () of  from being written to ; but it allows other instances whose sources are at least as trusted as . The rewriting follows a structural equivalence rule (\srule{bind}), explained later in the section.

While explicit substitution has been previously used in language implementations, we seem to be the first to adapt this device to track data flow in a concurrent language. In particular, we use explicit substitution both to specify DFI (in Definitions \ref{flowsdef} and \ref{locintdef1}) and to verify it statically (in proofs of Theorems \ref{subjred} and \ref{mainthm}).
We defer a more detailed discussion on this technique to Section~\ref{concl}.


We call sets of the form 
\emph{substitution environments}. \begin{definition}[Explicit flows]\label{flowsdef} A variable  flows from a label  or lower in a substitution environment , written , if  for some  and  such that either , or  is a variable and (inductively) .
\end{definition}
In other words,  flows from a label  or lower if  is an instance of a value substituted at  or lower. 
In Definition~\ref{locintdef1} below, we formalize DFI as a property of objects, as follows: \emph{an object is protected from label  if it never contains instances that flow from  or lower.} 
We define  to be the set of values in  that  is an instance of: , and if (inductively)  and  for some  and , then . 
The operational semantics ensures that substitution environments accurately associate instances of values with their runtime sources. 

We now present rules for local reduction, structural equivalence, and global reduction.
Reductions are of the form , meaning that ``process  
may reduce to process  with label  in
substitution environment ''. Structural equivalences are of the form , meaning that ``process  may be rewritten as process ''.
The notions
of free and bound variables ( and ) are
standard. 
We write  if , that is, there is a value that both  and  are instances of.


We first look at the local reduction rules.
In (\rrule{evaluate\-}), a substitution binds  to the intermediate value  and associates  with its
runtime source . 
(\rrule{new}) creates a new store denoted by a fresh variable , initializes the store, and returns ; a substitution binds  to the initialization of the new object and associates  with its runtime source . The value  and the trust annotation  in the initialization are used by the type system (Section \ref{typ}).
The remaining local reduction rules describe reactions with a store, following the informal semantics.

Next, we define evaluation contexts \cite{evalcontext}. An evaluation context is of the form , and contains a hole of the form ; the context yields a process that executes with label
 in substitution environment , if the hole is plugged by a process that executes with label  in substitution environment .
\begin{defn2}
\mycategory{\mathcal E_{\labp;\sigma}}{evaluation context} \\
\entry{\bullet_{\labp;\sigma}}{hole} \\
\entry{\eval x {\mathcal E_{\labp;\sigma}} b}{sequential evaluation} \\
\entry{\fork{\mathcal E_{\labp;\sigma}} b}{fork left} \\
\entry{\fork a \mathcal E_{\labp;\sigma}}{fork right} \\
\entry{\new {x/\mu @\labp'} \mathcal E_{\labp;\{x/\mu@\labp'\}\cup \sigma}}{explicit substitution} \\
\entry{[\labp']~\mathcal E_{\labp';\sigma}~~~~~(\labp' \sqsubseteq \labp)}{lowering of process label}
\end{defn2}
Evaluation can proceed sequentially inside  processes, and in parallel under forks \cite{gordon98concurrent}; it can also proceed under
explicit substitutions and lowering of process labels. 
In particular, note how evaluation contexts build substitution environments from explicit substitutions, and labels from changes of process labels. 
We denote by  the process obtained by plugging the
hole  in  with . 

Next, we look at the structural
equivalence and global reduction rules. In (\srule{bind}),  is the process obtained from  by the usual capture-avoiding substitution of  by . The rule states that explicit substitution may \emph{invert} usual substitution to create instances as required. In particular, variables that appear in packed code can be associated with the label of the process that packs that code, even though those variables may be bound later---by (\rrule{evaluate})---when that code is eventually unpacked at some other label. For example, the instance of  in  may be correctly associated with  (the label at which it is packed) instead of  (the label at which it is unpacked). Thus, in combination, the rules (\rrule{evaluate}) and (\srule{bind}) track precise sources of values by explicit substitution. 


By (\srule{substitution}), substitutions can float across contexts under standard scoping restrictions. 
By (\srule{fork}), forked processes can float across contexts \cite{gordon98concurrent}, but must remain under the same
process label. By (\srule{store}), stores can be shared across further contexts. 

Reduction is extended with contexts and structural equivalence in the natural way.


Finally, we formalize DFI in our language, as promised. 
\begin{definition}[DFI]\label{locintdef1} The object  is protected from label  by process 
  if there is no process , substitution environment , and instance  such that  and .
\end{definition}


\section{A type system to enforce DFI}\label{typ}
We now show a type system to enforce DFI in the language. (The formal protection guarantee for well-typed code appears in Section~\ref{Results}.) We begin by introducing types and typing
judgments. We then present typing rules and informally
explain their properties. Finally, we consider some examples of typechecking. An efficient algorithm for typechecking is outlined in Appendix \ref{algo}. 

\subsection{Types and effects}
\begin{figure}
\cenvvv{Core typing judgments}{\Gamma \vdash_{\labp} a : T}{
({\bf Typ unit})\vspace{-1mm}

~

({\bf Typ variable})\vspace{-1mm}

~

({\bf Typ fork})\vspace{-0mm}

~

({\bf Typ limit})\vspace{-1mm}

~

({\bf Typ evaluate})\vspace{1mm}

~

({\bf Typ substitute})\vspace{1mm}

~

({\bf Typ store})\vspace{1mm}

~

({\bf Typ new})\vspace{-1mm}

~

({\bf Typ pack})\vspace{-0mm}

~

({\bf Typ un/protect})\vspace{1mm}

~

({\bf Typ write})\vspace{1mm}

~

({\bf Typ read})\vspace{1mm}

~

({\bf Typ execute})\vspace{1mm}

}
\end{figure}
The core grammar of types is shown below. Here effects are simply labels; these labels belong to the same ordering  as in the operational semantics. \begin{defn}
\mycategory{\tau}{type}\\
\entry{\mathbf{Obj}(T)}{object} \\
\entry{\nabla_{\labp}.~\mathbf{Bin}(T)}{packed code} \\
\entry{\mathbf{Unit}}{unit} \\
\mycategory{T}{static approximation}\\
\entry{\tau^\labt}{type and effect}
\end{defn}
\begin{compact}
\item The type  is given to an object that
  contains values of type . Such contents may not flow from labels lower than ; in other words,  indicates the trust on the contents of this object. DFI follows from the soundness of object types.
\item The type  is given to packed
  code that can be run with label . Values returned by the code must be of type  and
  may not flow from labels lower than~. In fact, our type system admits a subtyping rule that allows such code to be run in a typesafe manner with any label that is at most .
\item The effect  is given to a value that does not flow from labels lower than . 
\end{compact}
When creating an object, the programmer declares the trust on the contents of that object. 
Roughly, an object returned by  gets a type .
For example, in Examples \ref{eg:1} and \ref{eg:2}, we declare the trust  on the contents of  and the trust  on the contents of .

A typing environment  contains 
typing hypotheses of the form . We assume that any variable has at most one typing hypothesis in , and define  as the set of variables that have
typing hypotheses in . 
A typing judgment is of the
form , where  is the label of the process ,  is the type and effect of values returned by , and  .


\subsection{Core typing rules}\label{core}




In the previous page, we present typing rules that enforce the core static discipline required for our protection guarantee. Some of these rules have side conditions that involve a predicate  on labels. These conditions, which are marked in \textshade[.91]{sharpcorners}{\gdef\outlineboxwidth{0.01}shaded boxes}, are ignored in our first reading of these rules. (The predicate  is true everywhere in the absence of a special label , introduced later in the section.) One of the rules has a condition that involves a predicate  on expressions; we introduce that predicate in the discussion below.
The typing rules preserve several invariants.
\begin{compactenum3}
\item Code that runs with a label  cannot return values that have effects higher than .
\item The contents of an object of type  cannot have effects lower than . 
\item The dynamic label that protects an object of type  cannot be lower than . 
\item An object of type  cannot be created at a label lower than . \item Packed code of type  must remain well-typed when unpacked at any label lower than .
\end{compactenum3}
Invariant (1) follows from our interpretation of effects. To preserve this invariant in \trule{variable}, for example, the effect of  at  is obtained by lowering 's effect in the typing environment with .


In \trule{store}, typechecking is independent of the process label, that is, a store is well-typed if and only if it is so at any process label; recall that by (\srule{store}) stores can float across contexts, and typing must be preserved by structural equivalence. Further, \trule{store} introduces Invariants (2) and (3). Invariant (2) follows from our interpretation of static trust annotations. To preserve this invariant we require Invariant (3), which ensures that access control prevents code running with labels less trusted than  from writing to objects whose contents are trusted at . 

By \trule{new}, the effect  of the initial content of a new object cannot be lower than . Recall that by (\rrule{new}), the new object is protected with the process label ; since  by Invariant (1), we have , so that both Invariants (2) and (3) are preserved. Conversely, if  then the process does not typecheck; Invariant (4) follows. 

Let us now look carefully at the other rules relevant to Invariants (2) and (3); these rules---combined with access control---are the crux of enforcing DFI. 
\trule{write} preserves Invariant (2), restricting trusted code from writing values to  that may flow from labels lower than . (Such code may not be restricted by access control.) Conversely, access control prevents code with labels lower than  from writing to , since by Invariant (3), 's label is at least as trusted as~. 
\trule{un/protect} preserves Invariant (3), allowing 's label to be either raised or lowered without falling below~. 
In \trule{read}, the effect of a value read from  at~ is approximated by ---the least trusted
label from which 's contents may flow---and further lowered with  to preserve Invariant~(1). 


In \trule{pack}, packing code requires work akin to proof-carrying
code~\cite{pcc}. Type safety for the code is proved and ``carried" in its type
, independently of the current process label. Specifically, it is proved that when the packed code
is unpacked by a process with label , the value of executing that code has type and effect . In Section \ref{Results} we show that such a proof in fact allows the packed code
to be unpacked by any process with label , and the type and effect of the value of executing that code can be related to  (Invariant (5)). 
This invariant is key to decidable and efficient typechecking (Appendix \ref{algo}). Of course, code may be packed to run only at specific process labels, by requiring the appropriate label changes.

Preserving Invariant (5) entails, in particular, preserving Invariant (4) at all labels . Since a  expression that is not guarded by a change of the process label may be run with any label , that expression must place the least possible trust on the contents of the object it creates. This condition is enforced  by predicate  :

\trule{execute} relies on Invariant (5); further, it checks that the label at which the code is unpacked () is at most as trusted as the label at which the code may have been packed (approximated by ). This check prevents privilege escalation---code that would perhaps block if run with a lower label cannot be packed to run with a higher label. For example, recall that in Example \ref{eg:2}, the code 
is packed at  and then copied into . While a -process can legitimately execute  (so that the code is typed and is not blocked by access control), it should not run that code by unpacking  from . The type system prevents this violation. Let  be of type . Then \trule{store} requires that , and \trule{execute} requires that  (contradiction). 

Because we do not maintain an upper bound on the dynamic label of an executable, we cannot rely on the lowering of the process label in (\rrule{execute}) to prevent privilege escalation. (While it is possible to extend our type system to maintain such upper bounds, such an extension does not let us typecheck any more correct programs than we already do.) In Section \ref{Results}, we show that the lowering of the process label can in fact be safely
eliminated. 


In \trule{evaluate}, typing proceeds sequentially, propagating the type and effect of the intermediate process to the continuation.
\trule{substitution} is similar, except that the substituted value is typed under the process label recorded in the
substitution, rather than under the current process label. In \trule{limit}, the continuation is typed under the
changed process label. In \trule{fork}, the forked process is typed under the current process label.

\subsection{Typing rules for stuck code}\label{stuck}

\begin{figure}
\cenvvv{Stuck typing judgments}{\Gamma \vdash_{\labp} a : \mathbf{Stuck}}{
({\bf Typ escalate stuck})\vspace{-2mm}

~

({\bf Typ write stuck})\vspace{-1mm}

~

({\bf Typ un/protect stuck})\vspace{0mm}

~

({\bf Typ subsumption stuck-I})\vspace{-1mm}

~

({\bf Typ subsumption stuck-II})\vspace{0mm}

}
\end{figure}

While the rules above rely on access control for soundness, they do not \emph{exploit} runtime protection provided by access control to typecheck more programs. For example, the reduced process 
in Example~\ref{eg:1} cannot yet be typed, although we have checked that DFI is not violated in . Below we introduce \emph{stuck typing} to identify processes that provably block by access control at runtime. Stuck typing allows us to soundly type more programs by composition. 
(The general principle that is followed here is that narrowing the set of possible execution paths improves the precision of the analysis.) 
This powerful technique of combining static typing and dynamic access control for runtime protection is quite close to hybrid typechecking~\cite{hybtc}. We defer a more detailed discussion of this technique to Section \ref{concl}.

We introduce the static approximation  for processes that do not return values, but may have side effects. 
\begin{defn}
\mycategory{T}{static approximation}\\
\entry{\cdots}{code}\\
\entry{\mathbf{Stuck}}{stuck process}
\end{defn}
We now present rules for stuck-typing. As before, in our first reading of these rules we ignore the side conditions in \textshade[.91]{sharpcorners}{\gdef\outlineboxwidth{0.01}shaded boxes} (which involve the predicate ). 
\trule{write stuck} identifies code that tries to write to an object whose static trust annotation  is higher than the current process label . By Invariant (3), the label  that protects the object must be at least as high as ; thus  and the code must block at runtime due to access control. For example, let  be of type  in Example \ref{eg:1}. By \trule{write stuck}, the code  is well-typed since . \trule{un/protect stuck} is similar to \trule{write stuck}; it further identifies code that tries to raise the label of an object beyond the current process label. \trule{escalate stuck} identifies code that tries to raise the current process label. All such processes block at runtime due to access control. 

By \trule{subsumption stuck-I}, processes that are typed under stuck hypotheses are considered stuck as well. For example, this rule combines with \trule{evaluate} to trivially type a continuation  if the intermediate process  is identified as stuck. Finally, by \trule{subsumption stuck-II}, stuck processes can have any type and effect, since they cannot return values.

\subsection{Typing rules for untrusted code}\label{arbit}
Typing must guarantee protection in arbitrary environments. Since the protection guarantee is derived via a type preservation theorem, arbitrary untrusted code needs to be accommodated by the type system. 
We assume that untrusted code runs with a special label , introduced into the total order by assuming  for all . 
We now present rules that allow arbitrary interpretation of types at . 
\begin{figure}
\cenvvv{Typing rules for untrusted code}{}{({\bf Typ subsumption -I})\vspace{-1mm}

~

({\bf Typ subsumption -II})\vspace{-1mm}

}
\end{figure}

\noindent
By \trule{subsumption -I}, placing the static trust  on the contents of an object amounts to assuming any type for those contents as required. By \trule{subsumption -II}, a value that has effect  may be assumed to have any type as required. These rules provide the necessary flexibility for typing any untrusted code using the other typing rules. On the other hand, arbitrary subtyping with objects can in general be unsound---we now need to be careful when typing trusted code. For example, consider the code

A -process reads the name of an object () from a -object (), and then writes  to that object (). DFI is violated if  has type  and  flows from . Unfortunately, it turns out that this code can be typed under process label  and typing hypotheses
 
Specifically, the intermediate judgment

can be derived by adjusting the type of  in the typing environment to  with \trule{subsumption -II}. 

This source of unsoundness is eliminated if some of the effects in our typing rules are required to be trusted, that is, to be higher than . Accordingly we introduce the predicate , such that for any label ,  simply means . We now revisit the typing rules earlier in the section and focus on the side conditions in \textshade[.91]{sharpcorners}{\gdef\outlineboxwidth{0.01}shaded boxes} (which involve ). In some of those conditions, we care about trusted effects only if the process label is itself trusted. With these conditions, \trule{write} prevents typechecking the offending write above, since the effect of  in the typing environment is untrusted.

\subsection{Compromise}
The label  introduced above is an artificial construct to tolerate a degree of ``anarchy" in the type system. We may want to specify that a certain label (such as ) acts like , \emph{i.e.}, is \emph{compromised}. The typing judgment  allows us to type arbitrary code  running at a compromised label  by assuming that  is the same as , \emph{i.e.}, by extending the total order with  (so that all labels that are at most as trusted as  collapse to ). We do not consider labels compromised at runtime (as in Gordon and
Jeffrey's type system for conditional secrecy~\cite{gordonjeffrey05});
however we do not anticipate any technical difficulty in including runtime compromise in our type
system. 

\subsection{Typechecking examples}
We now show some examples of typechecking. 

We begin with the program  in Example \ref{eg:2}. Recall that DFI is violated in . Suppose that we try to derive the typing judgment 

This amounts to deriving  by assuming . 

As a first step, we apply \trule{new}, \trule{read}, \trule{write}, \trule{pack}, and \trule{evaluate}, directed by syntax, until we have the following typing environment.

The only complication that may arise is in this step is in deriving an intermediate judgment

Here, we can apply \trule{subsumption -II} to adjust the typing hypothesis of  to , so that \trule{read} may apply.

After this step, we need to derive a judgment of the form:

Now, we apply \trule{fork}. We first check that the code  is well-typed. (In fact, untrusted code is always well-typed, as we show in Section \ref{Results}.) The judgment 

typechecks by \trule{write stuck}. Thus, by \trule{pack} and \trule{evaluate}, we add the following hypothesis to the typing environment.

Let . Next, by \trule{new} and \trule{evaluate}, we add the following hypothesis to the typing environment.

Finally, the judgment 
 
can be derived by \trule{write}, after massaging the typing hypothesis for  to the required  by \trule{subsumption -II}. 

On the other hand, the process  does not typecheck; as seen above, an intermediate judgment

cannot be derived, since \trule{execute} does not apply.

To understand this situation further, let us consider some variations where \trule{execute} does apply. Suppose that the code  is forked in a new process whose label is lowered to . Then  typechecks. In particular, the following judgment can be derived by applying \trule{execute}. 
Fortunately, the erasure of  now blocks by access control at runtime, so DFI is not violated. 

Next, suppose that the static annotation for  is  instead of , and  is initialized by a process with label  instead of . Then  typechecks. In particular, the type of  in  becomes . We need to derive an intermediate judgment 

This judgment can be derived by applying \trule{write stuck} instead of \trule{write}. Fortunately, the overwrite of  now blocks by access control at runtime, so DFI is not violated. 









Finally, we sketch how typechecking fails for the violations of DFI described in Section \ref{vista}. \begin{description}
\item[{\rm (}Write and copy{\rm )}]


  Let the type of  be , where . 
  Then the write to  does not typecheck, since the value to be written is read from  and thus has some effect  such that , so that .
\item[{\rm (}Copy and execute{\rm )}]


  Let the type of  be . 
  If  then the execution of  by  does not typecheck, since . 
  If  then the write to  does not typecheck, since the value to be written is read from  and thus has some effect  such that , so that .
\item[{\rm (}Unprotect, write, and protect{\rm )}]

  Let the type of  be , where . 
  Then the unprotection of  does not typecheck, since .  
\item[{\rm (}Copy, protect, and execute{\rm )}]

  Let the type of  be , where . 
  Then the execution of  does not typecheck, since .
\end{description}



\section{Properties of typing}\label{Results}
In
this section we show several properties of typing, and prove that DFI is preserved by well-typed code under arbitrary untrusted
environments. All proof details appear in Appendix \ref{proofs}.



We begin with the proposition that untrusted code can always be accommodated by
the type system. 
\begin{definition}[Adversary] A -adversary is any process of the form  that does not contain stores, explicit substitu\-tions, and static trust annotations that are higher than .
\end{definition}
\begin{proposition}[Adversary completeness]\label{advtyp} Let
   be any typing environment and  be any -adversary such that .
Then .
\end{proposition}
Proposition \ref{advtyp} provides a simple way to quantify over arbitrary environments. By \trule{fork} the composition of a well-typed process with any such environment remains well-typed, and thus enjoys all the properties of typing. 

Next, we present a monotonicity property of typing that is key to decidable and efficient typechecking (Appendix \ref{algo}). \begin{proposition}[Monotonicity]\label{mono} The following inference rule is admissible.

\end{proposition}
This rule formalizes Invariant (5), and allows inference of ``most general" types for packed code (Appendix \ref{algo}). Further, it implies an intuitive proof principle---code that is proved safe to run with higher privileges remains safe to run with lower privileges, and 
conversely, code that is proved safe against a more powerful adversary remains safe against a less powerful adversary. 

The key property of typing is that it is preserved by structural equivalence and reduction. Preservation depends delicately on the design of the typing rules, relying on the systematic maintenance of typing invariants. We write , meaning that ``the substitution environment  is consistent with the typing environment ", if for all  there exists  such that  and .

\begin{theorem}[Preservation]\label{subjred}
  Suppose that  and . Then 
\begin{itemize}
\item if  then ;
\item if  then .
\end{itemize}
\end{theorem}
We now present our formal protection guarantee for well-typed code. 
We begin by strengthening the definition of DFI in Section \ref{calc}. In particular, we assume that part of the adversary is known and part of it is unknown. This assumption allows the analysis to exploit any sound typing information that may be obtained from the known part of the adversary. (As a special case, the adversary may be entirely unknown, of course. In this case, we recover Definition \ref{locintdef1}; see below.) Let  be the set of objects that require protection from labels  or lower. We let the unknown part of the adversary execute with some process label  (). 
We say that  is protected if no such adversary can write any instance that flows from  or lower, to any object in .
\begin{definition}[Strong DFI]\label{locintdef} A set of objects  is protected by code  from label  despite  ()
  if there is no , -adversary , substitution environment , and instance  such that  and .
\end{definition}
For example, we may want to prove that some code protects a set of -objects from  despite (the compromised label) ; then we need to show that no instance may flow from  or lower to any of those -objects under any -adversary.

We pick objects that require protection based on their types and effects in the typing environment.
\begin{definition}[Trusted objects] The set of objects whose contents are trusted beyond the label  in the typing environment  is .
\end{definition}
Suppose that in some typing environment,  is the set of objects whose contents are trusted beyond label , and  () is compromised; we guarantee that  is protected by any well-typed code from  despite .
\begin{theorem}[Enforcement of strong DFI]\label{mainthm} Let
   be the set of objects whose contents are trusted beyond  in . Suppose that , where . Then 
  protects  from  despite . 
\end{theorem}
In the special case where the adversary is entirely unknown, we simply consider  and  to be the same label. 

The type system further enforces DFI for new objects, as can be verified by applying Theorem \ref{subjred}, \trule{substitute}, and Theorem \ref{mainthm}. 
Finally, the type system suggests a sound runtime optimization:
whenever a well-typed process executes packed code in a trusted context, the current process label is already appropriately lowered for execution. 
\begin{theorem}[Redundancy of execution control]\label{optim} Suppose that  and  
 such that  and . Then . \end{theorem}
It follows that the rule (\rrule{execute}) can be safely optimized as follows.

This optimization should not be surprising. Lowering the process label for execution aims to prevent trusted code from executing untrusted code in trusted contexts; our core static discipline on trusted code effectively subsumes this runtime control. 
 On the other hand, write-access control cannot be eliminated by any discipline on trusted code, since that control is required to restrict untrusted code. 

Lastly, typechecking can be efficiently mechanized thanks to Proposition \ref{mono} and our syntactic restriction on nested packing. 
A typechecking algorithm is outlined in Appendix \ref{algo}.
\begin{theorem}[Typechecking]\label{decide} Given a typing environment  and code  with  distinct labels, the problem of whether there exists  such that , is decidable in time , where  is the size of .
\end{theorem}













\section{Limitations, related work, and discussion}\label{concl}


In this paper we formalize DFI---a multi-level integrity property based on explicit flows---and present a type system that can efficiently enforce DFI in a language that simulates Windows Vista's security environment. 

Not surprisingly, our type system is only a conservative technique to enforce
DFI---while every program that typechecks is guaranteed to
satisfy DFI (as stated in Theorem~\ref{mainthm}), 
well-typedness is not necessary for DFI. 


By design, our analysis is control-insensitive---it does not track implicit flows. In many applications, implicit flows are of serious concern. It remains possible to extend our analysis to account for such flows, following the ideas of \cite{vis,robustdeclass,myers04enforcing,lipopl}. However, we believe that it is more practical to enforce a weaker property like DFI at the level of an operating system, and enforce stronger, control-sensitive properties like noninterference at the level of the application, with specific assumptions. 

Our core security calculus is simplified,
although we take care to include all aspects that require conceptual modeling 
for reasoning
about DFI.
In particular, we model threads, mutable references, binaries, and data and code pointers; other features of x86 binaries, 
such as recursion, control flow, and parameterized procedures, can be encoded in the core calculus.
We also model all details of Windows Vista that are relevant for mandatory integrity control with dynamic labels. On the other hand, we do not model details 
such as discretionary access control, file virtualization, and secure authorization of privilege escalation \cite{bppvista}, which can improve the precision of our analysis.
Building a typechecker that works at the level of x86 binaries and handles
all details of Windows Vista requires more work. At the same time, we believe that our analysis can be applied to more concrete programming models by translation. 

Our work is closely related to that of Tse and
Zdancewic~\cite{runtimeprin} and Zheng and Myers \cite{dynseclab} on
noninterference in lambda calculi with dynamic security levels. While Tse and Zdancewic do not consider mutable references in their language, it is possible to encode the sequential fragment of our calculus in the language of Zheng and Myers; however, well-typed programs in that fragment that rely on access control for DFI do not remain well-typed via such an encoding. Specifically, any restrictive access check for integrity in the presence of dynamically changing labels seems to let the adversary influence trusted computations in their system, violating noninterference~\cite{zheng}. 





Noninterference is known to be problematic for concurrent languages. In this context, Zdancewic and Myers study the notion of observational determinism \cite{obsdetconc}; Abadi, Hennessy and Riely, and others study information flow using testing equivalence~\cite{abadi99secrecy,inflowresacc}; and Boudol and Castellani, Honda and Yoshida, and others use stronger notions based on observational equivalence~\cite{boudolcastellani,linearpi}. So\-phisticated techniques that involve linearity, race analysis, behavior types, and liveness analysis also appear in the literature~\cite{linearpi,obsdetconc,inflowresacc,kobayashi05}. While most of these techniques are developed in the setting of the pi calculus, other works consider distributed and higher-order settings to study mobile code~\cite{safedpi,depHOMP,envbisim} (as in this work).

DFI being a safety property \cite{alpernschneider} gets around some of the difficulties posed by noninterference. A related approach guides the design of the operating systems  Asbestos \cite{asbestos} and HiStar \cite{histar}, and dates back to the Clark-Wilson approach to security in commercial computer systems \cite{clark-wilson,shankar}. In comparison with generic models of trace-based integrity that appear in protocol analysis, such as correspondence assertions \cite{typecorr,fournetGM05}, our integrity model is far more specialized; as a consequence, our type system requires far less annotations than type systems for proving correspondence assertions. 

Our definition of
DFI relies on an operational semantics based on
explicit substitution. Explicit substitution, as introduced by Abadi \emph{et al.} \cite{abadi90explicit}, has been primarily applied to study the
correctness of abstract machines for programming languages (whose semantics rely on substitution as a rather inefficient
meta-operation), and in proof environments. It also appears in the applied pi
calculus \cite{appliedpi} to facilitate an elegant formulation of
indistinguishability for security analysis. However, we seem to be
the first to use explicit substitutions to track explicit flows in
a concurrent language. 
Previously, dependency analysis
\cite{levylabels,cachedep} has been applied to information-flow analysis
\cite{dcc,pottier00information,ZM02}. These analyses track stronger dependencies than those induced by explicit flows; in particular, the dependencies are sensitive to control flows. In contrast, the use of explicit substitutions to track explicit flows seems rather obvious and appropriate in hindsight. We believe that this technique should be useful in other contexts as well. 

Our analysis manifests a genuine interplay between static typing and dynamic access control for runtime protection. We seem to be the first to study this interaction in a concurrent system with dynamic labels for multi-level integrity. This approach of combining static and dynamic protection mechanisms is reflected in previous work, \emph{e.g.}, on typing for noninterference in a Java-like language with stack inspection and other extensions \cite{banerjee03using,pistoia}, for noninterference in lambda calculi with runtime principals and dynamic labels~\cite{runtimeprin,dynseclab}, and for secrecy in concurrent storage calculi with discretionary access control mechanisms~\cite{sectypfac,ChaudhuriConcur06}. A verification technique based on this approach is developed by Flanagan~\cite{hybtc} for a lambda calculus with arbitrary base refinement types. In these studies and ours, dynamic checks complement static analysis where possible or as required, so that safety violations that are not caught statically are always caught at runtime. Moreover, static typing sometimes subsumes certain dynamic checks (as in our analysis), suggesting sound runtime optimizations. This approach is reflected in previous work on static access control \cite{inflowresacc,pottier-skalka-smith-toplas05,sumii}. 

In most real-world systems, striking the right balance between security and practice is a delicate task that is never far from controversy. It is reassuring to discover that perhaps, such a balance can be enforced formally in a contemporary operating system, and\linebreak possibly improved in future ones.

\paragraph{\em Acknowledgments}
We wish to thank Mart\'in Abadi, Steve Zdan\-cewic, Pavol \v{C}ern\'y,  and several anonymous reviewers for their comments on an earlier draft of this paper. We also wish to thank 
Karthik Bhargavan, Cormac Flanagan, and Lantian Zheng for various discussions on this work. 

Avik Chaudhuri's work was supported by Microsoft Research India and the National Science
Foundation under Grants CCR-0208800 and CCF-0524078.

\bibliographystyle{abbrv}
\bibliography{vista}




\appendix















\section*{Appendix}
In this appendix, we provide some additional material that may benefit the reader. First, we detail proofs of our results on typing (Appendix \ref{proofs}). Next, we outline an efficient typechecking algorithm (Appendix \ref{algo}).

\section{Proofs}\label{proofs}
\noindent
In this section we outline proofs of the results in Section \ref{Results}. 

\\
{\bf Restatement of Proposition \ref{advtyp}} (Adversary completeness) {\em Let
   be any typing environment and  be any -adversary  such that .
Then .
}
\begin{proof} We prove typability by induction on the structure of processes.
\begin{itemize}
\item  where  is a variable.\\
\\
Then .\\
By \trule{value} .\\
\item .\\
\\
By I.H. \\
Then .\\
By \trule{new} .\\
\item .\\
\\
By I.H. .\\
So by \trule{value} .
\begin{description}
\item[Case]  and  is not of the form .\\
By \trule{bogus stuck-I} .
\item[Case] , , and .\\
By \trule{un/protect stuck} .
\item[Case] , , and .\\
Then .\\
By \trule{value} and \trule{un/protect} \\
 .
\item[Case] .\\
By \trule{subsumption -II} \\
  such that .\\
By \trule{value} and \trule{un/protect} \\
 .
\end{description}

\item .\\
\\
By I.H. .\\
So by \trule{value} .
\begin{description}
\item[Case]  and  is not of the form .\\
By \trule{bogus stuck-I} .
\item[Case]  and .\\
By \trule{read} .
\item[Case] .\\
By \trule{subsumption -II} .\\
By \trule{read} .
\end{description}

\item .\\
\\
By I.H.  and .\\
So by \trule{value} .
\begin{description}
\item[Case]  and  is not of the form .\\
By \trule{bogus stuck-I} .
\item[Case] , , and .\\
By \trule{write stuck} .
\item[Case] , , and .\\
Then .\\
By \trule{value} and \trule{write} .
\item[Case] .\\
By \trule{subsumption -II} \\
  such that .\\
By \trule{value} and \trule{write} .
\end{description}

\item .\\
\\
By I.H. .\\
By \trule{pack} .\\
\item .\\
\\
By I.H. , so by \trule{value} .
\begin{description}
\item[Case]  and  is not of the form .\\
By \trule{bogus stuck-I} .
\item[Case] , , \\
 and  is not of the form .\\
By \trule{bogus stuck-II} .
\item[Case] , , and .\\
Then .\\
By \trule{execute} .
\item[Case] .\\
By \trule{subsumption -II} \\
  and \\
 such that .\\
By \trule{execute} .
\item[Case] , , and .\\
By \trule{subsumption -I}\\
  such that .\\
By \trule{execute} .
\end{description}

\item .\\
\\
If  then by \trule{escalate} .\\
Otherwise by I.H. .\\
 By \trule{limit} .\\
\item .\\
\\
By I.H. \\
 and  .\\
By \trule{evaluate} .\\
\item .\\
\\
By I.H. \\
 and  .\\
By \trule{fork} .  \qedhere
\end{itemize}
\end{proof}
\\
{\bf Restatement of Proposition \ref{mono}} (Monotonicity) {\em
The following typing rule is admissible.

}
\begin{proof} We proceed by induction on the structure of derivations.\\
\\
Suppose that .
\begin{description}
\item[Case (Typ variable)] 

By \trule{value} .\\
Here .\\
\item[Case (Typ new)]

By I.H. \\
Then .\\
By \trule{new} .\\
Here .\\
\item[Case (Typ fork)]

Let .\\
By I.H.  and .\\
By \trule{fork} .\\
\item[Case (Typ store)]

By \trule{store} .\\
Here .\\
\item[Case (Typ un/protect)]

By I.H. \\
and if  then , then , and then .\\
By \trule{un/protect} .\\
\item[Case (Typ write)]

By I.H.  and \\
and if  then , then , and then \\
and .\\
If  then .\\
 By \trule{write} .\\
Otherwise , so that .\\
 Because , we have  and thus .\\
 By \trule{value}  and .\\
 Then .\\
 By \trule{write stuck} . \\
 By \trule{subsumption stuck-II} 
 . \\
\item[Case (Typ execute)]

\\
and if  then , and then .\\
By \trule{execute} .\\
Here .\\
\item[Case (Typ read)]

If  then , and then .\\
By \trule{read} .\\
Here .\\
\item[Case (Typ limit)]

Let .\\
Then .\\
If  then\\
 .\\
 By \trule{limit} .\\
Otherwise .\\
By \trule{escalate stuck} .\\
By \trule{subsumption stuck-II} .\\
\item[Case (Typ evaluate)]

Let .\\
By I.H.  and .\\
By \trule{evaluate} .\\
\item[Case (Typ substitute)]

Let .\\
By I.H. .\\
By \trule{substitute} \qedhere
\end{description}
\end{proof}
\begin{lemma}[Bind]\label{application} Suppose that . Then  if and only if .
\end{lemma}
\begin{proof} By induction on the structure of .
\end{proof}
\\
{\bf Restatement of Theorem \ref{subjred}} (Type preservation) {\em
  Suppose that  and . Then \begin{enumerate}
\item If  then .
\item If  then .
\end{enumerate}
}
\begin{proof}[Proof of (1)] We prove preservation under  by induction on the structure of derivations.
\begin{defn2}
\mycategory{\mathcal E_{\lab;\sigma}}{evaluation context} \\
\entry{\bullet_{\lab;\sigma}}{hole} \\
\entry{\eval x {\mathcal E_{\lab;\sigma}} b}{evaluate sequential} \\
\entry{\fork{\mathcal E_{\lab;\sigma}} b}{fork child} \\
\entry{\fork a \mathcal E_{\lab;\sigma}}{fork parent} \\
\entry{\new {x/\mu @\lab'} \mathcal E_{\lab;\{x/\mu@\lab'\}\cup \sigma}}{restrict substitution} \\
\entry{[\lab']~\mathcal E_{\lab';\sigma}~~~~~(\lab' \sqsubseteq \lab)}{lower process label}
\end{defn2}
\\
{\bf Case (Struct substitution)}

 Let .
\begin{itemize}
\item 
\\
\\
and .\\
  \\
By \trule{substitute} and \trule{evaluate}\\
 \\
 and \\
 and .\\
By \trule{substitute} and S.R.\\
 \\
 and .\\
By I.H. .\\
By \trule{evaluate}\\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{substitute} and \trule{fork} \\
 \\
 and \\
 and .\\
By \trule{substitute} and S.R.\\
 \\
 and .\\
By I.H. .\\
By \trule{fork}\\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{substitute} and \trule{fork} \\
 \\
 and \\
 and .\\
By \trule{substitute} and S.R.\\
 \\
 and .\\
By I.H. .\\
By \trule{fork}\\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{substitute} and \trule{substitute} \\
 \\
 and \\
 and .\\
By \trule{substitute} and S.R.\\
 \\
 and \\
 and .\\
By \trule{substitute} \\
 .\\
By I.H. .\\
By \trule{substitute} \\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{substitute} and \trule{limit} \\
  \\
 and .\\
By \trule{substitute} \\
 .\\
By I.H. .\\
By \trule{limit} \\
 .
\end{itemize}
{\bf Case (Struct fork)}

\begin{itemize}
\item 
\\
\\
 and .\\
  \\
By \trule{fork} and \trule{evaluate} \\
 \\
 and \\  
 and .\\
By \trule{fork} \\
 \\  
 and .\\
By I.H. .\\
By \trule{evaluate} \\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{fork} and \trule{fork} \\
 \\
 and \\  
 and .\\
By \trule{fork} \\
 \\  
 and .\\
By I.H. .\\
By \trule{fork} \\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{fork} and \trule{fork} \\
 \\
 and \\  
 and .\\
By \trule{fork} \\
 \\  
 and .\\
By I.H. .\\
By \trule{fork} \\
 .\\
\item 
\\
\\
 and .\\
  \\
By \trule{fork} and \trule{substitute} \\
 \\
 and \\
 and .\\
By S.R. .\\
By \trule{fork} \\
 .\\
By I.H. .\\
By \trule{substitute} \\
 .
\end{itemize}
{\bf Case (Struct store)}
    
\\
\\
 and .\\
  \\
By \trule{fork} \\
  \\
 and .\\
By \trule{limit} \\
  \\
 and .\\
By \trule{fork} .\\    
By \trule{limit} .\\
\\
{\bf Case (Struct bind)}\\
By Lemma \ref{application}.
\end{proof}
\begin{proof}[Proof of (2)] We prove preservation under  by induction on the structure of derivations.\\
\\
{\bf Case (Reduct evaluate)}

.\\
\\
By \trule{evaluate} \\
  \\
 and .\\
By \trule{substitute}  .\\
\\
{\bf Case (Reduct new)}

.\\
\\
By \trule{new} \\
 , \\
 , \\
 and .\\
By \trule{store} .\\
By \trule{fork} .\\
By \trule{substitute} \\ 
 .\\
\\
{\bf Case (Reduct read)}

.\\
\\
By \trule{fork}\\
 . \\
By \trule{store} .\\
By \trule{fork} . \\
\\
{\bf Case (Reduct write)}

.\\
\\
By \trule{fork}\\
  \\
 and \\
and .\\
\\
By \trule{store}, \trule{write}, and \\
 ,\\
 , \\
 , \\
 , \\
 and .\\
\\
By \trule{store} . \\
By \trule{unit} . \\
By \trule{fork} .\\
\\
{\bf Case (Reduct execute)}

.\\
\\
By \trule{fork}\\
  \\
 and .\\
\\
By \trule{store}, \trule{execute}, and \\
  for some ,\\
 ,\\
 ,\\
 ,\\
 and . \\
\\
By \trule{pack} .\\
By \trule{subsumption process label} .\\
By \trule{fork} .\\
\\
{\bf Case (Reduct un/protect)}

.\\
\\
By \trule{fork}\\
   \\
 and \\
 .\\
\\
By \trule{store}, \trule{un/protect}, and , \\
 ,\\
 , \\
 ,\\
 and . \\
\\
By \trule{store} .\\
By \trule{unit} .\\
By \trule{fork} .\\
\\
{\bf Case (Reduct context)}

\begin{defn2}
\mycategory{\mathcal E_{\lab;\sigma}}{evaluation context} \\
\entry{\bullet_{\lab;\sigma}}{hole} \\
\entry{\eval x {\mathcal E_{\lab;\sigma}} b}{evaluate sequential} \\
\entry{\fork{\mathcal E_{\lab;\sigma}} b}{fork child} \\
\entry{\fork a \mathcal E_{\lab;\sigma}}{fork parent} \\
\entry{\new {x/\mu @\lab'} \mathcal E_{\lab,\{x/\mu@\lab'\}\cup \sigma}}{restrict substitution} \\
\entry{[\lab']~\mathcal E_{\lab';\sigma}~~~~~(\lab' \sqsubseteq \lab)}{lower process label}
\end{defn2}
\begin{itemize}
\item ,\\
 ,\\
 and .\\
\\
By (\rrule{context}) and \trule{evaluate} \\
 ,\\
 , \\
 and .\\
By I.H. .\\
By \trule{evaluate} \\
 .\\
\item ,\\
 ,\\
 and .\\
\\
By (\rrule{context}) and \trule{fork} \\
 ,\\
 , \\
 and .\\
By I.H. .\\
By \trule{fork} \\
 .\\
\item ,\\
 ,\\
 and .\\
\\
By (\rrule{context}) and \trule{fork} \\
 ,\\
 , \\
 and .\\
By I.H. .\\
By \trule{fork} \\
 .\\
\item ,\\
 ,\\
 and .\\
\\
By (\rrule{context}) and \trule{substitute} \\
 ,\\
 and ,\\
 and .\\
By I.H. .\\
By \trule{substitute} \\
 .\\
\item ,\\
 ,\\
 and .\\
\\
By (\rrule{context}) and \trule{limit} \\
 \\
 and .\\
By I.H. .\\
By \trule{limit} \\
 .
\end{itemize}
{\bf Case (Reduct congruence)}

,\\
 ,\\
 , \\ 
 and .\\
\\
By Theorem \ref{subjred}(1) .\\
By I.H. .\\
So by Theorem \ref{subjred}(1) .
\end{proof}
\\
{\bf Restatement of Theorem \ref{mainthm}} (Enforcement of strong DFI) {\em Let
   be the set of objects whose contents are trusted beyond  in . Suppose that , where . Then 
  protects  from  despite . 
}
\begin{proof} Let  be any -adversary . \\
By Proposition \ref{advtyp} . \\
By \trule{fork} . \\
\\
Suppose that . We need to prove that there are no  and  such that 
and . Assume otherwise.\\
\\
By Theorem \ref{subjred} there exists  extending  such that \\
 and .\\
By \trule{store}  such that .\\
We proceed by induction on the derivation of .
\begin{description}
\item[Case] .\\
For some  and , .\\
Then  and by \trule{value} .\\
Then .\\
Then .\\
But by assumptions  (contradiction).
\item[Case]  for some  and .\\
By I.H.  for some  such that .\\
Then .\\
But by assumptions  (contradiction). \qedhere
\end{description}
\end{proof}
\noindent
{\bf Restatement of Theorem \ref{optim}} (Redundancy of execution control) {\em Suppose that  and  
 such that , and . Then .
}
\begin{proof} The proof is by inspection of Case (Reduct execute) in the proof of Theorem \ref{subjred}. Recalling that case (where  is the process label): .
\end{proof}












\section{An efficient typechecking algorithm}\label{algo}
\begin{figure}
\cenvvv{Typechecking judgments for processes}{\Gamma \vdash_{\labp} a : T \rhd \Gamma'}{
({\bf Typc value}) \vspace{-1mm}

~

({\bf Typc new}) \vspace{-1mm}

~

({\bf Typc pack}) \vspace{-1mm}

~

({\bf Typc fork}) \vspace{-1mm}

~

({\bf Typc evaluate}) \vspace{-1mm}

~

({\bf Typc read}) \vspace{-1mm}

~

({\bf Typc write}) \vspace{-1mm}

~

({\bf Typc execute}) \vspace{-1mm}

~

}
\end{figure}
\begin{figure}
\cenvvv{Typechecking judgments for expressions}{\Gamma \vdash f : T \rhd \Gamma'}{
({\bf Typc ? value}) \vspace{-2mm}

~

({\bf Typc ? limit}) \vspace{-1mm}

~

({\bf Typc ? read}) \vspace{-1mm}

~

({\bf Typc ? write}) \vspace{-1mm}

~

({\bf Typc ? execute}) \vspace{-1mm}

~

({\bf Typc ? fork}) \vspace{-1mm}

~

({\bf Typc ? evaluate}) \vspace{-1mm}

~

}
\vspace{-2mm}
\cenvvv{Satisfiability of constraints}{\Gamma \vdash \diamond}{
({\bf Typc  obj}) \vspace{-2mm}

~

({\bf Typc  bin}) \vspace{-1mm}

~

({\bf Typc  left}) \vspace{-1mm}

~

({\bf Typc  right}) \vspace{-1mm}

~

({\bf Typc  middle}) \vspace{-1mm}

~

}
\end{figure}

\noindent
Finally, we outline an efficient algorithm to mechanize typechecking. Broadly, the algorithm builds constraints and then checks whether those constraints are satisfiable. The only complication is due to  processes, which require a ``most general" type. We extend the grammar of types with type variables , and introduce a distinguished label  denoting an ``unknown" label. We extend the grammar of typing environments with constraints of the form  and label constraints (\emph{i.e.}, boolean formulae over atoms of the form ).  Next, we introduce the following typechecking judgments: 
\begin{itemize}
\item , where  contains constraints of the form  only (\emph{i.e.}, the label constraint in  is true). 
\item , where  may contain a label constraint as well as constraints of the form . 
\end{itemize}
We now present some sample typechecking rules, followed by rules that interpret . Let us first look at the rules for deriving judgments of the form . These rules build constraints of the form  in . We elide by dots () label constraints that appear in the original typing rules. Let  denote the typing environment obtained from  by replacing all occurrences of  with . We write  iff  is the highest  for which the label constraint in  is true. Note that to derive a judgment of this form for a process , we need to derive a judgment of the other form for . In fact, the two kinds of judgments are mutually recursive (see below).


Next, we look at the rules for deriving judgments of the form . These rules apply to expressions that are not explicitly under a change of the process label, \emph{e.g.}, expressions obtained by unpacking  processes. They build label constraints from those that appear in the original typing rules; the implicit (unknown) process label is replaced by . Predicate  ensures that we do not need to consider  processes here; further we can assume that all annotations carry the least trusted label. Once we have an expression of the form , we can derive a judgment of the other form for .


Finally, we look at the rules that interpret constraints of the form . Here  denotes a subtyping relation that is invariant in  and covariant in , and preserves monotonicity. We introduce the judgment  to check satisfiability of such constraints.

We prove that typechecking is sound and complete.
\begin{proposition}
The typing judgment  can be derived if and only if the typechecking judgment  can be derived for some  and  such that .  
\end{proposition}
\noindent
Further, typechecking terminates in time  if  and  have  distinct labels. Indeed, let  be the running time of the judgment , and  be the total running time of the judgments  and  for some . 

Building constraints for the typechecking judgment  takes time 
 if  contains as subterms the  processes  without nesting. Checking the satisfiability of those constraints reduces to detecting cycles in a graph, and takes time , so the total running time for typechecking is 

Next, building the label constraint for the typechecking judgment  takes time  if  contains as subterms the processes  without nesting. Finding  such that  takes time , since at most  labels need to be checked. So 

Plugging the expansion of  into the expansion of , and solving by induction: 


\end{document}
