\documentclass{article}

\usepackage{authblk}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{clrscode4e}
\usepackage{enumerate}
\usepackage[parfill]{parskip}
\raggedbottom
\allowdisplaybreaks

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{observation}{Observation}
\newtheorem{corollary}{Corollary}

\title{Approximating Dense Max 2-CSPs}
\date{\today}

\author[1]{Pasin Manurangsi\thanks{Part of this work was completed while the author was at Massachusetts Institute of Technology.}}
\author[2]{Dana Moshkovitz\thanks{This material is based upon work supported by the National Science Foundation under Grant Number 1218547.}}
\affil[1]{Dropbox, Inc.\\
  San Francisco, CA 94107, USA\\
  \texttt{pasin@dropbox.com}}
\affil[2]{Massachusetts Institute of Technology \\
  Cambridge, MA 02139, USA\\
  \texttt{dmoshkov@mit.edu}}

\begin{document}
\maketitle


\begin{abstract}
In this paper, we present a polynomial-time algorithm that approximates sufficiently high-value {\sc Max 2-CSP}s on sufficiently dense graphs to within  approximation ratio for \emph{any} constant . Using this algorithm, we also achieve similar results for free games, projection games on sufficiently dense random graphs, and the {\sc Densest -Subgraph} problem with sufficiently dense optimal solution. Note, however, that algorithms with similar guarantees to the last algorithm were in fact discovered prior to our work by Feige et al. and Suzuki and Tokuyama.

In addition, our idea for the above algorithms yields the following by-product: a quasi-polynomial time approximation scheme (QPTAS) for satisfiable dense {\sc Max 2-CSP}s with better running time than the known algorithms. \\

{\bf Keywords:} {\sc Max 2-CSP}, Dense Graphs, {\sc Densest -Subgraph}, QPTAS, Free Games, Projection Games
\end{abstract}

\section{Introduction}

Maximum constraint satisfaction problem ({\sc Max CSP}) is a problem of great interest in approximation algorithms since it encapsulates many natural optimization problems; for instance, {\sc Max -SAT}, {\sc Max-Cut}, {\sc Max-DiCut}, {\sc Max -Lin}, projection games, and unique games are all families of {\sc Max CSP}s. In {\sc Max CSP}, the input is a set of variables, an alphabet set, and a collection of constraints. Each constraint's domain consists of all the possible assignments to a subset of variables. The goal is to find an assignment to all the variables that satisfies as many constraints as possible.

In this paper, our main focus is on the case where each constraint depends on exactly  variables and the alphabet size is large. This case is intensively researched in hardness of approximation and multi-prover games.

For Max -CSP with large alphabet size, the best known polynomial-time approximation algorithm, due to Charikar et al.~\cite{CHK}, achieves an approximation ratio of  where  is the number of variables and  is the alphabet size. On the other hand, it is known that, there is no polynomial-time -approximation algorithm for {\sc Max -CSP} unless NP  DTIME~\cite{Raz}. Moreover, it is believed that, for some constant , no polynomial-time -approximation algorithm exists for projection games, a family of {\sc Max -CSP} we shall introduce later, unless P = NP~\cite{M}. This is also known as the Projection Games Conjecture (PGC). As a result, if the PGC holds, one must study special cases in order to go beyond polynomial approximation ratio for {\sc Max 2-CSP}.

One such special case that has been particularly fruitful is dense {\sc Max -CSP} where density is measured according to number of constraints, i.e., an instance is -dense if there are  constraints. Note that, for convenience, we always assume that there is at most one constraint on a pair of variables. In other words, we form a simple graph by letting vertices represent the variables and edges represent the constraints. This is the interpretation that we will use throughout the paper. According to this view,  is the average degree of the graph.

In 1995, Arora, Karger and Karpinski~\cite{AKK95} invented a polynomial-time approximation scheme (PTAS) for dense Max -CSP when the density  and alphabet size  are constants. More specifically, for any constant , the algorithm achieves an approximation ratio  and runs in time . Unfortunately, the running time becomes quasi-polynomial time when  is not constant.

Another line of development of such PTASs centers around subsampling technique (e.g. ~\cite{AIM, Alon:2003:RSA:963875.963877, BMHS11}). In summary, these algorithms function by randomly sampling the variables according to some distribution and performing an exhaustive search on the induced instance. Since the sampled set of variables is not too large, the running time is not exponential. However, none of these algorithm achieves polynomial running time for large alphabets. In particular, all of them are stuck at quasi-polynomial running time.

Since none of these algorithms runs in polynomial time for large alphabet, a natural and intriguing question is how good a polynomial-time approximation algorithm can be for dense {\sc Max 2-CSP}s. In this paper, we partially answer this question by providing a polynomial-time approximation algorithm for dense high-value {\sc Max 2-CSP}s that achieves  approximation ratio for any constant . Moreover, our technique also helps us come up with a quasi-polynomial time approximation scheme for satisfiable {\sc Max 2-CSP}s with running time asymptotically better than that those from~\cite{AIM, Alon:2003:RSA:963875.963877, AKK95, BMHS11}.

The central idea of our technique is a trade-off between two different approaches: greedy assignment algorithm and ``choice reduction'' algorithm. In summary, either a simple greedy algorithm produces an assignment that satisfies many constraints or, by assigning an assignment to just one variable, we can reduce the number of optimal assignment candidates of other variables significantly. The latter is what we call the choice reduction algorithm. By applying this argument repeatedly, either one of the greedy assignments gives a high-value assignment, or we are left with only few candidate labels for each variable. In the latter case, we can then just pick a greedy assignment at the end.

Not only that our technique is useful for {\sc Max 2-CSP}, we are able to obtain approximation algorithms for other problems in dense settings as well. The first such problem is free games, which can be defined simply as {\sc Max -CSP} on balanced complete bipartite graphs. While free games have been studied extensively in the context of parallel repetition~\cite{BRR+09, S13} and as basis for complexity and hardness results~\cite{AIM, BKW15}, the algorithm aspect of it has not been researched as much. In fact, apart from the aforementioned algorithms for dense {\sc Max 2-CSP} that also works for free games, we are aware of only two approximation algorithms, by Aaronson et al.~\cite{AIM} and by Brandao and Harrow~\cite{BH13}, specifically developed for free games. Similar to the subsampling lemmas, these two algorithms are PTASs when  is constant but, when  is large, the running times become quasi-polynomial. Interestingly, our result for dense {\sc Max 2-CSP} directly yields a polynomial-time algorithm that can approximate free games within  factor for any constant , which may be the first non-trivial approximation algorithm for free games with such running time.

Secondly, our idea is also applicable for projection games. The projection games problem (also known as {\sc Label Cover}) is {\sc Max 2-CSP} on a bipartite graph where, for each assignment to a left vertex of an edge, there is exactly one satisfiable assignment to the other endpoint of the edge. {\sc Label Cover} is of great significance in the field of hardness of approximation since almost all NP-hardness of approximation results known today are reduced from the NP-hardness of approximation of projection games (e.g.~\cite{BGS,Has97}).

The current best polynomial-time approximation algorithm for satisfiable projection games is the authors' with  ratio~\cite{MM13}. Moreover, as mentioned earlier, if the PGC is true, then, in polynomial time, approximating {\sc Label Cover} beyond some polynomial ratio is unlikely. In this paper, we exceed this bound on random balanced bipartite graphs with sufficiently high density by proving that, in polynomial time, one can approximate satisfiable projection games on such graphs to within  factor for any constant .

Finally, we show a similar result for {\sc Densest -Subgraph}, the problem of finding a size- subgraph of a given graph that contains as many edges as possible. Finding best polynomial-time approximation algorithm for {\sc Densest -Subgraph}({\sc DS}) is an open question in the field of approximation algorithms. Currently, the best known algorithm for {\sc DS} achieves an approximation ratio of  for any constant ~\cite{BCCFV}. On the other hand, however, we only know that there is no PTAS for {\sc DS} unless P=NP~\cite{Khot04}.

Even though {\sc Densest -Subgraph} on general graphs remains open, the problem is better understood in some dense settings. More specifically, Arora et al.~\cite{AKK95} provided a PTAS for the problem when the given graph is dense and  where  is the number of vertices of the given graph. Later, Feige et al.~\cite{FPK01} and Suzuki and Tokuyama~\cite{ST05} showed that, if we only know that the optimal solution is sufficiently dense, we can still approximate the solution to within any polynomial ratio in polynomial time. Using our approximation algorithm for dense {\sc Max 2-CSP}, we are able to construct a polynomial-time algorithm for {\sc Densest -Subgraph} with similar conditions and guarantees as those of the algorithms from~\cite{FPK01} and~\cite{ST05}.

The theorems we prove in this paper are stated in Section~\ref{s:results} after appropriate preliminaries in the next section.

\section{Preliminaries and Notation}

In this section, we formally define the problems we focus on and the notation we use throughout the paper. First, to avoid confusion, let us state the definition of approximation ratio for the purpose of this paper. \\

\begin{definition}
  An approximation algorithm for a maximization problem is said to have an approximation ratio  if the output of the algorithm is at least  times the optimal solution.
\end{definition}

Note here that the approximation ratio as defined above is always at least one.

Next, before we define our problems, we review the standard notation of density of a graph. \\

\begin{definition}
  A simple undirected graph  is defined to be of density .
\end{definition}

Moreover, for a graph  and a vertex , we use  to denote the set of neighbors of  in . We also define  to denote the set of neighbors of neighbors of  in , i.e., . When it is unambiguous, we will leave out  and simply write  or .

Now, we will define the problems starting with {\sc Max 2-CSP}. \\

\begin{definition}
An instance  of {\sc Max -CSP} consists of
\begin{itemize}
  \item a simple undirected graph , and
  \item for each edge , a constraint (or constraint)  where  denotes .
\end{itemize}
The goal is to find an assignment (solution)  that maximizes the number of constraints 's that are satisfied, i.e. . In other words, find an assignment  that maximizes . The value of an assignment is defined as the fraction of edges satisfied by it and the value of an instance is defined as the value of the optimal assignment.
\end{definition}

A {\sc Max -CSP} instance  is called -dense if the graph  is -dense. Throughout the paper, we use  to denote the number of vertices (variables)  and  to denote , which can be viewed as the size of the problem.

Free games and projection games are specific classes of {\sc Max 2-CSP}, which can be defined as follows. Note that , density and value are defined in a similar fashion for free games and projection games as well. \\

\begin{definition} A free game  consists of
\begin{itemize}
  \item Two sets  of equal size, and
  \item for , a constraint .
\end{itemize}
The goal is to find an assignment  that maximizes the number of edges  that are satisfied, i.e., . \\
\end{definition}

\begin{definition}
A projection game  consists of
\begin{itemize}
  \item a simple bipartite graph , and
  \item for each edge , a ``projection'' 
\end{itemize}
The goal is to find an assignment to the vertices  that maximizes the number of edges  that are satisfied, i.e., .
\end{definition}

Both free games and projection games can be viewed as special cases of {\sc Max 2-CSP}. More specifically, free games are simply Max 2-CSPs on complete balanced bipartite graphs.

For projection games, one can view  as a constraint  where  if and only if . In other words, projection game is {\sc Max 2-CSP} on bipartite graph where an assignment to the endpoint in  of an edge determines the assignment to the endpoint in .

For convenience, we will define the notation of ``optimal assignment'' for {\sc Max 2-CSP} intuitively as follows. \\

\begin{definition}
For a {\sc Max 2-CSP} instance , for each vertex , let  be the assignment to  in an assignment to vertices that satisfies maximum number of edges, i.e.,  is the assignment that maximizes . In short, we will sometimes refer to this as ``the optimal assignment''.
\end{definition}

Note that since projection games and free games are families of {\sc Max 2-CSP}, the above definition also carries over when we discuss them.

Lastly, we define {\sc Densest -Subgraph}. \\

\begin{definition}
In the {\sc Densest -Subgraph} problem, the input is a simple graph  of  vertices. The goal is to find a subgraph of size  that contain maximum number of edges.
\end{definition}

\section{Summary of Results}\label{s:results}

We are finally ready to describe our results and how they relate to the previous results. We will start with the main theorem on approximating high-value dense {\sc Max 2-CSP}. \\

\begin{theorem}[Main Theorem] \label{thm:main}
  For every constant , there exists a polynomial-time algorithm that, given a -dense {\sc Max 2-CSP} instance of value , produces an assignment of value  for the instance.
\end{theorem}

Note that, when , by choosing , the algorithm can achieve  approximation ratio for any constant .

Since every free game is -dense, Theorem~\ref{thm:main} immediately implies the following corollary. \\

\begin{corollary} \label{cor:free-game}
  For every constant , there exists a polynomial-time algorithm that, given a free game of value , produces an assignment of value  for the instance.
\end{corollary}

Again, note that when , the algorithm can achieve  approximation ratio for any constant .

The next result is a similar algorithm for projection games on sufficiently dense random graphs as stated below. \\

\begin{theorem} \label{thm:dense-random-proj}
  For every constant , there exists a polynomial-time algorithm that, given a satisfiable projection game on a random bipartite graph  for any , produces an assignment of value  for the instance with probability .
\end{theorem}

Note that  is defined in Erd\H{o}s-R\'{e}nyi fashion, i.e., the graph contains  vertices on each side and, each pair of left and right vertices is included as an edge with probability  independently.

In addition, it is worth noting here that the required density for projection games is much lower than that of {\sc Max 2-CSP}; our {\sc Max 2-CSP} algorithm requires the degree to be  whereas the projection games algorithm requires only .

As stated earlier, we are unaware of any non-trivial polynomial-time algorithm for dense {\sc Max 2-CSP}, free games, or projection games on dense random graphs prior to our algorithm.

Next, we state our analogous result for {\sc Densest -Subgraph}. \\

\begin{corollary} \label{cor:dks}
  For every constant , there exists a polynomial-time algorithm that, given a graph  on  vertices such that its densest subgraph with  vertices is -dense, produces a subgraph of  vertices that is -dense with high probability.
\end{corollary}

Note that the density condition is on the optimal solution, not the given graph . The condition and the algorithm are exactly the same as that of~\cite{FPK01} and~\cite{ST05}. However, the techniques are substantially different. While~\cite{FPK01} deals combinatorially directly with the given graph  and~\cite{ST05} employs subsampling technique, we simply use our algorithm from Theorem~\ref{thm:main} together with a simple reduction from {\sc Densest -Subgraph} to {\sc Max 2-CSP} due to Charikar et al.~\cite{CHK}.

Lastly, we also give a quasi-polynomial time approximation scheme for satisfiable dense {\sc Max 2-CSP} as described formally below. \\

\begin{corollary}[QPTAS for Dense {Max 2-CSP}] \label{cor:qptas-dense}
  For any , there exists an -approximation algorithm for satisfiable -dense {\sc Max 2-CSP} that runs in time .
\end{corollary}

Comparing to the known algorithms, our QPTAS runs faster than QPTASs from~\cite{Alon:2003:RSA:963875.963877, AKK95, BMHS11}, each of which takes at least  time. However, while our algorithm works only for satisfiable instances, the mentioned algorithms work for unsatisfiable instances as well but with an additive error of  in value instead of the usual multiplicative guarantee of .

\section{Proof of The Main Theorem}

In this section, we prove the main theorem. In order to do so, we will first show that we do not have to worry about the density  at all, i.e., it is enough for us to prove the following lemma. \\

\begin{lemma} \label{lem:main}
  For every , there exists a polynomial-time algorithm that, given a free game  of value , produces an assignment of value  for the instance.
\end{lemma}

The proof of the main theorem based on the lemma above is shown below.

\begin{proof}[Proof of Theorem~\ref{thm:main} based on Lemma~\ref{lem:main}]
  The proof is based on putting in ``dummy edges'' where the constraints are always false regardless of the assignment to make the game more dense. More specifically, given a {\sc Max 2-CSP} instance  of value  and density , we construct a free game  as follows:
  \begin{itemize}
    \item Let  be copies of  and let .
    \item For each  and , let  if . Otherwise, let .
  \end{itemize}

  It is not hard to see that, if we assign the optimal assignment of the original instance to the free game, then  edges are satisfied where . In other words, the value of the free game is at least . Thus, from Lemma~\ref{lem:main}, for any constant , we can find an assignment  of value at least  for the free game.

  We create an assignment  based on  as follows. For each vertex , let  and  be the vertices corresponding to  in the free game. Set  to be either  or  with equal probability.

  From the above construction, the expected number of edges satisfied by  in the {\sc Max 2-CSP} instance is
  

  Observe that  is the value of  with respect to the free game, which is at least . As a result, we can conclude that  is of expected value at least  with respect to the instance .

  Lastly, we note that while the algorithm above is non-deterministic, the standard derandomization technique via conditional probability can be employed to make the algorithm deterministic without affecting the guarantee on the value of , which completes our proof for the main theorem.
\end{proof}

Now, we finally give the proof for Lemma~\ref{lem:main}. As mentioned in the introduction, the main idea of the proof is a trade-off between the greedy algorithm and the choice reduction algorithm. In other words, either the greedy assignment has high value, or we can reduce the number of candidates of the optimal assignment for many variables significantly by assigning only one variable. This argument needs to be applied multiple times to arrive at the result; the more variables we iterate on, the better guarantee we get on the output assignment value.

For the purpose of analysis, we will define our algorithm recursively and use induction to show that the output assignment meets the desired criteria.

\begin{proof}[Proof of Lemma~\ref{lem:main}]
First, let us define notation that we will use throughout the proof. For a free game , define  to be the set of edges satisfied by . In other words, . We also define  to be the neighborhood of  with respect to  and let  be the degree of  in , i.e., . In addition, let  be the size of  and .

We will prove the lemma by induction. Let  represent the following statement: there exists an -time algorithm {\sc Approx-FreeGame}( ) that takes in a free game instance  of value  and a reduced alphabet set  for every , and produces an assignment that satisfies at least  edges. Note here that  denotes an indicator variable for whether . Moreover, for convenience, we use the expression  to be represent zero when .

Before we proceed to the induction, let us note why  implies the lemma. By setting  and  for every , since  for every , the number of edges satisfied by the output assignment of the algorithm in  is at least

which is the statement of the lemma.

Now, we finally show that  is true for every  by induction.

{\em Base Case.} The algorithm {\sc Approx-FreeGame}() is a greedy algorithm that works as follows:
\begin{enumerate}
  \item For each , assign  that maximizes  to it. \label{step:free-greedy}
  \item For each , assign  that maximizes the number of edges satisfied, i.e., , to it.
\end{enumerate}

It is obvious that the algorithm runs in  time as desired.

Next, we need to show that the algorithm gives an assignment that satisfies at least  edges.

To prove this, observe that, from our choice of , the number of satisfied edges by the output assignment can be bounded as follows.


Thus, we can conclude that  is true.

{\em Inductive Step.} Let  be any positive integer. Suppose that  holds.

We will now describe {\sc Approx-FreeGame} based on {\sc Approx-FreeGame} as follows.

\begin{enumerate}
\item For each  and , do the following:
  \begin{enumerate}
  \item For each , compute .
  \item Call {\sc Approx-FreeGame}(). Let the output assignment be .
  \end{enumerate}
\item Execute the following greedy algorithm:
  \begin{enumerate}
  \item For each , assign  to it that maximizes . \label{step:free-greedy}
  \item For each , assign  to it that maximizes the number of edges satisfied, i.e., maximizes .
  \end{enumerate}
\item Output an assignment among the greedy assignment and  for every  that satisfies maximum number of edges.
\end{enumerate}

Since every step except the {\sc Approx-FreeGame}() calls takes  time and we call {\sc Approx-FreeGame} only at most  times, we can conclude that the running time of {\sc Approx-FreeGame} is  as desired.

Define  to be , our target number of edges we want to satisfy. The only thing left to show is that the assignment output from the algorithm indeed satisfies at least  edges. We will consider two cases.

First, if there exist  and  such that the output assignment from {\sc Approx-FreeGame}() satisfies at least  edges, then it is obvious that the output assignment of {\sc Approx-FreeGame} indeed satisfies at least  edges as well.

In the second case, for every  and , the output assignment from {\sc Approx-FreeGame}() satisfies less than  edges. For each , since the output assignment from {\sc Approx-FreeGame}() satisfies less than  edges, we arrive at the following inequality:


Now, observe that, for every , we have . This is because, from our definition of ,  for every , which means that, if  is in , then it remains in . Thus, the above inequality can be written as follows:


We will use inequality~(\ref{ine:1}) later in the proof. For now, we will turn our attention to the number of edges satisfied by the greedy algorithm, which, from our choice of , can be bounded as follows:


Moreover, from inequality~(\ref{ine:1}), we can derive the following inequalities:


By applying H\"{o}lder's inequality once again, the last term above is at least


Hence, we can conclude that  In other words, our greedy algorithm satisfies at least  edges, which means that  is also true for this second case.

As a result,  is true for every positive integer , which completes the proof for Lemma~\ref{lem:main}.
\end{proof}

\section{Approximation Algorithm for Projection Games}

In this section, we will present our approximation algorithm for projection games. The main idea of this algorithm is a reduction from projection games on dense random graphs to free games, which we use together with the approximation algorithm for free games from Corollary~\ref{cor:free-game} above to prove Theorem~\ref{thm:dense-random-proj}. The reduction's properties can be stated formally as follows. \\

\begin{lemma} \label{lem:reduction-dense}
There is a polynomial-time reduction from a satisfiable projection game \\  where  is sampled from a distribution  where  to a satisfiable free game instance  such that, with probability ,
\begin{enumerate} \itemsep0em
  \item  and , and
  \item For any , given an assignment  to the free game instance of value , one can construct an assignment  for the projection game of value  in polynomial time.
\end{enumerate}
\end{lemma}

Before we describe the reduction, we give a straightforward proof for Theorem~\ref{thm:dense-random-proj} based on the above lemma.

\begin{proof}[Proof of Theorem~\ref{thm:dense-random-proj} based on Lemma~\ref{lem:reduction-dense}]
The proof is simple. First, we use the reduction from Lemma~\ref{lem:reduction-dense} to transform a projection game on dense graph to a free game. Since the approximation ratio deteriorates by only constant factor with probability  in the reduction, we can use the approximation algorithm from Corollary~\ref{cor:free-game} with , which gives us an assignment of value at least .
\end{proof}

To prove the reduction lemma, we use the following two properties of random graphs. We do not prove the lemmas as they follow from a standard Chernoff bound. \\

\begin{lemma} \label{lem:prop-dense-random1}
When , with probability , every vertex in  has degree between  and . \\
\end{lemma}

\begin{lemma} \label{lem:prop-dense-random2}
In  with , with probability , every pair of vertices  on the left has at least  common neighbors.
\end{lemma}

Now, we are ready to prove the reduction lemma. Roughly speaking, the idea of the proof is to ``square'' the projection game, i.e., use  as the vertices of the new game and, for each pair of vertices in , add a constriant between them based on their constraints with their common neighbors in the projection game. This can be formalized as follows.

\begin{proof}[Proof of Lemma~\ref{lem:reduction-dense}]
The reduction proceeds as follows.
\begin{enumerate} \itemsep0em
\item Partition  into  of equal sizes. Then, set  and .
\item For each , let  to be one if and only if these two assignments agree on every . In other words,  if and only if  for every .
\end{enumerate}

It is obvious that the reduction runs in polynomial time, the first condition holds, and the new game is satisfiable. Thus, we only need to prove that, with probability , the second condition is indeed true.

To show this, we present a simple algorithm that, given an assignment  of the free game instance of value , output an assignment  of the projection game of value . The algorithm works greedily as follows.
\begin{enumerate} \itemsep0em
\item For each , let .
\item For each , pick  to be the assignment to  that satisfies maximum number of edges, i.e., maximize .
\end{enumerate}

Trivially, the algorithm runs in polynomial time. Thus, we only need to prove that, with probability , the produced assignment is of value at least . To prove this, we will use the properties from Lemma~\ref{lem:prop-dense-random1} and Lemma~\ref{lem:prop-dense-random2}, which holds with probability .

The number of satisfied edges can be written as follows.


Let  be the degree of  in  for every , i.e. . We can further rearrange the above expression as follows.



Observe that . Thus, the number of satisfied edges is at least


Moreover, from Lemma~\ref{lem:prop-dense-random1},  for every  with probability . This implies that, with probability , the output assignment satisfied at least  edges.

We can further reorganize this quantity as follows.


Now, observe that, from its definition, if  is one, then  is also one for every . Thus, we have


From Lemma~\ref{lem:prop-dense-random2}, with probability ,  for every . Hence, we can conclude that the above expression is, with probability , at least


Next, note that  is the number of edges satisfied by  in the free game, which is at least . Thus, we have

Finally, again from Lemma~\ref{lem:prop-dense-random1}, the total number of edges is at most  with probability . As a result, with probability , the algorithm outputs an assignment that satisfies at least  fraction of edges of the projection game instance as desired.
\end{proof}

\section{Approximation Algorithm for Densest -Subgraph}

The main goal of this section is to prove Corollary~\ref{cor:dks}. As stated previously, we simply use our algorithm from Theorem~\ref{thm:main} together with a reduction from {\sc Max 2-CSP} to {\sc DS} from~\cite{CHK}. First, let us start by stating the reduction from Theorem~\ref{thm:main}, which we rephrase as follows. \\

\begin{lemma}[\cite{CHK}] \label{lem:dks-reduction}
  There exists a randomized polynomial-time algorithm that, given a graph  of  vertices and an integer , produces an instance  of {\sc Max 2-CSP} such that
  \begin{itemize}
  \item , and
  \item any solution to the instance can be translated in polynomial time to a subgraph of  of  vertices such that the number of edges in the subgraph equals to the number of edges satisfied by the {\sc Max 2-CSP} solution, and
  \item with constant probability, the number of edges satisfied by the optimal solution to the instance is at least  times the number of edges in the densest -subgraph of .
  \end{itemize}
\end{lemma}

We will not show the proof of Lemma~\ref{lem:dks-reduction} here; please refer to Theorem 6 from~\cite{CHK} for the proof. Instead, we will now show how to use the reduction to arrive at the proof of Corollary~\ref{cor:dks}.

\begin{proof}[Proof of Corollary~\ref{cor:dks}]
  First, we note that, to prove Corollary~\ref{cor:dks}, it is enough to find a randomized polynomial-time algorithm with similar approximation guarantee to that in Corollary~\ref{cor:dks} except that the probability of success is a constant (instead of high probability as stated in Corollary~\ref{cor:dks}). This is because we can then repeatedly run this algorithm  times and produce the desired result.

  The algorithm proceeds as follows:
  \begin{enumerate}
    \item Use the reduction from Lemma~\ref{lem:dks-reduction} on the input graph  and  to produce .
    \item Run the algorithm from Theorem~\ref{thm:main} on . \label{step:dks-main-csp}
    \item Transform the assignment from previous step according to Lemma~\ref{lem:dks-reduction} and output the result.
  \end{enumerate}

  From the property of the reduction, we know that, with constant probability, the optimal assignment to  satisfies  edges. If this is the case, we can conclude that the density of  is  and, similarly, that the value of the instance is . As a result, the output assignment from step~\ref{step:dks-main-csp} has value at least . Since the reduction from Lemma~\ref{lem:dks-reduction} preserves the optimum, our algorithm produces a subgraph of density at least  as well, which concludes our proof for this corollary.
\end{proof}

\section{QPTAS for Dense Max 2-CSPs}

At first glance, it seems that the QPTAS would follow easily for our main theorem. This, however, is not the case as the algorithm in the main theorem always loses at least a constant factor. Instead, we need to give an algorithm that is similar to that of the main theorem but have a stronger guarantee in approximation ratio for satisfiable instances, which can be stated as follows. \\

\begin{lemma} \label{lem:approx-complete-game}
  For every positive integer , there exists an -time algorithm that, for any satisfiable {\sc Max 2-CSP} instance on the complete graph, produces an assignment of value at least .
\end{lemma}

Lemma~\ref{lem:approx-complete-game} can be viewed as a special case of the main theorem when the graph is complete. However, it should be noted that Lemma~\ref{lem:approx-complete-game} is more exact in the sense that the guaranteed lower bound of the value of the output assignment is not asymptotic. The proof of this lemma is also similar to that of Lemma~\ref{lem:main} except that we need slightly more complicated algorithm and computation to deal with the fact that the underlying graph is not bipartite.

\begin{proof}[Proof of Lemma~\ref{lem:approx-complete-game}]
We will prove the lemma by induction. Note that throughout the proof, we will not worry about the randomness that the algorithm employs; it is not hard to see that the random assignment algorithms described below can be derandomized via greedy approach so that the approximation guarantees are as good as the expected guarantees of the randomized ones and that we still end up with the same asymptotic running time.

Let  represent the following statement: there exists an -time algorithm {\sc Approx-CompleteGame}() that takes in a satisfiable {\sc Max 2-CSP} instance  where  is a complete graph and a reduced alphabet set  for every  such that, if  for every , then the algorithm outputs an assignment of value at least .

Observe that  implies the lemma by simply setting  for every .

{\em Base Case.} The algorithm {\sc Approx-CompleteGame}() is a simple random assignment algorithm. However, before we randomly pick the assignment, we need to first discard the alphabets that we know for sure are not optimal. More specifically, {\sc Approx-CompleteGame}() works as follows.
\begin{enumerate}
  \item While there exist  and  such that  for every , remove  from . \label{step:remove}
  \item For each , pick  independently and uniformly at random from . Output .
\end{enumerate}

It is obvious that the algorithm runs in  time as desired.

Now, we will show that, if  for every , then the algorithm gives an assignment that is of value at least  in expectation.

First, observe that  remains in  after step~\ref{step:remove} for every . This is because  for every .

Next, Consider the expected number of satisfied edges by the output assignment, which can be rearranged as follows:


From the condition of the loop in step~\ref{step:remove}, we know that after the loop ends, for each , there must be at least one  such that . In other words, 

Similarly, we can also conclude that 

Thus, we have  for every .

Hence, we can bound the expected number of satisfied edges as follows:

which implies that  is true as desired.

{\em Inductive Step.} Let  be any positive integer. Suppose that  holds.

We will now describe {\sc Approx-CompleteGame} based on {\sc Approx-CompleteGame} as follows.

\begin{enumerate}
\item Define  to be , our target value we want to achieve.
\item Run the following steps~\ref{step:reduce} to~\ref{step:exc} until no  is modified by neither step~\ref{step:exc} nor step~\ref{step:empty}.
  \begin{enumerate}
  \item For each  and , do the following:
    \begin{enumerate}
    \item For each , compute . This is the set of reduced assignments of  if we assign  to . Note that when , let . \label{step:reduce}
    \item If  for some , then remove  from  and continue to the next  pair. \label{step:empty}
    \item Compute . If , continue to the next  pair.
    \item Execute {\sc Approx-CompleteGame}(). If the output assignment is of value less than , then remove  from . Otherwise, return the output assignment as the output to {\sc Approx-CompleteGame}. \label{step:exc}
    \end{enumerate}
  \end{enumerate}
\item If the loop in the previous step ends without outputting any assignment, just output a random assignment (i.e. pick  independently and uniformly at random from ). \label{step:random-assignment}
\end{enumerate}

Observe first that the loop can run at most  times as the total number of elements of 's for all  is at most . This means that we call {\sc Approx-CompleteGame} at most  times. Since every step except the {\sc Approx-CompleteGame} calls takes  time and we call {\sc Approx-CompleteGame} only at most  times, we can conclude that the running time of {\sc Approx-CompleteGame} is  as desired.

The only thing left to show is that the assignment output from the algorithm indeed is of expected value at least . To do so, we will consider two cases.

First, if step~\ref{step:random-assignment} is never reached, the algorithm must terminate at step~\ref{step:exc}. From the return condition in step~\ref{step:exc}, we know that the output assignment is of value at least  as desired.

In the second case where step~\ref{step:random-assignment} is reached, we first observe that when we remove  from  in step~\ref{step:exc}, the instance is still satisfiable. The reason is that, if  is the optimal assignment for , then  remains in  for every . Hence, from our inductive hypothesis, the output assignment from {\sc Approx-CompleteGame}() must be of value at least . As a result, we never remove  from , and, thus, the instance remains satisfiable throughout the algorithm.

Moreover, notice that, if  for any , we either remove  from  or output the desired assignment. This means that, when step~\ref{step:random-assignment} is reached,  for every  and .

Now, let us consider the expected number of edges satisfied by the random assignment. Since our graph  is complete, it can be written as follows.



Since  is the number of edges in , we can conclude that the random assignment is indeed of expected value at least .

Thus, we can conclude that  is true. As a result,  is true for every positive integer , which completes the proof for Lemma~\ref{lem:approx-complete-game}.
\end{proof}

Next, we will prove Corollary~\ref{cor:qptas-dense} by reducing it to {\sc Max 2-CSP} on complete graph, and, then plug in Lemma~\ref{lem:approx-complete-game} with appropriate  to get the result.

First, observe that, since  for every , by plugging in  for large enough constant  into Lemma~\ref{lem:approx-complete-game}, we immediately arrive the following corollary. \\

\begin{corollary} \label{cor:qptas-complete}
  For any , there exists an -approximation algorithm for satisfiable {\sc Max 2-CSP} on the complete graph that runs in time .
\end{corollary}

Now, we will proceed to show the reduction and, thus, prove Corollary~\ref{cor:qptas-dense}.

\begin{proof}[Proof of Corollary~\ref{cor:qptas-dense}]
  First of all, notice that, since . It is enough for us to show that there exists an -time algorithm for satisfiable -dense {\sc Max 2-CSP} that produces an assignment of value at least .

  On input , the algorithm works as follows:
  \begin{enumerate}
    \item Construct a {\sc Max 2-CSP} instance  where  is a complete graph and  is defined as  if . Otherwise, . In other words, we put in dummy constraints that are always true just to make the graph complete.
    \item Run the algorithm from Corollary~\ref{cor:qptas-complete} on  with  and output the assignment got from the algorithm.
  \end{enumerate}

  To see that the algorithm indeed produces an assignment with value  for the input instance, first observe that, since  is satisfiable,   is trivially satisfiable. Thus, from Corollary~\ref{cor:qptas-complete}, the output assignment has value at least  with respect to . In other words, the assignment does not satisfy at most  edges. Thus, with respect to the input instance, it satisfies at least  edges. In other words, it is of value at least  as desired.

  Lastly, note that the running time of this algorithm is determined by that of the algorithm from Corollary~\ref{cor:qptas-complete}, which runs in  time as desired.
\end{proof}

\section{Conclusions and Open Questions}
Finally, we conclude by listing the open questions and interesting directions related to the techniques and problems presented here. We also provide our thoughts regarding each question.
\begin{itemize}
\item {\em Can our algorithm be extended to work for {\sc Max -CSP} for ?} Other algorithms for approximating {\sc Max 2-CSP} such as those from~\cite{Alon:2003:RSA:963875.963877, AKK95, BMHS11} are applicable for {\sc Max -CSP} for any value of  as well. So it is possible that our technique can be employed for {\sc Max -CSP} too.
\item {\em Can one also come up with an algorithm that approximates {\sc Max 2-CSP} to within  factor for any  for low-value dense {\sc Max 2-CSP}?} Our algorithm needs the value  to be  in order to give such a ratio so it is interesting whether we can remove or relax this condition. However, we do not think that one can remove the condition completely because, with similar technique to the proof of Corollary~\ref{cor:qptas-dense}, we can arrive at a reduction from any {\sc Max 2-CSP} to dense {\sc Max 2-CSP} where the approximation ratio is preserved but the value decreases. This means that, if we can remove the condition on , then we are also able to refute the PGC. This argument nonetheless does not rule out relaxing the condition for  without removing it completely.
\item {\em Can our QPTAS be extended to unsatisfiable instances?} One of the main disadvantages of our QPTAS is that it requires the instance to be satisfiable. This renders our QPTAS useless against many problems such as {\sc Max -SAT} and {\sc Max-Cut} because the satisfiable instances of those problems are trivial. If we can extend our QPTAS to work on unsatisfiable instances as well, then we may be able to produce interesting results for those problems.  Note, however, that, with similar argument to the preceding question, QPTAS for low-value instances likely does not exist. Instead, the case of unsatisfiable instances where~\cite{Alon:2003:RSA:963875.963877, AKK95, BMHS11} are successful is when they look for an additive error guarantee instead of a multiplicative one. Currently, it is unclear whether our technique can achieve such results.
\item {\em Can one arrive at a similar or even better algorithm using SDP hierarchies?} SDP hierarchies have been very useful in finding approximation algorithms for combinatorial optimization problems. A natural question to ask is whether one can apply SDP hierarchies to get similar results to ours. For example, can the -level of the Lasserre hierarchy produce an approximation algorithm with ratio  for dense {\sc Max 2-CSP}? If so, then this may also be an interesting direction to pursue an algorithm with guarantee additive error discussed previously.
\end{itemize}

\bibliographystyle{plain}

\bibliography{bi}

\end{document}
