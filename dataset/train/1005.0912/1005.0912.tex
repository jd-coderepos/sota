\documentclass[11pt]{article}
\usepackage{latexsym,color,amsmath,amssymb,amsthm,fullpage}
\usepackage{graphicx}



\def\marrow{\marginpar[\hfill]{}}
\def\micha#1{\textsc{(Micha says: }\marrow\textsf{#1})}
\def\haim#1{\textsc{(Haim says: }\marrow\textsf{#1})}
\def\natan#1{\textsc{(Natan says: }\marrow\textsf{#1})}
 
\def \Exp{{\sf E}}
\def\EE{{\bf E}}
\def\bd{{\partial}}
\def\CH{{\mathcal{CH}}}
\def\bridge{{\sf bridge}}
\def\U{{\mathcal U}}
\def\PT{{\cal PT}}
\def\CT{{\sf CT}}
\def\CV{{\sf CV}}
\def\CE{{\sf CE}}
\def\T{{\cal T}}
\def\rank{{\sf rank}}
\def\prior{{\sf priority}}
\def\E{{\cal E}}
\def\reals{{\mathbb R}}
\def\C{\mathcal{C}}
\def\A{\mathcal{A}}
\def\U{\mathcal{U}}
\def\Q{\mathcal{Q}}
\def\L{{\cal L}}
\def\R{\mathcal{R}}
\def\D{\mathcal{D}}
\def\K{\mathcal{K}}
\def\prob{{\sf Pr}}
\def\inter{\mathop{\mathrm{int}}}
\def\Left{{\sf left}}
\def\Right{{\sf right}}
\def\apex{{\sf apex}}
\def\Mid{{\sf mid}}
\def\lchain{{\sf lchain}}
\def\rchain{{\sf rchain}}
\def\eps{\varepsilon}

\def\Re{{\mathbb R}}
\def\dirtour{{\mathcal D}}
\def\xitour {{\mathcal V}}
\def\W{{\mathcal W}}
\def\bd{{\partial}}
\def\eps{{\varepsilon}}
\def\poly{\diamond}
\def\DDG{\mathop{\mathrm{DDG}}}
\def\G{\mathop{\mathrm{G}}}
\def\SDG{\mathop{\mathrm{SDG}}}
\def\PSDG{\mathop{\mathrm{PSDG}}}
\def\DT{\mathop{\mathrm{DT}}}
\def\VD{\mathop{\mathrm{VD}}}
\def\Vor{\mathop{\mathrm{Vor}}}
\def\intr{\mathop{\mathrm{int}}}




\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary} 
\newtheorem{proposition}[theorem]{Proposition} 
\begin{document}

\begin{titlepage}
\title{A Kinetic Triangulation Scheme for Moving Points in The Plane\thanks{Work by Haim Kaplan and Natan Rubin was partially supported by Grant 975/06 from the
Israel Science Fund. Work by Micha Sharir and Natan Rubin was partially supported by
by Grants 155/05 and 338/09 from the Israel Science Fund. Work by Haim Kaplan was also supported by Grant 2006-204 from the U.S. - Israel Binational Science Foundation. Work by Micha Sharir was also supported by
NSF Grant CCF-08-30272, by grant 2006-194 from the U.S.-Israeli 
Binational Science Foundation, 
and by the Hermann Minkowski--MINERVA
Center for Geometry at Tel Aviv University.}}

\author{
Haim Kaplan\thanks{School of Computer Science, Tel Aviv University, Tel Aviv 69978,
Israel. 
E-mail: {\tt haimk@post.tau.ac.il }} \and
Natan Rubin\thanks{School of Computer Science, Tel Aviv University, Tel Aviv 69978,
Israel. 
E-mail: {\tt rubinnat@post.tau.ac.il }} \and
Micha Sharir\thanks{School of Computer Science, Tel Aviv University, Tel Aviv 69978,
Israel, and Courant Institute of Mathematical Sciences, New York
University, New York, NY 10012, USA. E-mail: {\tt
michas@post.tau.ac.il }} }
\maketitle

\begin{abstract}
We present a simple randomized scheme for triangulating a set 
of  points in the plane, and construct a kinetic data structure 
which maintains the triangulation as the points of  move
continuously along piecewise algebraic trajectories of constant
description complexity. Our triangulation scheme experiences an expected number of  discrete changes, and handles them in a
manner that satisfies all the standard requirements from a kinetic
data structure: compactness, efficiency, locality and responsiveness. Here  is the maximum number of times where any specific triple of points of  can become collinear, , and  is the maximum length of Davenport-Schinzel sequences of order  on  symbols. 
Thus, compared to the previous solution of Agarwal et al.~\cite{AWY}, we achieve a (slightly) improved bound on the number of discrete changes in the triangulation.
In addition, we believe that our scheme is simpler to implement and analyze.
\end{abstract}
\end{titlepage}

\section{Introduction}\label{Sec:intro}

Let  be a set of  moving points 
in the plane. We assume that the motions of the points are simple, in
the sense that the trajectory of each point is a piecewise-algebraic
curve of {\em constant description complexity}, meaning that it can be
described as a Boolean combination of a constant number of polynomial
equalities and inequalities of constant maximum degree.

Our goal is to devise a reasonably simple scheme for triangulating 
 at any fixed time , and to maintain the triangulation 
as the points move. That is, we wish to partition the 
convex hull  of  into pairwise openly disjoint 
triangles whose vertices are the points of , so that the 
interior of each triangle is empty---it does not contain any 
point of . The scheme has to be {\em kinetic}, so that we 
can keep track of the discrete combinatorial changes that the 
triangulation undergoes as the points move, and update the
triangulation so that it continues to conform to the underlying
scheme. (That is, at any given time  the maintained triangulation coincides with the one that would result in applying the static scheme to .)


The study of triangulations plays a central role in computational geometry because of
their numerous applications in such areas as computer graphics,
physical simulation, collision detection, and geographic information systems \cite{BernEpp, EdelsMeshes}. With the advancement in technology, many applications, for instance, video
games, virtual reality, dynamic simulations, and robotics, call for maintaining a triangulation as the
points move. For example, the arbitrary Eulerian-Lagrangian method \cite{Lagrangean} provides a way to integrate
the motion of 
fluids and solids within a moving finite-element mesh.



In , the Delaunay triangulation  of  produces well-shaped triangles, and thus 
is a good candidate for such a triangulation scheme.
The problem,
though, is that the best known upper bound on the number of 
discrete changes in , as a function of time ,
is only nearly cubic in  (the bound is cubic if the points move with constant velocities); see \cite{Stable,FU91,GMR91,SA:ds}. 
While it is strongly believed that the maximum possible number of 
discrete changes that  can experience is only nearly 
quadratic in , this is one of the hardest open problems in 
computational and combinatorial geometry (as recognized,
e.g., in \cite{TOPP}). 
Until this conjecture is established, one seeks alternative 
triangulation schemes with a provable \textit{nearly-quadratic} upper 
bound on the number of discrete changes. 
(This is best possible, since the convex hull itself can change  times during a simple motion of the points of ; see \cite{SA:ds}.)
Moreover, the scheme 
should be sufficiently simple to define, to implement, and 
(as a secondary aesthetic virtue) to analyze. 
Finally, the 
scheme should satisfy the four basic properties of kinetic data 
structures \cite{BG99} detailed below.


Agarwal et al.~\cite{AWY} have recently presented such a randomized triangulation scheme which experiences
 discrete changes. Their scheme, however, is fairly 
complicated, and its analysis is also rather involved. It uses a hierarchy of subsets , where each set , for , is a random sample of roughly  points of . 
The algorithm maintains an entire hierarchy of triangulations , where each  is a triangulation of ; it is a refinement of  which is obtained by a suitable variant of the \textit{fan triangulation}, introduced in \cite{ABG}.

\medskip
\noindent{\bf Kinetic data structures.} 
The {\em Kinetic data structure\/} (KDS) framework, introduced by
Basch et al.~\cite{BG99}, proposes an algorithmic
approach, together with several quality criteria, for maintaining
certain geometric configurations determined by a set of objects,
each moving along a trajectory whose graph, as a function of time,
is a piecewise-algebraic curve (in space-time) of constant description complexity.
Several interesting algorithms have been designed, using this
framework, over the past decade, including algorithms for
maintaining the convex hull of a set of (moving) points in the
plane \cite{BG99}, the closest pair and all nearest neighbors
in any dimension \cite{AgKS,BG99}, and many other configurations. 
See \cite{Gui} for a comprehensive, albeit old, survey, and \cite{AgKS}
for a list of more recent results and references.

Typically, a KDS operates by maintaining a set of \textit{certificates}. As long as they are all valid, the structure being maintained is guaranteed to be valid too. Each certificate has a (first future) failure time, and we store these critical times in an event priority queue. When a certificate fails, we repair the KDS, update, if needed, the geometric structure that we maintain, generate new certificates and insert their failure times into the queue. 

Generally, a good KDS is expected to possess the following four properties: (i) \textit{Compactness}, meaning that the storage that it requires is larger only by a polylogarithmic factor than the space required for the structure being maintained. (ii) \textit{Efficiency}, meaning that the number of events that it processes (i.e., failure times of the certificates) is larger only by a polylogarithmic factor than the maximum possible number of discrete changes in the structure being maintained. (iii) \textit{Responsiveness}, meaning that repairing the KDS at a certificate failure event takes only  polylogarithmic time. (iv) \textit{Locality}, meaning that each input object is stored at only a polylogarithmic number of places in the KDS, so that an expected change in the motion of a single object can be processed efficiently. See \cite{AKS,BG99} for more details.


Therefore, a good KDS for 
kinetic triangulation in  should have only nearly linear storage, process only a nearly-quadratic number of events, each in polylogarithmic time, and each moving point should be stored at only a polylogarithmic number of places in the KDS.


\medskip
\noindent{\bf Our result.}
In Section \ref{Sect:Static}, we present a simple triangulation scheme for a set  of  moving
points in the plane. For the sake of efficient kinetization we make
the scheme randomized, and assume a (natural) model in which the flight plans of
the moving points are independent of the randomization used by the
algorithm. The basic idea of the (static) triangulation is quite
simple (some details are glossed over in this informal overview):
We sort the points of  by their -coordinates, split  at a
(random) point  into a left portion  and a right portion
, compute recursively the upper convex hulls of
 and of , and merge them into 
the upper convex hull of the whole set .

This process results in a {\em pseudo-triangulation} of the portion 
of the convex hull of  lying above the -monotone polygonal chain  
connecting the points of  in their -order. Each pseudo-triangle is
-monotone, and consists of an upper {\em base} and of a left and
right lower concave chains, meeting at its bottom {\em apex}. See
Figure \ref{Fig:PseudoTail} for an illustration.
A symmetric process is applied to the portion of the hull below 
, by computing recursively lower convex hulls of the
respective subsets of .
(In particular, we obtain a hierarchical representation of , similar to the one of Overmars and van
Leeuwen~\cite{Overmars}; see also \cite{AKS}. See~\cite{ABG,TwoPolyg04,Speckmann} for additional applications of hierarchical pseudo-triangulations to kinetic problems.)

To obtain a proper triangulation of (the convex hull of) , we partition each
pseudo-triangle  into triangles. 
We accomplish this in the
following randomized incremental manner. We process the vertices
of  (other than its apex and its leftmost and rightmost 
vertices) in order, according to the random ranks that they received
during the first splitting phase, and draw from each processed
vertex  a chord, within the current sub-pseudo-triangle 
of  containing , which splits  into two
sub-pseudo-triangles. This process ends with a triangulation of 
, and we apply it to each of the pseudo-triangles, to obtain the full triangulation of .

In Section \ref{Sec:CombiChanges}, we prove that the expected number of events that
can arise during the motion is  (with  and  as defined in the abstract), and that the expected number of discrete (also called topological) changes caused in our triangulation by each such event is bounded by .


In Section \ref{Sec:DataStruct}, we show how to maintain this triangulation, as the points 
of  move, using a kinetic data structure that satisfies the criteria of \cite{BG99}, as listed above. 
There are several kinds of critical events we need to
watch for, in which pairs of points are swapped in the -order or
triples of points become collinear.
We process each event of the former type in  expected time, and each event of the latter type in  expected time, for a total of  (expected) processing time.
Our implementation encodes the pseudo-triangulation as a \textit{treap} on  \cite{SA96}. 



The upper bounds that we obtain on the number of discrete events, and on their overall processing time, are slightly better than those of the scheme in \cite{AWY}, and we believe that our scheme is simpler (and more ``explicit") than that of \cite{AWY}.
\section{The Static Triangulation}\label{Sect:Static}
In this section we describe a simple scheme for constructing a static triangulation  of .
We fix a random permutation  of the points of .  For each
 we denote its rank in  as .  Let 
denote, as above, the -monotone polygonal chain which connects the points of
 in their -order, assuming that no two points of  have the
same -coordinate. (In degenerate cases, which will arise at
discrete instances during the motion of the points of , 
connects the points in the lexicographical order of their
coordinates.)  Since the two points of  with extreme
-coordinates are vertices of ,  partitions 
into two components,  and , lying respectively
above and below . With no loss of generality, we only describe
a triangulation  of , and obtain the triangulation
 of  in a fully symmetric fashion.  The overall
triangulation  is the union of  and .


\medskip
\noindent
{\bf A static pseudo-triangulation of .}
We first construct a \textit{pseudo-triangulation} of  and
then refine it into a triangulation by partitioning each
pseudo-triangle into triangles.

Each pseudo-triangle  that we construct consists of a \textit{left tail}, a middle \textit{funnel}, and a \textit{right tail}
(any of these substructures may be empty; the tails were not mentioned in the overview in the introduction). The funnel
is an -monotone simple polygon, whose
boundary consists of an upper \textit{base}, which is the segment connecting
its leftmost and rightmost vertices, and of a left and right lower concave
\textit{chains}, which are denoted respectively as  and
. The point in which  and   meet
is called  the \textit{apex} of  and denoted
by . The left chain  extends from the left endpoint of the base to , and the right chain extends from
 to the right endpoint of the base; see Figure
\ref{Fig:PseudoTail}.  
In addition,  may have a left tail\footnote{\small These tailed pseudo-triangles are a special case of so-called \textit{geodesic triangles} introduced in \cite{Geodesic}.}
 and a right tail , so that  is an -monotone polygonal chain which
extends from the left vertex of the funnel to the left, till the {\em left
endpoint\/}  of , so that  is
a concave chain, and symmmetrically for , which extends to
the right till the {\em right endpoint\/}  of . Moreover, the line containing the base of  is an upper common tangent of  and . Again, see
Figure \ref{Fig:PseudoTail}.
\begin{figure}[htb]
\begin{center}
\begin{picture}(0,0)\includegraphics{PseudoTail.pstex}\end{picture}\setlength{\unitlength}{2763sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5881,1518)(563,-1864)
\put(3826,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4239,-1061){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2278,-981){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(834,-1288){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2534,-529){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}base=}}}}}
\put(3548,-886){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5385,-1213){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf A single pseudo-triangle  in our pseudo-triangulation of . In addition to its funnel (drawn shaded),  has two tails .
 \label{Fig:PseudoTail}}
\end{center}
\end{figure}
We construct the pseudo-triangulation of 
recursively. At each step of the recursion we have some subset
 of points which are consecutive in the -order
of , and we construct a pseudo-triangulation  of
. At the topmost level of the recursion we have .
The construction of  proceeds as follows; see Figure
\ref{Fig:PseudoTrian}.  Let  (resp., ) denote the
point of  with the minimal (resp., maximal) -coordinate, and let
 be the point  of  with
the minimum value of .  Set ,  (so 
belongs to both sets).  We add to  the following pseudo-triangle
. The base of  is the
portion of the upper common tangent to  and  between the
points of tangency.
We call this base the {\em bridge\/} of  and denote it by
 .
The left (resp., right) chain 
(resp., ) is the portion of the upper hull of  (resp.,
) below  .
 We take  to be the portion of
the upper hull of  to the left of , and define
  symmetrically as the portion of the upper hull of
 to the right of .  The points  and
 become the respective \textit{endpoints}
,  of .  We also have
 which belongs, by definition, to both chains. (The funnel of 
may be empty, if  is a vertex of the upper hull of . In
this case we can think of the funnel of  as the singleton
, and  consists of the two tails
, meeting at , and forming together a common concave chain. Similarly, a pseudo-triangle may have an empty left tail and/or empty right tail.)


\begin{figure}[htb]
\begin{center}
\begin{picture}(0,0)\includegraphics{RecursivePseudo.pstex}\end{picture}\setlength{\unitlength}{3158sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5933,1533)(511,-1859)
\put(3451,-886){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1951,-1561){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6376,-1561){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3141,-497){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5026,-1561){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(526,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-1786){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf The recursive pseudo-triangulation of . We add to  the pseudo-triangle  (whose funnel is drawn shaded), with endpoints
, and , and then recursively construct . \label{Fig:PseudoTrian}}
\end{center}
\end{figure}

We then recursively pseudo-triangulate
each of , . The recursion
terminates when  (by construction, ). If  then we output a single pseudo-triangle , which is either a triangle,
when the midpoint lies below the segment connecting the endpoints, or, in the opposite case,
consists of the two segments  and
. If , no pseudo-triangle is output. In this case  is a single edge of the chain . 


Consider a pseudo-triangle  such that 
 is not the leftmost point of  and 
 is not the rightmost point of .
Then one can show that the triple 
 have the smallest priorities
among all points whose -coordinates are between 
and , inclusive (see Lemma \ref{Lemma:ConditionPseudo} below). To make this true for all 
pseudo-triangles, we
 augment the initial point set  with two dummy points
 and , and
assign to them priorities  and .
The upper hull of the augmented point set is
obtained from the upper hull of  by adding two vertical downward-directed rays at the leftmost and rightmost points of . Hence, any triangulation of  is also a triangulation of , and vice versa.
In the rest of the paper we denote by  the augmented point
set. 

The following lemma gives an operational definition of
, which will be used in the sequel.

\begin{lemma}\label{Lemma:ConditionPseudo}
  Let , , and  be three points in , such that
  . Then  contains a pseudo-triangle
   having endpoints , , and
  , if and only if\\ (i)
  , and\\ 
  (ii) all points , such that  satisfy .
\end{lemma}

\begin{proof}
  To prove the ``only if'' part we proceed by induction on our
  recursive construction.  Recall that at each recursive step we
  process some subset  whose points are
  consecutive in the -order of , and add to
   a pseudo-triangle  with
  , , and
  .  To establish both asserted conditions (i)
  and (ii) for , it is sufficient to observe that each point
  , such that , satisfies
  .  Indeed,
  the desired property holds initially for  by our choice of
  the artificial points  and  and their
  priorities. Assuming that this holds when we process some subset
  , and using the fact that  is the point with smallest
  priority in the range , the claim
  also holds for  and .

  For the ``if'' part, we observe that for every choice of 
  there is exactly one choice of  and  in  so that the triple
   satisfies (i) and (ii), and every point  is an
  apex of exactly one pseudo-triangle of  (and the
  apex of each pseudo-triangle is distinct from each of
   and ). 
  The latter is easy to establish by induction on the increasing order of the priorities of the points.
  This, combined with the arguments in the
  ``only if'' part, completes the proof.
\end{proof}

\medskip
\noindent
{\bf The pseudo-triangulation tree.}
The pseudo-triangulation  can be represented by a binary
tree in which every node  represents a pseudo-triangle , and stores the point . The inorder
of the tree is the increasing -order of the apices (i.e., the points of ). The subtree
rooted at  represents the recursive pseudo-triangulation of
, where  denotes the set of points stored at the nodes of the subtree rooted
at . Note that  and  are not stored
at this subtree---they are the next points to the left and to the
right of the points of .
Abusing the notation slightly, we denote by  both the
pseudo-triangulation  and the tree
representing it.

\medskip
\noindent{\bf Remark:}
Let  be a node in , so that . Then  is stored at the lowest ancestor of  whose right subree contains . If  then  belongs to the path from the root of  to the leftmost leaf. Symmetric properties hold for . 


In summary, we have the following lemma, whose proof is immediate from the construction.
\begin{lemma}\label{Lemma:treap}
  The tree representing  is a treap on . That is,
   is a heap with respect to the \textit{priorities}, and
  a search tree with respect to the -coordinates of the points.
\end{lemma}

\noindent
{\bf Triangulating a fixed pseudo-triangle.}
Let  be a pseudo-triangle of . Assume that the funnel of
 is not empty, and is not already a triangle. We say that two
vertices  of the funnel of , where  belongs to  and 
belongs to , are \textit{visible} from each other if 
does not intersect  (except at its endpoints); in this
case  lies inside the funnel of . Denote by  the
rightmost point on the right chain which is visible from
. Note that either  is the
rightmost vertex of  or  is an upper tangent to
. Symmetic definition and properties hold for points  on
. This definition also applies when  is the leftmost vertex of
 and when  the rightmost vertex of  (the endpoints of ), in which case  and . See Figure \ref{Fig:TrianPseudo} (left).



\begin{figure}[htb]
\begin{center}
\input{TriangulatePseudo2.pstex_t}\hspace{2cm}\begin{picture}(0,0)\includegraphics{TriangulatePseudo1.pstex}\end{picture}\setlength{\unitlength}{2368sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4150,2414)(1320,-2149)
\put(1335,-1110){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2988,-2062){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3617,-740){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2577,-87){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4960,-318){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2180,-1283){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2948,-1025){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf Left: The first step of triangulating a single pseudo-triangle . Right: During the recursive construction of  every non-corner vertex  of the funnel of  generates exactly one edge , thus recursively splitting some sub-pseudo-triangle  (drawn shaded). Note that in this figure , which is the left endpoint of .}\label{Fig:TrianPseudo}
\end{center}
\end{figure}



The triangulation  of  is obtained by recursively
splitting  by chords into sub-pseudo-triangles, in the following
manner.  Choose the minimum priority vertex  of the funnel of
, other than the leftmost and the rightmost vertices and the
apex. Assume, without loss of generality, that  lies on
. See Figure \ref{Fig:TrianPseudo} (left). The segment  splits  into two
sub-pseudo-triangles  and . The pseudo-triangle  has  as an
apex and the same base as . Its left chain is the portion of
 from  to the left, and its right chain is the
concatenation of  with the portion of  to the right
of . The pseudo-triangle  has  as its base, the
same apex as , and its left and right chains are the portions of
 and  delimited respectively by  and by
. A symmetric situation arises when . We add the
edge  to , and recursively triangulate each of
 and . We say that the edge  in  is
\textit{generated} by .  In the further recursive steps, we redefine
, for vertices  of each of these sub-pseudo-triangles,
restricting the visibility to only within the respective
pseudo-triangle. 
Note that for any pair of vertices  that lie on the same chain of , the segments  and  do not intersect in their relative interiors. Therefore, if  changes after a recursive call then it must change to a vertex of the base of the corresponding sub-pseudo-triangle.
See Figure \ref{Fig:TrianPseudo} (right). 
The recursion
bottoms out when the interior of  is a triangle.
Note also that all the chords in  cross the vertical ray above , and so they are totally ordered in the vertical direction.

\medskip
\noindent
{\bf Properties of .}
Every vertex  of the funnel of , other than the leftmost and the rightmost vertices and the apex, generates exactly one edge  during the whole recursive process. (For example, in Figure \ref{Fig:TrianPseudo} (left), the vertex  will not generate an edge in , since it is an endpoint of that funnel, but will still generate an edge within , or within some recursive sub-pseudo-triangle of .) 
We denote by  the sub-pseudo-triangle in which  is generated, and by  the other endpoint of . Note that  is either the original  or an endpoint of the base of .











\section{Number of Discrete Changes in }\label{Sec:CombiChanges}
In this section we bound the overall expected number of discrete changes that  experiences as the points of  move along (continuous) pseudo-algebraic trajectories of constant description complexity.
The analysis is with respect to a fixed random permutation  of  drawn ahead of the motion, so that the motion is ``oblivious'' to the choice of . Thus, even though the -order of the points may change during the motion, each point retains its initial priority, and the permutation  is still a random permutation of , with respect to the -order of these points, at any fixed .

\medskip
\noindent
{\bf Discrete changes in .}
For a fixed time instance , each pseudo-triangle  is defined by its endpoints 
, , and by its apex . 
Given such a triple of points, they define a
valid pseudo-triangle at time  if and only if they, and the points
in-between in the -order, satisfy the conditions of Lemma
\ref{Lemma:ConditionPseudo} (at time ).  Thus, as long as the
-order of the points does not change,  does not change
either. That is, it consists of a fixed set of pseudo-triangles, each
defined by a fixed triple of points. However, the geometric structure of
a pseudo-triangle may change during such a time interval, and we will bound the number of these changes separately. Changes in (the labelings of the pseudo-triangles of)  occur only at discrete times when the
-order of some pair of points in  changes; we refer to these
changes as -\textit{swap events}.  

We assume that each
pseudo-triangle  is present in  at a maximal connected time
interval , which is associated with .  That is,
pseudo-triangles with the same triple , , and 
   that appear in  at
disjoint time intervals, are considered distinct.  We emphasize that
all the other features of , such as , the
chains  and , and the triangulation  of its funnel, may undergo discrete changes during
the time interval .  A pseudo-triangle  is created or
destroyed only at a swap event when a point  with
 crosses one of the vertical lines
through its endpoints  and  (of course, this also subsumes the cases where  is smaller than that of an endpoint of ), or when the
-order of the points in the triple defining  changes. In the
former case, if  then  is replaced
by another pseudo-triangle  with the same endpoints
,  but with 
as a new apex.

If  then 
replaces the endpoint it was swapped with.  Thus, each pseudo-triangle
 in our kinetic pseudo-triangulation\\  is
\textit{defined} by at most five points:
, , , and at most two additional
points which determine, by swaps with the endpoints of , the
endpoints of the lifespan  of  in .

\medskip
\noindent
{\bf Discrete changes in .}
Fix a pseudo-triangle . 
We only consider discrete changes in the funnel of  and its triangulation , and ignore changes in the tails  (unless they also affect the funnel). This is because the changes in the tails will also show up as changes in the funnels of other pseudo-triangles that are created further down the recursion.

For a fixed time instance
, the combinatorial structure of the triangulation
 of  depends only on the discrete structure of the
boundary of the funnel of  (i.e., the ordered sequences of the
points along the chains , , and the base
) and the visibility points  of all the
vertices of the funnel of , excluding  (of course, it also depends on ).
Therefore, as the points of  move during the time interval
,  can change combinatorially only at events where the boundary
or visibility structure of  changes. These events fall into the
following three types:

(i) \textit{Envelope events}, which occur at instances when one of the
chains ,  contains three collinear vertices; see
Figure \ref{Fig:VisibilityEvent} (right).  This happens when a vertex
(which is not an endpoint of ) is added to or removed
from one of the chains bounding .  We denote the total number of
such events during the period  by .


\begin{figure}[htb]
\begin{center}
\input{VisibilityEvent2.pstex_t} \hspace{2cm} \begin{picture}(0,0)\includegraphics{EnvelopeEvent.pstex}\end{picture}\setlength{\unitlength}{2565sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3628,2347)(3938,-3433)
\put(5374,-2970){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5304,-1322){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5442,-2421){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6396,-1981){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5967,-3346){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5743,-2751){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5647,-1927){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf Left and right: visibility and envelope events (respectively). The sub-pseudo-triangle
 contains all edges which are inserted to or deleted from  at this event. \label{Fig:VisibilityEvent}}
\end{center}
\end{figure}


(ii) \textit{Visibility events}, at which a vertex  of  becomes collinear with an edge  of , or vice versa. See Figure \ref{Fig:VisibilityEvent} (left) ( is relevant only for visibility events that affect  and then  has to be its rightmost edge, and symmetrically for ).
This happens when  changes from  to , or vice versa. In particular, each (discrete) change of  corresponds to a visibility event in which the bridge becomes collinear with an edge of  or of  that is incident to the respective endpoint of the bridge. We denote the total number of visibility events during  by . 

A special case of this event occurs when  is created (resp., destroyed), so that right before (resp., after) the event, the funnel of  is empty. Note that immediately after (resp., before) the creation (resp., destruction) of , the funnel of  is a triangle.

(iii) \textit{Swap events}, at which some point , satisfying
, crosses one of the vertical lines
through  or . Note that a
single swap event of this kind may cause massive discrete changes, of
highly unlocal nature, in the chains , , in the visibility
pointers  of the vertices of , and in .
See Figure \ref{Fig:EnvelopeEvent} (left) for an illustration.

Note that a swap between any other pair of points  within the -range of  can be ignored in the present analysis, since the lower of the two points cannot belong to the funnel of  at the time of swap.

Assuming general position of the trajectories of the points,
the above events occur at distinct time instances (except that the same event may show up, in different forms, in several pseudo-triangles).

A visibility event happens when  changes for some point ;
we then say that  is {\em involved } in the visibility event.
An envelope event happens when a point  joins or leaves one
of the chains , ;
we then say that  is {\em involved } in the envelope event.

\begin{lemma}\label{Lemma:ingoingEnvelopeEvent}
The only point  for which  changes in an envelope event
is the point  involved in the event.
\end{lemma}

\begin{proof}
 The lemma follows since at
  the moment following (resp., preceding) the appearance of  on
  (resp., disappearance from) its chain, say , its
  two incident edges are almost collinear. Thus, all vertices  on
  the opposite chain satisfy  both before and
  after the event, and  is not affected by the event.
\end{proof}


\medskip
\noindent{\bf The number of changes in .}
We define  as the set of points , other than
, that appear on  between  and
, at any time during the life span , and put
. (Note that the points of  may enter or leave the interval between  and  in the middle of , at -swaps with either  or .) As noted above, every point  satisfies
.  Clearly, our triangulation undergoes
 swap events during  (recall that we only consider
swaps with  or ), and each of
them leads to  edge insertions and deletions to 
(the maximum number of edges in the whole triangulation ),
for a total of  such updates. We next bound the number of
discrete changes in  caused by events of the remaining two
types.

Fix a set of at most five points that can potentially define a
pseudo-triangle for some set of priorities.  This set has an associated time interval , and consists of
three points , , and , such that, at all times ,
, and of two additional points  and
 (each of which could be equal to ), so that the -coordinate of  swaps
with either  or  at times , for . For some drawings of the random priorities,  appears as 
a pseudo-triangle, and for other drawings it does not.
For  to appear in , the priorities of 
 and
 should be smaller than the priority of 
. The priorities of  and  have to be at most the priority of ,
and the priorities of all other points in   should be larger than
the priority of . The probability of this to happen, assuming  are all distinct, is easily seen to be  (for ).


When we
condition on drawings in which 
  indeed appears in  , the following holds.

\begin{proposition}\label{Thm:LogCostEvent}
  Let  be a pseudo-triangle in the kinetic triangulation
  . Then the expected number of discrete
  changes in the triangulation  of , after any single
  envelope or visibility event which happens during the period , and conditioned on  appearing in ,
  is .
\end{proposition}
\begin{proof}
  Clearly, the chords of  (the additional edges which partition  into triangles) admit a total vertical order, because
  they all cross the vertical line through .  Consider a
  time instance  when an envelope or a visibility event
  occurs, and let  be the point involved in
the event.
Let  (resp., ) be the time right before (resp., after) the event. 
Note
  that  cannot be the apex of  (unless the funnel of  is already, or is going to become, a triangle). Note also that  is not
  a vertex of , neither at  nor at , unless
   is involved in a visibility event which changes
  . In the latter case,  gains or loses
 its topmost triangle at
  time  but there are no other changes in the triangulation, as is easily checked.
 We may therefore assume that
   does not change at time
  , and that  is not a vertex of .

  With no loss of generality, we assume that  is a vertex of
   at time , and treat the remaining cases
  symmetrically (for a visibility event,  belongs to  also at time ).  Consider the triangulation  at time
   (that we would have obtained if we were to reconstruct  statically at time ).  Let  be the sub-pseudo-triangle of  within which
  the edge  is generated during the construction of  (see Figure
  \ref{Fig:VisibilityEvent} (right)).  
  Note that the event at time  leaves unchanged the visibility vertex  of each vertex  in  other than .
  Indeed, this follows from Lemma \ref{Lemma:ingoingEnvelopeEvent} for envelope events and is obvious for visibility events, using our assumption that  does not change. The recursive construction of  is easily seen to imply that 
  appears as a sub-pseudo-triangle in the construction also at time . Indeed, an easy inductive argument on the order of the ranks of the funnel vertices implies that the modified visibility vertices , and the resulting chords , also do not change, up to the point where  is constructed. Right after this step, the chord from  is drawn, so the rest of the construction of  might change completely, but only within . Hence,  contains every edge which
  is inserted to or deleted from  at time .  Therefore,
  the number of changes in  is bounded by , where
   denotes the number of vertices of  at the time of the event.


  Note that  is a random variable depending (only) on the permutation
   of , which is obtained by restricting  to
  . Recall that we condition the analysis on permutations 
 such that  indeed appears in .
In these permutations, the points of  have to follow all the (at most) five points defining ,
but as long as they obey this restriction
they can appear in any order.
It follows that, in our conditional probability subspace, the restriction
of  to  is a random permutation of  .

To bound the expected value of , we fix an arbitrary threshold  and prove that the event  occurs with probability at most . The expected value of  is then bounded
by 


To show that , we proceed through the following cases. In each case, except for the last one, we find a set  of  points which does not depend on , so that all its elements must appear in  after . This readily implies the asserted bound. The last case is more involved but it is still based on the same general idea.

\medskip
\noindent {\it Visibility event.} 
If  is a vertex of the base of , both at time  and at time , then  does not change combinatorially at time . Otherwise, as follows from the discussion in Section \ref{Sect:Static}, all three vertices that become collinear in the event appear in , both before and after the event, which implies that  at both times  and  (although they assume different values of these times).


Recall that  is assumed to be a vertex of , and suppose that .  If  contains at least  vertices of
, then it also contains a sequence  of 
consecutive vertices of  either immediately to the
left or immediately to the right of .  Otherwise, 
contains  together with at least  other vertices of
, so it must contain a sequence  of 
consecutive vertices of  lying either immediately to the
left or immediately to the right of .  In both cases, the
key observation is that  does not depend on
, and that 
precedes all the vertices of  in  (except possibly for
one extremal vertex which is a corner of ). As noted above, this establishes the asserted bound.


\medskip
\noindent {\it Envelope event.} 
Again, suppose that .  If  contains
at least  vertices of , the bound follows by exactly the same argument as in the case of a
visibility event. 
Otherwise, if  contains  we set  to be the first  points of  to the left of .
Again,  does not depend on , and all its elements must appear in  after , so the bound follows.





We therefore assume that  contains at most  vertices of
, and that its apex  is distinct from .
Thus, the edge  that  generates is the lowest edge of  which is a chord of . We argue that
 (before and after ; the definition of  implies that  precedes  in ). Indeed, otherwise, by the definition of
,  is a vertex of the base of , which
happens only if one of the chains of  consists of the single
edge . Since  and is involved in an envelope event, the edge  must be the only edge of the left chain of , which contradicts the fact that  must contain at least  vertices of
 (for ).  We distinguish between the following two cases.

(i)  (as depicted in Figure \ref{Fig:VisibilityEvent}
(right)). Then the entire left chain of  is contained in . Let  be the line passing through  and the
other two vertices of  participating in the envelope event,
and let  be the edge of  intersected by
. Clearly,  is contained in , because otherwise
 would not be convex.
If 
contains  consecutive vertices of
 which lie immediately to the left , we set  to be the set of these points, except for the leftmost one (which may be the endpoint of the base of ).
Otherwise we set  to be the set of  points lying on  to the right of . Since the definition of  does not depend on , the set  too does not depend on .

(ii)  (as depicted in Figure \ref{Fig:EnvelopeEvent} (right)). In this case we define at most  sets, each consisting of  points and independent of , such that all the points in at least one of these sets appear after both  and  in .
We fix  on  to the left of  and define 
as the set of  consecutive vertices of  which appear at time  (along ) immediately to the left of . By the current assumptions, if  is indeed the apex of  then all points  belong to  and, hence, satisfy . Since  is fixed,  is also fixed and is independent of . Hence, the above event happens with probability . 
Moreover,  is one of the at most  vertices of  that lie to the left of . Hence, by the probability union bound, the total probability of this scenario (over all the appropriate vertices ) is .

\begin{figure}[htb]
\begin{center}
\input{NonLocalSwap.pstex_t}\hspace{2cm}\begin{picture}(0,0)\includegraphics{EnvelopeEvent2.pstex}\end{picture}\setlength{\unitlength}{2565sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3604,2344)(3971,-3433)
\put(5595,-1944){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5081,-2342){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5605,-1301){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6396,-1981){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6134,-2628){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5967,-3346){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf Left: Swap event. The funnel of  immediately before the -swap between  and , which causes the vertices  and  to appear on , and the vertices  to disappear from . Right: Envelope event. The case in which  lies on .} \label{Fig:EnvelopeEvent}
\end{center}
\end{figure}




We have proved that  for any . This implies Equation (\ref{Eq:LogCost}) and completes the proof of Proposition \ref{Thm:LogCostEvent}.
\end{proof}

\begin{corollary}\label{Corol:LogCostEvent}
Let  be a pseudo-triangle in the kinetic pseudo-triangulation . Then the expected number of edge insertions and deletions in  during the period , conditioned upon the event that  appears in , is .
\end{corollary}


For a fixed pseudo-triangle  (including the choice of the connected life span ),  and  are 2-valued random variables: They are  if  does not appear in , and assume a fixed ``deterministic" value if  does appear.
The following theorem gives an upper bound on these values.





\begin{theorem}\label{Theorem:QuadEvents}
  For each pseudo-triangle  we have
  
and   , where  is the
  maximum number of times at which any fixed triple of points of 
  becomes collinear.
\end{theorem}
\begin{proof}
  We show the bound for visibility events. The bound for envelope
  events is known (see \cite{ABG,AKS}) and can be proved similarly.  

We fix a point  and count the number of visibility events where  is a
  vertex of  which is collinear with an edge of .
  To do so, we define, for each , a
  partially defined function  which measures the
  angle between  and the -axis, and whose domain consists of
  all  at which .  Clearly, each
  visibility event under consideration corresponds to a breakpoint of
  the lower envelope of  (but not necessarily vice versa; for example, such a breakpoint can arise at a time when  is not a vertex of the funnel of ). Since any pair
  ,  of these functions can intersect
  in at most  points (these are times at which , , and  are
  collinear),
and for each
 the domain of   
consists of a constant number of intervals (delimited by times at which either  or  swap with , or ), it follows that the number of
  breakpoints is  \cite{SA:ds}.  A
  symmetric argument holds for the number of visibility events where
   is a vertex of  which is collinear with an edge of
  . Repeating this analysis for each  yields the
  asserted overall bound.
\end{proof}



Fix a pseudo-triangle . Conditioned on  priorities that
cause  to appear in , Corollary \ref{Corol:LogCostEvent} and Theorem \ref{Theorem:QuadEvents} imply
that the expected number of discrete changes in  is 
. 
Let  be the probability that  indeed
appears in . Then the total expected number of discrete 
changes in  
is




\begin{lemma}\label{Lemma:BoundSumQuads} 
, where the sum is over all (possible sets of  points defining) possible pseudo-triangles .
\end{lemma}


\begin{proof}
Without loss of generality, we only consider pseudo-triangles  with , which are defined by five distinct points of . (Pseudo-triangles defined by fewer than five distinct points, or those
whose defining -tuple includes  and/or  are analyzed similarly, replacing the exponent  by the appropriate .)
Thus, as already noted, , because  appears in  if and only if the priorities of the
five points that define  are smaller than the priorities of 
all other points in 
(and  has the largest priority among the defining points).
Therefore


In what follows, we call  
 the {\em level} of .
Let  (resp.\ ) denote the
maximum number of pseudo-triangles of level  (resp., of level at most ), defined by  points, in a set of
  moving points.
We claim that . To see this, consider all the pseudo-triangles  (defined by five points) whose birth time is determined by a fixed -swap event occurring at some time , between some pair of points . Assume without loss of generality that . Then  and  are among the  points whose -coordinates lie at time  immediately to the right of .
Similarly, the fifth point, which is responsible for the destruction of , is one of the first  points whose -coordinates enter the interval between  and . Thus, each of the  -swap events defines the creation time of at most  pseudo-triangles of level at most , which readily implies the asserted bound on . We thus have


\end{proof}





The combination of Corollary \ref{Corol:LogCostEvent},
Theorem 
\ref{Theorem:QuadEvents}, and Lemma \ref{Lemma:BoundSumQuads} implies
the following summary theorem.
\begin{theorem}
The total expected number of discrete changes in the kinetic triangulation  is .
\end{theorem}

\section{Kinetic Maintenance of }\label{Sec:DataStruct}
In this section we describe a kinetic data structure which
supports efficient maintenance of  under motion.
The structure satisfies\footnote{\small As in \cite{AKS}, all properties (except for compactness) hold \textit{in expectation}, with respect to the random permutation .} the standard requirements of \textit{efficiency, compactness, responsiveness}, and \textit{locality}, as reviewed in the introduction.

\medskip
\noindent
{\bf The static structure.}
We store the pseudo-triangulation tree  as a treap over , as
described in Theorem \ref{Lemma:treap}, whose inorder is the -order of the points and where
the heap order is according to their random priorities. Each node  in 
corresponds to the pseudo-triangle  
whose apex is the point stored at . We also store at , as auxiliary data,
the endpoints  and , which are inherited from appropriate ancestors of .

In addition, we also store at  the combinatorial description of the
funnel of , and of its triangulation .  This includes
, two ordered lists storing the vertices of
, and  in their left-to-right order, and the list of
the chords of , sorted in their vertical order (i.e., the order of their intersections
with the vertical line through ).  We
represent any sorted list of vertices or edges\footnote{\small Note that we do not store explicitly the tails , because the overall storage that they would require could be too large, as they can be shared by many pseudo-triangles.} as a balanced
binary tree supporting each of the operations {\sf search}, {\sf split}, and {\sf concatenate},
 in  time \cite{Tarjan}.
To facilitate efficient kinetic maintenance of , we also store
the vertices of the upper hull of , in their left-to-right
order in a balanced search tree. Note that each edge of the triangulation (not on ) appears twice in our structure, once as  for some pseudo triangle , and once on  or  for some ancestor  of  or on the convex hull of .

\begin{theorem}\label{Thm:InitStructure}
  Let  be a set of  points in the plane.  The
  pseudo-triangulation tree , augmented with the auxiliary data items,
  as above, uses  space, and it can be initialized in  time.
\end{theorem}
\begin{proof}
  The asserted bound on the overall storage follows from the easy
  observation that  contains  nodes, and every point
   appears as a non-corner vertex on at most one chain
  , , over all nodes  of .

  We construct the pseudo-triangulation tree  (excluding the
  auxiliary items , ,  and
  the chords of ) in a single \textit{top-down} pass, which implements the recursive construction given in Section \ref{Sect:Static}.  Clearly, this can be done
  in  time, after an initial sorting of the points of , by their
  -coordinates and by their priorities; sorting the points
  takes
   time.


  We next compute the items , , and 
  stored at the nodes  of , by a single \textit{bottom-up}
  traversal of , which computes for every node  the upper
  hull  of the set .
  When we process a new non-leaf node , we have already visited
  its respective left and right children  and , so their hulls  and  are already available.  We compute
   in  time by a simultaneous binary seach
  over  and , in the manner described in
  \cite{Overmars}. Then we use  
  to split  (resp.,
  ) into  and  (resp., 
  and ).  We store explicitly the chains   at
  , and compute  by concatenating the three edge lists
  , , and , in a similar manner to that described in \cite{AKS}. Overall, we spend
   time at each node of , for a total of
   time.

  Finally, for each node  in , we compute the list of chords of
   using the recursive mechanism described in Section \ref{Sect:Static}.
  Recall that every non-corner vertex  of the funnel of  generates
  exactly one edge  which recursively splits the unique
  sub-pseudo-triangle  of . We process the non-corner
  vertices of  in the increasing order of their
  priorities, and store the edges constructed so far in a list, in
  the order of their intersections with the vertical line through
  .

  It takes  time to process a non-corner vertex  of
  , for a total of  time. Indeed, we can determine the
  corners of  in  time, by a binary search over the
  list of the previously generated edges. In addition, we can
  determine  by a binary search over the appropriate chain
   or , obtain  in  additional time, and insert the chord  into the list of chords in  time.
\end{proof}


\medskip
\noindent
{\bf The kinetic certificates.}
To ensure the validity of  and its triangulation ,
we use three types of \textit{certificates}, denoted as ,  and
. Each certificate is a  predicate on  a constant number of
points.  As long as all the certificates remain true, the validity of
 and  is ensured.  Each certificate contributes a
critical event to the global event priority queue , which is the first
future time at which the certificate becomes invalid (if there is such a
time).

\smallskip
\noindent {\bf \emph{-certificates}.} To ensure the validity of the tree
 (ignoring the auxiliary data), each pair of points  with consecutive -coordinates contributes a -certificate
asserting that the order of  and  remains unchanged.
This certificate fails at the first future moment of an -swap between  and .
According to Lemma \ref{Lemma:ConditionPseudo}, -certificates (together with the chosen priorities) are
sufficient to ensure the validity of the ``bare" tree .

\smallskip
\noindent {\bf \emph{-certificates}.} 
For each node  in , the edge   contributes a
-certificate ensuring that the (current) neighbors of  and 
on  and 
remain below the line through  and .  This certificate
involves\footnote{\small If  does not exist then we have an
  even simpler certificate which fails when the two edges of
   incident to  become
  collinear.} at most six points and fails at the first future time of
collinearity between , and one of their four neighbor vertices on
 and on .

So far, we have ensured the validity of the tree  and of the edges  stored at its nodes . Moreover, the validity of all the chains  is also ensured because each one of their edges either belongs to  or appears as  at some descendant  of . Here a collinearity between three consecutive points on  or on  (an envelope event) will be detected as a change in , for the appropriate descendant . 
Similarly, the validity of the upper hull of  follows since each of its edges either belongs to  or appears as  at some node .
See \cite{AKS} and \cite{Overmars} for more details.

\smallskip
\noindent {\bf \emph{-certificates}.}
It only remains to ensure the validity of the triangulations , over all nodes
. For this we need the third type of certificates, denoted by
.  Fix a node  in . Every internal point  of
 or  contributes a  certificate ensuring
the validity of . This certificate involves , , and 
the two points adjacent to 
  on its chain. It fails when one
of the points adjacent to
  becomes collinear with  and .

Clearly, all of the above certificates use  storage,
and can be initialized, including the construction of the event queue  of their first failure times, by the algorithm of Theorem
\ref{Thm:InitStructure}, without increasing its overall assymptotic
running time, i.e., in  time.

\medskip
\noindent
{\bf Handing critical events.} 
We next describe the repair operations 
required when an event, at which some certificate fails, happens. 

\smallskip
\noindent{\bf \emph{-certificates.}} Failure of a -certificate occurs at an -swap.
That is,
the order of the -coordinates of two consecutive points along  switches, at some time .

With no loss of generality we assume that ,
implying that  is a descendant of , where  denote the time just before and just after , respectively.  To update
  we reconstruct  from scratch the subtree rooted at the node  
containing , and recompute the kinetic
 certificates associated with its nodes and the points that they
contain. We remove the failure times
 of the expired certificates from , and insert the new ones.  All
 this can be done in  time using the algorithm of
 Theorem \ref{Thm:InitStructure}, where . We prove that  by applying a
 simplified version of the analysis used in Proposition
 \ref{Thm:LogCostEvent}. As above, it suffices to show that
 , for any .  Indeed,  implies
 that either each of the  points 
whose -coordinates immediately precede  or each of the
 points 
whose -coordinates immediately follow  at time 
satisfies  . 
This happens\footnote{\small We emphasize again that arguments of this kind are based on the assumption that the motion of the points is oblivious to the choice of priorities.} with probability at most
 . Thus, we can reconstruct the subtree rooted at  in  expected time.

 As can easily be checked, if neither  nor  is
the leftmost or the rightmost point of  (excluding the points
at infinity which we added)
 then no further updates outside the
 subtree of  are needed, and no additional certificates need to be
 created or destroyed. (That is because  and , so the upper hull  contains at most one of , and it does not change as a result of the swap.)
 We next describe the necessary modifications in the setting, depicted in Figure \ref{Fig:SwapEnvelope}, in which case we
 assume that (i)  and  are the two points with the smallest
 -coordinates, (ii) , and (iii)
the -coordinate of
  is larger than at 
when they swap; the other cases are treated
 symmetrically.  The -swap between  and  causes  to appear
 on the upper hull of , below and to the left of .
We add  to the upper hull in  
 time. Similarly,  becomes part of the tail  of every
 ancestor  of  (both  and  lie on the leftmost path of the treap). If  is such an ancestor whose bridge is incident to  (from the right), then we have to incorporate  into the certificate of
 , and possibly replace its old failure time in
  with a new one. Since the expected number of ancestors  of
 , in the treap , is  (see, e.g., \cite{SA96}), any swap event can
 be processed in  expected time.


 
\begin{figure}[htb]
\begin{center}
\begin{picture}(0,0)\includegraphics{SpecialSwap.pstex}\end{picture}\setlength{\unitlength}{3552sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2984,1715)(796,-2421)
\put(811,-2186){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2310,-2348){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1996,-1268){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3721,-1921){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1155,-1313){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1146,-1654){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1445,-884){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf The view after a swap event between a pair of points  with the smallest -coordinates stored in the left subtree of a node , whose -certificate has to be updated.}
 \label{Fig:SwapEnvelope}
\end{center}
\end{figure}

\smallskip
\noindent{\bf \emph{-certificates}.} 
Consider a time  when a 
-certificate at some node 
fails.
We assume
without loss of generality that at time  the leftmost vertex  of  becomes collinear with the leftmost edge  of , so that  was  before the event and is  afterwards, and
treat the remaining cases symmetrically. See Figure \ref{Fig:UpdateAncestor} for an illustration. As a result of this event,
the edge  replaces  as , the edge  is
added to the end of , and the triangulation  gains the new
triangle .  We need  time to update the
edge lists of  and  , and to compute the
-certificate of  (which ceases to be the endpoint of
) and add its failure time to . (Note that the -certificate of  is part of the former -certificate at .)


To recompute the new certificate of , we have
to determine the next edge  of  that is incident to 
from the right.  This edge is either stored in one of the lists 
or  at some ancestor  of , or it belongs to the
upper hull of . See Figure \ref{Fig:UpdateAncestor} (left).
We find  by doing a binary search on the lists  and  for the ancestors  of , and if necessary also on the convex hull of .

\begin{figure}[htb]
\begin{center}
\input{VisibilityEnvelope.pstex_t}\hspace{1.5cm}\begin{picture}(0,0)\includegraphics{VisibilityEnvelope1.pstex}\end{picture}\setlength{\unitlength}{2644sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5795,2146)(85,-1702)
\put(1141,-533){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2093,-586){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2318,-1419){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2903,-293){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(607,-1615){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3660,-241){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3226,-195){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4283,-106){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4501,-1493){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(699,-214){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small\sf Failure of the -certificate at  (shown at time  right after the event). Left: The case where the ancestor  that stores  coincides with the ancestor  that has lost . Right: The case where  is distinct from .}
 \label{Fig:UpdateAncestor}
\end{center}
\end{figure}


If  and  were part of the upper hull at time , we replace them by a single edge , in  time.
Otherwise,  has some ancestor  such that  and  are stored in the edge list of
 or . (There is exactly one such ancestor , which is equal to  unless  is incident to ; see Figure \ref{Fig:UpdateAncestor}. In the terminology of Section \ref{Sec:CombiChanges},  experiences an envelope event at time .)
We find  in  expected time by searching the edge lists stored at all ancestor nodes of , whose expected number is bounded by . We then replace  and  by  in the edge list of the respective chain  or , and remove from  the failure
time of the -certificate of  (within ).  Moreover, we have
to retriangulate a suitable sub-pseudo-triangle  of 
whose boundary, according to Proposition \ref{Thm:LogCostEvent}, has
expected complexity  (see also Figure \ref{Fig:EnvelopeEvent}).  To do so, we first determine ,
by locating the edge  in the edge list of , and then looking for
the lowest (resp., highest) edge above (resp., below)  which is generated by a vertex whose priority is smaller than .
We then recursively
triangulate , as described in the proof of Theorem
\ref{Thm:InitStructure}. All this can be done in  expected
time.  Therefore, we can process any
-certificate failure in  expected time.

\smallskip
\noindent {\bf \emph{-certificates}.} We finally consider the case when a visibility event, involving some point  within the funnel of ,
for some node  of
, causes the failure of the corresponding -certificate at some time .  Since the failed certificate is associated with an
internal vertex of  or , all the necessary
updates are local to the funnel of , and to its triangulation
.  We update the -certificate of  and insert its
new failure time into , in  time (the new neighbor of  is easily obtained in  from the respective edge list). In addition, we may
have to determine and re-triangulate a suitable sub-pseudo-triangle
 of , whose boundary has expected complexity  (see Proposition \ref{Thm:LogCostEvent}). An in the case of a failure of a -certificate, this can be done in  expected time, by searching the edge list of .





We thus obtain our main theorem.
\begin{theorem}\label{MainTheorem}
Let  be a collection of  moving points, as above. We can maintain the triangulation  under motion in a kinetic data structure of linear size, which processes an expected number of  events, each in  expected time, where  is the maximum number of times at which any single triple of points of  can become collinear. 
\end{theorem}

\medskip
\noindent{\bf Enforcing locality.} As implied by Theorem \ref{MainTheorem}, the proposed data structure for maintaining  is compact, efficient, and responsive (where the last two properties hold in expectation). To make it also local (in expectation), it is sufficient to ensure that at any moment of time the expected number of kinetic certificates involving any single point is . Clearly, each point is associated with at most two -certificates.
Since the expected depth of  is  and each pseudo-triangle of  defines a single -certificate, each point participates in an expected number of  -certificates.

We next slightly modify the definition of -certificates, in order to ensure that at any moment of time the total expected number of -certificates involving any point is also .
Consider a fixed moment of time  and a fixed node  in , and choose any vertex  on, say, the left chain .
Currently,  participates in a single certificate that it generates (ensuring the validity of ), and in an arbitrary number of certificates generated by all the vertices  of  satisfying .
We modify our algorithm by keeping (i.e., storing in  the failure times of) only the certificates of  that are generated by the leftmost and the rightmost such vertices  in . 
If  lies on , we act symmetrically. We apply this modification to every node  and every vertex of .
This modification does not affect the correctness of the kinetic data structure because, as can be easily checked, among all the -certificates involving  and points  with , the first to fail must be the extreme ones that we keep.

Now, at each node , every vertex of  participates in at most three -certificates. Since the expected depth of  is , the asserted (expected) locality bound follows. The kinetic maintenance of this restricted set of -certificates resembles that of the original set, with the following minor modification. Each time when we process a visibility event caused by the failure of some -certificate, generated by a vertex  at some node , we also have to recompute the -certificates involving the old and the new points . This can be done in  time using a binary search over  or , which does not affect the time bounds in Theorem \ref{MainTheorem}.

 

\begin{thebibliography}{}

\bibitem{ABG} P. K. Agarwal, J. Basch, L. J. Guibas, J. Hershberger and L. Zhang,
Deformable free-space tilings for kinetic collision detection,
{\it Internat. J. Robotics Research} 21 (2002), 179--197.

\bibitem{Stable}
P. K. Agarwal, J. Gao, L. Guibas, H. Kaplan, V. Koltun, N. Rubin and M. Sharir,
Kinetic stable Delaunay graphs, \textit{Proc. 26th Annu. ACM Symp. on Comput. Geom.} (2010), to appear.

\bibitem{AgKS}
P. K. Agarwal, H. Kaplan and M. Sharir,
Kinetic and dynamic data structures for closest pairs and nearest neighbors,
{\it ACM Trans. Algorithms} 5 (2008), Article 4 (37 pp.)

\bibitem{AWY}
P. K. Agarwal, Y. Wang and H. Yu,
A 2D kinetic triangulation with near-quadratic topological changes,
\textit{Discrete Comput. Geom.} 36 (2006), 573--592.

\bibitem{AKS}
G. Alexandron, H. Kaplan and M. Sharir,
Kinetic and dynamic data structures for convex hulls and upper
envelopes,
{\it Comput. Geom. Theory Appls.} 36 (2007), 144--158.

\bibitem{TwoPolyg04} 
J. Basch, J. Erickson, L. J. Guibas, J. Hershberger and L. Zhang, Kinetic collision detection between two simple polygons, {\it Comput. Geom. Theory Appls.} 27 (3) (2004), 211--235.

\bibitem{BG99}
J. Basch, L. J. Guibas and J. Hershberger,
Data structures for mobile data,
{\it J. Algorithms} 31 (1999), 1--28.

\bibitem{BernEpp} M. W. Bern and D. Eppstein, Mesh generation and optimal triangulation, in: Computing in Euclidean
Geometry (D.-Z. Du and F. K.-M. Hwang, eds.), World
Scientific, 2nd edition, 1995, pp. 47--123.

\bibitem{Geodesic} B. Chazelle, H. Edelsbrunner, M. Grigni, L.J. Guibas, J. Hershberger, M. Sharir and J. Snoeyink, Ray shooting in polygons using geodesic triangulations, {\it Algorithmica} 12 (1994), 54--68.





\bibitem{CS}
K.~Clarkson and P.~Shor, Applications of random sampling in
computational geometry, II, \emph{Discrete Comput. Geom.} 4 (1989),
387--421.


\bibitem{TOPP}
E.~D.~Demaine, J.~S.~B.~Mitchell and J.~O'Rourke,
The Open Problems Project,
\texttt{http://www.cs.smith.edu/\~{ }orourke/TOPP/}.


\bibitem{Lagrangean} 
J. Donea, Arbitrary Lagrangian-Eulerian finite element methods, in: \textit{Computational Methods for Transient
Analysis} (T. B. Belytschk and T. J. R. Hughes, eds.), North-Holland, Elsevier, 1983, pp. 474--516.

\bibitem{EdelsMeshes} 
H. Edelsbrunner, Triangulations and meshes in computational geometry, \textit{Acta Numerica} 9 (2000), 133--213.


\bibitem{FU91}
J.-J. Fu and R. C. T. Lee, Voronoi diagrams of moving points in the
plane, {\it Internat. J. Comput. Geom. Appl.} 1 (1994), 23--32.

\bibitem{GMR91}
L. Guibas, J. Mitchell and T. Roos, Voronoi diagrams of moving
points in the plane, {\it Proc. 17th Internat. Workshop
Graph-Theoret. Concepts Computer Science}, Lecture Notes in Comp.
Sci., vol.\ 570, Springer-Verlag, 1991, pp.\ 113--125.

\bibitem{Gui}
L. Guibas,
Kinetic data structures: A state of the art report.
{\it Robotics: the Algorithmic Perspective} (WAFR 1998),
191--209, A.K. Peters, Natick, MA, 1998.



\bibitem{LS}
D. Leven and M. Sharir,
Planning a purely translational motion for a convex object in
two--dimensional space using generalized Voronoi diagrams,
{\it Discrete Comput. Geom.} 2 (1987), 9--31.




\bibitem{Overmars}
M. H. Overmars and J. van Leeuwen, 
Maintenance of configurations in the plane, {\it J. Comput. Syst. Sci.} 23 (2) (1981), 166--204.

\bibitem{SA96}
R. Seidel and C. R. Aragon,
Randomized search trees,
{\it Algorithmica} 16 (1996), 464--497.

\bibitem{SA:ds}
M. Sharir and P. K. Agarwal,
{\it Davenport-Schinzel sequences and their geometric applications},
Cambridge University Press, New York, 1995.

\bibitem{Speckmann} D. Kirkpatrick, J. Snoeyink and B. Speckmann, Kinetic collision detection for simple polygons, 
{\it Internat. J. Comput. Geom. Appl.} 12 (1-2) (2002), 3--27.

\bibitem{Tarjan} R. E. Tarjan, \textit{Data Structures and Network Algorithms}, Society for Industrial and Applied Mathematics, Philadelphia, 1983.

\end{thebibliography}
\end{document}
