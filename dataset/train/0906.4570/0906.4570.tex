\documentclass[conference]{IEEEtran}
\pagestyle{plain}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{rotating}
\usepackage{proof}
\usepackage{color}
\usepackage{amssymb}
\usepackage{url}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{epic,eepicemu}
\usepackage{version}

\newcommand{\testo}[1]{\ensuremath{\texttt{#1}}}
\newcommand{\listansw}[3]{\ensuremath{#1[#2]}}
\newcommand{\state}[3]{\ensuremath{(#1,#2,#3)}}
\newcommand{\maybe}{\ensuremath{\mathsf{maybe}}}
\newcommand{\yes}{\ensuremath{\mathsf{yes}}}
\newcommand{\no}{\ensuremath{\mathsf{no}}}
\newcommand{\answt}[3]{\ensuremath{(#1,(#2,#3))}}
\newcommand{\update}{\ensuremath{\mathit{upd}}}
\definecolor{dgreen}{rgb}{0.13,0.54,0.13}
\newcommand{\sigsym}[1]{\mathsf{#1}}
\newcommand{\answf}[4]{\ensuremath{\langle #1, {#4:{#3}}, #2\rangle}}
\newcommand{\tell}{\ensuremath{\mathit{tell}}}
\newcommand{\ASK}{\ensuremath{\mathsf{ask}}}
\newcommand{\EVAL}{\ensuremath{\mathsf{eval}}}
\newcommand{\ORCH}{\ensuremath{\mathsf{orch}}}
\newcommand{\PermitOverr}{\ensuremath{\mathsf{PermOverr}}}
\newcommand{\DenyOverr}{\ensuremath{\mathsf{DenyOverr}}}
\newcommand{\FirstApp}{\ensuremath{\mathsf{FirstApp}}}
\newcommand{\allst}{\ensuremath{\mathsf{allst}}}
\newcommand{\exlst}{\ensuremath{\mathsf{exlst}}}
\newcommand{\filter}{\ensuremath{\mathsf{filter}}}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{assumption}{Assumption}
\newtheorem{verification-assumption}{Verification assumption}
\newtheorem{framework-assumption}{Framework assumption}
\newtheorem{fact}{Fact}
\newtheorem{property}{Property}
\newcommand{\close}{\IEEEQEDclosed}

\newcommand{\secref}[1]{Section~\ref{#1}}

\newcommand{\fix}[2]{} 



\newcommand{\longcite}{}
\includeversion{LONG}
\excludeversion{SHORT}

\begin{document}


\begin{SHORT}
\title{Verifying the Interplay of Authorization Policies and Workflow in Service-Oriented Architectures}
\end{SHORT}

\begin{LONG}
\title{Verifying the Interplay of Authorization Policies and Workflow in Service-Oriented Architectures (Full version)}
\end{LONG}

\author{\IEEEauthorblockN{Michele Barletta \qquad Silvio Ranise \qquad Luca Vigan\`o}
\IEEEauthorblockA{Department of Computer Science, University of Verona, Italy \\
\{\url{michele.barletta}  \url{silvio.ranise}  \url{luca.vigano}\}\url{@univr.it}}
}


\maketitle

\begin{abstract}
  A widespread design approach in distributed applications based on
  the service-oriented paradigm, such as web-services, consists of
  clearly separating the enforcement of authorization policies and the
  workflow of the applications, so that the interplay between the
  policy level and the workflow level is abstracted away.  While such
  an approach is attractive because it is quite simple and permits one
  to reason about crucial properties of the policies under
  consideration, it does not provide the right level of abstraction to
  specify and reason about the way the workflow may interfere with the
  policies, and vice versa.
  \begin{LONG}
    For example, the creation of a certificate as a side effect of a
    workflow operation may enable a policy rule to fire and grant
    access to a certain resource; without executing the operation, the
    policy rule should remain inactive.  Similarly, policy queries may
    be used as guards for workflow transitions.
  \end{LONG}

  In this paper, we present a two-level formal verification framework
  to overcome these problems 
  and formally reason about the interplay of authorization policies and
  workflow in service-oriented architectures.  This allows us to
  define and investigate some verification problems for SO
  applications and give sufficient conditions for their decidability.
\end{abstract}

\section{Introduction}

A widespread design approach 
in distributed applications based on the
Service-Oriented paradigm (SO), such as web-services, consists of
clearly separating the Workflow (WF) from the Policy Management (PM).
The former orchestrates complex processing of data performed by the
various principals using a set of resources made available in the
application, while the latter aims to regulate access decisions to the
shared resources, based on policy statements made by the involved
principals. This separation of concerns is beneficial in several
respects for the design, maintenance, and verification of the
resulting applications such as reusing policies across applications.

One of the key problems in obtaining a correct design of SO
applications is to be able to foresee all the---sometimes
subtle---ways in which their WF and PM levels interact. To understand
the difficulty underlying this endevor, let us first consider the WF
level. In this respect, SO applications can be seen as distributed
systems whose transitions can be interleaved in many possible
ways. This already creates a first difficult problem: to understand the behaviors of an SO application
and then to establish if it meets certain properties. An additional
burden, typical to SO applications, is the presence of the PM level,
which is supposed to constrain the allowed behaviors of the
application so as to meet certain crucial security
requirements. Declarative policy languages (such as Datalog and other
languages built on top of it, like Binder~\cite{deTreville:Binder},
SecPal~\cite{SecPAL-homepage} and DKAL~\cite{DKAL-homepage}), usually
based on a (fragment of) first-order logic, are used to design the PM
level of SO applications in a more flexible, reusable, and
verification-friendly way. The high flexibility and expressiveness of
such languages may grant access to a resource to someone who, in the
intention of the policy designer, is not allowed to do so.

To further complicate the situation, there are the subtle ways in which the WF and the PM levels may interact so as to give rise to behaviors that are unintended and may breach some crucial security requirements of an SO application. As a concrete example of this point, consider a system for virtual Program Committee meetings. A policy governing access to the reviews of a paper may be the following: a reviewer assigned to a paper is required to submit his own review before being able to read those of the others.  So, in order to resolve an access request to the reviews of a paper, the system should be able not only to know the identities and the roles of the various members of the Program Committee but also to maintain and consult the information about which reviewers have already submitted their reviews. Indeed, information of the first kind must be derived from the WF level.

Given all the difficulties to obtain correct designs for SO
applications, formal methods have been advocated to help in this
task. Unfortunately, most (see, e.g.,~\cite{fisler06,ryan05}) of the
specification and verification techniques (with some notable
exceptions, e.g.,~\cite{schaad}) have concentrated on one level at a
time and abstracted away the possible interplays between the WF and the PM
level. The \emph{first contribution} of this paper is a framework
capable of formalizing both the WF and the PM level as well as their
interface so as to enable a more precise analysis of the possible
behaviors of SO applications.  In particular, we use a temporal
extension of first-order logic, similarly to what has been proposed
in~\cite{manna-pnueli-book} for the specification and verification of
reactive systems.  The motivations for this choice are
three-fold. First, workflows can be easily specified by using
first-order formulae to describe sets of states and transitions of SO
applications. Second, a simple extension of this well-known framework
allows us to easily specify policy-relevant facts and
statements. Third, we hope to adapt and reuse to the case of SO
applications the cornucopia of specification and verification
techniques developed for reactive systems.  As a first step in this
direction, the \emph{second contribution} of this paper is to define
and investigate some verification problems for SO applications and
give sufficient conditions for their decidability. In particular, we
show how executability and some security properties (which can be
expressed as invariants) can be automatically verified within the
proposed framework.

We proceed as follows. In Section~\ref{subsec:comb-fol-ltl}, we
summarize the key points of a restricted combination of first-order
and temporal logic, which provides a formal basis for our approach.
In Section~\ref{sec:framework}, we present our formal two-level
specification framework for SO applications, which we apply, in
Section~\ref{sec:verification}, on a number of interesting
verification problems for SO applications. In
Section~\ref{sec:conclusions}, we discuss related and future work, and
draw conclusions.
\begin{SHORT}
Due to lack of space, proofs are given in the accompanying technical report~\cite{BRV-TR09}, which also contains the detailed formalization of a case study that illustrates our framework at work, as well as a number of useful pragmatical observations.
\end{SHORT}
\begin{LONG}
Due to lack of space, proofs are given in the appendix, together with 
the detailed formalization of a case study that illustrates our framework at work, and with a number of useful pragmatical observations.
\end{LONG}

\section{A restricted combination of first-order logic and temporal logic}
\label{subsec:comb-fol-ltl}

As a formal basis for our approach we use a
standard~\cite{manna-pnueli-book} minimal extension of \emph{Linear Time Logic} (\emph{LTL})
with a \emph{many-sorted version of First-Order Logic with equality}
(\emph{FOL}). We recall now some useful definitions and properties of
FOL where, for brevity, we do not explicitly consider sorts
although all notions can be easily adapted to the many-sorted version.
We assume the usual first-order syntactic notions of \emph{signature},
\emph{term}, \emph{literal}, \emph{formula}, \emph{quantifier-free
  formula}, \emph{substitution} and \emph{grounding} substitution,
\emph{sort} and so on, and call \emph{sentence} a formula that does
not contain free variables. Also the semantic notions of
\emph{structure}, \emph{satisfiability}, \emph{validity}, and
\emph{logical consequence} are the standard ones.  

Let  be a FOL signature. 
An \emph{expression} is a term, an atom, a literal, or a formula.
A \emph{-expression} is an expression built out
of the symbols in  where at most the variables in
the sequence  of variables may occur free, and we write
 to emphasize that  is a
-expression. Similarly, for a finite sequence
 of predicate symbols in , we write
 to denote a -formula where at most the
predicate symbols in  may occur.  We juxtapose
sequences to denote their concatenation,
e.g.~, and abuse notation and write
 to denote the empty sequence besides the empty set.  If
 is a substitution and  is a (finite) sequence
of expressions, then  is the sequence of
expressions obtained from  by applying the substitution
 to each element of .  

Following~\cite{manna-pnueli-book}, we use a tuple  of
variables, called \emph{WF state variables}, to represent the values
of application variables at a given instant of time, and use a FOL
formula  to represent sets of states.  WF
state variables take values in the domain of a first-order structure,
which formalizes the data structures, the values of the control
locations, and those of the auxiliary variables of the WF of a certain
SO application.  Formally, let  be a signature (containing,
e.g., the operators of certain data structures or the names of some
control locations) and  be a -structure;
 means that the state
formula  is true in  for the
valuation  mapping the variables in  to elements
of the domain of .  As shown in~\cite{manna-pnueli-book},
this is enough for the specification of virtually any reactive system
and hence also for the WF level.  However, the state of SO
applications should also support the PM level whose relevant part is
represented by tables where certain facts are recorded (e.g.,
``is-reviewer-of'' for the example in the introduction).  Following
the relational model of databases, we formalize tables as predicates
and we add to the WF state variables a set  of fresh
predicate symbols (i.e.\ ), called
\emph{PM state variables}.  Any -formula
 is an \emph{SO state formula}. 
For a -structure , a valuation  mapping
the WF state variables in  to elements of the
domain , and a relational valuation  mapping the PM state
variables in  (such that ) to the powerset of , we write 

to denote that  where
 is the -structure obtained from  by taking
, , and  for each .  The tuple  (or simply , when
 is clear from context) is an \emph{SO state}.

Let  be a signature and  be a -structure.
We formalize an SO application by a tuple
, called an
\emph{SO transition system}, where  are the WF state
variables,  are the PM state variables,  is a
-formula, and  is a
finite set of
-formulae,
called \emph{transitions}, which relate a set of SO states (identified
by the ``values'' of ) to that of a set
of SO ``next'' states (identified by the ``values'' of
).\footnote{We ignore fairness
  assumptions as, for simplicity in this paper, we are only concerned
  with security properties that can be encoded as a sub-class of
  safety properties.}  If  and
, then our notion of SO transition system
reduces to that of transition system in~\cite{manna-pnueli-book}; in
the rest of this paper, we assume that .

A \emph{run} of an SO transition system  is an infinite sequence of SO states  such that  and for every , there
exists a transition
 such that  where
 (respectively, ) map state variables and predicates in
 (respectively, ).

To specify properties of SO transition systems, we use an extension of
Linear Time Logic. Formally, let
 be SO state variables and  be a
signature; the set 
of \emph{LTL (state-based) formulae for  and
  } is inductively defined as
follows:
state formulae are in  and if  is
a state formula then  is in
.\footnote{The
  minimalist temporal logic defined here suffices for the purposes of
  specifying the sub-class of invariant properties that are relevant
  for this paper.  However, the proposed framework may be easily
  extended to support other temporal operators such as ``sometimes in
  the future,'' ``next'', or ``until.''} Note that we prohibit
alternation of FOL quantifiers and temporal operators: this makes the
logic less expressive but it helps to derive decidability results for
the satisfiability problem, which is a necessary condition to develop
(semi-)automatic verification methods for SO applications.


Let  be a -structure.  A \emph{model} of an
-formula is an
infinite sequence  of SO states such that
each  map all the SO state variables in
, for .
We then say that an
-formula
 is \emph{true in a model
}, and write

iff
\begin{itemize}
\item  whenever
   is a state formula;
\item  iff , for every .
\end{itemize}

Let  be
an SO transition system,  be a -structure, and
 be an
-formula.  Then,
 iff
 for every run  of .
A state formula  is an
\emph{invariant for the SO transition system } if
.

\section{A formal two-level specification framework  for SO applications}\label{sec:framework}
Recall that one of the main goals of this paper is to
provide a natural specification framework for SO applications whose
architecture is organized in two levels.  Indeed, it is possible to
model a large class of SO applications by using the notion of SO
transition system introduced in the previous section.  However, a good
framework should provide an adequate support to restrict the design
space for a two-level SO application and allow the designer to easily
specify the WF level, the PM level, and their interface in isolation
according to a divide-and-conquer strategy.  In our framework, this
consists of identifying suitable first-order structures formalizing
both the data structures at the WF level and the tables at the PM
level.  Unfortunately, working with first-order structures for
specification is quite difficult since there is no obvious way to
mechanically represent and reason about them.  Fortunately,
first-order theories are sets of FOL sentences that can be used as
reasonably precise approximations of first-order structures and for
which there is automated reasoning support.  Hence, we decided to use
theories to describe the WF, the PM levels, and their interface, as illustrated in 
Fig.~\ref{fig:ths-rels}: if  and  are the theories 
formalizing the WF and the PM levels, respectively, then their intersection , called the \emph{substrate theory}, formalizes their interface.

Intuitively, the theory  ensures that the WF and PM levels
``agree'' on certain notions. For example,  univocally
identifies the principals involved in the SO application and possibly
(an abstraction of) the {structure} of the resources that the SO
application can access or make available.  As we will see, the use of
theories allows us to easily import declarative policy specifications
expressed in logical languages based on (extensions of) Datalog in our
framework.
\label{sec:modelling}
\begin{figure}[tb]
\centering
\vspace*{-0.2cm}
\includegraphics[scale=.6]{relationpdf.pdf}
\vspace*{-0.5cm}
\caption{\label{fig:ths-rels}FOL formalization of the WF and PM levels
  of SO applications}
\end{figure}

A similar approach can also be used to restrict the formulae
characterizing transitions.  Intuitively, the transitions that can be
specified by formulae in the identified class are such that the
updates on the values of both the WF and the PM state variables are
functional (if we regard relations as first-order objects).  Since the
identities of the principals involved in the SO application being
specified play a crucial role in enabling or disabling the possibility
to execute a certain transition, the functional updates will depend
not only on the values of the actual SO state but also on the
existence of certain principals.

Before being able to formalize these intuitions, we recall the concept
of FOL theory and some standard related notions.

\subsection{First-order theories for SO applications}
\label{subsec:fol-theories-for-SOAs}
A \emph{-theory}  is a set of first-order
-sentences, called the \emph{axioms} of .  A
-structure  is a \emph{model} of the
-theory  iff all the sentences in  are true in
.  A -theory  is \emph{consistent} if it
admits at least one model.
The -\emph{satisfiability problem} for a quantifier-free
-formula  (such that
) consists of checking whether
there exists a model  of  and mappings  and 
such that .  By transformation in
disjunctive normal form (i.e.~as disjunctions of conjunctions of
literals), the -satisfiability problem for quantifier-free formulae
can be reduced to the -satisfiability problem for (quantifier-free)
conjunctions of literals.

For specifying SO applications, we usually need to introduce a finite
set of unique identifiers to name the various principals.  Formally,
this can be done by using a theory of the following kind.  An
\emph{enumerated data-type theory } is axiomatized
by the sentences

for  a sort symbol in the given signature (omitted for simplicity)
and ,  of sort  for  and .  It is easy to see that the
-satisfiability problem is decidable.  Enumerated
data-type theories will be sub-theories of the theory formalizing the
interface between the WF and PM levels.

For the WF level, we can reuse all the theories available in the
literature formalizing data structures and the decision procedures for
their satisfiability problem (see, e.g.,~\cite{sebastiani} for an
overview).  Enumerated data-type theories are also useful for the WF
level as they can formalize the (finitely many) control locations of
an application.  We now give a concrete example of a theory capable of
formalizing a simple message passing network that is relevant for SO
applications 
\begin{SHORT}
(see~\cite{BRV-TR09} for a more detailed case study).
\end{SHORT} 
\begin{LONG}
(see Appendix~\ref{subsec:running-ex} for a more detailed case study).
\end{LONG}
\begin{example}[Message passing]
  \label{ex:msg-pass}
  A net can be seen abstractly as a set of messages: sending a message
  amounts to adding the message to the set while receiving a message
  consists of checking if it is a member of the net; hence, messages
  are never deleted, only added to the set representing the net.  This
  view is simple but still allows one to model interesting facts such
  as the reception of messages in any order (since a set does not
  require an ordering on its elements) or duplication of messages (as
  a message is never removed from the net).

  To model the simple fragment of set theory necessary to formalize
  this idea in FOL, we use a theory ,
  parametrized over the sort  of messages which contains
   as the sort for sets of messages, the constant
   of sort  denoting the empty set,
  the binary function symbol  of sort  denoting the
  operation of adding a message to a set of messages, and the binary
  predicate symbol  of sort  for checking if a message is in a set of
  messages. The axioms of  are the
  following three sentences:
  
  where  are variables of sort  and  is a
  variable of sort .  It is easy to describe the
  states of a variable \texttt{net}: just introduce a logical variable
   and use suitable formulae from the theory
  .  For example,
  the formula  constrains
  \texttt{net} to contain at least two messages (plus possibly
  others).  Note that the only free variable in the formulae
  describing sets of states is .  The
  -satisfiability problem is
  decidable~\cite{ic03}.  \hfill \close
\end{example}

For the PM level, we recall the class of Bernays-Sch\"onfikel-Ramsey
(BSR) sentences~\cite{Boerger97}, which has been used, among other applications, to
model relational databases.  A \emph{BSR-theory} is a
set of sentences of the form

where  and  are tuples of variables and
 is a quantifier-free formula containing only predicate and
constant symbols (or, equivalently, no function symbols of arity
greater than or equal to ).  The decidability of the satisfiability
problem for any BSR-theory is a well-known decidability
result~\cite{Boerger97}.

The following sub-class of BSR-theories can be used to specify
policies as shown in, e.g.,~\cite{SPKI-SDSI-in-FOL}.  A
\emph{Datalog-theory} is a BSR-theory whose sentences are of the form

where , for , are predicate symbols,
and  are disjoint tuples of variables such
that the length of  is equal to the arity of .
Usually, sentences of the form (\ref{eq:horn-cl}) are written as 

where  can be read as the reverse of the implication
connective (sometimes also the universal quantifiers will be dropped).
Formulae written in this way are called \emph{rules} in the
literature, while their hypotheses and  are called
the \emph{body} and the \emph{head} of the rule, respectively.

We conclude by recalling some notions that are relevant for the
combination of theories that 
provide us with the formal tools to separately specify the WF and PM
levels of an SO application and then modularly combine them.  Let
 and  be two theories; we say that they \emph{share} the
theory  if  and their
\emph{combination}  is \emph{non-disjoint}.  Otherwise
(i.e.\ when ), we say that the {combination}  is \emph{disjoint}.  For verification, it is important to combine
decision procedures for each theory  and  so as to obtain a
decision procedure for their combination.  This is crucial to 
derive decidability results for verification problems of SO
applications as we will reduce them to satisfiability problems in the
combination of the theories formalizing the WF and the PM levels.  A
class of theories that will be relevant in this task (see
Lemma~\ref{th:dec-SOA-sat-univ} below) is the following.  A theory 
is \emph{stably infinite} if a -satisfiable quantifier-free formula
is satisfiable in a model of  whose domain has infinite
cardinality.  Examples of stably infinite theories are
 of Example~\ref{ex:msg-pass}, any BSR
theory (see, e.g.,~\cite{tinelli-zarba}), and many theories
formalizing data structures, such as arrays or sets.  Enumerated
data-type theories are not stably infinite as they admit only models
whose domains have finite cardinality.

\subsection{Two-level SO transition systems}
We are now ready to define an instance of the framework
of~\secref{subsec:comb-fol-ltl} to formally specify SO
applications designed according to the two-level architectures
considered in this paper. This framework relies on the following assumptions.
\begin{framework-assumption}\label{framework-one}
  As depicted in Fig.~\ref{fig:ths-rels}, we assume that the WF and
  PM levels are formalized by a -theory
   and a -theory , which share a
  -theory , called the
  \emph{substrate}. Formally,  and , and  and
  . \hfill \close
\end{framework-assumption}

The shared theory  plays the role of \emph{interface} between the
two levels.  A minimal requirement on the interface is to provide some
knowledge about the identities of the principals involved in the SO
application. This is formalized as follows.
\begin{framework-assumption}\label{framework-two}
   contains the sort symbol . \hfill \close
\end{framework-assumption}

This last assumption is crucial for many aspects of SO applications
related to PM, such as integrity (of messages or certificates),
authenticity (of certificates), and proof-of-compliance (of
credentials).

Using the notion of combination of theories introduced at the end
of~\secref{subsec:fol-theories-for-SOAs}, we are now able to define
the concept of background theory for an SO application that is obtained by
modularly combining the theories formalizing the WF and the PM levels.
Let , and  be consistent
theories satisfying Framework assumptions~\ref{framework-one}
and~\ref{framework-two}.  The \emph{background
  -theory } is the union of the
theories  and , i.e.\

and .  Note that, by
Robinson consistency theorem (see, e.g.,~\cite{chang-kiesler}),
 is consistent since both  and
 are assumed to be so.  We will sometimes refer to
 as the \emph{WF background theory} and to
 as the \emph{PM background theory}.

We introduce a particular class of SO transition systems (defined
in~\secref{subsec:comb-fol-ltl}) by using background theories obtained
by combining theories for the WF and PM levels satisfying the two
framework assumptions above.  A technical problem in doing this is the
following.  SO transition systems (in particular their states and
runs) are defined with respect to a certain first-order structure.  Instead,
we want to use theories that, in general, identify classes of
first-order structures and not just one particular structure.
However, since the verification problems for SO applications
considered below will be reduced to satisfiability problems, the
following notion tells us that---under suitable conditions---we can
use theories in place of structures.  A -theory  is
\emph{adequate} for a -structure  if 
, for some valuation 
mapping the variables in  to elements of the domain of
, is equivalent to the -satisfiability of
, for any quantifier-free formula
.  For example, it is possible to see that
enumerated data-type theories are adequate for any of their models (as
they are all isomorphic) or that the theory
 is adequate to the structure
containing finite sets of messages.  

As notation, let us write  (respectively, ) to abbreviate the finite conjunction, for , of formulae of the form  (respectively, ) when ,  (respectively, ), , and the length of  is equal to the arity of .
  
\begin{definition}[Two-level SO transition system]
  Let , , and  be consistent
  theories satisfying Framework assumptions~\ref{framework-one} and~\ref{framework-two} 
  and  be
  a -structure.  A \emph{two-level SO
    transition system (with background theory  
    adequate for )} is an SO transition system
   such that (a)
  ; (b)  is a state
  -formula of the form:
  
  where  is a finite sequence of variables of sort
  ,  is a quantifier-free
  -formula, and 
  is a quantifier-free
  -formula; and (c)
   is a finite state of transition formula of the form
  
  called \emph{guarded assignment transition}, where 
  is a tuple of variables of sort ;  are sets of variables of a sort dependent on the WF
  and PM levels of the application;  is a quantifier-free formula,
  called the \emph{guard} of the transition;  is a
  tuple of -terms,
  called the \emph{WF updates} of the transition, whose sorts are
  pairwise equal to those of the state variables in ;
  and  is a tuple of quantifier-free
  -formulae, called the \emph{PM updates} of the transition. 
  \hfill\close
\end{definition}

If  (recall that we have assumed that
 for SO transition systems,
cf.~\secref{subsec:comb-fol-ltl}), then we say that the SO application
is \emph{(purely) relational}.  Intuitively, the form
(\ref{eq:initial-formula}) for the initial state formula is inspired by
the observation that usually the principals at the beginning of the
computation have some common (or no) knowledge about the facts that
are relevant to the PM level.  Note that  and
 may not contain the state variables in
 and the state predicates in , i.e.\
updates are not recursive.  

\begin{SHORT}
Below, for simplicity, we will no more mention the
-structure  and implicitly assume
that  is adequate for .  To help
intuition, we illustrate the notion of two-level SO transition system
by means of a simple example (extracted from a larger one
in~\cite{BRV-TR09}).
\end{SHORT}
\begin{LONG}
Below, for simplicity, we will no more mention the
-structure  and implicitly assume
that  is adequate for .  To help
intuition, we illustrate the notion of two-level SO transition system
by means of a simple example (extracted from the case study in the appendix).
\end{LONG}
\begin{example}
  \label{ex:SO-appl}
  Consider a situation where the clerks of an office may send
  messages over a network.  The messages may contain, among many other
  things, certificates about their identities, roles, or capability to
  access certain resources in the organization they belong to.
  Certificates about the identities and roles are issued by a trusted
  certification authority while those about the access to a certain
  resource are issued by heads (who are clerks with this special
  right).  In order to comply with the policies of accessing
  resources, each clerk maintains a table about his/her identity,
  role, and access capability as well as about other clerks.  We
  describe a two-level SO transition system to formalize this
  situation.  

  First of all, we specify the WF background theory:
  
  where  and  are two clerks,
   is the trusted certification authority, 
  is a shared resource (e.g., a repository),  and
   are the possible roles of clerks, and
   is the theory for message passing
  introduced in Example~\ref{ex:msg-pass}.  In particular,
   is a theory to describe the structure of messages as
  follows: a message contains a field identifying the sender, a field
  identifying the receiver, and a field carrying their contents.
  Formally, this is done by introducing two new sort symbols
   and the ternary function  of sort
  .  Finally,  is a theory to provide
  functionalities to analyze the body of messages and extract some
  relevant information: the predicate  of
  sort  is
  capable of recognizing that the body of a message contains a
  certificate that its second argument is the identifier of a clerk
  whose role is that of its third argument.  For example, if
   is a constant of sort 
  representing the certificate that the employee  has the
  role , then the message sent by  to
   containing the certificate
   is encoded by the following term:
  
  and we will also have that, e.g., 
   holds.

  \begin{figure*}[t]
  
  \centerline{where  are variables of sort
    ,  is a variable of sort , and 
    is a variable of sort }
  \caption{\label{fig:transition-example3}A formalization of the interplay between WF and PM levels by a guarded assignment transition (cf.\ Example~\ref{ex:SO-appl})}
  \end{figure*}

  The state of the two-level SO transition system specifying the situation
  above should contain a WF state variable  of sort
   (containing the set of messages exchanged during
  a run of the transition system) and a PM state variable
   of arity  (storing the join of the tables of each clerk about
  their roles).  The initial state of the system
  should specify that no message has been exchanged over the net and
  that no role is known to the various clerks.  This can be formalized
  by a state formula as follows:
  
  which is a formula of the form (\ref{eq:initial-formula}) by taking
  , ,
  , and .

  As an example of interplay between the WF and PM levels,
  Fig.~\ref{ex:SO-appl} shows the guarded assignment transition of the
  form (\ref{eq:trans-form}) that formalizes what happens when a
  message containing a certificate about the role of an employee (say,
  ) is sent to another employee (say, )
  by the certification authority ().  Note that the
  content of the state variable  is left unchanged by
  the transition, whose only effect is to update the access table
  (represented by the predicate ) with the entry
  corresponding to the content of the received (role) certificate.
  For example, upon reception of the message containing the
  certificate , the following fact
  
  must hold in the next state, while for all the other triples,
   has the same Boolean value of
  .

  So far, we have specified the WF level of the SO application.  As
  anticipated above, we can define  to contain  and a
  finite set of Datalog rules that declaratively formalize the access
  policy statements of the SO application.  Since this way of
  formalizing policies has been well studied in the literature (see,
  e.g.,~\cite{deTreville:Binder}), as a simple example, we only give
  the following Datalog rule
  
  where the variable  is of sort  and
  .  It says that the clerk 
  can access the shared resource  if the latter knows
  (by retrieving the right entry in the table represented by
  ) that  has the role of .
  \hfill \close
\end{example}

\begin{SHORT}
  In~\cite{BRV-TR09}, we discuss in detail a generalization of the above
  example inspired by an industrial application.
\end{SHORT}
\begin{LONG}
  Appendix~\ref{sec:pragmatics-modeling} contains a generalization of
  the example above inspired by an industrial application.
\end{LONG}

\section{Some verification problems for SO applications}
\label{sec:verification}
Let  be a
two-level SO transition system with background theory 
for an SO application; for brevity, we will sometimes refer to
 simply as SO application. We define and investigate some
verification problems for SO applications and give sufficient
conditions for their decidability.
\begin{SHORT}
In~\cite{BRV-TR09}, we also
discuss pragmatical aspects of how to implement the decision procedures.
\end{SHORT}
\begin{LONG}
In appendices~\ref{sec:pragmatics-executability} and~\ref{sec:pragmatics-invariant}, we then 
discuss pragmatical aspects of how to implement the decision procedures.
\end{LONG}

\subsection{Executability of SO applications}
\label{sec:exec-so-apps}

Symbolic execution is a form of execution where many possible
behaviors of a system are considered simultaneously. This is achieved
by using symbolic variables to represent many possible states and
executions. For each possible valuation of these variables, there is a
concrete system state that is being indirectly simulated.  This
technique is particularly useful for the design of SO applications when
usually several scenarios are identified as typical execution paths
that the application should support.  Given the high degree of
non-determinism and the subtle interplay between the WF and
the PM levels, it is often far from being obvious that the SO
application just designed allows one or many of the chosen scenarios.  A
valuable contribution of the proposed framework is that symbolic
execution of SO applications can be done by using existing techniques
for automated deduction.  

In any scenario, there is only a known and finite number of principals. So, for the verification of the executability of two-level SO transition systems, 
we can assume that:
\begin{verification-assumption}
. \hfill \close
\end{verification-assumption}
Since there are only finitely many principals, universal quantifiers in initial state formulae do not add to expressiveness as  is logically -equivalent to a quantifier-free formula of the form ,
where  ranges over all possible grounding substitutions mapping the variables in  to the constants in .  Thus, we can further assume that:
\begin{verification-assumption}
Initial state formulae as well as any other state formula used to describe a state of a scenario are quantifier-free. \hfill \close
\end{verification-assumption}

The key notion for symbolic execution in our framework is the following. Let  and  two quantifier-free state -formulae; and let  be a transition formula of the form \eqref{eq:trans-form}.  We write  (in analogy with Hoare triples) to abbreviate the following formula:

whose validity modulo  implies that \emph{the transition  leads 
 from a state satisfying  to one satisfying }.
\begin{definition}
  Let  be a two-level SO
  transition system with background theory , let 
  be a sequence of transition formulae such that , and let
   be a sequence of quantifier-free state
  formulae. The \emph{(symbolic) execution problem} consists of
  checking whether  leads  from a state
  satisfying  to a state satisfying , or,
  equivalently, to checking
  
  for each . \hfill \close
\end{definition}

\begin{property}
  \label{prop:pre-comp-se}
  Let  and  be two quantifier-free state formulae and
   be a transition.  Then, it is possible to effectively compute
  a quantifier-free formula  that is logically equivalent to the
  negation of  and such that
   iff T_\mathit{SOA} \hfill \close
\end{property}

\begin{SHORT}
  That is, for quantifier-free  and , the negation of
   ``is'' still quantifier-free.
\end{SHORT}
\begin{LONG}
  That is, for quantifier-free  and , the negation of
   ``is'' still quantifier-free (e.g.,
  the negation of  in the case study in Appendix~\ref{subsec:running-ex}).
\end{LONG}

If we are able to check the -satisfiability of
quantifier-free formulae, then we are also able to solve the symbolic
execution problem for the two-level SO transition system with
 as background theory. We now identify sufficient
conditions on the component theories of  (i.e.\
 and ) for the
decidability of the -satisfiability problem.
\begin{lemma}
  \label{th:dec-SOA-sat}
  Let  be an enumerated data-type theory, and  and  be consistent theories with
  decidable satisfiability problems.  The -satisfiability
  problem is decidable for .
  \hfill \close
\end{lemma}

\begin{SHORT}
Pragmatical aspects of how to implement the decision procedures are discussed in~\cite{BRV-TR09}.
\end{SHORT}
\begin{LONG}
Pragmatical aspects of how to implement the decision procedures are discussed in Appendix~\ref{sec:pragmatics-executability}, extending the observations on the pragmatics of modeling WF and PM of SO applications of Appendix~\ref{sec:pragmatics-modeling}.
\end{LONG}

We are now in the position to state the main result of this section, which follows from the properties and lemmas above.
\begin{theorem}
  Let  be an enumerated data-type theory, and  and  be consistent theories with
  decidable satisfiability problems.  Then, the symbolic execution
  problem for two-level SO transition systems with background theory
   is decidable. \hfill \close
\end{theorem}

Note that the use of an enumerated data-type theory as 
does not imply that only two-level SO transition systems with finite state space can
be verified by our method.  In fact, both  and  can
have models with infinite cardinalities (this is the case, for
example, of the theory ).  So, symbolic execution is
decidable even if the state space of the two-level SO transition systems is infinite
provided that there exist decision procedures for the theories
characterizing the WF and the PM levels and it is possible to
find a common sub-theory, used for synchronization by the two levels,
whose models are finite.  

\subsection{Invariant verification of SO applications}
\label{sec:inv-so-apps}

Recall that we fixed a two-level SO transition system
 with background
theory .  We now consider the problem of verifying that 
 satisfies a certain security property
, in symbols .  Since many interesting
security properties can be expressed as invariance properties (e.g., for the verification of security protocols or web services), which are a sub-class of safety properties, we assume
below that  is a state formula of the form

Two remarks are in order.  First, we are considering a sub-class of
invariance properties since, in general,  can be a
past-formula (see, e.g.,~\cite{manna-pnueli-book}).  Second, we cannot
assume that a finite and known number of principals is fixed so that
(\ref{eq:inv-form}) is equivalent to a quantifier-free formula and thus
the verification techniques in~\secref{sec:exec-so-apps} still apply.
Rather, we want to verify that for a fixed but unknown number of
principals,  satisfies the invariance
property , i.e.\ we want to solve a \emph{parameterized}
invariance verification problem.  For this reason, in the rest of this
section, we assume that:
\begin{verification-assumption}
 is the theory of an equivalence relation. \hfill \close
\end{verification-assumption}

In this way, we are able to distinguish between the identifiers of the various principals.  
Now, in order to show that formulae of the form (\ref{eq:inv-form}) are
invariant of , we can use the well-known INV rule of
Manna and Pnueli~\cite{manna-pnueli-book}:
-1em]
          & \mathcal{A} & \models & \Box \varphi
  \end{array}

  \iota(\underline{i},\underline{p},\underline{x}) \wedge 
  \neg \psi(\underline{i},\underline{p},\underline{x}) \quad \mbox{ and } \quad
  \psi(\underline{i},\underline{p},\underline{x})  \wedge 
  \neg \varphi(\underline{i},\underline{p},\underline{x})

  \forall \underline{j}.\, \psi(\underline{j},\underline{p},\underline{x}) \wedge
  \tau(\underline{p},\underline{x},\underline{p}',\underline{x}') 
  \wedge
  \neg \psi(\underline{i}, \underline{p}',\underline{x}') 

    \forall \underline{i}:\mathit{Id}.\,
     \varphi(\underline{i},\underline{x},\underline{p}) ,
  
    \exists \underline{x},\underline{x}'.\,
    \varphi(\underline{p},\underline{x}) \wedge
    \tau(\underline{p},\underline{x},\underline{p}',\underline{x}') 
    \wedge
    \neg \psi(\underline{p}',\underline{x}') ,
  
    \exists \underline{x},\underline{x}'.\,
    \varphi(\underline{p},\underline{x}) \wedge
    \exists \underline{i},\underline{d}.\ (
    G(\underline{i}, \underline{d}) \,\wedge\,
    \underline{x}' = \underline{f}(\underline{x}, \underline{i}) \,\wedge\\
    \qquad \forall \underline{z}.\, \underline{p}'(\underline{z}) \leftrightarrow
    \underline{\phi}(\underline{z}, \underline{i}) )
    \wedge
    \neg \psi(\underline{p}',\underline{x}') .
  
    \varphi(\underline{p},\underline{x}) \wedge
    G(\underline{i}, \underline{d}) \,\wedge\,
    \underline{x}' = \underline{f}(\underline{x}, \underline{i}) \,\wedge\\
    \qquad
    \forall \underline{z}.\, \underline{p}'(\underline{z}) \leftrightarrow
    \underline{\phi}(\underline{p}, \underline{z}, \underline{i}) 
    \wedge
    \neg \psi(\underline{p}',\underline{x}') ,
  
    \varphi(\underline{p},\underline{x}) \wedge
    G(\underline{i}, \underline{d}) \,\wedge\,
    \neg \psi(\lambda \underline{z}.\,\underline{\phi}(\underline{p},\underline{z},\underline{i}),\underline{f}(\underline{x}, \underline{i})) ,
  
    \label{eq:qf-vc}
    \varphi(\underline{p},\underline{x}) \wedge
    G(\underline{i}, \underline{d}) \,\wedge\,
    \neg \overline{\psi}(\underline{\phi}(\underline{p},\underline{i}),\underline{f}(\underline{x}, \underline{i})) . 
  
    \exists \underline{x},\underline{x}'.\,
    \forall \underline{i}.\, \psi(\underline{i},\underline{p},\underline{x}) \wedge
    \tau(\underline{p},\underline{x},\underline{p}',\underline{x}') 
    \wedge
    \neg \forall \underline{i}.\, \psi(\underline{i}, \underline{p}',\underline{x}') .
  
    \exists \underline{x},\underline{x}', \underline{j}.\,
    \forall \underline{i}.\, \psi(\underline{i},\underline{p},\underline{x}) \wedge
    \tau(\underline{p},\underline{x},\underline{p}',\underline{x}') 
    \wedge
    \neg \psi(\underline{j}, \underline{p}',\underline{x}').
  
    \exists \underline{x},\underline{x}', \underline{j}, \underline{k}, \underline{d}.\left(
      \begin{array}{l}
        \forall \underline{i}.\, \psi(\underline{i},\underline{p},\underline{x}) \wedge 
        G(\underline{k}, \underline{d}) \,\wedge\, \\
        \underline{x}' = \underline{f}(\underline{x}, \underline{k})
        \,\wedge\,
        \underline{p}' = \lambda
        \underline{z}.\, \underline{\phi}(\underline{p},\underline{z},\underline{k}) \wedge \\
        \tau(\underline{p},\underline{x},\lambda
        \underline{z}.\, \underline{\phi}(\underline{p},\underline{z},\underline{k}),\underline{f}(\underline{x}, \underline{k})) \wedge \\
        \neg \psi(\underline{j}, 
        \lambda \underline{z}.\,
        \underline{\phi}(\underline{p},\underline{z},\underline{k}),
        \underline{f}(\underline{x}, \underline{k}))
      \end{array} \right) ,
  
    \forall \underline{i}.\psi(\underline{i},\underline{p},\underline{x})
    \wedge 
    G(\underline{k}, \underline{d}) \,\wedge\, \\
    \overline{\tau}(\underline{p},\underline{x},
    \underline{\phi}(\underline{p},\underline{z},\underline{k}),
    \underline{f}(\underline{x}, \underline{k})) \wedge 
    \neg \overline{\psi}(\underline{j}, 
    \underline{\phi}(\underline{p},\underline{z},\underline{k}),
    \underline{f}(\underline{x}, \underline{k})) ,
  
    \bigwedge_{\sigma} 
     \varphi(\underline{i}\sigma,\underline{x},\underline{p}) 
  
    \bigwedge_{\sigma} 
     \varphi(\underline{i}\sigma,\underline{x},\underline{p}) 
  
    \forall \underline{i}:\mathit{Id}.\,
     \varphi(\underline{i},\underline{x},\underline{p}) ,
  
\mathsf{knows}(P,AnyThing) \leftarrow \mathsf{knows}_{0}(P,AnyThing) 

\mathsf{knows}_{0}(P,said0(Q,AnyThing)) \leftarrow \mathsf{saysTo}_{0}(Q,AnyThing,P)\\
\mathsf{knows}(P,said(Q,AnyThing)) \leftarrow \mathsf{saysTo}(Q,AnyThing,P)

\mathsf{knows}(P,AnyThing) \leftarrow & \mathsf{knows}(P,\mathsf{tdOn}_{0}(Q,AnyThing)) ~ \wedge \\
											                  & \mathsf{knows}(P,\mathsf{said}_{0}(Q,AnyThing)) \\
\mathsf{knows}(P,AnyThing)  \leftarrow & \mathsf{knows}(P,\mathsf{tdOn}(Q,AnyThing)) ~ \wedge \\
                                                               & \mathsf{knows}(P,\mathsf{said}(Q,AnyThing))
 
\mathsf{saysTo}(Empl,& \mathsf{said}_{0} (\mathtt{RegOffCA},Cert),\_) \leftarrow \tag{Cert1}\\
& \mathsf{knows}(Empl,\mathsf{said}_{0}(\mathtt{RegOffCA},Cert)) \notag \\
\mathsf{saysTo}(Empl,& \mathsf{said}_{0} (Head,Cert),\_) \leftarrow \tag{Cert2} \\
& \mathsf{knows}(Empl,\mathsf{said}_{0}(Head,Cert)) \notag

\mathsf{saysTo}_{0} & (Head,\mathsf{storedocCRep}(Empl,\_)  \leftarrow \notag \\
& \mathsf{knows}_{0}(Head,\mathsf{storedocCRep}(Empl)) \tag{GenCert} 

&\mathsf{knows} (\mathtt{CentrRep},\mathsf{tdOn}_{0}(Head,\mathsf{storedocCRep}(Empl))) \leftarrow \notag \\
& \mathsf{knows}(\mathtt{CentrRep},\mathsf{said}_{0}(\mathtt{RegOffCA},\mathsf{isRegOffHead}(Head))) ~\wedge \notag \\
& \mathsf{knows}(\mathtt{CentrRep},\mathsf{said}_{0}(\mathtt{RegOffCA},\mathsf{isRegOffEmpl}(Empl))) \\
\tag{CentrRepTrustAnyoneViaHead}
  \mathsf{knows}(\mathtt{CentrRep},\mathsf{storedocCRep} (Empl)) 
    \exists i_1, i_2. 
     \left(
       \begin{array}{l}
         \mathsf{mem}(\mathsf{msg}(\mathtt{RegOffCA}, \mu[\mathsf{rolecert}(i_1, \mathtt{employee})], i_2), \mathit{net})
         ~\wedge \
         \mathit{net}' = \mathit{net} ~ \wedge \\
         
         \forall p_1,p_2,r.
           \mathsf{hasrole}'(p_1,p_2,r) \leftrightarrow 
           \left(
             \begin{array}{l}
               \mathit{if}~ (p_2=i_1 \wedge p_1=i_2 \wedge r=\mathtt{employee}) \\
               \mathit{then ~~ true} \\
               \mathit{else} ~ \mathsf{hasrole}(p_1,p_2,r) 
             \end{array} 
           \right)
         \end{array}
       \right)
  
    \exists i_1, i_2. 
     \left(
       \begin{array}{l}
         \mathsf{mem}(\mathsf{msg}(\mathtt{RegOffCA}, \mu[\mathsf{rolecert}(i_1, \mathtt{head})], i_2), \mathit{net})
         ~\wedge \
         \mathit{net}' = \mathit{net} ~ \wedge \\
         
         \forall p_1,p_2,r.
           \mathsf{hasrole}'(p_1,p_2,r) \leftrightarrow 
           \left(
             \begin{array}{l}
               \mathit{if}~ (p_2=i_1 \wedge p_1=i_2 \wedge r=\mathtt{head}) \\
               \mathit{then ~~ true} \\
               \mathit{else} ~ \mathsf{hasrole}(p_1,p_2,r) 
             \end{array} 
           \right)
         \end{array}
       \right)
  
    \exists d,c,i. 
     \left(
       \begin{array}{l}
         \mathsf{mem}(\mathsf{msg}(c, \mathtt{embeddoc}(d), i), \mathit{net}) ~ \wedge  \mathtt{isok}(d) ~ \wedge
         \mathsf{matchuser}(d,c) ~ \wedge \\
         net'=\mathsf{ins}(\mathsf{msg}(i,\mu[\mathsf{augdocwithdec}(d,\mathtt{acceptdoc})],\mathtt{CentrRep}),net) ~ \wedge \\
         \forall p_1,p_2,r.
           \mathsf{hasrole}'(p_1,p_2,r) \leftrightarrow \mathsf{hasrole}(p_1,p_2,r)
         \end{array}
       \right)
  
    \exists i,d. 
     \left(
       \begin{array}{l}
         \mathsf{mem}(\mathsf{msg}(i, \mu[\mathsf{augmentdocwithact}(d,\mathtt{storedoc})] ,\mathtt{CentrRep}), \mathit{net})
          ~ \wedge \\
         \mathsf{dbdoc}'=\mathsf{dbdoc}(d) ~ \wedge \\
         \forall p_1,p_2,r.
           \mathsf{hasrole}'(p_1,p_2,r) \leftrightarrow \mathsf{hasrole}(p_1,p_2,r)
         \end{array}
       \right)
  
\mathit{net} & = \\
& \mathsf{ins}(\mathsf{msg}(\mathtt{Charlie},\mathsf{embeddoc} (\mathsf{augdocwithsign}(req, \\
  & ~~~~~~~~~~ \mathsf{sign}(\mathtt{Charlie},req))), \mathtt{Ed}),\\
  & \mathsf{ins}(\mathsf{msg}(\mathtt{RegOffCA},\mathsf{embeddoc} (\mathsf{augdocwithsign}(\rho_E, \\
  & ~~~~~~~~~~\mathsf{sign}(\mathtt{RegOffCA},\rho_E))), \mathtt{Ed}), \\
  & \mathsf{ins}(\mathsf{msg}(\mathtt{RegOffCA}, \mathsf{embeddoc}(\mathsf{augdocwithsign}(\rho_H, \\
  & ~~~~~~~~~~\mathsf{sign}(\mathtt{RegOffCA},\rho_H))), \mathtt{Ed}),\mathsf{mty}))) ~ \wedge \\
  & \bigwedge_{p_1,p_2\in C, r\in R} \neg \mathsf{hasrole}(p_1,p_2,r)

    \mathsf{knows}(\mathtt{Ed}, \mathsf{isRegOffEmpl}(\mathtt{Ed}))
  
  \mathsf{mem}(\mathsf{msg} & (\mathtt{RegOffCA}, \mathsf{embeddoc} \\
  & (\mathsf{augdocwithsign}(\rho_E, \mathsf{sign}(\mathtt{RegOffCA},\rho_E))),\mathtt{Ed})), \\  
  & ~~~\mathsf{ins}(\mathsf{msg}(\mathtt{Charlie},\mathsf{embeddoc} (\mathsf{augdocwithsign}(req, \\
  & ~~~~~~~~~~ \mathsf{sign}(\mathtt{Charlie},req))), \mathtt{Ed}),\\
  & ~~~\mathsf{ins}(\mathsf{msg}(\mathtt{RegOffCA},\mathsf{embeddoc} (\mathsf{augdocwithsign}(\rho_E, \\
  & ~~~~~~~~~~\mathsf{sign}(\mathtt{RegOffCA},\rho_E))), \mathtt{Ed}), \\
  & ~~~\mathsf{ins}(\mathsf{msg}(\mathtt{RegOffCA}, \mathsf{embeddoc}(\mathsf{augdocwithsign}(\rho_H, \\
  & ~~~~~~~~~~\mathsf{sign}(\mathtt{RegOffCA},\rho_H))), \mathtt{Ed}), \\
  & \mathsf{mty}))))
  
    \neg \mathsf{knows}(\mathtt{Ed}, \mathsf{isRegOffEmpl}(\mathtt{Ed}))
  
    \mathsf{hasrole}(\mathtt{Ed}, \mathtt{Ed}, \mathtt{employee})
  
    \mathsf{knows}(i_1,\mathsf{isRegOffEmpl}(i_2)) 
    & \leftarrow &
    \mathsf{hasrole}(i_1, i_2, \mathtt{employee})
  
  \begin{array}{l}
  \Box \left(
  \begin{array}{l}
    \forall \mathit{preq}. \mathtt{dbdoc}(\mathit{preq})
    \Rightarrow 
    \exists \mathit{cit}, \mathit{req}, \mathit{empl}, 
            \mathit{preq}_1, \mathit{preq}_2. \\
     \left(
      \begin{array}{lcll}
        {\mathit{preq}_1}  =  
        \mathsf{augdocwithsign}(\mathit{req}, 
                                  \mathtt{sign}(\mathit{user}, \mathit{req})) ~ \wedge \\
        {\mathit{preq}_2}  = 
        \mathtt{augdocwithdec}({\mathit{preq}_1},
           \mathtt{accept})  ~ \wedge \\
        \mathit{preq} =
        \mathsf{augdocwithsign}({\mathit{preq}_2},
          \mathtt{sign}(\mathit{empl},{\mathit{preq}_2})) 
       \end{array}                                 
     \right)  
    \end{array}
    \right)
    \end{array}
   
  T_\mathit{WF} & := & \{ \psi ~\mbox{is a sentence} ~|~ 
                   Ax(WF)\models \psi \} \cup T_\mathit{sub} .

  T_\mathit{PM} & := & \{ \psi ~\mbox{is a Horn clause} ~|~ 
                   P(PM)\models \psi \} \cup T_\mathit{sub} .

    T_\mathit{WF} & := & \{ \psi ~\mbox{is a sentence} ~|~ 
                   Ax(WF)\models \psi \} \cup T_\mathit{sub}  \mbox{ and }\\
   T_\mathit{PM} & := & \{ \psi ~\mbox{is a Horn clause} ~|~ 
                   P(PM)\models \psi \} \cup T_\mathit{sub} ,

  2' ~~~~ A \longleftarrow \mathtt{Atoms}(\phi) \cup \mathtt{IE}(\underline{a},\underline{a}) .

  \forall \underline{i}:\mathit{Id}.\,
   \varphi(\underline{i},\underline{x},\underline{p}) 

to obtain a decision procedure for such a class of formulae.  Indeed,
the challenge here is to efficiently integrate the function
-\texttt{qfsat} and an instantiation strategy for the
universally quantified variables in .  This requires
some heuristics to filter out instances that are unlikely to
contribute to detecting the unsatisfiability of the formula.  To
understand why heuristics are needed, consider that the number of the
possible ground substitutions  is  where  is the
length of  and  is the length of .
Another key ingredient to scale up is to invoke
-\texttt{qfsat} incrementally so as to add one by one the
instances of .  Since tuning these heuristics and making them
work smoothly together require extensive experimental evaluation, we
leave the details for future work.  

\end{LONG}

\end{document}
