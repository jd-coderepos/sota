\documentclass[acmtocl,acmnow]{acmtrans2m}


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof_tree}
\usepackage{times}
\usepackage{url}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{definition}[theorem]{Definition}
\newdef{remark}[theorem]{Remark}

\newdef{example}[theorem]{Example}





\newcommand{\comment}[1]{}
\newcommand{\sidecomment}[1]{\marginpar{#1}}

\newcommand{\card}[1]{\sharp{#1}}
\newcommand{\var}{\mathcal{V}}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\mgu}{\operatorname{mgu}}
\newcommand{\set}[1]{\lbrace{#1}\rbrace}
\newcommand{\subst}[2]{{}^{#2}\!/_{\!#1}}
\newcommand{\pair}[2]{\langle{#1},{#2}\rangle}
\newcommand{\st}{\mathit{St}}
\newcommand{\est}{EncSt}
\newcommand{\lleft}[1]{\mathsf{lhs}(#1)}
\newcommand{\lhs}{\mathsf{lhs}}
\newcommand{\Lhs}{\mathsf{Lhs}}
\newcommand{\rright}[1]{\mathsf{rhs}(#1)}
\newcommand{\rhs}{\mathsf{rhs}}
\newcommand{\ttrue}{\mathsf{\bf true}}
\newcommand{\HK}{K}
\newcommand{\simple}{partial}

\newcommand{\penc}[2]{\operatorname{enc}(#1,#2)}
\newcommand{\penca}[2]{\{\![#1]\!\}_{#2}}
\newcommand{\enc}{\operatorname{enc}}
\newcommand{\enca}{\operatorname{enca}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\pub}[1]{#1}
\newcommand{\priv}{\operatorname{priv}}
\newcommand{\ar}{\operatorname{ar}}
\newcommand{\names}{\operatorname{names}}
\newcommand{\term}{\mathsf{Msg}}
\newcommand{\keys}{\mathsf{Key}}
\newcommand{\ids}{\mathsf{Id}}
\newcommand{\Time}{\mathsf{Time}}
\newcommand{\eqdef}{\stackrel{\mathsf{def}}{=}}
\newcommand{\rhoun}{\,\rho_1\,}
\newcommand{\rdeux}{\,\rho_2\,}
\newcommand{\sset}{\mathit{set}}
\newcommand{\lset}[1]{#1_s}
\newcommand{\N}{\mathbb{N}}
\newcommand{\bb}[1]{\overline{#1}}

\newcommand{\wit}{\operatorname{witness}}
\newcommand{\req}{\operatorname{request}}
\newcommand{\hidden}[1]{\mathsf{hidden}({#1})}

\newcommand{\simpl}{\rightsquigarrow}   \newcommand{\msimpl}{\rightsquigarrow}  \newcommand{\gsimpl}{\leadsto}          

\newcommand{\sacyclic}{strictly acyclic}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\posp}{\operatorname{Pos_p}} \newcommand{\sko}{\prec}
\newcommand{\nko}{\preceq}

\newcommand{\logic}{{\cal L}}

\newcommand{\new}{\mathsf{generate}}
\newcommand{\send}{\mathsf{send}}
\newcommand{\recv}{\mathsf{receive}}

\newcommand{\dedcons}[1]{deducibility constraint}
\newcommand{\dedsys}[1]{deducibility constraint system}
\newcommand{\dedconss}[1]{deducibility constraints}
\newcommand{\dedsyss}[1]{deducibility constraint systems}
\newcommand{\Dedsyss}[1]{Deducibility constraint systems}

\newcommand{\avispa}{AVISPA}

\setcounter{secnumdepth}{2}



\markboth{Hubert Comon-Lundh et al.}{Deciding security properties for cryptographic protocols}

\title{Deciding security properties for cryptographic protocols. Application to key cycles}

\author{
HUBERT COMON-LUNDH\\
ENS CACHAN \& Research Center for Information Security, AIST, Tokyo
\and
V\'ERONIQUE CORTIER\\
LORIA, CNRS \& Universit\'e Henri Poincar\'e \& INRIA Project CASSIS
\and 
EUGEN Z\u ALINESCU\\
MSR-INRIA Joint Centre, Orsay
}


\begin{abstract}
There is a large amount of work dedicated to the formal verification
of security protocols.
In this paper, we revisit and extend the NP-complete decision
procedure for a bounded number of sessions.
We use a, now standard, \dedcons{} formalism 
for modeling security protocols.
Our first contribution is to give a simple set of constraint simplification
rules, that allows to reduce any \dedsys{} to a set of \emph{solved forms}, representing all solutions (within the bound on sessions).




As a consequence, we prove that deciding the existence of key cycles is
NP-complete for a bounded number of sessions.
The problem of key-cycles has been put forward by recent works relating
computational and symbolic models.
The so-called \emph{soundness} of the symbolic model requires indeed
that no key cycle (e.g., ) ever occurs in the execution of
the protocol. Otherwise, stronger security assumptions (such as KDM-security)
are required.




We show that our decision procedure can also be applied to prove again
the decidability
of authentication-like properties and the decidability of a significant fragment of protocols with timestamps.
\end{abstract}





\category{F.3.1}{Logics and Meanings of Programs}{Verifying and Reasoning about Programs}

\terms{Security}

\keywords{formal proofs, security protocols, symbolic constraints, verification}



\begin{document}

\begin{bottomstuff}
This work has been partially supported by the ACI-SI Satin and the ARA SSIA Formacrypt.
\end{bottomstuff}


\maketitle




\section{Introduction}
Security protocols are small programs that aim at securing communications over a public network, like
Internet.
Considering the increasing size of networks and their dependence on
cryptographic protocols, a high level of assurance is needed in the
correctness of such protocols.
The design of such protocols is difficult and error-prone; many attacks are discovered even
several years after the publication of a protocol.
Consequently, there has been 
a growing interest in applying formal methods for validating
cryptographic protocols and many results have been obtained.
The main advantage of this approach is its relative simplicity which makes it
amenable to automated analysis.
For example, the
secrecy preservation is co-NP-complete for a bounded number of sessions~\cite{AL00,RT01},
and decidable for an unbounded number of
sessions under some additional restrictions~\cite{rta03,durgin99undecidability,lowe98towards,ramanujam05jcs}.
Many tools  have also been developed
to automatically verify cryptographic protocols,
like~\cite{avispa2005,Blanchet_CSFW01_efficient_verifier,MS01,cremers08cav}.

\paragraph{Generalizing the constraint system approach} 
In this paper, we re-investigate and extend the NP-complete decision
procedure for a bounded number of sessions~\cite{RT01}. In this
setting (i.e. finite number of sessions), \dedsyss{} have
become the standard model for verifying security properties, with a
special focus on secrecy. Starting with Millen and Shmatikov's
paper~\cite{MS01} many results
(e.g.~\cite{CS03,BaudetCCS05,BCD-stacs2007}) have been obtained and
several tools (e.g.~\cite{CorinE02}) have been developed within this
framework.  Our first contribution is to provide a generic approach
derived from~\cite{CS03} to decide general security properties. We
show that any \dedsys{} can be transformed in (possibly
several) much simpler \dedsyss{} that are called \emph{solved
forms}, preserving \emph{all} solutions of the original system, and not
only its satisfiability. In other words, the \dedsys{} represents
in a symbolic way all the possible sequences of messages that are
produced, following the protocol rules, whatever are the intruder's actions.
This set of symbolic traces is infinite in general. Solved forms
are a simple (and finite) representation of such traces and we show that it is
suitable for the verification of many security properties. 
We also consider sorted terms, symmetric and asymmetric encryption, pairing and
signatures, but we do not consider algebraic properties like Abelian
groups or exclusive or.  In addition, we prove termination in
\emph{polynomial time} of the (non-deterministic) \dedcons{} simplification.
Compared to~\cite{RT01}, our procedure preserves all solutions. Hence,
we can represent for instance, all attacks on the secrecy and not
only decide if there exists one. Moreover,
presenting the decision procedure using a
small set of simplification rules yields more flexibility
for further extensions and modifications.

The main originality is that the method is applicable to any security
property that can be expressed as a formula on the protocol trace
and the agent memories.  For example, our decision procedure
(published in the LPAR'06 proceedings~\cite{CortierLPAR06}) has been
used in~\cite{CKKW-fsttcs2006} for proving that a new notion of
secrecy in presence of hashes is decidable (and co-NP-complete) for a
bounded number of sessions. It has also been used in \cite{cortier07fsttcs}
in the proof of modularity results for security of protocols.
To illustrate the large applicability of
our decision procedure, we show in this paper how it can be used for
proving co-NP-completeness of three kinds of security properties: the
existence of key cycles, authentication-like properties, and secrecy of
protocols with timestamps.

For authentication properties, we introduce a small logic that allows
to specify authentication and some similar security properties.  Using
our solved forms, we show that any property that can be
expressed within this logic can be decided.  The logic is smaller than
NPATRL~\cite{SyversonM96} or
-LTL~\cite{corin-psltl,Corin-thesis}, but we believe
that decidability holds for a larger logic, closer to the two
above ones. However, the goal of this work is not to introduce a new logic,
but rather to highlight the proof method. Note also that the absence
of key cycles cannot be expressed in any of the three mentioned logics
because it is not only a trace property but also a property of the
message structure (see below).


For timestamps, we actually retrieve a significant fragment of
the decidable class identified by Bozga \textit{et al}~\cite{BEL04concur}.
We believe that our result can lead more easily to an implementation, since
we only need to adapt the procedure implemented in
\avispa~\cite{avispa2005}, while Bozga \textit{et al} have designed a
completely new decision procedure, which \textit{de facto} has not been implemented.


\paragraph{Application to key cycles} 
Our second main contribution is to use this approach to provide an
NP-complete decision procedure for detecting the generation of key
cycles during the execution of a protocol, in the presence of an
intruder, for a bounded number of sessions. To the best of our
knowledge, this problem has not been addressed before. The key cycle
problem is a problem that arises from the cryptographic community.
Indeed, two distinct approaches for the rigorous design and analysis
of cryptographic protocols have been pursued in the literature: the
so-called Dolev-Yao, symbolic, or formal approach on the one hand and
the cryptographic, computational, or concrete approach on the other
hand. In the symbolic approach, messages are modeled as formal terms
that the adversary can manipulate using a fixed set of operations. In
the cryptographic approach, messages are bit strings and the adversary
is an arbitrary probabilistic polynomial-time Turing machine. While
results in this model yield strong security guarantees, the proofs are
often quite involved and only rarely suitable for automation (see,
e.g.,
\cite{Goldwasser_Micali_JCSS84_probabilistic_encryption,BellareRogaway-CRYPTO-1993}).

Starting with the seminal work of Abadi and Rogaway
\cite{ARCryptology02}, recent results investigate the possibility of
bridging the gap between the two approaches.  The goal is to obtain
the best of both worlds: simple, automated security proofs that entail
strong security guarantees.  The approach usually consists in proving
that the Dolev-Yao abstraction of cryptographic primitives 
 is correct as soon as strong enough primitives are used in the
implementation.  For example, in the case of asymmetric encryption, it
has been shown~\cite{Micciancio_Warinschi_TCC04_soundness_of_formal_encryption}
that the perfect encryption assumption is a sound abstraction for
IND-CCA2, which corresponds to a well-established security level.  The
perfect encryption assumption intuitively states that encryption is a
black-box that can be opened only when one has the inverse
key. Otherwise, no information can be learned from a cipher-text about
the underlying plain-text.


However, it is not always sufficient to find the right cryptographic
hypotheses. Formal models may need to be amended in order to be
correct abstractions of the cryptographic models. A  widely used requirement is to control how keys can
encrypt other keys.  In a passive setting, soundness
results~\cite{ARCryptology02,MW04} require that no \emph{key cycles}
can be generated during the execution of a protocol. Key cycles are
messages like  or  where a key
encrypts itself or more generally when the encryption relation between
keys contains a cycle. Such key cycles have to be disallowed simply
because usual security definitions for encryption schemes do not
yield any guarantees otherwise.  In the active
setting, the typical hypotheses are even stronger.  For instance,
in~\cite{Backes_Pfitzmann_CSFW04_symmetric_encryption,cryptoeprint:2005:020}
the authors require that a key  never encrypts a key generated
before  or, more generally, that it is known in advance which key
encrypts which one. More precisely, the encryption relation has to be
compatible with the order in which keys are generated, or more
generally, it has to be compatible with an {a priori} given
\emph{ordering on keys}.

\paragraph{Related work on key cycles} 
Some authors circumvent the problem of key cycles by providing new
security definitions for encryption, \emph{Key Dependent Messages} security, or
KDM in short, that allow key
cycles~\cite{AdaoBanaHerzogScedrov-ESORICS05,backes07key}. However,
the standard security notions do not imply these new definitions, and
ad-hoc encryption schemes have to be constructed. 
Most of these constructions use the random oracle model, which
is provably non implementable. Though there was some recent
progress  \cite{hofheinz08towards} towards constructing a KDM-secure
encryption scheme in the standard model,
none of the usual, implemented encryption schemes has
been proved to satisfy KDM-security.

In a passive setting, Laud~\cite{Laud-NORDSEC02} proposed a
modification of the Dolev-Yao model such that the new model is a sound
abstraction even in the presence of key cycles. In his model the
intruder's power is strengthened by adding new deduction
rules. With the new rules, from a message containing a key cycle, the
intruder can infer all  keys  involved in the cycle as well as
 the messages encrypted by
these keys. Subsequently, Janvier~\cite{Janvier-these} proved that the
intruder deduction problem remains polynomial for the modified
deduction system. It was also suggested that this approach can be
extended to active intruders and incorporated in existing tools,
though, to the best of our knowledge, this has not been completed yet.  
Note that the
definition of key cycles used in~\cite{Janvier-these} is more
permissive than in~\cite{ARCryptology02} (which is unnecessarily
restrictive) and it corresponds to the approach of
Laud~\cite{Laud-NORDSEC02}.




\paragraph{Deciding key cycles} 
In this paper, we provide an NP-complete decision procedure for
detecting the generation of key cycles during the execution of a
protocol, in the presence of an active intruder, for a bounded number
of sessions.  Our procedure works for all the above mentioned
definitions of key cycles:  strict key cycles (\textit{\`a
la} Abadi, Rogaway),  non-strict (\textit{\`a la} Laud) key cycles,
key orderings (\textit{\`a la} Backes).  We therefore provide a
necessary component for automated tools used in proving strong,
cryptographic security properties, using existing soundness results.
Since our approach is an extension of the transformation rules derived
from the result of~\cite{RT01}, we believe that our algorithm can be
easily implemented since it can be adapted from the associated
procedure, already implemented in \avispa~\cite{avispa2005} for
deciding secrecy and authentication properties.



\paragraph{Outline of the paper} 
The messages and the intruder capabilities are modeled in
Section~\ref{sec:syntax}. In Section~\ref{sec:systems}, we define
\dedsyss{} and show how they can be used to express protocol
executions. In Section~\ref{sec:property}, we define security
properties and their satisfaction. In
Section~\ref{sec:approach}, we show that the satisfaction
of any (in)security property can be non-deterministically, polynomially
reduced to the satisfiability of the same problem, this time on
simpler constraint systems.  The simplification rules derived
from~\cite{CS03} are provided in Section~\ref{sec:rules}. They are
actually not sufficient to ensure termination in polynomial time. Thus
we introduce in Section~\ref{sec:poly} a refined decision procedure,
which is correct, complete, and terminating in polynomial time. 
We show in Section~\ref{sec:cycles} how this approach can be used to
obtain our main result of NP-completeness for the decision 
of the  key cycles generation.  In Section~\ref{sec:auth}, we introduce a small logic to
express authentication-like properties and we show how our technique
can be used to decide any formula of this logic.  In
Section~\ref{sec:timestamps}, we show how it can be used to derive
NP-completeness for protocols with timestamps. Some concluding remarks
about further work can be found in Section~\ref{sec:conclusion}.





\section{Messages and intruder capabilities}\label{sec:syntax}
\subsection{Syntax}


Cryptographic primitives are represented by function symbols. More specifically, we consider a
\emph{signature}  consisting
in  a set of \emph{sorts} 
and a set of \emph{function symbols} .
Each function symbol is associated with an \emph{arity}:  is a mapping
from  to , which we write 
.
The four first function symbols in  are binary: for each of
them  there are  such that
. The  last symbol is unary:
there are  such that .

 The symbol  represents the pairing function. The
terms  and   represent respectively the message  encrypted with the symmetric
(resp. asymmetric) key . The term  represents the message  signed by the key . The
term  represents the private key of the agent . For simplicity,
we confuse the agents names with their public key. (Or conversely, we claim
that agents identities are defined by their public keys).

  is a set of \emph{names} and  is
a set of \emph{variables}. Each name and each variable is associated with 
a sort. We assume that there are infinitely many names and infinitely
many variables of each sort.


The set of
\emph{terms of sort } is defined inductively by


We assume a special sort  that
subsumes all the other sorts: any term is of sort .

Sorts are mostly left unspecified in this paper. They can be used in
applications to express that certain operators can be applied only
to some restricted terms.
For example, we use sorts explicitly to express that messages are encrypted by atomic keys (only in Section~\ref{sec:cycles}),
and to represent timestamps (only in Section~\ref{sec:timestamps}).


As usual, we write  for the set of variables occurring in . For a  set  of terms,  denotes the union of the variables occurring in the terms of .
A term  is \emph{ground} or \emph{closed} if and only if .
A \emph{position} or an \emph{occurrence} in a term  is a sequence of positive integers corresponding
to paths starting from the root in the tree-representation of .
For a term  and a position  in this term,  denotes the  subterm of  at
position .
We write  and  for the set of subterms of a term ,
and of a set of terms , respectively.  The \emph{size} of a term
, denoted , is defined inductively as usual:  if  is
a variable or a name and  if
 for .  If~ is a set of terms
then~ denotes the sum of the sizes of its elements. The
cardinality of a set~ is denoted by~. By abuse of
notation, we sometimes denote by  the set .


Substitutions are written  with . We only consider \emph{well-sorted} substitutions, 
for which  and  have the same sort.  is \emph{closed} if and only if every  is
closed.
The application of a substitution  to a term  is written  or .
A {most general unifier} of two terms  and  is denoted by .





\subsection{Intruder capabilities}
The ability of the intruder is modeled by the deduction rules
displayed in Figure~\ref{fig:deduction} and corresponds to the usual
Dolev-Yao rules. 

Pairing, signing, symmetric and asymmetric encryption are the \emph{composition}
rules. The other rules are \emph{decomposition rules}.
Intuitively, these deduction rules say that an intruder can compose
messages by pairing, encrypting, and signing messages provided she has
the corresponding keys and conversely, she can decompose messages by
projecting or decrypting provided she holds the decryption keys. For
signatures, the intruder is also able to \emph{verify} whether a
signature  and a message  match (provided she has the
verification key), but this does not give rise to any new message: 
 this capability needs not to be represented in the deduction system.
We also consider an optional rule

that expresses the ability to retrieve the whole message from
its signature. This property may or may not hold depending on the
signature scheme, and that is why this rule is optional. Note that
this rule is necessary for
obtaining soundness properties w.r.t.~cryptographic digital signatures. Our
results will hold in both cases,
whether or not this rule is considered in the deduction relation.


\begin{figure}[t]

\caption{Intruder deduction system.}
\label{fig:deduction}
\end{figure}

A \emph{proof tree} (sometimes simply called a proof) is a tree whose
labels are sequents  where  is a finite set of terms
and  is a term. A proof tree is inductively
defined as follows:
\begin{itemize}
\item if  is a term and , then  is a proof tree
whose conclusion is , using the axiom;
\item if  are proof trees, whose respective conclusions
are  respectively and

is a rule  of the Figure~\ref{fig:deduction} such
that, for some (well-sorted) substitution , 
, then   
is a proof tree using , whose conclusion is .
\end{itemize}
We will call \emph{subproof} a subtree of a proof tree. An \emph{strict subproof}
(resp. \emph{immediate subproof}) of  is a subproof of  distinct
from  (resp. a maximal strict subproof of ). 


A term  is \emph{deducible} from a set of terms , which we sometimes
write  by abuse of notation, if there exists a proof tree
whose conclusion is .

\begin{example}
The term  is deducible from the set ,
as the following proof tree shows:

\end{example}

\section{\Dedsyss{} and security properties}
Deducibility constraint systems
are quite common (see e.g.~\cite{MS01,CS03}) in modeling security protocols. 
 We recall
here their definition and show how they can be used to specify general security properties. Then we prove that
any \dedsys{} can be transformed into  simpler ones, called \emph{solved}. Such simplified constraints are then used to decide the security
properties.

\subsection{\Dedsyss{}}\label{sec:systems}

In the usual attacker's model, the intruder controls the network. In particular
she can schedule the messages. Once such a scheduling is fixed, she can
still replace the messages with fake ones, which are nevertheless accepted
by the honest participants. More precisely, some pieces of messages
cannot be analyzed by the participants, hence can be replaced by any
other piece, provided that the attacker can construct the overall message. 
This can be used to mount attacks. 

In the formal model, pieces that cannot be analyzed are replaced with variables.
Any substitution of these variables will be accepted, provided that the
attacker can deduce (using the deduction system of Figure~\ref{fig:deduction})
the corresponding instance. The main problem then is to decide whether
there is such a substitution, yielding a violation of the security property.

Let us give a detailed example recalling how possible execution traces are
formalized.

\begin{example}\label{ex:ns}
Consider the famous Needham-Schroeder asymmetric key
authentication protocol~\cite{NS78} designed for mutual authentication:

The agent  sends to  his name and a fresh nonce (a randomly generated value) encrypted with the public
key of . The agent  answers by copying 's nonce and adds a fresh nonce , encrypted by 's
public key. The agent  acknowledges by forwarding 's nonce encrypted by 's public key. 

Formally, this protocol can be described using two roles  and .
The role  has two parameters:  (initiator and responder), and
is (informally) specified as follows:

where  is a variable:  cannot check that this piece of the message is
a nonce generated by . Hence it can be replaced by any term (or any term
of a given sort, depending on what we want to model). 

Similarly, the role of  takes the two parameters , and is specified as:







Without loss of generality, we may assume that  actions are
performed as soon as the corresponding  action is completed:
this is the best scheduling strategy for the attacker, who will get more
information for further computing fake messages. For this reason, we only need
to consider the possible scheduling of  events.


Let  be honest participants and  be a corrupted one.
Consider one session  and one session .
There are three message deliveries to schedule:  and  has to
occur after . Assume the chosen scheduling is .
In this scenario, the possible sequences of message  delivery are
instances of , ,
.  The variables  can be replaced by any term, provided that
the attacker can build the corresponding instances from her knowledge at
the appropriate control point.


The initial intruder knowledge can be set to
, including the private
key of the corrupted agent.

For the first message delivery, the attacker has to be able to build
the first message instance from this initial knowledge and the message
sent at step :


This notation will be formally defined later on. Informally, this is
a formula, which is satisfied by a substitution  on  if
 is deducible from , expressing
the ability of the intruder to construct .

Then, the agent  replies sending the corresponding instance 
, which increases the attacker's knowledge,
hence enabling its use for building the next message; we get the second
\dedcons{}:

Similarly, we construct a third \dedcons{} for the last message delivery:




\end{example}

\begin{definition}\label{def:constraint_sys}
A \emph{\dedsys{}}  is a finite set of expressions
,\linebreak called \emph{\dedconss{}}, where  is a non empty set of terms, called the \emph{left-hand
side} of the \dedcons{} and
 is a term, called the \emph{right-hand side} of the \dedcons{}, such that:
\begin{enumerate}
\item\label{def-item:cs1} the left-hand sides of all \dedconss{} are totally ordered by inclusion;
\item\label{def-item:cs2} if  for some  then  exists and .
\end{enumerate}
\end{definition}

Informally, the first condition states that the intruder knowledge is
always increasing. The second condition expresses that variables abstract
pieces of \emph{received} messages: they have to occur first on the right
side of a constraint , before occurring in some left side.  
Note that, due to point ,  exists if and only if the set
 is not empty. 
The linear ordering on left hand sides also implies the uniqueness of the
minimum. Hence  can be restated equivalently as:

In what follows, we may use this formulation instead.





The \emph{left-hand side} of a \dedsys{} , denoted by ,
is the maximal left-hand side of the \dedconss{} of .
The \emph{right-hand side} of a \dedsys{}
, denoted by , is the set of right-hand sides of its
\dedconss{}.  denotes the set of variables occurring in
.  denotes the unsatisfiable system. The \emph{size} of a
constraint system is defined as .


A \dedsys{}  is also written as a conjunction of \dedconss{}  with , for all  with . The second condition in

Definition~\ref{def:constraint_sys} then implies that if  then  such that 
and .




\begin{definition}
A \emph{solution}  of a \dedsys{}  is a (well-sorted) ground substitution whose domain is  and such that, for every , .
\end{definition}

\begin{example}
Coming back to Example~\ref{ex:ns}, the substitution 
  is a solution of the \dedsys{} since

\end{example}

\subsection{Security properties}\label{sec:property}

Deducibility constraint systems
represent in a symbolic and compact way a
possibly infinite set of traces (behaviors), which depend on the 
attacker's actions.
Security properties are formulas, that are interpreted over these 
traces. 



\begin{definition}
Given a set of predicate symbols together with their interpretation over
the set of ground terms,
a \emph{(in)security property} is a first-order formula  built on these predicate
symbols. 
A \emph{solution} of  is a ground substitution 
of  such that  is true in the given interpretation.
(We also write ).


If  is a \dedsys{} and  is a (in)security property,
possibly sharing free variables with ,
a closed substitution  from  is an \emph{attack
for  and  }, if is a solution of both  and . 


\end{definition}



\begin{example}\label{ex:classic}
If the security property is simply  (which is always satisfied)
and the only sort is  then we find the usual
\dedsys{} satisfaction problem, whose satisfiability
 is known to be NP-complete~\cite{RT03TCS}.
\end{example}


\begin{example}\label{ex:secrecy}
Secrecy can be easily expressed by requiring that the secret data is not
deducible from the messages sent on the network.
We consider again the \dedsys{}  defined in
Example~\ref{ex:ns}.
The (in)security property then expresses that  is deducible:
 is the \dedcons{} . 
Note that we may view a constraint (system) as a first order formula.



Then the substitution 
is an attack for  and  
and corresponds to the attack found by
G.~Lowe~\cite{lowe96breaking}.
Note
that such a deduction-based property can be directly included in
the constraint system by adding a \dedcons{} .
\end{example}











\begin{example}\label{ex:auth}
Let us show here an example of authentication property.
Two agents  and  authenticate on some message  if whenever
 finishes a session \emph{believing} he has talked to  then 
has indeed finished a session with  and they share the same value
for . Note that the agents  and  have in general a different
view of the message , depending e.g. on which nonces they have generated
themselves and on which nonces they have received.
If  denotes the view of  from  and  the view of 
from , then the insecurity property states that there is a trace in which
these two messages are distinct. 


Back to Example~\ref{ex:ns}, consider another scenario with two instances
of the role :  and  and one instance of the role :
. The attacker schedules the communications as in Example~\ref{ex:ns}: in particular the expected message delivery in  is
not scheduled (the message is not delivered). Then the \dedsys{}
 is identical to , except that  is replaced with
. The nonce~ received by  should correspond to the nonce 
sent by  for ; we consider , . 


The failure of authentication can be stated as the simple formula .
The substitution  defined in Example~\ref{ex:secrecy} is then
an attack,
since  accepts the nonce  instead of : . 
\end{example}


In Sections~\ref{sec:cycles},~\ref{sec:auth},~\ref{sec:timestamps} we provide with other examples 
corresponding to time constraints, more general authentication-like
properties, or to express that no key
cycles are allowed.

\section{Simplifying \dedsyss{}}\label{sec:approach}
Using simplification rules, solving \dedsyss{} can be reduced to solving simpler
constraint systems that we call solved.
One nice property of the transformation is that it works for any
security property.

\begin{definition}
A \dedsys{} is \emph{solved} if it is
  or each of its constraints are of

the form , where  is a variable.
\end{definition}
This definition corresponds to the notion of solved form in~\cite{CS03}.
Note that the empty \dedsys{} is solved. 




Solved \dedsyss{} with the single sort  are
particularly simple in the case of the  predicate since they
always have a solution, as noticed in~\cite{MS01}. Indeed, let 
be the smallest (w.r.t.~inclusion) left hand side of all constraints
of a \dedsys{}. From Definition~\ref{def:constraint_sys}, 
  is non empty and has no variables. Let . Then the substitution  defined by  for every
variable~ is a solution since  for any
constraint  in the solved system.







\subsection{Simplification rules}\label{sec:rules}


The \emph{simplification rules} we consider are defined in
Figure~\ref{fig:rules}. For instance, the rule   removes a redundant
constraint, i.e., when it is a logical consequence of smaller constraints.
The rule  guesses some identity (confusion) between two sent sub-messages.

All the rules are in fact indexed by a substitution:
when there is no index then the identity substitution is implicitly
assumed. We write  if there are
 with , ,
, and
. We write
 if  for some , or if  and  is the identity
substitution.

\begin{figure}[t]
0.1cm]
R_2 & C\,\wedge\,T\Vdash u & \simpl_\sigma
C\sigma\,\wedge\,T\sigma\Vdash u\sigma &
\mbox{if } \sigma=\mgu(t,u),\, t\in \st(T),\\
\vspace{-0.5mm}&&&\hspace{0.5cm} t\neq u,\ t, u \mbox{ not
variables}
\0.1cm]
R'_3 & C\,\wedge\,T\Vdash u & \simpl_\sigma
C\sigma\,\wedge\,T\sigma\Vdash u\sigma &
 \mbox{if } \sigma=\mgu(t_2,t_3),\, \enca(t_1,t_2),\priv(t_3)\in \st(T),\\
\vspace{-0.5mm}&&& \hspace{0.8cm}t_2\neq t_3,\ t_2\mbox{ or }t_3 \mbox{ (or both) is a variable}\0.1cm]
R_f & C\,\wedge\,T\Vdash f(u,v) &
\simpl\hspace{0.2cm}C\,\wedge\,T\Vdash u\,\wedge\,T\Vdash
v & \mbox{for } f\in\{\,\langle\,\rangle,\enc,\enca,\sign\}\\

\comment{ R_{\pair{}{}} & C\,\wedge\,T\Vdash \pair{u}{v} &
\simpl\hspace{0.2cm}C\,\wedge\,T\Vdash u\,\wedge\,T\Vdash
v
\\
R_{\enc} & C\,\wedge\,T\Vdash \penc{u}{v} & \simpl\hspace{0.2cm}C\,\wedge\,T\Vdash
u\,\wedge\,T\Vdash v
\\
R_{\enca} & C\,\wedge\,T\Vdash \enca(u,v) & \simpl\hspace{0.2cm}C\,\wedge\,T\Vdash
u\,\wedge\,T\Vdash v
\\
R_{\sign} & C\,\wedge\,T\Vdash \sign(u,v) & \simpl\hspace{0.2cm}C\,\wedge\,T\Vdash
u\,\wedge\,T\Vdash v
\\
}
\end{array}\left\{\begin{array}{rcl}
T_1 & \Vdash&  \langle\,\enca(x,\pub{a}),\, \enca(y,\pub{a})\,\rangle \\
T_2 & \Vdash& k_1
  \end{array}\right.

C\stackrel{R_{\langle\rangle}}{\simpl}
\left\{\begin{array}{@{}r@{\:}c@{\:}l}
T_1& \Vdash& \enca(x,\pub{a})\\
T_1& \Vdash& \enca(y,\pub{a})\\
T_2 & \Vdash& k_1
\end{array}\right.
\stackrel{R_{\enca}}{\simpl}
\left\{\begin{array}{@{}r@{\:}c@{\:}l}
T_1& \Vdash& x\\
T_1& \Vdash& a\\
T_1& \Vdash& \enca(y,\pub{a})\\
T_2 & \Vdash& k_1
\end{array}\right.
\stackrel{R_1}{\simpl}
\left\{\begin{array}{@{}r@{\:}c@{\:}l}
T_1& \Vdash& x\\
T_1& \Vdash& \enca(y,\pub{a})\\
T_2 & \Vdash& k_1
\end{array}\right.
\left\{\begin{array}{rcl}
T_1& \Vdash& x\\
T_1& \Vdash& \enca(y,\pub{a})\\
T_2 & \Vdash& k_1
\end{array}\right.
\stackrel{R_2}{\simpl}_{\sigma}
\left\{\begin{array}{rcl}
T_1& \Vdash& x\\
T_1& \Vdash& \enca(k_1,\pub{a})\\
T_2\sigma & \Vdash & k_1
\end{array}\right.
\stackrel{R_1}{\simpl}
\left\{\begin{array}{rcl}
T_1& \Vdash& x\\
T_2\sigma & \Vdash & k_1
\end{array}\right.
\stackrel{R_1}{\simpl}
\begin{array}{rcl}
T_1& \Vdash& x
\end{array}

\prooftree
S\vdash t_1 \quad \dots \quad S\vdash t_k
\justifies
S\vdash t
\endprooftree

A & \eqdef \{T''\sigma \mid (T''\Vdash u'') \in C', x\in\var(u'')\}  \\
  & = \{T\sigma \mid (T\Vdash u) \in C, x\in\var(u\sigma)\}  \\
  & \supseteq \{T\sigma \mid (T\Vdash u) \in C, \exists z\in\var(u), x\in\var(z\sigma)\}  \\
  & \supseteq \{T\sigma \mid (T\Vdash u) \in C, y'\in\var(u), x\in\var(y'\sigma)\}  \\
  & = \{T\sigma \mid (T\Vdash u) \in C, y'\in\var(u)\} \eqdef B_{y'}.
 \pi= \prooftree
\begin{array}{c}\pi_1\\ T_i\theta\vdash \penc{u}{w}\end{array}\;
\;\begin{array}{c}\pi_2\\ T_i\theta\vdash w \end{array}
\justifies T_i\theta\vdash u
\endprooftree

\prooftree
T_j\theta \vdash \penc{u\theta}{w}\;\;
\; T_j\theta\vdash w 
\justifies T_j\theta\vdash u\theta
\endprooftree

\prooftree
\begin{array}{rc}
& \enca(t_1,t_2)\theta\\
& \|\\
T_j\theta \vdash & \enca(u\theta,w)
\end{array}\;\;
\;\begin{array}{rc}
& \priv(w_2)\theta\\
& \| \\
T_j\theta \vdash & \priv(w)
\end{array}
\justifies T_j\theta \vdash u\theta
\endprooftree

\prooftree
T_j\theta\vdash \pair{u\theta}{v}
\justifies T_j\theta \vdash  u\theta
\endprooftree
 \prooftree
T_j\theta\vdash \sign(u\theta,v)
\justifies T_j\theta \vdash u\theta
\endprooftree

\prooftree
T_j\theta \vdash v_1\;\;
\;T_j\theta \vdash v_2
\justifies T_j\theta \vdash \penc{v_1}{v_2}
\endprooftree

T_0 \eqdef \{\enc(a,k_0)\} & \Vdash & \enc(x_0, k_0)\\
T_1 \eqdef T_0\cup\{\enc(\langle x_0,\langle x_0,a\rangle\rangle,k_1)\}
& \Vdash & \enc(x_1,k_1)\\
&\vdots &\\
T_n \eqdef T_{n-1}\cup\{\enc(\langle x_{n-1},\langle
x_{n-1},a\rangle\rangle,k_n)\}
& \Vdash & \enc(x_n,k_n)\\
T_{n+1} \eqdef T_n\cup\{a\} & \Vdash & x_n

C\simpl^{2n}_{\sigma}
\left\{\begin{array}{rcl}
T_0&\Vdash &\enc(x_0, k_0)\\
T_{n+1}\sigma & \Vdash & x_n\sigma\end{array}\right.

T\Vdash x_{n}\sigma\stackrel{R_{\langle\rangle}}{\simpl}
\left\{\begin{array}{rcl}
T&\Vdash& x_{n-1}\sigma\\
T&\Vdash &\langle x_{n-1}\sigma,a\rangle
       \end{array}\right.
\simpl^m
\left\{\begin{array}{rcl}
T&\Vdash& x_{0}\\
T&\Vdash& \langle x_{n-1}\sigma,a\rangle
       \end{array}\right.
\stackrel{R_{\langle\rangle}}{\simpl}\\
\left\{\begin{array}{rcl}
T&\Vdash &x_{0}\\
T&\Vdash &x_{n-1}\sigma\\
T&\Vdash &a
       \end{array}\right.
\stackrel{R_{1}}{\simpl}
\left\{\begin{array}{rcl}
T&\Vdash &x_{0}\\
T&\Vdash &x_{n-1}\sigma
       \end{array}\right.
\simpl^m T\Vdash x_{0}
C;D\ \msimpl_{\sigma}\ C'\setminus D; D\cup(C\setminus C')(C'\setminus D) \cap ((C\setminus C') \cup D)= ((C'\setminus D) \cap D )
\cup ((C'\setminus D) \cap (C\setminus C'))=\emptyset
\label{gtransf}
\{d\in C_{i+1} \mid d < c\} \models c.
\label{gtransf-inst}
  \bigwedge_{\substack{(T'\Vdash u')\in C_{i+1}\
We investigate the possible transformation rules.

  For the rules , . We have
   since either the
  multiset of variables of  is strictly smaller than the
  multiset of variables of , or else  and, in the
  latter case, either the multiset of variables of  is
  strictly smaller than the multiset of variables of  or else
  .  Moreover,  for all
  constraints  and substitutions~.
Indeed, if  is a solution of  then
   for any . It follows that
  , and thus  is a solution of .


  Hence, we have in particular that , which shows that (\ref{gtransf-inst})
  holds for this case.

  For the rule , it suffices to notice that  and
   for every .

For the rule , the constraint  is a consequence of the
(strictly smaller) constraints  for . 

Finally, the rule  only applies to unsatisfiable \dedconss{}.
\end{proof}






















The memorization strategy can be defined, as above,
 for any general constraint system transformation.
 The correctness of the memorization strategy
relies on the following invariant:

\begin{lemma}\label{lemma:redundancy}
For any  constraint system transformation , if , then .
\end{lemma}

\begin{proof}
We prove, by induction on the length of the derivation sequence the following
stronger  result: .

The base case is straightforward as  is empty. Next, assume that
. By definition, . If
, by definition of a constraint transformation rule,
. If , by induction hypothesis,
. Hence . But, again by definition of constraint transformations, any constraint in the second set is a consequence of the first set:
we get . 
\end{proof}

It follows that the memorization strategy is always correct when the
original constraint transformation is correct.

















































Now, the memorization strategy preserves the properties of our \dedsyss{}:
\begin{lemma}\label{lemma:preserves_origination}
If  is a \dedsys{} and
 then  is a \dedsys{}.
\end{lemma}
\begin{proof}
Let , with  be the sequence of
\dedsyss{} obtained by applying
successively the simplification rules, where ,
, , and
 (and thus , and ).
We know that  is a \dedsys{}, by Lemma~\ref{lemma_c2c}. 

First, the left members of  are linearly ordered by inclusion, as
they are a subset of the left members of . 

We consider now the other property of \dedsyss{}.
We let  be the ordering on constraints defined before. 
We show below, by induction on  that, for every ,
for every  such that ,
there is a  such that 
and . 

Note that this property implies that  is a \dedsys{}: For every
variable , there is  such that
, as  is a \dedsys{}.  If
 then we're done, otherwise , and hence, by the stated property, there is  such that . This shows that
 is a \dedsys{}.

The property holds trivially for . For the induction step,
let   and   be such that .
We investigate three cases:
\begin{itemize}
\item if  is obtained by one of the rules , then ,
and .
We assume w.l.o.g.~that  is a minimal constraint in  such
that . 

There is  such that  and :
if , then  and
by induction hypothesis, there is a  such that 
 and .

Let . By induction
hypothesis  is a constraint system, and hence, for every , there is a (minimal) constraint  such that
. Since ,
.  Let  be a minimal element in
. 
Suppose that .  Since  and
, it follows that , and hence
there is  such that . It
follows that  and , which contradicts the
minimality of . Hence .
Also . Furthermore, at least one of the
inequalities is strict: if  the last inequality is
strict, otherwise  hence
.  It follows that
 by minimality of
.













\item if  is obtained by an  rule. 
We may assume w.l.o.g.~that  is a minimal constraint in  such that . 

Either ,
in which case, by induction hypothesis, there is  such
that  and . 
If , there
is nothing to prove. Otherwise,  and, for every ,
. 
Moreover, there is an index  such that
 and, by minimality of , , hence completing this case.

Or else , in which case  and . As above, we conclude that for some
,  and .

\item if  is obtained by the rule , removing a constraint , then  and, by Lemma~\ref{lemma_c2c} for any variable  there is a strictly smaller constraint  such that
. Then we simply apply the induction hypothesis.
\end{itemize}
\end{proof}

















\begin{theorem}\label{theo:general_NP}
Let  be a \dedsys{},  a substitution and   a security property. \begin{enumerate}
\item(Correctness)
If  for some \dedsys{}

and some substitution , if  is an attack  for  and ,
then  is an attack for  and .\item(Completeness) If  is an attack for   and ,
then there exist a \dedsys{}  in solved
  form, a set of \dedconss{} 
  and  substitutions  such that , , and  is an
attack for   and .
\item(Termination) If  for some
\dedsys{}

and some substitution , then  is polynomially bounded in
the size of .
\end{enumerate}
\end{theorem}

\begin{proof}
For correctness, we rely on Lemmas~\ref{lemma_correct},
and~\ref{lemma:redundancy}: by Lemma~\ref{lemma:redundancy}, any solution   of  
is also a solution  and, by Lemma~\ref{lemma_correct} (and induction),
 is a solution of . 

For completeness, 
from Lemma~\ref{lemma_complet}, we know that
if  is an unsolved \dedsys{} and  is an attack
for  and , then there is a \dedsys{} , a substitution ,
and an attack  for  and  such that  and .
Then  is an attack also for  and
, for any set of constraints . By
Lemma~\ref{lemma:preserves_origination}, we know that when 
represents already visited constraints, then 
is a \dedsys{}. We can thus conclude by induction on the derivation
length , taking , ,  for all , and .





Concerning termination, we assume a DAG representation of
the terms and constraints, in such a way that the size of the constraint
is proportional to the number of the distinct subterms occurring in it.
Next, observe that . Hence, when unifying two subterms of , with
 ,
 since, for every variable ,  is a subterm of . It follows that, for any constraint system
 such that , . 

Next, observe that the number of distinct left hand sides of the constraints
 is never increasing: .
Furthermore, as long as we only apply the rules , starting from ,
 the 
left hand sides of the \dedsyss{} are fixed: there are at most
 of them. 
Now, since, thanks to memorization, we cannot get twice the same
constraint, the number of consecutive  steps is bounded by


It follows that the length of a derivation sequence is bounded
by   (for  steps)
plus  (for  steps) plus  (for a possible
 step).
\end{proof}

Theorem~\ref{theo:general_NP} extends the result of~\cite{RT01} to
sorted messages and general security properties.
Handling arbitrary security properties is possible as soon as we
do not forget any solution of the \dedsyss{} (as we do). If we only
preserve the existence of a solution of the constraint (as in \cite{RT01}),
it might be the case that the solution of  that we kept is not a solution
of the property , while there are solutions of both  and ,
that were lost in the satisfiability decision of . 
In addition, compared to~\cite{RT01}, presenting the decision
procedure using a small set of simplification rules makes it more
easily amendable to further extensions and modifications.
For example, Theorem~\ref{theo:general_NP} has been used in~\cite{CKKW-fsttcs2006} for
proving that a new notion of secrecy in presence of hashes is
decidable (and co-NP-complete) for a bounded number of sessions.

Note that termination in polynomial time also requires the use of a
DAG (Directed Acyclic Graph) representation for terms.















The following corollary
is easily obtained from the previous theorem by observing that we
can guess the simplification rules which lead to a solved form.

\begin{corollary}\label{corol:general}
Any property  that can be decided
in polynomial time on solved \dedsyss{} can be decided in non-deterministic polynomial
time on arbitrary \dedsyss{}.
\end{corollary}


























































































\subsection{An alternative approach to polynomial-time termination}
\label{section:strategy}


Inspecting the completeness proof, there is still some room for choosing a
strategy, while keeping completeness (correctness is independent
of the order of the rules application). 
To obtain even more flexibility, we slightly relax the condition on
the application of the rule  on a constraint : we
require unifying a subterm  and a subterm 
(instead of unifying  with ) where, as before, , ,
 non-variables.  Remark that this change preserves the
completeness of the procedure.

Let us group the rules  and call them \emph{substitution
  rules} . We write  if the substitution is obtained by
unifying  and .  There are some basic observations:
\begin{enumerate}
\item \label{obs1} 
If , then 
. Hence we may always move
forward the substitution rules.
\item \label{obs2} 
If  and , then
 and
,
hence any two consecutive applications of  on different constraints
can be performed in any order. 
\item \label{obs3} 
The rules  can be applied
at any time when they are enabled; we may apply them eagerly or postpone
them until no other rule can be applied.
\item \label{obs4} 
If , then, for some
, 
 Hence any two consecutive
substitution rules can be performed in any order. 
\item \label{obs5} 
If , and ,
 then .
\end{enumerate}

This provides with several complete strategies. For instance the
following strategy is complete:
\begin{itemize}
\item apply eagerly  and postpone  as much as possible
\item apply the substitution rules eagerly (as soon as they are enabled).
This implies that all substitution rules are applied at once, since the
rules  cannot enable a substitution.
\item when  and substitutions rules are not enabled, apply
 to the constraint, whose right hand side is maximal (in size).
\end{itemize}
Such a strategy will also yield polynomial length derivations, since
we cannot get twice the same constraint: in any derivation sequence
,
if  (we say then that 
has been eliminated at this step), then, for any , .
Indeed, for the substitution rules,  is eliminated only  when 
and , in which case for any , .
And, if   is eliminated by an  rule, then
 . If, for some , the
constraint  was in  and not in  , 
 then we would have .
Thus the maximum of the sizes of the right hand sides terms would have increased, which is not possible according to our strategy.

Then the complexity analysis of
the proof of Theorem~\ref{theo:general_NP} can be applied here.
\\

The above observations can also be used to bound the non-determinism
(which is useful in practice): 
for instance from (\ref{obs1}) and (\ref{obs4}), we see that
substitution rules can be applied ``don't care'': if we use
a substitution rule, we do not need to consider other alternatives.  
More precisely, if  is a substitution rule that is applicable to
, let  be the set of substitution rules , which
are applicable to  and such that there is no  other than the identity
such that
. 
Then







Similarly, from (\ref{obs5}), a right-hand side member
that is not unifiable with a non-variable subterm of the corresponding
left hand side, can be ``don't care'' decomposed:

if  is not unifiable with any non-variable subterm of .
































\section{Decidability of encryption cycles}\label{sec:cycles}
Using the general approach presented in the
previous section, verifying particular properties like the existence
of key cycles or the conformation to an \emph{a priori} given ordering
relation on keys can be reduced to deciding these properties on solved
\dedsyss{}. We deduce a new decidability result, useful in
models designed for proving cryptographic properties. 

To show that formal models (like the one presented in this article)
are sound with respect to cryptographic ones, the authors usually
assume that no key cycle can be produced during the execution of a
protocol or, even stronger, assume that the ``encrypts'' relation on keys
follows an \emph{a priori} given ordering.

For simplicity, and since there are very few papers constraining the key
relations in an asymmetric setting, in this section we restrict our attention to key cycles and key orders
on symmetric keys. Moreover, we consider atomic keys for symmetric encryption since
there exists no general definition (with a cryptographic interpretation) of key cycles in the case of arbitrary composed keys and soundness results are usually obtained for atomic keys.



More precisely, we assume a sort
 and we assume that the sort of  is
. All the other symbols are
of sort . Hence only names and variables can be of
sort . In this section we call \emph{key} a variable or a name of sort . Finally, for any list of terms ,  is the set of terms
that are members of the list.


















In this section, we consider (in)security properties of the form
 where  is a predicate symbol and  is a list of terms. Informally,
 will be a solution of  if  contains a key cycle.
The precise interpretation of  depends on the notion of key-cycle:
this is what we investigate first in the following section.





\subsection{Key cycles}
Many definitions of key cycles are available in the literature. They
are stated in terms of an ``encryption'' relation between keys or
occurrences of keys.  An early definition proposed by Abadi and Rogaway~\cite{ARCryptology02},
identifies a key cycle with a cycle in the encryption relation, with
no conditions on the occurrences of the keys.
However, the definition induced by Laud's
approach~\cite{Laud-NORDSEC02} corresponds to searching for such
cycles only in the ``visible'' parts of a message. For example the
message  contains a key cycle using the former
definition but does not when using the latter one and assuming that
 is secret. It is generally admitted that the Abadi-Rogaway
definition is unnecessarily restrictive and hence we will say that the
corresponding key cycles are \emph{strict}. However, for completeness
reasons, we treat both cases.






There can still be other variants of the definition,
depending on whether  the relation `` encrypts '' is restricted or not to keys  that occur in
plain-text. For example,  may or may not contain a key cycle. As above, even if
occurrences of keys used for encrypting (as  in ) need not be considered as encrypted keys,
and hence can safely be ignored when defining key cycles, we consider both cases. Note that the
initial Abadi-Rogaway setting considers that  has a key cycle.


We write  if and only if  is a subterm of .
 is the least reflexive and transitive relation
satisfying: , , and, if ,
 then .
Intuitively,  if  is a subterm of  that either
occurs (at least once) in clear (i.e.~not encrypted) or occurs (at
least once) in a plain-text position.  A position  is a
\emph{plain-text position} in a term  if there exists an occurrence
 of an encryption in  such that .

\begin{definition}
Let  be a relation chosen in
. Let  be a set of terms and  be two keys. We say that
 \emph{encrypts}  \emph{in}  (denoted ) if there exist
 and a term  such that 
\end{definition}
For simplicity, we may write  instead of , if  is
clear from the context.  Also, if  is a message we denote by
 the relation .





Let  be a set of terms. We define .

\begin{definition}[(Strict key cycle)]\label{def:skc}
Let  be a set of keys. We say that a set of terms  contains a \emph{strict key
cycle} on  if there is a cycle in the restriction of the relation  on . Otherwise we say that
 is \emph{\sacyclic} on .

We define the predicate  as follows:
 if and only if
the set  contains a strict key cycle on .
\end{definition}




We give now the definition induced by Laud's approach~\cite{Laud-NORDSEC02}. He has showed in a passive
setting that if a protocol is secure when the intruder's power is given by a modified Dolev-Yao deduction
system , then the protocol is secure in the computational model, without requiring a ``no
key cycle'' condition. Rephrasing Laud's result in terms of the standard deduction system  gives rise
to the definition of key cycles below, as it has been proved in~\cite{Janvier-these}.

To state the following definition we need a more precise notion than the encrypts relation. We say that
an occurrence  of a key  \emph{is protected} by a key  in a term 
if  for some term  and some position , and the occurrence of  at  in
 is a plain-text
occurrence of  in , that is . We extend this definition in the intuitive way to sets of terms. This can be done for example
by indexing the terms in the set and adding this index as a prefix to the position in the term to
obtain the position in the set.




\begin{definition}[(Key cycle~\cite{Janvier-these})]\label{def:kc}Let  be a set of keys. We say that a set of terms  is \emph{acyclic} on  if there
exists a strict partial ordering
 on  such that for all , for all occurrences  of  in plain-text position in , there
is  such that  and  is protected by  in . Otherwise we say that  contains a \emph{key cycle} on .

We define the predicate  as follows: for any list of terms ,
 if and only if
the set  contains a key cycle on .
\end{definition}

We say that a term  contains a (strict) key cycle if the set  contains one.

\begin{example}
The messages  and
  
are acyclic, while the message
 has
a key cycle. The orderings  and  prove it
for  and  while for  such an ordering cannot be found since
 is deducible. However, all three messages have strict key
cycles.
\end{example}


\subsection{Key orderings}
In order to establish soundness of formal models in a symmetric
encryption setting, the requirements on the encrypts relation
can be even stronger, in particular in the case of an active
intruder. In~\cite{Backes_Pfitzmann_CSFW04_symmetric_encryption}
and~\cite{cryptoeprint:2005:020} the authors require that a key never
encrypts a younger key. More precisely, the encrypts relation has to
be compatible with the ordering in which the keys are generated. Hence we also want to check whether there
exist executions of the protocol for which the encrypts relation is incompatible with an \textit{a priori}
given order on keys.

\begin{definition}[(Key ordering)]\label{def:korder}
Let  be a strict partial ordering on a set of  keys . We say that a set of terms 
is \emph{compatible} with  on  if


Given a strict partial ordering  on a set of keys, we define the predicate  as follows:
 holds on a list of terms  if and only if
the set  is compatible with  on .
\end{definition}
For example,
in~\cite{Backes_Pfitzmann_CSFW04_symmetric_encryption,cryptoeprint:2005:020}
the authors choose  to be the order in which the keys are
generated:  if  has been generated before .
We denote by   the
negation of . Indeed, an attack in this context is an execution such that the
encrypts relation is incompatible with~. 




\subsection{Properties that are independent of the notion of key cycle}
We show how to decide the existence of key cycles or the conformation
to an ordering in polynomial time for solved \dedsyss{}.
Note that the set of messages on which our predicates are applied usually contains all messages sent on
the network and possibly some additional intruder knowledge.




We start with statements, that do not depend on which notion of key cycle
we choose.

\begin{lemma}\label{lem:protects_deduc2}
Let  be a set of terms,  be a term and  be 
a key such that  and~. Then for
any plain-text occurrence  of  in , there is a plain-text occurrence  in  such that,
if there is key  with , and
which protects  in , then  protects~~in~.
\end{lemma}
\begin{proof}
We reason by induction on the depth of the proof of :\begin{itemize}
 \item if the last rule is an axiom, then  . We may simply
choose .\item if the last rule is a decryption, 
then  and  for some .
Take the position  in . It is an occurrence of . Applying the induction
hypothesis we obtain an occurrence  of  in  such that, if there is a key
 with  and
which protects  in , then
 protects  in  . Since , it
follows that  and hence  protects  in .
\item if the last rule is a another rule, we  proceed in a similar
way as above.
\end{itemize}
\end{proof}

As a corollary we obtain the following proposition, which
 states that, in the passive case, a key cycle can be
deduced from a set  only if it already appears in .
\begin{proposition}\label{prop:prop_deduc}
Let  be a list of ground terms, and  a strict partial ordering on a set of keys. The
predicate   (respectively,  or ) holds on
 if and only if  contains a key cycle (respectively,  contains a strict key cycle, or
the encrypts relation on  is not compatible with~). 
\end{proposition}
\begin{proof}
The right to left direction is trivial since .

We will prove the left to right direction only for the key cycle property,
 the other two properties can be proved in a similar way. Assume that there is no strict partial ordering satisfying the conditions in
Definition~\ref{def:kc} for . In other words, for any strict partial ordering 
on  there is a key  and an occurrence  of  in  such
that for any key ,   protects  in  implies . Using the
previous lemma we can replace  by  in the previous sentence, thus
obtaining that there is a key cycle in .
\end{proof}








\comment{Let   be a solved constraint system,  be a {\simple} solution of  and  be a list of
messages
such that  and . Also let  be a set of
names of sort .  Let  be a partial ordering on . If there is  such that  is
deducible, that is  then the predicates  and
 hold. If all the keys in  are not deducible then  holds on
 if and only if
}


The next lemma will be used to show that  does not
depend on the 
solution  of a solved constraint .
\begin{lemma}\label{lem:similar_deduc}
Let  be a constraint of a solved constraint system ,
 a  solution of  and  a non-variable term. If  then there is a
non-variable term  with  such that  and .
\end{lemma}
\begin{proof}
We write  as , with  and .
Consider the index  of the constraint , that is such that ,  and . The lemma is proved by induction on  (considering the lexicographical ordering)
where  is the length of the proof of . Consider the last rule of the proof:
\begin{itemize}
 \item (axiom rule) . Then there is  such that . If  is a variable
then there is  such that  is a constraint of . We have . Then
by induction hypothesis there is a non-variable term  with  such that
 and . Hence  satisfies the conditions.

 \item (decomposition rule) Suppose the rule is the decryption rule. Then the premises of the rule are
 and  for some term . By induction hypothesis
there are non-variable terms  and  with  such that
, ,  and
. Then  with  and . If  is a variable then, as in
the previous case, we find an  satisfying the conditions. Suppose  is not a variable. We still need to
show that . If  is a variable then
 since . If  is not a variable then 
hence . In both cases it follows that . The projection rule case is
simpler and is treated similarly.

\item (composition rule) This case follows easily from the induction hypothesis applied on the premises.
\end{itemize}
\end{proof}



\begin{corollary}\label{cor:same_keys}
Let  be a constraint of a solved \dedsys{} , and ,  be two 
solutions of . Then for any key ,  if and only if .
\end{corollary}
\begin{proof}
Suppose that . From the previous lemma we obtain that there is a non-variable  with
 such that  and .
Since keys are atomic and  is a ground substitution it follows that . Hence
. So , since  is a  solution (and thus  for all ) and by using Lemma~\ref{lemma_deduc-cutelim}.
\end{proof}

\subsection{Decision results}

On solved \dedsyss{}, it is possible to decide in polynomial time,
whether an attacker can trigger a key cycle or not, whatever notion of
key cycle we consider: 

\begin{proposition}\label{lemma_deter_ext}
Let   be a solved \dedsys{},  be a list of messages such that
 and , and  a strict partial ordering on a
set of keys. Deciding whether there exists an attack for  and   can be done in , for any .
\end{proposition}





We devote the remaining of this section to the proof of the above proposition.

We know by Proposition~\ref{prop:prop_deduc} that it is sufficient to analyze the encrypts (or protects)
relation only on  (and not on every deducible term), where  is an arbitrary
 solution.

We can safely assume that there is exactly one \dedcons{} for each variable. 
Indeed, eliminating from  all constraints  
for which there is a constraint  in  with  
we obtain an equivalent \dedsys{}  :  is a solution of  iff it is a solution of .
Let  be the term obtained by pairing all terms of  (in some arbitrary ordering).
We write  as , with  and .
We construct the following substitution ,
and  is defined inductively as follows:
\begin{itemize}
\item[-]  and 
\item[-] .
\end{itemize}
The construction is correct by the definition of \dedsyss{}.
It is clear that  is a  solution of . We show next that it is sufficient to analyze this
particular solution. 




\subsubsection{Key cycles} 
We focus first on the property .






\begin{lemma}\label{lem:tau_sol_kc}
Let  be a solved \dedsys{},  a list of terms such that ,
, and assume  is interpreted as . Then
there is an attack for  and  if and only if  is an attack
for  and .
\end{lemma}
\begin{proof}
We have to prove that if there is no partial ordering satisfying the conditions in Definition~\ref{def:kc} for
the set  (according to Proposition~\ref{prop:prop_deduc}) then there is no partial ordering
satisfying the same conditions for . Suppose that there is a strict partial ordering  which
satisfies the conditions for . We prove that the same partial ordering does the job for
.


Let  where  is a new variable.  is a 
\dedsys{} since
.
We write  as , with  and .
We prove by induction on  that for all , for all plain-text occurrences  of  in  there is a key
 such that  and  protects  in . It is sufficient to prove this since for  we have .
Remark also that from Corollary~\ref{cor:same_keys} applied to  we obtain that
.

For  we have  hence the property is clearly satisfied for  since it is
satisfied for .

Let . Consider an occurrence  of a key  in a plain-text position of 
for some . Let  such that .

If  is a non-variable position in  then it is a position in .
And since  is a solution we have that there is a key  (hence )
such that  and  is protected by  in . The key  cannot occur  in some , with
, since otherwise  is deducible (indeed  since the keys are atomic and
). Hence  occurs in . Then  protects  in , and thus in  also.


If  is not a non-variable position in  then there is a variable  with  such that
the occurrence  in  is an occurrence of  in 
(formally  where  is some position of  in  and  is some occurrence of  in ).
Applying Lemma~\ref{lem:protects_deduc2} we obtain that there is an occurrence  of  in
 such that if there is a key  with  and
which protects  in  then  protects  in . The existence of the
key  is assured by the induction hypothesis on . Hence  protects  in  
and thus  in .
since otherwise there is  such that , which implies that
. Then  is a position in . Moreover  protects  in
.

If  is not a non-variable position in  then there is a variable  such that
\end{proof}





Hence we only need to check whether  is an attack for  and . Let 
. We build inductively the sets  and for all
,

where  denotes the plain-text positions of a term  in a set .
Observe that for all , . This can be proved easily by induction on . Moreover, since  is finite and  for all ,
then there is  such that  for all .

\begin{lemma}
There exists  such that  if and only if .
\end{lemma}
\begin{proof}
Consider first that there exists  such that . Then take the following strict partial ordering on
:  if and only if there is  such that  and . Consider a key
 and a plain-text occurrence  of  in . Then take  minimal such that
. By the definition of  there is  such that  protects  and .
Since  is minimal . Hence . Thus . 

Consider now that  is a solution. Suppose that . Let . Since  there is a plain-text occurrence 
of  such that for all  either  does not protect , or . But
since  is a solution, there is  such that  protects  and . It follows that
, and thus . Hence for an arbitrary  we have
found  such that . That is, we can build an infinite sequence
 with distinct elements from a finite set -- contradiction. So there exists 
such that .
\end{proof}

Hence to check whether , we only need to construct the sets  until
 and then to check whether . This algorithm is similar to a classical method for
finding a topological sorting of vertices (and for finding cycles) of directed graphs. 
It is also similar to
that given by Janvier~\cite{Janvier-these} for the intruder deduction problem considering the deduction
system of Laud~\cite{Laud-NORDSEC02}.

Regarding the complexity, there are at most  sets to be build and each set  can be constructed in
. If a DAG-representation of the terms is used then
. This gives a complexity of 
for the above algorithm.

\medskip

\subsubsection{Strict key cycles and key orderings.}
For the other two properties  and  we proceed in a similar manner. 















\begin{lemma}\label{lem:encrypts_deduc}
Let  be a constraint of a solved \dedsys{}  and  be a
 solution. Let  be terms such that

Then there exists a non-variable term  such that   for some 
and .
\end{lemma}
\begin{proof}
We write  as , with  and .
Consider the index  of the constraint , that is such that ,  and
. The lemma is proved by induction on  (lexicographical ordering)
where  is the length of the proof of .
Consider the last rule of the proof:
\begin{itemize}
\item (axiom rule)  for some . We can have that either there is  such
that , or  for some . In the first case
take , . In the second case, by the definition of \dedsyss{},
there exists  with . Since  and  (since ), we
deduce by induction hypothesis that there exists a non-variable term
 such that  for some , hence  and .
\item (decomposition rule) Let  be the premise of the rule. We have that  (with a
  proof of a strictly smaller length) and 
thus . By induction hypothesis, we deduce that there
exists a non-variable term  such that   for some  and .
\item (composition rule) All cases are similar to the previous one
  except if  and the rule is {\small
}.
But this case contradicts .
\end{itemize}
\end{proof}





The following simple lemma is also needed for the proof of Lemma~\ref{lem:tau_sol_encrypts}.
\begin{lemma}\label{lem:rho}
Let  be a constraint of a solved \dedsys{} ,  be a
solution, , and  a term such that .
If  then there is  such that .
\end{lemma}
\begin{proof}
We write  as , with  and .
Consider the index  of the constraint , that is such that ,  and . The lemma is proved by induction on  (considering the lexicographical ordering)
where  is the length of the proof of . Consider the last rule of the proof:
\begin{itemize}
 \item (axiom rule)  or  a public constant. If  is a public constant then  since . Thus there is  such that . If  then we're done. Otherwise there is a variable  such that . Also, there is  such that  is a constraint of . Then, by induction hypothesis, there is , hence in , such that .

 \item (composition or decomposition rule) By inspection of all the composition and decomposition rules we observe that there is always a premise  with  for some term . The conclusion follows then directly from the induction hypothesis.
\end{itemize}
\end{proof}


The
following lemma shows that it is sufficient to analyze  when checking the properties  and
.
\begin{lemma}\label{lem:tau_sol_encrypts}
Let  be a solved \dedsys{},  a list of terms such that  and
, and  a solution of . For any
, if  encrypts  in  then  encrypts
 in .
\end{lemma}
\begin{proof}
Remember that  (Corollary~\ref{cor:same_keys}).

Consider two keys  such that  encrypts  in .
Then there are terms  such that ,  and
. We can have that either (first case) there are  such that ,
 non-variable and , or (second case)  with
. In the second case, consider the constraint . We have
. Hence we can apply Lemma~\ref{lem:encrypts_deduc} for , 
and  to obtain that there exists a non-variable term  such that  for some 
and . Hence, in both cases, we obtained that there is a non-variable term
 (since ) such that . Thus there is 
such that . Indeed, otherwise  for some , hence . Since  is solved we have . But , contradicting .

We have . Since  and  is a name or a variable, we can have that
, or  for some .
If  then  encrypts  in , hence in  also.
If  then from the previous lemma  for some ,
and hence . Therefore in both
cases we have that  encrypts  in .
\end{proof}



We deduce that deciding whether there is an attack for   and ,
when  is interpreted as ,can be done simply by
deciding whether the restriction of the relation  to  is
cyclic.


Deciding whether there is an attack for  and  , when  is interpreted as  , can be done by deciding
whether the  restriction to  of the relation  has the following
property : there are  such that  and .


Checking the cyclicity of the relation  reduces to  checking the
cyclicity of the
corresponding directed graph, using a classic algorithm in . Then,
checking the property
 can be performed by analyzing all pairs  hence also in .

\smallskip





Verifying any of the three properties requires a preliminary step of computing
. Computing deducible subterms can be performed in linear
time, hence this computation step requires . . If ,
then . It follows that the complexity of deciding
whether there is an attack for  and  is , when  is
interpreted as  or .









\comment{ We can have the following possibilities in :
\begin{itemize}
\item[-]  encrypts . Then  is an arc in the graph .
\item[-]  encrypts .
\item[-]  encrypts  or  encrypts . Since , thus , it follows that
there is constraint  in . Hence . We can either that  is a deducible key, and in
this case  is not a part on an encryption cycle (at least
we are not interested in those encryption cycles), either 
is not a key, and in this case  cannot encrypt (by our
definition -- no compound keys) other terms.
\end{itemize}
}


\subsection{NP-completeness} Let  be a \dedsys{} and  a list of terms such that
 and .
The NP membership of deciding whether there is an attack for  and 
(for our 3 possible interpretations of ) follows immediately from Corollary~\ref{corol:general}
and Proposition~\ref{lemma_deter_ext}.





\comment{
Testing for key cycles or for conformance to an order of the encrypts
relation is done in Proposition~\ref{lemma_deter_ext} for keys that are not deducible from . If one
of the keys  in  is deducible, that is there is a {\simple} solution  of  such that
, then we can simply construct a key cycle .

We deduce by combining Theorem~\ref{theo:general} and
Proposition~\ref{lemma_deter_ext} that the problem of deciding
 on arbitrary \dedsyss{} is in NP.
}

NP-hardness is obtained by adapting the construction for NP-hardness provided
in~\cite{RT03TCS}. More precisely, we consider the reduction of the 3SAT problem to our problem. For any 3SAT Boolean formula
we construct a protocol such that the intruder can deduce a key cycle if and only if the formula is
satisfiable. The construction is the same as in~\cite{RT03TCS} (pages 15 and 16) except that, in the last
rule, the participant responds with the term , for some fresh key  (initially secret), instead
of . Then it is easy to see that the only way to produce a key cycle on a secret key is to play this
last rule which is equivalent, using~\cite{RT03TCS}, to the satisfiability of the corresponding 3SAT
formula.











\section{Authentication-like properties}\label{sec:auth}
We propose a simple decidable logic for security properties. This
logic enables in particular to specify authentication-like properties.




\subsection{A simple logic}
The logic enables terms comparisons and is closed under Boolean connectives.



\begin{definition}
The logic  is inductively defined by:

 is the set of variables occurring in its atomic formulas.
\end{definition}

 if  and  are identical terms.
.
This satisfaction relation is extended to any of the above formulas, 
interpreting the Boolean connectives as usual.








\begin{example}
Let us consider again the authentication property introduced in
Example~\ref{ex:auth}. There is an attack on authentication between
 and   if  and  do not agree on the nonce  sent by
 for , that is if 
at the end of the run of the protocol.
This can be expressed by the following formula

The substitution  (assigning  to ) is an
attack for  (defined in Example~\ref{ex:auth}) and  and demonstrates
a failure of authentication.
\end{example}

More sophisticated properties can be expressed using the logic
. For example, when two sessions of the same role are executed, one can
expressed that an agent has received \emph{exactly once} the right
nonce , with the following formula.

where  (resp. ) represents the nonce received by the agent in the
first (resp. second) session.

We can also express properties of the form: if two agents agree on
some term , they also agree on some term . This can be indeed
modeled by the formula

where  (resp. ) represents the view of  by the first
(resp. second) agent and
 (resp. ) represents the view of  by the first
(resp. second) agent. The formula  is the usual
notation for the formula .


\subsection{Decidability}




\begin{theorem}
Let  be a \dedsys{} and  be a formula of .
Deciding whether there is an attack for  and  can be performed in
non-deterministic polynomial time.
\end{theorem}
\begin{proof}



First, choosing non-deterministically  or  in any
subformula , we may, w.l.o.g.~only consider the
case where  is a conjunction ,
where . 






Let  be a ~(idempotent, which does not introduce new variables)
of .  
The \dedsys{}  has a joined solution with  if and only if
 and  have a common solution. As in the previous sections,
we choose a representation of expressions, such that applying a ~of
subterms of an expression  on  does not increase the size of the expression . 

We are now left to the case where we have to decide whether a
\dedsys{} has a solution together with a property of the form
.



Applying Theorem~\ref{theo:general},  there exists
a solution  of  and  
if and only if there exist a \dedsys{}  in solved form
  and  substitutions  such that ,  and  is an attack for  
and . 
Thus, we are now left to decide whether there exists a solution to
a solved constraint system  and a formula  of the form
.







If, for some ,  is identical to , then there is clearly no
solution. We claim that, otherwise, there is always a solution. This
is an independence of disequation lemma (as in \cite{colmerauer84} for instance),
and the proof is similar to other independence of disequations lemmas:


\begin{lemma}
Let  be a solved \dedsys{} and  be the formula 
such that  and, for every ,  is not identical to . Then  there is always a solution
 of  and .
\end{lemma}
This is proved by induction on the number of variables of .
In the base case, there is no variable and the result is trivial as  is
a tautology.

Let  be the smallest left-hand
side of .  must be a non empty set of ground terms. Note that there is
an infinite set of deducible terms from .


Let . For each , either  has no solution,
in which case  is always satisfied, or else let .  We choose  such that
 and . This is possible since  is finite and there are
infinitely many terms deducible from . Now, for every ,
 is not identical to  by
construction. Hence, we may apply the induction hypothesis to
 and conclude.
\end{proof}


\section{Timestamps}\label{sec:timestamps}
For modeling timestamps, we introduce a new sort  for time and we assume an infinite number of names of sort
, represented by rational numbers or integers. We assume that the only two sorts are  and
. Any value of
time should be known to an intruder, that is why we add to the
deduction system the rule {\small}
for any name  of sort . All the previous results
can be easily extended to such a deduction system since ground
deducibility remains decidable in polynomial time.




To express relations between timestamps, we use timed constraints. 
\begin{definition}
An \emph{integer timed constraint} or a
\emph{rational timed constraint}  is a conjunction of formulas of the form

where the  and  are rational numbers, , and the  are variables
of sort . A \emph{solution} of a rational (resp. integer) timed constraint  is a closed
substitution , where the  are rationals (resp.
integers), that satisfies the constraint.
\end{definition}




Such timed properties can be used for example to say that a
timestamp  must be fresher than a timestamp  () or that  must be at least 30 seconds fresher than
 ().


\begin{example}
We consider the Wide Mouthed Frog Protocol~\cite{CJ97}.

 sends to a server  a fresh key  intended for . If the timestamp  is fresh enough, the
server answers by forwarding the key to , adding its own timestamps.  simply checks whether this
timestamp is older than any other message he has received from . As explained in~\cite{CJ97}, this
protocol is flawed because an attacker can use the server to keep a session alive as long as he wants by
replaying the answers of the server.

This protocol can be modeled by the following \dedsys{}:
where  are variables of sort  and  are variables of sort . We add explicitly the
timestamps emitted by the agents on the right hand side of the
constraints (that is in the messages expected by the participants)
since the intruder can schedule the message transmission whenever he
wants. Note that on the right hand side of constraints we do have
terms, but by abuse of notation we have omitted the pairing function symbol.

Initially, the intruder simply knows the names of the agents and 's message at time~0. Then  answers
alternatively to requests from  and . Since the intruder controls the network, the messages can be
scheduled as slow (or fast) as the intruder needs it. The server  should not answer
if 's timestamp is too old (let's say older than 30 seconds) thus 's timestamp cannot be too much
delayed (no more than 30 seconds). This means that we should have . Similarly, we
should have  and . The last rule corresponds to 's
reception. In this scenario,  does not perform any check on the timestamp since it is the first message he
receives.

We say that there is an attack if there is a joined solution of the
\dedsys{} and  the previously mentioned time
constraints together with . This last constraint expresses that the 
timestamp received by  is too
large to come from .
Altogether, the time constraint becomes

Then the substitution corresponding to the attack is

\comment{}
\end{example}



\begin{proposition}\label{prop:timed}
There is an attack to a solved \dedsys{} and a time constraint  iff
 has a solution. 
\end{proposition}
\begin{proof}[sketch]
Let  be a solved \dedsys{},  and  a timed constraint. Let
 be the variables of sort  in  and  the variables of sort 
in . Clearly, any substitution  of the form  where  for some
 and  for  any constant of sort  is a solution of . Let  be the restriction of  to the timed variables
.

  is an attack for  and  if and only if  is a solution to . 
Thus there
exists an attack for  and   if and only if  is satisfiable. 
\end{proof}

\begin{corollary}
Deciding whether a \dedsys{}, together with a time constraint, has a solution
is NP-complete. 
\end{corollary}

\begin{proof}
The NP membership follows from the NP membership of time constraint satisfiability,  
Theorem~\ref{theo:general} and
Proposition~\ref{prop:timed}.

NP-hardness directly follows from the NP-hardness of \dedsys{} solving, considering
an empty timed constraint.
\end{proof}

\section{Conclusions}\label{sec:conclusion}

We have shown how, revisiting the approach of \cite{CS03,RT03TCS}, we
can preserve the set of solutions, instead of only deciding the satisfiability.
We also derived  NP-completeness results for some security properties:
key-cycles, authentication, time constraints. 

Since the constraint-based approach~\cite{CS03,RT03TCS} has
already been implemented in \avispa~\cite{avispa2005}, it is likely that
we can, with only slight efforts, 
adapt this implementation to the case of key cycles and timestamps.

More generally, we would like to take advantage of our result to derive
decision procedures for even more security properties. A typical example
would be the combinations of several properties. Also, we could investigate
non-trace properties such as anonymity or guessing attacks, for which
there are very few decision results (only \cite{BaudetCCS05}, whose procedure
is quite complex). 










Regarding key cycles, our approach is valid for a bounded number of
sessions only. Secrecy is undecidable in
general~\cite{durgin04undecidability} for an unbounded number of
sessions. Such an undecidability result could be easily adapted to the
problem of detecting key cycles.  Secrecy is decidable
for several classes of protocols~\cite{RS03,rta03,blanchetTag03,VermaCade05} 
and an unbounded number of sessions. We plan to investigate how such
fragments could be used to decide key cycles.

\paragraph{Acknowledgments.} We are particularly grateful to Michael Backes, Micha\"el
Rusinowitch, St\'ephanie Delaune, and Bogdan Warinschi for their very helpful  suggestions.







\bibliographystyle{acmtrans}
\bibliography{key_cycles}


\begin{received}
Received August 2007;
accepted April 2008
\end{received}

\end{document} 
