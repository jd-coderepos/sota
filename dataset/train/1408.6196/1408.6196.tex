

\documentclass{elsart_TR2}

\usepackage{latexsym}
\usepackage{graphicx,amssymb,psfrag}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{varioref}
\usepackage{rotating}
\usepackage{graphics}
\usepackage[dvips]{epsfig}
\usepackage{amssymb}
\setcounter{tocdepth}{3}


\usepackage{url}






\def\boxit#1{\vbox{\hrule\hbox{\vrule\kern4pt
  \vbox{\kern1pt#1\kern1pt}
\kern2pt\vrule}\hrule}}



\newcommand\nc{\newcommand}

\newtheorem{theorem}{\bfseries Theorem}
\newtheorem{lemma}{\bfseries Lemma}
\newtheorem{rull}{\bfseries Rule}
\newtheorem{corollary}{\bfseries Corollary}
\newtheorem{definition}{\bfseries Definition}
\newenvironment{proof}{\noindent{\bfseries Proof.}}{\qed}

\nc{\crl}[2]{\begin{corollary}\label{crl:#1} #2 \end{corollary}}
\nc{\dfn}[2]{\begin{definition}\label{def:#1} #2 \end{definition}}
\nc{\llem}[2]{\begin{lemma}\label{lem:#1} #2 \end{lemma}}
\nc{\thmm}[2]{\begin{theorem}\label{thm:#1} #2\end{theorem}}
\nc{\rul}[2]{\begin{rull}\label{rull:#1} #2\end{rull}}

\nc{\eqn}[2]{}


\nc{\fig}[4]{\begin{figure}[h]
\begin{center}
\includegraphics[width=#2\textwidth]{#4}
\end{center}
\caption{#3}\label{fig:#1}
\end{figure}}



\nc{\tbl}[3]{\begin{table}[hbt] #3 \caption{#2} \label{tab:#1}
\end{table}}

\nc{\refc}[1]{Corollary~\ref{crl:#1}}
\nc{\refd}[1]{Definition~\ref{def:#1}}
\nc{\reff}[1]{Figure~\ref{fig:#1}}
\nc{\refl}[1]{Lemma~\ref{lem:#1}}
\nc{\refp}[1]{Proposition~\ref{prp:#1}}
\nc{\reft}[1]{Theorem~\ref{thm:#1}} \nc{\refe}[1]{(\ref{eqn:#1})}
\nc{\reftb}[1]{Table~\ref{tab:#1}}
\nc{\refr}[1]{Rule~\ref{rull:#1}}

\nc{\reffc}[1]{Fact~\ref{fact:#1}}


\nc{\pff}[1]{ \noindent \emph{Proof.} #1 \hfill \qed\par}

\long\def\invis#1{}

\begin{document}
\begin{frontmatter}
\title{Exact Algorithms for Dominating Induced Matching Based on Graph Partition}
\author{Mingyu Xiao\corauthref{cor}}
\corauth[cor]{Corresponding author. Tel.: +86 15397626165}
\ead{myxiao@gmail.com}
\address{School of Computer Science and Engineering\\
University of Electronic Science and Technology of China\\
Chengdu 611731, China}
\author{Hiroshi Nagamochi}
 \ead{nag@amp.i.kyoto-u.ac.jp}
\address{Department of Applied Mathematics and Physics\\
Graduate School of Informatics\\
Kyoto University\\
Yoshida Honmachi, Sakyo, Kyoto 606-8501, Japan}


\begin{abstract}
A \emph{dominating induced matching}, also called an \emph{efficient edge domination}, of a graph  with  vertices and  edges
is a subset  of edges in the graph such
that no two edges in  share a common endpoint and each edge in  is incident with exactly one edge in . It is NP-hard to decide whether a graph admits a dominating induced matching or not. In this paper, we design a -time exact algorithm for this problem, improving all previous results.
This problem can be redefined as a partition problem that is to partition the vertex set of a graph into two parts  and , where  induces an independent set (a 0-regular graph) and  induces
a perfect matching (a 1-regular graph).
After giving several structural properties of the problem, we show that the problem always contains some ``good vertices,'' branching on which by including them to either  or  we can effectively reduce the graph. This leads to a fast exact algorithm to this problem.

\end{abstract}


\begin{keyword}
Combinatorial Optimization, Graph Algorithms, Graph Partition, Exact Algorithms, Dominating Induced Matching
\end{keyword}
\end{frontmatter}




\section{Introduction}


Let  be a simple undirected graph. An edge  \emph{dominates} itself and all edges sharing a common endpoint with it.
A subset  of edges is called an \emph{edge domination} if each edge in the graph is dominated by at least one edge in .
An edge domination  is called \emph{efficient} if each edge in the graph is dominated by exactly one edge in .
A graph has many edge dominations but may not have an efficient edge domination.
To  find an optimal edge domination or an efficient edge domination in a graph is a hard problem and this problem finds
applications in the fields of design and analysis of communication networks, network routing and coding theory~\cite{CCDS:EEDRegularGraph,GSSH:EED}.

Note that an efficient edge domination is an induced matching in the graph such that each  edge is dominated by exactly one edge in it.
So an efficient edge domination is also called a \emph{dominating induced matching}. The dominating induced matching problem (\textsc{Dominating Induced Matching}),
also called \textsc{Efficient Edge Domination} in the literature, is to check whether a graph admits a dominating induced matching or not. This problem has been extensively studied, especially
in terms of the computational complexity of it in different graph
 classes~\cite{BHN:EEDhole-free,BM:DIMp7,CKL:DIM,GSSH:EED,PandEED,EED:bpermutation}.
Grinstead et al.~\cite{GSSH:EED} first established the NP-hardness of this problem.
Later it is was further shown to be NP-hard even in planar bipartite graphs of maximum degree 3~\cite{BHN:EEDhole-free} and -regular graphs for ~\cite{CCDS:EEDRegularGraph}.
On the other hand, this problem is polynomial-time solvable in  many graph classes such as
AT-free graphs~\cite{BLR:EEDhypergraph}, hole-free graphs~\cite{BHN:EEDhole-free}, -free graphs~\cite{BM:DIMp7},
and claw-free graphs~\cite{CKL:DIM}.

In terms of exact algorithms, the edge domination problem,
a problem of finding an edge domination of minimum size, has been extensively studied~\cite{kn:rooij,xn:eds}. Most exact algorithms for the edge domination problem are analyzed by using the measure-and-conquer method. However, none of them can be easily modified for
\textsc{Dominating Induced Matching}.
Some exact algorithms for \textsc{Dominating Induced Matching} were also introduced recently~\cite{LMS:DIMexact,LMS:DIMexact_odd}. Lin et al.~\cite{LMS:DIMexact} obtained a -time algorithm. Their algorithm branches on a vertex by including it to the vertex set of the dominating induced matching or not.
In this paper, we also use this idea to design a branch-and-reduce algorithm. However, our improvement is not obtained by carefully
checking the worst cases of previous algorithms. We derive several graph properties of the problem, which will reduce some bad cases and allow us to design an improved algorithm.


Our paper is organized as follows. The notation system and our algorithm type are introduced in Section~\ref{sec_pre}.
Some conditions for feasibility and several rules to simplify problem  instances are given in Section~\ref{sec_rules}. The full algorithm is described in Section~\ref{sec_alg} and
the detailed analysis is given in Section~\ref{sec_analy}.
Finally, some concluding remarks are put in Section~\ref{sec_con}.



\section{Preliminaries}
\label{sec_pre}
In this paper, a graph stands for a simple undirected graph.
Let  be a graph and  be a subset of vertices.
A vertex in  is called an \emph{-vertex},
and a neighbor  of a vertex  is called an \emph{-neighbor} of .
The subgraph induced by  is denoted by , and  is also written as .
For a subset , let  denote the subgraph obtained from  by deleting edges in .
The vertex set and edge set of a graph  are denoted by  and , respectively.
A vertex  (resp., an edge ) in a graph is called a \emph{cut-vertex} (resp., \emph{bridge})
 if removing it increases the number of connected components of the graph.
For a vertex ,  the set of vertices with distance  from  is denoted by , where  and  is also simply written as . The \emph{degree} of vertex  is defined to be .
For an edge , let ,
 and  for ,
where  is also written as .
For a vertex  or an edge  and an integer , we let .
A path (resp., cycle) of \emph{length} , i.e., a path (resp., cycle) containing exactly  edges is called
 a  \emph{-path} (resp., \emph{-cycle}).
When a given graph is  edge-weighted, we use  to denote the weight of edge .
For a graph with no edges, we treat the empty edge subset as a dominating induced matching.


Some references, such as~\cite{LMS:DIMexact},  address the weighted case of \textsc{Dominating Induced Matching}, in which the edges in the graph have a cost and the goal of the problem is to find
a dominating induced matching of minimum cost among all dominating induced matchings (if they exist). To find a dominating induced matching of minimum cost or maximum cost is NP-hard, since it is NP-hard to check the existence of dominating induced matchings in an unweighted graph. We call these two weighted versions of this problem the \emph{minimum version} and the \emph{maximum version}. Many search algorithms for the unweighted version, including our algorithms, can be easily modified to the weighted versions. So in this paper, we describe our algorithms in terms of the unweighted version and point out the arguments where the weighted versions may need additional operations for handling edge weights.
In our algorithm, non-negativeness of edge weights  is not necessary to be assumed.
We treat only the minimum version because  the maximum version can be solved
as the minimum version  just by replacing  with .


\subsection{Algorithms based on graph partition}
\textsc{Dominating Induced Matching} can also be defined as a partition problem: Whether the vertex set of a graph can be partitioned into two subsets  and  such that
  induces an independent set (a graph with  degree-0 vertices) and
  induces a matching (a graph with   degree-1 vertices).



We can solve  \textsc{Dominating Induced Matching} in  time by checking all partitions of the vertex set.
By using some branch-and-reduce methods, the searching space can be reduced greatly~\cite{LMS:DIMexact}.
Our algorithm is also a branch-and-reduce algorithm. We fix some vertices in the two sides of the partition and then try to extend them by some effective operations.

\medskip
For a subset  and an independent set
 in ,
a dominating induced matching  is called an {\em -dim}
if

We may use  to denote an instance of the problem to decide whether the graph  admits an -dim or not.
We always let  denote ,
and let  denote the set of -vertices  such that .
The vertices in  are called {\em undecided\/} vertices.
After setting  and  initially,
we search for an -dim ,
 keeping track of subsets  and  of the vertices of .
The following \emph{Basic Conditions} are kept invariant.
\begin{enumerate}
\item
 is an independent set in ;
\item
, i.e., no -vertex has two or more -neighbors; and
\item
Each -vertex has  at least one -neighbor.
\end{enumerate}
We specify an instance only by ,  and , from which
,  and  are uniquely determined.



When there are no undecided vertices in the graph, i.e., ,
we can easily know whether or not the  current graph has an -dim  by checking if it satisfies the Basic Conditions.
In our algorithm, we use reduction and branching rules to move
-vertices to either  or  until  becomes an empty set. In a reduction rule, we move some -vertices  to  directly keeping the optimality of the solution.
In a branching rule, we generate two subinstances by moving a -vertex to either  or . A branch-and-reduce algorithm consisting of reduction and branching rules will generate a search tree.
Each node of the search tree represents an instance in the algorithm.
In particular, the instance to the root of the search tree is the initial instance, and
 the instances to the leaves of the search tree are instances with .

\subsection{Branch-and-reduce algorithms and recurrence relations}

Our algorithm contains one branching rule that is to branch by moving a -vertex to either  or .
After  moving a -vertex to  or , we may be able
to move some other -vertices to  or  directly by some reduction rules.
We assume that the number of -vertices decreases by at least  and  in the two resulting instances, respectively. Let  denote the number of the leaves of the search tree generated by the algorithm to solve a problem with  -vertices. Then we get the following recurrence relation:

To derive an upper bound on the size of the search tree, or the exponential part of the running time bound of the algorithm, we need to solve
this kind of linear recurrence relation.
A solution to the above recurrence relation is of the form , where  is the unique positive real root of the function .
We call  the \emph{branching factor} of .
For the largest branching factor   in the algorithm,
 the size of the search tree is .
For more details about how to  evaluate the size of the search tree and to solve the recurrence relations,
the readers are referred to the monograph~\cite{Fomin:book}.




We introduce a notation to describe a relationship among  recurrence relations, which will be used for us to ignore some recurrence relations without missing the worst recurrence relations with the largest branching factor.
 For two  recurrence relations
 and
 with the same number  of branches,
we denote ,
if
there are indices  such that ,  and  for
all .
The recurrence relation  is \emph{covered} by the recurrence relation  if  or there is a finite sequence of recurrence relations
 such that
.
We see that the branching factor of a recurrence relation is not smaller than that of any recurrence relation covered by it~\cite{Fomin:book}.

We may also derive a single recurrence relation for a series of branching operations
by combining the recurrence relations of the operations.
Given two recurrence relations
 and
,
let   denote
the combined recurrence relation of the branching with  and then
branching with  in the first branch in ;
 i.e.,  is .
The following lemma allows us to ignore some recurrence relations covered
by others in our algorithm to find the largest branching factor.

\llem{combined_recurrences}{Given three recurrence relations
,
 and
.
Assume that  is covered by . Then the combined recurrence relation  is covered by the combined recurrence relation .
}


\pff{
If  then , because
for the indices
 such that ,  and  for  all ,
we see that
,  and 
for all
.
Otherwise, there is a sequence of recurrence relations  such that
, , and
 for each
.
Analogously with the case of ,
 we have .
 }\medskip




In our algorithm,  is one of the worst recurrence relations, which solves to .
However, we observe that the worst cases will not always happen in our algorithm. After branching with a worst recurrence,
we can branch with a much better recurrence in the next step. So we combine the bad and good recurrences together to get a single recurrence.
Finally we get an upper bound  on the size of the search tree.



In the next section, we first introduce some properties of \textsc{Dominating Induced Matching},
which show that some -vertices can be moved to  directly and will be used to design reduction rules for our algorithm.
We design our algorithm so that it returns an  -dim of a given instance  if any or
0 as a message of the infeasibility otherwise.




\section{Properties and Reduction Rules}
\label{sec_rules}

In this section, we will give some rules to reduce a given instance.
A reduction rule is called \emph{correct} if it preserves the feasibility of instances; i.e.,
for an instance  and the instance   obtained from  by applying the reduction rule,
    is an yes-instance if and only if so is . We will show the correctness of our reduction rules.


Clearly every instance  violating the Basic Conditions cannot have an -dim.
This provides the following reduction rule.

\rul{rule0}{When the current instance violates the Basic Conditions, halt and return 0 to indicate that there is no -dim.}

In the search steps of our algorithm, we can ignore any resulting instance that violates
the Basic Conditions. We also execute the following reduction operations to move -vertices  to  or  without branching.
\rul{rule1}{Move to  a -vertex  adjacent to some -vertex.} \rul{rule2}{Move to  a -vertex  adjacent to some -vertex.} \rul{rule3}{Move to  the unique -neighbor  of some -vertex , i.e.,  .}



A -vertex  in an instance  is called \emph{i-reducible} (resp., \emph{m-reducible})
if  moving it to  (resp., ) and applying Rules~2 to 4 as much as possible result in an instance that violates the Basic
Conditions.
Every i-reducible vertex should not be in the vertex set of any -dim of the instance ,
whereas every m-reducible vertex should be in the vertex set of any -dim of the instance  if it exists.
A vertex is called \emph{infeasible} if it is both i-reducible and m-reducible.
Clearly every instance with some infeasible vertex admits no -dim.
Whether a vertex is i-reducible (resp., m-reducible) or not can be checked in polynomial time. We have the following rules:


\rul{rule6}{When there is an infeasible vertex, halt and return 0 to indicate that there is no -dim.}
\rul{rule4}{Move any i-reducible vertex to .}
\rul{rule5}{Move any m-reducible vertex to .}

Next we identify some infeasible,   i-reducible and  m-reducible  vertices from graph structures.

Obviously any dominating induced matching contains exactly one vertex in a triangle,
whereas no dominating induced matching contains any edge in a 4-cycle.
Hence a complete graph with size 4 cannot admit a dominating induced matching.
\llem{k4}{\emph{\cite{LMS:DIMexact}} A -vertex in a set of four vertices that induces a clique of size    is infeasible.}

\llem{i-reducible}{A -vertex   is i-reducible if \\
{\rm (a)}   has at least two -neighbors; or \\
{\rm (b)}  contains two triangles  and  with .}


\llem{i-reducible2}{ A -vertex   adjacent to an -vertex 
is i-reducible if there are two adjacent  -vertices ; i.e.,
 or
  is a triangle,  or
 is a 4-cycle.}

\llem{m-reducible}{A -vertex  is m-reducible if \\
{\rm (a)}  is a unique -neighbor of some -vertex , i.e., ; or  \\
{\rm (b)}  has a 4-cycle  such that   is a chord or  is of degree 2.
}


We call an instance  {\em pseudo-feasible} if none of the above  seven rules is applicable.
When applying any other kind of reduction and branching rules, we always assume that the current instance is pseudo-feasible.





\medskip
It is easy to observe the next.
\llem{pseudo}{Let  be a pseudo-feasible instance and   be the sequence  of vertex subsets in the instance.
Then:\\
{\rm (i)} There is no edge  between  and  with ; and \\
{\rm (ii)}  is an yes-instance if and only if
for each connected component  of  the instance  is an yes-instance.}
\crl{cut}{In a pseudo-feasible instance, if the graph  is connected and  is not an empty set, then each connected component of  contains at least one -vertex.}

Note that when we regard  as a new instance ,
the associated vertex sets  and  are empty.
Then the lemma provides a method of decomposing an instance into those with connected graphs
and no vertices in .
From now on, we consider a  pseudo-feasible instance  with  such that
 is connected.







\llem{remove_edge}{Let  and  be two vertices in an  instance   such that
any -dim  in  satisfies .
Let  be the graph obtained by deleting the edge  from  if 
 or by adding an edge  to  if  .
If  is an yes-instance, then  is also an yes-instance.
}
\pff{Since  and  belong to  and  separately in any -dim  of ,
the edge set  is also an -dim of . }\medskip


\llem{tri1}{Let    be a pseudo-feasible  instance with ,
and let  be a degree-2  -vertex with two -neighbors  and .
Then  any -dim  in  satisfies .}
\pff{Since  is in  and has no -neighbor, exactly one of the -neighbors of 
needs to be an end-point of any -dim ; i.e.,  .
}\medskip


From \refl{remove_edge} and \refl{tri1}, we get the following reduction rule.

\rul{rule_edge1}{Let  be a degree-2  -vertex with  two -neighbors  and .
If there is an edge , remove the edge  from the graph.}

We can use \refl{remove_edge} and \refl{tri1} to prove the correctness of this rule.
Let  be the instance after deleting the edge  from  by applying \refr{rule_edge1}.
By \refl{remove_edge} and \refl{tri1}, we have that  is an yes-instance
 if and only if so is .


\llem{fivecycle}{
Let    be a pseudo-feasible  instance with ,
and   let   be a degree-2   -vertex with  two -neighbors  and .
If  has  two 2-paths   and  with ,
then  any -dim  in  satisfies . }

\pff{By \refl{i-reducible}(a), each of  and  has no -neighbor other than ,
and it holds .
Let  be an arbitrary -dim.
By \refl{tri1}, it holds that  .
Also we see that  for edges  and .
Hence . }\medskip

From \refl{remove_edge} and \refl{fivecycle}, we get the following reduction rule
to deal with some -vertices contained in 5-cycles.

\rul{rule_5cycle}{Let  be  a degree-2  -vertex with  two -neighbors   and .
If   has a 5-cycle  ,  then remove the edge  from the graph.}











\llem{sixcycle}{Let 
be a 6-cycle in a pseudo-feasible instance    with  such that  and  are degree-2 vertices
and  is
an -vertex, where  is also an -vertex since the instance is pseudo-feasible.
Then the  instance  is an yes-instance
if and only if the instance  is an yes-instance.}
\pff{
First, we show that if the instance  admits an -dim  then  is an -dim in
. Since the -vertex  is adjacent to only two -vertices  and , we know that exactly one of  and  is in .
When  (resp., ) is in , then
neither of  and  (resp.,  and ) is in  and  (resp., ) is in .
Then we see that  (resp.,  ) is an -dim in
.

Second, we show that if  admits an -dim  then either  or  is
an -dim in . In ,  is an -vertex adjacent to only two -vertices  and .
We know that exactly one of  and  is in . When  (resp., ) is in ,
then neither of  and  (resp.,  and ) is in .
Hence  (resp.,  ) is an -dim in
.
 }\medskip

From the above lemma and its proof, we get the following reduction rule.
\reff{reductions}(a) illustrates the operation of the reduction rule.



\rul{rule_6cycle}{
Let  be a 6-cycle in a pseudo-feasible instance    with .
If  and  are degree-2 vertices and  is
an -vertex, then delete  and  from the graph and move  to  the vertices in .
For the weighted versions, also update the weight of  and  by letting  and
.}

\vspace{-0mm}\fig{reductions}{1}{Reduction operations for Rules~10, 11 and 12}{reductions}\vspace{-0mm}


In a pseudo-feasible  instance   with ,
a 3-path  is called a \emph{chain}
if  and  are degree-2 vertices and  is an -vertex.
Note that  is also an -vertex and   no vertex is adjacent to both of  and 
 since the instance is pseudo-feasible.
See \reff{reductions}(b) for an illustration of a chain.


\llem{chain}{Let  be a chain in a pseudo-feasible instance    with .
Let  be the graph obtained from  by contracting vertices   and 
 into a new -vertex .
Then   is an yes-instance
if and only if   is an yes-instance.
}
\pff{
First, we show that if  admits an -dim  then  is an -dim in
.
Since   and  and  are degree-2 vertices,
we know that exactly one of  and  is in .
When  (resp., ) is in ,
  and  (resp.,  and ) are not in .
Then we see that  (resp.,  )
is an -dim in .


Second, we show that if  admits an -dim  then either  or  is
an -dim in .
In ,
an edge  incident on  is in  since  is an -vertex.
Note that  is adjacent to exactly one of   and .
If  is a neighbor of  in , then  is an -dim in  .
On the other hand,  is a neighbor of  in , and  is
an -dim in   .
}




\rul{rule_chain}{
For a chain  , contract the four vertices   and 
 into a new -vertex ,
as shown in \reff{reductions}(b).
For the weighted versions, also update the weight of each edge incident on 
by letting ,  and
 , .}



In a pseudo-feasible  instance   with ,
the induced subgraph  for an -vertex  is called  a \emph{tail}
if there is exactly one edge between  and .
See \reff{reductions}(c) for an illustration of a tail.



\llem{reduction1}{
Let  be a tail in a pseudo-feasible instance  with .
Let  be the graph obtained from  by deleting .
Then   is an yes-instance
if and only if so is .}
\pff{
Assume that the unique edge between  and  is , where  and .

If  admits an -dim , then  contains exactly one edge  incident on . It is easy to see that
 is an -dim in . If  admits an -dim  then  is an -dim in , where  if  and  if
.

Therefore  admits an -dim if and only if  admits an -dim. }

\rul{rule_tails}{Remove any tail  in a pseudo-feasible  instance ,
as shown in \reff{reductions}(c).
For the weighted versions, also update the weight of each edge  incident on 
by letting , where   is an edge of minimum weight incident on  except .
}


\rul{rule_small}{Let  be a pseudo-feasible  instance with .
If  for an -vertex , then
move a -neighbor  of  to , where
 is an arbitrary -neighbor of  for the unweighted version whereas  is chosen
so that the edge  has the minimum weight among all edges incident on 
for the minimum version of the problem.
}



An instance is \emph{reduced} if none of   \refr{rule0}-\refr{rule_small} can be applied.

\llem{reduced}{Let    be a reduced instance with  such that  is connected.
Then \\
{\rm (i)}
Every degree-1 vertex is in  and its unique neighbor is in ; \\
{\rm (ii)} No -vertex is in a triangle or a 4-cycle or has a common -neighbor with other -vertex.
No degree-2 -vertex is  in a 5-cycle; and \\
{\rm (iii)} Every -vertex  has at least two -neighbors and at least two edges between  and
.
}
\pff{
{\rm (i)} If a degree-1 vertex  is in , then  would be in  by \refr{rule3}.
If the unique neighbor of a degree-1 -vertex is in , then it would be m-reducible by \refl{m-reducible}(a).

{\rm (ii)} Clearly any common -neighbor of some two -vertices is i-reducible.
 If  is in a triangle, then
 \refr{rule4} (by \refl{i-reducible2}) or \refr{rule_edge1} can be applied.
If  is in a 4-cycle, then \refr{rule4} (by \refl{i-reducible2}) can be applied.
By \refr{rule_5cycle}, no degree-2 -vertex is contained in a 5-cycle.

{\rm (iii)}
If the number of -neighbors of an -vertex  is 0 (resp., 1), then
 \refr{rule0} (resp., \refr{rule4})   can be applied.
If there is at most one edge between  and ,
 then
 \refr{rule_tails} or \refr{rule_small} can be applied.
}




\section{Ideas for Design and Analysis of Algorithm}\label{sec_alg}
Our algorithm is simple in the sense that it always branches on a -vertex  in a reduced instance by moving it to either  or .
In what follows, we make a basic analysis on how many -vertices will be moved to  in each of the two branches,
and then define a ``good'' vertex to branch on so that the number of -vertices efficiently decreases in each of the resulting instances.
Recall that  and  is connected.




In our algorithm, there is only one step where  may hold.
In this step, we branch on  a -vertex by moving it to either  or , which is easy to analyze.
For the other steps,  is not empty and the algorithm will branch on a  -vertex  adjacent to an -vertex .
In the following, we mainly assume that  is
adjacent to an -vertex , where  and  have no common vertex and no edge between them
since no -vertex is in a triangle or 4-cycle by \refl{reduced}(ii).
We distinguish (I) the first branch of moving    to  and (II) the second branch of moving    to 
in a reduced instance .

(I) The first branch of moving    to :
Then all vertices in , which are all -vertices,
 will be moved to , and all vertices in  will be moved to  directly by applying our reduction rules.
So in this branch, the number of -vertices decreases by at least

We also analyze two special cases where  some  -vertices in  can be eliminated. \\
\noindent
- The first special case is that there are two vertices  adjacent to each other,
 including the case that  is contained in a 5-cycle or 6-cycle.
Any vertex  adjacent to one of  or  is
 a -vertex, since otherwise  would be i-reducible.
Such a vertex  will be eliminated by \refr{rule1}, since  and  will be a pair of adjacent -vertices after moving  to .
\\
\noindent - The second special case is that there is a vertex  adjacent to exactly
one vertex , where we can assume that  has no  other  -neighbor
 since otherwise  the first case can be applied.
The vertex  is also a -vertex since otherwise  would be i-reducible.
We can see that  will be moved to  directly by \refr{rule3}.

Hence for each of the two special cases we can decrease one more -vertex .
Moreover any other -neighbor  of  will also be eliminated by the reduction rules.
In the following sections,  we  sometimes prove the existence of such a vertex 
to ensure that two -vertices  and  can be further eliminated in the first branch.

(II) The second branch of moving    to :
Note that  since -vertex  has no common -vertex with any other -vertex by \refl{reduced}(ii).
In this branch all vertices in  will be moved to , and the number of -vertices decreases by at least

In a reduced instance with a non-empty set , we can always find
a -vertex  with  an -neighbor  and a -neighbor  by \refl{reduced}(iii).
Such a -vertex  satisfies
.
So in the second branch, the number of -vertices decreases by at least 2.
We show two special cases where  more -vertices in  can be eliminated.\\
\noindent -
The first special case is that  has a degree-2 -neighbor , where  we denote .
After  is moved to , both of  and  will be moved to , and any other vertices adjacent to  will be moved to . \\
\noindent - The second special case is that  is of degree 2, where  we denote .
 After  is moved to ,  will be moved to .
Thus the second branch is equivalent to the operation of moving  to ,
and we see that  the -vertices in  will be eliminated.

We are ready to define ``good'' vertices to branch on.
A -vertex  is called an \emph{effective} vertex if it is of degree at least 3 and has an -neighbor.


Our algorithm branches on vertices as follows.
We first select effective vertices to branch on as long as they exist.
After this step, no effective vertex exists and each -neighbor of an -vertex is of degree at most 2.
Next our algorithm tests whether the graph contains an -vertex 
having only two degree-2 -neighbors,
and selects a degree-2 -neighbor  of such an -vertex  to branch on, if any.
Note that every degree-2 -vertex has two degree-2 -neighbors, since otherwise it would be in a tail.
After this, no -vertices of degree 2 exist  any more.
Then our algorithm tests whether the graph has an -vertex contained in 5-cycles
 and selects one neighbor  of such an -vertex to branch on, if any.
Finally no -vertex is contained in a cycle of length 3, 4 or 5,
and our algorithm selects a neighbor  maximum  of any -vertex  or
a -vertex  with some other priority (if ) to branch on.
The main steps of our algorithm are described in Figure~\ref{dim}.
Note that Step~3 is based on \refl{pseudo}.
Then it is easy to observe the correctness of the algorithm.


 \vspace{-0mm}\begin{figure}[!h] \setbox4=\vbox{\hsize28pc
\noindent\strut
\begin{quote}
\vspace*{-5mm}
\textbf{Input}: An instance  of a graph  and two subsets of vertices  and ,
where initially .
\\
\textbf{Output}: 1 if an -dim exists in  and 0 otherwise.\\
\vspace*{-2mm}
\begin{enumerate}
\item \textbf{If}
   \{ or the maximum degree of the graph is at most 2\},
     Solve the instance directly and return 1 if an -dim exists and 0 otherwise.
\item \textbf{Elseif}
    \{The instance is not pseudo-feasible\},
      Apply  \refr{rule0}-\refr{rule5} until none of them can be applied any more.
\item \textbf{Elseif}
   \{ or  contains more than one component\},
     Let  be the components of ;
     Return  .\\
     /* After Step 3, it always holds . */
\item \textbf{Elseif}
    \{The instance is not a reduced instance\}, Apply  one of \refr{rule_edge1}-\refr{rule_small} in the listed order
and return , where  is the resulting instance after applying the rule.
\item \textbf{Else}
    Choose a -vertex  as follows and branch on it
by returning :
\begin{enumerate}
\item \textbf{If}\{There is some effective vertex\},
Choose an effective vertex  adjacent to an -vertex  so that the degree of  is minimized.
\item \textbf{Elseif}
\{There is a degree-2 -vertex\}, Choose a degree-2 -vertex  and let  be a neighbor of .
\item
\textbf{Elseif}\{There is an -vertex with exactly two degree-2 -neighbors\},
Choose such an -vertex , and
 let  be  a degree-2 neighbor of  with maximum .
\item
\textbf{Elseif}\{There is an -vertex  that is in a 5-cycle 
 and  has at least three degree-2  neighbors\},
Choose such a 5-cycle , and let  be a degree-2 vertex in .
\item
\textbf{Elseif} \{There is still an -vertex \}, Let  be a neighbor of  with maximum .
\item
\textbf{Else} /* */
Let  be a -vertex satisfying one of the following: (i)  is contained in a triangle or
4-cycle;
(ii) no such vertices in (i) exist, and  is adjacent to at least one degree-2
vertex; and (iii) no such vertices in (i) and (ii) exist, and  is of maximum degree.


\end{enumerate}
\end{enumerate}

\end{quote} \vspace*{-5mm} \strut}   \vspace*{-2mm}
\caption{Algorithm } \label{dim} \vspace{-0mm}
\end{figure}



\section{The Detailed Analysis}\label{sec_analy}


Only Step~5 in the algorithm creates recurrences. Before analyzing each substeps in Step~5,
we prove some properties of reduction operations.



\llem{reductionu}{After applying any step of , the total number of -vertices in the instance does not increase.}

No operation in the algorithm will create any new -vertex. It is easy to see the correctness of this lemma.




\llem{Mconnected}{Let  be an instance such that  is a connected graph and .
Assume that  applying a  branching rule or reduction rule except \refr{rule_tails} to 
 results in an instance  without solving the instance directly.
Then    is still a connected graph and .
}
\pff{In \refr{rule0} to \refr{rule5}, \refr{rule_small} and the branching operations in Step~5 of the algorithm, either the problem is solved directly or some -vertices are moved to .
In the latter case, the connectivity of the graph is not affected and no -vertices are removed from the graph.
In \refr{rule_edge1} and \refr{rule_5cycle}, one edge is removed from the graph, where the graph remains connected
 since we see that this edge is not a bridge in the graph.
In \refr{rule_6cycle}, some vertices including an -vertex are removed from the graph,
where the graph remains connected and still has an -vertex.
\refr{rule_chain} contracts
some vertices without disconnecting the graph and keeping at least one -vertex in the remaining graph.
This proves the lemma.
}

By \refl{Mconnected} and \refc{cut}, we know that if a pseudo-feasible instance has the property that each connected component of  contains at least one -vertex,
then the resulting pseudo-feasible instance still satisfies this property
after applying any branching rule or reduction rule except \refr{rule_tails}.
This will be used in the analysis in Step~5(f).

Next we give the detailed analysis of each substep  in Step~5.
When a vertex  is chosen in Step~5,
let   (resp., ) denote the number   of
-vertices that decrease by the branch of moving  to  (resp., to )
and by possible applications of reduction rules to the resulting instance.


\subsection{Step~5(a)}
For an instance in Step~5(a),  the graph has some effective vertex.
Let  be an effective vertex adjacent to an -vertex  and at least two -vertices .
We assume that the algorithm will branch on .

First we show that  and .
Since  is of degree at least 2 by \refl{reduced} and has another -neighbor , we have .
Now cnsider the vertices in .
Note that no pair of vertices in  are adjacent to each other,
since otherwise  would be i-reducible.
Neither of  and  can be a degree-1 vertex, since otherwise  would be in .
Then each of  and  is adjacent to a vertex in .
If there is only one vertex  in  , then
 and  are adjacent to the same vertex , and  would be m-reducible.
Therefore we have that each of  and   has  an -neighbor,  and it holds .

Next we derive an upper bound on   (resp., ).
We define ; i.e.,   if  is of degree 2
 and  if  is of degree .
Let .

In the branch of moving  to ,  all vertices in 
will be moved to  and all vertices in  will be moved to .
In this branch, the number of -vertices decreases by at least .
Note that  contains at least three vertices  and ,
and when  is  of degree  it holds .
Then  .


For the other branch of moving  to , we prove that

 by distinguishing five different values of .


Case 1. : In this case,  contains at least two vertices  since .
We assume that  (resp., ) is adjacent to  (resp., ),
where   and  are not adjacent to each other, since otherwise they would be in .
Since  no two vertices in   have a common -neighbor in a reduced instance by \refl{reduced},
we see that  and  have different -neighbors:   is adjacent to say, 
 and  is adjacent to say,  such that .
\reff{case1} illustrates the neighbors of edge .
We easily see that there is no edge between  and , since otherwise
 the graph would have  some i-reducible or m-reducible vertex.
Since  and  are not tails, we know that there are two vertices  such that either
(i) each of  and  is adjacent to a vertex in  or
(ii)  is adjacent to both of  and  and a vertex  is adjacent to .
For the latter case,  is possibly an -vertex.
Since  is not an -vertex,  cannot be
a degree-1 vertex, and thereby it has a -neighbor .
In any of (i) and (ii), when  is moved to , at least seven -vertices  will be eliminated from , implying that  when .
Furthermore, when  is of degree 2, the other neighbor  of  will also be moved to  and
then at least eight -vertices  will be eliminated from ,
 implying that .

\vspace{-0mm}\fig{case1}{1}{Neighbors of edge  in an instance at Step~5(a)}{case1}\vspace{-0mm}

Case 2. : In this case,   contains at least one vertex  and one vertex .
Note that  is not in  because no two -vertices have a common -neighbor.
Then  is adjacent to some neighbor of . Without loss of generality, we can assume that
 (resp.,   )  is adjacent to   (resp.,  ).
Furthermore,  and  cannot be adjacent to each other, since otherwise  would be u-reducible.
See \reff{case1} for an illustration of  the neighbors of edge .
 Analogously with the above case, we know that  is adjacent to a vertex .
Let .
There is also a vertex  adjacent to either  or .
When  is moved to , at least six vertices  will be eliminated from ,
implying that  when .
Furthermore, when  is of degree 2, the other neighbor  of  will also be moved to  and
then at least seven -vertices  will be eliminated from ,
 implying that .



Case 3. : Let .
In the branch where  is moved to , three -vertices  will be eliminated. If  is of degree 2, the other neighbor  of  will also be eliminated. We show that at least two more -vertices will be eliminated in this branch,
which implies that  for  and
 for .
We distinguish  two subcases.

(i)  and  have a common neighbor in :
See \reff{case1}.
If no vertex in   has a neighbor in , then  would be m-reducible.
Then at least one vertex in , say  has a neighbor .
Since  is not in  and  cannot be a degree-1 vertex, we know that  has a -neighbor .
Note that path  cannot be a tail. Then  or  should have a -neighbor  and it will be moved to  or  after  is moved to .
Then at least two more -vertices,  and , will be eliminated from .

(ii)  and   have no common neighbor in :
Then each of  and  is adjacent to at most one vertex in . If one of  and , say  is not adjacent to any vertices in , we can assume
that  is adjacent to a vertex . From the analysis in Case 3(i), we  see that at least two more -vertices  and  will be eliminated. Next we assume
that each of  and  is adjacent to exactly one vertex in . Without loss of generality, we assume that  (resp., ) is adjacent to   (resp.,  ).
We   see that: for each ,  will be moved to  if  has a  -neighbor,
which should be an -vertex; and  will be moved to  if  has no -neighbor.
Then at least two more -vertices,  and , will be eliminated from .

Case 4.  : At least one of  and , say  has at most  one -neighbor.
If  has exactly one -neighbor ,
then  the four vertices  will be eliminated after  is moved to .
Assume that  has no -neighbor.
Then   has an -neighbor , which  must have
 a -neighbor .
For this case, the four vertices  will be eliminated.
Hence
 for .
Note that when  is of degree 2,
the other neighbor  of  will also be eliminated in any of the above cases,
 implying that  for .

Case 5. : After moving  to , we can always eliminate at least three -vertices ,
 implying that  for .
If  is a degree-2 vertex the other neighbor  of  will also be eliminated directly,
 implying that  for .

\medskip
From the arguments in Cases~1-5, we have that .
Therefore we can branch with recurrence relations

all of which are covered by
\eqn{2dbranch}{C(n)\leq C(n-(8+\lambda(u)))+C(n-(4-\lambda(u))).}
\medskip

Before we proceed to analysis on Step~5(b),
we analyze a special case in Step~5(a), where the neighbor  of 
 is an -vertex such that all the neighbors are effective vertices.
Although it is covered by the above analysis, we here derive better
recurrence relations for it, which will be used in the analysis of Step~5(e).
The algorithm will branch on  by including it to  or  in Step~5(a),
and let  be the degree of  and , which contains only effective -vertices.
We distinguish two cases.

Case S1. :
 Then the two -neighbors  and  of  are  of degree at least 3.
Choose vertices  and .
Then  is a set of six different -vertices since  is not contained in any triangle or 4-cycle by \refl{reduced}(ii).
The second branch of moving  to  is equivalent to the operation of moving  to .
When we move   to , all -vertices in  will be eliminated.
We can see that . In each branch, at least six -vertices decrease,
implying that  and .
We will further show that 
to obtain  the following   recurrence relation.
\eqn{6-7}{C(n)\leq C(n-6)+C(n-7).}
For this, we prove that
at least one more -vertex decreases in one of the two instances generated by branching on .
Vertices  and  are not adjacent to each other, since otherwise  would be i-reducible.
Each of  and  must be adjacent to a vertex , since otherwise
 would be i-reducible.
Assume that  (resp., )  has a  -neighbor  (resp.,  ).
Let  be the number of -vertices in  .
Since   , it holds ,
where if  then both of  and  are of degree 3
and both of  and  are -vertices.
Note that two -vertices  and  are not adjacent and have no common -neighbors.
Then each of  and  has at least two -neighbors, since they cannot be degree-1 vertices.
If one of  and   has a -neighbor , then in the branch of moving  to ,
the seven -vertices in  will decrease, implying that .
Now assume that  neither of  and  has a -neighbor.
Then
each of  and  is a degree-2 vertex adjacent to a vertex in .
At least one -vertex  is adjacent to  or ,
since the graph contains more than six -vertices.
In the branch of moving  to , vertices  and  will become -vertices
and  will be included into .
Again
the seven -vertices in  will be eliminated, implying that .


Case S2. :
Note that each vertex in  is of degree at least 3 since it is an effective vertex in the special case.
In the branch where  is moved to , all -vertices in  are eliminated.
There are at least  -vertices in . No pair of vertices in  are adjacent otherwise  would be in a triangle or 4-cycle.
Then each vertex in  has at least two -neighbors,
which are -vertices since otherwise a vertex in  would be adjacent to two -vertices
and should have been moved to .
Furthermore, no pair of vertices in  can share a common neighbor in 
since otherwise  would be in a 4-cycle.
Then there are at least  different -vertices in .
In total, the number of -vertices in   is at least , implying that .
In the other branch of moving  to , at least three -vertices in  decrease, implying that .
Therefore we get a recurrence relation
\eqn{multi-eff}{C(n)\leq C(n-3d)+C(n-3)  \mbox{  for }. }


\medskip
This completes our analysis on recurrence relations  in  Step~5(a).
We also examine  structural property on
instances with no effective vertices.

\llem{withoutopt}{Let  be a reduced instance having no effective vertices.
For any pair of adjacent vertices  and  in , it holds that\\
{\rm (i)}  the degree of  is at most 2; and \\
{\rm (ii)}  .
}
\pff{{\rm (i)} By \refl{reduced}(ii), we know that  is not in a triangle.
Thus, if  is of degree at least 3, then  has  at least two -neighbors and  would  an effective vertices,
 a contradiction to the assumption.

{\rm (ii)} If there is an -vertex  in  then there is a path , where . If  is a degree-2 vertex, then  is a chain.
 If  is of degree , then  is an effective vertex adjacent to .
For any case, the instance cannot be a reduced instance having no effective vertex.
}

The  property will be frequently used in the next analysis.


\subsection{Step~5(b) and Step~5(c)}
We  derive recurrence relations to Step~5(b) and Step~5(c).
Recall that
no -vertex  is  in any triangle and there are at least two edges between  and  by \refl{reduced}.
In Step~5(b),  both of the two neighbors of any -vertex  are of degree 2 and
adjacent to some vertices in , since no neighbor of  is of degree  by \refl{withoutopt}(i).
Thus, in Step~5(b)-(c), every -vertex  has exactly two degree-2 -neighbors,
each of which is adjacent to some vertex in ,
and any other neighbor of  is of degree 1.

Let  be  a degree-2 -neighbor  of an -vertex 
on which algorithm  branch in Step~5(b) or (c).
Let   be the degree of  and , where  and  are of degree 2.
Denote  and , where  holds
since otherwise  and  would be i-reducible.
 Vertex  cannot be a degree-2 vertex since otherwise  would be in a chain.
Then   has no -neighbor since otherwise  would be i-reducible.
 We know that  has at least two  -neighbors, say   and , each of which
 is a -vertex by \refl{withoutopt}(ii).
We distinguish with Step~5(b) and Step~5(c).




Case~1.  (Step~5(b)):
Note that , since   would imply
that  edge  can be deleted by \refr{rule_5cycle}.
Hence  contains at least three different -vertices  and .
See \reff{case2} for an illustration of  the neighbors of edge .
In the branch where  is moved to ,   all vertices in  will be moved to ,
 and all vertices in   will be moved to .
The number of  -vertices  eliminated from  is at least .
The other branch of moving  to  is equivalent to moving  to .
By the same argument, we see that this branch  also decreases at least six -vertices.
We get a recurrence relation
\eqn{6-6}{C(n)\leq C(n-6)+C(n-6).}

\vspace{-0mm}\fig{case2}{0.9}{Neighbors of edge  in an instance at Step~5(b) and Step~5(c)}{case2}\vspace{-0mm}

When there is a degree-2 -vertex   in the resulting instance,
 the next branch will be in either Step~5(a) or Step~5(b). We have the following lemma.


\llem{degree2}{If a reduced instance  has a degree-2 -vertex,
then the algorithm will branch with a recurrence relation covered by
\eqn{2dbranch_g}{C(n)\leq C(n-8)+C(n-4).}
}
\pff{When there is an effective vertex in the instance, the algorithm branches with a recurrence relation coverted by
 \refe{2dbranch} with .
When there is no effective vertex,
the algorithm will execute Step~5(b) for  some degree-2  vertex, and it
branches with \refe{6-6} by the above analysis, where \refe{6-6} is covered by \refe{2dbranch_g}. }

Case~2.  (Step~5(c)): See \reff{case2}.
We show that each of the two branches on   decreases at least seven -vertices.
First consider  the branch of moving  to  by distinguishing two subcases.

(i)  or  is of degree :
After  in moved to , the number of -vertices decreases by at least
.

(ii)  and  is of degree :
Without loss of generality, we assume that , where  .
For this case,  must be a degree-3 vertex,
because if  is of degree  then there would be a chain or tail,
and if  is of degree  then the algorithm must have selected  instead of  to branch on,
since .
Since  the current graph contains more than six -vertices after Step 1,
  if  is adjacent to , then  is adjacent to  a vertex  ,
where the vertex  is a -vertex since otherwise  would be i-reducible.
On the other hand, if  is not adjacent to ,
 then it must be adjacent to a -vertex .
In the branch where  in moved to ,   all vertices in  will be moved to ,
 and all vertices in   will be moved to .
The vertex  in any case will also be moved to  or  directly.
Therefore this branch eliminates at least seven -vertices in .

Second we consider the other branch where  is moved to .
After  is moved to , vertex  will be moved to  and the neighbors of  together with  will form a tail.
By reducing this tail by \refr{rule_tails}, at least two move -vertices  and  will be removed from the graph,
which remains connected and contains at least one -vertex .
Hence at least four -vertices will be eliminated.
Then we get a recurrence relation \eqn{4-7}{C(n)\leq C(n-7)+C(n-4).}




\subsection{Step~5(d)}

In Step~5(d), the algorithm chooses  a 5-cycle  passing through
an  -vertex  which has at least three degree-2  neighbors,
and branches on a degree-2 vertex  in .
Denote , where  .
Note that no pair of vertices in  are adjacent  since otherwise  would be i-reducible.
Also vertex  cannot be a degree-2 vertex since
otherwise there would be a chain containing
a 2-path .
Then  is adjacent to at least two vertices in .
We consider two subcases.
See \reff{case3} for an illustration of the neighbors of edge .

\vspace{-0mm}\fig{case3}{0.9}{Neighbors of edge  in an instance at  Step~5(d)}{case3}\vspace{-0mm}

Case 1.  is adjacent to both of  and :
Since the graph has more than six -vertices,
we know that there is a vertex  adjacent to some vertex in
.
The vertex  cannot be an -vertex,
 because   contains no -vertices by \refl{withoutopt}(ii)
and if  is an -neighbor of  or  then  would be i-reducible.
In the branch where  is moved to ,
all the seven -vertices  will be eliminated.
In the other branch where  is moved to , vertex  is moved to .
Now \refr{rule_6cycle} can be applied to the 6-cycle .
Applying the reduction rule  eliminates at least two -vertices  and .
This branch eliminates at least four -vertices in .
We get the same recurrence relation as \refe{4-7}.


Case 2. At least one of  and , say  is not adjacent to :
Vertex  is adjacent to a vertex .
Note that  has no neighbor in ,
since otherwise  would be contained in a 4-cycle and  would be i-reducible.
Also  has no neighbor  in , since otherwise  would be i-reducible.
It is also impossible that  has no other neighbor than  and , since otherwise  would be i-reducible.
Hence   has an -neighbor, which must be
a -vertex since otherwise  would be i-reducible.
We know that either  has two -neighbors  and  or  has only one -neighbor .
For the latter case,  should also have a -neighbor ,
where  cannot be an -vertex since otherwise  would be i-reducible.


In the first branch where  is moved to , the -vertices in the following set will be eliminated

where  since  and  since .
In the second branch where  is moved to , vertex  will be moved to , and
two -vertices  and  are  eliminated.
Therefore we get a recurrence relation


We further look at the second branch of moving  to .
Let  be the graph after removing  and moving  to .
Recall that any resulting -vertices in   will be removed in Step 3.
In , vertices  and  are  -vertices, where no tail is created in .
We distinguish two subcases.

(i) At least one of  and  is of degree 2 in :
Then the algorithm executes either
 some reduction operation other than reducing tails
to eliminate at least one more -vertex
or   Step~5(a) or  (b) in 
with a recurrence relation covered by \refe{2dbranch_g} in \refl{degree2}.
In the former, we obtain a recurrence relation
\eqn{9-3}{C(n)\leq C(n-9)+C(n-3).}
In the latter, we analyze a recurrence relation for the operation combined with
the branching on  and branching in .
By \refl{combined_recurrences},
we can ignore recurrence relations covered by \refe{2dbranch_g},
and   we get a recurrence relation
\eqn{weak}{
\begin{array}{rcl}
C(n)&\leq& C(n-9)+C(n-2-8)+C(n-2-4)\\
&=&C(n-9)+C(n-10)+C(n-6).
\end{array}}



(ii) Neither of  and  is of degree 2 in :
We know that before branching on ,
vertex  has at least four neighbors  and ,
and vertex  has at least two -neighbors  such that .
 Therefore  and  in .
In the first branch where  is moved to ,
at least 11 -vertices in  are eliminated.
We get a recurrence relation
\eqn{11-2}{C(n)\leq C(n-11)+C(n-2).}



\subsection{Step~5(e)}

In Step~5(e), the algorithm chooses
an  -vertex  and branches on a -neighbor   of ,
where   is not contained in 5-cycles and  has at least three neighbors  and 
each of which is adjacent  to some vertex in .
Now all of  and  are degree-2 vertices.
For each , let  be the other neighbor of  than .
The six vertices in  are different from each other,
because  is not contained in a triangle or 4-cycle by \refl{reduced}.
Furthermore, vertex  has at least two -neighbors  and  since there is no chain, and
no neighbor of  is in  since  is not contained in a 4-cycle or 5-cycle.
See \reff{case4} for an illustration of the neighbors of edge .
We distinguish two cases.

\vspace{-0mm}\fig{case4}{0.7}{Neighbors of edge  in an instance at Step~5(e)}{case4}\vspace{-0mm}

Case~1.  is of degree 3: We further distinguish two subcases.

(i)   has at least three -neighbors  and :
Then
  and  by .
In the  first branch where  is moved to , -vertices in  will be eliminated,
 and the number of -vertices
decreases by at least .
In the second branch where  is moved to ,   is moved to ,  and the number of -vertices
decreases by 2, leaving a degree- -vertex  in the graph.
Analogously with Case~2 in Step~5(d), we can get either \refe{9-3} or \refe{weak}.


(ii)     has only two neighbors  and :
Then  we can assume that  both of  and  are degree-3 vertices
by the choice of  and .
Now we have that   by  and  by .
In the first branch of moving  to , at least eight -vertices   will be eliminated.
In the second branch of moving  to ,  at least two -vertices   will be eliminated.
Then we have only a recurrence relation . We derive an improved recurrence relation
based on the fact that each of the generated instances has  a degree-2 -vertex
but contains no tail:
In the first branch where  is moved to ,  vertex
 will be a degree-2 -vertex; and  in the second branch where  is moved to ,
vertex  will be a degree-2 -vertex.
It is easy to check that each of the instances still contains no tails.
To each instance, the algorithm  in the next step
 either eliminates at least one more -vertex by reduction operations except reducing tails
or
branches with a recurrence relation covered by \refe{2dbranch_g} in \refl{degree2}.
When a  -vertex is eliminated by a reduction rule in the first instance, analogously with the analysis in  Case~2 of Step~5(d),
 we get  recurrence relations
 \refe{9-3} and \refe{weak}.
 When the algorithm branches with a recurrence relation covered by \refe{2dbranch_g} in the first instance and eliminates one
 -vertex by reduction operations in the second instance, we get
\eqn{weak2}{
\begin{array}{rcl}
C(n)&\leq& C(n-8-8)+C(n-8-4)+C(n-3)\\
&=&C(n-16)+C(n-12)+C(n-3).
\end{array}
 }
Otherwise the algorithm branches with a recurrence relation covered by \refe{2dbranch_g} in both of the two instances.
We show that the combined operation will create a recurrence relation covered by
\eqn{weakall}{
\begin{array}{rcl}
C(n)&\leq &C(n-8-8)+C(n-8-4)+C(n-2-8)+C(n-2-4)\\
&=&C(n-16)+C(n-12)+C(n-10)+C(n-6).                     \end{array}
}


Assume that the algorithm branches with
a recurrence  and
a recurrence  in the two instances, respectively,
where  and  are covered by \refe{2dbranch_g}.
By \refl{combined_recurrences}, we know that
recurrence  is covered by , and
recurrence
 is covered by .
Then  is covered by \refe{weakall}.




Case~2.  is of degree : Let  denote the fourth neighbor of ,
 and  denote the second neighbor of .
Now we have that  by  and 
by .
We distinguish two subcases.

(i)  has only two -neighbors  and :
Then by branching on 
we get a recurrence relation .
The branch of moving  to  leaves a graph with a degree-2 -vertex  and no tail.
Analogously with Case~2 in Step~5(d),
we can get two recurrence relations covered by \refe{9-3} and \refe{weak}, respectively.

(ii)  has at least three neighbors  and :
Then  by .
In the branch where  is moved to , at least 11 -vertices will be eliminated.
We can branch with \refe{11-2} in this case.

\subsection{Step~5(f)}
In Step~5(f),  holds, and
the algorithm branches on a -vertex  of maximum degree,
where the degree of  is  at least 3 since after Step~1 the maximum degree of the graph is at least 3.
Also in this step, the graph has no degree-1 vertex, otherwise the unique neighbor of each degree-1 vertex would be in .
In the first  branch of moving  to , at least one -vertex will be eliminated.
In the second branch of moving  to , all neighbors of  will be moved to  by applying reduction rules, and
the number of eliminated -vertices is at least  .
This leads to a recurrence relation .
To derive a better recurrence relation, we distinguish four cases.

Case 1.  is contained in a triangle  or a 4-cycle :
We show that the first  branch eliminates at least three -vertices.
First consider the case where  is contained in a triangle .
Let  be an -neighbor of .
In the first branch of moving  to ,
 all vertices in  will become i-reducible,
at least three -vertices in  will be eliminated.
Next consider the case where   is contained in a 4-cycle .
In the first branch of moving  to , the two neighbors  and  of  will become i-reducible,
and at least three -vertices will be eliminated.
In any case, we can get a recurrence relation


In what follows, we assume that  is not contained any triangle or 4-cycle.

Case 2.  has a degree-2 neighbor :
Let  be the other neighbor of , where 
 since the condition of Case 1 does not hold.
Since the graph has no degree-1 vertex and  is not contained in a 4-cycle,
we know that  has an -neighbor .
In the second branch where  is moved to ,
all vertices in  will be moved from .
At least six -vertices will be eliminated in this branch. Therefore we can get


Case 3.  is a vertex of degree  with no degree-2 neighbors:
Since , it is easy to see that the algorithm  branches on  with a recurrence relation
 .
We further look at the first branch, and denote  be the graph obtained by moving  to .
If at least one more -vertex is moved to  by a reduction operation applied to , then
we have a recurrence relation

Assume that no more -vertex is moved to  in .
In ,
vertex  becomes an -vertex with all neighbors of degree ,
and it is
an -vertex such that all the neighbors are effective vertices.
In the next step, the algorithm will branch on an effective vertex adjacent to  in 
 with the recurrence relation  \refe{multi-eff}  with , i.e., ,
by the analysis in Case~S2 in Step~5(a).
By combing this with the above recurrence relation, we get


Case 4.  is a degree-3  vertex with no degree-2 neighbors:
By the choice of , the current graph   is a 3-regular graph without any triangle or 4-cycle.
Since ,   the algorithm  branches on  with a recurrence relation
 .
We further look at both branches.
Let  and  be the graphs obtained by moving  to  and , respectively.

In , all neighbors of  will become effective vertices.
If an effective vertex in  is  eliminated by a reduction rule, before the instance becomes a reduced one,
 then at least one more -vertex will be moved to  by the reduction operation.
On the other hand, the algorithm will branch on an effective vertex adjacent to  in 
with the recurrence relation
  \refe{2dbranch} with , i.e., , by the analysis in Step~5(a).
In ,  all neighbors of  are contained in .
Each neighbor  of  will become a degree-2 -vertex in  satisfying the condition of
Case~S1 in Step~5(a).
If no  more -vertex is eliminated by reduction rules before the next branching,
then the algorithm will branch
with \refe{6-7} in , where  \refr{rule_edge1}
cannot be applied to  since the graph has no triangle.
If only one -vertex is eliminated by reduction rules before
the next branching, then the resulting graph still has at least one degree-2 -vertex and the
algorithm will branch with \refe{2dbranch_g}.
Otherwise, two -vertices are eliminated and the resulting graph still has an -vertex.
Therefore we obtain six recurrence relations





We have analyzed recurrence relations for all cases in Step~5.
In fact, the  recurrence relations in Step~5(f)  are not good enough to get our claimed running time bound.
However, the condition of Step~5(f) will not always happen.
By \refl{Mconnected} and \refc{cut}, we know that before creating a connected component  of  that contains no -vertex,
at least one tail adjacent to  must have been removed from it
 except for the case where  is the initial connected graph.
A tail contains at least two -vertices.
Therefore, we see that
at least two more -vertices  have been eliminated before Step~5(f) is executed.
Considering this, we can replace the above ten recurrence relations with
 \eqn{5-6}{C(n)\leq C(n-5)+C(n-6),}
 \eqn{3-8}{C(n)\leq C(n-3)+C(n-8),} \eqn{4-7-2}{C(n)\leq C(n-4)+C(n-7),}
  \eqn{6-7-15}{C(n)\leq C(n-6)+C(n-7)+C(n-15),} \eqn{4-12-13}{C(n)\leq C(n-4)+C(n-12)+C(n-13), } \eqn{4-11-15}{C(n)\leq C(n-4)+C(n-11)+C(n-15),} \eqn{4-8_1}{C(n)\leq C(n-4)+C(n-8),}
\eqn{6-12-12-13}{C(n)\leq C(n-6)+2C(n-12)+C(n-13),} \eqn{6-11-12-15}{C(n)\leq C(n-6)+C(n-11)+C(n-12)+C(n-15),~~\mbox{and}} \eqn{6-8-12}{C(n)\leq C(n-6)+C(n-8)+C(n-12).} 




\subsection{The final solution}

Among the above recurrence relations, the worst one with the largest branching factor is \refe{weakall}, which solves to . Then we get
\thmm{final}{\textsc{Dominating Induced Matching} can be solved in  time.}

\section{Concluding Remarks}\label{sec_con}
By designing several branching rules, we can eliminate -vertices contained in some cycles of length at most 6.
This improves recurrence relations in the several previously worst cases in ~\cite{LMS:DIMexact}.
Finally, the worst case in our algorithm will be to branch on a vertex in a local graph
without any special structure and then we get the claimed running time bound.

In our algorithm, we use the number of undecided vertices as the measure.
For most NP-hard graph problems, the best exact algorithms are designed and analyzed by using the measure and conquer method,
which requires a complicated measure.
If we also introduce the measure and conquer method to our algorithm, we may need to set different weights to -vertices.
However, we have not found any good weight setting scheme to improve the bound of the running time.
It leaves as a question whether or not the measure and conquer method is also helpful in designing exact algorithms for \textsc{Dominating Induced Matching}.



\textsc{Dominating Induced Matching} is to partition a graph into two parts  and  which
 induce an independent set and a matching, respectively.
For further study, we may consider algorithms for the extended problem:  for
integers , we are asked
to partition a given graph into two parts  and    that 
   induce a degree- graph and a degree- graph, respectively.
Some complexity results of this kind of extended problems can be found in~\cite{xn:BDG}.



\section*{Acknowledgement}
The first author was supported in part by National Natural Science Foundation of China under the Grant
61370071.




\begin{thebibliography}{99}
\bibitem{BHN:EEDhole-free}
Brandst\"{a}dt, A., Hundt, C., and Nevries, R.:
Efficient edge domination on hole-free
graphs in polynomial time. In:  LATIN 2010, LNCS 6034,  650--661, 2010

\bibitem{BM:DIMp7}
Brandst\"{a}dt, A., and Mosca, R.:
Dominating induced matchings for -free graphs in linear time.
\emph{Algorithmica} (2013) DOI 10.1007/s00453-012-9709-4

\bibitem{BLR:EEDhypergraph}
Brandst\"{a}dt, A., Leitert, A., and Rautenbach, D.:
Efficient dominating and edge dominating sets for graphs and hypergraphs.
In: ISAAC 2012, LNCS 7676,  267--277, 2012.

\bibitem{CCDS:EEDRegularGraph}
Cardoso, D.M., Cerdeira, J.O., Delorme, C., and Silva, P.C.:
Efficient edge domination in regular graphs.
\emph{Discrete Applied Math.} \textbf{156} (2008), 3060--3065

\bibitem{CKL:DIM}
Cardoso, D.M., Korpelainen, N., and Lozin, V.V.:
On the complexity of the dominating induced matching problem in hereditary classes of graphs.
\emph{Discrete Applied Math.} \textbf{159} (2011), 521--531

\bibitem{Fomin:book}
Fomin, F. V.  and Kratsch, D.:
\newblock Exact Exponential Algorithms, Springer (2010)

\bibitem{GSSH:EED}
Grinstead, D.L., Slater, P.L., Sherwani, N.A., and Holmes, N.D.:
Efficient edge domination problems in graphs.
\emph{Information Processing Letters} \textbf{48}(1993), 221--228


\bibitem{LMS:DIMexact}
Lin, M.C., Mizrahi, M.J., and Szwarcfiter, J.L.:
An  time algorithm for minimum
weighted dominating induced matching.
In: ISAAC 2013, LNCS 8283,  558--567, 2013.

\bibitem{LMS:DIMexact_odd}
Lin, M.C., Mizrahi, M.J., and Szwarcfiter, J.L.:
Exact algorithms for dominating induced matchings. CoRR, abs/1301.7602 (2013)


\bibitem{PandEED}
Lu, C.L., Ko, M.-T., and Tang, C.Y.:
Perfect edge domination and efficient edge domination
in graphs.
\emph{Discrete Applied Math.} \textbf{119} (2002), 227--250

\bibitem{EED:bpermutation}
Lu, C.L. and Tang, C.Y.:
Solving the weighted efficient edge domination problem on bipartite permutation graphs.
\emph{Discrete Applied Math.} \textbf{87}(1998), 203--211

\bibitem{kn:rooij}
Van Rooij,~J.~M. and  Bodlaender,~H.~L.
Exact algorithms for edge domination,
\emph{Algorithmica} \textbf{64}(4) (2012),  535--563

\bibitem{xn:eds}
Xiao,~M.  and Nagamochi, H.:
\newblock A refined exact algorithm for edge dominating set.
\newblock \emph{Theoretical Computer Science }(2014) DOI: 10.1016/j.tcs.2014.07.019

\bibitem{xn:BDG}
Xiao,~M.  and Nagamochi, H.:
\newblock Complexity and kernels for bipartition into degree-bounded induced graphs.
\newblock Manuscript. 2014 (Submitted)





\end{thebibliography}


\end{document}
