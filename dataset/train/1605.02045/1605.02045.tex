\documentclass[11pt]{article}

\setcounter{tocdepth}{3}


\usepackage{amssymb,amsmath,amsfonts}
\usepackage{amsthm}
\usepackage{subfig}
\usepackage{times,inconsolata}
\usepackage{fullpage}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{url}
\usepackage[ruled,linesnumbered,noend]{algorithm2e}
\usepackage{color}


\DeclareMathOperator{\mrca}{mrca}

\newcommand{\Ch}{\Children}
\newcommand{\Children}{\ensuremath{{\mathrm{Ch}}}}
\newcommand{\child}{\ensuremath{{\rm child}}}
\newcommand{\parent}{\ensuremath{{\rm parent}}}
\newcommand{\Cl}{\ensuremath{{\mathrm{Cl}}}} 		\newcommand{\true}{{\ensuremath{\texttt{true}}}}
\newcommand{\false}{\ensuremath{\texttt{false}}}
\newcommand{\MP}{\ensuremath{M_\P}} \newcommand{\TG}{\ensuremath{\Gamma}} \newcommand{\incompatible}{\texttt{incompatible}}
\newcommand{\Uinit}{\ensuremath{U_\mathrm{root}}} \newcommand{\Ubef}{\ensuremath{U_\mathrm{bef}}} \newcommand{\Uaft}{\ensuremath{U_\mathrm{aft}}} \newcommand{\Urem}{\ensuremath{U_\mathrm{rem}}} \newcommand{\Yinit}{\ensuremath{Y_\mathrm{root}}} \newcommand{\Winit}{\ensuremath{W_\mathrm{root}}} \newcommand{\indeg}{\ensuremath{\mathrm{indegree}}} \newcommand{\Desc}{\ensuremath{\mathrm{Desc}}} 

\newcommand{\DG}{\ensuremath{H_\P}} \newcommand{\GBNT}{\ensuremath{G_{\mathtt{BNT}}}} 

\newcommand{\Build}{\ensuremath{\textsc{Build}}} \newcommand{\BuildG}{\ensuremath{\textsc{BuildST}}} \newcommand{\SLBuild}{\ensuremath{\texttt{BuildNT}}} \newcommand{\Successor}{\ensuremath{\texttt{Successor}}}
\newcommand{\InitLists}{\ensuremath{\texttt{Initialize}}}
\newcommand{\DelLabel}{\ensuremath{\texttt{Delete}}}


\newcommand{\Hcal}{\ensuremath{\mathcal{H}}}
\renewcommand{\P}{\ensuremath{\mathcal{P}}}
\newcommand{\R}{\ensuremath{\mathcal{R}}}
\newcommand{\T}{\ensuremath{\mathcal{T}}}


\newcommand{\comm}[1]{\marginpar{\textsl{\color{red} #1}}}
\newcommand{\commResp}[1]{\marginpar{\textsl{\color{blue} #1}}}
\newcommand{\FIX}[1]{\textsl{\color{red} #1 }}
\newcommand{\inprog}[1]{\textsl{\color{blue}#1}\marginpar{\textsl{\color{green}In progress}}}

\newcommand{\algcomm}[1]{\hfill \textsl{\color{red}  #1}}
\newcommand{\algcommResp}[1]{\hfill \textsl{\color{green}  #1}}

\newcommand{\cnt}{\ensuremath{\mathtt{count}}} \newcommand{\ID}{\ensuremath{\mathtt{id}}} \newcommand{\TYPE}{\ensuremath{\mathtt{in}}} \newcommand{\SIZE}{\ensuremath{\mathtt{size}}} \newcommand{\COUNT}{\ensuremath{\mathtt{count}}} \newcommand{\SET}{\ensuremath{\mathtt{set}}} \newcommand{\SEMI}{\ensuremath{\mathtt{semiU}}} \newcommand{\LABEL}{\ensuremath{\mathtt{label}}} \newcommand{\WEIGHT}{\ensuremath{\mathtt{weight}}} \newcommand{\NULL}{\ensuremath{\mathtt{null}}} \newcommand{\MAP}{\ensuremath{\mathtt{map}}} \newcommand{\KEY}{\ensuremath{\mathtt{key}}} \newcommand{\VALUE}{\ensuremath{\mathtt{value}}} \newcommand{\KEYSET}{\ensuremath{\mathtt{keySet}}} 

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{observation}{Observation}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\SetKw{continue}{continue}

\begin{document}
\title{Fast Compatibility Testing for Phylogenies with Nested Taxa\thanks{Supported in part by the National Science Foundation under grant CCF-1422134.}}
\author{
Yun Deng\thanks{Department of Computer Science, Iowa State University, Ames, IA 50011, USA, {\tt yundeng@iastate.edu}}
\and
David Fern\'{a}ndez-Baca\thanks{Department of Computer Science, Iowa State University, Ames, IA 50011, USA, {\tt fernande@iastate.edu}. 
}
}

\date{\empty}

\maketitle

\begin{abstract}
Semi-labeled trees are phylogenies whose internal nodes may be labeled by higher-order taxa.  Thus, a leaf labeled \emph{Mus musculus} could nest within a subtree whose root node is labeled Rodentia, which itself could nest within a subtree whose root is labeled Mammalia.  
Suppose we are given collection  of semi-labeled trees over various subsets of a set of taxa.  The ancestral compatibility problem asks whether there is a semi-labeled tree  that respects the clusterings and the ancestor/descendant relationships implied by the trees in . 
We give a  algorithm for the ancestral compatibility problem, where  is the total number of nodes and edges in the trees in .  Unlike the best previous algorithm, the running time of our method does not depend on the degrees of the nodes in the input trees.  
\end{abstract}

\section{Introduction}

In the \emph{tree compatibility problem}, we are given a collection  of rooted phylogenetic trees with partially overlapping taxon sets.  is called a \emph{profile} and the trees in  are the \emph{input trees}.  The question is whether there exists a tree  whose taxon set is the union of the taxon sets of the input trees, such that  exhibits the clusterings implied by the input trees.  That is, if two taxa are together in a subtree of some input tree, then they must also be together in some subtree of . The tree compatibility problem has been studied for over three decades \cite{Aho81a,DengFB2016,HenzingerKingWarnow99,Steel92}.

In the original version of the tree compatibility problem, only the leaves of the input trees are labeled. 
Here we study a generalization, called \emph{ancestral compatibility}, in which taxa may be \emph{nested}.  That is, the internal nodes may also be labeled; these labels represent \emph{higher-order taxa}, which are, in effect, sets of taxa.  Thus, for example,   an input tree may contain the taxon \emph{Glycine max} (soybean) nested within a subtree whose root is labeled Fabaceae (the legumes), itself nested within an Angiosperm subtree.  Note that leaves themselves may be labeled by higher-order taxa.  The question now is whether there is a tree   whose taxon set is the union of the taxon sets of the input trees, such that  exhibits not only the clusterings among the taxa, but also the ancestor/descendant relationships among taxa in the input trees.  Our main result is a  algorithm for the compatibility problem for trees with nested taxa, where  is the total number of nodes and edges in the trees in .

\vspace{-1.5\parsep}

\paragraph{Background.}  The tree compatibility problem is a basic special case of the \emph{supertree problem}.
A supertree method is a way to synthesize a collection of phylogenetic trees with partially overlapping taxon sets into a single supertree that represents the information in the input trees.  The supertree approach, proposed
in the early 90s \cite{Baum:1992,Ragan:1992}, has been used successfully to build large-scale phylogenies \cite{BinindaEmonds:Nature:07}. 

The original supertree methods were limited to input trees where only the leaves are labeled.
Page \cite{Page2004} was among the first to note the need to handle phylogenies where internal nodes are labeled, and taxa are nested.  A major motivation is the desire to incorporate \emph{taxonomies} as input trees in large-scale supertree analyses, as way to circumvent one of the obstacles to building comprehensive phylogenies: the limited taxonomic overlap among different phylogenetic studies \cite{Sanderson:2008}. Taxonomies group organisms according to a system of taxonomic rank  (e.g., family, genus, and species); two examples are the NCBI taxonomy \cite{NCBI2009} and the Angiosperm taxonomy \cite{APG2016}.  Taxonomies spanning a broad range of taxa provide structure and completeness that might be hard to obtain otherwise.    
A recent example of the utility of taxonomies is the Open Tree of Life, a draft phylogeny for over 2.3 million species \cite{HinchliffPNAS2015}.

Taxonomies are not, strictly speaking, phylogenies.  In particular, their internal nodes and some of their leaves are labeled with higher-order taxa. Nevertheless, taxonomies have many of the same mathematical characteristics as phylogenies.  Indeed, both phylogenies and taxonomies are \emph{semi-labeled trees} \cite{BordewichEvansSemple2006,SempleSteel03}.  We will use this term throughout the rest of the paper to refer to trees with nested taxa.



The fastest previous algorithm for testing ancestral compatibility, based on earlier work by Daniel and Semple \cite{DanielSemple2004}, is due to Berry and Semple \cite{BerrySemple2006}. Their algorithm runs in  time using  space. Here,  is the number of distinct taxa in  and  , where  is the set of internal nodes of , for each , and  is the degree of node .   While the algorithm is polynomial, its dependence on node degrees is problematic:  semi-labeled trees can be highly unresolved (i.e., contain nodes of high degree), especially if they are taxonomies.

\vspace{-1.5\parsep}

\paragraph{Our contributions.}
The  running time of our ancestral compatibility algorithm is independent of the degrees of the nodes of the input trees, a valuable characteristic for large datasets that include taxonomies.  To achieve this time bound, we extend ideas from our recent algorithm for testing the compatibility of ordinary phylogenetic trees \cite{DengFB2016}.   As in that algorithm, a central notion in the current paper is the \emph{display graph} of profile , denoted .  This is the graph obtained from the disjoint union of the trees in  by identifying nodes that have the same label (see Section \ref{sec:testAC}).
The term ``display graph'' was introduced by Bryant and Lagergren  \cite{BryantLagergren06}, but similar ideas have been used elsewhere.  In particular, the display graph is closely related to Berry and Semple's \emph{restricted descendancy graph} \cite{BerrySemple2006}, a mixed graph whose directed edges correspond to the (undirected) edges of  and whose undirected edges have no correspondence in .  The second kind of edges are the major component of the  term in the time and space complexity of Berry and Semple's algorithm.  The absence of such edges makes  significantly smaller than the restricted descendancy graph.  Display graphs also bear some relation to  \emph{tree alignment graphs} \cite{Smith:PloSCB:2013}.

Here, we exploit the display graph more extensively and more directly than our previous work.  Although the display graph of a collection of semi-labeled trees is more complex than that of a collection of  ordinary phylogenies, we are able to extend several of the key ideas --- notably, that of a semi-universal label --- to the general setting of semi-labeled trees.  As in \cite{DengFB2016}, the implementation relies on a dynamic graph data structure, but it requires a more careful amortized analysis based on a weighing scheme.

\vspace{-1.5\parsep}

\paragraph{Contents.} Section \ref{sec:prelims} presents basic definitions regarding semi-labeled trees and ancestral compatibility.  .  Section \ref{sec:dispGraph} introduces the display graph and discusses its properties.  Section \ref{sec:testAC} presents \SLBuild, our algorithm for testing ancestral compatibility.  Section \ref{sec:implementation} gives the implementation details for \SLBuild.  Section \ref{sec:discussion} gives some concluding remarks.

\section{Preliminaries}\label{sec:prelims}

For each positive integer ,  denotes the set .

Let  be a graph.  and  denote the node and edge sets of . The \emph{degree} of a node  is the number of edges incident on . A \emph{tree} is an acyclic connected graph.
In this paper, all trees are assumed to be rooted.  For a tree ,  denotes the root of . 
Suppose .  Then,  is an \emph{ancestor} of  in , denoted , if  lies on the path from  to  in .  If , then  is a \emph{descendant} of .  Node  is a \emph{proper descendant} of  if  is a descendant of  and . If  and , then   is the \emph{parent} of  and  is a \emph{child} of . If neither  nor   hold, then  we write  and say that  and  are \emph{not comparable} in . 

\vspace{-1.5\parsep}

\paragraph{Semi-labeled trees.} A \emph{semi-labeled tree} is a pair  where  is a tree and  is a mapping from a set  to  such that, for every node  of degree at most two, .   is the \emph{label set} of  and  is the \emph{labeling function} of .  

For every node ,  denotes the (possibly empty) subset of  whose elements map into ; these elements as the \emph{labels of } (thus, each label is a taxon). If , then  is \emph{labeled}; otherwise,  is \emph{unlabeled}.  
Note that, by definition, every leaf in a semi-labeled tree is labeled.  Further, any node, including the root, that has a single child must be labeled.  Nodes with two or more children may be labeled or unlabeled.  A semi-labeled tree  is \emph{singularly labeled} if every node in  has
at most one label;  is \emph{fully labeled} if every node in  is labeled.

Semi-labeled trees, also known as \emph{-trees}, generalize ordinary phylogenetic trees, also known as \emph{phylogenetic -trees} \cite{SempleSteel03}.  An ordinary phylogenetic tree is a semi-labeled tree  where  has degree at least two and  is a bijection from  into leaf set of  (thus, internal nodes are not labeled). 

Let  be a semi-labeled tree and let  and  be two labels in .  
If , then we write , and say that  is a \emph{descendant} of  in  and that  is an \emph{ancestor} of .  We write  if  is a proper descendant of .   If , then we write  and say that  and  are \emph{not comparable} in .  If  is fully labeled and
 is the parent of  in , then  is the \emph{parent} of  in  and  is a \emph{child} of  in ; two labels with the same parent are \emph{siblings}.

Two semi-labelled trees  and  are \emph{isomorphic} if there exists a bijection  such that  and, for any two nodes ,  if and only .



Let   be a semi-labeled tree. For each ,   denotes the set of all labels in the subtree of  rooted at ; that is, .  is called a \emph{cluster} of .  
 denotes the set of all clusters of .   It is well known \cite[Theorem 3.5.2]{SempleSteel03} that a semi-labeled tree  is completely determined by .  That is, if  for some other semi-labeled tree , then  is isomorphic to .



Suppose  for a semi-labeled tree .  The \emph{restriction} of  to , denoted , is the semi-labeled tree whose cluster set is

Intuitively,  is obtained from the minimal rooted subtree of  that connects the nodes in  by suppressing all vertices of degree two that are not in .

Let  and  be semi-labeled trees such that .    \emph{ancestrally displays}  if .  Equivalently,  ancestrally displays  if   can be obtained from  by contracting edges, and, for any , (i) if , then , and
(ii)
if , then .
The notion of ``ancestrally displays'' for semi-labeled trees generalizes the well-known notion of ``displays'' for ordinary phylogenetic trees \cite{SempleSteel03}.  





For a semi-labelled tree , let

Note that  consists of \emph{ordered} pairs, while  consists of \emph{unordered} pairs.

\begin{lemma}[Bordewich et al.\  \cite{BordewichEvansSemple2006}]\label{lm:DN}
Let  and  be semi-labelled trees such that . Then  ancestrally displays  if and only if  and .
\end{lemma}

\vspace{-1.5\parsep}

\paragraph{Profiles and ancestral compatibility.}
Throughout the rest of this paper  denotes a set where, for each ,  is a semi-labeled tree. We refer to  as a \emph{profile}, and write  to denote , the \emph{label set} of .   Figure~\ref{fig:profile} shows a profile where .
We write  for  and  for , The \emph{size} of  is .  



\begin{figure}\centering
\begin{minipage}[b]{0.46\linewidth}
  \includegraphics[scale=0.25]{profile.pdf}
  \caption{A profile  --- trees are ordered left-to-right. 
The letters are the original labels; grey numbers are labels added to make the trees fully labeled. (Adapted from  \cite{BerrySemple2006}.)}
  \label{fig:profile}
\end{minipage}
\quad
\begin{minipage}[b]{0.24\linewidth}
  \includegraphics[scale=0.25]{supertree.pdf}
  \caption{A tree  that ancestrally displays the profile of Figure \ref{fig:profile}. (Adapted from  \cite{BerrySemple2006}.)}
  \label{fig:supertree}
\end{minipage}
\quad
\begin{minipage}[b]{0.23\linewidth}
  \includegraphics[scale=0.25]{displayGraph.pdf}
  \caption{The display graph  for the profile of Figure \ref{fig:profile}.} \label{fig:displayGraph}
\end{minipage}
\end{figure}

 is \emph{ancestrally compatible} if there is a rooted semi-labeled  tree  that ancestrally displays each of the trees in .  If  exists, we say that  \emph{ancestrally displays}  (see Figure \ref{fig:supertree}). 

Given a subset  of , the \emph{restriction} of  to , denoted , is the profile .  The proof of the following lemma is straightforward.

\begin{lemma}\label{lm:compatSubprofile}
Suppose  is ancestrally compatible and let  be a tree that ancestrally displays .  Then, for any ,  ancestrally displays .
\end{lemma}

A  semi-labeled tree  is \emph{fully labeled} if every node in  is labeled.  Suppose  contains trees that are not fully labeled.  We can convert  into an equivalent profile  of fully-labeled trees as follows.  For each , let  be the number of unlabeled nodes in .  Create a set  of  labels such that .  For each  and each  such that , make , where  is a distinct element from .
We refer to  as the \emph{profile obtained by adding distinct new labels to } (see Figure \ref{fig:profile}).


\begin{lemma}[Daniel and Semple \cite{DanielSemple2004}]\label{lm:fullyL}
Let  be the profile obtained by adding distinct new labels to . Then,  is ancestrally compatible if and only if  is ancestrally compatible. Further, if  is a semi-labeled phylogenetic tree that ancestrally displays , then  ancestrally displays .
\end{lemma}

From this point forward, we shall assume that,
for each ,  is fully and singularly labeled.
By Lemma \ref{lm:fullyL}, no generality is lost in assuming that all trees in  are fully labeled. 
The assumption that the trees are singularly labeled is inessential; it is only for clarity.  Note that, even with the latter assumption, a tree that ancestrally displays  is not necessarily singularly labeled.  Figure \ref{fig:supertree} illustrates this fact.

\section{The Display Graph}\label{sec:dispGraph}

The \emph{display graph} of a profile , denoted , is the graph obtained from the disjoint union of the underlying trees  by identifying nodes that have the same label. Multiple edges between the same pair of nodes are replaced by a single edge. See Figure~\ref{fig:displayGraph}. 


 has  nodes and edges, and can be constructed in  time.  By our assumption that all the trees in  are fully and singularly labeled,
there is a bijection between the labels in  and the nodes of .  Thus, from this point forward, we refer to the nodes of  by their labels.
It is easy to see that if  is not connected, then  decomposes into label-disjoint sub-profiles, and that  is compatible if and only if each sub-profile is compatible.  Thus, we shall assume, without loss of generality, that  is connected. 

\vspace{-1.5\parsep}

\paragraph{Positions.} A \emph{position} (for ) is a vector , where , for each .  Since labels may be shared among trees, we may have , for  with .   
For each , let , and let .  


A position  is \emph{valid} if, for each , 
\vspace{-0.1cm}
\begin{enumerate}[(V1)]
\vspace{-0.5\parskip}
 \itemsep1pt \parskip0pt \parsep0pt
\item\label{item:v1}
if , then the elements of  are siblings in  and
\item\label{item:v2}
.
\end{enumerate}
\vspace{-1\parsep}

\begin{lemma}\label{lem:V2}
For any valid position , .
\end{lemma}
\begin{proof}
By (V\ref{item:v2}), we have that  and  are isomorphic, for each . The lemma then follows from the definition of .
\end{proof}

For any valid position ,  denotes the subgraph of  induced by .

\begin{observation}\label{obs:update1}
For any valid position ,  is the subgraph of  obtained by deleting all labels in , along with all incident edges.
\end{observation}

A valid position of special interest to us is , where 
, for each .  That is,  is a singleton containing only the label of .  Thus, in Figure \ref{fig:displayGraph}, .
It is straightforward to verify that  is indeed valid, that , and that .  

\vspace{-1.5\parsep}

\paragraph{Semi-universal labels.} Let  be a valid position, and let  be a label in .  Then,  is \emph{semi-universal in } if  , for every  such that .
It can be verified that in Figure \ref{fig:displayGraph}, labels  and  are semi-universal in , but  is not, since  is in both  and , but .  

The term ``semi-universal'', borrowed from Pe'er et al.\ \cite{PeerShamirSharan04}, derives from the following fact.
Suppose that  is ancestrally compatible, that  is a tree that ancestrally displays , and that  is a semi-universal label for some valid position .  Then, as we shall see,  must label the root  of a subtree of  that contains all the descendants of  in , for every  such that .  The qualifier ``semi'' is because this subtree may also contain labels that do not descend from  in any input tree, but descend from some other semi-universal label  in  instead. In this case,  also labels .  This property of semi-universal labels is exploited in both our ancestral compatibility algorithm and its proof of correctness (see Section \ref{sec:testAC}).

For each label , let  denote the number of input trees that contain label .  We can obtain  for every  in  time during the construction of .   

\begin{lemma}\label{lem:semiU}
Let  be a valid position.  Then, label  is semi-universal in  if the cardinality of the set  equals .
\end{lemma}
\begin{proof}
By definition, , for every . Since , the lemma follows.
\end{proof}

\vspace{-1.5\parsep}

\paragraph{Successor positions.} 
For every  and every , let  denote the set of children of  in .  For a subset  of , let .  
Let  be a valid position, and  be the set of semi-universal labels in .  The \emph{successor of  with respect to } is the position  defined as follows.  For each  and each , if , then ; otherwise, .  

In Figure \ref{fig:displayGraph}, the set of semi-universal labels in  is .  Since  and , the successor of  is .

\begin{observation}\label{obs:update2}
Let  be a valid position, and let  be the successor of  with respect to the set  of semi-universal labels in .  Then,  can be obtained from  by doing the following for each : (1) for each  such that , delete all edges between  and ; (2) delete .
\end{observation}

Let  be a valid position, and  be a subset of .  Then,  denotes the position .
In Figure \ref{fig:displayGraph}, the components of , where  is the successor of , are  and .  Thus,  and .  We have the following result.

\begin{lemma}\label{lm:childOfU}
Let  be a valid position, and  be the set of all semi-universal labels in .  Let  be the successor of  with respect to , and let  be the label sets of the connected components of .  Then,  is a valid position, for each . 
\end{lemma}

\begin{proof}
It suffices to argue that  satisfies conditions (V\ref{item:v1}) and  (V\ref{item:v2}).  The lemma then follows from  the fact that the connected components of  are label-disjoint.

 must satisfy condition (V\ref{item:v1}), since  does. Suppose .  Then, for each  such that ,  and .  Thus, since (V\ref{item:v2}) holds for , it also holds for .
\end{proof}


\section{Testing Ancestral Compatibility}\label{sec:testAC}

\SLBuild\ (Algorithm \ref{alg:SLBuild}) is our algorithm for testing compatibility of semi-labeled trees.  Its argument, , is a valid position in  such that  is connected.  Line \ref{alg:findSemi} computes the set  of semi-universal labels in .  If  is empty, then, as argued in Theorem \ref{thm:buildCorrect} below,  is incompatible, and, thus, so is .  This fact is reported in Line \ref{alg:S0emptyIncompat}.  Line \ref{alg:S0singleton} checks if  contains exactly one label , with no proper descendants.  If so, by the connectivity assumption,  must be the only element in .  Therefore, Line \ref{alg:S0singletonReturn} simply returns the tree with a single node, labeled . Line \ref{alg:updateU} updates , replacing it by its successor with respect to .  Let  be the connected components of  after updating .
By Lemma \ref{lm:childOfU},  is a valid position, for each . 
Lines \ref{alg:connected}--\ref{alg:recurseEnd} recursively invoke  on   for each , to determine if there is a tree  that ancestrally displays .  If any subproblem is incompatible, Line \ref{alg:recurseEnd} reports that  is incompatible.  Otherwise, Lines \ref{alg:rU}--\ref{alg:finalReturn} assemble the s into a single tree that displays , whose root is labeled by the semi-universal labels in the set  of Line \ref{alg:findSemi}.

\begin{algorithm}[t]
\SetAlgoLined
\SetNoFillComment
\DontPrintSemicolon
\KwIn{A valid position  for  such that  is connected.}
\KwOut{A semi-labeled tree that ancestrally displays , if  is ancestrally compatible; \texttt{incompatible} otherwise.
}
Let  \label{alg:findSemi} \;
\If{\label{alg:S0empty}}
{
	\Return \incompatible\label{alg:S0emptyIncompat}\;
}
\If{ and the single element, , of  has no proper descendants\label{alg:S0singleton}}
{
	\Return the tree consisting of exactly one node, whose label set is \label{alg:S0singletonReturn}
}
Replace  by the successor of  with respect to .\label{alg:updateU} \; 


Let  be the connected components of  \label{alg:connected}

\ForEach{ \label{alg:recurseBegin}}
{
	Let \; \label{alg:recurse}
\If{ is not a tree}
	{
		\Return \incompatible \label{alg:recurseEnd}
	}
}
Create a node , whose label set is  \label{alg:rU}\;
\Return the tree with root  and subtrees   \label{alg:finalReturn}\;
\caption{\SLBuild}\label{alg:SLBuild}
\end{algorithm}

Next, we argue the correctness of .



\begin{theorem}\label{thm:buildCorrect}
Let  be a profile and let , where, for each , .  Then, 
returns either
(i) a semi-labeled tree  that ancestrally displays , if  is ancestrally compatible, or (ii) \texttt{incompatible} otherwise.
\end{theorem}

\begin{proof}
(i) Suppose that  outputs a semi-labeled tree .  We prove that  ancestrally displays . By Lemma \ref{lm:DN}, it suffices to show that  and  , for each .

Consider any .  Then,  has a child  in  such that .  There must be a recursive call to , for some valid position , where  is the set  of semi-universal labels obtained in Line \ref{alg:findSemi}.  By Observation \ref{obs:update2}, label , and thus , both lie in one of the connected components of the graph obtained by deleting all labels in , including , and their incident edges from . It now follows from the construction of  that .  Thus, .

Now, consider any .  Let  be the lowest common ancestor of  and  in  and let  be the label of . Then,  has a pair of children,  and  say, in  such that , and . Because  returns a tree, there are recursive calls  and  for valid positions  and  such that  is semi-universal for  and  is semi-universal for . We must have ; otherwise, , and, thus, neither  nor  is semi-universal, a contradiction. Further, it follows from the construction of  that we must have .  Hence, , and, therefore, .

(ii) Asssume, by way of contradiction, that  returns \texttt{incompatible}, but that  is ancestrally compatible.  By assumption, there exists a semi-labeled  tree  that ancestrally displays .  Since  returns  \texttt{incompatible}, there is a recursive call to  for some valid position  such that  has no semi-universal label, and the set  of Line \ref{alg:findSemi} is empty. 


By Lemma~\ref{lm:compatSubprofile},  ancestrally displays .  Thus, by Lemma \ref{lem:V2},  ancestrally displays , for every .  Let
 be any label in the label set of the root of .  Then, for each  such that ,  must be the label of the root of .
Thus, for each such , .  Hence,  is semi-universal in , a contradiction.
\end{proof}

\section{Implementation}\label{sec:implementation}

Here we describe an efficient implementation of .  We focus on two key aspects: finding semi-universal labels in Line \ref{alg:findSemi}, and updating  and  in Lines \ref{alg:updateU} and \ref{alg:connected}.  

By Observation \ref{obs:update1}, at each recursive call,  deals with a graph obtained from  through edge and node deletions.  To handle these deletions efficiently, we represent  using the dynamic graph connectivity data structure of  Holm et al.\ \cite{HolmLichtenbergThorup:2001}, which we refer to as \emph{HDT}.  HDT allows us to maintain the list of nodes in each component, as well as the number of these nodes so that, if we start with no edges in a graph with  nodes, the amortized cost of each update is .  Since  has  nodes, each update takes  time.  
The total number of edge and node deletions performed by  --- including all deletions in the recursive calls --- is at most the total number of edges and nodes in , which is .  HDT allows us to maintain connectivity information throughout the entire algorithm in  time.

As deletions are performed on ,  maintains three data fields for each connected component  that is created: , , and .  It also maintains a field , for each .  
\vspace{-0.1cm}
\begin{enumerate}
\vspace{-0.5\parskip}
 \itemsep1pt \parskip0pt \parsep0pt
\item
 equals .
\item
 is a map from a set  to a set of nonempty subsets of .  For each ,  denotes the set associated with .
\item
 equals the cardinality of the set
. (Recall that  is the number of input trees that contain .)
\item
 is a set containing all labels  such that .   
\end{enumerate}
\vspace{-0.1cm}
Informally, each set  corresponds to a non-empty ;  corresponds to the semi-universal labels in .  Next, we formalize these ideas.

At the start of the execution of  for any valid position ,  has a single connected component, .  Our implementation maintains the following invariant. 
\begin{description}\item[INV:]
At the beginning of the execution of ,  for each  such that , and  is undefined for each  such that .
\end{description}
Thus,  equals the number of indices  such that .  Along with Lemma \ref{lem:semiU}, INV implies that, at the beginning of the execution of ,  contains precisely the semi-universal labels of .
Thus, the set  of line \ref{alg:findSemi} of  can be retrieved in  time.

To establish INV for the initial valid position , we proceed as follows.  By assumption,  has a single connected component, .  
Since  equals , we initialize data fields 1--4 for  during the construction of . 
 is simply . For each ,  is , where  is the label of the root of .  We initialize the \cnt\ fields as follows.  
First, set  to  for all .  Then,  iterate through each , incrementing  by one if .  Finally,  consists of all  such that .  All data fields can be initialized in  time.


We now focus on Lines \ref{alg:updateU} and \ref{alg:connected} of . By Observation \ref{obs:update2}, we can update  and  jointly as follows. We use a temporary variable .  Prior to executing Line \ref{alg:updateU}, we set .
Then, we successively consider each label , and perform two steps: (i) initialize data fields 1--4 in preparation for the deletion of  and (ii) delete from  the edges incident on  and then  itself, updating data fields 1--4 as necessary, to maintain INV.  After these steps are executed,  will equal  for the new set  created by Line \ref{alg:updateU}.  Steps (i) and (ii) are done by  (Algorithm \ref{alg:initMarks}) and  (Algorithm \ref{alg:delLabel}), respectively. 

Lines \ref{alg:delSemi}--\ref{alg:addPairMap} of  initialize  and  to reflect the fact that label  is leaving , for each  such that , to be replaced by its children in , and will no longer be semi-universal.  Lines \ref{alg:initSingleton}--\ref{alg:forAddAlphaSemi} are needed to update certain  fields due to the possibility that singleton sets  may be created in the preceding steps.  The number of operations on  performed by  is ; i.e., it is proportional to the total number of children of  in all the input trees.  Since  is considered only once, the total number of operations on  fields of the various sets  considered over the entire execution of  is .  The number of updates of  done by  is at most ; the total over all  considered by  over its entire execution is .

\begin{algorithm}\SetAlgoLined\SetNoFillComment

\DontPrintSemicolon
Delete  from  \label{alg:delSemi}\;
	\ForEach { such that \label{alg:forEachIContainingL}}
	{
		Delete  \;
		\ForEach {\label{alg:forEachAlpha}}
		{
			Add  to  \label{alg:addPairMap} \; 
		}
		\If{ is a singleton\label{alg:initSingleton}}
		{
			Let  be the single element in  \;
			Set  \;
			\lIf{}
			{
				add  to \label{alg:forAddAlphaSemi}
			}
		}
	}

\caption{\InitLists}\label{alg:initMarks}
\end{algorithm}

 begins by consulting HDT to identify the connected component  that currently contains .  The loop in Lines \ref{alg:forScanEdges}--\ref{alg:endForScanEdges} successively deletes each edge between  and a child  of , updating the appropriate data fields for the resulting connected components.  Line \ref{alg:testConn} queries the HDT data structure to determine whether deleting  splits  into two components. If  remains connected, no updates are needed --- the \textbf{continue} statement skips the rest of the current iteration and proceeds directly to the next.  Otherwise,  is split into two parts  and .   uses a weighted version of the technique of scanning the smaller component \cite{EvenShiloach:1981}.  Line \ref{alg:smallerWeight} identifies which of the two components has the smaller \WEIGHT\ field; without loss of generality, it assumes that .  Lines \ref{alg:delInitY1} and \ref{alg:delInitY2} initialize  and  to \NULL\ and  and  to the corresponding fields of .   Lines \ref{alg:forBetaY1}--\ref{alg:addToJ}, scan each label  in , from  to , for every  such that .
Set , updated in Line \ref{alg:addToJ}, keeps track of the indices  such that  and  are modified.  Lines \ref{alg:forUpdateSemi}--\ref{alg:endForScanEdges} iterate through  to determine if any new singleton sets were created in either  or .  
This operation requires at most one update in each of  and ; each update takes  time.   After all edges incident on  are deleted,  itself is deleted (Line \ref{alg:delEll}).

The preceding description of  omits the updating of the  fields of the connected components created by an edge deletion. This is done before Line \ref{alg:smallerWeight}, by (again) using the technique of scanning the smaller component.  We consult HDT to determine which of  and  has fewer labels.  Assuming, without loss of generality, that , compute  in a sequential scan of .  Then, .


\begin{algorithm}[t]
\SetAlgoLined\SetNoFillComment

\DontPrintSemicolon
Let  be the connected component of  that contains  \label{alg:findY}\;
	\ForEach {\label{alg:forScanEdges}}
	{
Delete edge  from  \label{alg:deleteEdge}\;
		\lIf{ remains connected\label{alg:testConn}}{\continue}
		Let  be the connected components of ; assume that  \label{alg:smallerWeight} \;
		Let  and  \label{alg:delInitY1}\;
		Let  and  \label{alg:delInitY2}\;
		Let  \;
		\ForEach {\label{alg:forBetaY1}}
		{
			\ForEach{ such that }
			{
Move  from  to  \label{alg:MoveBeta} \;
					 \label{alg:addToJ}
}
		}
		\ForEach {\label{alg:forUpdateSemi}}
		{
			\ForEach{}
			{
				\If{}
				{
					Delete 
				}
				\ElseIf{ is a singleton}
				{
					Let  be the single element in  \;
					 \;
					\lIf{}
					{
						add  to  \label{alg:endForScanEdges}
					}
				}
			}
		}
	}
	Delete  from  \label{alg:delEll}
\caption{}\label{alg:delLabel}
\end{algorithm}

Let us track the number of operations on  fields in Lines \ref{alg:forBetaY1}--\ref{alg:addToJ} of  that can be attributed to some specific label  over the entire execution of .  
Each execution of Lines \ref{alg:forBetaY1}--\ref{alg:addToJ} for  performs  operations on  fields.
Let  be the weight of the connected component containing  at the beginning of the loop of Lines \ref{alg:forBetaY1}--\ref{alg:addToJ}, at the th time that  is considered in those lines; thus, .  Then, .  The reason is that we only consider  if (i)  is contained in one of the two components that result from
deleting an edge in Line \ref{alg:deleteEdge} and (ii) the component containing  has the smaller weight of the two components.  Thus, the number of times  is considered in Lines \ref{alg:forBetaY1}--\ref{alg:addToJ}  over the entire execution of  is , which is , since . Therefore, the total number of updates of  fields over all labels is , which is . 
It can be verified that the number of updates to \cnt\ and \SEMI\ fields is also . 
A similar analysis shows that the total time to update  fields over all edge deletions performed by   is . 

To summarize, the work done by  consists of three parts: (i) initialization, (ii) maintaining connected components, and (iii) maintaining the \WEIGHT, \MAP, and \SEMI, and fields for each connected component, as well as  for each label . Part (i) takes  time. Part (ii) involves  edge and node deletions on the HDT data structure, at an amortized cost of  per deletion. Part (iii) requires a total of  updates to the various fields.  Using data structures that take logarithmic time per update, leads to our main result.  


\begin{theorem}\label{thm:SLBuildA}
\SLBuild\ can be implemented so that \SLBuild runs in  time.
\end{theorem}

\section{Discussion\label{sec:discussion}}

Like our earlier algorithm for compatibility of ordinary phylogenetic trees, the more general algorithm presented here, \SLBuild, is a polylogarithmic factor away from optimality (a trivial lower bound is , the time to read the input).  \SLBuild\ has a linear-space implementation, using the results of Thorup \cite{Thorup2000}.  A question to be investigated next is the performance of the algorithm on real data.  Another important issue is integrating our algorithm into a synthesis method that deals with incompatible profiles. 




\begin{thebibliography}{10}

\bibitem{Aho81a}
A.~V. Aho, Y.~Sagiv, T.~G. Szymanski, and J.~D. Ullman.
\newblock Inferring a tree from lowest common ancestors with an application to
  the optimization of relational expressions.
\newblock {\em SIAM J. Comput.}, 10(3):405--421, 1981.

\bibitem{Baum:1992}
B.~R. Baum.
\newblock Combining trees as a way of combining data sets for phylogenetic
  inference, and the desirability of combining gene trees.
\newblock {\em Taxon}, 41:3--10, 1992.

\bibitem{BerrySemple2006}
V.~Berry and C.~Semple.
\newblock Fast computation of supertrees for compatible phylogenies with nested
  taxa.
\newblock {\em Systematic Biology}, 55(2):270--288, 2006.

\bibitem{BinindaEmonds:Nature:07}
O.~R.~P. Bininda-Emonds, M.~Cardillo, K.~E. Jones, R.~D.~E. MacPhee, R.~M.~D.
  Beck, R.~Grenyer, S.~A. Price, R.~A. Vos, J.~L. Gittleman, and A.~Purvis.
\newblock The delayed rise of present-day mammals.
\newblock {\em Nature}, 446:507--512, 2007.

\bibitem{BordewichEvansSemple2006}
M.~Bordewich, G.~Evans, and C.~Semple.
\newblock Extending the limits of supertree methods.
\newblock {\em Annals of Combinatorics}, 10:31--51, 2006.

\bibitem{BryantLagergren06}
D.~Bryant and J.~Lagergren.
\newblock Compatibility of unrooted phylogenetic trees is {FPT}.
\newblock {\em Theoretical Computer Science}, 351:296--302, 2006.

\bibitem{DanielSemple2004}
P.~Daniel and C.~Semple.
\newblock Supertree algorithms for nested taxa.
\newblock In O.~R.~P. Bininda-Emonds, editor, {\em Phylogenetic supertrees:
  Combining information to reveal the Tree of Life}, pages 151--171. Kluwer,
  Dordrecht, 2004.

\bibitem{DengFB2016}
Y.~Deng and D.~Fern\'andez-Baca.
\newblock Fast compatibility testing for rooted phylogenetic trees.
\newblock In {\em Proceedings of 27th Annual Symposium on Combinatorial Pattern
  Matching}, to appear.

\bibitem{EvenShiloach:1981}
S.~Even and Y.~Shiloach.
\newblock An on-line edge-deletion problem.
\newblock {\em J. ACM}, 28(1):1--4, Jan. 1981.

\bibitem{HenzingerKingWarnow99}
M.~R. Henzinger, V.~King, and T.~Warnow.
\newblock Constructing a tree from homeomorphic subtrees, with applications to
  computational evolutionary biology.
\newblock {\em Algorithmica}, 24:1--13, 1999.

\bibitem{HinchliffPNAS2015}
C.~E. Hinchliff, S.~A. Smith, J.~F. Allman, J.~G. Burleigh, R.~Chaudhary, L.~M.
  Coghill, K.~A. Crandall, J.~Deng, B.~T. Drew, R.~Gazis, K.~Gude, D.~S.
  Hibbett, L.~A. Katz, H.~D. Laughinghouse~IV, E.~J. McTavish, P.~E. Midford,
  C.~L. Owen, R.~H. Reed, J.~A. Reesk, D.~E. Soltis, T.~Williams, and K.~A.
  Cranston.
\newblock Synthesis of phylogeny and taxonomy into a comprehensive tree of
  life.
\newblock {\em Proceedings of the National Academy of Sciences},
  112(41):12764--12769, 2015.

\bibitem{HolmLichtenbergThorup:2001}
J.~Holm, K.~de~Lichtenberg, and M.~Thorup.
\newblock Poly-logarithmic deterministic fully-dynamic algorithms for
  connectivity, minimum spanning tree, 2-edge, and biconnectivity.
\newblock {\em J. ACM}, 48(4):723--760, July 2001.

\bibitem{Page2004}
R.~M. Page.
\newblock Taxonomy, supertrees, and the tree of life.
\newblock In O.~R.~P. Bininda-Emonds, editor, {\em Phylogenetic supertrees:
  Combining information to reveal the Tree of Life}, pages 247--265. Kluwer,
  Dordrecht, 2004.

\bibitem{PeerShamirSharan04}
I.~Pe'er, T.~Pupko, R.~Shamir, and R.~Sharan.
\newblock Incomplete directed perfect phylogeny.
\newblock {\em {SIAM} J. Comput.}, 33(3):590--607, 2004.

\bibitem{Ragan:1992}
M.~A. Ragan.
\newblock Phylogenetic inference based on matrix representation of trees.
\newblock {\em Molecular Phylogenetics and Evolution}, 1:53--58, 1992.

\bibitem{Sanderson:2008}
M.~J. Sanderson.
\newblock Phylogenetic signal in the eukaryotic tree of life.
\newblock {\em Science}, 321(5885):121--123, 2008.

\bibitem{NCBI2009}
E.~W. {Sayers et al.}
\newblock Database resources of the {National Center for Biotechnology
  Information}.
\newblock {\em Nucleic Acids Research}, 37(Database issue):D5--D15, 2009.

\bibitem{SempleSteel03}
C.~Semple and M.~Steel.
\newblock {\em Phylogenetics}.
\newblock Oxford Lecture Series in Mathematics. Oxford University Press,
  Oxford, 2003.

\bibitem{Smith:PloSCB:2013}
S.~A. Smith, J.~W. Brown, and C.~E. Hinchliff.
\newblock Analyzing and synthesizing phylogenies using tree alignment graphs.
\newblock {\em {PLoS Computational Biology}}, 9(9):e1003223, 2013.

\bibitem{Steel92}
M.~A. Steel.
\newblock The complexity of reconstructing trees from qualitative characters
  and subtrees.
\newblock {\em J. Classification}, 9:91--116, 1992.

\bibitem{APG2016}
{The Angiosperm Phylogeny Group}.
\newblock An update of the {Angiosperm Phylogeny Group} classification for the
  orders and families of flowering plants: {APG IV}.
\newblock {\em Botanical Journal of the Linnean Society}, 181:1--20, 2016.

\bibitem{Thorup2000}
M.~Thorup.
\newblock Near-optimal fully-dynamic graph connectivity.
\newblock In {\em Proceedings of the 32nd Annual ACM Symposium on Theory of
  Computing}, pages 343--350. ACM, 2000.

\end{thebibliography}

\end{document}
