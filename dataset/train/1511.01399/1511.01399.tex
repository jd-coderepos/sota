\documentclass[authoryear,sort&compress,9pt,twocolumn,nocopyrightspace]{sigplanconf}





\usepackage{anyfontsize} \usepackage{amsmath}     \usepackage{amsthm}      \usepackage{amssymb}     \usepackage{amsbsy}      \usepackage{semantic}    \usepackage{stmaryrd}   \usepackage{mathpartir}  \usepackage{color}
\usepackage{braket}      \usepackage{mathtools}   \usepackage{thmtools}    \usepackage{marvosym} \usepackage{wasysym}     \usepackage{balance}     \usepackage{xspace}
\usepackage{mathrsfs} \usepackage{wasysym}
\usepackage{proof}
\usepackage{yhmath}
\usepackage{rotating}

\newcommand{\mynote}[2]
    {{\color{red} \fbox{\bfseries\sffamily\scriptsize#1}
    {\small\textsf{\emph{#2}}}}~}

\newcommand{\ron}[1]{\mynote{RG}{#1}}
\newcommand{\et}[1]{\mynote{ET}{#1}}
\newcommand{\mt}[1]{\mynote{MT}{#1}}

\newenvironment{block}[1][t]
  {\begin{array}[#1]{@{}l@{}}}
  {\end{array}}

\definecolor{lightgray}{gray}{0.90}
\newcommand{\Gbox}[1]{\colorbox{lightgray}{}}




\declaretheorem{theorem}
\declaretheorem[sibling=theorem]{lemma}
\declaretheorem[sibling=theorem]{proposition}
\declaretheorem[sibling=theorem]{corollary}
\declaretheorem{definition}
\declaretheorem[style=remark,numbered=no]{case}
\declaretheorem[style=remark,numbered=no]{notation}





\newcommand{\sbrack}[1]{|[ #1 |]} \newcommand{\Sbrack}[1]{\left[\!\!\left[ #1 \right]\!\!\right]} 

\mathlig{[]}{\square}
\mathlig{|-s}{\vdash^{\!\forall}}
\mathlig{|-}{\vdash}
\mathlig{|}{\mid} \mathlig{@>}{\leadsto} 


\reservestyle{\oblang}{\mathsf}
\oblang{if[if\;],then[\;then\;],else[\;else\;],let[let\;],in[\;in\;]}



\newcommand{\Z}{\ensuremath{\mathbb{Z}}} \newcommand{\Pow}{\ensuremath{\mathcal{P}}} \newcommand{\Int}{\mathsf{Int}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\oblset}[1]{\textsc{#1}}
\newcommand{\Label}{\oblset{Label}}
\newcommand{\Type}{\oblset{Type}}
\newcommand{\Var}{\oblset{Var}}
\newcommand{\Value}{\oblset{Value}}
\newcommand{\Term}{\oblset{Term}}
\newcommand{\TTerm}{\oblset{TTerm}}
\newcommand{\XTerm}{\oblset{XTerm}}
\newcommand{\GTerm}{\oblset{GTerm}}
\newcommand{\SType}{\oblset{SType}}
\newcommand{\GType}{\oblset{GType}}
\newcommand{\GSType}{\oblset{GSType}}
\newcommand{\GLabel}{\oblset{GLabel}}
\newcommand{\setof}[1]{\set{\overline{#1}}}

\newcommand{\fff}{\textsf{false}}
\newcommand{\ff}{\fff} \newcommand{\ttt}{\textsf{true}}
\newcommand{\ite}[3]{\<if> #1 \<then> #2 \<else> #3}
\newcommand{\lsec}{\xspace}
\newcommand{\lgsec}{\xspace}

\newcommand{\dom}{\mathit{dom}}
\newcommand{\cod}{\mathit{cod}}
\newcommand{\cmb}{\mathit{equate}}
\newcommand{\valid}{\mathit{valid}}
\newcommand{\tlc}{\ensuremath{\collecting{\mathit{tlc}}}}
\newcommand{\gprec}{\sqsubseteq} \newcommand{\sub}{<:}
\newcommand{\nsub}{<:_n}
\newcommand{\csub}{\lesssim}
\newcommand{\clsub}{\mathrel{\collecting{<:}}}
\newcommand{\ccsub}{\mathrel{\consistent{<:}}}
\newcommand{\join}{\sqcup}
\newcommand{\setdiff}{\mathrel{\backslash}}
\newcommand{\meet}{\sqcap}
\newcommand{\union}{\cup}
\newcommand{\setint}{\cap}
\newcommand{\finto}{\stackrel{\text{fin}}{\rightharpoonup}}\newcommand{\pfun}{\rightharpoonup}

\newcommand{\?}{\textsf{\upshape ?}} \newcommand{\consistent}[1]{\widetilde{#1}}
\newcommand{\collecting}[1]{\wideparen{#1}}
\newcommand{\cT}{\consistent{T}} \newcommand{\clT}{\collecting{T}}\newcommand{\ct}{\consistent{t}} \newcommand{\gvl}{\consistent{v}} 

\newcommand{\carrow}{\;\collecting{\rightarrow}\;}
\newcommand{\clab}{\collecting{label}}
\newcommand{\ctype}{\collecting{type}}
\newcommand{\ccod}{\consistent{\cod}}
\newcommand{\cdom}{\consistent{\dom}}
\newcommand{\ccmb}{\consistent{\cmb}}
\newcommand{\clcmb}{\collecting{\cmb}}
\newcommand{\clcod}{\collecting{\cod}}
\newcommand{\cldom}{\collecting{\dom}}
\newcommand{\cP}{\consistent{P}}
\newcommand{\clpred}{\collecting{P}}
\newcommand{\cpred}{\cP}
\newcommand{\clfun}{\collecting{F}}
\newcommand{\cfun}{\consistent{F}}
\newcommand{\ceq}{\consistent{=}}
\newcommand{\cleq}{\collecting{=}}

\newcommand{\subjoin}{\mathbin{\begin{turn}{90}\end{turn}}}
\newcommand{\submeet}{\mathbin{\begin{turn}{-90}\end{turn}}}
\newcommand{\proj}{\mathit{proj}}
\newcommand{\cproj}{\consistent{\proj}}
\newcommand{\cssubmeet}{\consistent{\submeet}}
\newcommand{\cssubjoin}{\consistent{\subjoin}}

\newcommand{\ltop}{\textsf{H}}
\newcommand{\lbot}{\textsf{L}}
\newcommand{\lx}{\ell} \newcommand{\ul}{\?}\newcommand{\clx}{{\tilde{\lx}}} \newcommand{\cll}{\collecting{\lx}} \newcommand{\cS}{{\consistent{S}}} \newcommand{\clS}{\collecting{S}}\newcommand{\subl}{\preccurlyeq}\newcommand{\csubl}{\;\consistent{\subl}\;}
\newcommand{\ljoincore}{\begin{turn}{90}\end{turn}}
\newcommand{\lmeetcore}{\begin{turn}{270}\end{turn}}
\newcommand{\ljoin}{\mathbin{\ljoincore}}
\newcommand{\lmeet}{\mathbin{\lmeetcore}}
\newcommand{\cjoin}{\mathbin{\consistent{\ljoincore}}}
\newcommand{\cmeet}{\mathbin{\consistent{\lmeetcore}}}
\newcommand{\cljoin}{\cjoin}
\newcommand{\clmeet}{\cmeet}
\newcommand{\gammal}{\gamma_\lx}
\newcommand{\alphal}{\alpha_\lx}
\newcommand{\gammas}{\gamma_S}
\newcommand{\gammat}{\gamma_T}
\newcommand{\alphas}{\alpha_S}
\newcommand{\alphat}{\alpha_T}
\newcommand{\slabel}{\mathit{label}}

\newcommand{\interior}[1]{\mathcal{I}_{#1}}
\newcommand{\Ev}[1]{\oblset{Ev}^{#1}}
\newcommand{\Isub}{\interior{<:}}
\newcommand{\trans}[1]{\circ^{#1}}
\renewcommand{\merge}[1]{\triangle^{#1}}

\newcommand{\rec}[1]{[#1]}
\newcommand{\VarT}[1]{\oblset{Var}_{#1}}
\newcommand{\TermT}[1]{\oblset{Term}_{#1}}
\newcommand{\injto}{\stackrel{\!\textrm{i\;f}}{\rightharpoonup}}
\newcommand{\EvTerm}{\oblset{EvTerm}}
\newcommand{\EvValue}{\oblset{EvValue}}
\newcommand{\SimpleValue}{\oblset{SimpleValue}}
\newcommand{\EvFrame}{\oblset{EvFrame}}
\newcommand{\TmFrame}{\oblset{TmFrame}}
\newcommand{\pr}[1]{\braket{{#1}}}
\newcommand{\cast}[2]{\evcast{\evpr{#1}}{#2}}
\newcommand{\error}{\textup{\textbf{error}}}
\newcommand{\evt}{\mathit{et}}
\newcommand{\evv}{\mathit{ev}}
\newcommand{\red}{\longmapsto}
\newcommand{\iapp}[1]{\mathbin{@^{#1}}}
\newcommand{\invcod}{\mathit{icod}}
\newcommand{\invdom}{\mathit{idom}}
\newcommand{\invproj}{\mathit{iproj}}

\newcommand{\sarray}[1]{
{\begin{array}[c]{@{}l@{}} #1
  \end{array}}}


\newcommand{\ie}{\emph{i.e.}\xspace}
\newcommand{\etal}{\emph{et al.}\xspace}
\newcommand{\eg}{\emph{e.g.}\xspace}

\newsavebox{\cTsave}
\savebox{\cTsave}{}
\newsavebox{\clTsave}
\savebox{\clTsave}{}

\newcommand{\DTerm}{\oblset{DTerm}}
\newcommand{\dyn}[1]{\check{#1}}
\newcommand{\dt}{\dyn{t}}

\newcommand{\ev}{\varepsilon}
\newcommand{\evcast}[2]{#1#2}
\newcommand{\evlangle}{\langle}
\newcommand{\evrangle}{\rangle}
\newcommand{\evpr}[1]{\braket{#1}}

\newcommand{\STFLsub}{\text{STFL}_{<:}}
\newcommand{\GTFLcsub}{\text{GTFL}_{\csub}}
 \usepackage{tikz-cd}


\newcommand{\ncsubl}{\not \hspace{-2mm}\csubl}
\newcommand{\Evidence}{\oblset{Evidence}}
\newcommand{\lobs}{\zeta}
\newcommand{\rel}{\approx_{\lobs}}
\newcommand{\rcomp}[1]{\mathcal{C}(#1)} 
\newcommand{\bval}[1]{bval(#1)}
\newcommand{\subst}{\sigma}
\newcommand{\itm}[1]{{t^{\cS_{#1}}}}
\renewcommand{\cast}[2]{#1#2}

\newcommand{\D}{\mathcal{D}}
\newcommand{\E}{\mathcal{E}}



\begin{document}


\title{Deriving a Simple Gradual Security Language}

\authorinfo{Ronald Garcia}{
Software Practices Lab \\
Department of Computer Science\\
University of British Columbia}
{rxg@cs.ubc.ca}
\authorinfo{\'Eric Tanter}
{PLEIAD Laboratory\\
Computer Science Department (DCC)\\
University of Chile}
{etanter@dcc.uchile.cl}

\maketitle

\begin{abstract}
  Abstracting Gradual Typing (AGT) is an approach to systematically deriving
  gradual counterparts to static type disciplines~\cite{garciaAl:popl2016}. The
  approach consists of defining the semantics of gradual types by interpreting
  them as sets of static types, and then defining an optimal abstraction back
  to gradual types. These operations are used to lift the static discipline to
  the gradual setting. The runtime semantics of the gradual language
  then arises as reductions on gradual typing derivations.

  To demonstrate the flexibility of AGT, we gradualize \linebreak
  \lsec~\cite{zdancewic},
  the prototypical security-typed language, with respect to only security
  labels rather than entire types, yielding a type system that ranges gradually
  from simply-typed to securely-typed. We establish noninterference for the
  gradual language, called \lgsec, using Zdancewic's logical relation proof
  method.  Whereas prior work presents gradual security \emph{cast} languages,
  which require explicit security casts, this work yields the first gradual
  security \emph{source} language, which requires no explicit casts.
\end{abstract}


\section{Introduction}

Gradual typing has often been viewed as a means to combine the agility benefits
of \emph{dynamic languages}, like Python and Ruby with the
reliability benefits of \emph{static languages} like OCaml and
Scala.  This paper, in a line of work on the foundations of gradual
typing, explores the idea that static and dynamic are merely relative notions.

This relativistic view of gradual typing is not new.  Work on gradual
information flow security by \citet{disney11flow} and
\citet{fennellThiemann:csf2013} develop languages where only information-flow
security properties are subject to a mix of dynamic and static checking.
\citet{banados14effects} develop a language where only computational effect
capabilities are gradualized.  In each of these cases, the ``fully-dynamic''
corner of the gradual language is not dynamic at all by typical standards, but
rather simply typed.  However, those languages support seamless migration
toward a \emph{more precise} typing discipline that subsumes simple typing.

To explore this notion, we revisit the idea of gradual information-flow
security.  Our tool of inquiry is a new approach to the foundations of gradual
typing called Abstracting Gradual Typing (AGT) \cite{garciaAl:popl2016}.  AGT
is a technique for systematically deriving gradual type systems by interpreting
gradual types as sets of static types.  That work developed a traditional
gradual type system with subtyping, introducing an \emph{unknown type} \?. But
AGT was directly inspired by~\citet{banados14effects}, who used an early
version of these techniques to gradualize only effects. However, they develop
the dynamic semantics of gradual effects in the traditional ad hoc fashion.
Here, we bring the approach full circle, deriving a complete static and dynamic
semantics for a gradual counterpart to the \lsec language of \citet{zdancewic}.

In their simplest form, security-typed languages require values and types to be
annotated with security labels, indicating their confidentiality level.  The
security type system guarantees \emph{noninterference}, \ie, that
more-confidential information does not alter the less-confidential results of
any expression.

We prove that the resulting gradual language, called \lgsec, is not only
\emph{safe} in that it never unexpectedly crashes, but that it is \emph{sound}
in that it honours the information-flow invariants of the precisely typed
terms.  The former property is unsurprising, since even the most imprecisely
typed program still maintains the simple typing discipline, which is enough to
establish the safety of the operational semantics.  The soundness of the
language with respect to the security type discipline, \ie, that basic
information flow properties are respected, is the key property.

The prior work in gradual security typing developed gradual \emph{cast
  languages}, which require explicit type casts to connect imprecisely typed
terms with precisely typed terms.  This is akin to the intermediate languages
of traditional gradually-typed languages.  This work presents the first gradual
\emph{source} language, where no explicit casts are needed: they are introduced
by the language semantics.  Furthermore, following the AGT approach, the
runtime semantics are induced by the proof of type safety for \lsec, yielding a
crisp connection to that precise static type discipline.

As with the original work on AGT, we can straightforwardly establish proper
adaptations of the refined criteria for gradually typed languages.  We will do
so in this ongoing work.

Ultimately this work views gradual typing as a theory of \emph{imprecise
  typing} rather than dynamic checking.  Indeed dynamic checking is an
inevitable consequence of this approach, but the focus here is on the types and
their meaning.  We believe that this broader view of gradual typing can widen
the reach of gradual typing beyond its current niche of interest among
dynamic language enthusiasts.  Furthermore, we believe that AGT generalizes the
foundations of gradual typing enough to support a wide variety of
gradual type disciplines.



\section{The Static Language: \lsec}


\begin{figure}[h]
\begin{small}
  3mm]
      S & ::= & \Bool_{\lx} | S ->_{\lx} S & \text{(types)} \\
      b & ::= & \ttt | \ff & \text{(Booleans)}\\
      r & ::= & b | \lambda x:S.t & \text{(raw values)}\\
      v & ::= & r_\lx & \text{(values)}\\
      t & ::= & v |  t\;t | t \oplus t | \ite{t}{t}{t} | t :: S 
      & \text{(terms)} \\
      \oplus & ::= & \land | \lor | \implies & \text{(operations)} \\
    \end{array}
  
  \begin{block}
    \subjoin : \Type \times \Type \rightharpoonup \Type \0.2em]
    \Bool_\lx \submeet \Bool_{\lx'} = \Bool_{(\lx \lmeet \lx')} \\
    (S_{11} ->_{\lx} S_{12}) \submeet (S_{21} ->_{\lx'} S_{22}) = 
    (S_{11} \subjoin S_{21}) ->_{(\lx \lmeet \lx')} (S_{12} \submeet S_{22}) \\
    S \submeet S \text{ undefined otherwise} \\
  \end{block}

\begin{array}{c}
\Bool_{\lx} \ljoin \lx' = \Bool_{(\lx \ljoin {\lx'})} \\
(S_1 ->_{\lx} S_2) \ljoin \lx' = S_1 ->_{(\lx \ljoin {\lx'})} S_2 \\
\end{array}

  \begin{array}{rcll}
    t & ::= & \ldots | t \ljoin \lx & \text{(term stamping)}\\
    f & ::= &  [] \oplus t | v \oplus [] | []\;t | v\;[] & \text{(frames)}\\
      & & \ite{[]}{t}{t} | [] \ljoin \lx & 
  \end{array}

\begin{block}
  \mbox{}_{\lx_1} \oplus \mbox{}_{\lx_2} --> 
(b_1 \;\llbracket \oplus \rrbracket\; b_2)_{(\lx_1 \ljoin \lx_2)} 
\0.8em]
\ite{\ttt_\lx}{t_1}{t_2} --> t_1 \ljoin \lx
\0.8em]
r_{\lx_1} \ljoin \lx_2 --> r_{(\lx_1 \ljoin \lx_2)}
\end{block}

\begin{array}{rcll}
\multicolumn{4}{l}{\clx \in \GLabel}\\
  \clx & ::= & \lx \;|\; \ul & \text{(gradual labels)}
\end{array}

\begin{array}{rcll}
\multicolumn{4}{l}{\cS \in \GType}\\
\cS & ::= & \Bool_{\clx} | \cS ->_{\clx} \cS & \text{(gradual types)}\\
\end{array}

  \gammal(\lx) &= \set{\lx} \\
  \gammal(\ul) &= \Label

    \alphal(\set{\lx})  &= \lx \\
    \alphal(\emptyset)  &\text{ is undefined} \\
    \alphal(\cll)  &= \;\ul \text{  otherwise}
  
\gammas(\Bool_{\clx}) &= \set{\Bool_{\lx} | \lx \in \gammal(\clx)} \\
\gammas(\cS ->_{\clx} \cS) &=
\savebox{\grr}{}
\wideparen{\usebox{\grr}}
\intertext{where}
\savebox{\grr}{}
\wideparen{\usebox{\grr}} &= 
\set{S_1 ->_{\lx} S_2 | S_i \in \gammas(\clS_i), \lx \in \cll}.

  \alphas(\set{\overline{\Bool_{\lx_i}}}) &=
  \Bool_{\alphal(\set{\overline{\lx_i}})} \1mm]
  \alphas(\clT) & \text{ is undefined otherwise}\
\end{definition}



We can only abstract {\em valid} sets of security types, \ie~in which
elements only defer by security labels.

\begin{definition}[Valid Type Sets]
\begin{mathpar} 
  \inference{}{\valid(\setof{\Bool_{\lx_i}})}

  \inference{\valid(\setof{S_{i1}}) & \valid(\setof{S_{i2}})}
  {\valid(\setof{(S_{i1} -> S_{i2})_{\lx_i}})}
  \end{mathpar}
\end{definition}



\begin{restatable}[ is Sound]{proposition}{saisound}
  \label{prop:sai-sound}
  \mbox{}\\
  If  then 
  
\end{restatable}
\begin{proof}
  By well-founded induction on  according
  to the ordering relation  defined as follows:
  
  Where  are the collecting
  liftings of the domain and codomain functions  respectively, \eg,
  

  We then consider cases on  according to the definition of .


\begin{case}[]

\end{case}

\begin{case}[]

by induction hypotheses on  and
  , and soundness of .
\end{case}
\end{proof}


\begin{restatable}[ is Optimal]{proposition}{saiopt}
  \label{prop:sai-opt}
  If  and  then 
  .
\end{restatable}
\begin{proof}
By induction on the structure of .
\begin{case}[] 
  \\
  So  for some
  . By optimality of ,
  , so
  .
\end{case}

\begin{case}[]
  \gammas(\cS_1) ->_{\gammal(\clx)} \gammas(\cS_2)
  \\
  So 
  ,
with ,\\
  , and
  .
By induction hypotheses,
   and 
  , and by
  optimality of , .
  Hence
  .
\end{case}

\end{proof}

 

\subsection{Consistent Predicates and Operators}


Following the AGT approach, we lift predicates on labels and types to
\emph{consistent} predicates on the corresponding gradual labels and gradual
types.  Consistent predicates hold if \emph{some} member of the collecting
semantics satisfies the corresponding static predicate.  We lift partial
functions to gradual partial functions, as per the standard approach in
abstract interpretation.

\begin{definition}[Consistent label ordering]
   if and only if  
  for some 
\\
\noindent Algorithmically:
\begin{mathpar}
   \inference[]{}{\? \csubl \clx}
   \and
   \inference[]{}{\clx \csubl \?}
   \and
   \inference[]{\lx_1 \subl \lx_2}{\lx_1 \csubl \lx_2}
 \end{mathpar}
\end{definition}


 \begin{definition}[Gradual label join]

\\
\noindent Algorithmically:

\end{definition}

Both gradual label stamping and gradual join of security types
are obtained by lifting their corresponding static operations:

\begin{definition}[Gradual label meet]
.
\end{definition}
\noindent Algorithmically:




We now lift subtyping to gradual security types.
\begin{definition}[Consistent subtyping]

  \end{definition}



  


 



\begin{figure}[h]

  \begin{small}
  3mm]
      \cS & ::= & \Bool_\clx | \cS ->_\clx \cS & \text{(gradual types)} \\
      b & ::= & \ttt | \ff & \text{(Booleans)}\\
      r & ::= & b | \lambda x:\cS.\ct & \text{(base values)}\\
      v & ::= & r_\lx & \text{(values)}\\
      \ct & ::= & v |  \ct\;\ct | \ct \oplus \ct | \ite{\ct}{\ct}{\ct}
      & \text{(terms)} \\
      \oplus & ::= & \land | \lor | \implies & \text{(operations)} \\
    \end{array}
  
  \begin{block}
    \cssubjoin : \GType \times \GType \rightharpoonup \GType \0.2em]
    \Bool_\clx \cssubmeet \Bool_{\clx'} = \Bool_{(\clx \lmeet \clx')} \\
    (\cS_{11} ->_{\clx} \cS_{12}) \cssubmeet (\cS_{21} ->_{\clx'} \cS_{22}) = 
    (\cS_{11} \cssubjoin \cS_{21}) ->_{(\clx \clmeet \clx')} (\cS_{12} \cssubmeet \cS_{22}) \\
    \cS \cssubmeet \cS \text{ undefined otherwise} \\
  \end{block}

    \interior{P}(\cT_1,\cT_2) = 
    \alpha^2(\set{\braket{T_1,T_2} \in 
      \gamma^2(\cT_1,\cT_2) | P(T_1,T_2)}).
  
\braket{\cS_1, \cS_{21}} \trans{<:} \braket{\cS_{22}, \cS_3} & = 
\merge{<:}(\cS_1, \cS_{21} \meet \cS_{22}, \cS_3)

\Bool_{\clx} \meet \Bool_{\clx'} &= \Bool_{\clx \meet \clx'}\\
(\cS_{11} ->_{\clx} \cS_{12}) \meet (\cS_{21} ->_{\clx'} \cS_{22}) &=
(\cS_{11} \meet \cS_{21}) ->_{\clx \meet \clx'} (\cS_{12} \meet \cS_{22})\\
\cS \meet \cS' & \text{ undefined otherwise}

  \clx \meet \? &= \? \meet \clx = \clx\\
  \lx \meet \lx &= \lx \\
  \lx \meet \lx' & \text{ undefined otherwise}
0.5em]=
      \braket{\cS_{11} ->_{\clx_1} \cS_{12},
        \cS_{31} ->_{\clx_3} \cS_{32}}
    \end{block}
  }
\end{mathpar}
with the following definition of , again calculated by
case analysis on the middle gradual label:
\begin{mathpar}
\inference{\top \csubl \clx_3}{
  \merge{\subl}(\clx_1, \top, \clx_3) = \braket{\clx_1, \top}}
\and
\inference{\clx_1 \csubl \bot}{
  \merge{\subl}(\clx_1, \bot, \clx_3) = \braket{\bot, \clx_3}}
\and
\inference{\clx_1 \csubl \clx_2 & \clx_2 \csubl \clx_3 & \clx_2
  \not\in \set{\bot,\top}}{
  \merge{\subl}(\clx_1,\clx_2, \clx_3) =
  \braket{\clx_1, \clx_3}}
\end{mathpar}


\begin{figure}[t]
\begin{small}
0.3em]
    v & ::= & u | \cast{\ev}{u} :: \cS \\
    g & ::= & [] \oplus^{\clx} \evt | \evv \oplus^{\clx} [] 
    | []\iapp{\cS}\evt | \evv\iapp{\cS}[]
    | []::\cS \\
    & | & \ite{[]}{\evt}{\evt} \\
    f & ::= & g[ \cast{\ev}{[]} ]
  \end{array}
0.5em]
\boxed{
  \begin{block}
    --> : \TermT{\cS} \times (\TermT{\cS} \union \set{\error}) \
\begin{block}
  \cast{\pr{\Bool_{\clx'_1},\Bool_{\clx''_1}}}{(b_1)_{\clx_1}} \oplus^{\clx}
  \cast{\pr{\Bool_{\clx'_2},\Bool_{\clx''_2}}}{(b_2)_{\clx_2}} -->\1.2em]
\evcast{\ev_1}{(\lambda x^{\cS_{11}}.t^{*})_{\clx_1}}
   \iapp{\cS_1 ->_\clx \cS_2}
  \evcast{\ev_2}{u}
  -->
  \1.2em]

 \<if>   \cast{\ev_1}{b_{\clx}} 
  \<then> \cast{\ev_2}{t^{\cS_2}}
  \<else> \cast{\ev_3}{t^{\cS_3}}
  --> \
\
\begin{block}
\ev_1(\cast{\ev_2}{v :: \cS}) -->_c 
\begin{cases}
    (\ev_2 \trans{<:} \ev_1){v} \\
    \error \qquad \text{if not defined}
  \end{cases}
\end{block}
0.5em]
\boxed{\red : \TermT{\cS} \times (\TermT{\cS} \union \set{\error})}

\begin{mathpar}
  \inference[(R)]{t^{\cS} --> r & r \in (\TermT{\cS} \union \set{\error})}{
    t^{\cS} \red r} 
  \and
  \inference[(R)]{\evt -->_c \evt'}{
    g[\evt] \red g[r]} 
  \and
  \inference[(Rerr)]{\evt --> _c\error}{
    g[\evt] \red \error
  }  \and
  \inference[(R)]{t^{\cS}_1 \red t^{\cS}_2}{
    f[t^{\cS}_1] \red f[t^{\cS}_2]
  }
  \and
  \inference[(Rerr)]{t^{\cS}_1 \red \error}{
    f[t^{\cS}_1] \red \error
  } 
\end{mathpar}
\end{small}
 \caption{\lgsec: Intrinsic Reduction}
  \label{fig:lgsec-dyn}
\end{figure}


The reduction rules are given in Fig.~\ref{fig:lgsec-dyn}.
The evidence inversion functions reflect the contravariance on
arguments and the need to stamp security labels on return types:
0.5em]
\invcod(\evpr{\cS'_{1} ->_{\clx'} \cS'_{2},\cS''_{1} ->_{\clx''} \cS''_{2}}) =
\evpr{\cS'_2 \cjoin \clx',\cS''_2 \cjoin \clx''} 
\end{block}

\begin{array}{rcll}
f & \triangleq & (\lambda x : {\Bool_\lbot}.x)_\lbot &
\text{a public channel}\
 does not type check, but  \emph{does}
typecheck, even though it fails at runtime.
Type checking yields the corresponding \emph{intrinsic} definitions:
1mm]

\begin{array}{rcll}
f & \triangleq & 
(\lambda x^{\Bool_\lbot}.x)_\lbot &  \text{a public channel}\1mm]
v & \triangleq &
 \ff_\ltop &\text{a private value}\\
\end{array}

\begin{array}{ll}
& (\braket{\cS_f, \cS_f}f) \; \big(\braket{\lbot,\lbot}((\braket{\cS_g,\cS_g}\Gbox{g}) \;  (\braket{\ltop,\ltop}{v})) \big) \1mm]
--> & (\braket{\cS_f, \cS_f}f) \; \big(\braket{\lbot,\lbot}(\underline{\cast{\ul,\ul}
      ([ \Gbox{(\braket{\ltop,\ltop} \trans{\sub} \braket{\ul,\ul})}
      {v  :: \ul}/x]x) :: \ul}) \big)\1mm]
=_{[t/t]t} & (\braket{\cS_f, \cS_f}f) \; \big(\braket{\lbot,\lbot}(\Gbox{\cast{\ul,\ul}
      (\underline{\braket{\ltop,\ltop}{v  :: \ul}})} :: \ul) \big)\1mm]
=_{\trans{\sub}} & (\braket{\cS_f, \cS_f}f) \; \big(\Gbox{\braket{\lbot,\lbot}(\underline{\braket{\ltop,\ltop}}{v} :: \ul) }\big)\1mm]

&\text{because }
  \braket{\ltop,\ltop} \trans{\sub} \braket{\lbot,\lbot} = 
  \merge{\sub}(\ltop, \ltop \meet \lbot, \lbot)\\
& \text{which is undefined because }  \ltop \meet \lbot \text{ is undefined.}
\end{array}

\begin{array}{rcl}
  v_1 \rel v_2 : \Bool_\clx & \iff & 
  v_i \in \TermT{\Bool_\clx} \land 
  \clx \csubl \lobs \implies \bval{v_1} = \bval{v_2}\\
  v_1 \rel v_2 : \cS_1 ->_{\clx} \cS_2 & \iff & 
  v_i \in \TermT{\cS_1 ->_{\clx} \cS_2} \land \clx \csubl \lobs \implies
  \forall \ev_1, \ev_2, \cS'_1 ->_{\clx'} \cS'_2, \text{ and }\cS''_1
                                                \text{ such that}~\0.5em]
& & \forall v'_1 \rel v'_2 : \cS''_1.~
(\evcast{\ev_1}{v_1} \iapp{\cS'_1 ->_{\clx'} \cS'_2} \evcast{\ev_2}{v'_1}) \rel 
(\evcast{\ev_1}{v_2} \iapp{\cS'_1 ->_{\clx'} \cS'_2} \evcast{\ev_2}{v'_2}) : \rcomp{\cS_2 \cljoin \clx}\\
& & \\
t_1 \rel t_2 : \rcomp{\cS} & \iff & t_i \in
                                        \TermT{\cS}~
                                        \wedge~(t_1 \red^{*} v_1
                                        \wedge t_2 \red^{*} v_2 \implies v_1
                                        \rel v_2 : \cS) 
\end{array}

t[v_1/x] \red^{*} v'_1 \wedge t[v_2/x] \red^{*} v'_2 => \bval{v'_1} = \bval{v'_2}

\subst_i(\itm{}) = (\lambda x^{\cS_1}.\subst_i(t^{\cS_2}))_\clx \in
\TermT{\cS}

\begin{array}{rcl}
 & \cast{\ev_1}{(\lambda x^{\cS_1}.\subst_1(t^{\cS_2}))_\clx}  
\; \cast{\ev_2}{v_1} & \\
\rel &
\cast{\ev_1}{(\lambda
x^{\cS_1}.\subst_2(t^{\cS_2}))_\clx}
\; \cast{\ev_2}{v_2} &
: \rcomp{\cS_2 \cljoin \clx}
\end{array}

\begin{array}{rl}
 & \cast{\ev_1}{(\lambda x^{\cS_1}.\subst_i(t^{\cS_2}))_\clx} \;
\cast{\ev'_{2i}}{u_i}\\ 
\red & \cast{\ev_r}{([\cast{\ev_a}{u_i ::
                            \cS_1}/x^{\cS_1}] \subst_i(\itm{2}))}
:: \cS_2 \cljoin \clx
\end{array}

\subst'_i = \subst_i \{ x^{\cS_1} \mapsto \cast{\ev_a}{u_i :: \cS_1} \}

\subst'_1(\itm{2}) \rel \subst'_2(\itm{2}) : \rcomp{\cS_2}

[ \cast{\ev_a}{u_1 :: \cS_1}/x^{\cS_1}] \subst_1(\itm{2}) \rel 
[ \cast{\ev_a}{u_2 :: \cS_1}/x^{\cS_1}] \subst_2(\itm{2}) : \rcomp{\cS_2}

\begin{array}{rcl}
 & \cast{\ev_r}{[ \cast{\ev_a}{u_1 :: \cS_1}/x^{\cS_1}] \subst_1(\itm{2})
  :: \cS_2 \cljoin \clx } & \\
\rel & \cast{\ev_r}{[ \cast{\ev_a}{u_2 :: \cS_1}/x^{\cS_1}] \subst_2(\itm{2})
:: \cS_2 \cljoin \clx} 
& :  \rcomp{\cS_2 \cljoin \clx}
\end{array}

\begin{array}{rcl}
& \cast{\ev_1}{(\lambda x^{\cS_1}.\subst_1(t^{\cS_2}))_\clx}  
\; \cast{\ev_2}{v_1} & \\
\rel & 
\cast{\ev_1}{(\lambda
x^{\cS_1}.\subst_2(t^{\cS_2}))_\clx}
\; \cast{\ev_2}{v_2}
& : \rcomp{\cS_2 \cljoin \clx}
\end{array}
0.5em]

\noindent By definition of substitution and Lemma~\ref{lm:if-subst-pres}:

By induction hypotheses:

By definition of related computations:
                 
By Lemma~\ref{lm:ifcf}, each  is either a boolean
 or a
casted boolean . 
In case a value  is a casted value, then the whole term
 can take a step by (R), combining  with
. Such a step either fails, or
succeeds with a new combined evidence. Therefore, either:

in which case we do not care since
we only consider termination-insensitive noninterference, or:
0.3em]
& \red& \cast{\ev'}{(b_i)_{\clx'_i}} :: \Bool_\clx
\end{array}

(b_1)_{\clx'_1} 
\rel
(b_2)_{\clx'_2} 
: \Bool_\clx
0.3em]

\noindent By definition of substitution and Lemma~\ref{lm:if-subst-pres}:

By induction hypothesis:

By definition of related computations:

By definition of  at values of function type, using  and
 to justify the subtyping relations, we have:

\end{case}

\begin{center}--------\end{center}
\begin{case}[\textsf{if}]
,
with 
, 
 and
\\
By definition of substitution:

If , then 

holds
trivially because the  relations relate all such well-typed
terms.
Let us assume . By the induction hypothesis we have
that:

Assuming , by the definition of
 we have:

By Lemma~\ref{lm:ifcf}, each  is either a boolean
 or a
casted boolean . 
In either case,  implies , so by definition of  on boolean values, 
.\\
In case a value  is a casted value, then the whole term
 can take a step by (R), combining  with
. Such a step either fails, or
succeeds with a new combined evidence. Therefore, either:

in which case we do not care since
we only consider termination-insensitive noninterference, or:

Because , both  and
 step into the same branch of the conditional. Let us
assume the condition is true (the other case is similar). Then:

By induction hypothesis:

Assume , then . Since , by Lemma~\ref{lm:relasc} we have:

\end{case}

\begin{center}--------\end{center}
\begin{case}[::]
, with 
and . 

\noindent By definition of substitution:

By induction hypothesis:

The result follows directly by Lemma~\ref{lm:relasc}.



\end{case}
\end{proof}

\section{Related Work and Conclusion}

The design of a gradual security-typed language is a novel
contribution. Despite the fact that both \citet{disney11flow} and
\citet{fennellThiemann:csf2013} have proposed languages for security
typing dubbed gradual, they do not propose gradual source languages.
Rather, the language designs require explicit security casts---which
can also be encoded with a label test expression in
Jif~\cite{zhengMyers:ijis2007}.
Furthermore, both designs treat an unlabeled type as having the top label, then
allowing explicit casts downward in the security lattice.  This design is
analogous to the internal language of the quasi-static typing approach.  In
that approach, explicit casts work well, but the external language there
accepts too many programs.  That difficulty was the original motivation for
consistency in gradual typing~\cite{GradualTyping}.

\citet{thiemannFennell:esop2014} develop a generic approach to gradualize
annotated type systems. This is similar to security typing (labels are one kind
of annotation), except that they only consider annotation on base types, and
the language only includes explicit casts, like the gradual security work
discussed above.  They track blame and provide a translation that removes
unnecessary casts.


\paragraph{Acknowledgments} We thank Mat{\'i}as Toro for feedback and contributing
the proofs of Propositions 1 and 2 in Appendix~\ref{sec:auxiliary-proofs}.  



\bibliographystyle{abbrvnat}
\bibliography{references}{}


\appendix

\section{Auxiliary Proofs}
\label{sec:auxiliary-proofs}



\syntypein*
\begin{proof}
  By induction on .  




  As most of the type rules are identical, most of the cases are
  straightforward. The exceptions to this are the (Sif) and (Sapp) rules.
\begin{case}[Sif]
    Then \\

      By Lemma~\ref{subtypesubjoin},  and
      , and by Lemma~\ref{subtypeljoin}
      , therefore
       and
      .\\
Combining these with the induction hypotheses, we get


\end{case}



  \begin{case}[Sapp]
    Then  and  for some  and  such that ,  and . Using induction hypothesis on  we know that . As . Then by (\lsec-SUB) .
    Using induction hypothesis on , , then by (\lsec-APP) we conclude that 
  \end{case}

\end{proof}

\begin{lemma}
  \label{subtypesubjoin}
  Let .  Then
  \enumerate
    \item If  is defined then .
    \item If  is defined then .
  \endenumerate
\end{lemma}
\begin{proof}
  We start by proving (1) assuming that  is defined. We proceed by case analysis on .
  \begin{case}[]
    If  then as  is defined then  must have the form  for some . Therefore . But by definition of ,  and therefore we use () to conclude that , i.e. .
  \end{case}

  \begin{case}[]
    If  then as  is defined then  must have the form  for some  and .\\
    We also know that . By definition of , . 
    Also, as  is defined then  is defined. 
    Using the induction hypothesis of (2) on , . Also, using the induction hypothesis of (1) on  we also know that .
    Then by () we can conclude that , i.e. .
  \end{case}

  The proof of (2) is  similar to (1) but using the argument that\\ .
\end{proof}



\begin{lemma}
  \label{subtypeljoin}
  Let  and . Then .
\end{lemma}
\begin{proof}
  Straigthforward case analysis on type  using the fact that  for any .
\end{proof}

\begin{lemma}
  \label{lemma:subtypetwoljoin}
  Let  such that , and let  such that . Then .
\end{lemma}
\begin{proof}
  Straightforward case analysis on type  using the definition of \emph{label stamping} on types.
\end{proof}

\insyntype*
\begin{proof}
  By induction on derivations of .

  We proceed by case analysis on  (modulo (\lsec-SUB)). As most of the type
  rules are identical, most of the cases are straightforward. The exception to
  this is case (\lsec-COND) and (\lsec-APP):
  \begin{case}[\lsec-COND]
    Then  and \\
     for some , and  such that ,  and .\\
    Using induction hypothesis on the premises we also know that  for some ,  for some , and  for some .\\
    By (Sif), .
    Then by Lemma~\ref{subtypesubjoin} we know that , and by Lemma~\ref{lemma:subtypetwoljoin} if we choose , we conclude that , i.e. .
  \end{case}

  \begin{case}[\lsec-APP]
    Then  and  for some  and  such that  and .\\
    Using induciton hypothesis on the premises we also know that  for some  and  such that  and , and that  such that . By transitivity on subtyping then . Then by (Sapp)  and by Lemma~\ref{lemma:subtypetwoljoin} if we choose , we conclude that , i.e. .
  \end{case}

\end{proof}

\begin{lemma}
 \label{lemma:subtypesubjoin}
 Let  and . 
 \enumerate
  \item If  is defined,  and  then .
  \item If  is defined,  and  then .
 \endenumerate
\end{lemma}
\begin{proof}
  We start by proving (1) by case analysis on type .
  \begin{case}[]
    As  is defined then  and  for some  and . Also as , then  for some . 
    By (),  and  then by definition of , . Then , i.e.  .
  \end{case}
  \begin{case}[]
    As  is defined then  and  for some  and . Also as , then  for some  and .
    By (),  and .\\
    Then . By using induction hypothesis (2) then  and by using induction hypothesis (1) then . Also by definition of , . Finally by () we conclude that , i.e.  .
  \end{case}

  The proof of (2) is  similar to (1) but using the argument that if  and  then   .
\end{proof}






\end{document}
