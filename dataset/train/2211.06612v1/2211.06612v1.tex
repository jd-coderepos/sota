\documentclass{article}


\PassOptionsToPackage{numbers}{natbib}









\usepackage[final]{neurips_2022}




\usepackage{natbib}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{graphicx}
\usepackage{subfloat}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{soul}
\usepackage{xspace}
\usepackage[subrefformat=parens]{subfig}
\usepackage{cleveref}
\usepackage{enumitem}
\usepackage{bbm}
\usepackage{bbding}
\usepackage{pifont}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{float}
\usepackage{dblfloatfix}
\usepackage{footnote}
\makesavenoteenv{tabular}
\makesavenoteenv{table}
\usepackage{authblk}
\usepackage{xspace}
\usepackage{multirow}  
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
urlcolor=blue,
}



\usepackage{amsmath,amsfonts,bm}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{amsthm}
\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}

\ifx\BlackBox\undefined
\newcommand{\BlackBox}{\rule{1.5ex}{1.5ex}}  \fi

\ifx\QED\undefined
\def\QED{~\rule[-1pt]{5pt}{5pt}\par\medskip}
\fi

\ifx\proof\undefined
\newenvironment{proof}{\par\noindent{\em Proof:\ }}{\hfill\BlackBox\\[.0mm]}
\fi

\ifx\theorem\undefined
\newtheorem{theorem}{Theorem}[section]
\fi

\ifx\example\undefined
\newtheorem{example}{Example}[section]
\fi

\ifx\property\undefined
\newtheorem{property}{Property}
\fi

\ifx\lemma\undefined
\newtheorem{lemma}{Lemma}[section]
\fi

\ifx\proposition\undefined
\newtheorem{proposition}{Proposition}[section]
\fi

\ifx\remark\undefined
\newtheorem{remark}{Remark}
\fi

\ifx\corollary\undefined
\newtheorem{corollary}{Corollary}[section]
\fi

\ifx\definition\undefined
\newtheorem{definition}{Definition}[section]
\fi

\ifx\conjecture\undefined
\newtheorem{conjecture}{Conjecture}[section]
\fi

\ifx\axiom\undefined
\newtheorem{axiom}[theorem]{Axiom}
\fi

\ifx\claim\undefined
\newtheorem{claim}[theorem]{Claim}
\fi

\ifx\assumption\undefined
\newtheorem{assumption}{Assumption}
\fi

\ifx\problem\undefined
\newtheorem{problem}{Problem}[section]
\fi

\ifx\fact\undefined
\newtheorem{fact}{Fact}
\fi

\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{stmaryrd}  
\usepackage{wrapfig}   



\newcommand{\modelName}{DaC}
\newcommand{\methodName}{Divide and Contrast}




\title{Formatting Instructions For NeurIPS 2022}





\title{Divide and Contrast: Source-free Domain Adaptation via Adaptive Contrastive Learning}

\author{Ziyi Zhang$^{1}$, Weikai Chen$^{3}$, Hui Cheng$^{2}$, Zhen Li$^{4,5}$, Siyuan Li$^{6}$, Liang Lin$^{2}$, Guanbin Li$^{2}$\thanks{Corresponding author.} \\
$^1$National Key Laboratory of Novel Software Technology, Nanjing University, Nanjing, China\\
$^2$School of Computer Science and Engineering, Sun Yat-sen University, Guangzhou, China\\
$^3$ Tencent America,
$^4$ The Chinese University of Hong Kong, Shenzhen, China\\
$^5$ Shenzhen Research Institute of Big Data, Shenzhen, China\\
$^6$  AI Lab, School of Engineering, Westlake University, Hangzhou, China
{\tt\footnotesize zhangziyi@lamda.nju.edu.cn}, {\tt\small liguanbin@mail.sysu.edu.cn}
}

\begin{document}


\maketitle


\begin{abstract}
We investigate a practical domain adaptation task, called source-free unsupervised domain adaptation (SFUDA), where the source pretrained model is adapted to the target domain without access to the source data. Existing  techniques mainly leverage self-supervised pseudo-labeling to achieve class-wise \textit{global} alignment~\cite{shot} or rely on \textit{local} structure extraction that encourages the feature consistency among neighborhoods~\cite{nrc_nips_2021}.
While impressive progress has been made, both lines of methods have their own drawbacks -- the ``global'' approach is sensitive to noisy labels while the ``local'' counterpart suffers from the source bias.
In this paper, we present \textit{\methodName{} (\modelName{})}, a new paradigm for SFUDA that strives to connect the good ends of both worlds while bypassing their limitations. 
Based on the prediction confidence of the source model, \modelName{} {divides} the target data into source-like and target-specific samples, where either group of samples is treated with tailored goals under an adaptive {contrastive} learning framework. 
Specifically, the source-like samples are utilized for learning \textit{global} class clustering thanks to their relatively clean labels.
The more noisy target-specific data are harnessed at the instance level for learning the intrinsic \textit{local} structures.
We further align the source-like domain with the target-specific samples using a memory-based maximum mean discrepancy (MMD) loss to reduce the distribution mismatch.
Extensive experiments on VisDA, Office-Home, and the more challenging DomainNet have verified the superior performance of \modelName{} over current state-of-the-art approaches. The code is available at \url{https://github.com/ZyeZhang/DaC.git}.
\end{abstract}

\section{Introduction}
Deep neural networks have brought impressive advances to the cutting edges of vast machine learning tasks. 
However, the leap in performance often comes at the cost of large-scale labeled data.
To ease the process of laborious data annotation, domain adaptation (DA) provides an attractive option that transfers the knowledge learned from the label-rich source domain to the unlabeled target data.
Though most DA approaches require the availability of source data during adaptation, in real-world scenarios, one may only access a source-trained model instead of source data due to privacy issues.
Hence, this work studies a more practical task, coded source-free unsupervised domain adaptation (SFUDA), that seeks to adapt a source model to a target domain without source data.

There are two mainstream strategies to tackle the SFUDA problem. 
One line of approaches focuses on class-wise \textit{global} adaptation.
The key idea is to mitigate domain shift by pseudo-labeling the target data~\cite{shot, Qiu2021ijcai} or generating images with target styles~\cite{li2020model}.
However, either the pseudo images or labels can be noisy due to the domain discrepancy, which would compromise the training procedure and lead to erroneous classifications (Figure~\ref{fig:teaser} (a)).
The other direction of research strives to exploit the intrinsic \textit{local} structure~\cite{nrc_nips_2021,gsfda_iccv_2021} by encouraging consistent predictions between neighboring samples.
Nonetheless, the closeness of features may be biased by the source hypothesis, which could render false predictions.
Further, as it fails to consider the global context, it may generate spurious local clusters that are detrimental to the discriminability of the trained model (Figure~\ref{fig:teaser} (b)).




\begin{figure}[!htbp]
\centering
\subfloat[Global adaptation method]{
\begin{minipage}[t]{0.3\linewidth}
\centering
\includegraphics[width=0.8\textwidth]{global_vis.png}
\end{minipage}}
\subfloat[Local consistency method]{
\begin{minipage}[t]{0.3\linewidth}
\centering
\includegraphics[width=0.8\textwidth]{local_vis.png}
\end{minipage}}
\subfloat[Divide and contrast (ours)]{
\begin{minipage}[t]{0.3\linewidth}
\centering
\includegraphics[width=0.8\textwidth]{ours_vis.png}
\end{minipage}
}
\centering
\caption{UMAP~\cite{mcinnes2018umap-software} visualizations of target features trained for 60 epochs on the randomly selected 6 VisDA classes. The results are compared with two types of baselines, global adaption based CPGA~\cite{Qiu2021ijcai} and neighborhood consistency based NRC~\cite{nrc_nips_2021}.
CPGA can achieve clear global-scale clusters but suffer from false predictions inside each class. NRC can only maintain the intrinsic local consistency but fail to generate clear intra-class boundaries. In contrast, our method inherits the merits of both methods -- clear global clusters and strong local consistency, while bypassing their limitations.}
\label{fig:teaser}
\vspace{-3mm}
\end{figure}


To address the above issues, we propose \textit{\methodName{}} (\textit{\modelName{}}), a dedicated framework for SFUDA that aims to combine the merits of existing techniques, i.e., taking full advantage of both global and local structures, while sidestepping their limitations.
Our key observation is that the ``global'' approach based on self-training can form clear clusters in the feature landscape (Figure~\ref{fig:teaser} (a)).
Its prediction artifacts are mainly caused by noisy labels with low prediction confidence.
Hence, after self-training by pseudo labels, we propose to divide the target data into \textit{source-like} and \textit{target-specific} samples, based on the prediction confidence of the source classifier~\cite{shot}.
The two groups of samples are then fully exploited with tailored learning strategies under a unified \textit{adaptive contrastive learning} framework with a memory bank. Specifically, the memory bank consists of representations of all target samples, and momentum updated in the training stage \cite{Qiu2021ijcai,nips2020spcl}. Thanks to the high prediction confidence, the memory bank generates robust class centroids as positive prototypes for source-like samples.  
This ensures \modelName{} can obtain a discriminative \textit{global} structure which is robust to noisy pseudo labels.
In contrast, for the low-confidence target-specific samples, we ignore their noisy class-level supervisory signals and use the memory bank to generate the positive prototype via the \textit{local} structure. This encourages the network to exploit the intrinsic local structures by contrastive learning.


To prevent the local clustering from forming spurious clusters, as shown in Figure~\ref{fig:teaser} (b), we further transfer the cluster structure from the source-like domain to the target-specific samples. 
In particular, we propose a maximum mean discrepancy (MMD) based on a memory bank for measuring the distribution mismatch between the source-like and target-specific data.
Since the set of source-like and target-specific samples are dynamically updated in our framework, the introduction of a memory bank can effectively alleviate the instability and batch bias caused by mini batches.
As seen in Figure~\ref{fig:teaser} (c), the proposed \modelName{} framework can generate clearer and cleaner clusters than both the class-wise and instance discrimination methods.
Finally, we provide a rigorous theoretical analysis of the upper bound of the task risk of the target model (Sec.~\ref{sec:prelim}) that justifies the soundness of our proposed framework.
Extensive experiments demonstrate that our proposed \modelName{} framework has set a new state of the art on a number of challenging datasets, including VisDA, Office-Home, and DomainNet.

We summarize our contributions as follows: 1) a novel divide-and-contrast paradigm for SFUDA that can fully exploit both the global and local structures of target data via data segmentation and customized learning strategies for data subsets; 2) a unified adaptive contrastive learning framework that achieves class-wise adaptation for source-like samples and local consistency for target-specific data; 3) a memory bank based MMD loss to reduce the batch bias in batch training and an
improved MMD loss with non-negative exponential form; 4) new state-of-the-art performance on VisDA, Office-Home, and DomainNet.



\section{Related Work}
\textbf{Unsupervised Domain Adaptation.}
Conventional UDA methods alleviate the domain discrepancy between the source domain and target domain by leveraging the Maximum Mean Discrepancy (MMD)~\cite{MMD} to match high-order moments of distributions~\cite{tzeng2014deep, CORAL, CMD} or by adversarial training to learn domain invariant features~\cite{ganin2015unsupervised,saito2018maximum}. In addition, some methods~\cite{Dai_2020_ACCV, Kang2019ContrastiveAN} utilize contrastive learning to enhance the global class-level structure by minimizing intra-class distance and maximizing inter-class distance, and others~\cite{saito2020dance,nips2020spcl} use memory bank to provide class-level information from the source domain and instance-level information from the target domain for contrastive learning. However, the absence of source data makes these methods cannot be applied directly.


\textbf{Source-free Unsupervised Domain Adaptation.}
Source-free Unsupervised Domain Adaptation (SFUDA) aims to adapt the well-trained source model to the target domain without the annotated source data. Some methods focus on generating target-style images~\cite{li2020model} or reconstructing fake source distributions via source model~\cite{VDMDA_arxiv_2021}. Another stream of SFUDA methods is exploiting the information provided by the source model. Some methods~\cite{shot,kim2020PrDA,arxiv_2021_chen, Qiu2021ijcai} only leverage the class-level information from the source model and adapt the source model to the target domain by pseudo-labeling, while the other~\cite{nrc_nips_2021,gsfda_iccv_2021} only exploit the neighborhood information and encourage the consistent predictions among samples with highly local affinity. 

\textbf{Contrastive Learning.}
Contrastive learning achieves the promising improvement on unsupervised visual representation learning~\cite{CPC_2018,he2019moco,chen2020simclr,CMC_eccv_2020,2019_cvpr_zhuang} by learning instance discriminative representations. Although the instance-level contrastive learning has well generalization capability in downstream tasks, it does not perform well on the source-free domain adaptation tasks, which demand correct measurement of inter-class affinities on the unsupervised target domain.
\section{Preliminaries and Analysis}
\label{sec:prelim}

Our \textit{Divide and Contrast} paradigm mainly divides the target data $\mathcal{D}_T$ into source-like samples $\mathcal{D}_S$ and target-specific outliers $\mathcal{D}_O$ via the source classifier. We claim the consistency robustness (Claim~\ref{thm:src}) of the source-like samples, and further show in Theorem~\ref{thm:main} an upper bound of task error on the target domain. In this part, we introduce some notations, assumptions, and our theoretical analysis. 

\textbf{Preliminary}. 
Only with a well-trained model on source domain, the goal of the SFUDA task is to learn a model $h$ which minimizes the task risk $\epsilon_{\mathcal{D}_T}(h)$ in the target domain, $i.e. \ \epsilon_{\mathcal{D}_T}(h)=\mathbb{P}_{\mathcal{D}_T}[h(x)\neq h^*(x))]$, where $\mathcal{D}_T$ is our available $n_t$ unlabeled $i.i.d$ samples from target domain, and $h^*$ is the ideal model in all model space $\mathcal{H}$. 
Specifically, we consider a $C$-way classification task, where the source and target domain share the same label space. The model $\bar{h}$ consists of a feature extractor $\phi$ and a classifier $g$, $i.e. \ \bar{h}(x) = g(\phi(x))$, which maps input space $\mathbb{R}^I$ to prediction vector space $\mathbb{R}^C$, and $h(x) = \argmax_c \bar{h}(x)_{[c]}$. The source model is denoted as: $h_s = g_s \circ \phi_s$. The feature from the feature extractor is denoted as $\vf_i = \phi(x_i)$. For the training stage, the batch data randomly sampled from $\mathcal{D}_T$ is denoted as $\mathcal{B}_T$, and $\delta$ is the softmax function. 

\textbf{Assumptions}. Following the subpopulation assumption in \cite{NIPS_2021_cycle,ICLR_2021_theory_wei,ICML_2021_theory_lp,ben2010theory}, we also denote $\mathcal{D}_{T_i}$ the conditional distribution of target data $\mathcal{D}_T$ given the ground-truth $y=i$, and further assume $\mathcal{D}_{T_i} \cap \mathcal{D}_{T_j} = \emptyset$ for all $i\neq j$. 
To introduce the expansion assumption \cite{ICML_2021_theory_lp,ICLR_2021_theory_wei}, we first define that the suitable set of input transformations ${\mathcal{B}(x)}$ takes the general form ${\mathcal{B}(x)} = \{x': \exists A \in \mathcal{A} \ s.t. ||x'-A(x)||< r     \}$ for a small radius $r>0$ and a set of data augmentations $\mathcal{A}$. 
Then, the neighborhood of a sample $x \in \mathcal{D}_{T_i}$ is defined as $\mathcal{N}(x):= \mathcal{D}_{T_i} \cap \{x'|\mathcal{B}(x)\cap \mathcal{B}(x') \neq \emptyset \}$, as well as that of a set $S\subset \mathcal{D}_T$ as: $\mathcal{N}(S) := \cup_{x\in S} \mathcal{N}(x)$. The consistency error of $h$ on domain $\mathcal{D}_T$ is defined as : $\mathcal{R}_{\mathcal{D}_T}(h) = \mathbb{E}_{\mathcal{D}_T}[\mathbbm{1}(\exists x' \in \mathcal{B}(x) \ s.t. \ h(x')\neq h(x))]$, which indicates the model stability of local structure and input transformations.
To this end, we introduce the expansion assumption to study the target domain.

\begin{definition}[\textbf{$(q,\gamma)$-constant expansion}~\cite{ICML_2021_theory_lp,ICLR_2021_theory_wei})]\label{expansion}
 We say $Q$ satisfies $(q,\gamma)$-constant expansion for some constant $q,\gamma \in (0,1)$, if for any set $S \subset Q$ with $ \mathbb{P}_{Q}[S] >q$, we have $\mathbb{P}_{Q}[\mathcal{N}(S) \setminus S]>\min{\{\gamma,\mathbb{P}_{Q}[S]\}}.$
\end{definition}

\textbf{Theoretical analysis}. Our \textit{Divide and Contrast} paradigm mainly divides the target data into source-like and target-specific samples via the source classifier. Specifically, by freezing the source classifier $i.e. \ h = g_s \circ \phi$ \cite{shot},
we select confident samples with prediction probability greater than a threshold $\tau_c$, and regard them as source-like samples:
$
    \mathcal{D}_S = \{x_i| \max_c \delta( \bar{h}(x_i)) \geq \tau_c , x_i \in \mathcal{D}_T\},
$
and the rest target data is target-specific samples $\mathcal{D}_O = \mathcal{D}_T \setminus \mathcal{D}_S$. Denote by $\mathcal{D}_{S_i}$ the conditional distribution of $\mathcal{D}_{S}$ where $\mathcal{D}_{S_i} = \mathcal{D}_S \cap \mathcal{D}_{T_i}$. The definition is similar for $\mathcal{D}_{O_i}$. 
The following claim guarantees the existence of $\tau_c$ and the consistency robustness of source-like samples:

\begin{claim}\label{thm:src} Suppose $h$ is $L_h$-Lipschitz w.r.t the $L_1$ distance, there exists threshold $\tau_c \in (0,1)$ such that the source-like set $\mathcal{D}_S$ is consistency robust, $i.e. \ \mathcal{R}_{\mathcal{D}_S}(h) = 0$. More specifically, 
\begin{equation*}
    \tau_c \geq \frac{L_h r}{4}+ \frac{1}{2}.
\end{equation*}
\end{claim}

\begin{remark}
Claim \ref{thm:src} illustrates the source-like set with a small consistency error, as long as the $\tau_c$ is large enough. Moreover, we empirically claim that model predictions on $\mathcal{D}_S$ are more robust, $i.e.$ $\epsilon_{\mathcal{D}_S}(h)\leq \epsilon_{\mathcal{D}_T}(h)$~\cite{kim2020PrDA}. The great properties of the source-like set, consistency, and robustness, motivate us to transfer knowledge from source-like samples to target-specific samples, by contrastive learning and distribution matching.
\end{remark}
Assume we have a pseudo-labeler $h_{pl}$ based on the source model. The following theorem establishes the upper bound on the target risks and states the key idea behind our method. The proofs of both the claim and theorem are provided in Appendix \ref{supple_proof}. 

\begin{theorem}\label{thm:main} Suppose the condition of Claim \ref{thm:src} holds and $\mathcal{D}_T,\mathcal{D}_S$ satisfies $(q,\gamma)$-constant expansion. Then the expected error of model $h\in \mathcal{H}$ on target domain $\mathcal{D}_T$ is bounded,
$$\epsilon_{\mathcal{D}_T}(h) \leq  
\left(
  \mathbb{P}_{\mathcal{D}_T}[h(x) \neq h_{pl}(x)] 
 - \epsilon_{\mathcal{D}_S}(h_{pl}) + q
\right)
\frac{\mathcal{R}_{\mathcal{D}_T}(h)(1+\gamma)}{\gamma \cdot \min{\{q,\gamma\}}} + \max_{i \in [C]}\{d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})\}+\lambda,$$ 
\end{theorem}
where constant $\lambda$ $w.r.t$ the expansion constant $q$ and task risk of the optimal model. 

\begin{remark}
The Theorem \ref{thm:main} states that the target risk is bounded by the following three main parts, the fitting accuracy between model $h$ and pseudo-labeler $ \mathbb{P}_{\mathcal{D}_T}[h(x) \neq h_{pl}(x)]$, the consistency regularization $\mathcal{R}_{\mathcal{D}_T}(h)$, and the $\mathcal{H}$-divergence between the source-like samples target-specific samples $d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})$. To constrain the above three parts, the theoretical insight of our method lies in class-wise adaptation, consistency of local structure, and alignment between target-specific and source-like samples. 
\end{remark}

Based on the theoretical analysis, our method consists of three parts: 1) achieves preliminary class-wise adaptation by $\mathcal{L}_{self}$, which fits $h$ to pseudo-labels; 2) leverages adaptive contrastive loss $\mathcal{L}_{con}$ to jointly achieve robust class-wise adaptation for source-like samples and local consistency regularization for target-specific samples; 3) minimizes the discrepancy between the source-like set and target-specific outliers by $\mathcal{L}_{\textit{EMMD}}$. The entire loss is defined as:
\begin{equation}
    \mathcal{L} =  \mathcal{L}_{con} + \alpha \mathcal{L}_{self}  + \beta \mathcal{L}_{\textit{EMMD}}.
\end{equation}



\section{Divide and Contrast for Source-free Unsupervised Domain Adaptation}\label{sec:method}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\textwidth]{pipeline.pdf}
\caption{The illustration of the proposed \textit{\modelName{}} framework.}
	\label{fig:overview}
\end{figure}

In this section, we introduce \textit{\modelName{}}, our proposed method for source-free unsupervised domain adaptation. 
As the overview shown in Figure \ref{fig:overview}, our method consists of three parts, self-training by pseudo-labels, an adaptive contrastive learning framework, and distribution alignment. The overall algorithm of DaC is summarized in Appendix \ref{supple_Algo}.

\subsection{Data Segmentation and Self-Training}
\label{sc:self-training}
To achieve preliminary class-wise adaptation without target annotations, we generate pseudo-labels to supervise the transformation set of input $\mathcal{B}(x)$. In practice, we consider two different augmentation strategies in augmentation set: $\mathcal{A} = \{\mathcal{A}_w, \mathcal{A}_s\}$, where weak augmentation $\mathcal{A}_w$ refers to random cropping and flipping, and strong augmentation $\mathcal{A}_s$ refers to the automatically learned augmentation strategy in \cite{autoaugment}. 

\textbf{Pseudo-labeling}. We apply the strategy proposed in \cite{shot} to update pseudo-labels in each epoch. Denote by ${p}_i = \delta(g_s(\vf_i))$ the prediction from source classifier. The initial centroid for each class $k$ is attained by:
$
    \textbf{c}_k = \frac{\sum_i^{n_t}\vf_i {p}_i[k]}{\sum_i^{n_t} {p}_i[k]}.
$
The centroids estimate the centers of different categories, and the samples are labeled identically with its nearest initial centroid:
\begin{equation}\label{pl}
\tilde{\mathcal{Y}}=\{
    \tilde{y}_i| \tilde{y}_i = \argmax_k \cos{(\phi(x_i),\textbf{c}_k)}, x_i \in \mathcal{D}_T \},
\end{equation}
where $\cos{(\cdot ,\cdot)}$ is the cosine similarity. The $k$-th centroid is further modified by: $\textbf{c}_k = \frac{\sum_i^{n_t} \mathbbm{1}(\tilde{y}_i=k)\textbf{f}_i}{\sum_i^{n_t} \mathbbm{1}(\tilde{y}_i=k)}$, where $\mathbbm{1}(\cdot)$ is the indicator function, and pseudo-labels are further updated by the modified centroids $\textbf{c}_k$ based on Eqn. \ref{pl} in each epoch. 

\textbf{Self-training for Consistency Regularization}. During the training iteration, we transfer each sample $x_i$ into two views: $\mathcal{A}_w(x_i),\mathcal{A}_s(x_i)$. Network predictions on the two views are denoted as $p_i^w$ and $p_i^s$ respectively.
Denote by $\hat{y}_i = \text{onehot}(\tilde{y}_i)$ the one-hot coding of pseudo-labels.
Since the same semantic content of the two augmented views, we encourage consistent predictions between two types outputs by the following loss:
\begin{equation}\label{eq:ce}
    \mathcal{L}_{self} = -\mathbb{E}_{x_i\in \mathcal{B}_T}  \left[\sum_{c=1}^C {\hat{y}^c_i}\log({p}_i^w[c])+{\hat{y}^c_i}\log( {p}_i^s[c]) \right]+\sum_{c=1}^C\text{KL}(\bar{p}_c||\frac{1}{C})+\omega H(p_i^w),
\end{equation}
where $\bar{{p}}_c = \mathbb{E}_{\mathcal{B}_T}[p^w_i[c]]$ is regularized by uniform distribution to encourage output diversity, $H(p_i^w) = -\mathbb{E}_{\mathcal{B}_T}[\sum_{c}{p}_i^w[c]\log({p}_i^w[c])]$ is the Shannon entropy~\cite{shannon_entropy}, which is used to encourage confident outputs and accelerate convergence, and $\omega$ is the corresponding parameters.



\paragraph{Dataset Division.}
As the analysis before, we divide all samples in $\mathcal{D}_T$ into the source-like set and target-specific outliers. During the training process, samples are dynamically grouped into the source-like set by the threshold $\tau_c$:
\begin{equation}\label{eq:div_sl2}
    \tilde{\mathcal{D}}_{S}^k= \{x_i | \max_c (p_i^w[c]) \geq \tau_c, \argmax_c (p_i^w[c]) = k, x_i \in \mathcal{D}_T \},
\end{equation}
and the target-specific samples are the rest target data, $i.e.\ \tilde{\mathcal{D}}_{O} = \mathcal{D}_T \setminus \tilde{\mathcal{D}}_{S}$, where $\tilde{\mathcal{D}}_S = \cup_{k=1}^C \tilde{\mathcal{D}}_S^k$. More specifically,
$
    \tilde{\mathcal{D}}_O^k = \{x_i| x_i \in \tilde{\mathcal{D}_O}, \tilde{y}_i=k, \tilde{y}_i \in \tilde{\mathcal{Y}} \}.
$
To this end, we design an adaptive contrastive learning framework that jointly adapts source-like features to class-wise prototypes and optimizes target-specific features by local structures.


\subsection{Adaptive Contrastive Learning}
Similar to \cite{CPC_2018,saito2020dance}, we employ a momentum updated memory bank to store all target features $\mathcal{F} =\{\vz_i\}_{i=1}^{n_t}$. The memory bank dynamically generates $C$ source-like class centroids $\{\vw_c\}_{c=1}^C$ and $n_o$ target-specific features $\{\vv_j\}_{j=1}^{n_o}$, where $n_o = |\tilde{\mathcal{D}}_{O}|$ is the current number of target-specific samples, which dynamically changes in the training stage.

For a general anchor feature during training time $\vf_i = \phi(\mathcal{A}_w(x_i)), \ x_i\in \tilde{\mathcal{D}}_{S}\cup \tilde{\mathcal{D}}_{O}$, we conduct prototype contrastive loss with similarity measured by inner product: 
\begin{equation}
\label{eq:contrastive}
    \mathcal{L}_{con}= -\mathbb{E}_{x_i\in \mathcal{B}_T} \log \frac{\exp(\vf_i \cdot \vk^+/\tau)}
    { \exp{(\vf_i \cdot \vk^+ /\tau)} + \sum_{j= 1}^{C+n_o-1} \exp{(\vf_i \cdot \vk^-_j/\tau)} },
\end{equation}
where the sum is over one positive pair $(\vf_i,\vk^+)$ and $C+n_o-1$ negative pairs $\{(\vf_i, \vk^-)\}$, the temperature $\tau$ is a hyper-parameter and is empirically set as 0.05.

\subsubsection{Prototype Generation}
The contrastive loss tries to classify anchor feature $\vf$ as its positive prototype $\vk^+$ from all negative samples. 
Memory bank generates $C+n_o$ features, including the class-level signals, $i.e.$ $C$ class centroids $\{\vw \}$ as well as $n_o$ target-specific instance features $\{\vv\}$. The source-like and target-specific samples are jointly optimized by generating corresponding positive prototypes.

\textbf{For the source-like anchor}, $i.e.\ x_i\in \tilde{\mathcal{D}}_{S}^k$, since the network prediction $k$ (in Eqn. \ref{eq:div_sl2}) is relatively reliable~\cite{kim2020PrDA}, we encourage contrastive learning to achieve class-wise adaptation by designating the positive prototype as class centroid $\vw_k$, $i.e. \ \vk^+ = \vw_k$. The rest $C-1$ class centroids and $n_o$ target-specific features are used to form negative pairs.

\textbf{For the target specific anchor}, due to its noisy class-level supervisory signal, we generate a positive prototype $\vk^+$ by introducing \textit{Local Structure}, including neighborhood consistency and transformation stability. Specifically, we enhance the semantic consistency with the strongly augmented features $\vf_i^s = \phi(\mathcal{A}_s(x_i))$ and the $K$-nearest features $\mathcal{N}_K(\vf_i)$, that can be easily found in memory bank via cosine similarity: $\mathcal{N}_K(\vf_i) = \{\vz_j|\textit{top-K}\left(\cos(\vf_i,\vz_j )\right),\forall \vz_k\in \mathcal{F} \}$. To this end, the positive prototype $\vk^+$ is generated as:$\vk^+ = \frac{1}{K+1}\left(\vf_i^s + \sum_{k=1}^K  \vz_k\right)$, where $\vz_k \in\mathcal{N}_K(\vf_i)$. Note that $\vk^+$ depicts the local information of its corresponding feature $\vv_i$, and we use the rest $n_o-1$ target-specific features $\{\vv_j\}_{j\neq i}$ and $C$ class centroids to form negative pairs.

 

\textbf{Discussion}. For the \textit{source-like anchor}, the positive prototype $\vk^+ = \vw_k$ is the mean of all source-like features with confident and consistent predictions, which makes the class-wise adaptation more robust to noisy pseudo-labels. For the $i$-th \textit{target-specific anchor}, its corresponding memory bank feature $\vz_i\in\mathcal{F}$ can be found in $\mathcal{N}_K(\vf_i)$. The contrastive loss constrains the consistency error $\mathcal{R}_{\mathcal{D}_T}$ in Thm \ref{thm:main}. 
Unlike the previous contrastive method \cite{Qiu2021ijcai}, Eqn. \ref{eq:contrastive} jointly achieves class-wise adaptation and instance-wise adaptation. 
The source-like and target-specific samples are dynamically updated, and adaptively benefit representation learning.





\subsubsection{Memory Bank}
One of the most important reasons to utilize the memory bank is to conserve source information by momentum updating features. 
Therefore, the memory bank is initialized with the features by performing forward computation of source feature extractor $\phi_s$: $\mathcal{F}=\{\vz_i | \vz_i = \phi_s(x_i),  x_i\in \mathcal{D}_T \}$.
At each iteration, the memory bank features are updated via momentum strategy for the $i$-th input feature:
$
    \vz_i = m \vz_i + (1-m) \vf_i,
$
where $m \in [0,1]$ is the momentum coefficient and is empirically set as 0.2.

The memory bank provides source-like centroids and target-specific features for contrastive learning. The target-specific features can be directly accessed in memory bank: $\{\vv_i|\vv_i = \vz_i, x_i \in \tilde{\mathcal{D}}_O\}$. We initialize the source-like set before initializing the source-like centroids. Samples with confident predictions from the source classifier are termed source-like.
To guarantee sufficient samples in a source-like set in the early training stage, we initialize the source-like set by drawing samples with top $5\%$ predictions in each class. The $c$-th source-like set is initialized as:
\begin{equation}
    \tilde{\mathcal{D}}^c_{S} =\underset{|{\mathcal{X}}|=N,\hat{\mathcal{X}}\subseteq\mathcal{D}_t}{\arg \max} \sum_{ x_i\in {\mathcal{X}}} p^w_i[c],
    \label{eq:div_sl1}
\end{equation}
where $N=5\%n_t$ is the number of samples in each class. And $\tilde{\mathcal{D}}^c_{S}$ is updated in training stage by Eqn. \ref{eq:div_sl2}. 
After updating the source-like set $\tilde{\mathcal{D}}_{S}$ ($ = \bigcup_{c=1}^C \tilde{\mathcal{D}}^c_{S}$), the $c$-th class centroids $\vw_c$ is generated by the mean of all source-like features:
\begin{equation}\label{eq:w_update}
    \vw_c = \frac{1}{|\tilde{\mathcal{D}}_{S}^c|} \sum_{x_i \in \mathcal{D}_{S}^c} \vz_i. 
\end{equation}



\subsection{Distribution Alignment}
To obtain better adaptation performance, we further achieve alignment by minimize the $\mathcal{H}$-divergence between source-like set and target-specific samples, $i.e.\ d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})$, where the kernel-based Max Mean Discrepancy (MMD)~\cite{MMD} is widely used. We use $\tilde{\mathcal{D}}_S^i,\tilde{\mathcal{D}}_O^i$ to estimate $\mathcal{D}_{S_i},\mathcal{D}_{O_i}$, the related optimization target is:
$
    \min_{h\in\mathcal{H}} d_{\textit{MMD}}^{\kappa}(\tilde{\mathcal{D}}_S^i,\tilde{\mathcal{D}}_O^i),
$
where $\kappa$ is the kernel function. 
MMD depicts the domain discrepancy by embedding two distribution into reproducing kernel Hilbert space. 
Considering the MMD between two domain $\mathcal{S},\mathcal{T}$ with the linear kernel function in mini-batch (batch size $B$):
\begin{equation}\label{eq:mmd}
    d_{\textit{MMD}}({\mathcal{S}},{\mathcal{T}}) =
\frac{1}{m}\sum_{i=1}^m  \vs_i \left( \frac{1}{m}\sum_{i'=1}^m \vs_{i'} 
- 
 \frac{1}{n} \sum_{j'=1}^n \vt_{j'}  \right)
+
\frac{1}{n}\sum_{i=1}^n \vt_i  \left( \frac{1}{n}\sum_{j'=1}^n \vt_{j'}
-
 \frac{1}{m} \sum_{i'=1}^m \vs_{i'}  \right).
\end{equation}
where $\vs,\vt$ represent the features of two domain, $m,n$ are their corresponding amounts in mini-batch ($m+n=B$). The previous UDA methods regard ${\mathcal{S}},{\mathcal{T}}$ as the source and the target domain, respectively. Two domains take an equal number of samples ( $i.e. \ m=n=B/2$). Since the absence of source data, we use MMD to measure the discrepancy between source-like and target-specific samples, whose amounts $m,n$ are uncertain in the random batch sampling. The vanilla MMD is not applicable in our setting because samples in mini-batch have estimation bias of the whole distribution, especially when the $m$ or $n$ is small. To this end, we use features in the memory bank to estimate the whole distribution and reduce batch bias. Specifically, for ${\mathcal{S}=\tilde{\mathcal{D}}_{S}^c},{\mathcal{T}=\tilde{\mathcal{D}}_{O}^c}$, we replace $\frac{1}{m}\sum_{i'=1}^m \vs_{i'}$ with $\mathbb{E}_{\tilde{\mathcal{D}}_{S}^c}[\vz]=\vw_c$, $\frac{1}{n}\sum_{j'=1}^n \vt_{j'}$ with $\mathbb{E}_{\tilde{\mathcal{D}}_{O}^c}[\vz]$, and rewrite Eqn. \ref{eq:mmd} as our linear memory bank-based MMD:
\begin{equation}
\label{eq:da1}
    \mathcal{L}_{\textit{LMMD}} = \mathbb{E}_{x_i\in \mathcal{B}_T} \vf_i(\vq^-_i-\vq^+_i),
\end{equation}
where $\vq^-_i$ is the correlating prototype in the memory bank at the same domain. For example, if $\vf_i$ is from the source-like set, $\vq^-_i = \vw_c, \vq^+_i = \mathbb{E}_{\tilde{\mathcal{D}}_{O}^c}[\vz]$. To avoid the negative term in Eq. \ref{eq:da1}, we improve it as a non-negative form. By simply clipping $\max{ \{ 0, \vf\vq^- - \vf\vq^+\}}$, we have:
\begin{equation*}
\max{ \{ 0, \vf\vq^- - \vf\vq^+\}}  = \max{\{ \vf\vq^+,\vf\vq^-\}}-\vf\vq^+ 
         \leq \log\left(\exp(\vf\vq^+)+\exp(\vf\vq^-)\right) - \vf\vq^+ ,
\end{equation*}
the inequality holds by the log-sum-exp bound. And the last term above can be more generally organized into our Exponential-MMD loss as follows:
\begin{equation}\label{eq:emmd}
    \mathcal{L}_{\textit{EMMD}} = -\mathbb{E}_{x_i\in \mathcal{B}_T}  \log \frac{\exp(\vf_i\vq^+_i/\tau)}{\exp(\vf_i\vq^+_i/\tau) + \exp(\vf_i\vq^-_i/\tau)}.
\end{equation}
where $\tau$ is the temperature hyper-parameter, note that we set the temperature the same as that in Eqn. \ref{eq:contrastive} (i.e. $\tau=0.05$). Thus the Exponential-MMD loss can be obtained by the calculated results in the memory bank without additional computing costs.

\section{Experiments}
\subsection{Experimental Setup}
\textbf{Datasets and benchmarks.} We conduct experiments on three benchmark datasets: \textbf{Office-Home}~\cite{officehome2017DeepHN} contains 65 classes from four distinct domains (Real, Clipart, Art, Product) and a total of 15,500 images. \textbf{VisDA-2017}~\cite{Peng2017VisDATV} is a large-scale dataset, with 12-class synthetic-to-real object recognition tasks. The dataset consists of 152k synthetic images from the source domain while 55k real object images from the target domain. \textbf{DomainNet}~\cite{peng2019moment_domainnet} is originally a large-scale multi-source domain adaptation benchmark, which contains 6 domains with 345 classes. Similar to the setting of \cite{saito2019semidomainnet,li2021semiuda}, we select four domains (Real, Clipart, Painting and Sketch) with 126 classes as the single-source unsupervised domain adaptation benchmark and construct seven single-source adaptation scenarios from the selected four domains. All results are the average of three random runs.


\textbf{Implementation Details.} We adopt the Resnet-50~\cite{He2016Resnet} as backbone for Office-Home and ResNet-101 for VisDA, and conduct ResNet-34 for DomainNet similar to previous work~\cite{saito2019semidomainnet,li2021semiuda}. We use the same basic experimental setting in \cite{shot,nrc_nips_2021} for a fair comparison. For the network architecture, the feature extractor consists of the backbone and a full-connected layer with batch normalization, and the classification head is full-connected with weight normalization. Following SHOT, the source model is supervised by smooth labels, the source model initializes the network, and we only train the feature extractor. 
The learning rate for the backbone is 10 times greater than that of the additional layer. The learning rate for the backbone is set as 2e-2 on Office-Home, 5e-4 on VisDA, and 1e-2 on DomainNet. We train 30 epochs for Office-Home, 60 epochs for VisDA, and 30 epochs for DomainNet.
More training details are delineated in Appendix \ref{supple_details}.


\textbf{Baselines.} We compare \textit{\modelName} with multiple source-present and source-free domain adaptation baselines. Here we briefly introduce some of the most related state-of-the-art source-free methods: SHOT~\cite{shot} and CPGA~\cite{Qiu2021ijcai} exploit pseudo label prediction to achieve class-wise adaptation, NRC~\cite{nrc_nips_2021} and G-SFDA~\cite{gsfda_iccv_2021} strengthen the local structure by neighborhood information from source model, and SHOT++~\cite{liang2021shot_pp} is a two-stage extension of SHOT, which adds the rotation prediction auxiliary task~\cite{rotation2018} to SHOT~\cite{shot} in the first stage and trains the second stage in a semi-supervised manner (MixMatch \cite{berthelot2019mixmatch}).
\textit{SF} in tables is short for source-free.

\subsection{Comparison with State-of-the-arts}


\begin{wrapfigure}{!htbp}{0.4\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{fig_acc.pdf}
  \end{center}
\caption{Average accuracy curve on VisDA over 60 epochs.}
  \label{fig:curve}
\end{wrapfigure}

We compare \textit{\modelName} with the state-of-the-art methods on the Office-Home, VisDA, and DomainNet. As the results for \textbf{VisDA} shown in Table \ref{tab:visda}, our method surpasses all baselines in terms of average accuracy, including the recent source-present method BCDM and the most recent source-free method CPGA (87.3\% $v.s.$ 86.0\%). For the \textbf{DomainNet}, Table \ref{tab:domainnet} illustrates the proposed \textit{\modelName} has significantly outperformed the best source-free baseline by more than 3 percent (68.3 v.s. 65.1), and outperforms all source-present and source-free methods $w.r.t$ average accuracy. Similar observation on the results of \textbf{Office-Home} can be found in Table \ref{tab:office-home}. The reported results indicate the superiority of our method.


We further compare the effectiveness of our framework with the state-of-the-art SFUDA methods, in which CPGA~\cite{Qiu2021ijcai} focuses on class-level supervision while NRC~\cite{nrc_nips_2021} focuses on neighborhood consistency. 
We show the UMAP visualization results in Fig. \ref{fig:teaser}, and the accuracy curve in Fig. \ref{fig:curve}. Since the early accuracy of CPGA is low, Fig. \ref{fig:curve} records the curve from 18 epochs.
While CPGA suffers false prediction within each cluster, NRC source bias local clusters due to the loss of global context, causing target error amplification.
Our method can achieve fast convergence speed and stable high classification performance thanks to the effectiveness of the proposed divide and contrast scheme.

To validate the scalability of our model, we extend DaC into a two-stage version called DaC++. The second training stage is the same as SHOT++ for a fair comparison. Table \ref{tab:scalability} shows that DaC++ outperforms SHOT++ by more than 1 percent, and DaC++ is quite close to the target supervised learning performance even without any target annotations. 
\begin{table}[!htbp]
    \vspace{-3mm}
    \centering
     \caption{Comparison of DaC++ and other state-of-the-art methods on VisDA.}\label{tab:scalability}
    \begin{tabular}{ccccccc}
					\toprule
					VisDA & NRC~\cite{nrc_nips_2021} &	CPGA~\cite{Qiu2021ijcai} & SHOT++~\cite{liang2021shot_pp} & DaC & 	DaC++ &	target-supervised   \\
					\midrule
					\multicolumn{1}{c}{Avg. (\%)} & 85.9 &	86.0 &	87.3 & 87.3 &	88.6 &	89.6\\
					\bottomrule
		\end{tabular}
    \vspace{-3mm}
\end{table}

\begin{table}[!htbp]
\vspace{-3mm}
\caption{\label{tab:visda}Accuracy (\%) on the {VisDA} dataset (ResNet-101).}
\setlength\tabcolsep{5pt}
    \begin{center}
\scalebox{0.75}{
         \begin{tabular}{l|c|ccccccccccccc}
         \toprule
         Method &\multicolumn{1}{|c|}{SF} & plane & bicycle & bus & car & horse & knife & mcycl & person & plant & sktbrd & train & truck & Avg.\\
         \midrule
         ResNet-101~\cite{He2016Resnet} & \xmark & 55.1 & 53.3 & 61.9 & 59.1 & 80.6 & 17.9 & 79.7 & 31.2 & 81.0 & 26.5 & 73.5 & 8.5 & 52.4 \\
CDAN~\cite{long2018conditional} & \xmark & 85.2 & 66.9 & 83.0 & 50.8 & 84.2 & 74.9 & 88.1 & 74.5 & 83.4 & 76.0 & 81.9 & 38.0 & 73.9 \\
SWD~\cite{lee2019sliced} & \xmark & 90.8 & 82.5 & 81.7 & 70.5 & 91.7 & 69.5 & 86.3 & 77.5 & 87.4 & 63.6 & 85.6 & 29.2 & 76.4 \\
MCC~\cite{jin2020minimum} & \xmark & 88.7 & 80.3 & 80.5 & 71.5 & 90.1 & 93.2 & 85.0 & 71.6 & 89.4 & 73.8 & 85.0 & 36.9 & 78.8 \\
         STAR~\cite{Lu_2020_CVPR}&\xmark& {95.0} & 84.0 & {84.6} & 73.0 & 91.6 & 91.8 & 85.9 & 78.4 & 94.4 & {84.7} & 87.0 & {42.2} & {82.7} \\
BCDM~\cite{Li21BCDM}& \xmark & 95.1 & 87.6 & 81.2 & 73.2 & 92.7 & 95.4 & 86.9 & 82.5 & 95.1 & 84.8 & 88.1 & 39.5 & 83.4 \\
         \midrule
3C-GAN~\cite{li2020model} & \cmark & 94.8 & 73.4 & 68.8 & {74.8} & {93.1} & 95.4 & 88.6 & {84.7} & 89.1 & 84.7 & 83.5 & 48.1 & 81.6\\
         SHOT~\cite{shot}&\cmark & {94.3} & {88.5} & 80.1 & 57.3 & 93.1 & {94.9} & 80.7 & {80.3} & {91.5} & {89.1} & 86.3 & {58.2} & {82.9} \\
G-SFDA~\cite{gsfda_iccv_2021}&\cmark & {96.1} & {88.3} & 85.5 & 74.1 & 97.1 & 95.4 & 89.5 & {79.4} & {95.4} & {92.9} & 89.1 & {42.6} & {85.4} \\
        NRC~\cite{nrc_nips_2021}&\cmark & \textbf{96.8} & {\textbf{91.3}} & {82.4} & 62.4 & {96.2} & {95.9} & 86.1 &{80.6} & {94.8} & {94.1} & 90.4  &  {59.7} & {85.9} \\
         CPGA~\cite{Qiu2021ijcai}& \cmark & {95.6} & {89.0} & 75.4 & 64.9 & 91.7 & {\textbf{97.5}} & 89.7 & \textbf{83.8} & {93.9} & {93.4} & 87.7 & {\textbf{69.0}} & {86.0} \\
        \midrule
        \textbf{\textbf{DaC}} & \cmark & 96.6 & 86.8 & \textbf{86.4} & \textbf{78.4} & \textbf{96.4} & 96.2 & \textbf{93.6} & 83.8 & \textbf{96.8}& \textbf{95.1} &\textbf{89.6} & 50.0 & \textbf{87.3}\\ 
        \bottomrule
        \end{tabular}
    }
    \end{center}
\end{table}

\begin{table}[!htbp]
\vspace{-3mm}
\setlength\tabcolsep{6pt}
 \caption{ Accuracy (\%) on the DomainNet dataset (ResNet-34). The * baselines are implemented by the official codes.}\label{tab:domainnet}
    \begin{center}
    \scalebox{0.9}{  
         \begin{tabular}{l|c|cccccccc}
         \toprule
         Method & \multicolumn{1}{|c|}{SF} & Rw$\rightarrow$Cl & Rw$\rightarrow$Pt & Pt$\rightarrow$Cl & Cl$\rightarrow$Sk & Sk$\rightarrow$Pt & Rw$\rightarrow$Sk & Pt$\rightarrow$Rw & Avg.\\
         \midrule
         ResNet-34~\cite{He2016Resnet} & \xmark & 58.4 & 62.5 & 56.0 & 50.1 & 41.9 & 48.2 & 70.1 & 56.7 \\
MME~\cite{saito2019semidomainnet} & \xmark & 70.0 & 67.7 & 69.0 & 56.3 & 64.8 & 61.0 & 76.1 & 66.4 \\
        CDAN~\cite{long2018conditional} & \xmark & 65.0 & 64.9 & 63.7 & 53.1 & 63.4 & 54.5 & 73.2 & 62.5 \\
        VDA*~\cite{jin2020minimum} & \xmark & 63.5 & 65.7 & 62.6 & 52.7 &  53.6& 62.0&74.9  & 62.1\\
        GVB*~\cite{cui2020gvb}  & \xmark & 68.2 &  \textbf{69.0} & 63.2 & 56.6 & 63.1 & \textbf{62.2} & 73.8 & 65.2 \\
         \midrule
        BAIT*~\cite{yang2020casting} & \cmark & 64.7 & 65.4 & 62.1 & 57.1 & 61.8 & 56.7 & 73.2 & 63 \\
         SHOT*~\cite{shot} & \cmark & 67.1 & 65.1 & 67.2 & 60.4 & 63 &  56.3 & 76.4 & 65.1 \\
         G-SFDA*~\cite{gsfda_iccv_2021}&\cmark &{63.4} & 67.5 & 62.5 & 55.3 & 60.8 & 58.3 & 75.2 &63.3 \\
        NRC*~\cite{nrc_nips_2021}&\cmark &{67.5} & 68.0 & 67.8 & 57.6 & 59.3 & 58.7 & 74.3 &64.7 \\
         \midrule
        {\textbf{DaC}} & \cmark & \textbf{70.0} & 68.8 & \textbf{70.9} & \textbf{62.4} & \textbf{66.8} & 60.3 & \textbf{78.6} & \textbf{68.3}  \\
         \bottomrule
         \end{tabular}
         }
    \end{center}
\end{table}

\begin{table}[!htbp]
\vspace{-3mm}
    \caption{\label{tab:office-home} Accuracy (\%) on the Office-Home dataset (ResNet-50).}
\setlength\tabcolsep{3pt}
    \begin{center}
\scalebox{0.7}{  
         \begin{tabular}{l|c|ccccccccccccc}
         \toprule
         Method & \multicolumn{1}{|c|}{SF} & Ar$\rightarrow$Cl & Ar$\rightarrow$Pr & Ar$\rightarrow$Rw & Cl$\rightarrow$Ar & Cl$\rightarrow$Pr & Cl$\rightarrow$Rw & Pr$\rightarrow$Ar & Pr$\rightarrow$Cl & Pr$\rightarrow$Rw & Rw$\rightarrow$Ar & Rw$\rightarrow$Cl & Rw$\rightarrow$Pr & Avg.\\
         \midrule
         ResNet-50~\cite{He2016Resnet} & \xmark & 34.9 & 50.0 & 58.0 & 37.4 & 41.9 & 46.2 & 38.5 & 31.2 & 60.4 & 53.9 & 41.2 & 59.9 & 46.1 \\
         MCD~\cite{saito2018maximum} & \xmark & 48.9 & 68.3 & 74.6 & 61.3 & 67.6 & 68.8 & 57.0 & 47.1 & 75.1 & 69.1 & 52.2 & 79.6 & 64.1 \\
         CDAN~\cite{long2018conditional} & \xmark & 50.7 & 70.6 & 76.0 & 57.6 & 70.0 & 70.0 & 57.4 & 50.9 & 77.3 & 70.9 & 56.7 & 81.6 & 65.8 \\
BNM~\cite{Cui2020TowardsDA} & \xmark & 52.3 & 73.9 & 80.0 & 63.3 & 72.9 & 74.9 & 61.7 & 49.5 & 79.7 & 70.5 & 53.6 & 82.2 & 67.9 \\
         BDG~\cite{yang2020bi} & \xmark & 51.5 & 73.4 & 78.7 & 65.3 & 71.5 & 73.7 & 65.1 & 49.7 & 81.1 & \textbf{74.6} & 55.1 & 84.8 & 68.7 \\
\midrule
        
         SHOT~\cite{shot} & \cmark & 56.9 & 78.1 & 81.0 & 67.9 & {78.4} & {78.1} & 67.0 & 54.6 & 81.8 & 73.4 & 58.1 & {84.5} & 71.6 \\
         G-SFDA~\cite{gsfda_iccv_2021}&\cmark & 57.9 & 78.6 & 81.0 & 66.7 & {77.2}& {77.2} & {65.6} & 56.0  & 82.2 & 72.0 & 57.8 & {83.4} & 71.3 \\
         CPGA~\cite{Qiu2021ijcai} & \cmark & {\textbf{59.3}} & {78.1} & 79.8 & 65.4 & 75.5 & 76.4 & 65.7 & {\textbf{58.0}} & 81.0 & 72.0 & {\textbf{64.4}} & 83.3 & {71.6} \\
         NRC~\cite{nrc_nips_2021}&\cmark &{57.7} 	&{\textbf{80.3}} 	&{\textbf{82.0}} 	&{68.1} 	&{\textbf{79.8}} 	&{78.6} 	&{65.3} 	&{56.4} 	&{\textbf{83.0}} 	&71.0	&{58.6} 	&{\textbf{85.6}} 	&{72.2} \\
\midrule
{\textbf{DaC}} & \cmark & {59.1} & {79.5} & 81.2 & \textbf{69.3} & 78.9 & \textbf{79.2} & \textbf{67.4} & {56.4} & 82.4 & 74.0 & {61.4} & 84.4 & {\textbf{72.8}} \\
         \bottomrule
         \end{tabular}}
    \end{center}

    \vspace{-3mm}
\end{table}



\subsection{Ablation Analysis}\label{sec:ablation}
\textbf{Role of \textit{Divide and Contrast} paradigm}. 
To study the effectiveness of our proposed \textit{Divide and Contrast} paradigm, we conduct contrastive learning without splitting target data. We strengthen the local or class-level global structure with two contrastive learning schemes. \textit{Scheme-S}
focuses on obtaining discriminative class-wise clusters using a contrastive learning method similar to CPGA~\cite{Qiu2021ijcai}. Specifically, the positive prototype is the class centroid $w.r.t$, the anchor's pseudo label, while other centroids are the negative samples.
\textit{Scheme-T} only enhances the local structure by instance discrimination learning following~\cite{chen2020simclr,CPC_2018}, the positive prototype is the anchor's corresponding feature in the memory bank, and the negative samples are the remaining features in the memory bank.

As shown in Table \ref{tab:ablation1}, both schemes improve the performance of self-training thanks to the contrastive framework. However, \textit{Scheme-S} is vulnerable to the noisy pseudo labels while the \textit{Scheme-T} can not further transfer the robust class-level classification into target outliers.
Our method, in comparison, outperforms all the alternatives by a large margin.


\begin{table}[!htbp]
    \vspace{-3mm}
    \centering
     \caption{Comparison with different contrastive learning schemes in the best accuracy over 60 epochs on VisDA.}
     \label{tab:ablation1}
    \begin{tabular}{cccc|c}
					\toprule
					SHOT & Scheme-S & Scheme-T & DaC  & \multicolumn{1}{|c}{Avg. (\%)} \\
					\midrule
\bm{\cmark}& & & & \multicolumn{1}{|c}{82.9}\\
					\bm{\cmark}&\bm{\cmark}& & & \multicolumn{1}{|c}{84.1}\\
					\bm{\cmark}&            &\bm{\cmark}&    &\multicolumn{1}{|c}{84.4}\\
					&&& \bm{\cmark}&  \multicolumn{1}{|c}{\textbf{87.3}}\\
\bottomrule
		\end{tabular}
    \vspace{-3mm}
\end{table}





\textbf{Component-wise Analysis}.
we conduct our ablation study by isolating each part of our method on VisDA. As the results shown in Table \ref{tab:ablation2}, each component of our methods helps to enhance the performance, in  which the adaptive contrastive learning framework makes the most contributions to the promotion of accuracy (over 3\% points).  Besides, both strong augmentation and local structure enhance the local neighborhood information for each sample, which benefit the theoretical consistency  $\mathcal{R}_{\mathcal{D}_T}(h)$ and improve the performance. 
Last but not least, removing the distribution alignment degrades the average accuracy to 86.5\%, which means both our linear and exponential memory-bank-based MMD are helpful. The $\mathcal{L}_{\textit{EMMD}}$ outperforms $\mathcal{L}_{\textit{LMMD}}$ because the non-negative exponential form is upper bound of the other, and is stable in batch training. 
\begin{table}[!htbp]
\vspace{-3mm}
\caption{Ablation study of different losses (\textbf{left}) and different modules (\textbf{right}) on VisDA.}\label{tab:ablation2}
\begin{minipage}[tbp]{0.5\textwidth}
\makeatletter 
		\linespread{2.0}
		\vspace{-0.5pt}
		\setlength{\tabcolsep}{1.mm}
\begin{tabular}{ccccc|c}
					\toprule
					BackBone& $\mathcal{L}_{self}$ & $\mathcal{L}_{con}$ & $\mathcal{L}_{\textit{LMMD}}$& $\mathcal{L}_{\textit{EMMD}}$ & \multicolumn{1}{|c}{Avg.} \\
					\midrule
					\bm{\cmark}&& & & & \multicolumn{1}{|c}{59.5}\\
					\bm{\cmark}&\bm{\cmark}& & &&  \multicolumn{1}{|c}{83.3}\\
					\bm{\cmark}&\bm{\cmark}&\bm{\cmark}& &&  \multicolumn{1}{|c}{86.5}\\
\bm{\cmark}&\bm{\cmark}&\bm{\cmark}&\bm{\cmark}&  &  \multicolumn{1}{|c}{87.0}\\
					\bm{\cmark}&\bm{\cmark}&\bm{\cmark}& &\bm{\cmark}&    \multicolumn{1}{|c}{\textbf{87.3}}\\
					\bottomrule
		\end{tabular}
\end{minipage}
	\begin{minipage}[tbp]{0.5\textwidth}
		\makeatletter 
	\setlength{\tabcolsep}{1.0mm}
    		\begin{tabular}{c|c}
					\toprule
					\textbf{Method}& \multicolumn{1}{|c}{Acc} \\
					\midrule
					\text{DaC} & \multicolumn{1}{|c}{\textbf{87.3}}\\
					\text{DaC} w/o Local Structure& \multicolumn{1}{|c}{{86.7}}\\
\text{DaC} w/o Strong Augmentation& \multicolumn{1}{|c}{{85.6}}\\
					\bottomrule
		\end{tabular}
	\end{minipage}
\vspace{-3mm}
\end{table}

\section{Conclusion}

In this paper, we have presented \methodName{} (\modelName{}), a novel learning paradigm for the SFUDA problem that can inherit the advantages of (global) class-wise and (local) neighbors consistency approaches while sidestepping their limitations. The key idea is to divide the target data according to the prediction confidence of the source hypothesis (source-like v.s. target-specific) and apply customized learning strategies that can best fit the data property. 
We achieve this goal via a proposed adaptive contrastive learning where different groups of data samples are learned under a unified framework.
We also proposed a MMD loss based on a memory bank to transfer the knowledge from the source-like domain to the target-specific data.
While promising performance has been achieved using our proposed approach, it would be an interesting future avenue to investigate how to extend the \modelName{} framework to more DA tasks, e.g. semi-supervised SFUDA or source-free open-set DA.

\section{Acknowledgments}
This work was supported in part by the Guangdong Basic and Applied Basic Research Foundation (No.2020B1515020048), in part by National Key Research and Development Program of China (2020AAA0107200) and
NSFC(61876077), in part by Open Research Projects of Zhejiang Lab (No.2019KD0AD01/017), in part by the National Natural Science Foundation of China (No.61976250, No.U1811463), in part by the Guangzhou Science and technology project (No.202102020633).





\bibliographystyle{plainnat}
\bibliography{egbib}




\newpage
\appendix


\section{Theoretical Details}\label{supple_proof}
Our \textit{Divide and Contrast} paradigm mainly divides the target data $\mathcal{D}_T$ into source-like samples $\mathcal{D}_S$ and target-specific outliers $\mathcal{D}_O$ via the network predictions from the source classifier. We claim the consistency robustness (Claim~\ref{claim:src}) of the source-like samples. We further show in Theorem~\ref{thm:main1} a upper bound of task error on target domain, and design our objective function motivated by constraining the upper bound.

We first review the main notations and assumptions in Section \ref{sec:prelim}. Considering a $C$-way classification task, our model consists of source classifier and feature extractor $\bar{h} = g_s \circ \phi$, which maps input space $\mathbb{R}^I$ to prediction vector space $\mathbb{R}^C$, and $h(x) = \argmax_c \bar{h}(x)_{[c]}$. Slightly different from the theoretical derivation, we use $h=g_s \circ \phi$ to denote our model in Section \ref{sec:method} to simplify the symbolic notations.
Following in \cite{NIPS_2021_cycle,ICLR_2021_theory_wei,ICML_2021_theory_lp,ben2010theory}, we denote $\mathcal{D}_{T_c}$ as the conditional distribution (probability measure) of $\mathcal{D}_T$ given the ground truth $y=c$, and also assume that the supports of $\mathcal{D}_{T_i}$ and $\mathcal{D}_{T_j}$ are disjoint for all $i\neq j$. This canonical assumption shows that the target distribution consists of $C$ class-wise subpopulations, and different class subpopulations have disjoint supports. 

In order to study the local structure, we define that the suitable set of input transformations $\mathcal{B}(x)\subset \mathcal{D}_T$ takes the general form:
$$\mathcal{B}(x) = \{x': \exists A\in \mathcal{A} \ s.t. \ ||(x'-A(x)||<r \},$$
where $||\cdot||$ is $L_1$ distance function, $r>0$ is a small radius, and $\mathcal{A}$ is a set of data augmentations. $\mathcal{B}(x)$ generally depicts the local structures around sample $x$, which can be understand as the neighborhood set in \cite{nrc_nips_2021,gsfda_iccv_2021} and the set of augmented data in \cite{liang2021shot_pp,NeurIPS2020_aumentation}. To this end, we further introduce the population consistency error on $\mathcal{D}_T$ to demonstrate the consistency robustness of predictions from the model within $\mathcal{B}(x)$: 
$$\mathcal{R}_{\mathcal{D}_T}(h) = \mathbb{E}_{x\sim \mathcal{D}_T}[\mathbbm{1}(\exists x' \in \mathcal{B}(x) \ s.t. \ h(x')\neq h(x))].$$

Following \cite{NIPS_2021_cycle,ICML_2021_theory_lp,ICLR_2021_theory_wei}, we study target domain relies on the \textit{expansion property}, which implies the continuity of data distributions in each class-wise subpopulations. For this, we first define the neighborhood function of a sample $x \in \mathcal{D}_{T_i}$ as:
$\mathcal{N}(x):= \mathcal{D}_{T_i} \cap \{x'|\mathcal{B}(x)\cap \mathcal{B}(x') \neq \emptyset \}$, as well as that of a set $S\subset \mathcal{D}_T$ as: $\mathcal{N}(S) := \cup_{x\in S} \mathcal{N}(x)$. 

\begin{definition}[\textbf{$(q,\gamma)$-constant expansion}~\cite{ICLR_2021_theory_wei})]\label{expansion1}
 We say $Q$ satisfies $(q,\gamma)$-constant expansion for some constant $q,\gamma \in (0,1)$, if for any set $S \subset Q$ with $ \mathbb{P}_{Q}[S] >q$, we have $\mathbb{P}_{Q}[\mathcal{N}(S) \setminus S]>\min{\{\gamma,\mathbb{P}_{Q}[S]\}}.$
\end{definition}

Our \textit{Divide and Contrast} paradigm selects confident samples (from target data) with prediction probability greater than a threshold $\tau$, and regard them as source-like samples:
$$
    \mathcal{D}_S = \{x_i| \max_c \bar{h}(x_i) \geq \tau , x_i \in \mathcal{D}_T\},
$$
and the rest target data is target-specific samples $\mathcal{D}_O = \mathcal{D}_T \setminus \mathcal{D}_S$.
Define the conditional distribution of source-like samples as $\mathcal{D}_{S_i} = \mathcal{D}_S \cap \mathcal{D}_{T_i}$.
The definition is similar for $\mathcal{D}_{O_i}$. 
The following claim guarantees the consistency and robustness of source-like samples:

\begin{claim}\label{claim:src} Suppose $h$ is $L_h$-Lipschitz w.r.t the $L_1$ distance, there exists threshold $\tau \in (0,1)$ such that the source-like set $\mathcal{D}_S$ is consistency robust, $i.e. \ \mathcal{R}_{\mathcal{D}_S}(h) = 0$. More specifically, 
\begin{equation*}
    \tau \geq \frac{L_h r}{4}+ \frac{1}{2}.
\end{equation*}
\end{claim}

\begin{proof}[Proof of Claim~\ref{claim:src}]
 Suppose $\mathcal{D}_S$ is defined by $\tau \geq \frac{L_h r}{4}+ \frac{1}{2}$. 
If $\exists\ x,x'\in \mathcal{D}_S, \ x'\in \mathcal{B}(x)\cap \mathcal{D}_S\ s.t. \ \bar{h}(x)\neq \bar{h}(x').$ Denote $h(x)=i, \ h(x')=j$, since $i\neq j$, there is $\bar{h}(x)_{[i]}-\bar{h}(x')_{[j]}\geq 2\tau -1,$ and $\bar{h}(x')_{[j]}-\bar{h}(x)_{[i]}\geq 2\tau -1$. Then we have:
\begin{equation*}
    L_h||x-x'||\geq||\bar{h}(x) - \bar{h}(x')||\geq|\bar{h}(x)_{[i]}-\bar{h}(x')_{[j]}|+|\bar{h}(x)_{[j]}-\bar{h}(x')_{[i]}|\geq 4\tau-2\geq L_h r,
\end{equation*}
Since $x'\in\mathcal{B}(x)$, $||x-x'||<r$, and Lipschitz constant $L_h>0$, this forms a contradiction with $L_h||x-x'||\geq L_h r$. Thus, $\forall x\in \mathcal{D}_S, x'\in \mathcal{B}(x)\cap \mathcal{D}_S$, the network predictions are consistent, $i.e. \ \mathcal{R}_{\mathcal{D}_S}(h) = 0$.
\end{proof}

Assume we have a pseudo-labeler $h_{pl}$ based on the source model. In Theorem~\ref{thm:main1}, we establish a upper bound of target error based on expansion property.



\begin{theorem}\label{thm:main1} Suppose the condition of Claim \ref{thm:src} holds and $\mathcal{D}_T,\mathcal{D}_S$ satisfies $(q,\gamma)$-constant expansion. Then the expected error of model $h\in \mathcal{H}$ on target domain $\mathcal{D}_T$ is bounded,
\begin{equation}\label{eq:main}
    \epsilon_{\mathcal{D}_T}(h) \leq  
\left(
  \mathbb{P}_{\mathcal{D}_T}[h(x) \neq h_{pl}(x)] 
 - \epsilon_{\mathcal{D}_S}(h_{pl}) + q
\right)
\frac{\mathcal{R}_{\mathcal{D}_T}(h)(1+\gamma)}{\gamma \cdot \min{\{q,\gamma\}}} + \max_{i \in [C]}\{d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})\}+\lambda, 
\end{equation}

\end{theorem}

We have proved that source-like samples are consistency robust (Claim \ref{claim:src}). For the source-like samples, we further assume that $\epsilon_{\mathcal{D}_S}(h)<\epsilon_{\mathcal{D}_T}(h)$ and $\mathbb{P}_{x\sim \mathcal{D}_S}[h(x)\neq h_{pl}(x)]<\mathbb{P}_{x\sim \mathcal{D}_T}[h(x)\neq h_{pl}(x)]$, which empirically holds since all source-like samples with confident predictions~\cite{kim2020PrDA}. To prove Theorem \ref{thm:main1}, we first use the expansion property to study the error bound of $\mathcal{D}_S$, and introduce new notations as follows. Let $\mathcal{M}^i(h) = \{x: h(x)\neq i, x\in \mathcal{D}_{S_i}\}$ denote the source-like samples where the model makes mistakes. The definition is similar for $\mathcal{M}(h_{pl})$, the source-like samples where the pseudolabeler makes mistakes. We introduces three disjoint subsets of $\mathcal{M}^i(h)$ following \cite{ICLR_2021_theory_wei}: $\mathcal{M}_1^i=\{x: h(x)=h_{pl}(x), h(x)\neq i\}$, $\mathcal{M}_2^i=\{x: h(x)\neq h_{pl}(x), h(x)\neq i, h_{pl}(x)\neq i \}$, $\mathcal{M}_3^i=\{x: h(x)\neq h_{pl}(x), h(x)\neq i, h_{pl}(x)=i\}$. $\mathcal{M}_1^i \cup \mathcal{M}_2^i \subseteq \mathcal{M}^i(h_{pl})\cap \mathcal{M}^i(h)$, where both $h$ and $h_{pl}$ makes mistakes. 

When $h$ fits the pseudolabels well, $i.e. \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[\mathbbm{1}(h(x)\neq h_{pl}(x))]-\epsilon_{\mathcal{D}_{S_i}}(h_{pl})\leq \gamma$, the Lemma A.3 in \cite{ICLR_2021_theory_wei} states that:
\begin{equation}\label{lemma:src0}
    \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}_1^i \cup \mathcal{M}_2^i] =\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}_1^i] + \mathbb{P}_{\mathcal{D}_{S_i}}  [\mathcal{M}_2^i] \leq q
\end{equation}
Thus we define $I= \{i\in [C]|\mathbb{P}_{x\sim \mathcal{D}_{S_i}}[\mathbbm{1}(h(x)\neq h_{pl}(x))]-\epsilon_{\mathcal{D}_{S_i}}(h_{pl})\leq \gamma \}$, where $[C] = \{1,2,\dots,C\}$. The following lemma bounds the probability of ${[C] \setminus I}$.

\begin{lemma}[Upper bound on the subpopulations of ${[C] \setminus I}$]\label{lemma:popI} Under the setting of Theorem~\ref{thm:main1},
$$\sum_{i\in [C]\setminus I}\mathbb{P}_{\mathcal{D}_S}[\mathcal{D}_{S_i}] \leq \frac{1}{\gamma}(\mathbb{P}_{x\in\mathcal{D}_{S}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S}}(h_{pl})+q)$$
\end{lemma}
\begin{proof}[Proof of Lemma \ref{lemma:popI}]
For any $i\in [C]$, the disjoint three parts  $\mathcal{M}^i_2, \mathcal{M}^i_3$, and $(\mathcal{M}^i(h_{pl})\cap \overline{\mathcal{M}^i(h)})$ have inconsistent predictions between $h$ and $h_{pl}$. Thus, $\mathcal{M}^i_2 \cup \mathcal{M}^i_3 \cup (\mathcal{M}^i(h_{pl})\cap \overline{\mathcal{M}^i(h)})\subseteq \{x: h(x)\neq h_{pl}(x), x\in \mathcal{D}_{S_i}\}$, and we have:
\begin{equation}\label{lemma:popI_help1}
    \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_2]+ \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_3]+ \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i(h_{pl})\cap \overline{\mathcal{M}^i(h)}]
    \leq 
    \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)]
\end{equation}
It is not hard to verify that $\mathcal{M}^i(h_{pl})\setminus \mathcal{M}^i_1 \subseteq \mathcal{M}^i_2 \cup (\mathcal{M}^i(h_{pl})\cap \overline{\mathcal{M}^i(h)})$, then:
\begin{equation}\label{lemma:popI_help2}
\begin{aligned}
    \epsilon_{\mathcal{D}_{S_i}}(h_{pl})-\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}_1^i] &\leq \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i(h_{pl})\setminus \mathcal{M}^i_1] \\
    & \leq \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_2]+ \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i(h_{pl})\cap \overline{\mathcal{M}^i(h)}]\\
    \text{by Eqn. \ref{lemma:popI_help1}}& \leq \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)] - \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_3]
\end{aligned}
\end{equation}
Then, we can write:
\begin{equation}\label{lemma:popI_help3}
    \begin{aligned}
        \mathbb{P}_{x\sim \mathcal{D}_{S}}[h(x)\neq h_{pl}(x)] &= \sum_{i\in I} \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)] \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}] \\
        &+\sum_{i\in [C]\setminus I} \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)] \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]\\
        \text{by Eqn. \ref{lemma:popI_help2}}&\geq 
        \sum_{i\in I} \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}](\epsilon_{\mathcal{D}_{S_i}}(h_{pl})-\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}_1^i])
         \\
        &+\sum_{i\in [C]\setminus I}
        \mathbb{P}_{x\sim \mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)] \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}] \\
        \text{by Eqn. \ref{lemma:src0} and Definition of $I$}&> 
        \sum_{i\in I} \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}](\epsilon_{\mathcal{D}_{S_i}}(h_{pl})-q)
         \\
        &+\sum_{i\in [C]\setminus I}
        (\epsilon_{\mathcal{D}_{S_i}}(h_{pl}) + \gamma) \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]\\
        &\geq \epsilon_{\mathcal{D}_{S_i}}(h_{pl}) -q + \gamma \sum_{i\in [C]\setminus I} \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]
    \end{aligned}
\end{equation}
By organizing the Eqn. \ref{lemma:popI_help3}, we complete the proof.
\end{proof}

\begin{lemma}\label{lemma:errI} Under the condiction of Theorem \ref{thm:main1}, for any $i \in  I$, the task error on $\mathcal{D}_{S_i}$ is bounded by:
$$\epsilon_{\mathcal{D}_{S_i}}(h)\leq \mathbb{P}_{x\sim\mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)]- \epsilon_{\mathcal{D}_{S_i}}(h_{pl}) + 2q$$
\end{lemma}
\begin{proof}[Proof of Lemma \ref{lemma:errI}] For $i\in I$, we can write:
\begin{equation}
    \begin{aligned}
        \epsilon_{\mathcal{D}_{S_i}}(h) &= \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_2]+ \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_3] +\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_1]\\
        \text{by Eqn. \ref{lemma:popI_help2}}&\leq
        \mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_2]  +2\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_1] + \mathbb{P}_{x\sim\mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S_i}}(h_{pl})\\
        \leq&2(\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_2]  +\mathbb{P}_{\mathcal{D}_{S_i}}[\mathcal{M}^i_1]) + \mathbb{P}_{x\sim\mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S_i}}(h_{pl})\\
        \text{by Eqn. \ref{lemma:src0}}&\leq
        2q  + \mathbb{P}_{x\sim\mathcal{D}_{S_i}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S_i}}(h_{pl})
    \end{aligned}
\end{equation}
\end{proof}

Based on the results above, we turn to bound the target error on the whole target data.
\begin{proof}[Proof of Theorem \ref{thm:main1}]
\begin{align}\label{thm1:help0}
    \epsilon_{\mathcal{D}_T}(h) = \sum_{i=1}^C \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \epsilon_{\mathcal{D}_{T_i}}(h)
    =\sum_{i\in G_1} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \epsilon_{\mathcal{D}_{T_i}}(h)+\sum_{i\in G_2} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \epsilon_{\mathcal{D}_{T_i}}(h)
\end{align}
Following \cite{NIPS_2021_cycle}, we define $G_1 = \{i\in [C]: \mathcal{R}_{\mathcal{D}_{T_i}}(h)\leq \min{\{q,\gamma\}} \}, G_2 = \{i\in [C]: \mathcal{R}_{\mathcal{D}_{T_i}}(h)> \min{\{q,\gamma\}} \}$
, by the Lemma 2 in \cite{NIPS_2021_cycle}, we also claim that, for $\forall i \in G_1$:
\begin{equation}\label{thm1:help1}
    \epsilon_{\mathcal{D}_{T_i}}(h)\leq q,
\end{equation}
otherwise, by the expansion property~\ref{expansion1}, $\mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{N}(\mathcal{M}^i(h))\setminus \mathcal{M}^i(h)]>\min\{q,\gamma \}$.
We claim that the $\mathcal{N}(\mathcal{M}^i(h))\setminus \mathcal{M}^i(h)$ is subset of $\mathcal{R}_{\mathcal{D}_{T_i}}(h)$. If not, $\exists \ x\in \mathcal{N}(\mathcal{M}^i(h))\setminus \mathcal{M}^i(h)$, say $ x \in \mathcal{N}( \mathcal{M}^i(h)\setminus \mathcal{R}_{\mathcal{D}_{T_i}}(h))$, by the definition of neighborhood, $\exists x'\in \mathcal{M}^i(h)\setminus \mathcal{R}_{\mathcal{D}_{T_i}}(h) \ s.t.  \ \exists  x''\in \mathcal{B}(x)\cap \mathcal{B}(x')$. By the definition of $\mathcal{R}_{\mathcal{D}_{T_i}}(h)$, we have $h(x) = h(x') = h(x'')=i$, which contradicts to $x'\in \mathcal{M}^i(h)$. Therefore, the consistency error on the subpopulations $\mathcal{R}_{\mathcal{D}_{T_i}}(h)\geq \mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{N}(\mathcal{M}(h))\setminus \mathcal{M}(h)]>\min\{q,\gamma \}$, which contradicts to the definition of $G_1$ that $\mathcal{R}_{\mathcal{D}_{T_i}}(h)\leq\min \{q,\gamma \}$. 

For $i\in G_2$, by the Lemma 1 in \cite{NIPS_2021_cycle}, we have:
\begin{equation}\label{thm1:help2}
    \sum_{i \in G_2} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \leq \frac{\mathcal{R}_{\mathcal{D}_T}(h)}{\min{\{q,\gamma\}}},
\end{equation}
otherwise, $\mathcal{R}_{\mathcal{D}_T}(h)> \sum_{i\in G_2}\mathbb{P}_{\mathcal{D}_T}[\mathcal{D}_{T_i}]\min{\{q,\gamma\}}>\mathcal{R}_{\mathcal{D}_T}(h)$, which forms contradiction.

The consistency error on the subpopulation of $G_2$ is greater than $\min{\{\gamma,q\}}$, we use our divided source-like set to estimate the target error $\epsilon_{\mathcal{D}_{T_i}}$. Following the Theorem 2 in \cite{ben2010theory}, for all $h$ in the model space of $C$-way classification task $\mathcal{H}$, we have:
\begin{equation}\label{thm1:help3}
\begin{aligned}
    \epsilon_{\mathcal{D}_{T_i}}(h) &= \mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{D}_{S_i}] \epsilon_{\mathcal{D}_{S_i}}(h) + \mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{D}_{O_i}]\epsilon_{\mathcal{D}_{O_i}}(h)\\
    &\leq 
    \mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{D}_{S_i}] \epsilon_{\mathcal{D}_{S_i}}(h)
    +\mathbb{P}_{\mathcal{D}_{T_i}}[\mathcal{D}_{O_i}]
    \left(
    \epsilon_{\mathcal{D}_{S_i}}(h)+ d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})
    +\lambda_i
    \right) \\
    &\leq \epsilon_{\mathcal{D}_{S_i}}(h) +d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})
    +\lambda_i,
\end{aligned}
\end{equation}
where $\lambda_i = \min_{h\in\mathcal{H}} \{ \epsilon_{\mathcal{D}_{S_i}}(h)+ \epsilon_{\mathcal{D}_{O_i}}(h)\}$.
Organizing Eqn. \ref{thm1:help1},\ref{thm1:help2},\ref{thm1:help3} into Eqn. \ref{thm1:help0}, we have:

\begin{equation}\label{eq:help1}
    \begin{aligned}
        \epsilon_{\mathcal{D}_T}&\leq \sum_{i \in G_1} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] q + \sum_{i\in G_2} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \epsilon_{\mathcal{D}_{S_i}}(h) + \max_i \{d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})\} + {\lambda}' \\
        &\leq q + \sum_{i\in G_2} \mathbb{P}_{\mathcal{D}_{T}}[\mathcal{D}_{T_i}] \epsilon_{\mathcal{D}_{S_i}}(h) + \max_i \{d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})\} + {\lambda}' \\
         (\text{by Eqn. \ref{thm1:help2}})& \leq \frac{\mathcal{R}_{\mathcal{D}_T}(h)}{\min{\{q,\gamma\}}} \epsilon_{\mathcal{D}_{S}}(h)
         +\max_i \{d_{\mathcal{H}\Delta\mathcal{H}}(\mathcal{D}_{S_i},\mathcal{D}_{O_i})\} + {\lambda}'+q\\
    \end{aligned}
\end{equation}
where ${\lambda' = \min_{h\in \mathcal{H}}\{  \epsilon_{\mathcal{D}_{S}}(h)+ \epsilon_{\mathcal{D}_{O}}(h)}\}$.
Then, there is:
\begin{equation}\label{eq:help2}
\begin{aligned}
    \epsilon_{\mathcal{D}_{S}}(h)
    &=\sum_{i\in I}   \epsilon_{\mathcal{D}_{S_i}}(h)
    \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]
    +
    \sum_{i\in [c] \setminus I}  \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]\epsilon_{\mathcal{D}_{S_i}}(h) \\
    \text{(by Lemma \ref{lemma:popI})}
    &\leq \frac{1}{\gamma}(\mathbb{P}_{x\sim\mathcal{D}_{S}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S}}(h_{pl})+q) + \sum_{i\in [c] \setminus I}  \mathbb{P}_{\mathcal{D}_{S}}[\mathcal{D}_{S_i}]\epsilon_{\mathcal{D}_{S_i}}(h) \\
    \text{(by Lemma \ref{lemma:errI})}
    & \leq \frac{1}{\gamma}(\mathbb{P}_{x\sim\mathcal{D}_{S}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S}}(h_{pl})+q) \\
    &+ \mathbb{P}_{x\in\mathcal{D}_{S}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S}}(h_{pl})+2q\\
    & \leq \frac{1+\gamma}{\gamma}(\mathbb{P}_{x\sim\mathcal{D}_{T}}[h(x)\neq h_{pl}(x)]-\epsilon_{\mathcal{D}_{S}}(h_{pl})+q)+q.
\end{aligned}
\end{equation}
Combining the results of Eqn. \ref{eq:help1} and Eqn. \ref{eq:help2}, we prove the result of Theorem \ref{thm:main1}. Specifically, in Eqn. \ref{eq:main}
, the $\lambda = \lambda'+q(1+\frac{\mathcal{R}_{\mathcal{D}_T}(h)(1+\gamma)}{\gamma \cdot \min{\{q,\gamma\}}})$ is a constant $w.r.t$ the expansion constant $q$ and task risk of ideal optimal model.
\end{proof}

\section{Additional Experimental Details}\label{supple_details}
\subsection{Implementation Details}
We train our model on four Nvidia Geforce GTX 1080Ti graphic cards, using SGD with a momentum of 0.9, and a weight decay of 0.0005. We conduct experiments on VisDA, Office-Home and DomainNet and set the batch size to 64 for all benchmarks. The initial learning rate is set as 5e-4 for VisDA, 2e-2 for Office-Home, and 1e-2 for DomainNet. The total epoch is set as 60 for VisDA, 30 for Office-Home and DomainNet. 
We apply the learning rate scheduler $\eta = \eta_0(1+15p)^{3/4}$ following~\cite{shot}, where training process $p$ changes from 0 to 1, and we further reduce the learning rate by a factor of 10 after 40 epochs on Visda, 15 epochs on Office-Home and DomainNet. We find that most hyperparameters of \textit{DaC} do not require to be heavily tuned. As can be seen in Table \ref{tab:sensitive}, the performance is not sensitive to the choice of $\tau_c$, and we set the confidence threshold $\tau_c$ as 0.95 for all experiments following \cite{fixmatch,li2021semiuda}.
We adopt a set of hyperparameters $\alpha=0.5,\beta=0.5,K=5$ for the large scale benchmarks VisDA and DomainNet, and $\alpha=0.7,\beta=0.3,K=3$ for most transfer senarios of Office-Home. 
\begin{table}[!htbp]
    \vspace{-3mm}
    \centering
    \caption{Sensitive analysis of $\tau_c$.}
    \label{tab:sensitive}
    \begin{tabular}{ccccccc}
					\toprule
					$\tau_c$ & 0.91 &	0.93 & 0.95 & 0.97 & 	0.98 &	target-supervised   \\
					\midrule
					\multicolumn{1}{c}{Avg. (\%)} & 87.06 &	87.27 &	87.34 & 87.39 &	87.19 &	89.6\\
					\bottomrule
		\end{tabular}

    \vspace{-3mm}
\end{table}

\subsection{Baseline Methods on DomainNet}
We compare \textit{DaC} with source-present and source-free domain adaptation methods.
DomainNet is widely used in multi-source domain adaptation tasks, and its subset is used as one of the benchmarks of single-source domain adaptation benchmark by \cite{saito2019semidomainnet}. The results of MME~\cite{saito2019semidomainnet} and CDAN~\cite{long2018conditional} are copied from \cite{saito2019semidomainnet}. The rest source-present and source-free methods are implemented by their official codes. We choose the learning rate for all baselines by five-fold cross-validation, and apply the training scheduler of their own. 

\section{Algorithm for DaC}\label{supple_Algo}
As shown in Algorithm \ref{alg:dac}, our method consists of self-training by pseudo-labeling, adaptive contrastive learning, and distribution alignment.
After self-training to achieve preliminary class-wise adaptation, we divide target data as source-like and target-specific to conduct representation learning. The adaptive contrastive learning framework exploits local and global information and improves feature discriminability. Distribution alignment reduces the mismatching between source-like and target-specific samples.   




\begin{algorithm}
\caption{Training of DaC}\label{alg:dac}
\begin{algorithmic}
\Require unlabeled target data $\mathcal{D}_T=\{x_i\}_{i=1}^{n_t}$, source model:$g_s, \phi_s$, augmentation set $\mathcal{A}=\{\mathcal{A}_w,\mathcal{A}_s\}$, threshold $\tau$, batch size $B$.
\State \textbf{Initialization:} target model $h = g \circ \phi, g = g_s, \phi =\phi_s$, memory bank by forward computation: $\mathcal{F} = \phi_s(\mathcal{D}_T)$, source-like and target specific features by Eqn. \ref{eq:div_sl1}.
\While{$e < \text{MaxEpoch}$}
\State Obtain the pseudo labels $\tilde{\mathcal{Y}}$ based on Eqn. \ref{pl}.
\For{$t=1 \to \text{NumIters}$}
\State From $\mathcal{D}_T\times \tilde{\mathcal{Y}}$, draw a mini-batch $\mathcal{B}_t = \{(x_i,\tilde{y}_i),i\in\{1,2,\dots,B\} \}$.\Comment{batch-training}
\For{$b = 1\to B$}
\State $p_i^w = \delta(h(\mathcal{A}_{w}(x_i)), p_i^s = \delta(h(\mathcal{A}_{s}(x_i))$;
\State $\vf_i = \phi(\mathcal{A}_{w}(x_i)), \vf_i^s = \phi(\mathcal{A}_{s}(x_i))$;
\State  $\vz_i = m\vz_i+(1-m)\vf_i$;
\Comment{update memory bank}
\State update the source-like and target-specific sample based on Eqn. \ref{eq:div_sl2}.
\Comment{divide}
\EndFor
\State Compute $\mathcal{L}_{self}$ using by Eqn. \ref{eq:ce} \Comment{self-training};
\State Generate prototypes $\vk^+,\{\vw\}, \{\vv\}$ from memory bank;
\State Compute $\mathcal{L}_{con}$ by Eqn. \ref{eq:contrastive}; \Comment{contrast}
\State Compute $\mathcal{L}_{\textit{EMMD}}$ by Eqn. \ref{eq:emmd}; \Comment{distribution alignment}
\State $\mathcal{L}=\mathcal{L}_{\text {con }}+\alpha \mathcal{L}_{\text {self }}+\beta \mathcal{L}_{\textit{EMMD}}$;
\State $\phi = SGD(\mathcal{L},\phi)$.
\EndFor
\EndWhile
\State\textbf{Output} $g_s\circ \phi$
\end{algorithmic}
\end{algorithm}


\end{document}