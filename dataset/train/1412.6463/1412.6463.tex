
\documentclass[10pt, conference, letterpaper]{IEEEtran}

\usepackage{mathtools,dsfont}
\usepackage{psfrag,bbm,graphicx}
\usepackage{algorithm,algorithmic}
\usepackage{comment,balance}
\usepackage{epstopdf}
\usepackage{epsfig}
\usepackage{multicol}
\usepackage{multirow, cite}
\usepackage{amsfonts}
\usepackage{color}

\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{exercise}{Exercise}
\newtheorem{example}{Example}
\newtheorem{prop}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{infthm}{Informal Theorem}
\newtheorem{assumption}{Assumption}


\def\EE{{\mathbb{E}}}
\def\PP{{\mathbb{P}}}
\def\BB{{\mathcal{B}}}
\def\MI{{\mathcal{I}}}
\def\setR{\mathbb{R}}
\def\setZ{\mathbb{Z}}
\def\setC{\mathbb{C}}
\def\setN{\mathbb{N}}
\def\bZ{\mathbf{Z}}
\def\bz{\mathbf{z}}
\def\FF{\mathcal{F}}
\newcommand{\fall}{\,\forall\,}
\def\vecV{\underbar{v}}
\def \OO {\mathrm{O}}
\def \oo {\mathrm{o}}
\def \idle {k}

\begin{document}

\title{Serving Content with Unknown Demand:\\ the High-Dimensional Regime}
\author{
	\IEEEauthorblockN{Sharayu Moharir, Javad Ghaderi, Sujay Sanghavi and Sanjay Shakkottai} \\
}


\maketitle

\begin{abstract}
In this paper we look at content placement in the high-dimensional regime: there are  servers, and  distinct types of content. Each server can store and serve  types at any given time. Demands for these content types arrive, and have to be served in an online fashion; over time, there are a total of  of these demands. We consider the algorithmic task of content placement: determining which types of content should be on which server at any given time, in the setting where the demand statistics (i.e. the relative popularity of each type of content) are not known a-priori, but have to be inferred from the very demands we are trying to satisfy. This is the high-dimensional regime because this scaling (everything being ) prevents consistent estimation of demand statistics; it models many modern settings where large numbers of users, servers and videos/webpages interact in this way.

We characterize the performance of \textit{any} scheme that separates learning and placement (i.e. which use a portion of the demands to gain some estimate of the demand statistics, and then uses the same for the remaining demands), showing it is order-wise strictly suboptimal. We then study a simple adaptive scheme - which myopically attempts to store the most recently requested content on idle servers - and show it outperforms schemes that separate learning and placement. Our results also generalize to the setting where the demand statistics change with time. Overall, our results demonstrate that separating the estimation of demand, and the subsequent use of the same, is strictly suboptimal.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Ever increasing volumes of multimedia content is now requested and
delivered over the Internet. Content delivery systems (e.g., YouTube
\cite{Youtube}), consisting of a large collection of servers (each
with limited storage/service capability), process and service these
requests. Naturally, the storage and content replication strategy
(i.e., what content should be stored on each of these servers) forms an
important part of the service and storage architecture.\footnote{An earlier version of this work appears in the
	Proceedings of ACM Sigmetrics, Austin, USA, June 2014
	\cite{SGSS14}.}.

Two trends have emerged in such settings of large-scale distributed
content delivery systems. First, there has been a sharp rise in not
just the volume of data, but indeed in \textit{the number
	of content-types} (e.g., number of distinct YouTube videos) that are
delivered to users~\cite{Youtube}. Second, the popularity and demand
for most of this content is \textit{uneven and ephemeral}; in many
cases, a particular content-type (e.g., a specific video clip) becomes
popular for a small interval of time after which the demand
disappears; further a large fraction of the content-types languish in
the shadows with almost no demand~\cite{Gill07,temporal13}.

To understand the effect of these trends, we study a stylized model
for the content placement and delivery in large-scale distributed
content delivery systems. The system consists of  servers, each
with constant storage and service capacities, and 
content-types ( is some constant number). We consider the
scaling where the system size  tends to infinity. The requests for
the content-types arrive dynamically over time and need to be served
in an online manner by the free servers storing the corresponding
contents. The requests that are ``deferred'' (i.e., cannot be
immediately served by a free server with requested content-type) incur
a high cost. To ensure reliability, we assume that there are
alternate server resources (e.g., a central server with large enough
backup storage and service capacity, or additional servers that can be
freed up on-demand) that can serve such deferred requests.

The performance of any content placement strategy crucially depends on
the popularity distribution of the content. Empirical studies in many
services such as YouTube, Peer-to-Peer (P2P) VoD systems, various
large video streaming systems, and web caching,
\cite{Gill07,BC99,YZ06,IRF04,VA02} have shown that access for
different content-types is very inhomogeneous and typically matches
well with power-law (Zipf-like) distributions, i.e., the request rate
for the -th most popular content-type is proportional to ,
for some parameter .  For the performance analysis, we assume
that the content-types have a popularity that is governed by some
power-law distribution with unknown  and further this
distribution changes over time.

Our objective is to provide efficient content placement strategies
that minimize the number of requests deferred. It is natural to expect
that content placement strategies in which more popular content-types
are replicated more will have a good performance. However, there is
still a lot of flexibility in designing such strategies and the extent
of replication of each content-type has to be determined.  Moreover, the
requests arrive dynamically over time and popularities of different
content-types might vary significantly over time; thus the content
placement strategy needs to be online and robust.

The fact that the number of contents is very large and their
popularities are time-varying creates two new challenges that are not
present in traditional queueing systems. First, it is imperative to
{\em measure the performance of content replication strategies over
	the time scale in which changes in popularities occur}. In
particular, the steady-state metrics typically used in queueing
systems are not a right measure of performance in this context.
Second, the number of content-types is enormous and {\em learning the
	popularities of all content-types over the time scale of interest is
	infeasible}. This is in contrast with traditional multi-class
multi-server systems where the number of demand classes does not scale
with the number of servers (low-dimensional setting) and thus learning
the demand rates can be done in a time duration that does not scale
with the system size.

\subsection{Contributions}

The main contributions of our work can be summarized as follows.

\textbf{Modeling Contribution:} We recognize that we are in the high-dimensional regime with unknown demand, that it is fundamentally different from the low-dimensional setting (finite number of content-types) and propose a model that captures this difference.

\textbf{Analytical Contributions:} In Section \ref{subsec:LBSSP}, we show that in this high-dimensional setting where the demand statistics are not known a-priori, the ``\textit{learn-and-optimize}'' approach, i.e., learning the demand statistics from requests and then locally caching content on
servers using the estimated statistics, is strictly
sub-optimal, even when using high-dimensional estimators such as the
Good-Turing estimator \cite{MS00} (Theorem~\ref{thm:converse}). This is in contrast to the
conventional low-dimensional setting where the ``learn-and-optimize'' approach is asymptotically optimal.

In addition, in Section \ref{subsec:MYOPIC}, we study an adaptive content
replication strategy which myopically attempts to cache the most
recently requested content-types on idle servers. Our key result is
that even this simple adaptive strategy strictly outperforms
\textit{any} content placement strategy based on the
``learn-and-optimize'' approach (Theorem~\ref{thm:MYOPIC_static_arrival_rates}). Our results also generalize to the
setting where the demand statistics change with time (Theorems~\ref{thm:converse_2} and \ref{thm:MYOPIC_changing_arrival_rates}).

Overall, our results demonstrate that separating the estimation of
demands and the subsequent use of the estimations to design optimal
content placement policies is deprecated in the high-dimensional
setting.


\subsection{Organization and Basic Notations}
The rest of this paper is organized as follows. We describe our system model and setting in Section \ref{sec:system_model}. The main results are presented in Section \ref{sec:main_results}. Our simulation results are discussed in Section \ref{sec:simulation_results}. Section \ref{proofs} contains the proofs of some of our results. Section \ref{sec:related} gives an overview of related works. We finally end the paper with conclusions. 

Some of the basic notations are as follows. Given two functions  and , we write  if .  if . If both  and , then . Similarly,  if , and  if . The term  means with high probability as .  

\section{Setting and Model}
\label{sec:system_model}
In this section, we consider a stylized model for large scale
distributed content systems that captures two emerging trends, namely,
a large number of content types, and uneven and time-varying demands.

\subsection{Server and Storage Model}


The system consists of  front-end servers, each of which can hold one content piece, and serve one user, at any time. In addition, there is a back-end server that stores the entire
catalog of  content-types (one copy of each content-type, e.g., a
copy of each YouTube video). The contents can be copied from the
back-end server and placed on the front-end servers. 

Since we are interested in the scaling performance, as , for clarity we assume that there are  servers and each server can store  content and can serve 
request at any time. If instead of one content, each front-end server can store at most  content pieces ( is a constant) and serve at most  requests at each time, the performance can be bounded from above by the performance of a system with  servers with a storage of  each, and from below by that of another system with  servers with a storage of  each. Thus asymptotically in a scaling-sense, the system is still equivalent to a system of  servers where each server can store  content and can serve  content request at any time. 



\subsection{Service Model}
When a request for a content arrives, it is routed to an idle
(front-end) server which has the corresponding content-type stored on
it, if possible. We assume that the service time of each request is
exponentially distributed with mean 1. The requests have to be served
in an online manner; further service is non-preemptive, i.e., once a
request is assigned to a server, its service cannot be interrupted and
also cannot be re-routed to another server. Requests that cannot be
served (no free server with requested content-type) incur a high cost
(e.g., need to be served by the back-end server, or content needs to
be fetched from the back-end server and loaded on to a new server). As
discussed before, we refer to such requests as deferred requests. The
goal is to design content placement policies such that the number of
requests deferred is minimized.

\subsection{Content Request Model}
There are  content-types (e.g.,  distinct YouTube videos). We
consider the setting where the number of content-types  is very
large and scales linearly with the system size , i.e.,  for some constant . We assume that requests for
each content arrive according to a Poisson process and request rates
(popularities) follow a Zipf distribution. Formally, we make the
following assumptions on the arrival process.
\begin{assumption}(Arrival and Content Request Process)
	\label{ass:zipf}
	\begin{itemize}
		\item[-] The arrival process for each content-type  is a Poisson
		process with rate .
		
		\item[-] The load on the system at any time is , where
		
		
		\item[-] Without loss of generality, content-types are indexed in the
		order of popularity. The request rate for content-type  is
		 where  for
		some . This is the Zipf distribution with parameter
		.
		
		
	\end{itemize}
\end{assumption}
We have used the Zipf distribution to model the popularity
distribution of various contents because empirical studies in many
content delivery systems have shown that the distribution of
popularities matches well with such distributions, see e.g.,
\cite{Gill07}, \cite{BC99}, \cite{YZ06}, \cite{IRF04}, \cite{VA02}.


\subsection{Time Scales of Change in Arrival Process}
\label{subsec:change_model}
A key trend discussed earlier is the time-varying nature of
popularities in content delivery systems \cite{Gill07,temporal13}. For
example, the empirical study in \cite{Gill07} (based on 25 millions
transactions on YouTube) shows that daily top 100 list of videos
frequently changes.
To understand the effect of this trend on the performance of content
placement strategies, we consider the following two change models.\\

\noindent \textbf{Block Change Model:} In this model, we assume that
the popularity of various content-types remains constant for some
duration of time , and then changes to some other arbitrarily
chosen distribution that satisfies Assumption \ref{ass:zipf}. Thus
 reflects the time-scale over which changes in popularities
occur. Under this model, we characterize the performance of content
placement strategies over such a time-scale . \\

\noindent \textbf{Continuous Change Model:} Under this model, we
assume that each content-type has a Poisson clock at some constant
rate . Whenever the clock of content-type  ticks,
content-type  exchanges its popularity with some other content-type
, chosen uniformly at random. Note that the average time over which
the popularity distribution ``completely'' changes is comparable to
that of the Block Change Model; however, here the change occurs incrementally
and continuously. Note that this model ensures that the
content-type popularity always has the Zipf distribution.
Under this model, we characterize the performance of content placement
strategies over constant intervals of time.

\section{Main Results and Discussion}
\label{sec:main_results}

In this section, we state and discuss our main results. The
proofs are provided in Section \ref{proofs}.


\subsection{Separating Learning from Content Placement}
\label{subsec:LBSSP}
In this section, we analyze the performance of storage policies which
separate the task of learning and that of content placement as
follows. Consider time intervals of length . The operation of
the policy in each time interval is divided into two phases:\\

\noindent \textbf{Phase 1. Learning:} Over this interval of time, use
the demands from the arrivals (see Figure
\ref{fig:learning_based_storage}) to estimate
the content-type popularity statistics. \\\\
\noindent \textbf{Phase 2. Storage:} Using the estimated popularity of
various content-types, determine which content-types are to be replicated
and stored on each server. The storage is fixed for the remaining time
interval. The content-types not requested even once in the learning
phase are treated equally in the storage phase. In other words, the
popularity of all {\em unseen} content-types in the learning phase is
assumed to be the same.\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.4]{learning_based_algos.eps}
		\caption{Learning-Based Static Storage Policies -- \sl The interval
			 is split into the Learning and Storage phases. The length of time spent in the Learning phase can be chosen optimally using the knowledge of the value of  and the Zipf parameter . \label{fig:learning_based_storage}}
	\end{center}
\end{figure}

Further, we allow the interval of time for the Learning phase potentially
to be chosen optimally using knowledge of  (the interval over
which statistics remain stationary) and  (the Zipf parameter
for content-types popularity).


This is a natural class of policies to consider because it is obvious
that popular content-types should be stored on more servers than the
less popular content-types. Therefore, knowing the arrival rates can
help in the design of better storage policies. Moreover, for the
content-types which are not seen in the learning phase, the storage
policy has no information about their relative popularity. It is
therefore natural to treat them as if they are equally popular.

The replication and storage in Phase~2 (Storage) can be performed by
\textit{any} static policy that relies on the knowledge (estimate) of
arrival rates, e.g., the proportional placement policy \cite{LLM12}
where the number of copies of each content-type is proportional
to its arrival rate, or the storage policy of \cite{LLM13} which was
shown to be approximately optimal in the steady state.

We now analyze the performance of learning-based static storage
policies under the Block Change Model defined in Section
\ref{subsec:change_model} where the statistics remain invariant over
the time intervals of length . The performance metric of
interest is the number of requests deferred by any policy belonging to
class of learning-based static storage policies in the interval of
interest. We assume that at the beginning of this interval, the
storage policy has no information about the relative popularity of
various content-types. Therefore, we start with an initial loading
where each content-type is placed on exactly one server. This loading is
not changed during Phase 1 (the learning phase) at the end of which,
the content-type on idle servers is changed as per the new storage
policy. As mentioned before, this storage is not changed for the
remaining duration in the interval of interest.




Theorem 1 in \cite{SGSS14} provides a lower bound on the number of requests
deferred by any learning-based static storage policy for the Block Change Model for the Zipf distribution with parameter . The following theorem provides a stronger bound on the performance of all learning based policies to extend this result for . This includes the case where , known to be a good fit for Video on Demand (VoD) systems \cite{fricker2012impact}.


\begin{theorem}
	\label{thm:converse}
	Under Assumption \ref{ass:zipf} and the Block Change Model defined in
	Section~\ref{subsec:change_model}, for , if , the expected number
	of requests deferred by any learning-based static storage policy is
	.
\end{theorem}

We therefore conclude that even if the division of the interval of
interest into Phase~1 (Learning) and Phase 2 (Storage) is done in the
optimal manner, no learning-based static storage policy can defer
fewer than  jobs in the interval of
interest. Therefore, Theorem \ref{thm:converse} provides a fundamental
lower bound on the number of jobs deferred by any policy which
separates learning and storage. It is worth pointing out that this
result holds even when the time-scale of change in statistics is quite
slow. Thus, even when , the time-scale over which statistics
remains invariant, goes to infinity and the time duration of the two phases
(Learning, Storage) is chosen optimally based on , ,  requests are still deferred.


The next theorem provides a lower bound on the number of requests deferred by any learning-based static storage policy for the Continuous Change Model.  As before, we assume that at the beginning of this interval, the storage policy has no information about content popularity and therefore, we start with an initial loading where each content-type is placed on exactly one server.

\begin{theorem}
	\label{thm:converse_2}
	Under Assumption \ref{ass:zipf} and the Continuous Change Model defined in
	Section~\ref{subsec:change_model}, for , if , the expected number
	of requests deferred by any learning-based static storage policy is
	.
\end{theorem}



Next, we explore \textit{adaptive storage policies} which perform the
task of learning and storage simultaneously.


\subsection{Myopic Joint Learning and Placement}
\label{subsec:MYOPIC}
We next study a natural adaptive storage policy called MYOPIC. In an
adaptive storage policy, depending on the requests that arrive and
depart, the content-type stored on a server can be changed when the server
is idle while other servers of the system might be busy serving
requests. Therefore, adaptive policies perform the tasks of learning
and placement jointly. Many variants of such adaptive policies have
been studied for decades in the context of cache management (e.g. LRU,
LRU-MIN \cite{LRU-MIN95}).


Let  refer to the  content-type, . The
MYOPIC policy works as follows: When a request for content-type 
arrives, it is assigned to a server if possible, or deferred
otherwise. Recall that a deferred request is a request for which on
arrival, no currently idle server can serve it and thus its service
invokes a backup mechanism such as a back-end server which can serve
it at a high cost. After the assigment/defer decision is made, if
there are no currently idle servers with content-type , MYOPIC
replaces the content-type of one of the idle servers with . This idle
server is chosen as follows:
\begin{itemize}
	\item[-] If there is a content-type  stored on more than one currently
	idle server, the content-type of one of those servers is replaced with
	,
	\item[-] Else, place  on that currently idle server whose content-type
	has been requested least recently among the content-types on the
	currently idle servers.
\end{itemize}
\noindent For a formal definition of MYOPIC, refer to Figure \ref{fig:MYOPIC}.\\

\begin{figure}[h]
	\hrule
	\vspace{0.1in}
	\begin{algorithmic}[1]
		\STATE On arrival (request for ) \textbf{do},
		\STATE Allocate request to an idle server if possible.
		\IF {no other idle server has a copy of ,}
		\IF {:  stored on  idle servers,}
		\STATE replace  with  on any one of them.
		\ELSE
		\STATE find : least recently requested on idle servers,\\ replace  with .
		\ENDIF
		\ENDIF
\end{algorithmic}
	\vspace{0.1in}
	\hrule
	\caption{MYOPIC -- \sl An adaptive storage policy which changes the content stored on idle servers in a greedy manner to ensure that recently requested content pieces are available on idle servers.}
	\label{fig:MYOPIC}
\end{figure}

\begin{remark} Some key properties of MYOPIC are:
	\begin{enumerate}
		\item The content-types on servers can be potentially changed only when
		there is an arrival.
		
		\item The content-type of at most one idle server is changed after each
		arrival. However, for many popular content-types, it is likely that
		there is already an idle server with the content-type, in which case
		there is no content-type change.
		
		\item To implement MYOPIC, the system needs to keep track of the time
		at which the recent most request of each content-type was made.
		
	\end{enumerate}
\end{remark}

The following theorem provides an upper bound on the number of
requests deferred by MYOPIC for the Block Change Model defined in Section
\ref{subsec:change_model}.
\begin{theorem}
	\label{thm:MYOPIC_static_arrival_rates}
	Under Assumption \ref{ass:zipf} and the Block Change Model defined in
	Section~\ref{subsec:change_model}, over any time interval  such
	that , the number of requests deferred by
	MYOPIC is  w.h.p.
\end{theorem}
We now compare this upper bound with the lower bound on the number of
requests deferred by any learning-based static storage policy obtained
in Theorem ~\ref{thm:converse}. 

\begin{corollary}
	\label{cor:MYOPIC_static_arrival_rates}
	Under Assumption \ref{ass:zipf}, the Block Change Model defined in
	Section \ref{subsec:change_model}, and for , over any time
	interval  such that  and , the expected number of requests deferred by
	any learning-based static storage policy is   and the
	number of requests deferred by the MYOPIC policy is 
	w.h.p.
\end{corollary}

For ,  and for ,  . Therefore,
from Corollary \ref{cor:MYOPIC_static_arrival_rates}, we conclude that
MYOPIC outperforms all learning-based static storage policies. Note
that:
\begin{itemize}
	\item[i.] Corollary \ref{cor:MYOPIC_static_arrival_rates} holds even
	when the interval of interest  grows to infinity (scaling
	polynomially in ), or correspondingly, even when the content-type
	popularity changes very slowly with time.
	
	\item[ii.] Even if the partitioning of the  into a Learning
	phase and a Static Storage phase is done in an optimal manner with
	the help of some side information , the MYOPIC
	algorithm outperforms any learning-based static storage policy.
	
	\item[iii.] Since we consider the high-dimensional setting, the
	learning problem at hand is a large-alphabet learning problem. It is
	well known that standard estimation techniques like using the
	empirical values as estimates of the true statistics is suboptimal
	in this setting. Many learning algorithm like the classical
	Good-Turing estimator \cite{MS00} and other linear estimators
	\cite{VV11} have been proposed, and shown to have good performance
	for the problem of large-alphabet learning. From Corollary
	\ref{cor:MYOPIC_static_arrival_rates}, we conclude that, even if the
	learning-based storage policy uses the best possible large-alphabet
	estimator, it cannot match the performance of the MYOPIC policy.
\end{itemize}


Therefore, in the high-dimensional setting we consider, separating the
task of estimation of the  demand statistics, and the subsequent use
of the same to design a static storage policy, is strictly
suboptimal. This is the key message of this paper.\\

Theorem \ref{thm:MYOPIC_static_arrival_rates} characterizes the
performance of MYOPIC under the Block Change Model, where the
statistics of the arrival process do not change in interval of
interest. To gain further insight into robustness of MYOPIC against
changes in the arrival process, we now analyze the performance of
MYOPIC when the arrival process can change in the interval of interest
according to the Continuous Change Model defined in
Section~\ref{subsec:change_model}.

Recall that under the Continuous Change Model, on average, we expect
 shuffles in the popularity of various content-types in an
interval of constant duration. For the Block Change Model, if , the entire popularity distribution can change at the end
of the block, which is equivalent to  shuffles. Therefore, for both
the change models, the expected number of changes to the popularity
distribution in an interval of constant duration is of the same
order. However, these changes occur constantly but slowly in the
Continuous Change Model as opposed to a one-shot change in the Block
Change Model.

\begin{theorem}
	\label{thm:MYOPIC_changing_arrival_rates}
	Under Assumption \ref{ass:zipf}, and the Continuous Change Model
	defined in Section \ref{subsec:change_model}, the number of requests
	deferred by the MYOPIC storage policy in any interval of constant
	duration is  w.h.p.
\end{theorem}

In view of Theorem \ref{thm:MYOPIC_static_arrival_rates}, if the
arrival rates do not vary in an interval of constant duration, under
the MYOPIC storage policy, the number of requests deferred in that
interval is  w.h.p. Theorem
\ref{thm:MYOPIC_changing_arrival_rates} implies that the number
of requests deferred in a constant duration interval is of the same
order even if the arrival rates change according to the Continuous
Change Model. This shows that the performance of the MYOPIC policy is
robust to changes in the popularity statistics.



We now compare the upper bound obtained in Theorem \ref{thm:MYOPIC_changing_arrival_rates} for the Continuous Change Model with the lower bound on the performance of any learning-based static storage policy obtained in Theorem \ref{thm:converse_2}.

\begin{corollary}
	\label{cor:MYOPIC_changing_arrival_rates}
	Under Assumption \ref{ass:zipf}, the Continuous Change Model defined in
	Section \ref{subsec:change_model}, and for , over any time
	interval of constant duration, the expected number of requests deferred by
	any learning-based static storage policy is  and the number of requests deferred by the MYOPIC policy is 
	w.h.p.
\end{corollary}

Thus, even for the Continuous Change Model, MYOPIC outperforms all Learning-based static policies.  Compared to the Block Change Model, Learning-based static policies are ``unsuitable" for the Continuous Change Model due to the following reasons:
\begin{itemize}
	\item[-] Content popularity can change while the system is in the learning phase. This makes the task of estimating content popularity more difficult.
	\item[-] Once storage is optimized for the estimated content popularity (at the end of Phase 1), it is not changed in Phase 2. However, content popularities will change (by a small amount) almost instantaneously after the learning period, thus making the storage suboptimal even if content popularity was estimated accurately in Phase 1.
\end{itemize}


\subsection{Genie-Aided Optimal Storage Policy}
\label{subsec:optimal}

In this section, our objective is to study the setting where the
demand statistics are available ``for free''. For the Block Change Model with known popularity statistics, we show that a simple
adaptive policy is optimal in the class of all policies which know
popularity statistics of various content-types. We denote the class of
such policies as  and refer to the optimal policy as the
GENIE policy.


\noindent Let the content-types be indexed from  to  and let
 be the  content-type. Without loss of generality, we
assume that the content-types are indexed in the order of popularity,
i.e,  for all . Let  denote the number of idle servers at time .

The key idea of the GENIE storage policy is to ensure that at any time
, if the number of idle servers is , the 
most popular content-types are stored on exactly one idle server
each. The GENIE storage policy can be implemented as follows. Recall
 is the  most popular content-type. At time ,
\begin{itemize}
	\item[-] If there is a request for content-type  with  then allocate the request to the corresponding idle
	server. Further, replace the content-type on server storing
	 with content-type 
	
	\item[-] If there is a request for content-type  with  defer this request. There is no storage update.
	
	\item[-] If there is a request for content-type  with  then allocate the request to the corresponding idle
	server. There is no storage update.
	
	\item[-] If a server becomes idle (due to a departure), replace its
	content-type with .
\end{itemize}

\noindent For a formal definition, please refer to Figure
\ref{policy:GENIE}. \\

\begin{figure}[h]
	\hrule
	\vspace{0.1in}
	\begin{algorithmic}[1]
		\STATE Initialize: Number of idle-servers .
		\WHILE {true}
		\IF {new request (for ) routed to a server,}
		\IF {,}
		\STATE replace content-type of idle server storing  with 
		\ENDIF
		\STATE 
		\ENDIF
		\IF{departure,}
		\STATE replace content-type of new idle server with 
		\STATE 
		\ENDIF
		\ENDWHILE
	\end{algorithmic}
	\vspace{0.1in}
	\hrule
	\caption{GENIE -- \sl An adaptive storage policy which has content popularity statistics available for ``free". At time , if the number of idle servers is , the  most popular content-types are stored on exactly one idle server each.}
	\label{policy:GENIE}
\end{figure}
\begin{remark} The implementation of GENIE requires replacing the
	content-type of at most one server on each arrival and departure.
\end{remark}

To characterize the performance of GENIE, we assume that the system
starts from the empty state (all servers are idle) at time . The
performance metric for any policy  is
, defined as the number of requests deferred by
time  under the adaptive storage policy .  We say that
an adaptive storage policy  is optimal if

for any storage policy  and any time .
Where Equation \ref{eq:stochastic_dominance} implies that,

for all  and .

\begin{theorem}
	\label{thm:stochastic_dominance}
	If the arrival process to the content-type delivery system is Poisson
	and the service times are exponential random variables with mean 1,
	for the Block Change Model defined in Section
	\ref{subsec:change_model}, let  be the number of
	requests deferred by time  under the adaptive storage policy
	. Then, we have that,
	
	for any storage policy  and any time .
\end{theorem}

Note that this theorem holds even if the s are not
distributed according to the Zipf distribution. We thus conclude that
GENIE is the optimal storage policy in the class of all storage
policies which at time , have no additional knowledge of the future
arrivals except the values of  for all content-types and
the arrivals and departures in . Next, we compute a lower
bound on the performance of GENIE.

\begin{theorem}
	\label{thm:GENIE_static_arrival_rates}
	Under Assumption \ref{ass:zipf}, for , the Block Change Model defined in Section \ref{subsec:change_model} and if the interval
	of interest is of constant length, the expected number of requests
	deferred by GENIE is .
\end{theorem}

From Theorems \ref{thm:MYOPIC_static_arrival_rates} and
\ref{thm:GENIE_static_arrival_rates} we see that there is a gap in the
performance of the MYOPIC policy and the GENIE policy (which has
additional knowledge of the content-type popularity statistics). Since
for the GENIE policy, learning the statistics of the arrival process
comes for ``free'', this gap provides an upper bound on the cost of
serving content-type with \emph{unknown} demands. We compare the
performance of the all the policies considered so far in the next
section via simulations.



As discussed before, the key property of the GENIE storage policy is that at time , if there are  idle servers, the policy ensures that exactly one copy of the  most popular contents is stored on the idle servers. In Figure \ref{policy:GENIE}, we describe how to preserve this property at all times, in the setting where content popularity remains constant in the interval of interest.  If content popularity is time-varying, as in the case of the Continous Change Model, to maintain this property, the policy needs to have instantaneous knowledge of any change in content popularity. Moreover, contents stored on idle servers might need to be changed at the instant of change in content popularity to ensure that the idle servers store the currently most popular contents at all times.


Since the MYOPIC and GENIE policies are adaptive policies, contents stored on the front-end servers are changed dynamically. Such content changes can be classified into two types: internal fetches and external fetches. An internal fetch occurs when a content is available on at least one front-end server and the storage policy needs to place a copy of this content on an idle front-end server. In such cases, we assume that the new copy is fetched internally from one of the local (front-end) servers storing this content. An external fetch occurs when the content is currently not stored on any of the front-end servers (busy/idle) and hence the copy needs to be fetched externally from the back-end server. The external fetches incur a much higher cost compared to the internal fetches as data transfer from outside is subject to high delay and/or bandwidth consumption. The next theorem provides bounds on the number of external fetches performed to implement the MYOPIC and GENIE policies under the Block Change Model. Since the comparison depends on the initial storage of servers at the beginning of the block, we consider the worst initial case for the MYOPIC policy which is an empty system.
\begin{theorem}
	\label{thm:adaptation_cost}
	Let   be the number of external fetches made while implementing the storage policy  in the time-interval . Under Assumption 1, for , the Block Change Model and assuming we start from an empty system, for ,
	\begin{itemize}
		\item [(i)]  w.h.p.
		\item [(ii)] \} w.h.p.
	\end{itemize}
\end{theorem}

Thus the MYOPIC policy incurs fewer external fetches compared to the GENIE policy. This is not surprising as the GENIE storage policy is designed with the objective of minimizing the number of deferred requests, and hence it is more aggressive in changing the contents stored on servers in order to minimize the probability that the next request is deferred.

\section{Simulation Results}
\label{sec:simulation_results}

We compare the performance of the MYOPIC policy with the performance of the GENIE policy and the following two learning-based static storage policies:
\begin{itemize}
	\item [-] The \emph{``Empirical + Static Storage''} policy uses the empirical popularity statistics of content types in the learning phase as estimates of the the true popularity statistics. At the end of the learning phase, the number of servers on which a content is stored is proportional to its estimated popularity.
	\item [-] The \emph{``Good Turing + Static Storage''} policy uses the
	Good-Turing estimator \cite{MS00} to compute an estimate of the
	missing mass at the end of the learning phase. The missing mass is
	defined as total probability mass of the content types that were not
	requested in the learning phase. Recall that we assume that learning-based static storage policies treat all the missing content-types equally, i.e., all missing content-types are estimated to be equally popular.
	
	Let  be the total probability mass of the content types that were not requested in the learning
	phase and  be the set of content types which were requested
	exactly once in the learning phase. The Good-Turing estimator of
	the missing mass  is given by
	
	See \cite{MS00} for details.
	
	Let  be the number of times content  was requested in the
	learning phase and  be the set of
	content-types not requested in the learning phase. The ``Good Turing + Static Storage'' policy computes an estimate of the content-popularity as follows:
	\begin{itemize}
		\item[i:] If , .
		\item[ii:] If , .
	\end{itemize}
	At the end of the learning phase, the number of servers on which a content is stored is proportional to its estimated popularity.
\end{itemize}

We simulate the content distribution system for arrival and service process which satisfy Assumption \ref{ass:zipf} to compare the performance of the four policies mentioned above and also understand how their performance depends on various parameters like system size , load  and Zipf parameter . In Tables \ref{table:diff_n}, \ref{table:diff_beta} and \ref{table:diff_load}, we report the mean and variance of the fraction of jobs served by the policies over a duration of 5~s ().

For each set of system parameters, we repeat the simulations between 1000 to 10000 times for each policy in order to ensure that the standard deviation of the quantity of interest (fraction of jobs served) is small and comparable. For the two adaptive policies (GENIE and MYOPIC), the results are averaged over 1000 iterations and for the learning-based policies (``Empirical + Static Storage'' and ``Good-Turing + Static Storage''), the results are averaged over 10000 iterations. In addition, the results for the learning-based policies are reported for empirically optimized values for the fraction of time spent by the policy in learning the distribution.




In Table \ref{table:diff_n}, we compare the performance of the policies for different values of system size (). For the results reported in Table \ref{table:diff_n}, the ``Empirical + Static Storage'' policy learns for 0.1~s and the ``Good Turing + Static Storage'' policy learns for 0.7~s. The performance of all four policies improves as the system size increases and the adaptive policies significantly outperform the two learning-based static storage policies. Figure \ref{fig:diff_n} is a plot of the mean values reported in Table \ref{table:diff_n}.



\begin{table}[h]
	
	\centering
	\begin{tabular}{l r c c }
		\hline\hline
		Policy &  & Mean &  \\ [0.5ex] \hline GENIE & 200 & 0.9577 & 0.0081  \\
		& 400 & 0.9698 & 0.0045 \\
		& 600 & 0.9752 & 0.0034 \\
		& 800 & 0.9788 & 0.0030 \\
		& 1000 & 0.9814 & 0.0025 \\
		\hline
		MYOPIC & 200 & 0.8995  & 0.0258 \\
		& 400 & 0.9260  & 0.0167  \\
		& 600 & 0.9380  & 0.0132 \\
		& 800 & 0.9481  & 0.0101 \\
		& 1000 & 0.9532 & 0.0080 \\
		\hline
		Empirical + Static Storage & 200 & 0.6292 & 0.0662  \\
		& 400 & 0.6918 & 0.0443 \\
		& 600 & 0.7246 & 0.0353 \\
		& 800 & 0.7464 & 0.0304 \\
		& 1000 & 0.7622 & 0.0268 \\
		\hline
		Good Turing + Static Storage & 200 & 0.6875 & 0.0274  \\
		& 400 & 0.7249 & 0.0180  \\
		& 600 & 0.7443 & 0.0140 \\
		& 800 & 0.7566 & 0.0118 \\
		& 1000 & 0.7651 & 0.0104 \\
		\hline
	\end{tabular}
	\caption{\sl The performance of the four policies as a function of the system size  for fixed values of load  and . The values reported are the mean and standard deviation () of the fraction of jobs served. Both adaptive policies (GENIE and MYOPIC) significantly outperform the two learning-based static storage policies.}
	
	\label{table:diff_n} \end{table}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.35]{10000_iterations_eps.eps}
		\caption{\sl Plot of the mean values reported in Table \ref{table:diff_n} -- performance of the storage policies as a function of system size  for  and . \label{fig:diff_n}}
	\end{center}
\end{figure}

In Table \ref{table:diff_beta}, we compare the performance of the policies for different values of Zipf parameter . For the results reported in Table \ref{table:diff_beta}, the duration of the learning phase for both learning based policies is fixed such that the expected number of arrivals in that duration is 100. The performance of all four policies improves as the value of the Zipf parameter  increases, however, the MYOPIC policy outperforms both learning-based static storage policies for all values of  considered.


\begin{table}[h]
	\centering
	\begin{tabular}{l c c c }
		\hline\hline
		Policy &  & Mean &  \\ [0.5ex] \hline GENIE & 2 & 0.9939 & 0.0026 \\
		& 3 & 0.9996 & 0.0015 \\
		& 4 & 0.9998 & 0.0011 \\
		& 5 & 0.9998 & 0.0012 \\
		& 6 & 0.9998 & 0.0011 \\
		\hline
		MYOPIC & 2 & 0.9778 & 0.0078 \\
		& 3 & 0.9960 & 0.0033 \\
		& 4 & 0.9982 & 0.0026 \\
		& 5 & 0.9990 & 0.0018 \\
		& 6 & 0.9993 & 0.0013 \\
		\hline
		Empirical + Static Storage & 2 & 0.8594 & 0.0194  \\
		& 3 & 0.9228 & 0.0155 \\
		& 4 & 0.9397 & 0.0119 \\
		& 5 & 0.9453 & 0.0095 \\
		& 6 & 0.9495 & 0.0073 \\
		\hline
		Good Turing + Static Storage & 2 & 0.8436 & 0.0235  \\
		& 3 & 0.9198 & 0.0154 \\
		& 4 & 0.9378 & 0.0124 \\
		& 5 & 0.9456 & 0.0094 \\
		& 6 & 0.9491 & 0.0072 \\
		\hline
	\end{tabular}
	\caption{\sl The performance of the four policies as a function of the Zipf parameter  for fixed values of system size  and load . The values reported are the mean and standard deviation () of the fraction of jobs served. The MYOPIC policy outperforms the two learning-based static storage policies for all values of  considered.}
	
	\label{table:diff_beta} \end{table}

In Table \ref{table:diff_load}, we compare the performance of the policies for different values of load . For the results reported in Table \ref{table:diff_load}, the duration of the learning phase for both learning based policies is fixed such that the expected number of arrivals in that duration is 100. The performance of all four policies deteriorates as the load increases, however, for all loads considered, the MYOPIC policies outperforms the two learning-based static storage policies.

\begin{table}[h]
	\centering
	\begin{tabular}{l c c c }
		\hline\hline
		Policy &  & Mean &  \\ [0.5ex] \hline GENIE & 0.500 & 0.9892 & 0.0025 \\
		& 0.725 & 0.9788 & 0.0013 \\
		& 0.950 & 0.9531 & 0.0017 \\
		\hline
		MYOPIC & 0.500 & 0.9605 & 0.0113 \\
		& 0.725 & 0.9484 & 0.0105 \\
		& 0.950 & 0.8973 & 0.0221 \\
		\hline
		Empirical + Static Storage & 0.500 & 0.7756 & 0.0222  \\
		& 0.725 & 0.7705 & 0.0238 \\
		& 0.950 & 0.7352 & 0.0235 \\
		\hline
		Good Turing + Static Storage & 0.500 & 0.7849 & 0.0230  \\
		& 0.725 & 0.7589 & 0.0249 \\
		& 0.950 & 0.6869 & 0.0348 \\
		\hline
	\end{tabular}
	\caption{\sl The performance of the four policies as a function of the load  for fixed values of system size  and . The values reported are the mean and standard deviation () of the fraction of jobs served. The MYOPIC policy significantly outperforms the two learning-based static storage policies for all loads considered.}
	
	\label{table:diff_load} \end{table}


In Figure \ref{fig:adaptation_cost}, we plot the mean value (with error bars of 3std. dev.) of the number of external fetches made by the MYOPIC and GENIE storage policies for different values of  and  for a load of 0.9 averaged over 10000 iterations. As expected, the GENIE storage policy makes more external fetches than the MYOPIC policy.


\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.35]{adaptation_cost_eps.eps}
		\caption{\sl The mean number of external fetches (content fetched from the back-end server to place on a front-end server) by the two adaptive policies as a function of system size  for  and  and . The first plot shows the performance of both GENIE and MYOPIC. The second plot focuses only on the performance of the MYOPIC storage policy for clarity. \label{fig:adaptation_cost}}
	\end{center}
\end{figure}












\section{Proofs of Main Results}
\label{proofs}
In this section, we provide the proofs of our results. 
\subsection{Proof of Theorem 1}
\label{sec:proof2}

\noindent We first present an outline of the proof of Theorem \ref{thm:converse}. We consider two cases. We first focus on the case when the learning-based storage policies use fewer than  arrivals to learn the distribution.
\begin{enumerate}
	\item If the learning phase lasts for the first  arrivals for some , we show that under Assumption \ref{ass:zipf}, w.h.p., in the learning phase, there are no arrivals for at least  content types. (Lemma \ref{lemma:E_1}).
	\item Next, we show that w.h.p., among the first  arrivals, i.e., during the learning phase,  requests are deferred (Lemma \ref{lemma:E_2}).
	\item Using Lemma \ref{lemma:E_1}, we compute a lower bound on the number of requests deferred in Phase 2 (after the learning phase) by any learning-based static storage policy (Lemma \ref{lemma:phase2_drops}).
	\item Using Steps 2 and 3, we lower bound the number of requests deferred in the interval of interest.
\end{enumerate}

In the case when the learning phase lasts for more than  arrivals, we show that the number of requests deferred in the learning phase alone is , thus proving the theorem for this case.

\begin{lemma}
	\label{lemma:E_1}
	
	Let  be the event that in the first  arrivals, for  no more than  different types of contents are requested. Then,
	
	for  large enough.
\end{lemma}
\begin{proof}
	Recall  where  for .
	
	for  large enough.
	Therefore, for all ,
	
	The total mass of all content types  is
	
	
	Now, for  + 1, we have that,
	
	Therefore, the expected number of requests for content types  is less than . Using the Chernoff bound, the probability that there are more than  requests for content types  in the interval of interest is less than  for  large enough.
	
	Therefore, with probability greater than , the number different types of contents requests for in the interval of interest is less than . Hence the result follows.
\end{proof}

We use the following concentration result for Exponential random variables.
\begin{lemma}
	\label{lemma:sum_of_exponentials}
	Let  for , be i.i.d. exponential random variables with mean 1, then,
	
\end{lemma}
\begin{proof}
	This follows from elementary calculations, and is provided here for completeness. For any  and , by the Chernoff bound, we have that,
	
	Since  is an exponential random variable with mean 1, we have that,
	
\end{proof}

\begin{lemma}
	\label{lemma:E_2}
	Suppose the system starts with each content piece stored on exactly one server. Let  be the event that in the first  arrivals for  such that , at most  are served (not deferred). Then, for ,
	
\end{lemma}
\begin{proof}
	This proof is conditioned on the event  defined in Lemma \ref{lemma:E_1}. Conditioned on , in the first  arrivals, at most  different content types are requested. Therefore, at most  servers can serve requests during the first  arrivals.
	
	Let  be the event that the time taken for the first  arrivals is less than . Since the expected time for the first  arrivals is , by the Chernoff bound, . The rest of this proof is conditioned on the event .
	
	If the system serves (does not defer) more than  requests in this interval, at least one server needs to serve more than  requests. By substituting  and  in Lemma \ref{lemma:sum_of_exponentials}, we have that,
	
	Therefore, the probability that a server serves more than  requests in an interval of  time is . Therefore, using the union bound, the probability that none of these  servers serve more than  requests each in  time is greater than .
	Therefore, we have that,
	
	for  large enough.
\end{proof}

\begin{lemma}
	\label{lemma:phase2_drops}
	Let the interval of interest be  such that . If the learning phase of the storage policy lasts for the first  arrivals, , the expected number of requests deferred in Phase 2 is .
\end{lemma}
\begin{proof}
	Let  be the number of arrivals in Phase 2, then we have that,
	.
	
	Let  be the event that . Using the Chernoff bound, it can be shown that .
	
	The rest of this proof is conditioned on  defined in Lemma \ref{lemma:E_1} and  defined above. We consider the following two cases depending on the number of servers allocated to content types not seen in Phase 1.\\
	
	\noindent Case I: The number of servers allocated to content types not seen in Phase 1 is less than  for some . For ,
	
	
	Therefore, for all , 
	The total mass of all content types  is
	
	for  large enough.
	
	Therefore, the expected number of arrivals of types not requested in Phase 1 in Phase 2 is at least .
	
	Let  be the event that in Phase 2, there are at least  arrivals of types not requested in Phase 1. Using the Chernoff bound,
	
	
	Conditioned on , all but  content types, are not requested in Phase 1. Recall that all learning-based policies treat all these content types equally and that the total number of servers allocated to store the content types not seen in Phase 1 is less than . Let  be the probability that a content is not stored by the storage policy under consideration. Then,
	
	for  large enough. \\
	
	Let  and  be the number of requests deferred in Phase 2.
	
	Therefore,
	
	
	\noindent Case II: The number of servers allocated to content types not seen in Phase 1 is more than  for some .
	
	Let  be the number of servers allocated to store all content types that are requested in Phase 1. By our assumption, .
	
	Let  be the set of content types requested in Phase 1. Let  be the total mass of all content types . Let  be the fraction of requests for content-type  in Phase 1. By the definition of , the total empirical mass of all content types  is obviously .
	
	Recall that there are  arrivals in Phase 1. Let . We now use the Chernoff bound to compute a lower bound on the true mass , using a technique similar to that used in \cite{MS00} (Lemma 4). By the Chernoff bound, we know that,
	
	Let , then, we have that, with probability greater than ,
	
	Solving for , we get that, with probability greater than ,

for  large enough.
	Let , then we have that, with probability greater than ,

Conditioned on the event , there are at least  arrivals in Phase 2. The remainder of this proof is conditioned on . Let  be the number of arrivals of types  in phase 2. Let  be the event that
	 Since the expected number of arrivals of content types  in Phase 2 is at least
	
	using the Chernoff bound, we can show that
	
	The rest of this proof is conditioned on .
	By our assumption, the number of servers which can serve arrivals of types  in Phase 2 is . Therefore, if at least  requests are to be served in Phase 2, the sum of the service times of these  requests should be less than  (since the number of servers which can serve these requests is ). Let  be the event that the sum of  independent Exponential random variables with mean 1 is less than . By substituting  and  in Lemma \ref{lemma:sum_of_exponentials}, we have that,
	
	for  large enough. Hence,
	
\end{proof}

\begin{proof} (Proof of Theorem \ref{thm:converse}) \\
	We consider two cases: \\
	Case I: The learning phase lasts for the first  arrivals where . \\
	Let  be the number of requests deferred in Phase 1 and  be total number of requests deferred in the interval of interest. Then, we have that,
	
	By Lemmas \ref{lemma:E_2} and \ref{lemma:phase2_drops} and since , we have that,
	
	Case II: The learning phase lasts for longer than the time taken for the first  arrivals.\\
	By Lemma \ref{lemma:E_2}, the number of requests deferred in the first  arrivals is at least  with probability greater than . Therefore, we have that,
	
\end{proof}


\subsection{Proof of Theorem 2}
In this section, we provide an outline of the proof of Theorem \ref{thm:converse_2}. The proof follows on the same lines as the proof of Theorem \ref{thm:converse}.
\begin{enumerate}
	\item First, we show that w.h.p., among the first  arrivals, i.e., during the learning phase,  requests are deferred (Lemma \ref{lemma:E_2}).
	\item Since we are studying the performance of the MYOPIC policy for the Continuous Change Model, the relative order of popularity of contents keeps changing in the interval of interest. If the learning phase lasts for the first  arrivals for some , we show that under Assumption \ref{ass:zipf}, w.h.p., in the learning phase, only  content types are requested.
	\item Next, we show that the expected the number of requests in Phase 2 for content types not requested in Phase 1 is . Using this, we compute a lower bound on the number of requests deferred in Phase 2 (after the learning phase) by any learning-based static storage policy. This results follows by the same arguments as the proof of Lemma \ref{lemma:phase2_drops}.
	\item Using Steps 1 and 3, we lower bound the number of requests deferred in the interval of interest.
\end{enumerate}


\subsection{Proof of Theorem 3}
\label{sec:proof3}

\noindent We first present an outline the proof of Theorem \ref{thm:MYOPIC_static_arrival_rates}.

\begin{enumerate}
	\item We first show that under Assumption \ref{ass:zipf}, on every arrival in the interval of interest (), there are  idle servers w.h.p. (Lemma \ref{lemma:F_1}).
	\item Next, we show that w.h.p., in the interval of interest of length , only  unique content types are requested (Lemma \ref{lemma:types_of_arrivals}).
	\item Conditioned on Steps 1 and 2, we show that, the MYOPIC policy ensures that in the interval of interest, once a content type is requested for the first time, there is always at least one idle server which can serve an incoming request for that content.
	\item Using Step 3, we conclude that, in the interval of interest, only the first request for a particular content type will be deferred. The proof of Theorem \ref{thm:MYOPIC_static_arrival_rates} then follows from Step 2.
\end{enumerate}

\begin{lemma}
	\label{lemma:occupancy}
	Let the cumulative arrival process to the content delivery system be a Poisson process with rate . At time , let  be the number of occupied servers under the MYOPIC storage policy. Then, we have that, , where  is a poisson random variable with rate .
\end{lemma}
\begin{proof}
	Consider an  queue where the arrival process is Poisson(). Let  be the number of occupied servers at time  in this system. It is well known that  is a Poisson random variable with rate . Here we provide a proof of this result for completeness. Consider a request  which arrived into the system at time . If the request is still being served by a server, we have that,
	
	where  is the service time of request . Since  Exp(1), we have that,
	
	Therefore,
	
	Therefore, every request that arrived in the system is still in the system with probability at most . Since the arrival process is Poisson, the number of requests in the system at time  is stochastically dominated by a Poisson random variable with rate .
	
	To show , we use a coupled construction similar to Figure \ref{fig:coupling}. The intuition behind the proof is the following: the rate of arrivals to the content delivery system and the  system (where each server can serve all types of requests) is the same. The content delivery system serves fewer requests than the  system because some requests are deferred even when the servers are idle. Hence, the number of busy servers is the content delivery system is stochastically dominated by the number of busy servers in the  queueing system.
\end{proof}


\begin{lemma}
	\label{lemma:F_1}
	Let the interval of interest be  where  and . Let  be the event that at the instant of each arrival in the interval of interest, the number of idle servers in the system is at least . Then,
	
\end{lemma}
\begin{proof}
	Let  be the event that the number of arrivals in . Using the Chernoff bound for the  Poisson process, we have that, 
	Consider any . By Lemma \ref{lemma:occupancy}, , where  Poisson(). Therefore,
	
	Moreover,  where  Poisson(). Therefore, using the Chernoff bound for , we have that,
	
	for some constant . Therefore,
	
\end{proof}


\begin{lemma}
	\label{lemma:types_of_arrivals}
	Let  be the event that in the interval of interest of duration  such that , no more than  different types of contents are requested. Then,
	
\end{lemma}
\begin{proof}
	Recall from the proof of Lemma \ref{lemma:E_1} that the total mass of all content types  is
	
	Now, for  + 1, we have that,
	
	Conditioned on the event  defined in Lemma \ref{lemma:F_1}, the expected number of requests for content types  is less than . Using the Chernoff bound, the probability that there are more than  requests for content types  in the interval of interest is less than  for  large enough.
	
	Therefore, with probability greater than , the number different types of contents requests for in the interval of interest is less than . Hence the result follows.
\end{proof}


\begin{proof} (Proof of Theorem \ref{thm:MYOPIC_static_arrival_rates})\\
	Let  be the event that, in the interval of interest, every request for a particular content type except the first request is not deferred.
	The rest of this proof is conditioned on  and . Let  be the number of unique contents which have been requested in the interval of interest before time  for . Conditioned on , as defined in Lemma~\ref{lemma:types_of_arrivals},  for some constant  and  large enough. Conditioned on , there are always  idle servers in the interval of interest. \\
	\newline CLAIM: For every  and  large enough, once a content  is requested for the first time in the interval of interest, the MYOPIC policy ensures that there is always at least 1 idle server which can serve a request for .\\
	\newline Note that since , . Let  be large enough such that , i.e., at any time , the number of idle servers is greater than . We prove the claim by induction. Let the claim hold for time  and let there be a request at time  for content . If this is not the first request for  in , by the claim, at , there is at least one idle server which can serve this request. In addition, if there is exactly one server which can serve  at , then the MYOPIC policy replaces the content of some other idle server with . Since there are more than  idle servers and , at , each content type requested in the interval of interest so far, is stored on at least one currently idle server. Therefore, conditioned on  and , every request for a particular content type except the first request, is not deferred. \\
	\newline Hence, putting everything together,
	
	thus  as  and the result follows.
\end{proof}




\subsection{Proof of Theorem \ref{thm:MYOPIC_changing_arrival_rates}}
\label{sec:proof4}

\noindent We first present an outline of the proof of Theorem \ref{thm:MYOPIC_changing_arrival_rates}. 

\begin{enumerate}
	\item Since we are studying the performance of the MYOPIC policy for the Continuous Change Model, the relative order of popularity of contents keeps changing in the interval of interest. We show that w.h.p., the number of content types which are in the  most popular content types at least once in the interval of interest is  (Lemma \ref{lemma:change_in_heavy_hitters}).
	\item Next, we show that w.h.p., in the interval of interest of length , only  content types are requested (Lemma \ref{lemma:types_of_arrivals_changing_arrival_rates}).
	\item By Lemma \ref{lemma:F_1} and the proof of Theorem \ref{thm:MYOPIC_static_arrival_rates}, we know that, conditioned on Step 3, the MYOPIC storage policy ensures that in the interval of interest, once a content type is requested for the first time, there is always at least one idle server which can serve an incoming request for that content. Using this, we conclude that, in the interval of interest, only the first request for a particular content type will be deferred. The proof of Theorem \ref{thm:MYOPIC_changing_arrival_rates} then follows from Step 2.
\end{enumerate}


\begin{lemma}
	\label{lemma:change_in_heavy_hitters}
	Let  be the event that, in the interval of interest of length , the number of times that a content among the current top  most popular contents changes its position in the popularity ranking is at most . Then, 
\end{lemma}
\begin{proof}
	The expected number of clock ticks in  time-units is . The probability that a change in arrival process involves at least one of the current  most popular contents is . Therefore, the expected number of changes in arrival process which involve at least one of the current  most popular contents is  . By the Chernoff bound, we have that
	
\end{proof}

\begin{lemma}
	\label{lemma:types_of_arrivals_changing_arrival_rates}
	Let  be the event that in the interval of interest, no more than  different types of contents are requested. Then,
	
\end{lemma}
\begin{proof}
	Conditioned on the event  defined in Lemma \ref{lemma:change_in_heavy_hitters}, we have that in the interval of interest, at most  different contents are among the top  most popular contents. Given this, the proof follows the same lines of arguments as in the proof of Lemma \ref{lemma:types_of_arrivals}.
\end{proof}
The proof of the theorem then follows from Lemma \ref{lemma:types_of_arrivals_changing_arrival_rates} and uses the same line of arguments as in the proof of Theorem \ref{thm:MYOPIC_static_arrival_rates}.





\subsection{Proof of Theorem 5}
\label{sec:proof1}

To show that GENIE is the optimal policy, we consider the process  which is the number of occupied servers at time  when the storage policy is GENIE. Let  be the number of occupied servers at time  for some other storage policy . We construct a coupled process  such that the marginal rates of change in  and  is the same as that of  and  respectively.

Recall . At time , let  and  be the sets of contents stored on idle servers by GENIE and  respectively. The construction of the coupled process  is described in Figure \ref{fig:coupling}. We assume that the system starts at time  and . In this construction, we maintain two counters  and  which keep track of the number of departures from the system. Let . Let Exp be an Exponential random variable with mean  and Ber be a Bernoulli random variable which is 1 with probability (w.p.) .

\begin{figure}[h]
	\hrule
	\vspace{0.1in}
	\begin{algorithmic}[1]
		\STATE Generate: ARR  Exp, DEP  Exp
		\STATE ARR,DEP
		\IF {ARRDEP, }
		\IF {()}
		\STATE Generate  Ber
		\IF {()}
		\STATE 
		\STATE Generate  Ber
		\STATE \textbf{if} () \textbf{then} 
		\ENDIF
		\ELSE
		\STATE Generate  Ber
		\STATE \textbf{if}() \textbf{then} 
		\STATE Generate  Ber
		\STATE \textbf{if}() \textbf{then} 
		\ENDIF
		\ELSE
		\IF{()}
		\STATE , 
		\STATE Generate  Ber
		\STATE \textbf{if} () \textbf{then} , 
		\ELSE
		\STATE , 
		\STATE Generate  Ber
		\STATE \textbf{if} () \textbf{then} , 
		\ENDIF
		\ENDIF
		\STATE Goto 1
	\end{algorithmic}
	\vspace{0.1in}
	\hrule
	\caption{Coupled Process}
	\label{fig:coupling}
\end{figure}

\begin{lemma}
	\label{lemma:marginals}
	 and  have the same marginal rates of transition as  and  respectively.
\end{lemma}
\begin{proof}
	Consider a small interval of time . By the definition of ,
	
	The above probabilities are implicitly conditioned on a suitable state definition for the system; we henceforth drop the conditioning on the state for notational compactness. For the process ,
	
	If ,
	
	and if ,
	
	The approximations become exact as , since the inter-event (arrival or departure) times are exponential. This proves the lemma for  and .
	\newline \newline By the definition of ,
	
	Consider the case when .
	\newline From Section \ref{subsec:optimal}, we know that, under the GENIE storage policy, if the number of idle servers at time  is , they store the  most popular contents. Given this, if , . Therefore,  as defined in Step 8 of the coupling construction is a valid bernoulli random variable and in addition,  is a bernoulli random variable with parameter . Therefore, we have that,
	
	If ,
	
	If ,
	
	and if ,
	
	This completes the proof.
\end{proof}


\begin{lemma}
	\label{lemma:marginals_2}
	Let  be the number of jobs deferred by time  by the GENIE adaptive storage policy and  to be the number of jobs deferred by time  by a policy . In the coupled construction, let  be the number of arrivals by time . Let,  and . Then,  and  have the same marginal rates of transition as  and  respectively.
\end{lemma}
\begin{proof}
	This follows from Lemma \ref{lemma:marginals} due to the fact that  have the same distribution as  and the marginal rate of increase of  given  is the same as the rate of increase of  given . The result for  follows by the same argument.
\end{proof}

\begin{lemma}
	\label{lemma:x_stochastic_dominance_y}
	 for all  on every sample path.
\end{lemma}
\begin{proof} 
	The proof follows by induction.  by construction.
	Let  and let there be an arrival or departure at time . There are 4 possible cases:
	\begin{itemize}
		\item[i:] If ARRDEP and ,  only if . Therefore, .
		\item[ii:] If ARRDEP and , . Therefore, .
		\item[iii:] If DEPARR and , .
		\item[iv:] If DEPARR and , . Therefore, .
	\end{itemize}
\end{proof}

\begin{lemma}
	\label{lemma:departures_stochastic_dominance}
	 for all  on every sample path.
\end{lemma}
\begin{proof}
	The proof follows by induction. Since the system starts at time , . Let  and let there be a departure at time . By Lemma \ref{lemma:x_stochastic_dominance_y}, we know that, . Therefore,  by the coupling construction.
\end{proof}



\begin{proof} (Proof of Theorem \ref{thm:stochastic_dominance}) \\
	By Lemmas \ref{lemma:x_stochastic_dominance_y} and \ref{lemma:departures_stochastic_dominance}, for any sample path,
	
	Therefore, for every sample path, the number of requests already served (not deferred) or being served by the servers by a content delivery system implementing the GENIE policy is more than that by any other storage policy. This implies that for each sample path, the number of requests deferred by GENIE is less than that of any other storage policy. Sample path dominance in the coupled system implies stochastic dominance of the original process. Using this and Lemma \ref{lemma:marginals_2}, we have that,
	
\end{proof}

\subsection{Proof of Theorem \ref{thm:GENIE_static_arrival_rates}}
\begin{proof}
	The key idea of the GENIE policy is to ensure that at any time , if the number of idle servers is , the  most popular contents are stored on exactly one idle server each. Since the total number of servers is , and the number of content-types is  for some constant , all content-types  for  are never stored on idle servers by the GENIE policy. This means that under the GENIE policy, all arrivals for content types  for  are deferred. For ,for all ,, for some constant .
	The cumulative mass of all content types  is
	
	for  large enough.
	
	Let the length of the interval of interest be . The expected number of arrivals of types , in the interval of interest is at least . Therefore, the expected number of jobs deferred by the GENIE policy in an interval of length  is .\\
\end{proof}


\subsection{Proof of Theorem \ref{thm:adaptation_cost}}
\begin{proof}
	From the proof of Theorem \ref{thm:MYOPIC_static_arrival_rates}, we know that if , w.h.p.,
	\begin{itemize}
		\item[-] no more than  different types of contents are requested,
		\item[-] once a content  is requested for the first time, the MYOPIC policy ensures that there is always at least 1 idle server which can serve a request for .
	\end{itemize}
	
	It follows that once a content is requested for the first time, there is at least one copy of that content in the system (more specifically, there is at least one copy of that content on an idle server). Therefore, w.h.p., the number of external fetches is equal to the number of unique content types requested in the interval of interest and the result follows.
	
	For the GENIE policy, before the first arrival, the GENIE policy fetches the  most popular contents to place on the servers.
	
	Let the number of idle servers at  be  and let there be a departure from the system at time . After this departure, the content of the new idle server is replaced with . From Lemma \ref{lemma:F_1}, we have that with probability ,  servers are idle at all times in the interval of interest. Therefore,  for some  and . The number of currently busy servers serving a request for content  is stochastically dominated by a Poisson random variable with rate . Therefore, at time , with probability , there is no currently busy server in the system serving a request for . By the properties of the GENIE policy, the other  idle servers store the  most popular contents. Therefore, content  is not available in the system (on a busy or idle server) at time  and will be fetched from the back-end server. Therefore, w.h.p., each departure is followed by an external fetch. Since there are  departures in an interval of duration , the result follows.
	
\end{proof}





\section{Related Work}
\label{sec:related}
Our model of content delivery systems shares several features with
recent models and analyses for content placement and request
scheduling in multi-server queueing systems
\cite{LLM12,XT13,LLM13,Whitt07}. All these works either assume known
demand statistics, or a low-dimensional regime (thus permiting
``easy'' learning). Our study is different in its focus on unknown,
high-dimensional and time-varying demand statistics, thus making it
difficult to consistently estimate statistics.  Our setting also
shares some aspects of estimating large alphabet distributions with
only limited samples, with early contributions from Good and
Turing~\cite{Good53}, to recent variants of such
estimators~\cite{MS00,VV11}.







Our work is also related to the rich body of work on the content
replication strategies in peer-to-peer networks, e.g., \cite{TM13,
	KRR02, LC02, KRT07, WL12, ZFC13, CMGLT12, cluster02}.  Replication
is used in various contexts: \cite{TM13} utilizes it in a setting with
large storage limits, \cite{KRR02,LC02} use it to decrease the time
taken to locate specific content, and \cite{ZFC13,CMGLT12,cluster02}
use it to increase bandwidth in the setting of video
streaming.
However, the common assumption is that the number of content-types
does not scale with the number of peers, and that a request can be
served in parallel by multiple servers (and with increased network
bandwidth as the number of peers with a specific content-type
increases) which is fundamentally different from our setting.

Finally, our work is also related to the vast literature on content
replacement algorithms in server/web cache management. As discussed in
\cite{Wang99}, parameters of the content (e.g., how large is the
content, when was it last requested) are used to derive a cost, which
in-turn, is used to replace content.
Examples of
algorithms that have a cost-based interpretation include the Least
Recently Used (LRU) policy, the Least Frequently Used (LFU) policy,
and the Max-Size policy \cite{Size96}. 
We refer to \cite{Wang99} for a survey of web caching schemes. There
is a huge amount of work on the performance of replication strategies
in single-cache systems; however the analysis of adaptive caching
schemes in distributed cache systems under stochastic models of
arrivals and departures is very limited.




\section{Conclusions}\label{conclusion}
In this paper, we considered the high dimensional setting where the
number of servers, the number of content-types, and the number of
requests to be served over any time interval all scale as ;
further the demand statistics are not known a-priori. This setting is
motivated by the enormity of the contents and their time-varying
popularity which prevent the consistent estimation of demands.

The main message of this paper is that in such settings, separating
the estimation of demands and the subsequent use of the estimations to
design optimal content placement policies (``learn-and-optimize''
approach) is order-wise suboptimal. This is in contrast to the
low dimensional setting, where the existence of a constant bound on the
number of content-types allows asymptotic optimality of a
learn-and-optimize approach.




\bibliographystyle{unsrt}
\bibliography{myref2}




\end{document}
