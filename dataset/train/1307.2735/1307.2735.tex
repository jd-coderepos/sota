\documentclass[conference]{IEEEtran}
\ifCLASSINFOpdf
\else
\fi
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}


\begin{document}
\title{An Efficient Multiplication Algorithm Using Nikhilam Method}
\author{\IEEEauthorblockN{Shri Prakash Dwivedi}
\IEEEauthorblockA{Email: shriprakashdwivedi@gbpuat-tech.ac.in}}

\maketitle


\begin{abstract}
Multiplication is one of the most important operation in computer arithmetic. Many integer operations such as squaring, division and computing reciprocal require same order of time as multiplication whereas some other operations such as computing GCD and residue operation require at most a factor of  time more than multiplication. We propose an integer multiplication algorithm using Nikhilam method of Vedic mathematics which can be used to multiply two binary numbers efficiently.
\end{abstract}

\begin{keywords}
 Integer Multiplication, Algorithm, Computer Arithmetic, Vedic Mathematics, Computation
\end{keywords}

 
\IEEEpeerreviewmaketitle


\section{Introduction}
The classical method of adding two integers of -bits takes  bit operations but the classical method of multiplying them takes  bit operations. Complexity of addition is optimal in number of bit operations, whereas optimal multiplication algorithm for integers is an open problem. The classical approach to multiply two -bit integers requires  bit operations. Karatsuba multiplication [9] uses divide-and-conquer technique to multiply two -bit integers in  bit operations(logarithms are to the base 2 unless otherwise specified) by replacing some of the multiplication by less costly addition and subtraction. Toom-Cook algorithm further improves the above bound [3]. Toom-Cook method is the generalization of Karatsuba method which split each number to be multiplied in multiple parts [12]. Given two large integers, Toom-Cook splits up multiplicand and multiplier into  smaller parts each of length , and performs operations on the parts. As  grows, one may combine many of the multiplication sub-operations, thus reducing the overall complexity of the algorithm. For  Toom-Cook reduces 9 multiplication to 5, with 
asymptotic complexity of . Schonhage-Strassen integer multiplication algorithm [10] uses Fast Fourier Transform (FFT) by selecting the principal roots of unity as evaluation point to perform multiplication in  bit operations. FFT method employs a divide-and-conquer strategy by taking advantage of the special properties of the complex root of unity to perform multiplication of two polynomials in only  arithmetic complexity [4]. In fact many multiplication algorithms can viewed as schemes for the evaluation of polynomials then multiplication of their values and followed by interpolation. Currently, the asymptotically fastest algorithm for multiplication of two -bit integers is by Furer [7] which runs in . Where  is iterated logarithm function [5] defined as: 
Furer algorithm uses arithmetic over complex number. Same asymptotic bound can also be achieved using modular arithmetic [6].\\
\indent The Schonhage-Strassen algorithm and Furer algorithm are asymptotically fast but they are suited for extremely large numbers. Furer algorithm although asymptotically fastest, only achieves an advantage for astronomically large values and as such it is currently not used in practice. The crossover points between these algorithms are usually very high when the algorithms are implemented [8].
For small inputs even Karatsuba algorithm runs slower than the classical multiplication algorithm because of recursion overhead. In this paper we use Nikhilam sutra or method from vedic mathematics [11] to perform efficient multiplication for small inputs. Nikhilam sutra performs large multiplication by converting it to small multiplication along with some addition and shifting operations. \\
\indent This paper is organized as follows. Section 2 describes background and motivation. Section 3 presents our proposed work, the multiplication algorithm and its features. In section 4, we present some applications. Finally, section 5 contains conclusion.


\section{Background and Motivation}
The simplest method to multiply two -digit integers is using classical or long multiplication method which requires
 multiplication operations. Whereas to add or subtract two -digit integers using traditional method requires at most  number of addition or subtraction which is optimal in terms of number of addition/subtraction operation performed. To improve the  bound of multiplication, several algorithms have been discovered.  The simplest one is Karatsuba algorithm which is based on divide-and-conquer paradigm [1]. Karatsuba algorithm is based on the fact that two-digit multiplication can be done with only three instead of four multiplications required by standard method. Suppose we want to multiply two -digit decimal numbers  :
\begin{enumerate}
 \item[1.] Compute 
 \item[2.] Compute 
 \item[3.] Compute 
 \item[4.] Compute , here  is equal to 
 \item[5.] Result  
\end{enumerate}
For large number of digits we can apply this method recursively by splitting the multiplicand and multiplier in two parts. The complexity of this method is . Since multiplication operation is costly as compared to addition and shift, some constant number of addition and shift operations can be safely ignored. In this paper we assume that multiplicand and multiplier are having equal number of digits.\\

For example suppose we want to multiply . The standard method of long multiplication requires 4 one-digit multiplication along with some addition and shift. Using Karatsuba algorithm we can compute it as follows:
\begin{enumerate}
 \item[1.] Compute 
 \item[2.] Compute 
 \item[3.] Compute ; 
 \item[4.] Compute  
 \item[5.] Result  
\end{enumerate}
A schematic view of above multiplication is shown in Fig. 1. The three multiplication operations are enclosed in ellipse.  In fact the total number of -digit multiplication required in above example is 5. Note that to compute  in step  requires, three -digit multiplication by applying this method one's more. 
\begin{figure}[ht]
\begin{center}
\includegraphics[width=7cm, height=4cm]{Dia11.png}
\end{center}
\caption{Multiplication of integers  using Karatsuba method}
\label{graph1}
\end{figure}

\indent Nikhilam Sutra is one of the 16 sutras of Vedic mathematics [11]. It can be used to convert large-digits multiplication to small-digits multiplication with the help of few extra add, subtract and shift operations. In some cases two-digit multiplication can be performed using only  one-digit multiplication instead of  one-digit multiplication as required by Karatsuba algorithm.
Suppose we have to perform same multiplication  using this method. We can use the Nikhilam sutra as follows:
\begin{enumerate}
 \item[1.] Compute ; Subtract the multiplicand from nearest base 
 \item[2.] Compute ; Subtract the multiplier from the same base
 \item[3.] Compute 
 \item[4.] Compute  
 \item[5.] Result  
\end{enumerate}

In the Fig. 2, we can see that there is only one multiplication operation involved.
\begin{figure}[ht]
\begin{center}
\includegraphics[width=7cm, height=4cm]{Dia2.png}
\end{center}
\caption{Multiplication of integers  using Nikhilam method}
\label{graph1}
\end{figure}


Above multiplication is also shown in Table 1. In this multiplication we have used  multiplication,  addition,  subtraction and  shift operation. This particular multiplication is more efficient than both standard multiplication and Karatsuba method. Suppose multiplicand is  and multiplier is  where  is nearest base. We have: 
 The general scheme of multiplication  is shown in Table 2.
\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{Multiplication of }
\label{table 1}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Integer & Base Difference    \\ [1ex] \hline\hline 
Multiplicand & 95 & (100-95)=5   \\ \hline
Multiplier & 96 & (100-96)=4  \\ \hline
 & (95-4)=91 & (5*4)=20  \\ \hline
Result & 9120 &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{Multiplication of }
\label{table 2}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Integer & Base Difference    \\ [1ex] \hline\hline 
Multiplicand &  &    \\ \hline
Multiplier &  &   \\ \hline
 &  &   \\ \hline
Result &  &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 

This scheme can also be utilized, when the multiplicand and multiplier are just above the certain power of base(which is  in this case). Suppose we have to multiply . We can proceed as follows:
\begin{enumerate}
 \item[1.] Compute ; Subtract the multiplicand from nearest base 
 \item[2.] Compute ; Subtract the multiplier from the same base
 \item[3.] Compute 
 \item[4.] Compute  
 \item[5.] Result  
\end{enumerate}

Above multiplication is shown in Table 3. This -digit multiplication is performed in just single  digit multiplication, whereas the standard method will take  multiplication and Karatsuba can compute in  multiplication operations.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{Multiplication of }
\label{table 3}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Integer & Base Difference    \\ [1ex] \hline\hline 
Multiplicand & 105 & (105-100)=5   \\ \hline
Multiplier & 106 & (106-100)=6  \\ \hline
 & (105+6)=111 & (5*6)=30  \\ \hline
Result & 11130 &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 

The principle behind this is as follows: 
Let the multiplicand be  and multiplier be  where  is the nearest base, then 

Details are given in Table 4.

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{Multiplication of }
\label{table 4}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Integer & Base Difference    \\ [1ex] \hline\hline 
Multiplicand &  &    \\ \hline
Multiplier &  &   \\ \hline
 &  &   \\ \hline
Result &  &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 


\section{Proposed Work}
\subsection{Binary Multiplication}
We can perform binary digit multiplication using Nikhilam sutra by converting -bit multiplication to -bit multiplication and some additional add/subtract and shift operation. We can apply this conversion repeatedly until we get trivial multiplicand/multiplier or -bit multiplication. We can also put some threshold limit  where  up to which we would like to do this conversion.\\

-bit multiplication can be performed using single -bit multiplication. For example if we have to multiply . Here multiplicand , and multiplier . We can proceed as follows:
\begin{enumerate}
 \item[1.] Compute ; Subtract the multiplicand from nearest base 
 \item[2.] Compute ; Subtract the multiplier from the same base
 \item[3.] Compute 
 \item[4.] Compute  
 \item[5.] Result  
\end{enumerate}
The only multiplication required in this computation(Table 5) is for  in step 3.
\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{Binary Multiplication of }
\label{table 5}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Bits & Base Difference    \\ [1ex] \hline\hline 
Multiplicand & 11 & (11-10)=1   \\ \hline
Multiplier & 11 & (11-10)=1  \\ \hline
 & (11+1)=100 & (1*1)=1  \\ \hline
Result & 1001 &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 

\indent For -bit multiplication consider the example of 
\begin{enumerate}
 \item[1.] Compute ; Subtract the multiplicand from nearest base 
 \item[2.] Compute ; Subtract the multiplier from the same base
 \item[3.] Compute 
 \item[4.] Compute  
 \item[5.] Result  
\end{enumerate}
In this computation also two -bit multiplication is performed. While in case of standard multiplication  multiplication is required, and Karatsuba algorithm use  multiplication.
\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{-bit Binary Multiplication of }
\label{table 6}
\begin{center}
\begin{tabular}{|c| c| c| } 
\hline
 & Bits & Base Difference    \\ [1ex] \hline\hline 
Multiplicand & 101 & (101-100)=1   \\ \hline
Multiplier & 110 & (110-100)=10  \\ \hline
 & (101+10)=111 & (1*10)=10  \\ \hline
Result & 11110 &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table} 

Let us consider -bit multiplication of . In this case multiplicand(M) and multiplier(N) are equal i.e. . For multiplication we can proceed as follows:
\begin{enumerate}
 \item[1.]  Compute ; Subtract the multiplicand from nearest base 
 \item[2.]  Compute ; Subtract the multiplier from the same base
 \item[3.]  Compute 
 \item[4.]  Compute  
 \item[5.]  Compute 
 \item[6.]  Compute 
 \item[7.]  Compute 
 \item[8.]  Compute 
 \item[9.]  Compute 
 \item[10.] Result  
\end{enumerate}
In this computation the only multiplication involved is in step 7 and apart from that all other steps are having either add/subtract or shift operation. Details of this multiplication are shown in Table 7.


\begin{table*}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{-bit Binary Multiplication of }
\label{table 7}
\begin{center}
\begin{tabular}{|c| c| c| c| c|} 
\hline
 & Bits & Base Difference  & Next Difference & Next Difference  \\ [1ex] \hline\hline 
Multiplicand & 1111 & (1111-1000)=111 &(111-100)=11 & (11-10)=1  \\ \hline
Multiplier & 1111 & (1111-1000)=111 &(111-100)=11 & (11-10)=1  \\ \hline
 &  &  &  &   \\ \hline
 &  &  &  & \\ \hline
 &  &  &  & \\ \hline
 &  &  &  & \\ \hline
Result & 11100001 &  &  &   \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table*} 


From these examples we can easily recognize that the computation is simple when multiplicand and multiplier both are same. 


\subsection{Nikhilam Algorithm}
 Nikhilam sutra seems to have special advantage when the multiplicand and multiplier are same. If both multiplicand and multiplier are equal then multiplication operation is known as squaring. Squaring is considered as special case of multiplication. First we write the NikhilamSquaring algorithm which can be used to compute square of a binary integer. NikhilamSquaring algorithm is in turn called by NikhilamMultiplication to perform the multiplication. Multiplication and squaring related to each other by the following well known formula: 

\indent Description of NikhilamSquaring is given in Algorithm 1. It takes input  as a binary number of -bits and produces square of  as its output which can be up to -bits. First while-loop is used for the computation of the forward direction subtraction operations. Two counters  and  are used to keep track of processed input and proper base subtraction respectively. If-loop is used to check whether the corresponding bit is  or . If base power to be subtracted is more than the number itself then else part of if-loop is executed. This happens to be only when the first bit of the number is . Least significant bits multiplication is assigned in . Second while-loop is used for the computation of reverse direction for shifting and addition operations. Again If-loop is used to check whether two consecutive  values are same, if it is so next value of  is unchanged, otherwise its value is updated.   

\begin{algorithm}
\caption{\bf :  NikhilamSquaring }
\begin{algorithmic}
\STATE \textbf{INPUT}: 
\STATE \textbf{OUTPUT}: 
   \STATE  
   \STATE 
   \WHILE { \textbf{and}  } 
   {
   \IF {}
   \STATE  \\
   \ELSE \STATE 
   \ENDIF
   \STATE 
   }
   \ENDWHILE
   \STATE 
   \STATE 
   \WHILE {  \textbf{and}  }
   {
   \IF {}
   \STATE  \\
   \ELSE \STATE 
   \ENDIF
   \STATE 
   }
   \ENDWHILE

   \RETURN 
\end{algorithmic}
\end{algorithm}

Execution of NikhilamSquaring algorithm for -bit input  is shown in Table 8. We have , ,  (since ), , , , , ,  (since ), , ,  .

\begin{table*}[ht]
\renewcommand{\arraystretch}{1.3}
\caption{-bit Binary Multiplication of }
\label{table 8}
\begin{center}
\begin{tabular}{|c| c| c| c| c| c| c|} 
\hline
 & Binary Digits & Base Difference  & Next Difference & Next Difference & Next Difference & Next Difference \\ [1ex] \hline\hline 
Multiplicand &  &  &  &  &  &  \\ \hline
Multiplier &  &  &  &  &  &   \\ \hline
 &  &  &  &  &  &   \\ \hline
 &  &  &  &  &  & \\ \hline
 &  &  &  & &  & \\ \hline
 &  &  & &  &  & \\ \hline
 &  &   &  &  &  & \\ \hline
Result &  &  &  &  &  & \\ [1ex] \hline

\end{tabular} 
\end{center}
\end{table*} 

Correctness of the NikhilamSquaring can be easily established using induction on the bit length of the input . Note that in each column of Table 8, the partial result is, in fact multiplication of corresponding multiplicand and multiplier in that column.\\
 
 
\textbf{Theorem 1.} \textit{NikhilamSquaring algorithm computes square of the input .}\\
 
\textbf{Proof}:  We prove this using induction on the bit length  of . For , number  has only one bit and  when  is  and  when  is . Therefore it works for . Assume it is true for . Now we show it for . Assume , therefore . \\
 Case 1: If th bit is  then , and the processing of th step is  also we have  and therefore
   
 and hence , and the statement of theorem follows.\\
 Case 2: If th bit is , then the statement is trivial and , and theorem is proved.\\


\indent NikhilamMultiplication is described in Algorithm 2. It takes two binary numbers  and  as input and compute their multiplication as output. It performs two calls to NikhilamSquaring algorithm and using that, outputs the desired result. NikhilamMultiplication uses only  multiplication,  division and  add/subtract and shift operations for some constant . To show the correctness of NikhilamMultiplication is trivial given the correctness of NikhilamSquaring.\\

\begin{algorithm}
\caption{\bf :  NikhilamMultiplication}
\begin{algorithmic}
\STATE \textbf{INPUT}: 
\STATE \textbf{OUTPUT}: 
\STATE  \textbf{NikhilamSquaring} 
\STATE  \textbf{NikhilamSquaring} 
\RETURN 
\end{algorithmic}
\end{algorithm}

\textbf{Theorem 2.} \textit{NikhilamMultiplication algorithm computes the product of  and .}\\

\textbf{Proof}: The statement of the above theorem follows from Theorem 1 and the fact that :
   \\

\section{Applications}
Since, asymptotically fast multiplication algorithms like Schonhage-Strassen and Furer algorithms are only useful for extremely large numbers, for small to medium size numbers we can apply Nikhilam multiplication. We can use Nikhilam multiplication even in conjunction with some other fast algorithm like Karatsuba. If  is the threshold between classical multiplication and Karatsuba algorithm then up to threshold limit  we can use Nikhilam multiply and beyond that limit we can use Karatsuba multiply. We can write the Karatsuba algorithm as given in [2], with the only modification that if  NikhilamMultiplication is called. The corresponding pseudo code is given in Algorithm 3. Karatsuba multiplication has relatively small threshold with the classical multiplication. The optimal threshold for Karatsuba algorithm can vary from about ten to hundred words. NikhilamMultiplication can also be used as a stand alone multiplication algorithm.\\
\indent Further optimization to NikhilamMultiplication is also possible. Least significant 's can be truncated from input numbers, and in the end corresponding modification can be done in single operation. We can process the multiplicand and multiplier for consecutive 's to skip some of the steps of the algorithm. The proposed algorithm is particularly efficient because multiplication operation is least involved in it.

\begin{algorithm}
\caption{\bf :  KaratsubaMultiplication}
\begin{algorithmic}
\STATE \textbf{INPUT}: 
\STATE \textbf{OUTPUT}: 
\IF {}
\RETURN \textbf{NikhilamMultiplication} 
\ENDIF
\STATE 
\STATE  mod  div  
\STATE  sign,  sign
\STATE  \textbf{KaratsubaMultiplication} 
\STATE  \textbf{KaratsubaMultiplication} 
\STATE  \textbf{KaratsubaMultiplication} 
\RETURN 
\end{algorithmic}
\end{algorithm}



\section{Conclusions and Future Work}
In this paper we have explored the possibility of applying the Nikhilam sutra of Vedic mathematics to binary number multiplication. We can take advantage of the fact that this sutra can convert large-digit multiplication to corresponding small digit multiplication. Nikhilam method is particularly efficient when both multiplicand and multiplier are near to some base (radix) power. To take this advantage, we have first performed square operation in NikhilamSquaring and then we have used this to finally compute multiplication.
\indent Future work can be to extend this method to large-digit multiplication and exploit it's properties to perform fast integer multiplications. 

\begin{thebibliography}{23}
\bibliographystyle{splncs}

\bibitem{}
Aho, A.V.; Hopcroft, J.E.; Ullman, J.D.; ``The design and analysis of computer algorithms'', Addison-Wesley, 1974.

\bibitem{}
Brent, R.P.; Zimmerman, P.; ``Modern computer arithmetic'', Cambridge University Press, 2010.

\bibitem{}
Cook, S.A.; Aanderaa, S.O.; ``On the minimum computation time of the functions'', Transactions of the American Mathematical Society, 1969.

\bibitem{}
Cooley, J.W.; Tukey, J.W.; ``An algorithm for the machine calculation of complex Fourier series'', Mathematics of Computation, 1965,

\bibitem{}
Cormen, T.H.; Leiserson, C.E.; Rivest, R.L.; Stein, C.; ``Introduction to algorithms'', MIT Press, 2009,

\bibitem{}
De, A.; Kurur, P.; Saha, C.; Sapthasrishi, R.; ``Fast integer multiplication using modular arithmetic'', In Proc. of the  ACM Symposium on Theory of Computing, 2008.

\bibitem{}
Furer, M.; ``Faster integer multiplication'', In Proc. of the ACM Symposium on Theory of Computing, 2007.

\bibitem{}
Gathen, J.; Gerhard, J.; ``Modern computer algebra'', Cambridge University Press, 2003.

\bibitem{}
Karatsuba, A.; Ofman, Y.; ``Multiplication of multidigit numbers on automata'', English Translation in Soviet Physics Doklady, 1963.

\bibitem{}
Schonhage, A.; Strassen, V.; Zanichelli, F.; ``Schnelle Multiplikation grosser Zahlen'', Computing 7, 1971.

\bibitem{}
Tirthaji, B.K.M.; ``Vedic mathematics'', Motilal Banarsidass Publication, 1992.

\bibitem{}
Toom, A.L.; ``The complexity of a scheme of functional elements simulating the multiplication of integers'', English Translation in Soviet Mathematics, 1963.



\end{thebibliography}

\end{document}
