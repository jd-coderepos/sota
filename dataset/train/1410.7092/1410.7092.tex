





In the earlier sections we focussed on the number of gaps in the schedule. For
certain applications,  the \emph{size} of the gaps is also of interest. 
In this section we will study the problem where the objective is to
minimize the maximum gap in the schedule. Such schedules
tend to spread the jobs more uniformly over the time range and
produce many gaps, which may be useful in applications
discussed in Section~\ref{sec: maximizing the number of gaps}, where a good
schedule should leave some gaps between high-priority jobs, to allow other
jobs to access the processor. This could also be useful in temperature
control of the processor (see the discussion at the end of Section~\ref{sec: final comments}).

The general setting is as before. We have an instance  consisting
of  unit jobs, where job  has release time  and deadline . 
As explained in Section~\ref{sec: preliminaries}, we can assume that  is feasible.
The objective is to compute a schedule of all jobs that minimizes the maximum gap size.

Interestingly, this problem is structurally different from these in the previous 
sections, because now, intuitively, a good schedule should
spread the jobs more-or-less evenly in time. For example, if we have  jobs released 
at , all with deadline , plus two more tight jobs  and  in time slots  and , respectively,
then we should schedule the non-tight jobs 
at time slots . In contrast, the algorithms in
Sections~\ref{sec: maximizing throughput with budget for gaps} and~\ref{sec: min gaps with throughput requirement}
attempted to group the jobs into a small number of blocks. 
Similar to the objective in Section~\ref{sec: maximizing the number of gaps}, a schedule
that minimizes the maximum gap size will typically create many gaps, but,
as can be seen in Figure~\ref{fig: example max gaps}, these two objective functions
will in general produce different schedules.



\begin{figure}[ht]
\begin{center}
\includegraphics[width=5in]{FIGURES/06_example_max_gaps.pdf}
\caption{An instance with two schedules. Red/dark shaded slots represent tight jobs.
The range of job  is represented by a horizontal segment. The schedule on the left maximizes the
number of gaps. The schedule on the right minimizes the maximum gap. Both
schedules are unique optimal solutions for their respective objective functions.}
\label{fig: example max gaps}
\end{center}
\end{figure}



In this section we give an -time algorithm for computing schedules
that minimize the maximum gap. We first give an algorithm for the
continuous model, and then extend it to the discrete model.



\subsection{The Continuous Case}

The continuous analogue of our scheduling problem can be formulated as follows. The input consists of  intervals
. As before,  for each .
The objective is to compute a hitting set  for these intervals that
minimizes the maximum gap between its consecutive points. Another way to think about this problem is as computing a
\emph{representative}  for each interval . Except for degenerate
situations (two equal intervals of length ), we can assume that
all representatives are different, although we will not be using this
property in our algorithm, and we treat  as a multiset.

We order the intervals so that . (In this continuous version
we cannot assume all 's are different without losing generality.) Further, we only need to
be concerned with sets  that contain , because if  contains any points
before  then we can replace them all by  without increasing the maximum gap in . 
Also, if  then there is a singleton hitting set, ,
whose maximum gap is equal to . Thus we can also assume
that , so that we need at least two points in .

Consider first the decision version: \emph{``Given , is there a
hitting set  for  in which all gaps are at most ?''}
If  has this property, we will call it \emph{viable}.
We first give a greedy algorithm for this decision version and
then later we show how to use it to obtain an efficient algorithm for the minimization version.



\medskip
\myparagraph{Algorithm~.}
We initialize  and .  represents the set containing  the
indices of intervals that do not have yet representatives selected.
We move from left to right, at each step assigning a representative to one
interval in , placing this representative as far to the right as possible, and we remove this interval from . 

Specifically, at the beginning of a step  the current set of representatives is
, listed in non-decreasing order. In this step we proceed as follows. 
Let . If all  satisfy , declare failure and return .
Otherwise, choose  with  that minimizes  and remove  from .
We now have two cases. If , let , and otherwise
(that is, when ) let . Then increment  and continue.
If the process completes with  (and thus also ),
return  and the computed solution .



\medskip

To show correctness of Algorithm~,
let  be some solution in increasing order and
with all gaps at most . We show that this solution can be converted into the one computed by our algorithm.
For , as we explained earlier, we can assume that , so  .
Consider the first step when Algorithm~ chooses some .  (If there is no such step, we are done.)
By the choice of  in the algorithm, we have that .  
(Otherwise, either the gap between  and  would exceed  or  would not hit .)
We can then replace  by  in , without increasing the gap
size to above . This way, we increase the number of steps of
Algorithm~ that produce the same representatives as those in .
So repeating this process sufficiently many times eventually converts  into the set .

\smallskip

We claim that Algorithm~ can be implemented in time . Instead of
, the algorithm maintains a set  that, when a step  starts, consists of indices  for which
 and  does not yet have a representative. 
Store  in a  priority queue with priority values equal to the deadlines.
Then choosing the new interval  in the algorithm and removing  from  takes time .
When  is incremented (after adding  to the solution), the indices of new intervals are inserted
into  in order of release times (which can be sorted in the pre-processing stage), with each insertion taking time .

\medskip

Now, the idea is to use Algorithm~ as an oracle in binary search on 's. 
For this to work, we need to be able to efficiently identify a small set of candidate values for the optimal . Let 

Observe that  and, by our assumption that , also .

We claim that  contains the optimal gap length . The argument is this. 
Consider some hitting set  whose maximum gap is , 
sorted in non-decreasing order. Choose some maximal (w.r.t. inclusion)
consecutive sub-sequence  
with all gaps equal to , and suppose that  is not a deadline. 
Then we can move  by a little bit to the right without creating a gap
longer than . Similarly, if  is not a release time then
we can apply a similar procedure to  and shift it to the left.
Each such operation reduces the number of gaps of length . Since  is optimal,
eventually we must get stuck, meaning that we will find a sub-sequence like the one above with the first
and last indices  and  that satisfy  and , for some  and .
Then we will have .

The idea above immediately yields an -time algorithm. This algorithm
first computes the set , sorts it, and then finds the optimal 
through binary search in . Note that the running time is dominated by sorting . 

\smallskip

We now show that this running time can be improved to ,
by conducting a more careful search in  that avoids constructing  explicitly. 
The basic idea is to use a smaller set  that consists of all values  where .
This set  implicitly represents , in the sense that it consists of
all numerator values of the fractions in . More precisely,
each value in  can be expressed as , for some  and . 
One can visualize  by representing such values  as points in 2D, 
with the two coordinates representing the values of  and , and point  representing
 (see Figure~\ref{fig: idea behind algorithm minmaxgap}). 
Roughly, the algorithm then finds two consecutive values  in  such that
 is viable but  is not. It then finds an index  such that
 is viable but  is not. Then the optimum
value of  must be between  and . We then
show that there are only  such values in , so by doing a binary
search among these values we can find the optimum  in time . 
A detailed algorithm with complete analysis follows.

\begin{figure}[ht]
\centering
\includegraphics[width=3in]{FIGURES/06_algorithm_min_maxgap.pdf} 
\caption{An illustration of the the idea behind Algorithm~.
Viable fractions in  are represented by the shaded region.
}
\label{fig: idea behind algorithm minmaxgap}
\end{figure}




\medskip

\myparagraph{Algorithm~.} 
The algorithm is described below in Pseudocode~\ref{alg:minmaxgap}. In this pseudo-code,
to avoid multi-level nesting, we assume that the algorithm terminates if
the \textbf{return} statement is reached. 



\begin{algorithm}
  \setstretch{1.2}
  \caption{Algorithm~}
  \label{alg:minmaxgap}
  \begin{algorithmic}[1]
	\State {\myIf} {} {\myThen} {\myReturn} 
	\State 
	\State sort  in non-decreasing order
	\State {\myIf} {} {\myThen} {\myReturn} 
	\State 
	\State 
	\State {\myIf} {} {\myThen} {\myReturn} 
	\State 
	\State 		
	\State sort  in non-decreasing order
	\State \textbf{return} 
  \end{algorithmic}
\end{algorithm} 

\bigskip

We now explain the steps in the algorithm and justify correctness and the running time.
First, if  then there is a hitting set with all representatives on one point, 
and we return  as the optimum value (Line~1).

Otherwise we have , that is any hitting set needs at least two points and 
the optimal gap is strictly positive. 
We then compute all positive values , store them in a set  and sort them (Lines~2-3).
This will take time .

If  is viable (which we check in Line~4), 
then this is the optimal value, since no hitting set can have all
gaps smaller than . 
We can thus now assume that  is not viable.

Next, we compute the largest  for which  is not viable. By the
previous paragraph, such  exists. 
To this end, we can do binary search in the set ,
at each step making calls to  to
determine whether the current split value is viable or not.
The binary search will take time . 
We also let  to be the next value in  after . (If there is no such value, let .)

At this point we check whether  is viable. If it is not, it means that for all  with
, all fractions , for , are not viable as well. 
Then the smallest viable value in  must be , so we output  in Line~7. 
(Note that in this case  must exist, because if  were the largest value in 
then  would be viable.)

If  is viable, we compute the largest  for which  is viable (Line~8). By the choice of  we have
. We now also know that the optimal value for  has the form 
where , , and

So we only need to search for  among such values.

Next, we define a small set  that contains all candidate values from the previous paragraph.
To this end, we claim that for any , if  then there is at most one integer
 for which condition~(\ref{eqn: min max gap range of x}) holds. 
This follows from simple calculation, as~(\ref{eqn: min max gap range of x}) implies that

Thus the only candidate for  is .

The above argument gives us that the only candidates for the optimal gap size we need to consider
are all values  , for  and , plus the value  that we identified before
as another candidate.
In Lines~9-10 we let  be the set of these candidates and we sort them in non-decreasing order.
Finally, we find the smallest viable value in . 
As , this can be done in time  with binary search that calls  for each split value.




\subsection{The Discrete Case}

We now show that Algorithm~ from the previous section can be adapted
to the discrete case, namely to scheduling unit jobs.

Let  be an instance of unit job scheduling with release times and deadlines.   
As explained in Section~\ref{sec: preliminaries},  we can now assume 
without loss of generality (and in contrast to the continuous case) that
all deadlines are different and sorted in increasing order, .

We treat  as a collection of intervals , , and
run Algorithm~. This will produce a set of
(real-valued) representatives  for the intervals in . 
(Here  denotes the representative of interval , so the elements in  may not be in increasing order.)
Let  be the maximum gap between these representatives. Since 
is an optimal gap for the continuous variant, 
is a lower bound on the optimal gap length for the discrete variant.
(We need to subtract  to account for unit length of jobs.)
It is thus enough to construct a schedule with all gaps of length at most .

Recall that Algorithm~ either assigns jobs to their deadlines
or it spaces consecutive jobs at intervals of  between some deadline and some release time.
As explained before, without loss of generality we can assume that job  is scheduled at , and
Algorithm~ will in fact produce . 
If all other 's are also deadlines, we are done. Otherwise, the rough idea is
to tentatively assign each job  to  (which may not be integral), and then, going from left to right,
gradually shift each job to the first available slot after . This does not quite
work, because when several intervals have their representatives in the same slot, this
could force some jobs past their deadlines. So the correct process needs to be more
subtle and allow for some job reordering, as described below.



\medskip
\myparagraph{Procedure~.}
We describe how to convert  into a schedule  of . Start by initializing  and . 
(Set  represents pending jobs that are ``delayed'', namely those
whose representatives' values in  are before or at the current slot.)
Then consider slots , one by one. For each such , first add to  all jobs  with . 
If , choose  to be the job in  with minimum , let , and remove  from .
Then increment  to  and continue.
\smallskip



We claim that  is a feasible schedule. By the way we add
jobs to , if  when we consider slot  then . Since also
, each job will be added to  not later than when processing slot .
Also, the assumption about different deadlines implies (by simple induction) that when we consider a slot  then all jobs in 
have deadlines at least ; in particular this gives us that no job will miss its deadline. 
Thus  for all .

Next, we show that the maximum gap size in  is equal to . Obviously (see above), it
cannot be smaller. To show that it is not larger, consider a tentative assignment  of jobs to
slots defined by , for all . (This is not a feasible schedule
because it may assign different jobs to the same slot.) We first show that the
maximum gap in this assignment is at most . Consider two jobs  and  that are consecutive in ;
that is,  and there is no job  with .
We can assume that  and
. Then  and  are also consecutive in  and
the length of the gap between them is . We then have

Thus all gaps in  are at most . But all slots of  are also used by 
because, in Procedure~, when we consider slot  set  is not empty.
This implies that the gaps in  are bounded from above by . We can thus conclude that  is optimal.  

The way we described Procedure~, its running time would not be bounded by a function of .
This is easy to fix by skipping all the slots  for which the current set  is empty. Specifically,
we do this: Suppose that when we process a slot  we have . If  then  remains non-empty
after scheduling a job in slot , so in this case we increment  by . Otherwise, we increment it to the
first value  after . This way we will only examine  slots.
With routine data structures, this approach will give us running time .

The discussion above focussed only on computing the optimum gap size. Given this value
and using Algorithm~, one can also compute an actual optimum schedule. Summarizing, we obtain the following theorem.



\begin{theorem}\label{thm: min max gap}
For any instance , Algorithm~ (adapted for the discrete case, as explained above)
in time  computes a schedule of  whose maximum gap value is minimized. 
\end{theorem}




