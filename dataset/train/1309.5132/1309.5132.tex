\documentclass[submission,copyright]{eptcs}
\providecommand{\event}{SAIRP 2013} 

\title{Notions of Monad Strength}
\author{Philip Mulry
\institute{Department of Computer Science\\
Colgate University\\
Hamilton, New York, 13346, USA}
\email{pmulry@colgate.edu}
}
\def\titlerunning{Monad Strength}
\def\authorrunning{P. S. Mulry}

\begin{document}
\maketitle







\makeatletter

\def\diagram{\leftwidth=\z@ \rightwidth=\z@ \topheight=\z@
\botheight=\z@ \setbox\@picbox\hbox\bgroup}

\def\enddiagram{\egroup\wd\@picbox\rightwidth\unitlength
\ht\@picbox\topheight\unitlength \dp\@picbox\botheight\unitlength
\hskip\leftwidth\unitlength\box\@picbox}

\def\bfig{\begin{diagram}}
\def\efig{\end{diagram}}
\newcount\wideness \newcount\leftwidth \newcount\rightwidth
\newcount\highness \newcount\topheight \newcount\botheight

\def\ratchet#1#2{\ifnum#1<#2 \global #1=#2 \fi}

\def\putbox(#1,#2)#3{\horsize{\wideness}{#3} \divide\wideness by 2
{\advance\wideness by #1 \ratchet{\rightwidth}{\wideness}}
{\advance\wideness by -#1 \ratchet{\leftwidth}{\wideness}}
\vertsize{\highness}{#3} \divide\highness by 2
{\advance\highness by #2 \ratchet{\topheight}{\highness}}
{\advance\highness by -#2 \ratchet{\botheight}{\highness}}
\put(#1,#2){\makebox(0,0){}}}

\def\putlbox(#1,#2)#3{\horsize{\wideness}{#3}
{\advance\wideness by #1 \ratchet{\rightwidth}{\wideness}}
{\ratchet{\leftwidth}{-#1}}
\vertsize{\highness}{#3} \divide\highness by 2
{\advance\highness by #2 \ratchet{\topheight}{\highness}}
{\advance\highness by -#2 \ratchet{\botheight}{\highness}}
\put(#1,#2){\makebox(0,0)[l]{}}}

\def\putrbox(#1,#2)#3{\horsize{\wideness}{#3}
{\ratchet{\rightwidth}{#1}}
{\advance\wideness by -#1 \ratchet{\leftwidth}{\wideness}}
\vertsize{\highness}{#3} \divide\highness by 2
{\advance\highness by #2 \ratchet{\topheight}{\highness}}
{\advance\highness by -#2 \ratchet{\botheight}{\highness}}
\put(#1,#2){\makebox(0,0)[r]{}}}


\def\adjust[#1]{} 

\newcount \coefa
\newcount \coefb
\newcount \coefc
\newcount\tempcounta
\newcount\tempcountb
\newcount\tempcountc
\newcount\tempcountd
\newcount\xext
\newcount\yext
\newcount\xoff
\newcount\yoff
\newcount\gap \newcount\arrowtypea
\newcount\arrowtypeb
\newcount\arrowtypec
\newcount\arrowtyped
\newcount\arrowtypee
\newcount\height
\newcount\width
\newcount\xpos
\newcount\ypos
\newcount\run
\newcount\rise
\newcount\arrowlength
\newcount\halflength
\newcount\arrowtype
\newdimen\tempdimen
\newdimen\xlen
\newdimen\ylen
\newsavebox{\tempboxa}\newsavebox{\tempboxb}\newsavebox{\tempboxc}

\newdimen\w@dth

\def\setw@dth#1#2{\setbox\z@\hbox{}\w@dth=\wd\z@
\setbox\@ne\hbox{}\ifnum\w@dth<\wd\@ne \w@dth=\wd\@ne \fi
\advance\w@dth by 1.2em}



\def\t@^#1_#2{\def\n@one{#1}\def\n@two{#2}\mathrel{\setw@dth{#1}{#2}
\mathop{\hbox to \w@dth{\rightarrowfill}}\limits
\ifx\n@one\empty\else ^{\box\z@}\fi
\ifx\n@two\empty\else _{\box\@ne}\fi}}
\def\t@@^#1{\@ifnextchar_ {\t@^{#1}}{\t@^{#1}_{}}}
\def\to{\@ifnextchar^ {\t@@}{\t@@^{}}}

\def\t@left^#1_#2{\def\n@one{#1}\def\n@two{#2}\mathrel{\setw@dth{#1}{#2}
\mathop{\hbox to \w@dth{\leftarrowfill}}\limits
\ifx\n@one\empty\else ^{\box\z@}\fi
\ifx\n@two\empty\else _{\box\@ne}\fi}}
\def\t@@left^#1{\@ifnextchar_ {\t@left^{#1}}{\t@left^{#1}_{}}}
\def\toleft{\@ifnextchar^ {\t@@left}{\t@@left^{}}}

\def\two@^#1_#2{\def\n@one{#1}\def\n@two{#2}\mathrel{\setw@dth{#1}{#2}
\mathop{\vcenter{\hbox to \w@dth{\rightarrowfill}\kern-1.7ex
                 \hbox to \w@dth{\rightarrowfill}}}\limits
\ifx\n@one\empty\else ^{\box\z@}\fi
\ifx\n@two\empty\else _{\box\@ne}\fi}}
\def\tw@@^#1{\@ifnextchar_ {\two@^{#1}}{\two@^{#1}_{}}}
\def\two{\@ifnextchar^ {\tw@@}{\tw@@^{}}}

\def\tofr@^#1_#2{\def\n@one{#1}\def\n@two{#2}\mathrel{\setw@dth{#1}{#2}
\mathop{\vcenter{\hbox to \w@dth{\rightarrowfill}\kern-1.7ex
                 \hbox to \w@dth{\leftarrowfill}}}\limits
\ifx\n@one\empty\else ^{\box\z@}\fi
\ifx\n@two\empty\else _{\box\@ne}\fi}}
\def\t@fr@^#1{\@ifnextchar_ {\tofr@^{#1}}{\tofr@^{#1}_{}}}
\def\tofro{\@ifnextchar^ {\t@fr@}{\t@fr@^{}}}

\def\epi{\mathop{\mathchar"221\mkern -12mu\mathchar"221}\limits}
\def\leftepi{\mathop{\mathchar"220\mkern -12mu\mathchar"220}\limits}
\def\mon{\mathop{\m@th\hbox to
      14.6\P@{\lasyb\char'51\hskip-2.1\P@\hss
}}\limits} \def\leftmono{\mathrel{\m@th\hbox to
14.6\P@{\hss\hskip-2.1\P@\lasyb\char'50}}\limits} \mathchardef\arrext="0200       


\setlength{\unitlength}{.01em}\def\settypes(#1,#2,#3){\arrowtypea#1 \arrowtypeb#2 \arrowtypec#3}
\def\settoheight#1#2{\setbox\@tempboxa\hbox{#2}#1\ht\@tempboxa\relax}\def\settodepth#1#2{\setbox\@tempboxa\hbox{#2}#1\dp\@tempboxa\relax}\def\settokens[#1`#2`#3`#4]{\def\tokena{#1}\def\tokenb{#2}\def\tokenc{#3}\def\tokend{#4}}
\def\setsqparms[#1`#2`#3`#4;#5`#6]{\arrowtypea #1
\arrowtypeb #2
\arrowtypec #3
\arrowtyped #4
\width #5
\height #6
}
\def\setpos(#1,#2){\xpos=#1 \ypos#2}



\def\settriparms[#1`#2`#3;#4]{\settripairparms[#1`#2`#3`1`1;#4]}

\def\settripairparms[#1`#2`#3`#4`#5;#6]{\arrowtypea #1
\arrowtypeb #2
\arrowtypec #3
\arrowtyped #4
\arrowtypee #5
\width #6
\height #6
}

\def\resetparms{\settripairparms[1`1`1`1`1;500]\width 500}

\resetparms

\def\mvector(#1,#2)#3{\put(0,0){\vector(#1,#2){#3}}\put(0,0){\vector(#1,#2){26}}}
\def\evector(#1,#2)#3{{\arrowlength #3
\put(0,0){\vector(#1,#2){\arrowlength}}\advance \arrowlength by-30
\put(0,0){\vector(#1,#2){\arrowlength}}}}

\def\horsize#1#2{\settowidth{\tempdimen}{}#1=\tempdimen
\divide #1 by\unitlength
}

\def\vertsize#1#2{\settoheight{\tempdimen}{}#1=\tempdimen
\settodepth{\tempdimen}{}\advance #1 by\tempdimen
\divide #1 by\unitlength
}

\def\putvector(#1,#2)(#3,#4)#5#6{{\ifnum3<\arrowtype
\putdashvector(#1,#2)(#3,#4)#5\arrowtype
\else
\ifnum\arrowtype<-3
\putdashvector(#1,#2)(#3,#4)#5\arrowtype
\else
\xpos=#1
\ypos=#2
\run=#3
\rise=#4
\arrowlength=#5
\ifnum \arrowtype<0
    \ifnum \run=0
        \advance \ypos by-\arrowlength
    \else
        \tempcounta \arrowlength
        \multiply \tempcounta by\rise
        \divide \tempcounta by\run
        \ifnum\run>0
            \advance \xpos by\arrowlength
            \advance \ypos by\tempcounta
        \else
            \advance \xpos by-\arrowlength
            \advance \ypos by-\tempcounta
        \fi
    \fi
    \multiply \arrowtype by-1
    \multiply \rise by-1
    \multiply \run by-1
\fi
\ifcase \arrowtype
\or \put(\xpos,\ypos){\vector(\run,\rise){\arrowlength}}\or \put(\xpos,\ypos){\mvector(\run,\rise)\arrowlength}\or \put(\xpos,\ypos){\evector(\run,\rise){\arrowlength}}\fi\fi\fi
}}

\def\putsplitvector(#1,#2)#3#4{\xpos #1
\ypos #2
\arrowtype #4
\halflength #3
\arrowlength #3
\gap 140
\advance \halflength by-\gap
\divide \halflength by2
\ifnum\arrowtype>0
   \ifcase \arrowtype
   \or \put(\xpos,\ypos){\line(0,-1){\halflength}}\advance\ypos by-\halflength
       \advance\ypos by-\gap
       \put(\xpos,\ypos){\vector(0,-1){\halflength}}\or \put(\xpos,\ypos){\line(0,-1)\halflength}\put(\xpos,\ypos){\vector(0,-1)3}\advance\ypos by-\halflength
       \advance\ypos by-\gap
       \put(\xpos,\ypos){\vector(0,-1){\halflength}}\or \put(\xpos,\ypos){\line(0,-1)\halflength}\advance\ypos by-\halflength
       \advance\ypos by-\gap
       \put(\xpos,\ypos){\evector(0,-1){\halflength}}\fi
\else \arrowtype=-\arrowtype
   \ifcase\arrowtype
   \or \advance \ypos by-\arrowlength
       \put(\xpos,\ypos){\line(0,1){\halflength}}\advance\ypos by\halflength
       \advance\ypos by\gap
       \put(\xpos,\ypos){\vector(0,1){\halflength}}\or \advance \ypos by-\arrowlength
       \put(\xpos,\ypos){\line(0,1)\halflength}\put(\xpos,\ypos){\vector(0,1)3}\advance\ypos by\halflength
       \advance\ypos by\gap
       \put(\xpos,\ypos){\vector(0,1){\halflength}}\or \advance \ypos by-\arrowlength
       \put(\xpos,\ypos){\line(0,1)\halflength}\advance\ypos by\halflength
       \advance\ypos by\gap
       \put(\xpos,\ypos){\evector(0,1){\halflength}}\fi
\fi
}

\def\putmorphism(#1)(#2,#3)[#4`#5`#6]#7#8#9{{\run #2
\rise #3
\ifnum\rise=0
  \puthmorphism(#1)[#4`#5`#6]{#7}{#8}#9\else\ifnum\run=0
  \putvmorphism(#1)[#4`#5`#6]{#7}{#8}#9\else
\setpos(#1)\arrowlength #7
\arrowtype #8
\ifnum\run=0
\else\ifnum\rise=0
\else
\ifnum\run>0
    \coefa=1
\else
   \coefa=-1
\fi
\ifnum\arrowtype>0
   \coefb=0
   \coefc=-1
\else
   \coefb=\coefa
   \coefc=1
   \arrowtype=-\arrowtype
\fi
\width=2
\multiply \width by\run
\divide \width by\rise
\ifnum \width<0  \width=-\width\fi
\advance\width by60
\if l#9 \width=-\width\fi
\putbox(\xpos,\ypos){#4}{\multiply \coefa by\arrowlength \advance\xpos by\coefa
\multiply \coefa by\rise
\divide \coefa by\run
\advance \ypos by\coefa
\putbox(\xpos,\ypos){#5} }{\multiply \coefa by\arrowlength \divide \coefa by2
\advance \xpos by\coefa
\advance \xpos by\width
\multiply \coefa by\rise
\divide \coefa by\run
\advance \ypos by\coefa
\if l#9\putrbox(\xpos,\ypos){#6}\else\if r#9\putlbox(\xpos,\ypos){#6}\fi\fi }{\multiply \rise by-\coefc \multiply \run by-\coefc
\multiply \coefb by\arrowlength
\advance \xpos by\coefb
\multiply \coefb by\rise
\divide \coefb by\run
\advance \ypos by\coefb
\multiply \coefc by70
\advance \ypos by\coefc
\multiply \coefc by\run
\divide \coefc by\rise
\advance \xpos by\coefc
\multiply \coefa by140
\multiply \coefa by\run
\divide \coefa by\rise
\advance \arrowlength by\coefa
\ifcase\arrowtype
\or \put(\xpos,\ypos){\vector(\run,\rise){\arrowlength}}\or \put(\xpos,\ypos){\mvector(\run,\rise){\arrowlength}}\or \put(\xpos,\ypos){\evector(\run,\rise){\arrowlength}}\fi}\fi\fi\fi\fi}}


\newcount\numbdashes \newcount\lengthdash \newcount\increment

\def\howmanydashes{\numbdashes=\arrowlength \lengthdash=40
\divide\numbdashes by \lengthdash
\lengthdash=\arrowlength
\divide\lengthdash by \numbdashes
\increment=\lengthdash
\multiply\lengthdash by 3
\divide\lengthdash by 5
}

\def\putdashvector(#1)(#2,#3)#4#5{\ifnum#3=0 \putdashhvector(#1){#4}#5
\else
\ifnum#2=0
\putdashvvector(#1){#4}#5\fi\fi}

\def\putdashhvector(#1,#2)#3#4{{\arrowlength=#3 \howmanydashes
\multiput(#1,#2)(\increment,0){\numbdashes}{\vrule height .4pt width \lengthdash\unitlength}
\arrowtype=#4 \xpos=#1
\ifnum\arrowtype<0 \advance\arrowtype by 7 \fi
\ifcase\arrowtype
\or \advance\xpos by 10
    \put(\xpos,#2){\vector(-1,0){\lengthdash}}
    \advance\xpos by 40
    \put(\xpos,#2){\vector(-1,0){\lengthdash}}
\or \advance \xpos by 10
    \put(\xpos,#2){\vector(-1,0){\lengthdash}}
    \advance\xpos by  \arrowlength
    \advance\xpos by  -50
    \put(\xpos,#2){\vector(-1,0){\lengthdash}}
\or \advance\xpos by 10
    \put(\xpos,#2){\vector(-1,0){\lengthdash}}
\or \advance\xpos by \arrowlength
    \advance\xpos by -\lengthdash
    \put(\xpos,#2){\vector(1,0){\lengthdash}}
\or {\advance\xpos by 10
    \put(\xpos,#2){\vector(1,0){\lengthdash}}}
    \advance\xpos by \arrowlength
    \advance\xpos by -\lengthdash
    \put(\xpos,#2){\vector(1,0){\lengthdash}}
\or \advance\xpos by \arrowlength
    \advance\xpos by -\lengthdash
    \put(\xpos,#2){\vector(1,0){\lengthdash}}
    \advance\xpos by -40
    \put(\xpos,#2){\vector(1,0){\lengthdash}}
   \fi
}}

\def\putdashvvector(#1,#2)#3#4{{\arrowlength=#3 \howmanydashes
\ypos=#2 \advance\ypos by -\arrowlength
\multiput(#1,#2)(0,\increment){\numbdashes}{\vrule width .4pt height \lengthdash\unitlength}
\arrowtype=#4 \ypos=#2
\ifnum\arrowtype<0 \advance\arrowtype by 7 \fi
\ifcase\arrowtype
\or \advance\ypos by \arrowlength \advance\ypos by -40
    \put(#1,\ypos){\vector(0,1){\lengthdash}}
    \advance\ypos by -40
    \put(#1,\ypos){\vector(0,1){\lengthdash}}
\or \advance\ypos by 10
    \put(#1,\ypos){\vector(0,1){\lengthdash}}
    \advance\ypos by \arrowlength \advance\ypos by -40
    \put(#1,\ypos){\vector(0,1){\lengthdash}}
\or \advance\ypos by \arrowlength \advance\ypos by -40
    \put(#1,\ypos){\vector(0,1){\lengthdash}}
\or \advance\ypos by 10
    \put(#1,\ypos){\vector(0,-1){\lengthdash}}
\or \advance\ypos by 10
    \put(#1,\ypos){\vector(0,-1){\lengthdash}}
    \advance\ypos by \arrowlength \advance\ypos by -40
    \put(#1,\ypos){\vector(0,-1){\lengthdash}}
\or \advance\ypos by 10
    \put(#1,\ypos){\vector(0,-1){\lengthdash}}
    \advance\ypos by 40
    \put(#1,\ypos){\vector(0,-1){\lengthdash}}
\fi
}}

\def\puthmorphism(#1,#2)[#3`#4`#5]#6#7#8{{\xpos #1
\ypos #2
\width #6
\arrowlength #6
\arrowtype=#7
\putbox(\xpos,\ypos){#3\vphantom{#4}}{\advance \xpos by\arrowlength
\putbox(\xpos,\ypos){\vphantom{#3}#4}}\horsize{\tempcounta}{#3}\horsize{\tempcountb}{#4}\divide \tempcounta by2
\divide \tempcountb by2
\advance \tempcounta by30
\advance \tempcountb by30
\advance \xpos by\tempcounta
\advance \arrowlength by-\tempcounta
\advance \arrowlength by-\tempcountb
\putvector(\xpos,\ypos)(1,0)\arrowlength\arrowtype
\divide \arrowlength by2
\advance \xpos by\arrowlength
\vertsize{\tempcounta}{#5}\divide\tempcounta by2
\advance \tempcounta by20
\if a#8 \advance \ypos by\tempcounta
   \putbox(\xpos,\ypos){#5}\else
   \advance \ypos by-\tempcounta
   \putbox(\xpos,\ypos){#5}\fi}}

\def\putvmorphism(#1,#2)[#3`#4`#5]#6#7#8{{\xpos #1
\ypos #2
\arrowlength #6
\arrowtype #7
\settowidth{\xlen}{}\putbox(\xpos,\ypos){#3}{\advance \ypos by-\arrowlength
\putbox(\xpos,\ypos){#4}}{\advance\arrowlength by-140
\advance \ypos by-70
\ifdim\xlen>0pt
   \if m#8\putsplitvector(\xpos,\ypos)\arrowlength\arrowtype
   \else
   \putvector(\xpos,\ypos)(0,-1)\arrowlength\arrowtype
   \fi
\else
   \putvector(\xpos,\ypos)(0,-1)\arrowlength\arrowtype
\fi}\ifdim\xlen>0pt
   \divide \arrowlength by2
   \advance\ypos by-\arrowlength
   \if l#8\advance \xpos by-40
      \putrbox(\xpos,\ypos){#5}\else\if r#8\advance \xpos by40
      \putlbox(\xpos,\ypos){#5}\else
      \putbox(\xpos,\ypos){#5}\fi\fi
\fi
}}

\def\putsquarep<#1>(#2)[#3;#4`#5`#6`#7]{{\setsqparms[#1]\setpos(#2)\settokens[#3]\puthmorphism(\xpos,\ypos)[\tokenc`\tokend`{#7}]{\width}{\arrowtyped}b\advance\ypos by \height
\puthmorphism(\xpos,\ypos)[\tokena`\tokenb`{#4}]{\width}{\arrowtypea}a\putvmorphism(\xpos,\ypos)[``{#5}]{\height}{\arrowtypeb}l\advance\xpos by \width
\putvmorphism(\xpos,\ypos)[``{#6}]{\height}{\arrowtypec}r}}

\def\putsquare{\@ifnextchar <{\putsquarep}{\putsquarep <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped;\width`\height>}}
\def\square{\@ifnextchar< {\squarep}{\squarep
   <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped;\width`\height>}}
\def\squarep<#1>[#2`#3`#4`#5;#6`#7`#8`#9]{{\setsqparms[#1]\diagram \putsquarep<\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped;\width`\height>(0,0)[#2`#3`#4`{#5};#6`#7`#8`{#9}]\enddiagram }}                                                 \def\putptrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\advance\ypos by \height
\puthmorphism(\xpos,\ypos)[#4`#5`{#7}]{\height}{\arrowtypea}a\putvmorphism(\xpos,\ypos)[`#6`{#8}]{\height}{\arrowtypeb}l\advance\xpos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[``{#9}]{\height}{\arrowtypec}r}}

\def\putptriangle{\@ifnextchar <{\putptrianglep}{\putptrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\ptriangle{\@ifnextchar <{\ptrianglep}{\ptrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\ptrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\diagram \putptrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}                                            

\def\putqtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\advance\ypos by\height
\puthmorphism(\xpos,\ypos)[#4`#5`{#7}]{\height}{\arrowtypea}a\putmorphism(\xpos,\ypos)(1,-1)[``{#8}]{\height}{\arrowtypeb}l\advance\xpos by\height
\putvmorphism(\xpos,\ypos)[`#6`{#9}]{\height}{\arrowtypec}r}}

\def\putqtriangle{\@ifnextchar <{\putqtrianglep}{\putqtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\qtriangle{\@ifnextchar <{\qtrianglep}{\qtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\qtrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                                \diagram \putqtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}

\def\putdtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\puthmorphism(\xpos,\ypos)[#5`#6`{#9}]{\height}{\arrowtypec}b\advance\xpos by \height \advance\ypos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[``{#7}]{\height}{\arrowtypea}l\putvmorphism(\xpos,\ypos)[#4``{#8}]{\height}{\arrowtypeb}r}}

\def\putdtriangle{\@ifnextchar <{\putdtrianglep}{\putdtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\dtriangle{\@ifnextchar <{\dtrianglep}{\dtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\dtrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                                \diagram \putdtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}

\def\putbtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\puthmorphism(\xpos,\ypos)[#5`#6`{#9}]{\height}{\arrowtypec}b\advance\ypos by\height
\putmorphism(\xpos,\ypos)(1,-1)[``{#8}]{\height}{\arrowtypeb}r\putvmorphism(\xpos,\ypos)[#4``{#7}]{\height}{\arrowtypea}l}}

\def\putbtriangle{\@ifnextchar <{\putbtrianglep}{\putbtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\btriangle{\@ifnextchar <{\btrianglep}{\btrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\btrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                               \diagram \putbtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}

\def\putAtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
{\multiply \height by2
\puthmorphism(\xpos,\ypos)[#5`#6`{#9}]{\height}{\arrowtypec}b}\advance\xpos by\height \advance\ypos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[#4``{#7}]{\height}{\arrowtypea}l\putmorphism(\xpos,\ypos)(1,-1)[``{#8}]{\height}{\arrowtypeb}r}}

\def\putAtriangle{\@ifnextchar <{\putAtrianglep}{\putAtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Atriangle{\@ifnextchar <{\Atrianglep}{\Atrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Atrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                                     \diagram \putAtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}

\def\putAtrianglepairp<#1>(#2)[#3;#4`#5`#6`#7`#8]{{\settripairparms[#1]\setpos(#2)\settokens[#3]\puthmorphism(\xpos,\ypos)[\tokenb`\tokenc`{#7}]{\height}{\arrowtyped}b\advance\xpos by\height
\puthmorphism(\xpos,\ypos)[\phantom{\tokenc}`\tokend`{#8}]{\height}{\arrowtypee}b\advance\ypos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[\tokena``{#4}]{\height}{\arrowtypea}l\putvmorphism(\xpos,\ypos)[``{#5}]{\height}{\arrowtypeb}m\putmorphism(\xpos,\ypos)(1,-1)[``{#6}]{\height}{\arrowtypec}r}}

\def\putAtrianglepair{\@ifnextchar <{\putAtrianglepairp}{\putAtrianglepairp <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>}}
\def\Atrianglepair{\@ifnextchar <{\Atrianglepairp}{\Atrianglepairp <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>}}

\def\Atrianglepairp<#1>[#2;#3`#4`#5`#6`#7]{{\settripairparms[#1]\settokens[#2]\width=\height                                \diagram \putAtrianglepairp                            <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>(0,0)[{#2};#3`#4`#5`#6`{#7}]\enddiagram }}

\def\putVtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\advance\ypos by\height
{\multiply\height by2
\puthmorphism(\xpos,\ypos)[#4`#5`{#7}]{\height}{\arrowtypea}a}\putmorphism(\xpos,\ypos)(1,-1)[`#6`{#8}]{\height}{\arrowtypeb}l\advance\xpos by\height
\advance\xpos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[``{#9}]{\height}{\arrowtypec}r}}

\def\putVtriangle{\@ifnextchar <{\putVtrianglep}{\putVtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Vtriangle{\@ifnextchar <{\Vtrianglep}{\Vtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Vtrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                                 \diagram \putVtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}

\def\putVtrianglepairp<#1>(#2)[#3;#4`#5`#6`#7`#8]{{
\settripairparms[#1]\setpos(#2)\settokens[#3]\advance\ypos by\height
\putmorphism(\xpos,\ypos)(1,-1)[`\tokend`{#6}]{\height}{\arrowtypec}l\puthmorphism(\xpos,\ypos)[\tokena`\tokenb`{#4}]{\height}{\arrowtypea}a\advance\xpos by\height
\puthmorphism(\xpos,\ypos)[\phantom{\tokenb}`\tokenc`{#5}]{\height}{\arrowtypeb}a\putvmorphism(\xpos,\ypos)[``{#7}]{\height}{\arrowtyped}m\advance\xpos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[``{#8}]{\height}{\arrowtypee}r}}

\def\putVtrianglepair{\@ifnextchar <{\putVtrianglepairp}{\putVtrianglepairp <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>}}
\def\Vtrianglepair{\@ifnextchar <{\Vtrianglepairp}{\Vtrianglepairp <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>}}
\def\Vtrianglepairp<#1>[#2;#3`#4`#5`#6`#7]{{\settripairparms[#1]\settokens[#2]\diagram \putVtrianglepairp                             <\arrowtypea`\arrowtypeb`\arrowtypec`\arrowtyped`\arrowtypee;\height>(0,0)[{#2};#3`#4`#5`#6`{#7}]\enddiagram }}


\def\putCtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\advance\ypos by\height
\putmorphism(\xpos,\ypos)(1,-1)[``{#9}]{\height}{\arrowtypec}l\advance\xpos by\height
\advance\ypos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[#4`#5`{#7}]{\height}{\arrowtypea}l{\multiply\height by 2
\putvmorphism(\xpos,\ypos)[`#6`{#8}]{\height}{\arrowtypeb}r}}}

\def\putCtriangle{\@ifnextchar <{\putCtrianglep}{\putCtrianglep
    <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Ctriangle{\@ifnextchar <{\Ctrianglep}{\Ctrianglep
    <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Ctrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                               \diagram \putCtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}                                           \def\putDtrianglep<#1>(#2,#3)[#4`#5`#6;#7`#8`#9]{{\settriparms[#1]\xpos=#2 \ypos=#3
\advance\xpos by\height \advance\ypos by\height
\putmorphism(\xpos,\ypos)(-1,-1)[``{#9}]{\height}{\arrowtypec}r\advance\xpos by-\height \advance\ypos by\height
\putmorphism(\xpos,\ypos)(1,-1)[`#5`{#8}]{\height}{\arrowtypeb}r{\multiply\height by 2
\putvmorphism(\xpos,\ypos)[#4`#6`{#7}]{\height}{\arrowtypea}l}}}

\def\putDtriangle{\@ifnextchar <{\putDtrianglep}{\putDtrianglep
    <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Dtriangle{\@ifnextchar <{\Dtrianglep}{\Dtrianglep
   <\arrowtypea`\arrowtypeb`\arrowtypec;\height>}}
\def\Dtrianglep<#1>[#2`#3`#4;#5`#6`#7]{{\settriparms[#1]\width=\height                              \diagram \putDtrianglep<\arrowtypea`\arrowtypeb`\arrowtypec;\height>(0,0)[#2`#3`#4;#5`#6`{#7}]\enddiagram }}                                          \def\setrecparms[#1`#2]{\width=#1 \height=#2}

\def\recursep<#1`#2>[#3;#4`#5`#6`#7`#8]{{\width=#1 \height=#2
\settokens[#3]
\settowidth{\tempdimen}{}
\ifdim\tempdimen=0pt
  \savebox{\tempboxa}{\hbox{}}\savebox{\tempboxb}{\hbox{}}\savebox{\tempboxc}{\hbox{}}\else
  \savebox{\tempboxa}{\hbox{\tokena\tokenb}}\savebox{\tempboxb}{\hbox{\tokena\tokend}}\savebox{\tempboxc}{\hbox{\tokena#6}}\fi
\ypos=\height
\divide\ypos by 2
\xpos=\ypos
\advance\xpos by \width
\bfig
\putCtrianglep<-1`1`1;\ypos>(0,0)[`\tokenc`;#5`#6`{#7}]\puthmorphism(\ypos,0)[\tokend`\usebox{\tempboxb}`{#8}]{\width}{-1}b\puthmorphism(\ypos,\height)[\tokenb`\usebox{\tempboxa}`{#4}]{\width}{-1}a\advance\ypos by \width
\putvmorphism(\ypos,\height)[``\usebox{\tempboxc}]{\height}1r\efig
}}

\def\recurse{\@ifnextchar <{\recursep}{\recursep<\width`\height>}}

\def\puttwohmorphisms(#1,#2)[#3`#4;#5`#6]#7#8#9{{\puthmorphism(#1,#2)[#3`#4`]{#7}0a
\ypos=#2
\advance\ypos by 20
\puthmorphism(#1,\ypos)[\phantom{#3}`\phantom{#4}`#5]{#7}{#8}a
\advance\ypos by -40
\puthmorphism(#1,\ypos)[\phantom{#3}`\phantom{#4}`#6]{#7}{#9}b
}}

\def\puttwovmorphisms(#1,#2)[#3`#4;#5`#6]#7#8#9{{\putvmorphism(#1,#2)[#3`#4`]{#7}0a
\xpos=#1
\advance\xpos by -20
\putvmorphism(\xpos,#2)[\phantom{#3}`\phantom{#4}`#5]{#7}{#8}l
\advance\xpos by 40
\putvmorphism(\xpos,#2)[\phantom{#3}`\phantom{#4}`#6]{#7}{#9}r
}}

\def\puthcoequalizer(#1)[#2`#3`#4;#5`#6`#7]#8#9{{\setpos(#1)\puttwohmorphisms(\xpos,\ypos)[#2`#3;#5`#6]{#8}11\advance\xpos by #8
\puthmorphism(\xpos,\ypos)[\phantom{#3}`#4`#7]{#8}1{#9}
}}

\def\putvcoequalizer(#1)[#2`#3`#4;#5`#6`#7]#8#9{{\setpos(#1)\puttwovmorphisms(\xpos,\ypos)[#2`#3;#5`#6]{#8}11\advance\ypos by -#8
\putvmorphism(\xpos,\ypos)[\phantom{#3}`#4`#7]{#8}1{#9}
}}

\def\putthreehmorphisms(#1)[#2`#3;#4`#5`#6]#7(#8)#9{{\setpos(#1) \settypes(#8)
\if a#9 \vertsize{\tempcounta}{#5}\vertsize{\tempcountb}{#6}\ifnum \tempcounta<\tempcountb \tempcounta=\tempcountb \fi
\else
     \vertsize{\tempcounta}{#4}\vertsize{\tempcountb}{#5}\ifnum \tempcounta<\tempcountb \tempcounta=\tempcountb \fi
\fi
\advance \tempcounta by 60
\puthmorphism(\xpos,\ypos)[#2`#3`#5]{#7}{\arrowtypeb}{#9}
\advance\ypos by \tempcounta
\puthmorphism(\xpos,\ypos)[\phantom{#2}`\phantom{#3}`#4]{#7}{\arrowtypea}{#9}
\advance\ypos by -\tempcounta \advance\ypos by -\tempcounta
\puthmorphism(\xpos,\ypos)[\phantom{#2}`\phantom{#3}`#6]{#7}{\arrowtypec}{#9}
}}

\def\setarrowtoks[#1`#2`#3`#4`#5`#6]{\def\toka{#1}
\def\tokb{#2}
\def\tokc{#3}
\def\tokd{#4}
\def\toke{#5}
\def\tokf{#6}
}
\def\hex{\@ifnextchar <{\hexp}{\hexp<1000`400>}}
\def\hexp<#1`#2>[#3`#4`#5`#6`#7`#8;#9]{\setarrowtoks[#9]
\yext=#2 \advance \yext by #2
\xext=#1 \advance\xext by \yext
\bfig
\putCtriangle<-1`0`1;#2>(0,0)[`#5`;\tokb``\tokd]
\xext=#1 \yext=#2 \advance \yext by #2
\putsquare<1`0`0`1;\xext`\yext>(#2,0)[#3`#4`#7`#8;\toka```\tokf]
\advance \xext by #2
\putDtriangle<0`1`-1;#2>(\xext,0)[`#6`;`\tokc`\toke]
\efig
}


 

\newtheorem{observation}{Remark}[section]
\newtheorem{lem}[observation]{Lemma}  \newtheorem{thm}[observation]{Theorem}
\newtheorem{dfn}[observation]{Definition}
\newtheorem{exm}[observation]{Example}
\newtheorem{rem}[observation]{Remark}
\newtheorem{nte}[observation]{Notation}
\newtheorem{pro}[observation]{Proposition} 
\newtheorem{cor}[observation]{Corollary} 
\newtheorem{nada}[observation]{}  \newcommand{\ph}[2]{\begin{#1} \label{#2}} 
\newcommand{\proof}{\noindent {\bf Proof} \hspace{.1in}}
\newcommand{\proofsketch}{\noindent {\bf Proof Sketch} \hspace{.1in}}
\newcommand\monadext[1]{ {#1} ^ \# }   \newcommand\qed{  } \newcommand\alg[2]{\ensuremath{\mathbf{#1}^{\mbox{\small \textbf{#2}}}}} \newcommand\kl[2]{\ensuremath{\mathbf{#1}_{\mbox{\small \textbf{#2}}}}} \newcommand\nats{\hbox{}} \newcommand\ints{\hbox{}} \newcommand\ssub[1]{_{{}_{#1}}}  \newcommand\pointyPT[1]{\ensuremath{< \hspace{-.05in} #1 \hspace{-.05in} > \hspace{-.02in}}}
\newcommand\Lrightarrow{\hbox to 20pt{\rightarrowfill}} \newcommand\LOrightarrow{\hbox to 30pt{\rightarrowfill}}
\newcommand\LONrightarrow{\hbox to 45pt{\rightarrowfill}}
\newcommand\LONGrightarrow{\hbox to 60pt{\rightarrowfill}}
\newcommand\LONGErightarrow{\hbox to 75pt{\rightarrowfill}}
\newcommand\LONGERrightarrow{\hbox to 90pt{\rightarrowfill}}
\newcommand\ssr[1]{\stackrel{#1}{\Lrightarrow}} \newcommand\csr[1]{\stackrel{#1}{\LOrightarrow}} \newcommand\bsr[1]{\stackrel{#1}{\LONrightarrow}} \newcommand\Bsr[1]{\stackrel{#1}{\LONGrightarrow}} 

\newcommand\sets{\ensuremath{ \EuScript{S}}}   \newcommand\cm{\mathbf{K} \circ_\sigma \mathbf{H}}  
\newcommand\bimapsto{\leftarrow \kern -.15em \mapsto}  \newcommand\double[1]{#1 \mbox{\hspace{-0.2em}} #1 }  \newcommand\cons{\hbox{+ \kern -.9em +}} 




\label{firstpage}
\maketitle

\begin{abstract}
Over the past two decades the notion of a strong monad has found wide applicability in computing. Arising out of a need to interpret products in computational and semantic settings, different approaches to this concept have arisen. In this paper we introduce and investigate the connections between these approaches and also relate the results to monad composition. We also introduce new methods for checking and using the required laws associated with such compositions, as well as provide examples illustrating problems and issues that arise.   
\end{abstract}





\section{Introduction}
The notion of a strong monad arises in numerous applications including programming language design and semantics, monadic interpreters, and building models of computation. The notion, originating with Kock\cite{articleB}, was originally defined for symmetric monoidal closed categories. Mulry and others exploited this idea to introduce specific kinds of strong monads to generate a wide variety of categorical computational models as well as an analysis of fixed point semantics\cite{articleM}.  In the work of Moggie and Wadler the notion of a strong monad was used to define the semantics of programming languages \cite{articleI}, \cite{articleL}. 

Different approaches to the notion of a strong monad have also arisen. From early on it was recognized that a strong monad, and particularly the special case of a commutative monad, was critical in providing a means of interpreting products in a Kleisli category, and a means of providing a functorial lifting of biproducts. More recently Manes and Mulry have focused attention on the idea that monads, rather than being called strong which might suggest that this is a uniquely defined property of a given monad, could be viewed as being equipped with a possibly non-unique strength of a given order. In  \cite{articleD}, the authors introduced the concept of a Kleisli strength of order  for arbitrary  monads in an arbitrary symmetric monoidal category, demonstrated that the notion of Kleisli strength differs from Kock strength and provided examples demonstrating that Kleisli strength takes the form of added (non-unique) structure on a given monad, leading to the terminology of a monad equipped with a strength . The authors further observed that the existence of Kleisli strength can be used to derive methods for generating (non-unique) composition of monads for a variety of monads including standard monadic data types such as lists, trees, exceptions, reader, writer and state monads.

Different ways of defining strength lead naturally to the question of describing more fully the connections between these definitions. For instance, the definition of strength found in some examples of strong monads used for monadic interpreters may not support products in the Kleisli category because they fail to satisfy the laws required of a Kleisli strength. A further complication arises from the observation that the original use of the notion by Kock assumed the monad itself was a monoidal functor, something most monads used in computing simply are not. 


This paper provides details of the relationship between these varying notions of strength and suggests new nomenclature to distinguish between them. The paper assumes the reader is familiar with the general notions of category theory, and also depends heavily on \cite{articleD}. In section 2 we provide preliminaries such as defining the notion of a Kleisli strength, and include some examples and methods for generating it. As the examples illustrate, this notion is of independent interest and generalizes the prior notions of a commutative monad. 

Section 3 provides a brief introduction to classical commutative monads and Kock strength contrasting these concepts with that of general Kleisli strength. Also introduced is the notion of a prestrength construction arising from the existence of , its associated category, as well as a wide variety of examples to help sort out the differences between the concepts.

In section 4 we restate and prove some of the previous results in Haskell syntax. In addition to providing a means of computing and using Kleisli strength and monad compositions in Haskell, it is hoped this approach may prove more intuitive and accessible to the reader used to working in the environment of functional programming.


\section{Preliminaries}
Let \textbf{C}, \textbf{D} be categories with functor ,
 a monad in \textbf{C},  a monad in \textbf{D}.  Note that we use categorical notation here.  We write  for the Kleisli category of \textbf{H} with canonical functor  , .  

A \textbf{Kleisli lifting} of functor  is a functor  that lifts  in the sense that the following diagram commutes.
\begin{center}
\setsqparms[1`-1`-1`1;500`500]
\square[\kl{C}{H}`\kl{D}{K}`\mathbf{C}`\mathbf{D};\overline{F}`\iota_\mathbf{H}`\iota_\mathbf{K}`F]
\end{center} 

Kleisli liftings are classified exactly by natural transformations  satisfying 

\begin{center}
\xext=2000 \yext=700
\adjust[`\mu;`n;`Tn;`\mu]
\begin{picture}(\xext,\yext)(\xoff,\yoff)
\putmorphism(0,600)(1,0)[F`FH`F \eta]{975}1a
\putmorphism(1150,600)(1,0)[`FHH`F \mu]{850}{-1}a
\putmorphism(1050,-70)(1,0)[`KKF`\nu F ]{975}{-1}b
\putmorphism(975,600)(0,-1)[`KF`\lambda]{660}1r
\putmorphism(2015,600)(0,-1)[``\lambda H ]{330}1r
\putmorphism(2015,275)(0,-1)[KFH``K \lambda]{330}1r
\putmorphism(0,600)(4,-3)[``]{980}1a
\put(450,150){\makebox(0,0){}}
\put(600,350){\makebox(0,0){}}
\put(1500,350){\makebox(0,0){}}
\end{picture}
\end{center}
\vspace{.1in}

\medskip The transformation  is referred to as a \textbf{lifting transformation}. For instance, it is easy to see that given such a  and defining  by  results in a well-defined functor. It should be further pointed out that liftings (and thus lifting transformations) may not be unique for a fixed functor , something we will demonstrate later. A simple example is the well known notion of a  which corresponds to a Kleisli lift of the identity functor on \textbf{C}. This is a rather simple explanation of a far more subtle process. An elegant and more conceptual account of the precise correspondence and interaction between liftings and morphisms of monads can be found in \cite{articleJ}. 

While most of our discussion will take place in a cartesian closed category such as , some of the following constructions and results are applicable to more general settings such as symmetric monoidal categories  with tensor  and tensor unit . We will make occasional use of these generalizations here. 

We shall use the abbreviation  for  ( times), where  can be either an object or a map.  When  is an object and , .  In general, .  We also use the same symbol for the -fold product functor, so that .  
 


\section{Notions of Strength}

Let  be a monad on . For , consider the cartesian power category  with objects  and morphisms .  \textbf{K} induces a monad  on  via , , .  We denote the resulting Kleisli category for  simply as , also reflecting the fact that the Kleisli construction commutes with products in .  

\subsection{Pre-strength}

Many of the notions and examples found in the first two sections can also be found in \cite{articleD}, including the notion of .

\ph{dfn}{prnv}
Consider the category whose objects are pairs  with  a functor and  a natural transformation.  Such a  is called a \textbf{pre-strength} on 
 (we often drop the subscripts except when needed for emphasis).  A morphism  is a natural transformation  such that the following square commutes.
\begin{center}
\square<1`1`1`1;1700`600>[FV_1 \times \cdots \times FV_n`GV_1 \times \cdots \times GV_n`F(V_1 \times \cdots \times V_n)`G(V_1 \times \cdots \times V_n);\alpha \ssub{V_1} \times \cdots \times \alpha \ssub{V_n}`\Gamma^F \ssub{V_1\cdots V_n}`\Gamma^G \ssub{V_1\cdots V_n}`\alpha \ssub{V_1 \times \cdots \times V_n}] 
\end{center}  
\end{dfn}
When  is such a morphism we say  \textbf{preserves pre-strengths}.  It is obvious that this is a category under vertical composition of natural transformations, but it is also a 2-category under the horizontal composition of the endofunctor category of .


\ph{exm}{comprehensionssformpre-strength}
If  is the non-empty list monad and one defines defines  via comprehensions, namely , it is easy to check that 
 is a natural transformation and forms a pre-strength of order 2.   We return to this example shortly.
\end{exm}



\subsection{Kleisli strength}

In \cite{articleE} the idea was promoted that in the context of programming language semantics, a Kleisli lifting provides a means of lifting a given functorial process  to the semantics residing in the corresponding Kleisli categories . The associated lifting transformation mediates this process. A special case of this corresponds to lifting the product bifunctor to the corresponding Kleisli category.  In short, if products are to be well defined in the Kleisli category  and capable of interpreting composition of functions for computational or programming semantics as described earlier, a Kleisli lifting of the bifunctor must exist. This has been generalized to the notion of Kleisli strength.

\ph{dfn}{Kleislistrength}
A \textbf{Kleisli strength} on  of order  is a natural transformation  which classifies a Kleisli lift  of the -fold product functor .  Thus  is a natural transformation satisfying  and  as shown in the diagram below. (Note -~subscripts are dropped for readability sake.) 
\end{dfn}  

\begin{center}
\xext=3200 \yext=700
\adjust[`\mu;`n;`Tn;`\mu]
\begin{picture}(\xext,\yext)(\xoff,\yoff)
\putmorphism(0,600)(1,0)[V_1 \times \cdots \times V_n`KV_1 \times \cdots \times KV_n`\rho \times \cdots \times \rho]{1400}1a
\putmorphism(1850,600)(1,0)[`KKV_1 \times \cdots \times KKV_n`\nu \times \cdots \times \nu]{1200}{-1}a
\putmorphism(1800,-70)(1,0)[`KK(V_1 \times \cdots \times V_n)`\nu  ]{1200}{-1}b
\putmorphism(1400,600)(0,-1)[`K(V_1 \times \cdots \times V_n)`\Gamma^n]{660}1r
\putmorphism(3015,600)(0,-1)[``\Gamma^n_K ]{330}1r
\putmorphism(3015,275)(0,-1)[K(KV_1 \times \cdots \times KV_n)``K \Gamma^n]{330}1r
\putmorphism(0,600)(4,-3)[``]{980}1a
\put(450,125){\makebox(0,0){}}
\put(800,300){\makebox(0,0){}}
\put(2200,300){\makebox(0,0){}}
\end{picture}
\end{center}
\vspace{.2in}

For ,  always exists and coincides with . A Kleisli strength of order  is the same thing as a monad map . We note that there is always at least one Kleisli strength of order 1, namely . Based on the discussion of section 2, a Kleisli strength of order  is precisely a lifting transformation for .

\vspace{.2in}
We briefly describe a few examples of Kleisli strength. As indicated earlier, the category of sets and total functions will be denoted .


\ph{exm}{revisKleislistrength}
Let  be the list monad then the reverse transformation  is a Kleisli strength of order 1 on \textbf{L}. Since identity is also of order one by the above remark, this  demonstrates that Kleisli strengths are not unique. 
\end{exm} 



\ph{exm}{powersetKleislistrength}
Let  be the finite power set monad.  Then  is a Kleisli strength of order , where  for .
\end{exm}



\ph{exm}{exceptionsarestrongmonads}
Let  be the exceptions monad , with  any nonempty set. If , for each  the monad admits a Kleisli strength of order n , where    , if all of the  are in , and equals  otherwise. If  where , then the new  generated by  differs from the one generated by . We return to this example shortly.
\end{exm}

\ph{exm}{bottommonadstrength} Much as in the previous example, let  be the \lq\rq or lifting monad,  defined on , the category of (possibly bottomless) Scott domains and continuous maps \cite{articleG}.  is a Kleisli strength of order n () where   if all of the  are in , and equals  otherwise. 
\end{exm}


\ph{exm}{exponentialisstrong} For a fixed  consider the exponential or reader monad  where .   has a Kleisli strength of order n where . 
\end{exm}

\ph{exm}{certificatemonadnotstrong} Consider the M-set or writer monad , where  is a commutative monoid, then  forms a Kleisli strength of order 2.
\end{exm}


In the last example if  is not commutative, then  need not form a Kleisli strength of order 2. Likewise in the next example we see list comprehensions do not generally form Kleisli strengths.


\ph{exm}{comprehensionssnotstrong}
Let  then the prestrength  of Example \ref{comprehensionssformpre-strength} does not form a Kleisli strength of order 2. Working clockwise on the pair  in diagram , for instance, generates , while counterclockwise generates 
. 
\end{exm}

\ph{exm}{binarytreemonad} The \textbf{binary tree monad}  consists of binary trees whose values (from ) are located in its leaves. We denote an empty tree by , a trivial tree (i.e. a leaf) with value  by  and a tree consisting of left and right subtrees  and  by . If  denotes the submonad of non-empty binary trees, then the map  defined by  where  and  are the leftmost nodes of trees  and  respectively forms a Kleisli strength of order 2 on .
\end{exm}

\ph{pro}{Kleislistrengthnfrom2}
Let  be a Kleisli strength on  of order 2, then  is a Kleisli strength on  of order 3.  The same process produces  from ,  from ,  producing a Kleisli strength  of order  for all . In a similar fashion one can also define a Kleisli strength of order 3 via  and similarly   . These constructions generally disagree unless  is \textbf{associative}, namely . 
\end{pro}    

\ph{exm}{non-emptylistsarestrongmonads} Let  be the non-empty list monad. In contrast to Example \ref{comprehensionssnotstrong}, by using a different approach than comprehensions we can produce examples of Kleisli strength. Let  and  choose the first (or respectively last) element of a non-empty list. Then  and  are associative Kleisli strengths of order 2.
\end{exm}





\subsection{Prestrength Construction}

As the prior sections illustrate, the notion of Kleisli strength consists of additional (non-unique) structure  imposed on the monad. In particular, no assumption was made of the existence of an internal map structure  for a monad . The underlying category need not even be closed. This is a common assumption in functional programming, indeed it is already built into the specification of the functor class in Haskell, where it is denoted . The idea of a monad in a category equipped with a map  had already been defined much earlier by Kock \cite{articleB} who called it a {\it strong monad}. Building the composition , and taking adjoints generates the map we denote , which is often referred to in the functional programming language literature as "the monad strength" for  (and often denoted simply by ). In a similar fashion one can generate the map . This leads in turn to the compositions

\medskip
\\

\\

\noindent where , using the standard  notation first introduced by Manes \cite{bookA}. These two compositions can easily be checked for naturality and form what we denote as the {\it left and right pre-strength constructions}, , for the given monad.  These derived pre-strengths are generally not equal nor are they always examples of Kleisli strength as we illustrate next. In light of this last observation, it makes sense to consider to what extent prestrength constructions support products in a semantic setting. 



\medskip
For the remainder of the paper whenever we have a monad  on a cartesian closed category  equipped with such a  we will denote  as a {\bf -monad}. 



\ph{exm}{lGammanotaKleislistrengthI} If  is the non-empty list monad, the derived left prestrength  is exactly the comprehension  of Example \ref{comprehensionssformpre-strength}. Example \ref{comprehensionssnotstrong} provides an easy example where  fails for . Similarly , which is the reverse comprehension, does not agree with  nor does it satisfy . Thus neither is a Kleisli strength.
\end{exm}

In \cite{articleB}, Anders Kock assumed  to be a symmetric monoidal \textit{closed} category,  required  to be a monoidal monad and  and  to be -natural. Under such assumptions Kock defined  to be commutative if  . Thus the previous example illustrates that even with a weaker notion of commutative monad in a cartesian closed category,  need not be commutative. For the remainder of the paper we will let the term {\it commutative monad} refer to this weaker notion, namely a -monad \  in a cartesian closed category where the derived left and right prestrengths agree, . This agrees with the usual use of this term, found for instance in \cite{articleI}.


\subsection{Monad semantics, cartesian products, and Kleisli Strength}

In \cite{articleL}, Wadler introduced the notion of a monadic interpreter. This application, as well as others in computation and programming semantics, depends on interpreting terms in the Kleisli category for a monad. In the case of monadic interpreters there is a core interpretation which applies to all monads with small modifications made for any particular monad. Notably, the example interpreters found there and elsewhere lack a product construct despite its obvious role in both programming and computation. This is no doubt due to the fact that such interpreters would have to satisfy certain laws ensuring that composition is well defined with regard to that construct in the associated Kleisli categories. As emphasized earler, such laws are satisfied precisely when the monad is equipped with a Kleisli strength.

Suppose we are given terms  where each  is interpreted  for some monad . The resulting term  should have type . This requires the existence of a prestrength   with the resulting composition .  must be a Kleisli strength, a general prestrength will not do, nor even a derived pre-strength, in order for function composition to behave properly. It does not require that  be commutative however. We illustrate this point with the next example. 

Let  , , ,  be four arbitrary functions respectively. In any cartesian category \textbf{C}, it follows from the definition of product that the following two compositions (of type ) must agree:

1)  

2) .




\ph{exm}{lGammanotaKleislistrengthII} 
Let  be the exceptions monad of Example \ref{exceptionsarestrongmonads}, where 
 now has exactly two elements  and . For arbitrary fixed values  in  and  in , let  (where  is the return method), ,  and  is arbitrary, all with the same type structure as above but where the maps are now in , so for instance  in  corresponds to  in \textbf{C}. Interpreting the compositions in the Kleisli category ,  and  should agree. Using the derived left prestrength  on value ,  while  and so the compositions disagree. In a symmetric fashion one can show that the derived right prestrength also fails to guarantee equality. The reader will recall that the derived right prestrength construction is what is usually referred to as the monad strength in the sense found in \cite{articleL} and thus a product semantics with this notion of strength will fail to be correct. In contrast either Kleisli strength in 
Example \ref{exceptionsarestrongmonads} will guarantee equality of the two compositions. 
\end{exm}


The above discussion illustrates that the prestrength construction leading to the usual notion of monad strength does not generally support products in the Kleisli category, not just for the exception monad but for many other monads such as the list, state, continuation and selection monads. In contrast Kleisli strengths exist for many of these monads. 

\subsection{Classical Commutative Monads and Kleisli Strength}
In the next several sections we investigate the connections between the previous results and commutative monads as well as monad compositions, where supporting
results can be found in \cite{articleD}. To emphasize the connection to prior work we briefly work with symmetric monoidal categories. 


\ph{lem}{getGammafromlstrst}
If  is an arbitrary Kleisli strength of order 2 on monad , define natural transformations ,  by 

Then 


Similarly 
\end{lem}


Note that the lemma begins with an arbitrary Kleisli strength  of order 2 on monad  which induces via the unit, , the maps  and . In essence what the lemma states is that if we use the prestrength construction of section 3.3, the resulting prestrengths agree with each other and generate the original Kleisli strength. Thus the notion of Kleisli strength can be seen as a natural generalization of Kock's commutative monads to symmetric monoidal categories that are not necessarily closed and where the monad is no longer assumed to be a monoidal functor. This is important as very few monads of interest to computer science are monoidal functors and so we work instead with Kleisli strength. 

Checking whether a given monad has a Kleisli strength however, namely that conditions () and () hold, can often be tedious and complicated, so it would be useful to have an easier characterization for determining when Kleisli strength exists. In general this is not known but in the special case of the prestrength construction we can generalize a result of Kock. First a useful lemma.



\ph{lem}{rstisaKleisliLift} Given -monad , the corresponding maps  and  form Kleisli lifting transformations.
\end{lem}
The proof is a straightforward diagram chase and simply checks that the following two equations hold (in the case of ).

1) 

2) 

\ph{thm}{KleisliequalsCommutative}
Given -monad , then the derived prestrength  is a Kleisli strength if and only if   is commutative () in which case  is also a Kleisli strength. Likewise the symmetric statement holds for .
\end{thm}

\begin{proof}
We look at the case of . 
Condition ( holds since

 

 (by \ref {rstisaKleisliLift})

 (by naturality of rst)

 (by \ref {rstisaKleisliLift}).

\medskip

Condition ( holds since


  (by definition)

 (naturality of lst)


(by \ref {rstisaKleisliLift})


(by \ref {rstisaKleisliLift})


(by naturality of )


(by naturality of )


(by naturality of )


(by property of monad)


(since )


(by property of monad)


(by naturality of )


(by naturality of )


(by property of monads)



\medskip
Conversely, suppose that the derived prestrength  is a Kleisli strength where . Consider the corresponding maps  and . We have that . Also . Thus by the argument of Lemma  \ref{getGammafromlstrst}, the maps  and  arising from  agree in turn with  and  respectively and so generate both  and  which agree. Thus the monad is commutative.
\end{proof}

\smallskip
Note: The last result does not characterize whether a given monad has a Kleisli strength. For example the state monad is not commutative but does have a Kleisli strength as we note in the next example, rather it asserts that the derived prestrength is a Kleisli strength exactly when the monad is commutative, often a much easier condition to check.

\medskip


\ph{exm}{statemonadsarenotKockstrong} Consider the state monad  where . Building the left and right pre-strength constructions  we have,

\noindent
\\
\noindent
. 

\noindent By the previous theorem since  and  don't agree, neither is a Kleisli strength, nor commutative. On the other hand  is a Kleisli strength. 
\end{exm}



\ph{exm}{exceptionsarenotKockstrongmonads} In Example \ref{exceptionsarestrongmonads} it was shown the exceptions monad  came equipped with different Kleisli strengths for non-trivial .  is not commutative however since for , the derived prestrengths are  while , and so . 
\end{exm}


\subsection{Composing Monadic Data Types}

As the previous sections illustrate, monads play an important role in different aspects of functional programming. Since we often wish to apply more than one monad to a particular construction, finding circumstances where they compose is of particular interest. Monads compose exactly in the presence of a distributive law which is defined next. Finding such laws can be difficult in general, but in the presence of Kleisli strength a large class of these laws exists. 



\ph{dfn} {DefnofDistLaw} For monads  and  on category \textbf{C}, a \textbf{distributive law of H over K} is a natural transformation  for which the following diagrams commute.  
\begin{center}
\xext=3500 \yext=1700
\adjust[`\mu;`n;`Tn;`\mu]
\begin{picture}(\xext,\yext)(\xoff,\yoff)
\putmorphism(0,1600)(1,0)[H`HK` H\rho ]{975}1a
\putmorphism(1150,1600)(1,0)[`HKK` H\nu ]{850}{-1}a
\putmorphism(1050,930)(1,0)[`KKH` \nu H]{975}{-1}b
\putmorphism(975,1600)(0,-1)[`KH`\lambda]{660}1r
\putmorphism(2015,1600)(0,-1)[`` \lambda K]{330}1r
\putmorphism(2015,1275)(0,-1)[KHK``K\lambda ]{330}1r
\putmorphism(0,1600)(4,-3)[``]{980}1a
\put(450,1150){\makebox(0,0){}}
\put(650,1350){\makebox(0,0){}}
\put(1500,1350){\makebox(0,0){}}
\put(2900,1350){\makebox(0,0)}
\putmorphism(0,600)(1,0)[K`HK` \eta K]{975}1a
\putmorphism(1150,600)(1,0)[`HHK` \mu K]{850}{-1}a
\putmorphism(1050,-70)(1,0)[`KHH`K \mu  ]{975}{-1}b
\putmorphism(975,600)(0,-1)[`KH`\lambda]{660}1r
\putmorphism(2015,600)(0,-1)[``H\lambda  ]{330}1r
\putmorphism(2015,275)(0,-1)[HKH`` \lambda H]{330}1r
\putmorphism(0,600)(4,-3)[``]{980}1a
\put(450,150){\makebox(0,0){}}
\put(650,350){\makebox(0,0){}}
\put(1500,350){\makebox(0,0){}}
\put(2900,350){\makebox(0,0)}
\end{picture}
\end{center} 
\end{dfn}
\vspace{.2in}

We now return to the problem of providing a means of composing monadic types such as . The key point is the existence of a distributive law. As pointed out in \cite{articleC}, a distributive law of  over  produces the composite monad   where the four laws above ensure the laws for a monad hold, thus providing a means of composing monadic data types. In particular, there may be more than one such law  for given monads  and  and it is critical to provide  when asserting the composition. In particular, monads equipped with Kleisli strength play an important role in the composition with free monadic data types. We address this next.

\ph{thm}{DLKleislistrengthoverfreemonad}
Let  be a monadic finitary signature in  with corresponding free monad 
. If  is a monad in  equipped with a family of Kleisli strengths  with each  of order  if , then there exists a distributive law 
.
\end{thm}

The categorical proof of this result is lengthy and will be skipped, however in section 4.1 we will sketch a proof in Haskell. This last result, and corresponding ones associated with linear monadic finitary signatures, generate compositions involving monadic data types such as lists, trees and exceptions which would not exist under normal circumstances, such as the list monad composed with itself, incorrectly claimed in \cite{articleA}. As emphasized earlier, Kleisli strength is a more general notion than commutativity and thus distributive laws can exist even for non-commutative monads. Since every commutative monad is Kleisli strong we have the immediate corollary.

\ph{cor}{DLCommutativeMonadoverfreemonad}
If in Theorem \ref{DLKleislistrengthoverfreemonad}  is commutative, there exists a distributive law  of  over \textbf{K}.
\end{cor}

\ph{exm}{powersetVcompose}
The monad   of Example \ref{powersetKleislistrength} has a Kleisli strength of order n. By \ref{DLKleislistrengthoverfreemonad}, there exists a distributive law  for any monadic finitary signature . For instance, if  is the binary tree monad , then   defined by  ,  and  is a distributive law resulting in the composite monad . 
\end{exm}

\ph{exm}{readerVcompose} Similarly, for the reader monad  of Example \ref{exponentialisstrong}, there exists a distributive law  for any monadic finitary signature .  Now when  is , the distributive law  is defined to be ,   and , resulting in the composite monad .
\end{exm}

The prior results provide a roadmap for constructing composite monads. They also provide a means for testing whether such compositions are correctly defined. The following example is a case in point. 

\ph{exm}{seqNotCorrect}
An important monad operation in Haskell is the function  i.e. a function with type structure . Since monads are at work, it is reasonable to require that the interpretation of this operation in the Kleisli category (for monad ) is consistent. As a functor,  acting on function  is just the ordinary  function, i.e.  in Haskell. If we now take into account arbitrary monad , does  preserve the composition of functions in , namely can  (or ) now be lifted to  where the operation  comes into play? If we denote the lift of  (or  on the function  as , then  is defined as  and preservation of Kleisli composition requires that the property  should hold, which it does not. We supply two simple examples in Haskell next.
\end{exm}

\ph{exm}{SequenceNotSemanticallyCorrectI} Let  be the list monad where , and , then the compositions 
 and   disagree.
\end{exm}

\ph{exm}{SequenceNotSemanticallyCorrectII}  Let  denote the {\it IO} monad in Haskell, ,  be defined where  is defined to call {\it getChar} -times while  is simply . While both  and  will return something of type  for a given list of integers, the resulting actions will differ. For example, we have that  on keyboard input  results in  while  on the same input generates  and thus the compositions do not agree.
\end{exm}

What went wrong in these last examples? The operation  fails to be a distributive law because of the choice of monads . This also is suggestive of why past examples of the list monad composed with itself were not correct. If the monad  comes equipped with a Kleisli strength, however, than a distributive law exists and a consistent notion of composition is possible. 


\section{Applying results in Haskell} As the prior section illustrates, satisfying the laws for Kleisli strength or commutativity is critical to correctly composing monadic data types via distributive laws. Proving that these laws hold, however, can at times be either difficult or nonintuitive, the proof of Theorem \ref{KleisliequalsCommutative} being a case in point. It would be very useful if these laws could be expressed in a more accessible form, such as a functional programming format, which might allow for easier testing and verification.  Additionally, we would like to generate concrete code that might generically build the default methods required for monad composition. In this section we provide several results in this direction using Haskell.

\subsection{Kleisli Strength and Distributive Laws in Haskell}

We begin by recalling some Haskell notation. Given a monad on \textbf{C}, , we note that  correspond to the {\it return} method in Haskell while  corresponds to a {\it join} function defined in Haskell by . The bind operation  is a default method for the monad class in Haskell, but it can easily be seen to correspond categorically to , or put in more categorical notation,  using Manes notation. A special case of  is  defined by  where x is not free in .




As pointed out in \cite{ArticleK}, the do-syntax provides an intuitive and convenient way of writing an abbreviated form for applying multiple bind operations. The interpretation of do is captured in the following two rules:

\noindent  \\
 \\




Given -monad  recall that a monad is called commutative if the left and right prestrengths  and  generated by the pre-strength construction agree. We have immediately the following lemma.

\ph{lem}{DoExpressionForCommutative}  is commutative exactly when the following two {\it do expressions} agree for any pair  in .


\begin{proof}
The reader can easily check that the left (right) do-expresssions correspond exactly to the pre-strength constructions , (  for the given monad .
\end{proof}
\end{lem}

\bigskip
We now consider an alternative proof in Haskell of Theorem \ref{KleisliequalsCommutative} of the prior section. Given monad  as in the theorem, then the derived prestrength  is a Kleisli strength if conditions ( and ( of Kleisli strength hold. Focusing on ( we have the following result.

\ph{lem}{DoExpressionForKleisli} Applying the clockwise composition of condition ( on value  in  results in the following do expression in Haskell.\\
\\
\begin{proof}


\end{proof}
\end{lem}

Going clockwise for  and using Lemma \ref{DoExpressionForCommutative} we have
 is exactly  applied to \\ 
\\

Since  is natural,  and again using Lemma \ref{DoExpressionForCommutative} results in  applied to \\
\medskip



By monad laws, applying  simply removes the middle return.\\


\ph{lem}{DoExpressionForKleisli2} The counterclockwise composition of condition ( on value  in  results in the following do expression in Haskell.\\

\\

\begin{proof}
The counterclockwise composition applied to  is just . The expression  corresponds to the do expression\\
 \\
with a similar do expression for .\\
Applying Lemma \ref{DoExpressionForCommutative} gives the desired result where we drop the redundant do's.
\end{proof}

\end{lem}






We now apply the previous results to prove Theorem \ref{KleisliequalsCommutative}.

\ph{thm}{NewProofKleisliequalsCommutative} Given monad , then the derived prestrength  is a Kleisli strength if and only if   is commutative
\end{thm}
\begin{proof} By Lemma \ref{DoExpressionForKleisli2} the counterclockwise composition of condition ( on value  in  corresponds to\\

\\

If  is commutative, we can swap the middle two lines resulting in the do-expression found in Lemma \ref{DoExpressionForKleisli} and so condition ( holds. Showing condition ( holds is trivial and left to the reader. 

Conversely if  is a Kleisli strength, then condition ( holds. Applying the values 
\newline  to the clockwise composition generates a do expression equivalent to \\
 \\
which must agree with applying the same values counterclockwise generating a do expression equivalent to \\
 \\
Since  and  were arbitrary values of type  and  respectively,   is commutative.
\end{proof}\\


We now turn our attention to the results on distributive laws found in section 3. We use Haskell to provide a more intuitive approach to Corollary \ref{DLCommutativeMonadoverfreemonad}. First we state a useful lemma that provides a definition in Haskell of the distributive laws generated by the corollary.


\ph{lem}{DefnOfLambdaUsingDo} Let  be the free monad of Theorem \ref{DLKleislistrengthoverfreemonad} with commutative monad  both defined on . Then the corresponding distributive law 
 can be defined as follows in Haskell. For each , 
\begin{proof}
The interested reader can check the original proof found in \cite{articleD} for details of the construction of  which is defined recursively. The do expression is a straightforward translation of that construction.
\end{proof}
\end{lem}




\ph{thm}{NewProofCommutativeImpliesComposition}
If in Theorem \ref{DLKleislistrengthoverfreemonad}  is commutative, there exists a distributive law of  over \textbf{K},  .
\end{thm}
\begin{proof}
For ease of discussion, we use a simple example of the free polynomial monad , namely  the non-empty binary tree monad of Example \ref{binarytreemonad}(we drop the ) where a trivial tree (i.e. a leaf) with value  is denoted by  and a tree consisting of left and right subtrees  and  by . We have four laws to check that a distributive law exists for .


Focusing on law  and starting with a term  of type , going clockwise  
 corresponds by Lemma \ref{DefnOfLambdaUsingDo} to  applied to the do expression\\
\\ 

\noindent
Since return is natural,  applied to\\
\\
composing with  removes the middle  and the redundant , resulting in the do expression \\
\\

In a similar fashion counterclockwise composition  generates a do expression equivalent to \\
\\

When  is commutative, the two middle components in the latter do expression can be swapped resulting in the clockwise composition and so  holds. The two conditions  and  are easily verified leaving only . Since  is a recursively defined data type, . Since  is also defined recursively, condition  follows immediately by structural recursion. The final case of considering elements of the form  easily holds for all conditions and is left to the reader.
\end{proof}


\subsection{Some examples in Haskell}

\ph{exm}{ReturnToSequence}
One can generalize the last result to include quotients of free monads, such as the list monad. In this case the Haskell code for the distributive law  produced whenever  is a commutative monad is defined by Lemma \ref{DefnOfLambdaUsingDo} as\\
\\
which coincides exactly with the usual definition of  found in Haskell. 
The problems arising in Examples \ref{SequenceNotSemanticallyCorrectI} and \ref{SequenceNotSemanticallyCorrectII} occurred since the monads used were the list and IO monad respectively, neither of which is commutative.
\end{exm}



\ph{exm}{GeneralizingSequenceToBinTrees} 
It is an easy matter to define a correct distributive law for composing binary trees over other commutative monads such as the reader monad, . 
\end{exm}

Theorem \ref{DLCommutativeMonadoverfreemonad} indicates that one can build composite monadic data types for any free polynomial monad data types over commutative monads such as powerset, bag, reader, writer(for commutative monoid) and maybe monads. Lemma \ref{DefnOfLambdaUsingDo} provides a roadmap for defining the corresponding distributive laws in Haskell. What remains is to provide an explicit definition of the  and  operators in Haskell so we can apply these results. We do this next.

\ph{pro}{DefiningBind} Given a recursive polynomial monad  over a commutative monad  one can define the resulting composite monad  generated by distributive law  in Haskell where the bind operation is defined by 
\end{pro}
\begin{proof}
The return method () for  is trivial and simply the composition of the individual return methods, i.e. . Exploiting basic propeties of a monad we arrive at a definition of bind on the composite monad . The join operation  is defined by  which in turn is used to define the bind operation on  via  where  denotes the action of the functor on the new composite monad. Now a straightforward diagram chase shows that\\
\\
where the latter uses of  refer to the monad .\\

\noindent So   corresponds to  applied to the do expression\\
 \\

\noindent 
rewriting  as a do expression and using naturality generates the desired result.

\vspace{.1in}
\end{proof}


\noindent
Next we provide several examples. A key point is that no actual work is required to decipher the details of how the operators  and  behave for these examples since it is already determined generically by the prior results.


\ph{exm}{CompositeReaderBinaryTree} Exploiting the previous proposition, computing the bind method for the composite monad  is straightforward. For instance\\
 while\\
 where\\ 
 if  is even and  otherwise.\\
\end{exm}


\ph{exm}{ComputingSequenceforBinTrees}
For the composite monad  of the Example \ref{GeneralizingSequenceToBinTrees} we have that given \\ 
\\
where  if n is even \\
\indent \indent \indent  otherwise, \\
\noindent
.

\end{exm}

\ph{exm}{CompositeMSetBinaryTree} Consider the M-set monad  of Example 
\ref{certificatemonadnotstrong} where C is a monoid. When  is  commutative, so is  and so we can form the composite monad . Here the definition of  derived from Lemma \ref{DefnOfLambdaUsingDo} yields for instance\\
.\\
\\
Likewise using Proposition \ref{DefiningBind},  produces\\
 \\
where  is the commutative monoid of integers under addition.
\end{exm}




\section{Summary and Future Work}
The results of section 3 indicate that there are tradeoffs on how to utilize monads to interpret products semantically. Derived strengths are a natural consequence of the existence of an st-monad however they may fail to provide a correct semantics except in the exceptional case when the monad is commutative. Kleisli strengths provide an alternative approach. They generalize the notion of commutative and are thus applicable to a much wider array of monad used in computing while also guaranteeing that products lift to the coresponding Kleisli categories. An important application comes up in the context of monad composition where derived strength is not sufficient, but Kleisli strength is, to guarantee the proper composition of certain monads with polynomial monadic data types. Additional restrictions on the class structure of monads along the lines of commutativity or Kleisli strength will thus be required to ensure composition of functions in Kleisli. Section 4 provides an approach to earlier results using Haskell. In addition to providing explicit expressions that can test for the existence of Kleisli strength and distributivity, it also provides the generic code required for the default methods for a monad composition class for the compositions investigated.

  
Other constructs related to composing monads arise and might profit from the approach introduced in the paper. For instance, the previous section included an example related to the monad transformer construction. In \cite{articleH} the connection between the present work on composing monads and monad transformers is explored in more detail. Another important question is understanding when Kleisli strength is preserved under monad composition. While an initial result can be found in \cite{articleD}, in \cite{articleF} we provide additional examples and results that exploit the Haskell-centric approach found in this paper.


\section{Acknowlegement}

This paper is dedicated to David Schmidt on the occasion of his 60th birthday. David has been a friend and colleague for many years, someone who has shown consistent care and support for his students, colleagues, and the research community. I wish David continued success for many years to come.



\nocite{*}
\bibliographystyle{eptcs}
\bibliography{NotionsOfMonadStrength}
\end{document}
