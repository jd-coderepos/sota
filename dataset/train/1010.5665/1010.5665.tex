
\subsection{Safe-LTL}

We now define a subset of LTL formulas that capture all safety properties.

\begin{definition}
The set of safe-LTL formulae is generated by the following grammar:

where  ranges over a set  of atomic propositions.
\end{definition}


\begin{figure*}[htb]
\centering
\subfigure[Fine Automaton for .]{
\includegraphics[scale=0.6]{nfa.pdf}
\label{fig:pwqnondet}
}
\subfigure[Determinized Version]{
\includegraphics[scale=0.5]{pwq.pdf}
\label{fig:pwqdet}
}
\label{fig:pwq}
\caption[optional]{}
\end{figure*}

A safe-LTL formula always defines a safety property. 
Intuitively, a formula  defines a safety property if  can 
be checked by looking at a finite prefix of .

Thus, reasoning about safety properties on infinite behaviors can be reduced to reasoning
about their finite prefixes.
First, we recall nondeterministic finite automata as acceptors of languages over finite words.
A \emph{nondeterministic finite automaton (NFA)} is a 5-tuple 
 = , , , , ,
where  is a finite set of states,  is a set of initial states, 
is a set of final states,  is an alphabet, and  is a set of transitions.
An NFA is \emph{deterministic}, written DFA, if  and  defines a total function
from  into . 
The unique successor of a state  under the letter  
in a deterministic automaton is denoted by . A {\em run} of an NFA on a word 
is a sequence  such that  and
for each  we have .
A run is accepting if moreover , and we say the NFA accepts .
The language of an NFA is the set of all words  such that the NFA has an accepting run on .


The set of \emph{bad prefixes} for a safety formula  is defined by:

That is, a (finite) prefix  is bad if none of its infinite extensions  
satisfies the formula .
The set of fine prefixes is the set of finite prefixes that are sufficient to prove that the computation is unsafe.
We say that a set  is a \emph{trap} for the safety language  iff
every word  has at least one prefix .  
We denote all the traps for  by .

We say that a nondeterministic automaton  is \emph{fine} for  iff 
there exists  such that .
Thus, a fine automaton  may not accept all the bad prefixes, however
it should accept at least one bad prefix of every computation that does not satisfy .


Kupferman and Vardi \cite{KV01,KupfermanL06} show that an automaton fine for  can
be constructed from .
The translation is based on the \emph{reverse deterministic} automaton defined 
in~\cite{VardiW94}. 
In \tool~we implemented the version of Kupferman and Vardi's algorithm reported in~\cite{Lat03} and 
presented here as Algorithm~\ref{algo:fine}. 
This algorithm computes  from a safe-LTL formula . 
It first computes the set of subformulas  of  by the procedure
\emph{computeClosure}.
Since each state of the automaton represent whether each of the subformulas is either 
true or false in that state, the fine automaton can have at most  states.

\begin{proposition}
For every safe-LTL formula , Algorithm~\ref{algo:fine} constructs a
nondeterministic fine automaton for  with at most  states. 
\end{proposition}





\begin{algorithm}[t]
\begin{algorithmic}
\begin{tabbing}
\= ; \\
\> , ; , \\ 
\> {\bf while}  {\bf do}\\
\> \quad \\
\> \quad {\bf foreach} \\
\> \quad \quad \\
\> \quad \quad {\bf foreach}  {\bf do}\\
\> \quad \quad \quad {\bf switch}  {\bf begin}\\
\> \quad \quad \quad \quad {\bf case}  or  for :\\
\> \quad \quad \quad \quad if  is satisfied by , then \\
\> \quad \quad \quad \quad {\bf case}  :\\
\> \quad \quad \quad \quad if  or  then \\
\> \quad \quad \quad \quad {\bf case}  :\\
\> \quad \quad \quad \quad if  and  then \\
\> \quad \quad \quad \quad {\bf case}  :\\
\> \quad \quad \quad \quad if  then \\
\> \quad \quad \quad \quad {\bf case}  :\\
\> \quad \quad \quad \quad if  or ( and )\\
\> \quad \quad \quad \quad then \\
\> \quad \quad \quad {\bf end switch}\\
\> \quad \quad {\bf end for}\\
\> \quad \quad {\bf if}  {\bf then} \\
\> \quad \quad \\
\> \quad \quad , \\
\> \quad {\bf end for}\\
\> {\bf end while}\\
\> {\bf return} 
\end{tabbing}
\end{algorithmic}
\caption{
{\bf ConstructFineAutomaton()}\label{algo:fine}}
\end{algorithm}


\section{Controller Synthesis}


In this section, we assume that we have already computed a finite
abstraction, 
in the form of a system , of the physical components.
\tool~accepts a pair of specifications : the
first, , is a safe-LTL
formula that specifies the safety requirements of the system, and
the second, , is a guarantee formula of the form  that
specifies that the goal  is eventually reached.
We perform controller synthesis in two steps.
First, we compute the maximal winning strategy for player~0 for the
safe-LTL part of the specification.
Second, we compute a controller that ensures the guarantee property
using a strategy compatible with the maximal strategy.

\subsection{Controller Synthesis for Safe-LTL}

For synthesizing a controller for a safe-LTL formula , we construct a
deterministic automaton on finite words that is fine for .
Note that Algorithm~\ref{algo:fine} may produce an NFA.
However, determinization for NFAs over finite words uses the (easier
to implement) subset construction.



Theoretically, the determinization step adds one more exponential,
making the complexity of the construction doubly exponential in the
size of .
In our practical examples, this double exponential behavior has not
shown up.
For example, given the fine automaton for , the subset construction
creates the deterministic automaton Figure~\ref{fig:pwqdet}.

Given a system  and a DFA  fine for , we
define the \emph{synchronous product}  where
\begin{itemize}
 \item ;
 \item ;
\item  ;
\item   if  and ;
\item ;
\item   for each .
\end{itemize}
A controller enforcing  on  can be constructed by synthesizing a controller
on the synchronus product  enforcing the
specification that the system always remains in the states 
, i.e., that player~0 ensures that no word in the
language of  is seen.
This is a safety game where player~0 keeps the states into an
invariant set (), and can be solved using
existing methods by iterating a symbolic controllable-predecessor operator
\cite{Zielonka98,MazoDT10}.
Moreover, it is well-known that player~0 has memoryless maximal
winning strategies in this game.




\begin{theorem}\label{th:fine}
Let   be system and let  
be a deterministic finite automaton fine for the safe-LTL formula .
For any initial state , player 0
has a winning strategy for the safe-LTL formula , if
player 0 has a memoryless winning strategy from the unique  to stay in  states in system .
Moreover, player~0 has a maximal winning strategy in .
\end{theorem}



Thus, the algorithm to construct a maximal memoryless controller for a
system  and a 
safe-LTL property  proceeds as follows.
First, we construct an NFA  fine for .
Second, we use the subset construction to determinize  into
a DFA .
Third, we construct the synchronous product of  with .
Finally, we solve the safety game on  for the
winning set  and construct a maximal
memoryless winning strategy.

\subsection{Controller Synthesis for the Guarantee Part}

Let  be the synchronous product of a system and a
DFA fine for the safe-LTL , and let  be a maximal
memoryless winning strategy for player~0 which ensures that all runs of the
system stay in the states .

We define the restriction of  modulo  to be
the system  where  if
 and .
That is, we restrict the actions available at a state to only those
allowed by the maximal strategy .

We now consider constructing a controller for the guarantee part
.
We solve this by constructing a winning strategy in the reachability
game on the product  modulo , the maximal
memoryless winning strategy for the safety game.
Again, the solution to the reachability game is constructed by
iterating a symbolic controllable predecessor operator
\cite{Zielonka98,MazoDT10}.

The resulting strategy ensures that the guarantee part  is
enforced by player~0 (by construction in the reachability game), 
while always maintaining the safety part (by ensuring that the
strategy is compatible with ).
Together, the controller enforces the specification .




While the current implementation of \tool~only handles guarantee
properties of the form  (or some syntactic sugar, e.g.,
properties of the form  using the identity ), notice that all we need is
that a deterministic generator for the liveness part of the
specification is efficiently computable.
For example, it is easy to extend the algorithm when the liveness part
of the specification is a B\"uchi requirements , or
more generally, from the fragments described in \cite{AlurT04}.