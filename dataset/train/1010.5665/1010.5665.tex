
\subsection{Safe-LTL}

We now define a subset of LTL formulas that capture all safety properties.

\begin{definition}
The set of safe-LTL formulae is generated by the following grammar:
\[
\varphi\, ::= \, p \mid \lnot p \mid \varphi \vee \varphi \mid \varphi \wedge \varphi \mid \bigcirc\; \varphi \mid \varphi\; \W\; \varphi
\]
where $p$ ranges over a set $\mathcal{P}$ of atomic propositions.
\end{definition}


\begin{figure*}[htb]
\centering
\subfigure[Fine Automaton for $p\ \W\ q$.]{
\includegraphics[scale=0.6]{nfa.pdf}
\label{fig:pwqnondet}
}
\subfigure[Determinized Version]{
\includegraphics[scale=0.5]{pwq.pdf}
\label{fig:pwqdet}
}
\label{fig:pwq}
\caption[optional]{$p\ \W\ q$}
\end{figure*}

A safe-LTL formula always defines a safety property. 
Intuitively, a formula $\varphi$ defines a safety property if $\mathsf{z}\not\models \varphi$ can 
be checked by looking at a finite prefix of $\mathsf{z}$.

Thus, reasoning about safety properties on infinite behaviors can be reduced to reasoning
about their finite prefixes.
First, we recall nondeterministic finite automata as acceptors of languages over finite words.
A \emph{nondeterministic finite automaton (NFA)} is a 5-tuple 
$A$ = $(Q$, $Q_0$, $\Sigma$, $\delta$, $F)$,
where $Q$ is a finite set of states, $Q_0 \subseteq Q$ is a set of initial states, $F \subseteq Q$
is a set of final states, $\Sigma$ is an alphabet, and $\delta \subseteq Q \times \Sigma \times Q$ is a set of transitions.
An NFA is \emph{deterministic}, written DFA, if $|Q_0|\ =\ 1$ and $\delta$ defines a total function
from $Q \times \Sigma$ into $Q$. 
The unique successor of a state $q\in Q$ under the letter $\sigma\in \Sigma$ 
in a deterministic automaton is denoted by $\delta (q,\sigma)$. A {\em run} of an NFA on a word $\sigma \equiv \sigma_0\ldots\sigma_{n-1}\in\Sigma^*$
is a sequence $q_0 \xrightarrow{\sigma_0} q_1 \ldots q_{n-1} \xrightarrow{\sigma_{n-1}} q_n$ such that $q_0\in Q_0$ and
for each $0\leq i\leq n-1$ we have $(q_i,\sigma_i, q_{i+1})\in\delta$.
A run is accepting if moreover $q_n \in F$, and we say the NFA accepts $\sigma$.
The language of an NFA is the set of all words $\sigma\in \Sigma^*$ such that the NFA has an accepting run on $\sigma$.


The set of \emph{bad prefixes} for a safety formula $\varphi$ is defined by:
$$Bad(\varphi) = \{\mathsf{z} \in (2^{\mathcal{P}})^{*} \mid \forall \mathsf{w} \in (2^{\mathcal{P}})^{\omega}\,\,  \mathsf{z}.\mathsf{w} \not\models \varphi\}.$$
That is, a (finite) prefix $\mathsf{z}$ is bad if none of its infinite extensions $\mathsf{z}\cdot\mathsf{w}$ 
satisfies the formula $\varphi$.
The set of fine prefixes is the set of finite prefixes that are sufficient to prove that the computation is unsafe.
We say that a set $Z \subseteq Bad(\varphi)$ is a \emph{trap} for the safety language $L(\varphi)$ iff
every word $\w \notin L(\varphi)$ has at least one prefix $\z \in Z$.  
We denote all the traps for $L(\varphi)$ by $trap(L(\varphi))$.

We say that a nondeterministic automaton $N_{\psi}$ is \emph{fine} for $\psi$ iff 
there exists $Z \in trap(L(\psi))$ such that $L(N_{\psi}) = Z$.
Thus, a fine automaton $N_{\psi}$ may not accept all the bad prefixes, however
it should accept at least one bad prefix of every computation that does not satisfy $\psi$.


Kupferman and Vardi \cite{KV01,KupfermanL06} show that an automaton fine for $\varphi$ can
be constructed from $\varphi$.
The translation is based on the \emph{reverse deterministic} automaton defined 
in~\cite{VardiW94}. 
In \tool~we implemented the version of Kupferman and Vardi's algorithm reported in~\cite{Lat03} and 
presented here as Algorithm~\ref{algo:fine}. 
This algorithm computes $N_{\varphi}$ from a safe-LTL formula $\varphi$. 
It first computes the set of subformulas $cl$ of $\lnot \varphi$ by the procedure
\emph{computeClosure}.
Since each state of the automaton represent whether each of the subformulas is either 
true or false in that state, the fine automaton can have at most $2^{|cl|}$ states.

\begin{proposition}
For every safe-LTL formula $\varphi$, Algorithm~\ref{algo:fine} constructs a
nondeterministic fine automaton for $\varphi$ with at most $2^{|\varphi|}$ states. 
\end{proposition}





\begin{algorithm}[t]
\begin{algorithmic}
\begin{tabbing}
\= $\psi'\ :=\ NNF(\neg\psi)$; $cl\ :=\ computeClosure(\psi')$\\
\> $F := \{\emptyset\}$, $Q := \{\emptyset\}$; $X := \{\emptyset\}$, $Q_0 := \{\}, \delta = \{\}$\\ 
\> {\bf while} $X \neq \emptyset$ {\bf do}\\
\> \quad $s := Dequeue(X)$\\
\> \quad {\bf foreach} $\sigma \in \Sigma$\\
\> \quad \quad $s' = \{\}$\\
\> \quad \quad {\bf foreach} $\phi \in cl$ {\bf do}\\
\> \quad \quad \quad {\bf switch} $\phi$ {\bf begin}\\
\> \quad \quad \quad \quad {\bf case} $p = q$ or $p = \lnot q$ for $q \in Y$:\\
\> \quad \quad \quad \quad if $p$ is satisfied by $\sigma$, then $s' := s' \cup \{p\}$\\
\> \quad \quad \quad \quad {\bf case} $\phi = \phi_1 \lor \phi_2$ :\\
\> \quad \quad \quad \quad if $\phi_1 \in s'$ or $\phi_2 \in s'$ then $s' := s' \cup \{\phi\}$\\
\> \quad \quad \quad \quad {\bf case} $\phi = \phi_1 \land \phi_2$ :\\
\> \quad \quad \quad \quad if $\phi_1 \in s'$ and $\phi_2 \in s'$ then $s' := s' \cup \{\phi\}$\\
\> \quad \quad \quad \quad {\bf case} $\phi = \bigcirc \phi_1$ :\\
\> \quad \quad \quad \quad if $\phi_1 \in s$ then $s' := s' \cup \{\phi\}$\\
\> \quad \quad \quad \quad {\bf case} $\phi = \phi_1 \U \phi_2$ :\\
\> \quad \quad \quad \quad if $\phi_2 \in s'$ or ($\phi_1 \in s'$ and $\phi \in s$)\\
\> \quad \quad \quad \quad then $s' := s' \cup \{\phi\}$\\
\> \quad \quad \quad {\bf end switch}\\
\> \quad \quad {\bf end for}\\
\> \quad \quad {\bf if} $\lnot\varphi \in s'$ {\bf then} $Q_0 := Q_0 \cup \{s'\}$\\
\> \quad \quad $\delta := \delta \cup \{(s', \sigma, s)\}$\\
\> \quad \quad $X := X \cup \{s'\}$, $Q := Q \cup \{s'\}$\\
\> \quad {\bf end for}\\
\> {\bf end while}\\
\> {\bf return} $A^{Fine}_{\lnot \varphi} = (Q,Q_0,2^{\mathcal{P}},\delta,F)$
\end{tabbing}
\end{algorithmic}
\caption{
{\bf ConstructFineAutomaton($\psi$)}\label{algo:fine}}
\end{algorithm}


\section{Controller Synthesis}


In this section, we assume that we have already computed a finite
abstraction, 
in the form of a system $S$, of the physical components.
\tool~accepts a pair of specifications $(\varphi_S,\varphi_L)$: the
first, $\varphi_S$, is a safe-LTL
formula that specifies the safety requirements of the system, and
the second, $\varphi_L$, is a guarantee formula of the form $\Diamond p$ that
specifies that the goal $p$ is eventually reached.
We perform controller synthesis in two steps.
First, we compute the maximal winning strategy for player~0 for the
safe-LTL part of the specification.
Second, we compute a controller that ensures the guarantee property
using a strategy compatible with the maximal strategy.

\subsection{Controller Synthesis for Safe-LTL}

For synthesizing a controller for a safe-LTL formula $\varphi$, we construct a
deterministic automaton on finite words that is fine for $\varphi$.
Note that Algorithm~\ref{algo:fine} may produce an NFA.
However, determinization for NFAs over finite words uses the (easier
to implement) subset construction.



Theoretically, the determinization step adds one more exponential,
making the complexity of the construction doubly exponential in the
size of $\varphi$.
In our practical examples, this double exponential behavior has not
shown up.
For example, given the fine automaton for $p\, \mathsf{W}\, q$, the subset construction
creates the deterministic automaton Figure~\ref{fig:pwqdet}.

Given a system $S = (X, X_0, U, \rTo, Y, H)$ and a DFA $D_{\varphi} =
(Q, q_0, Y, \delta, F)$ fine for $\varphi$, we
define the \emph{synchronous product} $S\times D_{\varphi} =
(X',X'_0,U',\rTo', Y', H')$ where
\begin{itemize}
 \item $X' = X \times Q$;
 \item $X'_0 = \{(x,q) \mid x \in X_0, q = \delta(q_0,H(x))\} $;
\item  $U' = U$;
\item  $(x,q)\to'^u (x',q')$ if $x \to^u x' $ and $\delta(q,H(x')) = q'$;
\item $Y' = Y$;
\item  $H'((x,q)) = H(x)$ for each $(x,q) \in X'$.
\end{itemize}
A controller enforcing $\varphi$ on $S$ can be constructed by synthesizing a controller
on the synchronus product $S\times D_{\varphi}$ enforcing the
specification that the system always remains in the states 
$X \times (Q\setminus F)$, i.e., that player~0 ensures that no word in the
language of $D_{\varphi}$ is seen.
This is a safety game where player~0 keeps the states into an
invariant set ($X\times (Q\setminus F)$), and can be solved using
existing methods by iterating a symbolic controllable-predecessor operator
\cite{Zielonka98,MazoDT10}.
Moreover, it is well-known that player~0 has memoryless maximal
winning strategies in this game.




\begin{theorem}\label{th:fine}
Let $S =  (X,X_0,U,\rTo,Y,$ $H)$ be system and let $D_{\varphi} = (Q,Q_0,Y, \delta,F)$ 
be a deterministic finite automaton fine for the safe-LTL formula $\varphi$.
For any initial state $x\in X_0$, player 0
has a winning strategy for the safe-LTL formula $\varphi$, if
player 0 has a memoryless winning strategy from the unique $x_0 \in X'_0$ to stay in $X
\times (Q\setminus F)$ states in system $S\times D_{\varphi}$.
Moreover, player~0 has a maximal winning strategy in $S\times D_\varphi$.
\end{theorem}



Thus, the algorithm to construct a maximal memoryless controller for a
system $S$ and a 
safe-LTL property $\varphi$ proceeds as follows.
First, we construct an NFA $N_\varphi$ fine for $\varphi$.
Second, we use the subset construction to determinize $N_\varphi$ into
a DFA $D_\varphi$.
Third, we construct the synchronous product of $S$ with $D_\varphi$.
Finally, we solve the safety game on $S\times D_\varphi$ for the
winning set $X\times (Q\setminus F)$ and construct a maximal
memoryless winning strategy.

\subsection{Controller Synthesis for the Guarantee Part}

Let $S\times D_\varphi = (X, X_0, U, \rTo, Y, H) $ be the synchronous product of a system and a
DFA fine for the safe-LTL $\varphi$, and let $\pi$ be a maximal
memoryless winning strategy for player~0 which ensures that all runs of the
system stay in the states $X\times (Q\setminus F)$.

We define the restriction of $S\times D_\varphi$ modulo $\pi$ to be
the system $(X,X_0, U, \rTo', Y, H)$ where $x\rTo'^{u} x'$ if
$x\rTo^{u} x'$ and $u \in \pi(x)$.
That is, we restrict the actions available at a state to only those
allowed by the maximal strategy $\pi$.

We now consider constructing a controller for the guarantee part
$\Diamond p$.
We solve this by constructing a winning strategy in the reachability
game on the product $S\times D_\varphi$ modulo $\pi$, the maximal
memoryless winning strategy for the safety game.
Again, the solution to the reachability game is constructed by
iterating a symbolic controllable predecessor operator
\cite{Zielonka98,MazoDT10}.

The resulting strategy ensures that the guarantee part $\Diamond p$ is
enforced by player~0 (by construction in the reachability game), 
while always maintaining the safety part (by ensuring that the
strategy is compatible with $\pi$).
Together, the controller enforces the specification $\varphi_S \wedge \varphi_L$.




While the current implementation of \tool~only handles guarantee
properties of the form $\Diamond p$ (or some syntactic sugar, e.g.,
properties of the form $p_1 \U p_2$ using the identity $p_1 \U p_2
\equiv p_1\W p_2 \wedge \Diamond p_2$), notice that all we need is
that a deterministic generator for the liveness part of the
specification is efficiently computable.
For example, it is easy to extend the algorithm when the liveness part
of the specification is a B\"uchi requirements $\Box\Diamond p$, or
more generally, from the fragments described in \cite{AlurT04}.