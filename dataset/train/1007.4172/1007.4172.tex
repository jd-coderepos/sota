\documentclass[11pt,techReport]{eptcs}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{units}
\usepackage{extarrows}
\usepackage{xspace,color}
\usepackage{enumitem}
\usepackage{multirow}

\usepackage{tikz,pgf}
\usetikzlibrary{trees,arrows,automata,positioning,plotmarks,matrix}

\usepackage{local}



\newcommand{\U}[1]{
    \textcolor{red}{\bfseries\sffamily(#1)}
    \marginpar{\textcolor{red}{\bfseries\sffamily U}}
  }
\newcommand{\K}[1]{
    \textcolor{green}{\bfseries\sffamily(#1)}
    \marginpar{\textcolor{green}{\bfseries\sffamily K}}
  }



\title{Breaking Symmetries}
\author{Kirstin Peters
\institute{Technische Universit\"at Berlin, Germany}
\email{kirstin.peters@tu-berlin.de}
\and
Uwe Nestmann
\institute{Technische Universit\"at Berlin, Germany}
\email{uwe.nestmann@tu-berlin.de}
}
\def\titlerunning{Breaking Symmetries}
\def\authorrunning{K.\ Peters, U.\ Nestmann}




\begin{document}
\maketitle

\begin{abstract}
A well-known result by Palamidessi tells us that \pimix (the -calculus with mixed choice) is more expressive than \pisep (its subset with only separate choice).  The proof of this result argues with their different expressive power concerning leader election in symmetric networks.  Later on, Gorla offered an arguably simpler proof that, instead of leader election in symmetric networks, employed the reducibility of ``incestual'' processes (mixed choices that include both enabled senders and receivers for the same channel) when running two copies in parallel.  In both proofs, the role of \emph{breaking (initial) symmetries} is more or less apparent.  In this paper, we shed more light on this role by re-proving the above result|based on a proper formalization of what it means to break symmetries|without referring to another layer of the distinguishing problem domain of leader election.

Both Palamidessi and Gorla rephrased their results by stating that there is no uniform and reasonable encoding from \pimix into \pisep.  We indicate how the respective proofs can be adapted and exhibit the consequences of varying notions of uniformity and reasonableness.  In each case, the ability to break initial symmetries turns out to be essential.
\end{abstract}

\section{Introduction}

Palamidessi's well-known result~\cite{palamidessi03} tells us that \pimix (the -calculus with mixed choice) is more expressive than \pisep (its subset with only separate choice).
More technically, the result states that there exists no ``good''---i.e., uniform (structure-preserving) and reasonable (semantics-preserving)---encoding from~\pimix into~\pisep.  Nestmann~\cite{nestmann00} proved that there is a "good" encoding from \pisep to \piasyn (the choice-free asynchronous subset of the -calculus).  He also exhibited various encodings from  \pimix to \pisep, which were not considered ``good'' by Palamidessi, as they were not uniform or reasonable enough.



Palamidessi's proof \cite{palamidessi03} argues with the different expressive power of the involved calculi concerning leader election in symmetric networks.  More precisely, Palamidessi proves that there is no symmetric network in \pisep that solves leader election, whereas there are such networks in \pimix. The proof implicitly uses the fact that it is not possible in \pisep to break initial symmetries, while this is possible in \pimix.  To this end, a rather strong notion of symmetry consisting of a syntactic and a semantic component is used to ensure that solving leader election requires breaking initial symmetries. With this result, inspired by Boug{\'e}'s work \cite{bouge88} in the context of \csp, Palamidessi proves that there is no uniform and reasonable encoding from \pimix into \pisep.

Later on, Gorla \cite{gorla08d} offered an arguably simpler proof for the non-existence of a ``good'' encoding from \pimix into \pisep. Instead of leader election in symmetric networks, it employed the reducibility of ``incestual'' processes (mixed choices that include both enabled senders and receivers for the same channel) when running two copies in parallel. Gorla's proof does not explicitly use a notion of symmetry.

Palamidessi's proof that there are no symmetric networks in \pisep that solve leader election addresses the \emph{absolute} expressive power of \pisep, whereas the proofs of the non-existence of a uniform encoding by Palamidessi and Gorla address the often-called \emph{relative} expressive power of the languages \cite{parrow08}. In the following, we discuss these two approaches in more detail, as this allows us to clarify the role of symmetry-breaking in the respective proofs.

The \emph{absolute expressive power} of a language describes what kind of behaviour or operations on behaviour are expressible in it (see \cite{parrow08,gorla08, gorla08d}). Analysing the absolute expressive power of a language usually consists of analysing which ``problems'' can be solved in it and which can not.  
It is often difficult to identify a suitable problem instance or problem domain to properly measure the expressive power of a language.  For instance, one might consider Turing-completeness to measure the computational power of a language.  In fact, Turing-completeness has been used in the context of process algebras, e.g., for Linda~\cite{busi00:_expres_of_linda_coord_primit}.   Instead, Palamidessi, inspired by Boug{\'e}~\cite{bouge88}, uses the distributed coordination problem of leader election.
More precisely, the problem refers to initially symmetric networks, where all potential leaders have equal chances and all processes run the same|read: symmetric|code.  There, to solve the leader election problem, it is required that in all possible executions a leader is elected.  Usually, it is argued that it is necessary|again in all possible executions|to break the initial symmetry in order to do so.  On the other hand, if there is just a single execution in which the symmetry is somehow perpetually maintained or at least restored, then also leader election may fail, and thus the leader election problem is not solved.
One may conclude that, at a closer look, Palamidessi's proof implicitly addresses another problem: the problem of breaking initial symmetries.  
Therefore, we suggest to promote ``breaking symmetries'' from a mere auxiliary proof technique to a proper problem of its own.  It turns out that, by doing so, we can significantly weaken the defintion of symmetry and at the same time provide a stronger proof applicable to problem instances different from leader election.

Now, to \emph{compare} the absolute expressive power of \emph{two} languages, we may simply choose a problem that can be solved in one language, but not in the other language.  
Actually, as soon as we compare two languages, it makes sense to use the term \emph{relative expressive power}, as we can now relate the two languages.  Unfortunately, the terminology was introduced differently.
It has been attributed (see~\cite{parrow08}) to the comparison of the expressive power of two languages by means of the existence or non-existence of encodings from one language into the other language, subject to various conditions on the encoding.\footnote{In our opinion, the denotation "relative expressive power" is misleading.  First, as mentioned above, also the absolute expressive power can directly be used to \emph{relate} two languages.  Second, results on the encodability of a language have to be understood relative to the specific conditions on the encoding---it is not always clear to what aspect the "relative" refers. Thus, in this paper, we prefer the notion of \emph{translational expressive power} to refer to comparisons of the expressiveness of two languages by analysing the existence or non-existence of an encoding, subject to various conditions.}
Both Palamidessi and Gorla state results of this kind; they prove that there is no uniform and reasonable encoding from \pimix into \pisep, for varying interpretations of the conditions uniform and reasonable.  

In this paper, we show that the problem of breaking inital symmetries, compared to the problem of leader election, appears to be a more suitable problem instance to separate \pimix from \pisep. There are two great benefits in proving an absolute separation result instead of a translational one. First, in opposite to translational separation results which are always equipped with the conditions on the encoding, we can formulate a separation result without any pre- or side conditions.  Second, as we show in Section \ref{sec:nonExistUniformEncoding}, we can prove several translational separation results due to different definitions of reasonableness as simple consequences of our absolute separation result.
For our work, we had to develop answers to two related questions of definition:
\begin{itemize}
\item How exactly should one define \emph{symmetric} networks?
\item What exactly does it mean to \emph{break symmetries}?
\end{itemize}
\emph{The main contributions of this paper} are then as follows.
(1)~We present a separation result between \pimix and \pisep that does not require any additional preconditions.  In particular, it is completely independent of what it means for an encoding to be "good" or "reasonable". 
(2)~Since we use a weaker notion of symmetry, and because we do not focus on the leader election problem, our separation result is more general than the one in \cite{palamidessi03}, i.e., it widens the gap between \pimix and \pisep.  It also allows us to derive a number of translational separation results using counterexamples different from leader election.
(3)~We prove a stronger translational separation result in comparison to \cite{palamidessi03, vigliottiPhillipsPalamidessi07} and (the first setting of) \cite{gorla08d} by weakening the conditions on the encodings used.


\paragraph{Overview of the Paper.}

In \S\ref{sec:techn-prel}, we introduce the two process calculi that we intend to compare. In \S\ref{sec:SemanticVsSyntactic}, we revisit the notion of symmetry used by Palamidesi to propose her separation result and define symmetry as we  use it. In \S\ref{sec:breakingSymmetry}, we prove the separation result, i.e., we prove that \pimix is strictly more expressive as \pisep, by proving the inability of \pisep to break initial symmetries. Based on this result, we prove in \S\ref{sec:nonExistUniformEncoding} that there is no uniform and reasonable encoding from \pimix to \pisep examining different notions of reasonableness. We conclude with \S\ref{sec:conclusion}.




\section{Technical Preliminaries} \label{sec:techn-prel}

In the following, let  denote a countable set of names. As is common nowadays, we present the -calculus including mixed guarded choice, but without match or mismatch operator \cite{sangiorgiWalker01, palamidessi03}.

\definition{def:fullPiCalculus}{-calculus}{
	The processes of the \textit{-calculus}, denoted by , are given by
	
}
\noindent
Note that the process term  represents \emph{finite} guarded choice; as usual, the term  denotes binary choice,  and we use  as abbrevation for the empty sum.

In the -calculus with separate choice, both output and input can be used as guards, but within a choice term either there are no input or no output guards, i.e., we have input and output guarded choice, but no mixed choice.
\definition{def:PiCalculusWithSeparateChoice}{-calculus with separate choice}{
	The processes of the \textit{-calculus with separate choice}, denoted by \procsep, are given by
	
}
We use  to range over names and capital letters  to range over processes. We often omit  in longer terms. If we refer to processes without further requirements we mean elements of \procmix; we sometimes use just  when the discussion applies to both.

Let  denote the set of visible actions, where  denotes \emph{free input},  denotes \emph{free output} and  denotes \emph{bound output}. Let  denote an internal not visible action. Let  be the corresponding set of \emph{labels}, i.e., . We use  to range over labels. Let  and   denote the sets of \emph{free names} in  and , respectively. Let  and  denote the sets of \emph{bound names} in  and , respectively. Likewise,   and  denote the sets of all \emph{names} occurring in  and . Their definitions are completely standard. We assume that there are no clashes between free and bound names in terms, i.e., in any term the set of bound and free names are disjoint.

The operational semantics of \procmix and \procsep are jointly given by the transition rules in Figure \ref{fig:operationalSemantics}, where congruence  is defined (according to \cite{palamidessi03}) by the following rules:
\begin{enumerate}
	\item  if  can be obtained from  by alpha-conversion
	\item  if 
	\item 
\end{enumerate}
\begin{figure}[ht]
	
	\caption{Operational semantics} \label{fig:operationalSemantics}
\end{figure}

As usual, the tuple notation  denotes finite sequences  of names in , i.e.,  denotes the set of tuples over a set . Moreover, we use  for a sequence  to abbrevate  and  for a set of names  to denote the sequence of names  without the occurrences of name  for all . We also use the tuple notation for other kinds of data, like actions or labels.

A \emph{network} is a process  for some ,  and . We refer to  as the processes of the network.

We use , , , \ldots to range over substitutions. A substitution is a set  of rules to rename free names of a term.  is defined as the result of replacing all occurences of  by  for , possibly applying alpha-conversion to avoid capture or name clashes. For all names  the substitution behaves as identity function. Let  denote identity, i.e.,  is the empty substitution .

As usual,  denotes a step from  to , where  is either a label of an action or . Moreover let  () denote existence (non-existence) of a step from , i.e., there is (no)  and (no)  such that . A (partial) execution is a sequence of steps  such that  for some  with the sequence  of observable and unobservable actions, i.e., . Accordingly  denotes a finite execution from  to  with the sequence of actions .




\section{Semantic versus Syntactic Symmetry} \label{sec:SemanticVsSyntactic}

Palamidessi in \cite{palamidessi03} proved that \pimix is strictly more expressive than \pisep by proving that the former can solve leader election in symmetric networks while the latter can not. The leader election problem consists of choosing a leader among the processes of a network. In \cite{palamidessi03}, a special channel  is assumed to propagate the index of the winning process, i.e., the leader. The leader election problem is solved by a network iff in each of its executions each process propagates the same process index over  and no other index is propagated.

As already Boug\'{e} did for \csp in \cite{bouge88}, Palamidessi uses a \emph{semantic} definition of symmetry.  Intuitively, the \emph{syntactic component} of the symmetry definition in \cite{bouge88, palamidessi03, vigliottiPhillipsPalamidessi07} states two processes as symmetric iff they are identical modulo some renaming according to a permutation  on their free names. Boug\'{e} \cite{bouge88} argues why a syntactic notion of symmetry does not suffice considering the leader election problem to distinguish \cspmix, i.e., \csp where input and output commands may appear in guards, and \cspin, i.e., \csp where only input commands may appear in guards. He presents two networks in \cspin each solving leader election although each should be considered as syntactically symmetric. The following example presents such a syntactically symmetric network solving leader election in \pisep:

 is syntactically symmetric with respect to the permutation , i.e.,  and  is equal to  modulo the exchange of  and  according to . Moreover  solves the leader election problem.

To overcome these problems the \emph{semantic component} of the symmetry definition is designed to be strongly connected to the problem considered, i.e., leader election in this case. Intuitively, its purpose is to ensure that the only way to solve the leader election problem is to break the initial symmetry of the given network. Note that  does \emph{not} break the initial syntactic symmetry, because e.g. in the execution  each second step results in a network that is syntactically symmetric with respect to .  So, without this semantic part in the definition of symmetry, the leader election problem can not be used to distinguish \pimix and \pisep (or \cspmix and \cspin).

\paragraph{Semantic symmetry.}
\label{sec:semantic-symmetry}

We revisit Palamidessi's notion of symmetry for the -calculus as of \cite{palamidessi03}. Note that the involved definitions are based on the ones introduced by Boug\'{e} in \cite{bouge88} for \csp.

According to \cite{palamidessi03}, a hypergraph is a tuple , where  and  are finite sets whose elements are called nodes and edges and , called type, is a function assigning to each edge the set of nodes connected by this edge. An automorphism on a hypergraph is a pair  such that  and  are permutations which preserve the type of edges. Given a hypergraph  and  on  the orbit of a name  is the set of nodes in which the iterations of  map .

A network  of  processes solves the leader election problem if for every computation of  there exists an extension of the computation and there exists an index  such that for each process the extended computation contains one output action of the form  and no other action  with . The hypergraph associated to a network  is the hypergraph  with , , and for each , . Given a network  and the hypergraph  associated to  an automorphism on  is any automorphism  on  such that  coincides with  on  and  preserves the distinction between free and bound names.

A network  with the associated hypergraph  and an automorphism  on  is symmetric with respect to  iff for each node , \footnote{In \cite{bouge88} and \cite{vigliottiPhillipsPalamidessi07} formally slightly different conditions but with the same effect are used.}, holds where  denotes equality modulo alpha conversion.

To distinguish \pimix and \pisep Palamidessi shows that a network  which is symmetric with respect to an automorphism  on  with only one orbit can not solve the leader election problem while this is possible in \pimix.

The main point of the semantic component of symmetry is that the special channel  can not be renamed by  while the indices of the processes of the network must be permuted by .  With that, the network  in (\ref{exm:symSolLE}) above is \emph{not} symmetric according to \cite{palamidessi03}.  This allows Palamidessi to prove that for each execution of a network in \procsep, which is symmetric with respect to an automorphism , whenever there is an output  there is an output  with  as well, which contradicts the leader election problem. This explains why in \cite{bouge88, palamidessi03, vigliottiPhillipsPalamidessi07} such an effort is spent to define symmetry.

Nevertheless it turns out that we do not need the leader election problem to distinguish \pimix and \pisep. The main argument in the proof of \cite{palamidessi03} that there is no symmetric network in \procsep solving leader election is that it is impossible in \pisep to break symmetries.

\paragraph{Syntactic symmetry.}

As mentioned in the introduction, we directly focus on the problem of breaking symmetries instead of concentrating on leader election. Thus, we can release most of the above conditions for symmetry. Moreover, we abandon the notion of hypergraphs and automorphisms. Instead, we use a simple syntactic definition of symmetry that, as mentioned above, states two processes as symmetric iff they are identical modulo some renaming according to a permutation  on their free names.

\definition{def:symmetryRelation}{Symmetry relation}{
	A \textit{symmetry relation of degree } is a permutation , such that .
	
	Let  denote the set of symmetry relations of degree  over  and let .
	
}
\noindent
Note that this definition does not require that  is the minimal degree of ; consequently, the condition that  is an automorphism with only one orbit is released. A symmetric network is then a network of  processes that are equal except for some renaming according to a symmetry relation .

\definition{def:symmetricNetwork}{Symmetric network}{
  Let . 
  Let sequence  contain only free names of .
  Let .
  Let  be a symmetry relation of degree  over .
  Let  be closed under .
  Then
  
  is a \textit{symmetric network of degree }.
}
\noindent
Note that, in the following proofs, we make use of the fact that names bound in  are bound in each other process of  as well, so we explicitly forbid alpha-conversion here. In the following, whenever we assume some symmetric network , we implicitly assume the respectively quantified parameters: a process , a sequence  containing only free names of , a network size , a symmetry relation  of degree  over .

The main difference of our definition to the definition of a symmetric network in \cite{palamidessi03} is that, in \cite{palamidessi03}, the processes of a symmetric network are numbered consecutively and for each process  within the symmetric network  holds.  Thus, each symmetric network in \cite{palamidessi03} is a symmetric network for our definition, but not vice versa. Our definition of symmetry is weaker.



We use an index-guided form of substitution to replace single processes within a symmetric network.

\definition{def:indexedSubstitution}{Indexed substitution}{Let  be a symmetric network. An \textit{indexed substitution} of some processes within a symmetric network, denoted by  for some processes  and  such that for all   implies , is the result of exchanging  in  by  for all .
}
\noindent
Obviously  is a network; in general, however, it is not symmetric with respect to .

\section{Symmetric Executions} \label{sec:breakingSymmetry}

We explicitly prove that in \pisep it is not possible to break initial symmetries, i.e., starting with a symmetric network there is always at least one execution preserving the symmetry. We  refer to such a execution as \emph{symmetric execution}. Let us consider a symmetric network  of degree . Of course, if only one process does a step on its own, then all the other processes of the network can mimic this step and thus restore symmetry. So, there is a symmetry preserving execution if there is no communication between the processes of the network. The most interesting case is how the symmetry is restored after a communication between two processes of the network has temporarily destroyed it. Both cases are reflected in the proof of Theorem \ref{thm:cannotBreakSymmetry}.

Apart from symmetric networks, we use the notion of a symmetric sequence of actions. Similarly to symmetric networks, in which a symmetry relation is applied to processes to derive symmetric processes, a symmetric sequence of actions is the result of applying a symmetry relation to action labels. It is sometimes necessary to translate a bound output to an according unbound output because a network can send a bound name several times but only the first of this outputs will be bound.

\definition{def:symmetricBehavior}{Symmetric sequence of actions}{
	Let  be an action label, let  be a sequence of names and  a symmetry relation of degree . Then  denotes the sequence  of  labels such that ,  and for :
	
	
	Sometimes we refer to  as the symmetric counterparts of .
}


Intuitively, a symmetric execution is an execution starting from a symmetric network returning to a symmetric network after any 'th step, and which is either infinite or terminates in a symmetric network. Thereby, each sequence of  steps is labeled by a symmetric sequence of actions. 


\definition{def:symmetricTrace}{Symmetric execution}{
	A \textit{symmetric execution} is either a finite execution of length 
	
	for some , ,  and  such that  or an infinite execution
	
	for some , ,  and  such that .
}
\noindent
Note that because of  the symmetry relation can only increase during a symmetric execution such that existing symmetries are preserved. Moreover|as shown in Lemma \ref{lem:cannotBreakSymmetry}|the symmetry relation does only grow in the presence of bound output to capture the renaming done by alpha-conversion. In the absence of bound output we have  and  respectively.

Palamidessi proved that \pisep enjoys a certain kind of \textit{confluence} property \cite{palamidessi03}. Let  denote an output action, i.e.,  is either a bound output  or an unbound output .
\lemma{lem:localConfluence}{
	Let  be a process. If  can make two steps  and  then there exists  such that  and .
}
\begin{proof}[Proof of Lemma \ref{lem:localConfluence}]
	See proof of Lemma 4.1 in \cite{palamidessi03} at pages 17 to 18.
\end{proof}

With this property we prove that it is not possible to break symmetries in \pisep.  Intuitively, we show that there is at least one symmetric execution by proving that whenever there is a step destroying symmetry we can restore it in  more steps mimicking the first step. The respective existence relies on the standard Lemma in process calculi like the -calculus that transitions are preserved under substitution.  As conclusion it is not possible in \pisep to break an initial symmetry in all executions.



\theorem{Symmetric Execution}{thm:cannotBreakSymmetry}{
  Every symmetric network in \procsep has at least one symmetric execution.
}
\begin{proof}[Proof of Theorem \ref{thm:cannotBreakSymmetry}]
	We first prove the following statement:
	\lemma{lem:cannotBreakSymmetry}{
		
	}
	Intuitively it states that given an arbitrary symmetric network  in \procsep, whenever  can perform a step then there are exactly  more steps that restore symmetry, i.e., that lead to a symmetric network again and the corresponding  steps are labeled by a sequence of symmetric actions. Note that the main line of argumentation of this Lemma is very similar to the proof of Theorem 4.2 in \cite{palamidessi03} at pages 18 to 23, although we prove a completly different statement. Nevertheless due to the different proof statements the proofs differ in technical details.

\begin{proof}[Proof of Lemma \ref{lem:cannotBreakSymmetry}]
	 can be the result of either an internal -step of one proccess of the network, i.e., it can be produced without the rules \textsc{Comm} or \textsc{Close}, or of a communication between two processes of the network, i.e., be produced by one of the rules \textsc{Comm} or \textsc{Close}. In the first case only one process performs a step and the rest of the network remains equal, i.e.:
	
	In the second case  and two processes of the network change, i.e.:
	
	We proceed with a case split.
	\begin{description}
		\item[Case (\ref{caseC1}):] Within the symmetric network  all processes  for  are equal except for some renaming of free names according to . That means whenever a process  can perform a step  then each other process  of the network can mimic this step by , where  is the result of applying  to  possibly by changing bound output to unbound output as described in Definition \ref{def:symmetricBehavior}.\footnote{Note that  is added in  and  just to ensure that both values are positive. Because  if  we have .} The case of a bound ouput action  is a little bit tricky so we consider the other cases first. If  is no bound output we can choose  such that . Moreover by symmetry  implies  for a . With it we can restore symmetry by mimicking the -step of process  by the  steps , \ldots, , , \ldots, . These  steps build the chain
			
			with  and . Because  after the last step we result in a network which is again symmetric with respect to , i.e., we choose . With that we can choose  such that . If  is an input or an unbound output action then so are its symmetric counterparts , so we can choose  and are done. Else if  is a bound output action  we have to consider two cases.
			\begin{description}
				\item[Case :] Then of course  and because  is a bound output  must be in . So we have to choose . Then by Definition \ref{def:symmetricBehavior} some of the actions  might be bound and some might be unbound outputs depending on whether  was already the subject of an earlier bound output of this sequence or not. If  of  was already the subject of an bound output within  then  is an unbound output and with it we choose , else  is a bound output and we choose  for all . Again we can choose  and  and proceed as in the case where  is no bound output.
				\item[Case :] Then by symmetry  is bound in  for all . By the above assumption that there are no name clashes we conclude . Then by Definition~\ref{def:symmetricBehavior}  is a sequence of  bound output actions. Each of these actions  changes the scope of  (in a symmetric way to the other processes) but the scope of the network is left unchanged. With it we can choose  again. The crux is that performing the first bound output with label  may force an alpha-conversion to avoid name clashes to the other bound instances of  in the other processes of the network such that the symmetry would be destroyed. To illustrate this problem let us consider an example first:
				\begin{description}
					\item[Example:] Let .  can perform two bound outputs . To avoid name capture we have to apply alpha-conversion such that we have . Because of this alpha-conversion we result in a network which is not symmetric with respect to . To overcome this problem we record the renaming done by alpha conversion in  such that . Note that because of this  can only increase by adding permutations on formerly bound names and fresh names.
				\end{description}
				That is why we have to increase the symmetry relation in this case to keep track of the renaming done by alpha-conversion. Thereto we enforce that the alpha-conversion after the first bound output to rename all instances of  (except to first) to a different fresh name for each process of the network and add the respective permutations of  to  in order to obtain  such that . Afterwards we can choose  such that  and  and proceed as in the case where  is no bound output.
			\end{description}
		\item[Case (\ref{caseC2}):] In this case there is a communication between  and  as result of one of the rules \textsc{Comm} or \textsc{Close}. Without loss of generality let us assume that  is the sender and  is the receiver of this communication, i.e., there are  such that  and . Because of symmetry each process  for  can perform an output action  (either bound or unbound) and an input action  such that  and . Because of local confluence (compare to Lemma \ref{lem:localConfluence}), i.e., without mixed-choice an output action can not block an alternatively input action (within one step) and vice versa\footnote{Indeed without mixed choice the only possibility for  to be able to perform both actions is that these two actions are composed in parallel, so  can perfom both actions in an arbitrary order and it is not possible that performing one of these actions alone prevents  form performing the other one next.}, as depicted in Figure \ref{fig:confluence} process  must be able to perform both actions consecutively in arbitrary order resulting in the same term which we denote by .
			\begin{figure}[ht]
				\begin{center}
					\begin{tikzpicture}[node distance=3.5cm, auto]
						\node (a)						{};
						\node (b) [below left of=a]		{};
						\node (c) [below right of=a]	{};
						\node (d) [below right of=b]	{};
						
						\path[->] (a) edge [swap]	node {}		(b);
						\path[->] (a) edge			node {}	(c);
						\path[->] (b) edge [swap]	node {}	(d);
						\path[->] (c) edge			node {}		(d);
					\end{tikzpicture}
				\end{center}
				\caption{Local confluence of receiving and sending actions.} \label{fig:confluence}
			\end{figure}
			To restore symmetry we build a chain of  steps such that each process  performs the output action  in step  and the input action  in step , i.e., each process is once a sender and once a receiver and  and with that . Again we consider the case of unbound outputs by first. Then we have  as first step with ,  and . Depending on the values of  and  some of the processes perform the corresponding input action first while others perform at first the corresponding output action. Because of Lemma \ref{lem:localConfluence} both is possible. We let each process perform exactly these two actions (compare to Figure \ref{fig:confluence}). We choose  and . We start with a symmetric network and all processes behave symmetricaly, i.e., each process mimic the behavoir of its neighbour, so we have  for all  with  such that can choose  and have
			
			
			Now we consider the case of bound outputs. Note that  and  peform a communication step \emph{within} the network, so if  performs a bound output  must be bound in , i.e., . By symmetry  is bound in  for all . With that either all output action are bound or all are unbound. In case of bound output we have , because first we have to apply alpha-conversion to rename the instance of  bound in  and then the bound output by  leads to a scope extrusion such that  and  is the renaming of  in . Again we  use alpha-conversion after the first communication step to rename all instances of  (except the first) to a different fresh name for each process of the network and add the respective permutations of  to  in order to obtain  such that . Let  denote the sequence of names used to rename  according to . We proceed as in the case of unbound outputs with the  communication steps as described above. Of course we have to replace the processes  by  and  by  for . After completing these  communication steps the names  are pulled outwards by scope extrusion, i.e. we have , where  and . With that we can choose  and are done.
	\end{description}
\end{proof}

	With Lemma \ref{lem:cannotBreakSymmetry}, we can now construct the symmetric execution. We start with an arbitrary symmetric network . If  we have a symmetric execution of length . Otherwise, if  can perform a step labeled by  by Lemma \ref{lem:cannotBreakSymmetry} we can perform  more steps such that . Now we can proceed alike with  and result either in a finite symmetric execution of length  or we have . By recursively repeating this argument, we either get a finite symmetric execution of length  or an infinite symmetric execution.
\end{proof}



\paragraph{Breaking Symmetries.}
\label{sec:breaking-symmetries}



Note that Theorem \ref{thm:cannotBreakSymmetry} does not state anything about encodability and it does not need a notion of reasonableness either. Instead, it just states without any precondition that every symmetric network in \procsep has at least one symmetric execution.  In contrast, there are symmetric networks in  without such a symmetric execution, as the following example shows. Consider the network

with , i.e.,  is a symmetric network in . It has, modulo structural congruence, exactly the two following executions 

and even none of them is symmetric; the initial symmetry is broken.  So Theorem \ref{thm:cannotBreakSymmetry} proves a difference in the absolute expressive power between \pisep and \pimix\footnote{Remember that \pisep is a subset of \pimix and with it \pimix is at least as expressive as \pisep.}.

\fact{fac:absolutExpressivness}{
	The full -calculus is strictly more expressive as the -calculus without mixed choice.
}

\section{Non-Existence of Uniform Encodings} \label{sec:nonExistUniformEncoding}

As done by Palamidessi \cite{palamidessi03} and also by Gorla \cite{gorla08d}, we now also prove that there is no uniform and reasonable encoding from \pimix into \pisep, but here using Theorem \ref{thm:cannotBreakSymmetry} which states a difference in the absolute expressive power of the two calculi.  It is no real surprise that this absolute result leads to differences in the translational expressiveness of the languages. Because uniform encodings preserve symmetries|or at least enough of the symmetric nature of the terms|, the non-existence of a uniform and reasonable encoding is a natural consequence of the difference in their absolute expressiveness. Unfortunately, there is no agreement on the minimal requirements of a reasonable encoding, so we can not formally prove this result in general, although we belive that it holds for any meaningful Definition of reasonableness. Instead to underpin our assertion we prove it in the settings of \cite{palamidessi03} and \cite{gorla08d}.

According to \cite{palamidessi03}, an encoding is uniform if it translates the parallel operator homomorphically and preserves renamings, i.e., for all permutations of names  there exists a permutation of names  such that . Vigliotti et al.~\cite{vigliottiPhillipsPalamidessi07} additionally require that the permutations  and  are compatible on observables. Gorla \cite{gorla08d} does not use the notion of uniformity, but in his first setting the separation result between \pimix and \pisep does also assume homomorphical translation of the parallel operator. Moreover, he specifies name invariance as a criteriaon for a good encoding, which is a more complex condition than  Palamidessi's second condition. It turns out that, in our setting, we do not need a second condition like renaming preservation or name invariance, because we base our counterexamples in the following separation results on symmetric networks of the form  as already Gorla did in \cite{gorla08d}.  For us, an encoding is uniform iff it translates the parallel operator homomorphically.

\definition{def:uniformEncoding}{Uniform encoding}{
	An encoding  from  into an other language is a \textit{uniform encoding} if and only if for all 
	
}





Actually, Theorem \ref{thm:cannotBreakSymmetry} should suffice to prove that there can not be a uniform and reasonable encoding from \pimix into \pisep, because uniform encodings preserve symmetries and it is possible to break symmetries in \pimix while this is not possible in \pisep. The crux is that there is no commonly accepted notion of reasonableness. For separation results, we seek a definition of reasonableness that is as weak as possible. But, without any notion of reasonableness, the theorem would not hold, because there are uniform encodings from \pimix into \pisep. For instance, we could simply translate everything to . Of course such an encoding makes no sense and so hardly anyone would call it reasonable. Usually, an encoding is called reasonable if it preserves some kind of behavior or the ability to solve some kind of problem so to ensure that the purpose of the original term is preserved.  In the following, we consider three different notions of reasonableness.

\paragraph{Version 1}

For Palamidessi, an encoding is reasonable if it preserves the relevant observables and termination properties \cite{palamidessi03}. Implicitly, she requires that a reasonable encoding should at least preserve the ability to solve leader election. We  do alike but with a different interpretation of what it means to solve leader election \ifadraft\footnote{\textcolor{red}{Fussnote nur einf√ºgen, wenn die Aussage in einem TechRep gezeigt wird?!} If we would like to prove the following separation result with the Definition of leader election of \cite{palamidessi03} we would need to strenghten our Definition of uniformity. More precisely we would have to require that a uniform encoding is name invariant as defined by Gorla in \cite{gorla08d}. Name invariance allows us to prove that the uniform encoding of an arbitrary symmetric network  is again a symmetric network  such that  iff  for all names , where  is a renaming policy as defined in \cite{gorla08d}. With that we can prove that each encoding of a symmetric network as e.g.  has at least one execution in which a decision on a leader  is directly followed by  with , contradicting leader election. Hence there is no uniform and reasonable encoding from \pimix into \pisep.}\fi that is more closely related to the definition used by Boug\'{e} \cite{bouge88}:
A network is said to solve leader election iff in each execution exactly one process propagates itself as leader while all the other processes propagate themselves as slaves. We assume the existence of two different predetermined output actions, one to propagate as leader and the other to propagate as slave. Moreover, we require that for both output actions neither the channel names nor the sent values are bound within the network\footnote{Note that if we allow bound names in these output actions, we could hardly predetermine them.}. The main difference to the definition of leader election used in \cite{palamidessi03} is that here the slaves do not have to know the identity, i.e., the index, of the leader. So, this definition is usually considered as a weaker notion of the leader election problem.  An encoding is now said to be reasonable iff it preserves the ability to solve the leader election problem.

\definition{def:Reasonableness1}{1-Reasonableness}{
	An encoding  is \textit{1-reasonable}, if  solves leader election if and only if  solves leader election for all .
}

To prove that there is no uniform and reasonable encoding we force our encoding to lead to a network of two processes that is symmetric with respect to identity. By Theorem \ref{thm:cannotBreakSymmetry}, this network has at least one symmetric execution. Because we use the identity as symmetry relation, in the symmetric execution both processes behave exactly the same such that if one of them propagates himself as leader then the other one does alike, which contradicts leader election.

\theorem{Separation Result}{thm:noUniformEncoding1}{
	There is no uniform and 1-reasonable encoding from \pimix into \pisep.
}
\begin{proof}[Proof of Theorem \ref{thm:noUniformEncoding1}]
	Let us assume the contrary, i.e., there is a uniform and 1-reasonable encoding  from \pimix into \pisep. Consider the network:
	
	Obviously  is a symmetry relation of degree  and so  is a symmetric network. Moreover  solves leader election, because the leader sends an empty message over channel  and all slaves send an empty message over channel . By Definition \ref{def:uniformEncoding} of uniformity, we have , i.e.,  is again a symmetric network of degree  with  as symmetry relation. By Theorem \ref{thm:cannotBreakSymmetry},  has at least one symmetric execution and by reasonableness  must solve leader election, i.e., there is exactly one process that propagates itself as leader by an output action. Let  denote this send action. By Definition \ref{def:symmetricTrace}, a symmetric execution has symmetric sequences of actions, i.e., the action  is coupled to its symmetric counterpart building the sequence  for some  and . By construction in the proof of Lemma \ref{lem:cannotBreakSymmetry}, and because we start with , we know that  consists of (permutations of) names that are bound in  or fresh. Because, by definition,  can neither contain fresh nor bound names, we conclude , i.e., the output action appears twice in the symmetric execution. With that two processes propagate themselves as leader, which is a contradiction.
\end{proof}


Note that, in contrast to the proof of Palamidessi \cite{palamidessi03,vigliottiPhillipsPalamidessi07}, we do not have to assume that the encoding is renaming preserving.






\paragraph{Version 2}

Here, we first introduce a technical lemma. Intuitively, it states that the symmetric execution of a symmetric network of degree , where  is \emph{not} the minimal degree of the corresponding symmetry relation, can be subdivided into symmetric executions on symmetric subnetworks of the original network.
\lemma{lem:subdividingSymmetricTraces}{
	Let  be a symmetric network in \procsep. If the degree of  is not minimal, i.e., if there is a  with  such that , then  has a finite or an infinite symmetric execution
	
	for a , ,  with ,  and  or some ,  with , some  and  respectively such that  has the finite or infinite symmetric execution
	
	for some ,  and  with  or some ,  and  with  respectively such that  is a subsequence of ,  is a subsequence of  and either  or if  is a bound output its unbound variant is in  for all  or  respectively.
}
\noindent 
Note that, like Theorem \ref{thm:cannotBreakSymmetry}, this result is absolute in the sense that it holds independently of any notion of uniformity or reasonableness. 


\begin{proof}[Proof of Lemma \ref{lem:subdividingSymmetricTraces}]
	Assume there is a  such that . Then because  there must be a  such that . Because  for each  we have . So  can be divided into  identical symmetric networks such that  and  can be divided in  identical sequences such that  for each  and each .
	
	If  has a symmetric execution of length , i.e., , then of course we have  as well and so  has a symmetric execution of length .
	
	Else we consider an arbitrary sequence of  steps  of the given symmetric execution for  in the case of a finite symmetric execution and  for an infinite symmetric execution. As constructed in Theorem \ref{thm:cannotBreakSymmetry}  is either the result of a step of  realized without the rules \textsc{Comm} and \textsc{Close} or it is the result of two communications of  and  realized by one of the rules \textsc{Comm} or \textsc{Close}. We proceed with a cases split.
	\begin{description}
		\item[Case without \textsc{Comm} and \textsc{Close}:] Let  with  be the process which performs the first of the  steps labeled . We choose  as the 'th action in , i.e., we choose the label of the action performed by process . If  is a bound output and  is not then we choose the bound ouput variant of . By construction in the proof of Lemma \ref{lem:cannotBreakSymmetry} there are  steps performed by the processes , \ldots,  and labeled by the first  labels of . Note that because  differs from  only on permutations on formerly bound names we can perform these steps by , \ldots, , too. If  is no bound output we can choose  and  and are done. Else if  and  we can choose  and  as the sequence of names in , where  are the values of the bound outputs in . Else if  we can choose  and we add the permutations of  done by alpha conversion as descriebed in Lemma \ref{lem:cannotBreakSymmetry} to  to obtain . Again by construction in Lemma \ref{lem:cannotBreakSymmetry} performing these  steps steps we have .
		\item[Case with \textsc{Comm} or \textsc{Close}:] Then  is a sequence of  times . We choose  and  is a sequence of  times . Let  and  with  be the processes which perform the first of the  steps. Without lost of generality let  be the sender and  be the receiver, i.e.,  performs an output action  and  performs the complemtary receiving action . By construction in the proof of therorem \ref{thm:cannotBreakSymmetry} the first  steps within  are performed by the senders , \ldots,  in this order sending  respectively and by the receivers , \ldots,  in this order receiving . Now because of  and  differs from  only by formerly bound names and their renamings according to alph-conversion for each  and for each \linebreak  we have  and , and  and  respectively are equal modulo the renaming performed by formerly alpha-conversion. With that we can again close the cycle as in the proof of Lemma \ref{lem:cannotBreakSymmetry} leading to , where  and  are obtained from  and  as descriebed in Lemma \ref{lem:cannotBreakSymmetry}.
	\end{description}
	Because we can subdivide an arbitrary sequence of  steps we can subdivide each such sequence in the symmetric execution and with it the symmetric execution.
\end{proof}

Gorla \cite{gorla08d} defines the reasonableness of an encoding by the properties operational correspondence, divergence reflection and success sensitiveness. We use just the last of his properties instantiated with must testing. So we implicitly require divergence reflection. According to \cite{gorla08d}, success is represented by a process  that is part of the source and the target language of the encoding and always appears unbound. More precisely, a process must-succeeds if it \emph{always} reduces to a proccess containing a top-level unguarded occurence of . The fact that  must-succeeds is denoted by . With it, an encoding is reasonable if the encoding of a term must-succeeds iff the term itself must-succeeds.

\definition{def:Reasonableness2}{2-Reasonableness}{
	An encoding  is \textit{2-reasonable}, if  iff  for all .
}

Again, we choose a term such that the encoding results in a network of the form  in \procsep that is symmetric with respect to the identity. In this case, we take advantage of the fact that the minimal degree of  is less than the degree of the network such that we can use Lemma \ref{lem:subdividingSymmetricTraces} to subdivide the symmetric execution. With it already  can perform the same sequence of steps as each process in  performs in the symmetric execution.

\theorem{Separation Result}{thm:noUniformEncoding2}{
	There is no uniform and 2-reasonable encoding from \pimix into \pisep.
}
\begin{proof}[Proof of Theorem \ref{thm:noUniformEncoding2}]
	Let us assume the contrary, i.e., there is a uniform and 2-reasonable encoding  from \pimix into \pisep. Consider the network:
	
	Obviously,  is a symmetry relation of degree  and so  is a symmetric network. Moreover, we have  but . We have , i.e.,  is again a symmetric network of degree  with  as symmetry relation. By Theorem \ref{thm:cannotBreakSymmetry},  has at least one symmetric execution and by success sensitiveness and must testing  must reduce to a proccess containing a top-level unguarded occurence of  within this symmetric execution, i.e., there is a sequence of actions , a process , a  and a sequence of names  such that  and  or  contain a top-level unguarded occurence of . Then, by symmetry, both processes of  contain a top-level unguarded occurence of . By Lemma \ref{lem:subdividingSymmetricTraces}, there is a sequence of actions  and an execution  for a subsequence  of . With it, , and with success sensitiveness , which is a contradiction.
\end{proof}

Note that, reconsidering the proofs of this separation result in \cite{gorla08d}, we managed to omit one of Gorla's additional assumptions\footnote{Namely, we do not need the assumption that  is exact (first setting in \cite{gorla08d}) or reduction sensitive (second setting in \cite{gorla08d}) and we do not need to assume the stronger version of operational correspondence in the third setting in \cite{gorla08d}. On the other side Gorla does not need to assume homomorphical translation of  in his second and third setting. He uses the weaker notion of compositional translation of  instead.}. Moreover, note that because we focus on breaking symmetries instead of leader election, we can apply Theorem \ref{thm:cannotBreakSymmetry} to problem instances different from leader election.



\paragraph{Version 3}

In his proofs of this separation result in \cite{gorla08d} Gorla uses may testing to show that there are terms  such that ,  and , but there are no such terms in \procsep. Implicitly, he uses the fact that  and  implies  and that there are no terms  in \procsep such that  and . By proving this fact directly, we do not need any notion of testing to prove the separation result.

\definition{def:Reasonableness3}{3-Reasonableness}{
	An encoding  is \textit{3-reasonable} if  if and only if  for all .
}

As far as we know, only few intuitively reasonable encodings are not also 3-reasonable.

Again, for the separation proof, we enforce that the encoding results in a symmetric network . By subdividing the symmetric execution of this network, we prove that  iff , which does not necessarily hold in \pimix.

\theorem{Separation Result}{thm:noUniformEncoding3}{
	There is no uniform and 3-reasonable encoding from \pimix into \pisep.
}
\begin{proof}[Proof of Theorem \ref{thm:noUniformEncoding3}]
	Let us assume the contrary, i.e., there is a uniform and 3-reasonable encoding  from \pimix into \pisep. Consider the network:
	
	Obviously,  is a symmetry relation of degree  and so  is a symmetric network. Moreover, we have  but . We have , i.e.,  is again a symmetric network of degree  with  as symmetry relation. By Theorem \ref{thm:cannotBreakSymmetry}  has at least one symmetric execution and by 3-reasonableness we have  and . By Lemma \ref{lem:cannotBreakSymmetry},  implies that there is at least one step in the symmetric execution, i.e., there is a , a process , a  and a sequence of names  such that . By Lemma \ref{lem:subdividingSymmetricTraces}, there is a execution  for a subsequence  of , , which is a contradiction.
\end{proof}

Note that in opposite to both Palamidessi and Gorla we do not even assume divergence reflection.








\section{Conclusion and Future Work} \label{sec:conclusion}

We prove that \pimix is strictly more expressive than \pisep by means of an absolute separation result about the ability to break initial symmetries. This result is inpendent of any notion of encodibility, uniformity and reasonableness. By choosing the problem of breaking initial symmetries instead of leader election, we may significantly weaken the underlying definition of symmetry in comparison to \cite{palamidessi03}.  Moreover, we could still apply our absolute separation result to derive that there is no uniform and reasonable encoding from \pimix into \pisep considering three different definitions of reasonableness.  It turns out that the concentration on the underlying problem of breaking initial symmetries allows us to use counterexamples different from leader election to prove the translational separation results. Likewise, the separation result in the setting of \cite{gorla08d} can be derived by our absolute separation result as well. Besides that, our absolute separation result allows us to weaken the definition of uniformity in comparison to the translational separation result of \cite{palamidessi03}, and also to weaken the definition of reasonableness in comparison to the translational separation result in the first setting of \cite{gorla08d}.  Moreover, considering our last translational separation result, we can even withdraw the assumption of divergence reflection.

Our own translational separation results, i.e., the proofs of the non-existence of a uniform and reasonable encoding for different definitions of reasonableness, follow similar lines of argument. The proofs argue by contradiction. First, a symmetric network of the form  in \procmix with special features is presented.  Second, we use the fact that uniformity, i.e., the homomorphic translation of the parallel operator, preserves essentials parts of the symmetric nature of .  Third, we apply Theorem \ref{thm:cannotBreakSymmetry} to conclude with the existence of a symmetric execution. In two proofs, we then apply Lemma \ref{lem:subdividingSymmetricTraces} to subdivide this symmetric execution. At last, we derive a contradiction between the additional information provided by the symmetric execution (and its subdivision) and the respective definition of reasonableness.

Note that we prove the absolute result without any precondition.  We use different definitions of reasonableness for the translational results. The only constant precondition of the translational separation results is the definition of uniformity, i.e., the homomorphic translation of the parallel operator. This condition is crucial. Without it, we could not apply our absolute separation result. To the best of our knowledge, only Gorla ever managed to prove such a separation result between \pimix and \pisep without the homomorphic translation of the parallel operator, using compositionality, operational correspondence, divergence reflection, success sensitiveness and either a reduction sensitive version of  or the stronger version of operational correspondence of his third setting.  However, Gorla believes that the result also holds for the general formulation of his criteria, i.e., without assuming a reduction sensitive version of  or the stronger version of operational correspondence of his third setting. We believe that this is an interesting open question.







We may also turn the non-existence of a uniform \emph{and} reasonable encoding around and rephrase it as a weakened existence statement.  Recall that any uniform encoding from \pimix into \pisep preserves symmetries.  While it is possible to break such symmetries in \pimix, this is not possible in \pisep.  Thus, should there be a non-uniform (at least: ``weakly compositional'') \emph{but} reasonable encoding from \pimix into \pisep, then \emph{it would have to be the encoding itself to break these symmetries}.  Finding such a reasonable encoding is an open problem, if reasonableness includes divergence reflection.  A uniform and ``almost reasonable'' divergent encoding was already presented in \cite{nestmann00}.


\addcontentsline{toc}{section}{References}
\bibliographystyle{alpha}
\bibliography{BreakingSymmetries.bib}

\end{document}
