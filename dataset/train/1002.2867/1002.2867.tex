\documentclass{eptcs}
\usepackage[latin1]{inputenc}
\usepackage{mathpartir}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{macros}
\usepackage{color}
\usepackage{graphics}
\usepackage{version}
\usepackage{url}

\providecommand{\event}{B. Klin, P. Soboci\'nski (Eds.): \\
6th Workshop on Structural Operational Semantics (SOS'09)}
\providecommand{\volume}{19}
\providecommand{\anno}{2010}
\providecommand{\firstpage}{17}
\providecommand{\eid}{2}
\usepackage{breakurl}


\usepackage{smacros}


\usepackage{amsthm}
\newtheorem{definition}{Definition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{proposition}[definition]{Proposition}
\theoremstyle{definition}

\renewcommand{\qed}{\hfill\ensuremath{\Box}}

\newcommand{\alert}{\mbox{\textcolor{red}{\ \bf * \ }}}

\title{A Fully Abstract Symbolic Semantics for Psi-Calculi}
\author{Magnus Johansson \and Bj{\"o}rn Victor \and Joachim Parrow}
\def\titlerunning{A Fully Abstract Symbolic Semantics for Psi-Calculi}
\def\authorrunning{Magnus Johansson, Bj{\"o}rn Victor, Joachim Parrow}
\date{\today}
\begin{document}
\maketitle

\begin{abstract}
We present a symbolic transition system and bisimulation equivalence
for psi-calculi, and show that it is fully
abstract with respect to bisimulation congruence in the non-symbolic semantics.

A psi-calculus is an extension of the pi-calculus with nominal data
types for data structures and for logical assertions representing
facts about data. These can be transmitted between processes and their
names can be statically scoped using the standard pi-calculus
mechanism to allow for scope migrations.
Psi-calculi can be more general than other proposed extensions of the
pi-calculus such as the applied pi-calculus, the spi-calculus, the
fusion calculus, or the concurrent constraint pi-calculus.

Symbolic semantics are necessary for an efficient implementation of
the calculus in automated tools exploring state spaces, and the full abstraction property means the
semantics of a process does not change from the original.
\end{abstract}

\section{Introduction}\label{sec:introduction}


A multitude of extensions of the pi-calculus have been defined,
allowing higher-level data structures and operations on them to be
used as primitives when modelling applications.  Ranging from
integers, lists, or booleans to encryption/decryption or hash
functions, the extensions increase the applicability of the basic calculus.
In order to implement automated tools for analysis and verification 
using state space exploration (e.g. bisimilarity or model checking),
each extended calculus needs a symbolic semantics, where the state space of
agents is reduced to a manageable size -- the non-symbolic semantics
typically generates infinite state spaces even for very simple agents. 

The extensions thus require added efforts both in developing the
theory of the calculus for each variant, and in constructing
specialised symbolic semantics for them.
As the complexity of the extensions increases, producing correct
results in these areas can be very hard. 
For example the labelled semantics of applied
pi-calculus~\cite{abadi.fournet:mobile-values} and of
CC-Pi~\cite{buscemi.montanari:open-bisimulation} have both turned out
to be non-compositional; another example is the rather complex  
bisimulations which have been developed for the
spi-calculus~\cite{abadi.gordon:calculus-cryptographic} (see
\cite{borgstrom.nestmann:bisimulations-spi} for an overview of
non-symbolic bisimulations, or
\cite{borgstroem.briais.ea:symbolic-bisimulation,briais:theory-tool,borgstroem:equivalences-calculi}
for symbolic ones).

The psi-calculi~\cite{bengtson.johansson.ea:psi-calculi} improve the situation: a single framework allows a range of
specialised calculi to be formulated with a lean and compositional labelled
semantics: with the parameters appropriately instantiated, the
resulting calculus can be used to model applications such as
cryptographic protocols and concurrent
constraints, but also more advanced scenarios with polyadic
synchronization or higher-order data and logics.
The expressiveness and modelling convenience of psi-calculi exceeds that
of earlier pi-calculus extensions, while the purity of the semantics
is on par with the original pi-calculus. Its meta-theory has been
proved mechanically using the theorem prover Isabelle~\cite{bengtson.parrow:psi-calculi-isabelle}.

In this paper we develop a symbolic semantics for psi-calculi,
admitting large parts of this range of calculi to be verified more efficiently.
We define a symbolic version of labelled bisimulation equivalence, and
show that it is fully abstract with respect to bisimulation congruence
in the original semantics.  This means that our new symbolic semantics
does not change which processes are considered equivalent.




A symbolic semantics abstracts the values received in an input
action. Instead of a possibly infinite branching of concrete values, a
single name is used to represent them all.  When the received values are
used in conditional constructions (e.g. if-then-else) or as
communication channels, we do not know their precise value, but need to
record the constraints which must be satisfied for a resulting
transition to be valid. 

A (non-symbolic) psi-calculus transition has the form , with
the intuition that  can perform  leading to  in an
environment that asserts .  
For example, if  can
do an  to  then  can make an
-transition
to  if we can deduce  from the environment, 
e.g. 

In the symbolic semantics where we may not have the precise value of
, we instead decorate the transition with its
requirement, so 

where  is the requirement for  to do an  to  in the
environment .
Constraints also arise from communication between parallel agents,
where, in the symbolic case, the precise channels may not be known;
instead we allow communication over symbolic representations of channels and
record the requirement in a transition constraint. As an example
consider 
 which after its initial inputs only has symbolic values of  and
. The resulting agent has the symbolic transition
 where
 means that  and  represent the same channel, but might
not have a  transition in the non-symbolic semantics.

Communication channels in psi-calculi may be structured data terms,
not only names. This leads to a new source of possibly infinite
branching: a subject in a prefix may be rewritten to another
equivalent term before it is used in a transition. E.g., when 
and  represent the same channel,
, but also ,
etc. The possibility of using
structured channels gives significant expressive power
(see~\cite{bengtson.johansson.ea:psi-calculi}). Our symbolic semantics
abstracts the equivalent forms of channel subject by using a fresh
name as subject, and adds a suitable constraint to the transition
label (see Section~\ref{sec:symbolic}).




\subsection{Comparison to related work}
Symbolic bisimulations for process calculi have a long history.
Our work is to a large extent based on the pioneering work by Hennessy
and Lin~\cite{hennessy.lin:symbolic-bisimulations} for value-passing
CCS, later specialised for the \pic{} by Boreale and
De~Nicola~\cite{boreale.de-nicola:symbolic-semantics} and independently
by Lin~\cite{lin:symbolic-transition,lin:computing-bisimulations}.
While~\cite{hennessy.lin:symbolic-bisimulations} is
parameterised by general boolean expressions on an underlying data
signature it does not handle names and mobility; on the other hand
\cite{boreale.de-nicola:symbolic-semantics,lin:symbolic-transition,lin:computing-bisimulations}
handle \emph{only} names and no other data structures.
The number of (direct or indirect) follow-up works to these is huge,
with applications ranging from pi-calculus to constraint programming;
here we focus on the relation to the ones for \api{} and spi-calculus.

The existing tools for calculi based on the \api{}
(e.g.~\cite{abadi.blanchet:analyzing-security,blanchet:efficient-cryptographic,blanchet.abadi.ea:automated-verification}),
are not fully abstract wrt bisimulation.  A symbolic
semantics and bisimulation for \api{} has been defined in
\cite{DBLP:conf/fsttcs/DelauneKR07}, but it is not complete.
Additionally, the labelled (non-symbolic) bisimulation of \api{} is
not compositional (see~\cite{bengtson.johansson.ea:psi-calculi}).
The situation for
the spi-calculus is better: fully abstract symbolic bisimulation for hedged
bisimulation has been defined in
\cite{borgstroem:equivalences-calculi}, and for open hedged
bisimulation (a finer equivalence) in \cite{briais:theory-tool}.  
According to those authors, neither is directly mechanizable.
The only symbolic
bisimulation which to our knowledge has been implemented in a tool is
not fully abstract~\cite{borgstroem.briais.ea:symbolic-bisimulation}.

It can be argued~\cite{borgstroem.briais.ea:symbolic-bisimulation}
that incompleteness is not a problem when verifying authentication and
secrecy properties of security protocols, which appears to have been the main
application of the \api{} so far.  
When going beyond security analysis we claim (based on experience from the Mobility
Workbench~\cite{victor.moller:mobility-workbench}) that
completeness is very important: when analysing
agents with huge state spaces, a positive result (the agents are
equivalent) may be more difficult to achieve than a negative result
(the agents differ).  However, such a negative result can only be
trusted if the analysis is fully abstract.

Our symbolic semantics is relatively simple, compared to the ones presented for \api{} or spi-calculus. 
In relation to the former, we are helped significantly by the absence
of structural equivalence rules, which in \api{} are rather
complex. In~\cite{DBLP:conf/fsttcs/DelauneKR07} an intermediate
semantics is used to overcome the complexity. In contrast we can directly
relate the original and symbolic semantics.
In relation to the symbolic semantics for spi-calculus, our semantics
has a straight-forward treatment of scope opening due to the simpler
psi-calculi semantics. In addition, the complexities of spi-calculus
bisimulations  are necessarily inherited by the symbolic semantics,
introducing e.g. explicit environment knowledge representations with
timestamps on messages and variables.  In psi-calculi, bisimulation is
much simpler and the symbolic counterpart is not significantly more
complex than the one for value-passing CCS.

In the light of these complications, the relevance of
precise encodings of the \api{} or spi-calculus as psi-calculi,
or comparing the resulting bisimulation equivalences is questionable.
Our interest is
in handling and analysing the same type of applications, and also
the more advanced kinds of applications mentioned in the beginning of this section. 

\paragraph{Disposition.}
In the next section we review the basic definitions of syntax,
semantics, and bisimulation of psi-calculi. Section~\ref{sec:symbolic}
presents the symbolic semantics and bisimulation, while
Section~\ref{sec:examples} illustrates the concrete and symbolic
transitions and bisimulations by examples. In
Section~\ref{sec:results} we show our main results: the correspondence
between concrete and symbolic transitions and
bisimulations. Section~\ref{sec:conclusion} concludes, and presents
plans and ideas for future work.


\section{Psi-calculi}\label{sec:psi}

This section is a brief recapitulation of psi-calculi and nominal data types; for a more extensive treatment including motivations and examples see~\cite{bengtson.johansson.ea:psi-calculi}.

\subsection{Nominal data types}

We assume a countably infinite set of atomic {\em names}  ranged over by . Intuitively, names will represent the symbols that can be statically scoped, and also represent symbols acting as variables in the sense that they can be subjected to substitution. 
A {\em nominal set}~\cite{PittsAM:nomlfo-jv,Gabbay01anew} is a set equipped with {\em name swapping} functions written , for any names . An intuition is that for any member  it holds that  is  with   replaced by  and   replaced by . One main point of this is that  even though we have not defined any particular syntax we can define what it means for a name to ``occur" in an element: it is simply that it can be affected by swappings. 
The names occurring in this way  in an element  constitute the  {\em support} of , written .

  We write , pronounced `` is fresh for ", for .  If  is a set of names we write  to mean .
We require all elements to have finite support, i.e.,  is finite for all
.


A function  on nominal sets is {\em equivariant} if  holds for all , and similarly for functions and
relations of any
arity. Intuitively, this means that all
names are treated equally.

A {\em nominal data type} is just a nominal set together with a set of functions on it. In particular we require a substitution function~\cite{bengtson.parrow:psi-calculi-isabelle}, which intuitively substitutes elements  for  names. If  is an element of a data type,  is a sequence of names without duplicates and  is an equally long sequence of elements, the {\em substitution}
 is an element of the same data type as . 


\subsection{Agents}

\newcommand{\terms}{{\rm\bf T}}
\newcommand{\conditions}{{\rm\bf C}}
\newcommand{\assertions}{{\rm\bf A}}


A psi-calculus is defined by instantiating three nominal data types and four operators:
\begin{definition}[Psi-calculus parameters]
\label{def:parameters}
A psi-calculus requires the three (not necessarily disjoint) nominal data types:

and the four equivariant operators:

\end{definition}
The binary functions above will be written in infix. Thus, if  and  are terms then  is a condition, pronounced `` and  are channel equivalent" and if  and  are assertions then so is . Also we write , `` entails ", for .


The data terms are used to represent all kinds of data, including communication
channels. Conditions are used as guards in agents, and  is a
particular condition saying that  and  represent the
same channel.
The assertions will be used to declare information necessary to resolve the
conditions. Assertions can be contained in agents and thus represent information
postulated by that agent; they can contain names and thereby be syntactically
scoped and thus represent information known only to the agents within that
scope. 
The intuition of entailment is that  means that given the
information in , it is possible to infer .
 We say that two assertions are equivalent if they entail the same conditions:
\begin{definition}[Assertion equivalence]
\label{def:assEq}
Two assertions are {\em equivalent}, written , if for all  we have that .
\end{definition}

A psi-calculus is formed by instantiating the nominal data types and morphisms so that the following requisites are satisfied:
\begin{definition}[Requisites on valid psi-calculus parameters]
\label{def:entailmentrelation}
\
\begin{mathpar}
\begin{array}{ll}
\mbox{Channel Symmetry:} & \Psi \vdash M \sch N \; \Longrightarrow\; \Psi \vdash N \sch M \\
\mbox{Channel Transitivity:} & \Psi \vdash M \sch N \; \land \; \Psi \vdash N \sch L\\
& \quad \quad \;\Longrightarrow\; \Psi \vdash M \sch L\\ 
\\
\mbox{Weakening:} & \Psi \vdash \varphi \; \Longrightarrow \; \Psi \ftimes \Psi' \vdash \varphi \\
\\ 

\mbox{Composition:} & \Psi \sequivalent \Psi'  \;\Longrightarrow\; \Psi \ftimes \Psi'' \sequivalent \Psi' \ftimes \Psi''\\
\mbox{Identity:} & \Psi \ftimes \emptyframe \sequivalent \Psi \\
\mbox{Associativity:}& (\Psi \ftimes \Psi') \ftimes \Psi'' \sequivalent \Psi \ftimes (\Psi' \ftimes \Psi'')\\
\mbox{Commutativity:}&  \Psi \ftimes \Psi' \sequivalent \Psi' \ftimes \Psi \\

\end{array}
\end{mathpar}
\end{definition}
\noindent

Our requisites on a psi-calculus are that the channel equivalence is a partial
equivalence relation, that  preserves equivalence, and that the
equivalence classes of assertions form an abelian monoid. 
We do not require that channel equivalence is reflexive. There may be
terms  such that  does not hold. By transitivity and
symmetry then  holds for no , which means that  cannot
be used as a channel at all. In this way we accommodate data
structures which cannot be used as channels.
The requisite of weakening (which is not present in
\cite{bengtson.johansson.ea:psi-calculi}) excludes some non-monotonic logics; it
simplifies our proofs in the present paper although we do not know if it is
absolutely necessary. It is only used in one place in the
proof of Theorem~\ref{theorem:soundness}.


In the following  means a finite (possibly empty) sequence of names, . The empty sequence is written  and the concatenation of  and  is written .
When occurring as an operand of a set operator,  means the corresponding set of names . We also use sequences of terms, conditions, assertions etc. in the same way.

A {\em frame} can intuitively be thought of as an assertion with local names:
\begin{definition}[Frame]
\label{def:frame}
A {\em frame}  is of the form  where
 is a sequence of names considered bound in
the assertion 
. We use  to range over frames. \footnote{In some presentations
frames have been written just as pairs .
The notation in this paper better conveys the idea that the names bind into the
assertion, at the slight risk of confusing frames with agents. Formally, we
establish frames and agents as separate types, although a valid intuition is to
regard a frame as a special kind of agent, containg only scoping and assertions.
This is the view taken in~\cite{abadi.fournet:mobile-values}. }

\end{definition}
Name swapping on a frame  just distributes to its two components. We
identify
alpha equivalent frames, so . 
We overload  to also mean the least informative frame
 and  to mean composition on frames
defined by  where
   and vice versa. We write

for , and when there is
no risk of confusing a frame with an assertion we write  for
.

\begin{definition}[Equivalence of frames]\label{def:frame-equivalence}
We define  to mean that there exists an alpha variant
 of  such that   and . We also define 
 to mean that for all  it holds that  iff .
\end{definition}
Intuitively a condition is entailed by a frame if it is entailed by the
assertion and does not contain any names bound by the frame. 
Two frames are equivalent if they entail the same conditions.

\begin{definition}[Psi-calculus agents]\label{def:agents}
Given valid psi-calculus parameters as in Definitions~\ref{def:parameters} and~\ref{def:entailmentrelation}, the psi-calculus {\em agents}, ranged over by ,  are of the following forms.
{\rm

}

\noindent
In the Input ,   binds its occurrences in . 
Restriction binds  in . An assertion is {\em guarded} if it is a subterm
of an Input or Output. In a replication  there may be no unguarded
assertions in .
\end{definition}
In the Output and Input forms  is called the subject and
 and  the objects, respectively.
Output and Input  are similar to those in the pi-calculus, but
arbitrary terms can function as both subjects and objects.
Note that differently from~\cite{bengtson.johansson.ea:psi-calculi},
for simplicity the input is not pattern matching (see
Section~\ref{sec:conclusion} for a discussion).
The {\bf case} construct works by performing the action of any
 for which the corresponding  is true. So it
embodies both an {\bf if} (if there is only one branch) and an internal
nondeterministic choice (if the conditions are overlapping).

Some notational conventions: We define the agent  as .
The  construct 
 is
sometimes written as
\mbox{\rm }, or if  as 
.
The input subject is underlined to facilitate parsing of complicated
expressions; in simple cases we often conform to a more traditional notation and
omit the underline.

Formally, we define name swapping on agents by distributing it over all constructors, and substitution on agents by distributing it and avoiding captures by binders through alpha-conversion in the usual way. We identify alpha-equivalent agents; in that way we get a nominal data type of agents where
the support  of  is the union of
the supports of the components of , removing the names bound by Input and
, and corresponds to the names with a free occurrence in .


\begin{definition}[Frame of an agent]
The {\em frame  of an agent} P is defined inductively as follows:

\end{definition}

\subsection{Operational semantics}

The presentation of psi-calculi in~\cite{bengtson.johansson.ea:psi-calculi} gives a semantics of an early kind, where input actions are of kind . 
Here we give an operational semantics of the late kind, meaning that
the labels of input transitions contain variables for the object to be
received. With this kind of semantics it is easier to establish a
relation to the symbolic semantics. We also establish precisely how it
relates to the original.


\begin{definition}[Actions]

The {\em actions} ranged over by  are of the following three kinds:
 (Output),  (Input), and
 (Silent).





\end{definition}

For actions we refer to  as the {\em subject} and  and  as the {\em
objects}. We let . We define 
, 
, 
and . We also define  and
 if  is an output or input.
As in the pi-calculus, the output  represents an
action sending  along  and opening the scopes of the names . 
Note in particular that the support of this action includes  . Thus 
 and  are different actions.

\begin{table*}[tb]

\begin{minipage}{1\textwidth} \begin{mathpar}

\inferrule*[Left=\textsc{In}]
    {\Psi \vdash M \sch K}
    {\framedtransempty
      {\Psi}
      {\inprefix{M}{\ve{x}}{x}.P}
      {\inlabel{K}{\ve{x}}{x}}
      {P}
    }~~
\inferrule*[left=\textsc{Out}]
    {\Psi \vdash M \sch K }
    {\framedtransempty
      {\Psi}
      {\out{M}{N}.P}
      {\out{K}{N}}
      {P}
    }~~
\inferrule*[left={\textsc{Case}}]
    {\framedtransempty{\Psi}{P_i}{\alpha}{P'} \\ \Psi \vdash \varphi_i}
    {\framedtransempty{\Psi}{\caseonly{\ci{\ve{\varphi}}{\ve{P}}}}{\alpha}{P'}}


\inferrule*[Left=\textsc{Com}, Right={}]
 {\framedtransempty{\frass{Q} \ftimes \Psi}{P}{\bout{\ve{a}}{M}{N}}{P'} \\
  \framedtransempty{\frass{P} \ftimes \Psi}{Q}{\inlabel{K}{\ve{x}}{x}}{Q'} \\
  \Psi \ftimes \frass{P} \ftimes \frass{Q} \vdash M \sch K
  }{\framedtransempty{\Psi}{P \pll Q}{\tau}{(\nu \ve{a})(P' \pll
Q'\lsubst{N}{x})}}


\inferrule*[left=\textsc{Par},  right={
}]
{\framedtransempty{\frass{Q} \ftimes \Psi}{P} {\alpha}{P'}}
{\framedtransempty{\Psi}{P|Q}{\alpha}{P'|Q}}

\inferrule*[left=\textsc{Scope}, right={}]
    {\framedtransempty{\Psi}{P}{\alpha}{P'}}
    {\framedtransempty{\Psi}{(\nu b)P}{\alpha}{(\nu b)P'}}

\inferrule*[left=\textsc{Open}, right={}]
    {\framedtransempty{\Psi}{P}{\bout{\ve{a}}{M}{N}}{P'}}
    {\framedtransempty{\Psi}{(\nu b)P}{\bout{\ve{a} \cup \{b\}}{M}{N}}{P'}}

\inferrule*[left=\textsc{Rep}]
   {\framedtransempty{\Psi}{P \pll !P}{\alpha}{P'}}
   {\framedtransempty{\Psi}{!P}{\alpha}{P'}}




\end{mathpar}

\caption{Late operational semantics. Symmetric versions of \textsc{Com}
and \textsc{Par} are elided. In the rule  we assume that  and    where  is fresh for all of 
 and , and that  is correspondingly
fresh. In the rule
\textsc{Par} we assume that 
where  is fresh for
 and . 
In  the expression  means the sequence
 with  inserted anywhere.
}

\label{table:struct-free-labeled-operational-semantics}
\end{minipage}
\end{table*}


\begin{definition}[Transitions]
\label{transitions}

A {\em transition} is of the kind \mbox{}, meaning that when the environment contains the assertion  the agent 
can do an  to become .  The transitions are defined inductively in 
Table~\ref{table:struct-free-labeled-operational-semantics}.
\end{definition}
Note that  in Table~\ref{table:struct-free-labeled-operational-semantics}
expresses the effect that  the environment has on the agent, by enabling
conditions in \textsc{Case}, by giving rise to action subjects in \textsc{In}
and \textsc{Out} and by enabling interactions in \textsc{Com}.

Both agents and frames are identified by alpha equivalence. This means that we
can choose the bound names fresh in the premise of a rule. In a transition the
names in  count as binding into both the action object and the
derivative, and transitions are identified up to alpha equivalence.
This means that the bound names can be chosen fresh, substituting each          
occurrence in both the object and the derivative. This is the reason why
 is in the support of the output action: otherwise it could be
alpha-converted in the action alone. 

\begin{table*}[tb]

\begin{minipage}{1\textwidth} \begin{mathpar}



\inferrule*[left=\textsc{In}]
    {\Psi \vdash M \sch K }
{\framedtransempty{\Psi}{\inprefix{M}{\ve{y}}{x}.P}{\inn{K}{N}} {
P\lsubst { N } { x } } } \quad
\inferrule*[left=\textsc{Com}, right={}]
 {\Psi \ftimes \frass{P} \ftimes \frass{Q} \vdash M \sch K \\\\
  \framedtransempty{\frass{Q} \ftimes \Psi}{P}{\bout{\ve{a}}{M}{N}}{P'} \\
  \framedtransempty{\frass{P} \ftimes \Psi}{Q}{\inn{K}{N}}{Q'}
  }
       {\framedtransempty{\Psi}{P \pll Q}{\tau}{(\nu \ve{a})(P' \pll Q')}}

\end{mathpar}
\caption{Early structured operational semantics. All other rules are as in the late semantics of Fig.~\ref{table:struct-free-labeled-operational-semantics}.}
\label{table:original-semantics}
\end{minipage}
\end{table*}


Table~\ref{table:original-semantics} gives the rules for
input and communication
of an early kind used in~\cite{bengtson.johansson.ea:psi-calculi}.
The following lemma clarifies the relation between the two semantics:
\begin{lemma}
\ 
\label{lemma:late-early}
\begin{enumerate}
\item \label{lemma:late-early:in}
 in the early semantics iff there exist
 and  such that
 in the late semantics,
where .
\item \label{lemma:late-early:out-tau}
For output and  actions,  in the early semantics iff the same transition can be derived in the early semantics.
\end{enumerate}
\end{lemma}
The proof is by induction over the transition derivations. In the proof of (\ref{lemma:late-early:out-tau}), the case  needs both (\ref{lemma:late-early:in}) and the case where  is an output.

\subsection{Bisimulation}
We proceed to define early bisimulation with the late semantics:

\begin{definition}[(Early) Bisimulation]
A {\em bisimulation}
  is a ternary relation between assertions and pairs of agents such that
  implies all of
 \begin{enumerate}
 \item Static equivalence:
  
 \item
   Symmetry: 
 \item
 Extension of arbitrary assertion: 
 \item
  Simulation: for all ,  such that 
\begin{enumerate}
\item if :\quad  and
.
\item otherwise: \quad  and
.
\end{enumerate}
\end{enumerate}
 \label{def:bisim}
We define  to mean that there exists a bisimulation  such
that
. We also define  to mean that
 for all .
\end{definition}

The relation between this definition and the original definition of bisimulation in~\cite{bengtson.johansson.ea:psi-calculi} is clarified by the following:

\begin{lemma}
For the psi-calculi in the present paper, a relation is a bisimulation according to Def.~\ref{def:bisim} precisely if it is a bisimulation according to \cite{bengtson.johansson.ea:psi-calculi}.
\end{lemma}
The proof is straightforward using Lemma~\ref{lemma:late-early}. As a corollary
the algebraic properties of  established
in~\cite{bengtson.johansson.ea:psi-calculi} hold, notably that it is a
congruence.

\section{Symbolic semantics and equivalence}
\label{sec:symbolic}
The idea behind a symbolic semantics is to reduce the state space of agents. One
standard way is to avoid infinite branching in inputs by 
using a fresh name to represent whatever was received.

In psi-calculi there is an additional source of infinite branching:  a subject  
in a prefix may get rewritten
to many terms. Also here we use a fresh name to represent these terms.
This means that the symbolic actions are the same as
the concrete actions with the exception that only names are used as subjects.

 
A {\em symbolic transition} is of form 

The intuition is that this represents a set of concrete transitions,
namely those that satisfy the constraint . Before the formal
definitions we here briefly explain the rationale. Consider a
psi-calculus with integers and integer equations; for example a
condition can be ``". An example agent is 
.
If , where  is a constraint that is
always true, then there should clearly be
a transition
 for some constraint  that captures
that
 must be 3. One
context that can make
this constraint true is an
input, as in . The input will give rise to a substitution for
, and if the substitution sends  to 3 the constraint is
satisfied. 
In this way the constraints are similar to those for the pi-calculus~\cite{boreale.de-nicola:symbolic-semantics,lin:symbolic-transition}.
In psi-calculi there is an additional way that a context
can enable the transition: it can contain an assertion as in
. Concretely this agent has a
transition
 since . 
Therefore a solution of a constraint will 
contain both a substitution of terms for names (representing the
effect of an input) and an assertion (representing the effect of a
parallel component).

\begin{definition}
The {\em atomic constraints} are of the form
 where  are binding
occurrences into  and . A {\em solution} of an
atomic constraint is a pair  where  is a
substitution of terms for names such that  and
. We adopt the notation  to say that  is a solution of , and write
 for .

The {\em transition constraints} are the atomic
constraints  and conjunctions of atomic constraints , where the
solutions are the intersection of the solutions for  and  and we let
 mean .
\end{definition}
A transition constraint  defines a set of solutions ,
namely those where the entailment becomes true by applying the substitution and
adding the assertion.
For example, the transition constraint  has
solutions  and , where Id is the
identity substitution.

The structured operational symbolic
semantics is defined in Table \ref{table:symbolic-semantics}.
First consider
the {\sc Out} rule:
.
The symbolic subject  must be chosen fresh and has a constraint
associated with it: the transition can be taken in any solution that implies
that the subject  of the syntactic prefix is channel equivalent to .


\begin{comment}
\TODO{Symbolic unification is only needed if we have pattern matching.}
\begin{definition}[Symbolic unification]
\label{def:symbolicunification}
 symbolically unifies  and  where  and , written , if and only
if  such that  we have that .
\end{definition}

\begin{lemma}
\label{lemma:unif1}
 If  where ,
then .
\end{lemma}
\begin{proof}
 We need to show that , which is clearly true.
\end{proof}

\begin{lemma}
\label{lemma:unif2} DOES NOT HOLD!!
 If  where 
then  such that ,
, and .
\end{lemma}
\end{comment}

\begin{table}[tb]

\begin{mathpar}

\inferrule*[Left=\textsc{In}, right={}]
    { }
    {\Psi \frames
\transs{\inprefix{M}{\ve{x}}{x}.P}{\inlabel{y}{\ve{x}}{x}}
{\constr{\Psi \vdash M \sch y}}{P}}~~
\inferrule*[left={\textsc{Case}}]
    {\Psi \frames \transs{P_i}{\alpha}{C}{P'} }
    {\Psi \frames
\transs{\caseonly{\ci{\ve{\varphi}}{\ve{P}}}}{\alpha}{C \wedge \constr{\Psi
\vdash \varphi_i}}{P'}}

\inferrule*[left=\textsc{Out}, right={}]
    { }
    {\Psi \frames \transs{\out{M}{N}.P}{\out{y}{N}}{\constr{\Psi
\vdash M \sch y}}{P}}



\inferrule*[Left=\textsc{Com}, Right={}]
    {\Psi \ftimes \frass{Q} \frames
\transs{P}{\sbout{y}{\ve{a}}{N}}{(\nu \ve{b_P})\constr{\Psi' \vdash M_P \sch
y} \wedge C_P}{P'} \\
     \Psi \ftimes \frass{P} \frames
\transs{Q}{\inlabel{z}{\ve{x}}{x}}{(\nu \ve{b_Q})\constr{\Psi' \vdash M_Q \sch
z}
\wedge C_Q}{Q'}
    }
    {\Psi \frames \transs{P \pll Q}{\tau}{(\nu
\ve{b_P},\ve{b_Q})\constr{\Psi'
\vdash M_P \sch M_Q} \wedge C_P \wedge C_Q}{(\nu
\ve{a})(P' \pll Q'\lsubst{N}{x})}}

\inferrule*[Left=\textsc{Par}, right={}]
    {\Psi \ftimes \frass{Q} \frames \transs{P}{\alpha}{C}{P'}}
    {\Psi \frames \transs{P \pll Q}{\alpha}{(\nu \frnames{Q})C}{P' \pll Q}}


\inferrule*[Left=\textsc{Scope}, right={}]
    {\Psi \frames \transs{P}{\alpha}{C}{P'}}
    {\Psi \frames \transs{(\nu a)P}{\alpha}{(\nu a)C}{(\nu a)P'}}

\inferrule*[left=\textsc{Open}, right={} ]
    {\Psi \frames \transs{P}{\sbout{y}{\ve{a}}{N}}{C}{P'}}
    {\Psi \frames \transs{(\nu a)P}{\sbout{y}{\ve{a} \cup a}{N}}{(\nu a)C
}{P'}}

\inferrule*[left=\textsc{Rep}]
   {\Psi \frames \transs{P \pll !P}{\alpha}{C}{P'}}
   {\Psi \frames \transs{!P}{\alpha}{C}{P'}}


\end{mathpar}
\caption{Transition rules for the symbolic semantics. Symmetric versions of
\textsc{Com} and \textsc{Par} are
elided. 
In the rule  we assume
that  and    where  is
fresh for all of  and , and that  is
correspondingly
fresh. We also assume that .
In
the rule \textsc{Par} we assume that 
where  is
fresh for  and . 
In  the expression  means the sequence
 with  inserted anywhere.}
\label{table:symbolic-semantics}
\end{table}

The rule \textsc{Com} is of particular interest. The intuition is that the
symbolic action subjects are placeholders for the values  and .
In the conclusion the constraint is that these are channel
equivalent, while  and  will not occur again.

We will often write  for .

\subsection{Symbolic bisimulation}

In order to define a symbolic bisimulation we need additional kinds of
constraints. If a process  does a bound output
 that is matched by a bound output 
from  we need constraints that keep track of the fact that  and 
should be syntactically the same, and that  is sufficiently fresh.
\begin{definition}
The {\em constraints} include the transition constraints, 
 , and
, where  is any nominal data type. The solutions of
the last two are all pairs  such that 
and  respectively. We also include conjunction of
constraints , where the set of solutions is the
intersection of the
solutions for  and .
\end{definition}
Note that the assertion part of the solution is irrelevant for constraints of kind  and
, and that the substitution does not affect  in .
The constraint  is
used in the bisimulation for matching output objects, and  is
used in the bisimulation for recording what an opened name must be fresh for.
This corresponds to distinctions in open bisimulation for the pi-calculus
\cite{sangiorgi:theory-bisimulation}.
We define  to be , we write  for
, and we extend the notation to sets of names, e.g.
.


\begin{definition}[Constraint implication]
 A constraint  \emph{implies} another constraint , written , iff .
We write  iff
 for
each  there exists a  such that .
\end{definition}

Before we can give the definition of symbolic
bisimulation we need to define a symbolic variant of  the concrete static equivalence.

\begin{definition}[Symbolic static equivalence]
 \label{def:ssequivalent}
 Two processes  and  are \emph{statically equivalent} for , written
, if for each 
we have that .
\end{definition}



\begin{comment}
\begin{definition}[Equal actions]
 Two actions  and  are equal for , written
, is defined as

\end{definition}
\end{comment}

We now have everything we need to define symbolic bisimulation. This definition
follows the definition in \cite{hennessy.lin:symbolic-bisimulations} closely.

\begin{definition}[(Early) Symbolic bisimulation]\label{def:symbisim}
A {\em symbolic bisimulation}
  is a ternary relation between constraints and pairs of agents such
that  implies all of

\begin{enumerate}
\item , and
\item , and
\item If ,
 and  then there exists a set of constraints
 such that 
 \\
and for all
 there exists , , and  such that

\begin{enumerate}
\item , and
\item , and
\item if  then , , \\
 and 

otherwise  and 
\end{enumerate}
\end{enumerate}
We write  if  for some symbolic
bisimulation , and say that  is \emph{symbolically
bisimilar} to .
\end{definition}


The set  allows a case analysis on the constraint solutions, as examplified in the next section. 
The output objects need to be equal in a solution to . Since
the solutions of   only depend on the substitutions, this constraint corresponds to the fact that the objects must be identical in the concrete bisimulation.
Note that  may occur in . Based on
\cite{boreale.de-nicola:symbolic-semantics,lin:symbolic-transition}, we
conjecture that adding the requirement
 would give late symbolic bisimulation.

\section{Examples}
\label{sec:examples}
We now look at a few examples to illustrate the concrete and
symbolic transitions and bisimulations. First consider a simple example from the pi-calculus.
This can be expressed as a psi-calculus: let the only data terms be
names,  the only
assertion be , the conditions be equality and inequality tests on
names, and entailment defined by ,  and . For a more thorough discussion,
see \cite{bengtson.johansson.ea:psi-calculi}. In the following examples we drop a trailing .
Consider the two agents  and :

These are bisimilar. A concrete bisimulation between these agents is

The bisimulation needs to be infinite because of the infinite branching in the input.
In contrast, a
symbolic bisimulation only contains four triples:


When checking the second triple , the transition of
 is matched by a case analysis:  in the definition of symbolic bisimulation (Def.~\ref{def:symbisim}) is
, and a matching transition for  can be found for each of
these cases, so the agents are bisimilar.
In contrast,
they are not equivalent in the incomplete
symbolic bisimulations in
\cite{borgstroem.briais.ea:symbolic-bisimulation} and
\cite{DBLP:conf/fsttcs/DelauneKR07}.

Next we look at an example where we have tuples of channels and projection,
e.g. the entailment relation gives us that . Consider the agent

Concretely this agent has infinitely many transitions even in an empty frame: , 
\iftrue and equivalent actions  
for all , and
 
for all  and , etc.
\else
and equivalently  
for all , and
 
for all  and , etc.
\fi
Symbolically, however, it has
only one transition: .

For another example, consider the two agents

where  is a term such that for no  does it hold that , i.e.,  is not a channel. Then we have that  and  are concretely bisimilar since
neither one of them has a transition. But symbolically  has the
transition , while
 has no symbolic transition. Perhaps surprisingly they are still symbolically
bisimilar: Def.~\ref{def:symbisim} requires that we find a
disjunction  such that , or in
this case such that . Since  is not channel equivalent to
anything, the left hand side has no solutions, which means that any set
 will do, and in particular the empty one.
The condition ``for all " in the definition becomes
trivially true, so  does not have to mimic the transition.

A final example shows the use of cryptographic primitives. Here
 the terms contains  and ,
assertions are variable assignments, e.g. , the conditions are
equality tests between terms, and the entailment relation is parametrised by an
equation system which contains the equation . Consider

Here the environment can use , the result of encrypting  with , but not the bound  or .
Intuitively these agents are bisimilar since the key  is not revealed until
after the agents receive , which therefore cannot be equal to . The first
symbolic transitions of the agents are

and the second transitions are

A symbolic
bisimulation, where we for simplicity ignore the constraints that arise for
subjects, is

Here the constraint  will among other things imply
that . The final transition of 
has the constraint
, so 
we must find a
disjunction  such that
.
Since  is bound, the only way to find a solution to
the left hand side is to find a value for  that evaluates to . One
candidate for a solution is , but
because of the constraint  this does not work. In fact, 
there is no
solution to the left hand side because of the freshness
constraint on  and the fact that  is bound. This means that, as in the previous example, any
disjunction
 will do, and in particular the empty disjunction, and trivially
 does not have to mimic the transition.

In contrast, if we swap the order of the inputs and the outputs in 
and  and try to construct the bisimulation relation we will discover that
we do not get the constraint . This means that 
 is a solution
to  in the definition of bisimulation, and that  must
mimic the transition from . In this case the agents are not bisimilar.

\section{Results}
\label{sec:results}
We now turn to showing that the concrete and symbolic equivalences coincide.


We define substitution on symbolic actions by
,
, and
,
where .
We define the substitution  for 
by
 if , and  otherwise.


The following two lemmas show the operational correspondence between the
symbolic semantics and the concrete semantics: given a symbolic transition
where the transition constraint has a solution, there is
always a corresponding concrete transition
(Lemma~\ref{lemma:correspondence-symbolic-concrete}) and vice versa
(Lemma~\ref{lemma:correspondence-concrete-symbolic}).

\begin{lemma}[Correspondence symbolic-concrete]\mbox{}\\
\label{lemma:correspondence-symbolic-concrete}
\vspace{-1\baselineskip}
\begin{enumerate}
 \item If  then for all  s.t. 
we have that .
\item If  then for all  s.t.  we have that .
\item If  then for all  we have that .
\end{enumerate}
\end{lemma}

\begin{lemma}[Correspondence concrete-symbolic]\mbox{}\\
\label{lemma:correspondence-concrete-symbolic}
\vspace{-1\baselineskip}
\begin{enumerate}
 \item   If ,\quad ,\quad
and 
then there exists , and   such that
\\
and .
\item   If ,\quad ,\quad and 
then there exists ,  such that
\\
 and
.
\item   If 
then there exists  such that 
 and .
\end{enumerate}
We assume in 1 and 2 that  and
.
\end{lemma}

The proofs are by induction over the transition derivation (one case for each
rule).


\begin{theorem}[Soundness]
\label{theorem:soundness}
Assume  is a symbolic bisimulation and let \\ .
Then  is a concrete bisimulation.
\end{theorem}

The proof idea to show that  is a concrete bisimulation is to
assume  and that  has a
transition in environment . We use
Lemma~\ref{lemma:correspondence-concrete-symbolic} to find a symbolic transition
from , then the fact that  is a symbolic bisimulation to find a
simulating symbolic transition from , and finally
Lemma~\ref{lemma:correspondence-symbolic-concrete} to find the required concrete
transitions from . 

Similarly to~\cite{hennessy.lin:symbolic-bisimulations} we need an extra assumption about the expressiveness of constraints: for all  such that
 is a concrete bisimulation there exists a constraint  such that
.
In order to determine symbolic bisimilarity in an efficient way we
need to compute this constraint, which is easy for the
pi-calculus~\cite{boreale.de-nicola:symbolic-semantics,lin:symbolic-transition,lin:computing-bisimulations}
and harder (but in many practical cases possible) for cryptographic
signatures~\cite{borgstroem:equivalences-calculi}. These results suggest that
our constraints are sufficiently expressive, but for other instances of
psi-calculi we may have to extend the constraint language. We leave this as an
area of further research.

\begin{theorem}[Completeness]
\label{theorem:completeness}
Assume that  is a concrete bisimulation and let \\ . Then  is a symbolic
bisimulation.
\end{theorem}

The proof idea is the converse of the proof for Theorem~\ref{theorem:soundness}. The expressiveness assumption of constraints mentioned above is needed in order to construct the disjunction of constraints in the symbolic bisimulation. 
From these two theorems we get:
\begin{corollary}[Full abstraction]
 if and only if .
\end{corollary}

\section{Conclusion and Future Work}

\label{sec:conclusion}
We have defined a symbolic operational semantics for psi-calculi and a
symbolic bisimulation which is fully abstract wrt the original
semantics. 
While the developments
in~\cite{bengtson.johansson.ea:psi-calculi} give meta-theory for a
wide range of calculi of mobile processes with nominal data and
logic, the work presented in this paper gives a solid foundation for
automated tools for the analysis of such calculi.  


As mentioned in the introduction, the purity of the original semantics
of psi-calculi has made the symbolic semantics easier to develop.
There are no structural equivalence rules (which are a complication in
\api), the scope opening rule is because of this straight-forward
which makes knowledge representation simpler than in spi-calculi, and
the bisimulation less complex.
Nevertheless, the technical challenges have not been absent: the
precise design of the constraints and their solution has been
delicate.  Since assertions may occur under a prefix, the environment can
change after a transition. Keeping the assertion  in the
transition constraints
(on the form ) essentially keeps
a snapshot of the environment that gives rise to the transition. An
alternative would be to use time stamps to keep track of which environment
made which condition true, but that approach seems more difficult.

Our symbolic bisimulation is a strong equivalence which does not
abstract the internal  transitions. This is less useful for
verification than a weak observational equivalence, but still a
significant step towards mechanized verification.
We are currently developing a weak bisimulation for psi-calculi, and
are studying the correspondence to a barbed bisimulation congruence.
Preliminary results indicate that lifting the symbolic bisimulation
presented here to weak bisimulation will be unproblematic.


The original psi-calculi admit pattern matching in inputs. 
In a symbolic semantics this would lead to complications in the \textsc{COM}-rule,
which should introduce a substitution
for the names bound in the pattern. This means introducing
more fresh names and constraints, and it is not clear that the
convenience of pattern matching outweighs such an awkward semantic
rule. We leave this as an area for further study.

For future work, we need to develop an algorithm for deciding symbolic
bisimulation and implement it in a tool. A natural basis for this
would be the algorithm given in
\cite{hennessy.lin:symbolic-bisimulations}.
Furthermore, the termination of the algorithm will depend
on the properties of the parameters of the particular psi-calculus: it
is easy to construct a psi-calculus where the entailment relation or
static equivalence is
not decidable, but in many practical cases it will be~\cite{borgstroem:equivalences-calculi,baudet:thesis}.  
We intend to use constraint solvers developed for specific application
domains (e.g. security) in a future generic tool. We will also produce mechanized proofs of the adequacy of the symbolic
semantics, using the Isabelle theorem prover.


When typing schemes have been developed for psi-calculi,
a natural progression would be to take advantage of those also in the
symbolic semantics, to further constrain the possible values and thus the
size of state spaces.

\bibliographystyle{eptcs}
\bibliography{sos09-symbolic-psi,pi}

\end{document}
