
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{graphics}
\usepackage{svg}
\usepackage{algorithm} 
\usepackage{algorithmic} 
\usepackage{dsfont}
\usepackage{wrapfig}
\usepackage{subcaption}


\newcommand{\alexey}[1]{{\color{orange} \textbf{Alexey}: {#1}}}
\newcommand{\emiel}[1]{{\color{blue} \textbf{Emiel}: {#1}}}

\title{Autoregressive Diffusion Models}



\author{Emiel Hoogeboom\thanks{Work done during as research intern at Google Brain.}, Alexey A. Gritsenko, Jasmijn Bastings, Ben Poole, \\ \textbf{Rianne van den Berg, Tim Salimans} \\
Google Research \\
\texttt{e.hoogeboom@uva.nl,\{agritsenko,pooleb,bastings,salimans\}@google.com,} \\ \texttt{riannevdberg@gmail.com}
}


\usepackage{listings,newtxtt}

\definecolor{deepblue}{rgb}{0,0,0.6}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\lstdefinestyle{lststyle}{
language=Python,
basicstyle=\ttfamily\small,
commentstyle=\color{deepred},
otherkeywords={self},             keywordstyle=\color{deepgreen},
emph={sum, get_cost_and_dimension_matrices, compute_next_cost, get_nelbo_matrix, inner_cost_and_dimension_loop,get_optimal_path_with_budget},          emphstyle=\color{deepblue},    stringstyle=\color{deepred},
frame=tb,                         showstringspaces=false            }
\lstset{style=lststyle}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We introduce Autoregressive Diffusion Models (ARDMs), a model class encompassing and generalizing order-agnostic autoregressive models (Uria et al., 2014) and absorbing discrete diffusion (Austin et al., 2021), which we show are special cases of ARDMs under mild assumptions. ARDMs are simple to implement and easy to train. Unlike standard ARMs, they do not require causal masking of model representations, and can be trained using an efficient objective similar to modern probabilistic diffusion models that scales favourably to highly-dimensional data. At test time, ARDMs support parallel generation which can be adapted to fit any given generation budget. We find that ARDMs require significantly fewer steps than discrete diffusion models to attain the same performance. Finally, we apply ARDMs to lossless compression, and show that they are uniquely suited to this task. Contrary to existing approaches based on bits-back coding, ARDMs obtain compelling results not only on complete datasets, but also on compressing single data points. Moreover, this can be done using a modest number of network calls for (de)compression due to the model's adaptable parallel generation. \end{abstract}

\section{Introduction}

\begin{figure}[b]
    \centering
    \vspace{-.3cm}
    \includegraphics[width=.9\textwidth]{figures/ao_ardm.pdf}
    \vspace{-.25cm}
    \caption{Generation of Autoregressive Diffusion Models for the generation order $\sigma= (3, 1, 2, 4)$. Filled circles in the first and third layers represent respectively the input and output variables, and the middle layer represents internal activations of the network.}
    \label{fig:overview}
\end{figure}
Deep generative models have made great progress in modelling different sources of data, such as images, text and audio. These models have a wide variety of applications, such as denoising, inpainting, translating and representation learning. A popular type of likelihood-based models are Autoregressive Models (ARMs). ARMs model a high-dimensional joint distribution as a factorization of conditionals using the probability chain rule. Although very effective, ARMs require a pre-specified order in which to generate data, which may not be an obvious choice for some data modalities, for example images. Further, although the likelihood of ARMs can be retrieved with a single neural network call, sampling from a model requires the same number of network calls as the dimensionality of the data.

Recently, modern probabilistic diffusion models have introduced a new training paradigm: Instead of optimizing the entire likelihood of a datapoint, a component of the likelihood bound can be sampled and optimized instead. Works on diffusion on discrete spaces \citep{sohldickstein2015diffusion,hoogeboom2021argmaxflows,austin2021structured} describe a discrete destruction process for which the inverse generative process is learned with categorical distributions. However, the length of these processes may need to be large to attain good performance, which leads to a large number of network calls to sample from or evaluate the likelihood with discrete diffusion.

In this work we introduce Autoregressive Diffusion Models (ARDMs), a variant of autoregressive models that learns to generate in any order. ARDMs generalize order agnostic autoregressive models and discrete diffusion models.  We show that ARDMs have several benefits: In contrast to standard ARMs, they impose no architectural constraints on the neural networks used to predict the distribution parameters. Further, ARDMs require significantly fewer steps than absorbing models to attain the same performance. In addition, using dynamic programming approaches developed for diffusion models, ARDMs can be parallelized to generate multiple tokens simultaneously without a substantial reduction in performance. Empirically we demonstrate that ARDMs perform similarly to or better than discrete diffusion models while being more efficient in modelling steps. The main contributions of this paper can be summarized as follows: 1) We introduce ARDMs, a variant of order-agnostic ARMs which include the ability to upscale variables. 2) We derive an equivalence between ARDMs and absorbing diffusion under a continuous time limit. 3) We show that ARDMs can have parallelized inference and generation processes, a property that among other things admits competitive lossless compression with a modest number of network calls.

 
\section{Background}
ARMs factorize a multivariate distribution into a product of $D$ univariate distributions using the probability chain rule. In this case the log-likelihood of such as model is given by:
\begin{equation}
\small
    \log p(\vx) = \sum_{t=1}^{D} \log p(x_t | \vx_{<t}),
\end{equation}
where $\vx_{<t}$ is shorthand for $x_1, x_2, \ldots, x_{t-1}$. ARMs are trained by ensuring that the neural network has a triangular dependency structure, for instance implemented via causal masking. Although this allows parallelized computation of the likelihood for all conditional distributions at once, to sample from the model it requires $D$ iterative sampling steps $x_1 \sim p(x_1), x_2 \sim p(x_2 | x_1)$ towards $x_D \sim p(x_D | x_1, x_2, \ldots, x_{D-1})$. 


\textbf{Order Agnostic ARMs} \hspace{.2cm}
\noindent Order Agnostic ARMs (OA-ARMs) \citep{uria2014adeeptractable} generate variables with a random ordering $\sigma \in S_D$, where $S_D$ represents a set of all permutations of the integers $1, \ldots, D$. The log-likelihood of this model is given by: 
\begin{equation}
\small
\log p(\vx) \geq \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} \sum_{t=1}^{D} \log p(x_{\sigma(t)} | \vx_{\sigma(<t)}).
\label{eq:ao_arm_standard}
\end{equation}
This can be seen as a latent variable model and the log-likelihood is derived via Jensen's inequality:
$$\log p(\vx) = \log \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} p(\vx | \sigma) \geq \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} \log p(\vx | \sigma).$$ 
Mind that hereafter we leave out $\sigma$ in our notation to avoid clutter.
One approach to train OA-ARMs is the procedure as described by \citet{yang2019xlnet} for XLNet. It takes a permutation equivariant network such as a Transformer that is causally masked. Then, inputs are permuted and outputs are permuted back according to a given order, which models the sequence in that specific order. However, such approaches typically suffer in likelihood score and cannot be combined with simple non-equivariant transformations such as convolutional layers.

\textbf{Discrete Diffusion} \hspace{.2cm}
Discrete diffusion models define a destruction process on discrete data. An example is absorbing diffusion \citep{austin2021structured}, for which each variable has a probability of decaying to an absorbing state. The opposite process to the destruction process is the learned \textit{generative process}. This generative process models the distribution over variables that are currently absorbed, and generates these with a probability.

 
\section{Autoregressive Diffusion Models}
\label{sec:autoregressive_diffusion_models}
We introduce Autoregressive Diffusion Models (ARDMs). ARDMs generate variables in an \textit{arbitrary order}, one by one. Further, ARDMs are able to \textit{upscale} variables, such as the bit values of a pixel. Unlike standard ARMs, ARDMs are trained on a \textit{single} step in the objective, as in modern diffusion models. In addition, both sampling and inference of ARDMs can be parallelized using dynamic programming with minimal degradation in log-likelihood. 

\textbf{Order Agnostic ARDMs} \hspace{.2cm} The main difficulty of parameterizing an autoregressive model from an engineering perspective, is the need to enforce the triangular or causal dependence. Especially for 2D signals, this triangular dependence is difficult to enforce for arbitrary orders \citep{jain2020locallymasked} and tedious design is needed for multi-scale architectures \citep{salimans2017pixelcnnpp}. To relax this requirement, we take inspiration from modern diffusion-based generative models. Using these insights, we derive an objective that is only optimized for a single step at a time. Starting at Equation~\ref{eq:ao_arm_standard}, a different objective for an order agnostic ARM can be derived, by replacing the summation over $t$ by an expectation that is appropriately re-weighted:
\begin{align*}
\small
\log p(\vx) &\geq \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} \textstyle\sum_{t=1}^{D} \log p(x_{\sigma(t)} | \vx_{\sigma(<t)}) \\ 
    &= \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} D \cdot \mathbb{E}_{t \sim \mathcal{U}(1, \ldots, D)}  \log p(x_{\sigma(t)} | \vx_{\sigma(<t)}) \\
     &= D \cdot \mathbb{E}_{t \sim \mathcal{U}(1, \ldots, D)} \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} \frac{1}{D - t + 1} \textstyle\sum_{k \in \sigma(\geq t)} \log p(x_{k} | \vx_{\sigma(<t)})
\end{align*}
Compactly, we can write the expected lower bound as:
\begin{equation*}
\small
\log p(\vx) \geq \mathbb{E}_{t \sim \mathcal{U}(1, \ldots, D)}[D \cdot \mathcal{L}_t], \text{ where } \mathcal{L}_t = \frac{1}{D - t + 1} \mathbb{E}_{\sigma \sim \mathcal{U}(S_D)} \sum_{k \in \sigma(\geq t)} \log p(x_{k} | \vx_{\sigma(<t)}).
\end{equation*}
Here the term $\mathcal{L}_t$ represents the likelihood component for step $t$. Importantly, we do not need to optimize for all $\mathcal{L}_t$ terms of a datapoint simultaneously. Instead, for each datapoint in a minibatch a single $\mathcal{L}_t$ term is optimized where $t$ is sampled from a uniform distribution. This objective was originally proposed by \citet{uria2014adeeptractable} to train order-agnostic ARMs. We will develop ARDMs starting from this perspective and refer to the special case of an order-agnostic ARM, as an order agnostic ARDM (OA-ARDM). Interestingly, each $\mathcal{L}_t$ component can be seen as a BERT-like training objective \citep{devlin2019bert}, where exactly $D-t+1$ tokens are masked and subsequently predicted. Therefore, an OA-ARDM is trained as a collection of $D$ BERTs with loss terms $\mathcal{L}_t$, which contain the reweighting term $\frac{1}{D - t + 1}$. Another insight is that this generative process is very similar to absorbing diffusion, where the model aims to generate absorbed (or masked) variables. In certain situations we might want to refer to loss terms instead of likelihood terms, so we define $L_t = - \mathcal{L}_t$. 

\begin{table}
\vspace{-.3cm}
\begin{minipage}[t]{.47\textwidth}
\begin{algorithm}[H]
   \caption{Sampling from OA-ARDMs}
   \label{alg:sample_ardms}
\begin{algorithmic}
\STATE {\bfseries Input:} Network $f$
   \STATE {\bfseries Output:} Sample $\vx$
\STATE Initialize $\vx = \mathbf{0}$
\STATE Sample $\sigma \sim \mathcal{U}(S_D)$
\FOR{$t$ in $\{1, \ldots, D\}$}
\STATE $\vm \leftarrow (\sigma < t)$ \text{ and } $\vn \leftarrow (\sigma = t)$
    \STATE $\vx' \sim \mathcal{C}(\vx | f(\vm \odot \vx))$ 
    \STATE $\vx \leftarrow  (1 - \vn) \odot \vx + \vn \odot \vx'$
\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{.47\textwidth}
\begin{algorithm}[H]
   \caption{Optimizing OA-ARDMs}
   \label{alg:optimize_ardms}
\begin{algorithmic}
   \STATE {\bfseries Input:} Datapoint $\vx$, Network $f$
   \STATE {\bfseries Output:} ELBO $\mathcal{L}$
\STATE Sample $t \sim \mathcal{U}(1, \ldots, D)$
\STATE Sample $\sigma \sim \mathcal{U}(S_D)$
\STATE Compute $\vm \leftarrow (\sigma < t)$
\STATE $\vl \leftarrow (1 - \vm) \odot \log \mathcal{C}(\vx | f(\vm \odot \vx))$
\STATE $\mathcal{L}_t \leftarrow  \frac{1}{D - t + 1} \operatorname{sum} (\vl)$
\STATE $\mathcal{L} \leftarrow D \cdot \mathcal{L}_t$
\end{algorithmic}
\end{algorithm}
\end{minipage}
\vspace{-.5cm}
\end{table}


\begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    \vspace{-.2cm}
    \includegraphics[width=.22\textwidth]{figures/ardm_training.pdf}
    \vspace{-.1cm}
    \caption{ARDM training step. This step optimizes for step $t = 2$ for all possible permutations $\sigma$ simultaneously which satisfy $\sigma(1) = 3$.}
    \label{fig:training-step}
    \vspace{-.3cm}
\end{wrapfigure}

\textbf{Parametrization} \hspace{.2cm}
We desire a parametrization for the model distribution $\log p(x_k | \vx_{\sigma(<t)})$ for $k \in \sigma(\geq t)$ for all $\sigma$ and $t$. For each $\sigma$ and $t$ it is in principle allowed to have an entirely new neural network. However, this would be very inconvenient as the number of $t$ grows as $\mathcal{O}(D)$ and the number of $\sigma$ grows as $\mathcal{O}(D!)$. Instead, a single neural network is utilized and shared for different $\sigma$ and $t$. This is implemented by masking variables at the input, and predicting those at the output. To be precise, we let $\vx \in \mathcal{X} = \{1, 2, \ldots, K\}^D$ represent discrete variables with $K$ classes and a neural network $f: \mathcal{X} \to \mathbb{R}^{D \times K}$ that outputs probability vectors for each dimension. Conditioning is done via masking: For a given permutation array $\sigma$, we compute the elementwise comparison $\vm = \sigma < t$ which produces a Boolean mask. The mask is then used by predicting $\boldsymbol{\theta} = f(\vm \odot \vx)$, where $\odot$ denotes element-wise multiplication. For each location $k \in \sigma(\geq t)$, the log probability vectors $\boldsymbol{\theta}_k$ are used. Letting $\mathcal{C}(x_k | \boldsymbol{\theta}_k)$ denote a categorical distribution over $x_k$ with class probabilities $\boldsymbol{\theta}_k$, we choose to model $\log (x_k | \vx_{\sigma(<t)}) = \log \mathcal{C}(x_k | \boldsymbol{\theta}_k)$. The locations of these relevant indices $k \in \sigma(\geq\! t)$ are retrieved by using the opposite mask $\boldsymbol{1} - \vm$. The procedure to sample and optimize an ARDM with this parametrization are given in Algorithms~\ref{alg:sample_ardms} and \ref{alg:optimize_ardms}. A training step is visualized in Figure~\ref{fig:training-step}. Note that opposed to Figure~\ref{fig:overview} where only a single output was used per step, in the train step all dimensions that were masked are predicted simultaneously. Therefore, there are multiple variables to predict which ensures there is sufficient signal to optimize the model.


For clarity some of the implementation details have been left out in the explanation above. However, given that these are important for practical implementations, they are specified in the following. The input to the function $f$ may be different depending on the data modality: For images and audio, the mask is applied to the input so that values are zero \textit{after} feature normalization. The mask itself is also concatenated to the input as an input representation, which allows the model to identify whether a value is actually zero, or the value is in the absorbing state zero. For language the input representation is augmented and absorbed values are instead set to a new class $K + 1$, in which case there is no need to provide the mask itself as input to the model. More generally, we can represent the masked state as an absorbing state vector $\va$ which has the same shape as $\vx$ but only contains a pre-specified value. The input to the network is then not the masked $\vm \odot \vx$, but instead the combination $\vm \odot \vx + (1 - \vm) \odot \va$. In addition, the network $f$ may also take the time component $t$ as input as is typically done in diffusion models \citep{ho2020denoising}. In summary the network takes some additional inputs as $\boldsymbol{\theta} = f(\vi, \vm, t)$ where $\vi = \vm \odot \vx + (1 - \vm) \odot \va$ and the processing of $\vx$ may be different depending on the type of data.

\begin{figure}[b]
    \vspace{-.1cm}
    \centering
    \includegraphics[width=.9\textwidth]{figures/parallel.pdf}
    \vspace{-.2cm}
    \caption{Loss components for Parallelized ARDMs using a budget of $5$ steps for a problem of $20$ steps. Left: individual loss component for every step. Right: parallelized policy extracted from the dynamic programming algorithm. Components of the same height are modelled simultaneously, so they are inferred and generated in parallel.}
    \label{fig:parallel_l_t}
    \vspace{-.3cm}
\end{figure}

\subsection{Parallelized ARDMs}
An important property of our parametrization is that the distribution over multiple variables is predicted at the same time. In this section, we will leverage this parameterization to allow parallel independent generation of variables. Essentially, we desire distributions over $x_{\sigma(t+k)}$ for positive $k$ while conditioning only on $\vx_{\sigma(<t)}$. First we make an observation regarding a connection between predicting future variables and our likelihood terms: For $k = 1, 2, \ldots, D - t$:
\begin{equation} \small
\mathbb{E}_{\sigma} \big{[}\log p(x_{\sigma(t + k)} | \vx_{\sigma(<t)}) \big{]} = \mathbb{E}_{\sigma} \big{[}\log p(x_{\sigma(t)} | \vx_{\sigma(<t)}) \big{]} =  \mathcal{L}_t,
\end{equation}
due to the uniform expectation over permutations. In other words, it does not matter which step $t+k$ the model predicts, in expectation these all have the same associated likelihood. As a result, order agnostic generation of $k$ tokens independently, starting from the $t$-th variable will result in a log-probability contribution of $k \cdot\mathcal{L}_t$ in a single step, whereas the traditional approach would take $k$ steps at the cost of $\sum_{i=1}^k \mathcal{L}_{t+i}$. 
This knowledge is sufficient to construct a dynamic programming algorithm as described by \citet{watson2021learningefficientlysample} to compute how many parallel steps to take at which moment, given a budget. Since dynamic programming is typically described from a minimization perspective we define the loss component $L_t = -\mathcal{L}_t$, which is measured in bits. In terms of loss, generating $k$ variables at timestep $t$ will cost $k \cdot L_t$ bits. Further, we define the transition cost matrix $\mathbf{L}_{t,t+k} = k \cdot L_t$ for positive integers $k$ and $\mathbf{L}_{t+k,t} = 0 $ otherwise. So $\mathbf{L}_{t,t+k}$ exactly describes how much it costs to model the next $k$ variables in parallel starting at the $t$-th position for all relevant $t$ and $k$. Using this transition cost matrix, the dynamic programming algorithm can be utilized to find which steps should be parallelized. For instance, in the example in Figure \ref{fig:parallel_l_t} a hypothetical 20-step problem is given a budget of 5 steps. Typically, the algorithm will spend more steps on regions with large differences between $L_t$ components and fewer steps on regions where the $L_t$ components are approximately equal. Parallelizing an ARDM may incur some cost, as for a well-calibrated model:
\begin{equation}
\label{eq:monotonicity_start} \small
\mathcal{L}_t = \mathbb{E}_{\sigma} \big{[}\log p(x_{\sigma(t + 1)} | \vx_{\sigma(<t)}) \big{]} \leq \mathbb{E}_{\sigma} \big{[}\log p(x_{\sigma(t + 1)} | \vx_{\sigma(<t+1)})\big{]} =  \mathcal{L}_{t+1}, 
\end{equation}
but can be traded off for faster generation because fewer steps are used. In other words, the \textit{loss} components $L_t$ are monotonically \textit{decreasing} over $t$ and parallelizing a model incurs a cost, which the algorithm aims to minimize. Recall that this is under the assumption that model is well-calibrated, which is observed in practice. See Figure~\ref{fig:parallel_l_t} for an example of a parallelized schedule.


\subsection{Depth Upscaling ARDMs}
Order agnostic ARDMs learn to generate variables in random order. As a result, decisions on very detailed information (such as the least significant bit in an image) are modelled relatively early in the generative process. Instead, we can structure the process into stages, where for each stage a refinement of the variable is generated. We refer to this process as \textit{upscaling}. For example, instead of generating an entire $256$-categorical variables at once, we can first generate the most significant bit, and then the subsequent bits in order of significance. To define the process, it is helpful to first imagine the opposite process to upscaling, which is the destructive process \textit{downscaling}. Formally, we can define maps via transition matrices $\mathbf{P}^{(i)}$ that define how a data variable downscales from its data value towards a common absorbing state. For simplicity assume single dimensional variables at this moment. Denote the absorbing state as a one-hot vector $\vx^{(0)}$, where all values are zero except at a prespecified index $a$ so that $x^{(0)}_a = 1$. From a diffusion perspective, upscaling is complementary to a downscaling destruction process where each variable decays by zeroing its least significant bit.

Let $\mathbf{P}^{(1)}, \ldots, \mathbf{P}^{(S)}$ define a sequence of downscaling maps so that for any categorical one-hot data variable $\vx^{(S)} \in \{0, 1\}^{K}$, it holds that $\mathbf{P}^{(1)} \cdot \ldots \cdot \mathbf{P}^{(S)} \cdot \vx^{(S)} = \vx^{(0)}$. In other words, any category $K$ decays to the common absorbing state after $S$ downscaling maps. We now define the \textit{upscaling} generative process by learning the reverse of the downscaling map, specifically by modelling $p(\vx^{(S)} | \vx^{(S-1)}) \cdot \ldots \cdot p(\vx^{(2)} | \vx^{(1)}) p(\vx^{(1)})$. The transition matrices allow easy transitions between the different stage variable $\vx^{(i)}$ via the following rules:
$$\vx^{(s)} = \mathbf{P}^{(s+1)} \vx^{(s+1)} = \overline{\mathbf{P}}^{(s+1)} \vx^{(S)}, \quad \text{ where } \quad \overline{\mathbf{P}}^{(s)} = \mathbf{P}^{(s)} \cdot \mathbf{P}^{(s+1)} \cdot \ldots \cdot \mathbf{P}^{(S)}.$$
The matrices $\overline{\mathbf{P}}^{(i+1)}$ are computed as cumulative matrix multiplications, and allow a transition directly from a datapoint $\vx^{(S)}$ to the corresponding downscaled variable $\vx^{(i)}$. This is particularly useful during training, where the model will only be optimized for a single specific stage per datapoint. For implementations it is generally useful to define $\overline{\mathbf{P}}^{(S+1)} = \mathbf{I}$ as an identity matrix so that the above equation also holds when $s = S$. To train Upscale ARDMs, we can extend Algorithm~\ref{alg:optimize_ardms}: In addition to sampling a timestep $t$, a stage $i \sim \mathcal{U}(1, \ldots, S)$ to optimize is sampled. For this particular stage, the ARDM models $p(\vx^{(s)} | \vx^{(s-1)})$ by sampling a permutation $\sigma$ within the stage and a timestep $t$ within the stage. Every term $p(\vx^{(s)} | \vx^{(s-1)})$ represents a stage that is modelled with an order agnostic ARDM. This highlights an interesting property of ARDMs: Although sampling from a model may take up to $D \cdot S$ steps, the training complexity has not changed by modelling multiple stages. As a result, one can experiment with adding an arbitrary number of stages without an increase in computational complexity during training. Depth upscaling is reminiscent of the upscaling networks proposed in \citep{kalchbrenner2018efficientneural,menick2019SPN}, with the important differences that Upscale ARDMs model the variables order-agnostic and only utilize a single neural network to parametrize all stages. For a more detailed explanation that includes the dimensionality of the variables $\{\vx^{(s)}\}$ see Appendix~\ref{app:details_ardm}.

\textbf{Bit Upscaling} \hspace{.2cm}
Depth upscaling is easiest demonstrated with an example, \textit{bit}-upscaling. Consider the task of generating a standard image with pixel values $\{0, \ldots, 255\}$ so that an image with $D$ dimensions can be represented by $\vx^{(8)} \in \{0, 1\}^{D \times 256}$ in onehot notation.
Imagine a downscaling process defined by the function that removes the $i$ least significant bits: $\mathrm{lsb}_s(k) = \lfloor k / 2^s \rfloor \cdot 2^s$, via this function we can define our transition matrices:
$$P_{l,k}^{(8 + 1 - s)} = 1 \quad \text{ if } \quad l = \mathrm{lsb}_{s}(k) \text{ and } k \in \mathrm{Im}(\mathrm{lsb}_{s-1}) \quad \text{ otherwise } \quad P_{l,k}^{(8 + 1 - s)} = 0,$$
where $\{\mathbf{P}^{(s)}\}$ are indexed starting at zero. Notice that in this case $8$ stages to map every value to the absorbing state $0$, because $\mathrm{lsb}_8(k) = 0$ for any $k \in \{0, \ldots, 255\}$. See Figure~\ref{fig:upscaling} for a visualization of such matrices for a problem with less categories.

\begin{figure}[H]
    \vspace{-.1cm}
    \centering
    \includegraphics[width=.8\textwidth]{figures/upscaling.pdf}
    \vspace{-.3cm}
    \caption{Bit upscaling matrices for data with eight categories and hence three stages, meaning $S = 3$. Entries that are white represent zeros, coloured entries represent ones.}
    \label{fig:upscaling}
    \vspace{-.3cm}
\end{figure}

Depth upscaling is not confined to bits, and indeed a more general formulation is given by the downscaling map $l = \lfloor k / b^s \rfloor \cdot b^s$, for a branching factor $b$. When $b$ is set to $2$, the bit upscaling transitions are retrieved as a special case. When $b$ is set to higher values, then variables can be generated in fewer stages, $S = \lceil \log_b (K) \rceil$ to be exact. This allows for a unique trade-off between the number of steps the model takes and the complexity that each modelling step inhibits. Other hand-crafted transitions are also imaginable, not excluding transitions that augment the space to new categories, but these are not considered in this paper.

\textbf{Parametrization of the Upscaling Distributions} \hspace{.2cm}
Although it is now defined how a datapoint $\vx^{(S)}$ downscales to $\vx^{(S-1)}, \ldots, \vx^{(1)}$ and to its absorbing state $\vx^{(0)}$, it is not immediately clear to parametrize the distributions $p(\vx^{(s)} | \vx^{(s-1)})$. Two methods can be used to parametrize the distribution. The first is a \textit{direct parametrization}. In the example of the bit-upscaling model above, one models the $s$-th significant bits given the $(s-1)$-th significant bits. The direct parametrization is generally more computationally efficient, as it requires only distribution parameter outputs that are relevant for the current stage. This is especially useful when the number of classes is large (such as with audio, which has $2^{16}$ classes). However, it can be somewhat tedious to figure out exactly which classes are relevant and should be modelled.

Alternatively we can use a \textit{data parametrization} which is similar to the parametrization in \citet{austin2021structured}. An important difference with their work is that the downscaling matrices $\mathbf{P}^{(s)}$ represent deterministic maps while theirs represent a stochastic process. For this parametrization, the network $f$ outputs a probability vector $\boldsymbol{\theta}$ that matches the shape of the data $\vx^{(S)}$, which transformed and converted to the relevant probabilities in stage $s$ via:
\begin{equation*}
\small
\boldsymbol{\theta}^{(s)} = \frac{{\mathbf{P}^{(s)}}^\mathrm{T} \vx^{(s-1)} \odot \overline{\mathbf{P}}^{(s+1)} \boldsymbol{\theta}}{{\vx^{(s-1)}}^\mathrm{T} \overline{\mathbf{P}}^{(s)} \boldsymbol{\theta}} \quad \text{ where } \quad p(\vx^{(s)} | \vx^{(s-1)}) = \mathcal{C}(\vx^{(s)} | \boldsymbol{\theta}^{(s)}).  
\end{equation*}
The advantage of this parametrization is that one only has to define the transition matrices $\{ \mathbf{P}^{(s)} \}$. As a result, the appropriate probabilities can be automatically computed which is ideal for experimentation with new downscaling processes. The disadvantage may be that modelling full probability vectors for problems with high number of classes may be expensive and not even fit in memory. Empirically in our experiments on image data we find that there is no meaningful performance difference between the two parametrizations.
 
\section{Related Work}
\textbf{Autoregressive Models} \hspace{.2cm}
Autoregressive Models (ARMs) factorize a joint distribution into a product of conditional distributions \citep{bengio2000takingcurse,larochelle2011nade}. 
Advances in deep learning have allowed tremendous progress
on various modalities, such as images \citep[][i.a.]{oord2016pixelrnn,child2019sparsetransformer}, audio \citep[][i.a.]{oord2016wavenet,kalchbrenner2018efficientneural}, and text \citep[][i.a.]{bengio2003neural,graves2013rnn,melis2018on,merity2018regularizing,brown2020language}, where for the latter they are referred to as language models.


Although evaluating the likelihood of a datapoint is generally efficient with ARMs, sampling requires an iterative process with as many network calls as the dimensionality of the data. Parallelized ARM approaches often rely either on cutting many dependencies in the conditioning \citep{reed2017parallel} which tend to suffer in log-likelihood. Alternatively, ARMs can be solved using fixed-point iteration algorithms in fewer steps without sacrificing log-likelihood \citep{wiggers2020predictive,song2021acceleratingparallel}, but these methods typically still require a large number of steps to converge. 


Order agnostic sequence modelling was introduced in \citep{uria2014adeeptractable} and utilizes the same objective as AO-ARDMs to optimize the model, operating by masking and predicting variables. Different from their method, ARDMs have more choices in absorbing states, parallelization support and depth upscaling techniques, in addition to modern advances to fit larger scale data. An alternative approach for order agnostic modelling is via causally masked permutation equivariant models such as Transformers \citep{yang2019xlnet,alcorn2021DEformer}, but these have had limited success in likelihood-based tasks. In \citep{ghazvininejad2019maskpredict} a mask predict method is proposed, although it does not contain a likelihood analysis. In other work, mixtures of ARMs over certain orders are trained by overriding convolutional routines for masking  \citep{jain2020locallymasked}. In a different context in \citep{liu2018constrainedgraph} graph edges connected to a node are modelled without order. However, the model is not entirely order agnostic because it models edges centered around focus nodes.


\textbf{Diffusion Models} \hspace{.2cm}
Diffusion models learn to denoise a Gaussian base distribution into the distribution of the data via a chain of latent variables \citep{song2019generativemodellingestimatinggradient,sohldickstein2015diffusion,ho2020denoising}. Diffusion and score-matching methods have shown large improvements in image \citep{dhariwal2021diffusionbeatgans} and audio sample quality \citep{chen2020wavegrad, kong2021diffwave}, as well as likelihood improvements with variational interpretations of diffusion models \citep{kingma2021vdm,huang2021variationalperspective}. Although faster sampling schedules for continuous diffusion models have been explored \citep{Jolicoeur2021gottagofast,kong2021onfastsampling}, little is known about shorter generative processes for discrete diffusion.

\textit{Discrete} diffusion models operate directly on discrete spaces. In \citet{sohldickstein2015diffusion} diffusion for binary data was proposed which was extended for categorical data in \citet{hoogeboom2021argmaxflows}. Whereas these approaches uniformly resample categories, in \citet{austin2021structured} a wide variety of transition distributions was proposed. This work finds that absorbing diffusion produces the best performing models in log-likelihood for text data, but these models still demand a large number of steps. OA-ARDMs are equivalent to the infinite time limit of absorbing diffusion, which makes them maximally expressive. Simultaneously, ARDMs upper bound the number of steps to the dimensionality of the data. More details on the connections between these model types are in Appendix~\ref{sec:diffusion_connection}. Other discrete diffusion processes have been explored in \citep{johnson2021beyondinplace}. 
 
\section{Results}
\label{sec:results}
\textbf{Order Agnostic Modelling} \hspace{.15cm}
To better understand how ARDMs compare to other order agnostic generative models, we study their performance on a character modelling task using the text8 dataset \citep{mahoney2011large}.
ARDMs are compared to D3PMs that model the inverse absorbing diffusion process \citep{austin2021structured}, and causally masked Transformers that are directly optimized on randomly permuted sequences as done in XLNet \citep{yang2019xlnet}. The different methods all use the same underlying neural network architecture which is the Transformer used in \citep{austin2021structured}, which has $12$ layers, $786$ hidden dimensions and $12$ heads. For the OA-Transformer baseline the architecture is causally masked, and inputs are permuted to model the sequence in a specific order. In addition to the standard positional embeddings for the input, the embeddings for the output are also concatenated to the token embedding. This can be seen as an implicit method to condition on the permutation that is currently generated. The specific hyperparameters of the optimization procedure are specified in Appendix~\ref{app:experimental_details} and are the same as reported in \citep{austin2021structured}, with the exception of a different learning rate schedule and further train steps.

\begin{table}
\vspace{-.6cm} \begin{minipage}[t]{.50\textwidth}
\centering
\begin{table}[H]
    \centering
    \caption{Order Agnostic model performance (in bpc) on the text8 dataset. The OA-Transformer learns arbitrary orders by permuting inputs and outputs as described in XLNet. A Transformer learning only a single order achieves $1.35$~bpc.}
    \vspace{-.2cm}
    \label{tab:text8_results}
    \scalebox{.83}{\begin{tabular}{l r l} 
    \toprule
    Model & Steps & \hspace{.1cm} NLL \\ \midrule
       OA-Transformer & 250 & \hspace{.1cm} 1.64 \\ 
       D3PM-uniform & 1000 & \hspace{.1cm} 1.61 {\scriptsize$\pm$0.020}\\
       D3PM-absorbing & 1000 & \hspace{.1cm} 1.45 {\scriptsize$\pm$0.020} \\
       D3PM-absorbing & \textbf{256} & \hspace{.1cm} 1.47 \\ 
       OA-ARDM (ours) & \textbf{250} & \hspace{.1cm} \textbf{1.43} {\scriptsize$\pm$0.001} \\ \midrule
       D3PM-absorbing & \textbf{20} & \hspace{.1cm} 1.56 {\scriptsize$\pm$0.040}\\
       Parallelized OA-ARDM (ours) & \textbf{20} & \hspace{.1cm} \textbf{1.51} {\scriptsize$\pm$0.007}\\ \bottomrule
    \end{tabular}}
\end{table}
\end{minipage}
\hfill
\begin{minipage}[t]{.47\textwidth}
\centering
\begin{table}[H]
    \centering
    \caption{Order Agnostic modelling performance (in bpd) on the CIFAR-10 dataset. The upscaling model generates groups of four most significant categories, equivalent to $2$ bits at a time.} 
    \vspace{-.2cm}
    \label{tab:cifar10_results}
    \scalebox{.83}{\begin{tabular}{l c l l} 
    \toprule
    Model & Steps & NLL \\ \midrule
       ARDM-OA & 3072 & 2.69 {\scriptsize$\pm$ 0.005} \\
       Parallel ARDM-OA & 50 & 2.74 \\ \midrule
       ARDM-Upscale 4 & 4 $\times$ 3072 & \textbf{2.64} {\scriptsize$\pm$ 0.002} \\  
       Parallel ARDM-Upscale 4 & 4 $\times$ 50 & 2.68 \\ \midrule
       D3PM Absorbing & 1000 & 4.40 \\
       D3PM Gaussian & 1000 & 3.44 {\scriptsize$\pm$ 0.007}\\ \bottomrule
    \end{tabular}}
\end{table}
\end{minipage}
\vspace{-.45cm} \end{table}

Performance of these methods is presented in Table~\ref{tab:text8_results}. Firstly, the OA-Transformer baseline does not perform very well compared to the other models. This result matches the behaviour that was found by \citet{yang2019xlnet}, who observed underfitting behaviour and limited the task complexity by only predicting a subset of the permuted tokens. Further, as expected the performance of our OA-ARDM with 1.43~bpc is very close to the performance of D3PM-absorbing at $1000$ steps with $1.45$ bpc. This is expected, since OA-ARDMs are equivalent to the continuous time limit of D3PM-absorbing models. For sequences containing only $250$ dimensions, the D3PM schedule with $1000$ steps starts to approximate the jump process where generally only a single variable is absorbed at a time. The important takeaway from this comparison is that OA-ARDMs perform similar to large-steps D3PM absorbing models \textit{while only requiring a quarter of the steps}. When the D3PM model is forced to take $256$ steps which is comparable to our OA-ARDM model, then its performance degrades further towards $1.47$~bpd. In addition, a Parallelized ARDM with only $20$ steps has a performance of $1.51$ bpd over a similar D3PM which has $1.56$~bpd. This pattern translates to CIFAR-10 \citep{krizhevsky2009learning} where ARDMs also outperform D3PMs and degrade more gracefully under fewer steps. This comparison to D3PM is however less direct, as the underlying architectures differ.

\begin{figure}
    \centering
    \vspace{-.2cm}
    \includegraphics[width=.999\textwidth]{figures/samples/chain_upscale_4.pdf}
    \vspace{-.65cm}
    \caption{Visualization of $\vx$ through the generative process for an ARDM Upscale 4 model.}
    \label{fig:chain}
    \vspace{-.5cm}
\end{figure}


\textbf{Lossless Compression} \hspace{.2cm}
To validate that ARDMs can form a viable basis for practical neural network-based compressors, we study their performance when compressing CIFAR-10 images and comparing them to existing methods. Since ARDMs provide probabilities for a sequence of symbols, they can be directly used together with an off-the-shelf entropy coder for lossless compression. In this experiment we use the range-based entropy coder rANS \citep{duda2009asymmetric}. To use ARDMs the order of the coding process needs to be fixed for all images. To avoid an unlucky sample, before coding we evaluate the log-likelihood of a few random permutations on the train set and pick the best performing one. Empirically, there is very little difference in performance ($<\!0.02$ bpd) between different permutations. 

Several deep learning based lossless compression methods in literature rely on bits-back coding \citep{townsend2019bitsback}, such as LBB \citep{ho2019localbitsback}, HiLLoC \citep{townsend2020hilloc} and VDM \citep{kingma2021vdm}. Although bits-back coding methods can perform well on large datasets, they have a large overhead when used as per-image compressors. This is caused by the large number of initial bits that are required. Further, the dataset is often interlinked, meaning that if an image in the middle of the dataset needs to be accessed, it requires all images earlier in the bitstream to also be decompressed. Therefore per-image compression is important for practical applications, because it is desirable to be able to send a specific image without sending an entire dataset. On the other hand, direct compressors such as L3C \citep{mentzer2019practicallossless}, IDF \citep{hoogeboom2019integer} and IDF++ \citep{vdberg2021idfanalyzing} do not incur an intial message overhead and their dataset performance translates directly to per-image compression. A more conventional codec is FLIF \citep{sneyers2016flif}, which is a recent lossless compression codec with machine learning components that outperforms traditional codecs such as PNG.

Performance of ARDMs and related methods in literature is presented in Table~\ref{tab:cifar10_compression_results}. ARDMs significantly outperform all methods on compression per image, requiring only $2.71$ bpd versus $3.26$ for the next best performing model, IDF++. In addition, even compared to a setting where an entire dataset needs to be compressed, ARDMs perform competitively to VDM, which attain $2.72$~bpd. Moreover, ARDMs degrade more gracefully when fewer steps are used to encode the data.


\begin{table}
    \centering
    \caption{CIFAR-10 lossless compression performance (in bpd).}
    \vspace{-.3cm}
    \label{tab:cifar10_compression_results}
    \scalebox{.85}{\begin{tabular}{l c c c c} 
    \toprule
    Model & Steps & Compression per image & Dataset compression \\ \midrule
       VDM \citep{kingma2021vdm} & 1000 & $\geq$ 8 & 2.72 \\
       VDM \citep{kingma2021vdm} & 500 &  $\geq$ 8 & 2.72 \\
       OA-ARDM (ours) & 500 & 2.73 & 2.73 \\
       ARDM-Upscale 4 (ours) & 500 & \textbf{2.71} & \textbf{2.71} \\ \midrule
       VDM \citep{kingma2021vdm} & 100 & $\geq$ 8 & 2.91 \\
       OA-ARDM (ours) & 100 & 2.75 & 2.75 \\
       ARDM-Upscale 4 (ours) & 100 & 2.76 & 2.76 \\
       \midrule
       LBB \citep{ho2019localbitsback} & & $\geq$ 8 & 3.12 &  \\ 
       IDF \citep{hoogeboom2019integer} & & 3.34 & 3.34 \\
       IDF++ \citep{vdberg2021idfanalyzing} & & 3.26 & 3.26 & \\ 
       HiLLoC \citep{townsend2020hilloc} & & 4.19 & 3.56 & \\ 
       FLIF \citep{sneyers2016flif} & & 4.19 & 4.19 & \\\bottomrule 
    \end{tabular}}
    \vspace{-.3cm}
\end{table}

Note that the lossless compressor based on VDM was trained on non-augmented data, whereas the best-performing likelihood model of \citet{kingma2021vdm} was trained with data augmentation. As a result, it is likely that their dataset compression results could be somewhat improved when trained on augmented CIFAR-10. Also, it is not a coincedence that HiLLoC and FLIF have the exact same compression per image performance. HiLLoC compresses the first few images using the FLIF format to fill the initial bitstream, and compresses the remaining images in the dataset with bits-back coding \citep{townsend2020hilloc}. As a result, on a per-image compression benchmark the method is equivalent to FLIF. 




\textbf{Effects of Depth-Upscaling} \hspace{.2cm}
A natural question that might arise is how standard order-agnostic modelling performs compared to order agnostic bit-upscaling, and how bit-upscaling compares to the upscaling with larger values. Due to the constant training complexity of ARDMs, one can easily train models that have generative processes of arbitrary length. To test this, we train ARDMs on image data from CIFAR-10 and audio data from SC09 \citep{speechcommandsv2}. For the audio data, the total number of categories is $2^{16}$, which is typically too large in terms of memory to model as a single softmax distribution. For that reason, the single stage OA-ARDM is trained using a discretized logistic distribution because it is computationally cheaper for a high number of categories. For the same reason, the Upscale ARDMs for audio can only be trained using the direct parametrization, whereas for images they are trained with the data parametrization. 


For images, the best performing model has an upscaling factor of $4$ with $2.64$~bpd (see Table~\ref{tab:depth_upscaling_cifar10}) and for audio the best performing model upscales by a factor of $2$ or $4$ with $6.29$~bpd (see Table~\ref{tab:depth_upscaling_sc09}). The hypothesis is that as the upscale factor becomes smaller, the generative process generally becomes more structured and easier to model. However, although for audio this pattern is consistently observed, for images an upscale factor of $4$ has better performance than an upscale factor of $2$. It is possible that for certain data, at some point smaller upscale factors give diminishing returns for performance. We hypothesize that by prolonging the generative process, the model may get less gradient signal per optimization step, leading to the decreased performance of smaller upscale factors in some situations.


\begin{table}
\vspace{-.3cm}
\begin{minipage}{.48\textwidth}
\centering
\begin{table}[H]
    \centering
    \caption{Audio (SC09) depth upscaling test set performance (in bpd). A WaveNet baseline learning only a single order achieves $7.77$~bpd.}
    \label{tab:depth_upscaling_sc09}
    \vspace{-.2cm}
    \scalebox{.9}{\begin{tabular}{l c c c c} 
    \toprule
    Model  & Steps & Performance\\ \midrule
      OA-ARDM & $D = 16000$ & 7.93 \\ \midrule
      ARDM Upscale 256 & $2 \times D$ & 6.36 \\ 
      ARDM Upscale 16 &  $4 \times D$ & 6.30  \\ 
      ARDM Upscale 4 &  $8 \times D$ & \textbf{6.29} \\ 
      ARDM Upscale 2 &  $16 \times D$ & \textbf{6.29} \\ \bottomrule 
    \end{tabular}}
\end{table}
\end{minipage}
\hfill
\begin{minipage}{.48\textwidth}
\centering
\begin{table}[H]
    \centering
    \caption{Image (CIFAR-10) depth upscaling performance (in bpd).}
    \label{tab:depth_upscaling_cifar10}
    \vspace{-.2cm}
    \scalebox{.92}{\begin{tabular}{l c c }
    \toprule
    Model & Steps & Performance  \\ \midrule
       OA-ARDM & $D = 3072$  & 2.69 \\ \midrule
       ARDM Upscale 16 &  $2 \times D$ & 2.67 \\
       ARDM Upscale 4 &  $4 \times D$ & \textbf{2.64} \\
       ARDM Upscale 2 &  $8 \times D$ & 2.67 \\ \bottomrule
    \end{tabular}}
\end{table}
\end{minipage}
\vspace{-.7cm}
\end{table}

 
\section{Limitations and Conclusion}
Notwithstanding the good results in this paper, there are some limitations to ARDMs. 1) Even though ARDMs outperform all other order-agnostic approaches on text, there is still a gap to the performance of single-order autoregressive models. In preliminary experiments, upscale variants for language did not perform better than the order-agnostic versions. 2) In the current description, ARDMs model discrete variables. In principle one could also define absorbing processes for continuous distributions. 3) Finally, in this work we have focused on optimizing for log-likelihood, because it directly corresponds to coding length in lossless compression. However when optimizing for other objectives such as sample quality, different architectural choices may give better results.

In conclusion, we introduced ARDMs, a new class of models at the intersection of autoregressive models and discrete diffusion models. ARDMs perform competitively with existing generative models, and outperform competing approaches on per-image lossless compression.  
























































































































\section*{Reproducibility and Ethics Statement}
To ensure the work is as reproducible as possible, in this paper we have described in detail both the training algorithms and the sampling algorithms. The main ideas are presented in Section~\ref{sec:autoregressive_diffusion_models}, and further clarifications that may be important for re-implementation are given in Appendix~\ref{app:details_ardm}. The hyperparameter settings to run experiments are presented in Section~\ref{sec:results} and further clarified in Appendix~\ref{app:experimental_details}. In addition, we plan to release the code that can be used to reproduce the experimental results in this paper.

In terms of ethics, we do not see immediate concerns for the models we introduce. However, deep generative models have a wide variety of applications such as representation learning, image inpainting, special effects in video, outlier detection and drug design. On the other hand, the generation of images, text and video may have negative downstream applications such as making false media seem realistic. Further, to the best of our knowledge no datasets were used that have known ethical issues.





\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\newpage
\appendix

\newpage
\section{Further Details of Autoregressive Diffusion}
\label{app:details_ardm}

Next to given descriptions, the implementation has been open-sourced at \url{https://github.com/google-research/google-research/tree/master/autoregressive_diffusion}.


\subsection{Depth Upscaling}
This section explains further details that are important to optimize and sample from Depth Upscaling ARDMs, which are summarized in Algorithm~\ref{alg:sample_upscale_ardms} and~\ref{alg:optimize_upscale_ardms}. Recall that for depth-upscaling models, the variables are modelled in stages $\vx^{(1)}, \ldots, \vx^{(S)}$ and the model learns $p(\vx^{(S)}|\vx^{(S-1)}), \ldots, p(\vx^{(1)} | \vx^{(0)})$. Here $\vx^{(0)}$ is a constant absorbing state and $\vx^{(S)}$ represents the data. The transition matrices $\{\mathbf{P}^{(s)}\}$ describe the destructive maps which end up in the absorbing state. They form the destructive counterpart of the generative process.


Instead of optimizing for all stages simultaneously, we sample a stage uniformly $s \sim \mathcal{U}(1, \ldots, S)$ and optimize for that stage. Here the cumulative matrix products $\overline{\mathbf{P}}^{(s)}$ allow us to directly transition to a specific stage, since $\vx^{(s)} = \overline{\mathbf{P}}^{(s+1)} \vx^{(S)}$. To be precise, for a single dimension $i$ the variable $\vx_i^{(s)}$ is represented as a onehot vector and then transformed using the matrix multiplication $\vx_i^{(s)} = \overline{\mathbf{P}}^{(s+1)} \vx_i^{(S)}$. For multiple dimensions this matrix multiplication is applied individually, meaning that $\overline{\mathbf{P}}^{(s+1)} \vx^{(S)} = \big{(}\overline{\mathbf{P}}^{(s+1)} \vx_1^{(S)},\overline{\mathbf{P}}^{(s+1)} \vx_2^{(S)}, \ldots, \overline{\mathbf{P}}^{(s+1)} \vx_D^{(S)}\big{)} = (\vx_1^{(s)}, \ldots, \vx_D^{(s)}) = \vx^{(s)}$.


For a optimization step, a stage $s \sim \mathcal{U}(1, \ldots, S)$ and a step $t \sim \mathcal{U}(1, \ldots, D)$ are sampled, in addition to a permutation $\sigma \sim \mathcal{U}(S_D)$. Then using the cumulative matrices, from a datapoint $\vx = \vx^{(S)}$ the variables $\vx^{(s)}$ and $\vx^{(s-1)}$ are computed. As before, the mask $\vm = \sigma < t$ gives the locations of the variables that are conditioned on. For those locations the values in $\vx^{(s)}$ may already be accessed. For the opposite locations $1 - \vm$, instead the values from $\vx^{(s-1)}$ are accessed. This leads to the expression for the input $\vi = \vm \odot \vx^{(s)} + (1 - \vm) \odot \vx^{(s-1)}$. The target of the network will be to predict a distribution for $\vx^{(s)}$ at the locations at $1 - \vm$. The network will take in the computed input $\vi$ together with variables to clarify in which stage of the generative process the model is, $\vm$, $s$ and $t$. In case of the data parametrization, the probabilities $\boldsymbol{\theta}$ are appropriately normalized and reweighted to $\boldsymbol{\theta}^{(s)}$ using transitions $\{\mathbf{P}^{(s)}\}$. Then, the log probabilities $\log \mathcal{C}(\vx^{(s)} | \boldsymbol{\theta}^{(s)})$ are computed elementwise over dimensions and subsequently masked with $1 - \vm$. These quantities are then summed and reweighted to get a stochastic estimate for the ELBO.

For the sampling, the model traverses through each stage, and for each stage through every dimension in a different order. In each step the network together with the transition matrices produces a probability vector $\boldsymbol{\theta}^{(s)}$ from which elementwise samples are taken $\vx' \sim \mathcal{C}(\vx^{(s)} | \boldsymbol{\theta}^{(s)})$, but only the values at locations $\vn \leftarrow (\sigma = t)$ are filled in, corresponding to the current generation step. By traversing through all steps and stages, the variable $\vx^{(S)}$ is generated.
\begin{table}[h]
\begin{minipage}[t]{.47\textwidth}
\begin{algorithm}[H]
   \caption{Sampling from Upscale-ARDMs}
   \label{alg:sample_upscale_ardms}
\begin{algorithmic}
\STATE {\bfseries Input:} Network $f$
   \STATE {\bfseries Output:} Sample $\vx$
\STATE Initialize $\vx = \vx^{(0)}$
\FOR{$s$ in $\{1, \ldots, S\}$}
\STATE Sample $\sigma \sim \mathcal{U}(S_D)$
\FOR{$t$ in $\{1, \ldots, D\}$}
\STATE $\vm \leftarrow \sigma < t$
\STATE $\vn \leftarrow (\sigma = t)$
\STATE $\boldsymbol{\theta} \leftarrow f(\vx, \vm, s, t)$
\STATE $\boldsymbol{\theta}^{(s)} \propto {\mathbf{P}^{(s)}}^\mathrm{T} \vx \odot \overline{\mathbf{P}}^{(s+1)} \boldsymbol{\theta}$ 
    \STATE {$\vx' \sim \mathcal{C}(\vx^{(s)} | \boldsymbol{\theta}^{(s)})$ }
    \STATE $\vx \leftarrow  (1 - \vn) \odot \vx + \vn \odot \vx'$
\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{minipage}
\hfill
\begin{minipage}[t]{.47\textwidth}
\begin{algorithm}[H]
   \caption{Optimizing Upscale-ARDMs}
   \label{alg:optimize_upscale_ardms}
\begin{algorithmic}
   \STATE {\bfseries Input:} Datapoint $\vx$, Network $f$
   \STATE {\bfseries Output:} ELBO $\mathcal{L}$
\STATE Sample $s \sim \mathcal{U}(1, \ldots, S)$
\STATE Sample $t \sim \mathcal{U}(1, \ldots, D)$
\STATE Sample $\sigma \sim \mathcal{U}(S_D)$
\STATE $\vx^{(s)}  \leftarrow \overline{\mathbf{P}}^{(s+1)} \vx$ and $\vx^{(s-1)}  \leftarrow \overline{\mathbf{P}}^{(s)}\vx$
\STATE Compute $\vm \leftarrow  \sigma < t$
\STATE $\vi \leftarrow \vm \odot \vx^{(s)} + (1 - \vm) \odot \vx^{(s-1)}$
\STATE $\boldsymbol{\theta} \leftarrow f(\vi, \vm, s, t)$
\STATE $\boldsymbol{\theta}^{(s)} \propto {\mathbf{P}^{(s)}}^\mathrm{T} \vx^{(s-1)} \odot \overline{\mathbf{P}}^{(s+1)} \boldsymbol{\theta}$ 
\STATE $\vl_t \leftarrow (1 - \vm) \odot \log \mathcal{C}(\vx^{(s)} | \boldsymbol{\theta}^{(s)})$
\STATE $\mathcal{L} \leftarrow  \frac{D}{D - t + 1} \operatorname{sum} (\vl_t)$
\end{algorithmic}
\end{algorithm}
\end{minipage}
\end{table}

\newpage
\subsection{Details on Parallelized ARDMs}
This section discusses further details on Parallelized ARDMs, and provides a JAX version of the dynamic programming algorithm from \citep{watson2021learningefficientlysample} that was written in NumPy. Since the algorithm scales with $\mathcal{O}(D^3)$ this implementation is important to scale to larger dimensional problems. To clarify, the upscale ARDMs can be seen as a $S$ sequential OA-ARDMs that model $p(\vx^{(s)} | \vx^{(s-1)})$, and when a parallel schedule is computed, it is computed for each stage separately. It is also possible to run the dynamic programming algorithm for all $S 
\cdot D$ steps simultaneously, which could even choose to distribute steps unevenly over stages, but that is not done in this paper. 



Recall that to run the algorithm a matrix $\mathbf{L}$ is needed which gives the cost of travelling from one generation step to another. It is constructed so that $L_{t,t+k} = k \cdot L_t$ for positive $k$ and $0$ otherwise, which represents the cost of generating $k$ variables in parallel where $L_t$ is the loss component. In practice this is implemented via a cumulative sum of a triangular mask. This part is relatively computationally cheap.
\begin{lstlisting}
import jax
from jax import numpy as jnp
import numpy as np

def get_nelbo_matrix(loss_components: np.ndarray):
  num_timesteps = len(loss_components)

  # Creates multiplicative mask. E.g. if num_timesteps = 3 then:
  #        [1 2 3]
  # triu = [0 1 2].
  #        [0 0 1]
  triu = np.triu(np.ones((num_timesteps, num_timesteps)))
  triu = np.cumsum(triu[::-1], axis=0)[::-1]

  # Compute nelbos[s, t] which contains -logp(x_s | x_t)
  nelbos_ = loss_components[:, None] * triu
  # Pad last row / first column.
  nelbos = np.zeros((num_timesteps + 1, num_timesteps + 1))
  nelbos[:-1, 1:] = nelbos_

  return nelbos
\end{lstlisting}

The most expensive part of the algorithm is the loop which has computational complexity $\mathcal{O}(D^3)$. This is the most important extension of the NumPy version and reduces runtime from $5$ minutes to about $2$ seconds for $D=3072$, which would be very impractical to run for our audio experiments where $D=16000$, which now take less than half a minute to run. Through JAX this loop is XLA-compiled with the scan operation, limiting overhead when running the algorithm. 
\begin{lstlisting}
@jax.jit
def inner_cost_and_dimension_loop(
    nelbos: jnp.ndarray, first_cost: jnp.ndarray):
  """Inner jax-loop that computes the cost and dimension matrices."""
  num_timesteps = first_cost.shape[0] - 1

  def compute_next_cost(prev_cost: jnp.ndarray, _: jnp.ndarray):
    bpds = prev_cost[:, None] + nelbos
    new_dimension = jnp.argmin(bpds, axis=0)
    new_cost = jnp.min(bpds, axis=0)
    return new_cost, (new_cost, new_dimension)

  _, (costs, dimensions) = jax.lax.scan(
      compute_next_cost, init=first_cost,
      xs=jnp.arange(1, num_timesteps+1))

  return costs, dimensions
\end{lstlisting}


The inner algorithm logic is then called via the function below. It first builds the loss transition matrix $\mathbf{L}$ which is referred to as $\texttt{nelbos}$ and then calls the inner loop. As an output it gives the cost and dimension matrices that can be used to \textit{1)} find an optimal path and \textit{2)} describe how expensive such paths are. As can be seen in Figure~\ref{fig:loss_t}, the running average of the loss components $\{L_t\}$ might be somewhat noisy, which can negatively influence the algorithm. As a straightforward method to reduce variance of the values $\{L_t\}$, they are \textit{sorted} before they are given to the algorithm. This is uniquely possible for ARDMs, as we expect $L_t$ to be monotonically decreasing over $t$ (see also Equation~\ref{eq:monotonicity_start}). For Upscale ARDMs that have multiple stages, the loss components are seperately sorted per stage.
\begin{lstlisting}
def get_cost_and_dimension_matrices(loss_components: np.ndarray):
  """Compute cost and assignment matrices, in JAX."""
  num_timesteps = len(loss_components)

  # First row of the costs matrix.
  first_cost = np.full((num_timesteps + 1,), np.inf)
  first_cost[0] = 0
  first_cost = jnp.array(first_cost)

  # First row of the dimensions matrix. The first row just contains -1 
  # and is never used, but this way it aligns with the cost matrix.
  first_dimension = jnp.full((num_timesteps + 1), -1, dtype=np.int32)

  # nelbos[s, t] is going to contain the value logp(x_s | x_t)
  nelbos = jnp.array(get_nelbo_matrix(loss_components))
  costs, dimensions = inner_cost_and_dimension_loop(nelbos, first_cost)

  # Concatenate first rows to the matrices.
  costs = jnp.concatenate([first_cost[None, :], costs], axis=0)
  dimensions = jnp.concatenate([first_dimension[None, :], dimensions],
                               axis=0)

  costs = np.array(costs)
  dimensions = np.array(dimensions)

  return costs, dimensions
\end{lstlisting}

The final part of this algorithm is used to retrieve the path that needs to be taken to attain a certain cost. This algorithm takes as input a budget and the cost \& dimension matrices, and returns the corresponding path to traverse.
\begin{lstlisting}
def get_optimal_path_with_budget(budget: int, costs: np.ndarray,
                                 dimensions: np.ndarray):
  num_timesteps = len(costs) - 1
  t = num_timesteps
  path = np.zeros(budget, dtype=np.int32)
  cost = costs[budget, num_timesteps]
  for k in reversed(range(1, budget+1)):
    t = dimensions[k, t]
    path[k-1] = t
  return path, cost
\end{lstlisting} 
\newpage \section{Additional Results}
\subsection{Relation to other likelihood-based generative models}

In this section we show how ARDMs perform compared to existing likelihood based generative models in literature. These results are presented in Table~\ref{tab:literature_comparison}. The best performing model is the Variational Diffusion Model (VDM) \citep{kingma2021vdm}. ARDMs perform competitively with a best score of $2.64$~bpd, and are the best performing model among discrete diffusion approaches.
\begin{table}[h!]
\vspace{-.2cm}
    \centering
    \caption{CIFAR-10 generative modelling.}
    \label{tab:literature_comparison}
    \scalebox{.8}{\begin{tabular}{l c c c c} 
    \toprule
    Model & Type & NLL \\ \midrule
       ARDM-AO (ours) & Discrete Diffusion $\cup$ ARM & 2.69 \\
       ARDM-Upscale 4 (ours) & Discrete Diffusion $\cup$ ARM & 2.64 \\
       D3PM Gaussian \citep{austin2021structured} & Discrete Diffusion & 3.44 \\  \midrule
       DDPM \citep{ho2020denoising} & Diffusion & 3.69 \\
       Improved DDPM \citep{nichol2021improvedddpm} & Diffusion & 2.94 \\
       VDM \citep{kingma2021vdm} & Diffusion & \textbf{2.49} \\ \midrule
       PixelCNN++ \citep{salimans2017pixelcnnpp} & ARM & 2.92 \\
       SPN \citep{menick2019SPN} & ARM & 2.90 \\ 
       Sparse Transformer \citep{jun2020distributionaugmentation} & ARM & 2.52 \\ \midrule
       NVAE \citep{vahdat2020nvae} & VAE & 2.91 \\
       Very Deep VAE \citep{child2021verydeepvae} & VAE & 2.87 \\
       CR-VAE \citep{sinha2021crvae} & VAE & 2.52 \\ \bottomrule
    \end{tabular}}
\end{table}


\subsection{Additional audio experiments}
In Table~\ref{tab:depth_upscaling_sc09_budget} we present additional experimental results from our best Upscale ARDM model for the SC09 dataset (branching factor $4$), in which we consider smaller computational budgets. Recall that dimensionality $D=16000$ for SC09 data.

\begin{table}
\vspace{-.3cm}
\centering
\begin{table}[H]
    \centering
    \caption{Audio (SC09) depth upscaling test set performance (in bpd) for various computational budgets.}
    \label{tab:depth_upscaling_sc09_budget}
    \scalebox{.9}{\begin{tabular}{l c c c c} 
    \toprule
    Model  & Steps & Performance\\ \midrule
      ARDM Upscale 4 &  $8 \times 16000$ & \textbf{6.29} \\ \midrule
      ARDM Upscale 4 &  $8 \times 1000$ &  6.30 \\
       &  $8 \times 500$ &  6.30 \\
       &  $8 \times 100$ &  6.32 \\
       &  $8 \times 50$ &  6.32 \\
    \bottomrule
    \end{tabular}}
\end{table}
\end{table}

\subsection{Loss components over time}
Since the training algorithm estimates the NLL by sampling a step $t$ for each input in the batch, we can collect and keep track of the loss components $\{L_t\}$ and plot them as a function of $t$ (see Figure~\ref{fig:loss_t}). These are collected by updating an exponential moving average during training, and are used in the dynamic programming routine. As expected by Equation~\ref{eq:monotonicity_start}, the components $L_t$ are monotonically decreasing over the step $t$ within a stage. The height is re-normalized so that the average height represents the total bits per dimension. As a result, in the upscale model the value divided by number of stages $S$ represents the actual uncertainty of generating that token.


The loss plot of the upscale model allows for interesting observations: For instance, After an initially high uncertainty ($\approx 8 / S = 2$ bits) the most significant bits become increasingly easier to model very fast ($<2 / S = 0.5$ bits). In contrast, for each stage that follows, the average height of that stages increases. This indicates that the model is more uncertain for the less significant bits. This can be a combination of two things: The model may have more difficulty in modelling these less significant bits (i.e. high $\mathrm{KL}$ between data and model distribution), and the data distribution may be more uncertain in those regions (i.e. high entropy of the data distribution). 
\begin{figure}[H]
    \vspace{-.1cm}
    \centering
    \includegraphics[width=.48\textwidth]{figures/loss_t/oa_loss_t.png} \hfill 
    \includegraphics[width=.47\textwidth]{figures/loss_t/upscale_loss_t.png}
    \vspace{-.3cm}
    \caption{Loss components over model step on CIFAR-10. The height is normalized so that the average represents the total bits per dimension. Left: loss terms for the OA-ARDM. Right: loss terms for the ARDM-Upscale 4, which comprises four stages.}
    \label{fig:loss_t}
    \vspace{-.3cm}
\end{figure}


\subsection{Samples from ARDMs}
\paragraph{Language} Sampling from ARDMs can be visualized at different steps $t$ to highlight the generative process. Recall that for models trained on language, the absorbing state augments the space, meaning that an additional index that is added for the absorbing state. We visualize this token by the underscore character `\texttt{\_}'. The process at four selected steps in the process are presented in Figure~\ref{fig:oa_ardm_chain_text8}, where the last sentence represents the resulting sample.


\lstset{
    numbers=none,
    stepnumber=3,
    firstnumber=1,
    numberstyle=\scriptsize,
    tabsize=4,
    rulecolor=,
    language=java,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=false,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\ttfamily
}

\begin{figure}[H]
\centering
\begin{minipage}{.999\textwidth}
\begin{lstlisting}[language=java]
__________________________________________________x___________________________________________
___________i___________________________________________________________________________n______
________________________i________________________________f____

to____li________egy_f___________c___________ _____x___i___e________rt s___k________________r i
_______ i__is___l__e___e _______a____h___ _ot_____l_______c_e__pr______ __j___ __er_t_onal_w_a
___s_in_______me_c______i____i__a_ m_d__________s________f____

to_r__li_e s_rategy for_____m___c_________h_ __n_ex_eri__ce______hort s_rike____b_r__wheth_r i
_ ___se i__is__el__er__e fo__g__a_ls_h__e _ot__t__l_y u_s_c_e__pr______ i_je__ __erational w_a
po_s_in_t___g_me_ca_ u__i_d__i__a_ m_d_l u__e___s___d____fy__g

to r__li_e s_rategy for autom__ics o_ i__the c_n ex_erie_ce_fo_ short s_rike_bombers_wheth_r i
n r_use it_is deli_erate for ga_auls ha_e _ot_ntially u_s_cke__pro_f___ i_ject __erational w_a
po_s in t_e_game_car us_i_divid_a_ mod_l urre___s___de__ifyi_g

to realize strategy for automatics or it the can experience for short strike bombers whether i
n reuse it is deliberate for gasauls have potentially unsucked proof or inject operational wea
pons in the game car us individual model urrealise identifying
\end{lstlisting}
\end{minipage}
\begin{minipage}{.999\textwidth}
\begin{lstlisting}[language=java]
____________s__________________________________________________________________________________
_________________________________________________ _________________t______________________t____
_________________________d__________________________________

_e_s__e___ows___ _____r___c__________e_______f_____b__s__el_i__ ____d__________s___c________he_
i____ __ ___ ___a____ma____i___e b____r_______bl_ __________d______t_n_a___ i_land__omp___t__n_
______o_g_____e___o_ a___d__t____e____m____t__________ __m__

le_s_re_shows___ t____ro__ct__n_o__t_e _ta___f_____by_sa_el_i_e _o_rd______ro__s __c_ _en__ he_
ita_e __ ___ ___a__y_mai__fis_ e b__u_r_______bl_ e_ __r_a__d_n_a__tin_a__s i_land_comp__it_on_
__d_g_orge__c_e___on a___d_ltum _eak__mongst_e__e___a_ _om__

leisure shows__t t_e _rot_ction o__the sta__ fal_s by sa_ellite _oard_a_d troo_s __ce tenu_ he_
itage of t__ _ata__y main_fish e b__uer__ ____bl_ el _erpa _d_n_a_ tin_a__s island compo_it_on 
_nd george_ clea_son a__ diltum peak amongsthe ge___a_ _omm_

leisure shows it the protection of the stamp falls by satellite board and troops lace tenua he
ritage of the catalay main fish e b fuerta e robla el serpa eden at tingalas island composition
and georges clearson and diltum peak amongsthe general commu
\end{lstlisting}
\end{minipage}
\caption{Two generative processes of an OA-ARDM trained on text8. The resulting sample from the model is at the bottom of each frame.}
\label{fig:oa_ardm_chain_text8}
\end{figure}
\newpage


\paragraph{Images} The generative processes for images are visualized in Figure~\ref{fig:ardm_chain_cifar10_appendix}. In constrast with the language model, here the absorbing state takes on a specific value in the domain of the image itself. In the case of OA-ARDMs, the absorbing state is $128$ so that it is $0$ when normalized in the network architecture. In constrast, the absorbing state of the Upscale ARDM is $0$ because it is defined by zeroing least significant bits until everything is zero. The right-most grid represents the resulting samples from the model. The generative processes are very different: whereas the upscale ARDM first generates a coarses version of the images with fewer bits, the order agnostic ARDM generates each value at once.


\begin{figure}[H]
\centering
\begin{subfigure}{\textwidth}
    \includegraphics[width=.999\textwidth]{figures/samples/chain_upscale_4_second.pdf}
\caption{Generative process of an Upscale 4 ARDM. This model was trained without data augmentation and with dropout, which explains that all images are generated upright. The performance of this model is approximately 2.71 bpd whereas the same model trained with data augmentation has 2.64 bpd.}
\end{subfigure}
\begin{subfigure}{\textwidth}
    \includegraphics[width=.999\textwidth]{figures/samples/chain_softmax.pdf}
\caption{Generative process of an OA-ARDM, starting at the absorbing state $\va$. This model was trained with data augmentation, which is known to somewhat degrade sample quality and naturally sometimes samples rotated or reflected images.}
\end{subfigure}
\caption{Visualization of the generative process for $\vx$, ending with the resulting samples at the right-most grid.}
\label{fig:ardm_chain_cifar10_appendix}
\end{figure} 
\newpage
\section{Equivalence of AO-ARDMs and Absorbing Diffusion in continuous time}
\label{sec:diffusion_connection}
In this section we examine the connection between absorbing diffusion and AO-ARDMs more closely. We start with a description of the independent process of absorbing diffusion as used in \citep{austin2021structured} and highlight potential complications of this process. Then, we will show that AO-ARDMs are equivalent to a continuous-time version of absorbing diffusion models.


\textbf{The Independent Absorbing Process from Austin et al.} \\
In absorbing diffusion as described by \citep{austin2021structured}, each dimension can independently get absorbed with some small probability for each time step. Specifically, letting a vector $\vx(t)$ represent a Markov process as a collection of random variables index by integers $t$, where $\vx(0)$ is the data distribution. Each dimension $x_i(t)$ as an equal and independent chance of getting absorbed according to rate $\gamma(t)$ at index $t$ to the absorbing state $a_i$. Define the cumulative chance of retaining the state as $\alpha(t) = \prod_{\tau = 1}^t (1 - \gamma(\tau))$. This allows the direct expression for the distribution over $x_i(t)$ as categorical on data and the absorbing state $\{x_{i}(0), a_i\}$ with probabilities $\{\alpha(t), 1 - \alpha(t)\}$. Typically, the decay rate $\gamma$ is chosen so that $\alpha(T) = 0$ for some large integer $T$. For example in \citep{austin2021structured} it is set $T = 1000$ for most experiments. We refer to the absorbing process from \citep{austin2021structured} as an \textit{independent} absorbing process, due to its independent absorbing probabilities between dimensions.


The reverse of this absorbing process is the generative process. As described above, the chance of a dimension absorbing is independent. As a result when $T$ is small, it is inevitable that multiple dimensions decay at once. This has a direct consequence for the generative process, which is parametrized to model dimensions independently. The generative process will have to model the variables of these multiple absorbed dimensions as an independent factorized distribution, which causes a loss in modelling performance. This problem can be overcome by setting $T$ to a larger value. Indeed, when $T$ is larger the chance of multiple dimensions decaying at once decreases. During training, $T$ can be set arbitrarily high without incurring costs. However, to sample or evaluate the likelihood of a specific datapoint, the computational cost scales directly with $T$ so it is desired to keep $T$ as low as possible. 

As an example, consider the experiment from \citep{austin2021structured} where text sequences of length 256 are modelled using a $1000$ timestep absorbing diffusion model. When sampling from this model, at least $744$ of the neural network forward passes do nothing to the latent variable and are needless compute. When $T$ is reduced, performance degrades. In addition, it can be difficult to determine beforehand how high a $T$ should be sufficient, and it depends on the data and the decay rate. 


\textbf{ARDMs model the reverse of a Fixed Absorbing Process} \\
Our ARDMs can be viewed as learning the generative process of a slightly modified absorbing process. Instead of independent absorbing costs, exactly one dimension decays at a time step until all dimensions have been absorbed. Since only one variable decays at a time, we refer to this process as a \textit{fixed} absorbing process. This ensures that $T = D$ exactly, where $D$ is the dimensionality of the data.

An equivalent way to describe this process is by sampling a permutation of the indices $1, \ldots, D$ and decaying in that order towards the absorbing state. The corresponding generative process is then modelling the variables exact opposite order of the permutation: an AO-ARDM. As a result the generative process with a fixed absorbing process process only requires at most $D$ steps.


 
\textbf{ARDMs are equivalent to Continuous Time Absorbing Models} \\
The absorbing diffusion model from \citep{austin2021structured} can be relaxed to continuous time. Define a continuous-time discrete-space absorbing-state Markov process as a collection of Markov random variables $\{\mathbf{x}(t)\}$ in dimension $D$, parameterized by $t \in \mathbb{R}^{+}$. Starting in state $\vx(0)$, each of the elements $x_i(t)$ of the state vector independently decays towards an absorbing state $\va$ at rate $\gamma(t)$, such that at time $t$ the distribution on the vector elements is categorical on $\{x_{i}(0), a_i\}$, with probabilities $\{\alpha(t), 1-\alpha(t)\}$, with $\alpha(t) = \exp(-\int_{0}^{t} \gamma(s) ds)$. This last equivalence is obtained via the first order logarithmic Taylor expansion $\log(1-x) \approx -x$ which holds for the small $\gamma(s) ds$.


An equivalent way of describing this stochastic process is as a finite set of $D$ random transition times $\{\tau_i\}$ for $i \in \{1,\ldots,N\}$ describing the time where the element $x_i$ has transitioned into the absorbing state. Specifically, we say that $\tau_i$ is the latest time for which $x_i$ is non-yet absorbed, so $x_i(t) = a_i$ for $t > \tau_i$. From this perspective, $\vx$ is only changing at the transition times $\tau_i$ and remains the same at other times. Then, the reverse process to model $\{\vx(t)\}$ for all $t$ is equivalent to only modelling the finite dimensional $\{x_i(\tau_i), \tau_i\}$. In other words, to model the reverse process, we only need to model the transition times $\{\tau_i\}$ and the variable right before it was absorbed.

To show an equivalence between the continuous time absorbing process and ARDMs, we will show that we can model the reverse process given by $\{x_i(\tau_i), \tau_i\}$ by sampling the transition times independently, and by using an AO-ARDM for the transitions in $\vx$. 


The distributions $\{\tau_i\}$ are already known, they are given by the distribution with the cumulative distribution function $1 - \alpha(t)$. That leaves the modelling of $\{x_i(\tau_i)\}$ to model the reverse process. An important question that now arises is whether the transition times $\{\tau_i\}$ provide any additional information in modelling the variables $\{x_i(\tau_i)\}$. Apart from knowing \textit{that} the variable will be un-absorbed, the answer is no. This is because the values are distributed as the data distribution so $x_i(0) | \vx(t) \sim x_i(\tau_i) | \vx(t)$ and the actual continuous value of $\tau_i$ does not matter, specifically $\{x_i(0)\} \perp \{\tau_i\} | \vx(t)$. 

As a consequence, the model for the reverse process does not need to be conditioned on the precise values $\{\tau_i\}$ and can instead be solely conditioned on $x_i(\tau_{i+1})$ to model $x_i(\tau_i)$ for all dimensions $i$. Recall that this process is equivalent to the generative process of our AO-ARDM: Each new timestep, a new dimension of the variable is modelled. The order in which the variables are modelled depends on the decay times $\{\tau_i\}$, and since these are all identically distributed, the order is uniform over all possible permutations.  


We claim that we can write the VLB as follows:
\begin{align*}
\log p(\vx(0)) & \geq \mathbb{E}_{q(\vx(>0)|\vx(0))} \log p(\vx(>\!0)) + \log p(\vx(0) | \vx(>\!0)) - \log q(\vx(>\!0)|\vx(0)) \\
& = \mathbb{E}_{q(\tau_1, \ldots, \tau_D)} \sum_{i} \log p(\vx(\tau_{i})|\vx(\tau_{i+1})) - \mathrm{KL}(q(\tau_{1}, \ldots, \tau_D) | p(\tau_1, \ldots, \tau_D)) \\
& = \mathbb{E}_{\sigma \sim \mathcal{U}(S_d)} \sum_{i} \log p(\mathbf{x}_{\sigma(i)}|\vx_{\sigma(<i)}),
\end{align*}
where $\vx(>\!0)$ denotes all values of $\vx(t)$ for $t>0$. The first equivalence follows from the above described equivalent representation of the continuous process. And indeed when the transition times and the values of $\vx$ at the transition times are given, the remaining variables of the continuous process can be reconstructed so it can be ensured that:
$$\mathrm{KL}(q(\vx | \vx(\tau_1), \ldots, \vx(\tau_D), \tau_1, \ldots, \tau_D) | p(\vx | \vx(\tau_1), \ldots, \vx(\tau_D), \tau_1, \ldots, \tau_D)) = 0.$$

In addition, recall that any transition variable is distributed according to any chosen cumulative distribution $\alpha(t)$. Therefore, we can simply set our generative process to the same distribution, which ensures that:
$$\mathrm{KL}(q(\tau_1, \ldots, \tau_D) | p(\tau_1, \ldots, \tau_D)) = 0.$$


At this point we observe that the sampling times only determine the order in which the dimensions $\vx$ are modelled. In fact when modelling $\vx(\tau_{i})|\vx(\tau_{i+1})$ only one dimension dimension changes from $\tau_{i+1}$ to $\tau_i$. Since all $\{\tau_i\}$ are independently and equally distributed, the distribution over the order of $\{\tau_i\}$ is uniform. A subtle detail is that the \textit{reverse} of the order of $\tau_i$ describes the generative order since we model timestep $\tau_i$ given $\tau_{i+1}$. Nevertheless, since the distribution over orders is uniform, the distribution over \textit{reverse} orders is also uniform. Therefore:
$$\mathbb{E}_{q(\tau_1, \ldots, \tau_D)} \sum_{i} \log p(\vx(\tau_{i})|\vx(\tau_{i+1})) =  \mathbb{E}_{\sigma \sim \mathcal{U}(S_d)} \sum_{i} \log p(\mathbf{x}_{\sigma(i)}|\vx_{\sigma(<i)}),$$
where the latter equation contains the same omitted notation as in the main paper: The model is aware which dimensions are conditioned on and which are not. In practical terms, this means that $\vx_{\sigma(<i)}$ should be viewed as a masked vector and not as an order-less set. For the curious reader, technically the ability to move from order-less to the structured masked vector is enabled by conditioning on $\sigma$. In summary, modelling the generative process of a continuous absorbing jump process is equivalent to an AO-ARDM. This is beneficial, as viewing the model as an AO-ARDM gives a simple bound to the number of required steps and allows an easier perspective on the model and its implementation.
 
\section{Experimental Details}
\label{app:experimental_details}

In this section further details are given on the experimental setup.

\paragraph{Images}
For CIFAR10 \citep{krizhevsky2009learning} we train the model using a fixed number of steps using the typical splits and evaluate the test log-likelihood after $3000$ epochs of training. The results that are reported with standard deviations results are based on runs with three different initial seeds. The other results are based on single-run experiments. The runs take approximately $2$ weeks to complete training on 8 TPUv4 devices, although good performance ($\approx \! 2.8$ bits per dimension) is already achieved after a couple of days.

As a base architecture for the OA-ARDM and the Upscale ARDMs, the exact same U-Net architecture as in \citep{kingma2021vdm} are used. This architecture has $32$ ResBlocks at resolution $32 \times 32$, a single middle attention layer and then another $32$ ResBlocks at resolution $32 \times 32$. Throughout the network feature maps have $256$ channels. This architecture is typical for NLL optimization and lossless compression, which typically require many high-resolution feature maps \citep{mentzer2019practicallossless}. The models are trained for $3000$ epochs with Adam using a learning rate of $0.0001$ and beta parameters ($0.9$ / $0.999$). The input processing uses a combination of the floating point representation and an embedding layer. The integer-valued input is put through a simple normalization by dividing by the total number of classes, and subtracting $0.5$. To this normalized input the mask $\vm$ is then concatenated. In the case of upscale ARDMs, the current stage in one-hot representation is also converted to a mask with $S$ channels, and is also part of $\vm$. So in that case $\vm$ has $S+1$ channels. Then a $3 \times 3$ convolutional layer maps the concatenated inputs to $3/4$ of the channels. In addition, the integers are also fed through an embedding layer to $1/4$ of the channels. These two outputs are then combined which produces the feature maps with $256$ channels. This is given as an input to the U-Net architecture as described above. Following \citet{austin2021structured} we include the Cross-Entropy (CE) objective $\mathcal{L}_{CE} = \mathbb{E}_{t \sim \mathcal{U}(1, \ldots, D)} \Big{[} D (D - t + 1) \mathcal{L}_t \Big{]}$ (i.e. the unnormalized likelihood components), with a small factor of $0.001$. However, in an experiment without the $\mathcal{L}_{CE}$ loss included, no substantial differences in performance were found for our ARDMs. Since the likelihood of the dataset is estimated with the ARDM objective, the results are computed over multiple dataset passes to reduce the stochastic effects from sampling $t$ and $\sigma$. For evaluation the exponential moving average of the parameters is used with a momentum coefficient of $0.9999$. The models are trained with a batch size of $128$. The gradient is clipped at $100$.


\paragraph{Language}
For the text8 dataset \citep{mahoney2011large}\footnote{\href{http://mattmahoney.net/dc/text8.zip}{
http://mattmahoney.net/dc/text8.zip}} we train using the typical $90 \cdot 10^6 / 5 \cdot 10^6 / 5 \cdot 10^6$ splits in characters. Because the text8 dataset is a long string of characters, there is predictive information between segments when chunked. For this reason there is a big difference between model performance in literature in the reported scores on the text8 benchmark. Some methods consider a larger context before the current sequence, which greatly improves the information available to the model and gives better log-likelihoods. The runs take approximately a week to complete on $4$ TPUv4 devices.

Since we are interested in the pure modelling capacity of models, we follow \citep{hoogeboom2021argmaxflows, austin2021structured} and consider chunked text segments \textit{without} any additional context. However, since the text8 splits are not evenly divisible by $256$, we slightly adjust the chunk size to $250$ characters, to avoid dropping the last batch. We validated empirically with a baseline Transformer that this small change does not meaningfully change the performance with the $256$ version. For reference, a baseline $12$ layer Transformer attains $1.35$ bpc on this problem. 

As a base architecture, we use a $12$ layer Transformer as used in \citep{austin2021structured}. It has $768$ dimensions, $12$ heads, $3072$ MLP dimensions. For the ARDM architectures we followed \citep{austin2021structured} and used a batch size of $512$ with no dropout. For standard language model baseline, since we observed overfitting the batch size was lowered and dropout of $0.1$ was added. The models are trained for $3 \cdot 10^6$ training steps. ARDMs are optimized with Adam with a learning rate of $0.0005$ which has a linear warm-up for the first $5000$ steps. The additional $\mathcal{L}_{CE}$ loss was included with a factor $0.0001$. The gradient is clipped at $0.25$. For evaluation the exponential moving average of the parameters is used with a momentum coefficient of $0.995$. All models use a sinusoidal positional embedding. However, the OA-Transformer based on the XLNet approach \citep{yang2019xlnet} requires both the input and target positional embeddings to infer which permutation currently needs to be generated. In \citep{alcorn2021DEformer}, this is handled by interleaving input and target nodes in the sequence. A downside to this approach is that is increases the sequence length by two, which increases the quadratic computational complexity of the attention layers by four. In contrast, we concatenate the input and target embeddings, which does not alter the sequence length.


\paragraph{Audio}
For audio experiments we used a subset of the SC09 dataset \citep{speechcommandsv2} obtained by filtering out all non-digit commands from the dataset without changing the structure of the train/validation/test splits. The resulting dataset contains $31158/3643/4107$ training/validation/test audio clips that are 1~second long and sampled at $16$~kHz. In a few rare cases when the audio clips were shorter than 1~second, we right-padded them with zeros; and all considered models were trained and evaluated on padded data. A Tensorflow Datasets \cite{TFDS} version of this dataset is provided with the open-source code. Training takes approximately $4$ days.

For both, the AO-ARDM as well as the Upscale ARDM experiments, we closely followed the DiffWave setup \citep{kong2021diffwave} in terms of the network architecture and size, bit adapted the input embedding layer to take input masks into account. Specifically, we used a non-causal WaveNet \citep{oord2016wavenet} architecture with $36$ blocks, $256$ channels and a dilation cycle of $11$ (i.e. maximum dilation of $2048$); input embedding were obtained by concatenating \textit{1)} $64$-channel embeddings of integer input values; with \textit{2)} $192$-channel mask and continuous input value embeddings output by a width $3$ convolution; the shared time embedding was obtained by mapping the standard $256$-channel sine and cosine representation through two dense layers with $1024$ features and Swish nonlinearities \citep{elfwing2018sigmoid}.

Audio AO-ARDM and Upscale ARDM models were trained using the Adam optimizer \citep{kingma2014adam} with beta paramters $0.9$ / $0.999$ for $10^6$ steps with a batch size of $256$ and a linear learning rate warm-up over the first $15000$ steps followed by a constant learning rate of $10^{-4}$. During training we tracked an exponential moving average (EMA) of the model parameters using a momentum of $0.995$, and employed the EMA parameters during evaluation. As in the case of image ARDMs, the models were optimized using a combination of the ELBO and CE objectives - the latter taken with a tiny weight of $10^{-4}$. No further regularisation was used.

Due to the large output space ($2^{16}$ classes) audio AO-ARDM modelled the output distribution using a mixture of discretized logistics (DMoL) with $30$ components, although we experimentally found the number of components to not make a big difference. To aid with training, the DMoL was initialized as an approximately uniform distribution with different mixtures responsible for the different parts of this distribution; and gradients with an $L_2$ norm larger than $1000$ were re-normalized. Owing to the smaller per-stage output space, we were able to utilize the categorical softmax parameterization for the Upscale ARDMs. Empirically we observed this model class to demonstrate a more stable training behaviour (in a addition to significantly improved likelihoods), which we (partially) attribute to the choice of parametrization.

For our autoregressive single-order baseline we sought to deviate from the above AO-ARDM setup as little as possible, and used a causal version of the WaveNet architecture above. However, we observed that the single-order baseline overfits quickly on the training data. To overcome this, we found it necessary to use weight decay ($0.01$), smaller batch size ($64$) and fewer channels ($128$) for the baseline model.
 
\end{document}
