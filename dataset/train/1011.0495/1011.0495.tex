\documentclass[preliminary,copyright,creativecommons]{eptcs}
\providecommand{\event}{MeCBIC2010}
\providecommand{\volume}{}
\providecommand{\anno}{2010}
\providecommand{\firstpage}{1}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{needspace}
\usepackage{enumerate}
\usepackage{color}
\usepackage[noend]{algorithmic}
\usepackage{listings}

\lstdefinelanguage{Algorithm}
{
 morecomment = [l]{//}, 
 morecomment = [l]{///},
 morecomment = [s]{/*}{*/},
 morestring=[b]", 
 sensitive = false,
 morekeywords = {
   Input, Output, loop, if, then, else, break, continue, end, null
	}
}

\lstset{language=Algorithm}
\lstset{frame=single}
\lstset{mathescape=true,escapechar=\#}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\myway}[1]{\raisebox{-4pt}{\rule{0pt}{16pt}}\colorbox[rgb]{.7,.7,.7}{#1}}

\renewcommand{\labelitemi}{}
\renewcommand{\labelitemii}{}


\newenvironment{definition}[1][]
   {\refstepcounter{theorem} \par\medskip\noindent
   {\bf Definition~\thetheorem \ifx #1 \else ~(#1)\fi.} 
\ignorespaces }
   {\par\medskip }
   

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{algorithm}[theorem]{\textbf{Algorithm}}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{example}[theorem]{Example}

\newcommand{\modmin}{\mathtt{min}}
\newcommand{\modpar}{\mathtt{par}}
\newcommand{\modmax}{\mathtt{max}}
\newcommand{\modone}{\mathtt{one}}
\newcommand{\modspread}{\mathtt{spread}}
\newcommand{\modrepl}{\mathtt{repl}}
\newcommand{\gensym}{\mathtt{sym}}
\newcommand{\defup}{\mathtt{def}_\uparrow}
\newcommand{\defdown}{\mathtt{def}_\downarrow}
\newcommand{\refup}{\mathtt{ref}_\uparrow}
\newcommand{\refdown}{\mathtt{ref}_\downarrow}


\title{Edge- and Node-Disjoint Paths in P~Systems}
\author{Michael~J.~Dinneen, Yun-Bum~Kim, and Radu~Nicolescu
\institute{Department of Computer Science, University of Auckland,\\
Private Bag 92019, Auckland, New Zealand}
\email{\{mjd,yun,radu\}@cs.auckland.ac.nz}
}
\def\titlerunning{Edge- and Node-Disjoint Paths in P~Systems}
\def\authorrunning{M.J.~Dinneen, Y.-B.~Kim \& R.~Nicolescu}

\begin{document}
\maketitle


\begin{abstract}
In this paper, we continue our development of algorithms used for topological network discovery.  
We present native P~system versions of two fundamental problems in graph theory: 
finding the maximum number of edge- and node-disjoint paths between a source node and target node.  
We start from the standard depth-first-search maximum flow algorithms, 
but our approach is totally distributed, 
when initially no structural information is available
and each P~system cell has to even learn its immediate neighbors.
For the node-disjoint version, our P~system rules are designed to enforce node weight capacities (of one), 
in addition to edge capacities (of one), which are not readily available in the standard network flow algorithms.
\end{abstract}

Keywords: P~systems, P~modules, simple~P~modules, cell IDs, distributed algorithms, synchronous networks, breadth-first-search, depth-first-search, edge-disjoint paths, node-disjoint paths, network flow, network discovery, routing.


\section{Introduction}
\label{sec-introduction}

Inspired by the structure and interaction of living cells, P~systems provides a
distributed computational model, as introduced by G. P\u{a}un in
1998~\cite{Paun1998}.  The model was initially based on transition rules, but
was later expanded into a large family of related models, such as tissue and
neural P~systems (nP~systems) \cite{MartinVidePPR2003,Paun2002} and hyperdag
P~systems (hP~systems)~\cite{NDK-BWMC2009}.  Essentially, all versions of
P~systems have a structure consisting of cell-like membranes and a set of rules
that govern their evolution over time.  A large variety of rules have been used
to describe the operational behavior of P~systems, the main ones being:
multiset rewriting rules, communication rules and membrane handling rules.
Transition P~systems and nP~systems use multiset rewriting rules, P~systems
with symport/antiport operate by communicating immutable objects, P~systems
with active membranes combine all three type rules.  For a comprehensive
overview and more details, we refer the reader to \cite{Paun2002}.

Earlier in \cite{DKN-JLAP2010}, we have proposed an extensible framework 
called P~modules, to assist the programmability of P~systems.
P~modules enable the modular composition of complex P~systems
and also embrace the essential features of a variety of P~systems.
In this paper, we will use a restricted subset of this unifying model,
called simple~P~modules,
(subset equivalent to neural P~systems~\cite{MartinVidePPR2003}),
to develop algorithms for finding the maximum number of edge- and node-disjoint paths
between two cells in a fairly large class of P~systems, where 
duplex communication channels exist between neighboring cells.  
We assume that the digraph structure of the simple~P~module is completely unknown
(even the local neighboring cells must be discovered~\cite{NDK-WMC2009}) 
and we need to, via a distributed process, optimally create local routing tables 
between a given source and target cell.

There are endless natural applications that need to find alternative
routes between two points, from learning strategies to
neural or vascular remodeling after a stroke.
In this paper, we focus on a related but highly idealized goal, 
how to compute a maximum cardinality set of edge- and node-disjoint paths 
between two arbitrary nodes in a given digraph.

One obvious application related to networks is to find the best 
bandwidth utilization for routing of information between a 
source and target \cite{Robacker56}.  
For instance, streaming of applications for multi-core computations 
uses edge-disjoint paths routing for task decomposition and inter-task
communications \cite{SeoT-IPDPS2009}.
In fact, classical solutions are based on a network flow approach such as
given in \cite{FordF1956,EdmondsK1972}, 
or on Menger's Theorem, an old, but very useful, result, cited below.

\begin{theorem}[Menger~\cite{Menger1927}]
Let  be a digraph and let . 
Then the maximum number of node-disjoint -- paths is equal 
to the minimum size of an -- disconnecting node set.
\end{theorem}

Another application is to find a maximum matching (or pairing) 
between two compatible sets such as the marriage arrangement problem or 
assigning workers to jobs.

Our third application (and a motivating problem for the authors) 
is the Byzantine Agreement problem \cite{DKN-JLAP2010,DKN-CMC2010},
in the case of non-complete graphs.
The standard solution (also based on Menger's Theorem) allows for  faulty 
nodes (within a set of nodes of order at least ) if and only if there
are at least  node-disjoint paths between each pair of nodes, 
to ensure that a distributed consensus can occur~\cite{Lynch1996}.


Briefly, the paper is organized as follows. In the next section, 
we give a formal definition of simple~P~modules, 
to give a unified platform for developing our P~systems algorithms.  
Next, in Section~\ref{sec-disjoint-paths} we summarize the standard network flow
approaches for finding edge- and node-disjoint paths in digraphs and 
we discuss optimizations and alternative strategies which are more appropriate for P~systems.
In Section~\ref{sec-structural-vs-search-digraph}, we discuss three possible
relations between the structural digraph underlying a simple~P~module
and the search digraph used for determining paths.
Section~\ref{sec-cell-neighborhoods} details breadth-first-search rules used 
to determine the local cell topologies,
i.e. all cell neighborhoods; this is a common preliminary phase for 
both the edge- and node-disjoint path implementations.
The next two sections detail depth-first-search rules
for the edge-disjoint case (in Section~\ref{sec-edge-disjoint-path-algorithm-rules})
and for the node-disjoint case (in Section~\ref{sec-node-disjoint-path-algorithm-rules}).
Finally, in Section~\ref{sec-conclusion}, 
we end with conclusions and some open problems.


\section{Preliminary}
\label{sec-preliminary}

We assume that the reader is familiar with the basic terminology 
and notations: functions, relations, graphs, edges, nodes (vertices), 
directed graphs, arcs, paths, directed acyclic graphs (dags), 
trees, alphabets, strings and multisets
\cite{NDK-IJCCC2010}.  We now introduce \emph{simple~P~modules},
as a unified model for representing several types of P~systems. 
Simple~P~modules are a simplified variety of the 
full P~modules, which omit the extensibility features
and use duplex communication channels only. 
With these restrictions, although their formal definitions are different,
simple~P~modules are essentially equivalent to neural P~systems~\cite{MartinVidePPR2003}. 
For the full definition of P~modules and
further details on recursive modular compositions,
the reader is referred to \cite{DKN-JLAP2010}.

\begin{definition}[simple~P~module]
\label{def:simple-P-module}
A \emph{simple~P~module} is a system , where:
\begin{enumerate}
  \item  is a finite non-empty alphabet of \emph{objects};
  \item  is a finite set of (internal) \emph{cells};
  \item  is a binary relation on ,
      without reflexive or symmetric arcs,
	   which represents a set of parent-child structural arcs between existing cells, 
	   with \emph{duplex} communication capability.
\end{enumerate}

Each cell, , 
has the initial form  and 
general form , where:  
\begin{itemize}
  \item  is a finite set of \emph{states};
  \item  is the \emph{initial state};  is the \emph{current
state};
  \item  is the \emph{initial multiset} of objects;
    is the \emph{current multiset} of objects;
  \item  is a finite \emph{ordered} set of multiset rewriting \emph{rules} of the general form: 
        , 
        where , , 
        , 
        ,
        ,
        .
        If , denoting the \emph{empty string} of objects, this rule can be 
abbreviated as . The application of a rule takes two sub-steps, 
after which the cell's current state  and multi-set of objects  is replaced by  and ,
respectively, while  is a message which is sent as specified by the 
transfer operator .
\end{itemize}

The rules given by the ordered set(s)  are applied in the \emph{weak priority} order~\cite{Paun2006}.
For a cell , a rule 
is \emph{applicable} if  and .
Additionally, if  is the first applicable rule,
then each subsequent applicable rule's target state 
(i.e. state indicated in the right-hand side) must be .
The semantics of the rules and the meaning of operators ,
,  are now described.
\end{definition}

For convenience, we will often identify a cell  with its index (or
\emph{cell ID}) , when the context of the variable  is clear.
We accept that cell IDs appear as objects or indices of complex objects.
Also, we accept \emph{custom cell ID} rules, which distinguish the cell ID of
the current cell from other cell IDs.
For example, the rule  of Section~\ref{sec-cell-neighborhoods}, 
given as ``'' for cell ,
appears as ``'' in cell  
and as ``'' in cell .

The rewriting operator 
indicates that an applicable rewriting rule of  is applied as many times as
possible, while the operator  requires a rule of  is 
applied only once.
The communication structure is based on the underlying digraph structure.  
In this paper, and we will only use the  
and   transfer operators.
With reference to cell , 
a rewriting rule using  indicates
that the multiset  is replicated and sent to all neighboring cells
(parents and children), i.e. to all cells in . 
Assuming that cell  is a parent or a child of cell , 
i.e. ,
a rewriting rule using 
indicates that the multiset  is specifically sent cell .
Otherwise, if ,
the rule is still applied, but the message  is silently discarded.
The other non-deterministic transfer operators (e.g., , ,
, ) are just mentioned here for completeness,
without details, and are not used in this paper.
For details, the interested reader is referred to \cite{DKN-JLAP2010}.

\begin{remark}
This definition of simple~P~module subsumes several earlier definitions of P~systems, hP~systems and nP~systems.
If  is a \emph{tree}, then  is essentially a tree-based P~system 
(which can also be interpreted as a cell-like P~system).
If  is a \emph{dag}, then  is essentially an hP~system.
If  is a \emph{digraph}, then  is essentially an nP~system.
\end{remark}


\section{Disjoint paths in digraphs}
\label{sec-disjoint-paths}

We now briefly describe the basic edge- and node-disjoint paths algorithms, 
based on network flow, particularized for unweighted edges 
(i.e. all edge capacities are one), see Ford and Fulkerson~\cite{FordF1956}.
Our presentation will largely follow the standard approach, but also 
propose a couple of customizations and optimizations, specifically targeted for  
running on highly distributed and parallel computing models,
such as P~systems.

We are given a digraph  and two nodes, 
a source node, , and a target node, .
We consider the following two optimization problems:
(1) find a maximum cardinality set of edge-disjoint paths from  to ; and
(2) find a maximum cardinality set of node-disjoint paths from  to .
Obviously, any set of node-disjoint paths is also edge-disjoint,
but the converse is not true.
For example: 
\begin{itemize}
\item Figure~\ref{fig-node-edge-paths}~(a) 
shows a maximum cardinality set of edge-disjoint paths for a digraph ,
which is also a maximum cardinality set of node-disjoint paths,
\item Figure~\ref{fig-node-edge-paths}~(b) 
shows two maximum cardinality sets of edge-disjoint paths for the same digraph ,
which are not node-disjoint.
\item Figure~\ref{fig-different-edge-node} shows a digraph where 
the maximum number of edge-disjoint paths
is greater than the maximum number of node-disjoint paths.
\end{itemize}

\begin{figure}[h]
\centerline{\includegraphics[scale=1.0]{figures/fig-node-edge-paths}}
\caption{For this digraph, the maximum number of edge-disjoint paths from  to , 
which is 2, can be achieved in three ways: 
(a) paths set , ;
(b) either of the following two paths sets: 
, , , .
Paths shown in (a) are also node-disjoint, but paths shown in (b) are not.}
\label{fig-node-edge-paths}
\end{figure}

\begin{figure}[h]
\centerline{\includegraphics[scale=1.0]{figures/fig-different-edge-node}}
\caption{For this digraph, 
the maximum number of edge-disjoint paths from  to  (2) 
is greater than the maximum number of node-disjoint paths (1).}
\label{fig-different-edge-node}
\end{figure}


\subsection{Edge disjoint paths in digraphs}
\label{sec-edge-disjoint-paths}

In both edge- and node-disjoint cases, 
the basic algorithms work by repeatedly searching paths,
called augmenting paths, in an auxiliary structure, called residual network
or residual digraph.
We will first focus more on \emph{edge-disjoint paths}, 
because the \emph{node-disjoint paths}
can be considered as an edge-disjoint paths problem, with additional constraints. 

For the following ``network flow'' definition for digraphs with non-weighted
arcs, we say that an arc  is in a set of paths , denoted 
by the slightly abused notation , if there exists 
a path  that uses arc .

\begin{definition}
Consider a digraph , two nodes  and , , 
and a set  of edge-disjoint paths from  to .
Nodes in  are called \emph{flow-nodes} and 
arcs in  are called \emph{flow-arcs}.

Given path , each flow-arc  has a natural 
\emph{incoming} and \emph{outgoing} direction--the flow is from the source to the target;
with respect to ,  is the \emph{flow-predecessor} of  and 
 is the \emph{flow-successor} of .

The \emph{residual digraph} is the digraph , 
where the arcs in  are reversed, or, more formally,
.
Any path from  to  in  is called an \emph{augmenting path}.

Given augmenting path , each flow-arc  has also a natural 
\emph{incoming} and \emph{outgoing} direction--the flow is from the source to the target;
with respect to ,  is the \emph{search-predecessor} of  and 
 is the \emph{search-successor} of .
\end{definition}

\begin{fact}
\label{fact-augmenting}
Augmenting paths can be used to construct a larger set of edge-disjoint paths.
More precisely, consider a digraph  and two nodes  and .
A set  of  edge-disjoint paths from  to 
and an augmenting path  from  to 
can be used together to construct a set  of  edge-disjoint paths.
First, paths in  are fragmented, by 
removing ``conflicting'' arcs, i.e. arcs that appear in ,
where  (where \~{} indicates arc reversal).
Then, new paths are created by concatenating resulting fragments.
For the formal definition of this construction,
we refer the reader to Ford and Fulkerson~\cite{FordF1956}.
Note that including a reversed arc in an augmenting path
is known as \emph{flow pushback operation}.
\end{fact}

This construction is illustrated in Figure~\ref{fig-residual-digraph}.
Figure~\ref{fig-residual-digraph}~(a) illustrates a digraph  and 
a set  of edge-disjoint paths from  to ,
currently the singleton , where .
Figure~\ref{fig-residual-digraph}~(b) shows its associated residual digraph  
(note the arcs reversal).
Figure~\ref{fig-residual-digraph}~(c) shows an augmenting path  in , 
.
Figure~\ref{fig-residual-digraph}~(d) shows the extended set  
(after removing arcs  and ),
consisting of two edge-disjoint paths from  to , 
, .
Figure~\ref{fig-residual-digraph1} shows a similar scenario, 
where another augmenting path is found.
Note that the two paths illustrated in Figure~\ref{fig-residual-digraph}~(d)
form both a maximum edge-disjoint set and a maximum node-disjoint set;
however, the two paths sets shown in Figure~\ref{fig-residual-digraph1}~(d)
form two other maximum edge-disjoint path sets, but none of them is node-disjoint.

\begin{figure}[h]
\centerline{\includegraphics[scale=0.85]{figures/fig-residual-digraph}}
\caption{A residual digraph and an augmenting path: 
(a) a digraph  and one (edge-disjoint) path  from  to  (indicated by bold arrows).
(b) the residual digraph  associated to digraph  and path .
(c) an augmenting path  in   (indicated by hollow arrows).
(d) two new edge-disjoint paths  and ,
reconstructed from  and  (both indicated by bold arrows).}
\label{fig-residual-digraph}
\end{figure}

\begin{figure}[h]
\centerline{\includegraphics[scale=0.85]{figures/fig-residual-digraph1}}
\caption{The residual digraph of Figure~\ref{fig-residual-digraph} 
with another augmenting path and two new paths sets, 
, ,
which are edge-disjoint but not node-disjoint.}
\label{fig-residual-digraph1}
\end{figure}

\newpage

The pseudo-code of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} 
effectively finds the maximum number (and a representative set) 
of edge-disjoint paths from  and . 

\begin{algorithm}[\textbf{Basic edge-disjoint paths algorithm}]
\label{alg-basic-edge-disjoint-paths-algorithm}
~ 
\lstset{frame=none,xleftmargin={0.75 cm},numbers=left,numberstyle=\small}
\begin{lstlisting}
Input: #a digraph  and two nodes , #
# (the stage counter)#
# (the current set of edge-disjoint paths)#
# (the current residual digraph)#
loop
  # an augmenting path in , from  to , if any (this is a search operation)#
  if  = null then break 
  # (next stage)#
  # the larger paths set constructed using  and  (as indicated in Fact~\ref{fact-augmenting})#
  # the residual digraph of  and #
end loop
Output: # and , i.e. the maximum number of edge-disjoint paths and a representative set#
\end{lstlisting}

\end{algorithm}
\smallskip

Typically, the internal implementation of search at step~6 alternates between
a \emph{forward} mode in the residual digraph, 
which tries to extend a partial augmenting path,
and a backwards \emph{backtrack} mode in the residual digraph, 
which retreats from an unsuccessful attempt,
looking for other ways to move forward.
The internal implementation of step~9 (i.e. Fact~\ref{fact-augmenting}) walks backwards in the residual digraph,
as a \emph{consolidation} phase, which recombines the newly found augmenting path with the existing edge-disjoint paths.

This algorithm runs in  stages, i.e. in up to  stages,
if we count the number of times it looks for an augmenting paths,
and terminates when a new augmenting path is not found.
The actual procedure used (in step~6) to find the augmenting path separates two families of algorithms:
(1) algorithms from the Ford-Fulkerson family use a depth-first-search (DFS);
(2) algorithms from the Edmonds-Karp family use a breadth-first-search (BFS).
As usual, both DFS and BFS use ``bread crumb'' objects, as markers, to avoid cycles;
at the end of each stage, these markers are cleaned, to start again with a fresh context.
In this paper, we develop P~algorithms from the Ford-Fulkerson family, i.e. using DFS.


\subsection{Node disjoint paths in digraphs}
\label{sec-node-disjoint-paths}

The edge-disjoint version can be also used to find node-disjoint paths.
The textbook solution for the node-disjoint problem is usually 
achieved by a simple procedure which transforms the original digraph
in such a way that, on the transformed digraph,
the edge-disjoint problem is identical to 
the node-disjoint problem of the original digraph. 
Essentially, this procedure globally replaces every node , 
other than  and , with two nodes,
an \emph{entry} node  and an \emph{exit} node ,
connected by a single arc . 
More formally, the new digraph  has
, 
,
where, for convenience, we assume that  and  are aliases.
This standard node-splitting technique is illustrated in Figure~\ref{fig-split-technique}.
It is straightforward to see that the newly introduced arcs
, ,  and ,
constrain any edge-disjoint solution to be also node-disjoint.

\begin{figure}[h]
\centerline{\includegraphics[scale=1.0]{figures/fig-split-technique}}
\caption{The node splitting technique.}
\label{fig-split-technique}
\end{figure}

However, in our case,
since each node is identified with a P~systems cell,
we cannot solve the node-disjoint paths problem
using the standard node-splitting technique.
We propose two non-standard search rules, 
which together limit the out-flow capacity of each  to one,
by simulating the node-splitting technique, without actually splitting the nodes.
We believe that our rules can be used in other distributed network models where 
the standard node-splitting technique is not applicable.
These rules are illustrated by the scenario presented in Figure~\ref{fig-interesting-case},
where we assume that we have already determined a first flow-path, ....,
and we are now trying to build a new augmenting path.

\begin{enumerate}
\item Consider the case when the augmenting path, consisting of ,
tries flow-node  via the non-flow arc .
We cannot continue with the existing non-flow arc 
(as the edge-disjoint version would do), 
because this will exceed node 's capacity, which is one already.
Therefore, we continue the search 
with just the reversed flow-arc .
Note that, in the underlying node-splitting scenario,
we are only visiting the entry node , but not its exit pair . 

\item Consider now the case when the augmenting path, extended now to ...,
tries again the flow-node , via the reversed flow-arc .
It may appear that we are breaking the traditional search rules,
by re-visiting the already visited node .
However, there is no infringement in the underlying node-splitting scenario,
where we are now trying the not-yet-visited exit node 
(to extend the underlying augmenting path ...).
From , we continue with any available non-flow arc, if any, 
otherwise, we backtrack. In our example, we continue with arc .
We obtain a new augmenting ``path'', .....
(corresponding to the underlying augmenting path .....).
We further recombine it with the already existing flow-path ....,
and we finally obtain the two possible node-disjoint paths,
... and ...
\end{enumerate}

\begin{figure}[h]
\centerline{\includegraphics[scale=0.9]{figures/fig-interesting-case}}
\caption{Node-disjoint paths.
(a) non-standard search: flow path .... and augmenting ``path'' ......
(b) node-splitting: flow path ....... and 
augmenting path ......
}
\label{fig-interesting-case}
\end{figure}

The following theorem is now straightforward:

\begin{theorem}
If the augmented path search in step~6 of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} is modified as indicated above,
the algorithm will terminate with a restricted subset of edge-disjoint paths,
forming a maximum cardinal subset of node-disjoint paths.
\end{theorem}


\subsection{Pointer management}
\label{sec-pointer-management}

With respect to the implementation, the edge-disjoint version provides 
its own additional challenge, not present in the node-disjoint version. 
In the node-disjoint version,
each flow-node needs only one pointer to its flow-predecessor and another 
to its flow-successor. However, in the edge-disjoint version,
a flow-node can have  flow-predecessors and  flow-successors, with ,
where each combination is possible, giving rise to  
different edge-disjoint paths sets, each of size , passing through this node.
A naive approach would require recording full details of all  possible 
size- paths sets,
or, at least, full details for one of them.

In our simplified approach, we do not keep full path details;
instead, a node needs only two size  lists:
its flow-predecessors list and its flow-successors list.
Using this information, any of the actual  paths sets can be recreated on the fly,
by properly matching flow-predecessors with flow-successors.
As an example, consider node  of Figure~\ref{fig-residual-digraph1}~(d),
which has two flow-predecessors,  and , and two flow-successors,  and ;
thus  is part of four distinct paths.
Node  needs only two size- lists:
its flow-predecessors list, , and its flow-successors list .


\subsection{Possible optimization}
\label{sec-possible-optimization}

We propose a potential speed-up for Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm}.
We restrict this discussion to edge-disjoint paths and standard DFS;
however, the discussion can be generalized to more general flows and other search patterns.
Consider , where . 
Step~6 systematically tries all arcs in .
Without loss of generality, we assume that step~6 
always tries arcs in the order ,
stopping upon the first arc which is identified as starting an augmenting path ,
say , where .
For brevity, we will indicate this by saying that 
arc  is the \emph{first} one that \emph{succeeds}
(and arcs , , \dots  \emph{fail}).

Consider a complete run of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm}.
Assume that this algorithm finds  augmenting paths and then stops. 
Assume that stage~, finds a new augmenting path ,
which starts with arc , 
i.e. arc  is the first one that succeeds at stage~.
A direct implementation of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} 
seems to require that step~6 starts a completely new search for each stage, 
restarting from  and retrying arcs that have been previously tried 
(whether they failed or succeeded).

However, this is \emph{not} necessary.
Theorem~\ref{conjecture} indicates that stage~ does not need to retry 
the nodes that have already been considered (whether they failed or succeeded).
Specifically, the indices indicating the successful arcs in  are ordered by stage number,
, and, at stage~, 
we can start the new search directly from arc 
(where ). 

\begin{theorem}
\label{conjecture}
Step~6 of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} 
can start directly with the arc in  
which follows the previous stage's succeeding arc in .
\end{theorem}

\begin{proof}
At stage , after finding augmenting path , 
the algorithm fragments  
together with the previous set of edge-disjoint paths, , 
deletes some arcs and reassembles a new and larger set of edge-disjoint-paths, ,
such that .

(1) Consider arc , the starting arc of path .
We first show that a successful arc, such as , 
need not be tried again by step~6, for two arguments:

(1.1) Arc  cannot start another augmenting path, 
because all following residual digraphs will only contain 
its reversal , never its direct form .

(1.2) Arc  cannot be revisited as part of another augmenting path.
No augmenting path contains arcs from , 
because the search (DFS or BFS) avoids already visited nodes (marked with ``pebbles''), 
and  is always the starting point and thus the first node marked.
Therefore, once successful arc  is never deleted 
by ``flow pushback operations''.

From (1.1) and (1.2), we conclude that, once successful, an arc in  
will always be the starting arc of an edge-disjoint path
and need not be tried again by step~6.

\medskip

(2) We next show that, once failed, an arc in  will always fail.
This part of the proof is by contradiction.
We select the first arc that succeeds after first failing and we exhibit a contradiction.
Consider that arc  is this arc, which succeeded at stage ,
but failed at least one earlier stage, and let  be the earliest such stage, .
It is straightforward to see that, in this case, 
,
and arc  was tried and failed at all stages 
between  (inclusive) and .

As a thought experiment, let us stop the algorithm after step~.
We have obtained  augmenting paths, thus a set , of  edge-disjoint paths,
starting with arcs , , , 
, , , , .
Following the same though experiment, let us run the algorithm on 
digraph , obtained from , by deleting all arcs in  
except arc  and those arcs that have been successful, 
before arc  was first tried and failed.
More formally, , where
, 
, , , , .
Obviously,  and digraph  admits exactly  edge-disjoint paths, 
because
(a) each of the remaining arcs in  can be the start 
of an edge-disjoint path in  (which do not use any other arc in ), and  
(b) digraph  cannot admit more than  edge-disjoint paths.

It is straightforward to see that, Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm}, 
running on digraph , will follow exactly the same steps as running on digraph , 
up to the point when it first fails on arc .
At this point, the run on digraph  stops, after finding  augmenting paths
and constructing  edge-disjoint paths.

Thus, the algorithm fails, because , which contradicts its correctness.
Therefore, the algorithm will never succeed on an arc that has already failed and
never needs reconsidering again such arcs. 

This completes the second part of the proof. 
\end{proof}


\section{Structural and search digraphs in P~systems}
\label{sec-structural-vs-search-digraph}

In this section, we look at various way to reformulate 
the digraph edge- and node-disjoint path problems as a native P~system problem.
The P~system we consider is ``physically'' based on a digraph,
but this digraph is not necessarily the \emph{virtual} search digraph 
, on which we intend to find edge- and node-disjoint paths.
Given a simple~P~system , where  is its structural digraph,
we first identify cells as nodes of interest, . 
However, after that, we see three fundamentally distinct scenarios,
which differ in the way how the \emph{forward} and \emph{backward} modes 
(i.e. \emph{backtrack} and \emph{consolidation}) of Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} map to the residual arcs and finally to the structural arcs. 

\begin{enumerate}
\item We set . In this case,
the forward mode follows the direction of parent-child arcs of ,
while the backward modes follow the reverse direction,
from child to parent.
\item We set . In this case,
the the backward modes follow the direction of parent-child arcs of ,
while the forward mode of the search follows the reverse direction,
from child to parent.
\item We set . In this case,
the resulting search digraph is symmetric, 
and each of the arcs followed by the forward or backward modes of the search
can be either a parent-child arc in the original  or its reverse.
\end{enumerate}

Cases (1) and (2) are simpler to develop. 
However, in this paper, we look for solutions in case (3), where 
all messages must be sent to all neighbors, parents and children together. 
Therefore, our rewriting rules use the  and
 transfer operators 
(also indicated in Section~\ref{sec-preliminary}).
Figure~\ref{fig-virtual-search-digraph} illustrates 
a simple~P~module and these three scenarios.

\begin{figure}[h]
\centerline{\includegraphics[scale=1.0]{figures/fig-virtual-search-digraph}}
\caption{Three virtual search digraphs for the same simple~P~module.
(a) Same ``physical'' and search structure.
(b) The search structure reverses the ``physical'' structure.
(c) The search structure covers both the ``physical'' structure and its reverse.}
\label{fig-virtual-search-digraph}
\end{figure}

Note that, in any of the three cases, 
Algorithm~\ref{alg-basic-edge-disjoint-paths-algorithm} needs to be able
to follow both the parent-child and the child-parent directions of P~system structure.
Therefore, the structural arcs must support duplex communication channels.

After fixing the directions used by the virtual graph , 
the next problem is to let the nodes identify their neighbors, 
i.e. discover the local network topology.


\section{Discovering cell neighbors}
\label{sec-cell-neighborhoods}

In this phase, cells discover their own neighbors.
Essentially, each cell sends its own ID to all its neighbors and
records the IDs sent from its neighbors.
This is a preliminary phase which is identical, 
for both edge-disjoint and node-disjoint versions.
Table~\ref{tab-neighbors} illustrates the immediate neighborhoods,
discovered at the end of this phase, for the P~system of
Figure~\ref{fig-virtual-search-digraph}~(a), with
the virtual search structure shown in 
Figure~\ref{fig-virtual-search-digraph}~(c). 

\setcounter{table}{\thefigure}
\begin{table}[ht] 
\caption{Neighbors table for the P~system of 
Figure~\ref{fig-virtual-search-digraph}~(a).
An object  indicates that cell  is a neighbor of the current cell.}
\label{tab-neighbors}
\begin{center}
\begin{tabular}{ | c | c | c | } \hline
Cell & Neighbors & Objects \\ \hline 
 &  &  \\ \hline
 &  &  \\ \hline
 &  &  \\ \hline
 &  &  \\ \hline
 &  &  \\ \hline
 &  &  \\ \hline
\end{tabular}
\end{center}
\end{table} 
\addtocounter{figure}{1}

The set of objects used in this phase is 
.
These objects have the following meanings:
 indicates a cell reachable from ;
 is the marker of the source cell;
 is the marker of the target cell;
 indicates that  is a neighbor of the current cell;
,  indicate that  is the target cell;
 only appears in the source cell, while  does not have this restriction.

Initially, the source cell  has one copy of , 
representing the ID of the target cell ,
and the other cells are empty.
All cells start in state .
Each reachable cell progresses through states ,
according to the rules given below.
In these generic rules (as elsewhere in this paper), we implicitly assume that
(1) subscript  is customized for each cell to its cell ID;
and (2) subscript  runs over all cell IDs (),
effectively instantiating  versions of each generic rule where it appears. 

\begin{tabular}[t]{ll}
  \begin{minipage}[t]{3.0in}
  \begin{enumerate}
  \setcounter{enumi}{-1}
  \item Rules for state :
    \begin{enumerate}[1]
    \item 
    \item 
    \item 
  
    \item 
    \item 
    \end{enumerate}
  \end{enumerate}
  \end{minipage}

  \begin{minipage}[t]{3.0in}
  \begin{enumerate}
  \setcounter{enumi}{0}
  \item Rules for state :
    \begin{enumerate}[1]
    \item 
    \end{enumerate}
  \item Rules for state :
    \begin{enumerate}[1]
    \item 
    \end{enumerate}
  \item Rules for state :
    \begin{enumerate}[1]
    \item 
    \item 
    \end{enumerate}
  \end{enumerate}
  \end{minipage}
\end{tabular}

~\

The following example indicates how our generic rules are instantiated to take account  the cell IDs, more specifically, how rules  and  are instantiated in cell :
\begin{itemize}
\item  
\item 
\item 
\item , 
\item 
\end{itemize}

The state transitions performed by cell , , 
are briefly discussed below.

\begin{itemize}
\item :
      If  contains ,  becomes the \emph{source cell}.
      The source cell broadcasts object  to all its neighbors.
      After receiving an object , 
      cell  becomes either the \emph{target cell}, if ;
      or an \emph{intermediate cell}, otherwise.
      Further, each cell relays one of received  objects to all its neighbors.

\item : 
      Cell  broadcasts  to all its neighbors.
      Additionally,  accumulates  objects from neighbors.

\item : 
      Cell  accumulates further  objects from neighbors.

\item : 
      Cell  accumulates further  objects from neighbors.
      Additionally,  removes superfluous  objects.
\end{itemize}


\section{Simple~P~module rules for edge-disjoint paths algorithm}
\label{sec-edge-disjoint-path-algorithm-rules}

First, we give a simple~P~module specification of the 
edge-disjoint paths algorithm presented in Section~\ref{sec-disjoint-paths}.  
We explicitly state our problem in terms of expected input and output.
We need to compute a set of edge-disjoint paths of maximum cardinality
between given source and target cells. 

\smallskip

\noindent \textbf{Edge-Disjoint Paths Problem}\\
\noindent \textbf{Input:} A simple~P~module , 
where the source cell  contains a token  identifying
the ID of the target cell .\\
\noindent \textbf{Output:}  If , each cell 
contains a set of objects  and  
a set of objects  that 
represent a maximum set of edge-disjoint paths from  to , 
where the following constraints hold:\\

\begin{minipage}{5.5in}
\begin{description}
\item[flow-arcs:] 
     , , 
      and 
     .
\item[source and target:] 
      and .
\item[in flow = out flow:] If  then . 
\item[only paths:] 
With ,
.

\end{description}
\end{minipage}

\smallskip

\noindent Because of the network flow properties, we must also have ,
which also represents the maximum number of edge-disjoint paths.

This implementation has two phases: Phase~I, which is the discovery phase
described in Section~\ref{sec-cell-neighborhoods} (using states  to ), 
and Phase~II, described below (which starts in state  and ends in state ).
Table~\ref{tab-edge-output-objects} illustrates
the expected algorithm output, for a simple~P~module with the cell structure
corresponding to Figure~\ref{fig-virtual-search-digraph}~(a).
For convenience, although these are deleted near the algorithm's end,
we also list all the local neighborhood objects 
, for , 
which are determined in Phase~I.

\setcounter{table}{\thefigure}
\begin{table}[ht]
\caption{A representation of maximum edge-disjoint paths for simple~P~module of
Figure~\ref{fig-virtual-search-digraph}~(a).}
\label{tab-edge-output-objects}
\begin{center}
\begin{tabular}{ | c | c | c | c | } \hline
Cell  Objects &  &  &  \\ \hline 
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
\end{tabular}
\end{center}
\end{table}
\addtocounter{figure}{1}

In addition to the set of objects used in Phase~I,
this phase uses the following set of objects:
, , , , , , , 
, , , , , .
In cell , these objects have the following meanings:
\begin{itemize}
\item  indicates a pushback, received from 's flow-successor ;

\item  records the sender of a pushback, if  is not-yet-visited;

\item  records the sender of a pushback, if  has already been visited;

\item  indicates that  is 's flow-successor;

\item  indicates that  is 's flow-predecessor;

\item  records a pushback sent by  to its flow-predecessor ;

\item  records a backtrack request, after a failed pushback to ;

\item  indicates that  is 's search-successor;

\item  indicates that  is 's search-predecessor;

\item  indicates an attempted search extension received from ;

\item  records that  was unsuccessfully tried;

\item  indicates that  rejected a flow-extension or flow-pushback attempt;

\item  indicates that  accepted a flow-extension or flow-pushback attempt;

\item  requests that  resets the record of all tried and visited neighbors;

\item  requests that  remains idle for one step.
\end{itemize}

Initially, the source cell  has one copy of , 
representing the ID of the target cell ,
and the other cells are empty.
All cells start in state .
According to the rules of Phase~I, 
each reachable cell progresses to state ,
which is the start of Phase~II, whose generic rules are given below.
In these rules (as in Phase~I), we implicitly assume that
(1) subscript  is customized for each cell to its cell ID;
and (2) subscripts  run over all cell IDs, ,
and .
To apply the \emph{optimization} proposed in Section~\ref{sec-possible-optimization}, 
replace rule 5.3 ``'' by 
``''.

\begin{tabular}[t]{ll}
  \begin{minipage}[t]{3.0in}
  \begin{enumerate}

  \setcounter{enumi}{3}
  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 

    \item 

    \item 
    \end{enumerate}

\item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 

    \item  
    \item  

    \item 
    \item  

    \item 
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]
\item  

    \item 

    \item 
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]

    \item 
    \item 

    \item 
    \item 

    \item 
    \item 

    \item 
    \item 
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 

\item  
    \end{enumerate}

  \end{enumerate}
  \end{minipage}
&
  \begin{minipage}[t]{3.0in}
  \begin{enumerate}

  \setcounter{enumi}{8}
  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    
    \item 
    \item 

    \item 

    \item 
    \item  
    \end{enumerate} 
  
  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item  

    \item  
    \item  
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 
    \item 
    \item 

    \item 
    \item  
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 
    \item 

    \item 
    \item 

    \item 
    \item 
    \item 
    \end{enumerate}

  \item Rules for a cell  in state :
    \begin{enumerate}[1]
    \item 

    \item 

    \item 
    \item 
    \item 

    \end{enumerate}

  \end{enumerate}
  \end{minipage}
\end{tabular}

The following paragraphs describe details of several critical steps of our edge-disjoint algorithm, such as forward and consolidation modes of intermediate cells.

\begin{itemize}

\item The rules in state  cover the 
      forward mode attempt of an intermediate cell ,
      via a non-flow arc.

      If  has a not-yet-tried neighbor , 
      the search continues with ;
      otherwise the search backtracks.
      

\item The rules in state  cover the 
      consolidation mode for an intermediate cell ,
      who has succeeded a forward extension on a non-flow arc.

      During the consolidation process, the behavior of  depends on 
      whether  was reached by a flow arc or non-flow arc:
      \begin{itemize}
      \item If  was reached by flow arc , in a reverse direction,
             replaces its flow-successor  with ,
            where  is its search-predecessor.
      \item If  was reached by a non-flow arc ,
             sets  as a flow-predecessor and 
             as a flow-successor,
            where  and  are 's 
            search-predecessor and search-successor, respectively.
      \end{itemize}
      
\item The rules in state  cover the 
      forward mode attempt of an intermediate cell ,
      via a pushback.

      If  has a not-yet-tried flow-predecessor ,
      the search continues with 
      (i.e. use flow arc , in a reverse direction);
      otherwise the search backtracks.

\item The rules in state  cover the 
      consolidation mode for an intermediate cell ,
      who has succeeded a forward extension via a pushback to 
      (i.e. on a flow-arc , in a reverse direction).

      During the consolidation process, the behavior of  depends on 
      whether  was reached by a flow arc or non-flow arc:
      \begin{itemize}
      \item If  was reached by flow arc , in a reverse direction,
             removes its flow-predecessor  and 
            flow-successor .
      \item If  was reached by a non-flow arc ,
             replaces its flow-predecessor  with ,
            where  is 's search-predecessor.
      \end{itemize}
\end{itemize}


\begin{theorem}
For a simple~P~module with  cells and  edges,
the algorithm in this section runs in  steps.
\end{theorem}


\section{Simple~P~module rules for node-disjoint paths algorithm}
\label{sec-node-disjoint-path-algorithm-rules}

First, we give a simple~P~module specification of the 
node-disjoint paths algorithm presented in Section~\ref{sec-disjoint-paths}.  
We explicitly state our problem in terms of expected input and output.
We need to compute a set of node-disjoint paths of maximum cardinality
between given source and target cells. 

\medskip

\noindent \textbf{Node-Disjoint Paths Problem}\\
\noindent \textbf{Input:} A simple~P~module , 
where the source cell  contains a token  identifying
the ID of the target cell .\\
\noindent \textbf{Output:}  If , each cell 
contains a set of objects  and  
a set of objects  that 
represent a maximum set of
node-disjoint paths from  to  where the following constraints hold:\\

\begin{minipage}{5.5in}
\begin{description}
\item[flow-arcs:] 
     , , 
        and 
     .
\item[source and target:] 
      and .
\item[node-disjoint:] 
     If  then . 
\item[only paths:] 
     With , .
\end{description}
\end{minipage}

\medskip

\noindent Because of the network flow properties, we must also have ,
which also represents the maximum number of node-disjoint paths.
Notice the constraints to require only paths has been simplified in that the
successor  of non-source cell  is a single cell instead of a set of 
cells that was needed for the general edge-disjoint problem.

\bigskip

Table~\ref{tab-node-output-objects} illustrates
the expected algorithm output, for a simple~P~module with the cell structure
corresponding to Figure~\ref{fig-virtual-search-digraph}~(a).
For convenience, although these are deleted near the algorithm's end,
we also list all the local neighborhood objects 
, for , 
which are determined in Phase~I.

\setcounter{table}{\thefigure}
\begin{table}[ht]
\caption{A representation of maximum node-disjoint paths for simple~P~module of
Figure~\ref{fig-virtual-search-digraph}~(a).}
\label{tab-node-output-objects}
\begin{center}
\begin{tabular}{ | c | c | c | c | } \hline
Cell  Objects &  &  &  \\ \hline 
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
 &  &  &  \\ \hline
\end{tabular}
\end{center}
\end{table}
\addtocounter{figure}{1}

The rules of this node-disjoint path algorithm are exactly 
the rules of the edge-disjoint path algorithm described in 
Section~\ref{sec-edge-disjoint-path-algorithm-rules},
where the rules for state  are replaced by the following group of rules.

  \begin{enumerate}
  \setcounter{enumi}{6}
  \item Rules for a cell  in state :
    \begin{enumerate}[1]

    \item 
    \item 

    \item 
    \item 
    \item 

    \item 
    \item 

    \item 
    \item 
    \end{enumerate}

  \end{enumerate}

The new state  rules implement our proposed non-standard technique 
described in Section~\ref{sec-node-disjoint-paths}, 
for enforcing node capacities to one, 
without node-splitting.


\medskip

The running time of our node-disjoint paths algorithm runs in
polynomial number of steps, since the algorithm is 
direct implementation of Ford-Fulkerson's network flow algorithm.

\begin{theorem}
For a simple~P~module with  cells and  edges,
the algorithm in this section runs in  steps.
\end{theorem}


\section{Conclusion and Open Problems}
\label{sec-conclusion}

Using the newly introduced simple~P~modules framework,
we have presented native P~system versions 
of the edge- and node-disjoint paths problems.
We have started from standard network flow ideas,
with additional constraints required by our model,
e.g., cells that start without any knowledge about the local and global structure. 
Our P~algorithms use a depth-first search technique
and iteratively build routing tables, 
until they find the maximum number of disjoint paths;
Our P~algorithms run in polynomial time, 
comparable to the standard versions of the Ford-Fulkerson algorithms.   
We have proved and used a speedup optimization,
which probably was not previously known.
For node-disjoint paths, we proposed an alternate set of search rules, 
which can be used for other synchronous network models, where, as in P~systems, 
the standard node-splitting technique is not applicable.

All of our previous P~algorithms assumed that the structural relation  
(of a simple~P~module) 
supports duplex communication channels between adjacent P~system cells.  
Substantial modifications are needed when we consider the simplex communication case.  
It is not just a simple matter of changing the rules of the systems to 
only following out-neighbors when we are finding paths from the source 
to the target---we have explicitly utilized the ability to ``push back'' flow 
on a flow-arc, by sending objects to their flow-predecessors, 
when hunting for augmenting paths.  
Thus, some new ideas are needed before we can compute disjoint paths 
when the structural arcs allow only simplex communication.

We also want to know if we can we solve the problem of finding disjoint paths 
between  pairs of , 
that is comparable in performance to the  algorithm of \cite{RobertsonS1995}.

We are interested to know whether a breadth-first search (BFS) approach
would be more beneficial than a depth-first search.  By using BFS we could
potentially exploit more of the parallel nature of P~systems. 

By combining this paper's results with our previous P~solutions
for the Byzantine problem~\cite{DKN-JLAP2010,DKN-CMC2010}, we have now solved one of our original goals, 
i.e. to solve, where possible, the Byzantine problem for P~systems
based on general digraphs, not necessarily complete. 
This more general problem can be solved in two phases:
(1) determine all node-disjoint paths in a digraph, 
assuming that, in this phase, there are no faults; and then 
(2) solve the consensus problem, even if, in this phase, 
some nodes fail in arbitrary, Byzantine ways.
An interesting problem arises, which, apparently, hasn't been considered yet.
What can we do if the Byzantine nodes already behave in a Byzantine manner 
in phase (1), while we attempt to build the node-disjoint paths?
Can we still determine all or a sufficient number of node-disjoint paths,
in the presence of Byzantine faults?

Some of previous experiences~\cite{DKN-MeCBIC2009,NDK-BWMC2009} have suggested that 
P~systems need to be extended with support for mobile arcs,
to incrementally build direct communication channels 
between originally distant cells and we have offered a preliminary solution.
The current experience suggests that this support should
be extended to enable straightforward creation of virtual 
search digraphs on top of existing physical digraphs.

We consider that this continued experience will provide good feedback on
the usability of P~systems as a formal model for parallel and distributed computing
and suggest a range of extensions and improvements, both at the conceptual level
and for practical implementations.


\section*{Acknowledgments}

The authors wish to thank Koray Altag, Masoud Khosravani, Huiling Wu 
and the three anonymous reviewers 
for valuable comments and feedback that helped us improve the paper.


\bibliographystyle{eptcs}
\bibliography{MyRef}  


\begin{table}[h]
\caption{Edge-disjoint paths solution traces (steps ) of the 
simple~P~module shown in Figure~\ref{fig-virtual-search-digraph}~(a),
where  is the source cell and  is the target cell.}
\label{tab-trace}
\begin{center}
\renewcommand{\tabcolsep}{3.0pt}
\renewcommand{\arraystretch}{1.3}
\footnotesize
\noindent
\begin{tabular}{ | l | l | l | l | l | l | l | }
\hline
StepCell
 &  &  &  &  &  &  \\ \hline
0 &  &  &  &  &  &  \\ \hline
1 &  &  &  &  &  &  \\ \hline
2 &  &  &  &  &  &  \\ \hline
3 &  &  &  &  &  &  \\ \hline
4 & \myway{} &  &  &  &  &  \\ \hline
5 &  & \myway{} &  & \myway{} &  &  \\ \hline
6 &  &  & \myway{} &  & \myway{} &  \\ \hline
7 &  &  &  &  &  & \myway{} \\ \hline
8 &  &  &  &  &  &  \\ \hline
9 &  &  &  &  &  &  \\ \hline
10 &  &  &  &  &  &  \\ \hline
11 &  &  &  &  &  &  \\ \hline
12 &  &  &  &  &  &  \\ \hline
13 &  &  &  &  &  &  \\ \hline
14 &  &  &  &  &  &  \\ \hline
15 &  &  &  &  &  &  \\ \hline
16 &  &  &  &  &  &  \\ \hline
17 &  &  &  &  &  &  \\ \hline
18 &  &  &  &  &  &  \\ \hline
19 &  &  &  &  &  &  \\ \hline
20 &  &  &  &  &  &  \\ \hline
21 &  &  &  &  &  &  \\ \hline
22 &  &  &  &  &  & \myway{} \\ \hline
23 &  &  & \myway{} &  &  &  \\ \hline
24 &  &  &  & \myway{} &  &  \\ \hline
25 & \myway{} &  &  &  &  &  \\ \hline
26 &  &  &  &  &  &  \\ \hline
27 &  &  &  &  &  &  \\ \hline
28 &  &  &  &  &  &  \\ \hline
29 &  &  &  &  &  &  \\ \hline
30 &  &  &  &  &  &  \\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{Edge-disjoint paths solution traces (steps ) of the 
simple~P~module shown in Figure~\ref{fig-virtual-search-digraph}~(a),
where  is the source cell and  is the target cell.}
\label{tab-trace1}
\begin{center}
\renewcommand{\tabcolsep}{3.0pt}
\renewcommand{\arraystretch}{1.3}
\footnotesize
\noindent
\begin{tabular}{ | l | l | l | l | l | l | l | }
\hline
StepCell
 &  &  &  &  &  &  \\ \hline
31 &  &  &  &  &  &  \\ \hline
32 &  &  &  &  &  &  \\ \hline
33 &  &  &  &  &  &  \\ \hline
34 &  &  &  &  &  &  \\ \hline
35 &  &  &  &  &  &  \\ \hline
36 &  &  &  &  &  &  \\ \hline
37 &  &  &  &  &  &  \\ \hline
38 &  &  &  &  &  &  \\ \hline
39 &  &  &  &  &  &  \\ \hline
40 &  &  &  &  &  &  \\ \hline
41 &  &  &  &  &  &  \\ \hline
42 &  &  &  &  &  &  \\ \hline
43 &  &  &  &  &  &  \\ \hline
44 &  &  &  &  &  &  \\ \hline
45 &  &  &  &  &  &  \\ \hline
46 &  &  &  &  &  &  \\ \hline
47 &  &  &  &  &  & \myway{} \\ \hline
48 &  &  &  &  & \myway{} &  \\ \hline
49 &  &  & \myway{} &  &  &  \\ \hline
50 &  & \myway{} &  &  &  &  \\ \hline
51 & \myway{} &  &  &  &  &  \\ \hline
52 &  &  &  &  &  &  \\ \hline
53 &  &  &  &  &  &  \\ \hline
54 &  &  &  &  &  &  \\ \hline
55 &  &  &  &  &  &  \\ \hline
56 &  &  &  &  &  &  \\ \hline
57 &  &  &  &  &  &  \\ \hline
58 &  &  &  &  &  &  \\ \hline
59 &  &  &  &  &  &  \\ \hline
60 &  &  &  &  &  &  \\ \hline
61 & \myway{} & \myway{} & \myway{} & \myway{} & \myway{} & \myway{} \\ \hline
\end{tabular}
\end{center}
\end{table}


\begin{table}[h]
\caption{Node-disjoint paths solution traces (steps ) of the 
simple~P~module shown in Figure~\ref{fig-virtual-search-digraph}~(a),
where  is the source cell and  is the target cell.}
\label{tab-trace-node}
\begin{center}
\renewcommand{\tabcolsep}{3.0pt}
\renewcommand{\arraystretch}{1.3}
\footnotesize
\noindent
\begin{tabular}{ | l | l | l | l | l | l | l | }
\hline
StepCell
 &  &  &  &  &  &  \\ \hline
0 &  &  &  &  &  &  \\ \hline
1 &  &  &  &  &  &  \\ \hline
2 &  &  &  &  &  &  \\ \hline
3 &  &  &  &  &  &  \\ \hline
4 & \myway{} &  &  &  &  &  \\ \hline
5 &  & \myway{} &  & \myway{} &  &  \\ \hline
6 &  &  & \myway{} &  & \myway{} &  \\ \hline
7 &  &  &  &  &  & \myway{} \\ \hline
8 &  &  &  &  &  &  \\ \hline
9 &  &  &  &  &  &  \\ \hline
10 &  &  &  &  &  &  \\ \hline
11 &  &  &  &  &  &  \\ \hline
12 &  &  &  &  &  &  \\ \hline
13 &  &  &  &  &  &  \\ \hline
14 &  &  &  &  &  &  \\ \hline
15 &  &  &  &  &  &  \\ \hline
16 &  &  &  &  &  &  \\ \hline
17 &  &  &  &  &  &  \\ \hline
18 &  &  &  &  &  &  \\ \hline
19 &  &  &  &  &  &  \\ \hline
20 &  &  &  &  &  &  \\ \hline
21 &  &  &  &  &  &  \\ \hline
22 &  &  &  &  &  & \myway{} \\ \hline
23 &  &  & \myway{} &  &  &  \\ \hline
24 &  &  &  & \myway{} &  &  \\ \hline
25 & \myway{} &  &  &  &  &  \\ \hline
26 &  &  &  &  &  &  \\ \hline
27 &  &  &  &  &  &  \\ \hline
28 &  &  &  &  &  &  \\ \hline
29 &  &  &  &  &  &  \\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{node-disjoint paths solution traces (steps ) of the 
simple~P~module shown in Figure~\ref{fig-virtual-search-digraph}~(a),
where  is the source cell and  is the target cell.}
\label{tab-trace1-node}
\begin{center}
\renewcommand{\tabcolsep}{3.0pt}
\renewcommand{\arraystretch}{1.3}
\footnotesize
\noindent
\begin{tabular}{ | l | l | l | l | l | l | l | }
\hline
StepCell
 &  &  &  &  &  &  \\ \hline
30 &  &  &  &  &  &  \\ \hline
31 &  &  &  &  &  &  \\ \hline
32 &  &  &  &  &  &  \\ \hline
33 &  &  &  &  &  &  \\ \hline
34 &  &  &  &  &  &  \\ \hline
35 &  &  &  &  &  &  \\ \hline
36 &  &  &  &  &  &  \\ \hline
37 &  &  &  &  &  &  \\ \hline
38 &  &  &  &  &  &  \\ \hline
39 &  &  &  &  &  &  \\ \hline
40 &  &  &  &  &  &  \\ \hline
41 &  &  &  &  &  &  \\ \hline
42 &  &  &  &  &  &  \\ \hline
43 &  &  &  &  &  &  \\ \hline
44 &  &  &  &  &  & \myway{} \\ \hline
45 &  &  &  &  & \myway{} &  \\ \hline
46 &  &  &  & \myway{} &  &  \\ \hline
47 &  &  & \myway{} &  &  &  \\ \hline
48 &  & \myway{} &  &  &  &  \\ \hline
49 & \myway{} &  &  &  &  &  \\ \hline
50 &  &  &  &  &  &  \\ \hline
51 &  &  &  &  &  &  \\ \hline
52 &  &  &  &  &  &  \\ \hline
53 &  &  &  &  &  &  \\ \hline
54 &  &  &  &  &  &  \\ \hline
55 &  &  &  &  &  &  \\ \hline
56 &  &  &  &  &  &  \\ \hline
57 &  &  &  &  &  &  \\ \hline
58 &  &  &  &  &  &  \\ \hline
59 & \myway{} & \myway{} & \myway{} & \myway{} & \myway{} & \myway{} \\ \hline
\end{tabular}
\end{center}
\end{table}


\end{document} 
