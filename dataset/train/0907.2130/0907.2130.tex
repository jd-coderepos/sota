\documentclass[3p,11pt]{elsarticle}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{mathrsfs}
\usepackage{times}
\usepackage{latexsym}
\usepackage{hhline}

\usepackage[latin1]{inputenc} \usepackage{calc}         \usepackage{graphicx}     \usepackage{ifthen}       \usepackage{subfigure}    \usepackage{pst-all}      \usepackage{pst-poly}     \usepackage{multido}      



\newtheorem{statement}{Statement}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newtheorem{construction}{Construction}


\begin{document}

\begin{frontmatter}

\title{Algebraic properties of structured context-free languages:\\ old approaches and novel developments}

\author[Milano]{Stefano Crespi Reghizzi}
\author[Milano]{Dino Mandrioli}
\address[Milano]{DEI - Politecnico di Milano, 
Piazza Leonardo da Vinci 32, \\
I-20133 Milano, Italy\\
e-mail: \{stefano.crespireghizzi, dino.mandrioli\}@polimi.it}



\begin{abstract}
The historical research line on the algebraic properties of structured CF languages initiated by McNaughton's Parenthesis Languages has recently attracted much renewed interest with the Balanced Languages, the Visibly Pushdown Automata languages (VPDA), the Synchronized Languages, and the Height-deterministic ones. Such families preserve to a varying degree the basic algebraic properties of Regular languages: boolean closure, closure under reversal, under concatenation, and Kleene star. We prove that the VPDA family is strictly contained within the Floyd Grammars (FG) family historically known as operator precedence. Languages over the same precedence matrix are known to be closed under boolean operations, and are recognized by a machine whose pop or push operations on the stack are purely determined by terminal letters. We characterize VPDA's  as the subclass of FG having a peculiarly structured set of precedence relations, and balanced grammars as a further restricted case.  The non-counting invariance property of FG has a direct implication for VPDA too.
\end{abstract}

\end{frontmatter}

\section{Introduction}
From the very beginning of formal language science, research has struggled with the wish and need to extend as far as possible the nice and powerful properties of regular languages (specifically closure properties). A major initial step has been made by McNaughton with parenthesis grammars \cite{McNaughton67}, characterized by enclosing any righthand side within a pair of parentheses; the alphabet is the disjoint union of internal letters and the pair. By considering instead of strings the stencil or skeletal trees encoded by parenthesized strings, some typical properties of regular languages that do not hold for CF languages are still valid: uniqueness of the minimal grammar, and boolean closure within the class of languages having the same rule stencils. Further mathematical developments of such ideas have been pursued in the setting of tree automata \cite{Tha67}.
\\
Several decades later, novel motivation arose for the investigation of parenthesis-like languages from the interest for mark-up languages such as XML. The \emph{balanced grammars} and languages \cite{Berstel:2001:BGT} generalize the parenthesis grammars in two ways: several pairs of parentheses are allowed, and the right-hand side of the grammar rules permit a regular expression over nonterminal and internal symbols to occur between matching parentheses. The property of uniqueness of the minimal grammar is preserved, and the family has the property of closure w.r.t. concatenation and Kleene star, that was missing in parenthesis languages. Clearly balanced as well as parenthesis languages are closed under reversal.
\\
Model checking and static program analysis provide an entirely different long-standing motivation for such families of languages --- those that extend the typical regular properties to infinite-state pushdown systems. To the best of our knowledge the seminal paper of this ``new era'' is \cite{AluMad04} which defines \emph{visibly pushdown automata} and \emph{languages} (VPDA), a subclass of realtime pushdown automata  and deterministic context-free languages. The input alphabet is partitioned into three sets named calls, returns and internals, and the decision of the type of move to perform (push, pop, or a stack neutral move) is determined by the membership of the current input letter; in other words the type of a move is solely input-driven. VPDA languages extend balanced grammars in two ways that are important for modelling symbolic program execution: they allow parentheses to remain unbalanced to represent an execution state where some procedures have not returned, and a call symbol can be matched by two or more return symbols to represent procedures with multiple exits. For each partitioned alphabet the corresponding language family is closed under the regular operations, including complement. VPDA's can be determinized and reversal produces a VPDA with calls and returns interchanged. We observe that the intended applications to static program analysis need closure under reversal in order to compute the pre- and post-reachability sets.
\\
Impulsed by this new approach, a variety of extensions and specializations of the original class have been proposed and investigated. Among them, we mention the following.
 The \emph{synchronized pushdown automata} \cite{conf/dlt/Caucal06}, instead of the fixed 3-partition of VPDA's, use
 a finite transducer that determines the type of move the PDA must perform.
\\
 The \emph{height-deterministic automata} \cite{conf/mfcs/NowotkaS07} further extended the previous idea by considering the class of PDA's characterized by the same integer-valued function returning the height of the stack for each input string; within this approach the deterministic and the real-time cases are singled out for having richer closure properties.
 Last, the \emph{synchronized grammars} \cite{caucal:DSP:2008:1743} are a more comprehensive model
 that uses an input-driven pushdown transducer to decide the type of a move. Not surprisingly, such more general models lose certain nice properties of VPL, in particular the closure under reversal, concatenation, and Kleene star.
\\
Short after McNaughton's results, we investigated similar closure properties of \emph{Floyd's} operator precedence \emph{Grammars} \cite{Floyd1963} \footnote{We propose to name them \emph{Floyd grammars} to honor the memory of Robert Floyd and also to avoid confusion with other similarly named but quite different types of precedence grammars.} (FG), an elegant precursor of LR() grammars, also exploited by one of us in his work on grammar inference \cite{crespi-72}. For any given precedence matrix a syntax tree stencil is defined a priori for any word that is generated by any FG having the same precedence matrix. The family of such Floyd grammars and the related languages are a boolean algebra \cite{Crespi-ReghizziMM1978}. We also extended the notion of non-counting regular language of McNaughton and Papert \cite{McNaughtPap71} to the parenthesis languages \cite{CreGuiMan78} and to FG \cite{CreGuiMan81}.
\\
In this paper we resume the study of FG in the perspective of the cited grammatical models. We show that VPDA is a special case of FG characterized by a very restricted structure of the precedence relations, thus providing a new characterization of VPDA in terms of operator grammars. Further restrictions are shown for the case of balanced languages. Then we compare FG with the height-deterministic family showing strict inclusion, and that reversal closure is lost by that generalization.
\\
The paper is structured as follows: Section \ref{SectBasicDef} provides the essential definitions of the main classes of languages (defined through automata and/or grammars) that will be considered in this paper (others will be referred only on the basis of previous literature); Section 3 investigates the mutual inclusion relations among them. Section 4 compares the same classes of languages w.r.t their closure properties. The conclusion mentions that the non-counting invariance property of FG has a direct implication for VPDA too and shows that the whole picture of such language families deserves further analysis to answer a few remaining open issues.
\section{Basic definitions}\label{SectBasicDef}
We list the essential definitions of parenthesis and balanced grammars, VPDA, height-deterministic automata, and Floyd grammars. For brevity, other classes are not defined here because they can be somewhat put in relation with the above "basic" ones. They are nevertheless taken into consideration in Section 4. The same name is given to a class of devices (grammars or automata) and to the class of languages that can be defined by means of them.
\\
The empty string is , the terminal alphabet is . For a string  and a letter ,  denotes the number of occurrences of letter , and extend the notation to , for a set . Let  and  denote the first and last letter of . The projection of a string  on  is denoted .
\\
The operators union, concatenation, and Kleene star are called \emph{regular}. A \emph{regular expression} is a formula written using the regular operators, parentheses and letters from a specified alphabet.
\\
A \emph{Context-Free} CF grammar is  a 4-tuple , where  is the nonterminal alphabet,  the rule set, and  the axiom. An \emph{empty rule} has  as the right part. A \emph{renaming rule} has one nonterminal as right part. A grammar is \emph{invertible} if no two rules have identical right parts.
\\
A rule has the \emph{operator form} if its right part has no adjacent nonterminals, and an \emph{operator grammar} (OG) contains just such rules. Any CF grammar admits an equivalent OG, which can be also assumed to be invertible \cite{Harrison78}.
\\
For a CF grammar  over ,  the associated \emph{parenthesis grammar} \cite{McNaughton67}   has the rules  obtained by enclosing each right part of a rule of  within the parentheses `' and `' that are assumed not to be in .
\\
A \emph{balanced grammar} \cite{Berstel:2001:BGT} is a CF grammar  has a terminal alphabet partitioned into , where  is a set of \emph{matching parentheses} and the elements of  are named \emph{internal}. Let  be the nonterminal alphabet. Every rule of a balanced grammar has the form  or , where  is a regular expression over . The corresponding family is denoted BALAN.
\\
A \emph{pushdown automaton} PDA  over an alphabet  is a tuple , where the initial state  and  are the final states.  is the stack alphabet containing , the stack bottom symbol. The transition relation is
\\

\\
The notation \cite{conf/mfcs/NowotkaS07}  is equivalent to .
\\
A PDA is called \emph{realtime} (RPDA) if .
\\
A PDA is called \emph{deterministic} (DPDA) if for every   and  we have  and 
\\
A \emph{realtime deterministic} PDA is named a RDPDA.
\\
The set  is the set of \emph{configurations} of a PDA, with \emph{initial} configuration .
\\
The \emph{labelled transition system} generated by  is the edge-labeled directed graph

Given a string , we write  if there exists a finite -labelled path, , from  to , and  is the projection of  onto . Notice that according to \cite{conf/mfcs/NowotkaS07} the -labelled path includes transitions of the type .
\\
An  is \emph{complete} if .
\\
The language \emph{recognized} by  is 
\\
A PDA  is \emph{normalized} \cite{conf/mfcs/NowotkaS07} if
\begin{enumerate}
    \item  is complete;
    \item for all , all rules in  of the form 
    either satisfy , or all of them satisfy , but not both;
    \item every rule in  is of the form
    \begin{itemize}
        \item 
        \item 
        \item  where 
    \end{itemize}
\end{enumerate}
For a normalized PDA moves are named \emph{push} if , \emph{pop} if , and internal if . The normalization preserves the characteristics of DPDA, RPDA and RDPDA devices.
 \subsubsection*{Height-determinism}
 Let . The set  of \emph{stack heights} reached by  after reading  is . A \emph{height-deterministic} PDA (HPDA) is a PDA that is normalized and such that  for every .
\\The families of height-deterministic PDA's, DPDA's, and RDPDA's  (and languages) are resp. denoted by HPDA, HDPDA, and HRDPDA.
\\
A normalized DPDA is an HDPDA and the language families HPDA and CF coincide \cite{conf/mfcs/NowotkaS07}.
\\
Two HPDA's  and  over the same alphabet  are in the equivalence relation \emph{H-synchronized}, denoted by , if  for every .
\\
Let  denote the equivalence class containing the HPDA  and  denote the class of languages recognized by any HPDA H-synchronized with .
\subsubsection*{Visibly pushdown automata}
A \emph{visibly pushdown} (VP) \cite{AluMad04} alphabet is a 3-tuple , with  the disjoint union of the three sets.  Elements of the three sets are resp. termed \emph{calls}, \emph{returns} and \emph{internal} letters.
\label{DetvisibPushdownAut} A  \emph{VP automaton} VPDA is a  PDA , where  is a VP alphabet. The transition relation is

that can be readily seen to specialize the previous definition for a general PDA.
\subsubsection*{Floyd or operator precedence grammars}
The  definitions for operator precedence grammars, here renamed \emph{Floyd Grammars} (FG), are from \cite{Crespi-ReghizziMM1978}. (See also \cite{GruneJacobs:08} for a recent presentation.) \label{LeftRightSets}
\\
For a nonterminal  of an OG , the \emph{left and right terminal sets} are

where  and  denotes, as usual, a derivation. The two definitions are extended to a set  of nonterminals and to a string  via

 where  is a new nonterminal and  is the same as  except for the addition of the
 rule .  Finally  . The definitions for  are similar.
\\
 \label{PrecRelat}
For an OG , let  and  , three binary operator precedence (OP) relations are defined:
\begin{center}
\begin{tabular}{cc}
  equal precedence:  &  iff , ; \\
  yields precedence:  &  iff ,  and  \\
  takes precedence: &  iff ,  and ; \\
\end{tabular}
\end{center}
\label{OPMatrixOPG} For an OG , the \emph{operator precedence matrix} (OPM)  is a  array that to each ordered pair  associates the set  of OP relations holding between  and .
Given two  OPM's   and , we define
\\

\\
 is a \emph{Floyd grammar} FG if, and only if,  is a \emph{conflict-free} matrix, i.e., , . Two matrices are \emph{compatible} if their union is conflict-free.
\\
A FG is in \emph{Fischer normal form \cite{Fischer69}} if it is invertible, the axiom  does not occur in the right part of any rule, and there are no renaming rules, except those with left part  (if any).
\par
For the reader convenience the acronyms are collected in the table:
\begin{center}
\begin{tabular}{l|l}
  \hline
  BALAN & balanced grammar \\
  CF & context-free \\
  DPDA & deterministic pushdown automaton \\
  FG    & Floyd grammar \\
  HDPDA & height-deterministic deterministic pushdown automaton \\
  HPDA & height-deterministic  pushdown automaton \\
  HRDPDA & height-deterministic realtime deterministic pushdown automaton \\
  OG & operator grammar \\
  OPM & operator precedence matrix \\
  REG & regular language \\
  RDPDA & realtime deterministic pushdown automaton \\
    RPDA & realtime pushdown automaton \\
  PDA & pushdown automaton \\
  VPDA & visibly pushdown automaton\\
  \hline
\end{tabular}
\end{center}
\section{Containment relations}
First we recall some of the relevant known \cite{AluMad04,conf/mfcs/NowotkaS07,conf/csr/LimayeMM08,caucal:DSP:2008:1743} containment relations between some recent language families, then we position FG within the picture. The main  strict inclusions are:
\begin{center}

\end{center}
Notice that the above inclusions preserve the structural properties of the languages: for instance if the partition of a VP alphabet places a letter in  and therefore associates a push move to it, the corresponding HDPDA automaton too performs a push move on that letter.
\\
The first \cite{conf/dlt/Caucal06} and second \cite{conf/csr/CaucalH08} family of Caucal, as well as the one of Fisman and Pnueli \cite{FisPnu01} fall in between VPDA and DPDA. but lack of space prevents a detailed presentation.
\\
\label{SectVPAareOPG} Next we focus on FG  languages. It is well-known that . On the other hand, FG includes non-realtime deterministic languages such as . Observing that  is in HRDPDA but not in FG, since, by an elementary application of the pumping lemma, this would imply a precedence conflict, we have:
 \begin{proposition}
 The families of FG and HRDPDA languages are incomparable.
 \end{proposition}
 Our main result is that the VPDA languages are a well-characterized special case of
 FG languages. First we give a construction from a VPDA to a FG having a
 certain type of precedence matrix, second we construct a VPDA for any FG with such matrices.
At last we include also BALAN in the matrix-based characterization.
\\
 We need to analyze the structure of  VPDA strings.
 A string in  is \emph{well parenthesized} if it reduces to  via the cancellation rule .
\\
Let  be the alphabetical mapping from  to  defined by , , and . A non-empty string  is \emph{well balanced} if   is well parenthesized; it is \emph{well closed} if in addition  and .
\\
Let  be a VPDA, with .
\begin{lemma}\label{LemmaStruttVPL}
 Any
string  can be factorized as\\
   or ,   with , such that
\begin{enumerate}
\item  where , and  is a, possibly missing, well-closed string;
    \item
    
 where  and  is a, possibly null, well-balanced string.
\end{enumerate}
\begin{proof}
 Let the transitions from state  to   be labelled as follows:  denotes a move of type ;
   denotes a move of type  with ;
   denotes a move of type ;
   denotes  a move of type .
 \\
  We examine the possible sequences of moves of a suitable VPDA  that for convenience is non-deterministic (determinization is always possible \cite{AluMad04}).
  We only discuss the case , since the case  is simpler.
\\
The computation starts with a series of moves in , which scan the prefix 
 and leave the stack empty.
\\ Then the machine may do a series of moves to scan string .
    The first move is of type . The move is
 possibly followed  by a nested computation scanning a well-balanced string, and at last by a move of type . The effect is  to scan a well balanced string . Clearly the nested computation may also include internal moves.
\\ After scanning  the stack is empty, and the
 computation may scan  , and so on, until  is scanned.
\\ Alternatively and non-deterministically, when the stack is empty, the machine may perform a move
    ,  thus  entering the phase that scans string . We denote as  a symbol written on the stack, which will never be touched by a subsequent pop move. In other words,  is nondeterministically assumed to be an unmatched call.
\\ Then the  phase non-deterministically scans a well balanced string . Then, again nondeterministically, it may
perform a move . Then it may scan another well balanced string , and so on, ending with a stack in .
\\
  At any time, when the machine enters a final state, it may halt and recognize the scanned input.
\end{proof}
\end{lemma}
Clearly  string  is the longest prefix such that the accepting computation ends with empty stack. For simplicity, without loss of generality, we assume that no transition enters the initial state . For convenience we shall denote by a subscripted letter  the states traversed while scanning , and by a subscripted letter  the states traversed in the computation of . The state set is thus partitioned into .
\par
Since VPL's are CF languages, previous papers (e.g. \cite{LaTorreNP06}) have also used grammars to define them,
 but such grammars are not OG or have precedence conflicts; instead, we present a construction producing a grammar with the required properties.
\begin{theorem}\label{TheorVPD2OPG}
For any  visibly pushdown automaton  a Floyd grammar  such that  can be effectively constructed.
\begin{proof}
 First we construct the grammar, then we prove that it is an FG, and lastly that it is equivalent to .
\end{proof}
\end{theorem}
\emph{Grammar construction}.\label{OPGgrammarConstr}
\\
 The rules are keyed to the factorization of Lemma \ref{LemmaStruttVPL} and are listed in Tables \ref{productionsS}, \ref{productionsY},  \ref{productionsB}, and \ref{productionsZ}. The scheme of a sample syntax tree produced by the grammar, for a string factorized as in Lemma \ref{LemmaStruttVPL}, is shown in Fig. \ref{figureTree}.
\begin{figure}[h!]
\begin{center}
 \scalebox{1.0}{\psset{arrows=-,linestyle=solid,levelsep=15pt}

\pstree{\TR{}}
 {
  \pstree{\TR{}}
    {


   \pstree{\TR{}}
    {

   \pstree{\TR{}}
    {

   \pstree{\TR{}}
    {


    \pstree{\TR{}}
    {
    \TR{}
    }


    \TR{}

    \pstree{\TR{}}
    {
    \TR{}
    }

    \TR{}

    }
    \TR{}

    }
    \TR{}

    \pstree{\TR{}}
    {
    \pstree{\TR{}}
    {
    \TR{}  \TR{}
    }

    \TR{}
    }
    \TR{}
    }
    \TR{}
    }


 \TR{}

      \pstree{\TR{}}
    {

      \pstree{\TR{}}
    {
    \TR{}

    \pstree{\TR{}}
    {
    \TR{}
    }

    \TR{}

    }

    \TR{}
    \pstree{\TR{}}
      {
\pstree{\TR{}}
    {
    \TR{}
   \pstree{\TR{}}
    {
    \pstree{\TR{}}{\TR{}}

    \TR{}\TR{}

    }
    \TR{}

    }
    \TR{}


      }

    }



 }
 }
\end{center}
\caption{\label{figureTree}Schema of a syntax tree generated by the precedence grammar constructed in Theor. \ref{TheorVPD2OPG}.}
\end{figure}

\begin{figure}[h]
\begin{center}

\end{center}
\caption{\label{figureTotalVPmatr}\emph{Total VP precedence matrix} . }
\end{figure}
Nonterminals of class  generate a string such that the automaton, parsing it, starts and ends with empty stack. Nonterminals of classes  derive a well-balanced (but not necessarily well-closed) string. Nonterminals of class  derive a string such that, starting with a non-empty stack of the form , the stack never pops a  and at last contains a string in .
\\
The nonterminal symbols of the grammar are denoted  by a pair of states  or , or by a triple  or , with . Intuitively, a nonterminal of the generic form  generates a terminal string  if, and only if, there is a computation of the machine from the left state  to the right state   which reads the same string and never modifies the initial stack. Furthermore, nonterminals  leave the stack unchanged; nonterminals  at most increase the number of 's; and nonterminals  or  denote that the computation starts and ends with  on the top and generates a well-balanced terminal string .
\\
To construct the rules we examine the transitions of the  VPDA. In what follows, calls, returns and internal letters are respectively denoted  and ;  are stack symbols different from .
\begin{table}[h!]
\caption{\label{productionsS}Productions of the axiom. }
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{l|p{5cm}|p{6cm}}
  case & transitions  & rules \\
  \hline
  &  &   ,  \\

      &   &  ,   \\

       & , &    \\

        &  &  ,  \\

      & ,  &  \\
  \hline
\end{tabular}
\end{table}
\begin{table}[h!]
\caption{\label{productionsY}Productions of nonterminals of class  (deriving the maximal prefix ending with empty stack). }
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{l|p{6cm}|l}
  case & transitions  & rules \\
  \hline
  &  &     \\

     &  &   \\

     &  &   \\

     &  & \\

    &  and   & \\

    &  and   & \\

  &  and  & \\

   &  and  and  &  \\

  \hline
\end{tabular}
\end{table}
\begin{table}[h!]
\caption{\label{productionsB}Productions for  nonterminals of classes  and , generating well-balanced string. (The case  just differs with respect to the state set, which is  instead of .) }
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{l|p{6,3cm}|p{7,0cm}}
  case & transitions  & rules \\
  \hline
  &  and 
                   & , \\


    &    and 
                        & ,  \\

   &    and 
                        &  \\


    &  and 
                      & ,  \\

 &  and 
                   & ,  \\

   &    and  & ,   \\


  &  and   & ,   \\

    &  & ,  \\

      &  & ,  \\\hline
\end{tabular}
\end{table}
\begin{table}[h!]
\caption{\label{productionsZ}Productions for  nonterminals of class . }
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{l|p{6,2cm}|p{7cm}}
  case & transitions  & rules \\
  \hline
  &  & ,  \\

  & ,  &  \\

       &  & , 
     \\

      & ,   &  \\

    &  and 
                   & , \\


      &    and 
                        & , \\

      &    and 
                        & ,  , \\

     &  and 
                      & ,  \\

       &  ,     &   ,   \\

       &    ,         &    \\
\hline
\end{tabular}
\end{table}
 Notice that the grammar  constructed may be not reduced (i.e. some nonterminal may be unreachable from the axiom or it may not derive any terminal string). In that case the useless nonterminals and rules can be removed by well-known algorithms (e.g. in \cite{hopullman:automata}).
\subsubsection*{ is a Floyd grammar}
By construction all the rules are in operator form. To verify that the operator precedence matrix  is conflict-free, it suffices to compute  the relevant terminal sets the matrix entries using  the previous definitions. It should be enough to show one case.
\\
 For the rule  the set
 produces the relations . The sets ,   determine  and ; the right part of the rule gives . Thus we obtain a conflict-free matrix  where  is the total matrix in Fig. \ref{figureTotalVPmatr}.

\begin{figure}[h]
\begin{center}
\scalebox{0.84}{\psset{arrows=->,labelsep=1pt,colsep=1mm, rowsep=3mm}
\begin{psmatrix}
\\
 & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - &- & - & - & - & - & - & - & 
\\
 &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - & - &- & - & - & - & - & - & - & 
\\
 &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - & - & - & - & - & - & - & - &- & - & - & - & - & - & - & 
\\
 &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - &  &  & - & - & - & - & - &- & - & - & - & - & - & - & 
\\
 &  & - & - & - & - & - & - & - & - & - & - &  &  & - & - & - & - & - & - & - & - &  &  &  &  & - & - & - & - & - & - &  &  & - & - & - & - & - &- & - & - & - & - &  &  & 
\\
 &  & - & - & - & - & - & - & - & - &  &  &  &  & - & - & - & - & - & - &  &  &  &  &  &  & - & - & - & - & - & - &  &  &  &  & - & - & - &- & - & - &  &  &  &  & 
\\
 &  & - & - &  &  & - & - &  &  &  &  &  &  & - & - & - & - &  &  &  &  &  &  &  &  &  &  & - & - &  &  &  &  &  &  & - & - &  &  &  &  &  &  &  &  & 
\\
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  & 
 \\




\end{psmatrix}
}


\end{center}
\caption{\label{figureParsingRelations}Precedence relations between letters during the parsing of the string of Fig. \ref{figureTree}. The dummy string delimiters  by hypothesis respectively yield and take precedence over any other letter. }
\end{figure}
Fig. \ref{figureParsingRelations} reproduces the string of Fig. \ref{figureTree} with precedence relations between letters that are consecutive or separated by a nonterminal.
\subsubsection*{Proof that }
It is obtained by a fairly natural induction showing the double implication between computations and derivations. It is structured into several ``macro-steps'' mirroring the factorization introduced in Lemma \ref{LemmaStruttVPL}. We develop in detail only a sample of the various cases, since the others are similar.
\begin{enumerate}
    \item , .
    \\

    \item ,  and well-balanced.
    \\

    \item ,  and well-balanced.
    \\

    \item .
    \\
\item ,
     (without ever popping )
    , where  is a well-balanced string.
    \\
    Induction base:
    \begin{enumerate}
        \item 


        \item 
    \end{enumerate}
     From the inductive hypotheses:
     \begin{enumerate}
        \item 

        \item  

        \item  

        \item  

    \end{enumerate}
\end{enumerate}
we derive:

Special cases, such as  and many others, can be similarly treated.
 \qed
 N.B. Each inductive proof of the various assertions may exploit other assertions in the inductive steps.
 For instance the inductive hypothesis (a) above is based on assertion 3.
\par
\label{SectStrictInclus} A natural question is whether every FG defines a VPDA language or not.
\begin{theorem}\label{TheorStrictInclusion}
The VPDA language family is strictly included in the FG family.
\begin{proof}
\label{ProposCounterexample} The  language

is a FG language  but not a VPDA language.
  is generated by the FG grammar\\

\\
which has precedence relations :

From  it follows  must be a call and  a return. For similar reasons,  must be a call and  a return. From  it follows that at least one of  and  must be a return, a contradiction for a VP alphabet.
\end{proof}
\end{theorem}

\subsection*{FG with a partitioned precedence matrix}\label{SectRestrOPGareVPL}
We prove that the OPM structure obtained in the proof of Theor. \ref{TheorVPD2OPG} is a sufficient condition for an FG to generate a VPDA language thus obtaining a complete characterization of VPDA as a subclass of FG.
\\
For an alphabet , let  be an OPM such that there exists a partition of  into three subsets  and,  satisfying the conditions:
\\
 and 
\\

\\

\\
Then  is termed a \emph{total VP-matrix}  representing the VP alphabet , shown in Fig. \ref{figureTotalVPmatr}. Any OPM  is termed a \emph{VP-matrix}.
\\
Observe that, for any  grammar , such that  is a VP-matrix, any rule  has . The possible stencils (or skeletons) of the right parts of the rules are , and those obtained by erasing one or more . Notice that the stencils  are forbidden because  does not yield precedence to any letter. It follows that, for any FG having a VP matrix, the length of any right part is .
\begin{theorem}\label{TheorRestrOPGisVP}
Let  be an FG such that  is a VP matrix. Then  is a VPDA language.
\begin{proof}
First we argue that the grammar generates any string in  with a syntax structure corresponding to the factorization presented in Lemma \ref{LemmaStruttVPL}. Then, in Lemma \ref{LemmaRestrOPG2VPA}, we construct a VPDA equivalent to .
\\
Let  satisfy the hypotheses of Theor. \ref{TheorRestrOPGisVP}. For every string , the syntax tree induces the factorization\\

\\where all terms are as
in Lemma \ref{LemmaStruttVPL}, and its syntax tree has the structure shown in Fig. \ref{figureTree}. It suffices to consider that the precedence relations of the VP matrix completely determine the skeleton of the syntax tree (see Fig. \ref{figureParsingRelations}).
\end{proof}
\end{theorem}

\begin{lemma}\label{LemmaRestrOPG2VPA}
Let   satisfy the hypotheses of Theor. \ref{TheorRestrOPGisVP}. Then  is recognized by a VPDA automaton , which can be effectively constructed.
 \begin{proof}
  We specify how to construct from the grammar rules a VPDA , that recognizes by final state and for convenience is nondeterministic. We recall the rule stencils are just the ones previously listed.
\\
We set , where  . The pushdown vocabulary is

Intuitively,  is built in such a way that it enters a state  after finishing the scanning of a substring syntactically rooted in .
\\
In state , reading a symbol   (the only ones that yield precedence),  enters state   and pushes  on the stack a symbol, for which two cases occur. The symbol is , if the  is not to be matched by an ; it is , if the machine ``looks for'' a well-balanced string  such that . Simpler special cases also occur, such that  pushes on the stack a symbol  or , ``looking'' directly for .
\\
In state , reading a ,   remains in the state and pushes on the stack either the symbol  if the  is not to be matched, or a symbol  if it ``looks for'' a string  such that .
\\
Finally we describe the moves that read . If the stack is empty, the machine  enters a state  associated to a nonterminal. If the top of stack is a symbol , the machine pops the stack and enters a state . Here too some simpler special cases exist.
\\
The final states set is defined as . Notice that a rule  can be used only in a derivation  such as , otherwise  would take precedence over some other letter. Thus,  and  are both in .

\begin{table}[h!]
\caption{\label{tableVPAMoves} Transition relation  of .}
\renewcommand{\arraystretch}{1.3}
\begin{center}
\begin{tabular}{|l|p{4cm}|p{5cm}|}  \hline
  & rules  &   \\
  \hline
 1& & 
 \\
  &,\quad such that   & 
  \\
  \hline
 2&  & 
 \\
 &   & 
 \\
 &  & 
  \\
  \hline
 3&  & 
  \\
 &  & 
  \\
  \hline
 4&  & 
  \\
                 && 
 \\
 &  & 
  \\
  &  & 
  \\
 &  & 
  \\
  & & 
  \\
                  && 
  \\
  & & 
  \\

                  && 
  \\
  \hline
  5&  & 
  \\
                  && 
  \\
  &   & 
  \\
                  && 
  \\  \hline
\end{tabular}
\end{center}
\end{table}
The transition relation  is then built from  according to Table \ref{tableVPAMoves}. Notice that the derivations  needed in section 1 of the table can be effectively computed.
\\
The proof of the equivalence  somewhat mirrors the equivalence proof of Theor. \ref{TheorVPD2OPG}. For instance, from  section 2 of Table \ref{tableVPAMoves} the following lemma immediately descends:

Similarly, the lemma

can be proved by a natural induction, taking as the basis the cases  and , and then exploiting for the induction steps sections 2, 4, and 5  of Table \ref{tableVPAMoves}. Further details of the proof are omitted as fairly obvious.
\end{proof}
\end{lemma}
Second, we remark that various subclasses of VPDA languages recently considered correspond to restrictions on the VP-precedence matrix and/or on the stencils of the grammar rules. A nice illustration is the family BALAN \cite{Berstel:2001:BGT}. First, balanced grammars do not allow  any  or  to be unmatched. Thus an FG such that no rule has the stencils  ensure the balancing property. Second, balanced grammars do not allow a  to be matched by distinct returns  (and similarly for ). An FG such that  and the OPM submatrix identified by rows  and columns  contains  only on the diagonal, ensures the bijection of call and return letters.

\section{Closure properties}
All families considered here (except DPDA) share the property of being boolean algebras, for suitably defined subsets.  The core of the property dates back to the original approach by McNaughton and the "structure preserving" operations as in \cite{Crespi-ReghizziMM1978}. Other closure properties possessed by VPDA, though relevant and classical, have been less investigated. It appears that all the previous families more general than VPDA lack  some closure properties, as shown in the next table.
\begin{center}
\begin{tabular}{|c||p{4cm}|c|c|}\hline
   family  & boolean operations & concatenation, Kleene star & reversal  \\
  \hline\hline
  VPDA \cite{AluMad04}& yes for a fixed VP alphabet & yes for a fixed VP alphabet & yes \\ \hline
  FG & yes for compatible precedence matrices \cite{Crespi-ReghizziMM1978}& yes & yes (proved here) \\\hline
  HRDPDA & yes for H-synchronized languages \cite{conf/mfcs/NowotkaS07} & no \cite{caucal:DSP:2008:1743} & no (proved here)  \\
  \hline
\end{tabular}
\end{center}
The reversal of a FG language is generated by the specularly reversed rules; they are a FG grammar with a matrix obtained interchanging yield- and take-precedence relations.
\\
We observe that the boolean closure of  FG languages has been  proved in \cite{Crespi-ReghizziMM1978} by extending McNaughton's method for parenthesis languages. It states that the union of two FG having compatible precedence matrices is a FG language with compatible matrices, and similarly for the other operators. We notice that this is not implied by  the closure property \cite{conf/mfcs/NowotkaS07} of the equivalence class of H-synchronized HDPDA languages, although  two FG's having compatible matrices are necessarily H-synchronized\footnote{For brevity we omit the natural construction of the HDPDA equivalent to a FG grammar.}.
\\
On the other hand the closure of VPDA languages for a given VP alphabet, under the boolean operators and under reversal, are an immediate consequence of the same properties of the family of FG languages having compatible precedence relations,
\\
Since HRDPDA=RDPDA, the non-closure under reversal follows from a classical counterexample, used for proving the same for deterministic languages: the reversal of  is non-deterministic.
\\
The proof\footnote{A complete proof is under development.}  of concatenation and Kleene star closures for FG's is more intricate than with other traditional families of CF grammars due to the need to preserve the operator structure and the precedence relations. For kleene star the property requires the assumption that the  relation does not contain cycles.
\\
In conclusion, the FG family is currently the one, among the existing VPDA generalizations, that preserves the majority, and possibly the totality, of VPDA closure properties.

\section{Conclusions}\label{SectConclusion}
We mention some open questions raised by the present study.
\\
FG appears at present to be the family that preserves the majority, and possibly the totality, of VPDA closure properties, but we wonder whether more general families can be found with the same properties.
\par
In a different direction, it is possible to transfer to VPDA a rather surprising invariance property of FG. We recall the definition of \emph{Non-Counting context-free} grammar \cite{CreGuiMan78}, which extends the notion of NC regular language \cite{McNaughtPap71}.  is NC if for the parenthesized language , the following condition holds: , where  and  are well-parenthesized, and ,  if, and only if, . In general, two equivalent CF grammars may differ with respect to the NC property. However if an FG grammar is NC, then all equivalent FG grammars are NC \cite{CreGuiMan81}. Consider now, for a VPDA , two equivalent VPDA recognizers. Notice the two VP alphabets may differ with respect to the 3-partition of the letters. The two corresponding FG's (Theor. \ref{TheorVPD2OPG}) may differ in precedence relations, but they are either both NC or both counting. We wonder whether such invariance property holds for other families of grammars generalizing VPDA.
\par
Last, it would be interesting to assess the suitability of Floyd languages for the applications that have motivated balanced grammars and VPDA. We observe that the greater generative capacity of FG's permits to define more realistic recursively nested structures. For instance, the VPDA approach uses single letters to represent a call  and the corresponding return , but this is just an abstraction. In real programming languages a call is a string typically containing the name of the invoked procedure and possibly a list of parameters. Also, at it is suggested by the example in the proof of Theor \ref{TheorStrictInclusion}, a return corresponding to a given call may use the same letters as some other call. This will cause conflicts in the partitioning of , but can be dealt with by suitable precedence relations. Similar examples can be found in the area of mark-up languages.
\\
Finally, for application in model checking, the computational complexity of the decision problems for FG languages should be studied.



\bibliographystyle{plain}
\bibliography{VPDbib}
\end{document}
