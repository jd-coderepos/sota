\chapter{Implementations} \label{sec:impl}

In this chapter, we present two implementations of controllers for SAR robots, one for stationary target search in an USAR application, and the other for moving target search in a WiSAR application. In the stationary target search, a central authority, called the ``allocator'' is responsible for dispatching the robots to the vertices in the graph where a target needs to be rescued. In the moving target search, a distributed solution is adopted, where the authority structure among the robots is already negotiated in advance, cf.\ \sec{negotiations}.\\

\section{SAR of Stationary Target} \label{sec:statSAR}

In USAR\index{USAR}, the targets are mostly considered stationary. We develop specifications to build controllers for a team of robots that is managed by a central allocator. The goal is to find all targets in the affected area and rescue them. A robot that is at the location of a target may {\bf engage} with it by performing a rescue task like providing medical support. In this scenario, we will consider a target to be rescued if $\bar{\alpha} = 2$ robots have engaged with it for a sufficient amount of time.\\

The allocator is responsible for gathering information about the targets' status and location, and coordinating the action of the robots by dispatching them to the location of a target. If a robot is not dispatched, it may move around freely. The topology is represented as a graph, which is explained in \sec{maprepresentation}. It is optimistically assumed that the entire graph is known to the robots at synthesis time and that it does not change during the SAR task.\\



When the allocator dispatches a robot to a vertex, it merely asserts the index of a target's vertex on a transmission variable to the respective robot. The robot is then expected to move to this vertex on its own account, so the allocator does not need to know the topology. The allocator knows about a target's needs by receiving a message, or a ``flag'' associated with the location of the target. Targets will be assumed to be stationary since an injured or trapped person will not move.\\

Communication between the allocator and the robots is assumed to be layered on top of some reliable wireless protocol. Delivery of data is guaranteed eventually in finite time, messages are not corrupted, no reordering takes place, no messages get lost --- comparable to a data-layer protocol. Thus the communication is based on the four-phase handshake protocol developed in \sec{4PHP}.\\




\subsection{Architecture} \label{sec:statarch} \index{Architecture}

We synthesize the controllers for a set of robots and the central allocator. The asynchronous composition of the reactive systems resulting from the synthesis must satisfy the global specification of rescuing each flagged target, see~\sec{globsearchspec}.\\

In order to be able to simulate the reactive systems, it is necessary to close them as explained in~\sec{gametheorappr}. This is done by also synthesizing a reactive system for each vertex or ``cell'' in the topology. These reactive systems control the flags according to the environment assumptions of the allocator, which gathers the information about the targets. The complete architecture is shown in \fig{amm2} and the individual parts are explained below.\\




\subsubsection{Allocator and Queues}

At the heart of the architecture is the allocator, denoted by $\AMM$. It is connected to the robots, $\{R_0, R_1, \ldots, R_{m-1} \}$. The cells are also included in the figure to show how the closed-loop system would be controlled. They are shown as FDS's $\{C_0, C_1, \ldots, C_{n-1}\}$.\\

The allocator is informed about whether a target needs to be rescued by the boolean flags $f_0, f_1, \ldots, f_{n-1}$, each associated with one cell. Similarly, the allocator knows about which robots are ready by receiving the boolean variables $r_0, r_1, \ldots, r_{m-1}$, each associated with one robot. If a robot is ready and a vertex has been flagged, the allocator must dispatch a robot to the vertex that has been flagged for the longest period of time.\\

If there are $n$ vertices and $m$ robots, the allocator would need at least $2^{n+m}$ states to account for the $n$ flags and $m$ ready signals of the robots. However, in order to reduce the allocator's state space, two FIFO\index{FIFO} queues $\FIFOf$ and $\FIFOr$ are implemented as separate components that maintain which target and robot has been waiting for the longest period of time respectively. Thus the environment variables of $\FIFOf$ are the flags $f_0, f_1, \ldots, f_{n-1}$ and the environment variables of $\FIFOr$ are the ready signals $r_0, r_1, \ldots, r_{m-1}$.\\

The allocator receives a flag-index $F \in [\e, n)$ from $\FIFOf$, and a robot-index $R \in [\e, m)$ from $\FIFOr$ indicating which robot may be dispatched to which cell. If $\FIFOf$ holds $f_i$ at its head, then it {\bf offers} $F = i$ to the allocator, and symmetrically if $\FIFOr$ holds $r_j$ at its head, then it offers $R = j$. Moreover, the allocator may request the next flag index from $\FIFOf$ by sending a dequeue signal $\Df$, which is acknowledged by $\DfA$. The queue $\FIFOr$ does not have such a dequeuing capability, since this is not required in the specification.\\

The allocator can dispatch robots by setting the dispatch variable $D \in [\e, m)$ to the value in $F$. This indicates to the robot which is currently selected by $R$ that it has to go to the vertex in $D$. Internally, $\AMM$ maintains a counter variable $c \in [0,\bar{\alpha}]$ of the number of robots that have already been dispatched to the cell with index $F$. If possible, $\bar{\alpha} = 2$ robots will be dispatched to a cell, but never more, because $\bar{\alpha}$ is the number of robots that are required to clear the flag.\\

We do not provide specifications for the queues since they are not synthesized in the way explained above. With $n$ inputs a FIFO FDS would have $\mathcal{O}(2^nn!)$ states, making synthesis futile even for modest $n$. This number results from the $\mathcal{O}(n!)$ configurations the internal store of the queue can be in (corresponding to the system variables $\Y$) and the $\mathcal{O}(2^n)$ configurations the boolean inputs can be in (corresponding to the environment variables $\X$). Hence, we consider FIFO's as standard components and use a Python implementation for simulation.\\


\subsubsection{Robots}

For stationary target search, the number of robots required is only as high as the number of robots required to rescue a target, i.e.\ $\bar{\alpha}$. However, we may include an arbitrary number of robots in the architecture to complete the rescue operation more effectively. For example, with $\bar{\alpha} = 2$, if there are two targets and four robots, the robots can be dispatched in teams of two and rescue both targets at the same time. We synthesize one controller that is used on all robots and simply rename the variables with indices to indicate which variable belongs to a particular robot.\\

A robot $R_j$ maintains its own position on the topology both in $\cellID_j \in [\e, n)$ and in the boolean variables $X^j_0, X^j_1, \ldots, X^j_{n-1}$. As explained above, the two representations are merely introduced for notational convenience in the specification. Another variable, $\store_j \in [\e, n)$, stores the destination cell if the robot has been dispatched.\\

The robot $R_j$ knows that it is dispatched from the dispatch signal $D$ sent by $\AMM$, if the associated robot index $R$ from $\FIFOr$ satisfies $R = j$, indicating that $\AMM$ sends $D$ to $R_j$. However, the robot is not interested in whether any other robot is dispatched or not. Therefore, in order to decrease the state space of the robot, auxiliary environment variables $d_0, d_1, \ldots, d_{m-1}$ over the domain $[\e, n)$ are introduced, one for each robot. Robot $j$ receives $d_j = i$ from the allocator if it is dispatched to vertex $v_i$. On reaching the vertex $v_i$, the robot checks its boolean sensor signal $\flag_j$ whether there is still a target on this vertex. The environment variable $\flag_j$ is true iff there is a target on the vertex the robot is currently on. If a target is detected at the vertex to which the robot is dispatched (recognized by $\cellID_j = \store_j \wedge \flag_j = \mathrm{True}$), the robot asserts a boolean engage signal $e_j$ to indicate to the allocator that it has successfully reached the target's vertex.

\newcommand{\connE}[1]{\textstyle{E_{#1} = \sum_{j}(e_j \wedge X^j_{#1})}}
\newcommand{\connF}[1]{\textstyle{\flag_{#1} = \bigvee_{i} (X^{#1}_i \wedge f_i)}}\
\newcommand{\connD}[1]{\textstyle{d_{#1} = \begin{cases} D, &\text{if }R = {#1}\\ \e, &\text{otherwise}\end{cases}}}

\newcommand{\rinputF}{{f_i} \ar[l]}
\newcommand{\rinputD}{{} \ar[l]_<{D, R,}^<{f_i}}
\newcommand{\cinput}{{} \ar[r]^<{\cellID_j}_<{e_j}}

\newcommand{\cell}[1]{\cinput & *+[F]{\connE{#1}} \ar[r]^(0.7){E_{#1}} & *+++[o][F]{C_{#1}}}
\newcommand{\robotM}[2]{*+++[o][F]{R_{#1}} \ar@<.7pc>[r]^(.24){\cellID_{#1}} \ar[#2]_(.3){r_{#1}} & *+[F]{\begin{array}{l}\connD{#1} \\ \connF{#1}\end{array}} \ar@<.7pc>[l]^(.7){\flag_{#1}} & \rinputD }
\newcommand{\middleportion}{*++++[o][F]{\FIFOf} \ar@<1pc>[r]^{\DfA} \ar[r]^{F} & *++++[o][F]{\AMM} \ar@<1pc>[l]^{\Df} \ar[uu]^(0.3){D} & *++++[o][F]{\FIFOr} \ar[l]^{R}}

\begin{sidewaysfigure}
\begin{displaymath}
    \xymatrix@R=1.2pc@C=1.5pc{
\cell{0} \ar[ddr]^(.3){f_0} & & & & \robotM{0}{ddl} \\
\cell{1} \ar[dr]^(.3){f_1} & & & & \robotM{1}{dl} \\
\cell{2} \ar[r]^(.3){f_2} & \middleportion & \robotM{2}{l} \\
 {\vdots} & {\vdots} & {\vdots} & & & & {\vdots} & {\vdots} & {\vdots} \\
\cell{n} \ar[uur]^(.3){f_n} & & & & \robotM{m}{uul} \save "3,4"."3,6"*++[F--]\frm{} \restore
}
\end{displaymath}
\caption{Allocator based SAR architecture. Implicitly, $i \in [0, n)$ and $j \in [0, m)$. The outgoing arrows showing the system variables $e_j$ of the robots are omitted for a clearer layout. Also, internal system variables such as $c$ and $\store_j$ are not shown.}
\label{fig:amm2}
\end{sidewaysfigure}


\subsubsection{Connectors} \index{Connector}

The communication\index{Communication} between the individual components in the architecture is shown by the arrows between the individual components. Some environment variables of the robots and cells are functions of the system variables of their peers. For example, the environment variable $E_i$ of cell $C_i$ is a function of the variables $\cellID_j$ and $e_j$ for $j \in [0, m)$. One way to incorporate their relationship into the design would be to have $E_i$ as a system variable and $\cellID_j$ and $e_j$ for $j \in [0, m)$ as environment variables in $C_i$. Then the guarantee
\begin{equation*}
  \always(\connE{i})
\end{equation*}
can be added to the specification of $C_i$. Note that the summation interprets ``$\mathrm{True}$'' as ``$1$'' and ``$\mathrm{False}$'' as ``$0$''. While this would produce the desired result, it introduces many environment variables\index{Environment variables} into the design of the cells. If they cannot be suitably restricted by assumptions in the specification, this will lead to a considerable increase in the number of states in each cell's FDS.\\

To overcome this, these functions are implemented externally to the FDS's in the form of {\bf connectors}. A connector is an invariant proposition of the global state space. It is of the form $\vartheta = \pi(\vartheta_0, \vartheta_1, \vartheta_2, \ldots)$ where $\vartheta$ is an environment variable of an FDS $\M$, called a {\bf connector variable}, $\vartheta_0, \vartheta_1, \vartheta_2, \ldots$ are system variables of peers of $\M$ and $\pi$ is some proposition over $\vartheta_0, \vartheta_1, \vartheta_2, \ldots$ with the additional condition that $\vartheta$ is not a system variable of \emph{any} component in the architecture and $\vartheta$ is an environment variable only of $\M$. Thus, a connector introduces a new variable to the global state variables.\\

When proving properties over the composition of the specifications, these invariants can simply be assumed to hold at all times. In a simulation, these invariants are ensured by calculating the values of a connector variable $\vartheta$ whenever it is accessed by an FDS.\\

In our implementation of stationary target search, there are three types of connectors, shown as rectangles in \fig{amm2}. There is a connector for the engage signal $E_i$ of a cell $C_i$ that indicates how many robots are engaged on vertex $i$. This is expressed by
\begin{equation}
  \connE{i}.
  \label{eq:connE}
\end{equation}
Another connector is for the flag signal $\flag_j$ of a robot $R_j$ that indicates whether the vertex $i = \cellID_j$ the robot is currently on contains a target, i.e.\ $f_i = \mathrm{True}$. This expressed by
\begin{equation}
  \connF{j}.
  \label{eq:connF}
\end{equation}
The third type of connectors is for the dispatch signal $d_j$ of a robot $R_j$. Robot $R_j$ is dispatched to the vertex $i$ iff $d = i$ and $r = j$, i.e.\ if the robot that is offered to the allocator is $R_j$ and the allocator decides to dispatch a robot to the vertex $i$. This is expressed by
\begin{equation}
	\connD{j}.
	\label{eq:connD}
\end{equation}
Note that the connectors have access to the global state, i.e.\ they are not restricted by the position a robot is in. However, the expressions in \eqref{eq:connE}--\eqref{eq:connD} clearly indicate that only the local state is used to calculate the connector variables. By local state we mean that a cell can only use the values of robots on the corresponding vertex and a robot can only use the values of the cell on which it is currently.\\



\subsection{Global Specifications} \index{Global specification}

The composition of all components in \fig{amm2} has to satisfy the global specification for stationary target search discussed in \sec{globsearchspec} in a form that corresponds to the problem setting considered here. A target on vertex $i$ is indicated by the flag $f_i$ being asserted, and the goal of the allocator is the to get $\bar{\alpha} = 2$ robots to arrive at the vertex $i$. This can be expressed analogously to \eqref{eq:globstatgoal} by
\begin{equation*}
	\bigwedge_{i \in [0, n)}\always(f_i \rightarrow \eventually\bigvee_{\substack{j_1 \in [0, m) \\ j_2 \in [0, m) \backslash \{j_1\}}}(X_i^{j_1} \wedge X_i^{j_2})).
\end{equation*}

We now state the specifications of each component so that the asynchronous composition fulfills this global specification. This can be verified for example by using the Feedback Interconnection Refinement Rule in Proposition 1, but here we only note that the simulation yields the desired result.\\

For compacter specifications, define
\begin{align*}
\stay{\pi} &\defines \pi \wedge \next \pi, \\
\rais{\pi} &\defines \neg \pi \wedge \next \pi, \\
\clear{\pi} &\defines \pi \wedge \next \neg \pi,
\end{align*}
for any propositional formula $\pi$.\\

\subsection{Allocator Specification}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$R$ & $[\e, m)$ & Indicates a robot that is ready \\
$F$ & $[\e, n)$ & Indicates a vertex that is flagged \\
$\DfA$ & $\mathbb{B}$ & Dequeue acknowledge signal from $\FIFOf$ \\
\hline
\end{tabular}
\caption{Environment variables of the allocator, $\AMM$.}
\label{tab:env:alloc}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$\Df$ & $\mathbb{B}$ & Dequeue signal to $\FIFOf$ \\
$c$ & $[0, \bar{\alpha}]$ & Counts how many robots have been dispatched \\
$D$ & $[\e, m)$ & Dispatch signal to robots \\
\hline
\end{tabular}
\caption{System variables of the allocator, $\AMM$.}
\label{tab:sys:alloc}
\end{table}

The state variables of the allocator are shown in tables \tab{env:alloc} and \tab{sys:alloc}. The following specifications are for the FDS $\AMM$ in \fig{amm2}.\\ 


\subsubsection{Assumptions}

Initially, no robot is ready, so $\FIFOr$ offers no robot and $R = \e$. Moreover, $\FIFOf$ doesn't have a dequeue request to acknowledge, so $\DfA$ is low:
\begin{equation*}
  \ass{A}{1} = (R=\e) \wedge \neg\DfA.
\end{equation*}

$\FIFOr$ keeps track of the robots that are ready, and so, if available, presents a robot to the allocator that can be dispatched. This robot will not change unless the formerly presented robot has been dispatched:
\begin{equation*}
    \ass{A}{2} = \bigwedge_{j \in [0, m)} \always(\clear{R=j} \rightarrow D\neq\e).
\end{equation*}

Once a vertex is flagged, it is not unflagged unless a robot is dispatched to this cell, i.e.\ no target can rescue itself. More precisely, the flag offered by $\FIFOf$ may only change if a robot is dispatched or a dequeue signal is sent to the queue:
\begin{equation*}
    \ass{A}{3} = \bigwedge_{i \in [0, n)} \always(\clear{F=i} \rightarrow \Df \vee D\neq\e).
\end{equation*}

The dequeue acknowledgement stays high as long as the dequeue request stays high:
\begin{equation*}
    \ass{A}{4} = \always(\clear{\DfA} \rightarrow \next\neg\Df).
\end{equation*}


\subsubsection{Guarantees}

Initially, the dequeue signal is low, the counter is zero and no robot is dispatched:
\begin{equation*}
    \guar{A}{1} = \neg\Df \wedge c=0 \wedge D=\e.
\end{equation*}

Once the allocator has dispatched a robot, it monitors the ready signal it receives from $\FIFOr$. As long as this does not change, it does not clear the dispatch signal:
\begin{equation*}
    \guar{A}{2} = \bigwedge_{j \in [0, m)} \bigwedge_{i \in [0, n)} \always(D=i \wedge \stay{R=j} \rightarrow \next(D=i)).
\end{equation*}
However, if $\FIFOr$ presents a different robot to the allocator, this means that the robot to which the dispatch signal has been sent is no longer ready and has successfully reacted to the dispatch request. Thus dispatch is cleared:
\begin{equation*}
    \guar{A}{3} = \bigwedge_{j \in [0, m)} \bigwedge_{i \in [0, n)} \always(D=i \wedge \clear{R=j} \rightarrow \next(D=\e)).
\end{equation*}

If the allocator gets offered a flag $F = i$ from $\FIFOf$ and a robot is offered by $\FIFOr$, it may dispatch a robot to vertex $i$ by asserting $D = i$. In this case the counter $c$ must be increased by one:
\begin{equation*}
    \guar{A}{4} = \bigwedge_{\gamma < \bar{\alpha}} \bigwedge_{i \in [0,m)} \always (F=i \wedge D=\e \wedge c=\gamma \wedge R\neq \e \rightarrow \next(D=i \wedge c=\gamma+1)).
\end{equation*}

The dispatch signal may only be asserted if the counter $c$ is not saturated, some robot is ready and a cell is flagged:
\begin{equation*}
    \guar{A}{5} = \bigwedge_{i \in [0, m)} \always(D=\e \wedge \next(D=i) \rightarrow c<\bar{\alpha} \wedge R\neq\e \wedge F=i).
\end{equation*}
If a robot is dispatched and the dispatch signal is changed, it must be reset:
\begin{equation*}
    \guar{A}{6} = \bigwedge_{i \in [0, m)} \always(\clear{D=i} \rightarrow \next(D=\e)).
\end{equation*}
Moreover, dispatching a robot requires the dispatch signal to be clear:
\begin{equation*}
    \guar{A}{7} = \bigwedge_{i \in [0, m)} \always(\rais{D=i} \rightarrow D=\e).
\end{equation*}

The counter may only increase by one if a robot has been dispatched:
\begin{equation*}
    \guar{A}{8} = \always(\bigvee_{\gamma < \bar{\alpha}} (c=\gamma \wedge \next(c=\gamma+1)) \rightarrow \bigvee_{i \in [0, n)} (D=\e \wedge \next(D=i))).
\end{equation*}
Also, the counter may not decrease (unless it is reset), and it may only go up by one at a time. This requirement is captured by $0 \leq (\bar{\alpha} + \gamma' - \gamma) \mathrel\mathrm{mod} \bar{\alpha} \leq 1$, where $\gamma$ and $\gamma'$ are the values of the counter at the current and next step respectively:
\begin{equation*}
    \guar{A}{9} = \bigwedge_{\substack{\gamma \leq \bar{\alpha}, \gamma' \leq \bar{\alpha} \\ 0 \leq (\bar{\alpha} + \gamma' - \gamma) \mathrel\mathrm{mod} \bar{\alpha} \leq 1}} \always(c=\gamma \wedge \next(c=\gamma') \rightarrow \mathrm{False}).
\end{equation*}
This formulation \emph{forbids} certain changes of the counter $c$. A positive formulation that ensures that $c$ only changes in a permissible way can also be used but results in exactly the same synthesized FDS.\\

If no robot is dispatched, the counter must not change:
\begin{equation*}
    \guar{A}{10} = \bigwedge_{\gamma \leq \bar{\alpha}} \always(c=\gamma \wedge \stay{D=\e} \rightarrow \next(c=\gamma)).
\end{equation*}
The counter is only reset on a raising edge of the acknowledgement received from FIFOf:
\begin{equation*}
    \guar{A}{11} = \always(c=\bar{\alpha} \wedge c=0 \rightarrow \rais{\DfA}).
\end{equation*}
Conversely, if the counter is saturated and a raising edge of the acknowledgement is observed, then the counter is reset:
\begin{equation*}
    \guar{A}{12} = \always(c=\bar{\alpha} \wedge \rais{\DfA} \rightarrow \next(c=0)).
\end{equation*}

If enough robots have been dispatched to the vertex currently offered by $\FIFOf$, then the counter $c$ is saturated. The allocator must then ask $\FIFOf$ to offer the location of the next target, if available. For this purpose, the dequeue signal $\Df$ is raised if no acknowledgement is currently received:
\begin{equation*}
    \guar{A}{13} = \always(c=\bar{\alpha} \wedge \neg\DfA \wedge \neg\Df \rightarrow \next\Df).
\end{equation*}
The dequeue signal may only go high if the acknowledgement is low:
\begin{equation*}
    \guar{A}{14} = \always(\rais{\Df} \rightarrow \next\neg\DfA).
\end{equation*}
Also, the dequeue signal must stay high until an acknowledgement is received from FIFOf:
\begin{equation*}
    \guar{A}{15} = \always(\clear{\Df} \rightarrow \DfA).
\end{equation*}


\subsubsection{GR[1] Specification and Communication} \index{Communication} \index{Specification!GR[1]}

The above formulae are composed into the specification of the allocator:
\begin{equation*}
    \v_A = \bigwedge_{\alpha \in [1, 4]} \ass{A}{\alpha} \rightarrow \bigwedge_{\beta \in [1, 15]} \guar{A}{\beta},
\end{equation*}
which can be translated into a GR[1] specification.\\

The communication with $\FIFOf$ over the request signal $\Df$ and the acknowledgement signal $\DfA$ follows the four-phase handshake protocol of \sec{4PHP}. The assumption $\ass{A}{4}$ corresponds to III in $\M_S$, and the guarantees $\guar{A}{14}$ and $\guar{A}{15}$ correspond to VII and VIII respectively. IX is not required for a boolean request signal and XI is indirectly asserted by $\guar{A}{4}$, $\ass{A}{3}$ and $\guar{A}{13}$, \emph{given that} there are at least $\bar{\alpha}$ robots offered by $\FIFOr$. The property X is not guaranteed from the specification itself, but is required for the communication protocol to be valid. However, model checking\index{Model checking} the synthesized FDS of the allocator $\M_A \models \v_A$ reveals that also $\M_A \models \always(\DfA \rightarrow \next\Df)$. Thus the allocator satisfies the requirements to be a sender in the four-phase handshake protocol.\\

The allocator communicates with a robot also using the four phase handshake protocol. The request signal that is sent by the allocator is a combination of the index $R$ offered by $\FIFOr$ and the index of the target's vertex in $D$. In the notation of \sec{4PHP}, $(r = i) \Leftrightarrow (D = i \wedge R = j)$ for the request signal to robot $R_j$. The acknowledgement from robot $R_j$ is the signal $r_j$ being cleared. However, $r_j$ is not received as an environment variable by the allocator, so the robot index $R$ offered by $\FIFOr$ is used to extract this information: When $R = j$ changes, then robot $j$ has acknowledged the dispatch request. In the notation of \sec{4PHP}, $a \Leftrightarrow \clear{R = j}$. Thus $\guar{A}{2}$ and $\guar{A}{6}$ correspond to VIII and IX respectively, while X is implied by $\guar{A}{3}$ and $\ass{A}{2}$.\\


\subsection{Robot Specification}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$d_j$ & $[\e, n)$ & The vertex the robot is dispatched to \\
$\flag_j$ & $\mathbb{B}$ & Indicates whether the vertex the robot is on is flagged \\
\hline
\end{tabular}
\caption{Environment variables of the robot $R_j$. Note that $d_j$ and $\flag_j$ are both provided by a connector.}
\label{tab:env:robot}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$r_j$ & $\mathbb{B}$ & Indicates whether the robot is ready \\
$e_j$ & $\mathbb{B}$ & Indicates whether the robot is engaged \\
$\store_j$ & $[\e, n)$ & Stores the current target vertex \\
$\cellID_j$ & $[\e, n)$ & Stores the current position of the robot \\
$X^j_i, i \in [0, n)$ & $\mathbb{B}$ & Stores the current position of the robot \\
\hline
\end{tabular}
\caption{System variables of the robot $R_j$.}
\label{tab:sys:robot}
\end{table}

The environment and system variables of the robot $R_j$ are given in tables \tab{env:robot} and \tab{sys:robot} respectively. In the following specifications, the sub- and superscripts with the robot's index $j$ are omitted.

\subsubsection{Assumptions}

Initially, it is only known that the robot is not dispatched. This is a consequence of the robot also not being ready when it is started up (see guarantees):
\begin{equation*}
    \ass{R}{1} = (d=\e).
\end{equation*}

The allocator must wait for the robot to become ready before it can be dispatched:
\begin{equation*}
    \ass{R}{2} = \always(\clear{d=\e} \rightarrow r).
\end{equation*}

If the allocator sends a dispatch signal, this must remain the same until the robot acknowledges this by clearing its ready signal. Then FIFOr deletes this robot out of its list of robots that are ready, which in turn is (possibly) received by the allocator which only then may clear the dispatch signal:
\begin{equation*}
    \ass{R}{3} = \bigwedge_{i \in [0, n)} \always(\clear{d=i} \rightarrow \neg r).
\end{equation*}


\subsubsection{Guarantees}

Initially, the robot is not engaged, not ready and has no target stored:
\begin{equation*}
    \guar{R}{1} = \neg E \wedge \neg r \wedge \store=\e.
\end{equation*}

The robot becomes ready when no target is stored and it is not ready. From this time on, it will turn out that the atomic propositions $r = \mathrm{True}$ and $\store=\e$ are equivalent, because the robot is ready exactly if no destination is stored:
\begin{equation*}
    \guar{R}{2} = \always(\neg r \wedge \store\neq\e \rightarrow \next r).
\end{equation*}

If the robot receives a dispatch signal when it is ready, it fills its target storage with the appropriate destination:
\begin{equation*}
    \guar{R}{3} = \bigwedge_{i \in [0, n)} \always(\store=\e \wedge d=i \wedge r \rightarrow \next(\store=i)).
\end{equation*}
Moreover, a target may only be stored if the robot is ready. As a result of this, the robot must clear the ready signal $r$:
\begin{equation*}
    \guar{R}{4} = \bigwedge_{i \in [0, n)} \always(\store=\e \wedge \next(store=i) \rightarrow r \wedge d=i \wedge \neg\next r).
\end{equation*}
The target store may only be cleared to $\e$, and only if the robot is at the target location and no flag is detected. Then also the robot must assert that it is ready:
\begin{equation*}
    \guar{R}{5} = \bigwedge_{i \in [0, n)} \always(\clear{\store=i} \rightarrow \neg\flag \wedge X_i \wedge \next(\store=\e \wedge r)).
\end{equation*}

When a destination is stored then the robot eventually reaches the required cell:
\begin{equation*}
    \guar{R}{6} = \always(\store\neq\e \rightarrow \eventually \bigvee_{i \in [0, n)} (X_i \wedge \store=i)).
\end{equation*}

If the robot arrives at the correct cell and the flag is still up, then it engages:
\begin{equation*}
    \guar{R}{7} = \bigwedge_{i \in [0, n)} \always(\store=i \wedge X_i \wedge \flag \rightarrow e).
\end{equation*}
If the robot arrives at the correct cell but the flag is already cleared, then the store is cleared, the robot goes back to ready and disengages:
\begin{equation*}
    \guar{R}{8} = \bigwedge_{i \in [0, n)} \always(\store=i \wedge X_i \wedge \neg\flag \rightarrow \next(r \wedge \store=\e \wedge \neg e)).
\end{equation*}
The robot may only engage if it is in the correct cell and the flag is still sensed:
\begin{equation*}
    \guar{R}{9} = \always(\rais{e} \rightarrow \next\left(\bigvee_{i \in [0, n)} (X_i \wedge \store=i)\right) \wedge \next\flag).
\end{equation*}
Disengaging requires the target storage to be cleared. Note that this implicitly also includes all that is required to clear the target storage:
\begin{equation*}
    \guar{R}{10} = \always(\clear{e} \rightarrow \bigvee_{i \in [0, n)} \clear{\store=i}).
\end{equation*}

The robot is free to move as long as it is not engaged.
\begin{equation*}
    \guar{R}{11} = \bigwedge_{i \in [0, n)} \always(\stay(e) \rightarrow (X_i \leftrightarrow \next X_i)).
\end{equation*}

The allowable moves of the robot depend on the graph $G$ on which the search is performed. Since $G$ is given at specification time, the restrictions due to the topology are encoded as presented in \sec{maprepresentation}, and the formula $\v_G$ is included in the robot's specification.\\


\subsubsection{GR[1] Specification and Communication} \index{Specification!GR[1]} \index{Communication}

The above formulae are composed into the specification of the robot:
\begin{equation*}
    \v_R = \bigwedge_{\alpha \in [1, 3]} \ass{R}{\alpha} \rightarrow \v_G \wedge \bigwedge_{\beta \in [1, 11]} \guar{R}{\beta},
\end{equation*}
which can be translated into a GR[1] specification, see \sec{GR1}.\\

The robot $R_j$ may receive dispatch signals from the allocator via the dispatch signal $d_j$. It acknowledges such a request by clearing its ready signal $r_j$. The allocator does not directly receive $r_j$ but only the signal $R$ from $\FIFOr$, which must be taken into account when reasoning about the correctness of the communication protocols. Thus the acknowledgement signal is equivalent to $r_j = \mathrm{False}$, i.e.\ when the robot declares that it is no longer ready. Except in the initial state, this is also equivalent to $\store_j \neq \e$. The request signal is equivalent to $d_j \neq \e$. Therefore the guarantee $\guar{R}{4}$ corresponds to XIV, and the combination of $\guar{R}{3}$ and $\guar{R}{5}$ corresponds to XII. However, XV and XIII are not directly guaranteed by the robot but are required in Cases 4 and 5 of the proof of Proposition 3. XIII states that $d_j=\e$ necessarily results in $r_j=\mathrm{True}$. However, since the allocator does not require the liveness assumption I, the proof of Case 5 still works without guaranteeing XIII as follows:\\

To prove Precondition 1. we deduce II--VI from the conjuncts of the closures of $\varphi_S^s$ and $\varphi_R^s$. II and III follow from $\always(a = \mathrm{True})$ arising from the existential quantification of $\bar{a}$. IV--VI similarly follow from $\always(r = \e)$. To prove Precondition 2. we take $\bar{\bar{t}} = \mathrm{False}$ in the closure and the result follows trivially.\\

XV states that $\rais{r_j}$ requires $d_j=\e$. But the proof of Case 4 fails when omitting this guarantee. However, let us consider what would happen if the robot raised $r_j$ when $d_j\neq\e$. The allocator only receives $R$ from $\FIFOr$. If $R = \e$ then $D$ must be $\e$ from $\guar{A}{3}$ and $\guar{A}{5}$, so in this case $d_j\neq\e$ is not possible. Thus at that point $R\neq\e$ and so a robot $R_h$, $h \neq j$ is offered to the allocator in $R$. Thus when $r_j$ is raised, $R$ does not change necessarily, since $\FIFOr$ offers $R=h$ first. However, from the connector proposition for $d_j$, when $R\neq j$ then $d_j=\e$. So also in this case $d_j\neq\e$ is not possible.\\


\subsection{Cell and Queue Specifications}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment & $E_i$ & $[0, m]$ & The number of robots engaged on this cell \\
\hline
System & $f_i$ & $\mathbb{B}$ & Indicates whether the cell is flagged \\
\hline
\end{tabular}
\caption{Variables of the Cell $C_i$}
\label{tab:cellvars}
\end{table}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment & $r_j, j \in [0, n)$ & $\mathbb{B}$ & The ready signal received from robot $R_j$ \\
\hline
System & $R$ & $[\e, n)$ & The index of the robot offered to $\AMM$\\
\hline
\end{tabular}
\caption{Variables of $\FIFOr$.}
\label{tab:fiforvars}
\end{table}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment & $f_i, i \in [0, m)$ & $\mathbb{B}$ & The flag received from cell $C_i$\\
            & $\Df$ & $\mathbb{B}$ & The dequeue request from $\AMM$\\
\hline
System & $F$ & $[\e, n)$ & The index of the vertex offered to $\AMM$\\
       & $\DfA$ & $\mathbb{B}$ & The dequeue acknowledgement \\
\hline
\end{tabular}
\caption{Variables of $\FIFOf$.}
\label{tab:fifofvars}
\end{table}

Each cell $C_i$ in the architecture in \fig{amm2} has just one environment variable $E_i$, indicating the number of robots engaged on the cell, and one system variable $f_i$, the flag of the cell. These variables are shown in \tab{cellvars}. In the specification, we will again drop the subscripts from the variables and write just $f$ and $E$.\\

A cell has to satisfy only two guarantees. The flag can only be cleared if there are at least $\bar{\alpha} = 2$ robots engaged on the cell:
\begin{equation*}
	\guar{C}{1} = \always(\clear{f} \rightarrow E \geq \bar{\alpha}).
\end{equation*}
Moreover, we include a liveness property, ensuring that the cell will always be flagged eventually:
\begin{equation*}
	\guar{C}{2} = \always\eventually f.
\end{equation*}

In order for the specification to be realizable, we need to assume that as long as a cell is flagged, the number of robots that are engaged on the vertex associated with that cell will never decrease:
\begin{equation*}
	\ass{C}{1} = \bigwedge_{\gamma \in [0, m)}\always(f \wedge E=\gamma \rightarrow \next(E\geq\gamma)).
\end{equation*}

The FIFO\index{FIFO} queues $\FIFOr$ and $\FIFOf$ are not synthesized as FDS's due to the state space explosion problem, cf.\ \sec{statarch}. Instead, a thread is implemented that guarantees certain properties to the allocator $\AMM$. In particular, the environment assumptions of $\AMM$ on the local system variables controlled by $\FIFOr$ and $\FIFOf$ must be satisfied. The conceptual environment and system variables of the two queues are shown in \tab{fiforvars} and \tab{fifofvars} respectively.\\

From $\ass{A}{1}$, the allocator requires that initially ``$\DfA = \mathrm{False}$'', which can easily be implemented in $\FIFOf$. Also, $\ass{A}{4}$ requires the dequeue acknowledgement $\DfA$ to only be lowered if also the dequeue request $\Df$ is false, which is similarly straightforward to implement.\\

There is only one requirement on $\FIFOr$, imposed by $\ass{A}{3}$. The robot index $R$ that is offered to $\AMM$ may hence only be changed if a robot is dispatched. Since $\FIFOr$ keeps track on which robots are ready, and robots may only lower their ready signals $r$ following a dispatch $D$ (cf.\ the connector \eqref{eq:connD}), this requirement is automatically met.\\

Lastly, from $\ass{A}{3}$, the flag offered to the allocator may only be changed if a dequeue signal $\Df$ is received by $\FIFOf$ or a robot is dispatched. $\FIFOf$ therefore only dequeues a flag either if $\Df$ is high, or the flag is lowered. By the cell's guarantee $\guar{C}{1}$ and the connector \eqref{eq:connE}, a flag can only be lowered if at least $\bar{\alpha}$ robots are engaged on the corresponding cell. This again is only the case if $D \neq \e$, i.e.\ a robot is dispatched.\\


\subsection{Synthesis} \index{Synthesis}

The specifications given above were successfully synthesized using the TuLiP\index{TuLiP} front end. \fig{statstates} shows the number of states of the allocator and the robot when varying the size of the topology and the number of robots available.\\

The size of the state space of the robot does not depend on the number of robots in the architecture, but the size of the state space of both the allocator and the robots increases quadratically with the number of vertices in the graph representation of the topology. Also, the size of the state space of the allocator increases slightly with the number of robots.\\

\begin{figure}
\centering
	\psfrag{alloc2}[ll][cc]{\footnotesize{$\AMM$, $m=2$}}
	\psfrag{alloc3}[ll][cc]{\footnotesize{$\AMM$, $m=3$}}
	\psfrag{alloc4}[ll][cc]{\footnotesize{$\AMM$, $m=4$}}
	\psfrag{alloc5}[ll][cc]{\footnotesize{$\AMM$, $m=5$}}
	\psfrag{alloc6}[ll][cc]{\footnotesize{$\AMM$, $m=6$}}
	\psfrag{robot}[ll][cc]{\footnotesize{Robots $R_j$, any $m$}}
	\psfrag{States}[cc][cc]{\footnotesize{States}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, $n$}}
	\includegraphics[width=0.8\textwidth]{stats.eps}
\caption{States of allocator and robot for the stationary target search. The relation for both allocator $\AMM$ and robots $R_j$ is quadratic in the number of vertices $n$.}
\label{fig:statstates}
\end{figure}

The time for synthesizing the controllers is also polynomial in the size of the topology, as would be expected: The size of the specification increases at most quadratically with $n$, the number of vertices in the graph representing the topology, and the synthesis time is cubic in the size of the specification. By plotting the synthesis time on a logarithmic scale as in \fig{stattime} shows that the complexity must be subexponential. A rough analysis yields polynomial complexity of sixth order in $n$, but this cannot be seen accurately from the available data.\\

The timing measurements have been conducted on a $2.4\unit{GHz}$ Intel Core i7 CPU, with $4\unit{GB}$ of working memory. The available memory is likely to also affect the performance because the JTLV implementation uses the JVM Garbage Collector. Note also that the graph presented in this section was obtained for just one random graph for each value of $n$. Other random graphs give different state space sizes and synthesis times, but the polynomial complexity results still hold.\\

\begin{figure}
\centering
	\psfrag{alloc2}[ll][cc]{\footnotesize{allocator, $m=2$}}
	\psfrag{alloc3}[ll][cc]{\footnotesize{allocator, $m=3$}}
	\psfrag{alloc4}[ll][cc]{\footnotesize{allocator, $m=4$}}
	\psfrag{alloc5}[ll][cc]{\footnotesize{allocator, $m=5$}}
	\psfrag{alloc6}[ll][cc]{\footnotesize{allocator, $m=6$}}
	\psfrag{robot}[ll][cc]{\footnotesize{robots, any $m$}}
	\psfrag{Synthesis Time [s]}[cc][cc]{\footnotesize{Synthesis Time [s]}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, $n$}}
	\includegraphics[width=0.8\textwidth]{times.eps}
\caption{Time to synthesize allocator and robot for the stationary target search with $n$ vertices and $m$ robots. Note that the ordinate is logarithmic but the relation is polynomial.}
\label{fig:stattime}
\end{figure}





\subsection{Discussion}

Stationary target search has been successfully simulated for various numbers of robots and vertices. When more than two robots are used, the allocator explicitly requests a new flag to be offered by $\FIFOf$ and dispatches a robot to the corresponding vertex. Thus, with four and more robots several targets can be rescued simultaneously.\\

However, as is clear from \fig{statstates}, the size of the state space grows very fast with the size of the graph. This affects the efficiency of synthesis. The synthesis of the controllers for $20$ vertices and $6$ robots already took about $15\unit{min}$, and much longer times are expected for larger graphs. However, space seems to be even a more pressing issue. Larger problems are susceptible to heap overflow due to unsuccessful JVM garbage collection. For example, synthesis of a controller for $16$ vertices and $5$ robots is not successful when only permitting $1\unit{GB}$ of working memory.\\

The increase of the state space is mostly due to the added environment variables from the communication protocol. The assumptions on these additional environment variables cannot be strengthened sufficiently to reduce the state space further. The communication in this specification already deviates slightly from the four-phase handshake protocol defined in \sec{4PHP} in order to alleviate this problem, as any additional signal like a boolean acknowledgement roughly doubles the state space. Also, beyond a certain graph size, synthesis seems impractical. If this limitation cannot be overcome, then this type of specification seems unsuitable for practical applications.\\


\section{Moving Target Search} \label{sec:implmovt}

In contrast to USAR, the targets in WiSAR\index{WiSAR} are considered to be able to move. That means that the stationary target search methods are no longer sufficient, and we implement the distributed multi stage moving target search strategy developed in \sec{mstage}.\\

There is no central allocator, hence the specification is easier than that of stationary target search. However, as is evident from \sec{movtsearch}, justifying that a given number robots with controllers synthesized from the specification reliably find all moving targets requires more effort than with stationary target search.\\


\subsection{Communication Structure} \label{sec:commstructure} \index{Communication}

As indicated in \sec{negotiations}, the robots are organized in a circular structure of authority and communication. A robot $R_j$ has exactly one slave and exactly one master. \fig{commstructure} shows such a cycle. The state variables of the robots are explained in \tab{inp:robot} and \tab{out:robot}.\\

\newcommand{\dist}{0.2pc}
\newcommand{\ratio}{0.35}
\newcommand{\robot}[1]{*++[o][F-]{R_{#1}}}
\begin{figure}[h!]
\begin{displaymath}
    \xymatrix@R=2cm@C=5cm{ \robot{0} \ar@<\dist>[r]^(\ratio){\ackin_1 = \ackout_0} \ar@<\dist>[d]^(\ratio){\Cin{,3} = \Cout{,0}} & \robot{1} \ar@<\dist>[d]^(\ratio){\ackin_2 = \ackout_1} \ar@<\dist>[l]^(\ratio){\Cin{,0} = \Cout{,1}}\\ \robot{3} \ar@<\dist>[u]^(\ratio){\ackin_0 = \ackout_3} \ar@<\dist>[r]^(\ratio){\Cin{,2} = \Cout{,3}} & \robot{2} \ar@<\dist>[l]^(\ratio){\ackin_3 = \ackout_2} \ar@<\dist>[u]^(\ratio){\Cin{,1} = \Cout{,2}}}
\end{displaymath}
\caption{Four robots communicating in the moving target search architecture. Note that only the local system and environment variables directly relevant for communication are shown.}
\label{fig:commstructure}
\end{figure}

We use the standard four-phase handshake protocol introduced in \sec{4PHP}. Hence no sophisticated arguments as in the previous section on stationary target search are required to justify the correctness of the communication protocols used. Also, the correctness of the composition of all synthesized components is a simple extension of Proposition 2 in \sec{4PHP}.\\

\subsection{Robot Specifications} \label{sec:robspec}

Similar to the stationary target search, the global specification must state that any target is eventually found on the given topology. Since the search strategies developed in \sec{distrsoln} ensure that the graph is cleared, this global requirement is necessarily satisfied, given that the architecture contains sufficiently many robots. We therefore only state the specifications that are synthesized into robots implementing a winning strategy for the cops. It is then easy to extend this to include sensors to detect targets and react appropriately (e.g.\ by engaging).\\

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$\Cin{,j}$ & $[\e, n)$ & Vertex the robot is sent to by its master \\
$\ackin_j$ & $\mathbb{B}$ & Acknowledgement received from its slave \\
$\cst_j$ & $\{\ccl, \cpc, \ccr, \csv\}$ & State of the vertex on which the robot is \\
\hline
\end{tabular}
\caption{Environment Variables of Robot $R_j$}
\label{tab:inp:robot}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
$M_j$ & $\{\mgu, \mcs, \mpc, \mcl\}$ & Mode of the robot \\
$\store_j$ & $[\e, n)$ & Vertex stored for the clearing mode\\
$\cellID_j$ & $[0, n)$ & Current position of the robot \\
$X_i^j, i \in [0, n)$ & $\mathbb{B}$ & True if robot $R_j$ is in position $i$\\
$c_j$ & $[\e, \bar{\gamma}_\mathrm{max}]$ & Counter in clearing mode\\
$\cnt_j$ & $[0, |p|)$ & Counter in search modes\\
$\mcnt_j$ & $[0, |p|)$ & Maximum counter value in search modes\\
$\ackout_j$ & $\mathbb{B}$ & Acknowledgement sent to master \\
$\Cout{,j}$ & $[\e, n)$ & Vertex to send the robot's slave to \\
\hline
\end{tabular}
\caption{System Variables of Robot $R_j$}
\label{tab:out:robot}
\end{table}

In the following specifications, the subscripts and superscripts indicating the index of the robot are omitted for notational convenience.\\


\subsubsection{Guarantees: Topology}

Similar to the stationary target search, the allowable moves of the robot have to be defined in the guarantee part of the specification. The restrictions due to the topology are encoded as presented in \sec{maprepresentation}, and the formula $\v_G$ encoding the topology is included in the robot's specification.\\

Note that the targets are restricted to move on the same topology. However, since they are assumed to be able to move with infinite speed, and the graph is strongly connected, the robot cannot assume any restriction on the movement of the targets.\\


\subsubsection{Guarantees: Guarding Mode}

In the guarding mode $\Mgu$, the robot has to stay at the current vertex unless a command from its master is received via $\Cin{}$:
\begin{equation*}
	\guar{M}{1} = \bigwedge_{i \in [0, n)}\always(\Mgu \wedge \Cin{}=\e \wedge X_i \rightarrow \next(X_i \wedge \Mgu)).
\end{equation*}
However, if a command is received, then the clearing mode $\Mcl$ has to be entered, setting up the store and counter appropriately:
\begin{equation*}
	\guar{M}{2} = \bigwedge_{i \in [0, n)}\always(\Mgu \wedge \Cin{}=i \rightarrow \next(\Mcl \wedge \store=i \wedge c=\e)).
\end{equation*}
If the guarding mode is entered, then the robot's slave is instructed to clear all out-edges of the current vertex $v_i$ by asserting the index $i$ on $\Cout{} = i$. However, if the guarding mode is entered because the counter $c$ is saturated, this means that no vertex was found in $\Mcs$ or $\Mpc$. In this case we know that the graph is cleared and so $\Cout{}$ stays at $\e$.\\
\begin{align*}
	\guar{M}{3} = \bigwedge_{i \in [0, n)}\bigwedge_{\gamma \in [0, |p|)}\always(\Mcs \wedge &\next(\Mgu) \wedge \next(X_i)\,\wedge\\
 &\cnt=\gamma \wedge \mcnt\neq\gamma \rightarrow \next(\Cout{}=i)).
\end{align*}


\subsubsection{Guarantees: Searching Modes}

The searching modes $\Mcs$ and $\Mpc$ can be specified together, as they differ only slightly by the state of the vertex the robot is searching for and the mode that is entered if such a vertex is encountered.\\

First, when entering a searching mode, the counters must be initialized correctly:
\begin{align*}
	\guar{M}{4} = \bigwedge_{i \in [0, n)}\always(&X_i \wedge (\rais{\Mcs} \vee \rais{\Mpc}) \\ &\rightarrow \next(\cnt=\gamma_i \wedge \mcnt=\nextval{\gamma_i} \wedge X_i)),
\end{align*}
where $\gamma_i$ is the index of the first occurrence of the vertex $v_i$ in the path $p$. Note that $\nextval{\gamma} = (\gamma + 1 + |p|) \mathop\mathrm{mod} |p|$ as defined in \sec{globsearchspec} before \eqref{eq:countincrease}.\\

The robot moves along the path $p$ one vertex at a time, making sure that the counter $\cnt$ increases at every transition:
\begin{align*}
	\guar{M}{5} = \bigwedge_{\gamma \in [0, |p|)}\always(&X_{p(\gamma)} \wedge \cnt=\gamma \wedge \mcnt\neq\gamma\,\wedge \\ &((\Mcs \wedge \next(\cst\neq\csv)) \vee (\Mpc \wedge \next(\cst\neq\cpc)))\\ & \rightarrow \next(\cnt=\nextval{\gamma} \wedge X_{p(\nextval{\gamma})})).
\end{align*}

If a start vertex\index{Start vertex} has been found, then enter the guarding mode $\Mgu$:
\begin{equation*}
	\guar{M}{6} = \bigwedge_{i \in [0, n)}\always(\Mcs \wedge \next(\cst=\csv) \wedge X_i \rightarrow \next(\Mgu \wedge c=\e \wedge X_i)).
\end{equation*}
Similarly, if a partially cleared vertex $v$ has been found, then enter the clearing mode $\Mcl$, initialized to clear the out-edges of $v$:
\begin{align*}
	\guar{M}{7} = \bigwedge_{i \in [0, n)}\always(&\Mpc \wedge \next(\cst=\cpc) \wedge X_i \\ &\rightarrow \next(\Mcl \wedge c=\e \wedge \store=i \wedge X_i)).
\end{align*}
Also, if the maximum counter value is reached in $\Mpc$, then there is no partially cleared vertex and the search for a start vertex $\Mcs$ is entered:
\begin{equation*}
	\guar{M}{8} = \bigwedge_{\gamma \in [0, |p|)}\always(\Mpc \wedge \cnt=\gamma \wedge \mcnt=\gamma \wedge \next(\cst\neq\cpc) \rightarrow \next(\Mcs)).
\end{equation*}
Note that the values of the counters are reset to the correct values necessarily by the guarantee $\guar{M}{4}$. Similarly, if the maximum counter value is reached in $\Mcs$, then there is no contaminated (start) vertex and the graph must necessarily be cleared and the robot becomes dormant in guarding mode $\Mgu$. Note that an additional mode can be introduced in this case that allows the robots to move arbitrarily on the graph, but here only the concept of moving target search should be introduced. The corresponding guarantee is:
\begin{equation*}
	\guar{M}{9} = \bigwedge_{\gamma \in [0, |p|)}\always(\Mcs \wedge \cnt=\gamma \wedge \mcnt=\gamma \wedge \next(\cst\neq\csv) \rightarrow \next(\Mgu)).
\end{equation*}

Now a few guarantees are required that prevent the counters from changing when they should not (so called frame axioms). The counter of the position in the path $p$, $\cnt$ may only increase until it overflows, corresponding to the path closing in a cycle.
\begin{align*}
	\guar{M}{10} = \always(&\stay{\Mcs} \vee \stay{\Mpc} \\&\rightarrow \bigvee_{\gamma \in [0, |p|)}(\cnt=\gamma \wedge \next(\cnt=\nextval{\gamma}))).
\end{align*}
Similarly, the value stored as maximum for the counter may not change:
\begin{align*}
	\guar{M}{11} = \always(&\stay{\Mcs} \vee \stay{\Mpc} \\&\rightarrow \bigvee_{\gamma \in [0, |p|)}(\mcnt=\gamma \wedge \next(\mcnt=\gamma))).
\end{align*}
Since $\cnt$ and $\mcnt$ are only used in $\Mcs$ or $\Mpc$, they are set to zero otherwise:
\begin{equation*}
	\guar{M}{12} = \always(\neg(\Mcs \vee \Mpc) \rightarrow \cnt=0 \wedge \mcnt=0).
\end{equation*}

Two more guarantees are required to prevent the robot from leaving the searching mode if no start vertex or partially cleared vertex was encountered or the counter has not reached its maximum value:
\begin{align*}
	&\guar{M}{13} = \always(\clear{\Mcs} \rightarrow \bigvee_{\gamma \in [0, |p|)}(\cnt=\gamma \wedge \mcnt=\gamma) \wedge \next(\cst=\csv)),\\
	&\guar{M}{14} = \always(\clear{\Mpc} \rightarrow \bigvee_{\gamma \in [0, |p|)}(\cnt=\gamma \wedge \mcnt=\gamma) \wedge \next(\cst=\cpc)).
\end{align*}


\subsubsection{Guarantees: Clearing Mode}

The clearing mode is the most involved mode, but also the mode that is responsible for actual progress in clearing edges: no edges can be cleared by a robot that is not in mode $\Mcl$.\\

First, on entering clearing mode, the index of a vertex is written to $\store$ so that the robot knows for which vertex the out-edges must be cleared. This can only happen when the robot is guarding and called by its master to move, or when the robot has found a partially cleared cell that it is now about to clear:
\begin{align*}
	\guar{M}{15} = \bigwedge_{i \in [0, n)}\always(&\store=\e \wedge \next(\store=i) \rightarrow \\ &(\Cin{}=i \wedge \Mgu) \vee (\Mpc \wedge \next(\cst=\cpc) \wedge X_i)).
\end{align*}
Also, $\store$ may only change from $\e$ if also the counter $c$ is reset to $\e$ or alternatively if the robot enters the clearing mode from a search for a partially cleared vertex:
\begin{align*}
	\guar{M}{16} = \always(\clear{\store=\e} \rightarrow &(\next(c=\e)\wedge \Mgu \wedge\next(\Mcl)) \vee \\ &(\Mpc \wedge\next(\cst=\cpc) \wedge\next(\Mcl))).
\end{align*}
Moreover, if $\store\neq\e$, then it may only change to $\e$, i.e.\ it is not permitted to immediately change from sliding down the out-edges of one vertex to sliding down the out-edges of another. Such a change also requires the counter $c$ to be saturated, indicating that all out-edges of the vertex held in $\store$ are successfully cleared:
\begin{equation*}
	\guar{M}{17} = \bigwedge_{i \in [0, n)}\always(\clear{\store=i} \rightarrow \next(\store=\e) \wedge c=\bar{\gamma}_i \wedge \next(c=\e)).
\end{equation*}
Conversely, if the counter $c$ is saturated, then the robot has successfully cleared all out-edges of the vertex held in $\store$ and thus enters the search for a partially cleared vertex:
\begin{equation*}
	\guar{M}{18} = \bigwedge_{i \in [0, n)}\always(\store=i \wedge c=\bar{\gamma}_i \rightarrow \next(\store=\e \wedge c=\e \wedge \Mpc)).
\end{equation*}

The counter $c$ is always diligently set to $\e$ when the clearing mode is entered (see $\guar{M}{26}$), representing that the robot first has to move to the vertex held in $\store$. This latter requirement is expressed using the following property:
\begin{equation}
	\always(\store\neq\e\wedge c=\e \rightarrow \eventually \bigvee_{i \in [0, n)}(\store=i\wedge X_i)).
	\label{eq:gohome}
\end{equation}
Note that we write $\always(\pi \rightarrow \eventually\bigvee_{i \in [0,n)}(\store=i\wedge X_i))$ rather than the more intuitively obvious $\bigwedge_{i \in [0,n)}\always(\pi \wedge \store=i \rightarrow \eventually X_i)$. This is because the latter introduces $n$ response formulae\index{Response formula}, each of which requires a trigger\index{Trigger} variable to be added to the system variables, which would multiply the potential number of states by $2^n$. Using the former contracted response property only requires one trigger and thus the synthesized FDS has fewer states.\\

While the robot moves to the vertex held in $\store$, the counter $c$ must remain at $\e$:
\begin{equation*}
	\guar{M}{19} = \bigwedge_{i \in [0, n)}\always(\store=i \wedge c=\e \wedge \neg X_i \rightarrow \next(c=\e)).
\end{equation*}	
On reaching the vertex, the robot sets the counter to zero. It also stays in the vertex so that the state of the robot is consistent:
\begin{equation*}
	\guar{M}{20} = \bigwedge_{i \in [0, n)}\always(\store=i \wedge c=\e \wedge X_i \rightarrow \next(c=0 \wedge X_i)).
\end{equation*}

Given that the robot is in the vertex held in $\store$ and the counter $c$ has a value not equal to $\e$, an out-edge can be cleared. The corresponding property has already been introduced in \sec{mstage}:
\begin{equation*}
	\guar{M}{21} = \bigwedge_{i \in [0, n)} \bigwedge_{\gamma \in [0, \bar{\gamma}_i)} \always(\store = i \wedge c = \gamma \wedge X_i \rightarrow \next(X_{w_\gamma^i} \wedge c = \gamma + 1)).
\end{equation*}
Recall that $\bar{\gamma}_i$ is the number of out-edges of the vertex $i$ and $w_{\gamma^i}$ is the (unique) vertex such that there is an edge $e$ from $i$ to $w_{\gamma^i}$ and $e$ is the $\gamma^\mathrm{th}$ edge to be cleared by the robot. After clearing the edge, the robot must move back to the vertex held in $\store$, which is expressed by the guarantee
\begin{equation}
	\always\left(\bigvee_{i \in [0, n)} \store = i \wedge \bigvee_{\gamma \in [0, \bar{\gamma}_i)}(c = \gamma + 1 \wedge X_{w_\gamma^i})) \rightarrow \eventually \bigvee_{i \in [0, n)} (\store = i \wedge X_i)\right).
	\label{eq:goback}
\end{equation}
This again is a response property, which would require a trigger to be introduced. Instead of having both response properties \eqref{eq:gohome} and \eqref{eq:goback}, we combine them into one guarantee:
\begin{align*}
	\guar{M}{22} = \always((&\store\neq\e\wedge c=\e) \vee \bigvee_{i \in [0, n)} (\store = i \wedge \bigvee_{\gamma \in [0, \bar{\gamma}_i)}(c = \gamma + 1 \wedge X_{w_\gamma^i})) \rightarrow \\ &\eventually \bigvee_{i \in [0, n)} (\store = i \wedge X_i)).
\end{align*}
This is of course only possible since the right hand side of the implication $\rightarrow$ is the same in both \eqref{eq:gohome} and \eqref{eq:goback}.\\

Again, the counter $c$ must be restricted. It may only increase by one if an edge is cleared:
\begin{equation*}
	\guar{M}{23} = \bigwedge_{\gamma \in [0, \bar{\alpha})}\always\left(c=\gamma \wedge \next(c=\gamma+1) \rightarrow \bigvee_{i \in [0, \bar{\gamma}_i)}(\store=i \wedge X_i \wedge \next X_{w_\gamma^i})\right).
\end{equation*}
Also, the counter may not decrease unless it is reset. Moreover, it may only increase by one:
\begin{equation*}
	\guar{M}{24} = \bigwedge_{i \in [0, n)}\always(\store=i \rightarrow \bigvee_{\substack{\gamma_1 \in [\e, \bar{\gamma}_i] \\ \gamma_2 \in [\e, \bar{\gamma}_i]}}\namefont{increase}(c, \gamma_1, \gamma_2, i)),
\end{equation*}
where $\namefont{increase}(c, \gamma_1, \gamma_2, i)$ is a formula that only holds if the counter changes by an admissible amount, which is defined as follows:
\begin{equation*}
	\namefont{increase}(c, \gamma_1, \gamma_2, i) =
	\left\{
	\begin{array}{ll}
		c=\gamma_1 \wedge \next(c=\gamma_2) & \mbox{if } \gamma_2=\gamma_1+1 \\&\mbox{or } \gamma_1=\bar{\gamma}_i \wedge \gamma_2=\e \\&\mbox{or } \gamma_1=\gamma_2 \\
		\mathrm{False} & \mbox{otherwise}
	\end{array}
	\right.
\end{equation*}
The counter may only be reset to $\e$ if all out-edges have been cleared:
\begin{equation*}
	\guar{M}{25} = \always(\rais{c=\e} \rightarrow \bigvee_{i \in [0, n)}(\store=i \wedge c=\bar{\gamma}_i)).
\end{equation*}

If the robot is not in the clearing mode, then the counter $c$ and $\store$ are not used, and they are therefore set to $\e$:
\begin{equation*}
	\guar{M}{26} = \always(\Mncl \rightarrow c=\e \wedge \store=\e).
\end{equation*}
Finally, the robot has to remain in the clearing mode as long as there are still out-edges of the vertex held in $\store$ to be cleared.
\begin{equation*}
	\guar{M}{27} = \always(\Mcl \wedge \neg\bigwedge_{i \in [0, n)}(\store\neq i \vee c=\bar{\gamma}_i) \rightarrow \next(\Mcl)).
\end{equation*}


\subsubsection{Communication}

The robots communicate with each other using the four-phase handshake protocol introduced in \sec{4PHP}. Each robot communicates with its slave and its master as receiver and sender respectively, see \sec{negotiations}. The sender specifications, i.e.\ for the communication of the robot as master, consist of the following guarantees:
\begin{eqnarray*}
	&\mathrm{VII} &\guar{M}{28} = \always(\Mgu \wedge \clear{\Cout{}=\e} \rightarrow \neg\ackin), \\
	&\mathrm{VIII} &\guar{M}{29} = \always(\Mgu \wedge \rais{\Cout{}=\e} \rightarrow \ackin),\\
	&\mathrm{X} &\guar{M}{30} = \always(\Mgu \wedge \ackin \rightarrow \next(\Cout{}=\e)),
\end{eqnarray*}
and of the following assumptions:
\begin{eqnarray*}
	&\mathrm{II} &\ass{M}{1} = \always(\rais{\ackin} \rightarrow \Cout{}\neq\e), \\
	&\mathrm{III} &\ass{M}{2} = \always(\clear{\ackin} \rightarrow \Cout{}=\e).
\end{eqnarray*}
Note however, that the assumption $\always(\Cout{}=\e \rightarrow \eventually\neg\ackin)$ corresponding to I is not included, since then the specification would not be synthesizable. This is because the rest of the specification implicitly includes $\always(\pi(\ackin) \rightarrow \eventually\pi'(\Cout{}))$ for some propositional formulae $\pi$ and $\pi'$. However, leaving out an assumption does not render the protocol incorrect (while leaving out a guarantee would). The guarantee IX is not necessary, since the request signal $\Cout{}$ is boolean and a specification $\always(\Cout{} \wedge \next\neg\Cout{} \rightarrow \next\neg\Cout{})$ is redundant. The conjunct $\Mgu$ in the antecedents of the guarantees is necessary to ensure realizability since $\Cout{}$ must be permitted to be asserted when guarding mode is entered (cf.\ guarantee $\guar{M}{3}$).\\

The receiver specifications, i.e.\ for the communication of the robot as a slave consist of the following guarantees:
\begin{eqnarray*}
	&\mathrm{XII} &\guar{M}{31} = \always(\Cin{}\neq\e \rightarrow \next\ackout),\\
	&\mathrm{XIII} &\guar{M}{32} = \always(\Cin{}=\e \rightarrow \next\neg\ackout),\\
	&\mathrm{XIV} &\guar{M}{33} = \always(\rais{\ackout} \rightarrow \Cin{}\neq\e),\\
	&\mathrm{XV} &\guar{M}{34} = \always(\clear{\ackout} \rightarrow \Cin{}=\e),
\end{eqnarray*}
and of the following assumptions:
\begin{eqnarray*}
	&\mathrm{VI} &\ass{M}{3} = \always(\rais{\Cin{}=\e} \rightarrow \ackout),\\
	&\mathrm{VII} &\ass{M}{4} = \always(\clear{\Cin{}=\e} \rightarrow \neg\ackout).
\end{eqnarray*}
Note again that the assumption $\always(\ackout \rightarrow \eventually(\Cin{}=\e))$ corresponding to V is not included due to problems with synthesizability. But since all guarantees are included, the communication protocol works as proved above in Proposition 2 in \sec{4PHP}.\\


\subsubsection{Assumptions}

While the specification above is perfectly realizable, due to the large number of possible valuations of the environment variables ($|\Cin{}| \times |\ackin| \times |\cst| = 8n$) it is beneficial to make assumptions on the environment to reduce the number of transitions that have to be included in the synthesized FDS (see \sec{compsingle}).\\

Since the state of a vertex is only required in the searching modes $\Mcs$ and $\Mpc$, we can artificially set $\cst$ to some arbitrary value in these modes. Then the robot can make the following two assumptions on the environment:
\begin{align*}
	&\ass{M}{5} = \always(\Mncs \wedge \Mnpc \rightarrow \next(\cst=\ccr)),\\
	&\ass{M}{6} = \always(\stay{\Mncs \wedge \Mnpc} \rightarrow \next(\cst=\ccr)).
\end{align*}
Here we chose to set $\cst= \ccr$. Note that this has to be guaranteed by the global storage of the graph state, cf. \sec{globstore}.\\


\subsection{Synthesis}
	
The full specification of the robots results is the following
\begin{equation*}
	\v_M = \bigwedge_{1 \leq \alpha \leq 6} \ass{M}{\alpha} \rightarrow v_G \wedge \bigwedge_{1 \leq \beta \leq346} \guar{M}{\beta},
\end{equation*}
which can be translated into a GR[1] specification and hence synthesized with TLV\index{TLV}.\\

The robot specifications given above were successfully synthesized using the TuLiP\index{TuLiP} front end. For varying numbers of vertices in the topology, nine\footnote{For $n = 11$ only four samples were calculated.} random graphs were generated each in order to investigate the state space size and synthesis time,  plotted in \fig{movstates} and \fig{movtimes}. The resulting mean and standard deviation are presented by bold and dashed lines respectively.\\

As with the controllers for stationary target search, the size of the state space depends quadratically on the size of the graph $n$. The synthesis time for the moving target search controllers is polynomial as well, since the curve on the logarithmic plot in \fig{movtimes} is sublinear. However, for a given $n$ the state space size of the controllers exceeds those in stationary target search. The same is true for the time they take to synthesize (cf. \fig{statstates} and \fig{stattime}). \\

\begin{figure}
\centering
	\psfrag{avg_states}[ll][cc]{\footnotesize{Robots $R_j$}}
	\psfrag{States}[cc][cc]{\footnotesize{States}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, $n$}}
	\includegraphics[width=0.8\textwidth]{movstats.eps}
\caption{States of the robots for the moving target search. The mean and the standard deviation of nine samples are shown in bold and dashed lines respectively.}
\label{fig:movstates}
\end{figure}

\begin{figure}
\centering
	\psfrag{avg_time}[ll][cc]{\footnotesize{Robots $R_j$}}
	\psfrag{Synthesis Time [s]}[cc][cc]{\footnotesize{Synthesis Time [s]}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, $n$}}
	\includegraphics[width=0.8\textwidth]{movtimes.eps}
\caption{Time to synthesize allocator and robot for the moving target search with $n$ vertices. The mean and the standard deviation of nine samples are shown in bold and dashed lines respectively. Note that the ordinate is logarithmic.}
\label{fig:movtimes}
\end{figure}


\subsection{Simulation}

We show a simulation of the moving target search on a small graph $G$ with five vertices. The cop number is $c(G) = 3$, and so we use three robots. The specification is synthesized first and then the resulting FDS is executed in three different threads, corresponding to three robots on the graph  with controllers $\M_{\Cops_0}$, $\M_{\Cops_1}$ and $\M_{\Cops_2}$. The communication between the robots is realized using a shared data structure holding the valuations of the global state variables $V$ of the composite FDS $\M_\Cops = \M_{\Cops_0} \comp \M_{\Cops_1} \comp \M_{\Cops_2}$.\\

As explained in \sec{mstage}, all robots are initialized to $\Mgu$, except one, which is initialized to $\Mcs$. \fig{s0} shows the initial configuration on the graph. Solid edges are contaminated while dashed edges are cleared. A vertex is black, red, green and dashed if it is contaminated, critical, partially cleared or cleared, respectively.\\

The execution of the asynchronous composition of $\M_{\Cops_0}$, $\M_{\Cops_1}$ and $\M_{\Cops_2}$ results in a sequence of states $s_0s_1s_2\ldots \models \M_{\Cops}$. Significant points in this sequence are shown in \fig{movsim}. It can be seen that the graph is successfully cleared with the given number of robots. The specifications do not state how the target is detected, in which case the moving target search would have ended with the target being found (if one exists).\\

\newcommand{\fsize}{\tiny}
\newcommand{\rlabel}[3]{\psfrag{#1}[cc][cc]{\fsize{$R_{#2}\!\!:$#3}}}
\newcommand{\subst}{
	\psfrag{(0)}[cc][cc]{\fsize{$v_0$}}
	\psfrag{(1)}[cc][cc]{\fsize{$v_1$}}
	\psfrag{(2)}[cc][cc]{\fsize{$v_2$}}
	\psfrag{(3)}[cc][cc]{\fsize{$v_3$}}
	\psfrag{(4)}[cc][cc]{\fsize{$v_4$}}
	\rlabel{R0:-1}{0}{$\mgu$}
	\rlabel{R1:-1}{1}{$\mgu$}
	\rlabel{R2:-1}{2}{$\mgu$}
	\rlabel{R0:0}{0}{$\mcs$}
	\rlabel{R1:0}{1}{$\mcs$}
	\rlabel{R2:0}{2}{$\mcs$}
	\rlabel{R0:1}{0}{$\mcl$}
	\rlabel{R1:1}{1}{$\mcl$}
	\rlabel{R2:1}{2}{$\mcl$}
	\rlabel{R0:2}{0}{$\mpc$}
	\rlabel{R1:2}{1}{$\mpc$}
	\rlabel{R2:2}{2}{$\mpc$}
}

\newcommand{\fwidth}{0.45\textwidth}
\newcommand{\statefig}[3]{
	\subfigure[$s_{#1}$: #3]{
	\subst
	\includegraphics[width=\fwidth]{state0#2.eps}
	\label{fig:s#1}
	}
}

\begin{figure}[p!]
\centering
	\statefig{0}{000}{Initial configuration.}
	\statefig{1}{001}{Robot $R_0$ starts moving.}
	\statefig{6}{006}{Robot $R_0$ moves onto the starting vertex $v_4$.}
	\statefig{9}{009}{Robot $R_0$ realizes that $v_4$ is a starting vertex and goes to $\Mgu$, calling its slave $R_1$.}
	\statefig{24}{024}{Robot $R_1$ goes to $\Mcl$ and arrives at $v_4$.}
	\statefig{26}{026}{Robot $R_1$ clears the edge from $v_4$ to $v_0$. $v_4$ becomes critical.}
	\caption{Simulation result of moving target search on a graph with five vertices and three robots.}
		\label{fig:movsim}
\end{figure}

\begin{figure}[p!]
\centering
	\setcounter{subfigure}{6}
	\statefig{47}{047}{All out-edges of $v_4$ are cleared.}
	\statefig{50}{050}{$R_1$ goes to $\Mpc$ to search for a partially cleared vertex.}
	\statefig{63}{063}{$R_1$ found $v_2$, a partially cleared vertex.}
	\statefig{80}{080}{All out-edges of $v_2$ are cleared. $v_2$ itself is now cleared and $v_3$ is partially cleared. $R_1$ continues looking for partially cleared vertices.}
	\statefig{118}{118}{$R_1$ has finished clearing all out-edges of all partially cleared vertices.}
	\statefig{121}{121}{$R_1$ tries looking for other partially cleared vertices, but will not find any.}
	\caption*{{\bf Figure 5.7:} Simulation result of moving target search on a graph with five vertices and three robots.}
\end{figure}


\begin{figure}[p!]
\centering
	\setcounter{subfigure}{12}
	\statefig{136}{136}{$R_1$ discovered no partially cleared vertex and thus goes to $\Mcs$ to search for the next starting vertex.}
	\statefig{139}{139}{Coincidentally, the vertex $R_1$ is on already is the starting vertex, so $R_1$ enters guarding mode $\Mgu$ without moving.}
	\statefig{143}{143}{$R_2$ is the slave of $R_1$ and enters $\Mcl$ to clear the out-edges of $v_1$}
	\statefig{159}{159}{All out-edges of $v_1$ are cleared, and the graph is already cleared, but the robots continue moving until all edges are cleared.}
	\statefig{183}{183}{All edges are cleared after $R_2$ has cleared $v_0$ which was partially cleared in $s_{159}$. $R_2$ is still in $\Mpc$ after clearing $v_0$.}
	\statefig{213}{213}{After $R_2$ has unsuccessfully searched for partially cleared vertices and another starting vertex, it also enters $\Mgu$.}
	\caption*{{\bf Figure 5.7:} Simulation result of moving target search on a graph with five vertices and three robots.}
\end{figure}



\subsection{Discussion}


Again, as in the case of the stationary target search, the size of the state space increases quadratically with the number of vertices in the graph. However, the number of robots does not influence the size of the state space, since each robot has exactly one master and one slave and no further negotiation is required. Still, due to the required additional variables for communication, the synthesized FDS's are even larger than those in stationary target search.\\

In the searching modes, the circular search introduced in \sec{statsearch} is used. This results in a rather inefficient moving target search implementation. However, the robots only have local information, so when global properties such as ``for all partially cleared vertices'' need to be implemented in such a distributed way, a tradeoff between information and efficiency is introduced. Note also that by only using $V_G^i$, the heuristics $\mathcal{H}$ uses local information to decide on the start vertex.\\

When a robot is guarding a vertex, it cannot move. In this specification of moving target search, there is always only one robot not in guarding mode unless the graph is already cleared. This might seem inefficient, as only one robot can move. However, the guarding robots are playing an important part in the search; if they move, recontamination\index{Recontamination} could revert the progress of previous sliding moves.\\

One reason why the moving target search strategy can be implemented in such a way is because the global storage (cf. \sec{globstore}) allows the robots to not retain any historical knowledge of the graph state. Also, the heuristics $\mathcal{H}$ is implemented in the global storage, so that the start vertex is offered to a robot $R_j$ simply by letting $\cst_j = \csv$. In a real-world implementation this has to be taken into account.\\
