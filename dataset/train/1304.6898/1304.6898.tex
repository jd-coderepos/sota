\chapter{Implementations} \label{sec:impl}

In this chapter, we present two implementations of controllers for SAR robots, one for stationary target search in an USAR application, and the other for moving target search in a WiSAR application. In the stationary target search, a central authority, called the ``allocator'' is responsible for dispatching the robots to the vertices in the graph where a target needs to be rescued. In the moving target search, a distributed solution is adopted, where the authority structure among the robots is already negotiated in advance, cf.\ \sec{negotiations}.\\

\section{SAR of Stationary Target} \label{sec:statSAR}

In USAR\index{USAR}, the targets are mostly considered stationary. We develop specifications to build controllers for a team of robots that is managed by a central allocator. The goal is to find all targets in the affected area and rescue them. A robot that is at the location of a target may {\bf engage} with it by performing a rescue task like providing medical support. In this scenario, we will consider a target to be rescued if  robots have engaged with it for a sufficient amount of time.\\

The allocator is responsible for gathering information about the targets' status and location, and coordinating the action of the robots by dispatching them to the location of a target. If a robot is not dispatched, it may move around freely. The topology is represented as a graph, which is explained in \sec{maprepresentation}. It is optimistically assumed that the entire graph is known to the robots at synthesis time and that it does not change during the SAR task.\\



When the allocator dispatches a robot to a vertex, it merely asserts the index of a target's vertex on a transmission variable to the respective robot. The robot is then expected to move to this vertex on its own account, so the allocator does not need to know the topology. The allocator knows about a target's needs by receiving a message, or a ``flag'' associated with the location of the target. Targets will be assumed to be stationary since an injured or trapped person will not move.\\

Communication between the allocator and the robots is assumed to be layered on top of some reliable wireless protocol. Delivery of data is guaranteed eventually in finite time, messages are not corrupted, no reordering takes place, no messages get lost --- comparable to a data-layer protocol. Thus the communication is based on the four-phase handshake protocol developed in \sec{4PHP}.\\




\subsection{Architecture} \label{sec:statarch} \index{Architecture}

We synthesize the controllers for a set of robots and the central allocator. The asynchronous composition of the reactive systems resulting from the synthesis must satisfy the global specification of rescuing each flagged target, see~\sec{globsearchspec}.\\

In order to be able to simulate the reactive systems, it is necessary to close them as explained in~\sec{gametheorappr}. This is done by also synthesizing a reactive system for each vertex or ``cell'' in the topology. These reactive systems control the flags according to the environment assumptions of the allocator, which gathers the information about the targets. The complete architecture is shown in \fig{amm2} and the individual parts are explained below.\\




\subsubsection{Allocator and Queues}

At the heart of the architecture is the allocator, denoted by . It is connected to the robots, . The cells are also included in the figure to show how the closed-loop system would be controlled. They are shown as FDS's .\\

The allocator is informed about whether a target needs to be rescued by the boolean flags , each associated with one cell. Similarly, the allocator knows about which robots are ready by receiving the boolean variables , each associated with one robot. If a robot is ready and a vertex has been flagged, the allocator must dispatch a robot to the vertex that has been flagged for the longest period of time.\\

If there are  vertices and  robots, the allocator would need at least  states to account for the  flags and  ready signals of the robots. However, in order to reduce the allocator's state space, two FIFO\index{FIFO} queues  and  are implemented as separate components that maintain which target and robot has been waiting for the longest period of time respectively. Thus the environment variables of  are the flags  and the environment variables of  are the ready signals .\\

The allocator receives a flag-index  from , and a robot-index  from  indicating which robot may be dispatched to which cell. If  holds  at its head, then it {\bf offers}  to the allocator, and symmetrically if  holds  at its head, then it offers . Moreover, the allocator may request the next flag index from  by sending a dequeue signal , which is acknowledged by . The queue  does not have such a dequeuing capability, since this is not required in the specification.\\

The allocator can dispatch robots by setting the dispatch variable  to the value in . This indicates to the robot which is currently selected by  that it has to go to the vertex in . Internally,  maintains a counter variable  of the number of robots that have already been dispatched to the cell with index . If possible,  robots will be dispatched to a cell, but never more, because  is the number of robots that are required to clear the flag.\\

We do not provide specifications for the queues since they are not synthesized in the way explained above. With  inputs a FIFO FDS would have  states, making synthesis futile even for modest . This number results from the  configurations the internal store of the queue can be in (corresponding to the system variables ) and the  configurations the boolean inputs can be in (corresponding to the environment variables ). Hence, we consider FIFO's as standard components and use a Python implementation for simulation.\\


\subsubsection{Robots}

For stationary target search, the number of robots required is only as high as the number of robots required to rescue a target, i.e.\ . However, we may include an arbitrary number of robots in the architecture to complete the rescue operation more effectively. For example, with , if there are two targets and four robots, the robots can be dispatched in teams of two and rescue both targets at the same time. We synthesize one controller that is used on all robots and simply rename the variables with indices to indicate which variable belongs to a particular robot.\\

A robot  maintains its own position on the topology both in  and in the boolean variables . As explained above, the two representations are merely introduced for notational convenience in the specification. Another variable, , stores the destination cell if the robot has been dispatched.\\

The robot  knows that it is dispatched from the dispatch signal  sent by , if the associated robot index  from  satisfies , indicating that  sends  to . However, the robot is not interested in whether any other robot is dispatched or not. Therefore, in order to decrease the state space of the robot, auxiliary environment variables  over the domain  are introduced, one for each robot. Robot  receives  from the allocator if it is dispatched to vertex . On reaching the vertex , the robot checks its boolean sensor signal  whether there is still a target on this vertex. The environment variable  is true iff there is a target on the vertex the robot is currently on. If a target is detected at the vertex to which the robot is dispatched (recognized by ), the robot asserts a boolean engage signal  to indicate to the allocator that it has successfully reached the target's vertex.

\newcommand{\connE}[1]{\textstyle{E_{#1} = \sum_{j}(e_j \wedge X^j_{#1})}}
\newcommand{\connF}[1]{\textstyle{\flag_{#1} = \bigvee_{i} (X^{#1}_i \wedge f_i)}}\
\newcommand{\connD}[1]{\textstyle{d_{#1} = \begin{cases} D, &\text{if }R = {#1}\\ \e, &\text{otherwise}\end{cases}}}

\newcommand{\rinputF}{{f_i} \ar[l]}
\newcommand{\rinputD}{{} \ar[l]_<{D, R,}^<{f_i}}
\newcommand{\cinput}{{} \ar[r]^<{\cellID_j}_<{e_j}}

\newcommand{\cell}[1]{\cinput & *+[F]{\connE{#1}} \ar[r]^(0.7){E_{#1}} & *+++[o][F]{C_{#1}}}
\newcommand{\robotM}[2]{*+++[o][F]{R_{#1}} \ar@<.7pc>[r]^(.24){\cellID_{#1}} \ar[#2]_(.3){r_{#1}} & *+[F]{\begin{array}{l}\connD{#1} \\ \connF{#1}\end{array}} \ar@<.7pc>[l]^(.7){\flag_{#1}} & \rinputD }
\newcommand{\middleportion}{*++++[o][F]{\FIFOf} \ar@<1pc>[r]^{\DfA} \ar[r]^{F} & *++++[o][F]{\AMM} \ar@<1pc>[l]^{\Df} \ar[uu]^(0.3){D} & *++++[o][F]{\FIFOr} \ar[l]^{R}}

\begin{sidewaysfigure}

\caption{Allocator based SAR architecture. Implicitly,  and . The outgoing arrows showing the system variables  of the robots are omitted for a clearer layout. Also, internal system variables such as  and  are not shown.}
\label{fig:amm2}
\end{sidewaysfigure}


\subsubsection{Connectors} \index{Connector}

The communication\index{Communication} between the individual components in the architecture is shown by the arrows between the individual components. Some environment variables of the robots and cells are functions of the system variables of their peers. For example, the environment variable  of cell  is a function of the variables  and  for . One way to incorporate their relationship into the design would be to have  as a system variable and  and  for  as environment variables in . Then the guarantee

can be added to the specification of . Note that the summation interprets ``'' as ``'' and ``'' as ``''. While this would produce the desired result, it introduces many environment variables\index{Environment variables} into the design of the cells. If they cannot be suitably restricted by assumptions in the specification, this will lead to a considerable increase in the number of states in each cell's FDS.\\

To overcome this, these functions are implemented externally to the FDS's in the form of {\bf connectors}. A connector is an invariant proposition of the global state space. It is of the form  where  is an environment variable of an FDS , called a {\bf connector variable},  are system variables of peers of  and  is some proposition over  with the additional condition that  is not a system variable of \emph{any} component in the architecture and  is an environment variable only of . Thus, a connector introduces a new variable to the global state variables.\\

When proving properties over the composition of the specifications, these invariants can simply be assumed to hold at all times. In a simulation, these invariants are ensured by calculating the values of a connector variable  whenever it is accessed by an FDS.\\

In our implementation of stationary target search, there are three types of connectors, shown as rectangles in \fig{amm2}. There is a connector for the engage signal  of a cell  that indicates how many robots are engaged on vertex . This is expressed by

Another connector is for the flag signal  of a robot  that indicates whether the vertex  the robot is currently on contains a target, i.e.\ . This expressed by

The third type of connectors is for the dispatch signal  of a robot . Robot  is dispatched to the vertex  iff  and , i.e.\ if the robot that is offered to the allocator is  and the allocator decides to dispatch a robot to the vertex . This is expressed by

Note that the connectors have access to the global state, i.e.\ they are not restricted by the position a robot is in. However, the expressions in \eqref{eq:connE}--\eqref{eq:connD} clearly indicate that only the local state is used to calculate the connector variables. By local state we mean that a cell can only use the values of robots on the corresponding vertex and a robot can only use the values of the cell on which it is currently.\\



\subsection{Global Specifications} \index{Global specification}

The composition of all components in \fig{amm2} has to satisfy the global specification for stationary target search discussed in \sec{globsearchspec} in a form that corresponds to the problem setting considered here. A target on vertex  is indicated by the flag  being asserted, and the goal of the allocator is the to get  robots to arrive at the vertex . This can be expressed analogously to \eqref{eq:globstatgoal} by


We now state the specifications of each component so that the asynchronous composition fulfills this global specification. This can be verified for example by using the Feedback Interconnection Refinement Rule in Proposition 1, but here we only note that the simulation yields the desired result.\\

For compacter specifications, define

for any propositional formula .\\

\subsection{Allocator Specification}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & Indicates a robot that is ready \\
 &  & Indicates a vertex that is flagged \\
 &  & Dequeue acknowledge signal from  \\
\hline
\end{tabular}
\caption{Environment variables of the allocator, .}
\label{tab:env:alloc}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & Dequeue signal to  \\
 &  & Counts how many robots have been dispatched \\
 &  & Dispatch signal to robots \\
\hline
\end{tabular}
\caption{System variables of the allocator, .}
\label{tab:sys:alloc}
\end{table}

The state variables of the allocator are shown in tables \tab{env:alloc} and \tab{sys:alloc}. The following specifications are for the FDS  in \fig{amm2}.\\ 


\subsubsection{Assumptions}

Initially, no robot is ready, so  offers no robot and . Moreover,  doesn't have a dequeue request to acknowledge, so  is low:


 keeps track of the robots that are ready, and so, if available, presents a robot to the allocator that can be dispatched. This robot will not change unless the formerly presented robot has been dispatched:


Once a vertex is flagged, it is not unflagged unless a robot is dispatched to this cell, i.e.\ no target can rescue itself. More precisely, the flag offered by  may only change if a robot is dispatched or a dequeue signal is sent to the queue:


The dequeue acknowledgement stays high as long as the dequeue request stays high:



\subsubsection{Guarantees}

Initially, the dequeue signal is low, the counter is zero and no robot is dispatched:


Once the allocator has dispatched a robot, it monitors the ready signal it receives from . As long as this does not change, it does not clear the dispatch signal:

However, if  presents a different robot to the allocator, this means that the robot to which the dispatch signal has been sent is no longer ready and has successfully reacted to the dispatch request. Thus dispatch is cleared:


If the allocator gets offered a flag  from  and a robot is offered by , it may dispatch a robot to vertex  by asserting . In this case the counter  must be increased by one:


The dispatch signal may only be asserted if the counter  is not saturated, some robot is ready and a cell is flagged:

If a robot is dispatched and the dispatch signal is changed, it must be reset:

Moreover, dispatching a robot requires the dispatch signal to be clear:


The counter may only increase by one if a robot has been dispatched:

Also, the counter may not decrease (unless it is reset), and it may only go up by one at a time. This requirement is captured by , where  and  are the values of the counter at the current and next step respectively:

This formulation \emph{forbids} certain changes of the counter . A positive formulation that ensures that  only changes in a permissible way can also be used but results in exactly the same synthesized FDS.\\

If no robot is dispatched, the counter must not change:

The counter is only reset on a raising edge of the acknowledgement received from FIFOf:

Conversely, if the counter is saturated and a raising edge of the acknowledgement is observed, then the counter is reset:


If enough robots have been dispatched to the vertex currently offered by , then the counter  is saturated. The allocator must then ask  to offer the location of the next target, if available. For this purpose, the dequeue signal  is raised if no acknowledgement is currently received:

The dequeue signal may only go high if the acknowledgement is low:

Also, the dequeue signal must stay high until an acknowledgement is received from FIFOf:



\subsubsection{GR[1] Specification and Communication} \index{Communication} \index{Specification!GR[1]}

The above formulae are composed into the specification of the allocator:

which can be translated into a GR[1] specification.\\

The communication with  over the request signal  and the acknowledgement signal  follows the four-phase handshake protocol of \sec{4PHP}. The assumption  corresponds to III in , and the guarantees  and  correspond to VII and VIII respectively. IX is not required for a boolean request signal and XI is indirectly asserted by ,  and , \emph{given that} there are at least  robots offered by . The property X is not guaranteed from the specification itself, but is required for the communication protocol to be valid. However, model checking\index{Model checking} the synthesized FDS of the allocator  reveals that also . Thus the allocator satisfies the requirements to be a sender in the four-phase handshake protocol.\\

The allocator communicates with a robot also using the four phase handshake protocol. The request signal that is sent by the allocator is a combination of the index  offered by  and the index of the target's vertex in . In the notation of \sec{4PHP},  for the request signal to robot . The acknowledgement from robot  is the signal  being cleared. However,  is not received as an environment variable by the allocator, so the robot index  offered by  is used to extract this information: When  changes, then robot  has acknowledged the dispatch request. In the notation of \sec{4PHP}, . Thus  and  correspond to VIII and IX respectively, while X is implied by  and .\\


\subsection{Robot Specification}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & The vertex the robot is dispatched to \\
 &  & Indicates whether the vertex the robot is on is flagged \\
\hline
\end{tabular}
\caption{Environment variables of the robot . Note that  and  are both provided by a connector.}
\label{tab:env:robot}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & Indicates whether the robot is ready \\
 &  & Indicates whether the robot is engaged \\
 &  & Stores the current target vertex \\
 &  & Stores the current position of the robot \\
 &  & Stores the current position of the robot \\
\hline
\end{tabular}
\caption{System variables of the robot .}
\label{tab:sys:robot}
\end{table}

The environment and system variables of the robot  are given in tables \tab{env:robot} and \tab{sys:robot} respectively. In the following specifications, the sub- and superscripts with the robot's index  are omitted.

\subsubsection{Assumptions}

Initially, it is only known that the robot is not dispatched. This is a consequence of the robot also not being ready when it is started up (see guarantees):


The allocator must wait for the robot to become ready before it can be dispatched:


If the allocator sends a dispatch signal, this must remain the same until the robot acknowledges this by clearing its ready signal. Then FIFOr deletes this robot out of its list of robots that are ready, which in turn is (possibly) received by the allocator which only then may clear the dispatch signal:



\subsubsection{Guarantees}

Initially, the robot is not engaged, not ready and has no target stored:


The robot becomes ready when no target is stored and it is not ready. From this time on, it will turn out that the atomic propositions  and  are equivalent, because the robot is ready exactly if no destination is stored:


If the robot receives a dispatch signal when it is ready, it fills its target storage with the appropriate destination:

Moreover, a target may only be stored if the robot is ready. As a result of this, the robot must clear the ready signal :

The target store may only be cleared to , and only if the robot is at the target location and no flag is detected. Then also the robot must assert that it is ready:


When a destination is stored then the robot eventually reaches the required cell:


If the robot arrives at the correct cell and the flag is still up, then it engages:

If the robot arrives at the correct cell but the flag is already cleared, then the store is cleared, the robot goes back to ready and disengages:

The robot may only engage if it is in the correct cell and the flag is still sensed:

Disengaging requires the target storage to be cleared. Note that this implicitly also includes all that is required to clear the target storage:


The robot is free to move as long as it is not engaged.


The allowable moves of the robot depend on the graph  on which the search is performed. Since  is given at specification time, the restrictions due to the topology are encoded as presented in \sec{maprepresentation}, and the formula  is included in the robot's specification.\\


\subsubsection{GR[1] Specification and Communication} \index{Specification!GR[1]} \index{Communication}

The above formulae are composed into the specification of the robot:

which can be translated into a GR[1] specification, see \sec{GR1}.\\

The robot  may receive dispatch signals from the allocator via the dispatch signal . It acknowledges such a request by clearing its ready signal . The allocator does not directly receive  but only the signal  from , which must be taken into account when reasoning about the correctness of the communication protocols. Thus the acknowledgement signal is equivalent to , i.e.\ when the robot declares that it is no longer ready. Except in the initial state, this is also equivalent to . The request signal is equivalent to . Therefore the guarantee  corresponds to XIV, and the combination of  and  corresponds to XII. However, XV and XIII are not directly guaranteed by the robot but are required in Cases 4 and 5 of the proof of Proposition 3. XIII states that  necessarily results in . However, since the allocator does not require the liveness assumption I, the proof of Case 5 still works without guaranteeing XIII as follows:\\

To prove Precondition 1. we deduce II--VI from the conjuncts of the closures of  and . II and III follow from  arising from the existential quantification of . IV--VI similarly follow from . To prove Precondition 2. we take  in the closure and the result follows trivially.\\

XV states that  requires . But the proof of Case 4 fails when omitting this guarantee. However, let us consider what would happen if the robot raised  when . The allocator only receives  from . If  then  must be  from  and , so in this case  is not possible. Thus at that point  and so a robot ,  is offered to the allocator in . Thus when  is raised,  does not change necessarily, since  offers  first. However, from the connector proposition for , when  then . So also in this case  is not possible.\\


\subsection{Cell and Queue Specifications}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment &  &  & The number of robots engaged on this cell \\
\hline
System &  &  & Indicates whether the cell is flagged \\
\hline
\end{tabular}
\caption{Variables of the Cell }
\label{tab:cellvars}
\end{table}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment &  &  & The ready signal received from robot  \\
\hline
System &  &  & The index of the robot offered to \\
\hline
\end{tabular}
\caption{Variables of .}
\label{tab:fiforvars}
\end{table}

\begin{table}
\centering
\begin{tabular}{l|c|c|l}
\hline
& Name & Domain & Description \\
\hline
Environment &  &  & The flag received from cell \\
            &  &  & The dequeue request from \\
\hline
System &  &  & The index of the vertex offered to \\
       &  &  & The dequeue acknowledgement \\
\hline
\end{tabular}
\caption{Variables of .}
\label{tab:fifofvars}
\end{table}

Each cell  in the architecture in \fig{amm2} has just one environment variable , indicating the number of robots engaged on the cell, and one system variable , the flag of the cell. These variables are shown in \tab{cellvars}. In the specification, we will again drop the subscripts from the variables and write just  and .\\

A cell has to satisfy only two guarantees. The flag can only be cleared if there are at least  robots engaged on the cell:

Moreover, we include a liveness property, ensuring that the cell will always be flagged eventually:


In order for the specification to be realizable, we need to assume that as long as a cell is flagged, the number of robots that are engaged on the vertex associated with that cell will never decrease:


The FIFO\index{FIFO} queues  and  are not synthesized as FDS's due to the state space explosion problem, cf.\ \sec{statarch}. Instead, a thread is implemented that guarantees certain properties to the allocator . In particular, the environment assumptions of  on the local system variables controlled by  and  must be satisfied. The conceptual environment and system variables of the two queues are shown in \tab{fiforvars} and \tab{fifofvars} respectively.\\

From , the allocator requires that initially ``'', which can easily be implemented in . Also,  requires the dequeue acknowledgement  to only be lowered if also the dequeue request  is false, which is similarly straightforward to implement.\\

There is only one requirement on , imposed by . The robot index  that is offered to  may hence only be changed if a robot is dispatched. Since  keeps track on which robots are ready, and robots may only lower their ready signals  following a dispatch  (cf.\ the connector \eqref{eq:connD}), this requirement is automatically met.\\

Lastly, from , the flag offered to the allocator may only be changed if a dequeue signal  is received by  or a robot is dispatched.  therefore only dequeues a flag either if  is high, or the flag is lowered. By the cell's guarantee  and the connector \eqref{eq:connE}, a flag can only be lowered if at least  robots are engaged on the corresponding cell. This again is only the case if , i.e.\ a robot is dispatched.\\


\subsection{Synthesis} \index{Synthesis}

The specifications given above were successfully synthesized using the TuLiP\index{TuLiP} front end. \fig{statstates} shows the number of states of the allocator and the robot when varying the size of the topology and the number of robots available.\\

The size of the state space of the robot does not depend on the number of robots in the architecture, but the size of the state space of both the allocator and the robots increases quadratically with the number of vertices in the graph representation of the topology. Also, the size of the state space of the allocator increases slightly with the number of robots.\\

\begin{figure}
\centering
	\psfrag{alloc2}[ll][cc]{\footnotesize{, }}
	\psfrag{alloc3}[ll][cc]{\footnotesize{, }}
	\psfrag{alloc4}[ll][cc]{\footnotesize{, }}
	\psfrag{alloc5}[ll][cc]{\footnotesize{, }}
	\psfrag{alloc6}[ll][cc]{\footnotesize{, }}
	\psfrag{robot}[ll][cc]{\footnotesize{Robots , any }}
	\psfrag{States}[cc][cc]{\footnotesize{States}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, }}
	\includegraphics[width=0.8\textwidth]{stats.eps}
\caption{States of allocator and robot for the stationary target search. The relation for both allocator  and robots  is quadratic in the number of vertices .}
\label{fig:statstates}
\end{figure}

The time for synthesizing the controllers is also polynomial in the size of the topology, as would be expected: The size of the specification increases at most quadratically with , the number of vertices in the graph representing the topology, and the synthesis time is cubic in the size of the specification. By plotting the synthesis time on a logarithmic scale as in \fig{stattime} shows that the complexity must be subexponential. A rough analysis yields polynomial complexity of sixth order in , but this cannot be seen accurately from the available data.\\

The timing measurements have been conducted on a  Intel Core i7 CPU, with  of working memory. The available memory is likely to also affect the performance because the JTLV implementation uses the JVM Garbage Collector. Note also that the graph presented in this section was obtained for just one random graph for each value of . Other random graphs give different state space sizes and synthesis times, but the polynomial complexity results still hold.\\

\begin{figure}
\centering
	\psfrag{alloc2}[ll][cc]{\footnotesize{allocator, }}
	\psfrag{alloc3}[ll][cc]{\footnotesize{allocator, }}
	\psfrag{alloc4}[ll][cc]{\footnotesize{allocator, }}
	\psfrag{alloc5}[ll][cc]{\footnotesize{allocator, }}
	\psfrag{alloc6}[ll][cc]{\footnotesize{allocator, }}
	\psfrag{robot}[ll][cc]{\footnotesize{robots, any }}
	\psfrag{Synthesis Time [s]}[cc][cc]{\footnotesize{Synthesis Time [s]}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, }}
	\includegraphics[width=0.8\textwidth]{times.eps}
\caption{Time to synthesize allocator and robot for the stationary target search with  vertices and  robots. Note that the ordinate is logarithmic but the relation is polynomial.}
\label{fig:stattime}
\end{figure}





\subsection{Discussion}

Stationary target search has been successfully simulated for various numbers of robots and vertices. When more than two robots are used, the allocator explicitly requests a new flag to be offered by  and dispatches a robot to the corresponding vertex. Thus, with four and more robots several targets can be rescued simultaneously.\\

However, as is clear from \fig{statstates}, the size of the state space grows very fast with the size of the graph. This affects the efficiency of synthesis. The synthesis of the controllers for  vertices and  robots already took about , and much longer times are expected for larger graphs. However, space seems to be even a more pressing issue. Larger problems are susceptible to heap overflow due to unsuccessful JVM garbage collection. For example, synthesis of a controller for  vertices and  robots is not successful when only permitting  of working memory.\\

The increase of the state space is mostly due to the added environment variables from the communication protocol. The assumptions on these additional environment variables cannot be strengthened sufficiently to reduce the state space further. The communication in this specification already deviates slightly from the four-phase handshake protocol defined in \sec{4PHP} in order to alleviate this problem, as any additional signal like a boolean acknowledgement roughly doubles the state space. Also, beyond a certain graph size, synthesis seems impractical. If this limitation cannot be overcome, then this type of specification seems unsuitable for practical applications.\\


\section{Moving Target Search} \label{sec:implmovt}

In contrast to USAR, the targets in WiSAR\index{WiSAR} are considered to be able to move. That means that the stationary target search methods are no longer sufficient, and we implement the distributed multi stage moving target search strategy developed in \sec{mstage}.\\

There is no central allocator, hence the specification is easier than that of stationary target search. However, as is evident from \sec{movtsearch}, justifying that a given number robots with controllers synthesized from the specification reliably find all moving targets requires more effort than with stationary target search.\\


\subsection{Communication Structure} \label{sec:commstructure} \index{Communication}

As indicated in \sec{negotiations}, the robots are organized in a circular structure of authority and communication. A robot  has exactly one slave and exactly one master. \fig{commstructure} shows such a cycle. The state variables of the robots are explained in \tab{inp:robot} and \tab{out:robot}.\\

\newcommand{\dist}{0.2pc}
\newcommand{\ratio}{0.35}
\newcommand{\robot}[1]{*++[o][F-]{R_{#1}}}
\begin{figure}[h!]

\caption{Four robots communicating in the moving target search architecture. Note that only the local system and environment variables directly relevant for communication are shown.}
\label{fig:commstructure}
\end{figure}

We use the standard four-phase handshake protocol introduced in \sec{4PHP}. Hence no sophisticated arguments as in the previous section on stationary target search are required to justify the correctness of the communication protocols used. Also, the correctness of the composition of all synthesized components is a simple extension of Proposition 2 in \sec{4PHP}.\\

\subsection{Robot Specifications} \label{sec:robspec}

Similar to the stationary target search, the global specification must state that any target is eventually found on the given topology. Since the search strategies developed in \sec{distrsoln} ensure that the graph is cleared, this global requirement is necessarily satisfied, given that the architecture contains sufficiently many robots. We therefore only state the specifications that are synthesized into robots implementing a winning strategy for the cops. It is then easy to extend this to include sensors to detect targets and react appropriately (e.g.\ by engaging).\\

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & Vertex the robot is sent to by its master \\
 &  & Acknowledgement received from its slave \\
 &  & State of the vertex on which the robot is \\
\hline
\end{tabular}
\caption{Environment Variables of Robot }
\label{tab:inp:robot}
\end{table}

\begin{table}
\centering
\begin{tabular}{c|c|l}
\hline
Name & Domain & Description \\
\hline
 &  & Mode of the robot \\
 &  & Vertex stored for the clearing mode\\
 &  & Current position of the robot \\
 &  & True if robot  is in position \\
 &  & Counter in clearing mode\\
 &  & Counter in search modes\\
 &  & Maximum counter value in search modes\\
 &  & Acknowledgement sent to master \\
 &  & Vertex to send the robot's slave to \\
\hline
\end{tabular}
\caption{System Variables of Robot }
\label{tab:out:robot}
\end{table}

In the following specifications, the subscripts and superscripts indicating the index of the robot are omitted for notational convenience.\\


\subsubsection{Guarantees: Topology}

Similar to the stationary target search, the allowable moves of the robot have to be defined in the guarantee part of the specification. The restrictions due to the topology are encoded as presented in \sec{maprepresentation}, and the formula  encoding the topology is included in the robot's specification.\\

Note that the targets are restricted to move on the same topology. However, since they are assumed to be able to move with infinite speed, and the graph is strongly connected, the robot cannot assume any restriction on the movement of the targets.\\


\subsubsection{Guarantees: Guarding Mode}

In the guarding mode , the robot has to stay at the current vertex unless a command from its master is received via :

However, if a command is received, then the clearing mode  has to be entered, setting up the store and counter appropriately:

If the guarding mode is entered, then the robot's slave is instructed to clear all out-edges of the current vertex  by asserting the index  on . However, if the guarding mode is entered because the counter  is saturated, this means that no vertex was found in  or . In this case we know that the graph is cleared and so  stays at .\\



\subsubsection{Guarantees: Searching Modes}

The searching modes  and  can be specified together, as they differ only slightly by the state of the vertex the robot is searching for and the mode that is entered if such a vertex is encountered.\\

First, when entering a searching mode, the counters must be initialized correctly:

where  is the index of the first occurrence of the vertex  in the path . Note that  as defined in \sec{globsearchspec} before \eqref{eq:countincrease}.\\

The robot moves along the path  one vertex at a time, making sure that the counter  increases at every transition:


If a start vertex\index{Start vertex} has been found, then enter the guarding mode :

Similarly, if a partially cleared vertex  has been found, then enter the clearing mode , initialized to clear the out-edges of :

Also, if the maximum counter value is reached in , then there is no partially cleared vertex and the search for a start vertex  is entered:

Note that the values of the counters are reset to the correct values necessarily by the guarantee . Similarly, if the maximum counter value is reached in , then there is no contaminated (start) vertex and the graph must necessarily be cleared and the robot becomes dormant in guarding mode . Note that an additional mode can be introduced in this case that allows the robots to move arbitrarily on the graph, but here only the concept of moving target search should be introduced. The corresponding guarantee is:


Now a few guarantees are required that prevent the counters from changing when they should not (so called frame axioms). The counter of the position in the path ,  may only increase until it overflows, corresponding to the path closing in a cycle.

Similarly, the value stored as maximum for the counter may not change:

Since  and  are only used in  or , they are set to zero otherwise:


Two more guarantees are required to prevent the robot from leaving the searching mode if no start vertex or partially cleared vertex was encountered or the counter has not reached its maximum value:



\subsubsection{Guarantees: Clearing Mode}

The clearing mode is the most involved mode, but also the mode that is responsible for actual progress in clearing edges: no edges can be cleared by a robot that is not in mode .\\

First, on entering clearing mode, the index of a vertex is written to  so that the robot knows for which vertex the out-edges must be cleared. This can only happen when the robot is guarding and called by its master to move, or when the robot has found a partially cleared cell that it is now about to clear:

Also,  may only change from  if also the counter  is reset to  or alternatively if the robot enters the clearing mode from a search for a partially cleared vertex:

Moreover, if , then it may only change to , i.e.\ it is not permitted to immediately change from sliding down the out-edges of one vertex to sliding down the out-edges of another. Such a change also requires the counter  to be saturated, indicating that all out-edges of the vertex held in  are successfully cleared:

Conversely, if the counter  is saturated, then the robot has successfully cleared all out-edges of the vertex held in  and thus enters the search for a partially cleared vertex:


The counter  is always diligently set to  when the clearing mode is entered (see ), representing that the robot first has to move to the vertex held in . This latter requirement is expressed using the following property:

Note that we write  rather than the more intuitively obvious . This is because the latter introduces  response formulae\index{Response formula}, each of which requires a trigger\index{Trigger} variable to be added to the system variables, which would multiply the potential number of states by . Using the former contracted response property only requires one trigger and thus the synthesized FDS has fewer states.\\

While the robot moves to the vertex held in , the counter  must remain at :
	
On reaching the vertex, the robot sets the counter to zero. It also stays in the vertex so that the state of the robot is consistent:


Given that the robot is in the vertex held in  and the counter  has a value not equal to , an out-edge can be cleared. The corresponding property has already been introduced in \sec{mstage}:

Recall that  is the number of out-edges of the vertex  and  is the (unique) vertex such that there is an edge  from  to  and  is the  edge to be cleared by the robot. After clearing the edge, the robot must move back to the vertex held in , which is expressed by the guarantee

This again is a response property, which would require a trigger to be introduced. Instead of having both response properties \eqref{eq:gohome} and \eqref{eq:goback}, we combine them into one guarantee:

This is of course only possible since the right hand side of the implication  is the same in both \eqref{eq:gohome} and \eqref{eq:goback}.\\

Again, the counter  must be restricted. It may only increase by one if an edge is cleared:

Also, the counter may not decrease unless it is reset. Moreover, it may only increase by one:

where  is a formula that only holds if the counter changes by an admissible amount, which is defined as follows:

The counter may only be reset to  if all out-edges have been cleared:


If the robot is not in the clearing mode, then the counter  and  are not used, and they are therefore set to :

Finally, the robot has to remain in the clearing mode as long as there are still out-edges of the vertex held in  to be cleared.



\subsubsection{Communication}

The robots communicate with each other using the four-phase handshake protocol introduced in \sec{4PHP}. Each robot communicates with its slave and its master as receiver and sender respectively, see \sec{negotiations}. The sender specifications, i.e.\ for the communication of the robot as master, consist of the following guarantees:

and of the following assumptions:

Note however, that the assumption  corresponding to I is not included, since then the specification would not be synthesizable. This is because the rest of the specification implicitly includes  for some propositional formulae  and . However, leaving out an assumption does not render the protocol incorrect (while leaving out a guarantee would). The guarantee IX is not necessary, since the request signal  is boolean and a specification  is redundant. The conjunct  in the antecedents of the guarantees is necessary to ensure realizability since  must be permitted to be asserted when guarding mode is entered (cf.\ guarantee ).\\

The receiver specifications, i.e.\ for the communication of the robot as a slave consist of the following guarantees:

and of the following assumptions:

Note again that the assumption  corresponding to V is not included due to problems with synthesizability. But since all guarantees are included, the communication protocol works as proved above in Proposition 2 in \sec{4PHP}.\\


\subsubsection{Assumptions}

While the specification above is perfectly realizable, due to the large number of possible valuations of the environment variables () it is beneficial to make assumptions on the environment to reduce the number of transitions that have to be included in the synthesized FDS (see \sec{compsingle}).\\

Since the state of a vertex is only required in the searching modes  and , we can artificially set  to some arbitrary value in these modes. Then the robot can make the following two assumptions on the environment:

Here we chose to set . Note that this has to be guaranteed by the global storage of the graph state, cf. \sec{globstore}.\\


\subsection{Synthesis}
	
The full specification of the robots results is the following

which can be translated into a GR[1] specification and hence synthesized with TLV\index{TLV}.\\

The robot specifications given above were successfully synthesized using the TuLiP\index{TuLiP} front end. For varying numbers of vertices in the topology, nine\footnote{For  only four samples were calculated.} random graphs were generated each in order to investigate the state space size and synthesis time,  plotted in \fig{movstates} and \fig{movtimes}. The resulting mean and standard deviation are presented by bold and dashed lines respectively.\\

As with the controllers for stationary target search, the size of the state space depends quadratically on the size of the graph . The synthesis time for the moving target search controllers is polynomial as well, since the curve on the logarithmic plot in \fig{movtimes} is sublinear. However, for a given  the state space size of the controllers exceeds those in stationary target search. The same is true for the time they take to synthesize (cf. \fig{statstates} and \fig{stattime}). \\

\begin{figure}
\centering
	\psfrag{avg_states}[ll][cc]{\footnotesize{Robots }}
	\psfrag{States}[cc][cc]{\footnotesize{States}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, }}
	\includegraphics[width=0.8\textwidth]{movstats.eps}
\caption{States of the robots for the moving target search. The mean and the standard deviation of nine samples are shown in bold and dashed lines respectively.}
\label{fig:movstates}
\end{figure}

\begin{figure}
\centering
	\psfrag{avg_time}[ll][cc]{\footnotesize{Robots }}
	\psfrag{Synthesis Time [s]}[cc][cc]{\footnotesize{Synthesis Time [s]}}
	\psfrag{Vertices}[cc][cc]{\footnotesize{Vertices, }}
	\includegraphics[width=0.8\textwidth]{movtimes.eps}
\caption{Time to synthesize allocator and robot for the moving target search with  vertices. The mean and the standard deviation of nine samples are shown in bold and dashed lines respectively. Note that the ordinate is logarithmic.}
\label{fig:movtimes}
\end{figure}


\subsection{Simulation}

We show a simulation of the moving target search on a small graph  with five vertices. The cop number is , and so we use three robots. The specification is synthesized first and then the resulting FDS is executed in three different threads, corresponding to three robots on the graph  with controllers ,  and . The communication between the robots is realized using a shared data structure holding the valuations of the global state variables  of the composite FDS .\\

As explained in \sec{mstage}, all robots are initialized to , except one, which is initialized to . \fig{s0} shows the initial configuration on the graph. Solid edges are contaminated while dashed edges are cleared. A vertex is black, red, green and dashed if it is contaminated, critical, partially cleared or cleared, respectively.\\

The execution of the asynchronous composition of ,  and  results in a sequence of states . Significant points in this sequence are shown in \fig{movsim}. It can be seen that the graph is successfully cleared with the given number of robots. The specifications do not state how the target is detected, in which case the moving target search would have ended with the target being found (if one exists).\\

\newcommand{\fsize}{\tiny}
\newcommand{\rlabel}[3]{\psfrag{#1}[cc][cc]{\fsize{#3}}}
\newcommand{\subst}{
	\psfrag{(0)}[cc][cc]{\fsize{}}
	\psfrag{(1)}[cc][cc]{\fsize{}}
	\psfrag{(2)}[cc][cc]{\fsize{}}
	\psfrag{(3)}[cc][cc]{\fsize{}}
	\psfrag{(4)}[cc][cc]{\fsize{}}
	\rlabel{R0:-1}{0}{}
	\rlabel{R1:-1}{1}{}
	\rlabel{R2:-1}{2}{}
	\rlabel{R0:0}{0}{}
	\rlabel{R1:0}{1}{}
	\rlabel{R2:0}{2}{}
	\rlabel{R0:1}{0}{}
	\rlabel{R1:1}{1}{}
	\rlabel{R2:1}{2}{}
	\rlabel{R0:2}{0}{}
	\rlabel{R1:2}{1}{}
	\rlabel{R2:2}{2}{}
}

\newcommand{\fwidth}{0.45\textwidth}
\newcommand{\statefig}[3]{
	\subfigure[: #3]{
	\subst
	\includegraphics[width=\fwidth]{state0#2.eps}
	\label{fig:s#1}
	}
}

\begin{figure}[p!]
\centering
	\statefig{0}{000}{Initial configuration.}
	\statefig{1}{001}{Robot  starts moving.}
	\statefig{6}{006}{Robot  moves onto the starting vertex .}
	\statefig{9}{009}{Robot  realizes that  is a starting vertex and goes to , calling its slave .}
	\statefig{24}{024}{Robot  goes to  and arrives at .}
	\statefig{26}{026}{Robot  clears the edge from  to .  becomes critical.}
	\caption{Simulation result of moving target search on a graph with five vertices and three robots.}
		\label{fig:movsim}
\end{figure}

\begin{figure}[p!]
\centering
	\setcounter{subfigure}{6}
	\statefig{47}{047}{All out-edges of  are cleared.}
	\statefig{50}{050}{ goes to  to search for a partially cleared vertex.}
	\statefig{63}{063}{ found , a partially cleared vertex.}
	\statefig{80}{080}{All out-edges of  are cleared.  itself is now cleared and  is partially cleared.  continues looking for partially cleared vertices.}
	\statefig{118}{118}{ has finished clearing all out-edges of all partially cleared vertices.}
	\statefig{121}{121}{ tries looking for other partially cleared vertices, but will not find any.}
	\caption*{{\bf Figure 5.7:} Simulation result of moving target search on a graph with five vertices and three robots.}
\end{figure}


\begin{figure}[p!]
\centering
	\setcounter{subfigure}{12}
	\statefig{136}{136}{ discovered no partially cleared vertex and thus goes to  to search for the next starting vertex.}
	\statefig{139}{139}{Coincidentally, the vertex  is on already is the starting vertex, so  enters guarding mode  without moving.}
	\statefig{143}{143}{ is the slave of  and enters  to clear the out-edges of }
	\statefig{159}{159}{All out-edges of  are cleared, and the graph is already cleared, but the robots continue moving until all edges are cleared.}
	\statefig{183}{183}{All edges are cleared after  has cleared  which was partially cleared in .  is still in  after clearing .}
	\statefig{213}{213}{After  has unsuccessfully searched for partially cleared vertices and another starting vertex, it also enters .}
	\caption*{{\bf Figure 5.7:} Simulation result of moving target search on a graph with five vertices and three robots.}
\end{figure}



\subsection{Discussion}


Again, as in the case of the stationary target search, the size of the state space increases quadratically with the number of vertices in the graph. However, the number of robots does not influence the size of the state space, since each robot has exactly one master and one slave and no further negotiation is required. Still, due to the required additional variables for communication, the synthesized FDS's are even larger than those in stationary target search.\\

In the searching modes, the circular search introduced in \sec{statsearch} is used. This results in a rather inefficient moving target search implementation. However, the robots only have local information, so when global properties such as ``for all partially cleared vertices'' need to be implemented in such a distributed way, a tradeoff between information and efficiency is introduced. Note also that by only using , the heuristics  uses local information to decide on the start vertex.\\

When a robot is guarding a vertex, it cannot move. In this specification of moving target search, there is always only one robot not in guarding mode unless the graph is already cleared. This might seem inefficient, as only one robot can move. However, the guarding robots are playing an important part in the search; if they move, recontamination\index{Recontamination} could revert the progress of previous sliding moves.\\

One reason why the moving target search strategy can be implemented in such a way is because the global storage (cf. \sec{globstore}) allows the robots to not retain any historical knowledge of the graph state. Also, the heuristics  is implemented in the global storage, so that the start vertex is offered to a robot  simply by letting . In a real-world implementation this has to be taken into account.\\
