\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumerate}
\usepackage[numbers,sort&compress]{natbib}
\usepackage[pdftitle={Disimplicial arcs, transitive vertices, and disimplicial eliminations},pdfauthor={Martiniano Eguía and Francisco J.\ Soulignac},pdfcreator={},pdfsubject={Disimplicial arcs, transitive vertices, and disimplicial eliminations},pdfkeywords={disimplicial arcs, bisimplicial edges of bipartite graphs, disimplicial elimination schemes, bisimplicial elimination schemes, diclique irreducible digraphs, transitive digraphs, dedekind digraphs},colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}  


\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{observation}[theorem]{Observation}

\title{Disimplicial arcs, transitive vertices, and disimplicial eliminations}
\author{Martiniano Eguía\thanks{Departamento de Computaci\'on, FCEN, Universidad de Buenos Aires, 
Buenos Aires, Argentina.} \and Francisco J.\ Soulignac\thanks{CONICET, Departamento de Computaci\'on, FCEN, Universidad de Buenos Aires, and Departamento de Ciencia y Técnica, Universidad Nacional de Quilmes, Bernal, Argentina.}}

\date{\normalsize\texttt{meguia@dc.uba.ar, francisco.soulignac@unq.edu.ar}}



\newcommand{\SPLIT}{\ensuremath{\mathrm{Split}}}
\newcommand{\JOIN}{\ensuremath{\mathrm{Join}}}
\newcommand{\IN}{\ensuremath{\mathrm{in}}}
\newcommand{\OUT}{\ensuremath{\mathrm{out}}}
\newcommand{\REPG}{\ensuremath{\mathrm{Repr}}}
\newcommand{\TN}{\ensuremath{\theta}}
\newcommand{\REP}{\ensuremath{\mathrm{repr}}}


\begin{document}
\maketitle

\begin{abstract}
 In this article we deal with the problems of finding the disimplicial arcs of a digraph and recognizing some interesting graph classes defined by their existence.  A \emph{diclique} of a digraph is a pair  of sets of vertices such that  is an arc for every  and .  An arc  is \emph{disimplicial} when  is a diclique.  We show that the problem of finding the disimplicial arcs is equivalent, in terms of time and space complexity, to that of locating the transitive vertices.  As a result, an efficient algorithm to find the bisimplicial edges of bipartite graphs is obtained.  Then, we develop simple algorithms to build disimplicial elimination schemes, which can be used to generate bisimplicial elimination schemes for bipartite graphs.  Finally, we study two classes related to perfect disimplicial elimination digraphs, namely weakly diclique irreducible digraphs and diclique irreducible digraphs.  The former class is associated to finite posets, while the latter corresponds to dedekind complete finite posets.

 \vspace*{.2\baselineskip} {\bf Keywords:} disimplicial arcs, bisimplicial edges of bipartite graphs, disimplicial elimination schemes, bisimplicial elimination schemes, diclique irreducible digraphs, transitive digraphs, dedekind digraphs.
\end{abstract}


\section{Introduction}

Disimplicial arcs are important when Gaussian elimination is performed on a sparse matrix, as they correspond to the entries that preserve zeros when chosen as pivots.  Let  be an  matrix and  be the digraph that has a vertex  for each row of  and a vertex  for each column of , where  is an arc of  if and only if .  The \emph{fill-in} of  is the number of zero entries of  that change into a non-zero value when  is the next pivot.  To reduce the extra space required to represent , the idea is to pivot with an entry of minimum fill-in.   The extreme case in which  has zero fill-in happens when  for every  such that  and .  Translated to , the arc  has ``zero fill-in'' if and only if  is an arc of  for every  such that  and  are arcs of .  In graph theoretical terms, the arcs with ``zero fill-in'' are the \emph{disimplicial} arcs of , i.e., the arcs that belong to a unique diclique of .

The discussion above is usually described in terms of bisimplicial edges of bipartite graphs, and not in terms of the disimplicial arcs of digraphs.  We emphasize that these concepts are equivalent for .  Say that a digraph is a \emph{source-sink (ST) graph} when every vertex is either a source or a sink.  Clearly, there are two ST graphs for every bipartite graph , depending on whether the edges are oriented from  to  or from  to .  Moreover, there is a one-to-one correspondence between the bisimplicial edges of  and the disimplicial arcs of its orientations.  Thus, it is unimportant whether  is oriented or non-oriented.  There is a reason why we work with digraphs in this manuscript that has to do with the fact that we relate the disimplicial arcs of ST graphs with the vertices of transitive digraphs.  So, in this way we need not describe how the edges of a non-oriented graph should be oriented.

Finding the disimplicial arcs of a digraph  is an interesting and somehow unexplored problem.  It is rather simple to determine if an arc is disimplicial in  time, thus all the disimplicial arcs can be obtained in  time and  space.  (We use  and  to denote the number of vertices and arcs of .  Also, and we assume  connected, hence .)  As we shall see in Section~\ref{sec:disimplicial vs transitive}, this problem can be reduced to that of finding the disimplicial arcs of an ST graph .  As it was noted by Bomhoff and Manthey in~\cite{BomhoffMantheyDAM2013}, the twin reduction  of  can have at most  disimplicial arcs, where  is the number of \emph{thin arcs} of .  This yields an  time and  space algorithm to find all the disimplicial arcs of .  Bomhoff and Manthey also show that certain random graphs have a constant number of thin arcs, in which case the algorithm takes linear time.  Fast matrix multiplication can also be used to obtain the disimplicial arcs in  time, but at the expense of  space.  This algorithm is, therefore, not convenient for  sparse.

In the process of Gaussian elimination not only the next pivot is important; the whole sequence of pivots is of matter.  Ideally, we would like to use no extra space throughout the algorithm to represent the input matrix .  Thus, no zero entry of  should be changed into a non-zero entry in the entire elimination process.  In~\cite{GolumbicGossJGT1978}, Golumbic~and~Goss observed that this problem corresponds to finding a perfect elimination scheme of .  An \emph{elimination scheme} of a digraph  is a sequence of arcs  such that  is disimplicial in , for every .  The sequence  is \emph{maximal} when  has no disimplicial arcs, while it is \emph{perfect} when  has no edges at all.  Not every digraph admits a perfect elimination scheme; those that do admit it are said to be \emph{perfect elimination}.  In~\cite{GolumbicGossJGT1978} it is proven that every maximal elimination scheme of  is perfect when  is a perfect elimination ST graph.  

The first algorithm to compute a maximal elimination scheme of an ST graph was given by Golumbic and Goss in the aforementioned article.  The algorithm works by iteratively removing the endpoints of a disimplicial arc until no more disimplicial arcs remain.  The complexity of their algorithm is not explicit in~\cite{GolumbicGossJGT1978}; if the disimplicial arcs are searched for as in~\cite{BomhoffMantheyDAM2013}, then  time and  space is required.  Goh and Rotem~\cite{GohRotemIPL1982} propose an  time and  space algorithm, which was later improved by Bomhoff so as to run in  time~\cite{Bomhoff2011}.  For the densest cases, the algorithm by Spinrad~\cite{SpinradDAM2004} runs in  time and  space.  In~\cite{Bomhoff2011}, Bomhoff shows the most efficient algorithm for the sparse case up to this date, requiring  time while consuming  space.

A common restriction of the zero fill-in problem is to ask all the pivots to belong to the diagonal of .  This problem is equivalent to that of finding a perfect elimination scheme whose arcs all belong to some input matching  of .  The matching  represents the arcs that correspond to the diagonal entries of .  Again, this problem can be solved by finding an elimination scheme  such that no arc of  is disimplicial in ~\cite{GolumbicGossJGT1978}.  Rose and Tarjan~\cite{RoseTarjanSJAM1978} devise two algorithms for finding such an elimination scheme of an ST graph, one runs in  time and space, and the the other requires  time but consumes only  space.  The  time algorithm by Bomhoff for finding an unrestricted scheme works in  time and  space for this case.

In this manuscript we consider two classes related to perfect elimination digraphs, namely diclique irreducible and weakly diclique irreducible graphs.  As far as our knowledge extends, these graph classes were not studied previously.  The motivating question is when does an ST graph  admit a perfect matching  of disimplicial arcs.  For such graphs, any permutation of  is a perfect elimination scheme, thus the pivots of the matrix associated to  can be taken in any order from  with zero fill-in.  How to answer this question efficiently is already known, as it reduces to establishing if the thin arcs form a perfect matching of disimplicial arcs (see~\cite{BomhoffMantheyDAM2013} and Section~\ref{sec:disimplicial vs transitive}).  Nevertheless, the class defined by these graphs has some interesting properties.  Note that, by definition, the arc set of  can be partitioned into a family of dicliques, all of which contain a disimplicial arc.  This resembles the definition of \emph{weakly clique irreducible} graphs~\cite{WangCN2003}, in which every edge should belong to a clique that contains a simplicial edge.  For this reason is that we say a digraph  is \emph{weakly diclique irreducible (WDI)} when every arc of  belongs to a diclique that contains a disimplicial arc.  The word ``weakly'' in the definition of weakly clique irreducible graphs comes from the fact that this is a superclass of the clique irreducible graphs.  A graph is \emph{clique irreducible} when every maximal clique has a simplicial edge~\cite{WallisZhangJCMCC1990}.  By analogy, we define the \emph{diclique irreducible (DI)} digraphs as those digraphs in which every maximal diclique has a disimplicial arc.  

We are mainly interesting on the above problems restricted to sparse digraphs, where sparseness is well distributed.  By this, we mean that we expect each subdigraph to be sparse as well.  The \emph{arboricity}  of a digraph correctly measures this kind of density, as it is the maximum value  for a subdigraph with  arcs and  vertices~\cite{Nash-WilliamsJLMS1964}.  So, rephrasing, we are mainly interest in the case in which .  Sometimes, however, our algorithms are most efficient when the input digraph is sparse in a stronger sense, as it must have low -index or low maxdegree.  The \emph{-index} is the maximum  such that the graph has  vertices with degree at least , while the \emph{maxdegree}  is the maximum among the degrees of the vertices; it is well known that  (see e.g.~\cite{LinSoulignacSzwarcfiterTCS2012}).

The article is organized as follows. In Section~\ref{sec:preliminaries} we introduce the terminology used.  In Section~\ref{sec:disimplicial vs transitive} we show two simple operators that transform disimplicial arcs into transitive vertices and back.  As a consequence, finding the disimplicial arcs and finding the transitive vertices are equally hard problems.  In particular, an  time and  space algorithm for a digraph with  thin arcs is obtained, improving over the algorithm in~\cite{BomhoffMantheyDAM2013}.  This algorithm is optimal unless an  time algorithm for finding the transitive vertices of a sparse graph is obtained, which is an open problem~\cite{Spinrad2003}.  In Section~\ref{sec:disimplicial elimination} we study the problem of generating maximal elimination schemes.  For the general case we show an algorithm that runs in  time and  space.  The improvement with respect to the algorithm in~\cite{Bomhoff2011} is significant for graphs with .  For the case in which all the arcs of the elimination scheme must belong to an input matching, we develop an  time and  space; which is a major improvement for sparse graphs.  The classes of WDI and DI graphs are studied in Section~\ref{sec:WDI and DI}.  We show that the operators of Section~\ref{sec:disimplicial vs transitive} provide a bijection  between a subfamily of WDI digraphs and finite posets.  When DI digraphs are considered, the range of  are precisely the dedekind complete finite posets, i.e., the finite posets that satisfy the least upper bound property.  With respect to the recognition problems, it can be solved in  time for WDI digraphs and in  time for DI digraphs.  Finally, in Section~\ref{sec:further remarks} we translate all the results to bipartite graphs while we provide further remarks.
  
\section{Preliminaries}\label{sec:preliminaries}

A \emph{digraph} is a pair  where  is finite and ;  and  are the \emph{vertex set} and \emph{arc set} of , respectively.  We write  to denote the arc with \emph{endpoints}  and  that \emph{leaves}  and \emph{enters} , regardless of whether  or not.  Note that our definition allows  to have an arc  for any ; in such case,  is a \emph{reflexive} vertex and  is a \emph{loop}.  For , we write  to denote the subdigraph of  \emph{induced} by , and  to denote . 

For , define , , and .  Sets , , and  are respectively the \emph{out-neighborhood}, \emph{in-neighborhood}, and \emph{neighborhood} of  in , while the members of , , and  are the \emph{out-neighbors}, \emph{in-neighbors}, and \emph{neighbors} of , respectively.  The \emph{out-degree}, \emph{in-degree}, and \emph{degree} of  are the values , , and , respectively.  We omit the subscript from  and  whenever  is clear from context.

For , we say that  is a \emph{source} when ,   is a \emph{sink} when , and  is \emph{transitive} when  for every  and .  A digraph is a \emph{source-sink (ST) graph} when it contains only source and sink vertices, while it is \emph{transitive} when it contains only transitive vertices.  A digraph is \emph{simple} when it has no loops, while it is \emph{reflexive} when every vertex is reflexive.  The \emph{reflexive closure} of  is the digraph obtained by adding all the missing loops to  so as to make each vertex reflexive, i.e., the reflexive closure of  is .  An \emph{oriented graph} is a digraph such that  and  only if .  An \emph{order graph} is an oriented graph that is simultaneously reflexive and transitive.  Let  be the relation on  such that  if and only if .  Note that  is reflexive (resp.\ antisymmetric, transitive) precisely when  is reflexive (resp.\ oriented, transitive).  Thus,  is an order graph if and only if  is a finite poset.

For , we write  and .  In other words,  has the out-neighbors of  whose in-degree is greater than or equal to the out-degree of , while  has the out-neighbors of  with in-degree at least .  Note that either  or  for every arc , thus all the arcs of  get visited when all the  sets are traversed.  The values ,  are denoted by  and , while .  Again, we omit the subscript  when no ambiguities arise.

We write , , and  to denote the values , , and , respectively.  The arboricity and -index are values that measure how dense is a digraph.  We use a non-standard definition of arboricity given by the equivalence in~\cite{Nash-WilliamsJLMS1964}, i.e., the \emph{arboricity}  of  is the maximum  such that  has a subdigraph with  arcs and  vertices.  The \emph{-index} is the value  such that  has  vertices with degree at least .  It is well known that , while  for every ~\cite{ChibaNishizekiSJC1985,LinSoulignacSzwarcfiterTCS2012}.  The time required to multiply two  matrices is denoted by ; up to this date  ~\cite{Williams2012}.  As before, we omit the subscripts  whenever possible.  Also, we assume  for all the problems considered with no loss of generality.

Two arcs of  are \emph{independent} when they have no common endpoints.  A \emph{matching} is a set  of pairwise independent arcs.  Sometimes we deal with  as if it were the subgraph of  with vertex set  and arc set .  Thus, we write  to denote the set of vertices entering or leaving an arc of , or we talk about the unique neighbor of  in , etc.  A matching is \emph{perfect} when .  

A \emph{diclique} of  is an ordered pair  such that  for every  and  (note that every vertex in  is reflexive).  For the sake of notation, we write  to refer to , regardless of whether  is a diclique of not.  The term \emph{diclique} is also used to denote the subdigraph  of  with vertex set  and arc set ; note that  needs not be an induced subdigraph of .  Thus, for instance, we can talk about the arcs of the diclique .  A diclique  of  is \emph{maximal} when  has no diclique  for .  An arc  is \emph{disimplicial} when  is a diclique of ; note that  is the unique maximal diclique of  that contains .  In such case, the diclique  is said to be \emph{reduced}, i.e.,  is \emph{reduced} when it is maximal and it contains a disimplicial arc.


\section{Disimplicial arcs versus transitive vertices}
\label{sec:disimplicial vs transitive}

By definition, a reflexive vertex  is transitive if and only if  is a disimplicial arc.  Hence, we can find out if a digraph  is transitive by looking if all the loops of its reflexive closure  are disimplicial.  This result can be easily strengthen so as to make  an ST graph.  

For any digraph , define  to be the digraph  that has a vertex  for each non-sink vertex , and a vertex  for each non-source vertex , where  if and only if , for every  (see Figure~\ref{fig:split+join}). Clearly,  and  are source and sink vertices, resepctively, hence  is an ST graph.  Moreover, the dicliques of  are ``preserved'' into  as in the next proposition.

\begin{figure}
 \centering
 \includegraphics{split}
 
 \includegraphics{join}
 \caption{Examples of the operations  and  for .  For the sake of exposition, we write  and  to denote the vertices  and  of , respectively.  Note that  is an arc of  if only if  is reflexive, while  is reflexive in  if and only if either  or  is reflexive in .}\label{fig:split+join}
\end{figure}


\begin{proposition}\label{prop:SPLIT dicliques}
  Let  be a digraph.  Then,  is a diclique of  if and only if\/  is a diclique of\/ , where\/  and\/ .
\end{proposition}

\begin{corollary}\label{cor:SPLIT disimplicials}
  Let  be a digraph.  Then,  is a disimplicial arc of  if and only if\/  is a disimplicial arc of\/ .
\end{corollary}

So, as anticipated, we can find out whether  is transitive or not by computing the disimplicial arcs of .  Since  can be computed in linear time when  is provided as input, we conclude that finding the disimplicial arcs of an ST graph is harder than testing if a digraph is transitive.

\begin{theorem}\label{thm:transitive is disimplicial}
  A digraph  is transitive if and only if all the arcs in the matching\/  of\/  are disimplicial, where  is the reflexive closure of .  
\end{theorem}

For the rest of this section, we discuss how to find disimplicial arcs by computing transitive vertices.  The idea is to revert, as much as possible, the effects of .  For any matching  of a digraph , define  to be the digraph  that has a vertex  for each , and a vertex  for each , where  if and only if  (see Figure~\ref{fig:split+join}).  The restricted duality between the  and  operators is given in the next lemmas.

\begin{lemma}\label{lem:bip then join}
  If  is a reflexive digraph, then  is isomorphic to\/ .
\end{lemma}

\begin{proof}
  Note that  is a matching of  because  is reflexive, hence  is well defined for .  Let  be the function such that  (see Figure~\ref{fig:bip then join}).   By definition of ,  if and only if , for every .  Similarly, by the definition of ,  if and only if .  That is,  if and only if .    
\end{proof}

\begin{figure}
 \centering
 \includegraphics{split-join}
 \caption{From left to right: , , and  for .   Again, we write  and  to denote the vertices  and  of , respectively. Note that the function  of Lemma~\ref{lem:bip then join} is an isomorphism between  and .}\label{fig:bip then join}
\end{figure}


\begin{lemma}\label{lem:join then bip}
  If  is a perfect matching of an ST graph , then  is isomorphic to\/ .
\end{lemma}

\begin{proof}
  The proof is analogous to that of Lemma~\ref{lem:bip then join}.  This time, take  and  be the neighbor of  in , and observe that  is an isomorphism when  for every sink vertex  and  for every source vertex .
\end{proof}

Despite Lemma~\ref{lem:join then bip} requires an ST graph  with a perfect matching , the  operator can be applied to any digraph and any matching.  The final result is always the same, though; the disimplicial arcs of  get transformed into transitive vertices.

\begin{theorem}\label{thm:disimplicial is transitive}
  Let  be a matching of a digraph , and .  Then,  is disimplicial in  if and only if  is a transitive vertex of\/ .
\end{theorem}

\begin{proof}
  Let  and observe that .  By definition,  if and only if , for every .  Then,  for every pair  such that  and  if and only if  for every pair  such that  and .  That is,  is transitive in  if and only if  is disimplicial in .
\end{proof}

Theorem~\ref{thm:disimplicial is transitive} gives us a method for testing if an arc  is disimplicial: check if  is transitive in .  Since  can be computed in  time when  and  are given as input, we conclude that querying if an arc is disimplicial is equally hard as determining if a vertex is transitive.  We remark that testing if  is transitive and checking if  is disimplicial are both solvable in  time.

Theorem~\ref{thm:disimplicial is transitive} can also be used to find all the disimplicial arcs of  when an adequate matching is provided.  For the sake of simplicity, we restrict ourselves to ST graphs, by Proposition~\ref{prop:SPLIT dicliques}.  Moreover, we find it convenient to eliminate twin vertices.  Two vertices  of an ST graph  are \emph{twins} when , while  is \emph{twin-free} when it contains no pair of twins.  A \emph{twin block} is a maximal set of twin vertices; note that  admits a unique partition into twin blocks.  We assume the existence of a function  that, given a block , returns a vertex of , and we write  for every .  For the sake of notation, we omit the subscript  from  when no ambiguities arise.  The \emph{twin reduction} of  is the subdigraph  of  induced by .  The twin reduction of  contains all the information about the disimplicial arcs of , as in the next proposition.

\begin{proposition}\label{prop:twin reduction}
  An arc  of an ST graph  is disimplicial if and only if\/  is disimplicial in . 
\end{proposition}

We are now ready to state what an adequate matching looks like.  For each , define the \emph{thin neighbor}  of  to be the (unique) vertex  such that  for every ; if such a vertex does not exist, then  is some undefined vertex.  Say that  is a \emph{thin} arc when  and .  For the sake of notation, we write  to denote  where  is the set of thin arcs of ; note that  is well defined because  is a matching. The following easy-to-prove lemma is as fundamental for us as it is for the algorithm in~\cite{BomhoffMantheyDAM2013}.

\begin{lemma}[see e.g.~\cite{BomhoffMantheyDAM2013}]\label{lem:disimplicial is thin}
  All the disimplicial arcs of a twin-free ST graph are thin. 
\end{lemma}

The algorithm to compute the disimplicial arcs of an ST graph works in two phases.  In the first phase, all the disimplicial arcs of  are obtained by querying which of the vertices of  are transitive.  In the second phase, each  is tested to be disimplicial by querying if  is disimplicial in .   The algorithm is correct by Theorem~\ref{thm:disimplicial is transitive}, Proposition~\ref{prop:twin reduction}, and Lemma~\ref{lem:disimplicial is thin}.  

\begin{theorem}\label{thm:disimplicial algorithm}
  An arc  of a digraph  is disimplicial if and only if\/  is transitive in\/ .
\end{theorem}

Since , , and  can be computed in linear time, we conclude that listing the disimplicial arcs and finding the transitive vertices are equally hard problems. Up to these date, the best algorithms for computing the transitive vertices of  take  time and  space or  time and  space. Since , , and , we conclude that the disimplicial arcs of a digraph  can be obtained in either  time and  space or  time and  space.

\section{Disimplicial eliminations}
\label{sec:disimplicial elimination}

The present section is devoted to the problems of finding disimplicial elimination sequences.  Before doing so, we review the -digraph structure as it is required by our algorithms.

The \emph{-graph structure} was introduced in~\cite{LinSoulignacSzwarcfiterTCS2012} with dynamic algorithms in mind.  It proved to be well suited for some vertex elimination problems, particularly those in which the conditions for removing a vertex are local to its neighborhood.  The \emph{-digraph structure} is the cousin of -graphs for digraphs, and it was superficially described in~\cite{LinSoulignacSzwarcfiterTCS2012}.  Let  be a digraph and .  In short, the -digraph structure maintains  values for  and each , namely , , and , where  is an ordered list of the nonempty sets  =  with .  Recall that .    The data structure also keeps track of several pointers that allow efficient access to the different incarnations of a vertex in the structure (see~\cite{LinSoulignacSzwarcfiterTCS2012}).  At all, no more than  bits are consumed.

Table~\ref{tab:h-operations} describes the operations supported by the -digraph structure that are of interest for our purposes.  All of them, but {\tt MinN}, where described in~\cite{LinSoulignacSzwarcfiterTCS2012} for graphs, though their translation to digraphs is direct.  For the implementation of {\tt MinN}, two cases are considered to obtain the desired output .  If , then  for every , thus ; otherwise,  is equal to the first set in .  The time required for this operation is, therefore, .  

\begin{table}
  \centering
  \begin{tabular}{llcc}
    \hline
    Operation & Description & \multicolumn{2}{c}{Complexity}\\
              &             & one & all \\\hline
    {\tt Initialize}() & creates the -graph structure of  & - & \\
    {\tt Remove}() & removes  from   &  &  \\
    {\tt N'}() & returns   &  &  \\
    {\tt MinN}() & returns  &  & -\\
    {\tt d}() & returns  &  & - \\
    \hline
  \end{tabular}
  \caption{Some operations supported by the -digraph data structure.  The complexity column ``one'' indicates the time required by one invocation of the operation, while the complexity column ``all'' indicates the time required when the operation is applied  times to all the vertices in the digraph.  Here , ,  and ,  must belong to , and  is the opposite of .}\label{tab:h-operations}
\end{table}

\subsection{General disimplicial eliminations}

A sequence of arcs  is a \emph{disimplicial elimination} of a digraph  when  is disimplicial in  for every ;  is \emph{maximal} when  has no disimplicial arcs.  For convenience, we write  to denote the set of vertices of .  

The algorithm to compute a maximal disimplicial elimination works in an iterative manner from an input digraph .  At iteration , the algorithm finds a disimplicial elimination  of  by taking any maximal matching of disimplicial arcs of .  By maximal, we mean that either  or  for every disimplicial arc  of .  Then, the algorithm updates  into  for the iteration .  The algorithm stops with output  when .  

For the sake of notation, in the rest of this section we write  to denote each parameter  on  instead of using ; thus, we write  to denote ,  to denote , and so on.  When no subscript is wrote, the parameter on  should be understood; e.g., , , etc. 

The main idea of the algorithm is to compute , for , by looking only at the arcs leaving or entering .  Of all such arcs, we are interested in those with ``low degree'', which are the analogous of thin arcs for those digraphs that can contain twins (see Proposition~\ref{prop:disimplicial in L} below).   Let  and , i.e.,  and  are the set of vertices of  that have an out and in neighbor that was removed from , respectively. For each  (resp.\ ), let  be the set of out-neighbors (resp.\ in-neighbors) of  with minimum in-degree (resp.\ out-degree) in .  To compute , the algorithm first initializes  and then it traverses each vertex .  For  (resp.\ ), the algorithm evaluates whether  (resp.\ ) is disimplicial for any .  If affirmative and , then  (resp.\ ) is inserted into  for any .  (Note that  needs not be equal to ; this happens when  or  was previously inserted into  for some .) If negative or , then  is ignored.  By invariant,  is a matching of .  Moreover  contains only disimplicial arcs, as it follows from the following generalization of Lemma~\ref{lem:disimplicial is thin}.  

\begin{proposition}\label{prop:disimplicial in L}
  Let  be an endpoint of some disimplicial arc of .  Then,  (resp.\ ) is disimplicial in  if and only if .
\end{proposition}

The next proposition shows that, as required,  is indeed maximal.  That is, the algorithm to compute  is correct. 

\begin{proposition}
 If  is a disimplicial arc of , then either  or .
\end{proposition}

\begin{proof}
  Observe that  is not disimplicial in , since otherwise either  or  would have been removed in the update from  to , by the maximality of .  Hence, there exist  such that ,  and .  Since  is disimplicial in , then either  or  does not belong to .  In the former case  and , while in the latter case  and .  Both cases are analogous, so suppose .  By Proposition~\ref{prop:disimplicial in L}, , while  is disimplicial for every .  Consequently,  is ignored by the algorithm (i.e., ) only if .
\end{proof}

Each time an arc  is evaluated to be disimplicial, the algorithm works as follows.  First, the vertices in  are marked, and a variable  is initialized to .  The purpose of  is to count the number of arcs that leave a vertex in  to enter a vertex in .  To compute , each  is traversed, for every . If  is marked, then  and , thus  is increased by ; otherwise , thus  remains unchanged.  The arc  is also marked so as to avoid counting it again.  When the execution for  is done, the algorithm proceeds to traverse each , for every , increasing  by  when  is marked and  is not.  At the end, all the marks are cleared.  Clearly,  counts the number of arcs of  leaving  and entering  as each arc  with  and  is traversed at least once.  Thus  is disimplicial if and only if .

The algorithm implements  with the -digraph structure.  To compute , the vertices in  need to be traversed; recall that, by definition, .  For each traversed , a vertex  needs to be located; this costs  time if the first vertex given by \texttt{MinN} is taken. Following,  (or ) is queried to be disimplicial.  For this, the vertices in  are first marked in , and then  is computed in  time.  Moreover, note that every arc is traversed  times, thus  in actually spent to check if  is disimplicial.  When  (or ) is disimplicial, \texttt{MinN} is invoked to obtain , which is then traversed so as to locate the arc  (or ) to be inserted into .  Note that every vertex  that is traversed while looking for  belongs to  at the end of step .  Also,  will be evaluated no more than  times, once for each  such that  is considered.  Thus, all the required traversals to the sets  consume  time. Summing up, the time required to compute  is



Before the algorithm starts,  is initialized with an invocation to \texttt{Initialize} at the cost of  time.  Similarly, after each iteration,  is removed from  using the operation \texttt{Remove}.  Note that each vertex is removed exactly once, hence  time is totally consumed.   Let  be the number of iterations required by the algorithm and  be the output disimplicial elimination.  Since  can be computed in  time and  is a matching, we obtain that the total time required by the algorithm is

Since the -digraph structure uses  bits, the space complexity is linear.

\subsection{Disimplicial -eliminations}

We now consider the restricted problem of finding a maximal disimplicial -elimination of a digraph , when an input matching  is given.  A \emph{disimplicial -elimination} is just a disimplicial elimination  of  included in ;  is \emph{maximal} when no arc of  is disimplicial in .  

This time, the idea is to take advantage of the relation between disimplicial arcs and transitive vertices.  Say that a sequence  is a \emph{transitive -elimination} of a digraph , for , when  is transitive in , for every .  Suppose  and let  and .  For , define
\begin{itemize}
\item ,
\item ,
\item ,
\item , 
\item , and
\item 
\end{itemize}
By definition,  has a vertex  for each  and a vertex  for each  where  is an arc of  if and only if .  It is not hard to see, then, that .  Moreover, by Theorem~\ref{thm:disimplicial is transitive},  is transitive in  if and only if  is disimplicial in .  Hence, by induction,  is a disimplicial -elimination of  if and only if  is a transitive -elimination of  for  and .  Moreover,  is maximal if and only if  is maximal.  This discussion is summarized in the following theorem.

\begin{theorem}\label{thm:transitive elimination}
  Let  be a matching of a digraph ,  be a sequence of arcs of , , and .  Then,  is a maximal disimplicial -elimination of  if and only if  is a maximal transitive -elimination of . 
\end{theorem}

In view of Theorem~\ref{thm:transitive elimination}, we discuss how to obtain a maximal transitive -elimination of a digraph .  The algorithm works in an iterative manner from .  At each step , a transitive vertex  is removed from  so as to obtain ; if no such vertex exists, then the algorithm halts with output .  To be able to find  efficiently, the following data is maintained by the algorithm prior to the execution of iteration :
\begin{itemize}
 \item , implemented with the -digraph structure,
 \item the set of transitive vertices  of ,
 \item the number  of arcs leaving  and entering  in , for .
\end{itemize}
With the above information, any vertex of  is taken by the algorithm to play the role of . Once  is selected, the algorithm has to update its data structure for the next iteration.  The update of  into  is handled by the \texttt{Remove} operation of the -digraph structure.  The update of  into  is done in two phases.  The first phase decrements  by  for each arc  such that , while the second phase decrements  by  for each arc  such that .  The \texttt{N'} operation of the -digraph structure is employed for this step.  Finally, observe that  if and only if either  or  and .  Thus, the update of  into  takes  time.  Before the first step can take place,  is initialized with an invocation to \texttt{Initialize}.  Note that \texttt{Remove} and \texttt{N'} are called  times for each vertex of , thus  total time is consumed by the algorithm.  As for the space,  requires  space while the remaining variables consume  bits.

Since  can be computed in linear time, , and  we conclude that a maximal disimplicial -elimination can be computed in  time and linear space.

\section{Reduced dicliques}
\label{sec:WDI and DI}

By definition, a reflexive vertex  is transitive if and only if  is disimplicial. Hence, if  is an order graph, then  can be partitioned into a family of dicliques, all of which are reduced.  Moreover, by Proposition~\ref{prop:SPLIT dicliques},  is an ST graph and  can also be partitioned into a family of dicliques, all of which are reduced.  The purpose of this section is to study two graph classes that admit this kind of partition.

\subsection{Weakly diclique irreducible digraphs}

Say that a digraph is \emph{weakly diclique irreducible (WDI)} when all its arcs belong to a reduced diclique.  By Propositions \ref{prop:SPLIT dicliques}~and~\ref{prop:twin reduction},  is WDI if and only both  and  are WDI; for this reason, we consider only ST graphs with no twins for this section.  The next theorem, combined with Lemma~\ref{lem:bip then join}, shows that there is a one-to-one correspondence between the class of twin-free ST graphs that admit a perfect matching of disimplicial arcs and the class of order graphs.  A direct consequence of this theorem is that the recognition of WDI digraphs is harder than the recognition of order graphs.

\begin{theorem}
 A reflexive oriented graph  is transitive if and only if  is WDI.  Furthermore, if  is WDI, then the perfect matching  is the set of disimplicial arc of .
\end{theorem}

\begin{proof}
 If  is a reflexive oriented graph, then (i)  is a perfect matching of , and (ii)  and  are both arcs of  if only if .  Then,  belongs to a reduced diclique if and only if it is disimplicial.  Since every arc  belongs to the diclique  of , we conclude that  is WDI if and only if all the arcs of  are disimplicial.  Therefore, by Theorem~\ref{thm:transitive is disimplicial},  is WDI if and only if  is transitive.  Moreover, since  is twin-free by (ii), and the set of thin arcs is a matching containing  by Lemma~\ref{lem:disimplicial is thin}, we conclude that no arc of  is disimplicial.
\end{proof}

The following theorem shows that the recognition of WDI digraphs is simpler than the problem of listing the \emph{acyclic triangles} , ,  of a digraph.  All such triangles can be found in either  time and  space or  time and  space~\cite{ChibaNishizekiSJC1985}.  We conclude then that, unless it is proved that recognizing order graphs is strictly easier than listing triangles, the recognition of WDI digraphs is well solved. 

\begin{theorem}\label{thm:WDI characterization}
  An ST graph  with no twins is WDI if and only if:
  \begin{itemize}
   \item  is transitive, and 
   \item for every arc  of  there exists a vertex  of  such that  and  are also arcs of .   
  \end{itemize}
\end{theorem}

\begin{proof}
  Suppose  is WDI.  By definition, every vertex  of  that is neither a source nor a sink corresponds to a thin arc  of .  Since  is WDI, we know that  belongs to a diclique  for some disimplicial arc , thus  and . Moreover, taking into account that  is thin, it follows that  and , thus  and .  Therefore,  is disimplicial in  and, by Theorem~\ref{thm:disimplicial is transitive},  is transitive in ; in other words  is transitive.  Now, consider any arc  of .  By definition,  is an arc of  that belongs to some reduced diclique .  By Lemma~\ref{lem:disimplicial is thin},  is a thin arc and, since  and , it follows that  and  are arcs of .  

  For the converse, let  be any arc of  and  and  be the vertices of  that correspond to  and  (possibly ).  By definition,  is an arc of , thus, there exists a vertex  of  such that  and  are arcs of  (possibly  or ).  Since  is neither a source nor a sink of , then it follows that  is transitive in  and  is a thin arc of .  So, by Theorem~\ref{thm:disimplicial is transitive},  is a disimplicial arc of  which means that  is a reduced diclique.  Now, taking into account that  and  are arcs of , it follows that  and , i.e.,  belongs to a reduced diclique.  In other words,  is WDI.
\end{proof}

\subsection{Diclique irreducible digraphs}

In the remaining of this section we work with a subclass of WDI graphs, namely the diclique irreducible digraphs.  A digraph  is \emph{diclique irreducible (DI)} when all its maximal dicliques are reduced.  Again,  is DI if and only if both  and  are DI, thus we restrict our attention to ST graphs with no twins.  By Theorem~\ref{thm:WDI characterization}, we know that  is a transitive oriented graph; the following lemma proves that  must also be reflexive.

\begin{lemma}
 If an ST graph with no twins is DI, then its set of thin arcs is a perfect matching.
\end{lemma}

\begin{proof}
  Let  be an ST graph that is DI and has no twins,  be a source vertex of , and  be minimum among the neighbors of .  Since  is DI, it follows that  belongs to some diclique  for a disimplicial arc .  Then  which implies that  as  is twin-free.  Consequently, the thin neighbor of  is .  Moreover, as  is disimplicial, it follows that the thin neighbor of  is .  Suppose, to obtain a contradiction, that .  Then, since , we conclude that there exists .  Thus,  is a diclique that must be contained in  for some disimplicial arc .  The same arguments used before allow us to conclude that  and .  This is clearly a contradiction because  does not belong to  as it is not adjacent to . We conclude, therefore, that .  Analogously,  for every sink vertex , thus every vertex belongs to a thin arc.  That is, the set of thin arcs is a perfect matching of .
\end{proof}

\begin{corollary}
 If an ST graph with no twins is DI, then\/  is an order graph.
\end{corollary}

Recall that order graphs are the graph theoretical equivalents of finite posets.  When  is DI, the poset defined by  turns out to be what in order theory is known under the name of \emph{dedekind complete}.  We do not define what a dedekind complete poset is; in turn, we translate this concept in graph theoretic terms.

Let  be a digraph.  Say that  (resp.\ ) is an \emph{upper bound} (resp.\ a \emph{lower bound}) of  when  (resp.\ ) for every .  We write  and  to denote the sets of upper and lower bounds of , respectively.  When  (resp.\ ) is nonempty, the set  is said to be \emph{bounded from above (resp.\ below)}.  Every lower bound of  that belongs to  is a \emph{supremum} of , while every upper bound of  that belongs to  is an \emph{infimum of }.  Note that  has at most one supremum (resp.\ infimum) when  is an oriented graph.  A \emph{dedekind graph} is an order graph  such that every  that is bounded from above has a supremum.  It is well known that an order graph  is dedekind if and only if every  that is bounded from below has an infimum.

The reason why dedekind graphs come into play in the characterization of DI graphs has to do with the way  encodes the dicliques and disimplicial arcs of .  Roughly speaking, a disimplicial arc  of  is a transitive vertex  of  where  and  corresponds to the lower and upper bounds  of , respectively.  Moreover,  is both the infimum and supremum of  and , respectively.  This somehow explains why dedekind graphs appear when every diclique has a disimplicial arc.  The complete proof is given in the next theorem.  

\begin{lemma}\label{lem:dicliques in JOIN}
  Let  be a digraph,  be nonempty subsets of , , and  and .  Then,   is a diclique of  if and only if  and .  Furthermore,  is a maximal diclique exactly when  and .
\end{lemma}

\begin{proof}
  Just observe that, by definition,  for every  and  if and only if  for every  and .  That is,  is a diclique of  if and only if  and .  Moreover, using the same argument, the maximality of  occurs precisely when  and .
\end{proof}

\begin{theorem}\label{thm:DI characterization}
 Let  be an ST graph with no twins.  Then  is DI if and only if\/  is dedekind.
\end{theorem}

\begin{proof}
  Suppose  is DI, let , and consider any nonempty  bounded from above.  Let (a)  and (b) , and observe that (c) .  By definition,  and  for some  .  By Lemma~\ref{lem:dicliques in JOIN},  is a maximal diclique of , thus it contains some disimplicial arc .  By Lemma~\ref{lem:disimplicial is thin},  is a thin arc, thus  is a vertex of .  Moreover,  because  and .  Then, by (b) and (c), it follows that  is the supremum of  and the infimum of , while by (a),  is a supremum of  as well.
 
  For the converse, suppose  is a maximal diclique of  and let (a)  and (b) .  By Lemma~\ref{lem:dicliques in JOIN},  and , hence, since  is dedekind, it follows that  contains some vertex  such that (c)  and (d) .  By (a) and (c), and considering how  works, we conclude that , while  by (a) and (d).  In other words,  is a disimplicial arc of . 
\end{proof}

\begin{corollary}\label{cor:dedekind characterization}
  A digraph  is dedekind if and only if\/  is DI.
\end{corollary}

\begin{proof}
  By Lemma~\ref{lem:bip then join},  for , while, by Theorem~\ref{thm:DI characterization},  is dedekind if and only if  is DI.  
\end{proof}

By Theorem~\ref{thm:DI characterization} and Corollary~\ref{cor:dedekind characterization}, DI and dedekind graphs are equally hard to recognize, and the recognition can be done in polynomial time rather easily.  Just observe that a DI graph has at most  maximal dicliques, one for each disimplicial arc.  Then, a recognition algorithm needs to traverse at most  maximal dicliques before finding one that is not reduced.  To test if a diclique is reduced, it is enough to check that it contains a precomputed disimplicial arc.  Since the disimplicial arcs can be found in  time, and the  dicliques of can be traversed in  time~\cite{DiasFigueiredoSzwarcfiterDAM2007}, an  time algorithm is obtained.  We now describe an  time and  space algorithm that exploits the definition of dedekind graphs.  The following simple lemma is the key of the algorithm.

\begin{lemma}
  An order graph  is dedekind if and only if for every  with  there exists  such that .
\end{lemma}

\begin{proof}
  Suppose  is dedekind and let  be the supremum of , for  bounded from above.  By definition,  and , thus  because  is transitive.  Also by definition,  for every , thus .  Therefore, .

  For the converse, observe again that  for every , because  is transitive.  So, if  has degree , then , which means that  has a supremum.  That is,  has a supremum for every  bounded from above.  It is well known (taking into account that dedekind graphs correspond to dedekind complete finite posets) that, in this case,  is dedekind.
\end{proof}

The algorithm to determine if an order digraph  is dedekind traverses , for each pair of vertices , searching for a vertex  with .  For the implementation, an outer loop traverses each  and an inner loop traverses each .  Before the inner loop begins, all the vertices in  are marked in  time.  Then, in the inner loop,  is obtained in  time by filtering those vertices of  that are marked.  The degree of all the vertices in  is the evaluated in  time as well.  The total time required by the algorithm is, therefore, 
while the space complexity is  bits.  Since order graphs can be recognized in  time and  space, we conclude that the recognition DI and dedekind graphs takes  time and  space.

\section{Results on bipartite graphs and further remarks}
\label{sec:further remarks}

A \emph{bipartite graph} is a triple  where an unordered pair  belongs to  only if  and .  An edge  is \emph{bisimplicial} when every vertex in  is adjacent to all the vertices in .  By replacing each  by an arc , an ST graph  is obtained.  Moreover, an edge  of  is bisimplicial precisely when  is disimplicial in .  So, the algorithms in this article can be applied directly to bipartite graphs so as to solve the corresponding problems.  In this section we summarize the results for bipartite graphs while we provide further remarks.

In Section~\ref{sec:disimplicial vs transitive} we proved that listing the bisimplicial edges of a bipartite graph and finding the transitive vertices of a digraph are equally hard problems.  The good news is that the bisimplicial edges of a bipartite graph can be found in  time, improving over the previous  time algorithm; the bad news is that we cannot improve this algorithm further using only  space, unless an  time algorithm to find the transitive vertices of a digraph is provided.  

In Section~\ref{sec:disimplicial elimination} we describe an  time and  space algorithm to compute a maximal disimplicial elimination of .  When applied to bipartite graphs, a maximal elimination scheme  is obtained.  Since , our algorithm improves the worst-case time bound of~\cite{Bomhoff2011} for all the bipartite graphs with .  Golumbic and Goss~\cite{GolumbicGossJGT1978} proved that  is perfect whenever  admits a perfect elimination scheme, thus the algorithm can be used to recognize if a sparse graph is perfect elimination bipartite.  The concept of perfect elimination graphs can be generalized to digraphs and disimplicial eliminations.  Just say that a digraph  is \emph{perfect disimplicial elimination} whenever it admits a disimplicial elimination  such that  has no arcs.  Unfortunately, finding a maximal disimplicial elimination is not enough to determine if  is perfect, as it is shown in Figure~\ref{fig:maximal not perfect}.  So, the recognition of perfect disimplicial elimination remains open.

\begin{figure}
  \centering
  \includegraphics{perfect-counterexample}
  \caption{A perfect disimplicial elimination digraph with a non-perfect maximal disimplicial elimination:  and  are maximal disimplicial eliminations.}\label{fig:maximal not perfect}
\end{figure}

In Section~\ref{sec:disimplicial elimination} we also consider the problem of computing a maximal disimplicial -elimination, for an input matching , for which we provide an  time and  space algorithm.  Rose and Tarjan~\cite{RoseTarjanSJAM1978} proved that this problem is harder than determining if a given digraph is transitive.  Up to this date, the best algorithm to determine if a sparse graph is transitive costs  time and  space.  So, the problem is well solved, without using more than  space, unless better algorithms for recognizing transitive digraphs are found.

Recall one of the motivations for finding a maximal disimplicial elimination is to be able to perform some iterations of the Gaussian elimination process on a sparse matrix  with the guaranty that no zero entry will change into a non-zero value.  Being  sparse, we expect  and  for .  If so, then finding the disimplicial elimination and applying the corresponding iterations of the Gaussian elimination require linear time.  That is, our algorithm can be used to preprocess , say before solving the system .  In the worst case no zero fill-in entry is found and thus  remains the same.  Yet, the extra time paid for this examination is low.

In Section~\ref{sec:WDI and DI} we deal with the classes of WDI and DI digraphs.  We noted that every order graph  is uniquely associated with a twin-free ST graph  that is WDI, namely .  In fact, each  gets transformed into the disimplicial arc  of , thus  has a perfect matching of disimplicial arcs.  The converse is also true, any ST graph that has a perfect matching of disimplicial arcs must be isomorphic to  for some order graph .  We remark that the order relation  of  is somehow preserved in .  Indeed, note that  only if , thus  while .  Hence, by transitivity,  if and only if  and .  In this section we also proved that  is also DI whenever  is a dedekind graph.  Moreover, each  with supremum  is associated with a reduced biclique  such that  and .   Note that, in particular,  is the disimplicial arc of .  

\newcommand{\doi}[1]{doi: \href{http://dx.doi.org/#1}{\dodoi{#1}}}
\newcommand{\dodoi}{\begingroup \urlstyle{rm}\Url}



\begin{thebibliography}{14}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Bomhoff(2011)]{Bomhoff2011}
M.~Bomhoff.
\newblock Recognizing sparse perfect elimination bipartite graphs.
\newblock In \emph{Computer science---theory and applications}, vol. 6651 of
  \emph{Lecture Notes in Comput. Sci.}, pp. 443--455. Springer, Heidelberg,
  2011.
\newblock \doi{10.1007/978-3-642-20712-9_35}.

\bibitem[Bomhoff and Manthey(2013)]{BomhoffMantheyDAM2013}
M.~Bomhoff and B.~Manthey.
\newblock Bisimplicial edges in bipartite graphs.
\newblock \emph{Discrete Appl. Math.}, 161\penalty0 (12):\penalty0 1699--1706,
  2013.
\newblock \doi{10.1016/j.dam.2011.03.004}.

\bibitem[Chiba and Nishizeki(1985)]{ChibaNishizekiSJC1985}
N.~Chiba and T.~Nishizeki.
\newblock Arboricity and subgraph listing algorithms.
\newblock \emph{SIAM J. Comput.}, 14\penalty0 (1):\penalty0 210--223, 1985.
\newblock \doi{10.1137/0214017}.

\bibitem[Dias et~al.(2007)Dias, de~Figueiredo, and
  Szwarcfiter]{DiasFigueiredoSzwarcfiterDAM2007}
V.~M.~F. Dias, C.~M.~H. de~Figueiredo, and J.~L. Szwarcfiter.
\newblock On the generation of bicliques of a graph.
\newblock \emph{Discrete Appl. Math.}, 155\penalty0 (14):\penalty0 1826--1832,
  2007.
\newblock \doi{10.1016/j.dam.2007.03.017}.

\bibitem[Goh and Rotem(1982)]{GohRotemIPL1982}
L.~Goh and D.~Rotem.
\newblock Recognition of perfect elimination bipartite graphs.
\newblock \emph{Inform. Process. Lett.}, 15\penalty0 (4):\penalty0 179--182,
  1982.
\newblock \doi{10.1016/0020-0190(82)90101-6}.

\bibitem[Golumbic and Goss(1978)]{GolumbicGossJGT1978}
M.~C. Golumbic and C.~F. Goss.
\newblock Perfect elimination and chordal bipartite graphs.
\newblock \emph{J. Graph Theory}, 2\penalty0 (2):\penalty0 155--163, 1978.
\newblock \doi{10.1002/jgt.3190020209}.

\bibitem[Lin et~al.(2012)Lin, Soulignac, and
  Szwarcfiter]{LinSoulignacSzwarcfiterTCS2012}
M.~C. Lin, F.~J. Soulignac, and J.~L. Szwarcfiter.
\newblock Arboricity, {}-index, and dynamic algorithms.
\newblock \emph{Theoret. Comput. Sci.}, 426/427:\penalty0 75--90, 2012.
\newblock \doi{10.1016/j.tcs.2011.12.006}.

\bibitem[Nash-Williams(1964)]{Nash-WilliamsJLMS1964}
C.~S. J.~A. Nash-Williams.
\newblock Decomposition of finite graphs into forests.
\newblock \emph{J. London Math. Soc.}, 39:\penalty0 12, 1964.
\newblock \doi{10.1112/jlms/s1-39.1.12}.

\bibitem[Rose and Tarjan(1978)]{RoseTarjanSJAM1978}
D.~J. Rose and R.~E. Tarjan.
\newblock Algorithmic aspects of vertex elimination on directed graphs.
\newblock \emph{SIAM J. Appl. Math.}, 34\penalty0 (1):\penalty0 176--197, 1978.
\newblock \doi{10.1137/0134014}.

\bibitem[Spinrad(2003)]{Spinrad2003}
J.~P. Spinrad.
\newblock \emph{Efficient graph representations}, vol.~19 of \emph{Fields
  Institute Monographs}.
\newblock American Mathematical Society, Providence, RI, 2003.

\bibitem[Spinrad(2004)]{SpinradDAM2004}
J.~P. Spinrad.
\newblock Recognizing quasi-triangulated graphs.
\newblock \emph{Discrete Appl. Math.}, 138\penalty0 (1-2):\penalty0 203--213,
  2004.
\newblock \doi{10.1016/S0166-218X(03)00295-6}.

\bibitem[Wallis and Zhang(1990)]{WallisZhangJCMCC1990}
W.~D. Wallis and G.-H. Zhang.
\newblock On maximal clique irreducible graphs.
\newblock \emph{J. Combin. Math. Combin. Comput.}, 8:\penalty0 187--193, 1990.

\bibitem[Wang(2003)]{WangCN2003}
T.-M. Wang.
\newblock On characterizing weakly maximal clique irreducible graphs.
\newblock In \emph{Proceedings of the {T}hirty-{F}ourth {S}outheastern
  {I}nternational {C}onference on {C}ombinatorics, {G}raph {T}heory and
  {C}omputing}, vol. 163, pp. 177--188, 2003.

\bibitem[Williams(2012)]{Williams2012}
V.~V. Williams.
\newblock Multiplying matrices faster than {C}oppersmith-{W}inograd [extended
  abstract].
\newblock In \emph{S{TOC}'12---{P}roceedings of the 2012 {ACM} {S}ymposium on
  {T}heory of {C}omputing}, pp. 887--898. ACM, New York, 2012.
\newblock \doi{10.1145/2213977.2214056}.

\end{thebibliography}

\end{document}
