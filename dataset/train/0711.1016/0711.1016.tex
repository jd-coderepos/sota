\documentclass{entcs} 


\usepackage{entcsmacro}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[all]{xy}


\sloppy





\newtheorem{stp}{Step}
\newenvironment{step}{\vspace{-\lastskip}\par \addvspace{.6pc
    plus .2pc minus .1pc}\begin{stp}\rm}{\end{stp}\par\addvspace{.6pc
    plus .2pc minus .1pc}}



\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\cf}{\emph{cf.}}

\newcommand{\Nat}{{\mathbb N}}
\newcommand{\Natp}{{\mathbb N_{>0}}}

\newcommand{\ximp}{\;\Rightarrow\;}
\newcommand{\xand}{\;\&\;}
\newcommand{\xor}{\text{ or }}
\newcommand{\xiff}{\text{ iff }}
\newcommand{\xnot}{\text{not }}

\newcommand{\pnot}[1]{\lnot #1}
\newcommand{\pneg}[1]{\sim\!#1}
\newcommand{\pand}[2]{#1 \land #2}
\newcommand{\por}[2]{#1 \lor #2}
\newcommand{\pea}[2]{\langle#1\rangle #2}
\newcommand{\paa}[2]{[#1] #2}
\newcommand{\psp}[2]{#1;#2}
\newcommand{\pup}[2]{#1\cup#2}
\newcommand{\prp}[1]{#1*}
\newcommand{\pip}[1]{#1?}
\newcommand{\pimp}[2]{#1 \to #2}
\newcommand{\peq}[2]{#1 \leftrightarrow #2}
\newcommand{\ptrue}{\top}
\newcommand{\pfalse}{\bot}

\newcommand{\pdl}{}
\newcommand{\fml}{\mathrm{Fml}}
\newcommand{\prg}{\mathrm{Prg}}
\newcommand{\proptn}{\mathrm{AFml}}
\newcommand{\act}{\mathrm{APrg}}
\newcommand{\fea}{}
\newcommand{\fean}{}
\newcommand{\fear}{}
\newcommand{\fmlea}{\mathrm{Fml}\pea{}{}}
\newcommand{\fmlean}{\mathrm{Fml}\pea{\not\!\!a}{}}
\newcommand{\fmler}{\mathrm{Fml}\pea{\prp{}}{}}

\newcommand{\evf}[1]{\tau_{#1}}
\newcommand{\evp}[1]{\rho_{#1}}
\newcommand{\psr}[2]{#1 \Vdash #2}
\newcommand{\pnsr}[2]{#1 \nVdash #2}
\newcommand{\prel}[3]{#1 \,#2\, #3}
\newcommand{\pnnf}[1]{\mathrm{nnf}(#1)}
\newcommand{\pcl}[1]{\mathrm{cl}(#1)}
\newcommand{\ppre}[1]{\mathrm{pre}(#1)}
\newcommand{\pzz}{\mathrel{\rightsquigarrow}}

\newcommand{\tnode}[3]{(#1 :: #2 :: #3)}
\newcommand{\thc}{\mathrm{HCr}}
\newcommand{\tnext}{\mathrm{Nx}}
\newcommand{\tbdia}{\mathrm{BD}}
\newcommand{\tbbox}{\mathrm{BB}}
\newcommand{\tmrk}{\mathrm{stat}}
\newcommand{\tuev}{\mathrm{uev}}

\newcommand{\talpha}{\boldsymbol{\alpha}}
\newcommand{\tbeta}{\boldsymbol{\beta}}
\newcommand{\trid}{}
\newcommand{\trand}{}
\newcommand{\tres}{}
\newcommand{\tras}{}
\newcommand{\trau}{}
\newcommand{\trar}{}
\newcommand{\trei}{}
\newcommand{\tror}{}
\newcommand{\treu}{}
\newcommand{\trero}{}
\newcommand{\trert}{}
\newcommand{\trai}{}
\newcommand{\trea}{}

\newcommand{\ttrue}{\mathbf{unsat}}
\newcommand{\tloop}{\mathbf{barred}}
\newcommand{\tfalse}{\mathbf{open}}
\newcommand{\tmin}{\mathop{\mathrm{min}_{\bot}}}
\newcommand{\llen}{\mathop{\mathrm{len}}}
\newcommand{\tfean}{\mathop{\mathrm{tst}}}
\newcommand{\tbl}{\mathop{\mathrm{bl}}}

\newcommand{\ds}{\displaystyle\strut}
\newcommand{\ruleone}[3]{
\mbox{ {\bf #1} \ #2#3}}

\newcommand{\tm}{T_{\mathrm{p}}}
\newcommand{\tl}{T_{\mathrm{l}}}
\newcommand{\fchn}{\sigma}

\newcommand{\extst}{\pea{\prp{(\pip{q})}}{(\pand{p}{\pnot{p}})}}
\newcommand{\exasp}{\paa{\prp{a}}{p}}
\newcommand{\exaasp}{\pea{\prp{(\psp{a}{a})}}{\pnot{p}}}


\hyphenation{
}


\def\lastname{Abate and Gor\'e and Widmann}


\begin{document}

\begin{frontmatter}
  \title{An On-the-fly Tableau-based Decision Procedure for \pdl{}-Satisfiability} 
  \author[Canberra]{Pietro Abate\thanksref{myemail}},
  \author[Canberra]{Rajeev Gor\'e\thanksref{coemail}} and
  \author[Nicta]{Florian Widmann\thanksref{cocoemail}\thanksref{NICTA}} 
  \address[Canberra]{Computer Sciences Laboratory
    \\The Australian National University
    \\ Canberra, Australia}
  \address[Nicta]{Computer Sciences Laboratory
    and Logic \& Computation Programme
    \\The Australian National University and NICTA
    \\ Canberra, Australia}
  \thanks[myemail]{Email:
    \href{mailto:Pietro.Abate@pps.jussieu.fr}
    {\texttt{\normalshape Pietro.Abate@pps.jussieu.fr}}} 
  \thanks[coemail]{Email:
    \href{mailto:Rajeev.Gore@rsise.anu.edu.au }
    {\texttt{\normalshape Rajeev.Gore@rsise.anu.edu.au }}}
  \thanks[cocoemail]{Email:
    \href{mailto:Florian.Widmann@rsise.anu.edu.au} 
    {\texttt{\normalshape Florian.Widmann@rsise.anu.edu.au}}}
  \thanks[NICTA]{National ICT Australia is
    funded by the Australian Government's Dept of Communications,
    Information Technology and the Arts and the Australian Research
    Council through Backing Australia's Ability and the ICT Centre of
    Excellence program.}
  \begin{abstract} 
    We present a tableau-based algorithm 
    for deciding satisfiability for propositional dynamic logic (\pdl{})
    which builds a finite rooted tree with ancestor loops
    and passes extra information from children to parents
    to separate good loops from bad loops during backtracking.
    It is easy to implement, with potential for parallelisation,
    because it constructs a pseudo-model ``on the fly''
    by exploring each tableau branch independently. But its
    worst-case behaviour is 2EXPTIME rather than EXPTIME.
    A prototype implementation in the TWB
    (\url{http://twb.rsise.anu.edu.au})
    is available.
  \end{abstract}
  \begin{keyword}
    propositional dynamic logic, automated reasoning, tableau calculus,
    decision procedure
  \end{keyword}
\end{frontmatter}


\section{Introduction}

Propositional dynamic logic (\pdl{}) is a logic
for reasoning about programs~\cite{pratt-semantical,fischer-ladner-dynamic}.
Its formulae consist of traditional Boolean formulae
plus ``action modalities'' built from a finite set of atomic programs
using sequential composition~, non-deterministic choice~,
repetition~, and test~.
The satisfiability problem for \pdl{}
is EXPTIME-complete~\cite{pratt-near-optimal-reasoning-about-action}.
Unlike EXPTIME-complete description logics
with algorithms exhibiting good average-case behaviour,
no decision procedures for \pdl{}-satisfiability are satisfactory
from both a theoretical (soundness and completeness)
and practical (average case behaviour) viewpoint as we explain below.

The earliest decision procedures for \pdl{}
are due to Fischer and Ladner~\cite{fischer-ladner-dynamic}
and Pratt~\cite{pratt-near-optimal-reasoning-about-action}.
Fischer and Ladner's method is impractical
because it first constructs 
the set of all consistent subsets of the set of all subformulae of the given formula,
which always requires exponential time in all cases.
On the other hand, Pratt~\cite{pratt-near-optimal-reasoning-about-action}
essentially builds a multi-pass (explained shortly) tableau method.
Most subsequent decision procedures for other fix-point logics
like propositional linear temporal logic (PLTL)~\cite{wolper-expressive},
computation tree logic (CTL)~\cite{ben-ari-pnueli-manna-branching,emerson-halpern-decision}
and the modal -calculus~\cite{kozen-parikh}
trace back to Pratt~\cite{pratt-near-optimal-reasoning-about-action},
and they all share one main disadvantage as explained next.

In these multi-pass procedures,
a ``state'' is a node
which contains only diamond-like-formulae (``eventualities''),
box-like--formulae, atoms and negated atoms.
The first pass constructs a rooted tableau of nodes containing formula-sets,
but allows cross-branch arcs from a state~ on one branch
to a (previously constructed) state~ on a different branch
if applying the tableau construction to~ would duplicate~.
Thus the first pass constructs a ``pseudo-model''
which is a potentially exponential-sized cyclic graph
(rather than a cyclic tree where~ would have to be an ancestor of~).
The subsequent passes check that the ``pseudo-model'' is a real model
by pruning inconsistent nodes and pruning nodes containing ``unfulfilled eventualities''.

Although efficient model-checking techniques
can check the ``pseudo-model'' in time which is linear in its size,
these multi-pass methods can construct an exponential-sized cyclic graph needlessly.
One solution is to check for fulfilled eventualities ``on the fly'',
as the graph is built,
and although such methods exist for
model-checking~\cite{cleaveland,bhat-cleaveland-on-the-fly-model-checking},
we know of no such decision procedures for \pdl{}. 
The only implementation of a multiple-pass method for \pdl{}
that we know of is in LoTRec (\url{www.irit.fr/Lotrec})
but it is not optimal as it treats disjunctions naively.

Baader~\cite{baader-augmenting-transitive-closure}
gave a single-pass tableau-based decision procedure for a description logic
with role definitions involving union, composition and transitive closure of roles:
essentially \pdl{} without test.
His method constructs a (cyclic tree) tableau
using the semantics of the \pdl{} operators.
To separate ``good loops'' from ``bad loops'',
Baader must decide equality of regular languages,
a PSPACE-complete problem
which in practice may require exponential time.
Instead of solving these problems ``on the fly'',
they can be reduced to a simple check on the identity of states
in a deterministic minimal automaton
created from the positive regular expressions
appearing in the initial formula
during a pre-processing stage~\cite[page~27]{baader-augmenting-transitive-closure}.
But since the pre-computed automaton can be of exponential size,
this alternative may require exponential time needlessly. 
Baader's method is double-exponential in the worst-case.
The ``test'' construct is essential to express ``while'' loops
but creates a mutual recursion between the Boolean language
and the regular language.
It is not obvious to us how to extend Baader's method to ``test''.
DLP (\url{http://www.cs.bell-labs.com/cm/cs/who/pfps/dlp})
implements this method restricted to test-free formulae
where~ applies only to atomic programs.

De Giacomo and Massacci~\cite{de-giacomo-massacci-tableaux-converse-pdl}
gave an optimal \pdl{}-satisfiability test
using labelled formulae like~ to capture
that ``possible world~ makes formula~ true''.
They first give a NEXPTIME algorithm for deciding \pdl{}-satisfiability 
and then discuss ways to obtain an EXPTIME version using various known results.
But an actual EXPTIME algorithm,
and its soundness and completeness proofs,
are not given.
A deterministic implementation of their NEXPTIME algorithm by Schmidt and Tishkovsky
struck problems with nested stars,
but a solution is forthcoming~\cite{schmidt-tishkovsky-pdl-tableau}.

Other decision procedures for fix-point logics use resolution calculi,
translation methods, automata-theoretic methods, and game theoretic methods:
see~\cite{abate-gore-widmann-onepass-ctl-lpar} for references.
We know of no implementations for \pdl{} based on these methods.

Here, we give a sound, complete and terminating decision procedure for \pdl{}
with the following advantages and disadvantages:
\begin{description}
\item[\rm One-pass nature:] our method constructs a single-rooted finite tree
  (with loops from leaves to ancestors).
  As there are no cross-branch edges, 
  we can use depth-first, left-to-right search,
  reclaiming the space used for each branch via backtracking.
\item[\rm Proofs:] Full elementary proofs of soundness and completeness are available.
\item[\rm Ease of implementation:] our rules are easy to implement
  since our tableau nodes contain sets of formulae
  and some easily defined extra information
  whose manipulation requires only set intersection, set membership,
  and min/max on integers.
  But these low-level details make the rules cumbersome to describe.
\item[\rm Potential for optimisation:] there is potential
  to optimise our (tree) tableaux
  using successful techniques from (one-pass) tableaux
  for description logics~\cite{horrocks-patel-schneider-optimising-description-logic}.
\item[\rm Ease of generating counter-models:] the soundness proof immediately gives
  an effective procedure for turning an ``open'' tableau into a \pdl{}-model.
\item[\rm Ease of generating proofs:] unlike existing Gentzen calculi
  for fix-point logics~\cite{alberucci-jaeger-lck,kretz-studer-jaeger-lck-cut-free},
  our tableau calculus gives a cut-free Gentzen-style calculus
  with ``cyclic proofs'' with an optimal rather than worst-case bound
  for the finitised omega rule.
\item[\rm Potential for parallelisation:] our rules build the branches independently
  but combine their results during backtracking,
  enabling a parallel implementation.
\item[\rm Prototype:] a (sequential) prototype implementation
  in the Tableau Work Bench
  (\url{twb.rsise.anu.edu.au})
  allows to test arbitrary \pdl{} formulae over the web.
\item[\rm Complexity:] our method has worst-case double-exponential time complexity.
\item[\rm Generality:] Our method for \pdl{}
  fits into a class of similar ``one pass'' methods
  for other fix-point logics like
  PLTL~\cite{schwendimann-one-pass} and
  CTL~\cite{abate-gore-widmann-onepass-ctl-lpar}. 
  Further experimental work is required to determine
  if our methods can be optimised to exhibit good average-case behaviour
  using techniques like sound global caching~\cite{gore-nguyen-exptime-alc}.
\end{description}


\section{Syntax, Semantics and Hintikka Structures}

\begin{definition}
  Let~ and~ be two disjoint and countably infinite sets of propositional atoms
  and \emph{atomic programs}, respectively.
  The set~ of all formulae and the set~ of all \emph{programs}
  are defined inductively as follows:
  \begin{enumerate}
  \item  and~
  \item if~ then~
    and~ and~ and~
  \item if~ and~ then~ and~
  \item if~ and  then~ and~ and~.
  \end{enumerate}
  Let~ range over members of~
  and~ range over members of~.
  A \fea{}-formula is any formula~,
  a \fean{}-formula is a \fea{}-formula 
   with~,
  and a \fear{}-formula is any formula~.
   is the set of all \fea{}-formulae,
   is the set of all \fean{}-formula,
  and~ is the set of all \fear{}-formulae.
\end{definition}

\begin{definition}
  A \emph{transition frame} is a pair~
  where~ is a non-empty set of worlds and~ a function
  that maps each atomic program~ to a binary relation~ over~.
  A \emph{model}~ is a transition frame~
  and a valuation function~
  mapping each atomic proposition~ to
  a set~ of worlds.
\end{definition}

\begin{definition}
  Let~ be a model.
  The functions~ and~
  are defined inductively as follows:
  
  For~ and~, we write
  .
\end{definition}

\begin{definition}
  Formula~ is \emph{satisfiable}
  iff there is a model~ and a~
  such that~.
  Formula~ is \emph{valid} iff~ is not satisfiable.
\end{definition}

\begin{definition}
  Formula~ is in \emph{negation normal form}
  if~ appears only immediately before propositional atoms.
  For every~,
  we obtain a formula~ in negation normal form
  by pushing negations inward repeatedly
  (\eg{} using de Morgan's laws)
  so~ is valid.
  We define~.
\end{definition}

\begin{table}[t]
  \caption{Smullyan's - and -notation to classify formulae}
  \label{tab_alphabeta}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|}
      \hline
       
      &  
      &  
      &  
      &  
      &  
      &  
      \\ \hline
       
      &  
      &  
      &  
      &  
      &  
      &  
      \\ \hline
      
      & 
      & 
      & 
      & 
      & 
      & 
      \\ \hline
      \end{tabular}
      \begin{tabular}{|c|c|c|c|c|}
      \hline
       
      &  
      &  
      &  
      &  
      \\ \hline
       
      &  
      &  
      &  
      &  
      \\ \hline
      
      & 
      & 
      & 
      & 
      \\ \hline
    \end{tabular}
  \end{center}
\end{table}
We use Smullyan's /-notation to categorise formulae
via Table~\ref{tab_alphabeta}
and use bolding to differentiate it from the use of~ and~ as members of~.
So if~~(respectively ) is any formula pattern in the first row
then~ and~ (respectively~ and~)
are its corresponding patterns in the second and third row.
\begin{proposition}
  \label{prop_axioms}
  All formulae~
  and~ in
  Table~\ref{tab_alphabeta} are valid.
\end{proposition}

\begin{definition}
  A \emph{structure}~ for~
  is a transition frame~
  and a labelling function~ which associates with each world~
  a set~ of formulae and has~ for some world~.
\end{definition}

\begin{definition}
  For a given~
  the (infinite) set~ is defined as:
  
  For all formulae~ and~,
  the binary relation~ on formulae is defined as:
   iff (exactly) one of the following conditions is true:
  \begin{itemize}
  \item 
  \item 
  \item 
  \item 
  \end{itemize}
\end{definition}
Intuitively, using Table~\ref{tab_alphabeta},
the~``'' relates a \fean{}-formulae~ (respectively~),
to~ (respectively~ and~)
while~ captures
that~ can be ``reduced'' to~,
which can be reduced to~.
Note that~.

\begin{definition}
  Let~ be a structure,  a formula,  a program, and~ a state.
  A \emph{fulfilling chain for~ in~}
  is a finite sequence~ of world-formula pairs with~ such that:
  \begin{itemize}
  \item , , and~ for all~
  \item , , , and~ for all~
  \item for all~,
    if~ for some~ and~
    then~ and~;
    otherwise~ and~.
  \end{itemize}
\end{definition}
Each~ is in~,
the chain starts at~, ends at~,
and no other~ is paired with~.
Formulae~ are~-related 
and corresponding worlds~ are equal
unless~,
in which case~ and~.
Thus eventuality~ is fulfilled by~
and~ is -reachable from~.

\begin{definition}
  A \emph{pre-Hintikka structure}~ for~
  is a structure for~
  that satisfies~H1-H5 (below) for every~
  where~ and~ are formulae as defined in Table~\ref{tab_alphabeta}.
  A \emph{Hintikka structure}~ for~
  is a pre-Hintikka structure for~
  that additionally satisfies~H6 below:
  
\end{definition}
H3 ``locally unwinds'' the fix-point semantics of~,
but does not guarantee a \emph{least} fix-point which 
requires~ be true eventually.
H6 ``globally''
ensures all \fear{}-formulae are fulfilled.
H2 captures the \emph{greatest} fix-point 
semantics of~.

\begin{theorem}
  \label{theo_satisfiable}
  A formula~ in negation normal form is satisfiable
  iff there exists a Hintikka structure for~.
\end{theorem}


\section{An Overview of the Algorithm}
\label{sec_overview}

To track unfulfilled eventualities and to avoid ``at a world'' cycles,
our algorithm stores additional information in each tableau node
using \emph{histories} and
\emph{variables}~\cite{schwendimann-one-pass}.
Histories are passed from parents to children and
variables from children to parents.

Our algorithm starts at a root
containing a given formula~
and some default history values.
It builds a tree by repeatedly applying -/-rules
to decompose formulae via the semantics of \pdl{}.
The -rule for~ has a left child
that fulfils this eventuality by reducing it to~,
and a right child
that procrastinates fulfilment by ``reducing'' it to~.
The rules modify the histories and variables as appropriate
for their intended purpose.

But naive application of the -/-rules to
formulae like~
with nested stars can lead to ``at a world'' cycles: e.g.\
.
A solution is to use the histories to reduce one particular~-formula
until~ becomes atomic by forcing the rules to concentrate on
this task, and 
to block previously reduced diamonds and boxes
if they lead to ``at a world'' cycles.
The application of /-rules stops
when all non-blocked leaves contain only atoms, negated atoms,
and all \fea{}-formulae and all -formulae
begin with outermost atomic programs only.

For each such leaf node~, and for each -formula in~,
the \trea{}-rule creates a successor node containing~,
where~.
These successors are then saturated to produce new leaves
using the - and -rules,
and the \trea{}-rule creates the successors of these new leaves, and so on.

If left unchecked, this procedure can produce infinite branches
since the same successors can be created again and again on the same branch.
To obtain termination,
the \trea{}-rule creates a successor containing~ for 
only if 
this successor has not already been created previously higher up on the current branch.

So if the successor~ exists already,
the current branch is ``blocked'' from re-creating it.
The resulting loop may be ``bad'' since every -node
on this branch for an eventuality~ may procrastinate,
so~ is never fulfilled.
To track this potentially unfulfilled eventuality,
we assign the height of the blocking node to the pair~ 
via a variable~ as long as~ is a decomposition of~.

During backtracking, our rules ``merge'' the~ entries of the children
and also modify the resulting~
to reverse-track the decomposition of~.
In particular, a~ entry becomes undefined at a node
if the eventuality it tracks can be fulfilled in the sub-tableau rooted at this node.
Conversely, if a node at height~ receives a~ entry with value at least~
then the eventuality tracked by this~ entry definitely cannot be fulfilled,
so the parent of this (blocking) node is then unsatisfiable.

Whether or not the initial formula~ is satisfiable
is determined by the status of the root node.
Due to technicalities caused by ``at a world'' cycles,
the status can be one of the values ``unsatisfiable'', ``open'' or ``barred'' (to be explained later).
The initial formula~ is \pdl{}-satisfiable iff the status of the root node is ``open''.


\section{A One-pass Tableau Algorithm for \pdl{}}

\begin{definition}
  A \emph{tableau node}~ is of the form  where:
   is a set of formulae;
   is a list of pairs~ where~ is a set of formulae and~;
   is either~ or a formula designated to be the principal formula of the rule applied to~;
   is the set of ``\underline{B}locked \underline{D}iamonds'';
   is the set of ``\underline{B}locked \underline{B}oxes'';
   has one of the values~, , or~; and
   is a partial function from 
  to~ (the positive natural numbers).
\end{definition}

\begin{definition}
  A \emph{tableau} for a formula set~ and histories~, , , and~
  is a tree of tableau nodes with root 
  where the children of a node~ are obtained by a single application of a rule to~
  (\ie{} only one rule can be applied to a node)
  but where the parent can inherit some information from the children.
  A tableau is \emph{expanded} if no rules can be applied to any of its leaves.
  On any branch of a tableau, a node~ is an \emph{ancestor} of a node~
  iff~ lies above~ on the unique path from the root down to~.
\end{definition}

The list~ is a history for detecting ancestor-loops and guarantees termination. 
The choice of principal formula is free if , but is pre-determined as the
formula in~ otherwise.
When a diamond formula in the parent is decomposed
to give a formula~ in the current node,
we set the~-value of the child to  to  ensure that~ is decomposed next.
Together with the histories~ and~,
this allows us to block~-formulae and~-formulae
from creating ``at a world'' cycles.
The variables~ and~ have their values
determined by the children of a node.
Formally,  at node~
if~ is definitely unsatisfiable.
Informally,  if all descendants of node~ are unsatisfiable
or lead to an ``at a world'' cycle.
Finally,  indicates that the node is potentially satisfiable,
but as it may be on a loop,
this is something which we can determine only later as we backtrack towards the root. 

\begin{definition}
  The partial function~ is the constant function
  that is undefined for all pairs of formulae: \ie{}~.
  The partial functions~ and~ are defined as:
  
\end{definition}
The function~ returns~
when the formula being tested is not a \fea{}-formula,
or is a \fea{}-formula but its program is atomic.
The function~ tracks
\underline{u}nfulfilled \underline{ev}entualities,
so~ flags that all eventualities are fulfilled,
and~ defined flags a potentially unfulfilled eventuality.
If a node has~ or~
then its~ is irrelevant so it is arbitrarily set to~.


\subsection{The Rules}

We use~ and~ for sets of formulae
and write~ for the
partition~ of formulae in a node.
To save space, we often omit histories/variables which are passed
unchanged from parents/children to children/parents.
Most rules are applicable only if some side-conditions hold,
and most involve actions that change histories downwards or variables upwards.

\paragraph{Terminal Rules.}

\begin{center}
  \ruleone{(\trid{})}
  {\tnode{\Gamma}{\dotsb}{\tmrk, \tuev}}{}
  
\end{center}
Action for~(\trid{}):  and~.
\begin{center}
  \ruleone{(\trert{})}
  {\tnode{\pea{\prp{\alpha}}{\varphi} , \; \Gamma}{\tnext, \tbdia}{\tmrk, \tuev}}{}
  
\end{center}
Action for~(\trert{}):  and~.

An \trid{}-node is clearly unsatisfiable.
The principal formula of the \trert{}-rule is unfulfillable
because it causes an ``at a world'' cycle,
so this rule terminates the current branch. Note both rules may be
applicable to a node.

\paragraph{Linear () Rules.}

\begin{tabular}[c]{l@{\extracolsep{1.5cm}}l}
  \ruleone{(\trand{})}
  {\tnode{\pand{\varphi}{\psi} , \; \Gamma}{\tnext}{\tuev}}
  {\tnode{\varphi , \; \psi , \; \Gamma}{\tnext}{\tuev_1}}
  &
  \ruleone{(\trau{})}
  {\tnode{\paa{\pup{\alpha}{\beta}}{\varphi} , \; \Gamma}{\tnext}{\tuev}}
  {\tnode{\paa{\alpha}{\varphi} , \; \paa{\beta}{\varphi} , \; \Gamma}{\tnext}{\tuev_1}}
  \1em]
\end{tabular}
\begin{flushleft}
  Common Side Condition: .
  
  Common Action:
  
  if  
  else .
  
  Extra Action for~(\trar{}):
  \begin{array}[t]{l}
    \Gamma_1 := \Gamma
    \text{ if } \paa{\prp{\alpha}}{\varphi} \in \tbbox
    \text{ else } \Gamma_1 := \{\varphi\} \cup \{\paa{\alpha}{\paa{\prp{\alpha}}{\varphi}}\} \cup \Gamma,\\
    \tbbox_1 := \big\{ \paa{\prp{\alpha}}{\varphi} \big\} \cup \tbbox.
  \end{array}
\end{flushleft}

Most rules are standard but for the histories
since they just capture the transformations in Table~\ref{tab_alphabeta}.
The \trar{}-rule just deletes~ 
if~ since this indicates
that it has already been expanded once ``at this world''.
Otherwise it captures the fix-point nature of~ via Prop.~\ref{prop_axioms}
and then puts~ into~.

The next two rules have individual side-conditions and actions as shown.
\begin{center}
  \ruleone{(\tres{})}
  {\tnode{\pea{\psp{\alpha}{\beta}}{\varphi} , \; \Gamma}{\tnext, \tbdia}{\tuev}}
  {\tnode{\pea{\alpha}{\pea{\beta}{\varphi}} , \; \Gamma}{\tnext_1, \tbdia_1}{\tuev_1}}
  
\end{center}
\begin{flushleft}
  Actions for~(\tres{}): \ \\
  \begin{tabular}[c]{lr}
    \begin{minipage}[l]{0.28\linewidth}
      
    \end{minipage}
    &
    \begin{minipage}[l]{0.72\linewidth}
      
    \end{minipage}
  \end{tabular}
\end{flushleft}

\begin{center}
  \ruleone{(\trei{})}
  {\tnode{\pea{\pip{\psi}}{\varphi} , \; \Gamma}{\tnext, \tbdia_1}{\tuev}}
  {\tnode{\psi , \; \varphi , \; \Gamma}{\tnext_1, \tbdia_1}{\tuev_1}}
  
  \
        \tnext_1 & := & \tfean(\varphi)
        \\ \\
        \tbdia_1 & := & \tbl\big( \varphi, \tbdia \big)
      
        \tuev(\chi_1, \chi_2) & := &
        \left\{
          \begin{array}{ll}
            \tuev_1(\varphi, \chi_2) & \text{ if } \chi_1 = \pea{\pip{\psi}}{\varphi}\\
            \tuev_1(\chi_1, \chi_2) & \text{ if } \chi_1 \in \Gamma\\
            \bot & \text{ otherwise}
          \end{array}
        \right .
      1em]
  \ruleone{(\trai{})}
  {\tnode{\paa{\pip{\psi}}{\varphi} , \; \Gamma}{\tnext}{\tmrk, \tuev}}
  {\tnode{\pneg{\psi} , \; \Gamma}{\tnext}{\tmrk_1, \tuev_1}
    \mid
    \tnode{\varphi , \; \Gamma}{\tnext}{\tmrk_2, \tuev_2}}
  
  \
        \tnext_i & := & \tfean\big( \pea{\alpha_i}{\varphi} \big)
        \\ \\
        \tbdia_i & := & \tbl\big( \pea{\alpha_i}{\varphi}, \tbdia \big)
      
        \tuev_i'(\chi_1, \chi_2) & := &
        \left\{
          \begin{array}{ll}
            \tuev_i(\pea{\alpha_i}{\varphi}, \chi_2) & \text{ if } \chi_1 = \pea{\pup{\alpha_1}{\alpha_2}}{\varphi}\\
            \tuev_i(\chi_1, \chi_2) & \text{ if } \chi_1 \in \Gamma\\
            \bot & \text{ otherwise}
          \end{array}
        \right . \\
      
        \tnext_1 & := & \tfean(\varphi)
        \\ \\
        \tbdia_1 & := & \tbl\big( \varphi, \{ \pea{\prp{\alpha}}{\varphi} \} \cup \tbdia \big)
      
        \tuev_1'(\chi_1, \chi_2) & := &
        \left\{
          \begin{array}{ll}
            \bot & \text{ if } \chi_1 = \chi_2 = \pea{\prp{\alpha}}{\varphi}\\
            \tuev_1(\varphi, \chi_2) & \text{ if } \chi_1 = \pea{\prp{\alpha}}{\varphi} \not= \chi_2\\
            \tuev_1(\chi_1, \chi_2) & \text{ if } \chi_1 \in \Gamma\\
            \bot & \text{ otherwise}
          \end{array}
        \right . \\
      
        \tnext_2 & := & \tfean\big( \pea{\alpha}{\pea{\prp{\alpha}}{\varphi}} \big)
        \
    \end{minipage}
    &
    \begin{minipage}[c]{0.74\linewidth}
      
    \end{minipage}
  \end{tabular}
\end{flushleft}

The \trero{}-rule captures the fix-point nature of the \fear{}-formulae
according to Prop.~\ref{prop_axioms}
as long as the principal formula is not blocked via~.
The choice of the principal formulae in the first child is either free
if~ is not a \fean{}-formula
or is~ if~ is a \fean{}-formula.
In the latter case we also block the regeneration of~
and thus avoid an ``at a world'' cycle by putting~ into~.
The right child is treated similarly
but uses~ instead of~.
\begin{flushleft}
  Actions for all -rules: 
  
\end{flushleft}

The intuitions are:
\begin{description}
\item[\rm :] the definitions of~ ensure
  that the pairs~, where~ is the principal \fea{}-formula,
  get the values from their corresponding \fea{}-formulae in the children.
  In the \trero{}-rule, a special case sets
  the value of~ to~
  if~ and~ are equal
  to the principal formula~ of this rule
  since the eventuality~
  is no longer unfulfilled as the left child fulfils it.
  Note that~ is only defined
  if~ is in the parent.
\item[\rm :] the definition of~ ensures
  that we take the minimum of~ and~
  only when both functions are defined for~.
\item[\rm :] if~,
  the~ is irrelevant,
  so we arbitrarily set it as undefined.
  If only one child has~, we take its~.
  If both children have~,
  we take the minimum value of entries
  that are defined in~ and~.
\end{description}

All previous rules modify existing -entries, but never
create new ones.
The next rule is the only rule that creates -entries (by identifying loops).

\paragraph{Existential Branching Rule.}

\begin{center}
  \ruleone{(\trea{})}
  {\begin{array}{l}
      \pea{a_1}{\varphi_1} , \dotsc, \pea{a_n}{\varphi_n} , \;
      \pea{a_{n+1}}{\varphi_{n+1}} , \dotsc, \pea{a_{n+m}}{\varphi_{n+m}} , \;
      \paa{-}{\Delta} , \; \Gamma\\
      :: \thc, \tnext, \tbdia, \tbbox :: \tmrk, \tuev
    \end{array}}
  {\begin{array}{l}
      \varphi_1 , \; \Delta_1 :: \thc_1, \tnext_1, \tbdia_1, \tbbox_1 \\
      :: \tmrk_1, \tuev_1
    \end{array}
    \mid \dotsm \mid
    \begin{array}{l}
      \varphi_n , \; \Delta_n :: \thc_n, \tnext_n, \tbdia_n, \tbbox_n \\
      :: \tmrk_n, \tuev_n
    \end{array}}
\end{center}
\noindent where:
\renewcommand{\theenumi}{(\arabic{enumi})}
\renewcommand{\labelenumi}{\theenumi}
\begin{enumerate}
\item\label{enum_one} 
\item\label{enum_two} 
\item\label{enum_thr} 
\item\label{enum_fou}  for 
\item\label{enum_fiv} 
\item\label{enum_six}
  
\item\label{enum_sev}
  
\end{enumerate}
Actions for~(\trea):
\begin{array}[t]{rl}
  \text{for } i = 1, \dotsc, n:\;
  &
  \thc_i := \thc \;@\; \big[ \big( \varphi_i, \{ \varphi_i \} \cup \Delta_i \big) \big],\\
  &
  \tnext_i := \tfean(\varphi_i), \quad
  \tbdia_i := \emptyset, \quad
  \tbbox_i := \emptyset
\end{array}
1em]
  \tuev_k(\cdot, \cdot) & := & j \in \{1, \dotsc, \llen(\thc)\}
  \text{ such that } \big( \varphi_k, \{ \varphi_k \} \cup \Delta_k \big) = \thc[j] \\
  & & \text{for } k = n+1, \dotsc ,n+m
  \

Some intuitions are in order:
\begin{description}
\item[\rm \ref{enum_one}]
  If~, the application of the rule generates no new nodes
  and~ vacuously evaluates to~.
  If~, we additionally have~.
\item[\rm \ref{enum_two}] The set~ contains only propositional atoms or their negations.
\item[\rm \ref{enum_thr}] The set~ contains only formulae of the type~.
  Thus~\ref{enum_two} and~\ref{enum_thr} imply
  that the \trea{}-rule is applicable only
  if the node contains no - or -formulae.
\item[\rm \ref{enum_fou}] The set~ contains all formulae
  that must belong to the ~child, which fulfils~,
  so that we can build a Hintikka structure later on.
\item[\rm \ref{enum_fiv}] The node must not contain a contradiction.
\item[\rm \ref{enum_six}] If~,
  then each~ for~ is not ``blocked'' by an ancestor
  and has a child containing the formula set~
  thereby generating the required successor for~.
  Note that~ denotes the length of~.
\item[\rm \ref{enum_sev}] If~,
  then each~ for~ is ``blocked''
  from creating its required child~
  because some ancestor does the job.
  This ancestor must not only consist of the formulae~
  but it must also have been created to fulfil~ for some~.
  Note that the values~ and~ are ignored
  when looking for loops
  since we are interested only in the contents of the required child.
\item[\rm :] is the~ of the parent
  extended with an extra entry to record the ``history''
  of worlds created on the path from the root down to the ~child
  using ``@'' as list concatenation.
  Note that we store a \emph{pair}~, not just~.
  That is, we remember that the node~ was created
  to fulfil~ for some~.
\item[\rm :] the parent is unsatisfiable
  if some child has~.
  But it is also unsatisfiable if some child, say the~,
  and some eventuality~ in it ``loops lower''
  because~
  and~ is defined and greater than the length of the current~.
  Intuitively, the latter tells us
  that the eventuality~
  occurs in the sub-tableau rooted at the parent
  but cannot be fulfilled.
\item[\rm :] for~, the ~child is blocked
  by a higher (proxy) child.
  For every such~
  we set~ to be the \emph{constant} function
  which maps every formula-pair to the \emph{level}~ of its proxy child.
  This is just a temporary function
  used to define~ as explained next.
  The blocking child itself must have been created
  to fulfil a \fea{}-formula~,
  as indicated by the first component of~.
\item[\rm :]
  If~ then~ is undefined everywhere.
  Else,
  for each~ with~,
  and each~ with~,
  we take~
  from the formulae-pair~ of the corresponding (real) child
  if~ is ``unblocked'',
  or set it to the level of the proxy child higher in the branch
  if it is ``blocked''.
  For all other formulae-pairs,  is undefined.
  The intuition is that a defined~ flags
  a ``loop'' which starts at the parent
  and eventually ``loops'' up to some blocking proxy.
  The value of~ tells us the level of the proxy
  because we cannot classify this ``loop'' as ``good'' or ``bad''
  until we backtrack to that level.
  The~ of each~ is taken from \emph{the} child
  created specifically to contain~,
  a fact which is vital in the proofs.
\item[\rm :]
  each child has no blocked diamond- or box-formulae,
  and its principal formula is determined by the form of .
\end{description}

The \trea{}- and \trid{}-rules are mutually exclusive via their
side-conditions.  Our rules are designed so that at least one rule is
applicable to any node. As shown in the next section, we need to build
only one fully expanded tableau, hence if multiple rules are
applicable to a node, the choice of rule is immaterial.
Of course, in our implementation, we give priority to the \trid{}-rule
since it may close a branch sooner. Other heuristics, like preferring
linear rules over branching rules, are also useful.

\subsection{Termination, Soundness, and Completeness}

\begin{definition}
  Let~ be a tableau node,
   a formula, and~ a set of formulae.
  We write~  to mean~ .
  The parts of~
  are written as~, , , , , and~.
  Node~ is \emph{closed} iff~,
  \emph{open} iff~, and \emph{barred} iff~.
\end{definition}

\begin{definition}
  Let~ be a \trea{}-node in a tableau~
  (i.e.\ a \trea{}-rule was applied to~).
  Then~ is also called a \emph{state} and
  the children of~ are called \emph{core-nodes}.
  Using the notation of the \trea{}-rule,
  a formula~ is \emph{blocked} iff~.
  For every not blocked~,
  the \emph{successor} of~ is the ~child of the \trea{}-rule.
  For every blocked~
  there exists a unique core-node~ on the path from the root of~ to~
  such that~ is the set of formulae of~,
  and~ is the successor of a formula~
  in the parent of~.
  We call~ the \emph{virtual successor} of~,
  and also call the formula~ in the (possibly virtual) successor of~
  a \emph{core-formula}.
\end{definition}
A state is another term for a \trea{}-node
but a core-node can be any type of node
(even a state).
A state arises from a core-node
by - and -rules.
Note that the core-formula in a core-node~ is well-defined and unique:
if~ and~ are states
and~ is the (possibly virtual) successor of~ and~,
then~.

Let~ be a formula in negation normal form,
and~ an expanded tableau with root~
with~ and~ determined by 's children.
\begin{theorem}
  \label{thm_term}
   is a finite tree.
\end{theorem}
\begin{theorem}
  \label{theo_correctness}
  If the root~ is open, there is a Hintikka structure for~.
\end{theorem}
\begin{theorem}
  \label{theo_completeness}
  If the root~ is not open then~ is not satisfiable.
\end{theorem}
\begin{theorem}
  \label{theo_complexity}
  If~, our procedure has worst-case time complexity in~.
\end{theorem}
The length of a branch in a tableau is bounded, essentially
by the number of core-nodes on that branch.
The number of core-nodes itself is bounded, essentially
by the cardinality of the power set of the set~ of all formula
that can appear in the tableau.
The size of~ is polynomial in~,
hence the length of a branch is in~.
Thus the overall (worst case) number of nodes in a tableau is in~.


\subsection{Fully Worked Examples}

The first simple example illustrates
how the procedure avoids infinite loops due to ``at a world'' cycles
by blocking - and -formulae from regenerating.
The formula~ is obviously not satisfiable.
Hence, any expanded tableau with root~ should not be open.
Figure~\ref{fig_ex2} shows such a tableau
where each node is classified as a -node
if rule~ is applied to that node in the tableau.

The initial formula~ in node~(1) 
is decomposed into a -child~
and a -child~
according to the \trero{}-rule.
The formula~ in node~(2) is then decomposed
according to the \trand{}-rule and node~(3) is marked as closed
because it contains a contradiction.
Node~(2) inherits the status from node~(3) unchanged 
according to the -rules
and, thus, is closed too.

Because the -formula~ is a \fean{}-formula,
the \trero{}-rule puts this formula into its~,
the~-value of node~(4),
and thus forces node~(4) to have~ as its principal formula.
For the same reason, 
the \trero{}-rule puts its own principal formula~
into its~, the -value of node~(4).
Hence node~(4) decomposes~ according to the \trei{}-rule.
Again, the resulting node~(5) is forced to have~ as its principal formula
via its -value, and gets its~-value unchanged from node~(4).

Node~(5) has the same principal formula as node~(1),
so applying the \trero{}-rule to node~(5) would cause
the procedure to enter an ``at a world'' (infinite) cycle.
Because the history~ of node~(5) contains~,
the \trero{}-rule is blocked on node~(5),
but the \trert{}-rule is not.
Hence the branch is terminated and the status of node~(5) is set to 
(thereby avoiding the ``at a world'' cycle).

Node~(4) inherits the status from node~(5) unchanged
and node~(1) is marked  also
according to the definition of~ in the -rules.
Therefore the tableau is not open.
Note that the variable~ does not play a role in this example
as it is irrelevant for nodes that are closed or barred.
\begin{figure}
  \begin{center}
    
  \end{center}
  \caption[]{A first example: a closed tableau for~}
  \label{fig_ex2}
\end{figure}


The second example demonstrates the role of~.
The formula~ is valid.
Hence, its negation~,
which is already in negation normal form, is unsatisfiable
and the root of any expanded tableau for~ should not be open.
Figure~\ref{fig_ex1} shows such a tableau.
The unlabelled edges in Fig.~\ref{fig_ex1} link states to core-nodes.
We omit the histories~ and~ 
as they do not play an important role in this example.
Each partial function~ maps the formula-pair~
in Table~\ref{tab_uev} to~1
and is undefined otherwise as explained below.
The histories are~
where  and 
and~ where  and .
\begin{table}[t]
  \caption{Definitions for the example in Fig.~\ref{fig_ex1}}
  \label{tab_uev}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|}
      \hline
       &  &  &  &  
      \\ \hline
       
      &  
      &  
      &  
      &  
      \\ \hline
      
      &  &  &  & 
      \\ \hline
    \end{tabular}
  \end{center}
\end{table}

The dotted frame at~(7a) indicates
that its child, an \trid{}-node,
is not shown due to space restrictions.
Thus the marking of the nodes~(3a) and~(7a) in Fig.~\ref{fig_ex1} with~ is straightforward.
The leaf~(9) is a \trea{}-node,
but it is ``blocked'' from creating its successor containing~
because there is a~
such that : namely~.
Thus the \trea{}-rule computes  as stated above
and also puts .
As node~(7a) is closed,
nodes~(8), (7b), (7), (6), and~(5)
inherit their functions~ from their open children
via the corresponding - and -rules.

The crux of our method occurs at node~(4),
a \trea{}-node with  and hence~.
The \trea{}-rule thus finds a child node~(5)
and a pair of formulae~
where~ is a core-formula, ,
and .
Thus node~(4) ``sees'' a child~(5) that ``loops lower'',
meaning that node~(5) is the root of an ``isolated'' subtree
which fails to fulfil its eventuality~.
The \trea{}-rule marks~(4) as closed via~.
The propagation of  to the root is simple.

What if the omitted child of~(7a), and hence~(7a) itself, had been open?
Then~ in~(7) would be undefined everywhere via the
\trero{}-rule, regardless of~.
Thus~ in~(7) would be fulfilled via the -child~(7a).
Hence~ would be undefined everywhere,
and node~(4) would not be closed.
\begin{figure}
  \begin{center}
    
  \end{center}
  \caption[]{A second example: a closed tableau for~}
  \label{fig_ex1}
\end{figure}

\section{Conclusion and Further Work}

We have given a sound, complete and terminating procedure
for checking \pdl{}-satisfiability.
Unfortunately, its worst-case time-complexity is in 2EXPTIME rather than in EXPTIME,
thus our procedure is sub-optimal.
We now outline some further practical and theoretical work
which may eliminate this disadvantage.

First, we believe that a small refinement of our histories will allow
our calculus to classify a loop as ``bad'' or ``good'' at the looping leaf,
as is done by Baader's procedure~\cite{baader-augmenting-transitive-closure},
but with no pre-computation of automata.
Thus it should be possible to extend DLP to handle our method.
Further experimental work is required to determine
if such an extension will remain practical.

Second, recent work has shown that global caching
can indeed deliver optimality of tableau procedures
soundly~\cite{gore-nguyen-exptime-alc}.
The histories used in our calculus make it harder to extend sound global caching to it
since nodes are now sensitive to their context in the tree under construction.
Further theoretical work is required
to extend sound global caching to handle such context sensitivity.


\begin{thebibliography}{10}

\bibitem{abate-gore-widmann-onepass-ctl-lpar}
  Abate, P., R.~Gor{\'e}, and F.~Widmann.
  \newblock One-pass tableaux for computation tree logic.
  \newblock In N.~Dershowitz and A.~Voronkov, editors, {\em Proc.\
    LPAR 2007},  LNCS~4790:32-46, Springer, 2007.

\bibitem{alberucci-jaeger-lck}
Alberucci~L., and G.~J{\"a}ger.
  \newblock About cut elimination for logics of common knowledge.
  \newblock {\em Annal of Pure and Applied Logic}, 133(1-3):73--99, 2005.

\bibitem{baader-augmenting-transitive-closure}
  Baader, F.
  \newblock Augmenting concept languages by transitive closure of roles: an
  alternative to terminological cycles.
  \newblock Technical Report RR-90-13, DFKI, Kaiserslautern, Germany, 1990.

\bibitem{ben-ari-pnueli-manna-branching}
  Ben-Ari, M., Z.~Manna, and A.~Pnueli.
  \newblock The temporal logic of branching time.
  \newblock In {\em Proc.\ Eighth ACM Symposium on Principles of Programming
    Languages}, pages~164--176, 1981.

\bibitem{bhat-cleaveland-on-the-fly-model-checking}
  Bhat, G., and R.~Cleaveland.
  \newblock Efficient on-the-fly model checking for {CTL}.
  \newblock In {\em Proc. Symposium on Logics in Computer Science},
  pages~388--397, 1995.

\bibitem{cleaveland}
  Cleaveland, R.
  \newblock Tableau-based model checking in the propositional mu-calculus.
  \newblock {\em Acta Informatica}, 27:725--747, 1990.

\bibitem{emerson-halpern-decision}
  Emerson, E.~A., and J.~Y.~Halpern.
  \newblock Decision procedures and expressiveness in the temporal logic of
  branching time.
  \newblock {\em Journal of Computer and System Science}, 30:1--24, 1985.

\bibitem{fischer-ladner-dynamic}
  Fischer, M.~J., and R.~E. Ladner.
  \newblock Propositional dynamic logic of regular programs.
  \newblock {\em Journal of Computer Systems and Science}, 18:194-211, 1979.

\bibitem{de-giacomo-massacci-tableaux-converse-pdl}
  Giacomo, G.~D., and F.~Massacci.
  \newblock Combining deduction and model checking into tableaux and algorithms
  for Converse-PDL.
  \newblock {\em Information and Computation }, 160:109--169, 2000.

\bibitem{gore-nguyen-exptime-alc}
  Gor{\'e}, R., and L.~A. Nguyen.
  \newblock Exptime tableaux for {ALC} using sound global caching.
  \newblock In {\em DL'07: Proc. International Workshop on Description
    Logics, 2007}, 8 pages.

\bibitem{horrocks-patel-schneider-optimising-description-logic}
  Horrocks, I., and P.~F.~Patel-Schneider.
  \newblock Optimising description logic subsumption.
  \newblock {\em Journal of Logic and Computation}, 9(3):267--293, OUP, 1999.

\bibitem{kretz-studer-jaeger-lck-cut-free}
  J{\"a}ger, G., M.~Kretz, and T.~Studer.
  \newblock Cut-free common knowledge.
  \newblock {\em Journal of Applied Logic}, to appear.

\bibitem{kozen-parikh}
  Kozen, D., and R.~Parikh.
  \newblock An elementary proof of the completeness of {PDL}.
  \newblock {\em Theoretical Computer Science}, 14:113--118, 1981.

\bibitem{pratt-semantical}
  Pratt, V.
  \newblock Semantical considerations on {Floyd-Hoare} logic.
  \newblock In {\em Proc.\ 17th IEEE Symposium on Foundations Of Computer Science}, pages 109--121, 1976.

\bibitem{pratt-near-optimal-reasoning-about-action}
  Pratt, V.
  \newblock A near-optimal method for reasoning about action.
  \newblock {\em Journal of Computer Systems and Science}, 20:231--254, 1980.

\bibitem{schmidt-tishkovsky-pdl-tableau}
  Schmidt, R., and D.~Tishkovsky. Personal communication, September 2007.
  \newblock \url{http://www.cs.man.ac.uk/~schmidt/pdl-tableau}

\bibitem{schwendimann-one-pass}
  Schwendimann, S.
  \newblock A new one-pass tableau calculus for {PLTL}.
  \newblock In H.~de~Swart, editor, {\em Proc. TABLEAUX'98}, LNAI~1397:277-291. Springer, 1998.

\bibitem{wolper-expressive}
  Wolper, P.
  \newblock Temporal logic can be more expressive.
  \newblock {\em Information and Computation}, 56:72--99, 1983.

\end{thebibliography}


\newpage


\section*{Appendix: Termination, Soundness and Completeness}

\begin{definition}
  Let~ be a directed graph
  (\eg{} a tableau
  where~ is just the child-of relation between nodes).
  A \emph{path}~ in~
  is a finite or infinite sequence~ of nodes in~
  such that~ for all~
  except the last node if~ is finite.
\end{definition}

\paragraph{\bf Termination}

\noindent{}\textbf{Theorem~\ref{thm_term}\ }
\emph{ is a finite tree.}
\begin{proof*}{Proof Sketch}
  It is obvious that~ is a tree
  and that every node in~ can contain only formulae
  from the negation normal form analogue~
  of the Fisher-Ladner closure~\cite{fischer-ladner-dynamic}.
  The definition of~ has been omitted to save space,
  but~ is finite.
  Hence there are only a finite number of different sets
  that can be assigned to nodes,
  in particular core-nodes,
  and the number of pairs~
  with~ is finite.
  As each core-node is assigned such a pair
  and the \trea{}-rule ensures
  core-nodes on a branch possess different pairs,
  the number of core-nodes on a branch is finite.

  It is not obvious
  that the number of nodes between consecutive core-nodes on a branch is finite
  since -
  and -formulae like~
  can ``regenerate'' on a branch without passing a core-node
  (\eg{}~).
  However, it is relatively easy to see
  that formulae of the form~ or~
  are the only potential ``troublemakers'' between two states.
  For formulae of the form~
  regeneration between two core-nodes is clearly ruled out
  by the history~ and the \trar{}-rule.
  For formulae of the form~,
  the job is done by the history~ and the \trero{} and \trert{}-rules.
  In the latter case, it is crucial
  that the procedure chooses the decomposition of a principal \fean{}-formula
  as the principal formula of the child,
  provided that the decomposition is also a \fean{}-formula.

  As the number of nodes between two core-nodes is finite,
  and there are only finitely many core-nodes on any branch,
  all branches in~ are finite.
  Every node has finite degree
  so K\"onig's lemma completes the proof.
\end{proof*}

\paragraph{\bf Soundness}

\noindent{}\textbf{Theorem~\ref{theo_correctness}\ }
\emph{If the root~ is open, there is a Hintikka structure for~.}
\begin{proof}
  By construction,  is a finite tree.
  Let~ (``p'' for pruned)
  be the subgraph that consists of all nodes~ having the following property:
  there is a path of open nodes from~ to~ inclusive.
  The edges of~ are exactly the edges of~ that connect two nodes in~.
  Clearly,  is also a finite tree with root~.
  Intuitively,  is the result of pruning all subtrees of~ that have a closed or barred root.

  Next, we extend~ to a finite cyclic tree~ (``l'' for looping)
  by doing the following for every state~:
  for every formula~ having a \emph{virtual} successor~,
  which must lie on the path from~ to~,
  we add the edge~ to~.
  Theses new edges are called \emph{backward edges}.
  Note that as \trid{}-nodes are closed by construction of~,
  all leaves of~ must be states where all \fea{}-formulae (if any) are blocked.
  Hence every formula~ of every leaf has a virtual successor.

  Finally, following Ben-Ari et al.~\cite{ben-ari-pnueli-manna-branching},
  the cyclic tree~ is used to generate a structure~
  as described next.
  Let~ be the set of all states of~.
  For every~ and every~,
  let~ iff~ contains a formula~
  and there exists a path  in~
  such that~ is the (possibly virtual) successor of~
  and each~ is an - or a -node.
  Thus state~ is a ``saturation'' of~ using only - and -rules.
  Note that~ and~ is possible for~,
  because two formulae~ and~ might have the same virtual successor:
  see point~\ref{enum_sev} of the \trea{}-rule.
  It is also possible that~ and~ for~.

  If we consider the root~ of~ as a core-node for a moment,
  it is not hard to see that for every state~
  there exists a unique core-node~
  and a unique path~ of the form  in~
  such that either~ (and thus~)
  or~ and each~ is not a state.
  We set~ to be the union of all formulae of all nodes on~.
  Intuitively, we form~ by adding back all the principal formulae
  of the - and -rules
  which were applied to obtain~ from~.

  It is almost straightforward to check that~ is a pre-Hintikka structure for~.
  There are only two things that deserve extra comments:
  Firstly, it is not possible
  that~ contains a \trert{}-node as it would be barred.
  Secondly, assume that~ is a \trar{}-node with principal formula~
  and~ is a state such that~ lies on the path~ to~
  that defines the set~, which contains~, as described above.
  Then either~ and~ are contained in the child of~ in~,
  or -- as the first node~ on~ is a core-node with~ --
  there exists another \trar{}-node on~
  that also has~ as principal formula 
  and its child in~ contains~ and~.
  As the child of an -node that lies on~ must lie on~ too,
  in both cases, there is a node on~ containing~ and~.
  Thus~ and~ are also contained in~.

  To show that~ is even a Hintikka structure
  we use Lemma~\ref{lem_ex_fulfilling} to conclude~ as is shown next.

  Suppose~.
  If we also have~
  then~ is a fulfilling chain for~
  and we are done.
  Otherwise,
  the finiteness of the tableau
  and the fact that~ is a pre-Hintikka structure
  give us a sequence~
  such that:
  \begin{itemize}
  \item  and~ for all~
  \item  and  for some~ and~
  \item  for all~.
  \end{itemize}
  Applying Lemma~\ref{lem_ex_fulfilling} for the state~ and the formula~
  gives us a sequence~
  with the properties stated in Lemma~\ref{lem_ex_fulfilling}.
  Let~ be an arbitrary path in~ such that~ is a state.
  Next, we replace each~ in~ with the first state~
  that appears on the path .

  It is easy to check that the combined sequence~
  is a fulfilling chain for~ in~
  if we contract all consecutive repetitions of pairs.
  This concludes the proof.
\end{proof}

\begin{lemma}
  \label{lem_ex_fulfilling}
  Let~ be a node and~ a formula such that~.
  There exists a finite sequence~ of pairs with~ such that:
  \begin{itemize}
  \item  is a path in~
  \item , , and~ for all~
  \item , , , and~ for all~
  \item for all~, either  or:
    if~ for some~ and~
    then~ is a state else~.
  \end{itemize}
\end{lemma}
\begin{proof}
  We inductively construct~ starting with~.
  Most of the required properties of~ follow directly from its construction
  and we leave it to the reader to check that they hold.
  \begin{step}
    \label{step_one}
    Let~ be the last pair of~.
    We distinguish three cases: either~ is an - or -node
    and~ is not the principal formula in~;
    or~ is an - or -node
    and~ is the principal formula in~;
    or~ is a state.

    If~ is an - or -node
    and~ is not the principal formula in~,
    we set~ and we choose~ to be a successor of~ in~
    such that .
    Note that such a~ always exists
    since the value of~
    is determined by one of its open children during the construction of~ and hence~.
    But it does not have to be unique.
    We then repeat Step~\ref{step_one}.

    If~ is an - or -node
    and~ is the principal formula in~,
    we look at all pairs~
    such that~ is a child of~ in~
    and~ is decomposed into~
    and~ holds.
    By construction of~ and hence~ there is at least one open child
    such that the corresponding pair~
    obeys~.
    Let~ be such a pair.
    If~ we stop and return~;
    otherwise we repeat Step~\ref{step_one}.

    If~ is a state,
    it is not too hard to see that~ must be of the form~
    for some~ and~.
    We set~
    where~ is the (possibly virtual) successor of~
    and repeat Step~\ref{step_one}.
    Note that if~ is a non-virtual successor of~,
    we have~
    by construction of~ and hence~.
    Also note that if~ is a virtual successor of~
    then~ is the core-formula of~ by construction of~ and hence~.
  \end{step}
  The only way for Step~\ref{step_one} to terminate is
  by finding~.
  It is not difficult to see that
  the resulting (finite) sequence~ fulfils all requirements and the proof is completed.
  Hence the rest of the proof shows that~ as constructed by Step~\ref{step_one} is finite.
  Step~\ref{step_one} maintains the following invariant:
  \begin{description}
  \item[] For all appropriate~
    we have~
    unless~ is the \emph{virtual} successor of~.
  \end{description}
  In other words, the values of~
  and~ can differ only if~ is a backward edge in~.
  We distinguish two cases: either~ is undefined or it is defined.
  In both cases we show that the path~
  can only have a finite number of backward edges.
  As every infinite path in~ must use an infinite number of backward edges
  since~ and~ are finite trees,
  this proves that Step~\ref{step_one} terminates.

  \noindent{}\textbf{Case~1.} If~ is undefined,
  the path~ cannot contain a backward edge as shown next.
  Assume for a contradiction that~ with~ is the first node
  such that~ is a backward edge.
  Since the initial  was undefined,
  by~ we know that~ is undefined.
  But~ is a state and as~,
  which must be of the form~ for some~ and~,
  has a virtual successor~,
   is defined
  to be the height of~ by the application of the \trea{}-rule to~
  during the construction of the tableau.
  Thus~ is both defined and undefined,
  which is a contradiction.

  \noindent{}\textbf{Case~2.} If~ is defined,
  the path~ can only contain a finite number of backward edges as shown next.
  Let~ with~ be the first node
  such that~ is a backward edge.
  If no such node exists, we are obviously done.
  Otherwise, we have~ by~.
  This means by construction of the tableau
  that there exists a set~ such that~.
  Thus~ is the  core-node (child of a \trea{}-node)
  on the path from the root~ to~ in~
  and we have~ by construction of~.

  If~ had a value equal to or greater than~
  then the \trea{}-rule would cause the parent of~ in~
  to be marked as closed
  since~ is the core-formula of~;
  but we know this is not the case.
  Hence~ is either undefined or
  has a value~ that is strictly smaller than~.

  If~ is undefined,
  we can prove exactly as in Case~1 that the path~ cannot contain a backward edge.
  On the other hand,
  if~ is defined,
  we can inductively repeat the arguments in Case~2
  for the sequence .
  The induction is well-defined because of~,
  meaning that eventually this inductive argument must terminate
  because all such -values must be in~.
\end{proof}

\paragraph{\bf Completeness}

\begin{definition}
  \label{def_chain}
  Let~ be a model,  a state
  and~ a formula of the form~
  for some~ and  and~.
  A \emph{witness chain for~}
  is a finite sequence~
  of world-formula pairs with~ such that:
  \begin{enumerate}
  \item , , and~ for all~
  \item , , ,
    and~ for all~
  \item 
  \item for all~,
    if~ for some~ and~
    then~ and~;
    otherwise~ and~.
  \end{enumerate}
\end{definition}
\begin{prop}
  \label{prop_lastelem}
  In the setting of Def.~\ref{def_chain}, we have:
  \begin{enumerate}
  \item for every~ there exists an~
    such that~
    is a witness chain for~
  \item if~ for some~ then~.
  \end{enumerate}
\end{prop}
\begin{proposition}
  \label{prop_chain}
  Let~ be a model,  a state
  and~ a formula of the form~
  for some~ and  and~.
  If~ then there exists a witness chain for~.
\end{proposition}

From now on,
let~ denote the set of formulae of a node~.
We say that a finite set of formulae~ is satisfiable
iff~ is satisfiable.
\begin{lemma}
  \label{lemma_focus}
  Let~ with~ and principal formula~
  of the form~
  for some~ and  and~.
  Let~ be a model and~ a world such that~ satisfies~.
  Furthermore let~ be a witness chain for~.
  Then there exists a finite path~ in~
  with the following properties:
  \renewcommand{\theenumi}{(\roman{enumi})}
  \renewcommand{\labelenumi}{\theenumi}
  \begin{enumerate}
  \item , , , and the only state (if any) is~
  \item , , and~ satisfies~ for all~
  \item  is the principal formula of~ for all~
  \item  or~ for some~ and~.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We inductively construct~ starting with~,
  such that the following invariant holds:
  \begin{description}
  \item[]  and for all~:
     and~ satisfies~ and~ is the principal formula of~.
  \end{description}
  Note that~ holds for the initial path~.
  Also note that if~ fulfils~
  then no node on~ can be a state and
  and  for all~.
  \begin{step}
    \label{step_two}
    Let~ be the last node of~.
    It cannot be an \trid{}-node because it is satisfiable,
    nor a \trert{}-node for the following reason:
    Assume that~ were a \trert{}-node.
    Then~ due to the \trert{}-rule
    and there must be an ancestor node~ of~ in~
    which inserted~ into the~ of its child
    such that~ is contained in the~ of all nodes
    between~ (exclusive) and~ (inclusive).
    As~ by assumption,
    the node~ must lie on~,
    \ie{}~ for some~.
    Due to the tableau rules and the fact that~ inserted~, 
    the node~ must be a \trero{}-node with principal formula~;
    but that -- together with~ --
    entails~
    which is not possible because~ is a witness chain.
    Hence~ is a not a \trert{}-node.

    Let~ be the child of~
    where~ is decomposed into~.
    Such a child must exist because we have~ and~
    due to the definition of the witness chain~ and the fact that~.
    The same reasoning also gives us~ and~.
    Moreover, the set~ is satisfied by~ by~
    and~ by construction of the tableau~.
    Hence the set~ is satisfied by~.

    Now we distinguish whether or not~ is a \fean{}-formula.

    If~ is a \fean{}-formula,
    it must be the principal formula of~
    due to the tableau rules and the fact that we have~.
    Moreover, we have~ because~ and~.
    Thus our invariant~ for~ extended by~ still holds
    and we repeat Step~\ref{step_two}.

    If~ is not a \fean{}-formula,
    we have~
    due to the tableau rules and the fact that~.
    Furthermore, we have~ or~ for some~ and~
    because~ is a witness chain.
    Thus~ extended by~ fulfils all the required properties of the lemma
    which concludes the proof in this case.
  \end{step}
  As~ is finite,
  Step~\ref{step_two} must terminate after a finite number of repetitions
  which means that we have found a path~ that proves this lemma.
\end{proof}

\begin{lemma}
  \label{lemma_findstate}
  Let~ with~
  and~ be a model and~ a world
  such that~ satisfies~.
  Then there exists a finite path~ in~
  with the following properties:
  ,  is the only state on~, and~ satisfies~ for all~.
\end{lemma}
\begin{proof}
  We inductively construct~ starting with~
  such that the following invariant holds:
  \begin{description}
  \item[]  satisfies~ for every node~ on~
    and the last node~ of~ has~.
  \end{description}
  Note that the initial~ fulfils the invariant by assumption.
  \begin{step}
    \label{step_three}
    Let~ be the last node of~.
    If~ is a state, we stop and return~.
    Otherwise, we distinguish two cases:
    either the principal formula of~ is not a \fea{}-formula
    or it is a \fea{}-formula.

    If the principal formula of~ is not a \fea{}-formula,
    we choose~ to be a successor of~ in~
    such that~ satisfies~.
    The existence of~ is guaranteed by Prop.~\ref{prop_axioms},
    the fact that~ satisfies~ by~,
    and the fact that~ cannot be an \trid{}-node because~ is satisfiable
    nor a \trert{}-node because~'s principal formula is not a \fea{}-formula.
    As~'s principal formula is not a \fea{}-formula and~ by~, 
    we also have~ by a simple inspection of the tableau rules.
    We then repeat Step~\ref{step_three}.
    
    If the principal formula~ of~ is a \fea{}-formula,
    it is also a \fean{}-formula because~ is not a state.
    Hence it must be of the form~
    for some~ and~ and~.
    As~ satisfies~ by~ and~,
    we have~.
    Thus Prop.~\ref{prop_chain} gives us a sequence~ 
    with the properties stated in Prop.~\ref{prop_chain}.

    Next we apply Lemma~\ref{lemma_focus} to~
    and obtain a path~ with the properties of Lemma~\ref{lemma_focus}.
    Finally,
    the new~ is obtained from the old~ by appending~
    -- minus the first node~
    which is already the last node of~ -- to the old~.
    As  satisfies~ for all~ on~
    and the last node~ on~ has~,
    the new~ fulfils~.
    We then repeat Step~\ref{step_three}.
  \end{step}
  As~ is finite, it is easy to see that Step~\ref{step_three} terminates,
  meaning that the last node~ of the finite path~ is the only state on~.
\end{proof}

\begin{lemma}
  \label{lemma_marked}
  For every closed node~ in~,
  the set~ is not satisfiable.
  In particular, if~ is closed then~ is not satisfiable.
\end{lemma}
\begin{proof}
  We use well-founded induction on the (strict) descendant relation of~.
  As~ is a finite tree, the descendant relation is clearly well-founded.
  Thus we can use the following induction hypothesis for every node~:
  \begin{description}
  \item[IH:] for every descendant~ of~,
    if~ is closed then the set~ is not satisfiable.
  \end{description}

  If a leaf~ is closed,
  it must be an \trid{}-node
  as a state with no children is always open.
  Hence, our theorem follows from the fact
  that~ for some~.
  Note that this can be seen as the base case of the induction
  as leaves do not have descendants.

  If~ is a closed -node
  then its child must be closed as well
  so we can apply the induction hypothesis
  and the claim follows from the fact
  that -- in the sense of Table~\ref{tab_alphabeta} --
  the formulae of the form~ are valid
  (Prop.~\ref{prop_axioms}).

  If~ is a closed -node
  then both children are closed as well
  so we can apply the induction hypothesis
  and the claim follows from the fact
  that -- in the sense of Table~\ref{tab_alphabeta} --
  the formulae of the form~ are valid
  (Prop.~\ref{prop_axioms}).
  Note that~ cannot be a \trert{}-node as it would not be closed in this case.

  If~ is a closed \trea{}-node
  (\ie{} a closed state)
  then it has at least one child and there are three possibilities
  for why it was marked as closed by the \trea{}-rule:
  \renewcommand{\theenumi}{(\arabic{enumi})}
  \renewcommand{\labelenumi}{\theenumi}
  \begin{enumerate}
  \item Some child~ of~ is closed.
  \item Some child~ of~ is barred.
  \item Some open child~ of~ with core-formula~
    has 
    for some~ and~ with~.
  \end{enumerate}

  \noindent{}\textbf{Case~1.}
  In the first case,
  it is not too hard to see
  that the satisfiability of~ implies the satisfiability of~
  since the \trea{}-rule preserves satisfiability from parent to child.
  By the induction hypothesis,
  we know that~ is not satisfiable,
  therefore~ cannot be satisfiable either.

  \noindent{}\textbf{Case~2.}
  In the second case,
  we assume that~ is satisfiable and derive a contradiction.
  We can then prove the claim as in the first case.

  So, for a contradiction,
  let~ be a model and~ a world
  such that~ satisfies~.
  As~ by the \trea{}-rule,
  we can apply Lemma~\ref{lemma_findstate}
  which gives us a path~ in~ with the properties stated in Lemma~\ref{lemma_findstate}.
  Let~ be the last node of~, hence~ is a state.
  It is a descendant of~,
  therefore the induction hypothesis applies to it.
  By Lemma~\ref{lemma_findstate},  satisfies~,
  hence~ cannot be closed;
  but this means that~ must be open 
  as states can only be closed or open by the \trea{}-rule.
  It is now easy to see that all nodes on~ must also be open 
  due to the construction of the variable~ in the - and -rules.
  But this is a contradiction to the assumption
  that~, which is the first node on~, is barred.

  \noindent{}\textbf{Case~3.}
  In the third case,
  we assume that~ is satisfiable and derive a contradiction.
  We can then prove the claim as in the first case.

  So, for a contradiction,
  let~ be a model and~ a world
  such that~ satisfies~.
  In particular, we have~ by assumption since~.
  As~,
  it is of the form~
  for some~.
  Furthermore,
  let~ be of the form~
  for some~ and~.
  Note that~ is possible:
  in this case we already have~.

  Applying Prop.~\ref{prop_chain} to~ and~
  with~
  gives us a witness chain~ for~.
  According to Prop~\ref{prop_lastelem},
  there exists an~ with~
  and~.
  Our plan is to ``walk down'' the tableau~ -- starting from~ --
  in a way that is ``consistent'' with~
  which will lead to a contradiction when we ``reach''~.

  As~ by the \trea{}-rule,
  we can apply Lemma~\ref{lemma_focus}
  which gives as a path~ in~
  with the properties stated in Lemma~\ref{lemma_focus}.
  We can then apply Lemma~\ref{lemma_findstate} to~
  which gives us a path~ with the properties stated in Lemma~\ref{lemma_findstate}.
  Let~ be the last node of~, hence~ is a state.
  It is a descendant of~,
  therefore the induction hypothesis applies to it.
  Thus~ cannot be closed because~ satisfies~ by Lemma~\ref{lemma_findstate};
  but this means that~ must be open 
  as states can only be closed or open by the \trea{}-rule.
  If we join~ and~ to obtain~,
  it is now easy to see that all nodes on~ must also be open 
  due to the construction of the variable~ in the - and -rules.

  By assumption we have~.
  As all nodes on~ are open
  and~ is the principal formula of~ for all~,
  we also have~ for all~
  by definition of the - and -rules.
  We now distinguish whether or not~.

  If~ then we have 
  as~;
  but as~ is the principal formula of~,
  this is only possible if the first child of~,
  which is~ as~ by definition of~, is not open
  according to the construction of~ in the \trero{}-rule.
  This, however, is a contradiction to the fact that all nodes on~,
  in particular~, are open.

  If~, we must have~ for some~ and~
  as~ is clearly not possible.
  Furthermore, we have~
  by definition of the - and -rules.
  As~ is the first node on~ 
  and all nodes on~ are open,
  we also have~ for all nodes~ on~
  by definition of the - and -rules.
  In particular, we have~.
  Let~ be the (possibly virtual) successor of~,
  that contains~.
  Then~ is clearly 
  a witness chain for~
  which is strictly shorter than~
  and still contains~ and~.
  Note that~ as~.
  Additionally, we make the following two claims:
  \begin{enumerate}
  \item  
    and~ is a descendant of~
    (\ie{} the induction hypothesis holds in the subtree rooted at~).
  \item  satisfies~.
  \end{enumerate}
  Before we prove the two claims, we show their consequences:
  Basically, the two claims and the properties of~ allow us
  to inductively repeat the proof
  for~, , , and~ instead of~, , , and~, respectively.
  As~ is strictly shorter than~,
  this is possible only a finite number of times.
  Hence we must eventually end up in the case ``'' of the proof
  that yields a contradiction.
  Therefore the only thing left is to show that the two claims hold.

  \noindent{}\textbf{Claim~1.}
  We distinguish whether~ is a virtual successor of~ or not.
  
  If~ is not virtual,
  that is it is a child of~ in~,
  it is obviously a descendant of~
  as every node -- in particular~ -- on~ is a descendant of~.
  Furthermore,
  it follows directly from~ and~
  and the definition of the \trea{}-rule
  that~.

  If~ is a virtual successor,
  a glance at the definition of~ in the \trea{}-rule reveals
  that~ must lie on the path from~ to~ (it could be~)
  as we have  and .
  Thus~ is a descendant of~
  and has~
  as we have already established this on our way from~ down to~.
  
  \noindent{}\textbf{Claim~2.}
  By definition of the \trea{}-rule,
   is of the form~ where~.
  We know~ because of the properties of~.
  We also know that~ in particular satisfies~
  since we have established that~
  is satisfied by~ and~.
  As~ is a successor world of~ (\ie{}~),
  this implies that~ satisfies~,
  and hence~.
\end{proof}

\noindent{}\textbf{Theorem~\ref{theo_completeness}\ }
\emph{If the root~ is not open then~ is not satisfiable.}
\begin{proof}
  If~ is closed, the claim follows directly from Lemma~\ref{lemma_marked}.
  If~ is barred, 
  we assume that~ is satisfiable and derive a contradiction.

  So, for a contradiction,
  let~ be a model and~ a world
  such that~ satisfies~.
  As~ by construction of~,
  we can apply Lemma~\ref{lemma_findstate}
  which gives us a path~ with the properties stated in Lemma~\ref{lemma_findstate}.
  Let~ be the last node of~, hence~ is a state.
  It cannot be closed because of Lemma~\ref{lemma_marked}
  and the fact that~ satisfies~;
  but this means that~ must be open 
  as states can only be closed or open by construction.
  It is easy to see that all nodes on~ must also be open 
  due to the construction of the variable~ in the - and -rules.
  But this is a contradiction to the assumption
  that~, which is the first node on~, is barred.
\end{proof}

\end{document}
