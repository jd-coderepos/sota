\documentclass{fundam}

\usepackage{makeidx} \usepackage{setspace}


\usepackage{epsfig,wrapfig}
\usepackage{amssymb,amsmath,latexsym}
\usepackage{subfigure,mathabx,graphicx}
\usepackage{url}

\input xy \xyoption{all}

\newcommand{\abb}[3]{#1 \colon #2 \rightarrow #3}
\newcommand{\Rule}[1]{\stackrel{#1}{\Longrightarrow}}
\newcommand{\LRule}[1]{\stackrel{#1}{\Longleftarrow}}
\newcommand{\grule}[5]{#1 \overset{#4}{\longleftarrow} #2
  \overset{#5}{\longrightarrow} #3}

\newcommand{\figeps}[3]{ \begin{figure}[h!tb]
    \def\epsfsize##1##2{#2##1}\centerline{\epsfbox{figures/#1.eps}}
    \caption{#3}
    \label{fig:#1}
  \end{figure}
}

\long\def\omitthis#1{\relax}

\newtheorem{defi}{Definition} \newcommand{\Nat}{{\mathbb N}}
\newcommand{\Real}{{\mathbb R}}
\newcommand{\proofend}{\hfill}

\onehalfspacing

\begin{document}
\setcounter{page}{1}
\issue{XXI~(2010)}


\title{Matrix Graph Grammars: Transformation of Restrictions}

\author{Pedro Pablo P\'erez Velasco\\
School of Computer Science \\
Universidad Aut\'onoma de Madrid\\    	
Ciudad Universitaria de Cantoblanco, 28049 - Madrid, Spain\\
pedro.perez{@}uam.es}

\maketitle

\runninghead{P.~P.~P\'erez}{Matrix Graph Grammars}

\begin{abstract}
  In the Matrix approach to graph transformation we represent
  \emph{simple} digraphs and rules with Boolean matrices and vectors,
  and the rewriting is expressed using Boolean operations only. In
  previous works, we developed analysis techniques enabling the study
  of the applicability of rule sequences, their independence, stated
  reachability and the minimal digraph able to fire a
  sequence. See~\cite{MGGBook} for a comprehensive
  introduction. In~\cite{MGGfundamenta}, graph constraints and
  application conditions (so-called \emph{restrictions}) have been
  studied in detail. In the present contribution we tackle the problem
  of translating post-conditions into pre-conditions and vice
  versa. Moreover, we shall see that application conditions can be
  moved along productions inside a sequence (\emph{restriction
    delocalization}). As a practical-theoretical application we show
  how application conditions allow us to perform multidigraph
  rewriting (as opposed to simple digraph rewriting) using Matrix
  Graph Grammars.
\end{abstract}

\textbf{Keywords:} Matrix Graph Grammars, Graph Dynamics, Graph
Transformation, Restrictions, Application Conditions, Preconditions,
Postconditions, Graph Constraints.

\section{Introduction}
\label{sec:intro}


Graph transformation~\cite{graGraBook,handbook} is becoming
increasingly popular in order to describe system behavior due to its
graphical, declarative and formal nature. For example, it has been
used to describe the operational semantics of Domain Specific Visual
Languages (DSVLs,~\cite{JVLC}), taking the advantage that it is
possible to use the concrete syntax of the DSVL in the rules which
then become more intuitive to the designer.

The main formalization of graph transformation is the so-called
algebraic approach~\cite{graGraBook}, which uses category theory in
order to express the rewriting step. Prominent examples of this approach
are the double~\cite{DPO:handbook,graGraBook} and
single~\cite{SPO:handbook} pushout (DPO and SPO) which have developed
interesting analysis techniques, for example to check sequential and
parallel independence between pairs of
rules~\cite{graGraBook,handbook} or the calculation of critical
pairs~\cite{Heckel,Lambers}.

Frequently, graph transformation rules are equipped with {\em
  application conditions} (ACs)~\cite{AC:Ehrig,graGraBook,HeckelW95},
stating extra (in addition to the left hand side) positive and
negative conditions that the host graph should satisfy for the rule to
be applicable.  The algebraic approach has proposed a kind of ACs with
predefined diagrams (i.e. graphs and morphisms making the condition)
and quantifiers regarding the existence or not of matchings of the
different graphs of the constraint in the host
graph~\cite{AC:Ehrig,graGraBook}. Most analysis techniques for plain
rules (without ACs) have to be adapted then for rules with ACs (see
e.g.~\cite{Lambers} for critical pairs with negative ACs). Moreover,
different adaptations may be needed for different kinds of ACs. Thus,
a uniform approach to analyze rules with arbitrary ACs would be very
useful.

In previous works~\cite{JuanPP_1,JuanPP_2,JuanPP_4,MGGBook} we
developed a framework (Matrix Graph Grammars, MGGs) for the
transformation of simple digraphs. Simple digraphs and their
transformation rules can be represented using Boolean matrices and
vectors. Thus, the rewriting can be expressed using Boolean operators
only. One important point is that, as a difference from other
approaches, we explicitly represent the rule dynamics (addition and
deletion of elements) instead of only the static parts (rule pre and
postconditions). This point of view enables new analysis techniques,
such as for example checking independence of a sequence of arbitrary
length and a permutation of it, or to obtain the smallest graph able
to fire a sequence. On the theoretical side, our formalization of
graph transformation introduces concepts from many branches of
mathematics like Boolean algebra, group theory, functional analysis,
tensor algebra and logics~\cite{MGGBook, MGGCombinatorics, MGGmodel}.
This wealth of available mathematical results opens the door to new
analysis methods not developed so far, like sequential independence
and explicit parallelism not limited to pairs of sequences,
applicability, graph congruence and reachability. On the practical
side, the implementations of our analysis techniques, being based on
Boolean algebra manipulations, are expected to have a good
performance.

In MGGs we do not only consider the elements that must be present in
order to apply a production (left hand side, LHS, also known as
\emph{certainty part}) but also those elements that potentially
prevent its application (also known as \emph{nihil} or
\emph{nihilation part}). Refer to~\cite{MGGfundamenta} in which,
besides this, application conditions and graph constraints are studied
for the MGG approach. The present contribution is a continuation
of~\cite{MGGfundamenta} where a comparison with related work can also be
found. We shall tackle pre and postconditions, their transformation,
the sequential version of these results and multidigraph rewriting.

\noindent {\bf Paper organization}. Section~\ref{sec:MGGs} gives an
overview of Matrix Graph Grammars. Section~\ref{sec:previous} revises
application conditions as studied
in~\cite{MGGfundamenta}. Postconditions and their equivalence to
certain sequences are addressed in
Sec.~\ref{sec:postconditions}. Section~\ref{sec:movingConditions}
tackles the transformation of preconditions into postconditions. The
converse, more natural from a practical point of view, is also
addressed. The transformation of restrictions is generalized in
Sec.~\ref{sec:delocalization} in which \emph{delocalization} -- how to
move application conditions from one production to another inside the
same sequence -- is also studied together with \emph{variable
  nodes}. As an application of restrictions to MGGs,
Sec.~\ref{sec:fromSimpleDigraphsToMultidigraphs} shows how to make MGG
deal with multidigraphs instead of just simple digraphs without major
modifications to the theory. The paper ends in
Sec.~\ref{sec:conclusions} with some conclusions, further research
remarks and acknowledgements.

\section{Matrix Graph Grammars Overview}
\label{sec:MGGs}


We work with \textbf{simple digraphs} which we represent as , where  is a Boolean matrix for edges (the graph {\em
  adjacency} matrix) and  a Boolean vector for vertices or
nodes.\footnote{The vector for nodes is necessary because in MGG nodes
  can be added and deleted, and thus we mark the existing nodes with a
   in the corresponding position of the vector.} The left of
Fig.~\ref{fig:example_graph} shows a graph representing a production
system made up of a machine (controlled by an operator) which consumes
and produces pieces through conveyors. Self loops in operators and
machines indicate that they are busy.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.4]{figures/graph2_bmp}
  \caption{Simple Digraph Example (left). Matrix Representation
    (right)}
  \label{fig:example_graph}
\end{figure}


Well-formedness of graphs (i.e. absence of dangling edges) can be
checked by verifying the identity , where  is the Boolean
matrix product,\footnote{The Boolean matrix product is like the regular
  matrix product, but with \textbf{and} and \textbf{or} instead of
  multiplication and addition.}  is the transpose of the matrix
,  is the negation of the nodes vector , and  is an operation (a norm, actually) that results in the
{\bf or} of all the components of the vector. We call this property
\textbf{compatibility} (refer to~\cite{JuanPP_1}). Note that  results in a vector that contains a 1 in position 
when there is an outgoing edge from node  to a non-existing node. A
similar expression with the transpose of  is used to check for
incoming edges.


A \textbf{type} is assigned to each node in  by a function
from the set of nodes  to a set of types ,
. Sets will be represented by . In
Fig.~\ref{fig:example_graph} types are represented as an extra column
in the matrices, where the numbers before the colon distinguish
elements of the same type. It is just a visual aid. For edges we use
the types of their source and target nodes. A \textbf{typed simple
  digraph} is . From now on we shall assume typed
graphs and shall drop the  subindex.

A \textbf{production} or grammar rule  is a
morphism of typed simple digraphs, which is defined as a mapping that
transforms  in  with the restriction that the type of the image
must be equal to the type of the source element.\footnote{We shall
  come back to this topic in Sec.~\ref{sec:delocalization}.} More
explicitly,  being  and 
partial injective mappings ,
 such that  and , where  stands for
domain,  for edges and  for vertices.


A production  is \textbf{statically represented} as
. The matrices and vectors of these graphs are arranged so
that the elements identified by morphism  match (this is called
completion, see below). Alternatively, a production adds and deletes
nodes and edges, therefore they can be \textbf{dynamically represented}
by encoding the rule's LHS together with matrices and vectors
representing the addition and deletion of edges and nodes:\footnote{We
  call such matrices and vectors  for ``erase'' and  for
  ``restock''.} , where 
contains the types of the new nodes,  and  are the deletion
Boolean matrix and vector,  and  are the addition Boolean
matrix and vector. They have a 1 in the position where the element is
to be deleted or added, respectively. The output of rule  is
calculated by the Boolean formula , which applies both to nodes and edges.\footnote{The and symbol
   is usually omitted in formulae, so  with precedence of  over .}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.22]{figures/startProcess2_bmp}
  \caption{(a) Rule Example. (b) Static Formulation. (c) Dynamic
    Formulation}
  \label{fig:example_rule}
\end{figure}

\noindent \textbf{Example}.Figure~\ref{fig:example_rule}
shows a rule and its associated matrices. The rule models the
consumption of a piece (Pack) by a machine (Mach) input via the
conveyor (Conv). There is an operator (Oper) managing the
machine. Compatibility of the resulting graph must be ensured, thus
the rule cannot be applied if the machine is already busy, as it would
end up with two self loops which is not allowed in a simple digraph.
This restriction of simple digraphs can be useful in this kind of
situations and acts like a built-in negative application
condition. Later we will see that the \emph{nihilation matrix} takes
care of this restriction. \proofend

In order to operate with the matrix representation of graphs of
different sizes, an operation called \textbf{completion} adds extra
rows and columns with zeros to matrices and vectors, and rearranges
rows and columns so that the identified edges and nodes of the two
graphs match.  For example, in Fig.~\ref{fig:example_rule}, if we need
to operate  and , completion adds a fourth -row and
fourth -column to . No further modification is needed because
the rest of the elements have the right types and are placed
properly.\footnote{In the present contribution we shall assume that
  completion is being performed somehow. This is closely related to
non-determinism. The reader is referred to~\cite{MGGmodel} for further
details.}

With the purpose of considering the elements in the host graph that
disable a rule application, we extend the notation for rules with a
new simple digraph , which specifies the two kinds of forbidden
edges: Those incident to nodes which are going to be erased and any
edge added by the rule (which cannot be added twice, since we are
dealing with simple digraphs).  has non-zero elements in positions
corresponding to newly added edges, and to non-deleted edges incident
to deleted nodes. Matrices are derived in the following order: .  Thus, a rule
is \emph{statically} determined by its LHS and RHS , from which it is possible to give a \emph{dynamic}
definition , with  and
, to end up with a full specification including its
\emph{environmental} behavior .  No
extra effort is needed from the grammar designer because  can be
automatically calculated: , with .\footnote{Symbol
   denotes the tensor or Kronecker product, which sums up the
  covariant and contravariant parts and multiplies every element of
  the first vector by the whole second vector.} The evolution of the
nihilation matrix (what elements can not appear in the RHS) -- call it
 -- is given by the inverse of the production: . See~\cite{MGGfundamenta} for more details.

Inspired by the Dirac or bra-ket notation~\cite{braket} we split the
static part (initial state, ) from the dynamics (element addition
and deletion, ): . The \emph{ket} operators (those to the right side of the
bra-ket) can be moved to the \emph{bra} (left hand side) by using
their adjoints.

\textbf{Matching} is the operation of identifying the LHS of a rule
inside a host graph. Given a rule  and a simple
digraph , any total injective\footnote{MGG considers only injective
  matches.} morphism  is a match for  in ,
thus it is one of the ways of {\em completing}  in . Besides, we
shall consider the elements that must not be present.

Given the grammar rule  and the graph ,  is called a \textbf{direct
  derivation} with  and result  if the following conditions are satisfied:
\begin{enumerate}
\item There exist total injective morphisms 
  and  with ,
  .
\item The match  induces a completion of  in . Matrices
   and  are then completed in the same way to yield  and
  . The output graph is calculated as .
\end{enumerate}

The negation when applied to graphs alone (not specifying the nodes)
-- e.g.  in the first condition above -- will be carried
out just on edges. Notice that in particular the first condition above
guarantees that  and  will be applied to the same nodes in the
host graph .

In direct derivations \emph{dangling edges} can occur because the
nihilation matrix only considers edges incident to nodes appearing in
the rule's LHS and not in the whole host graph. In MGG an operator
 takes care of dangling edges which are deleted by
adding a preproduction (known as production) before the
original rule. Refer to~\cite{JuanPP_1, JuanPP_2}. Thus, rule  is
transformed into the sequence , where
 deletes the dangling edges and  remains
unaltered.

There are occasions in which two or more productions should be matched
to the same nodes. This is achieved with the \textbf{marking operator}
 introduced in Chap.~6 in~\cite{MGGBook}. A grammar rule and
its associated -production is one example and we shall
find more in future sections.

In~\cite{JuanPP_1,JuanPP_2,JuanPP_4,MGGBook} some analysis techniques
for MGGs have been developed which we shall skim through. One
important feature of MGG is that sequences of rules can be analyzed
independently to some extent of any host graph. A rule
\textbf{sequence} is represented by  where
application is from right to left, i.e.  is applied first. For
its analysis, the sequence is completed by identifying the nodes
across rules which are assumed to be mapped to the same node in the
host graph.

Once the sequence is completed, sequence
\textbf{coherence}~\cite{JuanPP_1, MGGBook, MGGCombinatorics}
allows us to know if, for the given identification, the sequence is
potentially applicable, i.e. if no rule disturbs the application of
those following it. The formula for coherence results in a matrix and
a vector (which can be interpreted as a graph) with the problematic
elements. If the sequence is coherent, both should be zero; if not,
they contain the problematic elements. A coherent sequence is
\textbf{compatible} if its application produces a simple digraph. That
is, no dangling edges are produced in intermediate steps.

Given a completed sequence, the \textbf{minimal initial digraph} (MID)
is the smallest graph that permits the application of such
sequence. Conversely, the \textbf{negative initial digraph} (NID)
contains all elements that should not be present in the host graph for
the sequence to be applicable. In this way, the NID is a graph that
should be found in  for the sequence to be applicable
(i.e. none of its edges can be found in ). See Sec.~6
in~\cite{MGGCombinatorics} or Chaps.~5 and~6 in~\cite{MGGBook}.

Other concepts we developed aim at checking \textbf{sequential
  independence} (same result) between a sequence and a permutation of
it. \textbf{G-Congruence} detects if two sequences, one permutation of
the other, have the same MID and NID. It returns two matrices and two
vectors, representing two graphs which are the differences between the
MIDs and NIDs of each sequence, respectively. Thus if zero, the
sequences have the same MID and NID. Two coherent and compatible
completed sequences that are G-congruent are sequentially
independent. See Sec.~7 in~\cite{MGGCombinatorics} or Chap.~7
in~\cite{MGGBook}.

\section{Previous Work on Application Conditions in MGG}
\label{sec:previous}


In this section we shall brush up on application conditions (ACs) as
introduced for MGG in~\cite{MGGfundamenta} with non-fixed diagrams and
quantifiers. For the quantification, a full-fledged monadic second
order logic\footnote{MSOL, see e.g. \cite{Courcelle}.} formula is
used. One of the contributions in~\cite{MGGfundamenta} is that a
rule with an AC can be transformed into (sequences of) plain rules by
adding the positive information to the left hand side of the
production and the negative to the nihilation matrix.

A \textbf{diagram}  is a set of simple digraphs  and a set of partial injective morphisms  with . The diagram 
is well defined if every cycle of morphisms commute.  is a \textbf{graph constraint} where
 is a well defined diagram and  a sentence
with variables in  and predicates  and
. See eqs.~(\ref{eq:P}) and~(\ref{eq:Q}). Formulae are restricted
to have no free variables except for the default second argument of
predicates  and , which is the host graph  in which we
evaluate the GC. GC formulae are made up of expressions about graph
inclusions. The predicates  and  are given by:

where predicate  states that element  (a node or an edge)
is in graph .  Predicate  means that graph  is
included in . Predicate  asserts that there is a
partial morphism between  and , which is defined on at least
one edge ( ranges over all edges). The notation (syntax) will be
simplified by making the host graph  the default second argument
for predicates  and .  Besides, it will be assumed that by
default total morphisms are demanded: Unless otherwise stated
predicate  is assumed. We take the convention that negations in
abbreviations apply to the predicate (e.g. ) and not the negation of the
graph's adjacency matrix.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.35]{figures/diagExample2_bmp}
  \caption{Diagram Example}
  \label{fig:DiagExample}
\end{figure}

\noindent {\bf Example}.The GC in Fig.~\ref{fig:DiagExample}
is satisfied if for every  in  it is possible to find a
related  in , i.e. its associated formula is , equivalent by
definition to . Nodes and
edges in  and  are related through morphism  in
which the image of the machine in  is the machine in . To
enhance readability, each graph in the diagram has been marked with
the quantifier given in the formula. The GC in
Fig.~\ref{fig:DiagExample} expresses that each machine should have an
output conveyor. \proofend

Given the rule  with nihilation matrix , an
\textbf{application condition} AC (over the free variable ) is a
GC satisfying:
\begin{enumerate}
\item  such that  and .
\item  such that  is the only free variable.
\item  must demand the existence of  in  and the
  existence of  in .
\end{enumerate}

For simplicity, we usually do not explicitly show the condition 3 in
the formulae of ACs, nor the nihilation matrix  in the diagram
which are existentially quantified before any other graph of the
AC. Notice that the rule's LHS and its nihilation matrix can be
interpreted as the minimal AC a rule can have. For technical reasons
addressed in Sec.~\ref{sec:movingConditions} (related to converting
pre into postconditions) we assume that morphisms  in the diagram
do not have codomain  or . This is easily solved as we may
always use their inverses due to 's injectiveness.

It is possible to embed arbitrary ACs into rules by including the
positive and negative conditions in  and , respectively.
Intuitively: ``MGG + AC = MGG'' and ``MGG + GC =
MGG''. In~\cite{MGGfundamenta} two basic operations are
introduced:~\textbf{closure} --  -- that transforms
universal into existential quantifiers, and \textbf{decomposition} --
 -- that transforms partial morphisms into total
morphisms. Notice that a match is an existentially quantified total
morphism. It is proved in~\cite{MGGfundamenta} that any AC can be
embedded into its corresponding direct derivation. This is achieved by
transforming the AC into some sequences of productions. There are four
basic types of ACs/GCs. Let  be a graph constraint with diagram 
and consider the associated production . The case
 is just the matching of  in the host
graph . It is equivalent to the sequence , where 
has  as LHS and RHS, so it simply demands its existence in . We
introduce the operator  that replaces  by  and leaves
the diagram and the formula unaltered. If the formula  is considered, we can reduce it to a sequence of
matchings via the closure operator  whose result is:
 
with , ,\footnote{ is an isomorphism.}
 and .\footnote{ is a
  maximal non-empty partial morphism with .} This is
equivalent to the sequence . If the
application condition has formula ,
we can proceed by defining the composition operator 
with action:

where  contains a single edge of  and  is the number of
edges of . This is equivalent to the set of sequences .

Less evident are formulas of the form . Fortunately, operators 
and  commute when composed so we can get along with the
operator . The image of  on
such ACs are given by:


An AC is said to be \textbf{coherent} if it is not a contradiction
(false in all scenarios), \textbf{compatible} if, together with the
rule's actions, produces a simple digraph, and \textbf{consistent} if
 host graph such that \footnote{We shall say
  that the host graph  satisfies , written , if and only if , being  is a
  total morphism. Also,  satisfies
  , written\phantom{i} , if and
  only if . Usually we shall abuse of the notation and write  instead. For more details, please refer
  to~\cite{MGGfundamenta}.} to which the production is applicable. As
ACs can be transformed into equivalent (sets of) sequences, it is
proved in~\cite{MGGfundamenta} that coherence and compatibility of an
AC is equivalent to coherence and compatibility of the associated (set
of) sequence(s), respectively. Also, an AC is consistent if and only
if its equivalent (set of) sequence(s) is applicable. Besides, all
results and analysis techniques developed for MGG can be applied to
sequences with ACs. Some examples follow:
\begin{itemize}
\item As a sequence is applicable if and only if it is coherent and
  compatible (see Sec~6.4 in~\cite{MGGBook}) then an AC is consistent
  if and only if it is coherent and compatible.
\item Sequential independence allows us to delay or advance the
  constraints inside a sequence. As long as the productions do not
  modify the elements of the constraints, this is transformation of
  preconditions into postconditions. More on
  Sec.~\ref{sec:movingConditions}.
\item Initial digraph calculation solves the problem of finding a host
  graph that satisfies a given AC/GC. There are some limitations,
  though. For example it is necessary to limit the maximum number of
  nodes when dealing with universal quantifiers. This has no impact in
  some cases, for example when non-uniform MGG submodels are
  considered (see \emph{nodeless MGG} in~\cite{MGGmodel}).
\item \emph{Graph congruence} characterizes sequences with the same
  initial digraph. Therefore it can be used to study when two
  GCs/ACs are equivalent for all morphisms or for some of them.
\end{itemize}

Summarizing, there are two basic results
in~\cite{MGGfundamenta}. First, it is always possible to embed an
application condition into the LHS of the production or
derivation. The left hand side  of a production receives elements
that must be found --  -- and  those whose presence is
forbidden --  --. Second, it is always possible to
find a sequence or a set of sequences of plain productions whose
behavior is equivalent to that of the production plus the application
condition.

\section{Postconditions}
\label{sec:postconditions}


In this section we shall introduce postconditions and state some basic
facts about them analogous to those for preconditions. We shall
enlarge the notation by appending a left arrow on top of the
conditions to indicate that they are preconditions and an upper
right arrow for postconditions.  Examples are
 for a precondition and
 for a postcondition.  If it is clear
from the context, arrows will be omitted.

\begin{definition}[Precondition and Postcondition]
  \label{def:prePostCondition}
  An application condition set on the LHS of a production is known as
  a \emph{precondition}. If it is set on the RHS then it is known as a
  \emph{postcondition}.
\end{definition}

Operators  and
 are defined similarly for
postconditions. The following proposition establishes an
equivalence between the basic formulae (match, decomposition, closure
and negative application condition) and certain sequences of
productions.

\begin{proposition}
  \label{prop:postConds}
  Let  be a postcondition. Then we can
  obtain a set of equivalent sequences to given basic formulae as
  follows:
  
  where  is the number of potential matches of  in the image of
  the host graph,  is the number of edges in  and
   asks for the existence of  in the complement of
  the image of the host graph.
\end{proposition}

\noindent \emph{Proof} \\*
 For the first case (match), the AC states that an additional
graph  has to be found in the image of the host graph. This is
easily achieved by applying  to the image of , i.e. by
considering . The elements in  are related to those in  according to the
identifications in a morphism  that has to be given in the diagram
of the postcondition. In the four cases considered in the proposition
we can move from composition to concatenation by means of the marking
operator . Recall that  guarantees that the
identifications in  are preserved.

The second case (closure) is very similar. We have to verify all
potential appearances of  in the image of the host graph because
. We proceed as in the
first case but this time with a finite number of compositions: .

For decomposition,  is not found in the host graph if for some
matching there is at least one missing edge. It is thus similar to
matching but for a single edge. The way to proceed is to consider the
set of sequences that appear in eq.~(\ref{eq:decomp}). Negative
application conditions (NACs) are the composition of
eqs.~(\ref{eq:closure}) and~(\ref{eq:decomp}). \proofend

One of the main points of the techniques available for preconditions
is to analyze rules with ACs by translating them into sequences of
flat rules, and then analyzing the sequences of flat rules instead.

\begin{theorem}
  \label{th:reductionPost}
  Any well-defined postcondition can be reduced to the study of
  the corresponding set of sequences.
\end{theorem}

\noindent \emph{Proof} \\*
The proof follows that of Th.~4.1 in~\cite{MGGfundamenta} and
is included here for completeness sake. Let the depth of a graph for a
fixed node  be the maximum over the shortest path (to avoid
cycles) starting in any node different from  and ending in
. The depth of a graph is the maximum depth for all its
nodes. Notice that the depth is  if and only if  in
the diagram are unrelated. We shall apply induction on the depth of
the AC.

A diagram  is a graph where nodes are digraphs  and
edges are morphisms . There are  possibilities for depth
 in a AC made up of a single element , summarized in
Table~\ref{tab:possibilitiesSingleCase}.

\begin{table*}[hbtp]
  \centering
  \begin{tabular}{|rl|rl||rl|rl|}
    \hline
    \begin{Large}\phantom{I}\end{Large}(1*) &  & (5*)
    &  & (9*) &  & (13*) & \\
    \hline
    \begin{Large}\phantom{I}\end{Large}(2*) &  & (6*) &  & (10*) &
     & (14*) & \\ 
    \hline
    \begin{Large}\phantom{I}\end{Large}(3*) &  & (7*) &  & (11*) &  & (15*) & \\
    \hline
    \begin{Large}\phantom{I}\end{Large}(4*) &  &
    (8*) &  & (12*) &  & (16*) & \\
    \hline
  \end{tabular}
  \caption{All Possible Diagrams for a Single Element}
  \label{tab:possibilitiesSingleCase}
\end{table*}

Elements in the same row for each pair of columns are related using
equalities  and
, so it is possible
to reduce the study to cases (1*) -- (4*) and (9*) --
(12*). Identities  and  reduce (9*) -- (12*) to formulae (1*)
-- (4*):


Proposition~\ref{prop:postConds} considers the four basic cases which
correspond to (1*) -- (4*) in Table~\ref{tab:possibilitiesSingleCase},
showing that in fact they can all be reduced to matchings in the image
of the host graph, i.e. to~(1*) in
Table~\ref{tab:possibilitiesSingleCase}, verifying the theorem.

Now we move on to the induction step which considers combinations of
quantifiers. Well-definedness guarantees independence with respect to
the order in which elements  in the postcondition are
selected. When there is a universal quantifier , according
to eq.~(\ref{eq:closure}), elements of  are replicated as many
times as potential instances of  can be found in the host graph.
In order to continue the procedure we have to clone the rest of the
diagram for each replica of , except those graphs which are
existentially quantified before  in the formula. That is, if we
have a formula  when performing the
closure of , we have to replicate  as many times as , but not
.  Moreover  has to be connected to each replica of ,
preserving the identifications of the morphism .
More in detail: When closure is applied to , we iterate on all
graphs  in the diagram. There are three possibilities:

\begin{itemize}
\item If  is existentially quantified after  --  -- then it is replicated as many times as .
  Appropriate morphisms are created between each  and  if
  a morphism  existed. The new morphisms identify
  elements in  and  according to .  This permits finding
  different matches of  for each , some of which can be
  equal.\footnote{If for example there are three instances of  in
    the image of the host graph but only one of , then the three
    replicas of  are matched to the same part of .}
\item If  is existentially quantified before  --  -- then it is not replicated, but just connected to
  each replica of  if necessary. This ensures that a unique 
  has to be found for each . Moreover, the replication of  has
  to preserve the shape of the original diagram. That is, if there is
  a morphism  then each  has to
  preserve the identifications of  (this means that we take only
  those  which preserve the structure of the diagram).
\item If  is universally quantified (no matter if it is
  quantified before or after ), again it is replicated as many
  times as . Afterwards,  will itself need to be replicated
  due to its universality. The order in which these replications are
  performed is not relevant as . \proofend
\end{itemize}

Previous theorem and the corollaries that follow heavily depend on the
host graph and its image (through matching) so analysis techniques
developed so far in MGG which are independent of the host graphs can
not be applied. The ``problem'' is the universal quantifier. We can
consider the initial digraph and dispose to some extent of the host
graph and its image. This is related to the fact
(Sec.~\ref{sec:movingConditions}) that it is possible to transform
postconditions into equivalent preconditions.

Two applications of Th.~\ref{th:reductionPost} are the
following corollaries that characterize coherence, compatibility and
consistency of postconditions.

\begin{corollary}
  \label{cor:equivPostAC_seqs}
  A postcondition is coherent if and only if its associated (set of)
  sequence(s) is coherent.  Also, it is compatible if and only if its
  associated (set of) sequence(s) is compatible and it is consistent
  if and only if its associated (set of) sequence(s) is applicable.
\end{corollary}



\begin{corollary}
  \label{cor:postcondConsCohComp}
  A postcondition is consistent if and only if it is coherent and
  compatible.
\end{corollary}





\noindent \textbf{Example.}Let's consider the diagram in
Fig.~\ref{fig:final_example_GC} with formula . The postcondition states that if an operator
is connected to a machine, such machine is busy. The formula has an
implication so it is not possible to directly generate the set of
sequences because the postcondition also holds when the left of the
implication is false. The closure operator  reduces the
postcondition to existential quantifiers, which is represented to the
right of the figure. The resulting modified formula would be  .

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.28]{figures/postCondExample_bmp}
  \caption{Postcondition Example}
  \label{fig:final_example_GC}
\end{figure}

Once the formula has existentials only, we manipulate it to get rid of
implications. Thus, we have . This leads to a
set of four sequences:
. Thus, the graph
 and the production satisfy the postcondition if and only if some
sequence in the set is applicable to . \proofend

Something left undefined is the order of productions  and
 in the sequences. Consistency does not depend on
the ordering of productions -- as long as the first to be applied is
production  -- because productions  (and their negation) are
sequentially independent (they do not add nor delete any edge or
node). If they are not sequentially independent then there exists at
least one inconsistency. This inconsistency can be detected using
previous corollaries independently of the order of the productions.

\section{Moving Conditions}
\label{sec:movingConditions}


In this section we give two different proofs that it is possible to
transform preconditions into equivalent postconditions and back
again. The first proof (sketched) makes use of category theory while
the second relies on the characterizations of coherence, G-congruence
and compatibility. To ease exposition we shall focus on the certainty
part only as the nihilation part would follow using the inverse of the
production.



We shall start with a case that can be addressed using
equations~\eqref{eq:postMatch}~--~\eqref{eq:postNAC},
Th.~\ref{th:reductionPost} and Cor.~\ref{cor:equivPostAC_seqs}: When
the transformed postcondition for a given precondition does not
change.\footnote{This is not so unrealistic. For example, if the
  production preserves all elements appearing in the precondition.}
The question of whether it is always possible to transform a
precondition into a postcondition -- and back again -- in this
restricted case would be equivalent to asking for sequential
independence of the production  and the identities  or
:

where the sequence to the left of the equality corresponds to a
precondition and the sequence to the right corresponds to its
equivalent postcondition.

\begin{figure}[htb]
  \centering
  \makebox{
    \xymatrix{
      \stackrel{\leftarrow}{A}
      \ar@[blue][ddr]_{m_{\stackrel{\leftarrow}{A}}} 
      \ar@{.>}[rrrr]_{p_A} &&&& \stackrel{\rightarrow}{A}
      \ar@{.>}@[red][ddl]^{m_{\stackrel{\rightarrow}{A}} } & 
      L \ar@[blue][rrr]_{p} \ar@[blue][dd]^{d_L} &&& R
      \ar@{.>}@[red][dd]_{d^{*}_L} &
      \stackrel{\leftarrow}{A} \ar@[blue][rrr]_{p_A}
      \ar@[blue][dd]^{m_{\stackrel{\leftarrow}{A}}} &&&
        \stackrel{\rightarrow}{A}
        \ar@{.>}@[red][dd]_{m_{\stackrel{\rightarrow}{A}}} \\
      & L \ar@[blue][rr]^p \ar@[blue][d]^{m_L} \ar@[blue][ul]_{d_L} &&
      R \ar@{.>}@[red][d]_{m^*_L} \ar@{.>}[ur]^{d^*_L} \\
      & G \ar@{.>}@[red][rr]^{p^*} && H && 
      \stackrel{\leftarrow}{A}
      \ar@{.>}@[red][rrr]^{p_A} &&& \stackrel{\rightarrow}{A} &
      G \ar@{.>}@[red][rrr]^{p_A^*} &&& H
    }
  }
  \caption{Precondition to Postcondition Transformation}
  \label{fig:prePostTrans}
\end{figure}

In general the production may act on elements that appear in the
diagram of the precondition, spoiling sequential independence. Left
and center of Fig.~\ref{fig:prePostTrans} -- in which the first basic
AC (match) is considered -- suggest that the pre-to-post
transformation is a categorical pushout\footnote{The square 
  is a pushout where , , ,  and
   are known and
  ,  and  need to be calculated.}
in the category of simple digraphs and partial morphisms.

Theorem~\ref{th:reductionPost} proves that any postcondition can be
reduced to the match case. Besides, we can trivially consider total
morphisms (instead of partial ones) by restricting the domain and the
codomain of  to the nodes in . For the
post-to-pre transformation we can either use pullbacks or pushouts
plus the inverse of the production involved.

To see that precondition satisfaction is equivalent to postcondition
satisfaction using category theory, we should check that the different
pushouts can be constructed (, etcetera) and that
 and  (refer to
Fig.~\ref{fig:prePostTrans}). Although some topics remain untouched
such as dangling edges, we shall not carry on with category theory.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.75]{figures/pre2PostSimpleEx}
  \caption{Restriction to Common Parts: Total Morphism}
  \label{fig:pre2PostSimpleEx}
\end{figure}

\noindent \textbf{Example}.Let be given the precondition
 to the left of
Fig.~\ref{fig:pre2PostSimpleEx} with formula
. To calculate its
associated postcondition we can apply the production to
 and obtain ,
represented also to the left of the same figure. Notice however that
it is not possible to fing a match of  in
 because of node . One possible solution
is to consider  and restrict
the production to those common elements. This is done to the right of
Fig.~\ref{fig:pre2PostSimpleEx} \proofend

\begin{theorem}
  \label{th:prePostPre}
  Any consistent precondition is equivalent to some consistent
  postcondition and vice versa.
\end{theorem}

\noindent \emph{Proof} \\*
For the post-to-pre transformation roles of  and 
are interchanged so we shall address only the pre-to-post case. It is
enough to study a single  in the diagram as the same procedure
applies mechanically (Th.~4.1 transforms any precondition into a
sequence of productions). Also, it suffices to state the result for
 because  is similar but the evolution depends
on . Finally, we shall assume that  and  are not
sequentially independent.

Recall that -congruence guarantees sameness of the initial digraph,
which is what the sequence demands on the host graph. Therefore, all
we have to do is to use -congruence to check the differences in the
two sequences:

However, before that we need to guarantee coherence and compatibility
of both sequences (see the hypothesis of Th.~4
in~\cite{MGGCombinatorics}). Coherence gives rise to the following
equation:

where  and  correspond to ,  to
 and  to
. Fortunately,  is a production
that does nothing, so from the dynamical point of view any conflict
should come from , i.e.  which has been used in the
implication of eq.~(\ref{eq:3}).

By consistency we have that  so eq.~(\ref{eq:3}) will be fulfilled if the
postcondition is the precondition but erasing the elements that the
production deletes. A similar reasoning for the nihil part tells us
that we should add to the postcondition all those elements added by
the production.

Compatibility can only be ruined by dangling edges. In~Sec.~6.1
in~\cite{MGGBook} dangling edges are deleted transforming the
production via the opeartor . This is proved to be
equivalent to defining a sequence by appending a so-called
-production. In essence the -production just
deletes any dangling edge, thus keeping compatibility. This very same
procedure can be applied now:


According to Prop.~5 and Th.~4 in~\cite{MGGCombinatorics}, two
compatible and coherent sequences are -congruent if the following
equation (adapted to our case) is fulfilled:

We have that . Also,
 because
 acts on the certainty part and
 (see e.g. Prop.~4.1.4 in~\cite{handbook}). We are
left with

which is guaranteed by compatibility: once
 is transformed into
 in
eq.~(\ref{eq:7}) there can not be any potential dangling edge, except
those to be deleted by  in the last step. \proofend 

It is worth stressing the fact that the transformation between pre and
postconditions preserve consistency of the application condition. We
have seen in this section that  not only acts on  but on the
whole precondition. We can therefore extend the notation:


Pre-to-post and post-to-pre transformations can affect the diagram and
the formula. See the example below. There are two clear cases:
\begin{itemize}
\item The application condition requires the graph to appear and the
  production deletes all its elements.
\item The application condition requires the graph not to appear and
  the production adds all its elements.
\end{itemize}

For a given application condition AC it is not necessarily true that
 because some new elements may be added and some
obsolete elements discarded.  What we will get is an equivalent
condition adapted to  that holds whenever  holds and fails to be
true whenever  is false.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.75]{figures/pre2PostEx2}
  \caption{Precondition to Postcondition Example}
  \label{fig:pre2PostEx}
\end{figure}

\noindent\textbf{Example}.In Fig.~\ref{fig:pre2PostEx} there
is a very simple transformation of a precondition into a postcondition
through morphism . The associated formula to the precondition
 that we shall consider is
. The production
deletes two arrows and adds a new one. The overall effect is reverting
the direction of the edge between nodes  and  and deleting the
self-loop in node . Notice that  can not match node  to
 in  because of the edge  in the application condition.

Suppose we had a (redundant) graph  made up of a single node 
with a self loop in the precondition and with formula
. The formula
in the postcondition would still be
.

The opposite transformation, from postcondition into precondition, can
be obtained by reverting the arrow, i.e. through .  More
general schemes can be studied applying the same principles.

Let . If a pre-post-pre transformation is carried out, we will
have  because edge (2,1)
would be added to . However, it is true that
.

Note that in fact  and  are
sequentially independent if we limit ourselves to edges, so it would
be possible to simply move the precondition to a postcondition as it
is. Nonetheless, we have to consider nodes 1 and 2 as the common parts
between  and . This is the same kind of
restriction as the one illustrated in
Fig.~\ref{fig:pre2PostSimpleEx}. \proofend

If the pre-post-pre transformation is thought of as an operator 
acting on application conditions, then it fulfills

where  is the identity. The same would also be true for a
post-pre-post transformation.

A possible interpretation of eq.~\eqref{eq:2} is that the definition
of the application condition can vary from the \emph{natural} one,
according to the production under consideration. Pre-post-pre or
post-pre-post transformations adjust application conditions to the
corresponding production.

When defining diagrams some ``practical problems'' may turn up.  For
example, if the diagram  is considered then there are two potential problems:
\begin{enumerate}
\item The direction in the arrow  is not the
  natural one.  Nevertheless, injectiveness allows us to safely revert
  the arrow, .
\item Even though we only formally state  and , other
  morphisms naturally appear and need to be checked out, e.g. .  New morphisms should be considered if they
  relate at least one element.\footnote{Otherwise stated: Any
    condition made up of  graphs  can be identified as the
    complete graph , in which nodes are graphs  and
    morphisms are .  Whether this is a directed graph or not
    is a matter of taste (morphisms are injective).}
\end{enumerate}

\section{Delocalization and Variable Nodes}
\label{sec:delocalization}


In this section we touch on \emph{delocalization} of graph constraints
and application conditions as well as their equivalence. Also, we
shall pave the way to multidigraph rewriting to be studied in detail
in Sec.~\ref{sec:fromSimpleDigraphsToMultidigraphs}.

Let  be a sequence of productions with their
corresponding ACs. We have seen in Th.~\ref{th:reductionPost} that
preconditions and postconditions are equivalent and in
Th.~\ref{th:prePostPre} that they can be transformed into sequences of
productions. As a precondition in  is the same as a
postcondition in , we see that ACs can be moved arbitrarily
inside a sequence.

Similarly, constraints set on the intermediate states of a derivation
can be moved among them. A graph constraint GC set in the initial
state  to which a production  is going to be applied is
equivalent to the precondition

If the GC is set on the final state  to which the
production  has been applied, there is an equivalent postcondition:

In both cases the diagrams are given by the LHS or the RHS plus the
diagram of the graph constraint. We call this property of application
conditions and graph constraints \emph{delocalization}.

We shall now address variable nodes which will be used to enhance MGG
functionality to deal with multidigraphs. Graph transformation with
variables is studied in~\cite{Hof05}. We shall summarize the proposal
in~\cite{Hof05} and propound an alternative way to close the section.

If instead of nodes of fixed type variable, types are allowed we get a
so called \emph{graph pattern}. A \emph{rule scheme} is just a
production in which graphs are graph patterns. A \emph{substitution
  function}  specifies how variable names taking place in a
production are substituted.  A rule scheme  is instantiated via
substitution functions producing a particular production. For example,
for substitution function  we get . The set of
production instances for  is defined as the set   is a
substitution. The \emph{kernel} of a graph ,
, is defined as the graph resulting when all variable nodes
are removed.  It might be the case that .

The basic idea is to reduce any rule scheme to a set of rule
instances.  Note that it is not possible in general to generate
 because this set can be infinite.  The way to proceed
is not difficult:
\begin{enumerate}
\item Find a match for the kernel of .
\item Induce a substitution  such that the match for the kernel
  becomes a full match .
\item Construct the instance  and apply  to
  get the direct derivation .
\end{enumerate}

As an alternative, we may extend the concept of type
assignment. Recall from Sec.~\ref{sec:MGGs} that types are assigned by
a function from the set of nodes  of a simple digraph  to some
fixed set  of types, . Instead, we shall define

where  is the power set\footnote{The set of all
  subsets.} of  except for the empty set because we do not permit
nodes without types.

When two matrices are operated, the types of a fixed node will be the
intersection of the nodes operated. For example, suppose that we
\textbf{and} two matrices  and that the (set of) nodes
associated to the elements  and  are  and
, respectively. Then, . The operation would not be allowed in case . 

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.8]{figures/simplifiedDiagram3}
  \caption{Example of Graph Constraint}
  \label{fig:simplifiedDiagram2}
\end{figure}

\noindent \textbf{Example}. Let a type of nodes be
represented by squares (call them \emph{multinodes}) and the rest
(call them \emph{simple nodes}) by colored circles. The set of types
 is split into two: multinodes and simple nodes.

Let's consider the graph constraint , with  the diagram depicted
in Fig.~\ref{fig:simplifiedDiagram2} made up of the graphs  and
, along with the formula . This graph constraint is
``edges must connect nodes and multinodes alternatively but no edge
is allowed to be incident to two multinodes or to two simple nodes,
including self-loops''.

In the graph  of Fig.~\ref{fig:simplifiedDiagram2},  and 
represent variable nodes while  and  in  have a fixed
type. We may think of  and  as variable nodes whose set of types
has a single element. \proofend




\section{From Simple Digraphs to Multidigraphs}
\label{sec:fromSimpleDigraphsToMultidigraphs}


In this section we show how MGG can deal with multidigraphs (directed
graphs allowing multiple parallel edges) just by considering variable
nodes. At first sight this might seem a hard task as MGG heavily
depends on adjacency matrices.  Adjacency matrices are well suited for
simple digraphs but can not cope with parallel edges. This section can
be thought of as a \emph{theoretical application} of graph constraints
and application conditions to Matrix Graph Grammars.

The idea is not difficult: A special kind of node (call it
\emph{multinode} in contrast to \emph{simple node}) associated to
every edge in the graph is introduced, i.e. edges in the multidigraph
are substituted by multinodes in a simple digraph representation of
the multidigraph.  Graphically, multinodes will be represented by a
filled square while normal nodes will appear as colored circles. See
the example by the end of Sec.~\ref{sec:delocalization}



Operations previously specified on edges now act on multinodes: Adding
an edge is transformed into a multinode addition and edge deletion
becomes multinode deletion.  There are edges that link multinodes to
their source and target simple nodes.

Some restrictions (application conditions) to be imposed on the
actions that can be performed on multinodes exist, as well as on the
shape or topology of permitted graphs (graph constraints). Not every
possible graph with multinodes represents a multidigraph.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.9]{figures/simpleMultiGraph}
  \caption{Multidigraph with Two Outgoing Edges}
  \label{fig:simpleMultiGraph}
\end{figure}

\noindent\textbf{Example}.Consider the simple production in
Fig.~\ref{fig:simpleMultiGraph} with two parallel edges between nodes
 and .  As commented above, multinodes are represented by square
nodes while normal nodes are left unchanged.  When  deletes an
edge,  deletes a multinode.  Adjacency matrices for 
are:





In a real situation, a development tool such as AToM or
AGG\footnote{\url{http://moncs.cs.mcgill.ca/MSDL/research/projects/AToM3/}
  for AToM and \url{http://www.gratra.org/} for AGG and some other
  tools.} should take care of all these representation issues.  A user
would see what appears to the left of Fig.~\ref{fig:simpleMultiGraph}
and not what is depicted to the right of the same figure. \proofend

Some restrictions on what a production can do to a multidigraph are
necessary in order to obtain a multidigraph again. Think for example
the case in which after applying some production we get a graph in
which there is an isolated multinode (which would stand for an edge
with no source nor target nodes). All we have to do is to find the
properties that define one edge and impose them on multinodes as graph
constraints:
\begin{enumerate}
\item A simple node (resp., multinode) can not be directly connected
  to another simple node (resp., multinode).
\item Edges (encoded as multinodes) always have a simple node as
  source and a simple node as target.
\end{enumerate}

First condition above is addressed in the example of
Sec.~\ref{sec:delocalization} with graph constraint . See
Fig.~\ref{fig:simplifiedDiagram2}. The second condition can be encoded
as another graph constraint . The diagram can be found in
Fig.~\ref{fig:multidigraphGC2} and the formula is .

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.9]{figures/multidigraphGC3}
  \caption{Multidigraph Constraints}
  \label{fig:multidigraphGC2}
\end{figure}



\begin{theorem}
  \label{th:multidigraph}
  Any multidigraph is isomorphic to some simple digraph  together
  with the graph constraint .
\end{theorem}

\noindent \emph{Proof (sketch)}\\*
A graph with multiple edges 
consists of disjoint finite sets  of nodes and  of edges and
source and target functions  and , respectively.  Function , ,  returns
the node source  for edge .  We are considering multidigraphs
because the pair function  need not be
injective, i.e. several different edges may have the same source and
target nodes.  We have digraphs because there is a distinction between
source and target nodes.  This is the standard definition found in any
textbook.

It is clear that any  can be represented as a multidigraph 
satisfying .  The converse also holds.  To see it, just consider
all possible combinations of two nodes and two multinodes and check
that any problematic situation is ruled out by . Induction
finishes the proof.\proofend

The multidigraph constraint  must be fulfilled by any host graph.
If there is a production  involved,  has to be
transformed into an application condition over .  In fact, the
multidigraph constraint should be demanded both as precondition and
postcondition. This is easily achieved by means of eqs.~(\ref{eq:8})
and~(\ref{eq:9}).

This section is closed analyzing what behavior we have for
multidigraphs with respect to dangling edges.  With the theory as
developed so far, if a production specifies the deletion of a simple
node then an -production would delete any edge incident
to this simple node, connecting it to any surrounding multinode.  But
restrictions imposed by MC do not allow this so any production with
potential dangling edges can not be applied.

In order to automatically delete any potential multiple dangling edge,
-productions need to be restated by defining them at a
multidigraph level, i.e.  -productions have to delete any
potential ``dangling multinode''.  \index{x@-production}A new
type of productions (-productions) are introduced to get rid of
annoying edges\footnote{Edges connect simple nodes and multinodes.}
that would dangle when multinodes are also deleted by
-productions. We will not develop the idea in detail and
will limit to describe the concepts.  The way to proceed is to define
the appropriate operator  and redefine the operator
.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale = 0.73]{figures/spoMultidigraph}
  \caption{-production and -production}
  \label{fig:spoMultidigraph}
\end{figure}

A production  between multidigraphs that deletes
one simple node  may give rise to one -production
that deletes one or more multinodes  (those ``incident'' to 
not deleted by the grammar rule).  This -production can
in turn be applied only if any edge incident to the 's has
already been erased, hence possibly provoking the appearance of one
-production.

This process is depicted in Fig.~\ref{fig:spoMultidigraph} where, in
order to apply production , productions  and 
need to be applied in advance


Eventually, one could simply compose the -production with its
-production, renaming it to -production and
defining it as the way to deal with dangling edges in case of multiple
edges, fully recovering the standard behavior in MGG. As commented
above, a potential user of a development tool such as AToM would
still see things as in the simple digraph case, with no need to worry
about -productions.

Another theoretical use of application conditions and graph
constraints is the encoding of Turing Machines and Boolean
Circuits using Matrix Graph Grammars (see~\cite{MGGmodel}). However,
they are not necessary for Petri nets (see Chap.~10
in~\cite{MGGBook}).

\section{Conclusions and Future Work}
\label{sec:conclusions}


In the present contribution we have introduced preconditions and
postconditions for MGGs, proving that there is an equivalent set of
sequences of plain rules to any given postcondition. Besides,
coherence, compatibility and consistency of postconditions have been
characterized in terms of already known concepts for sequences. We
have also proved that it is always possible to transform any
postcondition into an equivalent precondition and vice
versa. Moreover, we have seen that restrictions are delocalized if a
sequence is under consideration. An alternative way to that
in~\cite{Hof05} to tackle variable nodes has also been proposed. This
allows us to extend MGG to cope with multidigraphs without major
modifications to the theory.

In~\cite{MGGfundamenta} there is an exhaustive comparison of the
application conditions in MGG and other proposals. The main papers to
the best of our knowledge that tackle this topic are~\cite{AC:Ehrig}
(with the definition of ACs), \cite{Habel, HP09} where GCs and ACs are
extended with nesting and satisfiability, and also~\cite{Rensink} in
which ACs are generalized to arbitrary levels of nesting (though
restricted to trees).

For future work, we shall generalize already studied concepts in MGG
for multidigraphs such as coherence, compatibility, initial digraphs,
graph congruence, reachability, etcetera. Our main interest, however,
will be focused on complexity theory and the application of MGG to the
study of complexity classes, \textbf{P} and \textbf{NP} in
particular. \cite{MGGmodel} follows this line of research.



\begin{thebibliography}{10}\label{bibliography}

\bibitem{AGG} AGG, The Attributed Graph Grammar system. {\texttt
    {http://tfs.cs.tu-berlin.de/agg/}}.

\bibitem{braket} Bra-ket notation intro:
  {\texttt{http://en.wikipedia.org/wiki/Bra-ket\_notation}}

\bibitem{DPO:handbook} Corradini, A., Montanari, U., Rossi, F., Ehrig,
  H., Heckel, R., L\"owe, M. 1999.  {\em Algebraic Approaches to Graph
    Transformation - Part I: Basic Concepts and Double Pushout
    Approach}.  In~\cite{handbook}, pp.: 163-246

\bibitem{Courcelle} Courcelle, B. 1997. \emph{The expression of graph
    properties and graph transformations in monadic second-order
    logic}.  In~\cite{handbook}, pp.: 313-400.



\bibitem{SPO:handbook} Ehrig, H., Heckel, R., Korff, M., L\"owe, M.,
  Ribeiro, L., Wagner, A., Corradini, A. 1999.  {\em Algebraic
    Approaches to Graph Transformation - Part II: Single Pushout
    Approach and Comparison with Double Pushout Approach.}
  In~\cite{handbook}, pp.: 247-312.

\bibitem{AC:Ehrig} Ehrig, H., Ehrig, K., Habel, A., Pennemann, K.-H.
  {\em Constraints and Application Conditions: From Graphs to
    High-Level Structures}.  Proc. ICGT'04. LNCS 3256, pp.: 287-303.
  Springer.

\bibitem{graGraBook} Ehrig, H., Ehrig, K., Prange, U., Taentzer, G.
  2006.  {\em Fundamentals of Algebraic Graph Transformation.}
  Springer.



\bibitem{Habel} Habel, A., Pennemann, K.-H. 2005. {\em Nested
    Constraints and Application Conditions for High-Level Structures}.
  In Formal Methods in Software and Systems Modeling, LNCS 3393, pp.
  293-308. Springer.

\bibitem{HP09} Habel, A., Penneman, K.-H. 2009. {\em Correctness of High-Level
Transformation Systems Relative to Nested
Conditions}. Math. Struct. Comp. Science 19(2), pp.: 245--296.

\bibitem{Heckel} Heckel, R., K\"uster, J.-M-., Taentzer, G. 2002.
  {\em Confluence of typed attributed graph transformation systems}.
  Proc. ICGT'02, LNCS 2505, pp. 161--176. Springer.

\bibitem{HeckelW95} Heckel, R., Wagner, A. 1995.  {\em Ensuring
    consistency of conditional graph rewriting - a constructive
    approach.}, Electr. Notes Theor. Comput. Sci. (2).

\bibitem{Hof05} Hoffman, B. 2005.  \emph{Graph Transformation with
    Variables}.  In Graph Transformation, Vol. 3393/2005 of LNCS, pp.
  101-115. Springer.

\bibitem{Lambers} Lambers, L., Ehrig, H., Orejas, F. 2006.  {\em
    Conflict Detection for Graph Transformation with Negative
    Application Conditions}.  Proc ICGT'06, LNCS 4178, pp.: 61-76.
  Springer.

\bibitem{JVLC} de Lara, J., Vangheluwe, H. 2004.  {\em Defining Visual
    Notations and Their Manipulation Through Meta-Modelling and Graph
    Transformation}.  Journal of Visual Languages and Computing.
  Special section on ``Domain-Specific Modeling with Visual
  Languages'', Vol 15(3-4), pp.: 309-330. Elsevier Science.

\bibitem{JuanPP_1} P\'erez Velasco, P. P., de Lara, J. 2006.
  \emph{Towards a New Algebraic Approach to Graph Transformation: Long
    Version.}  Tech. Rep. of the School of Comp. Sci., Univ.
  Aut\'onoma Madrid.
  {\texttt{http://www.ii.uam.es/jlara/investigacion/techrep\_03\_06.pdf}}.

\bibitem{JuanPP_2} P\'erez Velasco, P. P., de Lara, J. 2006.  {\em
    Matrix Approach to Graph Transformation: Matching and Sequences}.
  Proc ICGT'06, LNCS 4178, pp.:122-137. Springer.

\bibitem{JuanPP_4} P\'erez Velasco, P. P., de Lara, J. 2007.  {\em
    Using Matrix Graph Grammars for the Analysis of Behavioural
    Specifications: Sequential and Parallel Independence} Proc.
  PROLE'07, pp.: 11-26. Electr. Notes
  Theor. Comput. Sci. (206). pp.:133--152. Elsevier.

\bibitem{GTVC} P\'erez Velasco, P. P., de Lara, J. 2007.  {\em
    Analysing Rules with Application Conditions using Matrix Graph
    Grammars}.  Graph Transformation for Verification and Concurrency
  (GTVC) workshop.

\bibitem{MGGBook} P\'erez Velasco, P. P. 2009.  \emph{Matrix Graph
    Grammars: An Algebraic Approach to Graph Dynamics}.  ISBN
  978-3639212556. VDM Verlag. Also available as e-book at:
  {\texttt{http://www.mat2gra.info/}} and \texttt{arXiv:0801.1245v1}.

\bibitem{MGGCombinatorics} P\'erez Velasco, P. P., de Lara, J. 2009.
  \emph{A Reformulation of Matrix Graph Grammars with Boolean
    Complexes}. The Electronic Journal of Combinatorics. Vol
  16(1). R73. Available at: {\texttt{http://www.combinatorics.org/}}.

\bibitem{MGGmodel} P\'erez Velasco, P. P. 2009. \emph{Matrix Graph
    Grammars as a Model of Computation}. Preliminary version available
  at {\texttt{arXiv:0905.1202v2}}.

\bibitem{MGGfundamenta} P\'erez Velasco, P. P., de Lara,
  J. 2010. \emph{Matrix Graph Grammars with Application
    Conditions}. To appear in Fundamenta Informaticae. Also available
  at {\texttt{arXiv:0902.1809v2}}.

\bibitem{Rensink} Rensink, A. 2004. {\em Representing First-Order
    Logic Using Graphs.}  Proc. ICGT'04, LNCS 3256, pp.: 319-335.
  Springer.

\bibitem{handbook} {Rozenberg, G.} 1997.  {\em Handbook of Graph
    Grammars and Computing by Graph Transformation. Vol 1. } World
  Scientific.

\end{thebibliography}

\end{document}
