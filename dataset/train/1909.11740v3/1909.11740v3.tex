

\documentclass[runningheads]{llncs}
\usepackage{graphicx}


\usepackage{tikz}
\usepackage{comment} 
\usepackage{amsmath,amssymb} \usepackage{color}





\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{url}
\usepackage{makecell}
\usepackage{graphicx}  \usepackage{multirow}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{arydshln}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

\newcommand{\yenchun}[1]{\textcolor{blue}{\small{\bf [ #1 -- Yen-Chun ]}}}
\newcommand{\licheng}[1]{\textcolor{violet}{\small{\bf [ #1 -- Licheng ]}}}
\newcommand{\linjie}[1]{\textcolor{magenta}{\small{\bf [ #1 -- Linjie ]}}}
\newcommand{\zhe}[1]{\textcolor{blue}{\small{\bf [ #1 -- Zhe ]}}}
\newcommand{\yu}[1]{\textcolor{orange}{\small{\bf [ #1 -- Yu ]}}}
\newcommand{\jj}[1]{\textcolor{red}{\small{\bf [ #1 -- JJ ]}}}

\newcommand{\specialcell}[2][c]{\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
\newcommand{\specialcelll}[2][l]{\begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand*\rot{\rotatebox{0}}

\newcommand{\muv}{{\boldsymbol \mu}}
\newcommand{\nuv}{{\boldsymbol \nu}}
\newcommand{\av}{{\mathbf a}}
\newcommand{\bv}{{\mathbf b}}
\newcommand{\wv}{{\mathbf w}}
\newcommand{\vv}{{\mathbf v}}
\newcommand{\xv}{{\mathbf x}}
\newcommand{\yv}{{\mathbf y}}
\newcommand{\gammav}{{\boldsymbol \gamma}}
\newcommand{\Tmat}{{\bf T}}
\newcommand{\Cmat}{{\bf C}}
\newcommand{\Smat}{{\bf S}}
\newcommand{\Qmat}{{\bf Q}}
\newcommand{\Amat}{{\bf A}}

\usepackage{algorithm,algpseudocode,adjustbox}

\begin{document}
\pagestyle{headings}
\mainmatter
\def\ECCVSubNumber{7093}  

\title{UNITER: UNiversal Image-TExt Representation Learning} 

\begin{comment}
\titlerunning{ECCV-20 submission ID \ECCVSubNumber} 
\authorrunning{ECCV-20 submission ID \ECCVSubNumber} 
\author{Anonymous ECCV submission}
\institute{Paper ID \ECCVSubNumber}
\end{comment}


\titlerunning{UNITER: UNiversal Image-TExt Representation Learning}
\author{Yen-Chun Chen\thanks{Equal contribution.} \and Linjie Li \and Licheng Yu \and Ahmed El Kholy \\ Faisal Ahmed \and Zhe Gan \and Yu Cheng \and Jingjing Liu}
\authorrunning{Y.-C. Chen et al.}
\institute{Microsoft Dynamics 365 AI Research \\
\email{\{yen-chun.chen,lindsey.li,licheng.yu,ahmed.elkholy,fiahmed, zhe.gan,yu.cheng,jingjl\}@microsoft.com}}
\maketitle

\begin{abstract}
Joint image-text embedding is the bedrock for most Vision-and-Language (V+L) tasks, where multimodality inputs are simultaneously processed for joint visual and textual understanding. In this paper, we introduce UNITER, a UNiversal Image-TExt Representation, learned through large-scale pre-training over four image-text datasets (COCO, Visual Genome, Conceptual Captions, and SBU Captions), which can power heterogeneous downstream V+L tasks with joint multimodal embeddings. We design four pre-training tasks: Masked Language Modeling (MLM), Masked Region Modeling (MRM, with three variants), Image-Text Matching (ITM), and Word-Region Alignment (WRA).
Different from previous work that applies joint random masking to both modalities, we use conditional masking on pre-training tasks (\emph{i.e.}, masked language/region modeling is conditioned on full observation of image/text). In addition to ITM for global image-text alignment, we also propose WRA via the use of Optimal Transport (OT) to \emph{explicitly} encourage fine-grained alignment between words and image regions during pre-training.  
Comprehensive analysis shows that both conditional masking and OT-based WRA contribute to better pre-training.
We also conduct a thorough ablation study to find an optimal combination of pre-training tasks.
Extensive experiments show that UNITER achieves new state of the art across six V+L tasks (over nine datasets),
including Visual Question Answering, Image-Text Retrieval, Referring Expression Comprehension, Visual Commonsense Reasoning, Visual Entailment, and NLVR.\footnote{Code is available at \url{https://github.com/ChenRocks/UNITER}.}
\end{abstract}

\section{Introduction}


Most Vision-and-Language (V+L) tasks rely on joint multimodel embeddings to bridge the semantic gap between visual and textual clues in images and text, although such representations are usually tailored for specific tasks.
For example, MCB~\cite{fukui2016multimodal}, BAN~\cite{kim2018bilinear} and DFAF~\cite{gao2019dynamic} proposed advanced multimodal fusion methods for Visual Question Answering (VQA)~\cite{VQA}.
SCAN~\cite{lee2018stacked} and MAttNet~\cite{yu2018mattnet} studied learning latent alignment between words and image regions for Image-Text Retrieval~\cite{wang2016learning} and Referring Expression Comprehension~\cite{kazemzadeh2014referitgame}.
While each of these models has pushed the state of the art on respective benchmarks, their architectures are diverse and the learned representations are highly task-specific, preventing them from being generalizable to other tasks.
This raises a million-dollar question: can we learn a universal image-text representation for all V+L tasks?

In this spirit, we introduce \textbf{UN}iversal \textbf{I}mage-\textbf{TE}xt \textbf{R}epresentation \linebreak (\textbf{UNITER}), a large-scale pre-trained model for joint multimodal embedding.
We adopt Transformer~\cite{vaswani2017attention} as the core of our model, to leverage its elegant self-attention mechanism designed for learning contextualized representations.
Inspired by BERT~\cite{devlin2018bert}, 
which has successfully applied Transformer to NLP tasks through large-scale language modeling, 
we pre-train UNITER through four pre-training tasks: 
() Masked Language Modeling (MLM) \emph{conditioned on image}; () Masked Region Modeling (MRM) \emph{conditioned on text}; () Image-Text Matching (ITM); and () Word-Region Alignment (WRA).
To further investigate the effectiveness of MRM, we propose three MRM variants: () Masked Region Classification (MRC); () Masked Region Feature Regression (MRFR); and () Masked Region Classification with KL-divergence (MRC-kl). 

\begin{figure*}[!t]
\centering
  \includegraphics[width=1.0\linewidth]{figures/model.pdf}
 \caption{\small{Overview of the proposed UNITER model (best viewed in color), consisting of an Image Embedder, a Text Embedder and a multi-layer Transformer, learned through four pre-training tasks}}
  \label{fig:model}
\end{figure*} 

As shown in Figure~\ref{fig:model}, UNITER first encodes image regions (visual features and bounding box features) and textual words (tokens and positions) into a common embedding space with Image Embedder and Text Embedder. Then, a Transformer module is applied to learn generalizable contextualized embeddings for each region and each word through well-designed pre-training tasks.
Compared with previous work on multimodal pre-training~\cite{tan2019lxmert,lu2019vilbert,alberti2019fusion,li2019unicoder,su2019vl,zhou2019unified,li2019visualbert}: () our masked language/region modeling is conditioned on full observation of image/text, rather than applying joint random masking to both modalities; () we introduce a novel WRA pre-training task via the use of Optimal Transport (OT)~\cite{peyre2019computational,chen2020graph} to \emph{explicitly} encourage fine-grained alignment between words and image regions. Intuitively, OT-based learning aims to optimize for distribution matching via minimizing the cost of transporting one distribution to another. In our context, we aim to minimize the cost of transporting the embeddings from image regions to words in a sentence (and vice versa), thus optimizing towards better cross-modal alignment.
We show that both conditional masking and OT-based WRA can successfully ease the misalignment between images and text, leading to better joint embeddings for downstream tasks. 


To demonstrate the generalizable power of UNITER, we evaluate on six V+L tasks across nine datasets,
including: 
() VQA;
() Visual Commonsense Reasoning (VCR)~\cite{zellers2019recognition}; () NLVR~\cite{suhr2018corpus}; 
() Visual Entailment~\cite{xie2019visual};
() Image-Text Retrieval (including zero-shot setting)~\cite{lee2018stacked};
and 
() Referring Expression Comprehension~\cite{yu2016modeling}.
Our UNITER model is trained on a large-scale V+L dataset composed of four subsets: () COCO~\cite{lin2014microsoft}; () Visual Genome (VG)~\cite{krishna2017visual}; () Conceptual Captions (CC)~\cite{sharma2018conceptual}; and () SBU Captions~\cite{ordonez2011im2text}. Experiments show that UNITER achieves new state of the art with significant performance boost across all nine downstream datasets. Moreover, training on additional CC and SBU data (containing unseen images/text in downstream tasks) further boosts model performance over training on COCO and VG only.

Our contributions are summarized as follows: 
() We introduce UNITER, a powerful UNiversal Image-TExt Representation for V+L tasks. 
() We present Conditional Masking for masked language/region modeling, and propose a novel Optimal-Transport-based Word-Region Alignment task for pre-training.
() We achieve new state of the art on a wide range of V+L benchmarks, outperforming existing multimodal pre-training methods by a large margin. 
We also present extensive experiments and analysis to provide useful insights on the effectiveness of each pre-training task/dataset for multimodal encoder training.








 \section{Related Work}

Self-supervised learning utilizes original data as its own source of supervision, which has been applied to many Computer Vision tasks, such as
image colorization~\cite{zhang2016colorful}, solving jigsaw puzzles~\cite{noroozi2016unsupervised,trinh2019selfie}, inpainting~\cite{pathak2016context}, rotation prediction~\cite{gidaris2018unsupervised}, and relative location prediction~\cite{doersch2015unsupervised}.
Recently, pre-trained language models, such as
ELMo~\cite{peters2018deep},
BERT~\cite{devlin2018bert}, GPT2~\cite{radford2019language},
XLNet~\cite{yang2019xlnet}, RoBERTa~\cite{liu2019roberta} and ALBERT~\cite{lan2019albert}, 
have pushed great advances for NLP tasks.
There are two keys to their success: 
effective pre-training tasks over large language corpus, and the use of Transformer~\cite{vaswani2017attention} for learning contextualized text representations.

More recently, there has been a surging interest in self-supervised learning for multimodal tasks,
by pre-training on large-scale image/video and text pairs, then finetuning on downstream tasks.
For example, VideoBERT~\cite{sun2019videobert} and CBT~\cite{sun2019contrastive} applied BERT to learn a joint distribution over video frame features and linguistic tokens from video-text pairs.
ViLBERT~\cite{lu2019vilbert} and LXMERT~\cite{tan2019lxmert} introduced the two-stream architecture, where two Transformers are applied to images and text independently, which is fused by a third Transformer in a later stage.
On the other hand, B2T2~\cite{alberti2019fusion}, VisualBERT~\cite{li2019visualbert}, Unicoder-VL~\cite{li2019unicoder} and VL-BERT~\cite{su2019vl} proposed the single-stream architecture, where a single Transformer is applied to both images and text. VLP~\cite{zhou2019unified} applied pre-trained models to both image captioning and VQA. 
More recently, multi-task learning~\cite{lu201912} and adversarial training~\cite{gan2020large} were used to further boost the performance. VALUE~\cite{cao2020behind} developed a set of probing tasks to understand pre-trained models. 

\noindent \textbf{Our Contributions} The key differences between our UNITER model and the other methods are two-fold: () UNITER uses conditional masking on MLM and MRM, \emph{i.e.}, masking only one modality while keeping the other untainted; and () a novel Word-Region Alignment pre-training task via the use of Optimal Transport, while in previous work such alignment is only implicitly enforced by task-specific losses.
In addition, we examine the best combination of pre-training tasks through a thorough ablation study,
and achieve new state of the art on multiple V+L datasets, often outperforming prior work by a large margin. 

 \section{UNiversal Image-TExt Representation}
In this section, we first introduce the model architecture of UNITER (Section~\ref{subsec:overview}), then describe the  designed pre-training tasks and V+L datasets used for pre-training (Section~\ref{subsec:tasks} and \ref{subsec:datasets}).

\subsection{Model Overview}\label{subsec:overview}



The model architecture of UNITER is illustrated in Figure~\ref{fig:model}.
Given a pair of image and sentence, UNITER takes the visual regions of the image and textual tokens of the sentence as inputs.
We design an Image Embedder and a Text Embedder to extract their respective embeddings.
These embeddings are then fed into a multi-layer Transformer to learn a cross-modality contextualized embedding across visual regions and textual tokens. 
Note that the self-attention mechanism in Transformer is order-less, thus it is necessary to explicitly encode the positions of tokens and the locations of regions as additional inputs.

Specifically, in \emph{Image Embedder}, we first use Faster R-CNN\footnote{Our Faster R-CNN was pre-trained on Visual Genome object+attribute data~\cite{anderson2018bottom}.} to extract the visual features (pooled ROI features) for each region. We also encode the location features for each region via a 7-dimensional vector.\footnote{\mbox{} (normalized top/left/bottom/right coordinates, width, height, and area.)}
Both visual and location features are then fed through a fully-connected (FC) layer, to be projected into the same embedding space.
The final visual embedding for each region is obtained by summing up the two FC outputs and then passing through a layer normalization (LN) layer.
For \emph{Text Embedder}, we follow BERT~\cite{devlin2018bert} and tokenize the input sentence into WordPieces~\cite{wu2016google}.
The final representation for each sub-word token\footnote{We use word/sub-word and token interchangeably throughout the rest of the paper.} is obtained via summing up its word embedding and position embedding, followed by another LN layer.\footnote{We also use a special modality embedding to help the model distinguish between textual and visual input, which is similar to the `segment embedding' in BERT. This embedding is also summed before the LN layer in each embedder. For simplicity, this modality embedding is omitted in Figure~\ref{fig:model}.}



We introduce four main tasks to pre-train our model: Masked Language Modeling \emph{conditioned on image regions} (MLM), Masked Region Modeling \emph{conditioned on input text} (with three variants) (MRM), Image-Text Matching (ITM), and Word-Region Alignment (WRA). As shown in Figure~\ref{fig:model},
our MRM and MLM are in analogy to BERT, where we randomly mask some words or regions from the input and learn to recover the words or regions as the output of Transformer.
Specifically, word masking is realized by replacing the token with a special token \texttt{[MASK]}, and region masking is implemented by replacing the visual feature vector with all zeros.
Note that each time we only mask one modality while keeping the other modality intact, instead of randomly masking both modalities as used in other pre-training methods.
This prevents potential misalignment when a masked region happens to be described by a masked word (detailed in Section~\ref{sec:ablation_pretraining}).

We also learn an instance-level alignment between the whole image and the sentence via ITM. During training, we sample both positive and negative image-sentence pairs and learn their matching scores.
Furthermore, in order to provide a more fine-grained alignment between word tokens and image regions, we propose WRA via the use of Optimal Transport, which effectively calculates the minimum cost of transporting the contextualized image embeddings to word embeddings (and vice versa). The inferred transport plan thus serves as a propeller for better cross-modal alignment.
Empirically, we show that both conditional masking and WRA contributes to performance improvement (in Section~\ref{sec:ablation_pretraining}).
To pre-train UNITER with these tasks, we randomly sample one task for each mini-batch, and train on only one objective per SGD update.





\subsection{Pre-training Tasks}\label{subsec:tasks}

\noindent \textbf{Masked Language Modeling (MLM)} 
We denote the image regions as , the input words as , and the mask indices as .\footnote{ is the natural numbers,  is the number of masked tokens, and  is the set of masked indices.}
In MLM, we randomly mask out the input words with probability of 15\%, and replace the masked ones  with special token \texttt{[MASK]}.\footnote{Following BERT, we decompose this 15\% into 10\% random words, 10\% unchanged, and 80\% \texttt{[MASK]}.}
The goal is to predict these masked words based on the observation of their surrounding words  and all image regions , by minimizing the negative log-likelihood:

where  is the trainable parameters. 
Each pair  is sampled from the whole training set .


\noindent \textbf{Image-Text Matching (ITM)} 
In ITM, an additional special token \texttt{[CLS]} is fed into our model, which indicates the fused representation of both modalities.
The inputs to ITM are a sentence and a set of image regions, and the output is a binary label , indicating if the sampled pair is a match.
We extract the representation of \texttt{[CLS]} token as the joint representation of the input image-text pair, then feed it into an FC layer and a sigmoid function to predict a score between 0 and 1. 
We denote the output score as .
The ITM supervision is over the \texttt{[CLS]} token.\footnote{Performing this during pre-training also alleviates the mismatch problem between pre-training and downstream finetuning tasks, since most of the downstream tasks take the representation of the \texttt{[CLS]} token as the joint representation.}
During training, we sample a positive or negative pair  from the dataset  at each step.
The negative pair is created by replacing the image or text in a paired sample with a randomly-selected one from other samples.
We apply the binary cross-entropy loss for optimization:


\noindent \textbf{Word-Region Alignment (WRA)} 
We use Optimal Transport (OT) for WRA, where a transport plan  is learned to optimize the alignment between  and . OT possesses several idiosyncratic characteristics that make it a good choice for WRA:
() \emph{Self-normalization}: all the elements of  sum to 1~\cite{peyre2019computational}. () \emph{Sparsity}: when solved exactly, OT yields a sparse solution  containing  non-zero elements at most, where , leading to a more interpretable and robust alignment~\cite{peyre2019computational}. () \emph{Efficiency}: compared with conventional linear programming solvers, our solution can be readily obtained using iterative procedures that only require matrix-vector products~\cite{xie2018fast}, hence readily applicable to large-scale model pre-training.

Specifically,  can be considered as two discrete distributions , formulated as
 and , with  as the Dirac function centered on . 
The weight vectors  and  belong to the - and -dimensional simplex, respectively (\emph{i.e.}, ), as both  and  are probability distributions. The OT distance between  and  (thus also the alignment loss for the () pair) is defined as:

where ,  denotes an -dimensional all-one vector, and  is the cost function evaluating the distance between  and . In experiments, the cosine distance  is used. The matrix  is denoted as the transport plan, interpreting the alignment between two modalities. Unfortunately, the exact minimization over  is computational intractable, and we consider the IPOT algorithm~\cite{xie2018fast} to approximate the OT distance (details are provided in the supplementary file). After solving , the OT distance serves as the WRA loss that can be used to update the parameters . 


\noindent \textbf{Masked Region Modeling (MRM)} 
Similar to MLM, we also sample image regions and mask their visual features with a probability of 15\%. 
The model is trained to reconstruct the masked regions  given the remaining regions  and all the words . 
The visual features of the masked region are replaced by zeros.
Unlike textual tokens that are represented as discrete labels, visual features are high-dimensional and continuous, thus cannot be supervised via class likelihood.
Instead, we propose three variants for MRM, which share the same objective base:


1) \textbf{Masked Region Feature Regression (MRFR)} 
MRFR learns to regress the Transformer output of each masked region  to its visual features.
Specifically, we apply an FC layer to convert its Transformer output into a vector  of same dimension as the input ROI pooled feature .
Then we apply L2 regression between the two: . 


2) \textbf{Masked Region Classification (MRC)} 
MRC learns to predict the object semantic class for each masked region.
We first feed the Transformer output of the masked region  into an FC layer to predict the scores of  object classes, which further goes through a softmax function to be transformed into a normalized distribution .
Note that there is no ground-truth label, as the object categories are not provided. Thus, we use the object detection output from Faster R-CNN, and take the detected object category (with the highest confidence score) as the label of the masked region, which will be converted into a one-hot vector .
The final objective minimizes the cross-entropy (CE) loss: 
.


3) \textbf{Masked Region Classification with KL-Divergence (MRC-kl)}
MRC takes the most likely object class from the object detection model as the hard label (w.p. 0 or 1),
assuming the detected object class is the ground-truth label for the region.
However, this may not be true, as no ground-truth label is available.
Thus, in MRC-kl, we avoid this assumption by using soft label as supervision signal, which is the raw output from the detector (\emph{i.e.}, a distribution of object classes  ).
MRC-kl aims to distill such knowledge into UNITER as~\cite{hinton2015distilling}, by minimizing the KL divergence between two distributions: 
. 



\begin{table}[t!]
\centering
\small
\begin{tabular}{c  c c c c}
\hline
& \multicolumn{2}{c}{In-domain} & \multicolumn{2}{c}{Out-of-domain} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-5}
Split & COCO Captions & VG Dense Captions & Conceptual Captions & SBU Captions\\
\hline
train & 533K (106K) & 5.06M (101K) & 3.0M (3.0M) & 990K (990K) \\
val   & 25K (5K) & 106K (2.1K) & 14K (14K) & 10K (10K) \\
\hline
\end{tabular}
\caption{\small{Statistics on the datasets used for pre-training. Each cell shows \#image-text pairs (\#images)}}
\label{table:datasets}
\end{table}


\subsection{Pre-training Datasets}\label{subsec:datasets}
We construct our pre-training dataset based on four existing V+L datasets: COCO~\cite{lin2014microsoft},  Visual Genome (VG)~\cite{krishna2017visual}, Conceptual Captions (CC)~\cite{sharma2018conceptual}, and SBU Captions~\cite{ordonez2011im2text}.
Only image and sentence pairs are used for pre-training, which makes the model framework more scalable, as additional image-sentence pairs are easy to harvest for further pre-training.

To study the effects of different datasets on pre-training, we divide the four datasets into two categories.
The first one consists of image captioning data from COCO and dense captioning data from VG.
We call it ``In-domain" data, as most V+L tasks are built on top of these two datasets.
To obtain a ``fair'' data split, we merge the raw training and validation splits from COCO, and exclude all validation and test images that appear in downstream tasks.
We also exclude all co-occurring Flickr30K~\cite{plummer2015flickr30k} images via URL matching, as both COCO and Flickr30K images were crawled from Flickr and may have overlaps.\footnote{A total of 222 images were eliminated through this process.}
The same rule was applied to Visual Genome as well. In this way, we obtain 5.6M image-text pairs for training and 131K image-text pairs for our internal validation, which is half the size of the dataset used in LXMERT~\cite{tan2019lxmert}, due to the filtering of overlapping images and the use of image-text pairs only.
We also use additional Out-of-domain data from Conceptual Captions~\cite{sharma2018conceptual} and SBU Captions~\cite{ordonez2011im2text} for model training.\footnote{We apply the same URL matching method, excluding 109 images from training.} The statistics on the cleaned splits are provided in Table~\ref{table:datasets}.

 \section{Experiments}



We evaluate UNITER on six V+L tasks\footnote{VQA, VCR, NLVR, Visual Entailment, Image-Text Retrieval, and Referring Expression Comprehension. Details about the tasks are listed in the supplementary.}
by transferring the pre-trained model to each target task and finetuning through end-to-end training. 
We report experimental results on two model sizes: UNITER-base with 12 layers and UNITER-large with 24 layers.\footnote{UNITER-base: L=12, H=768, A=12, Total Parameters=86M. UNITER-large: L=24, H=1024, A=16, Total Parameters=303M (L: number of stacked Transformer blocks; H: hidden activation dimension; A: number of attention heads).  and  V100 GPU hours were used for pre-training UNITER-base and UNITER-large.}






\begin{table*}[t!]
\centering
\small
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l p{0.02\textwidth} l c  c  c c c c }
\hline
Pre-training Data & & Pre-training Tasks& Meta-Sum & VQA & \specialcell{IR\\\scriptsize{(Flickr)}} & \specialcell{TR\\\scriptsize{(Flickr)}} & NLVR & \specialcell{Ref- \\COCO+ } \\ 
 \cmidrule(lr){5-5} \cmidrule(lr){6-6} \cmidrule(lr){7-7} \cmidrule(lr){8-8} \cmidrule(lr){9-9}  
& & &  & test-dev & val & val & dev & val\\
\hline
 \scriptsize{None} & \scriptsize{1} & \scriptsize{None} & 314.34 & 67.03 & 61.74 & 65.55 & 51.02 &68.73\\
\hline
\specialcelll{\scriptsize{Wikipedia +}\\ \scriptsize{BookCorpus}} & \scriptsize{2} & \scriptsize{MLM (text only)} & 346.24 & 69.39 & 73.92 & 83.27 & 50.86 & 68.80\\
\hline
\multirow{9}{*}{\specialcelll{\scriptsize{In-domain}\\\scriptsize{(COCO+VG)}}} & \scriptsize{3} & \scriptsize{MRFR} & 344.66 & 69.02 & 72.10 & 82.91 & 52.16 & 68.47\\
& \scriptsize{4} &\scriptsize{ITM} & 385.29 & 70.04 & 78.93 & 89.91 & 74.08 &72.33\\
& \scriptsize{5} & \scriptsize{MLM} & 386.10  & 71.29 & 77.88 & 89.25 & 74.79 & 72.89\\

& \scriptsize{6} & \scriptsize{MLM + ITM} &393.04 & 71.55 & 81.64 & 91.12 & 75.98 & 72.75\\
& \scriptsize{7} & \scriptsize{MLM + ITM + MRC} & 393.97 & 71.46 & 81.39 & 91.45 & 76.18 & 73.49\\
& \scriptsize{8} & \scriptsize{MLM + ITM + MRFR} &396.24 & 71.73 & 81.76 & 92.31 & 76.21  & 74.23\\
& \scriptsize{9} & \scriptsize{MLM + ITM + MRC-kl} & 397.09 & 71.63 &  82.10 & 92.57 & 76.28 & 74.51\\
& \scriptsize{10} &\scriptsize{MLM + ITM + MRC-kl + MRFR} & \cellcolor[gray]{.8}399.97 & \cellcolor[gray]{.8}71.92 & \cellcolor[gray]{.6}83.73 & \cellcolor[gray]{.8} 92.87 & \cellcolor[gray]{.6}76.93 & \cellcolor[gray]{.8}74.52\\
& \scriptsize{11} &\scriptsize{MLM + ITM + MRC-kl + MRFR + WRA} & \cellcolor[gray]{.6}400.93 & \cellcolor[gray]{.6}72.47 & \cellcolor[gray]{.8}83.72 & \cellcolor[gray]{.6} 93.03 & \cellcolor[gray]{.8}76.91 & \cellcolor[gray]{.6}74.80 \\
\cline{2-9}
& \scriptsize{12} &\specialcelll{\scriptsize{MLM + ITM + MRC-kl + MRFR}\\ \scriptsize{ (w/o cond. mask)}} & 396.51 & 71.68 & 82.31 & 92.08 & 76.15 & 74.29\\
\hline
\specialcelll{\scriptsize{Out-of-domain}\\\scriptsize{(SBU+CC)}} & \scriptsize{13} & \scriptsize{MLM + ITM + MRC-kl + MRFR + WRA}& 396.91  & 71.56 & 84.34 & 92.57 & 75.66 & 72.78  \\
\hline
\specialcelll{\scriptsize{In-domain +}\\\scriptsize{Out-of-domain}} & \scriptsize{14} & \scriptsize{MLM + ITM + MRC-kl + MRFR + WRA}& \textbf{405.24} & \textbf{72.70} & \textbf{85.77} & \textbf{94.28} & \textbf{77.18} & \textbf{75.31}  \\
\hline
\end{tabular}
}
\caption{\small{Evaluation on pre-training tasks and datasets using VQA, Image-Text Retrieval on Flickr30K, NLVR, and RefCOCO+ as benchmarks. All results are obtained from UNITER-base. Averages of R@1, R@5 and R@10 on Flickr30K for Image Retrieval (IR) and Text Retrieval (TR) are reported. Dark and light grey colors highlight the top and second best results across all the tasks trained with In-domain data}}
\label{table:ablation_study}
\end{table*}

 
\subsection{Downstream Tasks}\label{sec:downstream}
In VQA, VCR and NLVR tasks, given an input image (or a pair of images) and a natural language question (or description), the model predicts an answer (or judges the correctness of the description) based on the visual content in the image. 
For Visual Entailment, we evaluate on the SNLI-VE dataset. The goal is to predict whether a given image semantically entails an input sentence. Classification accuracy over three classes (``Entailment", ``Neutral" and ``Contradiction") is used to measure model performance. 
For Image-Text Retrieval, we consider two datasets (COCO and Flickr30K) and evaluate the model in two settings: Image Retrieval (IR) and Text Retrieval (TR).
Referring Expression (RE) Comprehension requires the model to select the target from a set of image region proposals given the query description.
Models are evaluated on both ground-truth objects and detected proposals\footnote{The evaluation splits of RE comprehension using detected proposals are denoted as val, test, etc.} (MAttNet~\cite{yu2018mattnet}).


For VQA, VCR, NLVR, Visual Entailment and Image-Text Retrieval, we extract the joint embedding of the input image-text pairs via a multi-layer perceptron (MLP) from the representation of the \texttt{[CLS]} token. For RE Comprehension, we use the MLP to compute the region-wise alignment scores. These MLP layers are learned during the finetuning stage.
Specifically, we formulate VQA, VCR, NLVR, Visual Entailment and RE Comprehension as classification problems and minimize the cross-entropy over the ground-truth answers/responses. 
For Image-Text Retrieval, we formulate it as a ranking problem. 
During finetuning, we sample three pairs of image and text, one positive pair from the dataset and two negative pairs by randomly replacing its sentence/image with others.
We compute the similarity scores (based on the joint embedding) for both positive and negative pairs, and maximize the margin between them through triplet loss. 

\subsection{Evaluation on Pre-training Tasks}\label{sec:ablation_pretraining}
We analyze the effectiveness of different pre-training settings through ablation studies over VQA, NLVR, Flickr30K and RefCOCO+ as representative V+L benchmarks.
In addition to standard metrics\footnote{Details about the metrics are listed in the supplementary.} for each benchmark
, we also use Meta-Sum (sum of all the scores across all the benchmarks) as a global metric. 


Firstly, we establish two baselines:
Line 1 (L1) in Table~\ref{table:ablation_study} indicates no pre-training is involved, and L2 shows the results from MLM initialized with pre-trained weights from~\cite{devlin2018bert}.
Although MLM trained on text only did not absorb any image information during pre-training, we see a gain of approximately +30 on Meta-Sum over L1. 
Hence, 
we use the pre-trained weights in L2 to initialize our model for the following experiments.

Secondly, we validate the effectiveness of each pre-training task through a thorough ablation study. 
Comparing L2 and L3, MRFR (L3) achieves better results than MLM (L2) only on NLVR.
On the other hand, when pre-trained on ITM (L4) or MLM (L5) only, we observe a significant improvement across all the tasks over L1 and L2 baselines. 
When combining different pre-training tasks, MLM + ITM (L6) improves over single ITM (L4) or MLM (L5). 
When MLM, ITM and MRM are jointly trained (L7-L10), we observe consistent performance gain across all the benchmarks. 
Among the three variants of MRM (L7-L9), we observe that MRC-kl (L9) achieves the best performance (397.09) when combined with MLM + ITM, while MRC (L7) the worst (393.97). 
When combining MRC-kl and MRFR together with MLM and ITM (L10), we find that they are complimentary to each other, which leads to the second highest Meta-Sum score. 
The highest Meta-Sum Score is achieved by MLM + ITM + MRC-kl + MRFR + WRA (L11). 
We observe significant performance improvements from adding WRA, especially on VQA and RefCOCO+.
It indicates the fine-grained alignment between words and regions learned through WRA during pre-training benefits the downstream tasks involving region-level recognition or reasoning. 
We use this optimal pre-training setting for the further experiments. 

Additionally, we validate the contributions of conditional masking through a comparison study. When we perform random masking on both modalities simultaneously during pre-training, \emph{i.e.}, w/o conditional masking (L12), we observe a decrease in Meta-Sum score (396.51) compared to that with conditional masking (399.97). This indicates that the conditional masking strategy enables the model to learn better joint image-text representations effectively.


Lastly, we study the effects of pre-training datasets. Our experiments so far have been focused on In-domain data. In this study, we pre-train our model on Out-of-domain data (Conceptual Captions + SBU Captions). A performance drop (396.91 in L13) from the model trained on In-domain data (COCO + Visual Genome) (400.93 in L11) shows that although Out-of-domain data contain more images, the model still benefits more from being exposed to similar downstream images during pre-training. 
We further pre-train our model on both In-domain and Out-of-domain data. 
With doubled data size, the model continues to improve (405.24 in L14).




\begin{table*}[t!]
\centering
\small
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l l | cc c c c c  | c c }
\Xhline{1pt}
\multicolumn{2}{c|}{\multirow{2}{*}{Tasks}} &\multirow{2}{*}{\footnotesize{SOTA}} & \multirow{2}{*}{\footnotesize{ViLBERT}} & VLBERT & Unicoder & \multirow{2}{*}{\footnotesize{VisualBERT}} &\multirow{2}{*}{LXMERT} & \multicolumn{2}{c}{UNITER}\\
& & & & (Large) & -VL & & & Base & Large\\
\Xhline{1pt}
\multirow{2}{*}{\small{VQA}} & test-dev & 70.63 & 70.55& 71.79& - & 70.80 &  72.42& \cellcolor[gray]{.8}72.70 & \cellcolor[gray]{.6}\textbf{73.82}\\
 & test-std & 70.90  & 70.92 & 72.22 & - &71.00&  72.54 & \cellcolor[gray]{.8}72.91 & \cellcolor[gray]{.6}\textbf{74.02}\\
\hline
 \multirow{3}{*}{\specialcelll{VCR}} & QA &72.60 &  73.30& \cellcolor[gray]{.8}75.80& -  & 71.60 &  - & 75.00 & \cellcolor[gray]{.6}\textbf{77.30}\\
 & QAR & 75.70 &74.60 & \cellcolor[gray]{.8}78.40 &-& 73.20 &  -& 77.20 & \cellcolor[gray]{.6}\textbf{80.80}\\
  & QAR & 55.00&54.80 & \cellcolor[gray]{.8}59.70  & - & 52.40& -& 58.20 & \cellcolor[gray]{.6}\textbf{62.80}\\
 \hline
 \multirow{2}{*}{\small{NLVR}} & dev & 54.80& -& - & - & 67.40 & 74.90& \cellcolor[gray]{.8}77.18 & \cellcolor[gray]{.6}\textbf{79.12}\\
 & test-P & 53.50 & - & - & - &67.00& 74.50& \cellcolor[gray]{.8}77.85 & \cellcolor[gray]{.6}\textbf{79.98}\\
\hline
\multirow{2}{*}{\specialcelll{SNLI-\\VE}} & val & 71.56 & - & - & - & - & - & \cellcolor[gray]{.8}78.59 & \cellcolor[gray]{.6}\textbf{79.39}\\
& test & 71.16 & - & - & - & - & - & \cellcolor[gray]{.8}78.28 & \cellcolor[gray]{.6}\textbf{79.38}\\
\hline
 \multirow{3}{*}{\specialcelll{ZS IR\\  \scriptsize{(Flickr)}}} & R@1 & - & 31.86& -& 48.40 & - & - & \cellcolor[gray]{.8}66.16 & \cellcolor[gray]{.6}\textbf{68.74}\\
 & R@5 & - & 61.12 & - & 76.00&-& -& \cellcolor[gray]{.8}88.40 & \cellcolor[gray]{.6}\textbf{89.20}\\
  & R@10 & - & 72.80 & - & 85.20 &-& -& \cellcolor[gray]{.8}92.94 & \cellcolor[gray]{.6}\textbf{93.86}\\
\hline

 \multirow{3}{*}{\specialcelll{IR\\  \scriptsize{(Flickr)}}} & R@1 & 48.60 & 58.20& -& 71.50 & - & - & \cellcolor[gray]{.8} 72.52 & \cellcolor[gray]{.6}\textbf{75.56}\\
 & R@5 & 77.70 & 84.90 & - & 91.20 &-& -& \cellcolor[gray]{.8} 92.36 & \cellcolor[gray]{.6}\textbf{94.08}\\
  & R@10 & 85.20 & 91.52 & - & 95.20 &-& -& \cellcolor[gray]{.8} 96.08 & \cellcolor[gray]{.6}\textbf{96.76}\\
\hline
 \multirow{3}{*}{\specialcelll{IR\\  \scriptsize{(COCO)}}} & R@1 & 38.60 & -& -& 48.40 & - & - & \cellcolor[gray]{.8}50.33& \cellcolor[gray]{.6}\textbf{52.93}\\
 & R@5 & 69.30 & - & - & 76.70 &-& -& \cellcolor[gray]{.8}78.52 & \cellcolor[gray]{.6}\textbf{79.93}\\
  & R@10 & 80.40 & - & - & 85.90 &-& -& \cellcolor[gray]{.8}87.16 & \cellcolor[gray]{.6}\textbf{87.95}\\
\hline
 \multirow{3}{*}{\specialcelll{ZS TR\\ \scriptsize{(Flickr)}}} & R@1 & - & - & -& 64.30 & - & - & \cellcolor[gray]{.8}80.70 &\cellcolor[gray]{.6}\textbf{83.60}\\
 & R@5 & - & - & - & 85.80 &-& -& \cellcolor[gray]{.6}\textbf{95.70} & \cellcolor[gray]{.6}\textbf{95.70}\\
  & R@10 & - & - & - & 92.30 &-& -& \cellcolor[gray]{.6}\textbf{98.00} &\cellcolor[gray]{.8}97.70\\
\hline
 \multirow{3}{*}{\specialcelll{TR\\  \scriptsize{(Flickr)}}} & R@1 & 67.90 & -& -& \cellcolor[gray]{.8}86.20 & - & - & 85.90 & \cellcolor[gray]{.6}\textbf{87.30}\\
 & R@5 & 90.30 & - & - & 96.30 &-& -& \cellcolor[gray]{.8}97.10 & \cellcolor[gray]{.6}\textbf{98.00}\\
  & R@10 & 95.80 & - & - & \cellcolor[gray]{.8}99.00 &-& -& 98.80 &\cellcolor[gray]{.6}\textbf{99.20}\\
\hline
 \multirow{3}{*}{\specialcelll{TR\\  \scriptsize{(COCO)}}} & R@1 & 50.40 & -& -& 62.30 & - & - & \cellcolor[gray]{.8}64.40& \cellcolor[gray]{.6}\textbf{65.68}\\
 & R@5 & 82.20 & - & - & 87.10 &-& -& \cellcolor[gray]{.8}87.40 & \cellcolor[gray]{.6}\textbf{88.56}\\
  & R@10 & 90.00 & - & - & 92.80 &-& -& \cellcolor[gray]{.8}93.08 & \cellcolor[gray]{.6}\textbf{93.76}\\

\hline
 \multirow{6}{*}{\specialcelll{Ref-\\COCO}} 
 & val & 87.51 & & - & - & - & - & \cellcolor[gray]{.8}91.64 &\cellcolor[gray]{.6}\textbf{91.84}\\
 & testA & 89.02 & - & - & -&-& - & \cellcolor[gray]{.8}92.26 & \cellcolor[gray]{.6}\textbf{92.65}\\
 & testB & 87.05 & - & - & - &-& - & \cellcolor[gray]{.8}90.46 & \cellcolor[gray]{.6}\textbf{91.19}\\
 \cline{2-10}
 & val & 77.48 & - & -& - & - & - & \cellcolor[gray]{.8}81.24 &\cellcolor[gray]{.6}\textbf{81.41}\\
 & testA & 83.37 & - & - & -&-& - & \cellcolor[gray]{.8}86.48 & \cellcolor[gray]{.6}\textbf{87.04}\\
 & testB & 70.32 & - & - & - &-& -& \cellcolor[gray]{.8}73.94 & \cellcolor[gray]{.6}\textbf{74.17}\\
\hline
 \multirow{6}{*}{\specialcelll{Ref-\\COCO+}} 
 & val & 75.38 & - & 80.31 & - & - & - & \cellcolor[gray]{.8}83.66 &\cellcolor[gray]{.6}\textbf{84.25}\\
 & testA & 80.04 & - & 83.62 & -&-&  - & \cellcolor[gray]{.8}86.19 & \cellcolor[gray]{.6}\textbf{86.34
}\\
 & testB & 69.30 & - & 75.45 & - &-& - & \cellcolor[gray]{.8}78.89 & \cellcolor[gray]{.6}\textbf{79.75}\\
 \cline{2-10}
 & val & 68.19 & 72.34& 72.59& - & - & - & \cellcolor[gray]{.8}75.31 &\cellcolor[gray]{.6}\textbf{75.90}\\
 & testA & 75.97 & 78.52 & 78.57 & -&-& -& \cellcolor[gray]{.8}81.30 & \cellcolor[gray]{.6}\textbf{81.45
}\\
 & testB & 57.52 & 62.61 & 62.30 & - &-& -& \cellcolor[gray]{.8}65.58 & \cellcolor[gray]{.6}\textbf{66.70}\\
\hline
 \multirow{4}{*}{\specialcelll{Ref-\\COCOg}} 
 & val & 81.76 & - & -& - & - & - & \cellcolor[gray]{.8}86.52 &\cellcolor[gray]{.6}\textbf{87.85}\\
 & test & 81.75 & - & - & -&-& - & \cellcolor[gray]{.8}86.52 & \cellcolor[gray]{.6}\textbf{87.73}\\
 \cline{2-10}
 & val & 68.22 & - & -& - & - & - & \cellcolor[gray]{.8}74.31 &\cellcolor[gray]{.6}\textbf{74.86}\\
 & test & 69.46 & - & - & -&-& - & \cellcolor[gray]{.8}74.51 & \cellcolor[gray]{.6}\textbf{75.77}\\
\Xhline{1pt}
\end{tabular}
}
\caption{\small{Results on downstream V+L tasks from UNITER model, compared with task-specific state-of-the-art (SOTA) and previous pre-trained models. ZS: Zero-Shot, IR: Image Retrieval and TR: Text Retrieval}}
\label{tab:results}
\end{table*}



 
\subsection{Results on Downstream Tasks}

Table~\ref{tab:results} presents the results of UNITER on all downstream tasks. 
Both our base and large models are pre-trained on In-domain+Out-of-domain datasets, with the optimal pre-training setting: MLM+ITM+MRC-kl+MRFR+WRA. The implementation details of each task are provided in the supplementary file.
We compare with both task-specific models and other pre-trained models on each downstream task. 
SOTA task-specific models include: MCAN~\cite{Yu_2019_CVPR} for VQA, MaxEnt~\cite{suhr2018corpus} for NLVR,  B2T2~\cite{alberti2019fusion} for VCR, SCAN~\cite{lee2018stacked} for Image-Text Retrieval, EVE-Image~\cite{xie2019visual} for SNLI-VE, and MAttNet for RE Comprehension (RefCOCO, RefCOCO+ and RefCOCOg).\footnote{MAttNet results are updated using the same features as the others. More details are provided in the supplementary file.}
Other pre-trained models include: ViLBERT~\cite{lu2019vilbert}, LXMERT~\cite{tan2019lxmert}, Unicoder-VL~\cite{li2019unicoder}, VisualBERT~\cite{li2019visualbert} and VLBERT~\cite{su2019vl}. 

Results show that our UNITER-large model achieves new state of the art across all the benchmarks. 
UNITER-base model also outperforms the others by a large margin across all tasks except VQA.
Specifically, our UNITER-base model outperforms SOTA  by approximately  for VCR on QAR,  for NLVR,  for SNLI-VE,   on R@1 for Image-Text Retrieval ( for zero-shot setting), and  for RE Comprehension.



Note that LXMERT pre-trains with downstream VQA (+VG+GQA) data, which may help adapt the model to VQA task. However, when evaluated on unseen tasks such as NLVR, UNITER-base achieves 3\% gain over LXMERT. 
In addition, among all the models pre-trained on image-text pairs only, our UNITER-base outperforms the others by \textgreater  on VQA.

It is also worth mentioning that both VilBERT and LXMERT observed two-stream model outperforms single-stream model, while our results show empirically that with our pre-training setting, single-stream model can achieve new state-of-the-art results, with much fewer parameters (UNITER-base: 86M, LXMERT: 183M, VilBERT: 221M).\footnote{The word embedding layer contains excessive rare words, thus excluded from the parameter counts.}
 



\begin{table}[!t]
\begin{minipage}{.52\linewidth}
    \centering
    \small
\begin{tabular}{c c |c c c}
        \hline
          Stage I & Stage II & QA & QA R & Q  AR \\
         \hline
          N & N & 72.44& 73.71& 53.52\\
          N & Y & 73.52 & 75.34 & 55.6 \\
          \hline
          Y & N & 72.83 & 75.25 & 54.94\\
          Y & Y & \textbf{74.56} & \textbf{77.03} & \textbf{57.76}\\
         \hline
    \end{tabular}
    \caption{\small{Experiments on two-stage pre-training for VCR. Results are from UNITER-base on VCR val split. Stage I and Stage II denote first-stage and second-stage pre-training}}
    \label{tab:vcr}
\end{minipage}\hfill
\begin{minipage}{.42\linewidth}
    \centering
    \small
\begin{tabular}{l c c}
        \hline
         Setting & dev & test-P \\
         \hline
         Triplet & 73.03 & 73.89 \\
         Pair & 75.85 & 75.80 \\
         \hline
         Pair-biattn & \textbf{77.18} & \textbf{77.85}\\
         \hline
    \end{tabular}
\caption{\small{Experiments on three modified settings for NLVR. All models use pre-trained UNITER-base}}
    \label{tab:nlvr2}
\end{minipage}
\end{table} 
For VCR, we propose a two-stage pre-training approach: () pre-train on standard pre-training datasets; and then () pre-train on downstream VCR dataset. 
Interestingly, while VLBERT and B2T2 observed that pre-training is not very helpful on VCR, we find that the second-stage pre-training can significantly boost model performance, while the first-stage pre-training still helps but with limited effects (results shown in Table~\ref{tab:vcr}). This indicates that the proposed two-stage approach is highly effective in our pre-trained model over new data that are unseen in pre-training datasets.


Different from other tasks, NLVR takes two images as input. Thus, directly finetuning UNITER pre-trained with image-sentence pairs might not lead to optimal performance, as the interactions between paired images are not learned during the pre-training stage. Thus, we experimented with three modified settings on NLVR: () \emph{Triplet}: joint embedding of images pairs and query captions; () \emph{Pair}: individual embedding of each image and each query caption; and () \emph{Pair-biattn}: a bidirectional attention is added to the \emph{Pair} model to learn the interactions between the paired images. 

Comparison results are presented in Table~\ref{tab:nlvr2}. The \emph{Pair} setting achieves better performance than the \emph{Triplet} setting even without cross-attention between the image pairs. We hypothesize that it is due to the fact that our UNITER is pre-trained with image-text pairs. Thus, it is difficult to finetune a pair-based pre-trained model on triplet input. The bidirectional attention mechanism in the \emph{Pair-biattn} setting, however, compensates the lack of cross-attention between images, hence yielding the best performance with a large margin. This show that with minimal surgery on the top layer of UNITER, our pre-trained model can adapt to new tasks that are very different from pre-training tasks.

\begin{figure}[t!]
     \centering
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/vertical.pdf}
         \caption{Vertical}
         \label{subfig:vertical}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/diagnal.pdf}
         \caption{Diagonal}
         \label{subfig:diagonal}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/vnd.pdf}
         \caption{Vertical + Diagonal}
         \label{subfig:vnd}
     \end{subfigure}
        
     
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/block.pdf}
         \caption{Block}
         \label{subfig:block}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/heterogeneous.pdf}
         \caption{Heterogeneous}
         \label{subfig:heter}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.32\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/heatmaps/rblock.pdf}
         \caption{Reversed Block}
         \label{subfig:rblock}
     \end{subfigure}
\caption{\small{Visualization of the attention maps learned by the UNITER-base model}}
\label{fig:heatmaps}
\end{figure} 
\begin{figure*}[!t]
  \includegraphics[width=1.0\linewidth]{figures/attn_vis/example1.png} \\
 \caption{\small{Text-to-image attention visualization example}}
  \label{fig:vis1}
\end{figure*} 
 \subsection{Visualization} \label{sec:vis}
Similar to~\cite{kovaleva2019revealing}, we observe several patterns in the attention maps of the UNITER model, as shown in Fig.~\ref{fig:heatmaps}.
Note that different from~\cite{kovaleva2019revealing}, our attention mechanism operates in both inter- and intra-modalitiy manners.
For completeness, we briefly discuss each pattern here:
\begin{itemize}
  \item \textit{Vertical}: attention to special tokens \texttt{[CLS]} or \texttt{[SEP]};
  \item \textit{Diagonal}: attention to the token/region itself or preceding/following tokens/regions;
  \item \textit{Vertical + Diagonal}: mixture of vertical and diagonal;
  \item \textit{Block}: intra-modality attention, \textit{i.e.}, textual self-attention and visual self-attention;
  \item \textit{Heterogeneous}: diverse attentions that cannot be categorized and is highly dependent on actual input;
  \item \textit{Reversed Block}: inter-modality attention, \textit{i.e.}, text-to-image and image-to-text attention.
\end{itemize}
Note that \textit{Reversed Block}~(Fig.~\ref{subfig:rblock}) shows cross-modality alignment between tokens and regions.
In Fig.~\ref{fig:vis1}, we visualize several examples of text-to-image attention to demonstrate the local cross-modality alignment between regions and tokens.

\section{Conclusion}
In this paper, we present UNITER, a large-scale pre-trained model providing UNiversal Image-TExt Representations for Vision-and-Language tasks. Four main pre-training tasks are proposed and evaluated through extensive ablation studies. 
Trained with both in-domain and out-of-domain datasets, UNITER outperforms state-of-the-art models over multiple V+L tasks by a significant margin.
Future work includes studying early interaction between raw image pixels and sentence tokens, as well as developing more effective pre-training tasks. 
\clearpage
\bibliographystyle{splncs04}
\bibliography{egbib}

\newpage
\appendix
\section{Appendix}

This supplementary material has eight sections. Section~\ref{sec:dataset_collection} describes the details of our dataset collection. Section~\ref{sec:implementation} describes our implementation details for each downstream task. Section~\ref{sec:conditional_masking} provides detailed quantitative comparison between conditional masking and joint random masking. Section~\ref{sec:more_results_vcr_nlvr2} provides more results on VCR and NLVR. Section~\ref{sec:comparison_vlbert} provides a direct comparison to VLBERT and ViLBERT. Section~\ref{sec:ot_ipot} provides some background on optimal transport (OT) and the IPOT algorithm that is used to calculate the OT distance. Section~\ref{sec:addtional_viz} provides additional visualization example.


\subsection{Dataset Collection} \label{sec:dataset_collection}
As introduced, our full dataset is composed of four existing V+L datasets: COCO,  Visual Genome, Conceptual Captions, and SBU Captions.
The dataset collection is not simply combining them, as we need to make sure none of the downstream evaluation images are seen during pre-training.
Among them, COCO is the most tricky one to clean, as several downstream tasks are built based on it.
Figure~\ref{fig:coco_splits} lists the splits from VQA, Image-Text Retrieval, COCO Captioning, RefCOCO/RefCOCO+/RefCOCOg, and the bottom-up top-down (BUTD) detection~\cite{anderson2018bottom}, all from COCO images.

As observed, the validation and test splits of different tasks are scattered across the raw COCO splits.
Therefore, we exclude all those evaluation images that appeared in the downstream tasks.
In addition, we also exclude all co-occurring Flickr30K images via URL matching, making sure the zero-shot image-text retrieval evaluation on Flickr is fair.
The remaining images become the COCO subset within our full dataset, as shown in Figure~\ref{fig:coco_splits} bottom row.
We apply the same rules to Visual Genome, Conceptual Captions, and SBU Captions.

\begin{figure*}[!h]
\centering
\includegraphics[width=0.95\linewidth]{figures/in_domain_data.pdf}
\caption{\small{Different data splits from downstream tasks based on COCO images. Our UNITER pre-training avoids seeing any downstream evaluation images}}
\label{fig:coco_splits}
\vspace{-10mm}
\end{figure*}

\begin{table*}[t!]
\centering
\small
\begin{tabular}{l l l  l c  c  l }
\arrayrulecolor{black}\hline
 & Task & Datasets & Image Src. & \#Images & \#Text & Metric \\ 
\arrayrulecolor{black}\hline
1 & VQA & VQA & COCO & 204K  & 1.1M &VQA-score\\
\noalign{\global\arrayrulewidth=0.01mm}
\arrayrulecolor{gray}\hline
2 & VCR & VCR & Movie Clips & 110K &  290K & Accuracy\\
\noalign{\global\arrayrulewidth=0.01mm}
\arrayrulecolor{gray}\hline
3 & NLVR & NLVR & Web Crawled & 214K & 107K & Accuracy \\
\noalign{\global\arrayrulewidth=0.01mm}
\arrayrulecolor{gray}\hline
4 & Visual Entailment & SNLI-VE & Flickr30K & 31K & 507K & Accuracy \\
\noalign{\global\arrayrulewidth=0.01mm}
\arrayrulecolor{gray}\hline
\multirow{2}{*}{5} & \multirow{2}{*}{Image-Text Retrieval} & COCO & COCO & 92K & 460K &\multirow{2}{*}{Recall@1,5,10} \\
& & Flickr30K & Flickr30K & 32K & 160K & \\
\noalign{\global\arrayrulewidth=0.01mm}
\arrayrulecolor{gray}\hline
\multirow{3}{*}{6} & \multirow{3}{*}{RE Comprehension} & RefCOCO & \multirow{3}{*}{COCO} & 20K & 142K & \multirow{3}{*}{Accuracy}\\
& & RefCOCO+ & & 20K & 142K &\\
& & RefCOCOg & & 26K & 95K & \\
\arrayrulecolor{black}\hline
\end{tabular}
\caption{\small{Statistics on the datasets of downstream tasks }}
\label{table:downstream_dataset}
\vspace{-20pt}
\end{table*}

 \subsection{Implementation Details} \label{sec:implementation}
Our models are implemented based on PyTorch\footnote{https://pytorch.org/}~\cite{paszke2017automatic}. To speed up training, we use Nvidia Apex\footnote{https://github.com/NVIDIA/apex} for mixed precision training.
All pre-training experiments are run on Nvidia V100 GPUs (16GB VRAM; PCIe connection).
Finetuning experiments are implemented on the same hardware or Titan RTX GPUs (24GB VRAM).
To further speed up training, we implement dynamic sequence length to reduce padding and batch examples by number of input units (text tokens + image regions).
For large pre-training experiments, we use Horovod\footnote{https://github.com/horovod/horovod} + NCCL\footnote{https://github.com/NVIDIA/nccl} for multi-node communications (on TCP connections through ethernet) with up to 4 nodes of 4x V100 server.
Gradient accumulation~\cite{ott2018scaling} is also applied to reduce multi-GPU communication overheads.

\vspace{5pt}
\noindent \textbf{Visual Question Answering (VQA)} 
We follow~\cite{Yu_2019_CVPR} to take  most frequent answers as answer candidates, and assign a soft target score to each candidate based on its relevancy to the  human responses. To finetune on VQA dataset, we use a binary cross-entropy loss to train a multi-label classifier using batch size of  input units over maximum K steps. We use AdamW optimizer \cite{AdamW} with a learning rate of  and weight decay of . At inference time, the max-probable answer is selected as the predicted answer. For results on \texttt{test-dev} and \texttt{test-std} splits, both training and validation sets are used for training, and additional question-answer pairs from Visual Genome are used for data augmentation as in \cite{Yu_2019_CVPR}. 


\vspace{5pt}
\noindent \textbf{Visual Commonsense Reasoning (VCR)} 
VCR can be decomposed into two multiple-choice sub-tasks: question-answering task (Q  A) and answer-justification task (QA  R). In the holistic setting (Q  AR), a model needs to first choose an answer from the answer choices, then select a supporting rationale from rationale choices if the chosen answer is correct. We train our model in two settings simultaneously. When testing in the holistic setting, we first apply the model to predict an answer, then obtain the rationale from the same model based on the given question and the predicted answer. To finetune on VCR dataset, we concatenate the question (the qeustion and the ground truth answer) and each answer (rationale) choice  from the four possible answer (rationale) candidates. The `modality embedding' is extended to help distinguish question, answer and rationale. Cross-entropy loss is used to train a classifier over two classes (\texttt{``right''} or \texttt{``wrong''}) for each question-answer pair (question-answer-rationale triplet) with a batch size of 4096 input units over maximum K steps. We use AdamW optimizer with a learning rate of  and weight decay of . 

Since the images and text in VCR dataset are very different from our pre-training dataset, we further pre-train our model on VCR, using MLM, MRFR and MRC-kl as the pre-training tasks. ITM is discarded because the text in VCR does not explicitly describe the image. The results of both pre-trainings on VCR are reported in Table~\ref{tab:vcr} (in the main paper) and discussed in the main text. In conclusion, for downstream tasks that contain new data which is very different from the pre-training datasets, second-stage pre-training helps further boost the performance. 

In our implementation, the second-stage pre-training is implemented with a batch size of 4096 intput units, a learning rate of  and a weight decay of  over maximum K steps. After second-stage pre-traing, we finetune our model with a learning rate of  over maximum K steps.

\vspace{5pt}
\noindent \textbf{Natural Language for Visual Reasoning for Real (NLVR)}
NLVR is a new challenging task for visual reasoning.
The goal is to determine whether a natural language statement is true about the given image pair. 
Here we discuss the three architecture variants of NLVR finetuning in detail.
Since UNITER only handles one image and one text input at pre-training, the `modality embedding' is extended to help distinguish the additional image presented in the NLVR task.
For the \emph{Triplet} setup, we concatenate the image regions and then feed into the UNITER model.
An MLP transform is applied on the \texttt{[CLS]} output for binary classification.
For the \emph{Pair} setup, we treat one input example as two text-image pairs by repeating the text.
The two \texttt{[CLS]} outputs from UNITER are then depth concatenated as the joint embedding for the example.
Another MLP further transform this embedding for the final classification.
For the \emph{Pair-biattn} setup, the input format is the same as the Pair setup.
As for the joint representation, instead of rely on only two \texttt{[CLS]} outputs, we apply a multi-head attention layer~\cite{vaswani2017attention} on one sequence of joint image-text embeddings to attend to the other sequence of embeddings, and vice versa.
After this `bidirectional' attention interactions, a simple attentional pooling is applied on each output sequences and then a final concat+MLP layer transforms the cross-attended joint representation for true/false classification.

We finetune UNITER on NLVR for 8K steps with a batch size of 10K input units. AdamW optimizer is used with learning rate of  and weight decay of .





\vspace{5pt}
\noindent \textbf{Image-Text Retrieval} 
Two datasets are considered for this task: COCO and Flickr30K. COCO consists of K images, each accompanied with five human-written captions. We follow \cite{karpathy2015deep} to split the data into 82K/5K/5K training/ validation/test images. Additional 30K images from MSCOCO validation set are also included to improve training as in~\cite{lee2018stacked}. Flickr30K dataset contains 31K images collected from the Flickr website, with five textual descriptions per image. We follow~\cite{karpathy2015deep} to split the data into 30K/1K/1K  training/validation/test splits. During finetuning, we sample two negative image-text pairs per positive sample from image and text sides, respectively. For COCO, we use batch size of 60 examples, learning rate of  and finetune our model for K steps. For Flickr30K, we finetune our model with a batch size of 120 examples and a learning rate of  over maximum K steps. 

To obtain the final results in Table~\ref{tab:results} in the main text, we further sample hard negatives to facilitate the finetuning. For every  steps, we randomly sample 128 negative images per text input and obtain a sparse scoring matrix for the whole training set. For each image, we choose the top 20 ranked negative sentences as hard negative samples. Similarly, we get 20 hard negative images for each sentence according to their scores. The hard negatives are sent to the model as additional negative samples. In the end, we have two randomly sampled negatives and two hard negative samples per positive sample.  is set to 4000 for COCO and 2500 for Flickr30K. 

\vspace{5pt}
\noindent \textbf{Visual Entailment (SNLI-VE)}
Visual Entailment is a task derived from Flickr30K images and Stanford Natural Language Inference (SNLI) dataset, where the goal is to determine the logical relationship between a natural language statement and an image.
Similar to BERT for Natural Language Inference (NLI), we treat SNLI-VE as a three-way classification problem and apply an MLP Transform on \texttt{[CLS]} output. 
The UNITER model is finetuned using cross-entropy loss. The batch size is set to 10K input units and we use AdamW with learning rate of  to train for 3K steps.

\vspace{5pt}
\noindent \textbf{Referring Expression Comprehension}
We use three referring expression datasets: RefCOCO, RefCOCO+, and RefCOCOg for the evaluation, all collected on COCO images.
To finetune UNITER on this task, we add a MLP layer on top of the region outputs from Transformer, to compute the alignment score between the query phrase/sentence and each region.
Since only one object is paired with the query phrase/sentence, we apply cross-entropy loss on the normalized alignment scores.
The finetuning is efficient - we train the model with a batch size of 64 examples and a learning rate of  for only 5 epochs, and achieve state-of-the-art performance.

Note all works including ours use off-the-shelf object detectors trained on COCO (and Visual Genome) to extract the visual features.
While this does not affect other downstream tasks, it raises an issue for RE comprehension, as the val/test images of RefCOCO, RefCOCO+, and RefCOCOg are a subset of COCO's training split.
Strictly, our object detector is not allowed to train with these val/test images.
However, just for a ``fair" comparison with concurrent works, we ignore this issue and use the same features~\cite{anderson2018bottom} as the others. 
We also update the results of MAttNet using this "contaminated" features, whose accuracy is 1.5\% higher than the original one.
As aforementioned, the interaction between sentence and image could start from tokens and pixels instead of the extracted features.
We leave this study and RE comprehension with strictly correct features to future work.

\begin{figure*}
\centering
\includegraphics[width=0.85\textwidth]{figures/cm_jrm_example.pdf}
\caption{Example showing difference between conditional masking and joint random masking}\label{fig:cm_jrm_example}
\vspace{-20pt}
\end{figure*}

\begin{figure*}[t]
     \centering
     \begin{subfigure}[b]{0.95\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/cm_jrm_mlm.pdf}
         \caption{\small{Validation accuracy of MLM on COCO and VG datasets}}
     \end{subfigure}
     \begin{subfigure}[b]{0.95\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/cm_jrm_mrckl.pdf}
         \caption{\small{Validation accuracy of MRC-kl on COCO and VG datasets}}
     \end{subfigure}
     \caption{\small{Comparison of MLM and MRC-kl validation accuracy using joint masking and our proposed conditional masking}}
     \label{fig:cm_jrm_val}
     \vspace{-20pt}
\end{figure*}


\subsection{Conditional Masking vs. Joint Random Masking} \label{sec:conditional_masking}
We further discuss the advantage of our proposed conditional masking over joint random masking used in~\cite{tan2019lxmert,lu2019vilbert}.
Intuitively, our conditional masking learns better latent alignment of entities (regions and words) across two modalities. 
Fig.~\ref{fig:cm_jrm_example} shows an example image with ``man with his dog and cat sitting on a sofa''.
With conditional masking, when the region of “dog” is masked, our model should be able to infer that the region is “dog”, based on the context of both surrounding regions and the full sentence (Fig.~\ref{fig:cm_jrm_example}(a)), and vice versa.
However, for the joint masking implementation, it could happen when both the region of “dog” and the word “dog” are masked (Fig.~\ref{fig:cm_jrm_example}(b)). 
In such case, the model has to make the prediction blindly, which might lead to mis-alignment.


To verify this intuition, we show the validation curves during pre-training of MLM and MRC-kl in Fig.~\ref{fig:cm_jrm_val}.
Each sub-figure shows a comparison between applying conditional masking and joint random masking during the pre-training of UNITER.
The MLM accuracy measures how well UNITER can reconstruct the masked words, and MRC-kl accuracy\footnote{When validating on MRC-kl accuracy, we simply pick the most confident category from the predicted probability and measure its correctness.} measures how well UNITER can classify the masked regions.
In both cases, as shown in Fig.~\ref{fig:cm_jrm_val}, our conditional masking converges faster and achieves higher final accuracy than joint random masking.
In addition, Table~\ref{table:ablation_study} (row 10 \& 11) in the main paper shows our conditional masking also performs better on fine-tuned downstream tasks.

\subsection{More Ablation Studies on Pre-training Settings}
\subsubsection{MRC-only Pre-training}
In addition to ablations shown in Table~\ref{table:ablation_study} in the main paper, we include results from UNITER-base when pre-trained with MRC only on in-domain data. Table~\ref{tab:mrc_ablation} shows that MRC-only pre-training leads to a similar downstream performance to MRFR-only prer-training, which is a weak baseline compared with all other pre-training settings with in-domain data (line 4 - 12 in Table~\ref{table:ablation_study}).

\subsubsection{Significance of WRA}
In Table~\ref{table:ablation_study} of the main paper, we show that adding WRA significantly improves model performance on VQA and RefCOCO+, while achieves comparable results on Flickr and NLVR. By design, WRA encourages local alignment between each image region and each word in a sentence. Therefore, WRA mostly benefits downstream tasks relying on region-level recognition and reasoning such as VQA, while Flickr and NLVR focus more on global rather than local alignments. We add additional ablation results for WRA of UNITER-large when pre-trained with both In-domain and Out-of-domain data in Table~\ref{tab:wra}. We observe large performance gains in zero-shot setup for image/text retrieval and consistent gains across all other tasks.
\begin{table*}[t!]
\centering
\small
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l l c  c  c c c c }
\hline
Pre-training Data & Pre-training Tasks& Meta-Sum & VQA & \specialcell{IR\\\scriptsize{(Flickr)}} & \specialcell{TR\\\scriptsize{(Flickr)}} & NLVR & \specialcell{Ref- \\COCO+ } \\ 
\cmidrule(lr){4-4} \cmidrule(lr){5-5} \cmidrule(lr){6-6} \cmidrule(lr){7-7} \cmidrule(lr){8-8} 
& &  & test-dev & val & val & dev & val\\
\hline
\specialcelll{\scriptsize{In-domain}\\\scriptsize{(COCO+VG)}}  &\scriptsize{MRC} & 350.97 & 66.23 & 77.17 & 84.57 & 52.31 &70.69\\
\hline
\end{tabular}
}
\caption{\small{Additional ablation results of MRC-only pre-training for UNITER-base with in-domain data.}}
\label{tab:mrc_ablation}
\vspace{-10pt}
\end{table*}

\begin{table*}[t!]
\centering
\small
\begin{tabular}{l c  c c c c c c c}
\hline
WRA pre-train & VQA & NLVR & SNLI-VE & \specialcell{ZS IR\flickr)} & \specialcell{Ref-\\COCO} &  \specialcell{Ref-\\COCO+} &  \specialcell{Ref-\\COCOg}\\
\cmidrule(lr){2-2} \cmidrule(lr){3-3}  \cmidrule(lr){4-4} \cmidrule(lr){5-5} \cmidrule(lr){6-6} \cmidrule(lr){7-7} \cmidrule(lr){8-8} \cmidrule(lr){9-9} 
& test-std & test & test & val  & val & testB & testB & test \\
\hline
N & 73.40 & 79.50 & 78.98 & 65.82 & 77.50 & 74.17 & 78.89 & 87.73  \\
Y & \textbf{74.02} & \textbf{79.98} & \textbf{79.38} & \textbf{68.74} & \textbf{83.60} & \textbf{74.98} & \textbf{79.75} & \textbf{88.47}  \\
\hline
\end{tabular}
\caption{\small{A direct ablation on WRA pre-training task using UNITER-large, all pre-trained on both In-domain + Out-of-domain data, with MLM + ITM + MRC-kl + MRFR (+ WRA). For simplicity, only R@1 is reported for ZS IR and ZS TR.}}
\label{tab:wra}
\vspace{-10pt}
\end{table*} 


\subsection{More Results on VCR and NLVR2} \label{sec:more_results_vcr_nlvr2}
Following the VCR setup in Table~\ref{tab:vcr} of the main paper, we further construct an ensemble model using 10 UNITER-large.
Table~\ref{tab:vcr+} shows the comparison between VLBERT, ViLBERT and UNITER on VCR.
The  accuracy of our ensemble model outperforms ViLBERT~\cite{lu2019vilbert} ensemble by a large margin of 7.0\%.
Note even single UNITER-large already outperforms ViLBERT ensemble and VLBERT-large by 3.0\%.

Besides, we also compare our UNITER-large with LXMERT~\cite{tan2019lxmert} and VisualBERT~\cite{li2019visualbert} on an additional testing split of NLVR in Table~\ref{tab:nlvr+}.
Our results consistently outperform the previous SOTA on all metrics\footnote{The balanced and unbalanced evaluations were introduced in~\cite{suhr2019nlvr2}.} by a large margin of 4.0\%.

\begin{table}[!t]
    \centering
\begin{tabular}{l |c c c}
        \hline
          Model & QA & QA R & Q  AR \\
         \hline
          VLBERT-large (single) & 75.8 & 78.4 & 59.7 \\
          ViLBERT (10 ensemble) & 76.4 & 78.0 & 59.8 \\
          UNITER-large (single) & 77.3 & 80.8 & 62.8 \\
          UNITER-large (10 ensemble) & \textbf{79.8} & \textbf{83.4} & \textbf{66.8} \\
         \hline
    \end{tabular}
    \caption{\small{VCR results from VLBERT~\cite{su2019vl}, ViLBERT~\cite{lu2019vilbert}, and UNITER}}
    \label{tab:vcr+}
\vspace{-10pt}
\end{table}

\begin{table}[!t]
    \centering
\begin{tabular}{l | c c c c}
        \hline
         Model & Balanced & Unbalanced & Overall & Consistency\\
         \hline
         VisualBERT & 67.3 & 68.2 & 67.3 & 26.9\\
         LXMERT & 76.6 & 76.5 & 76.2 & 42.1\\
         UNITER-large & \textbf{80.0} & \textbf{81.2} & \textbf{80.4}  & \textbf{50.8}\\
         \hline
    \end{tabular}
\caption{\small{NLVR results on test-U split from VisualBERT~\cite{li2019visualbert}, LXMERT~\cite{tan2019lxmert}, and UNITER}}
\label{tab:nlvr+}
\vspace{-10pt}
\end{table}

 

\begin{table*}[t!]
\centering
\small
\begin{tabular}{l c  c c c  }
\hline
Model & VQA & \multicolumn{3}{c}{RefCOCO+ (det)} \\
\cmidrule(lr){2-2} \cmidrule(lr){3-5} 
& test-dev & val & testA & testB \\
\hline
ViLBERT & 70.55 & 72.34 & 78.52 & 62.61  \\
VLBERT-base & 71.16 &  71.60 & 77.72 & 60.99  \\
UNITER-base & \textbf{71.22} & \textbf{72.49} & \textbf{79.36} & \textbf{63.65} \\
\hline
\end{tabular}
\caption{\small{A direct comparison between ViLBERT~\cite{lu2019vilbert}, VLBERT~\cite{su2019vl}, and our UNITER, all trained on Conceptual Captions~\cite{sharma2018conceptual} only}}
\label{tab:cc_results}
\vspace{-20pt}
\end{table*} 
\subsection{Direct Comparison to VLBERT and ViLBERT} \label{sec:comparison_vlbert}
To further demonstrate our idea, we conduct a direct comparison to ViLBERT~\cite{lu2019vilbert} and VLBERT~\cite{su2019vl}, trained on Conceptual Captions~\cite{sharma2018conceptual}.
We pre-train UNITER on Conceptual Captions only using our proposed conditional masking and the best pre-training tasks.
Table~\ref{tab:cc_results} shows that UNITER still consistently outperforms the other models by a visible margin on VQA and RefCOCO+.

\subsection{Review of Optimal Transport and the IPOT Algorithm} \label{sec:ot_ipot}

\noindent \textbf{Optimal Transport}
We first provide a brief review of optimal transport, which defines distances between probability measures on a domain  (the sequence space in our setting). 
The \textit{optimal transport distance} for two probability measures  and  is defined as~\cite{peyre2019computational}:
 
where  denotes the set of all joint distributions  with marginals  and ;  is the cost function for moving  to , \emph{e.g.}, the Euclidean or cosine distance. Intuitively, the optimal transport distance is the minimum cost that  induces in order to transport from  to . When  is a metric on ,  induces a proper metric on the space of probability distributions supported on , commonly known as the Wasserstein distance. One of the most popular choices is the Wasserstein distance  where the squared Euclidean distance  is used as cost. 


\begin{algorithm}[t!]
\small
\caption{\small{IPOT algorithm}}
\label{alg:ipot}
\begin{algorithmic}[1]
\State {\bfseries Input:} Feature vectors 
 ,   and generalized stepsize , 

\State , 
\State , 
\For{}
    \State  \footnotesize{//  is Hadamard product}
    \For{} \footnotesize{//  in practice}
        \State , 
    \EndFor
    \State 
\EndFor
\State \textbf{Return} 
\end{algorithmic}
\end{algorithm}
 
\vspace{5pt}
\noindent \textbf{The IPOT algorithm}
Unfortunately, the exact minimization over  is in general computational intractable~\cite{wgan,genevay2018learning,salimans2018improving}. To overcome such intractability, we consider an efficient iterative approach to approximate the OT distance. 
We propose to use the recently introduced Inexact Proximal point method for Optimal Transport (IPOT) algorithm to compute the OT matrix , thus also the OT distance~\cite{xie2018fast}. 
Specifically, IPOT iteratively solves the following optimization problem using the proximal point method~\cite{boyd2004convex}:

where the proximity metric term  penalizes solutions that are too distant from the latest approximation, and  is understood as the generalized stepsize. This renders a tractable iterative scheme towards the exact OT solution. In this work, we employ the generalized KL Bregman divergence
 as  the proximity metric. 
Algorithm \ref{alg:ipot} describes the implementation details for IPOT.



Note that the Sinkhorn algorithm~\cite{cuturi2013sinkhorn} can also be used to compute the OT matrix. Specifically, the Sinkhorn algorithm tries to solve the entropy regularized optimization problem:  where  is the entropy regularization term and  is the regularization strength. However, in our experiments, we empirically found that the numerical stability and performance of the Sinkhorn algorithm is quite sensitive to the choice of the hyper-parameter , thus only IPOT is considered in our model training.


\subsection{Additional Visualization} \label{sec:addtional_viz}

\begin{figure*}[!h]
  \includegraphics[width=1.0\linewidth]{figures/attn_vis/example2.png}
 \caption{\small{Additional text-to-image attention visualization example}}
  \label{fig:vis2}
\end{figure*} 

  
\end{document}
