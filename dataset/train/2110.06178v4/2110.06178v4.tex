
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{xcolor}
\definecolor{themeblue}{RGB}{57, 162, 219}
\definecolor{themegreen}{RGB}{87, 204, 153}
\definecolor{forestgreen}{RGB}{47, 159, 87}
\definecolor{link}{RGB}{75, 166, 154}

\usepackage[colorlinks=true, allcolors=link]{hyperref}
\usepackage{url}
\newcommand{\cmark}{\color{forestgreen}\ding{51}}\newcommand{\xmark}{\color{red}\ding{55}}\usepackage{pifont}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{booktabs}
\usepackage{anyfontsize}
\usepackage{makecell}

\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\small}
\newcommand\pl[1]{{\color{violet}#1}}
\newcommand\gray[1]{\color{gray}#1}
\def\x{}

\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}

\title{TAda! Temporally-Adaptive Convolutions for Video Understanding}



\author{Ziyuan Huang\textsuperscript{1}, \quad Shiwei Zhang\textsuperscript{2,*}, \quad Liang Pan\textsuperscript{3}, \quad Zhiwu Qing\textsuperscript{2}, \\
\textbf{Mingqian Tang\textsuperscript{2}, \quad Ziwei Liu\textsuperscript{3}, \quad Marcelo H. Ang Jr\textsuperscript{1,*}}\\
\textsuperscript{1}Advanced Robotics Centre, National University of Singapore\\
\textsuperscript{2}DAMO Academy, Alibaba Group \quad
\textsuperscript{3}S-Lab, Nanyang Technological University\\
\fontsize{8}{8}{
\texttt{ziyuan.huang@u.nus.edu,}}
\fontsize{8}{8}
{\texttt{\{zhangjin.zsw,mingqian.tmq,qingzhiwu.qzw\}@alibaba-inc.com,}}\\
\fontsize{8}{8}{
\texttt{\{liang.pan, ziwei.liu\}@ntu.edu.sg, mpeangh@nus.edu.sg}}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Spatial convolutions\footnote{In this work, we use spatial convolutions and 2D convolutions interchangeably.} are widely used in numerous deep video models.
It fundamentally assumes spatio-temporal invariance, \textit{i.e.}, using shared weights for every location in different frames.
This work presents \textbf{Temporally-Adaptive Convolutions (TAdaConv)} for video understanding\footnote{Project page: \scriptsize{\url{https://tadaconv-iclr2022.github.io/}}.}, which shows that adaptive weight calibration along the temporal dimension is an efficient way to facilitate modelling complex temporal dynamics in videos.
Specifically, TAdaConv empowers the spatial convolutions with temporal modelling abilities by calibrating the convolution weights for each frame according to its local and global temporal context.
Compared to previous temporal modelling operations, TAdaConv is more efficient as it operates over the convolution kernels instead of the features, whose dimension is an order of magnitude smaller than the spatial resolutions.
Further, the kernel calibration brings an increased model capacity.
We construct TAda2D and TAdaConvNeXt networks by replacing the 2D convolutions in ResNet and ConvNeXt with TAdaConv, which leads to at least on par or better performance compared to state-of-the-art approaches on multiple video action recognition and localization benchmarks.
We also demonstrate that as a readily plug-in operation with negligible computation overhead, TAdaConv can effectively improve many existing video models with a convincing margin.
\end{abstract}

\section{Introduction}

Convolutions are an indispensable operation in modern deep vision models~\citep{resnet,inception,alexnet}, whose different variants have driven the state-of-the-art performances of convolutional neural networks (CNNs) in many visual tasks~\citep{resnext,deformable,nes} and application scenarios~\citep{mobilenets,condconv}. 
In the video paradigm, compared to the 3D convolutions~\citep{c3d}, the combination of 2D spatial convolutions and 1D temporal convolutions are more widely preferred owing to its efficiency~\citep{r21d,p3d}.
Nevertheless, 1D temporal convolutions still introduce non-negligible computation overhead on top of the spatial convolutions. Therefore, we seek to directly equip the spatial convolutions with temporal modelling abilities.

One essential property of the convolutions is the translation invariance~\citep{ruderman1994statistics,simoncelli2001natural}, resulted from its local connectivity and shared weights. 
However, recent works in dynamic filtering have shown that strictly shard weights for all pixels may be sub-optimal for modelling various spatial contents~\citep{ddf,wu2018dynamic}.

Given the diverse nature of the temporal dynamics in videos, we hypothesize that the temporal modelling could also benefit from relaxed invariance along the temporal dimension. This means that the convolution weights for different time steps are no longer strictly shared.
Existing dynamic filter networks can achieve this, but with two drawbacks. First, it is difficult for most of them~\citep{ddf,condconv} to leverage the existing pre-trained models such as ResNet. This is critical in video applications, since training video models from scratch is highly resource demanding~\citep{slowfast,x3d} and prone to over-fitting on small datasets.
Second, for most dynamic filters, the weights are generated with respect to its spatial context~\citep{ddf,dynamicfilter} or the global descriptor~\citep{dycnn,condconv}, which has difficulty in capturing the temporal variations between frames.

\begin{figure}[t]
\centering
\vspace{-4mm}
\includegraphics[width=0.85\textwidth]{main_tight.pdf}
\vspace{-3mm}
\caption{\textbf{Comparisons between TAdaConv and the spatial convolutions in video models}. 
(a) Standard spatial convolutions in videos share the kernel weights between different frames. 
(b) Our TAdaConv adaptively calibrates the kernel weights for each frame by its temporal context.
}
\vspace{-5mm}
\label{fig:spatialconvcomp}
\end{figure}

In this work,
we present the Temporally-Adaptive Convolution (TAdaConv) for video understanding, where the convolution kernel weights are no longer fixed across different frames. 
Specifically, the convolution kernel for the -th frame  is factorized to the multiplication of the base weight and a calibration weight: , where the calibration weight  is adaptively generated from the input data for all channels in the base weight . 
For each frame, we generate the calibration weight based on the frame descriptors of its adjacent time steps as well as the global descriptor, which effectively encodes the local and global temporal dynamics in videos. The difference between TAdaConv and the spatial convolutions is visualized in Fig.~\ref{fig:spatialconvcomp}.

The main advantages of this factorization are three-fold: \textbf{(i)} TAdaConv can be easily plugged into any existing models to enhance temporal modelling, and their pre-trained weights can still be exploited; \textbf{(ii)} the temporal modelling ability can be highly improved with the help of the temporally-adaptive weight; \textbf{(iii)} in comparison with temporal convolutions that often operate on the learned 2D feature maps, TAdaConv is more efficient by directly operating on the convolution kernels.

TAdaConv is proposed as a drop-in replacement for the spatial convolutions in existing models.
It can both serve as a stand-alone temporal modelling module for 2D networks, or be inserted into existing convolutional video models to further enhance the ability to model temporal dynamics.
For efficiency, we construct TAda2D by replacing the spatial convolutions in ResNet~\citep{resnet}, which leads to at least on par or better performance than the state-of-the-arts.
Used as an enhancement of existing video models, TAdaConv leads to notable improvements on multiple video datasets. 
The strong performance and the consistent improvements demonstrate that TAdaConv can be an important operation for modelling complex temporal dynamics in videos.


\begin{figure}[t]
\centering
\vspace{-3mm}
\includegraphics[width=0.9\textwidth]{structurev3.pdf}
\vspace{-2mm}
\caption{\textbf{An instantiation of TAdaConv and the temporal feature aggregation used in TAda2D.}
(a) Standard convolutions used in video models. 
(b) Our TAdaConv using non-linear weight calibrations with global temporal context.
(c) The temporal feature aggregation scheme used in TAda2D. 
}
\vspace{-4mm}
\label{fig:tadaconvinstantiation}
\end{figure}

\section{Related Work}

\noindent\textbf{ConvNets for temporal modelling. }A fundamental difference between videos and images lies in the temporal dimension, which makes temporal modeling an important research area for understanding videos. Recent deep CNNs for video understanding can be divided into two types. The first type jointly models spatio-temporal information by 3D convolutions~\citep{i3d,c3d,x3d,csn}.
The second type builds upon 2D networks, where most approaches employ 2D convolutions that share weights among all the frames for spatial modelling, and design additional operations for temporal modelling, such as temporal shift~\citep{tsm}, temporal difference~\citep{tdn,stm}, temporal convolution~\citep{r21d,tam} and correlation operation~\citep{corrnet}, \textit{etc}.
Our work directly empowers the spatial convolutions with temporal modelling abilities, which can be further coupled with other temporal modelling operations for stronger video recognition performances. 


\noindent\textbf{Dynamic networks. }
Dynamic networks refer to networks with content-adaptive weights or modules, such as dynamic filters/convolutions~\citep{dynamicfilter,condconv,dcd},
dynamic activations~\citep{micronet,dynamicrelu}, and dynamic routing~\citep{skipnet,dynamicrouting}, \textit{etc}.
Dynamic networks have demonstrated their exceeding network capacity and thus performance compared to the static ones.
In video understanding, dynamic filter~\citep{tam} or temporal aggregation~\citep{adafuse} also demonstrate strong capability of temporal modelling.
Recently, some convolutions applies spatially-adaptive weights~\citep{lrlc,drconv}, showing the benefit of relaxing the spatial invariance in modelling diverse visual contents.
Similarly, our proposed TAdaConv enhances temporal modelling by relaxing the invariance along the temporal dimension.
TAdaConv has two key differences from previous works: (i) the convolution weight in TAdaConv is factorized into a base weight and a calibration weight, which enables TAdaConv to exploit pre-trained weights;
(ii) the calibration weights are generated according to the temporal contexts.

\section{TAdaConv: Temporally-adaptive Convolutions}

In this work, we seek to empower the spatial convolutions with temporal modelling abilities. 
Inspired by the calibration process of temporal convolutions (Sec.~\ref{Sec:TempConv}), TAdaConv dynamically calibrates the convolution weights for each frame according to its temporal context (Sec.~\ref{Sec:TempVariance}). 

\subsection{Revisiting temporal convolutions}
\label{Sec:TempConv}

We first revisit the temporal convolutions to showcase its underlying process and its relation to dynamic filters. 
We consider depth-wise temporal convolution for simplicity, which is more widely used because of its efficiency~\citep{tam,stm}.
Formally, for a 3\x1\x1 temporal convolution filter parameterized by  and placed (ignoring normalizations) after the 2D convolution parameterized by , the output feature  of the -th frame can be obtained by:

\noindent where the  indicates the element-wise multiplication,  denotes the convolution over the spatial dimension and  denotes ReLU activation~\citep{relu}. It can be rewritten as follows:

\noindent where  and  are spatio-temporal location adaptive convolution weights.  is a dynamic tensor, with its value dependent on the result of the spatial convolutions (see Appendix~\ref{appendix:tempconvs} for details). Hence, the temporal convolutions in the (2+1)D convolution essentially performs \textbf{(i)} weight calibration on the spatial convolutions and \textbf{(ii)} feature aggregation between adjacent frames. 
However, if the temporal modelling is achieved by coupling temporal convolutions to spatial convolutions, a non-negligible computation overhead is still introduced (see Table~\ref{tab:temporalmodellingcomparison}). 

\subsection{Formulation of TAdaConv}
\label{Sec:TempVariance}
For efficiency, we set out to directly empower the spatial convolutions with temporal modelling abilities. 
Inspired by the recent finding that the relaxation of spatial invariance strengthens spatial modelling~\citep{ddf,lrlc}, we hypothesize that temporally adaptive weights can also help temporal modelling. 
Therefore, the convolution weights in a TAdaConv layer are varied on a frame-by-frame basis.
Since we observe that previous dynamic filters can hardly utilize the pretrained weights, we take inspiration from our observation in the temporal convolutions and factorize the weights for the -th frame  into the multiplication of a base weight  shared for all frames, and a calibration weight  that are different for each time step:

\textbf{Calibration weight generation. }
To allow for the TAdaConv to model temporal dynamics, it is crucial that the calibration weight  for the -th frame takes into account not only the current frame, but more importantly, its temporal context, \textit{i.e.,} .
Otherwise TAdaConv would degenerate to a set of unrelated spatial convolutions with different weights applied on different frames.
We show an instantiation of the generation function  in Fig.~\ref{fig:tadaconvinstantiation}(b).

In our design, we aim for efficiency and the ability to capture inter-frame temporal dynamics. 
For efficiency, we operate on the frame description vectors  obtained by the global average pooling over the spatial dimension  for each frame, \textit{i.e.,} .
For temporal modelling, we apply stacked two-layer 1D convolutions  with a dimension reduction ratio of  on the local temporal context  obtained from :

\noindent where  and  denote the ReLU~\citep{relu} and batchnorm~\citep{bn}. 

In order for a larger inter-frame field of view in complement to the local 1D convolution, we further incorporate global temporal information by adding a global descriptor  to the weight generation process  through a linear mapping function :

\noindent where  with  being global average pooling on spatial and temporal dimensions.


\textbf{Initialization. }The TAdaConv is designed to be readily inserted into existing models by simply replacing the 2D convolutions. 
For an effective use of the pre-trained weights, TAdaConv is initialized to behave exactly the same as the standard convolution.
This is achieved by zero-initializing the weight of the last convolution in  and adding a constant vector  to the formulation:

\noindent In this way, at initial state, , where we load  with the pre-trained weights.

\textbf{Calibration dimension. }
The base weight  can be calibrated in different dimensions.
We instantiate the calibration on the  dimension (), as the weight generation based on the input features yields a more precise estimation for the relation of the input channels than the output channels or spatial structures (empirical analysis in Table~\ref{tab:calibrationdim}). 

\begin{wraptable}[8]{r}{0.48\textwidth}
\tablestyle{3pt}{1.0}
\vspace{-1.5em}
\caption{{Comparison with other dynamic filters.}
}
\vspace{-1em}
\centering
\begin{tabular}{lccc}
\shline
~ &  \textbf{Temporal} &  \textbf{Location} & \textbf{Pretrained}\\
\textbf{Operations} &  \textbf{modelling} &  \textbf{adaptive} & \textbf{weights}\\
\hline
 CondConv & \xmark & \xmark & \xmark \\
 DynamicFilter & \xmark & \xmark & \xmark \\
 DDF & \xmark & \cmark & \xmark \\
 TAM & \cmark & \xmark & \xmark \\
 TAdaConv & \cmark & \cmark & \cmark \\
\shline
\end{tabular}
\label{tab:compdyconv}
\end{wraptable}
\textbf{Comparison with other dynamic filters.} Table~\ref{tab:compdyconv} compares TAdaConv with existing dynamic filters. 
Mixtue-of-experts based dynamic filters such as CondConv dynamically aggregates multiple kernels to generate the weights that are shared for all locations.
The weights in most other dynamic filters are completely generated from the input, such as DynamicFilter~\citep{dynamicfilter} and DDF~\citep{ddf} in images and TAM~\citep{tam} in videos.
Compared to image based ones, TAdaConv achieves temporal modelling by generating weights from the local and global temporal context. Compared to TANet~\citep{tam}, TAdaConv is better at temopral modellling because of temporally adaptive weights.
Further, TAdaConv can effectively generate weights identical to the pre-trained ones, while it is difficult for previous approaches to exploit pre-trained models.
More detailed comparisons of dynamic filters are included in Appendix~\ref{appendix:comparisondynamicfilter}.

\textbf{Comparison with temporal convolutions.} Table~\ref{tab:temporalmodellingcomparison} compares the TAdaConv with R(2+1)D in parameters and FLOPs, which shows most of our additional computation overhead on top of the spatial convolution is an order of magnitude less than the temporal convolution. For detailed computation analysis and comparison with other temporal modelling approaches, please refer to Appendix~\ref{appendix:companalysis}.

\begin{table}[t]
\caption{
Comparison of (2+1)D convolution and TAdaConv in FLOPs and number of parameters. 
Example setting for operation: , , ,  and . 
Example setting for network: ResNet-50 with input resolution .
Colored numbers denote the extra FLOPs/Params. added to 2D convolutions or ResNet-50.
Refer to Appendix~\ref{appendix:modelstructure} for model structures.
}
\vspace{-2mm}
\centering
\tablestyle{8pt}{1.0}
\begin{tabular}{lcc}
\shline
 ~& \textbf{(2+1)D Conv} & \textbf{TAdaConv} \\
\hline
\multirow{2}{*}{FLOPs} &  &  \\
 &  &  \\
E.G. Op & 1.2331 {\color{red}\textbf{(+0.308, 33)}} & 0.9268 {\color{forestgreen}\textbf{(+0.002, 0.2)}}\\
E.G. Net & 37.94 {\color{red}\textbf{(+4.94, 15)}} & 33.02 {\color{forestgreen}\textbf{(+0.02, 0.06)}} \\
\hline
Params. &  & \\
E.G. Op.& 49,152 {\color{red}\textbf{(+12,288, 33)}} & 43,008 {\color{forestgreen}\textbf{(+6,144, 17)}}\\
E.G. Net & 28.1M {\color{red}\textbf{(+3.8M, 15.6)}}& 27.5M {\color{forestgreen}\textbf{(+3.2M, 13.1)}}\\
\shline
\end{tabular}
\label{tab:temporalmodellingcomparison}
\vspace{-3mm}
\end{table}

\section{TAda2D: Temporally Adaptive 2D Networks}
\label{Sec:TempAgg}
We construct TAda2D networks by replacing the 2D convolutions in ResNet (R2D, see Appendix~\ref{appendix:modelstructure}) with our proposed TAdaConv.
Additionally, based on strided average pooling, we propose a temporal feature aggregation module for the 2D networks, corresponding to the second essential step for the temporal convolutions.
As illustrated in Fig.~\ref{fig:tadaconvinstantiation}(c), the aggregation module is placed after TAdaConv. 
Formally, given the output of TAdaConv , the aggregated feature can be obtained as follows:

\noindent where  denotes strided temporal average pooling with kernel size of . 
We use different batch normalization parameters for the features extracted by TAdaConv  and aggregated by strided average pooling , as their distributions are essentially different. 
During initialization, we load pre-trained weights to , and initialize the parameters of  to zero. 
Coupled with the initialization of TAdaConv, the initial state of the TAda2D is exactly the same as the Temporal Segment Networks~\citep{tsn}, while the calibration and the aggregation notably increases the model capacity with training (See Appendix~\ref{appendix:trainingprocedure}).
In the experiments, we refer to this structure as the shortcut (Sc.) branch and the separate BN (SepBN.) branch.

\section{Experiments on video classification}
To show the effectiveness and generality of the proposed approach, we present comprehensive evaluation of TAdaConv and TAda2D on two video understanding tasks using four large-scale datasets.

\textbf{Datasets.}
For video classification, we use Kinetics-400~\citep{kinetics400}, Something-Something-V2~\citep{ssv2}, and Epic-Kitchens-100~\citep{ek100}. \textit{K400} is a widely used action classification dataset with 400 categories covered by 300K videos.
\textit{SSV2} includes 220K videos with challenging spatio-temporal interactions in 174 classes.
\textit{EK100} includes 90K segments labelled by 97 verb and 300 noun classes with actions defined by the combination of nouns and verbs. For action localization, we use HACS~\citep{hacs} and Epic-Kitchens-100~\citep{ek100}.

\textbf{Model.} In our experiments, we mainly use ResNet (R2D) as our base model, and construct TAda2D by replacing the spatial convolutions with the TAda-structure in Fig.~\ref{fig:tadaconvinstantiation}(c).
Alternatively, we also construct TAdaConvNeXt based on the recent ConvNeXt model~\citep{convnext}. For TAdaConvNeXt, we use a tubelet embedding stem similar to~\citep{arnab2021vivit} and only use TAdaConv to replace the depth-wise convolutions in the model. More details are included in Appendix~\ref{appendix:modelstructure}.

\textbf{Training and evaluation.} 
During training, 8, 16 or 32 frames are sampled with temporal jittering,
following convention~\citep{tsm,tam,slowfast}. 
We include further training details in the appendix~\ref{appendix:implementationdetails}.
For evaluation, we use three spatial crops with 10 or 4 clips (K400\&EK100), or 2 clips (SSV2) uniformly sampled along the temporal dimension. 
Each crop has the size of 256\x256, which is obtained from a video with its shorter side resized to 256.
\subsection{TAdaConv on existing video backbones}
\begin{table}[t]
\caption{Plug-in evaluation of TAdaConv in existing video models on K400 and SSV2 datasets. 
}
\vspace{-2mm}
\centering
\tablestyle{5pt}{1.0}
\begin{tabular}{lcccccccc}
\shline
\bf \small Base Model & \bf TAdaConv & \bf Frames & \bf Params. & \bf GFLOPs & \bf K400 &  & \bf SSV2 & \\
\hline
\multirow{2}{*}{SlowOnly {8\x8}} & \xmark & 8 & 32.5M & 54.52 & 74.56 & - & 60.31 & -\\
~ & \cmark & 8 & 35.6M & 54.53 & 75.85 & {\bf +1.29} & 63.30 & {\bf +2.99}\\
\hline
\multirow{2}{*}{SlowFast 4\x16} & \xmark & 4+32 & 34.5M & 36.10 & 75.03 & - & 56.71 & - \\
~ & \cmark & 4+32 & 37.7M & 36.11 & 76.47 & {\bf +1.44} & 59.80 & {\bf +3.09} \\
\hline
\multirow{2}{*}{SlowFast 8\x8} & \xmark & 8+32 & 34.5M & 65.71 & 76.19 & - & 61.54 & - \\
~ & \cmark & 8+32 & 37.7M & 65.73 & 77.43 & \bf +1.24  & 63.88 & \bf +2.34 \\
\hline
\multirow{3}{*}{R(2+1)D} & \xmark & 8 & 28.1M & 49.55 & 73.63 & - & 61.06 & - \\
~ & \cmark {\scriptsize (2d)} & 8 & 31.2M & 49.57 & 75.19 & \bf +1.56 & 62.86 & \bf  +1.80 \\
~ & \cmark {\scriptsize (2d+1d)}& 8 & 34.4M & 49.58 & 75.36 & \bf +1.73 & 63.78 & \bf +2.72 \\
\hline
\multirow{2}{*}{R3D} & \xmark & 8 & 47.0M & 84.23 & 73.83 & - & 59.86 & - \\
~ & \cmark {\scriptsize (3d)} & 8 & 50.1M & 84.24 & 74.91 & \bf +1.08 & 62.85 & {\bf +2.99} \\
\shline
\multicolumn{9}{l}{\makecell[l]{\scriptsize Notation  indicates our own implementation. 
See Appendix~\ref{appendix:modelstructure} for details on the model structure.}}
\end{tabular}
\label{tab:plugineval}
\vspace{-2mm}
\end{table}
TAdaConv is designed as a plug-in substitution for the spatial convolutions in the video models. 
Hence, we first present plug-in evaluations in Table~\ref{tab:plugineval}.
TAdaConv improves the classification performance
with negligible computation overhead on a wide range of video models, including SlowFast~\citep{slowfast}, R3D~\citep{retrace} and R(2+1)D~\citep{r21d}, by an average of 1.3\% and 2.8\% respectively on K400 and SSV2 at an extra computational cost of less than 0.02 GFlops.
Further, not only can TAdaConv improve spatial convolutions, it also notably improve 3D and 1D convolutions.
For fair comparison, all models are trained using the same training strategy. 
Further plug-in evaluations for action classification is presented in Appendix~\ref{appendix:pluginclassification}.
\begin{table}[]
\begin{minipage}[t]{0.46\textwidth}
\centering
    \tablestyle{4pt}{1.0}
    \caption{Calibration weight generation.
\textit{K:} kernel size; \textit{Lin./Non-Lin.}: linear/non-linear weight generation; \textit{G:} global information .}
\vspace{-2mm}
\begin{tabular}{lcccc}
\shline
\bf Model & \bf TAdaConv & \bf K. & \bf G. & \bf Top-1\\
\hline
TSN & - & - & - & 32.0 \\
\hline
\multirow{9}{*}{Ours} & Lin. & 1 & \xmark & 37.5 \\
~ & Lin. & 3 & \xmark & 56.5 \\
\cline{2-5}
~ & Non-Lin. & (1, 1) & \xmark & 36.8\\
~ & Non-Lin. & (3, 1) & \xmark & 57.1\\
~ & Non-Lin. & (1, 3) & \xmark & 57.3\\
~ & Non-Lin. & (3, 3) & \xmark & 57.8\\
\cline{2-5}
~ & Lin. & 1 & \cmark & 53.4 \\
~ & Non-Lin. & (1, 1) & \cmark & 54.4\\
~ & Non-Lin. & (3, 3) & \cmark & 59.2\\
\shline
\end{tabular}
\label{tab:calibrationweightgen}
\end{minipage}
\hspace{2mm}
\begin{minipage}[t]{0.46\textwidth}
\centering
    \tablestyle{3pt}{1.0}
    \caption{Feature aggregation scheme.
\textit{FA:} feature aggregation; \textit{Sc:} shortcut for convolution feature; \textit{SepBN:} separate batch norm.}
\vspace{-2mm}
\begin{tabular}{cccccc}
\shline
\bf TAdaConv & \bf FA. & \bf Sc. &\bf SepBN. & \bf Top-1 & \\
\hline
\xmark & - & - & - & 32.0 & - \\
\cmark & - & - & - & 59.2 & +27.2\\
\hline
\xmark & Avg. & \xmark & - & 47.9 & +15.9 \\
\xmark & Avg. & \cmark & \xmark & 49.0 & +17.0 \\
\xmark & Avg. & \cmark & \cmark & 57.0 & +25.0\\
\hline
\cmark & Avg. & \xmark & - & 60.1 & +28.1 \\
\cmark & Avg. & \cmark & \xmark & 61.5 & +29.5\\
\cmark & Avg. & \cmark & \cmark & 63.8 & \bf +31.8 \\
\hline
\cmark & Max. & \cmark & \cmark & 63.5 & +31.5 \\
\cmark & Mix. & \cmark & \cmark & 63.7 & +31.7\\
\shline
\end{tabular}
\label{tab:featureaggregation}
\end{minipage}
\vspace{-4mm}
\end{table}
\begin{figure}[t]
\centering
\begin{minipage}[t]{0.53\textwidth}
\centering
\includegraphics[width=0.95\textwidth]{channel-stage-a-v4.pdf}
\caption{
The classification performance of TAda2D (a) with different channels (C.) and stages (S.) enabled; (b) in comparison with other state-of-the-arts.
}
\label{fig:proportions}
\end{minipage}\hspace{1.5mm}
\begin{minipage}[t]{0.45\textwidth}
\centering
\includegraphics[width=0.95\textwidth]{channel-stage-b-v2.pdf}
\caption{
Grad-CAM visualization and prediction comparison between TSN, R(2+1)D and TAda2D (more examples in Fig.~\ref{fig:furtherqualitative}). 
}
\label{fig:visualization}
\end{minipage}
\vspace{-7mm}
\end{figure}
\subsection{Ablation studies}
We present thorough ablation studies for the justification of our design choices and the effectiveness of our TAdaConv in modelling temporal dynamics. SSV2 is used as the evaluation benchmark, as it is widely acknowledged to have more complex spatio-temporal interactions. 

\begin{wraptable}[9]{r}{0.42\textwidth}
\tablestyle{6pt}{1.0}
\vspace{-1.5em}
\caption{Benefit of dynamic calibration. \textit{T.V.:} temporally varying. \textit{*}: w/o our init.}
\vspace{-1em}
\centering

    \begin{tabular}{lccc}
		\shline
\bf Calibration & \bf  T.V.  & \bf  Top-1 & \bf Top-1* \\
\hline
 None & \xmark & - & {32.0}\\
\hline
\multirow{2}{*}{Learnable} & \xmark & 34.3 & 32.6 \\
~ & \cmark & 45.4 & 43.8 \\
\hline
\multirow{2}{*}{Dynamic} & \xmark & 51.2 & 41.7 \\
~ & \cmark & 53.8 & 49.8 \\
\hline
TAda & \cmark & 59.2 & 47.8 \\
\shline
	\end{tabular}
	\label{tab:calibrationsource}
	\vspace{1mm}
\end{wraptable}
\textbf{Dynamic vs. learnable calibration.} We first compare different source of calibration weights (with our initialization strategy) in Table~\ref{tab:calibrationsource}. 
We compare our calibration with no calibration, calibration using learnable weights, and calibration using dynamic weights generated only from a global descriptor (C\x1).
Compared with the baseline (TSN~\citep{tsn}) with no calibration, learnable calibration with shared weights has limited improvement, while temporally varying learnable calibration (different calibration weights for different temporal locations) performs much stronger. 
A larger improvement is observed when we use dynamic calibration, where temporally varying calibration further raises the accuracy.
The results also validate our hypothesis that temporal modelling can benefit from temporally adaptive weights. 
Further, TAdaConv generates calibration weight from both local (C\x T) and global (C\x1) contexts and achieves the highest performance. 

\textbf{Calibration weight initialization.} Next, we show that our initialization strategy for the calibration weight generation plays a critical role for dynamic weight calibration.
As in Table~\ref{tab:calibrationsource}, randomly initializing learnable weights slightly degrades the performance, while randomly initializing dynamic calibration weights (by randomly initializing the last layer of the weight generation function) notably degenerates the performance. 
It is likely that randomly initialized dynamic calibration weights purturb the pre-trained weights more severely than the learnable weights since it is dependent on the input.
Further comparisons on the initialization are shown in the Table~\ref{tab:compdyconvperf} in the Appendix.


\textbf{Calibration weight generation function. } 
Having established that the temporally adaptive dynamic calibration with appropriate initialization can be an ideal strategy for temporal modelling, we further ablate different ways for generating the calibration weight in Table~\ref{tab:calibrationweightgen}. 
Linear weight generation function (\textit{Lin.}) applies a single 1D convolution to generate the calibration weight, while non-linear one (\textit{Non-Lin.}) uses two stacked 1D convolutions with batch normalizations and ReLU activation in between. 
When no temporal context is considered (K.=1 or (1,1)), TAdaConv can still improve the baseline but with a limited gap.
Enlarging the kernel size to cover the temporal context (K.=3, (1,3), (3,1) or (3,3)) further yields a boost of over 20\% on the accuracy, with K.=(3,3) having the strongest performance.
This shows the importance of the local temporal context during calibration weight generation.
Finally, for the scope of temporal context, introducing global context to frame descriptors performs similarly to only generating temporally adaptive calibration weights solely on the global context (in Table~\ref{tab:calibrationsource}). 
The combination of the global and temporal context yields a better performance for both variants.
We further show in Appendix~\ref{appendix:comparisondynamicfilter} that this function in our TAdaConv yields a better calibration on the base weight than other existing dynamic filters.

\textbf{Feature aggregation. }The feature aggregation module used in the TAda2D network is ablated in Table~\ref{tab:featureaggregation}. First, the performance is similar for plain aggregation  and aggregation with a shortcut (Sc.) branch , with Sc. being slightly better. Separating the batchnorm (Eq.~\ref{eq:aggregation}) for the shortcut and the aggregation branch brings notable improvement.
Strided max and mix (avg+max) pooling slightly underperform the average pooling variant. 
Overall, the combination of TAdaConv and our feature aggregation scheme has an advantage over the TSN baseline of 31.8\%. 

\begin{wraptable}[6]{r}{0.35\textwidth}
\tablestyle{2pt}{1.0}
\vspace{-1.5em}
\caption{Calibration dimension.}
\vspace{-1.2em}
\centering
    \begin{tabular}{lccc}
		\shline
\bf Cal. dim. & \bf   & \bf  &\bf Top-1 \\
\hline
 & 3.16M & 0.016 &63.8 \\
\hline
 & 3.16M & 0.016 & 63.4 \\
 & 4.10M & 0.024 & 63.7 \\
 & 2.24M & 0.009 & 62.7 \\
\shline
	\end{tabular}
	\label{tab:calibrationdim}
	\vspace{-2.5em}
\end{wraptable}
\textbf{Calibration dimension. }
Multiple dimensions can be calibrated in the base weight.
Table~\ref{tab:calibrationdim} shows that calibrating the channel dimension more suitable than the spatial dimension, which means that the spatial structure of the original convolution kernel should be retained. 
Within channels, the calibration works better on  than  or both combined.
This is probably because the calibration weight generated by the input feature can better adapt to itself.

\textbf{Different stages employing TAdaConv. }The solid lines in Fig~\ref{fig:proportions} show the stage by stage replacement of the spatial convolutions in a ResNet model.
It has a minimum improvement of 17.55\%, when TAdaConv is employed in \textit{Res2}.
Compared to early stages, later stages contribute more to the final performance, as later stages provide more accurate calibration because of its high abstraction level.
Overall, TAdaConv is used in all stages for the highest accuracy. 

\textbf{Different proportion of channels calibrated by TAdaConv. }Here, we calibrate only a proportion of channels using TAdaConv and leave the other channels uncalibrated. The results are presented as dotted lines in Fig~\ref{fig:proportions}. 
We find TAdaConv can improve the baseline by a large margin even if only 1/64 channels are calibrated, with larger proportion yielding further larger improvements.

\begin{table}[t]
\caption{Comparison with the top approaches on Something-Something-V2~\citep{ssv2}.
}
\centering
\tablestyle{3pt}{1.0}
\begin{tabular}{lccccc}
\shline
\bf Model & \bf Backbone & \bf Frames\x clips\x crops & \bf GFLOPs & \bf Top-1 & \bf Top-5 \\
\hline
\gray  TDN~\citep{tdn} & \gray ResNet-50 & \gray (8+32)\x1\x1 & \gray 47 &\gray64.0 & \gray88.8 \\
\gray  TDN~\citep{tdn} & \gray ResNet-50 & \gray (16+64)\x1\x1 & \gray 94 & \gray 65.3 & \gray 89.5 \\
\gray  TDN~\citep{tdn} & \gray ResNet-50 & \gray (8+32+16+64)\x1\x1 & \gray 141 &\gray 67.0 & \gray 90.3 \\
\hline
TSM~\citep{tsm} & ResNet-50 & 82\x3 & 43 & 59.1 & 85.6 \\
TSM~\citep{tsm} & ResNet-50 & 162\x3 & 86 & 63.4 & 88.5 \\
SmallBigNet~\citep{smallbignet} & ResNet-50 & 82\x3 & 57 & 61.6 & 87.7 \\
SmallBigNet~\citep{smallbignet} & ResNet-50 & 162\x3 & 114 & 63.8 & 88.9 \\ 
SmallBigNet~\citep{smallbignet} & ResNet-50 & (8+16)\x2\x3 & 171 & 64.5 & 89.1 \\
TANet~\citep{tam} & ResNet-50 & 82\x3 & 43 & 62.7 & 88.0 \\
TANet~\citep{tam} & ResNet-50 & 162\x3 & 86 & 64.6 & 89.5 \\
TANet~\citep{tam} & ResNet-50 & (8+16)\x2\x3 & 129 & 64.6 & 89.5 \\
\hline
TAda2D (Ours) & ResNet-50 & 82\x3 & 43 & 64.0 & 88.0 \\
TAda2D (Ours) & ResNet-50 & 162\x3 & 86 & 65.6 & 89.2 \\
TAda2D (Ours) & ResNet-50 & (8+16)\x2\x3 & 129 & 67.2 & 89.8 \\
\hline
TAdaConvNeXt-T (Ours) & ConvNeXt-T & 162\x3 & 47 & 64.8 & 88.8 \\
TAdaConvNeXt-T (Ours) & ConvNeXt-T & 322\x3 & 94 & 67.1 & 90.4 \\
\shline
\multicolumn{5}{l}{\makecell[l]{\scriptsize {\color{gray} Gray} font indicates models with different inputs. FLOPs are calculated with 256\x256 resolution as in the evaluation.}}
\end{tabular}
\label{tab:main-ssv2}
\vspace{-2mm}
\end{table}
\textbf{Visualizations.} We qualitatively evaluate our approach in comparison with the baseline approaches (TSN and R(2+1)D) by presenting the Grad-CAM~\citep{gradcam} visualizations of the last stage in Fig.~\ref{fig:visualization}. TAda2D can more completely spot the key information in videos, thanks to the temporal reasoning based on global spatial information and the global temporal information.

\subsection{Main results}
\begin{table}[t]
\caption{Comparison with the state-of-the-art approaches over action classification on Epic-Kitchens-100~\citep{ek100}.  indicates our own implementation for fair comparison.  indicates the main evaluation metric for the dataset.}
\centering
\tablestyle{5.5pt}{1.0}
\begin{tabular}{lccccccc}
\shline
~ & ~ & \multicolumn{3}{c}{\bf Top-1} & \multicolumn{3}{c}{\bf Top-5} \\
\cmidrule(r){3-5}\cmidrule(r){6-8}
\bf Model & \bf Frames & \textbf{Act.} & Verb & Noun &\textbf{Act.} & Verb & Noun \\
\hline
TSN~\citep{tsn} & 8 & 33.19 & 60.18 & 46.03 & 55.13 & 89.59 & 72.90 \\
TRN~\citep{trn} & 8 & 35.34 & 65.88 & 45.43 & 56.74 & 90.42 & 71.88 \\ 
TSM~\citep{tsm} & 8 & 38.27 & 67.86 & 49.01 & 60.41 & 90.98 & 74.97 \\
SlowFast~\citep{slowfast} & 8+32 & 38.54 & 65.56 & 50.02 & 58.60 & 90.00 & 75.62 \\
\hline
TSN (Our baseline) & 8 & 30.15 & 51.89 & 45.77 & 53.00 & 87.51 & 72.16\\
TAda2D (Ours) & 8 & 41.61 & 65.14 & 52.39 & 61.98 & 90.54 & 76.45\\
\shline
\end{tabular}
\label{tab:epickitchensclassification}
\vspace{-2mm}
\end{table}

\textbf{SSV2.} As shown in Table~\ref{tab:main-ssv2}, 
TAda2D outperforms previous approaches using the same number of frames. 
Compared to TDN that uses more frames, TAda2D performs competitively.
Visualization in Fig.~\ref{fig:proportions}(b) also demonstrates the superiority of our performance/efficiency trade-off.
An even stronger performance is achieved with a similar amount of computation by TAdaConvNeXt, which provides an accuracy of 67.1\% with 94GFLOPs.

\textbf{Epic-Kitchens-100.} Table~\ref{tab:epickitchensclassification} lists our results on EK100 in comparison with the previous approaches\footnote{The performances are referenced from the official release of the EK100 dataset \citep{ek100}.}. 
We calculate the final action prediction following the strategies in \citet{vivitek100}.
For fair comparison, we reimplemented our baseline TSN using the same training and evaluation strategies. 
TAda2D improves this baseline by 11.46\% on the action prediction. 
Over previous approaches, TAda2D achieves a higher accuracy with a notable margin.

\textbf{Kinetics-400. }Comparison with the state-of-the-art models on Kinetics-400 is presented in Table~\ref{tab:main-k400}, where we show TAda2D performs competitively in comparison with the models using the same backbone and the same number of frames.
Compared with models with more frames, \textit{e.g.,} TDN, TAda2D achieves a similar performance with less frames and computation.
When compared to the more recent Transformer-based models, our TAdaConvNeXt-T provides competitive accuracy with similar or less computation.

\begin{table}[t]
\caption{Comparison with the state-of-the-art approaches on Kinetics 400~\citep{kinetics400}. }
\centering
\vspace{-1mm}
\tablestyle{5pt}{1.0}
\begin{tabular}{lccccc}
\shline
\bf Model & \bf Pretrain & \bf Frames & \bf GFLOPs & \bf Top-1 & \bf Top-5 \\
\hline
TSM~\citep{tsm} & IN-1K & 8\x3\x10 & 43 & 74.1 & N/A\\
SmallBigNet~\citep{smallbignet} & IN-1K & 8\x3\x10 & 57 & 76.3 & 92.5 \\
TANet~\citep{tam} & IN-1K & 8\x3\x10 & 43 & 76.3 & 92.6 \\
TANet~\citep{tam} & IN-1K &  16\x3\x10 & 86 & 76.9 & 92.9 \\
SlowFast 4\x16~\citep{slowfast} & - &  (4+32)\x3\x10 &  36.1 &  75.6 & 92.1 \\
SlowFast 8\x8~\citep{slowfast} & - &  (8+32)\x3\x10 &  65.7 & 77.0 & 92.6 \\
TDN~\citep{tdn} & IN-1K & (8+32)\x3\x10 &  47 &  76.6 &  92.8\\
TDN~\citep{tdn} & IN-1K & (16+64)\x3\x10 &  94 &  77.5 &  93.2\\
CorrNet~\citep{corrnet} & IN-1K & 32\x1\x10 & 115 & 77.2 & N/A \\
\hline
TAda2D (Ours) & IN-1K & 8\x3\x10 & 43 & 76.7 & 92.6 \\
TAda2D (Ours) & IN-1K & 16\x3\x10 & 86 & 77.4 & 93.1 \\
TAda2D (Ours) & IN-1K & (8+16)\x3\x10 & 129 & 78.2 & 93.5\\
\shline
MViT-B~\citep{mvit} & - & 16\x1\x5 & 70.5 & 78.4 & 93.5\\
MViT-B~\citep{mvit} & - & 32\x1\x5 & 170 & 80.2 & 94.4 \\
TimeSformer~\citep{timesformer} & IN-21K & 8\x3\x1 & 196 & 78.0 & 93.7 \\
ViViT-L~\citep{arnab2021vivit} & IN-21K & 16\x3\x4 & 1446 & 80.6 & 94.6\\
Swin-T~\citep{videoswin} & IN-1K & 32\x3\x4 & 88 & 78.8 & 93.6 \\
\hline
TAdaConvNeXt-T (Ours) & IN-1K & 16\x3\x4 & 47 & 78.4 & 93.5 \\
TAdaConvNeXt-T (Ours) & IN-1K & 32\x3\x4 & 94 & 79.1 & 93.7 \\
\shline
\end{tabular}
\label{tab:main-k400}
\vspace{-3mm}
\end{table}

\newcommand{\hacs}[1]{\multirow{3}{*}{#1}}
\begin{table}[t]
\caption{Action localization evaluation on HACS and Epic-Kitchens-100.  indicates the main evaluation metric for the dataset, \textit{i.e.,} average mAP for action localization.}
\centering
\vspace{-1mm}
\tablestyle{3pt}{1.0}
\begin{tabular}{lccccccccccccc}
\shline
~ & \multicolumn{6}{c}{\bf HACS} & \multicolumn{7}{c}{\bf Epic-Kitchens-100} \\
\cmidrule(r){2-7} \cmidrule(r){8-14}
\bf Model & @0.5 & @0.6 & @0.7 & @0.8 & @0.9 & \bf Avg. & Task & @0.1 & @0.2 & @0.3 & @0.4 & @0.5 & \bf Avg. \\
\hline
\multirow{3}{*}{TSN} & \hacs{43.6} & \hacs{37.7} & \hacs{31.9} & \hacs{24.6} & \hacs{15.0} & \hacs{28.6} & Verb & 15.98 & 15.01 & 14.09 & 12.25 & 10.01 & 13.47\\
~ & ~ & ~ & ~ & ~ & ~ & ~ & Noun &15.11 & 14.15 & 12.78 & 10.94 & 8.89 & 12.37\\
~ & ~ & ~ & ~ & ~ & ~ & ~ & \bf Act. & 10.24 & 9.61 & 8.94 & 7.96 & 6.79 & 8.71\\
\hline
\multirow{3}{*}{TAda2D} & \hacs{48.7} & \hacs{42.7} & \hacs{36.2} & \hacs{28.1} & \hacs{17.3} & \hacs{32.3} & Verb & 19.70 & 18.49 & 17.41 & 15.50 & 12.78 & 16.78 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & Noun & 20.54 & 19.32 & 17.94 & 15.77 & 13.39 & 17.39 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & \bf Act. & 15.15 & 14.32 & 13.59 & 12.18 & 10.65 & 13.18 \\
\shline
\end{tabular}
\label{tab:localization}
\vspace{-4mm}
\end{table}

\section{Experiments on temporal action localization}
\label{sec:exp-tal}

\textbf{Dataset, pipeline, and evaluation.} 
Action localization is an essential task for understanding untrimmed videos, whose current pipeline makes it heavily dependent on the quality of the video representations.
We evaluate our TAda2D on two large-scale action localization datasets, HACS~\citep{hacs} and Epic-Kitchens-100~\citep{ek100}.
The general pipeline follows~\citep{ek100,ek100actionlocalization,hacscompetition}.
For evaluation, we follow the standard protocol for the respective dataset.
We include the details on the training pipeline and the evaluation protocal in the Appendix~\ref{appendix:implementationdetails}.

\textbf{Main results.} 
Table~\ref{tab:localization} shows that, compared to the baseline, TAda2D provides a stronger feature for temporal action localization, with an average improvement of over 4\% on the average mAP on both datasets. In Appendix~\ref{appendix:pluginlocalization}, we further demonstrate the TAdaConv can also improve action localization when used as a plug-in module for existing models.

\section{Conclusions}
This work proposes Temproally-Adaptive Convolutions (TAdaConv) for video understanding, which dynamically calibrates the convolution weights for each frame based on its local and global temporal context in a video. 
TAdaConv shows superior temporal modelling abilities on both action classification and localization tasks, both as stand-alone and plug-in modules for existing models.
We hope this work can facilitate further research in video understanding.
\newpage
\textbf{Acknowledgement:} This research is supported by the Agency for Science, Technology and Research (A*STAR) under its AME Programmatic Funding Scheme (Project \#A18A2b0046), by the RIE2020 Industry Alignment Fund – Industry Collaboration Projects (IAF-ICP) Funding Initiative, as well as cash and in-kind contribution from the industry partner(s), and by Alibaba Group through Alibaba Research Intern Program. 

\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\clearpage

\appendix
\renewcommand{\thetable}{A\arabic{table}}
\renewcommand{\thefigure}{A\arabic{figure}}
\setcounter{figure}{0}
\setcounter{table}{0}
\section*{Appendix}
In the appendix, we provide detailed analysis on the temporal convolutions (Appendix~\ref{appendix:tempconvs}), computational analysis (Appendix~\ref{appendix:companalysis}), further implementation details (Appendix~\ref{appendix:implementationdetails}) on the action classification and localization, model structures that we used for evaluation (Appendix~\ref{appendix:modelstructure}), per-category improvement analysis on Something-Something-V2 (Appendix~\ref{appendix:percategoryimprovement}), further plug-in evaluations on Epic-Kitchens classification (Appendix~\ref{appendix:pluginclassification}) plug-in evaluations on the temporal action localization task (Appendix~\ref{appendix:pluginlocalization}), the visualization of the training procedure of TSN and TAda2D (Appendix~\ref{appendix:trainingprocedure}), as well as detailed comparisons between TAdaConv and existing dynamic filters (Appendix~\ref{appendix:comparisondynamicfilter}).
Further, we show additional qualitative analysis in Fig.~\ref{fig:furtherqualitative}.

\section{Detailed analysis on temporal convolutions}
\label{appendix:tempconvs}
Here, we provide detailed analysis to showcase the underlying process of temporal modelling by temporal convolutions. As in Sec.~\ref{Sec:TempConv}, we use depth-wise temporal convolutions for simplicity and its wide application. We first analyze the case where temporal convolutions are directly placed after spatial convolutions without non-linear activation in between, before activation functions is inserted in the second part of our analysis. 


\textbf{Without activation. }We first consider a simple case with no non-linear activation functions between the temporal convolution and the spatial convolution. 
Given a 3\x1\x1 depth-wise temporal convolution parameterized by , where , a spatial convolution parameterized by , the output feature  of the -th frame can be obtained by:

\noindent where  denotes element-wise multiplication with broadcasting, and  denotes convolution over the spatial dimension. 
In this case,  could be grouped with the spatial convolution weight  and the combination of temporal and spatial convolution can be rewritten as Eq.~\ref{eq:simplerform_tempspatconv} in the manuscript:

\noindent where ,  and . 
This equation share the same form with the Eq.~\ref{eq:simplerform_tempspatconv} in the manucript.
In this case, the combination of temporal convolution with spatial convolution can be certainly viewed as the temporal convolution is simply performing calibration on spatial convolutions before aggregation, with different weights assigned to different time steps for the calibration. 

\textbf{With activation.} Next, we consider a case where activation is in between the temporal convolution and spatial convolution. The output feature  are now obtained by Eq.~\ref{eq:tempspatconv} in the manuscript:


Next, we show that this can be still rewritten in the form of Eq.~\ref{eq:simplerform_tempspatconv}. Here, we consider the case where ReLU~\citep{relu} is used as the activation function, denoted as :

Hence, the term  can be easily expressed as:

\noindent where  is a binary map sharing the same shape as , indicating whether the corresponding element in  is greater than 0 or not. That is:

\noindent where  are the location index in the tensor.
Hence, Eq.~\ref{eq:tempspatconv} can be expressed as:

\noindent In this case, we can set , , and , where  indicate the spatial location index.
In this case, each filter for a specific time step  is composed of  filters and Eq.~\ref{eq:tempspatconv} can be rewritten as Eq.~\ref{eq:simplerform_tempspatconv}. 
Interestingly, it can be observed that with ReLU activation function, the convolution weights are different for all spatio-temporal locations, since the binary map  depends on the results of the spatial convolutions. 

\section{Computational analysis}
\label{appendix:companalysis}
Consider the input tensor with the shape of , where  denotes the number of input channels, TAdaConv essentially performs 2D convolution, with weights dynamically generated. Hence, a good proportion of the computation is carried out by the 2D convolutions:


\noindent where  denote the number of output channels, and  denotes the kernel size of the 2D convolutions. For the weight generation, the features are first aggregated by average pooling over the spatial dimension and the temporal dimension, which contains no parameters:

For the local information, a two layer 1D convolution with kernel size of  are applied, with reduction ratio of  in between. For global information, a one layer 1D convolution with kernel size of  is applied.

Further, the calibration weight  is multiplied to the kernel weight of 2D convolutions :

Hence, the overall computation and parameters are:


For the FLOPs, despite the overwhelming number of terms, all the other terms are at least an order of magnitude smaller than the first term. This is in contrast to the (2+1)D convolutions for spatio-temporal modelling, where the FLOPs are . The extra computation introduced by the temporal convolutions is only  times smaller than the 2D convolutions. 
Table~\ref{tab:apptemporalmodellingcomparison} shows the comparison of computation and parameters with other approaches.


\begin{table}[t]
\caption{Comparison of different operations for spatial and temporal modeling~\citep{tsm,r21d,corrnet,retrace}. 'T.' refers to the temporal modeling ability.
}
\centering
\tablestyle{2pt}{1.0}
\begin{tabular}{lcccc}
\shline
\bf T. & \bf Operation & \bf Parameters & \bf FLOPs \\
\hline
\xmark & Spat. conv &  &   \\
\hline
\cmark & Temp. conv &  &   \\
\cmark & Temp. shift &  &  \\
\cmark & (2+1)D conv &  &  \\
\cmark & 3D conv &  &  \\
\cmark & Correlation &  & \\
\hline
\multirow{2}{*}{\cmark} & \multirow{2}{*}{TAdaConv} & \multirow{2}{*}{} & \\
~ & ~ & ~ & \\
\shline
\end{tabular}
\label{tab:apptemporalmodellingcomparison}
\end{table}


\section{Further implementation details}
\label{appendix:implementationdetails}
Here, we further describe the implementation details for the action classification and action localization experiments.
For fair comparison, we keep all the training strategies the same for our baseline, the plug-in evaluations as well as our own models.

\subsection{Action classification}
Our experiments on the action classification are conducted on three large-scale datasets.
For all action classification models, we train them with synchronized SGD using 16 GPUs. The batch size for each GPU is 16 and 8 respectively for 8-frame and 16-frame models. The weights in TAda2D are initialized using ImageNet~\citep{imagenet} pre-trained weights~\citep{resnet}, except for the calibration function  and the batchnorm statistics () in the average pooling branch.
In the calibration function, we randomly initialize the first convolution layer (for non-linear weight generation) following~\citet{kaiminginit}, and fill zero to the weight of last convolution layer. 
The batchnorm statistics are initialized to be zero so that the initial state behaves the same as without the average pooling branch. For all models, we use a dropout ratio~\citep{dropout} of 0.5 before the classification heads. Spatially, we randomly resize the short side of the video to [256, 320] and crop a region of 224\x224 to the network in ablation studies, and set the scale to [224, 340] following TANet~\citep{tam} for comparison against the state-of-the-arts. Temporally, we perform interval based sampling for Kinetics-400 and Epic-Kitchens-100, with interval of 8 for 8 frames, interval of 5 for 16 frames and interval of 2 for 32 frames. On Something-Something-V2, we perform segment based sampling.

On \textit{Kinetics-400}, a half-period cosine schedule is applied for decaying the learning rate following~\citet{slowfast}, with the base learning rate set to 0.24 for ResNet-base models using SGD. For TAdaConvNeXt, the base learning rate is set to 0.0001 for the backbone and 0.001 for the head, using adamw~\citep{adamw} as the optimizer. The models are trained for 100 epochs. In the first 8 epochs, we adopt a linear warm-up strategy starting from a learning rate of 0.01. The weight decay is set to 1e-4. The frames are sampled based on a fixed interval, which is 8 for 8-frame models, 5 for 16-frame models and 2 for 32-frame models. Additionally for TAdaConvNeXt-T, a drop-path rate of 0.4 is employed.

On \textit{Epic-Kitchens-100}, the models are initialized with weights pre-trained on Kinetics-400, and are further fine-tuned following a similar strategy as in kinetics. The training length is reduced to 50 epochs, with 10 epochs for warm-up.
The base learning rate is 0.48.
Following \citet{ek100} and \citet{vivitek100}, we connect two separate heads for predicting verbs and nouns. Action predictions are obtained according to the strategies in \citet{vivitek100}, which is shown to have a higher accuracy over the original one in \citet{ek100}. For fair comparison, we also trained and evaluated our baseline using the same strategy.

On \textit{Something-Something-V2}, we initialize the model with ImageNet pretrained weights for ResNet-based models and Kinetics-400 pre-trained weights for TAdaConvNeXt.
A segment-based sampling strategy is adopted, where for -frame models, the video is divided into  segments before one frame is sampled from each segment randomly for training or uniformly for evaluation. 
The models are trained for 64 epochs, with the first 4 being the warm-up epochs. 
The base learning rate is set to 0.48 in training TAda2D with SGD, and 0.001/0.0001 respectively for the head and the backbone in training TAdaConvNeXt with adamw. Following~\citet{videoswin}, we use stronger augmentations such as mixup~\citep{mixup}, cutmix~\citep{cutmix}, random erasing~\citep{randomerasing} and randaugment~\citep{randaugment} with the same parameters in~\citet{convnext}.

It is worth noting that, for SlowFast models~\citep{slowfast} in the plug-in evaluations, we do not apply precise batch normalization statistics in our implementation as in its open-sourced codes, which is possibly the reason why our re-implemented performance is slightly lower than the original published numbers. 


\subsection{Action Localization}
We evaluate our model on the action localization task using two large-scale datasets. 
The overall pipeline for our action localization evaluation is divided into finetuning the classification models, obtaining action proposals and classifying the proposals.

\textbf{Finetuning. }On \textit{Epic-Kitchens}, we simply use the evaluated action classification model. On \textit{HACS}, following~\citep{hacscompetition}, we initialize the model with Kinetics-400 pre-trained weights and train the model with adamW for 30 epochs (8 warmups) using 32 GPUs. 
The mini-batch size is 16 videos per GPU. 
The base learning rate is set to 0.0002, with cosine learning rate decay as in Kinetics.
In our case, only the segments with action labels are used for training.

\textbf{Proposal generation.} 
For the action proposals, a boundary matching network (BMN)~\citep{bmn} is trained over the extracted features on the two datasets. 
On \textit{Epic-Kitchens}, we extract features with the videos uniformly decoded at 60 FPS. 
For each clip, we use 8 frames with an interval of 8 to be consistent with finetuning, which means a feature roughly covers a video clip of one seconds. 
The interval between each clip for feature extraction is 8 frames (\textit{i.e.,} 0.133 sec) as well.
The shorter side of the video is resized to 224 and we feed the whole spatial region into the backbone to retain as much information as possible.
Following \citet{ek100actionlocalization}, we generate proposals using BMN based on sliding windows.
The predictions on the overlapped region of different sliding windows are simply averaged.
On \textit{HACS}, the videos are decoded at 30 FPS, and extend the interval between clips to be 16 (\textit{i.e.,} 0.533 sec) because the actions in HACS last much longer than in Epic-Kitchens. 
The shorter side is resized to 128 for efficient processing. 
For the settings in generating proposals, we mainly follow~\citet{hacscompetition}, except that the temporal resolution is resized to 100 in our case instead of 200.

\textbf{Classification. }On \textit{Epic-Kitchens}, we classify the proposals with the fine-tuned model using 6 clips. Spatially, to comply with the feature extraction process, we resize the shorter side to 224 and feed the whole spatial region to the model for classification.
On \textit{HACS}, considering the property of the dataset that only one action category can exist in a video, we obtain the video level classification results by classifying the video level features, following~\citet{hacscompetition}.

\textbf{Evaluation.} For evaluation, we follow the standard evaluation protocol used in the respective datasets, \textit{i.e.,} the average mean Average Precision (average mAP) at IoU threshold [0.5:0.05:0.95] for HACS~\citep{hacs} and [0.1:0.1:0.5] for Epic-Kitchens-100~\citep{ek100}. 

\section{Model structures}
\label{appendix:modelstructure}
\newcommand{\blockrtd}[3]{\multirow{4}{*}{-.1em] \textbf{\textcolor{themeblue}{\text{3\x3, #2}}}\\x#3}
}
\newcommand{\blockrtpod}[3]{\multirow{4}{*}{-.1em] \textbf{\textcolor{themeblue}{\text{1\x3, #2}}}\-.1em]\text{1\x1, #1}\end{array}\right]\left[\begin{array}{c}\text{1\x1, #2}\-.1em] \text{1\x1, #1}\end{array}\right]\x#3}
}
\begin{table}[t]
\centering
\caption{Model structure of R3D, R(2+1)D and R2D that we used in our experiments.
\textbf{\textcolor{themeblue}{Blue}} and \textbf{\textcolor{themegreen}{green}} fonts indicate respectively the default convolution operation and optional operation that can be replaced by TAdaConv. (Better viewed in color.)
}
\tablestyle{3pt}{1.08}
\begin{tabular}{c|c|c|c|c}
\shline
\bf Stage & \bf R3D & \bf R(2+1)D & \bf R2D (default baseline) & \bf output sizes \\
\shline
Sampling & interval 8, 1 & interval 8, 1 & interval 8, 1 &  8\x224\x224   \\
\hline
\multirow{2}{*}{conv} & 3\x7, {64} & 1\x7, {64} & 1\x7, {64} & \multirow{2}{*}{8\x112\x112}     \\
& stride 1, 2 & stride 1, 2 & stride 1, 2  \\
\hline
\multirow{4}{*}{res} & \blockrtd{{256}}{{64}}{3} & \blockrtpod{{256}}{{64}}{3} & \blockresnet{{256}}{{64}}{3} & \multirow{4}{*}{8\x56\x56} \\
&  &  & \\
&  &  & \\
&  &  & \\
\hline
\multirow{4}{*}{res} & \blockrtd{{512}}{{128}}{4} & \blockrtpod{{512}}{{128}}{4} & \blockresnet{{512}}{{128}}{4} & \multirow{4}{*}{8\x28\x28} \\
&  &  & \\
&  &  & \\
&  &  & \\
\hline
\multirow{4}{*}{res} & \blockrtd{{1024}}{{256}}{6} & \blockrtpod{{1024}}{{256}}{6} & \blockresnet{{1024}}{{256}}{6} & \multirow{4}{*}{8\x14\x14} \\
&  &  & \\
&  &  & \\
&  &  & \\
\hline
\multirow{4}{*}{res} & \blockrtd{{2048}}{{512}}{3} & \blockrtpod{{2048}}{{512}}{3} & \blockresnet{{2048}}{{512}}{3} & \multirow{4}{*}{8\x7\x7} \\
&  &  & \\
&  &  & \\
&  &  & \\
\hline
\multicolumn{4}{c|}{global average pool, fc}  & 1\x1\x1 \\
\shline
\end{tabular}
\label{tab:arch}
\end{table}
The detailed model structures for R2D, R(2+1)D and R3D is specified in Table~\ref{tab:arch}. 
We highlight the convolutions that are replaced by TAdaConv by default or optionally.
For all of our models, a small modification is made in that we remove the max pooling layer after the first convolution and set the spatial stride of the second stage to be 2, following~\citet{corrnet}. 
Temporal resolution is kept unchanged following recent works~\citep{slowfast,tea,stm}. 
Our \textit{R3D} is obtained by simply expanding the R2D baseline in the temporal dimension by a factor of three. 
We initialize with weights reduced by 3 times, which means the original weight is evenly distributed in adjacent time steps.
We construct the \textit{R(2+1)D} by adding a temporal convolution operation after the spatial convolution. 
The temporal convolution can also be optionally replaced by TAdaConv, as shown in Table~\ref{tab:plugineval} and Table~\ref{tab:pluginevalepickitchen}.
For its initialization, the temporal convolution weights are randomly initialized, while the others are initialized with the pre-trained weights on ImageNet.
For SlowFast models, we keep all the model structures identical to the original work~\citep{slowfast}.

For TAdaConvNeXt, we keep most of the model architectures as in ConvNeXt~\citep{convnext}, except that we use a tubelet embedding similar to~\citep{arnab2021vivit}, with a size of 3\x4\x4 and stride of 2\x4\x4. Center initialization is used as in \citep{arnab2021vivit}. Based on this, we simply replace the depth-wise convolutions with TAdaConv to construct TAdaConvNeXt.
\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{diff_tsn.pdf}
\caption{\textbf{Per-category performance comparison of TAda2D against the baseline TSN.} We achieve an average per-category performance improvement of 30.35\%. }
\label{fig:diff_tsn}
\end{figure}
\begin{table}[t]
\caption{Comparison with the state-of-the-art approaches over action classification on Epic-Kitchens-100~\citep{ek100}.  indicates the main evaluation metric for the dataset. For fair comparison, we implement all the baseline models using our own training strategies.}
\centering
\tablestyle{3pt}{1.0}
\begin{tabular}{lccccccccc}
\shline
~ & ~ & ~ & ~ & \multicolumn{3}{c}{\bf Top-1} & \multicolumn{3}{c}{\bf Top-5} \\
\cmidrule(r){5-7}\cmidrule(r){8-10}
\bf Model & \bf Frames & \bf GFLOPs & \bf Params.& \textbf{Act.} & Verb & Noun &\textbf{Act.} & Verb & Noun \\
\hline
SlowFast 4\x16 & 4+32 & 36.10 & 34.5M & 38.17 & 63.54 & 48.79 & 58.68 & 89.75 & 73.37 \\
SlowFast 4\x16 + TAdaConv & 4+32 & 36.11 & 37.7M & 39.14 & 64.50 & 49.59 & 59.21 & 89.67 & 73.88 \\
\hline
SlowFast 8\x8 & 8+32 & 65.71 & 34.5M & 40.08 & 65.05 & 50.72 & 60.10 & 90.04 & 74.26 \\ 
SlowFast 8\x8 + TAdaConv & 8+32 & 65.73 & 37.7M & 41.35 & 66.36 & 52.32 & 61.68 & 90.59 & 75.89 \\
\hline
R(2+1)D & 8 & 49.55 & 28.1M & 37.45 & 62.92 & 48.27 & 58.02 & 89.75 & 73.60 \\
R(2+1)D + TAdaConv & 8 & 49.57 & 31.3M & 39.72 & 64.48 & 50.26 & 60.22 & 90.01 & 75.06\\
R(2+1)D + TAdaConv & 8 & 49.58 & 34.4M & 40.10 & 64.77 & 50.28 & 60.45 & 89.99 & 75.55\\
\hline
R3D & 8 & 84.23 & 47.0M & 36.67 & 61.92 & 47.87 & 57.47 & 89.02 & 73.05 \\
R3D + TAdaConv & 8 & 84.24 & 50.1M & 39.30 & 64.03 & 49.94 & 59.67 & 89.84 & 74.56\\
\shline
\end{tabular}
\label{tab:pluginevalepickitchen}
\end{table}
\begin{table}[t]
\caption{Ablation studies.}
\vspace{-3mm}
\centering
\subfloat[Ablation studies on kernel size with linear calibration weight generation function.
\label{tab:ablationstudieskernelsizelin}]{
\tablestyle{10pt}{1.0}
\begin{tabular}{cc}
\shline
\bf Kernel size & \bf Top-1\\
\hline
1 & 37.5 \\
3 & 56.5 \\
5 & 57.3 \\
7 & 56.5 \\
\shline
\end{tabular}
}\hspace{3mm}
\subfloat[Ablation studies on kernel size with non-linear calibration weight generation function.
\label{tab:ablationstudieskernelsizenonlin}]{
\tablestyle{4pt}{1.0}
\begin{tabular}{c|cccc}
\shline
~ & \bf K=1 & \bf K=3 & \bf K=5 & \bf K=7 \\
\hline
\bf K=1 & 36.8 & 57.1 & 57.8 & 57.9 \\
\bf K=3 & 57.3 & 57.8 & 57.9 & 58.0 \\
\bf K=5 & 57.6 & 57.9 & 58.2 & 57.9 \\
\bf K=7 & 57.4 & 57.6 & 58.0 & 57.6 \\
\shline
\end{tabular}
}\hspace{3mm}
\subfloat[Ablation studies on reduction ratio  for .
\label{tab:ablationstudiesreductionratio}]{
\tablestyle{6pt}{1.0}
\begin{tabular}{cc}
\shline
\bf Ratio  & \bf Top-1 \\
\hline
1 & 57.79\\
2 & 57.83\\
4 & 57.78\\
8 & 57.66\\
\shline
\end{tabular}
}
\end{table}

\begin{table}[t]
\caption{Plug-in evaluation of TAdaConv on the action localization on HACS and Epic-Kitchens.  indicates the main evaluation metric for the dataset. `S.F.' is SlowFast network.}
\centering
\tablestyle{2pt}{1.0}
\begin{tabular}{lccccccccccccc}
\shline
~ & \multicolumn{6}{c}{\bf HACS} & \multicolumn{7}{c}{\bf Epic-Kitchen-100} \\
\cmidrule(r){2-7} \cmidrule(r){8-14}
\bf Model & @0.5 & @0.6 & @0.7 & @0.8 & @0.9 & \bf Avg. & Task & @0.1 & @0.2 & @0.3 & @0.4 & @0.5 & \bf Avg. \\
\hline
\multirow{3}{*}{S.F. 8\x8} & \hacs{50.0} & \hacs{44.1} & \hacs{37.7} & \hacs{29.6} & \hacs{18.4} & \hacs{33.7} & Verb & 19.93 & 18.92 & 17.90 & 16.08 & 13.24 & 17.21 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & Noun & 17.93 & 16.83 & 15.53 & 13.68 & 11.41 & 15.07 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & \bf Act. & 14.00 & 13.19 & 12.37 & 11.18 & 9.52 & 12.04\\
\hline
\multirow{3}{*}{S.F. 8\x8 + TAdaConv} & \hacs{51.7} & \hacs{45.7} & \hacs{39.3} & \hacs{31.0} & \hacs{19.5} & \hacs{35.1} & Verb & 19.96 & 18.71 & 17.65 & 15.41 & 13.35 & 17.01 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & Noun & 20.17 & 18.90 & 17.58 & 15.83 & 13.18 & 17.13 \\
~ & ~ & ~ & ~ & ~ & ~ & ~ & \bf Act. & 14.90 & 14.12 & 13.32 & 12.07 & 10.57 & 13.00\\
\shline
\end{tabular}
\label{tab:pluginevallocalization}
\end{table}

\section{Per-category improvement analysis on SSV2}
\label{appendix:percategoryimprovement}
This section provides a per-category improvement analysis on the Something-Something-V2 dataset in Fig.\ref{fig:diff_tsn}.
As shown in Table~\ref{tab:featureaggregation}, our TAda2D achieves an overall improvement of 31.7\%. 
Our per-category analysis shows an mean improvement of 30.35\% over all the classes.
The largest improvement is observed in class 0 (78.5\%, \textit{Approaching something with your camera}), 32 (78.4\%, \textit{Moving away from something with your camera}), 30 (74.3\%, \textit{Lifting up one end of something without letting it drop down}), 44 (66.2\%, \textit{Moving something towards the camera}) and 41 (66.1\%, \textit{Moving something away from the camera}).
Most of these categories contain large movements across the whole video, whose improvement benefits from temporal reasoning over the global spatial context. 
For class 30, most of its actions lasts a long time (as it needs to be determined whether the end of something is let down or not). The improvements over the baseline mostly benefits from the global temporal context that are included in the weight generation process. 

\section{Further ablation studies}
\label{appendix:ablation}
Here we provide further ablation studies on the kernel size in the calibration weight generation. As shown in Table~\ref{tab:ablationstudieskernelsizelin} and Table~\ref{tab:ablationstudieskernelsizenonlin}, kernel size does not affect the classification much, as long as the temporal context is considered. Further, Table~\ref{tab:ablationstudiesreductionratio} shows the sensitivity analysis on the reduction ratio, which demonstrate the robustness of our approach against different set of hyper-parameters. 


\section{Further plug-in evaluation for TAdaConv on classification}
\label{appendix:pluginclassification}

In complement to Table~\ref{tab:plugineval}, we further show in Table~\ref{tab:pluginevalepickitchen} the plug-in evaluation on the action classification task on the Epic-Kitchens-100 dataset.
As in the plug-in evaluation on Kinetics and Something-Something-V2, we compare performances with and without TAdaConv over three baseline models, SlowFast~\citep{slowfast}, R(2+1)D~\citep{r21d} and R3D~\citep{retrace} respectively representing three kinds of temporal modeling techniques. 
The results are in line with our observation in Table~\ref{tab:plugineval}. Over all three kinds of temporal modelling strategies, adding TAdaConv further improves the recognition accuracy of the model.
\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{losses.pdf}
\caption{\textbf{Training and validation on Kinetics-400 and Something-Something-V2.} On both datasets, TAda2D shows a stronger capability of fitting the data and a better generality to the validation set. Further, TAda2D reduces the overfitting problem in Something-Something-V2.}
\label{fig:losses}
\end{figure}
\section{Plug-in evaluation for TAdaConv on Action Localization}
\label{appendix:pluginlocalization}
Here, we show the plug-in evaluation on the temporal action localization task. 
Specifically, we use SlowFast as our baseline, as it is shown to be superior in the localization performance in \citet{tcanet} compared to many early backbones.
The result is presented in Table~\ref{tab:pluginevallocalization}. 
With TAdaConv, the average mAP on HACS is improved by 1.4\%, and the average mAP on Epic-Kitchens-100 action localization is improved by 1.0\%. 

\section{Comparison of training procedure}
\label{appendix:trainingprocedure}
In this section, we compare the training procedure of TSN and TAda2D on Kinetics-400 and Something-Something-V2. The results are presented in Fig.~\ref{fig:losses}. TAda2D demonstrates a stronger fitting ability and generality even from the early stages of the training, despite that the initial state of TAda2D is identical to that of TSN.

\begin{table}[t]
    \tablestyle{3pt}{1.0}
\vspace{-1.5em}
\caption{Approach comparison between different dynamic filters. The weights column denotes how weights in respective approaches are obtained. The pre-trained weights colmun shows whether the weight generation can exploit pre-trained models such as ResNet~\citep{resnet}. 
}
\centering
\begin{tabular}{llccc}
\shline
 ~ & ~ & \textbf{Temporal} &  \textbf{Location} & \textbf{Pretrained}\\
\textbf{Operations} & \textbf{Weights} & \textbf{Modelling} & \textbf{Adaptive} & \textbf{weights}\\
\hline
 CondConv & Mixture of experts  &\xmark & \xmark & \xmark \\
 DynamicFilter & Completely generated  &\xmark & \xmark & \xmark \\
 DDF & Completely generated  & \xmark & \cmark & \xmark \\
 TAM & Completely generated  & \cmark & \xmark & \xmark \\
 TAdaConv & Calibrated from a base weight & \cmark & \cmark & \cmark \\
\shline
\end{tabular}
\label{tab:compdyconvfull}
\end{table}

\section{Comparison with existing dynamic filters}
\label{appendix:comparisondynamicfilter}

In this section, we compare our TAdaConv with previous dynamic filters in two perspectives, respectively the difference in the methodology and in the performance.
\subsection{Comparison in the methodology level}
For the former comparison, we include Table~\ref{tab:compdyconvfull} to show the differences in different approaches, which is a full version of Table~\ref{tab:compdyconv}. We compare TAdaConv with several representative approaches in image and in videos, respectively CondConv~\citep{condconv}, DynamicFilter~\citep{dynamicfilter}, DDF~\citep{ddf} and TAM~\citep{tam}.

The first difference in the methodology level lies in the source of weights, where previous approaches obtain weights by mixture of experts or generation completely dependent on the input.
\textit{Mixture of experts} denotes , where  is a scalar obtained by a function , \textit{i.e.,} .
\textit{Completely generated} means the weights are only dependent on the input, \textit{i.e.,} , where  generates complete kernel for the convolution.
In comparison, the weights in TAdaConv are obtained by \textit{calibration}, \textit{i.e,,} , where  is a vector calibration weight and  where  generates the calibration vector for the convolutions.
Hence, this fundamental difference in how to obtain the convolution weights makes the previous approaches difficult to exploit pre-trained weights, while TAdaConv can easily load pre-trained weights in .
This ability is essential for video models to speed up the convergence.

The second difference lies in the ability to perform temporal modelling. The ability to perform temporal modelling does not only mean the ability to generate weights according to the whole sequence in dynamic filters for videos, but it also requires the model to generate different weights for the same set of frames with different orders.
For example, weights generated by the global descriptor obtained by global average pooling over the whole video  does not have the temporal modelling ability, since they can not generate different weights if the order of the frames in the input sequence are reversed or randomized. Hence, most image based approaches based on global descriptor vectors (such as CondConv and DynamicFilter) or based on adjacent spatial contents (DDF) can not achieve temporal modelling. TAM generates convolution weights for temporal convolutions based on temporally local descriptors obtained by the global average pooling over the spatial dimension , which yields different weights if the sequence changes. Hence, in this sense, TAM has the temporal modelling abilities. In contrast, TAdaConv exploits both temporally local and global descriptors to utilize not only local but also global temporal contexts. Details on the source of the weight generation process is also shown in Table~\ref{tab:compdyconvperf}.

The third difference lies in whether the weights generatd are shared for different locations. 
For CondConv, DynamicFilter and TAM, their generated weights are shared for all locations, while for DDF, the weights are varied according to spatial locations. In comparison, TAdaConv generate temporally adaptive weights.

\begin{table}[]
    \tablestyle{5pt}{1.0}
\vspace{-1.5em}
\caption{{Performance comparison with other dynamic filters.
\textit{Our Init.} denotes initializing the calibration weights to ones so that the initial calibrated weights is identical to the pre-trained weights. Temp. Varying is short for temporally varying, which indicates different weights for different temporal locations (frames).
* denotes that the branch was originally not designed for generating filter or calibration weights, but we slightly modified the structure so that it can be used for calibration weight generation. \textbf{\color{forestgreen}(Numbers in brackets)} show the performance improvement brought by our initialization scheme for calibration weights.}
}
\centering
\begin{tabular}{lcccl}
\shline
\textbf{Calibration Generation} & \textbf{Our Init.} & \textbf{Temp. Varying} & \textbf{Generation source} & \textbf{Top-1} \\
\hline
DynamicFilter & \xmark & \xmark &  & 41.7 \\
DDF-like & \xmark & \cmark &  & 49.8 \\
TAM (global branch) & \xmark & \xmark &  & 39.7 \\
TAM (local*+global branch) & \xmark & \cmark &  & 41.3 \\
\hline
DynamicFilter & \cmark  & \xmark &  & 51.2 \textbf{\color{forestgreen}(+9.5)} \\
DDF-like & \cmark  & \cmark &  & 53.8 \textbf{\color{forestgreen}(+4.0)} \\
TAM (global branch) & \cmark & \xmark &  & 52.9 \textbf{\color{forestgreen}(+13.2)}\\
TAM (local*+global branch) & \cmark & \cmark &  & 54.3 \textbf{\color{forestgreen}(+13.0)}\\
\hline
TAdaConv w/o global info  & \cmark & \cmark &   & 57.9 \\
\hline
\multirow{2}{*}{TAdaConv} & \multirow{2}{*}{\cmark} & \multirow{2}{*}{\cmark} & both   & \multirow{2}{*}{59.2} \\
~ & ~ & ~ & and  & ~\\
\shline
\end{tabular}
\label{tab:compdyconvperf}
\end{table}

\subsection{Comparison in the performance level}
Since TAdaConv is fundamentally different from previous approaches in the generation of calibration weights, it is difficult to directly compare the performance on video modelling, especially for those that are not designed for video modelling. 
However, since the calibration weight in TAdaConv  is completely generated, \textit{i.e.,} , we can use other dynamic filters to generate the calibration weights for TAdaConv. 
Since MoE based approaches such as CondConv were essentially designed for applications with less memory constraint but high computation requirements, it is not suitable for video applications since it would be too memory-heavy for video models. 
Hence, we apply approaches that generate complete kernel weights to generate calibration weights, and compare them with TAdaConv. 
The performance is listed in Table~\ref{tab:compdyconvperf}.

It is worth noting that these approaches originally generate weights that are randomly initialized. 
However, as is shown in Table~\ref{tab:calibrationsource}, our initialization strategy for the calibration weights are essential for yielding reasonable results, we further apply our initialization on these existing approaches to see whether their generation function is better than the one in TAdaConv.
In the following paragraphs, we provide details for applying representative previous dynamic filters in TAdaConv to generate the calibration weight.

For DynamicFilter~\citep{dynamicfilter}, the calibration weight  is generated using an MLP over the global descriptor that is obtained by performing global average pooling over the whole input , \textit{i.e.,} .
In this case, the calibration weights are shared between different time steps. 

For DDF~\citep{ddf}, we only use the channel branch since it is shown in Table~\ref{tab:calibrationdim} that it is better to leave the spatial structure unchanged for the base kernel.
Similarly, the weights in DDF are also generated by applying an MLP over the global descriptor, \textit{i.e.,} .
The difference between DDF and DynamicFilter is that for different time step, DDF generates a different calibration weight.

The original structure of TAM~\citep{tam} only generates kernel weights with its global branch, and uses local branch to generate attention maps over different time steps. 
In our experiments, we modify the TAM a little bit and further make the local branch to generate kernel calibration weights as well. 
Hence, for only-global version of TAM, the calibration weights are calculated as follows: , where  denotes global average pooling over the spatial dimension and  denotes the global branch in TAM.
In this case, calibration weights are shared for all temporal locations.
For local+global version of TAM, the calibration weight are calculated by combining the results of the local  and the global branch , \textit{i.e.,} , where  denotes element-wise multiplication with broadcasting.
This means in this case, the calibration weights are temporally adaptive. Note that this is our modified version of TAM. The original TAM does not have a temporally adaptive convolution weights.

The results in Table~\ref{tab:compdyconvperf} show that (a) without our initialization strategy, previous approaches that generate random weights at initialization are not suitable for generating the calibration weights in TAdaConv; (b) our initialization strategy can conveniently change this and make previous approaches yield reasonable performance when they are used for generating calibration weights; and (c) the calibration weight generation function in TAdaConv, which combines the local and global context, outperform all previous approaches for calibration.

Further, when we compare TAdaConv without global information with TAM (local*+global branch), it can be seen that although both approach generates temporally varying weights from the frame descriptors  with shape , our TAdaConv achieves a notably higer performance. Adding the global information enables TAdaConv to achieve a more notable lead in the comparison with previous dynamic filters.

\begin{figure}[t]
\centering
\includegraphics[width=0.8\textwidth]{further_visualizations.pdf}
\caption{\textbf{Further qualitative evaluations on the Something-Something-V2 dataset.} In most cases, TAda2D captures meaningful areas in the videos for the correct classification. Further, the activated region of TAda2D also lasts longer along the temporal dimension compared to other two models, thanks to the global temproal context in the weight generation function . }
\label{fig:furtherqualitative}
\end{figure}

\end{document}
