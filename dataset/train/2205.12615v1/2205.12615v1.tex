\documentclass{article}





\PassOptionsToPackage{numbers}{natbib}
\usepackage[preprint]{neurips_2022}










\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{listings}
\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true,
breakatwhitespace=true
}

\usepackage{amssymb}
\usepackage{isabelle,isabellesym}
\usepackage[many]{tcolorbox} 
\newtcolorbox{boxB}{
    fontupper = \color{black}, boxrule = 1.5pt,
    colframe = main,
    rounded corners,
    arc = 5pt   }
\usepackage{xcolor, soul}
\sethlcolor{pink}
\usepackage{multicol}
\newcommand{\customfootnotetext}[2]{{\renewcommand{\thefootnote}{#1}\footnotetext[0]{#2}}}

\definecolor{citecolor}{rgb}{.259,.659,1}
\definecolor{mydarkblue}{rgb}{0,0.08,0.45}
\definecolor{urlcolor}{rgb}{0,.145,.698}
\definecolor{linkcolor}{rgb}{.71,0.21,0.01}
\hypersetup{
    colorlinks=true,
    breaklinks=true,  bookmarksnumbered=true,
    linkcolor=linkcolor,
    citecolor=citecolor,
    filecolor=mydarkblue,
    urlcolor=urlcolor,
    pdftitle={Autoformalization with Large Language Models},
    pdfpagemode=FullScreen,
    pdfview=FitH
    }


\definecolor{main}{HTML}{5989cf} 
\tcbset{
    sharp corners,
    colback = white,
    before skip = 0.2cm,    after skip = 0.5cm      }   




\title{Autoformalization with Large Language Models}





\author{Yuhuai Wu \And Albert Q. Jiang \And Wenda Li \AND Markus N. Rabe \And Charles Staats \And Mateja Jamnik \And Christian Szegedy \AND\normalfont{Google Research} \\ Stanford University \\University of Cambridge}




\begin{document}


\maketitle

\customfootnotetext{}{Correspondence to Yuhuai Wu (\texttt{yuhuai@google.com}).}
\begin{abstract}




Autoformalization is the process of automatically translating from natural language mathematics to formal specifications and proofs. A successful autoformalization system could advance the fields of formal verification, program synthesis, and artificial intelligence.
While the long-term goal of autoformalization seemed elusive for a long time, we show large language models provide new prospects towards this goal.
We make the surprising observation that LLMs can correctly translate a significant portion (25.3\%) of mathematical competition problems perfectly to formal specifications in Isabelle/HOL.
We demonstrate the usefulness of this process by improving a previously introduced neural theorem prover via training on these autoformalized theorems.
Our methodology results in a new state-of-the-art result on the MiniF2F theorem proving benchmark, improving the proof rate from~ to~.




\end{abstract} \section{Introduction}

















\emph{Autoformalization} refers to the task of automatically translating from natural language mathematics to a formal language~\citep{wang2018firsttranslationinformaltoformal,szegedy2020promisingpath}. The implication of a successful autoformalization tool is huge in both practical and philosophical terms.
It would reduce the currently excessive cost of formalization efforts~\citep{Klein2009seL4}, and in the long-term it could connect the various research fields that automate aspects of mathematical reasoning, such as automated theorem proving and computer algebra, to the vast body of mathematical knowledge exclusively written up in natural language.
Moreover, autoformalization would be a true testament to machine understanding, grasping both the fuzziness of natural language and the preciseness of formal language.

Recent advances in large language models~\citep{brown2020gpt3, chowdhery2022palm} showed promising capabilities of understanding formal languages~\citep{chen2021codex, Li2022alphacode}. However, the existing successes are limited to formal languages where there exists a large body of corpus on the web (e.g., Python language). Formal mathematics data is very scarce. For example, one of the largest formal mathematics libraries, the \href{https://www.isa-afp.org}{Archive of Formal Proofs}, is only 180MB in size, that is less than  of the training data for the large language model Codex~\citep{chen2021codex}. Moreover, unlike in the case of commonly used programming languages, where natural language docstrings are broadly available, there is almost zero aligned data between natural language and formal mathematics. Therefore, it is unclear the recent successes can directly contribute to the development of autoformalization.


In this work, we explore the prospects of autoformalization with large language models. To our surprise, we find that large language models already have a decent capability of formalizing natural language mathematics in an interactive theorem prover. See Figure~\ref{fig:example_1} for a perfect autoformalization example. The model not only translates into syntactically correct Isabelle code, but also grasps the non-trivial reasoning in natural language.
We randomly pick 150 formalizations and manually evaluate their correctness. Among them, LLMs are capable of producing 38 perfect formalizations! As an application, we further demonstrate that autoformalization can provide useful training data for neural theorem provers.
We use autoformalized statements as targets for proof search with a neural theorem prover for Isabelle/HOL.
After fine-tuning our neural theorem prover on the proofs it found, its success rate on the MiniF2F benchmark~\citep{zheng2021minif2f} increases significantly, achieving a new state-of-the-art result of 35.2\% theorems proven.
\begin{figure}[t]
\begin{center}
\begin{minipage}[c]{0.9\linewidth}
\begin{boxB}
\textbf{Case Study 1 Question:} 

\emph{"Prove that there is no function  from the set of non-negative integers into itself such that  for every ."}

\
\hrule
\

\textbf{Codex Output:} 

\hl{\texttt{theorem}}

  \hspace{12pt}\hl{\texttt{fixes f :: "nat \textbackslash<Rightarrow> nat"}}
  
  \hspace{12pt}\hl{\texttt{assumes "\textbackslash<forall> n. f (f n) = n + 1987"}}
  
  \hspace{12pt}\hl{\texttt{shows False}}
\end{boxB}
\end{minipage}
\end{center}
\label{fig:example_1}
\caption{Case study 1: An example of a perfect translation from natural language to Isabelle code.}
\vspace{-10pt}
\end{figure} \section{Related Work}





Early applications of machine learning in theorem proving include the works by~\citet{Schulz2001learningsearchcontrol} and \citet{urban2004mptp}, and later, directly guiding interactive proof assistants using machine learning techniques~\citep{GauthierKUKN21TacTicToe}.
The revolution of deep learning then kicked off a new wave of interest in the topic starting with DeepMath~\citep{alemi2016deepmath, loos2017deepmath}.




Several approaches have been suggested to address data scarcity:
Imitation-free reinforcement learning was used to avoid the need for training on human proofs \citep{lederman2020qbf,bansal2019withoutimitation,GauthierKUKN21TacTicToe,wu2021tacticzero}. Also, hindsight experience replay~\citep{AndrychowiczWRS17HER} was used to generate additional training data~\citep{aygun2021hindsight}.
\citet{Hahn2021temporallogics,Schmitt2021CircuitSynthesis,kreber2021logicGANs} and \citet{WuJBG2021INT} have shown that training on synthetic formulas can be successful for temporal logics and inequalities.
\citet{rabe2021skiptree} masked out different subexpressions from formal mathematical statements and generated 100 training examples for each source statement.
Skip-tree data can also be used to improve the performance of neural theorem provers \citep{han2022pact}.

\citet{wang2018firsttranslationinformaltoformal} explored the use of supervised and unsupervised translation techniques for autoformalization.
Supervised translation yielded interesting results, but relied on synthetic (natural-looking) data that was generated by the Mizar theorem prover, while we rely on models trained via self-supervised language modeling, not trained for this particular purpose.






 \section{Background}

\paragraph{Formal Mathematics}
A few important and complex results of mathematics and computer science have been formalized manually using \emph{interactive theorem provers}, such as the four color theorem~\citep{gonthier2008formal}, the Kepler conjecture~\citep{hales2017formal}, the odd-order theorem~\citep{gonthier2013odd} and the verification of a microkernel~\citep{Klein2009seL4}.
This gives us almost complete certainty about the correctness of proofs, which can be of great value to resolve doubt about the correctness of complicated mathematical proofs or proving certain properties of software used in safety-critical applications, such as aircraft components~\citep{klein2018acm}.

These projects relied on interactive theorem provers, such as Isabelle~\citep{wenzel08isabelle}, Coq~\cite{coq}, HOL Light~\citep{Harrison96hollight}, and Lean~\citep{demoura2015lean}, which are essentially programming languages that enable users to enter their statements and proofs in a formal language, and which can then be checked automatically for correctness.
Interactive theorem provers offer a limited amount of automation, but projects that formalize complex problems typically span many years of tedious work by specialists. Only in narrow domains like chip design and the verification of drivers in operating systems has the automation of logic made sufficient progress to find commercial applications.





Progress in autoformalization and the automation of proofs might eventually make mathematics a universally available tool and enable a paradigm shift in science and the development of (safety-critical) software.
Our interest in formalizing mathematics, however, has an additional aspect.
We believe that autoformalization will serve a dual purpose and will not only accelerate the development of tools for mathematical reasoning, but also provide a means to ground machine learning systems, enabling a positive feedback loop between machine learning and formal systems (cf.~\cite{szegedy2020promisingpath}).


\paragraph{Large Language Models}
Our work relies heavily on large language models (LLMs), in particular on PaLM~\citep{chowdhery2022palm} and Codex~\citep{chen2021codex}.
The training goal of these models is to predict the next word given some prefix. This allows us to train these models on arbitrary text, which is available in vast quantities.
After training the models on hundreds of billions of words (cf.~\cite{hoffman2022chinchilla}), they are often able to generate high-quality text.
We can also give these models an arbitrary prefix (the \emph{prompt}) that they are then supposed to continue, which gives us some control over what they generate.
This has been demonstrated with news articles, conversations, summaries, jokes, and poems. LLMs have also been evaluated on natural language word problems on datasets such as GSM8K~\citep{cobbe2021trainingverifiers} and MATH~\citep{hendrycks2021math}, and have been shown to make progress on these benchmarks with increasing scale~\citep{chowdhery2022palm}.

\paragraph{In-context Learning}
Large language models have shown a remarkable ability to learn patterns and tasks within the current input (context) that they are given~\citep{brown2020gpt3}: this is called \emph{in-context learning} or \emph{few-shot learning}.
For example, if we prompt a language model with a few pairs of English and matching French sentences, and end with a new English sentence, then the language model is very likely to pick up on the translation task and attempt a translation of the last English sentence.
This observation has been used, for example, to achieve strong translation performance without access to large corpora of matching sentence pairs~\citep{han2021fewshotunsupervised}.


This allows us to specify the task of autoformalization simply by giving a couple of example formalizations.
In Section~\ref{sec:exp} we will detail how exactly we use in-context learning for autoformalization.
 



\section{Autoformalization for Mathematical Competition Problems}
\label{sec:exp}



Inspired by the success of LLMs for synthesizing computer code by co-training on both natural language and code on web-scale data, we explore the capabilities of LLMs to turn natural language mathematics into formalized theorems for the interactive theorem prover Isabelle. This can be seen as a machine translation task (cf. \cite{Wang2020autoformalization}) in which the input language is English and output language is formal code used by the interactive proof assistant Isabelle~\citep{wenzel08isabelle}.

We first study autoformalization in a constrained setting -- formalizing mathematical competition problem statements. This setting has the advantage that most of the required background theory and definition has been formalized in the current libraries of Isabelle, so that formalizations are often possible without introducing additional definitions.

We start assessing LLMs' abilities to do autoformalization with a case study. We manually pick two interesting natural language mathematical statements, and prompt PaLM models of various scales~\citep{chowdhery2022palm} as well as Codex~\citep{chen2021codex} to translate them into a formal statement in Isabelle.
Next, we study a dataset in which we have human ground truth formalizations. The dataset is a subset of the miniF2F~\citep{hendrycks2021math} dataset consisting of 140 algebra problems and 120 number theory problems. Using human formalizations as the reference, we compute the BLEU scores of the formalizations produced by several LLMs.
Lastly, we perform human evaluations on failure cases in autoformalization on 150 problems. 

Note that many mathematical competition statements are often of the form in which one asks to find the answer to a certain problem, instead of \emph{proving} a given proposition. However, formal mathematical statements are in the form of propositions, instead of questions. To transform a question into a proposition, we append the final answer after the question:


The format of the prompt we use to do autoformalization is:







\subsection{Mathematical Competition Datasets}



{\bf MATH}~\citep{hendrycks2021math}
contains in total 12,500 (7,500 training and 5,000 test) middle school and high school mathematical competition problems. Problems are taken from past mathematical competitions, including
AMC 10, AMC 12, AIME, and more, and many can be found at \url{http://aops.com/community/c3158_usa_contests}. The dataset contains seven categories: \texttt{algebra}, \texttt{pre-algebra}, \texttt{intermediate algebra}, \texttt{number\_theory}, \texttt{precalculus}, \texttt{probability}, \texttt{geometry}. Problem statements are written in LaTeX.

{\bf MiniF2F}~\citep{zheng2021minif2f}
is a recently introduced benchmark containing 488 mathematical competition statements manually formalized by humans in three different formal languages. Its goal is to compare and benchmark methods across different theorem provers for machine learning research. Some of these problems come from the valid and test set of MATH \texttt{algebra} and \texttt{number\_theory}, and others come from previous International Mathematical Olympiad competitions or AoPS\footnote{\url{https://artofproblemsolving.com/}}. Note that the Isabelle formalizations of the miniF2F benchmark were committed to the repository during March, 2022. According to the public information on the large language models, we think it is highly unlikely these formalizations were included in the pre-training corpus.


\begin{figure}
    \begin{boxB}
Natural language version:
\emph{"Let , find . The final answer is 36."} Translate the natural language version to an Isabelle version:
\begin{verbatim}
theorem
  fixes z::complex
  assumes h0: "z = (Complex (1/sqrt 2) (1/sqrt 2))"
  shows "(\<Sum>k::nat=1..12. (z^(k^2))) 
            * (\<Sum> k::nat=1..12. 1/(z^(k^2)))=36" 
\end{verbatim}


Natural language version:
\emph{"Determine the value of  if  and . The final answer is 512".}
Translate the natural language version to an Isabelle version:
\begin{verbatim}
theorem
  fixes a b ::real
  assumes "(ln a) / (ln 8) + (ln (b^2)) / (ln 4) = 5"
          "(ln b) / (ln 8) + (ln (a^2)) / (ln 4) = 7"
        shows "a * b = 512"
\end{verbatim}

\end{boxB}
    \caption{The two few-shot examplars used in case studies: both examples are merely an illustration of a syntactical translation from from \LaTeX to Isabelle, without much sophistication in natural language understanding or reasoning.}
    \label{fig:case_study_formal}
\end{figure}

\subsection{Case Studies}
\label{sec:case_study_formal}

\paragraph{Experimental setup} For all our experiments, we use the standard greedy decoding (i.e., temperature 0, ) to obtain the autoformalizations. We randomly select two mathematical statements for constructing the prompt. No prompt engineering / tuning is performed when constructing the prompt. The examples are shown in Figure~\ref{fig:case_study_formal}. The natural language problem statements used in the case studies are taken from the miniF2F dataset.
In the case studies below, we highlight the output of language models in red to distinguish it from the prompt.



\paragraph{Case Study  (Figure~\ref{fig:example_1})} We study the example shown in Figure~\ref{fig:example_1}, in which we ask LLMs to autoformalize an International Mathematical Olympiad problem\footnote{A problem from IMO 1987.} in natural language. Surprisingly, Codex is able to autoformalize the natural language statement as an Isabelle theorem perfectly, with output given. This is surprising for the following reasons.


First of all, the amount of Isabelle code is very scarce on the internet. The entire AFP library, the largest formal library that contains most of Isabelle proofs, is only 180MB in size. Even assuming that all of this data was included in the training of Codex, this makes at most  of the pretraining data on which Codex was trained. The fact that the model can write syntactically correct Isabelle code at all is already fascinating.

Second, there is almost zero aligned data from natural language to Isabelle on the web.
While some Isabelle files have comments, they typically only give a very high level description of what the theory being formalized is about.
So either LLMs are able to transfer knowledge quite successfully between natural language and formal mathematics, or the task was learned mostly via few-shot learning. 

Last but not least, the model is capable of understanding and formalizing nontrivial reasoning. First, the model is able to formalize the non-existence statement via proof-by-contradiction. To formalize ``there is no function ...'', it assumes there is such a function, and aims to prove ``False''. Second, the model understands what it means by the phrase ``to itself'', and correctly infers the domain of function: \verb|f :: "nat \<Rightarrow> nat"|.

On the other hand, PaLM made some syntactic mistakes while getting most of the structure of the proof correctly, with outputs shown in Appendix~\ref{appendix:case_study_1}. 





\paragraph{Case Study  (Figure~\ref{fig:examples})} In the next example, we ask LLMs to autoformalize a grade school mathematical word problem. Remarkably, PaLM and Codex are both capable of formalizing the statement perfectly. This is surprising because formalizations of grade school math problems in interactive theorem provers are rare (if they exist at all), as this type of mathematics is not of interest to formal mathematicians. Even more, none of the examples in the prompt (see Figure~\ref{fig:case_study_formal}) that we provide are of this type. It is hence remarkable that the model is capable of extrapolating to this type of statement, showing a great promise of using LLMs for autoformalization.

To study this problem in more depth, we probe PaLM models of various sizes (8B, 64B, 540B) with outputs shown in Appendix~\ref{appendix:case_study_2}, and notice that scale is crucial for the LLMs ability to formalize. We observe that the 8B and 64B models are incapable of formalizing this problem, but the largest 540B model is able to produce a correct formalization.

\begin{figure}[t!]
\begin{minipage}[c]{0.47\linewidth}
\begin{boxB}
\textbf{Case Study 2 Question:} 

Natural Language version: "\emph{When all the girls at Madeline's school line up in rows of eight, there are seven left over. If instead they line up in rows of four, how many are left over? The final answer is 3.}"
Translate the natural language version to an Isabelle version:



\
\hrule
\

\textbf{PaLM output:} 

\hl{\texttt{theorem}}

  \hspace{10pt} \hl{\texttt{fixes n::nat}}
  
  \hspace{12pt}\hl{\texttt{assumes "n mod 8 = 7"}}
  
  \hspace{12pt}\hl{\texttt{shows "n mod 4 = 3"}}
\end{boxB}

\end{minipage}
\begin{minipage}[c]{0.55\linewidth}
\begin{boxB}
\textbf{Case Study 3 Question:}

Natural language version:
\emph{"Let  be a linear function for which  What is  The final answer is 30."}
Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{Codex output:}

\hl{\texttt{theorem}}

  \hspace{10pt} \hl{\texttt{fixes f :: "real \textbackslash<Rightarrow> real"}}
  
  \hspace{12pt}\hl{\texttt{assumes "linear f"}}
  
  \hspace{12pt}\hl{\texttt{\qquad\qquad"f 6 - f 2 = 12"}}
  
  \hspace{12pt}\hl{\texttt{shows "f 12 - f 2 = 30"}}
        
\end{boxB}
\end{minipage}
\caption{Autoformalizations from natural language to Isabelle code. {\bf Left:}~Case study 2 -- perfect formalization by PaLM. {\bf Right:}~Case study 3 -- incorrect formalization by Codex.
}
\label{fig:examples}
\vspace{-10pt}
\end{figure}



















\paragraph{Case Study  (Figure~\ref{fig:examples})} In our third case study, Codex gives an incorrect formalization in Isabelle. The mathematical statement involves a concept of ``linear function'', which the model fails to formalize correctly. Codex assumes this is already a known concept in Isabelle, and made up a name: \texttt{linear~f}. Can the model learn to formalize such problems if the prompt contains an example that explains the concept of a line? We explore this and give an affirmative answer to the question~(see Appendix~\ref{appendix:case_study_3}). Once seeing a tangentially related problem that explains the concept of a ``line'', Codex is able to perfectly formalize a ``linear function''. This shows the importance of the few shot examples we include, and also how good a few-shot learners these models are!  





















\paragraph{Has the model memorized these formalizations?}
Whilst we do not have access to the training set of Codex, we attempted to find any occurrences of the formalizations produced in the case studies on the internet.
We Googled them in different variants and inspected the first page of the search results.
We tried variants with and without an ``Isabelle'' prefix, with and without quotation marks and other special characters, and also individual parts of it, such as ``\texttt{Isabelle "n mod 8 = 7"}'', but we did not find any occurrences of related statements.
We also tested that we are indeed able to find occurrences of Isabelle formalizations on the web with this methodology, using pieces of formalizations picked from several websites, including the Archive of Formal Proofs. Hence, we are confident that the model has not memorized the formalizations it generated.

\subsection{BLEU for Model Comparisons}
\label{sec:bleu}
The miniF2F benchmark contains 140 algebra problems and 120 number theory problems from the MATH dataset. For these problems, we have human ground truth formalizations in Isabelle, which gives us an evaluation set with pairs of natural language statements (from MATH) and their formalizations. We use this dataset to quantitatively compare different LLMs.

Given the observation about few shot learning in Case study 3, we decided to add more relevant examples to each subject to improve the quality of autoformalization. For each subject (i.e., \texttt{algebra} and \texttt{number\_theory}), we randomly sample 10 problems to construct the few shot prompt. The rest of the problems are used for evaluation (i.e., 130 for \texttt{algebra} and 110 for \texttt{number\_theory}. We provide the prompt used in the Appendix~\ref{appendix:prompt_quan_study_algebra} and \ref{appendix:prompt_quan_study_number_theory}.

We use PaLM models of varying sizes and Codex to perform the autoformalization, and compute the BLEU scores of the formalizations, shown in Table~\ref{tab:bleu}. Confirming our observation in Case~study~2, we see a clear trend that scaling improves translation, as the BLEU scores consistently improve when we scale PaLM models from 8B to 540B, for both subjects. In addition, we see that the Codex model is better at autoformalization measured by BLEU, possibly due to the fact that Codex was trained on more formal data than PaLM.

\begin{table}[t]
  
  \caption{BLEU scores between the autoformalized statements and human formalized ground truth.}
  \label{tab:bleu}
  \centering
  \begin{tabular}{lccccc}
    \toprule
    Models  Subject   & \texttt{algebra} & \texttt{number\_theory}  \\ 
    \midrule
    PaLM 8B    &  31.49 &  22.10\\
    PaLM 64B    &  43.13&  31.43 \\
    PaLM 540B    &  50.30& 36.16 \\
    Codex &   \textbf{57.13}  & \textbf{43.33}  \\
    \bottomrule
  \end{tabular}
\end{table}



\subsection{Human Evaluation of Failure cases}
\label{sec:failure_case}

To better understand LLMs' ability to do autoformalization, we manually inspect Codex's autoformalizations of 150 random problems from the MATH dataset~\citep{hendrycks2021math}. 50 of the problem statements are sampled from the \texttt{algebra} training set, 50 from \texttt{number\_theory} and 50 from \texttt{intermediate\_algebra}. For \texttt{algebra} and \texttt{number\_theory}, we use their corresponding prompt as in the last section, shown in Appendix~\ref{appendix:prompt_quan_study_algebra} and~\ref{appendix:prompt_quan_study_number_theory}. For \texttt{intermediate\_algebra}, we use the prompt we used for \texttt{algebra} (Appendix~\ref{appendix:prompt_quan_study_algebra}).  We classify the failure modes of these translations, shown in Table~\ref{tab:failure}. 

We see that out of 150 problems, Codex is capable of translating 38 problems perfectly -- a success rate of 25.3. The majority of the failures are due to the misalignment of informal and formal definitions. For example, when seeing the phrase ``the greatest possible value'', the LLMs often fail to align it with the function \texttt{Greatest}/\texttt{Max} in Isabelle. Another example is the failure to align the factorial of  (i.e., ) to \isa{fact n} in Isabelle. Other common failure modes include the misapplication of functions (e.g., applying a prefix function in an infix way).




\begin{table}[t]
  
  \caption{Failure case study of 150 problems formalized by Codex.}
  \label{tab:failure}
  \centering
  \begin{tabular}{lccc}
    \toprule
    Failure cases  Subjects   & \texttt{algebra} & \texttt{number\_theory} & \texttt{inter\_alg}  \\ 
    \midrule
    Perfect translation  & 13  & 17 & 8   \\
    Incomplete/ill-formed/unclear prompt &  9  & 3 & 14 \\
    Fail to align definitions or concepts &   10  & 18 & 18  \\
    Inconsistent/missing assumption  & 8 & 9 & 9 \\
    Syntactical/type error & 7 & 2 & 11\\
    Missing definition in Isabelle & 0 & 12 & 3\\
    Wrong application of functions & 6 & 13 & 16 \\
    Other & 6 & 2 & 1 \\
    \bottomrule
  \end{tabular}
\end{table}

























\section{Autoformalization for Neural Theorem Proving}
\label{sec: exp}
To demonstrate the usefulness of the formalized statements, we explore if one can improve neural theorem provers by training the neural models on proofs of automatically translated theorems. In this section, we combine autoformalization with expert iteration algorithms~\citep{DBLP:conf/nips/AnthonyTB17}, and achieve a new state of the art in miniF2F benchmark.








\subsection{Expert Iteration with Autoformalization}
\label{subsec: expert}


The basic idea of expert iteration~\citep{DBLP:conf/nips/AnthonyTB17} is to iteratively generate a better dataset using the model, and use the data to improve the model quality. This allows the model to generate an even better quality of the dataset and hence a better model, forming a self-improvement cycle. 

In neural theorem proving, one way to get better quality data is to use  feedback from the proof checker to run many proof searches (or generate multiple proofs) and check the proof attempts for correctness.
Newly found correct proofs can then be used as the new training data to improve the neural prover~\citep{bansal2019holist,polu2020gptf,fmscl}. 
The main critical ingredient that is needed is a set of problem statements on which the model can perform proof search to obtain new training data. However, unlike in~\citet{fmscl}, where one asks humans to manually formalize a set of problems to get formal statements, here we use LLMs to autoformalize the theorems in order to kick off the self-improvement cycle. 

More formally, denote a base neural theorem prover as . Let the set of autoformalized problems be . For each iteration , we carry out the following procedure: use the language model  with best-first search to prove as many theorems as possible in , collect the set of successful proofs , concatenate successful problems from all iterations with the formal mathematics problems to create the set , and fine-tune  on it for exactly one epoch to get a new model . When we take the union of successful proofs from all past iterations, we perform deduplication by problem statements, similar to~\citet{fmscl}.

\subsection{Neural Theorem Provers} 
\label{sec:ntp}
To demonstrate the effectiveness of the approach, we start with a recently introduced neural theorem prover for Isabelle, Thor~\citep{jiang2022thor}. The Thor agent is fine-tuned on the PISA dataset~\citep{jiang2021lisa}~(extraction and interaction code under a \href{https://github.com/albertqjiang/Portal-to-ISAbelle/blob/main/LICENSE}{BSD license}), which consists of 2.49 million proof steps from the \href{https://isabelle.in.tum.de/dist/library/HOL/index.html}{Isabelle/HOL library}~(under a \href{https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2021-1/COPYRIGHT}{BSD-style license}) and the \href{https://www.isa-afp.org}{Archive of Formal Proofs}~(under various licenses as described \href{https://www.isa-afp.org/about.html}{here}). The model is trained with the objective to predict the next token in a proof step, given the proof state and the last proof step. When the ground truth proof step contains any of the keywords \texttt{metis, meson,} and \texttt{smt}, the model learns to predict a special token \texttt{<hammer>}. In evaluation, whenever the special token is emitted, Thor invokes the proof method Sledgehammer~\citep{paulson2015three} in Isabelle with a 30 second timeout.

We use a pre-trained and fine-tuned Thor agent as the base model~().
The agent's language model uses \citet{mesh-transformer-jax}'s implementation~(under an \href{https://github.com/kingoflolz/mesh-transformer-jax/blob/master/LICENSE.txt}{Apache license 2.0}) of a GPT-2~\citep{radford2019language} style decoder-only transformer~\citep{vaswani2017attention} model with 700M non-embedding parameters. The model has 24 layers, 24 attention heads, a hidden dimension of 1536, and a vocabulary size of 50400. It uses the AdamW~\citep{loshchilov2019adamw} optimizer and is pre-trained on the GitHub + arXiv subsets of The Pile~\citep{pile} for 200,000 steps, with a context length of 2048 tokens. In pre-training a warmup strategy~\citep{goyal2017accurate} raises the learning rate linearly from 0 to  in 3,000 steps. Then a cosine learning rate scheduler~\citep{DBLP:conf/iclr/LoshchilovH17} is used for the rest of the pre-training, with a final learning rate of . The training has a global batch size of 32 sequences, or 65,536 tokens. For fine-tuning the learning rate strategy is the same, with 10,000 warmup steps, 90,000 annealing steps, maximum learning rate  and final learning rate . The global batch size is 144 sequences, or 294,912 tokens. The model's evaluation loss reaches a minimum after 13,000 steps and that checkpoint is used.



\paragraph{Machine specification}
For experiments in this paper, we use a TPUv3 with 8 cores from \href{https://cloud.google.com/tpu?hl=en}{Google Cloud Platform}.
The Isabelle process has access to up to 32 CPU cores. Running all the experiments in this paper requires a total of  TPU hours. Of the  TPU hours,  are for running the proof search on the autoformalized theorems,  are for training the model on the successful proofs, and  are for evaluating the model on miniF2F.



\subsection{Result}
\begin{table}[t]
  
  \caption{Proof success rates on miniF2F.}
  \label{tab:minif2f}
  \centering
  \begin{tabular}{llll}
    \toprule
    Model   & \emph{valid} & \emph{test} \\ 
    \midrule
    
PACT~\citep{han2022pact}  &    & \\
    FMSCL~\citep{fmscl} &   &   \\
    Base model~()~\citep{jiang2022thor}             &  & \\
    After  expert iteration~()             &  & \\
    After  expert iterations~()             &  & {} \\
\bottomrule
  \end{tabular}
      \vspace{-5pt}
\end{table}


We use Codex with greedy decoding to formalize 3908 mathematical problems in \texttt{algebra}, \texttt{intermediate} \texttt{algebra}, and \texttt{number} \texttt{theory} from the training set of MATH~\citep{hendrycks2021math}, with the same few shot prompts used in Section~\ref{sec:failure_case}. Out of them, 3363 of the autoformalized theorems are syntactically correct. We then perform expert iteration on this dataset. 

We start with a neural theorem prover () as described in Section~\ref{sec:ntp}. In our first iteration,  proves 782 theorems, with a success rate of  (out of 3363). This gives us a new set of verified proofs to further train the neural theorem prover. We proceed to fine-tune our neural theorem prover in the fashion described in Section~\ref{subsec: expert} to get a new prover~(). This process is repeated in the second iteration, giving us 1011 successful proofs from the autoformalized theorems~(). We fine-tuned  again, but on the deduplicated concatenation of problems from PISA and successful proofs found for the autoformalized theorems.

After each stage of fine-tuning, we evaluate the neural theorem prover on miniF2F~\citep{zheng2021minif2f}. The results are shown in Table~\ref{tab:minif2f}. The base model~() has a success rate of  and  on the validation and test fractions of miniF2F respectively. It can be observed that the first expert iteration increases the success rate of the neural prover by  and  to  and  on the valid and test sets. The second iteration further improves them both by , to  and . By doing two expert iterations on the autoformalized theorems, the neural prover achieves a success rate that is  higher than the previous state-of-the-art.










\section{An Outlook on Autoformalizing Advanced Mathematics}

So far, we focused on mathematical competition problems, in which we achieve significant results using autoformalization. Not only can LLMs autoformalize non-trivial theorems, the autoformalized theorems can also improve neural prover performance. In this section, we take a peek into more advanced mathematics. We hope to identify some of the limitations of our methods when it comes to autoformalizing mathematics in the wild.

\subsection{Autoformalization: from Natural Language to Isabelle}
Autoformalization is extremely challenging in the sense that the model needs to (1) bridge the logical gaps left in pen-and-paper proofs, (2) assume the implicit contexts and assumptions, and (3) align informal definitions/concepts to formal ones. This task is further complicated considering the context can change from time to time and the same mathematical object can be formalized in subtly different ways. In this paper, we only deal with autoformalization of theorem statements, where the model is mainly challenged by definition alignments. Compared to competition problems in Section~\ref{sec:failure_case}, advanced mathematical statements assume more context information that additionally obscures the alignment.



\begin{figure}
\begin{boxB}
\textbf{Question:} 
\emph{An arbitrary product of compact spaces is compact.} 

\
\hrule
\

\textbf{Codex Output:}

\hl{\texttt{theorem}}
  
  \hspace{12pt}\hl{\texttt{fixes X :: "'a set set"}}
  
  \hspace{12pt}\hl{\texttt{assumes "\textbackslash<forall>x \textbackslash<in>X. compact x"}}
  
  \hspace{12pt}\hl{\texttt{shows "compact (\textbackslash<Prod> x \textbackslash<in> X. x)"}}
\end{boxB}
\caption{A formalization for an advanced mathematical statement by Codex.}
\label{fig:formal_advanced}
\vspace{-10pt}
\end{figure}
Figure~\ref{fig:formal_advanced} shows a typical case where the model fails to align the informal definition to the formal one. Based on the notation used, the model does not correctly distinguish between products of numbers, products of sets, and products of topological spaces. In Isabelle, the correct conclusion for the statement should be \isa{compact\_space (product\_topology X I)}, where
 is an index set that ought to have been introduced in the \isa{fixes} and \isa{assumes} sections.




\subsection{Informalization: from Isabelle to Natural Language}

So far, we explored one direction of translation: from natural language statement to formal statement in Isabelle. The other direction, \emph{informalization}, is also of great importance for two reasons: (1) the informal texts are much easier for humans to comprehend and communicate, and (2) we can align translated informal statements with formal ones to create data, and use the back-translation techniques~\citep{DBLP:conf/acl/SennrichHB16} to potentially boost the translator's performance further. In this section, we explore Codex's capability of translating formal Isabelle statement to natural language. 

A corpus of 38 formal-language theorems, lemmas, and definitions is selected by an Isabelle expert. These statements are automatically translated to informal mathematics using Codex; to
see the prompt we used and the results for all 38 examples, see Appendix~\ref{appendix:prompt_case_informal} and ~\ref{appendix:advanced_informal}. We present two examples of informalization in Figure~\ref{fig:examples_informal}. Of the 38 examples, 36 were translated to a reasonably coherent statement, and 29 of these statements (76\%) were more-or-less correct, giving a vastly better success rate than the 25\% success rate of formalization (Section~\ref{sec:failure_case}). Our main conclusion is that for advanced mathematics, the model is better at informalization than formalization, showing the prospect of backtranslation style algorithms.


Note that the standard is more relaxed here since we assume a human reader will supply the obvious context and correct mistakes when the intended meaning is obvious (intended by the hypothetical human writer of these sentences). To illustrate, an example of a minor ``acceptable'' error: assuming that `` are in the same connected component of the plane'' when, in context, it is clear that  should be assumed to be in the same connected component of the complement of a previously specified curve. (The assumption as originally stated is trivial.) For an example of a major error: almost-perfect translation of the Central Limit Theorem that omits the assumption of identical distributions.





\begin{figure}[!t]
    \centering
    \begin{minipage}[c]{0.35\linewidth}
    \begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ seteqI{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}{\isasymAnd}x{\isachardot}{\kern0pt}\ x{\isasymin}A\ {\isasymLongrightarrow}\ x{\isasymin}B{\isacharsemicolon}{\kern0pt}\ {\isasymAnd}x{\isachardot}{\kern0pt}\ x{\isasymin}B\ {\isasymLongrightarrow}\ x{\isasymin}A\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ A\ {\isacharequal}{\kern0pt}\ B{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

\hl{"If  and  are sets such that  and , then ."}
\end{boxB}
\end{minipage}
\begin{minipage}[c]{0.6\linewidth}
\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ topologyI{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}\ {\isasymAnd}\ x\ y{\isachardot}{\kern0pt}\ {\isasymlbrakk}\ is{\isacharunderscore}{\kern0pt}open\ T\ x{\isacharsemicolon}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}open\ T\ y{\isasymrbrakk}\ {\isasymLongrightarrow}\ is{\isacharunderscore}{\kern0pt}open\ T\ {\isacharparenleft}{\kern0pt}x\ {\isasyminter}\ y{\isacharparenright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ {\isasymAnd}\ M{\isachardot}{\kern0pt}\ {\isasymforall}\ m\ {\isasymin}\ M{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}open\ T\ m\ {\isasymLongrightarrow}\ is{\isacharunderscore}{\kern0pt}open\ T\ {\isacharparenleft}{\kern0pt}{\isasymUnion}\ M{\isacharparenright}{\kern0pt}\isanewline
\ \ \ {\isasymrbrakk}\ {\isasymLongrightarrow}\ topology\ T{\isachardoublequoteclose}
\end{isabelle}   
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

\hl{"If  is a set and  is closed under finite intersections and arbitrary unions, then  is a topology."}
\end{boxB}
\end{minipage}
\caption{Two perfect translations from Isabelle code to natural language by Codex.}
    \label{fig:examples_informal}
\vspace{-10pt}
\end{figure}












\section{Discussion}

\paragraph{Promise of Autoformalization with LLMs} We have seen that automated formalization of informally given natural language statements is generally possible, even with language models not trained for this particular task. Also, automatically formalized statements are useful for training and improving the reasoning capabilities of automated neural provers. Our hope is that improved versions of this methodology will be capable of enabling a positive feedback loop involving formalization and formal reasoning that has the potential of reaching human level capabilities in both respects, as was suggested by~\cite{szegedy2020promisingpath}. 

\paragraph{Limitations and future directions} 
We use a static model for the formalization process. For large-scale autoformalization, we will need to formalize larger theories, preferably without fine tuning the model, as training it could be cumbersome and resource consuming. However, in order to utilize the newly added notions, the model would need to keep whole large theories in the current context window, which  exceeds those of the current LLMs. This limits our approach to the generation of fairly small pieces of formal mathematics and the automatic formalization of entire theories including their definitions will require new research ideas.
One path towards this goal might be the use of continuous training or expert iteration, cycle-consistency-based training ~\citep{lample2017unsupervised,wang2018firsttranslationinformaltoformal}, or novel uses of in-context learning.
To generate larger theories we will also need neural networks that can recall longer sequences (current LLMs are typically limited to a few thousand words). Retrieval-augmented language models, such as the memorizing transformer~\citep{wu2022memorizing} offer one path to overcome this limitation.


\paragraph{Societal Impact}
While the potential of creating negative societal impact through formalizations is small, the use of LLMs always comes with risks. For example, for deploying an autoformalization tool using LLMs we would need to consider the inclusivity of variable and lemma names, and of the attribution of scientific ideas.
 
\bibliography{neurips_2022}
\bibliographystyle{neurips_2022}
\appendix
\newpage
\textbf{\huge Appendix}

\section{Few-shot Prompts}



\subsection{Prompt used to formalize \texttt{algebra} problems}
\label{appendix:prompt_quan_study_algebra}
 
 \begin{boxB}
Natural language version: \emph{"Simplify . The final answer is "}. Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes x :: real
  assumes h0 : "x \<noteq> 0"
  shows "1/(4/x) * ((3*x^3)/x)^2 * (1/(1 / (2 * x)))^3 = 18 * x^8"
\end{lstlisting}

\

Natural language version: \emph{"For integers , let Find . The final answer is 1".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes f :: "int \<Rightarrow> int"
  assumes "\<forall>n. odd n \<longrightarrow> f n = n^2"
    and "\<forall> n. even n \<longrightarrow> f n = n^2 - 4*n -1"
  shows "f 4 = -1"
\end{lstlisting}

\

Natural language version: \emph{"The volume of a cone is given by the formula , where  is the area of the base and  is the height. The area of
the base of a cone is 30 square units, and its height is 6.5 units. What is the number of cubic units in its volume? The final answer is 65".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes b h v ::real
  assumes "0 < b \<and> 0 < h \<and> 0 < v"
      and "v = 1 / 3 * (b * h)"
      and "b = 30"
      and "h = 13 / 2"
    shows "v = 65"
\end{lstlisting}

\

Natural language version: \emph{"If , then find . The final answer is -56".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes a b c :: real
  assumes "3 * a + b + c = -3"
    and "a + 3 * b + c = 9"
    and "a + b + 3 * c = 19"
  shows "a * b * c = -56"
\end{lstlisting}
\end{boxB}

\begin{boxB}
Natural language version: \emph{"If , find a value for  so that . The final answer is ".} Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes x :: real and \<sigma>::"real \<Rightarrow> real"
  assumes "bij \<sigma>"
    and \<sigma>:"\<forall> x. \<sigma> x = 5 * x - 12"
    and "\<sigma> (x + 1) = (inv \<sigma>) x" 
  shows "x = 47 / 24"
\end{lstlisting}

\ 

Natural language version: \emph{"What is the -coordinate for the -intercept of the line containing the points  and ? The final answer is 3".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes a b :: real
    and f :: "real \<Rightarrow> real"
  assumes h0 : "\<And>x. f x = a * x + b"
    and h1 : "f 7 = 4"
    and h2 : "f 6 = 3"
  shows "f 3 = 0"
\end{lstlisting}
  
  \
  
Natural language version: \emph{"Given  and  find . The final answer is 243".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes a b :: real
  assumes "2 powr a = 32"
    and "a powr b = 125"
  shows "b powr a = 243"
\end{lstlisting}
  
\
  
Natural language version: \emph{"Let If , find the sum of all possible values of . The final answer is 6".}
Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes f :: "real \<Rightarrow> real"
  assumes "\<forall> x < -5. f x = x^2 + 5"
    and "\<forall> x \<ge> -5. f x = 3 * x -8"
  shows "(\<Sum> k \<in> (f -` {10}). k) = 6" 
\end{lstlisting}

\

Natural language version: \emph{"Simplify . The final answer is 12".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes q e :: complex
  assumes h0 : "q = Complex (Re 9) (Im (-4))"
    and h1 : "e = Complex (Re (-3)) (Im (-4))"
  shows "q - e = 12"
\end{lstlisting}

\

Natural language version: \emph{"What is the minimum possible value for  in the equation ? The final answer is 4".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes x y :: real
  assumes h0 : "y = x^2 - 6 * x + 13"
  shows "4 \<le> y"
\end{lstlisting}
\end{boxB}

\subsection{Prompt used to formalize \texttt{number theory}
 problems}
\label{appendix:prompt_quan_study_number_theory}

\begin{boxB}
Natural language version: \emph{"If  is a positive integer such that  has 28 positive divisors and  has 30 positive divisors, then how many positive divisors does  have? The final answer is 35".} Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes n :: nat
  assumes "n>0" 
    and "card ({k. k dvd (2*n)}) = 28"
    and "card ({k. k dvd (3*n)}) = 30" 
  shows "card ({k. k dvd (6*n)}) = 35"
\end{lstlisting}
  
\

Natural language version: \emph{"Let  be the number of integers  in the range  such that . What is the remainder when  is divided by ? The final answer is 1".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes n :: nat
  assumes "n = card {k::nat. gcd k 8 = 1 \<and> 1\<le>k \<and> k < 8}" 
  shows "(3^n) mod 8 = (1::nat)"
\end{lstlisting}

\

Natural language version: \emph{"What is the remainder when  is divided by 9? The final answer is 1".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  "(\<Sum> k< 11. k) mod 9 = (1::nat)"
\end{lstlisting}

\

Natural language version: \emph{"Cards are numbered from 1 to 100. One card is removed and the values on the other 99 are added. The resulting sum is a multiple of 77. What number was on the card that was removed? The final answer is 45".}

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes x :: nat
  assumes h0 : "1 \<le> x \<and> x \<le> 100"
    and h1 : "77 dvd ((\<Sum>k::nat=0..100. k)-x)"
  shows "x=45"
\end{lstlisting}

\

Natural language version: \emph{"Find , as a residue modulo 100.  (Give an answer between 0 and 99, inclusive.) The final answer is ".}

Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes x::nat
  assumes "x < 100"
    and "x*9 mod 100 = 1" 
  shows "x = 89"
\end{lstlisting}
\end{boxB}

\begin{boxB}
Natural language version: "Suppose  is a two-digit positive integer such that  exists and . What is ? The final answer is 43".

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes m x :: nat
  assumes h0 : "10 \<le> m"
    and h1 : "m \<le> 99"
    and h2 : "(6 * x) mod m = 1"
    and h3 : "(x - 6^2) mod m = 0"
  shows "m = 43"
\end{lstlisting}

\ 

Natural language version: "Find . That is, find the residue  for which .
Express your answer as an integer from  to , inclusive. The final answer is 116".

Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes b::int
  assumes "\<forall>b::int. 0\<le>b \<and> b\<le>11^2 \<and> [b * 24 = 1] (mod (11^2))"
  shows "b = 116"
\end{lstlisting}

\

Natural language version: \emph{"Given that  is a prime number, evaluate  The final answer is ".}

Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes p :: nat
  assumes "prime p"
  and "7 \<le> p" 
shows "(\<Sum> k \<in> {1..<p-1}. (inv_mod k p)* (inv_mod (k+1) p)) = 2"
\end{lstlisting}
\

Natural language version: \emph{"What is the remainder when  is divided by ? The final answer is 0".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  "(2000 + 2001 + 2002 + 2003 + 2004 + 2005 + 2006) mod 7 = (0::nat)"
\end{lstlisting}

\

Natural language version: \emph{"One morning each member of Angela's family drank an 8-ounce mixture of coffee with milk. The amounts of coffee and milk varied from cup to cup, but were never zero. Angela drank a quarter of the total amount of milk and a sixth of the total amount of coffee. How many people are in the family? The final answer is 5".}
Translate the natural language version to an Isabelle version:
\begin{lstlisting}
theorem
  fixes x y n ::nat
  assumes "x / 4 + y / 6 = (x + y) / n"
    and "n\<noteq>0"
    "x\<noteq>0" "y\<noteq>0"
  shows "n = 5"
\end{lstlisting}

\end{boxB}

\subsection{Prompt used for informalization}
\label{appendix:prompt_case_informal}

\begin{boxB}
Isabelle version:
\begin{lstlisting}
theorem
  fixes z::complex
  assumes h0: "z = (Complex (1/sqrt 2) (1/sqrt 2))"
  shows "(\<Sum>k::nat=1..12. (z^(k^2))) 
            * (\<Sum> k::nat=1..12. 1/(z^(k^2))) =36" 
\end{lstlisting}
Translate the Isabelle version to a natural language version:
\emph{"Let , find . The final answer is 36."}


Isabelle version:
\begin{lstlisting}
theorem
  fixes a b ::real
  assumes "(ln a) / (ln 8) + (ln (b^2)) / (ln 4) = 5"
          "(ln b) / (ln 8) + (ln (a^2)) / (ln 4) = 7"
        shows "a * b = 512"
\end{lstlisting}

Translate the Isabelle version to a natural language version:
"Determine the value of  if  and . The final answer is 512".

\end{boxB}

\section{More on case Studies}

\subsection{Case Study 1} 
~\label{appendix:case_study_1}
Here we show the output given by PaLM model 540B. The model got the most structure correctly, but made some syntactical errors.

\begin{boxB}
\textbf{Question:} 

Natural language version:
"Prove that there is no function  from the set of non-negative integers into itself such that  for every ."
Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{PaLM 540B Output:} 

\begin{lstlisting}
theorem
  fixes f :: "nat -> nat"
  assumes "forall n::nat. f(f(n)) = n + 1987"
  shows "false"
\end{lstlisting}
\end{boxB}
\newpage
\subsection{Case Study 2} 
\label{appendix:case_study_2}
We show below the output given by PaLM models of different sizes.

\begin{boxB}
\textbf{Question:} 

Natural Language version: "\emph{When all the girls at Madeline's school line up in rows of eight, there are seven left over. If instead they line up in rows of four, how many are left over? The final answer is 3.}"

Translate the natural language version to an Isabelle version:



\
\hrule
\

\textbf{PaLM 540B output:} 
\begin{lstlisting}
theorem
    fixes n::nat
    assumes "n mod 8 = 7"
    shows "n mod 4 = 3"
\end{lstlisting}

\end{boxB}

\begin{boxB}
\textbf{Question:} 

Natural Language version: "\emph{When all the girls at Madeline's school line up in rows of eight, there are seven left over. If instead they line up in rows of four, how many are left over? The final answer is 3.}"

Translate the natural language version to an Isabelle version:



\
\hrule
\



\textbf{PaLM 64B output:} 
\begin{lstlisting}
theorem
    fixes girls :: nat
    assumes "(girls / 8) + 7 = girls"
    shows "girls = 3"
\end{lstlisting}
\end{boxB}


\begin{boxB}
\textbf{Question:} 

Natural Language version: "\emph{When all the girls at Madeline's school line up in rows of eight, there are seven left over. If instead they line up in rows of four, how many are left over? The final answer is 3.}"

Translate the natural language version to an Isabelle version:



\
\hrule
\

        
\textbf{PaLM 8B output:} 
\begin{lstlisting}
theorem
    fixes a b ::real
    assumes "(ln a) / (ln 8) + (ln (b^2)) / (ln 4) = 7"
            "(ln b) / (ln 8) + (ln (a^2)) / (ln 4) = 3"}}
    shows "a * b = 3"
\end{lstlisting}
\end{boxB}

\newpage
\subsection{Case Study 3}
\label{appendix:case_study_3}

If we include the following example in the prompt in additional to the two examples shown in Figure~\ref{fig:case_study_formal}:
\begin{boxB}
Natural language version: "What is the -coordinate for the -intercept of the line containing the points  and ? The final answer is 3".
Translate the natural language version to an Isabelle version:

\begin{lstlisting}
theorem
  fixes a b :: real
    and f :: "real \<Rightarrow> real"
  assumes h0 : "\<And>x. f x = a * x + b"
    and h1 : "f 7 = 4"
    and h2 : "f 6 = 3"
  shows "f 3 = 0"
\end{lstlisting}
\end{boxB}

Then Codex was able to formalize the problem perfectly:
\begin{boxB}
\textbf{Question:}

Natural language version:
"Let  be a linear function for which  What is  The final answer is 30."

Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{Codex Output:}

\begin{lstlisting}
theorem
    fixes a b :: real
        and f :: "real \<Rightarrow> real"
    assumes h0 : "\<And>x. f x = a * x + b"
        and h1 : "f 6 - f 2 = 12"
    shows "f 12 - f 2 = 30"
\end{lstlisting}
\end{boxB}
Note that this additional example in the prompt is only tangentially related. The phrase ``linear function'' is not even mentioned. Instead, it shows an example how to formalize a \emph{line}. But that is sufficient for the model to understand how to formalize a ``linear function''.




\section{More Examples on Mathematical Competition Problems}

\subsection{Perfect Translations}

\begin{boxB}
\textbf{Question:}

Natural language version: \emph{"At what point does the line containing the points 
 and  intersect the -axis? Express your answer as an ordered pair. 
The final answer is (0,5)".} Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes a b :: real
    and f :: "real \<Rightarrow> real"
  assumes h0 : "\<And>x. f x = a * x + b"
    and h1 : "f 1 = 7"
    and h2 : "f 3 = 11"
  shows "f 0 = 5"
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: \emph{"A map of the town that Annie, Barbara, 
and Charlie live in can be represented by the Cartesian plane.
 Annie is located at  and Barbara is located at .
 They agree to meet at the closest point that is equidistant from their current 
locations and walk upwards together to get to Charlie's location at . How many units upward do Annie and Barbara walk together to get to Charlie? 
The final answer is 5."} Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes a b c :: "real \<times> real"
  assumes h0 : "a = (6, -20)"
    and h1 : "b = (1, 14)"
    and h2 : "c = (7 / 2, 2)"
  shows "dist a c + dist b c = 5"
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Let  be a positive integer, 
and define the integers  and . When dividing  by , 
the quotient is , and the remainder is . Find . The final answer is 2".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x n d :: int
  assumes h0 : "x > 0"
    and h1 : "n = x^2 + 2 * x + 17"
    and h2 : "d = 2 * x + 5"
    and h3 : "n div d = x"
    and h4 : "n mod d = 7"
  shows "x = 2"
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "A line segment begins at . 
It is 5 units long and ends at the point  and . 
What is the value of ? The final answer is 7".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: real
  assumes h0 : "x > 0"
    and h1 : "5 = sqrt ((4 - 1)^2 + (x - 3)^2)"
  shows "x = 7"
\end{lstlisting}
\end{boxB}

\begin{boxB}
Natural language version: "A line segment begins at . 
It is 5 units long and ends at the point  and . 
What is the value of ? The final answer is 7".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: real
  assumes h0 : "x > 0"
    and h1 : "5 = sqrt ((4 - 1)^2 + (x - 3)^2)"
  shows "x = 7"  
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Let . 
How many distinct real numbers  satisfy ? The final answer is 9".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes f :: "real \<Rightarrow> real"
  assumes h0 : "\<forall> x. f x = x^2 - 2 * x"
  shows "card {c. f (f (f (f c))) = 3} = 9"    
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Find the solutions to   
Enter the solutions, separated by commas. The final answer is 1 + i, 1 - i, -1 + i, -1 - i".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes z :: complex
  assumes "z^4 = -4"
  shows "z = 1 + \<i> \<or> z = 1 - \<i> \<or> z = -1 + \<i> \<or> z = -1 - \<i>"   
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Let  be a complex number satisfying 
. Given that  is an integer, find  The final answer is 3 + 4i".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes z :: complex
  assumes h0 : "z^2 = 4 * z - 19 + 8 * \<i>"
    and h1 : "norm z \<in> \<int>"
  shows "z = 3 + 4 * \<i>" 
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "The sequence  satisfies
for all 
  If  find  The final answer is 2016".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes a :: "nat \<Rightarrow> real"
  assumes h0 : "\<forall> n \<ge> 2. (\<Sum> k = 1..n. a k) = n^2 * a n"
    and h1 : "a 63 = 1"
  shows "a 1 = 2016"    
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Find the units digit of the following 
within the indicated number base:  The final answer is 4".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x y :: nat
  assumes "x < 7"
    and "y < 7"
  shows "((x*7+2) + (y*7+2)) mod 7 = 4"
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "How many factors of 8000 are perfect squares? The final answer is 8".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes n :: nat
  assumes "n = card {k::nat. k^2 dvd 8000}"
  shows "n = 8"   
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Solve the congruence , as a residue modulo 43.  
(Give an answer between 0 and 42.) The final answer is 28".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes n :: nat
  assumes "n < 43"
    and "(11 * n) mod 43 = 7"
  shows "n = 28"
\end{lstlisting}
\end{boxB}




\begin{boxB}
\textbf{Question:}

Natural language version: "What is the 100th digit after the decimal 
point of the decimal representation of 1/7? The final answer is 8".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: nat
  assumes "x = (1/7) * 10^100"
  shows "x mod 10 = 8"
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Question:}

Natural language version: "Two positive integers  and  
are chosen such that  is the smallest positive integer with 
only two positive divisors and  is the largest integer less than  with exactly three positive divisors. What is ? The final answer is 51".

\
\hrule
\
 
\textbf{Codex Output:}
\begin{lstlisting}
  theorem
  fixes m n :: nat
  assumes "m = (LEAST k. card {d. d dvd k \<and> d > 0} = 2)"
    and "n = (GREATEST k. card {d. d dvd k \<and> d > 0} = 3 \<and> k < 100)"
  shows "m + n = 51"  
\end{lstlisting}
\end{boxB}

\newpage
\subsection{Incorrect Translations}

In this section, we present failure cases for each of the categories in Table~\ref{tab:failure} in Section.~\ref{sec:failure_case}.

\begin{boxB}
\textbf{Error category: incomplete/ill-formed/unclear prompt}

\textbf{Question:}

Natural language version: "Find the largest value of  
such that  The final answer is \textbackslash frac\{5".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes t :: real
  assumes h0 : "13 * t^2 - 34 * t + 12 = 3 * t - 2"
    and h1 : "5 * t = 6 * t - 1"
  shows "t = 5 / 2"  
\end{lstlisting}
\end{boxB}



\begin{boxB}
\textbf{Error category: fail to align definitions or concepts}

\textbf{Question:}

Natural language version: "What is the smallest four-digit positive integer that is divisible by 47? The final answer is 1034".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: nat
  assumes "x > 999"
    and "x < 10000"
    and "47 dvd x"
  shows "x = 1034" 
\end{lstlisting}
\end{boxB}
Here, the translator correctly captured the meaning of "four-digit positive integer" (i.e., \texttt{"x > 999"} and \texttt{"x < 10000"}) and that of "divisible by 47" (i.e., \texttt{"47 dvd x"}). However, it fails to align the "smallest" concept to the one in Isabelle. 

\begin{boxB}
\textbf{Error category: inconsistent/missing assumption}

\textbf{Question:}

Natural language version: "Jack walked up a hill at a speed of  
miles per hour. Meanwhile, Jill walked a total distance of  miles 
in  hours. If Jack and Jill walked at the same speed, what is that speed, 
in miles per hour? The final answer is 4".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: real
  assumes h0 : "x^2 - 11 * x - 22 = x^2 - 3 * x - 54"
  shows "x = 4"  
\end{lstlisting}
\end{boxB}
Here, the translator missed the "()" part in the natural language---it should be translated to \lstinline|"x^2 - 11 * x - 22 = (x^2 - 3 * x - 54)/(x+6)"| instead. Also, the conclusion is incorrect either: it should be \lstinline|"x^2 - 11 * x - 22 = 4"| or \lstinline|"(x^2 - 3 * x - 54)/(x+6) = 4"|. 

\begin{boxB}
\textbf{Error category: syntactical/type error)}

\textbf{Question:}

Natural language version: "Find
 The final answer is 8204".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes N :: nat
  shows "(\<Sum> N = 1..1024. nat \<lfloor>log 2 N\<rfloor>) = 8204"
\end{lstlisting}
\end{boxB}
In the current version, \texttt{N} will be inferred as a real number, so that the interval "\texttt{1..1024}" will be a real interval from 1 to 1024. This is incorrect, and sum over such infinite interval will result in 0 (i.e., \lstinline|"(\<Sum> N = 1..1024. nat \<lfloor>log 2 N\<rfloor>) = 0"|). The correct version requires an explicit type conversion:
\lstinline|"(\<Sum> N = 1..1024. \<lfloor>log 2 (of_int N)\<rfloor>) = 8204"|.

\begin{boxB}
\textbf{Error category: missing definition in Isabelle}

\textbf{Question:}

Natural language version: "The product of two positive three-digit 
palindromes is 436,995. What is their sum? The final answer is 1332".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x y :: nat
  assumes "100 \<le> x \<and> x \<le> 999"
    and "100 \<le> y \<and> y \<le> 999"
    and "x * y = 436995"
  shows "x + y = 1332"
\end{lstlisting}
\end{boxB}

The only missing part in this example is the definition of palindromes. It appears that the translator does not know what a palindrome is so that it chooses to drop it from the assumptions.

\begin{boxB}
\textbf{Error category: wrong application of functions}

\textbf{Question:}

Natural language version: "If the operation  is defined as , 
what is the value of ? The final answer is 22".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes a b :: real
  assumes h0 : "a Z b = b + 10 * a - a^2"
  shows "2 Z 6 = 22"
\end{lstlisting}
\end{boxB}
The function \lstinline|Z| should be applied in a prefix way in Isabelle. Also, the translator missed the "for all" quantifier in the assumption. The correct assumption should be \lstinline|"\<forall> a b. Z a b = b + 10 * a - a^2"|.

\begin{boxB}
\textbf{Error category: other}

\textbf{Question:}

Natural language version: "Simplify:  The final answer is 5".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes x :: real
  assumes h0 : "x = - 3 ^2 + 4"
  shows "abs x = 5" 
\end{lstlisting}
\end{boxB}
Here, a parenthesis should be placed around \lstinline|3 ^2| (i.e., \lstinline|"x = - (3 ^2) + 4"|). This is a subtle issue to operator precedence in Isabelle. 

\begin{boxB}
\textbf{Error category: other}

\textbf{Question:}

Natural language version: "How many numbers from  to  
are not perfect squares or perfect cubes? The final answer is 135".

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
theorem
  fixes n :: nat
  assumes "n \<le> 150"
  shows "card {k::nat. k \<le> n \<and> \<not> (\<exists> m. m^2 = k \<or> m^3 = k) } = 135"   
\end{lstlisting}
\end{boxB}
The translator somehow introduces an unnecessary variable \lstinline|n| and assumed \lstinline|"n \<le> 150"|. The correct translation should have \lstinline|n| replaced with 150 in the conclusion: \lstinline|"card {k::nat. k \<le> 150 \<and> \<not> (\<exists> m. m^2 = k \<or> m^3 = k) } = 135"|.   


\newpage
\section{More Examples on Advanced Mathematics}
\label{appendix:advanced_formal}

\subsection{Formalization}

\begin{boxB}
\textbf{Question:}

Natural language version: "Let  be a continuous function from a compact convex set  to itself.
 Then there exists  such that ." Translate the natural language version to an Isabelle version:

\
\hrule
\

\textbf{Codex Output:}

\begin{lstlisting}
theorem
  fixes f :: "'a::real_normed_vector \<Rightarrow> 'a"
  assumes "continuous_on S f"
          "compact S"
          "convex S"
        shows "\<exists>x\<in>S. f x = x"
\end{lstlisting}
\end{boxB}
Here, we asked the model to formalize the statement of the famous Brouwer's fixed-point theorem. The model made two mistakes. The first one is that the model erroneously assume the function is on a real normed vector space rather than a euclidean space or a banach space. This is quite understandable as we left this information in the source. The second and more critical error is that the absence of the assumption of  mapping from  to itself (i.e.,  or ).

\begin{boxB}
\textbf{Question:}
Let  be a closed path in the complex plane, 
and  be a point not on . Then the winding 
number of  around  is an integer.

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
  theorem
  fixes \<gamma> :: "real \<Rightarrow> complex" and z :: complex
  assumes "continuous_on {0..1} \<gamma>"
          "\<gamma> 0 = \<gamma> 1"
          "z \<notin> \<gamma> ` {0..1}"
        shows "winding_number \<gamma> z \<in> \<int>"
\end{lstlisting}
\end{boxB}
Here, the model has made a perfect translation--not only the model correctly infers that a path in the complex plane should be a function from the real interval  to complex, it also manages to align a path being closed to the assumption \verb|\<gamma> 0 = \<gamma> 1|.

\newpage
\subsection{Informalization}
\label{appendix:advanced_informal}
The following lemma statements are from the standard library of Isabellle (i.e., HOL-Complex\_Analysis and HOL-Probability).
\begin{boxB}
\begin{isabelle}
\isacommand{proposition}\isamarkupfalse \ openin{\isacharunderscore}{\kern0pt}clauses{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ U\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ topology{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\isanewline
\ \ \ \ {\isachardoublequoteopen}openin\ U\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymAnd}S\ T{\isachardot}{\kern0pt}\ openin\ U\ S\ {\isasymLongrightarrow}\ openin\ U\ T\ {\isasymLongrightarrow}\ openin\ U\ {\isacharparenleft}{\kern0pt}S{\isasyminter}T{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymAnd}K{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymforall}S\ {\isasymin}\ K{\isachardot}{\kern0pt}\ openin\ U\ S{\isacharparenright}{\kern0pt}\ {\isasymLongrightarrow}\ openin\ U\ {\isacharparenleft}{\kern0pt}{\isasymUnion}K{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}
\begin{lstlisting}
Let  be a topology, then  is open if and only if it satisfies the following conditions:
1.  is open.
2. If  and  are open, then  is open.
3. If  is a collection of open sets, then  is open.
\end{lstlisting}
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ openin{\isacharunderscore}{\kern0pt}Int{\isacharbrackleft}{\kern0pt}intro{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\ \isanewline
\ \ \ \ {\isachardoublequoteopen}openin\ U\ S\ {\isasymLongrightarrow}\ openin\ U\ T\ \isanewline
\ \ \ \ \ \ {\isasymLongrightarrow}\ openin\ U\ {\isacharparenleft}{\kern0pt}S\ {\isasyminter}\ T{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a topology, then  is open in , if  and  are open in , then  is open in , if  is a collection of sets, and each set in  is open in , then  is open in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ openin{\isacharunderscore}{\kern0pt}Int{\isacharbrackleft}{\kern0pt}intro{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\ \isanewline
\ \ \ \ {\isachardoublequoteopen}openin\ U\ S\ {\isasymLongrightarrow}\ openin\ U\ T\ \isanewline
\ \ \ \ \ \ {\isasymLongrightarrow}\ openin\ U\ {\isacharparenleft}{\kern0pt}S\ {\isasyminter}\ T{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  and  are open in , then  is open in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ openin{\isacharunderscore}{\kern0pt}Inter\ {\isacharbrackleft}{\kern0pt}intro{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}finite\ {\isasymF}{\isachardoublequoteclose}\ {\isachardoublequoteopen}{\isasymF}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\ {\isachardoublequoteopen}{\isasymAnd}X{\isachardot}{\kern0pt}\ X\ {\isasymin}\ {\isasymF}\ {\isasymLongrightarrow}\ openin\ T\ X{\isachardoublequoteclose}\ \isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}openin\ T\ {\isacharparenleft}{\kern0pt}{\isasymInter}{\isasymF}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline

\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a topological space, and  is a finite non-empty collection of open subsets of , then  is open in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ openin{\isacharunderscore}{\kern0pt}subtopology{\isacharcolon}{\kern0pt}\ \isanewline
\ \ \ \ \ \ {\isachardoublequoteopen}openin\ {\isacharparenleft}{\kern0pt}subtopology\ U\ V{\isacharparenright}{\kern0pt}\ S\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}{\isasymexists}T{\isachardot}{\kern0pt}\ openin\ U\ T\ {\isasymand}\ S\ {\isacharequal}{\kern0pt}\ T\ {\isasyminter}\ V{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

" is open in the subtopology of  induced by  if and only if there exists an open set  in  such that ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ closedin{\isacharunderscore}{\kern0pt}subtopology{\isacharunderscore}{\kern0pt}Un{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymlbrakk}closedin\ {\isacharparenleft}{\kern0pt}subtopology\ X\ T{\isacharparenright}{\kern0pt}\ S{\isacharsemicolon}{\kern0pt}\ closedin\ {\isacharparenleft}{\kern0pt}subtopology\ X\ U{\isacharparenright}{\kern0pt}\ S{\isasymrbrakk}\isanewline
\ \ \ \ \ {\isasymLongrightarrow}\ closedin\ {\isacharparenleft}{\kern0pt}subtopology\ X\ {\isacharparenleft}{\kern0pt}T\ {\isasymunion}\ U{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ S{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is closed in  and  is closed in , then  is closed in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ connected{\isacharunderscore}{\kern0pt}closedin{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ \ \ {\isachardoublequoteopen}connected\ S\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymnexists}E{\isadigit{1}}\ E{\isadigit{2}}{\isachardot}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ closedin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ S{\isacharparenright}{\kern0pt}\ E{\isadigit{1}}\ {\isasymand}\isanewline
\ \ \ \ \ \ \ \ closedin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ S{\isacharparenright}{\kern0pt}\ E{\isadigit{2}}\ {\isasymand}\isanewline
\ \ \ \ \ \ \ \ S\ {\isasymsubseteq}\ E{\isadigit{1}}\ {\isasymunion}\ E{\isadigit{2}}\ {\isasymand}\ E{\isadigit{1}}\ {\isasyminter}\ E{\isadigit{2}}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymand}\ E{\isadigit{1}}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymand}\ E{\isadigit{2}}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"A set  is connected if and only if there does not exist two closed sets  and  such that , ,  and ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{definition}\isamarkupfalse \ continuous{\isacharunderscore}{\kern0pt}map\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}map\ X\ Y\ f\ {\isasymequiv}\isanewline
\ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}x\ {\isasymin}\ topspace\ X{\isachardot}{\kern0pt}\ f\ x\ {\isasymin}\ topspace\ Y{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}U{\isachardot}{\kern0pt}\ openin\ Y\ U\ {\isasymlongrightarrow}\ openin\ X\ {\isacharbraceleft}{\kern0pt}x\ {\isasymin}\ topspace\ X{\isachardot}{\kern0pt}\ f\ x\ {\isasymin}\ U{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"A function  from a topological space  to a topological space  is continuous if for every open set  in , the preimage  is open in ". 
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{definition}\isamarkupfalse \ continuous{\isacharunderscore}{\kern0pt}map\ \isakeyword{where}\isanewline
\ \ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}map\ X\ Y\ f\ {\isasymequiv}\isanewline
\ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}x\ {\isasymin}\ topspace\ X{\isachardot}{\kern0pt}\ f\ x\ {\isasymin}\ topspace\ Y{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}U{\isachardot}{\kern0pt}\ openin\ Y\ U\ {\isasymlongrightarrow}\ openin\ X\ {\isacharbraceleft}{\kern0pt}x\ {\isasymin}\ topspace\ X{\isachardot}{\kern0pt}\ f\ x\ {\isasymin}\ U{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"A continuous map  is a map such that for every open set , the preimage  is open in ". 
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ connectedin{\isacharunderscore}{\kern0pt}separation{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}connectedin\ X\ S\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ \ \ \ \ S\ {\isasymsubseteq}\ topspace\ X\ {\isasymand}\isanewline
\ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymnexists}C{\isadigit{1}}\ C{\isadigit{2}}{\isachardot}{\kern0pt}\ C{\isadigit{1}}\ {\isasymunion}\ C{\isadigit{2}}\ {\isacharequal}{\kern0pt}\ S\ {\isasymand}\ C{\isadigit{1}}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymand}\ C{\isadigit{2}}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ {\isasymand}\ C{\isadigit{1}}\ {\isasyminter}\ X\ closure{\isacharunderscore}{\kern0pt}of\ C{\isadigit{2}}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymand}\ C{\isadigit{2}}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isasyminter}\ X\ closure{\isacharunderscore}{\kern0pt}of\ C{\isadigit{1}}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\ {\isacharparenleft}{\kern0pt}\isakeyword{is}\ {\isachardoublequoteopen}{\isacharquery}{\kern0pt}lhs\ {\isacharequal}{\kern0pt}\ {\isacharquery}{\kern0pt}rhs{\isachardoublequoteclose}{\isacharparenright}{\kern0pt}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

" is connected in  if and only if  and there do not exist two non-empty sets  and  such that  and  and ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ connectedin{\isacharunderscore}{\kern0pt}Union{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isasymU}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}S{\isachardot}{\kern0pt}\ S\ {\isasymin}\ {\isasymU}\ {\isasymLongrightarrow}\ connectedin\ X\ S{\isachardoublequoteclose}\ \isakeyword{and}\ ne{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymInter}{\isasymU}\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}connectedin\ X\ {\isacharparenleft}{\kern0pt}{\isasymUnion}{\isasymU}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is connected in  for all  and , then  is connected in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ compact{\isacharunderscore}{\kern0pt}space{\isacharunderscore}{\kern0pt}alt{\isacharcolon}{\kern0pt}\isanewline
\ \ \ {\isachardoublequoteopen}compact{\isacharunderscore}{\kern0pt}space\ X\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}{\isasymU}{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymforall}U\ {\isasymin}\ {\isasymU}{\isachardot}{\kern0pt}\ openin\ X\ U{\isacharparenright}{\kern0pt}\ {\isasymand}\ topspace\ X\ {\isasymsubseteq}\ {\isasymUnion}{\isasymU}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isasymlongrightarrow}\ {\isacharparenleft}{\kern0pt}{\isasymexists}{\isasymF}{\isachardot}{\kern0pt}\ finite\ {\isasymF}\ {\isasymand}\ {\isasymF}\ {\isasymsubseteq}\ {\isasymU}\ {\isasymand}\ topspace\ X\ {\isasymsubseteq}\ {\isasymUnion}{\isasymF}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"A topological space  is compact if and only if for every open cover  of , there exists a finite subcover  of ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ compactin{\isacharunderscore}{\kern0pt}subtopology{\isacharcolon}{\kern0pt}\ \isanewline
\ \ \ \ \ \ {\isachardoublequoteopen}compactin\ {\isacharparenleft}{\kern0pt}subtopology\ X\ S{\isacharparenright}{\kern0pt}\ T\ {\isasymlongleftrightarrow}\ compactin\ X\ T\ {\isasymand}\ T\ {\isasymsubseteq}\ S{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

" is compact in  if and only if  is compact in  and ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ closedin{\isacharunderscore}{\kern0pt}compact{\isacharunderscore}{\kern0pt}space{\isacharcolon}{\kern0pt}\isanewline
\ \ \ {\isachardoublequoteopen}{\isasymlbrakk}compact{\isacharunderscore}{\kern0pt}space\ X{\isacharsemicolon}{\kern0pt}\ closedin\ X\ S{\isasymrbrakk}\ {\isasymLongrightarrow}\ compactin\ X\ S{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a compact space and  is a closed subset of , then  is a compact space".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ compactin{\isacharunderscore}{\kern0pt}discrete{\isacharunderscore}{\kern0pt}topology{\isacharcolon}{\kern0pt}\isanewline
\ \ \ {\isachardoublequoteopen}compactin\ {\isacharparenleft}{\kern0pt}discrete{\isacharunderscore}{\kern0pt}topology\ X{\isacharparenright}{\kern0pt}\ S\ {\isasymlongleftrightarrow}\ S\ {\isasymsubseteq}\ X\ {\isasymand}\ finite\ S{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

" is compact in the discrete topology on  if and only if  is a finite subset of ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ image{\isacharunderscore}{\kern0pt}compactin{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ cpt{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}compactin\ X\ S{\isachardoublequoteclose}\ \isakeyword{and}\ cont{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}map\ X\ Y\ f{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}compactin\ Y\ {\isacharparenleft}{\kern0pt}f\ {\isacharbackquote}{\kern0pt}\ S{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is compact in  and  is continuous from  to , then  is compact in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ continuous{\isacharunderscore}{\kern0pt}on{\isacharunderscore}{\kern0pt}open{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}on\ S\ f\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}T{\isachardot}{\kern0pt}\ openin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ {\isacharparenleft}{\kern0pt}f\ {\isacharbackquote}{\kern0pt}\ S{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ T\ {\isasymlongrightarrow}\isanewline
\ \ \ \ \ \ openin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ S{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}S\ {\isasyminter}\ f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ T{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

" is continuous on  if and only if for any open set  in ,  is open in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ continuous{\isacharunderscore}{\kern0pt}closedin{\isacharunderscore}{\kern0pt}preimage{\isacharunderscore}{\kern0pt}gen{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}on\ S\ f{\isachardoublequoteclose}\ {\isachardoublequoteopen}f\ {\isacharbackquote}{\kern0pt}\ S\ {\isasymsubseteq}\ T{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}closedin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ T{\isacharparenright}{\kern0pt}\ U{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}closedin\ {\isacharparenleft}{\kern0pt}top{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}set\ S{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}S\ {\isasyminter}\ f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ U{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline

\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is continuous on  and , and  is closed in , then  is closed in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ Casorati{\isacharunderscore}{\kern0pt}Weierstrass{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}open\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}z\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}f\ holomorphic{\isacharunderscore}{\kern0pt}on\ {\isacharparenleft}{\kern0pt}M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ {\isachardoublequoteopen}{\isasymAnd}l{\isachardot}{\kern0pt}\ {\isasymnot}\ {\isacharparenleft}{\kern0pt}f\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}{\isasymAnd}l{\isachardot}{\kern0pt}\ {\isasymnot}\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}inverse\ {\isasymcirc}\ f{\isacharparenright}{\kern0pt}\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}closure{\isacharparenleft}{\kern0pt}f\ {\isacharbackquote}{\kern0pt}\ {\isacharparenleft}{\kern0pt}M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ UNIV{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a holomorphic function on an open set  containing . If  is not constant in any neighborhood of  and  is not constant in any neighborhood of , then  is dense in ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}open\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}z\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}f\ holomorphic{\isacharunderscore}{\kern0pt}on\ {\isacharparenleft}{\kern0pt}M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ {\isachardoublequoteopen}{\isasymAnd}l{\isachardot}{\kern0pt}\ {\isasymnot}\ {\isacharparenleft}{\kern0pt}f\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}{\isasymAnd}l{\isachardot}{\kern0pt}\ {\isasymnot}\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}inverse\ {\isasymcirc}\ f{\isacharparenright}{\kern0pt}\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}closure{\isacharparenleft}{\kern0pt}f\ {\isacharbackquote}{\kern0pt}\ {\isacharparenleft}{\kern0pt}M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ UNIV{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be an open set and . Let  be a holomorphic function on . If  is not bounded in any neighborhood of  and  is not bounded in any neighborhood of , then  is dense in . 
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ great{\isacharunderscore}{\kern0pt}Picard{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}open\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}z\ {\isasymin}\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}a\ {\isasymnoteq}\ b{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \isakeyword{and}\ holf{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}f\ holomorphic{\isacharunderscore}{\kern0pt}on\ {\isacharparenleft}{\kern0pt}M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ fab{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}w{\isachardot}{\kern0pt}\ w\ {\isasymin}\ M\ {\isacharminus}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}\ {\isasymLongrightarrow}\ f\ w\ {\isasymnoteq}\ a\ {\isasymand}\ f\ w\ {\isasymnoteq}\ b{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{obtains}\ l\ \isakeyword{where}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}f\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}\ \isanewline
\ \ \ \ \ \ {\isasymor}\ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}inverse\ {\isasymcirc}\ f{\isacharparenright}{\kern0pt}\ {\isasymlonglongrightarrow}\ l{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ z{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a holomorphic function on , where  is an open set and . If  and , then  or  has a limit at ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ brouwer{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}euclidean{\isacharunderscore}{\kern0pt}space\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ S{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}compact\ S{\isachardoublequoteclose}\ {\isachardoublequoteopen}convex\ S{\isachardoublequoteclose}\ {\isachardoublequoteopen}S\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ contf{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}on\ S\ f{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ fim{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}f\ {\isacharbackquote}{\kern0pt}\ S\ {\isasymsubseteq}\ S{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{obtains}\ x\ \isakeyword{where}\ {\isachardoublequoteopen}x\ {\isasymin}\ S{\isachardoublequoteclose}\ \isakeyword{and}\ {\isachardoublequoteopen}f\ x\ {\isacharequal}{\kern0pt}\ x{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a continuous function from a compact convex set  to itself. Then there exists  such that ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ Jordan{\isacharunderscore}{\kern0pt}curve{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ c\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}real\ {\isasymRightarrow}\ complex{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}simple{\isacharunderscore}{\kern0pt}path\ c{\isachardoublequoteclose}\ \isakeyword{and}\ loop{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}pathfinish\ c\ {\isacharequal}{\kern0pt}\ pathstart\ c{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{obtains}\ inner\ outer\ \isakeyword{where}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}inner\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\ {\isachardoublequoteopen}open\ inner{\isachardoublequoteclose}\ {\isachardoublequoteopen}connected\ inner{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}outer\ {\isasymnoteq}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\ {\isachardoublequoteopen}open\ outer{\isachardoublequoteclose}\ {\isachardoublequoteopen}connected\ outer{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}bounded\ inner{\isachardoublequoteclose}\ {\isachardoublequoteopen}{\isasymnot}\ bounded\ outer{\isachardoublequoteclose}\ {\isachardoublequoteopen}inner\ {\isasyminter}\ outer\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}inner\ {\isasymunion}\ outer\ {\isacharequal}{\kern0pt}\ {\isacharminus}{\kern0pt}\ path{\isacharunderscore}{\kern0pt}image\ c{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}frontier\ inner\ {\isacharequal}{\kern0pt}\ path{\isacharunderscore}{\kern0pt}image\ c{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}frontier\ outer\ {\isacharequal}{\kern0pt}\ path{\isacharunderscore}{\kern0pt}image\ c{\isachardoublequoteclose}\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a simple closed curve. Then there exist two disjoint open sets  and  such that  is bounded,  is unbounded, , , , and ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{corollary}\isamarkupfalse \ Jordan{\isacharunderscore}{\kern0pt}disconnected{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ c\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}real\ {\isasymRightarrow}\ complex{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}simple{\isacharunderscore}{\kern0pt}path\ c{\isachardoublequoteclose}\ {\isachardoublequoteopen}pathfinish\ c\ {\isacharequal}{\kern0pt}\ pathstart\ c{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymnot}\ connected{\isacharparenleft}{\kern0pt}{\isacharminus}{\kern0pt}\ path{\isacharunderscore}{\kern0pt}image\ c{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}

Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a simple closed curve, then  is not connected".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ inverse{\isacharunderscore}{\kern0pt}squares{\isacharunderscore}{\kern0pt}sums{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}{\isasymlambda}n{\isachardot}{\kern0pt}\ {\isadigit{1}}\ {\isacharslash}{\kern0pt}\ {\isacharparenleft}{\kern0pt}n\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isacharparenright}{\kern0pt}\isactrlsup {\isadigit{2}}{\isacharparenright}{\kern0pt}\ sums\ {\isacharparenleft}{\kern0pt}pi\isactrlsup {\isadigit{2}}\ {\isacharslash}{\kern0pt}\ {\isadigit{6}}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Find the sum of the series . The final answer is ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{proposition}\isamarkupfalse \ connected{\isacharunderscore}{\kern0pt}space{\isacharunderscore}{\kern0pt}product{\isacharunderscore}{\kern0pt}topology{\isacharcolon}{\kern0pt}\isanewline
\ \ \ {\isachardoublequoteopen}connected{\isacharunderscore}{\kern0pt}space{\isacharparenleft}{\kern0pt}product{\isacharunderscore}{\kern0pt}topology\ X\ I{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymPi}\isactrlsub E\ i{\isasymin}I{\isachardot}{\kern0pt}\ topspace\ {\isacharparenleft}{\kern0pt}X\ i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymor}\ {\isacharparenleft}{\kern0pt}{\isasymforall}i\ {\isasymin}\ I{\isachardot}{\kern0pt}\ connected{\isacharunderscore}{\kern0pt}space{\isacharparenleft}{\kern0pt}X\ i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"The product topology of a family of topological spaces is connected if and only if the product of the topological spaces is empty or each topological space is connected".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ ring{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}sets{\isacharparenright}{\kern0pt}\ caratheodory{\isacharprime}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ posf{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}positive\ M\ f{\isachardoublequoteclose}\ \isakeyword{and}\ ca{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}countably{\isacharunderscore}{\kern0pt}additive\ M\ f{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}{\isasymmu}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacharprime}{\kern0pt}a\ set\ {\isasymRightarrow}\ ennreal{\isachardot}{\kern0pt}\ \isanewline
\ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}s\ {\isasymin}\ M{\isachardot}{\kern0pt}\ {\isasymmu}\ s\ {\isacharequal}{\kern0pt}\ f\ s{\isacharparenright}{\kern0pt}\ {\isasymand}\ measure{\isacharunderscore}{\kern0pt}space\ {\isasymOmega}\ {\isacharparenleft}{\kern0pt}sigma{\isacharunderscore}{\kern0pt}sets\ {\isasymOmega}\ M{\isacharparenright}{\kern0pt}\ {\isasymmu}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a -algebra on , and  be a positive countably additive function on . Then there exists a measure  on  such that  for all  and  is a measure space".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ sigma{\isacharunderscore}{\kern0pt}finite{\isacharunderscore}{\kern0pt}density{\isacharunderscore}{\kern0pt}unique{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ borel{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}f\ {\isasymin}\ borel{\isacharunderscore}{\kern0pt}measurable\ M{\isachardoublequoteclose}\ {\isachardoublequoteopen}g\ {\isasymin}\ borel{\isacharunderscore}{\kern0pt}measurable\ M{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{and}\ fin{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}sigma{\isacharunderscore}{\kern0pt}finite{\isacharunderscore}{\kern0pt}measure\ {\isacharparenleft}{\kern0pt}density\ M\ f{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\isakeyword{shows}\ {\isachardoublequoteopen}density\ M\ f\ {\isacharequal}{\kern0pt}\ density\ M\ g\ {\isasymlongleftrightarrow}\ {\isacharparenleft}{\kern0pt}AE\ x\ in\ M{\isachardot}{\kern0pt}\ f\ x\ {\isacharequal}{\kern0pt}\ g\ x{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  and  be two measurable functions on a sigma-finite measure space . Then  and  are equal almost everywhere if and only if the measures  and  are equal".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ mvt{\isacharunderscore}{\kern0pt}simple{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}real\ {\isasymRightarrow}\ real{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}a\ {\isacharless}{\kern0pt}\ b{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ derf{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}x{\isachardot}{\kern0pt}\ {\isasymlbrakk}a\ {\isasymle}\ x{\isacharsemicolon}{\kern0pt}\ x\ {\isasymle}\ b{\isasymrbrakk}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isasymLongrightarrow}\ {\isacharparenleft}{\kern0pt}f\ has{\isacharunderscore}{\kern0pt}derivative\ f{\isacharprime}{\kern0pt}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ x\ within\ {\isacharbraceleft}{\kern0pt}a{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}b{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}x{\isasymin}{\isacharbraceleft}{\kern0pt}a{\isacharless}{\kern0pt}{\isachardot}{\kern0pt}{\isachardot}{\kern0pt}{\isacharless}{\kern0pt}b{\isacharbraceright}{\kern0pt}{\isachardot}{\kern0pt}\ f\ b\ {\isacharminus}{\kern0pt}\ f\ a\ {\isacharequal}{\kern0pt}\ f{\isacharprime}{\kern0pt}\ x\ {\isacharparenleft}{\kern0pt}b\ {\isacharminus}{\kern0pt}\ a{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a function defined on  and differentiable on . Then there exists a point  such that ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ second{\isacharunderscore}{\kern0pt}countable{\isacharunderscore}{\kern0pt}borel{\isacharunderscore}{\kern0pt}measurable{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ X\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}second{\isacharunderscore}{\kern0pt}countable{\isacharunderscore}{\kern0pt}topology\ set\ set{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ eq{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}open\ {\isacharequal}{\kern0pt}\ generate{\isacharunderscore}{\kern0pt}topology\ X{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}borel\ {\isacharequal}{\kern0pt}\ sigma\ UNIV\ X{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a set of open sets in a second countable topology. Then the Borel -algebra is the -algebra generated by ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ borel{\isacharunderscore}{\kern0pt}measurable{\isacharunderscore}{\kern0pt}ereal{\isacharunderscore}{\kern0pt}iff{\isacharunderscore}{\kern0pt}real{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ ereal{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}f\ {\isasymin}\ borel{\isacharunderscore}{\kern0pt}measurable\ M\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ {\isacharparenleft}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ real{\isacharunderscore}{\kern0pt}of{\isacharunderscore}{\kern0pt}ereal\ {\isacharparenleft}{\kern0pt}f\ x{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ {\isasymin}\ borel{\isacharunderscore}{\kern0pt}measurable\ M\ {\isasymand}\ f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isasyminfinity}{\isacharbraceright}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ \ \ {\isasyminter}\ space\ M\ {\isasymin}\ sets\ M\ {\isasymand}\ f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharminus}{\kern0pt}{\isasyminfinity}{\isacharbraceright}{\kern0pt}\ {\isasyminter}\ space\ M\ {\isasymin}\ sets\ M{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a function from  to , then  is measurable if and only if  is measurable and  and  are measurable sets".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ condensation{\isacharunderscore}{\kern0pt}test{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ mono{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}m{\isachardot}{\kern0pt}\ {\isadigit{0}}\ {\isacharless}{\kern0pt}\ m\ {\isasymLongrightarrow}\ f\ {\isacharparenleft}{\kern0pt}Suc\ m{\isacharparenright}{\kern0pt}\ {\isasymle}\ f\ m{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ nonneg{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}n{\isachardot}{\kern0pt}\ f\ n\ {\isasymge}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}summable\ f\ {\isasymlongleftrightarrow}\ summable\ {\isacharparenleft}{\kern0pt}{\isasymlambda}n{\isachardot}{\kern0pt}\ {\isadigit{2}}{\isacharcircum}{\kern0pt}n\ {\isacharasterisk}{\kern0pt}\ f\ {\isacharparenleft}{\kern0pt}{\isadigit{2}}{\isacharcircum}{\kern0pt}n{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a non-negative function such that  for all . Prove that  is summable if and only if  is summable".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ ratio{\isacharunderscore}{\kern0pt}test{\isacharunderscore}{\kern0pt}convergence{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ real{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ pos{\isacharunderscore}{\kern0pt}f{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}eventually\ {\isacharparenleft}{\kern0pt}{\isasymlambda}n{\isachardot}{\kern0pt}\ f\ n\ {\isachargreater}{\kern0pt}\ {\isadigit{0}}{\isacharparenright}{\kern0pt}\ sequentially{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{defines}\ {\isachardoublequoteopen}l\ {\isasymequiv}\ liminf\ {\isacharparenleft}{\kern0pt}{\isasymlambda}n{\isachardot}{\kern0pt}\ ereal\ {\isacharparenleft}{\kern0pt}f\ n\ {\isacharslash}{\kern0pt}\ f\ {\isacharparenleft}{\kern0pt}Suc\ n{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ l{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}l\ {\isachargreater}{\kern0pt}\ {\isadigit{1}}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ \ \ {\isachardoublequoteopen}summable\ f{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a positive function, and let  be the limit inferior of the sequence . If , then  is summable".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ Stone{\isacharunderscore}{\kern0pt}Weierstrass{\isacharunderscore}{\kern0pt}polynomial{\isacharunderscore}{\kern0pt}function{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ f\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isacharprime}{\kern0pt}a{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}euclidean{\isacharunderscore}{\kern0pt}space\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}b{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}euclidean{\isacharunderscore}{\kern0pt}space{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ S{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}compact\ S{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ f{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}continuous{\isacharunderscore}{\kern0pt}on\ S\ f{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ e{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isadigit{0}}\ {\isacharless}{\kern0pt}\ e{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}g{\isachardot}{\kern0pt}\ polynomial{\isacharunderscore}{\kern0pt}function\ g\ {\isasymand}\ {\isacharparenleft}{\kern0pt}{\isasymforall}x\ {\isasymin}\ S{\isachardot}{\kern0pt}\ norm{\isacharparenleft}{\kern0pt}f\ x\ {\isacharminus}{\kern0pt}\ g\ x{\isacharparenright}{\kern0pt}\ {\isacharless}{\kern0pt}\ e{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a continuous function on a compact set . Then there exists a polynomial function  such that .
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ Riemann{\isacharunderscore}{\kern0pt}mapping{\isacharunderscore}{\kern0pt}theorem{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ {\isachardoublequoteopen}open\ S\ {\isasymand}\ simply{\isacharunderscore}{\kern0pt}connected\ S\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ \ S\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymor}\ S\ {\isacharequal}{\kern0pt}\ UNIV\ {\isasymor}\isanewline
\ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymexists}f\ g{\isachardot}{\kern0pt}\ f\ holomorphic{\isacharunderscore}{\kern0pt}on\ S\ {\isasymand}\ g\ holomorphic{\isacharunderscore}{\kern0pt}on\ ball\ {\isadigit{0}}\ {\isadigit{1}}\ {\isasymand}\isanewline
\ \ \ \ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}z\ {\isasymin}\ S{\isachardot}{\kern0pt}\ f\ z\ {\isasymin}\ ball\ {\isadigit{0}}\ {\isadigit{1}}\ {\isasymand}\ g{\isacharparenleft}{\kern0pt}f\ z{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ z{\isacharparenright}{\kern0pt}\ {\isasymand}\isanewline
\ \ \ \ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymforall}z\ {\isasymin}\ ball\ {\isadigit{0}}\ {\isadigit{1}}{\isachardot}{\kern0pt}\ g\ z\ {\isasymin}\ S\ {\isasymand}\ f{\isacharparenleft}{\kern0pt}g\ z{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ z{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a simply connected open set. Then  is either empty, the whole plane, or there exists a holomorphic function  from  to the unit disk and a holomorphic function  from the unit disk to  such that  is the identity function on  and  is the identity function on the unit disk."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ Residue{\isacharunderscore}{\kern0pt}theorem{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ s\ pts{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}complex\ set{\isachardoublequoteclose}\ \isakeyword{and}\ f{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}complex\ {\isasymRightarrow}\ complex{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ g{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}real\ {\isasymRightarrow}\ complex{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}open\ s{\isachardoublequoteclose}\ {\isachardoublequoteopen}connected\ s{\isachardoublequoteclose}\ {\isachardoublequoteopen}finite\ pts{\isachardoublequoteclose}\ \isakeyword{and}\isanewline
\ \ \ \ \ \ \ \ \ \ holo{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}f\ holomorphic{\isacharunderscore}{\kern0pt}on\ s{\isacharminus}{\kern0pt}pts{\isachardoublequoteclose}\ \isakeyword{and}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}valid{\isacharunderscore}{\kern0pt}path\ g{\isachardoublequoteclose}\ \isakeyword{and}\isanewline
\ \ \ \ \ \ \ \ \ \ loop{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}pathfinish\ g\ {\isacharequal}{\kern0pt}\ pathstart\ g{\isachardoublequoteclose}\ \isakeyword{and}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}path{\isacharunderscore}{\kern0pt}image\ g\ {\isasymsubseteq}\ s{\isacharminus}{\kern0pt}pts{\isachardoublequoteclose}\ \isakeyword{and}\isanewline
\ \ \ \ \ \ \ \ \ \ homo{\isacharcolon}{\kern0pt}{\isachardoublequoteopen}{\isasymforall}z{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}z\ {\isasymnotin}\ s{\isacharparenright}{\kern0pt}\ {\isasymlongrightarrow}\ winding{\isacharunderscore}{\kern0pt}number\ g\ z\ \ {\isacharequal}{\kern0pt}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}contour{\isacharunderscore}{\kern0pt}integral\ g\ f\ {\isacharequal}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isadigit{2}}\ {\isacharasterisk}{\kern0pt}\ pi\ {\isacharasterisk}{\kern0pt}\ {\isasymi}\ {\isacharasterisk}{\kern0pt}{\isacharparenleft}{\kern0pt}{\isasymSum}p{\isasymin}pts{\isachardot}{\kern0pt}\ winding{\isacharunderscore}{\kern0pt}number\ g\ p\ {\isacharasterisk}{\kern0pt}\ residue\ f\ p{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a holomorphic function on a connected open set  and let  be a closed path in  that does not pass through any of the points in the finite set . Then ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ integer{\isacharunderscore}{\kern0pt}winding{\isacharunderscore}{\kern0pt}number{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}path\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ pathfinish\ {\isasymgamma}\ {\isacharequal}{\kern0pt}\ pathstart\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ \isanewline
\ \ z\ {\isasymnotin}\ path{\isacharunderscore}{\kern0pt}image\ {\isasymgamma}{\isasymrbrakk}\ {\isasymLongrightarrow}\ winding{\isacharunderscore}{\kern0pt}number\ \isanewline
\ \ {\isasymgamma}\ z\ {\isasymin}\ {\isasymint}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a closed path in the complex plane, and  be a point not on . Then the winding number of  around  is an integer".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ winding{\isacharunderscore}{\kern0pt}number{\isacharunderscore}{\kern0pt}eq{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ \ {\isachardoublequoteopen}{\isasymlbrakk}path\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ pathfinish\ {\isasymgamma}\ \isanewline
\ \ \ \ \ \ \ \ {\isacharequal}{\kern0pt}\ pathstart\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ w\ {\isasymin}\ S{\isacharsemicolon}{\kern0pt}\ z\ {\isasymin}\ S{\isacharsemicolon}{\kern0pt}\ connected\ S{\isacharsemicolon}{\kern0pt}\ \isanewline
\ \ \ \ \ \ \ \ S\ {\isasyminter}\ path{\isacharunderscore}{\kern0pt}image\ {\isasymgamma}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}{\isasymrbrakk}\isanewline
\ \ \ \ \ \ {\isasymLongrightarrow}\ winding{\isacharunderscore}{\kern0pt}number\ {\isasymgamma}\ w\ {\isacharequal}{\kern0pt}\ winding{\isacharunderscore}{\kern0pt}number\ {\isasymgamma}\ z{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a closed path in the plane, and let  be two points in the plane. If  does not pass through  or , and  are in the same connected component of the plane, then the winding number of  about  is the same as the winding number of  about ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{corollary}\isamarkupfalse \ winding{\isacharunderscore}{\kern0pt}number{\isacharunderscore}{\kern0pt}zero{\isacharunderscore}{\kern0pt}outside{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymlbrakk}path\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ convex\ s{\isacharsemicolon}{\kern0pt}\ pathfinish\ {\isasymgamma}\ \isanewline
\ \ \ \ {\isacharequal}{\kern0pt}\ pathstart\ {\isasymgamma}{\isacharsemicolon}{\kern0pt}\ z\ {\isasymnotin}\ s{\isacharsemicolon}{\kern0pt}\ path{\isacharunderscore}{\kern0pt}image\ {\isasymgamma}\ \isanewline
\ \ \ \ {\isasymsubseteq}\ s{\isasymrbrakk}\ {\isasymLongrightarrow}\ winding{\isacharunderscore}{\kern0pt}number\ {\isasymgamma}\ z\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a path,  is a convex set,  is a closed path,  is not in , and  is in , then the winding number of  around  is 0".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ winding{\isacharunderscore}{\kern0pt}number{\isacharunderscore}{\kern0pt}zero{\isacharunderscore}{\kern0pt}at{\isacharunderscore}{\kern0pt}infinity{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isasymgamma}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}path\ {\isasymgamma}{\isachardoublequoteclose}\ \isakeyword{and}\ loop{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}pathfinish\ {\isasymgamma}\ {\isacharequal}{\kern0pt}\ pathstart\ {\isasymgamma}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isasymexists}B{\isachardot}{\kern0pt}\ {\isasymforall}z{\isachardot}{\kern0pt}\ B\ {\isasymle}\ norm\ z\ {\isasymlongrightarrow}\ winding{\isacharunderscore}{\kern0pt}number\ {\isasymgamma}\ z\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a closed path, then there exists a constant  such that for all , if , then the winding number of  at  is 0". 
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ winding{\isacharunderscore}{\kern0pt}number{\isacharunderscore}{\kern0pt}homotopic{\isacharunderscore}{\kern0pt}paths{\isacharcolon}{\kern0pt}\isanewline
\ \ \ \ \isakeyword{assumes}\ {\isachardoublequoteopen}homotopic{\isacharunderscore}{\kern0pt}paths\ {\isacharparenleft}{\kern0pt}{\isacharminus}{\kern0pt}{\isacharbraceleft}{\kern0pt}z{\isacharbraceright}{\kern0pt}{\isacharparenright}{\kern0pt}\ g\ h{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}winding{\isacharunderscore}{\kern0pt}number\ g\ z\ {\isacharequal}{\kern0pt}\ winding{\isacharunderscore}{\kern0pt}number\ h\ z{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  and  are homotopic paths in , then the winding number of  around  is equal to the winding number of  around ".
\end{boxB}



\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ simple{\isacharunderscore}{\kern0pt}closed{\isacharunderscore}{\kern0pt}path{\isacharunderscore}{\kern0pt}winding{\isacharunderscore}{\kern0pt}number{\isacharunderscore}{\kern0pt}cases{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}simple{\isacharunderscore}{\kern0pt}path\ {\isasymgamma}{\isachardoublequoteclose}\ {\isachardoublequoteopen}pathfinish\ {\isasymgamma}\ {\isacharequal}{\kern0pt}\ pathstart\ {\isasymgamma}{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}z\ {\isasymnotin}\ path{\isacharunderscore}{\kern0pt}image\ {\isasymgamma}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}winding{\isacharunderscore}{\kern0pt}number\ {\isasymgamma}\ z\ {\isasymin}\ {\isacharbraceleft}{\kern0pt}{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharcomma}{\kern0pt}{\isadigit{0}}{\isacharcomma}{\kern0pt}{\isadigit{1}}{\isacharbraceright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a simple closed path,  is not in the image of , then the winding number of  at  is either -1, 0 or 1".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{corollary}\isamarkupfalse \ Cauchy{\isacharunderscore}{\kern0pt}theorem{\isacharunderscore}{\kern0pt}primitive{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}{\isasymAnd}x{\isachardot}{\kern0pt}\ x\ {\isasymin}\ S\ {\isasymLongrightarrow}\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}f\ has{\isacharunderscore}{\kern0pt}field{\isacharunderscore}{\kern0pt}derivative\ f{\isacharprime}{\kern0pt}\ x{\isacharparenright}{\kern0pt}\ {\isacharparenleft}{\kern0pt}at\ x\ within\ S{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \isakeyword{and}\ {\isachardoublequoteopen}valid{\isacharunderscore}{\kern0pt}path\ g{\isachardoublequoteclose}\ {\isachardoublequoteopen}path{\isacharunderscore}{\kern0pt}image\ g\ {\isasymsubseteq}\ S{\isachardoublequoteclose}\ \isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}pathfinish\ g\ {\isacharequal}{\kern0pt}\ pathstart\ g{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}{\kern0pt}f{\isacharprime}{\kern0pt}\ has{\isacharunderscore}{\kern0pt}contour{\isacharunderscore}{\kern0pt}integral\ {\isadigit{0}}{\isacharparenright}{\kern0pt}\ g{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a function with a derivative  on a set , and  is a closed path in , then ".
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{theorem}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ prob{\isacharunderscore}{\kern0pt}space{\isacharparenright}{\kern0pt}\ central{\isacharunderscore}{\kern0pt}limit{\isacharunderscore}{\kern0pt}theorem{\isacharunderscore}{\kern0pt}zero{\isacharunderscore}{\kern0pt}mean{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ X\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ real{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ {\isasymmu}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}real\ measure{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ {\isasymsigma}\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ real\isanewline
\ \ \ \ \isakeyword{and}\ S\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}nat\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ real{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{assumes}\ X{\isacharunderscore}{\kern0pt}indep{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}indep{\isacharunderscore}{\kern0pt}vars\ {\isacharparenleft}{\kern0pt}{\isasymlambda}i{\isachardot}{\kern0pt}\ borel{\isacharparenright}{\kern0pt}\ X\ UNIV{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ X{\isacharunderscore}{\kern0pt}mean{\isacharunderscore}{\kern0pt}{\isadigit{0}}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}n{\isachardot}{\kern0pt}\ expectation\ {\isacharparenleft}{\kern0pt}X\ n{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ {\isasymsigma}{\isacharunderscore}{\kern0pt}pos{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymsigma}\ {\isachargreater}{\kern0pt}\ {\isadigit{0}}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ X{\isacharunderscore}{\kern0pt}square{\isacharunderscore}{\kern0pt}integrable{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}n{\isachardot}{\kern0pt}\ integrable\ M\ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}X\ n\ x{\isacharparenright}{\kern0pt}\isactrlsup {\isadigit{2}}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ X{\isacharunderscore}{\kern0pt}variance{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}n{\isachardot}{\kern0pt}\ variance\ {\isacharparenleft}{\kern0pt}X\ n{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isasymsigma}\isactrlsup {\isadigit{2}}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ X{\isacharunderscore}{\kern0pt}distrib{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}n{\isachardot}{\kern0pt}\ distr\ M\ borel\ {\isacharparenleft}{\kern0pt}X\ n{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isasymmu}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{defines}\ {\isachardoublequoteopen}S\ n\ {\isasymequiv}\ {\isasymlambda}x{\isachardot}{\kern0pt}\ {\isasymSum}i{\isacharless}{\kern0pt}n{\isachardot}{\kern0pt}\ X\ i\ x{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}weak{\isacharunderscore}{\kern0pt}conv{\isacharunderscore}{\kern0pt}m\ {\isacharparenleft}{\kern0pt}{\isasymlambda}n{\isachardot}{\kern0pt}\ distr\ M\ borel\ \isanewline
\ \ \ \ \ \ \ \ \ \ \ {\isacharparenleft}{\kern0pt}{\isasymlambda}x{\isachardot}{\kern0pt}\ S\ n\ x\ {\isacharslash}{\kern0pt}\ sqrt\ {\isacharparenleft}{\kern0pt}n\ {\isacharasterisk}{\kern0pt}\ {\isasymsigma}\isactrlsup {\isadigit{2}}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}\ std{\isacharunderscore}{\kern0pt}normal{\isacharunderscore}{\kern0pt}distribution{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"Let  be a sequence of independent random variables with mean 0 and variance . Let . Then  converges in distribution to a standard normal distribution".
\end{boxB}


\begin{boxB}
\begin{isabelle}
\isacommand{proposition}\isamarkupfalse \ compact{\isacharunderscore}{\kern0pt}space{\isacharunderscore}{\kern0pt}product{\isacharunderscore}{\kern0pt}topology{\isacharcolon}{\kern0pt}\isanewline
\ \ \ {\isachardoublequoteopen}compact{\isacharunderscore}{\kern0pt}space{\isacharparenleft}{\kern0pt}product{\isacharunderscore}{\kern0pt}topology\ X\ I{\isacharparenright}{\kern0pt}\ {\isasymlongleftrightarrow}\isanewline
\ \ \ \ topspace{\isacharparenleft}{\kern0pt}product{\isacharunderscore}{\kern0pt}topology\ X\ I{\isacharparenright}{\kern0pt}\ {\isacharequal}{\kern0pt}\ {\isacharbraceleft}{\kern0pt}{\isacharbraceright}{\kern0pt}\ {\isasymor}\ {\isacharparenleft}{\kern0pt}{\isasymforall}i\ {\isasymin}\ I{\isachardot}{\kern0pt}\ compact{\isacharunderscore}{\kern0pt}space{\isacharparenleft}{\kern0pt}X\ i{\isacharparenright}{\kern0pt}{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a compact space for all , then  is a compact space".
\end{boxB}

Lemma statements in the remainder of this section are from the \emph{Topology} entry in the AFP.\footnote{\url{https://www.isa-afp.org/browser_info/current/AFP/Topology/Topology.html}} All the natural language version is generated by the Codex model.

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ seteqI{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}{\isasymAnd}x{\isachardot}{\kern0pt}\ x{\isasymin}A\ {\isasymLongrightarrow}\ x{\isasymin}B{\isacharsemicolon}{\kern0pt}\ {\isasymAnd}x{\isachardot}{\kern0pt}\ x{\isasymin}B\ {\isasymLongrightarrow}\ x{\isasymin}A\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ A\ {\isacharequal}{\kern0pt}\ B{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  and  are sets such that  and , then ."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ carrier{\isacharparenright}{\kern0pt}\ openI{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}m\ {\isasymin}\ T\ {\isasymLongrightarrow}\ m\ open{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a topology on a set , then  is open."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ carrier{\isacharparenright}{\kern0pt}\ openE{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymlbrakk}\ m\ open{\isacharsemicolon}{\kern0pt}\ m\ {\isasymin}\ T\ {\isasymLongrightarrow}\ R\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ R{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is an open set in a topological space , then ."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ topology{\isacharparenright}{\kern0pt}\ open{\isacharunderscore}{\kern0pt}kriterion{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ t{\isacharunderscore}{\kern0pt}contains{\isacharunderscore}{\kern0pt}open{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}\ x{\isachardot}{\kern0pt}\ x{\isasymin}t\ {\isasymLongrightarrow}\ {\isasymexists}t{\isacharprime}{\kern0pt}{\isachardot}{\kern0pt}\ t{\isacharprime}{\kern0pt}\ open\ {\isasymand}\ x{\isasymin}t{\isacharprime}{\kern0pt}\ {\isasymand}\ t{\isacharprime}{\kern0pt}{\isasymsubseteq}t{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}t\ open{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a subset of a topological space  such that for every , there exists an open set  such that  and , then  is open."
\end{boxB}

\begin{boxB}
\begin{isabelle}
 \isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ carrier{\isacharparenright}{\kern0pt}\ carrierI\ {\isacharbrackleft}{\kern0pt}intro{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}\ t\ open{\isacharsemicolon}{\kern0pt}\ x\ {\isasymin}\ t\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ x\ {\isasymin}\ carrier{\isachardoublequoteclose}
 \end{isabelle}
Translate the Isabelle version to a natural language version:
"If  is an open set in a topological space  and , then ."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ topology{\isacharparenright}{\kern0pt}\ Un{\isacharunderscore}{\kern0pt}open\ {\isacharbrackleft}{\kern0pt}intro{\isacharbang}{\kern0pt}{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ abopen{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}A\ open{\isachardoublequoteclose}\ {\isachardoublequoteopen}B\ open{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}A\ {\isasymunion}\ B\ open{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  and  are open sets in a topological space , then  is open."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ topologyI{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}{\isasymlbrakk}{\isasymAnd}\ x\ y{\isachardot}{\kern0pt}\ {\isasymlbrakk}\ is{\isacharunderscore}{\kern0pt}open\ T\ x{\isacharsemicolon}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}open\ T\ y{\isasymrbrakk}\ {\isasymLongrightarrow}\ is{\isacharunderscore}{\kern0pt}open\ T\ {\isacharparenleft}{\kern0pt}x\ {\isasyminter}\ y{\isacharparenright}{\kern0pt}{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ {\isasymAnd}\ M{\isachardot}{\kern0pt}\ {\isasymforall}\ m\ {\isasymin}\ M{\isachardot}{\kern0pt}\ is{\isacharunderscore}{\kern0pt}open\ T\ m\ {\isasymLongrightarrow}\ is{\isacharunderscore}{\kern0pt}open\ T\ {\isacharparenleft}{\kern0pt}{\isasymUnion}\ M{\isacharparenright}{\kern0pt}\isanewline
\ \ \ {\isasymrbrakk}\ {\isasymLongrightarrow}\ topology\ T{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a set and  is closed under finite intersections and arbitrary unions, then  is a topology."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ topobase{\isacharparenright}{\kern0pt}\ topo{\isacharunderscore}{\kern0pt}open{\isacharcolon}{\kern0pt}\isanewline
\ \ {\isachardoublequoteopen}t\ open\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}t\ {\isasymin}\ topo\ B{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to a natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a topological base of a topological space , then  is open if and only if ."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ topobase{\isacharparenright}{\kern0pt}\ topo{\isacharunderscore}{\kern0pt}induct\isanewline
\ \ {\isacharbrackleft}{\kern0pt}case{\isacharunderscore}{\kern0pt}names\ basic\ inter\ union{\isacharcomma}{\kern0pt}\ induct\ set{\isacharcolon}{\kern0pt}\ topo{\isacharcomma}{\kern0pt}\ consumes\ {\isadigit{1}}{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ opn{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}x\ open{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ bas{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}x{\isachardot}{\kern0pt}\ x\ {\isasymin}\ B\ {\isasymLongrightarrow}\ P\ x{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ int{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}x\ y{\isachardot}{\kern0pt}\ {\isasymlbrakk}x\ open{\isacharsemicolon}{\kern0pt}\ P\ x{\isacharsemicolon}{\kern0pt}\ y\ open{\isacharsemicolon}{\kern0pt}\ P\ y{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isacharparenleft}{\kern0pt}x\ {\isasyminter}\ y{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ uni{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}M{\isachardot}{\kern0pt}\ {\isacharparenleft}{\kern0pt}{\isasymforall}t{\isasymin}M{\isachardot}{\kern0pt}\ t\ open\ {\isasymand}\ P\ t{\isacharparenright}{\kern0pt}\ {\isasymLongrightarrow}\ P\ {\isacharparenleft}{\kern0pt}{\isasymUnion}M{\isacharparenright}{\kern0pt}{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}P\ x{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to an natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a topological base of a topological space , then  holds for all open sets  if  holds for all  and  is closed under finite intersections and arbitrary unions."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ subtopologyI{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ S\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ T\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ H{\isadigit{1}}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}s{\isachardot}{\kern0pt}\ s\ open\ {\isasymLongrightarrow}\ {\isasymexists}t{\isachardot}{\kern0pt}\ t\ open\isactrlbsub T\isactrlesub \ {\isasymand}\ s\ {\isacharequal}{\kern0pt}\ t\ {\isasyminter}\ carrier{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ \ \ H{\isadigit{2}}{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}t{\isachardot}{\kern0pt}\ t\ open\isactrlbsub T\isactrlesub \ {\isasymLongrightarrow}\ t\ {\isasyminter}\ carrier\ open{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}subtopology\ S\ T{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to an natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a subset of a topological space  such that for every open set  in , there exists an open set  in  such that  and for every open set  in ,  is open in , then  is a subspace of ."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ {\isacharparenleft}{\kern0pt}\isakeyword{in}\ subtopology{\isacharparenright}{\kern0pt}\ subtopologyE\ {\isacharbrackleft}{\kern0pt}elim{\isacharbrackright}{\kern0pt}{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ major{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}s\ open{\isachardoublequoteclose}\isanewline
\ \ \ \ \isakeyword{and}\ \ \ minor{\isacharcolon}{\kern0pt}\ {\isachardoublequoteopen}{\isasymAnd}t{\isachardot}{\kern0pt}\ {\isasymlbrakk}\ t\ open\isactrlbsub T\isactrlesub {\isacharsemicolon}{\kern0pt}\ s\ {\isacharequal}{\kern0pt}\ t\ {\isasyminter}\ carrier\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ R{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}R{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to an natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is an open set in a topological space , then  is an open set in a subspace  of  if and only if  for some open set  in ."
\end{boxB}






\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ continuousI{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ S\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ T\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{assumes}\ {\isachardoublequoteopen}f\ {\isacharcolon}{\kern0pt}\ carrier\isactrlbsub S\isactrlesub \ {\isasymrightarrow}\ carrier\isactrlbsub T\isactrlesub {\isachardoublequoteclose}\isanewline
\ \ \ \ \ \ \ \ \ \ {\isachardoublequoteopen}{\isasymAnd}m{\isachardot}{\kern0pt}\ m\ open\isactrlbsub T\isactrlesub \ {\isasymLongrightarrow}\ carrier\ {\isasyminter}\ {\isacharparenleft}{\kern0pt}f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ m{\isacharparenright}{\kern0pt}\ open{\isachardoublequoteclose}\isanewline
\ \ \isakeyword{shows}\ {\isachardoublequoteopen}continuous\ f\ S\ T{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to an natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a function from a topological space  to a topological space  such that the preimage of every open set in  is open in , then  is continuous."
\end{boxB}

\begin{boxB}
\begin{isabelle}
\isacommand{lemma}\isamarkupfalse \ continuousE{\isacharcolon}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ S\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{fixes}\ T\ {\isacharparenleft}{\kern0pt}\isakeyword{structure}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{shows}\isanewline
\ \ \ \ {\isachardoublequoteopen}{\isasymlbrakk}continuous\ f\ S\ T{\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ {\isasymlbrakk}f\ {\isacharcolon}{\kern0pt}\ carrier\isactrlbsub S\isactrlesub \ {\isasymrightarrow}\ carrier\isactrlbsub T\isactrlesub {\isacharsemicolon}{\kern0pt}\isanewline
\ \ \ \ \ \ \ \ {\isasymforall}m{\isachardot}{\kern0pt}\ m\ open\isactrlbsub T\isactrlesub \ {\isasymlongrightarrow}\ carrier\isactrlbsub S\isactrlesub \ {\isasyminter}\ {\isacharparenleft}{\kern0pt}f\ {\isacharminus}{\kern0pt}{\isacharbackquote}{\kern0pt}\ m{\isacharparenright}{\kern0pt}\ open\ {\isasymrbrakk}\ {\isasymLongrightarrow}\ P\isanewline
\ \ \ \ \ {\isasymrbrakk}\ {\isasymLongrightarrow}\ P{\isachardoublequoteclose}
\end{isabelle}
Translate the Isabelle version to an natural language version:

\
\hrule
\

\textbf{Codex Output:}

"If  is a limit point of a set  in a topological space , then there exists a filter  such that  and ."
\end{boxB} 
\end{document}
