\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}


\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathmorphing}
\pgfmathsetmacro{\constantx}{1.2}
\pgfmathsetmacro{\constanty}{1.2}
\pgfmathsetmacro{\nodescale}{0.60}
\pgfmathsetmacro{\letterfigsc}{0.75}
\pgfmathsetmacro{\letterscale}{1}


\DeclareMathOperator{\level}{level}

\title{Subsequence Automata with Default Transitions}

\author{Philip Bille \and Inge Li G\o rtz \and Frederik Rye Skjoldjensen}
\date{\small Technical University of Denmark\\ 
  \footnotesize\texttt{\{phbi,inge,fskj\}@dtu.dk}}

\begin{document}
\maketitle
\begin{abstract}
Let  be a string of length  with characters from an alphabet of size . The  \emph{subsequence automaton} of  (often called the \emph{directed acyclic subsequence graph}) is the minimal deterministic finite automaton accepting all subsequences of . A straightforward construction shows that the size (number of states and transitions) of the subsequence automaton is   and that this bound is asymptotically optimal. 

In this paper, we consider subsequence automata with \emph{default transitions}, that is, special transitions to be taken only if none of the regular transitions match the current character, and which do not consume the current character. We show that with default transitions, much smaller subsequence automata are possible, and provide a full trade-off between the size of the automaton and the \emph{delay}, i.e., the maximum number of consecutive default transitions followed before consuming a character. 

Specifically, given any integer parameter , , we present a subsequence automaton with default transitions of size  and delay . Hence, with  we obtain an automaton of size  and delay . On the other extreme, with , we obtain an automaton of size  and delay , thus matching the bound for the standard subsequence automaton construction. Finally, we generalize the result to multiple strings. The key component of our result is a novel hierarchical automata construction of independent interest. 
\end{abstract}



\section{Introduction}

Let  be a string of length  with characters from an alphabet of size . A \emph{subsequence} of  is any string obtained by deleting zero or more characters from . The \emph{subsequence automaton} (often called the \emph{directed acyclic subsequence graph}) is the minimal deterministic finite automaton accepting all subsequences of . Baeza-Yates~\cite{BaezaYates1991} initiated the study of subsequence automata. They presented a simple construction using  size (size denotes the total number of states \emph{and} transitions) and showed that this bound is optimal in the sense that there are subsequence automata of size at least . They also considered variations with encoded input strings and multiple strings. Subsequently, several researchers have further studied subsequence automata (and its variants)~\cite{tronivcek2005size,CMT2003,crochemore1999directed,Tronivcek2001episode,hoshino2000online,farhana2010finite,bannai2003inferring,tronivcek1999operations}. See also the surveys by Tron\'{\i}\v{c}ek~\cite{Tronicek2001,tronicek2003common}. The general problem of \emph{subsequence indexing}, not limited to automata based solutions, is investigated by Bille et al.~\cite{BFC2008}.

In this paper, we consider subsequence automata in the context of \emph{default transitions}, that is, special transitions to be taken only if none of the regular transitions match the current character, and which do not consume the current character. Each state has at most one default transition and hence the automaton remains deterministic. The key point of default transitions is to reduce the size of standard automata at the cost of introducing a \emph{delay}, i.e., the maximum number of consecutive default transition followed before consuming a character. 
For instance, given a pattern string of length  the classic Knuth-Morris-Pratt (KMP)~\cite{KMP1977} string matching algorithm may be viewed as an automaton with default transitions (typically referred to as \emph{failure transitions}). This automaton has size , whereas the standard automaton with no default transitions would need  space.
The delay of the automaton in the KMP algorithm is either  or  depending on the version. 
Similarly, the Aho-Corasick string matching algorithm for multiple strings may also be viewed as an automaton with default transitions~\cite{AC1975}. More recently, default transitions have also been used extensively to significantly reduce sizes of deterministic automata for regular expression~\cite{kumar2006algorithms,hayes2007dpico}. The main idea is to effectively enable states with large overlapping identical sets of outgoing transitions to "share" outgoing transitions using default transitions. 

Surprisingly, no non-trivial bounds for subsequence automata with default transitions are known. Naively\label{lab:naive-single}, we can immediately obtain an  size solution with  delay by using the standard subsequence automaton (without default transitions). At the other extreme, we can build an automaton with  states (each corresponding to a prefix of ) with a standard and a default transition from the state corresponding to the th prefix to the state corresponding to the st prefix (the standard transition is labeled ). It is straightforward to show that this leads to an  size solution with  delay. Our main result is a substantially improved trade-off between the size and delay of the subsequence automaton:

\begin{theorem}
\label{thm:main}
Let  be a string of  characters from an alphabet of size . For any integer parameter , , we can construct a subsequence automaton with default transitions of size  and delay .
\end{theorem}

Hence, with  we obtain an automaton of size  and delay . On the other extreme, with , we obtain an automaton of size  and delay , thus matching the bound for the standard subsequence automaton construction. 

To obtain our result, we first introduce the \emph{level automaton}. Intuitively, this automaton uses the same states as the standard solution, but hierarchically orders them in a tree-like structure and samples a selection of their original transitions based on their position in the tree, and adds a default transition to the next state on a higher level. We show how to do this efficiently leading to a solution with  size and  delay. To achieve our full trade-off from Theorem~\ref{thm:main} we show how to augment the construction with additional ideas for small alphabets and generalize the level automaton with parameter , , where large  reduces the height of the tree but increases the number of transitions. In the final section we generalize the result to \emph{multiple} strings.

\section{Preliminaries}
A \emph{deterministic finite automaton} (DFA) is a tuple  where  is a set of nodes called \emph{states},  is a set of labeled directed edges between states, called \emph{transitions}, where each label is a character from the alphabet ,  is the \emph{initial} state and  is a set of \emph{accepting} states. No two outgoing transitions from the same state have the same label. The DFA is \emph{incomplete} in the sense that every state does not contain transitions for every character in .
 The \emph{size} of  is the sum of the number of states and transitions.

We can think of  as an \emph{edge-labeled directed graph}.
Given a string  and a path  in  we say that  and  match if the concatenation of the labels on the transitions in  is . We say that  \emph{accepts} a string  if there is a path in , from  to any state in , that matches . Otherwise  \emph{rejects} .



A \emph{deterministic finite automaton with default transitions} is a deterministic finite automaton  where each state can have a single unlabeled default transition. Given a string  and a path  in  we define a match between  and  as before, with the exception that for any default transition  in  the corresponding character in  cannot match any standard transition out of the start state of . Definition of accepted and rejected strings are as before. The \emph{delay} of  is the maximum length of any path matching a single character, i.e., if the delay of  is  then we follow at most  default transitions for every character that is matched in .


A \emph{subsequence} of  is a string , obtained by removing zero or more occurrences of characters from . The alphabet of the string  is denoted by .
A \emph{subsequence automaton} constructed from , is a deterministic finite automaton that accepts string  iff  is a subsequence of . A subsequence automaton construction is presented in~\cite{BaezaYates1991}. This construction is often called the \emph{directed acyclic subsequence graph} or DASG, but here we denote it SA.
The SA has  states, all accepting, that we identify with the integers .
For each state , , we have the following transitions:
\begin{itemize}
\item For each character  in , there is a transition labeled  to the smallest state  such that .
\end{itemize}
The SA has size  since every state can have at most  transitions.
An example of an SA is given in Figure~\ref{fig:simpledasg}.
\begin{figure}
\centering
\begin{tikzpicture}
  \draw (-1*\constantx,2*\constanty) node(s0) [circle, draw, scale=\nodescale] {}
        (0*\constantx,2*\constanty) node(s1) [circle, draw, scale=\nodescale] {}
        (1*\constantx,2*\constanty) node(s2) [circle, draw,scale=\nodescale] {}
        (2*\constantx,2*\constanty) node(s3) [circle, draw,scale=\nodescale] {}
        (3*\constantx,2*\constanty) node(s4) [circle, draw,scale=\nodescale] {}
        (4*\constantx,2*\constanty) node(s5) [circle, draw,scale=\nodescale] {}
        (5*\constantx,2*\constanty) node(s6) [circle, draw,scale=\nodescale] {};
  \draw (0*\constantx,0.5*\constanty) node(a1) [scale=\letterscale] {}
        (1*\constantx,0.5*\constanty) node(b2) [scale=\letterscale] {}
        (2*\constantx,0.5*\constanty) node(a3) [scale=\letterscale] {}
        (3*\constantx,0.5*\constanty) node(d4) [scale=\letterscale] {}
        (4*\constantx,0.5*\constanty) node(c5) [scale=\letterscale] {}
        (5*\constantx,0.5*\constanty) node(a6) [scale=\letterscale] {};
  \draw[->] (s0) edge node[above, scale=\letterfigsc] {} (s1);
  \draw[->] (s0) edge[bend right] node[below, scale=\letterfigsc] {} (s2);
  \draw[->] (s0) edge[bend left=60] node[above, scale=\letterfigsc] {} (s5);
  \draw[->] (s0) edge[bend right=50] node[above, scale=\letterfigsc] {} (s4);
  \draw[->] (s1) edge[bend left=60] node[above,scale=\letterfigsc] {} (s3);
  \draw[->] (s1) edge node[above,scale=\letterfigsc] {} (s2);
  \draw[->] (s1) edge[bend right] node[above,scale=\letterfigsc] {} (s5);
  \draw[->] (s1) edge[bend left=90] node[above,scale=\letterfigsc] {} (s4);
  \draw[->] (s2) edge[] node[above,scale=\letterfigsc] {} (s3);
  \draw[->] (s2) edge[bend right] node[above,scale=\letterfigsc] {} (s5);
  \draw[->] (s2) edge[bend left=80] node[above,scale=\letterfigsc] {} (s4);
  \draw[->] (s3) edge[bend left=50] node[above,scale=\letterfigsc] {} (s6);
  \draw[->] (s3) edge[bend right] node[above,scale=\letterfigsc] {} (s5);
  \draw[->] (s3) edge[] node[above,scale=\letterfigsc] {} (s4);
  \draw[->] (s4) edge[bend left] node[above,scale=\letterfigsc] {} (s6);
  \draw[->] (s4) edge[] node[above,scale=\letterfigsc] {} (s5);
  \draw[->] (s5) edge[] node[above,scale=\letterfigsc] {} (s6);
    



  \end{tikzpicture}
\caption{\label{fig:simpledasg} An example of an SA constructed from the string .}
\end{figure}

A \emph{subsequence automaton with default transitions} constructed from , denoted SAD, is a deterministic finite automaton with default transitions that accepts string  iff  is a subsequence of . 

The next section explores different configurations of transitions and default transitions in SADs.















\section{New Trade-Offs for Subsequence Automata.}
We now present a new trade-off for subsequence automata, with default transitions. We will gradually refine our construction until we obtain an automaton that gives the result presented in Theorem~\ref{thm:main}. In each construction we have  states that we identify with the integers . Each of these states represents a prefix of the string  and are all accepting states.
We first present the \emph{level automaton} that gives the first non-trivial trade-off that exploits default transitions. 
The general idea is to construct a hierarchy of states, such that every path that only uses default transitions is guaranteed to go through states where the outdegree increases at least exponentially.
The level automaton is a SAD of size  and delay . 
By arguing that any path going through a state with outdegree  will do so by taking a regular transition, we are able to improve both the size and delay of the level automaton. 
This results in the \emph{alphabet-aware level automaton} which is a SAD of size  and delay . Finally we present a generalized  construction that gives a trade-off between size and delay by letting parameter , , be the base of the exponential increase in outdegree on paths with only default transitions. This SAD has size  and delay . With  we get an automaton of size  and delay . In the other extreme, for  we get an automaton of size  and delay .
\subsection{Level Automaton}
The level automaton is a SAD with  states that we identify with the integers . All states are accepting. For each state , we associate a level, , given by:


Hence,  is the exponent of the largest power of two that divides . The level function is in the literature known as the ruler function. 
We do not associate any level with state 0. Note that the maximum level of any state is .
For a nonnegative integer , we define  to be the smallest integer  such that . 

The transitions in the level automaton are as follows:
From state 0 we have a default transition to state 1 and a regular transition to state 1 with label . For every other state , , we have the following transitions:
\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item For each character  in , there is a transition labeled  to the smallest state  such that .
\end{itemize}
An example of the level automaton constructed from the string  and alphabet  is given in Figure~\ref{fig:levelautomaton}. The dashed arrows denote default transitions and the vertical position of the states denotes their level.
\begin{figure}
\centering
\begin{tikzpicture}
  \draw (-1*\constantx,2*\constanty) node(s0) [circle, draw, scale=\nodescale] {}
        (0*\constantx,2*\constanty) node(s1) [circle, draw, scale=\nodescale] {}
        (1*\constantx,3*\constanty) node(s2) [circle, draw,scale=\nodescale] {}
        (2*\constantx,2*\constanty) node(s3) [circle, draw,scale=\nodescale] {}
        (3*\constantx,4*\constanty) node(s4) [circle, draw,scale=\nodescale] {}
        (4*\constantx,2*\constanty) node(s5) [circle, draw,scale=\nodescale] {}
        (5*\constantx,3*\constanty) node(s6) [circle, draw,scale=\nodescale] {}
        (6*\constantx,2*\constanty) node(s7) [circle, draw, scale=\nodescale] {}
        (7*\constantx,5*\constanty) node(s8) [circle, draw,scale=\nodescale] {}
        (8*\constantx,2*\constanty) node(s9) [circle, draw,scale=\nodescale] {}
        (9*\constantx,3*\constanty) node(s10) [circle, draw,scale=\nodescale] {}
        (10*\constantx,2*\constanty) node(s11) [circle, draw,scale=\nodescale] {}
        (11*\constantx,4*\constanty) node(s12) [circle, draw,scale=\nodescale] {};
  \draw (0*\constantx,1*\constanty) node(a1) [scale=\letterscale] {}
        (1*\constantx,1*\constanty) node(b2) [scale=\letterscale] {}
        (2*\constantx,1*\constanty) node(a3) [scale=\letterscale] {}
        (3*\constantx,1*\constanty) node(d4) [scale=\letterscale] {}
        (4*\constantx,1*\constanty) node(c5) [scale=\letterscale] {}
        (5*\constantx,1*\constanty) node(a6) [scale=\letterscale] {}
        (6*\constantx,1*\constanty) node(b2) [scale=\letterscale] {}
        (7*\constantx,1*\constanty) node(a3) [scale=\letterscale] {}
        (8*\constantx,1*\constanty) node(d4) [scale=\letterscale] {}
        (9*\constantx,1*\constanty) node(c5) [scale=\letterscale] {}
        (10*\constantx,1*\constanty) node(a6) [scale=\letterscale] {}
        (11*\constantx,1*\constanty) node(c5) [scale=\letterscale] {};
        
  \draw[->] (s0) edge node[above, scale=\letterfigsc] {} (s1);
  \draw[->] (s0) edge[bend right=15,style=dashed] node[below, scale=\letterfigsc] {} (s1);
  \draw[->] (s1) edge[] node[right, scale=\letterfigsc] {} (s2);
  \draw[->] (s1) edge[bend left=15,style=dashed] node[above, scale=\letterfigsc] {} (s2);
  \draw[->] (s2) edge[] node[right,scale=\letterfigsc] {} (s3);
  \draw[->] (s2) edge node[above,scale=\letterfigsc] {} (s4);
  \draw[->] (s2) edge[bend left,style=dashed] node[above,scale=\letterfigsc] {} (s4);
  
  \draw[->] (s3) edge[] node[right,scale=\letterfigsc] {} (s4);
  \draw[->] (s3) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s4);

  \draw[->] (s4) edge[] node[right,scale=\letterfigsc] {} (s5);
  \draw[->] (s4) edge[] node[above,scale=\letterfigsc] {} (s6);
  \draw[->] (s4) edge[] node[above,scale=\letterfigsc] {} (s8);
  \draw[->] (s4) edge[style=dashed,bend left=15] node[above,scale=\letterfigsc] {} (s8);

  \draw[->] (s5) edge[] node[below,scale=\letterfigsc] {} (s6);
  \draw[->] (s5) edge[bend left=15, style=dashed] node[above,scale=\letterfigsc] {} (s6);

  \draw[->] (s6) edge[] node[above,scale=\letterfigsc] {} (s7);
  \draw[->] (s6) edge[] node[left,scale=\letterfigsc] {} (s8);
  \draw[->] (s6) edge[style=dashed,bend left=15] node[above,scale=\letterfigsc] {} (s8);
  
  \draw[->] (s7) edge[] node[right,scale=\letterfigsc] {} (s8);
  \draw[->] (s7) edge[style=dashed,bend left=15] node[above,scale=\letterfigsc] {} (s8);

  \draw[->] (s8) edge[] node[right,scale=\letterfigsc] {} (s9);
  \draw[->] (s8) edge[] node[right,scale=\letterfigsc] {} (s10);
  \draw[->] (s8) edge[] node[above,scale=\letterfigsc] {} (s12);

  \draw[->] (s9) edge[] node[right,scale=\letterfigsc] {} (s10);
  \draw[->] (s9) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s10);

  \draw[->] (s10) edge[] node[above,scale=\letterfigsc] {} (s11);
  \draw[->] (s10) edge[] node[below,scale=\letterfigsc] {} (s12);
  \draw[->] (s10) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s12);

  \draw[->] (s11) edge[] node[right,scale=\letterfigsc] {} (s12);
  \draw[->] (s11) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s12);






  \end{tikzpicture}
\caption{\label{fig:levelautomaton}The level automaton constructed from the string .}
\end{figure}







We first show that the level automaton is a SAD for , i.e., the level automaton accepts a string iff the string is a subsequence of . To do so suppose that  is a string of length  accepted by the level automaton and let  be the sequence of states visited with regular transitions on the path that accepts . From the definition of the transition function, we know that if a transition with label  leads to state , then . This means that  spells out a subsequence of  if the sequence  is strictly increasing. From the definition of the transitions, a state  only have transitions to states  if . Hence, the sequence is strictly increasing.

For the other direction, we show that the level automaton simulates the SA. At each state , trying to match character , we find the smallest state  such that  has an incoming transition with label : By the construction, either  has an outgoing transition leading directly to  \emph{or} we follow default transitions until reaching the first state with a transition to . This means that the states visited with standard transitions in the level automaton are the same states that are visited in the SA. Since the SA accepts all subsequences of  this must also hold for the level automaton.












\subsubsection{Analysis}
The following shows that the number of outgoing transitions increase with a factor two when the level increase by one.
For all , we have the following property of  and :

By definition,  divides . This means that we can write  as  , where  is a uneven positive integer. We know that  is uneven because  is the largest power of two that divides . The next integer, larger than , that  divides is . This means that . We can rewrite  as follows: . Since  is uneven we know that  is even so we can rewrite  further: . This shows that  divides  which means that  and we conclude that .

Since the maximal level of any state is  and the level increase every time we follow a default transition, the delay of the level automaton is .







At each level  we have  states, since every th state is divided by , and  is the largest divisor in every second of these cases. Since  each state at level  has at most  outgoing transitions. Therefore, each level contribute with size at most . Since we have at most  levels, the total size becomes .

In summary, we have shown the following result.
\begin{lemma}\label{lemma:levelaut}
Let  be a string of  characters. We can construct a subsequence automaton with default transitions of size  and delay .
\end{lemma}




\subsection{Alphabet-aware level automaton}
We introduce the \emph{Alphabet-aware level automaton}. When the level automaton reaches a state  where , then  can have up to  outgoing transitions without violating the space analysis above. The level automaton only has a transition for each character in . Hence, for all states  in the alphabet-aware level automaton where , we let  have a transition for each symbol  in , to the smallest state  such that . No matching path can take a default transition from a state with  outgoing transitions. Hence, states with  outgoing transitions do not need default transitions.

We change the level function to reflect this. For each state  we have that:



The transitions in the alphabet-aware level automaton is as follows:
From state 0 we have a default transition to state 1 and a regular transition to state 1 with label .
For every other state , , we have the following transitions:
\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item If  then for each character  in , there is a transition labeled  to the smallest state  such that .
\item If  then for each character  in , there is a transition labeled  to the smallest state  such that .
\end{itemize}

An example of the alphabet-aware level automaton constructed from the string  and alphabet  is given in Figure~\ref{fig:alphalevelautomaton}. The level automaton in Figure~\ref{fig:levelautomaton} is constructed from the same string and the same alphabet. For comparison, state 4 in Figure~\ref{fig:alphalevelautomaton} now has outdegree  and has transitions to the first succeeding occurrence of any unique character and state 8 has been constrained to level .

\begin{figure}
\centering
\begin{tikzpicture}
  \draw (-1*\constantx,2*\constanty) node(s0) [circle, draw, scale=\nodescale] {}
        (0*\constantx,2*\constanty) node(s1) [circle, draw, scale=\nodescale] {}
        (1*\constantx,3*\constanty) node(s2) [circle, draw,scale=\nodescale] {}
        (2*\constantx,2*\constanty) node(s3) [circle, draw,scale=\nodescale] {}
        (3*\constantx,4*\constanty) node(s4) [circle, draw,scale=\nodescale] {}
        (4*\constantx,2*\constanty) node(s5) [circle, draw,scale=\nodescale] {}
        (5*\constantx,3*\constanty) node(s6) [circle, draw,scale=\nodescale] {}
        (6*\constantx,2*\constanty) node(s7) [circle, draw, scale=\nodescale] {}
        (7*\constantx,4*\constanty) node(s8) [circle, draw,scale=\nodescale] {}
        (8*\constantx,2*\constanty) node(s9) [circle, draw,scale=\nodescale] {}
        (9*\constantx,3*\constanty) node(s10) [circle, draw,scale=\nodescale] {}
        (10*\constantx,2*\constanty) node(s11) [circle, draw,scale=\nodescale] {}
        (11*\constantx,4*\constanty) node(s12) [circle, draw,scale=\nodescale] {};
  \draw (0*\constantx,1*\constanty) node(a1) [scale=\letterscale] {}
        (1*\constantx,1*\constanty) node(b2) [scale=\letterscale] {}
        (2*\constantx,1*\constanty) node(a3) [scale=\letterscale] {}
        (3*\constantx,1*\constanty) node(d4) [scale=\letterscale] {}
        (4*\constantx,1*\constanty) node(c5) [scale=\letterscale] {}
        (5*\constantx,1*\constanty) node(a6) [scale=\letterscale] {}
        (6*\constantx,1*\constanty) node(b2) [scale=\letterscale] {}
        (7*\constantx,1*\constanty) node(a3) [scale=\letterscale] {}
        (8*\constantx,1*\constanty) node(d4) [scale=\letterscale] {}
        (9*\constantx,1*\constanty) node(c5) [scale=\letterscale] {}
        (10*\constantx,1*\constanty) node(a6) [scale=\letterscale] {}
        (11*\constantx,1*\constanty) node(c5) [scale=\letterscale] {};
        
  \draw[->] (s0) edge node[above, scale=\letterfigsc] {} (s1);
  \draw[->] (s0) edge[bend right=15,style=dashed] node[below, scale=\letterfigsc] {} (s1);
  \draw[->] (s1) edge[] node[right, scale=\letterfigsc] {} (s2);
  \draw[->] (s1) edge[bend left=15,style=dashed] node[above, scale=\letterfigsc] {} (s2);
  \draw[->] (s2) edge[] node[right,scale=\letterfigsc] {} (s3);
  \draw[->] (s2) edge node[above,scale=\letterfigsc] {} (s4);
  \draw[->] (s2) edge[bend left,style=dashed] node[above,scale=\letterfigsc] {} (s4);
  
  \draw[->] (s3) edge[] node[right,scale=\letterfigsc] {} (s4);
  \draw[->] (s3) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s4);

  \draw[->] (s4) edge[] node[right,scale=\letterfigsc] {} (s5);
  \draw[->] (s4) edge[] node[above,scale=\letterfigsc] {} (s6);
  \draw[->] (s4) edge[] node[above,scale=\letterfigsc] {} (s8);
  \draw[->] (s4) edge[bend left] node[above,scale=\letterfigsc] {} (s12);

  \draw[->] (s5) edge[] node[below,scale=\letterfigsc] {} (s6);
  \draw[->] (s5) edge[bend left=15, style=dashed] node[above,scale=\letterfigsc] {} (s6);

  \draw[->] (s6) edge[] node[above,scale=\letterfigsc] {} (s7);
  \draw[->] (s6) edge[] node[left,scale=\letterfigsc] {} (s8);
  \draw[->] (s6) edge[style=dashed,bend left=15] node[above,scale=\letterfigsc] {} (s8);
  
  \draw[->] (s7) edge[] node[right,scale=\letterfigsc] {} (s8);
  \draw[->] (s7) edge[style=dashed,bend left=15] node[above,scale=\letterfigsc] {} (s8);

  \draw[->] (s8) edge[] node[right,scale=\letterfigsc] {} (s9);
  \draw[->] (s8) edge[] node[above,scale=\letterfigsc] {} (s10);
  \draw[->] (s8) edge[] node[above,scale=\letterfigsc] {} (s12);

  \draw[->] (s9) edge[] node[right,scale=\letterfigsc] {} (s10);
  \draw[->] (s9) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s10);

  \draw[->] (s10) edge[] node[above,scale=\letterfigsc] {} (s11);
  \draw[->] (s10) edge[] node[below,scale=\letterfigsc] {} (s12);
  \draw[->] (s10) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s12);

  \draw[->] (s11) edge[] node[right,scale=\letterfigsc] {} (s12);
  \draw[->] (s11) edge[bend left=15,style=dashed] node[above,scale=\letterfigsc] {} (s12);






  \end{tikzpicture}
\caption{\label{fig:alphalevelautomaton}The alphabet level automaton constructed from the string .}
\end{figure}


The alphabet-aware level automaton is a SAD by the same arguments that led to Lemma~\ref{lemma:levelaut}.




The delay is now bounded by  since no state is assigned a level higher than .
The size of each level is still . Hence, the total size becomes 

In summary, we have shown the following result.
\begin{lemma}\label{lemma:alphalevel}
  Let  be a string of  characters. We can construct a SAD of  with size  and delay .
\end{lemma}




\subsection{Full trade-off}
We can generalize the construction above by introducing parameter , , which is the base of the exponential increase in outdegree of states on every path that only uses default transitions. Now, when we follow a default transition from  to , the number of outgoing transitions increase with a factor  instead of a factor 2.
This gives a trade-off between size and delay in the SAD determined by . Increasing  gives a shorter delay of the SAD but increases the size and vice versa.

Each state, except state 0, is still associated with a level, but we need to generalize the level function to account for the parameter .
For every  and  we have that:


Now, the level function gives the largest power of  that divides . 










The transitions in the generalized alphabet-aware level automaton is as follows:
From state 0 we have a default transition to state 1 and a regular transition to state 1 with label .
For every other state , , we have the following transitions:
\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item If  then for each character  in , there is a transition labeled  to the smallest state  such that .
\item If  then for each character  in , there is a transition labeled  to the smallest state  such that .
\end{itemize}

We can show that the generalized alphabet-aware level automaton is a SAD by the same arguments that led to Lemma~\ref{lemma:alphalevel}.
\subsubsection{Analysis}
The delay is bounded by  because no state is assigned a level higher than .

With the new definition of the level function we have that 

for all .
This expression bounds the number of outgoing transitions from state .


At level  we have  states each with  outgoing transitions such that each level has size . The size of the automaton becomes  because we have  levels.

In summary, we have shown Theorem~\ref{thm:main}.





    
    
\section{Subsequence automata for multiple strings}







Tron\'{\i}\v{c}ek et al.~\cite{CMT2003} generalizes the simple subsequence automaton to multiple strings. Given a set of strings  of length , two types of automata are presented: The subsequence automaton accepts a pattern  iff  is a subsequence of \emph{some} string in  and the \emph{common} subsequence automaton accepts  iff  is a subsequence of \emph{every} string in . When  and , a  lower bound on the number of states is shown for the subsequence automaton~\cite{tronivcek2005size}. For both automata, the number of states is trivially upper bounded by  such that the total size becomes . We can reduce the size of these automata by augmenting them with default transitions. This generalization is in the same spirit as the naive generalization of the single string automaton in section \ref{lab:naive-single}: We introduce default transitions and save a factor  in the space but also introduce a delay. Consider the naive common subsequence automaton with default transitions: For two strings  we have  states that we identify with the points . For each state  we have the following transitions:

\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item If character  is in , there is a transition labeled  to the state  such that  is the minimal index where .
\item If character  is in , there is a transition labeled  to the state  such that  is the minimal index where .
\end{itemize}

The states of the automaton represents the progression in  and , such that state  represents that subsequences of the prefixes  and  have been used to match a prefix of . Each state  considers the symbols  and  for matching with the next symbol in . If this is not possible, a default transition is followed to state .

For this automaton the size is  and the delay is . Hence, we save a  factor in the size, but introduce a significant delay. As we did for the subsequence automaton for a single string, we introduce a level automaton that associates a level with each state. In this way we are able to reduce the delay significantly with only a small increase in size. For simplicity we only present our construction for the common subsequence automaton, but it follows immediately that the construction also applies to the subsequence automaton.

\subsection{The alphabet-aware level automaton for two strings}
The alphabet-aware level automaton for two strings  have  states that we identify with the points . We define the \emph{diagonal} of a state , as the set of states . We say that states belong to the same diagonal if the diagonals of the states defines identical sets of states. For states  in the same diagonal,  if . For each state  we associates the integer , which is also its position in the diagonal, such that  and . With each diagonal of states, we associate a level structure identical to the one used in the alphabet-aware level automaton for a single string.  Now, when following a default transition from state  to , , every unique symbol in  contributes with a transition.
For each state , , we again associate a level:




For a pair of positive integers , we define  to be the smallest pair of integers in the same diagonal such that .

The alphabet-aware level automaton for two strings  has the following transitions: State  has a transition labeled  to state  where  is the minimal index such that , a transition labeled  to state  where  is the minimal index such that  and a default transition to state .  These transitions only exists if the indices exists. Every other state state , where , have the following transitions:
\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item If  then for each character  in , there is a transition labeled  to the state , where  and  are the minimal indices such that .
\item If  then for each character  in , there is a transition labeled  to the state , where  and  are the minimal indices such that .
\end{itemize}

An example of an incomplete common subsequence automaton for two strings is given in Figure~\ref{fig:simple2d}.
\begin{figure}
\centering
\begin{tikzpicture}
  \draw (0*\constantx,0*\constanty) node(s0) [circle, draw, scale=\nodescale] {}
        (1*\constantx,-1*\constanty) node(s1) [circle, draw, scale=\nodescale] {}
        (1*\constantx,-3*\constanty) node(s2) [circle, draw,scale=\nodescale] {}
        (4*\constantx,-1*\constanty) node(s3) [circle, draw,scale=\nodescale] {}
        (4*\constantx,-3*\constanty) node(s4) [circle, draw,scale=\nodescale] {}
        (8*\constantx,-4*\constanty) node(s5) [circle, draw,scale=\nodescale] {}
        (5*\constantx,-7*\constanty) node(s6) [circle, draw,scale=\nodescale] {}
        (6*\constantx,-5*\constanty) node(s8) [circle, draw,scale=\nodescale] {};
  \draw (1*\constantx,0*\constanty) node(a1) [scale=\letterscale] {}
        (4*\constantx,0*\constanty) node(d4) [scale=\letterscale] {}
        (5*\constantx,0*\constanty) node(c5) [scale=\letterscale] {}
        (6*\constantx,0*\constanty) node(a6) [scale=\letterscale] {}
        (8*\constantx,0*\constanty) node(c5) [scale=\letterscale] {};
  \draw (1*\constantx,0.5*\constanty) node(c1) [scale=\letterfigsc] {}
        (4*\constantx,0.5*\constanty) node(c2) [scale=\letterfigsc] {}
        (5*\constantx,0.5*\constanty) node(i3) [scale=\letterfigsc] {}
        (6*\constantx,0.5*\constanty) node(i4) [scale=\letterfigsc] {}
        (8*\constantx,0.5*\constanty) node(i5) [scale=\letterfigsc] {};
  \draw (-0.6*\constantx,-1*\constanty) node(j1) [scale=\letterfigsc] {}
        (-0.6*\constantx,-3*\constanty) node(j2) [scale=\letterfigsc] {}
        (-0.6*\constantx,-4*\constanty) node(j3) [scale=\letterfigsc] {}
        (-0.6*\constantx,-5*\constanty) node(j4) [scale=\letterfigsc] {}
        (-0.6*\constantx,-7*\constanty) node(j5) [scale=\letterfigsc] {};

 \draw (0*\constantx,-1*\constanty) node(a1) [scale=\letterscale] {}
        (0*\constantx,-3*\constanty) node(d4) [scale=\letterscale] {}
        (0*\constantx,-4*\constanty) node(c5) [scale=\letterscale] {}
        (0*\constantx,-5*\constanty) node(a6) [scale=\letterscale] {}
        (0*\constantx,-7*\constanty) node(c5) [scale=\letterscale] {};

\draw  {(1.5*\constantx,0*\constanty) -- (3.5*\constantx,0*\constanty)};
\draw  {(6.5*\constantx,0*\constanty) -- (7.5*\constantx,0*\constanty)};
\draw  {(0*\constantx,-1.5*\constanty) -- (0*\constantx,-2.5*\constanty)};
\draw  {(0*\constantx,-5.5*\constanty) -- (0*\constantx,-6.5*\constanty)};

  \draw[->] (s0) edge[bend right=15] node[above, scale=\letterfigsc] {} (s3);
  \draw[->] (s0) edge[bend left=15] node[right, scale=\letterfigsc] {} (s2);
  \draw[->] (s0) edge[style=dashed] node[below, scale=\letterfigsc] {} (s1);

  \draw[->] (s4) edge node[above, scale=\letterfigsc] {} (s5);
  \draw[->] (s4) edge node[right, scale=\letterfigsc] {} (s6);
  \draw[->] (s4) edge[bend right=15,style=dashed] node[below, scale=\letterfigsc] {} (s8);
  \draw[->] (s4) edge[bend left=15] node[above, scale=\letterfigsc] {} (s8);







  \end{tikzpicture}
\caption{\label{fig:simple2d} An incomplete common subsequence automaton for two strings , laid out in a two-dimensional grid. State  has a transition labeled  to state  and a transition labeled  to state . State  is at level 1 and has a transition for each unique character in . Transitions out of the remaining states are missing from the illustration.}
\end{figure}

\subsubsection{Analysis}

For every pair of positive integers , we have the following property:

This property follows from the same argument that led to equation (\ref{sec:overlinesminuss}). The number of transitions out of every state , is now bounded by  since both  and  can contribute with up to  transitions.

We can calculate the size of the alphabet-aware level automaton for two strings by summing up the space contribution from each diagonal of states. Let  be a diagonal consisting of  states. Then the size of  is , since each diagonal has the size of an alphabet-aware level automaton for one string. If  is the set of all diagonals, then the total size of the automaton becomes

The last step is possible since the sum over the states in all diagonals is exactly the number of states in the automaton. In summary we have shown the following result:

\begin{lemma}
Let  be strings of length  and  over an alphabet of size . We can construct a subsequence automaton and a common subsequence automaton with default transitions of size  and delay .
\end{lemma}

\subsection{The alphabet-aware level automaton for multiple strings}
The alphabet-aware level automaton for the set of strings  have  states that we identify with the set of integer points . Hence, a state in the automaton corresponds to a tuple with  elements . We generalize the definition of diagonals for dimension  as follows. The diagonal of a state  is the set of states:

Again, states belong to the same diagonal if the diagonal of each state defines identical sets of states, and for states , in the same diagonal,  if . For each state  we associate the integer  and define subtraction and modulo operations on states as in the previous section.

With each state we again associate the level:


For a tuple of positive integers , we define  to be the smallest tuple of integers in the same diagonal such that .


The alphabet-aware level automaton for multiple strings, , has the following transitions: State  has a transition labeled  to state  where , such that  is the minimal index where , for every  and  and a default transition to state .
Every other state , where , has the following transitions:
\begin{itemize}
\item A default transition to state . If no such state exist, the state  does not have a default transition.
\item If  then for each character  in   there is a transition labeled  to the state , where,  is the minimal index such that , for all 
\item If  then for each character  in  there is a transition labeled  to the state , where  is the minimal index such that , for all .
\end{itemize}

\subsubsection{Analysis}
For each state  we have that 


The number of transitions out of every state , is now bounded by  because each of the  strings can contribute with up to  transitions.

 We can calculate the size of the alphabet-aware level automaton for  strings by summing up the space contribution from each diagonal of states. Let  be a diagonal consisting of  states. Then the size of  is . If  is the set of all diagonals, then the total size of the automaton becomes

The last step is possible since the sum over the states in all diagonals is the number of states in the automaton. In summary we have shown the following result:
\begin{theorem}
Let  be a set of strings of length  over an alphabet of size . We can construct a subsequence automaton and a common subsequence automaton with default transitions of size  and delay .
\end{theorem}
















\bibliographystyle{splncs}
\bibliography{references}

\end{document}
