\documentclass[11pt]{amsart}
\usepackage[margin=1in]{geometry}

\usepackage{graphicx}
\usepackage{amsfonts,amsmath,amssymb,multirow}
\usepackage{multirow}
\usepackage[usenames, dvipsnames]{color}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\bx}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\bE}{\ensuremath{\mathbf{E}}}
\newcommand{\bP}{\ensuremath{\mathbf{P}}}
\newcommand{\rv}{\ensuremath{\text{rv}}\xspace}
\newcommand{\bV}{\ensuremath{\mathbf{V}}\xspace}
\newcommand{\perk}{\texttt{PErK}\xspace}
\newcommand{\pctext}[2]{\text{\parbox{#1}{\centering #2}}}
\newcommand{\polylog}{\operatorname{polylog}}
\newcommand{\ID}{\operatorname{ID}}
\newcommand{\poly}{\operatorname{poly}}

\newcommand{\rank}{\operatorname{Rank}}

\newenvironment{oneshot}[1]{\@begintheorem{#1}{\unskip}}{\@endtheorem}


\newcommand{\pal}{\operatorname{Pal}}
\newcommand{\extd}{\ensuremath{{\overline{d}}}}

\newcommand{\INDSTATE}[1][1]{\STATE\hspace{#1\algorithmicindent}}


\begin{document}


\author[David G. Harris and Johannes Schneider and Hsin-Hao Su]{
{\sc David G.~Harris}
\and
{\sc Johannes Schneider}
\and
{\sc Hsin-Hao Su}
}

\setcounter{footnote}{0}


\addtocounter{footnote}{1}
\footnotetext{This is an extended version of a paper which appeared in the 2016 Symposium on Theory of Computing (STOC)}

\addtocounter{footnote}{1}
\footnotetext{Department of Computer Science, University of Maryland,
College Park, MD 20742.
Research supported in part by NSF Awards CNS-1010789 and CCF-1422569.
Email: \texttt{davidgharris29@gmail.com}.}

\addtocounter{footnote}{1}
\footnotetext{University of Liechtenstein, Vaduz, Liechtenstein. Email: \texttt{johannes.schneider@uni.li}.}

\addtocounter{footnote}{1}
\footnotetext{University of North Carolina at Charlotte. Part of the work was done while at MIT and University of Michigan, supported by NSF Awards CCF-0939370, CCF-1217338, BIO-1455983, and AFOSR FA9550-13-1-0042. Email: \texttt{hsinhaosu@uncc.edu}.}

\title{Distributed -Coloring in Sublogarithmic Rounds}



\maketitle
\section*{Abstract} \label{sec:Abstract}
\noindent
 We give a new randomized distributed algorithm for -coloring in the LOCAL model, running in  rounds in a graph of maximum degree~. This implies that the -coloring problem is easier than the maximal independent set problem and the maximal matching problem, due to their lower bounds of  by Kuhn, Moscibroda, and Wattenhofer [PODC'04]. Our algorithm also extends to list-coloring where the palette of each node contains  colors. We extend the set of distributed symmetry-breaking techniques by performing a decomposition of graphs into dense and sparse parts.



\bigskip

\noindent Categories and Subject Descriptors: G.2.2 \textbf{[Graph Theory]}: Graph Algorithms; F.2.2 \textbf{[Nonnumerical Al-
gorithms and Problems]}: Computations on Discrete Structures

\medskip

\noindent General Terms: Algorithms, Theory

\medskip

\noindent Additional Key Words and Phrases: Distributed Networks, Vertex Coloring


\section{Introduction} \label{sec:Intro}
Given a graph , let~ denote the number of vertices and let~ denote the maximum degree. The -coloring problem is to assign each vertex~ a color~ such that no two neighbors are assigned the same color.

In this paper, we study the -coloring problem in the distributed  model. In this model, vertices host processors and operate in synchronized rounds. In each round, each vertex sends a message of arbitrary size to each of its neighbors, receives messages from its neighbors, and performs (unbounded) local computations. The time complexity of an algorithm is measured by the number of rounds until every vertex commits its output -- in our case, its color. The  model is a model for investigating what {\it local information is needed for each vertex to compute its own output}. An -round algorithm in the  model implies that each vertex only uses information in its -neighborhood to compute the output, and vice versa. 

Graph coloring is one of the central problems of graph theory, with numerous applications to algorithms and combinatorics. The  -coloring problem is the most celebrated case, because for every graph there exists a  coloring, which can be found via a simple (sequential) greedy algorithm. Furthermore, even if -colorings exist for some graphs, there are examples where it cannot be solved locally; for example, 2-coloring a ring requires  rounds. 

Vertex-coloring in the distributed model, in particular, has applications as a subroutine in other distributed algorithms (for example, the Lov\'{a}sz Local Lemma \cite{fischer2017sublogarithmic}) and scheduling problems (for example, radio network broadcasts~\cite{CK85, CS89, RP89, ET90}). It is typical in such applications that solution quality depends on the number of colors used. Thus -coloring is a natural problem, as it leads to the optimal schedules that one can hope to guarantee as a function of .

\subsection{Previous results on distributed graph coloring}
The distributed coloring problem, and variants, have a long history dating back to the 1980's. Table \ref{ResultsOverview} summarizes the results for the most prominent coloring problem, i.e. -coloring. Several deterministic algorithms have been developed with a run-time of  ~\cite{bar15a, BEK09,Kuhn2006On,linial92,GPS88,GP87}.  The latter term is necessary as 3-coloring a ring require~ rounds for both deterministic and randomized algorithms \cite{linial92, Noar91}.  A breakthrough by Barenboim~\cite{bar15a} gave an algorithm running in  rounds, subsequently improved to  by Fraigniaud et al.~\cite{FraigniaudHK15}. These bounds have a sublinear dependence on~, which is notable since~ lower bounds hold for related problems in more restrictive settings~\cite{ goo14, hef16, hir12, Kuhn2006On, SV93}.

The randomized algorithms considered in this paper are those which return a correct answer w.h.p.~({\it with high probability}, which is with probability at least~, where~ is an arbitrary constant~.) Randomized approaches can be traced back to the  rounds maximal independent set (MIS) algorithm of Alon, Babai, and Itai~\cite{alon86} and Luby~\cite{lub86}. The  upper bound lasted until Schneider and Wattenhofer gave an algorithm of running time~  \cite{Sch10}. Then, Barenboim et al.~\cite{BEPS16} improved the dependence on  to . All these algorithms require  rounds when  for some constant . 

\subsection{Our contributions.} We give a randomized algorithm running in time~ rounds w.h.p., which is the first algorithm that runs in  rounds for every graph. Moreover, this implies a separation between the -coloring and the MIS problem. We elaborate our contributions in the following:

\begin{table*}
\centering
\begin{tabular}{|l | l r |l r | }    \hline
   Bounds  & Randomized & & Deterministic &\\ \hline
    \multirow{ 8}{*}{Upper} &  & [This paper]  &  & \cite{FraigniaudHK15}  \\ \cline{2-5}& & \cite{BEPS16} &  & \cite{bar15a}  \\ \cline{2-5}&  &\cite{Sch10}  &   & \cite{BEK09}  \\ \cline{2-5}& & \cite{lub86,alon86,Joh99} &    & \cite{Kuhn2006On} \\ \cline{2-5}& & &  & \cite{linial92, GPS88} \\ \cline{4-5}
    & & &  & \cite{GPS88} \\ \cline{4-5}& & &   & \cite{GP87} \\ \cline{4-5}&  &    &  & \cite{panc92}   \\ \hline
    \hline
    Lower&  & \cite{Noar91} &  & \cite{linial92}   \\ \hline
  \end{tabular}
\caption{Comparison of -coloring algorithms and lower bounds} \label{ResultsOverview}
\vspace{-5mm}
\end{table*}



\begin{enumerate}
\item {\bf Separation between the coloring problem and the MIS problem.}  The coloring problem and the MIS problem are closely related; for example, given a -coloring one can compute a MIS in  rounds by letting a node with color~ join the MIS in round~ (if no neighbor joined previously). Conversely, Lov\'{a}sz describes how any MIS algorithm can be used for -coloring in the same running time by simulating it on a blow-up graph \cite{lov79} (this result has also been mentioned in \cite{lub86} and \cite{alon86}). Kuhn, Moscibroda, and Wattenhofer \cite{kuh10} constructed a family of graphs with  for which computing an MIS or a maximal matching requires at least~ rounds. To this date, it has been unclear whether -coloring,  MIS and maximal matching are equally hard problems.

As our algorithm computes -colorings in the above graphs in  rounds, we show that -coloring is an easier problem.

\item {\bf Breaking the  barrier.} From a technical perspective, the {\it union bound barrier} for randomized distributed algorithms was observed in \cite{bar15}. Roughly speaking, randomized algorithms generally conduct a series of trials at each vertex. When the trial at a vertex succeeds for the first time, then it commits its output. If the failure probability of each trial is at least~, then it takes  trials to ensure a vertex succeed with probability at least~ for~.  However, since we require all the nodes to correctly output their answers at the end of the algorithm,  has to be bounded by  in order to take the union bound over every vertex. Therefore, many randomized algorithms require at least~ rounds. 
	
Barenboim et al.~\cite{bar15a} used the {\it graph shattering technique} to circumvent the union bound barrier. The basic idea is to run the experiments for~ rounds so that the probability each vertex failed is at most~ after this first phase. The size of each connected component in the graph induced by unsuccessful vertices then becomes . Then, one may run a deterministic algorithm on each component in parallel in the second phase. The running time of Panconesi and Srinivasan's deterministic algorithm is~ on graphs of size ~\cite{panc92}. Since the size of the component is exponentially smaller than the original graph, the running time scales down correspondingly to be~. 
	
The graph shattering technique does not directly apply to -coloring, since every algorithm up to this date has had a failure probability per round (and node) lower-bounded by constants. To appreciate the difficulty of achieving sub-constant failure probability, consider the following natural approach to the -coloring problem: each vertex selects a color randomly and commits to the color if no neighbors has selected the same color. If the graph contains a clique of size , then the probability that a vertex in the clique successfully colors itself is . (The MIS problem is even harder, and it was only recently shown by \cite{Moh16} how to achieve {\it amortized} constant  failure probability in ~rounds.)

To break the  barrier, we introduce novel ideas to address symmetry-breaking problems. We develop a network decomposition that splits a graph into sparse and dense parts and tackles them separately. The key is that vertices boost their probability of getting colored by using either the properties of dense parts or those of sparse parts (see Section \ref{sec:technical}). Our algorithm does not directly use graph shattering, although we use a number of previous algorithms as subroutines which do use this technique.
\end{enumerate}

Our algorithm extends to a closely related generalization of the vertex-coloring problem known as \emph{list-coloring}. Here, there is a set of colors~, and each vertex is equipped with a palette~ of size ; each vertex selects one color from its palette, and no two neighbors can be assigned the same color. -coloring is a special case in which  and every vertex has the same palette of size~. 

\subsection{Technical summary}\label{sec:technical}


The possibility of coloring a vertex with super-constant probability was first observed in \cite{Sch10, elk15}, in the setting where there are~ colors for some~. The idea is that vertices try for multiple colors on each trial, if the palette size exceeds a node's degree. This yields a~ rounds algorithm for the first phase. Combined with the graph shattering technique, the algorithm runs in  rounds. Elkin, Pettie, and Su~\cite{elk15} observed that if a graph is -locally-sparse (each vertex participates in at most  triangles), then it can be reduced to the coloring problem with  colors.



It is thus the dense parts of the graph that become bottlenecks. However, if a subgraph is dense, then it is likely to have small (weak) diameter. (The {\it weak diameter} of a subgraph  is the maximum distance measured in  between any pair of vertices .) A single vertex in  can read in all the information in~, make a decision, and broadcast it to  in time proportional to its weak diameter.

We develop a network decomposition procedure based on \emph{local sparseness}. Our decomposition algorithm is targeted towards identifying dense components of constant weak diameter and sparse components in a constant number of rounds. Roughly speaking, a sparse vertex is one which participates in at most  triangles in its neighborhood, where  is a parameter that we will carefully choose. At the same time, we would also like to bound the number of neighbors of a dense component that are not members of the dense component itself, called \emph{external neighbors}. This step is necessary to bound the influence of color choices of nodes in one component on other components. This mechanism may help to leverage algorithms for other distributed problems that can handle either dense or sparse graphs well.

First, we ignore the sparse vertices. Since each dense component has constant weak diameter, it can elect a leader to assign a color to every member so that no intra-component conflicts occur, i.e.~the endpoints of the edges inside the same component are always assigned different colors. Meanwhile, we hope that the assignments are random enough so that the chance of inter-component conflicts will be small.
Combined with the property of the decomposition that the number of external neighbors is bounded, we show that the probability that a vertex remains uncolored is roughly  in each round. After  rounds, the degree of each vertex becomes sufficiently small so that the algorithm of Barenboim et al.~\cite{bar15a} can handle the residual graph efficiently.

For the sparse vertices we analyze a preprocessing {\it initial coloring step} of the algorithm. In a similar vein as \cite{elk15}, we show that there will be an  gap between the palette size and the degree due to the sparsity. The gap remains while the dense vertices are colored. So, we will be able to color the sparse vertices by using the algorithm of Elkin et al.~\cite{elk15}, which requires  rounds. In contrast to \cite{elk15}, our analysis generalizes to the list-coloring problem. By setting , we balance the round complexity between the dense part and the sparse part, yielding the desired running time.

The main technical challenge lies in the dense components. In each component, we need to generate a random proper coloring so that each vertex has a small probability of receiving the same color as one of its external neighbors.
We give a process for generating a proper coloring where the probability that a vertex gets any color from its palette is close to uniform. Additionally, we need to show that the structure of the decomposition is maintained in the next round for appropriately scaled-down parameters.


\subsection{Overview}
In Section~\ref{related-work}, we review related algorithms for network decomposition and coloring.

In Section~\ref{decomp-sec}, we state our network decomposition.

In Section~\ref{full-algorithm-sec}, we outline the full algorithm for list-coloring. It consists of two steps: an initial coloring step applied to all vertices, and multiple rounds of dense coloring.

In Section~\ref{sec:firstcoloring}, we describe the initial coloring step for creating the gap between the palette size and the degree for sparse vertices.

In Section~\ref{color-dense}, we describe a single round of the dense coloring procedure and analyze the behavior of the graph structure. 

In Section~\ref{sec:solver}, we finish our analysis by solving recurrence relations for dense components which yields the overall algorithm run time. 

In Section~\ref{list-color-locally-sparse-sec}, we apply the initial coloring step to give a full algorithm for locally-sparse graphs; this extends the algorithm of \cite{elk15} to list-coloring.

\section{Related work}\label{related-work}
A variety of network decompositions have been developed to solve distributed computing problems. Awerbuch et al.~\cite{awer89} introduced the notion of -decompositions where each component has diameter~ and the contracted graph is -colorable. They give a deterministic procedure to obtain a -decomposition, which can be used to deterministically compute a -coloring and MIS in  rounds. Panconesi and Srinivasan~\cite{panc92} showed how to obtain a -decomposition, yielding -time algorithms for -coloring and MIS. Linial and Saks~\cite{lin93} gave a randomized algorithm for obtaining a -decomposition in  rounds. Barenboim et al.~\cite{bar15} gave a randomized algorithm for obtaining -decompositions in constant rounds.

Reed~\cite{ree98} introduced the structural decomposition to study the chromatic number of graphs of bounded clique size (see~\cite{MR01} for a detailed exposition). This was later used for applications including total coloring, frugal coloring, and computation of the chromatic number~\cite{ree99, mol14, mol98, mol10}. Our network decomposition method is inspired by theirs in the sense that they showed a graph can be decomposed into a sparse component and a number of dense components. However, as their main goal was to study the existential bounds, the properties of the decomposition between our needs are different. For example, the diameter is an important constraint in our case. Also, our decomposition must be computable in parallel, while theirs is obtained sequentially.

The -coloring algorithms are briefly summarized in Table \ref{ResultsOverview}. Barenboim and Elkin's monograph~\cite{bar13} contains an extensive survey of coloring algorithms. Faster algorithms are available if we use more than  colors. For deterministic algorithms, Linial~\cite{linial92} and Szegedy and Vishwanathan~\cite{SV93} gave algorithms for obtaining a -coloring in  rounds. Barenboim and Elkin~\cite{elk10} showed how to obtain an -coloring in  rounds. For randomized algorithms, Schneider and Wattenhofer~\cite{Sch10} showed that an -coloring can be obtained in  rounds. Combining the results in~\cite{Sch10} with Kothapalli et al.~\cite{KSOS06}, an -coloring can be obtained in  rounds. Barenboim et al.~\cite{BEPS16} showed it can be improved to  rounds.

On the other hand, sparse-type graphs can be colored using significantly less than  colors. Panconesi and his co-authors~\cite{GP00, DGP98, GP97, PS97} developed a line of randomized algorithms for edge-coloring (i.e. coloring the line graph, which is sparse) and Brook-Vizing colorings in the distributed setting. For example, \cite{GP00} showed a -coloring for girth-5 graphs in  rounds, provided ; this was generalized to triangle-free graphs by Pettie and Su~\cite{PS13}. The restriction on the size of  can be removed via the distributed Lov\'{a}sz Local Lemma~\cite{CPS17}.

Schneider et al.~\cite{sch13} investigated distributed coloring where the number of colors used depends on the chromatic number~. Their algorithm requires  colors and running time of  for graphs with  and .

More efficient algorithms for -coloring exist for very dense graphs, e.g.~a deterministic O() algorithm for growth bounded graphs (e.g.~unit disk graphs)~\cite{sch10opt}, as well as for many types of sparse graphs~\cite{BEPS16,elk15,PS13}, e.g. for graphs of low arboricity. Elkin et al.~\cite{elk15} described a -coloring algorithm for locally-sparse graphs. We will extend this result to cover list-colorings as well.

As we have discussed, the MIS problem and the coloring problems are related. An MIS can be computed in  rounds deterministically ~\cite{BEK09} and in  rounds randomly~\cite{panc92}. More recently, Ghaffari~\cite{Moh16} reduced the randomized complexity of MIS to . Whether an MIS can be obtained in polylogarithmic deterministic time or sublogarithmic randomized time remain interesting open problems.

\iffalse
A generalization of MIS, known as an \emph{ruling set}, has also been considered. A ()-ruling set~ is a set of vertices such that two nodes  have distance at least~ and for any node~ there exists a node~ with distance at most~~\cite{awer89}.  MIS is a special case, namely a -ruling set.  A number of papers~\cite{gfeller07,sch13,awer89} use ruling sets to compute colorings in different kinds of graphs. A ruling set can be viewed as defining a network decomposition, such that any component has diameter at least~ and at most~.
\fi

\section{Network decomposition and sparsity} \label{decomp-sec}
In this section, we define a structural decomposition of the graph~ into \emph{sparse} and \emph{dense} vertices. We measure  these notions with respect to a parameter~.

\begin{definition}[Friend edge]
An edge~ is a \emph{friend} edge if  and  share at least~ neighbors, i.e. . We define  to be the set of friend edges.

For any vertex~, vertex~ is a friend of  if~; we denote the friends of  by~.
\end{definition}

\begin{definition}[Dense and sparse vertices]
A vertex~ is \emph{dense} if it has at least~ friends. Otherwise, it is \emph{sparse}.

We write  for the set of dense vertices in~, and  for the set of sparse vertices in~.
\end{definition}

Next, we define the \emph{weak diameter}; this measures the diameter of a subgraph, while allowing shortcuts using nodes from the original graph.
\begin{definition}[Weak diameter]
Let  be an induced subgraph of~. For vertices~, let~ denote the distance between  and  in~. The weak diameter of  is defined to be .
\end{definition}



Let  be the connected components of the subgraph , where u,v \in V^{\text{dense}}uv \in F. That is, they are the connected components induced by friend edges and dense vertices. The vertices of  are partitioned disjointly as . We refer to each component~ as an \emph{almost-clique}. See Figure~\ref{fig:decomposition}.


\begin{figure}[t]
\centering
\includegraphics[scale = 0.35]{decomposition.pdf}
\caption{An illustration of a network decomposition.}
\label{fig:decomposition}
\end{figure}


\begin{lemma}\label{lem:diameter}
Suppose . Then, for any vertices , we have .
\end{lemma}

\begin{proof}
As  are in the same component~, there is a path of friend edges  connecting them. We claim that  for all~. We will show this by induction on~. The base case~ follows as  is a friend edge.

Now, consider the induction step. As  is a friend, . By the induction hypothesis, . We thus have:


Since  and  are dense, we have  and . Therefore, .

So  and  have a common friend~, such that  and . So:

\end{proof}

\begin{corollary}\label{cor:diameter}
Suppose . Then all almost-cliques have weak diameter of at most 2.
\end{corollary}
\begin{proof}
By Lemma~\ref{lem:diameter}, any vertices  have . In particular, they have a common neighbor.
\end{proof}

A vertex~ in  can identify all other members of  in  rounds by  the following procedure: Initially, each vertex~ broadcasts the edges incident to  to all nodes within distance 3.  In this way, every vertex~ learns the graph topology of all nodes up to distance 3, which is sufficient to determine whether an edge (both of whose endpoints are within distance 2 of ) is a friend edge and whether a vertex (within distance 2) is dense. Since by Corollary \ref{cor:diameter}, all members of  are within distance 2 to~, all the members can be identified. Also, the leader of  can be elected as the member with the smallest ID.


\begin{definition}[External degree]
For any dense vertex , we define~, the \emph{external degree} of~, to be the number of \emph{dense} neighbors of  outside~. (Sparse neighbors are not counted.)
\end{definition}

\begin{lemma}
\label{network1}
Any dense vertex  has .
\end{lemma}
\begin{proof}
Let . As  is dense, it has at least~ friends. So it has at most  dense vertices which are not friends.  If any dense vertex~ is a friend of~, then by definition~. So  has at most  dense neighbors outside~.
\end{proof}

\begin{definition}[Anti-degree]
For any dense vertex , we define the \emph{anti-degree} of  to be .
\end{definition}

\begin{lemma}
\label{network2}
Suppose . Then any dense vertex~ has .
\end{lemma}
\begin{proof}
Let , and let~ denote the number of length- paths of the form~ where  and  We show this result by counting  into ways different ways. First, observe that for any , there are precisely  possibilities for the middle vertex~. Lemma~\ref{lem:diameter} shows that:


We can also count~ by summing over the middle vertex :

Combining these two inequalities gives ; this is at most  for .
\end{proof}

\begin{corollary}
For , all almost-cliques have size at most .
\end{corollary}
\begin{proof}
Let . Then .
\end{proof}


\section{Full algorithm outline}
\label{full-algorithm-sec}
We can now describe our complete algorithm for list-coloring graphs, whether sparse or dense. It will be convenient to have a ``blank'' color, which is available to all vertices and which we denote~; we say that  to indicate that  has not (yet) chosen a color. Our parameters will be specified in terms of a constant ; we require  to be sufficiently large, and will state certain conditions on its value later in the proofs. We assume that . If , then , and so that the coloring procedure of~\cite{BEPS16} will already color the graph in  rounds.

We set the density parameter to be 
 

Note that our assumptions ensure that , which is needed for the results of Section~\ref{decomp-sec} and elsewhere. The bound on  is used at a number of other places without further comment.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Decompose  into .
\STATE Execute {\it the initial coloring step}:
\begin{ALC@g}
\FOR{all vertices }
\STATE  selects a tentative color~ as follows:

\IF{no neighbor~ has  and }
\STATE  commits to permanent color .
\ENDIF
\ENDFOR
\end{ALC@g}
\FOR{}
\STATE Execute the \emph{dense coloring step} on the dense vertices (Algorithm \ref{algo:app1})
\ENDFOR
\STATE Run the algorithm of~\cite{elk15} to color the sparse vertices.
\STATE Run the algorithm of~\cite{BEPS16} to color the residual graph.
\end{algorithmic} 
\caption{The coloring algorithm}
\label{algo:app0}
\end{algorithm}

The key subroutine for the coloring algorithm is the dense coloring step. The  dense coloring step is defined in terms of a parameter , which we will specify shortly.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE Initialize  for all .
\STATE \textbf{For each}~, elect a leader~ to simulate the following process to color :
\begin{ALC@g}
\STATE Generate a random permutation~ of 
\FOR{}
\STATE Vertex  selects  uniformly at random from 

\ENDFOR
\end{ALC@g}
\FOR{all  and all }
\IF{no dense neighbor~ has , where  and }
\STATE  commits to permanent color .
\ENDIF
\ENDFOR
\end{algorithmic}
\caption{The dense coloring step}
\label{algo:app1}
\end{algorithm}

We note that the decomposition of  in Line 1 of Algorithm~\ref{algo:app0} remains fixed for the entire algorithm and all its dense coloring steps. Although in later steps vertices become colored and are removed from~, we always define the decomposition in terms of the \emph{original} graph~, not the residual graph. However, we abuse notation so that when we refer to a component~ during an intermediate step, we mean the intersection of  with the residual (uncolored) vertices. 

The algorithm is based on maintaining a partial coloring and a residual palette. That is, whenever a vertex is colored, we remove it from the graph as well as the vertex sets ; also, its selected color is removed from the palettes of its neighbors. An important parameter for such partial-coloring algorithms is the difference between the available colors, i.e. the palette size~ and the uncolored neighbors~. We call this parameter \emph{(color) surplus}  of a vertex~, defined by


The surplus  is initially at least one for every vertex, since all palettes are of size~. A vertex~ can only lose a color from its palette if a neighbor becomes colored and drops out of the residual graph. Therefore,  can never decrease during the partial coloring.

For any vertex~, let~ denote, respectively, the palette,  degree, and surplus of  after the initial coloring step (note that the 0 in the subscript does not denote time 0, but the time immediately after the initial coloring step). We set . We will show in Theorem~\ref{initial-coloring-good-prop} that w.h.p. every sparse vertex~ has  and that every vertex~ (sparse or dense) has~.

Then we turn our attention to the dense vertices and we will show that they can be colored efficiently. For a dense vertex , we let~ and  denote its external degree and anti-degree after the initial coloring step. Let , and  denote the quantities at the end of the  dense coloring step. As we color the graph, we maintain two key parameters,  and~, which bound the external degree, anti-degree, and palette size for dense vertices after the  dense coloring step. Specifically, we ensure the invariant that every dense vertex  has


We will then set our parameter  by

We will show in Corollary~\ref{gamma-cor} that  as required.
 
At the end of the dense coloring steps, every sparse vertex~ has


The algorithm of Elkin et al.~\cite{elk15} is designed for list-coloring where vertices have a large surplus, which indeed holds for the sparse vertices. Thus they can be colored in  rounds. This removes the sparse vertices from the graph, leaving only the dense vertices behind.

After the sparse vertices are removed, Theorem~\ref{th1} shows that each remaining dense vertex is connected to  other vertices. The algorithm of~\cite{BEPS16} then takes  steps.

\section{The initial coloring step}
\label{sec:firstcoloring}
The initial coloring step is designed to achieve two important objectives:
\begin{enumerate}
\item[(A1)] For every vertex~, we have .
\item[(A2)] For every sparse vertex~, we have .
\end{enumerate}
Recall that  and  are respectively the palette size and degree of vertex~ after the initial coloring step, and the (color) surplus is . Property (A1) is fairly straightforward, and most of our effort will be to show that (A2) holds w.h.p. for a given sparse vertex~.

We briefly summarize the initial coloring step. With probability~, each vertex~ chooses a tentative color~ uniformly at random from its palette.\footnote{We will write  instead of directly writing .} It discards the tentative color if any neighbor also chooses the same tentative color; in this case we say that  is \emph{de-colored}. We let~ denote the permanent color selected by  \emph{after the initial coloring step.} We say that  if vertex~ chose not to select a color initially and we say~ if  is uncolored (either because it did not select a tentative color, or it became de-colored).

For each color~ and each vertex , we define  to be the set of neighbors of  whose palette contains~; that is, 

Let us now fix some sparse vertex~, and show that after the initial coloring step~ has a large surplus. We define a color~ to be \emph{good} if

(Here and in the remainder of the paper, we use the Iverson notation so that for any predicate ,   is equal to 1 if  is true and zero otherwise.)

Let~ denote the set of colors that are good for~. 
\begin{proposition}
\label{sparse-prop2}
The following bound holds with probability one:

\end{proposition}
\begin{proof}
Suppose  and there is some neighbor~ with~. When we remove~ from the residual graph,  does not change while~ decreases by one. Suppose , and there are two neighbors  with . When we remove~ and~ from the residual graph,  decreases by one while~ decreases by two.
\end{proof}

In light of Proposition~\ref{sparse-prop2}, it will suffice to show that  is large with high probability. We do so in two stages: first, we show that  is large, and second we show that  is concentrated around its mean.
\begin{lemma} \label{sparse-prop3a}
For , we have .
\end{lemma}
\begin{proof}
For each , let us define  to be the event that (i)  and (ii)  for all . 

If event  occurs, then we will have , and so  will go into . Also, condition (ii) ensures that the events  are all mutually exclusive. Thus

\end{proof}

\begin{lemma}
\label{sparse-prop3}
Suppose that . If  and , then .
\end{lemma}
\begin{proof}
Define  to be the set of ordered pairs  with  and . For every pair of vertices , let us define  to be the event that (i)  and (ii)  for all . 

If event~ occurs, then (as  are not neighbors) we will have , and so  will go into~. Also, note that condition (ii) ensures that the events  are mutually exclusive. Thus,


Next, we estimate~. Consider the set . By definition of sparsity,  has at most  friends. Thus, .

Since each  is not a friend of~, we have .  So . So we count~ as follows:


This shows that .
\end{proof}

\begin{lemma}
\label{sparse-prop4}
Suppose that .  If , then .
\end{lemma}
\begin{proof}
Let us partition the set of colors~ into three disjoint sets:


If , then by Proposition~\ref{sparse-prop3} we immediately have 

and we are done. So let us suppose that . 

Recall that  for every vertex . Thus, for each , there are exactly  values of  with~. By double counting, 


Rearranging, and using the fact that , gives:

where the last inequality holds since .

Lemma~\ref{sparse-prop3a} then gives:

\end{proof}

\begin{lemma}
\label{sparse-conc-prop}
With probability at least , we have .
\end{lemma}
\begin{proof}
If  then~ with certainty. Also, if , then  with certainty. So let us assume that  and . We will now show~ with probability at least~. By Proposition~\ref{sparse-prop2} this will establish the result.

Let  and let~ denote the set of vertices with distance 2 to~. Let us define  to be the set of colors which would be good \emph{if~ for all~}. Note that vertices in  can de-color vertices in . So vertices of  can only remove colors from  and hence  .

Since , Proposition~\ref{sparse-prop4} shows that 

for some constant~. 

Note that for~, modifying the value of~ can only change~ by at most 2 (the value of~ only affects whether~). Hence, by the Bounded Differences Inequality,


Now, let us condition on the full set of values  for , and also condition on the event  (which only depends on the values of  for ). Let~. The values of  for  are still independent and uniform, and each such vertex has the possibility of de-coloring a vertex in~.

For each , let~ be any vertex in  with  and not de-colored by any vertices in~. Similarly, for , let~ be any two vertices in  with  and not de-colored by any vertices in  (so  and  cannot be neighbors). Such colors will go into  unless a vertex in  selects  (respectively, in  selects color~.)

If a vertex~ selects  for such a color~, causing color~ to not appear in~, we say that  \emph{disqualifies} color~. Define the random variable~ by


Observe that , and so the Lemma will follow by showing that .

Each vertex~ disqualifies any given color~ with probability at most~. Furthermore there are at most  vertices  that can disqualify any given color . Hence,


All such disqualification events are negatively correlated. Using the fact that , we apply Chernoff's bound to obtain


Overall, we have shown that  with probability .
\end{proof}

\begin{theorem}
\label{initial-coloring-good-prop}
For  a sufficiently large constant, properties (A1) and (A2) hold for every vertex w.h.p.
\end{theorem}
\begin{proof}
By Lemma~\ref{sparse-conc-prop}, for any individual sparse vertex~ the probability that (1) fails is at most~. Since , this is at most~ for an arbitrary large constant  given that  is sufficiently large. (A2) follows by taking a union bound over all sparse vertices.

To show property (A1), fix some vertex~, and note that any  chooses an initial color with probability at most~, independently of any other vertices. Thus, a Chernoff bound shows that there is a probability of  that more than  neighbors of  are colored. So with probability , vertex~ loses at most~ colors from its original palette of size of~. Again, this is at most~ for an arbitrary constant~ given that~ is sufficiently large.
\end{proof}

\section{Coloring the dense vertices}
\label{color-dense}
Suppose that we are at the beginning of the  dense coloring step. We assume that there are parameters~,~, such that all dense vertices  have the following properties:
\begin{enumerate}
\item 
\item 
\item 
\end{enumerate}

Henceforth we will suppress the dependence on  and write , , , , , and~. We define  and .

Let us consider some almost-clique~, with  vertices. The dense coloring step for each  generates a permutation~ of its members. Starting from vertex~ up to vertex~, where , each vertex selects a tentative color from its palette excluding the colors selected by lower rank vertices. (Note that the leader~ in  simulates this process.) Then, a vertex becomes \emph{de-colored} if an external neighbor from a lower indexed component chooses the same color.

Our goal is to show for some parameters  and  that at the end of the round holds~,~ and~. To do this, we will show that most vertices are colored in round~.

We require throughout this section the following conditions on  and~, which we will refer to as the \emph{regularity conditions}:
\begin{enumerate}
\item[(R1)]  for some sufficiently large constant~
\item[(R2)]  for some sufficiently large constant~
\end{enumerate}
Recall that  is a universal constant that we will not explicitly compute. At several places we will assume it is sufficiently large. In Section~\ref{sec:solver} we will discuss how to satisfy these regularity conditions (or how our algorithm can succeed when they become false). \emph{In Section~\ref{color-dense}, we require implicitly that these regularity conditions all hold.} 

\subsection{Overview}
We first contrast our dense coloring procedure with a naive one, which assigns each vertex a random color and de-colors a vertex if there is a conflict. It is not hard to show that such a procedure successfully assigns a color to a vertex with constant probability. Thus, in each round, the degrees are shrinking by a constant factor in expectation. So it takes  rounds to reduce to a low (near-constant) degree.

In order to get a faster algorithm, we need to color much more than a constant fraction of all vertices per round. Here, the network decomposition plays the decisive role as only \emph{external} neighbors of a vertex~ can de-color ~. To illustrate, suppose that each vertex~ selects a color from its palette uniformly at random. (That is, suppose we ignore the interaction between  and the other vertices in ). Since the external neighbors are upper bounded by  and the palette size is at least~, even if the external neighbors of  choose distinct colors, the probability that  has any conflicts with its neighbors is upper bounded by . Ideally, we would like to show that each cluster shrinks by a factor of  in each round. Moreover, one would also need to prove that the ratio~ in the next round remains approximately~, so that the almost-cliques continue to shrink by the same factor.

The reason why we only attempt to color the first~ vertices rather than the entire almost-clique is that we cannot afford the palette size to shrink too fast. A ``controlled'' uniform shrinking process maintains the overall ratio between palette size, external neighbors, and internal neighbors. This renders undesirable  scenarios very unlikely.

The following lemma uses the regularity conditions to show a useful bound on several parameters of the almost-clique.
\begin{lemma}
\label{aprop1}
For any , the following bound holds with probability one:

\end{lemma}
\begin{proof}
Note that . Therefore,
{\allowdisplaybreaks

}
\end{proof}


\subsection{Concentration of the number of uncolored vertices}
We will show that most vertices become colored at the end of a dense coloring step. We distinguish two ways in which a vertex~ could fail to be colored: first, it may be \emph{de-colored} in the sense that it initially chose a color, but then had a conflict with an almost-clique of smaller index. Second, it may be \emph{initially-uncolored} in the sense that~.

\begin{lemma}
\label{color-lemma}
Let . Let  be an arbitrary sequence of non-blank colors. Then

\end{lemma}
\begin{proof}
Let us condition on the permutation~, and without of loss generality . We assume  as otherwise .

For each  we claim that , even after conditioning on all the colors choices made by vertices  with . For, at this point, at most  colors from the palette of  have been used by previously-colored neighbors from . Hence,  has a remaining palette of size . Using Lemma~\ref{aprop1} then gives

\end{proof}

\begin{lemma}
\label{prop1}
Let . The probability that all the vertices in  become de-colored is at most .
\end{lemma}
\begin{proof}
Let us sort the almost-cliques  by the vertex ID of their leaders, so that . For each  we define . 

We will show for any  that the vertices in  become de-colored with probability at most , conditioned on the event that the vertices in  become de-colored.  In fact, we will not just condition on the event that the vertices in  become de-colored, but we will condition on the complete set of random variables involved in . (The event that  becomes de-colored is a function of only the colors involved in .)

For each , the event that  becomes de-colored is a union of at most  events of the form , where  enumerates the colors selected by vertices in . Hence, the event that all of the vertices in  become de-colored is a union of  events of the form stated in Lemma~\ref{color-lemma}, each of which has probability at most . Therefore, the probability that all of them become de-colored is .
\end{proof}

\begin{lemma}
\label{prop2}
Let . The probability that all of the vertices in  are initially uncolored is at most .
\end{lemma}
\begin{proof}
It suffices to show that for a particular~, the probability that all vertices in  are initially uncolored is bounded by , since the nodes in distinct almost-cliques make their choices independently.

We select from~ a set of  vertices to be colored, uniformly at random without replacement. Thus, the probability that all vertices in  are initially-uncolored is:
{\allowdisplaybreaks

If , the right hand side is zero and we are done. Otherwise,

}
\end{proof}

\begin{lemma}
\label{prop3}
Let , and let~ be a real number with . Then the probability that~ contains more than  uncolored vertices at the end of round~ is at most~ for an arbitrarily large constant .
\end{lemma}
\begin{proof}
Let . We claim that the number of de-colored vertices in  is at most  with probability~ and we also claim that the number of initially-uncolored vertices is at most  with probability ; combining these two claims gives the stated result.

The proofs are nearly the same, so we show only the latter one. By a union bound over all possible sets of size~, the probability that the number of initially-uncolored vertices exceeds  is at most
{\allowdisplaybreaks

}
\end{proof}

\begin{lemma}
\label{r-prop1}
W.h.p. at the end of round~, every dense vertex~ satisfies the bounds

for the parameters

\end{lemma}
\begin{proof}
Let . We first note that the regularity conditions imply  and hence .

So we may apply Lemma~\ref{prop3} with  being the set of external neighbors of~ and  to show that that  holds with probability at least~ for an arbitrarily large constant . Similarly, we apply Lemma~\ref{prop3} with  and  to show that that  holds with probability~.  

Next, we bound~. We color at most~ external neighbors and at most~ internal neighbors. Thus, the residual palette of~ has size at least~. By Lemma~\ref{aprop1}, this is at least~ for  sufficiently large.

Finally, take a union bound over all dense vertices .
\end{proof}

\begin{proposition}
\label{aprop2}
W.h.p. at the end of round~, every almost-clique  has size at most

\end{proposition}
\begin{proof}
 Apply Lemma~\ref{prop3} with  and ; this shows that with probability at least~ for an arbitrarily large constant   there are at most  uncolored vertices remaining in~. Finally, take a union bound over all almost-cliques~.
\end{proof}

\section{Solving the recurrence}
\label{sec:solver}
In light of Lemma~\ref{r-prop1}, we can explicitly derive a recurrence relation for the parameters~ and~. We define  throughout.

\begin{lemma}
\label{r-prop0}
Define the recurrence relation with initial conditions

and recurrence


Let . Assuming that the regularity conditions (R1), (R2) are satisfied for , then we have w.h.p.:

\end{lemma}
\begin{proof}
The bound on  is given in Theorem~\ref{initial-coloring-good-prop}. By Lemma~\ref{network1} and Lemma~\ref{network2}, we get~ and   in the initial graph. The initial coloring step cannot increase these parameters, so we have  as well. This shows the bound on~.


A simple induction, using Lemma~\ref{r-prop1}, shows that for all  we have the following:


Thus, for any fixed , the probability that any of these events does not occur, is at most  for an arbitrarily large constant .
\end{proof}

We will now show how to solve this recurrence.
\begin{lemma}
\label{r-prop3}
For all  we have .
\end{lemma}
\begin{proof}
For each~, we may compute  as


As  , we have  as claimed. Now, recalling our formula , we have 

\end{proof}

\begin{corollary}
\label{gamma-cor}
For every , we have .
\end{corollary}
\begin{proof}
Follows immediately from Lemma~\ref{r-prop3} and the definition .
\end{proof}

\begin{lemma}
\label{r-prop2}
For all , we have .
\end{lemma}
\begin{proof}
We recursively compute  from  as:

Using Lemma~\ref{r-prop3} we then estimate:

\end{proof}

\begin{corollary}
\label{cor-dbound}
We have the bound .
\end{corollary}
\begin{proof}
If , then . Otherwise, we apply Lemma~\ref{r-prop2}:

\end{proof}

\iffalse
\textbf{Expository remark:} Corollary~\ref{cor-dbound} explains why we selected  and ran our coloring steps for  rounds. Suppose instead we set~ and ran  dense coloring steps, for some~. At the end of these steps, we would have . This is close to  (differing in only a sub-polynomial term), which implies that we have hardly made any progress in reducing the number of uncolored vertices.
\fi

\begin{theorem}
\label{th1}
At the end of the dense coloring steps, w.h.p. every dense vertex is connected to at most  other dense vertices.
\end{theorem}
\begin{proof}
Let  be minimal such that ; Corollary~\ref{cor-dbound} ensures such an  exists. 

The regularity conditions are satisfied up to round~. Noting that , Lemma~\ref{r-prop0} shows that:


Next, we bound the size of each almost-clique . The initial size of  is at most . Applying Proposition~\ref{aprop2} repeatedly for  shows that the size of  reduces to 

w.h.p. We bound the latter term as follows:
{\allowdisplaybreaks

}

We have shown that   has  external neighbors and   neighbors  after round . Dense coloring steps after round  can only decrease the degree of , so  has  dense neighbors after round . 
\end{proof}

\iffalse
We have shown that after the  dense coloring steps, the number of dense neighbors of each dense vertex shrinks to . Also, for each sparse vertex~, we have  due to the initial coloring step. By applying the algorithm of Elkin, Pettie, and Su~\cite[Section 4]{elk15} on the sparse component, it can be colored in  rounds. Then, we apply the algorithm of Barenboim et al.~\cite{BEPS16} to color the remaining vertices whose degrees are bounded by . It then runs in  rounds. The total number of rounds is .
\fi

\section{List-coloring locally-sparse graphs}
\label{list-color-locally-sparse-sec}
Although the overall focus of this paper is an algorithm for coloring arbitrary graphs in time , we note that our initial coloring step may also be used to obtain a faster list-coloring algorithm for sparse graphs. This result extends the work of~\cite{elk15}, which showed a similar type of -coloring algorithm for graphs which satisfy a property they refer to as \emph{local sparsity.} We define this property and show that it is essentially equivalent to the definition of sparsity defined in Section~\ref{decomp-sec}.
\begin{definition}
A graph~ is \emph{-locally sparse} if very vertex contains at most  edges in its neighborhood, for some parameter . (That is, the induced subgraph  contains  edges).
\end{definition}

\iffalse
\begin{lemma}
Suppose that we have a network decomposition with sparsity parameter~. The neighborhood of a sparse vertex~ spans at most  edges. That is, .
 \end{lemma}
\begin{proof}
We can count the number of edges in the neighborhood of  by:

\end{proof}
\fi

\begin{lemma}\label{sparse-equiv-prop}
Suppose that  is -locally sparse. If we apply the network decomposition of Section~\ref{decomp-sec} with parameter , then every vertex is sparse, i.e. .
\end{lemma}
\begin{proof}
Suppose that  is dense with respect to~. Then  has at least~ friends. Each such friend~ corresponds to at least~ edges between  and another neighbor of~, that is, an edge in . Furthermore, any such edge in  is counted at most twice, so  must contain  edges, which contradicts our hypothesis for .
\end{proof}

\begin{corollary}
Suppose that  is -locally-sparse and that every vertex has a palette of size exactly~. Then  can be list-colored w.h.p. in  rounds.
\end{corollary}
\begin{proof}
By Proposition~\ref{sparse-equiv-prop}, every vertex in  is sparse with respect to parameter . 

First suppose that , where  is a sufficiently large constant. Then by Theorem~\ref{initial-coloring-good-prop}, each vertex satisfies  w.h.p. The algorithm of~\cite{elk15} applied to the residual graph runs in  rounds.

Next, suppose that . Then the coloring algorithm of~\cite{BEPS16} runs in  rounds.
\end{proof}

\section{Conclusions}
Distributed symmetry breaking tasks such as coloring or MIS lie at the heart of distributed computing. We have shown that the -coloring problem is easier than MIS. However, there is still a large gap in the round complexity between the best lower bound of  and our upper bound of . Recent advances for lower bounds~\cite{Brandt16, ChangP17, hef16, chlpj17} for the \textsf{LOCAL} model and its variants might yield inspiration for improving the existing lower bound. Our deterministic decomposition into locally sparse and dense parts might foster additional advances as well. It might help to further reduce upper bounds for symmetry breaking tasks -- in particular for deterministic algorithms, since there exist efficient algorithms for (very) dense graphs, e.g. ~\cite{sch10opt}, and sparse graphs, e.g.~\cite{moh17}. Furthermore, the gap for -coloring between our randomized algorithm running in time~ and the best deterministic algorithm requiring ~\cite{FraigniaudHK15} is more than exponential and, therefore, larger than any known separation result for randomized and deterministic algorithms~\cite{chan16}.

\medskip
\noindent \textbf{Acknowledgments:} We would like to thank Seth Pettie for his valuable comments. We thank the anonymous reviewers for many helpful suggestions and comments.

\bibliographystyle{abbrv}
\bibliography{coloralg-references}
\end{document}
