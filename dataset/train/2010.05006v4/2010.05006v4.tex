

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{acl2021}
\usepackage{times}
\usepackage{latexsym}
\renewcommand{\UrlFont}{\ttfamily\small}




\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{url}
\usepackage{hyperref}
\usepackage{url}
\usepackage{bbm}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{boldline}
\usepackage{caption}
\usepackage{tikz-dependency}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage[T1]{fontenc}
\usepackage{subfiles}
\usepackage{readarray}
\usepackage{xcolor}
\usepackage{import}
\usepackage{hhline}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{enumitem}



\newcommand{\xvec}{\mathbf{x}}
\newcommand{\yvec}{\mathbf{y}}
\newcommand{\cvec}{\mathbf{c}}
\newcommand{\evec}{\mathbf{e}}
\newcommand{\zvec}{\mathbf{z}}
\newcommand{\mVec}{\mathbf{s}}
\newcommand{\tvec}{\mathbf{t}}
\newcommand{\rvec}{\mathbf{r}}
\newcommand{\dvec}{\mathbf{d}}
\newcommand{\mcL}{\mathcal{L}}
\newcommand{\mcR}{\mathcal{R}}
\newcommand{\mcT}{\mathcal{T}}
\newcommand{\mcY}{\mathcal{Y}}
\newcommand{\mcV}{\mathcal{V}}
\newcommand{\mcC}{\mathcal{C}}
\newcommand{\mcA}{\mathcal{A}}
\newcommand{\mcZ}{\mathcal{Z}}
\newcommand{\mcU}{\mathcal{U}}
\newcommand{\context}{\mathbf{y}_{\mathrm{c}}}
\newcommand{\embcontext}{\mathbf{\tilde{y}}_{\mathrm{c}}}
\newcommand{\inpcontext}{\mathbf{\tilde{x}}}
\newcommand{\start}{\mathbf{\tilde{y}}_{\mathrm{c0}}}
\newcommand{\End}{\mathrm{\texttt{</s>}}}
\newcommand{\Score}{\text{Score}}
\newcommand{\Uvec}{\mathbf{U}}
\newcommand{\Evec}{\mathbf{E}}
\newcommand{\Gvec}{\mathbf{G}}
\newcommand{\Fvec}{\mathbf{F}}
\newcommand{\Pvec}{\mathbf{P}}
\newcommand{\mvec}{\mathbf{m}}
\newcommand{\pvec}{\mathbf{p}}
\newcommand{\Vvec}{\mathbf{V}}
\newcommand{\Wvec}{\mathbf{W}}
\newcommand{\hvec}{\mathbf{h}}
\newcommand{\wvec}{\mathbf{w}}
\newcommand{\uvec}{\mathbf{u}}
\newcommand{\vvec}{\mathbf{v}}
\newcommand{\bvec}{\mathbf{b}}
\newcommand{\reals}{\mathbb{R}}
\usepackage{microtype}

\aclfinalcopy \def\aclpaperid{444} 



\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{Automated Concatenation of Embeddings for Structured Prediction}


\author{Xinyu Wang, Yong Jiang\textsuperscript{}, Nguyen Bach, Tao Wang,\\
\textbf{Zhongqiang Huang, Fei Huang,  Kewei Tu}\thanks{\hspace{1mm} Yong Jiang and Kewei Tu are the corresponding authors. : This work was conducted when Xinyu Wang was interning at Alibaba DAMO Academy. } \\
 School of Information Science and Technology, ShanghaiTech University \\
 Shanghai Engineering Research Center of Intelligent Vision and Imaging \\
  Shanghai Institute of Microsystem and Information Technology, Chinese Academy of Sciences \\
 University of Chinese Academy of Sciences \\
 DAMO Academy, Alibaba Group \\
  {\tt \{wangxy1,tukw\}@shanghaitech.edu.cn, yongjiang.jy@alibaba-inc.com} \\
  {\tt \{nguyen.bach,leeo.wangt,z.huang,f.huang\}@alibaba-inc.com} \\
}



\date{}

\begin{document}
\maketitle

\begin{abstract}
Pretrained contextualized embeddings are powerful word representations for structured prediction tasks. Recent work found that better word representations can be obtained by concatenating different types of embeddings. However, the selection of embeddings to form the best concatenated representation usually varies depending on the task and the collection of candidate embeddings, and the ever-increasing number of embedding types makes it a more difficult problem. In this paper, we propose Automated Concatenation of Embeddings (ACE) to automate the process of finding better concatenations of embeddings for structured prediction tasks, based on a formulation inspired by recent progress on neural architecture search. Specifically, a controller alternately samples a concatenation of embeddings, according to its current belief of the effectiveness of individual embedding types in consideration for a task, and updates the belief based on a reward. We follow strategies in reinforcement learning to optimize the parameters of the controller and compute the reward based on the accuracy of a task model, which is fed with the sampled concatenation as input and trained on a task dataset. Empirical results on 6 tasks and 21 datasets show that our approach outperforms strong baselines and achieves state-of-the-art performance with fine-tuned embeddings in all the evaluations.\footnote{Our code is publicly available at \url{https://github.com/Alibaba-NLP/ACE}.}




\end{abstract}

\section{Introduction}

Recent developments on pretrained contextualized embeddings have significantly improved the performance of structured prediction tasks in natural language processing. Approaches based on contextualized embeddings, such as ELMo \citep{peters-etal-2018-deep}, Flair \citep{akbik-etal-2018-contextual}, BERT \citep{devlin-etal-2019-bert}, and XLM-R \citep{conneau-etal-2020-unsupervised}, have been consistently raising the state-of-the-art for various structured prediction tasks. Concurrently, research has also showed that word representations based on the concatenation of multiple pretrained contextualized embeddings and traditional non-contextualized embeddings (such as word2vec \citep{mikolov2013distributed} and character embeddings \citep{santos2014learning}) can further improve performance \citep{peters-etal-2018-deep,akbik-etal-2018-contextual,strakova-etal-2019-neural,wang-etal-2020-more}. Given the ever-increasing number of embedding learning methods that operate on different granularities (e.g., word, subword, or character level) and with different model architectures, choosing the best embeddings to concatenate for a specific task becomes non-trivial, and exploring all possible concatenations can be prohibitively demanding in computing resources.



Neural architecture search (NAS) is an active area of research in deep learning to automatically search for better model architectures, and has achieved state-of-the-art performance on various tasks in computer vision, such as image classification \citep{real2019regularized}, semantic segmentation \citep{liu2019auto}, and object detection \citep{ghiasi2019fpn}. In natural language processing, NAS has been successfully applied to find better RNN structures  \citep{zoph2016neural,pham2018efficient} and recently better transformer structures \citep{so2019evolved,zhu2020autotrans}. In this paper, we propose Automated Concatenation of Embeddings (ACE) to automate the process of finding better concatenations of embeddings for structured prediction tasks. ACE is formulated as an NAS problem. In this approach, an iterative search process is guided by a controller based on its belief that models the effectiveness of individual embedding candidates in consideration for a specific task. At each step, the controller samples a concatenation of embeddings according to the belief model and then feeds the concatenated word representations as inputs to a task model, which in turn is trained on the task dataset and returns the model accuracy as a reward signal to update the belief model. We use the policy gradient algorithm \citep{williams1992simple} in reinforcement learning \citep{sutton2018reinforcement} to solve the optimization problem. In order to improve the efficiency of the search process, we also design a special reward function by accumulating all the rewards based on the transformation between the current concatenation and all previously sampled concatenations. 



Our approach is different from previous work on NAS in the following aspects:
\begin{enumerate}[leftmargin=*]
	\item Unlike most previous work, we focus on searching for better word representations rather than better model architectures.
    \item We design a novel search space for the embedding concatenation search. Instead of using RNN as in previous work of \citet{zoph2016neural}, we design a more straightforward controller to generate the embedding concatenation. We design a novel reward function in the objective of optimization to better evaluate the effectiveness of each concatenated embeddings.
    \item ACE achieves high accuracy without the need for retraining the task model, which is typically required in other NAS approaches.
    \item Our approach is efficient and practical. Although ACE is formulated in a NAS framework, ACE can find a strong word representation on a single GPU with only a few GPU-hours for structured prediction tasks. In comparison, a lot of NAS approaches require dozens or even thousands of GPU-hours to search for good neural architectures for their corresponding tasks.
\end{enumerate}

Empirical results show that ACE outperforms strong baselines. 
Furthermore, when ACE is applied to concatenate pretrained contextualized embeddings fine-tuned on specific tasks, we can achieve
state-of-the-art accuracy on 6 structured prediction tasks including Named Entity Recognition \citep{Sundheim1995NamedET}, Part-Of-Speech tagging \citep{derose-1988-grammatical}, chunking \citep{tjong-kim-sang-buchholz-2000-introduction}, aspect extraction \citep{10.1145/1014052.1014073}, syntactic dependency parsing \citep{arrive1969elements} and semantic dependency parsing \citep{oepensemeval} over 21 datasets.
Besides, we also analyze the advantage of ACE and reward function design over the baselines and show the advantage of ACE over ensemble models. 

\section{Related Work}
\subsection{Embeddings}



Non-contextualized embeddings, such as word2vec \citep{mikolov2013distributed}, GloVe \citep{pennington2014glove}, and fastText \citep{bojanowski2017enriching}, help lots of NLP tasks. 
Character embeddings \citep{santos2014learning} are trained together with the task and applied in many structured prediction tasks \citep{ma-hovy-2016-end,lample-etal-2016-neural,dozat-manning-2018-simpler}. 
For pretrained contextualized embeddings, ELMo \citep{peters-etal-2018-deep}, a pretrained contextualized word embedding generated with multiple Bidirectional LSTM layers, significantly outperforms previous state-of-the-art approaches on several NLP tasks. 
Following this idea, \citet{akbik-etal-2018-contextual} proposed Flair embeddings, which is a kind of contextualized character embeddings and achieved strong performance in sequence labeling tasks. 
Recently, \citet{devlin-etal-2019-bert} proposed BERT, which encodes contextualized sub-word information by Transformers \citep{vaswani2017attention} and significantly improves the performance on a lot of NLP tasks. 
Much research such as RoBERTa \citep{liu2019roberta} has focused on improving BERT model's performance through stronger masking strategies. Moreover, multilingual contextualized embeddings become popular. \citet{pires-etal-2019-multilingual} and \citet{wu-dredze-2019-beto} showed that Multilingual BERT (M-BERT) could learn a good multilingual representation effectively with strong cross-lingual zero-shot transfer performance in various tasks. \citet{conneau-etal-2020-unsupervised} proposed XLM-R, which is trained on a larger multilingual corpus and significantly outperforms M-BERT on various multilingual tasks.

\subsection{Neural Architecture Search}
Recent progress on deep learning has shown that network architecture design is crucial to the model performance. 
However, designing a strong neural architecture for each task requires enormous efforts, high level of knowledge, and experiences over the task domain. 
Therefore, automatic design of neural architecture is desired. 
A crucial part of NAS is search space design, which defines the discoverable NAS space. 
Previous work \citep{baker2016designing,zoph2016neural,xie2017genetic} designs a global search space \citep{elsken2019neural} which incorporates structures from hand-crafted architectures. For example, \citet{zoph2016neural} designed a chained-structured search space with skip connections. 
The global search space usually has a considerable degree of freedom. For example, the approach of \citet{zoph2016neural} takes 22,400 GPU-hours to search on CIFAR-10 dataset. Based on the observation that existing hand-crafted architectures contain repeated structures \citep{szegedy2016rethinking,he2016deep,huang2017densely}, \citet{zoph2018learning} explored cell-based search space which can reduce the search time to 2,000 GPU-hours. 

In recent NAS research, reinforcement learning and evolutionary algorithms are the most usual approaches. 
In reinforcement learning, the agent's actions are the generation of neural architectures and the action space is identical to the search space. Previous work usually applies an RNN layer \citep{zoph2016neural,zhong2018practical,zoph2018learning} or use Markov Decision Process \citep{baker2016designing} to decide the hyper-parameter of each structure and decide the input order of each structure.
Evolutionary algorithms have been applied to architecture search for many decades \citep{geoffrey1989designing,angeline1994evolutionary,stanley2002evolving,floreano2008neuroevolution,jozefowicz2015empirical}. The algorithm repeatedly generates new populations through recombination and mutation operations and selects survivors through competing among the population. Recent work with evolutionary algorithms differ in the method on parent/survivor selection and population generation. For example, \citet{real2017large}, \citet{liu2018hierarchical}, \citet{wistuba2018deep} and \citet{real2019regularized} applied tournament selection \citep{goldberg1991comparative} for the parent selection while \citet{xie2017genetic} keeps all parents. \citet{suganuma2017genetic} and \citet{elsken2017simple} chose the best model while \citet{real2019regularized} chose several latest models as survivors.







\section{Automated Concatenation of Embeddings}
In ACE, a task model and a controller interact with each other repeatedly. The task model predicts the task output, while the controller searches for better embedding concatenation as the word representation for the task model to achieve higher accuracy. Given an embedding concatenation generated from the controller, the task model is trained over the task data and returns a reward to the controller. The controller receives the reward to update its parameter and samples a new embedding concatenation for the task model. 
Figure \ref{fig:architecture} shows the general architecture of our approach.
\subsection{Task Model}
For the task model, we emphasis on sequence-structured and graph-structured outputs. Given a structured prediction task with input sentence  and structured output , we can calculate the probability distribution  by:

where  represents all possible output structures given the input sentence . Depending on different structured prediction tasks, the output structure  can be label sequences, trees, graphs or other structures. In this paper, we use sequence-structured and graph-structured outputs as two exemplar structured prediction tasks. We use BiLSTM-CRF model \citep{ma-hovy-2016-end,lample-etal-2016-neural} for sequence-structured outputs and use BiLSTM-Biaffine model \citep{dozat2016deep} for graph-structured outputs:

where ,  is a matrix of the word representations for the input sentence  with  words,  is the hidden size of the concatenation of all embeddings. The word representation  of -th word is a concatenation of  types of word embeddings:

where  is the model of -th embeddings, , .  is the hidden size of . 

\subsection{Search Space Design}
\label{sec:search_space}
The neural architecture search space can be represented as a set of neural networks \citep{elsken2019neural}. 
A neural network can be represented as a directed acyclic graph with a set of nodes and directed edges.
Each node represents an operation, while each edge represents the inputs and outputs between these nodes. 
In ACE, we represent each embedding candidate as a node. 
The input to the nodes is the input sentence , and the outputs are the embeddings . Since we concatenate the embeddings as the word representation of the task model, there is no connection between nodes in our search space. Therefore, the search space can be significantly reduced. 
For each node, there are a lot of options to extract word features. 
Taking BERT embeddings as an example, \citet{devlin-etal-2019-bert} concatenated the last four layers as word features while \citet{kondratyuk-straka-2019-75} applied a weighted sum of all twelve layers. However, the empirical results \citep{devlin-etal-2019-bert} do not show a significant difference in accuracy. We follow the typical usage for each embedding to further reduce the search space. As a result, each embedding only has a fixed operation and the resulting search space contains  possible combinations of nodes.



In NAS, weight sharing \citep{pmlr-v80-pham18a} shares the weight of structures in training different neural architectures to reduce the training cost. In comparison, we fixed the weight of pretrained embedding candidates in ACE except for the character embeddings. 
Instead of sharing the parameters of the embeddings, we share the parameters of the task models at each step of search.
However, the hidden size of word representation varies over the concatenations, making the weight sharing of structured prediction models difficult. Instead of deciding whether each node exists in the graph, we keep all nodes in the search space and add an additional operation for each node to indicate whether the embedding is masked out. To represent the selected concatenation, we use a binary vector  as an mask to mask out the embeddings which are not selected:

where  is a binary variable. Since the input  is applied to a linear layer in the BiLSTM layer, multiplying the mask with the embeddings is equivalent to directly concatenating the selected embeddings:

where  and  and . Therefore, the model weights can be shared after applying the embedding mask to all embedding candidates' concatenation. Another benefit of our search space design is that we can remove the unused embedding candidates and the corresponding weights in  for a lighter task model after the best concatenation is found by ACE.

\begin{figure*}
	\centering
	\includegraphics[scale=0.8]{rl.pdf}
	\caption{The main paradigm of our approach is shown in the middle, where an example of reward function is represented in the left and an example of a concatenation action is shown in the right.}
	\label{fig:architecture}
\end{figure*}


\subsection{Searching in the Space}
During search, the controller generates the embedding mask for the task model iteratively. We use parameters  for the controller instead of using the RNN structure applied in previous approaches \citep{zoph2016neural,zoph2018learning}. The probability distribution of selecting an concatenation  is . Each element  of  is
sampled independently from a Bernoulli distribution,
which is defined as:

where  is the sigmoid function.
Given the mask, the task model is trained until convergence and returns an accuracy  on the development set. 
As the accuracy cannot be back-propagated to the controller, we use the reinforcement algorithm for optimization. 
The accuracy  is used as the reward signal to train the controller. 
The controller's target is to maximize the expected reward  through the policy gradient method \citep{williams1992simple}.
In our approach, since calculating the exact expectation is intractable, the gradient of  is approximated by sampling only one selection following the distribution  at each step for training efficiency:
 
where  is the baseline function to reduce the high variance of the update function. The baseline usually can be the highest accuracy during the search process. 
Instead of merely using the highest accuracy of development set over the search process as the baseline, we design a reward function on how each embedding candidate contributes to accuracy change by utilizing all searched concatenations' development scores.
We use a binary vector  to represent the change between current embedding concatenation  at current time step  and  at previous time step .
We then define the reward function as:

where  is a vector with length  representing the reward of each embedding candidate.  and  are the reward at time step  and . 
When the Hamming distance of two concatenations  gets larger, the changed candidates' contribution to the accuracy becomes less noticeable. The controller may be misled to reward a candidate that is not actually helpful.
We apply a discount factor to reduce the reward for two concatenations with a large Hamming distance to alleviate this issue.
Our final reward function is:

where . Eq. \ref{eq:rl} is then reformulated as:
 

\subsection{Training}
To train the controller, we use a dictionary  to store the concatenations and the corresponding validation scores. At , we train the task model with all embedding candidates concatenated. From , we repeat the following steps until a maximum iteration :
\begin{enumerate}[leftmargin=*]
    \item Sample a concatenation  based on the probability distribution in Eq. \ref{eq:prob}.
    \item Train the task model with  following Eq. \ref{eq:vector} and evaluate the model on the development set to get the accuracy .
    \item Given the concatenation , accuracy  and , compute the gradient of the controller following Eq. \ref{eq:gradient} and update the parameters of controller.
    \item Add  and  into , set .
\end{enumerate}
When sampling , we avoid selecting the previous concatenation  and the all-zero vector (i.e., selecting no embedding). If  is in the dictionary , we compare the  with the value in the dictionary and keep the higher one.



\begin{table*}[!ht]
\small
\centering
\setlength\tabcolsep{2.25pt}
\begin{tabular}{l||cccc|ccc|cccccccc}
\hlineB{4}
      & \multicolumn{4}{c|}{\bf \textsc{NER}}     & \multicolumn{3}{c|}{\bf \textsc{POS}}   & \multicolumn{8}{c}{\bf \textsc{AE}}          \\
\hhline{~||----|---|--------}
      & de       & en         & es   & nl  & Ritter & ARK    & TB-v2   & 14Lap  & 14Res   & 15Res   & 16Res & es   & nl   & ru   & tr   \\
\hline\hline
\bf \textsc{All}    & 83.1        & 92.4        & \textbf{88.9} & 89.8  & 90.6   & 92.1   & 94.6    & 82.7   & 88.5    & 74.2    & 73.2  & 74.6 & 75.0 & 67.1 & 67.5 \\
\bf \textsc{Random} & 84.0        & 92.6        & 88.8 & 91.9  & 91.3   & 92.6   & 94.6    & 83.6   & 88.1    & 73.5    & 74.7  & 75.0 & 73.6 & 68.0 & 70.0 \\
\bf \textsc{ACE}    & \textbf{84.2}        & \textbf{93.0}        & \textbf{88.9} & \textbf{92.1}  & \textbf{91.7}   & \textbf{92.8}   & \textbf{94.8}    & \textbf{83.9}   & \textbf{88.6}    & \textbf{74.9}    & \textbf{75.6}  & \textbf{75.7} & \textbf{75.3} & \textbf{70.6} & \textbf{71.1} \\
\hline
\end{tabular}
\begin{tabular}{l||c|cc|cccccc||c}
\hline
      & \multicolumn{1}{c|}{\bf \textsc{Chunk}} & \multicolumn{2}{c|}{\bf \textsc{DP}}   & \multicolumn{6}{c||}{\bf \textsc{SDP}}   & \multirow{2}{*}{\bf \textsc{Avg}}\\
\hhline{~||-|--|------||~}
      & CoNLL 2000         & UAS & LAS  & DM-ID & DM-OOD & PAS-ID & PAS-OOD & PSD-ID & PSD-OOD &           \\
\hline\hline
\bf \textsc{All}    & 96.7    & 96.7     & 95.1 & 94.3  & 90.8   & \textbf{94.6}   & 92.9    & 82.4   & 81.7    & 85.3      \\
\bf \textsc{Random} & 96.7    & 96.8    & 95.2 & 94.4  & 90.8   & \textbf{94.6}   & 93.0    & 82.3   & 81.8    & 85.7      \\
\bf \textsc{ACE}    & \textbf{96.8} & \textbf{96.9}        & \textbf{95.3} & \textbf{94.5}  & \textbf{90.9}   & 94.5   & \textbf{93.1}    & \textbf{82.5}   & \textbf{82.1}    & \textbf{86.2}     \\
\hlineB{4}
\end{tabular}
\caption{Comparison with concatenating all embeddings and random search baselines on 6 tasks.}
\label{tab:baseline}
\end{table*}



\section{Experiments}
We use ISO 639-1 language codes to represent languages in the table\footnote{\url{https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes}}.

\subsection{Datasets and Configurations}
\label{sec:datasets}
To show ACE's effectiveness, we conduct extensive experiments on a variety of structured prediction tasks varying from syntactic tasks to semantic tasks. The tasks are named entity recognition (NER), Part-Of-Speech (POS) tagging, Chunking, Aspect Extraction (AE), Syntactic Dependency Parsing (DP) and Semantic Dependency Parsing (SDP).
The details of the 6 structured prediction tasks in our experiments are shown in below:
\begin{itemize}[leftmargin=*]
    \item {\bf NER}: We use the corpora of 4 languages from the CoNLL 2002 and 2003 shared task \citep{tjong-kim-sang-2002-introduction,tjong-kim-sang-de-meulder-2003-introduction} with standard split.
    \item {\bf POS Tagging}: We use three datasets, Ritter11-T-POS \citep{ritter-etal-2011-named}, ARK-Twitter \citep{gimpel-etal-2011-part,owoputi-etal-2013-improved} and Tweebank-v2 \citep{liu-etal-2018-parsing} datasets (Ritter, ARK and TB-v2 in simplification). We follow the dataset split of \citet{nguyen2020bertweet}.
    \item {\bf Chunking}: We use CoNLL 2000 \citep{tjong-kim-sang-buchholz-2000-introduction} for chunking. Since there is no standard development set for CoNLL 2000 dataset, we split 10\% of the training data as the development set.
    \item {\bf Aspect Extraction}: Aspect extraction is a subtask of aspect-based sentiment analysis \citep{pontiki-etal-2014-semeval,pontiki-etal-2015-semeval,pontiki-etal-2016-semeval}. The datasets are from the laptop and restaurant domain of SemEval 14, restaurant domain of SemEval 15 and restaurant domain of  SemEval 16 shared task (14Lap, 14Res, 15Res and 16Res in short). Additionally, we use another 4 languages in the restaurant domain of SemEval 16 to test our approach in multiple languages. We randomly split 10\% of the training data as the development set following \citet{li-etal-2019-exploiting}.
    \item {\bf Syntactic Dependency Parsing}: We use Penn Tree Bank (PTB) 3.0 with the same dataset pre-processing as \citep{ma-etal-2018-stack}.
    \item {\bf Semantic Dependency Parsing}: We use DM, PAS and PSD datasets for semantic dependency parsing \citep{oepensemeval} for the SemEval 2015 shared task \citep{oepen2015semeval}. The three datasets have the same sentences but with different formalisms. We use the standard split for SDP. In the split, there are in-domain test sets and out-of-domain test sets for each dataset.
\end{itemize}
Among these tasks, NER, POS tagging, chunking and aspect extraction are sequence-structured outputs while dependency parsing and semantic dependency parsing are the graph-structured outputs. POS Tagging, chunking and DP are syntactic structured prediction tasks while NER, AE, SDP are semantic structured prediction tasks. 


We train the controller for  steps and save the task model with the highest accuracy on the development set as the final model for testing. Please refer to Appendix \ref{app:detail} for more details of other settings.

\subsection{Embeddings}
\paragraph{Basic Settings:} For the candidates of embeddings on English datasets, we use the language-specific model for ELMo, Flair, base BERT, GloVe word embeddings, fastText word embeddings, non-contextual character embeddings \citep{lample-etal-2016-neural}, multilingual Flair (M-Flair), M-BERT and XLM-R embeddings. The size of the search space in our experiments is \footnote{Flair embeddings have two models (forward and backward) for each language.}. For language-specific models of other languages, please refer to Appendix \ref{sec:embed} for more details. In AE, there is no available Russian-specific BERT, Flair and ELMo embeddings and there is no available Turkish-specific Flair and ELMo embeddings. We use the corresponding English embeddings instead so that the search spaces of these datasets are almost identical to those of the other datasets. All embeddings are fixed during training except that the character embeddings are trained over the task. The empirical results are reported in Section \ref{sec:exp:base}.

\paragraph{Embedding Fine-tuning:} A usual approach to get better accuracy is fine-tuning transformer-based embeddings. In sequence labeling, most of the work follows the fine-tuning pipeline of BERT that connects the BERT model with a linear layer for word-level classification. 
However, when multiple embeddings are concatenated, fine-tuning a specific group of embeddings becomes difficult because of complicated hyper-parameter settings and massive GPU memory consumption. 
To alleviate this problem, we first fine-tune the transformer-based embeddings over the task and then concatenate these embeddings together with other embeddings in the basic setting to apply ACE. The empirical results are reported in Section \ref{sec:exp:finetune}.






\subsection{Results}
We use the following abbreviations in our experiments: \textbf{UAS}: Unlabeled Attachment Score; \textbf{LAS}: Labeled Attachment Score; \textbf{ID}: In-domain test set; \textbf{OOD}: Out-of-domain test set. We use language codes for languages in NER and AE.

\subsubsection{Comparison With Baselines} \label{sec:exp:base}
To show the effectiveness of our approach, we compare our approach with two strong baselines. For the first one, we let the task model learn by itself the contribution of each embedding candidate that is helpful to the task. We set  to all-ones (i.e., the concatenation of all the embeddings) and train the task model ({\tt All}). The linear layer weight  in Eq. \ref{eq:linear} reflects the contribution of each candidate. For the second one, we use the random search ({\tt Random}), a strong baseline in NAS \citep{li2020random}. For {\tt Random}, we run the same maximum iteration as in ACE. For the experiments, we report the averaged accuracy of 3 runs. Table \ref{tab:baseline} shows that ACE outperforms both baselines in 6 tasks over 23 test sets with only two exceptions. Comparing {\tt Random} with {\tt All}, {\tt Random} outperforms {\tt All} by 0.4 on average and surpasses the accuracy of {\tt All} on 14 out of 23 test sets, which shows that concatenating all embeddings may not be the best solution to most structured prediction tasks. 
In general, searching for the concatenation for the word representation is essential in most cases, and our search design can usually lead to better results compared to both of the baselines.



\begin{table*}[t]
\small
\centering
\begin{tabular}{l|ccccc||l|ccc}
\hlineB{4}
 & \multicolumn{5}{c||}{\bf \textsc{NER}} &       &\multicolumn{3}{c}{\bf \textsc{POS}}\\
 \hhline{~|-----||~|---}
  & de   & de & en   & es   & nl   & & Ritter & ARK  & TB-v2 \\
\hline\hline
\citet{baevski-etal-2019-cloze}      & -    & -    & 93.5 & -    & -    & \citet{owoputi-etal-2013-improved} & 90.4   & 93.2 & 94.6  \\
\citet{strakova-etal-2019-neural}   & 85.1 & -    & 93.4 & 88.8 & 92.7     & \citet{gui-etal-2017-part}          & 90.9   & -    & 92.8  \\
\citet{yu-etal-2020-named} & 86.4 & 90.3 & 93.5 & 90.3 & 93.7 & \citet{gui-etal-2018-transferring} & 91.2   & 92.4 & -     \\
\citet{yamada-etal-2020-luke} & - & - & 94.3 & - & - & \citet{nguyen2020bertweet}         & 90.1   & 94.1 & 95.2  \\
\hline
XLM-R+Fine-tune & 87.7    & 91.4 & 94.1 & 89.3    & 95.3     & XLM-R+Fine-tune    & 92.3   & 93.7 & 95.4 \\
ACE+Fine-tune & \textbf{88.3} & \textbf{91.7} & \textbf{94.6} & \textbf{95.9} & \textbf{95.7} & ACE+Fine-tune  & \textbf{93.4}   & \textbf{94.4} & \textbf{95.8} \\
\hlineB{4}
\end{tabular}
\caption{Comparison with state-of-the-art approaches in NER and POS tagging. : Models are trained on both train and development set.}
\label{tab:ner_pos}
\end{table*}


\begin{table*}[t]
\small
\centering
\setlength\tabcolsep{4pt}
\begin{tabular}{l|c||l|cccccccc}
\hlineB{4}
 & \multicolumn{1}{c||}{\bf \textsc{Chunk}} & &\multicolumn{8}{c}{\bf \textsc{AE}}        \\
\hhline{~|-||~|--------}
 &  CoNLL 2000 & & 14Lap  & 14Res & 15Res & 16Res & es   & nl   & ru   & tr   \\
\hline\hline
\citet{akbik-etal-2018-contextual}  & 96.7    & \citet{xu-etal-2018-double} & 84.2   & 84.6 & 72.0  & 75.4  & -    & -    & -    & -    \\
\citet{clark-etal-2018-semi}        & 97.0    & \citet{xu-etal-2019-bert}          & 84.3   & -    & -     & 78.0  & -    & -    & -    & -    \\
\citet{liu-etal-2019-gcdt}              & \textbf{97.3}    & \citet{wang-etal-2020-structure}   & -      & -    & -     & 72.8  & 74.3 & 72.9 & 71.8 & 59.3 \\
\citet{chen-etal-2020-seqvat} & 95.5       & \citet{wei-etal-2020-dont}         & 82.7   & 87.1 & 72.7  & 77.7  & -    & -    & -    & -    \\
\hline
XLM-R+Fine-tune  & 97.0 & XLM-R+Fine-tune & 85.9  & 90.5  & 76.4  & 78.9  & 77.0 & 77.6 & 77.7 & 74.1  \\
ACE+Fine-tune  &  \textbf{97.3}    & ACE+Fine-tune   & \textbf{87.4}   & \textbf{92.0} & \textbf{80.3}  & \textbf{81.3}  & \textbf{79.9} & \textbf{80.5} & \textbf{79.4} & \textbf{81.9} \\
\hlineB{4}
\end{tabular}
\caption{Comparison with state-of-the-art approaches in chunking and aspect extraction. : We report the results reproduced by \citet{wei-etal-2020-dont}.}
\label{tab:chunk_ae}
\end{table*}

\begin{table*}[t]
\small
\centering
\begin{tabular}{l|cc||l|cccccc}
\hlineB{4}
& \multicolumn{2}{c||}{\bf \textsc{DP}}     &            & \multicolumn{6}{c}{\bf \textsc{SDP}}       \\
\hhline{~|--||~|------}
& \multicolumn{2}{c||}{\bf \textsc{PTB}}     &            & \multicolumn{2}{c}{\bf \textsc{DM}} & \multicolumn{2}{c}{\bf \textsc{PAS}} & \multicolumn{2}{c}{\bf \textsc{PSD}}       \\
     & UAS     & LAS  &            & ID   & OOD & ID  & OOD & ID  & OOD \\
\hline\hline
\citet{zhou-zhao-2019-head}            & 97.2    & 95.7 &\citet{he2019establishing}      &  94.6 & 90.8    & 96.1 & 94.4     & 86.8 & 79.5  \\
\hhline{~|~~||-|------}
\citet{mrini-etal-2020-rethinking} & 97.4 & 96.3 &  D \& M \shortcite{dozat-manning-2018-simpler} &93.7 & 88.9    & 93.9 & 90.6     & 81.0 & 79.4  \\
\hhline{-|--||~|~~~~~~}
\citet{li2020global}       & 96.6    & 94.8 &    \citet{wang-etal-2019-second}  & 94.0 & 89.7    & 94.1 & 91.3     & 81.4 & 79.6      \\
 \citet{zhang-etal-2020-efficient}       & 96.1    & 94.5 &      \citet{jia-etal-2020-semi}  &93.6 & 89.1    & - & -    & - & -  \\
  \citet{wang-tu-2020-second} & 96.9    & 95.3& F \& G \shortcite{fernandez-gonzalez-gomez-rodriguez-2020-transition} & 94.4 & 91.0    & 95.1 & 93.4     & 82.6 & 82.0     \\
\hline
XLNET+Fine-tune           & 97.0        & 95.6   &XLNet+Fine-tune    & 94.2       & 90.6      & 94.8       & 93.4       & 82.7       & 81.8\\
ACE+Fine-tune  & \textbf{97.2}    & \textbf{95.8} & ACE+Fine-tune  & \textbf{95.6} & \textbf{92.6}    & \textbf{95.8} & \textbf{94.6}     & \textbf{83.8} & \textbf{83.4}    \\
\hlineB{4}
\end{tabular}
\caption{Comparison with state-of-the-art approaches in DP and SDP. : For reference, they additionally used constituency dependencies in training. We also find that the PTB dataset used by \citet{mrini-etal-2020-rethinking} is not identical to the dataset in previous work such as \citet{zhang-etal-2020-efficient} and \citet{wang-tu-2020-second}. : For reference, we confirmed with the authors of \citet{he2019establishing} that they used a different data pre-processing script with previous work.}.
\label{tab:dp_sdp}
\end{table*}


\subsubsection{Comparison With State-of-the-Art approaches} \label{sec:exp:finetune}
As we have shown, ACE has an advantage in searching for better embedding concatenations. We further show that ACE is competitive or even stronger than state-of-the-art approaches. We additionally use XLNet \citep{yang2019xlnet} and RoBERTa as the candidates of ACE.  In some tasks, we have several additional settings to better compare with previous work. In NER, we also conduct a comparison on the revised version of German datasets in the CoNLL 2006 shared task \citep{buchholz-marsi-2006-conll}. Recent work such as \citet{yu-etal-2020-named} and \citet{yamada-etal-2020-luke} utilizes document contexts in the datasets. We follow their work and extract document embeddings for the transformer-based embeddings. Specifically, we follow the fine-tune process of \citet{yamada-etal-2020-luke} to fine-tune the transformer-based embeddings over the document except for BERT and M-BERT embeddings. For BERT and M-BERT, we follow the document extraction process of \citet{yu-etal-2020-named} because we find that the model with such document embeddings is significantly stronger than the model trained with the fine-tuning process of \citet{yamada-etal-2020-luke}. In SDP, the state-of-the-art approaches used POS tags and lemmas as additional word features to the network. We add these two features to the embedding candidates and train the embeddings together with the task. We use the fine-tuned transformer-based embeddings on each task instead of the pretrained version of these embeddings as the candidates.\footnote{Please refer to Appendix for more details about the embeddings.}

We additionally compare with fine-tuned XLM-R model for NER, POS tagging, chunking and AE, and compare with fine-tuned XLNet model for DP and SDP, which are strong fine-tuned models in most of the experiments. Results are shown in Table \ref{tab:ner_pos}, \ref{tab:chunk_ae}, \ref{tab:dp_sdp}.
Results show that ACE with fine-tuned embeddings achieves state-of-the-art performance in all test sets, which shows that finding a good embedding concatenation helps structured prediction tasks. We also find that ACE is stronger than the fine-tuned models, which shows the effectiveness of concatenating the fine-tuned embeddings\footnote{We compare ACE with other fine-tuned embeddings in Appendix.}.



\begin{filecontents}{max_dev.dat}
episode	ACE	Random
1	96.2	95.96666667
2	96.21	96.00333333
3	96.37666667	96.00333333
4	96.37666667	96.05
5	96.39	96.05
6	96.39	96.05
7	96.39333333	96.05
8	96.39333333	96.17666667
9	96.40333333	96.18
10	96.43666667	96.18
11	96.52666667	96.23333333
12	96.52666667	96.23333333
13	96.52666667	96.23333333
14	96.52666667	96.28666667
15	96.52666667	96.28666667
16	96.53666667	96.28666667
17	96.53666667	96.3
18	96.53666667	96.35666667
19	96.55333333	96.35666667
20	96.55333333	96.35666667
21	96.59	96.44
22	96.61	96.44
23	96.64	96.44
24	96.64	96.44
25	96.64	96.44
26	96.64	96.44
27	96.64333333	96.44
28	96.64333333	96.45
29	96.64333333	96.45
30	96.64333333	96.45
\end{filecontents}

\begin{filecontents}{avg_dev.dat}
episode	ACE	Random
1	96.2	95.96666667
2	95.82666667	93.76333333
3	95.95333333	93.82333333
4	95.75666667	95.99666667
5	95.83333333	94.23333333
6	95.39	95.95333333
7	96.16333333	95.32
8	95.70333333	94.94666667
9	95.86	95.82333333
10	96.18666667	95.07333333
11	96.41666667	95.85666667
12	95.57	92.43
13	96.19	95.75333333
14	96.42666667	96.18666667
15	96.3	95.67333333
16	96.46	95.46
17	96.2	95.86666667
18	96.46	96.12333333
19	96.45333333	94.70333333
20	96.51	96.08
21	96.55333333	96.23666667
22	96.44	93.74
23	96.49	95.50333333
24	96.46333333	96.29
25	96.49666667	94.07333333
26	96.54666667	93.87
27	96.6	94.09333333
28	96.55	96.12666667
29	96.56666667	96.06666667
30	96.51333333	95.07333333
\end{filecontents}


\begin{figure*}[t!]
\begin{minipage}{1.0\linewidth}
\centering
\begin{tikzpicture}
\begin{axis}[
        xshift=-6cm,
name=ner,
width=0.5\textwidth,
        height=0.3\textwidth,
ylabel=Best Accuracy,
        legend columns=2, 
        legend pos=south east,
        legend style={font=\small},
        tick label style={font=\small},
ylabel style={font=\small,yshift=-0.2cm},
        ]
        \addplot[red] table[x=episode,y=ACE] {max_dev.dat};
        \addplot[blue,dashed] table[x=episode,y=Random] {max_dev.dat};
        \legend{ACE, Random}
    \end{axis}
    \begin{axis}[
at={(ner.south west)},
        xshift=8.0cm,
width=0.5\textwidth,
        height=0.3\textwidth,
ylabel=Sample Accuracy,
        legend columns=2, 
        legend pos=south east,
        legend style={font=\small},
        tick label style={font=\small},
ytick={91,92,93,94,95,96},
        ylabel style={font=\small,yshift=-0.5cm},
        ]
        \addplot[red] table[x=episode,y=ACE] {avg_dev.dat};
        \addplot[blue,dashed] table[x=episode,y=Random] {avg_dev.dat};
        \legend{ACE, Random}
    \end{axis}
\end{tikzpicture}
\caption{Comparing the efficiency of random search ({\tt Random}) and ACE. The x-axis is the number of time steps. The left y-axis is the averaged best validation accuracy on CoNLL English NER dataset. The right y-axis is the averaged validation accuracy of the current selection.}
\label{fig:dev_curve}
\end{minipage}
\end{figure*}



\section{Analysis}

\subsection{Efficiency of Search Methods}
To show how efficient our approach is compared with the random search algorithm, we compare the algorithm in two aspects on CoNLL English NER dataset. The first aspect is the best development accuracy during training. The left part of Figure \ref{fig:dev_curve} shows that ACE is consistently stronger than the random search algorithm in this task. The second aspect is the searched concatenation at each time step. The right part of Figure \ref{fig:dev_curve} shows that the accuracy of ACE gradually increases and gets stable when more concatenations are sampled.


\subsection{Ablation Study on Reward Function Design}
\label{sec:ablation}
To show the effectiveness of the designed reward function, we compare our reward function (Eq. \ref{eq:reward}) with the reward function without discount factor (Eq. \ref{eq:reward_a}) and the traditional reward function (reward term in Eq. \ref{eq:rl}). We sample 2000 training sentences on CoNLL English NER dataset for faster training and train the controller for  steps. Table \ref{tab:ablation} shows that both the discount factor and the binary vector  for the task are helpful in both development and test datasets. 
\begin{table}[h!]
\small
\centering
\begin{tabular}{l||cc}
\hlineB{4}
 & \bf \textsc{Dev} &   \bf \textsc{Test}\\
\hline
ACE & \textbf{93.18} & \textbf{90.00}\\
No discount (Eq. \ref{eq:reward_a}) &  92.98 & 89.90\\
Simple (Eq. \ref{eq:rl}) & 92.89 & 89.82 \\
\hlineB{4}
\end{tabular}
\caption{Comparison of reward functions.}
\label{tab:ablation}
\end{table}

\begin{table}[!ht]
\small
\centering
\setlength\tabcolsep{1.2pt}
\begin{tabular}{l||cccccccc}
\hlineB{4}
             & \multirow{2}{*}{\bf \textsc{NER}}  & \multirow{2}{*}{\bf \textsc{POS}}  &  \multirow{2}{*}{\bf \textsc{AE}}   & \multirow{2}{*}{\bf \textsc{CHK}} &\multicolumn{2}{c}{\bf \textsc{DP}} & \multicolumn{2}{c}{\bf \textsc{SDP}}  \\
&  &  & &   & UAS & LAS & ID  & OOD \\
\hline
\hline
All          & 92.4 & 90.6 & 73.2 & 96.7  & 96.7   & 95.1   & 94.3 & 90.8    \\
Random          & 92.6 & 91.3  & 74.7 & 96.7 & 96.8   & 95.2   & 94.4 & 90.8    \\
ACE          & \textbf{93.0} & \textbf{91.7} & \textbf{75.6}& \textbf{96.8}   & \textbf{96.9}   & \textbf{95.3}   & \textbf{94.5} & \textbf{90.9}   \\
All+Weight & 92.7  & 90.4 & 73.7 & 96.7 & 96.7 & 95.1 & 94.3 & 90.7 \\ 
Ensemble & 92.2 & 90.6  & 68.1 & 96.5 & 96.1   &94.3   & 94.1 & 90.3    \\ 
Ensemble & 92.2 & 90.8   & 70.2 & 96.7 & 96.8   &95.2   & 94.3 & 90.7    \\
\hline
Ensemble & 92.7 & 91.4  & 73.9 & 96.7 & 96.8   &95.2   & 94.4 & 90.8    \\
\hlineB{4}
\end{tabular}
\caption{A comparison among \texttt{All}, \texttt{Random}, ACE, \texttt{All+Weight} and \texttt{Ensemble}. \textbf{\sc CHK}: chunking.}
\label{tab:ensemble}
\end{table}




\subsection{Comparison with Embedding Weighting \& Ensemble Approaches}
\label{sec:ensemble}
We compare ACE with two more approaches to further show the effectiveness of ACE. One is a variant of \texttt{All}, which uses a weighting parameter  passing through a sigmoid function to weight each embedding candidate. Such an approach can explicitly learn the weight of each embedding in training instead of a binary mask. We call this approach \texttt{All+Weight}. Another one is model ensemble, which trains the task model with each embedding candidate individually and uses the trained models to make joint prediction on the test set. We use voting for ensemble as it is simple and fast. For sequence labeling tasks, the models vote for the predicted label at each position. For DP, the models vote for the tree of each sentence. For SDP, the models vote for each potential labeled arc. We use the confidence of model predictions to break ties if there are more than one agreement with the same counts. We call this approach \texttt{Ensemble}. One of the benefits of voting is that it combines the predictions of the task models efficiently without any training process. We can search all possible  model ensembles in a short period of time through caching the outputs of the models. Therefore, we search for the best ensemble of models on the development set and then evaluate the best ensemble on the test set (\texttt{Ensemble}). Moreover, we additionally search for the best ensemble on the test set for reference (\texttt{Ensemble}), which is the upper bound of the approach. We use the same setting as in Section \ref{sec:exp:base} and select one of the datasets from each task. For NER, POS tagging, AE, and SDP, we use CoNLL 2003 English, Ritter, 16Res, and DM datasets, respectively. The results are shown in Table \ref{tab:ensemble}. Empirical results show that ACE outperforms all the settings of these approaches and even \texttt{Ensemble}, which shows the effectiveness of ACE and the limitation of ensemble models. \texttt{All}, \texttt{All+Weight} and \texttt{Ensemble} are competitive in most of the cases and there is no clear winner of these approaches on all the datasets. These results show the strength of embedding concatenation. Concatenating the embeddings incorporates information from all the embeddings and forms stronger word representations for the task model, while in model ensemble, it is difficult for the individual task models to affect each other.


\section{Discussion: Practical Usability of ACE}
Concatenating multiple embeddings is a commonly used approach to improve accuracy of structured prediction. However, such approaches can be computationally costly as multiple language models are used as input. ACE is more practical than concatenating all embeddings as it can remove those embeddings that are not very useful in the concatenation. Moreover, ACE models can be used to guide the training of weaker models through techniques such as knowledge distillation in structured prediction \cite{kim-rush-2016-sequence,kuncoro-etal-2016-distilling,wang-etal-2020-structure,wang2020structural}, leading to models that are both stronger and faster. 


\section{Conclusion}
In this paper, we propose Automated Concatenation of Embeddings, which automatically searches for better embedding concatenation for structured prediction tasks. We design a simple search space and use the reinforcement learning with a novel reward function to efficiently guide the controller to search for better embedding concatenations. We take the change of embedding concatenations into the reward function design and show that our new reward function is stronger than the simpler ones. Results show that ACE outperforms strong baselines. Together with fine-tuned embeddings, ACE achieves state-of-the-art performance in 6 tasks over 21 datasets.

\subsubsection*{Acknowledgments}
This work was supported by the National Natural Science Foundation of China (61976139) and by Alibaba Group through Alibaba Innovative Research Program. We thank Chengyue Jiang for his comments and suggestions on writing. 



\bibliographystyle{acl_natbib}
\bibliography{anthology,acl2021}
\appendix
\section{Detailed Configurations}
\label{app:detail}
\paragraph{Evaluation}
To evaluate our models, We use F1 score to evaluate NER, Chunking and AE, use accuracy to evaluate POS Tagging, use unlabeled attachment score (UAS) and labeled attachment score (LAS) to evaluate DP, and use labeled F1 score to evaluate SDP. 

\paragraph{Task Models and Controller}
\label{sec:models}
For sequence-structured tasks (i.e., NER, POS tagging, chunking, aspect extraction), we use a batch size of  sentences and an SGD optimizer with a learning rate of . We anneal the learning rate by  when there is no accuracy improvement on the development set for 5 epochs. We set the maximum training epoch to . For graph-structured tasks (i.e., DP and SDP), we use Adam \citep{kingma2014adam} to optimize the model with a learning rate of . We anneal the learning rate by  for every  iterations following \citet{dozat2016deep}. We set the maximum training epoch to . For DP, we run the maximum spanning tree \cite{mcdonald-etal-2005-non} algorithm to output valid trees in testing. We fix the hyper-parameters of the task models. 

We tune the learning rate for the controller among  and the discount factor among  on the same dataset in Section \ref{sec:ablation}. We search for the hyper-parameter through grid search and find a learning rate of  and a discount factor of  performs the best on the development set. The controller's parameters are initialized to all  so that each candidate is selected evenly in the first two time steps. 
We use Stochastic Gradient Descent (SGD) to optimize the controller. 
The training time depends on the task and dataset size. Take the CoNLL English NER dataset as an example. It takes  GPU hours to train the controller for  steps on a single Tesla P100 GPU, which is an acceptable training time in practice.



\paragraph{Sources of Embeddings}
\label{sec:embed}
The sources of the embeddings that we used are listed in Table \ref{tab:embeddings}. 
\begin{table*}[!ht]
\tiny
\centering
\begin{tabular}{l|l|l}
\hlineB{4}
\bf \textsc{Embedding} & \bf \textsc{Resource} & \bf \textsc{URL}\\
\hline
GloVe & \citet{pennington2014glove} & \url{nlp.stanford.edu/projects/glove}\\
fastText & \citet{bojanowski2017enriching} & \url{github.com/facebookresearch/fastText}\\
ELMo & \citet{peters-etal-2018-deep} & \url{github.com/allenai/allennlp}\\
ELMo (Other languages) & \citet{schuster-etal-2019-cross} & \url{github.com/TalSchuster/CrossLingualContextualEmb}\\
BERT & \citet{devlin-etal-2019-bert} & \url{huggingface.co/bert-base-cased}\\
M-BERT & \citet{devlin-etal-2019-bert} & \url{huggingface.co/bert-base-multilingual-cased}\\
BERT (Dutch) & wietsedv & \url{huggingface.co/wietsedv/bert-base-dutch-cased}\\
BERT (German) & dbmdz & \url{huggingface.co/bert-base-german-dbmdz-cased}\\
BERT (Spanish) & dccuchile & \url{huggingface.co/dccuchile/bert-base-spanish-wwm-cased}\\
BERT (Turkish) & dbmdz & \url{huggingface.co/dbmdz/bert-base-turkish-cased}\\
XLM-R & \citet{conneau-etal-2020-unsupervised} & \url{huggingface.co/xlm-roberta-large}\\
RoBERTa & \citet{liu2019roberta} & \url{huggingface.co/roberta-large}\\
XLNet & \citet{yang2019xlnet} & \url{huggingface.co/xlnet-large-cased}\\
\hlineB{4}
\end{tabular}
\caption{The embeddings we used in our experiments. The URL is where we downloaded the embeddings. }
\label{tab:embeddings}
\end{table*}

\begin{table}[t!]
\small
\centering
\setlength\tabcolsep{4pt}
\begin{tabular}{l|ccccc}
\hlineB{4}
  & de   & de & en   & es   & nl \\
\hline\hline
All+sent & 86.8 & 90.1 & 93.3 & 90.0 & 94.4 \\
ACE+sent & 87.1 & 90.5 & 93.6 & 92.4 & 94.6 \\
\hline
BERT (\citeyear{devlin-etal-2019-bert})    &  -    & - & 92.8 & -    & -\\
\citet{akbik-etal-2019-pooled}     &  -    & 88.3 & 93.2 & -    & 90.4\\
\citet{yu-etal-2020-named} & 86.4 & 90.3 & 93.5 & 90.3 & 94.7 \\
\citet{yamada-etal-2020-luke} & - & - & 94.3 & - & - \\ 
\citet{luoma-pyysalo-2020-exploring} & 87.3 & - & 93.7 & 88.3 & 93.5 \\
\citet{wang2021improving} & - & - & 93.9 & - & -  \\
All+doc & 87.5 & 90.8 & 94.0 & 90.7 & 93.7 \\
ACE+doc &  \textbf{88.3} & \textbf{91.7} & \textbf{94.6} & \textbf{95.9} & \textbf{95.7}\\
\hlineB{4}
\end{tabular}
\caption{Comparison of models with and without document contexts on NER. +sent/+doc: models with sentence-/document-level embeddings.}
\label{tab:document}
\end{table}


\section{Additional Analysis}


\subsection{Document-Level and Sentence-Level Representations}
Recently, models with document-level word representations extracted from transformer-based embeddings significantly outperform models with sentence-level word representations in NER \citep{devlin-etal-2019-bert,yu-etal-2020-named,yamada-etal-2020-luke}. However, there are a lot of application scenarios that document contexts are unavailable. We replace the document-level word representations from transformer-based embeddings (i.e., XLM-R and BERT embeddings) with the sentence-level word representations. Results are shown in Table \ref{tab:document}. We report the test results of \texttt{All} to show how the gap between ACE and \texttt{All} changes with different kinds of representations. We report the test accuracy of the models with the highest development accuracy following \citet{yamada-etal-2020-luke} for a fair comparison. Empirical results show that the document-level representations can significantly improve the accuracy of ACE. Comparing with models with sentence-level representations, the averaged accuracy gap between ACE and \texttt{All} is enhanced from 0.7 to 1.7 with document-level representations, which shows that the advantage of ACE becomes stronger with document-level representations.


\subsection{Fine-tuned Models Versus ACE}
\label{sec:finetune}
To fine-tune the embeddings, we use AdamW \citep{loshchilov2018decoupled} optimizer with a learning rate of  and trained the contextualized embeddings with the task for 10 epochs. We use a batch size of 32 for BERT, M-BERT and use a batch size of 4 for XLM-R, RoBERTa and XLNet. A comparison between ACE and the fine-tuned embeddings that we used in ACE is shown in Table \ref{tab:ft_vs_ace_0}, \ref{tab:ft_vs_ace_1}. Results show that ACE can further improve the accuracy of fine-tuned models. 


\subsection{Retraining}
Most of the work \citep{zoph2016neural,zoph2018learning,pham2018efficient,so2019evolved,zhu2020autotrans} in NAS retrains the searched neural architecture from scratch so that the hyper-parameters of the searched model can be modified or trained on larger datasets. To show whether our searched embedding concatenation is helpful to the task, we retrain the task model with the embedding concatenations on the same dataset from scratch. For the experiment, we use the same dataset settings as in Section \ref{sec:exp:base}. We train the searched embedding concatenation of each run from ACE 3 times (therefore, 9 runs for each dataset). 

Table \ref{tab:direct} shows the comparison between retrained models with the searched embedding concatenation from ACE and \texttt{All}. The results show that the retrained models are competitive with ACE in SDP and in chunking. However, in another three tasks, the retrained models perform inferior to ACE. The possible reason is that the model at each step is initialized by the trained model of previous step. The retrained models outperform \texttt{All} in all tasks, which shows the effectiveness of the searched embedding concatenations. 


\subsection{Effect of Embeddings in the Searched Embedding Concatenations}
There is no clear conclusion on what concatenation of embeddings is helpful to most of the tasks. 
We analyze the best searched embedding concatenations by ACE over different structured outputs, semantic/syntactic type, and monolingual/multilingual tasks. 
The percentage of each embedding selected by the best concatenations from all experiments of ACE are shown in Table \ref{tab:selection}. 
The best embedding concatenation varies over the output structure, syntactic/semantic level of understanding, and the language. 
The experimental results show that it is essential to select embeddings for each kind of task separately. 
However, we also find that the embeddings are strong in specific settings. In comparison to the sequence-structured and graph-structured tasks, we find that M-BERT and ELMo are only frequently selected in sequence-structured tasks while XLM-R embeddings are always selected in graph-structured tasks. 
For Flair embeddings, the forward and backward model are evenly selected. 
We suspect one direction of Flair embeddings is strong enough. 
Therefore concatenating the embeddings from two directions together cannot further improve the accuracy. 
For non-contextualized embeddings, pretrained word embeddings are frequently selected in sequence-structured tasks, and character embeddings are not.
When we dig deeper into the semantic and syntactic type of these two structured outputs, we find that in all best concatenations, BERT embeddings are selected in all syntactic sequence-structured tasks, and Flair, M-Flair, word, and XLM-R embeddings are selected in syntactic graph-structured tasks. 
In multilingual tasks, all best concatenations in multilingual NER tasks select M-BERT embeddings while M-BERT is rarely selected in multilingual AE tasks. 
The monolingual Flair embeddings are always selected in NER tasks, and XLM-R is more frequently selected in multilingual tasks than monolingual sequence-structured tasks (\textbf{SS}).


\begin{table*}[!ht]
\small
\centering
\begin{tabular}{l||ccccc|ccc}
\hlineB{4}
& \multicolumn{5}{c|}{NER}  & \multicolumn{3}{c}{POS}\\
\hhline{~||-----|---}
                & de   & de (Revised) & en   & es   & nl   & Ritter & ARK  & TB-v2 \\
\hline\hline
BERT+Fine-tune            & 76.9 & 79.4 & 89.2 & 83.3 & 83.8 & 91.2   & 91.7 & 94.4  \\
MBERT+Fine-tune           & 81.6 & 86.7 & 92.0 & 87.1 & 87.2 & 90.8   & 91.5 & 93.9  \\
XLM-R+Fine-tune & 87.7    & 91.4 & 94.1 & 89.3    & 95.3    & 92.3   & 93.7 & 95.4 \\
RoBERTa+Fine-tune & -    & - & 93.9 & -    & -    & 92.0   & 93.9 & 95.4 \\
XLNET+Fine-tune & -    & - & 93.6 & -    & -    & 88.4   & 92.4 & 94.4 \\
\hline
ACE+Fine-tune & \textbf{88.3} & \textbf{91.7} & \textbf{94.6} & \textbf{95.9} & \textbf{95.7} & \textbf{93.4}   & \textbf{94.4} & \textbf{95.8} \\
\hlineB{4}
\end{tabular}
\caption{A comparison between ACE and the fine-tuned embeddings that are used in ACE for NER and POS tagging.}
\label{tab:ft_vs_ace_0}
\end{table*}


\begin{table*}[!ht]
\small
\centering
\setlength\tabcolsep{4pt}
\begin{tabular}{l||c|cccccccc}
\hlineB{4}
 & \multicolumn{1}{c|}{Chunk} & \multicolumn{8}{c}{AE}  \\
\hhline{~||------|---}
                  & CoNLL 2000 & 14Lap & 14Res & 15Res & 16Res & es   & nl   & ru   & tr \\
\hline\hline
BERT+Fine-tune & 96.7 & 81.2  & 87.7  & 71.8  & 73.9  & 76.9 & 73.1 & 64.3 & 75.6   \\
MBERT+Fine-tune  & 96.6 & 83.5  & 85.0  & 69.5  & 73.6  & 74.5 & 72.6 & 71.6 & 58.8  \\
XLM-R+Fine-tune  & 97.0 & 85.9  & 90.5  & 76.4  & 78.9  & 77.0 & 77.6 & 77.7 & 74.1  \\
RoBERTa+Fine-tune  & 97.2 & 83.9  & 90.2  & 78.5  & 80.7  & - & - & - & -  \\
XLNET+Fine-tune  & 97.1 & 84.5  & 88.9  & 72.8  & 73.4  & - & - & - & -  \\
\hline
ACE+Fine-tune  &  \textbf{97.3}    & \textbf{87.4}   & \textbf{92.0} & \textbf{80.3}  & \textbf{81.3}  & \textbf{79.9} & \textbf{80.5} & \textbf{79.4} & \textbf{81.9} \\
\hlineB{4}
\end{tabular}
\caption{A comparison between ACE and the fine-tuned embeddings we used in ACE for chunking and AE.}
\label{tab:ft_vs_ace_1}
\end{table*}


\begin{table*}[!ht]
\small
\centering
\begin{tabular}{l||cc|ccccccccc}
\hlineB{4}
                & \multicolumn{2}{c|}{DP}  & \multicolumn{6}{c}{SDP}\\
\hhline{~||--|------}
                & \multicolumn{2}{c|}{PTB} & \multicolumn{2}{c}{DM} & \multicolumn{2}{c}{PAS} & \multicolumn{2}{c}{PSD} \\
                & UAS         & LAS       & ID         & OOD       & ID         & OOD        & ID         & OOD        \\
\hline\hline
BERT+Fine-tune            & 96.6        & 95.1      & 94.4       & 91.4      & 94.4       & 93.0       & 82.0       & 81.3       \\
MBERT+Fine-tune           & 96.5        & 94.9      & 93.9       & 90.4      & 93.9       & 92.1       & 81.2       & 80.0       \\
XLM-R+Fine-tune & 96.7        & 95.4      & 94.2       & 90.4      & 94.6       & 93.2       & 82.9       & 81.7       \\
RoBERTa+Fine-tune & 96.9        & 95.6      & 93.0       & 89.3      & 94.3       & 92.8       & 82.0       & 80.6       \\
XLNET+Fine-tune           & 97.0        & 95.6      & 94.2       & 90.6      & 94.8       & 93.4       & 82.7       & 81.8\\
\hline
ACE+Fine-tune  & \textbf{97.2}    & \textbf{95.7} & \textbf{95.6} & \textbf{92.6}    & \textbf{95.8} & \textbf{94.6}     & \textbf{83.8} & \textbf{83.4}    \\
\hlineB{4}
\end{tabular}
\caption{A comparison between ACE and the fine-tuned embeddings that are used in ACE for DP and SDP.}
\label{tab:ft_vs_ace_2}
\end{table*}



\begin{table*}[!ht]
\small
\centering
\begin{tabular}{l||cccccccc}
\hlineB{4}
             & NER  & POS  & Chunk & AE   & DP-UAS & DP-LAS & SDP-ID  & SDP-OOD \\
\hline
\hline
All          & 92.4 & 90.6 & 96.7  & 73.2 & 96.7   & 95.1   & 94.3 & 90.8    \\
Retrain & 92.6 & 90.8 & \textbf{96.8}  & 73.6 & 96.8   &95.2   & \textbf{94.5} & \textbf{90.9}    \\
ACE          & \textbf{93.0} & \textbf{91.7} & \textbf{96.8}  & \textbf{75.6} & \textbf{96.9}   & \textbf{95.3}   & \textbf{94.5} & \textbf{90.9}   \\
\hlineB{4}
\end{tabular}
\caption{A comparison among retrained models, All and ACE. We use the one dataset for each task.}
\label{tab:direct}
\end{table*}


\begin{table*}[t!]
\small
\centering
\setlength\tabcolsep{2.2pt}
\begin{tabular}{l||cccccccccccc}
\hlineB{4}
          & BERT & M-BERT & Char & ELMo & F    & F-bw & F-fw & MF   & MF-bw & MF-fw & Word & XLM-R \\
\hline\hline
SS        & 0.81 & 0.74   & 0.37 & 0.85 & 0.70 & 0.48 & 0.59 & 0.78 & 0.59  & 0.41  & 0.81 & 0.70  \\
GS      & 0.75 & 0.17   & 0.50 & 0.25 & 0.83 & 0.75 & 0.42 & 0.83 & 0.58  & 0.58  & 0.50 & 1.00  \\
\hline
Sem. SS   & 0.67 & 0.73   & 0.40 & 0.80 & 0.60 & 0.40 & 0.53 & 0.87 & 0.60  & 0.53  & 0.80 & 0.60  \\
Syn. SS   & 1.00 & 0.75   & 0.33 & 0.92 & 0.83 & 0.58 & 0.67 & 0.67 & 0.58  & 0.25  & 0.83 & 0.83  \\
\hline
Sem. GS & 0.78 & 0.22   & 0.67 & 0.33 & 0.78 & 0.67 & 0.56 & 0.78 & 0.56  & 0.67  & 0.33 & 1.00  \\
Syn. GS & 0.67 & 0.00   & 0.00 & 0.00 & 1.00 & 1.00 & 0.00 & 1.00 & 0.67  & 0.33  & 1.00 & 1.00  \\
\hline
M-NER     & 0.67 & 1.00   & 0.56 & 0.83 & 1.00 & 0.78 & 1.00 & 0.89 & 0.78  & 0.44  & 0.78 & 0.89  \\
M-AE      & 1.00 & 0.33   & 0.75 & 0.33 & 0.58 & 0.42 & 0.42 & 0.75 & 0.25  & 0.75  & 0.50 & 0.92  \\
\hlineB{4}
\end{tabular}
\caption{The percentage of each embedding candidate selected in the best concatenations from ACE. \textbf{F} and  \textbf{MF} are monolingual and multilingual Flair embeddings. We count these two embeddings are selected if one of the forward/backward (\textbf{fw}/\textbf{bw}) direction of Flair is selected in the concatenation. We count the \textbf{Word} embedding is selected if one of the fastText/GloVe embeddings is selected. \textbf{SS}: sequence-structured tasks. \textbf{GS}: graph-structured tasks. \textbf{Sem.}: Semantic-level tasks. \textbf{Syn.}: Syntactic-level tasks. \textbf{M-NER}: Multilingual NER tasks. \textbf{M-AE}: Multilingual AE tasks. We only use English datasets in \textbf{SS} and \textbf{GS}. English datasets are removed for \textbf{M-NER} and \textbf{M-AE}.}
\label{tab:selection}
\end{table*}





\end{document}
