\documentclass[twocolumn]{svjour3}
\usepackage[boxed]{algorithm2e}
\usepackage{citesort,cite}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{url}
\usepackage{times,amsmath,amssymb,amsfonts,epsfig,graphicx}
\usepackage{enumerate}
\usepackage{stackrel}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{psfrag}
\usepackage{color}
\usepackage{comment}
\usepackage{framed}

\newcommand{\class}{{\textsc{Clash}}\xspace}

\newcommand{\vectornorm}[1]{\|#1\|}
\newcommand{\vectornormbig}[1]{\big\|#1\big\|}
\newcommand{\vectornormmed}[1]{\big\|#1\big\|}

\newcommand{\obs}{\boldsymbol{y}}
\newcommand{\sensing}{\boldsymbol{\mathcal{A}}}
\newcommand{\vsignal}{\boldsymbol{x}}
\newcommand{\vbestsignal}{\boldsymbol{x}^\ast}
\newcommand{\signal}{\boldsymbol{X}}
\newcommand{\bestsignal}{\boldsymbol{X}^\ast}
\newcommand{\xtrue}{\bestsignal}
\newcommand{\noise}{\boldsymbol{\varepsilon}}
\newcommand{\dimension}{m \times n}
\newcommand{\numsam}{p}
\newcommand{\sparsity}{s}
\newcommand{\id}{\mathbf{I}}
\newcommand{\rank}{k}

\newcommand{\constraint}{\mathcal{C}_\sparsity}
\newcommand{\constrainttwo}{\mathcal{C}_{2\odot\sparsity}}
\newcommand{\structsub}{\mathcal{V}_{\constraint}}
\newcommand{\projection}{\mathcal{P}_{\constraint}}
\newcommand{\apprprojection}{\mathcal{P}_{\constraint}^{\epsilon}}

\newcommand{\BlackBox}{\rule{1.5ex}{1.5ex}}  \DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\newcommand{\qq}{\vspace*{-3mm}}
\newcommand{\R}{ \mathbb{R} }   
\newcommand{\reals}{\mathbb R}
\linespread{0.9}
\smartqed


\author{\IEEEauthorblockN{Anastasios Kyrillidis \and Volkan Cevher \\}}

\begin{document}
\title{Matrix Recipes for \\ Hard Thresholding Methods}

\author{Anastasios Kyrillidis \and Volkan Cevher}

\institute{A. Kyrillidis \at
              Laboratory for Information and Inference Systems, Ecole Polytechnique Federale de Lausanne \\
              Tel.: +41 21 69 31154\\
              \email{anastasios.kyrillidis@epfl.ch}
           \and
           V. Cevher \at
              Laboratory for Information and Inference Systems, Ecole Polytechnique Federale de Lausanne \\
              Tel.: +41 21 69 31101\\
              \email{volkan.cevher@epfl.ch}
}

\date{Received: date / Accepted: date}

\maketitle

\begin{abstract}
In this paper, we present and analyze a new set of low-rank recovery algorithms for linear inverse problems within the class of hard thresholding methods. We provide strategies on how to set up these algorithms via basic ingredients for different configurations to achieve complexity vs. accuracy tradeoffs. Moreover, we study acceleration schemes via memory-based techniques and randomized, -approximate matrix projections to decrease the computational costs in the recovery process. For most of the configurations, we present theoretical analysis that guarantees convergence under mild problem conditions.  Simulation results demonstrate notable performance improvements as compared to state-of-the-art algorithms both in terms of reconstruction accuracy and computational complexity.

\keywords{Affine rank minimization \and hard thresholding \and -approximation schemes \and randomized algorithms.}
\end{abstract}

\section{Introduction}

In this work, we consider the general affine rank minimization (ARM) problem, described as follows:
\vskip.04in
\noindent \textsc{The ARM Problem:} {\it Assume  is a rank- matrix of interest () and let  be a known linear operator. Given a set of observations as , we desire to recover from  in a scalable and robust manner.}
\vskip.04in
The challenge in this problem is to recover the true low-rank matrix in subsampled settings where . In such cases, we typically exploit the prior information that  is low-rank and thus, we are interested in finding a matrix  of rank at most  that minimizes the data error  as follows:
 The ARM problem appears in many applications; low dimensional embedding \cite{baraniuk2010low}, matrix completion \cite{candès2009exact}, image compression \cite{SVP}, function learning \cite{TyagiCevherRidge, TyagiCevherRidgeII} just to name a few. We present below important ARM problem cases, as characterized by the nature of the linear operator .

\textbf{General linear maps:} In many ARM problem cases,  or  has a dense range, satisfying specific incoherence or restricted isometry properties (discussed later in the paper); here,  is the adjoint operator of . In Quantum Tomography, \cite{liuuniversal} studies the Pauli operator, a {\it compressive} linear map  that consists of the kronecker product of  matrices and obeys restricted isometry properties, defined later in the paper. Furthermore, recent developments indicate connections of ridge function learning \cite{TyagiCevherRidge, hemant2012active} and phase retrieval \cite{candes2012solving} with the ARM problem where  is a Bernoulli and a Fourier operator, respectively. 

\textbf{Matrix Completion (MC):} Let  be the set of ordered pairs that represent the coordinates of the observable entries in . Then, the set of observations satisfy  where  defines a linear mask over the observable entries . To solve the MC problem, a potential criterion is given by (\ref{opt:05}) \cite{candès2009exact}. As a motivating example, consider the famous Netflix problem \cite{netflix}, a recommender system problem where users' movie preferences are inferred by a limited subset of entries in a database. 

\textbf{Principal Component Analysis:} In Principal Component Analysis (PCA), we are interested in identifying a low rank subspace that best explains the data in the Euclidean sense from the observations  where  is an identity linear map that stacks the columns of the matrix  into a 
single column vector with . We observe that the PCA problem falls under the ARM criterion in (\ref{opt:05}). While (\ref{opt:05}) is generally NP-hard to solve optimally, PCA can be solved in polynomial time using the truncated Singular Value Decomposition (SVD) of . As an extension to the PCA setting, \cite{candes2011robust} considers the Robust PCA problem where  is further corrupted by gross sparse noise. We extend the framework proposed in this paper for the RPCA case and its generalizations in \cite{KyrillidisCevherSSP}.

For the rest of the paper, we consider only the low rank estimation case in (\ref{opt:05}). As running test cases to support our claims, we consider the MC setting as well as the general ARM setting where  is constituted by permuted subsampled noiselets \cite{sparcs}. 

\subsection{Two camps of recovery algorithms}

~~~~\textbf{Convex relaxations:} In \cite{brecht2010}, the authors study the nuclear norm   as a convex surrogate of  operator so that we can leverage convex optimization approaches, such as interior-point methods---here,  denotes the -th singular value of . Under basic incoherence properties of the sensing linear mapping , \cite{brecht2010} provides provable guarantees for unique low rank matrix recovery using the nuclear norm.

Once (\ref{opt:05}) is relaxed to a convex problem, decades of knowledge on convex analysis and optimization can be leveraged. Interior point methods find a solution with fixed precision in polynomial time but their complexity might be prohibitive even for moderate-sized problems \cite{Liu2009, Fazel2010}. More suitable for large-scale data analysis, first-order methods constitute low-complexity alternatives but most of them introduce complexity vs. accuracy tradeoffs \cite{SVT, ParallelRecht, ALM, APG}.

\vskip.04in
\textbf{Non-convex approaches:} In contrast to the convex relaxation approaches, iterative greedy algorithms maintain the nonconvex nature of (\ref{opt:05}).
Unfortunately, solving (\ref{opt:05}) optimally is in general NP-hard \cite{natarajan1995sparse}. Due to this computational intractability, the algorithms in this class greedily refine a rank- solution using only ``local'' information available at the current iteration \cite{admira2010, Goldfarb:2011, beck2011linearly}.

\subsection{Contributions}

In this work, we study a special class of iterative greedy algorithms known as hard thresholding methods. Similar results have been derived for the vector case \cite{KyrillidisCevherRecipes}. Note that the transition from sparse vector approximation to ARM is {\it non-trivial}; while -sparse signals ``live'' in the union of finite number of subspaces, the set of rank- matrices expands to infinitely many subspaces. Thus, the selection rules do not generalize in a straightforward way.

Our contributions are the following:

\textbf{Ingredients of hard thresholding methods:} We analyze the behaviour and performance of hard thresholding methods from a global perspective. Five building blocks are studied:  step size selection ,  gradient or least-squares updates over restricted low-rank subspaces (e.g., adaptive block coordinate descent),  memory exploitation,  active low-rank subspace tracking and,  low-rank matrix approximations (described next). We highlight the impact of these key pieces on the convergence rate and signal reconstruction performance and provide optimal and/or efficient strategies on how to set up these ingredients under different problem conditions. 

\textbf{Low-rank matrix approximations in hard thresholding methods:} 
In \cite{clash}, the authors show that the solution efficiency can be significantly improved by -approximation algorithms. Based on similar ideas, we analyze the impact of -approximate low rank-revealing schemes in the proposed algorithms with well-characterized time and space co- mplexities. Moreover, we provide extensive analysis to prove convergence using -approximate low-rank projections.

\textbf{Hard thresholding-based framework with improved convergence conditions:} We study hard thresholding variants that provide salient computational tradeoffs for the class of greedy methods on low-rank matrix recovery. These methods, as they iterate, exploit the non-convex scaffold of low rank subspaces on which the approximation problem resides. Using simple analysis tools, we derive improved conditions that guarantee convergence, compared to state-of-the-art approaches. 

The organization of the paper is as follows. In Section \ref{sec:prel}, we set up the notation and provide some definitions and properties, essential for the rest of the paper. In Section \ref{sec:ALPS}, we describe the basic algorithmic frameworks in a nutshell, while in Section {\ref{section:ingredients}} we provide important ``ingredients'' for the class of hard-thresholding methods; detailed convergence analysis proofs are provided in Section \ref{section:convergence}. The complexity analysis of the proposed algorithms is provided in Section \ref{section:complexity}. We study two acceleration schemes in Sections \ref{sec:memory} and \ref{section:approximate}, based on memory utilization and -approximate low-rank projections, respectively. We further improve convergence speed by exploiting randomized low rank projections in Section 9, based on power iteration-based subspace finder tools \cite{findingstructure}. We provide empirical support for our claims through experimental results on synthetic and real data in Section \ref{section:experiments}. Finally, we conclude with future work directions in Section \ref{sec: conc}.

\section{Elementary Definitions and Properties}{\label{sec:prel}}

We reserve lower-case and bold lower-case letters for scalar and vector variable representation, respectively. Bold upper-case letters denote matrices while bold calligraphic upper-case letters represent linear operators. We use calligraphic upper-case letters for set representations. We use  to represent the matrix estimate at the -th iteration. 

The rank of  is denoted as . The empirical data error is denoted as  with gradient ,  where  is the adjoint operation over the linear mapping . The inner product between matrices  is denoted as , where  represents the transpose operation.  represents an identity matrix with dimensions apparent from the context. 

Let  be a set of orthonormal, rank-1 matrices that span an arbitrary subspace in . We reserve  to denote the subspace spanned by . With slight abuse of notation, we use:
 to denote the {\it maximum} rank a matrix  can have such that  lies in the subspace spanned by the set . Given a finite set ,  denotes the cardinality of . For any matrix , we use  to denote its range.

We define a {\it minimum cardinality} set of orthonormal, rank-1 matrices that span the subspace induced by a set of rank-1 (and possibly non-orthogonal) matrices  as:
 where  denotes the superset that includes all the sets of {\it orthonormal}, rank-1 matrices in  such that   and, . In general,  is not unique.

A well-known lemma used in the convergence rate proofs of this class of greedy hard thresholding algorithms is defined next.

\begin{lemma}{\label{lemma:5}}\cite{Bertsekas} \textit{Let  be a closed convex set and  be a smooth objective function defined over . Let  be a local minimum of the objective function  over the set . Then}

\end{lemma}

\subsection{Singular Value Decomposition (SVD) and its properties}

\begin{definition}{\label{def:svd}}[SVD]
Let  be a rank- ( ) matrix. Then, the SVD of  is given by:
 where  and  for  . Here, the columns of  represent the set of left and right singular vectors, respectively, and  denote the singular values.
\end{definition}

For any matrix  with arbitrary , its best orthogonal projection  onto the set of rank- () matrices  defines the optimization problem:
 According to the Eckart-Young theorem \cite{horn1990matrix}, the best rank- approximation of a matrix  corresponds to its truncated SVD: if , then  where  is a diagonal matrix that contains the first  diagonal entries of  and  contain the corresponding left and right singular vectors, respectively. Moreover, this projection is not always unique. In the case of multiple identical singular values, the lexicographic approach is used to break ties. In any case,  for any rank- .

\subsection{Subspace projections}
Given a set of orthonormal, rank-1 matrices , we denote the orthogonal projection operator onto the subspace induced by  as \footnote{The distinction between  and  for  positive integer is apparent from context.} which is an idempotent linear transformation; furthermore, we denote the orthogonal projection operator onto the orthogonal subspace of  as . 
We can always decompose a matrix  into two matrix components, as follows:
 If , the best projection of  onto the subspace induced by  is the matrix  itself. Moreover,  for any  and .
\begin{definition}{\label{def:svd_proj}}[Orthogonal projections using SVD]
Let  be a matrix with arbitrary  and SVD decomposition given by (\ref{prel:eq:00}). Then,  () constitutes a set of orthonormal, rank-1 matrices that spans the best -rank subspace in  and ; here,  and  denote the -th left and right singular vectors, respectively. The orthogonal projection onto this subspace is given by \cite{candès2009exact}:
 where  and  in \textsc{Matlab} notation. Moreover, the orthogonal projection onto the  is given by:

\end{definition}

In the algorithmic descriptions, we use  to denote the set of rank-1, orthonormal matrices as outer products of the  left  and right  principal singular vectors of  that span the best rank- subspace of ; e.g. . Moreover,  denotes a/the best rank- projection matrix of . In some cases, we use  when we compute both. The distiction between these cases is apparent from the context.

\subsection{Restricted Isometry Property}

Many conditions have been proposed in the literature to establish solution uniqueness and recovery stability such as null space property \cite{cohen06}, exact recovery condition \cite{Tro04:Greed-Good}, etc.
For the matrix case, \cite{brecht2010} proposed the {\it restricted isometry property} (RIP) for the ARM problem. 

\begin{definition}{\label{def:RIP}}[Rank Restricted Isometry Property (R-RIP) for matrix linear operators \cite{brecht2010}] A linear operator   satisfies the R-RIP with constant  if and only if:
  We write  to mean , unless otherwise stated.
\end{definition} \cite{liuuniversal} shows that Pauli operators satisfy the rank-RIP in compressive settings while, in function learning, the linear map  is designed specifically to satisfy the rank-RIP \cite{hemant2012active}.

\subsection{Some useful bounds using R-RIP}

In this section, we present some lemmas that are useful in our subsequent developments---these lemmas are consequen- ces of the R-RIP of .

\begin{lemma}{\label{lemma:1}}\cite{admira2010}
Let  be a linear operator that satisfies the R-RIP with constant . Then, , the following holds true:
 where  is a set of orthonormal, rank-1 matrices in  such that .
\end{lemma}

\begin{lemma}{\label{lemma:2}}\cite{admira2010}
Let  be a linear operator that satisfies the R-RIP with constant . Then, , the following holds true:
 where  is a set of orthonormal, rank-1 matrices in  such that .
\end{lemma}

\begin{lemma}{\label{lemma:3}}\cite{Goldfarb:2011}
Let  be a linear operator that satisfies the R-RIP with constant  and  be a set of orthonormal, rank-1 matrices in  such that . Then, for ,  satisfies:
 where  represents the range of eigenvalues of the linear operator .
Moreover, , it follows that:

\end{lemma}

\begin{lemma}{\label{lemma:4}}\cite{Goldfarb:2011}
Let  be a linear operator that satisfies the R-RIP with constant  and  be two sets of orthonormal, rank-1 matrices in  such that 
 Then, the following inequality holds:

\end{lemma}

\section{Algrebraic Pursuits in a nutshell}{\label{sec:ALPS}}

\begin{algorithm*}[t!]
   \caption{\textsc{Matrix ALPS I}}\label{algo: class}
\begin{algorithmic}[1]
   \Statex {\bfseries Input:} , , , Tolerance , MaxIterations
   \Statex {\bfseries Initialize:} , , 
   \Statex {\bfseries repeat} \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Best rank- subspace orthogonal to )~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Active subspace expansion)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Step size selection)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Error norm reduction via gradient descent)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}{\textit{(Best rank- subspace selection)~~~~~~~~~}}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Step size selection)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(De-bias using gradient descent)~~~~~~~~~}
   \Statex \hspace{0.16cm} 
   \Statex {\bfseries until}  or MaxIterations.
\end{algorithmic}
\end{algorithm*}

\begin{algorithm*}[t!]
   \caption{ADMiRA Instance}\label{algo: class}
\begin{algorithmic}[1]
   \Statex {\bfseries Input:} , , , Tolerance , MaxIterations
   \Statex {\bfseries Initialize:} , , 
   \Statex {\bfseries repeat} 
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Best rank- subspace orthogonal to )~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Active subspace expansion)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Error norm reduction via least-squares optimization)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}{\textit{(Best rank- subspace selection)~~~~~~~~~}}
   \Statex \hspace{0.16cm} 
   \Statex {\bfseries until}  or MaxIterations.
\end{algorithmic}
\end{algorithm*}

Explicit descriptions of the proposed algorithms are provided in Algorithms 1 and 2. Algorithm 1 follows from the ALgrebraic PursuitS (ALPS) scheme for the vector case \cite{cevher2011alps}. \textsc{Matrix ALPS I} provides efficient strategies for adaptive step size selection and additional signal estimate updates at each iteration (these motions are explained in detail in the next subsection). Algorithm 2 (ADMiRA) \cite{admira2010} further improves the performance of Algorithm 1 by introducing least squares optimization steps on restricted subspaces---this technique borrows from a series of vector reconstruction algorithms such as CoSaMP \cite{cosamp}, Subspace Pursuit (SP) \cite{SP} and Hard Thresholding Pursuit (HTP) \cite{HTP}. 

In a nutshell, both algorithms simply seek to improve the subspace selection by iteratively collecting an extended subspace  with  and then finding the rank- matrix that fits the measurements in this restricted subspace using least squares or gradient descent motions. 

At each iteration, the Algorithms 1 and 2 perform motions from the following list:

\begin{framed}
1) \textit{Best rank- subspace orthogonal to  and active subspace expansion:} We identify the best rank- subspace of the current gradient , orthogonal to  and then merge this low-rank subspace with . This motion guarantees that, at each iteration, we expand the current rank- subspace estimate with  new, rank-1 orthogonal subspaces to explore. 

2a) \textit{Error norm reduction via greedy descent with adaptive step size selection (Algorithm 1):} We decrease the data error by performing a single gradient descent step. This scheme is based on a one-shot step size selection procedure (Step size selection step)---detailed description of this approach is given in Section \ref{section:ingredients}.

2b) \textit{Error norm reduction via least squares optimization (Algorithm 2):} We decrease the data error  on the active -low rank subspace. Assuming  is well-conditioned over low-rank subspaces, the main complexity of this operation is dominated by the solution of a symmetric linear system of equations. 

3) \textit{Best rank- subspace selection:} We project the constrained solution onto the set of rank- matrices  to arbitrate the active support set. 
This step is calculated in polynomial time complexity as a function of  using SVD or other matrix rank-revealing decomposition algorithms---further discussions about this step and its approximations can be found in Sections \ref{section:approximate} and \ref{section:QR}.

4) \textit{De-bias using gradient descent (Algorithm 1):} We de-bias the current estimate  by performing an additional gradient descent step, decreasing the data error. The step size selection procedure follows the same motions as in 2a).

\end{framed}

\section{Ingredients for hard thresholding methods}{\label{section:ingredients}}

\subsection{Step size selection}

For the sparse vector approximation problem, recent works on the performance of the IHT algorithm provide strong convergence rate guarantees in terms of RIP constants \cite{Blumensath_iterativehard}. However, as a prerequisite to achieve these strong isometry constant bounds, the step size is set  given that the sensing matrix satisfies  where  denotes the spectral norm \cite{HTP}; similar analysis can be found in \cite{SVP} for the matrix case. From a different perspective, \cite{garg2009gradient} proposes a constant step size , based on a simple but intuitive convergence analysis of the gradient descent method. 

Unfortunately, most of the above problem assumptions are not naturally met; the authors in \cite{NIHT} provide an intuitive example where IHT algorithm behaves differently under various scalings of the sensing matrix; similar counterexamples can be devised for the matrix case. Violating these assumptions usually leads to unpredictable signal recovery performance of the class of hard thresholding methods. 
Therefore, more sophisticated step size selection procedures should be devised to tackle these issues during actual recovery. On the other hand, the computation of R-RIP constants has exponential time complexity for the strategy of \cite{SVP}. 

To this end, existing approaches broadly fall into two categories: constant and adaptive step size selection. In this work, we present efficient strategies to adaptively select the step size  that implies fast convergence rate, for mild R-RIP assumptions on . Constant step size strategies easily follow from \cite{KyrillidisCevherRecipes} and are not listed in this work. 

\textbf{Adaptive step size selection.} 
There is limited work on the adaptive step size selection for hard thresholding methods. To the best of our knowledge, apart from \cite{KyrillidisCevherRecipes}, \cite{NIHT}-\cite{AIHT} are the only studies that attempt this via line searching for the vector case. At the time of review process, we become aware of \cite{tannernormalized} which implements ideas presented in \cite{NIHT} for the matrix case.

\begin{figure*}[!t]
\hspace{-0.2cm}\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.34\textwidth]{ALPSstepsize-noiselets-2}\label{fig:1a}} 
\hfill
\subfigure[]{\includegraphics[width = 0.34\textwidth]{ALPSstepsize-robustMC-2}\label{fig:1b}}
\hfill
\subfigure[]{\includegraphics[width = 0.34\textwidth]{ALPSupdates-robustMC-2}\label{fig:1c}}}
\end{tabular}
\caption{\small\sl Median error per iteration for various step size policies and 20 Monte-Carlo repetitions. In brackets, we present the median time consumed for convergene in seconds. (a) ,  and rank --- is formed by permuted and subsampled noiselets \cite{coifman2001noiselets}. (b)  , , , and rank ---we use underdetermined linear map  according to the MC problem (c) , ,  and rank ---we use underdetermined linear map  according to the MC problem.}
\end{figure*}

According to Algorithm 1, let  be the current rank- matrix estimate spanned by the set of orthonormal, rank-1 matrices in . Using regular gradient descent motions, the new rank- estimate  can be calculated through: 
 We highlight that the rank- approximate matrix may not be unique. It then holds that the subspace spanned by  originates:  either from the subspace of ,  or from the best subspace (in terms of the Frobenius norm metric) of the current gradient , {\it orthogonal to },  or from the combination of orthonormal, rank-1 matrices lying on the union of the above two subspaces. The statements above can be summarized in the following expression:
 for any step size  and . Since , we easily deduce the following key observation: let  be a set of rank-1, orthonormal matrices where . 
Given  is unknown before the -th iteration,  spans the smallest subspace that contains  such that the following equality
 necessarily holds.\footnote{In the case of multiple identical singular values, any ties are lexicographically dissolved.}

To compute step-size , we use:
 i.e.,  is the minimizer of the objective function, given the current gradient . 
Note that:
 due to R-RIP---i.e., we select  subspaces such that  satisfies (\ref{eq:additional:1}). We can derive similar arguments for the additional step size selection  in Step 6 of Algorithm 1. 

Adaptive  scheme results in more restrictive worst-case isometry constants compared to \cite{HTP, foucart2010sparse, SVP}, but faster convergence and better stability are empirically observed in general. In \cite{SVP}, the authors present the Singular Value Projection (SVP) algorithm, an iterative hard thresholding algorithm for the ARM problem. According to \cite{SVP}, both constant and iteration dependent (but user-defined) step sizes are considered. Adaptive strategies presented in \cite{SVP} require the computation of R-RIP constants which has exponential time complexity. Figures 1(a)-(b) illustrate some characteristic examples. The performance varies for different problem configurations. For , SVP {\it diverges} for various test cases. We note that, for large fixed matrix dimensions , adaptive step size selection becomes computationally expensive compared to constant step size selection strategies, as the rank of  increases.

\subsection{Updates on restricted subspaces}

In Algorithm 1, at each iteration, the new estimate  can be further refined by applying a single or multiple gradient descent updates with line search restricted on  \cite{HTP} (Step 7 in Algorithm 1): 
  In spirit, the gradient step above is the same as block coordinate descent in convex optimization where we find the subspaces adaptively. Figure 1(c) depicts the acceleration achieved by using additional gradient updates over restricted low-rank subspaces for a test case.

\subsection{Acceleration via memory-based schemes and low-rank matrix approximations}
Memory-based techniques can be used to improve convergence speed. Furthermore, low-rank matrix approximation tools overcome the computational overhead of computing the best low-rank projection by inexactly solving (\ref{eq:svd_proj}). We keep the discussion on memory utilization for Section \ref{sec:memory} and low-rank matrix approximations for Sections \ref{section:approximate} and \ref{section:QR} where we present new algorithmic frameworks for low-rank matrix recovery.

\begin{figure*}[!t]
\hspace{-0.2cm}\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataProj1-memory-crop}} 
\hfill
\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataProj2-memory2-crop}}
\hfill
\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataProj3-memory-crop}}}
\end{tabular}
\caption{\small\sl Median error per iteration for \textsc{Matrix ALPS I} and \textsc{Matrix ALPS II} variants over 10 Monte-Carlo repetitions. In brackets, we present the median time consumed for convergene in seconds. (a) ,  and rank . (b) ,  and rank . (c) ,  and rank . }\label{proj_figure}
\end{figure*}

\subsection{Active low-rank subspace tracking}
Per iteration of Algorithms 1 and 2, we perform projection operations  and  where , as described by (\ref{eq:newproj}) and (\ref{eq:neworthoproj}), respectively. Since  is constituted by outer products of left and right singular vectors as in Definition \ref{def:svd_proj},  (resp. ) projects onto the (resp. complement of the) best low-rank subspace in  and . These operations are highly connected with the adaptive step size selection and the updates on restricted subspaces. Unfortunately, the time-complexity to compute  is dominated by three matrix-matrix multiplications which decelerates the convergence of the proposed schemes in high-dimensional settings. To accelerate the convergence in many test cases, it turns out that we do not have to use the best projection  in practice.\footnote{From a different perspective and for a different problem case, similar ideas have been used in \cite{ALM}.} Rather, employing {\it inexact} projections is sufficient to converge to the optimal solution: either   onto the best low-rank subspace in  only (if ) or   onto the best low-rank subspace in  only (if )\footnote{We can move between these two cases by a simple transpose of the problem.};  and  are defined in Definition \ref{def:svd_proj} and require only one matrix-matrix multiplication. 

Figure 2 shows the time overhead due to the exact projection application  compared to  for . In Figure 2(a), we use subsampled and permuted noiselets for linear map  and in Figures 2(b)-(c), we test the MC problem. While in the case  the use of (\ref{eq:newproj})-(\ref{eq:neworthoproj}) has a clear advantage over inexact projections using only , the latter case converges faster to the desired accuracy  when  as shown in Figures 2(a)-(b).
In our derivations, we assume  and  as defined in  (\ref{eq:newproj}) and (\ref{eq:neworthoproj}). 

\section{Convergence guarantees}{\label{section:convergence}}

In this section, we present the theoretical convergence guarantees of Algorithms 1 and 2 as functions of R-RIP constants. 
To characterize the performance of the proposed algorithms, both in terms of convergence rate and noise resilience, we use the following recursive expression:
 In (\ref{it:00}),  denotes the approximation guarantee and provides insights into algorithm's reconstruction capabilities when additive noise is present;  expresses the convergence rate towards a region around , whose radius is determined by . In short, (\ref{it:00}) characterizes how the distance to the true signal  is decreased and how the noise level affects the accuracy of the solution, at each iteration.

\subsection{\textsc{Matrix ALPS I}}
An important lemma for our derivations below is given next:

\begin{lemma}\label{lemma:act_subspace_exp}[Active subspace expansion] Let  be the matrix estimate at the -th iteration and let  be a set of orthonormal, rank-1 matrices such that .  Then, at each iteration, the Active Subspace Expansion step in Algorithms 1 and 2 identifies information in , such that:
 where  and .
\end{lemma}

Lemma \ref{lemma:act_subspace_exp} states that, at each iteration, the active subspace expansion step identifies a 2 rank subspace such that the amount of unrecovered energy of ---i.e., the projection of  onto the orthogonal subspace of ---is bounded by (\ref{eq:lemma6}).

Then, Theorem 1 characterizes the iteration invariant of Algorithm 1 for the matrix case:
\begin{theorem}\label{thm:mALPS0}[Iteration invariant for \textsc{Matrix ALPS I}] The -th matrix estimate  of \textsc{Matrix ALPS I} satisfies the following recursion:
 where  and  Moreover, when , the iterations are contractive.
\end{theorem}

To provide some intuition behind this result, assume that  is a rank- matrix. Then, according to Theorem \ref{thm:mALPS0}, for , the approximation parameter  in (\ref{eq:mALPS0:thm}) satisfies:
 Moreover, we derive the following:
 which is {\it a stronger} R-RIP condition assumption compared to state-of-the-art approaches \cite{admira2010}. In the next section, we further improve this guarantee using Algorithm 2.

Unfolding the recursive formula (\ref{eq:mALPS0:thm}), we obtain the following upper bound for  at the -th iteration:
 Then, given , \textsc{Matrix ALPS I} finds a rank- solution  such that  after  iterations.

If we ignore steps 5 and 6 in Algorithm 1, we obtain another projected gradient descent variant for the affine rank minimization problem, for which we obtain the following performance guarantees---the proof follows from the proof of Theorem \ref{thm:mALPS0}.

\begin{corollary}{\label{cor:1}}[\textsc{Matrix ALPS I} Instance] 
In Algorithm 1, we ignore steps 5 and 6 and let . Then, by the same analysis, we observe that the following recursion is satisfied:
 for  and . Moreover,  when .
\end{corollary} 

We observe that the absence of the additional estimate update over restricted support sets results in less restrictive isometry constants compared to Theorem \ref{thm:mALPS0}. In practice, additional updates result in faster convergence, as shown in Figure 1(c).

\subsection{ADMiRA Instance}

In \textsc{Matrix ALPS I}, the gradient descent steps constitute a first-order approximation to least-squares minimization problems. Replacing Step 4 in Algorithm 1 with the following optimization problem:

we obtain ADMiRA (furthermore, we remove the de-bias step in Algorithm 1). Assuming that the linear operator , restricted on sufficiently low-rank subspaces, is well conditioned in terms of the R-RIP assumption, the optimization problem (\ref{eq:opt:1}) has a unique optimal minimizer. By exploiting the optimality condition in Lemma \ref{lemma:5}, ADMiRA instance in Algorithm 2 features the following guarantee:

\begin{theorem}\label{thm:mALPS5}[Iteration invariant for ADMiRA instance] The -th matrix estimate  of ADMiRA answers the following recursive expression:
  and   Moreover, when , the iterations are contractive.
\end{theorem}

Similarly to \textsc{Matrix ALPS I} analysis, the parameter  in Theorem \ref{thm:mALPS5} satisfies:
 Furthermore, to compare the approximation guarantees of Theorem \ref{thm:mALPS5} with \cite{admira2010}, we further observe:
 We remind that \cite{admira2010} provides convergence guarantees for ADMiRA with  for .

\section{Complexity Analysis}{\label{section:complexity}}

In each iteration, computational requirements of the proposed hard thresholding methods mainly depend on the total number of linear mapping operations , gradient descent steps, least-squares optimizations, projection operations and matrix decompositions for low rank approximation. Different algorithmic configurations (e.g. removing steps 6 and 7 in Algorithm 1) lead to hard thresholding variants with less computational complexity per iteration and better R-RIP conditions for convergence but a degraded performance in terms of stability and convergence speed is observed in practice. On the other hand, these additional processing steps increase the required time-complexity per iteration; hence, low iteration counts are desired to tradeoff these operations. 

A non-exhaustive list of linear map examples includes the identity operator (Principal component analysis (PCA) problem), Fourier/Wavelets/Noiselets tranformations and the famous Matrix Completion problem where  is a mask operator such that only a fraction of elements in  is observed. Assuming the most demanding case where  and  are dense linear maps with no structure, the computation of the gradient  at each iteration requires  arithmetic operations. 

Given a set  of orthonormal, rank-1 matrices, the projection  for any matrix  requires time complexity   as a sequence of matrix-matrix multiplication operations.\footnote{While such operation has   complexity, each application of  requires three matrix-matrix multiplications. To reduce such computational cost, we {\it relax} this operation in Section \ref{section:experiments} where in practice we use only  that needs one matrix-matrix multiplication. } In \textsc{Matrix ALPS I}, the adaptive step size selection steps require  time complexity for the calculation of  and  quantities. In ADMiRA solving a least-squares system restricted on rank-2 and rank- subspaces requires  complexity; according to \cite{cosamp}, \cite{admira2010}, the complexity of this step can be further reduced using iterative techniques such as the Richardson method or conjugate gradients algorithm. 

Using the Lanczos method, we require  arithmetic operations to compute a rank- matrix approximation for a given constant accuracy; a prohibitive time-complexity that does not scale well for many practical applications. Sections \ref{section:approximate} and \ref{section:QR} describe approximate low rank matrix projections and how they affect the convergence guarantees of the proposed algorithms.

Overall, the operation that dominates per iteration requires  time complexity in the proposed schemes. 

\section{Memory-based Acceleration}{\label{sec:memory}}
Iterative algorithms can use memory to gain momentum in convergence. Based on Nesterov's optimal gradient methods \cite{nesterov2007gradient}, we propose a hard thresholding variant, described in Algorithm 3 where an additional update on  with momentum step size  is performed using previous matrix estimates.

\begin{algorithm*}[th!]
   \caption{\textsc{Matrix ALPS II}}\label{algo: class}
\begin{algorithmic}[1]
   \Statex {\bfseries Input:} , , , Tolerance , MaxIterations
   \Statex {\bfseries Initialize:} , , , , , 
   \Statex {\bfseries repeat} \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Best rank- subspace orthogonal to )~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Active subspace expansion)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Step size selection)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Error norm reduction via gradient descent)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}{\textit{(Best rank- subspace selection)~~~~~~~~~}}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Momentum update)~~~~~~~~~}
   \State \hspace{0.16cm} 
   \Statex \hspace{0.16cm} 
   \Statex {\bfseries until}  or MaxIterations.
\end{algorithmic}
\end{algorithm*}

Similar to  strategies,  can be preset as constant or adaptively computed at each iteration. Constant momentum step size selection has no additional computational cost but convergence rate acceleration is not guaranteed for some problem formulations in practice. On the other hand, empirical evidence has shown that adaptive  selection strategies result in faster convergence compared to zero-memory methods with {\it similar complexity}. 

For the case of strongly convex objective functions, Nesterov \cite{nesterov} proposed the following constant momentum step size selection scheme:
, where  and  is computed as the root  of
 where  denotes the condition number of . In this scheme, exact calculation of  parameter is computationally expensive for large-scale data problems and approximation schemes are leveraged to compensate this complexity bottleneck.

Based upon adaptive  selection, we propose to select  as the minimizer of the objective function:
 where  are already {\it pre-computed} at each iteration. According to (\ref{tau_optimized:00}),  is dominated by the calculation of a vector inner product, a computationally cheaper process than  calculation. 

Theorem \ref{thm:mALPS0:memory} characterizes Algorithm 3 for {\it constant} momentum step size selection. To keep the main ideas simple, we ignore the additional gradient updates in Algorithm 3. In addition, we only consider the noiseless case for clarity. The convergence rate proof for these cases is provided in the appendix.

\begin{theorem}\label{thm:mALPS0:memory}[Iteration invariant for \textsc{Matrix ALPS II}] Let  be a noiseless set of observations. To recover  from  and , the -th matrix estimate  of \textsc{Matrix ALPS II} satisfies the following recursion:
 where . Moreover, solving the above second-order recurrence, the following inequality holds true:
 for .
\end{theorem}

\begin{figure}[!t]
\centering
\begin{tabular}{cc}
\centerline{\subfigure{\includegraphics[width = 0.38\textwidth]{momstepsize-crop}\label{fig:3b}}}
\end{tabular}
\caption{\small\sl Median error per iteration for various momentum step size policies and 10 Monte-Carlo repetitions. Here, , ,  and rank . We use permuted and subsampled noiselets for the linear map . In brackets, we present the median time for convergence in seconds. 
}\label{fig: lambda}
\end{figure}

Theorem \ref{thm:mALPS0:memory} provides convergence rate behaviour proof for the case where  is constant . The more elaborate case where  follows the policy described in (\ref{tau_optimized:00}) is left as an open question for future work. To provide some insight for (\ref{eq:mALPS0_memory_result}), for  and ,  and  guarantee convergence in Algorithm 3, respectively. While the RIP requirements for memory-based \textsc{Matrix ALPS II} are more stringent than the schemes proposed in the previous section, it outperforms Algorithms 1 and 2. Figure 2 shows the acceleration achieved in \textsc{Matrix ALPS II} by using inexact projections . Using the proper projections (\ref{eq:newproj})-(\ref{eq:neworthoproj}), Figure \ref{fig: lambda} shows acceleration in practice when using the adaptive momentum step size strategy: while a wide range of constant momentum step sizes leads to convergence, providing flexibility to select an appropriate , adaptive  avoids this arbitrary  selection while further decreases the number of iterations needed for convergence in most cases.  

\section{Accelerating \textsc{Matrix ALPS}: -Approximation of SVD via Column Subset Selection}{\label{section:approximate}}

A time-complexity bottleneck in the proposed schemes is the computation of the singular value decomposition to find subspaces that  describe the unexplored information in matrix . Unfortunately, the computational cost of regular SVD for best subspace tracking is prohibitive for many applications. 

Based on \cite{drineas1, drineas2},  we can obtain randomized SVD approximations of a matrix  using {\it column subset selection} ideas: we compute a leverage score for each column that represents its ``significance''. In particular, we define a probability distribution that weights each column depending on the amount of information they contain; usually, the distribution is related to the -norm of the columns. The main idea of this approach is to compute a surrogate rank- matrix  by subsampling the columns according to this distribution. It turns out that the total number of sampled columns is a function of the parameter .  Moreover, \cite{deshpande1, deshpande2} proved that, given a target rank  and an approximation parameter , we can compute an -approximate rank- matrix  according to the following defintion.

\begin{definition}{\label{def:appr_svd}}[-approximate low-rank projection]
Let  be an arbitrary matrix. Then,  projection provides a rank- matrix approximation to  such that:
 where .
\end{definition}

For the following theoretical results, we assume the following condition on the sensing operator   where . 
Using -approximation schemes to perform the Active subspace selection step, the following upper bound holds. The proof is provided in the Appendix:

\begin{lemma}\label{lemma:appr_act_subspace_exp}[-approximate active subspace expansion] Let  be the matrix estimate at the -th iteration and let  be a set of orthonormal, rank-1 matrices in  such that . Furthermore, let 
 be a set of orthonormal, rank-1 matrices that span rank- subspace such that (\ref{eq:appr_svd:00}) is satisfied for . Then, at each iteration, the Active Subspace Expansion step in Algorithms 1 and 2 captures information contained in the true matrix , such that:
 where  and . 
\end{lemma}

Furthermore, to prove the following theorems, we extend Lemma \ref{lemma:comb_selection}, provided in the Appendix, as follows. The proof easily follows from the proof of Lemma \ref{lemma:comb_selection}, using Definition \ref{def:appr_svd}:
\begin{lemma}{\label{lemma:appr_comb_selection}}[-approximation rank- subspace selection] Let  be a rank- proxy matrix in the subspace spanned by  and let  denote the rank- -approxi- mation to , according to (\ref{eq:svd_proj}). Then:
 where .
\end{lemma}

\subsection{\textsc{Matrix ALPS I} using -approximate low-rank projection via column subset selection}

Using -approximate SVD in \textsc{Matrix ALPS I}, the following iteration invariant theorem holds:

\begin{theorem}\label{thm:mALPS0_appr}[Iteration invariant with -approximate projections for \textsc{Matrix ALPS I}] The -th matrix estimate  of \textsc{Matrix ALPS I} with -approximate projections  and  in Algorithm 1 satisfies the following recursion:

where   and \\  \\ 
\end{theorem}


\begin{figure}[!ht]
\centering
\subfigure[]{\includegraphics[width = 0.40\textwidth]{approximation-noiselets-crop}\label{fig:3cc}}
\caption{\small\sl Performance comparison using -approximation SVD \cite{deshpande2} in \textsc{Matrix ALPS II}. , , rank of  equals  and  constituted by permuted noiselets. The non-smoothness in the error curves is due to the extreme low rankness of  for this setting. } \label{fig: lambda1}
\end{figure}

Similar analysis can be conducted for the ADMiRA algorithm. To illustrate the impact of SVD -approximation on the signal reconstruction performance of the proposed methods, we replace the {\it best} rank- projections in steps 1 and 5 of Algorithm 1 by the -approximation SVD algorithm, presented in \cite{deshpande2}. In this paper, the column subset selection algorithm satisfies the following theorem:

\begin{theorem}{\label{thm:adaptiveVolume}} 
Let  be a signal of interest with arbitrary  and let  represent the {\it best} rank- approximation of . After  passes over the data, the Linear Time Low-Rank Matrix Approximation algorithm in \cite{deshpande2} computes a rank- approximation  such that Definition \ref{def:appr_svd} is satisfied with probability at least 3/4.
\end{theorem} 

The proof is provided in \cite{deshpande2}. In total, Linear Time Low-Rank Matrix Approximation algorithm \cite{deshpande2} requires    and  time and space complexity, respectively. However, while column subset selection methods such as \cite{deshpande2} reduce the overall complexity of low-rank projections in theory, in practice this applies only in very high-dimensional settings. To strengthen this argument, in Figure \ref{fig: lambda1} we compare SVD-based \textsc{Matrix ALPS II}	with \textsc{Matrix ALPS II} using the -approximate column subset selection method in \cite{deshpande2}. We observe that the total number of iterations for convergence increases due to -approximate low-rank projections, as expected. Nevertheless, we observe that, on average, the column subset selection process \cite{deshpande2} is computationally prohibitive compared to regular SVD due to the time overhead in the column selection procedure---fewer passes over the data are desirable in practice to tradeoff the increased number of iterations for convergence. In the next section, we present alternatives based on recent trends in randomized matrix decompositions and how we can use them in low-rank recovery.

\section{Accelerating \textsc{Matrix ALPS}: SVD Approximation using Randomized Matrix Decompositions }{\label{section:QR}}

\begin{algorithm*}[Htp!]
   \caption{Randomized \textsc{Matrix ALPS II} with QR Factorization}\label{algo: class}
\begin{algorithmic}[1]
   \Statex {\bfseries Input:} , , , , Tolerance , MaxIterations
   \Statex {\bfseries Initialize:} , , , , , 
   \Statex {\bfseries repeat} \State \hspace{0.16cm}  \textsc{RandomizedPowerIteration} \hspace*{\fill}\textit{(Rank- subspace via Randomized Power Iteration)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Active subspace expansion)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Step size selection)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill} \textit{(Error norm reduction via gradient descent)~~~~~~~~~}
   \State \hspace{0.16cm}  \textsc{RandomizedPowerIteration}  \hspace*{\fill}\textit{(Rank- subspace via Randomized Power Iteration)~~~~~~~~~}
   \State \hspace{0.16cm}  \hspace*{\fill}{\textit{(Best rank- subspace selection)~~~~~~~~~}}
   \State \hspace{0.16cm}  \hspace*{\fill}\textit{(Momentum update)~~~~~~~~~}
   \State \hspace{0.16cm} 
   \Statex \hspace{0.16cm} 
   \Statex {\bfseries until}  or MaxIterations.
\end{algorithmic}
\end{algorithm*} 

Finding low-cost SVD approximations to tackle the above complexity issues is a challenging task. Recent works on probabilistic methods for matrix approximation \cite{findingstructure} provide a family of efficient approximate projections on the set of rank-deficient matrices with clear computational advantages over regular SVD computation in practice and attractive theoretical guarantees. In this work, we build on the low-cost, power-iteration {\it subspace tracking} scheme, described in Algorithms 4.3 and 4.4 in \cite{findingstructure}. Our proposed algorithm is described in Algorithm 4.

The convergence guarantees of Algorithm 4 follow the same motions described in Section \ref{section:approximate}, where  is a function of  and . 

\section{Experiments}{\label{section:experiments}}

\subsection{List of algorithms}
In the following experiments, we compare the following algorithms:  the Singular Value Projection (SVP) algorithm \cite{SVP}, a non-convex first-order projected gradient descent algorithm with {\it constant} step size selection (we study the case where ),  the inexact ALM algorithm \cite{ALM} based on augmented Langrance multiplier method,  the OptSpace algorithm \cite{OptSpace}, a gradient descent algorithm on the Grassmann manifold,  the Grassmannian Rank-One Update Subspace Estimation (GROUSE) and the Grassmannian Robust Adaptive Subspace Tracking methods (GRASTA) \cite{GROUSE, GRASTA}, two stochastic gradient descent algorithms that operate on the Grassmannian---moreover, to allay the impact of outliers in the subspace selection step, GRASTA incorporates the augmented Lagrangian of -norm loss function into the Grassmannian optimization framework,  the Riemannian Trust Region Matrix Completion algorithm (RTRMC) \cite{RTRMC}, a matrix completion method using first- and second-order Riemannian trust-region approaches,  the Low rank Matrix Fitting algorithm (LMatFit) \cite{LMatFit}, a nonlinear successive over-relaxation algorithm and  the algorithms \textsc{Matrix ALPS I}, ADMiRA \cite{admira2010}, \textsc{Matrix ALPS II} and Randomized \textsc{Matrix ALPS II} with QR Factorization (referred shortly as \textsc{Matrix ALPS II} with QR) presented in this paper.

\begin{figure*}[!t]
\hspace{-0.2cm}\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataOrtho1-crop}} 
\hfill
\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataOrtho2-crop}}
\hfill
\subfigure[]{\includegraphics[width = 0.3\textwidth]{dataOrtho3-crop}}}
\end{tabular}
\caption{\small\sl Median error per iteration for \textsc{Matrix ALPS II} variants over 10 Monte-Carlo repetitions. In brackets, we present the mean time consumed for convergene in seconds. (a) ,  and rank . (b) ,  and rank . (c) , ,  and rank . }\label{ortho_figure}
\end{figure*}

\subsection{Implementation details}
To properly compare the algorithms in the above list, we preset a set of parameters that are common. We denote the ratio between the number of observed samples and the number of variables in  as  (sampling ratio). Furthemore, we reserve  to represent the degree of freedom in a rank- matrix to the number of observations---this corresponds to the following definition . In most of the experiments, we fix the number of observable data  and vary the dimensions and the rank  of the matrix . This way, we create a wide range of different problem configurations with variable . 

Most of the algorithms in comparison as well as the proposed schemes are implemented in \textsc{Matlab}. We note that the LMaFit software package contains parts implemented in C that reduce the per iteration computational time. This provides insights for further time savings in our schemes; we leave a fully optimized implementation of our algorithms as future work. In this paper, we mostly test cases where . Such settings can be easily found in real-world problems such as recommender systems (e.g. Netflix, Amazon, etc.) where the number of products, movies, etc. is much greater than the number of active users.

In all algorithms, we fix the maximum number of iterations to 500, unless otherwise stated. To solve a least squares problem over a restricted low-rank subspace, we use conjugate gradients with maximum number of iterations given by  and tolerance parameter . We use the same stopping criteria for the majority of algorithms under consideration:
 where  denote the current and the previous estimate of  and . If this is not the case, we tweak the algorithms to minimize the total execution time and achieve similar reconstruction performance as the rest of the algorithms. For SVD calculations, we use the  implementation in PROPACK package \cite{propack}---moreover, all the algorithms in comparison use the same linear operators  and  for gradient and SVD calculations and conjugate-gradient least-squares minimizations. For fairness, we modified all the algorithms so that they {\it exploit the true rank}. Small deviations from the true rank result in relatively small degradation in terms of the reconstruction performance. In case the rank of  is unknown, one has to predict the dimension of the principal singular space. The authors in \cite{SVP}, based on ideas in \cite{OptSpace}, propose to compute singular values incrementally until a significant gap between singular values is found. Similar strategies can be found in \cite{ALM} for the convex case.

In \textsc{Matrix ALPS II} and \textsc{Matrix ALPS II} with QR, we perform  to construct a set of orthonormal rank-1 matrices that span the subspace, spanned by . 
While such operation can be implemented using factorization procedures (such as SVD or QR decompositions), in practice this degrades the time complexity of the algorithm substantially as the rank  and the problem dimensionality increase. In our implementations, we simply {\it union} the set of orthonormal rank-1 matrices, without further orthogonalization. Thus, we employ {\it inexact} projections for computational efficiency which results in faster convergence. Figure 5 shows the time overhead due to the additional orthogonalization process. We compare three algorithms: \textsc{Matrix ALPS II} (no orthogonalization step), \textsc{Matrix ALPS II} using SVD for orthogonalization and, \textsc{Matrix ALPS II} using QR for orthogonalization. In Figures 5(a)-(b), we use subsampled and permuted noiselets for linear map  and in Figure 5(c), we test the MC problem. In all the experimental cases considered in this work, we observed identical performace in terms of reconstruction accuracy for the three variants, as can be also seen in Figure 5. To this end, for the rest of the paper, we use \textsc{Matrix ALPS II} where .

\subsection{Limitations of -based algorithms: a toy example}

While nucluear norm heuristic is widely used in solving the low-rank minimization problem, \cite{nonuclear} presents simple problem cases where convex, nuclear norm-based, algorithms {\it fail} in practice. Using the  -norm in the objective function as the convex surrogate of the  metric might lead to a candidate set with multiple solutions, introducing ambiguity in the selection process. Borrowing the example in \cite{nonuclear}, we test the list of algorithms above on a toy problem setting that does not satisfy the rank-RIP. To this end, we design the following problem: let  be the matrix of interest with , as shown in Figure \ref{fig:toy}(a). We consider the case where we have access to  only through a subset of its entries, as shown in Figure \ref{fig:toy}(b).


\begin{figure}[ht]
\begin{center}
\begin{minipage}[c]{0.25\linewidth}
 \hspace{0.6cm} (a)
\end{minipage}
\hspace{-0.5cm}
\begin{minipage}[c]{0.25\linewidth}
 \hspace{0.6cm}  (b)
\end{minipage}
\end{center}
\caption{\small\sl Matrix Completion toy example for . We use `?' to denote the unobserved entried. } \label{fig:toy}
\end{figure}

In Figure \ref{fig:toy2}, we present the reconstruction performance of various matrix completion solvers after 300 iterations. Although there are multiple solutions that induce the recovered matrix and have the same rank as , most of the algorithms in comparison reconstruct  successfully. We note that, in some cases, the inadequancy of an algorithm to reconstruct  is not because of the (relaxed) problem formulation but due to its fast---but inaccurate---implementation (fast convergence versus reconstruction accuracy tradeoff).

\begin{figure*}[ht]
\hspace{1.5cm}\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (a) SVT
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (b) FPC
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (c) SVP ()
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (d) ALM
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (e) OptSpace
\end{minipage} 
\\

\hspace{1.5cm}\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (f) SET
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (g) ADMiRA
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (h) GRASTA
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (i) LMatFit
\end{minipage}
\hspace{0.4cm}
\begin{minipage}[c]{0.15\linewidth}
\centering
 \hspace{-1.1cm} (j) \textsc{Matrix ALPS II}
\end{minipage}
\caption{\small\sl Toy example reconstruction performance for various algorithms. We observe that  is an integer matrix---since the algorithms under consideration return real matrices as solutions, we round the solution elementwise. } \label{fig:toy2}
\end{figure*}

\subsection{Synthetic data}

\textbf{General affine rank minimization using noiselets:} In this experiment, the set of observations  satisfy:
 Here, we use permuted and subsampled noiselets for the linear operator  \cite{sparcs}. The signal  is generated as the multiplication of two low-rank matrices,  and , such that  and . Both  and  have random independent and identically distributed (iid) Gaussian entries with zero mean and unit variance. In the noisy case, the additive noise term  contains entries drawn from a zero mean Gaussian distribution with . 

We compare the following algorithms: SVP, ADMiRA, \textsc{Matrix ALPS I}, \textsc{Matrix ALPS II} and \textsc{Matrix ALPS II} with QR for various problem configurations, as depicted in Table \ref{table:1} (there is no available code with arbitrary sensing operators for the rest algorithms). In Table \ref{table:1}, we show the median values of reconstruction error, number of iterations and execution time over 50 Monte Carlo iterations. For all cases, we assume  and we set the maximum number of iterations to 500. Bold font denotes the fastest execution time. Furthermore, Figure \ref{fig: TableI_fig} illustrates the effectiveness of the algorithms for some representative problem configurations.

In Table \ref{table:1}, \textsc{Matrix ALPS II} and \textsc{Matrix ALPS II} with QR obtain accurate low-rank solutions much faster than the rest of the algorithms in comparison. In high dimensional settings, \textsc{Matrix ALPS II} with QR scales better as the problem dimensions increase, leading to faster convergence. Moreover, its execution time is at least a few orders of magnitude smaller compared to SVP, ADMiRA and \textsc{Matrix ALPS I} implementations.

\begin{table*}
\caption{General ARM using Noiselets.} {\label{table:1}}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
\multicolumn{4}{c|}{Configuration} & FR & \multicolumn{3}{|c|}{SVP} & \multicolumn{3}{|c|}{ADMiRA} & \multicolumn{3}{|c}{\textsc{Matrix ALPS I}} \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline \hline \hline

\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{\textsc{Matrix ALPS II}} & \multicolumn{6}{|c}{\textsc{Matrix ALPS II} with QR}  \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{2}{|c}{\rm{iter.}} & \multicolumn{2}{c}{\rm{err.}} & \multicolumn{2}{c}{\rm{time}}  \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{2}{|c}{} & \multicolumn{2}{c}{} & \multicolumn{2}{c}{} \\
\hline
\end{tabular}
\end{center}
\end{table*}

\begin{figure*}[!htp]
\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig1-crop}\label{fig:2a}} 
\hfill
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig2-crop}\label{fig:2b}}
\hfill 
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig3-crop}\label{fig:2c}}} \\
\centerline{\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig4-crop}\label{fig:2a}} 
\hfill
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig5-crop}\label{fig:2b}}
\hfill 
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableI-fig6-crop}\label{fig:2c}}}
\end{tabular}
\caption{\small\sl Low rank signal reconstruction using noiselet linear operator. The error curves are the median values across 50 Monte-Carlo realizations over each iteration. For all cases, we assume . (a) , ,  and . (b) , ,  and .  (c) , ,  and . (d) , ,  and . (e) , ,  and .  (f) , ,  and .   } \label{fig: TableI_fig}
\end{figure*}

\textbf{Robust matrix completion:} We design matrix completion problems in the following way. The signal of interest  is synthesized as a rank- matrix, factorized as  with  where  and  as defined above. In sequence, we subsample  by observing  entries, drawn uniformly at random. We denote the set of ordered pairs that represent the coordinates of the observable entries as  and let  denote the linear operator (mask) that samples a matrix according to . Then, the set of observations satisfies:
 i.e., the known entries of  are structured as a vector , disturbed by a dense noise vector  with fixed-energy, which is populated by iid zero-mean Gaussians. 

To demonstrate the reconstruction accuracy and the convergence speeds, we generate various problem configurations (both noisy and noiseless settings), according to (\ref{eq:RMC}). The energy of the additive noise takes values  . All the algorithms are tested for the same signal-matrix-noise realizations. A summary of the results can be found in Tables \ref{table:2}, \ref{table:3} and, \ref{table:4} where we present the median values of reconstruction error, number of iterations and execution time over 50 Monte Carlo iterations. For all cases, we assume  and set the maximum number of iterations to 700. Bold font denotes the fastest execution time. Some convergence error curves for specific cases are illustrated in Figures \ref{fig: TableII_fig} and \ref{fig: TableIII_IV_fig}.

In Table \ref{table:2}, LMaFit \cite{LMatFit} implementation has the fastest convergence for small scale problem configuration where  and . We note that part of LMaFit implementation uses C code for acceleration. GROUSE \cite{GROUSE} is a competitive low-rank recovery method with attractive execution times for the {\it extreme low rank} problem settings due to stochastic gradient descent techniques. Nevertheless, its execution time performance degrades significantly as we increase the rank of . Moreover, we observe how randomized low rank projections accelerate the convergence speed where \textsc{Matrix ALPS II} with QR converges faster than \textsc{Matrix ALPS II}. In Tables \ref{table:3} and \ref{table:4}, we increase the problem dimensions. Here, \textsc{Matrix ALPS II} with QR has faster convergence for most of the cases and scales well as the problem size increases. We note that we do not exploit stochastic gradient descent techniques in the recovery process to accelerate convergence which is left for future work.

\begin{table*}[!htp]
\caption{Matrix Completion problem for  and . ``'' depicts no information or not applicable due to time overhead.} {\label{table:2}}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\multicolumn{4}{c|}{Configuration} & FR & \multicolumn{3}{|c|}{SVP} & \multicolumn{3}{|c|}{GROUSE} & \multicolumn{3}{|c}{TFOCS} \\
\hline \hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\

\hline \hline \hline
\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{Inexact ALM} & \multicolumn{3}{|c|}{OptSpace} & \multicolumn{3}{|c}{GRASTA} \\
\hline \hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\

\hline \hline \hline
\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{RTRMC} & \multicolumn{3}{|c|}{LMaFit} & \multicolumn{3}{|c}{\textsc{Matrix ALPS I}} \\
\hline \hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\

\hline \hline \hline
\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{ADMiRA} & \multicolumn{3}{|c|}{\textsc{Matrix ALPS II}} & \multicolumn{3}{|c}{\textsc{Matrix ALPS II} with QR} \\
\hline \hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\

\hline
\end{tabular}
\end{center}
\end{table*}

\begin{figure*}[!htp]
\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.4\textwidth]{TableII-fig1-crop}\label{fig:2a}} 
\hspace{1cm}
\subfigure[]{\includegraphics[width = 0.4\textwidth]{TableII-fig2-crop}\label{fig:2b}}}
\end{tabular}
\caption{\small\sl Low rank matrix recovery for the matrix completion problem. The error curves are the median values across 50 Monte-Carlo realizations over each iteration. For all cases, we assume . (a) , ,  and . (b) , ,  and . } \label{fig: TableII_fig}
\end{figure*}


\begin{table*} [!htp]
\caption{Matrix Completion problem for  and . ``'' depicts no information or not applicable due to time overhead.} {\label{table:3}}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
\multicolumn{4}{c|}{Configuration} & FR & \multicolumn{3}{|c|}{SVP} & \multicolumn{3}{|c|}{Inexact ALM} & \multicolumn{3}{|c}{GROUSE} \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline  \hline \hline

\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{LMaFit} & \multicolumn{3}{|c}{\textsc{Matrix ALPS II}} & \multicolumn{3}{|c}{\textsc{Matrix ALPS II} with QR}  \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}}  \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\end{tabular}
\end{center}
\end{table*}

\begin{table*} [!htp]
\caption{Matrix Completion problem for  and . ``'' depicts no information or not applicable due to time overhead.} {\label{table:4}}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
\multicolumn{4}{c|}{Configuration} & FR & \multicolumn{3}{|c|}{SVP} & \multicolumn{3}{|c|}{Inexact ALM} & \multicolumn{3}{|c}{GROUSE} \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}} \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline \hline \hline

\multicolumn{4}{c|}{} & & \multicolumn{3}{|c|}{LMaFit} & \multicolumn{3}{|c}{\textsc{Matrix ALPS II}} & \multicolumn{3}{|c}{\textsc{Matrix ALPS II} with QR}  \\
\hline \hline
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} & & 
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c|}{\rm{time}} &
\multicolumn{1}{|c}{\rm{iter.}} & \multicolumn{1}{c}{\rm{err.}} & \multicolumn{1}{c}{\rm{time}}  \\
\hline\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}  & \multicolumn{1}{c|}{} &  & 
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c|}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &
\multicolumn{1}{|c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} \\
\hline
\end{tabular}
\end{center}
\end{table*}

\begin{figure*}[!htp]
\centering
\begin{tabular}{ccc}
\centerline{\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIII-fig1-crop}\label{fig:2a}} 
\hfill
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIII-fig2-crop}\label{fig:2b}}
\hfill 
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIII-fig3-crop}\label{fig:2c}}} \\
\centerline{\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIV-fig1-crop}\label{fig:2a}} 
\hfill
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIV-fig2-crop}\label{fig:2b}}
\hfill 
\subfigure[]{\includegraphics[width = 0.33\textwidth]{TableIV-fig3-crop}\label{fig:2c}}}
\end{tabular}
\caption{\small\sl Low rank matrix recovery for the matrix completion problem. The error curves are the median values across 50 Monte-Carlo realizations over each iteration. For all cases, we assume . (a) , ,  and . (b) , ,  and . (c) , ,  and . (d) , ,  and . (e) , ,  and . (f) , ,  and .  } \label{fig: TableIII_IV_fig}
\end{figure*}

\subsection{Real data}

We use real data images to highlight the reconstruction performance of the proposed schemes. To this end, we perform grayscale image denoising from an incomplete set of observed pixels---similar experiments can be found in \cite{LMatFit}. Based on the matrix completion setting, we observe a limited number of pixels from the original image and perform a low rank approximation based only on the set of measurements. While the true underlying image might not be low-rank, we apply our solvers to obtain low-rank approximations.

Figures \ref{fig:real1} and \ref{fig:real2} depict the reconstruction results. In the first test case, we use a  grayscale image as shown in the top left corner of Figure \ref{fig:real1}. For this case, we observe only the  of the total number of pixels, randomly selected---a realization is depicted in the top right plot in Figure \ref{fig:real1}. In sequel, we fix the desired rank to . The best rank- approximation using SVD is shown in the top middle of Figure \ref{fig:real1} where the full set of pixels is observed. Given a fixed common tolerance and the same stopping criteria, Figure \ref{fig:real1} shows the recovery performance achieved by a range of algorithms under consideration for 10 Monte-Carlo realizations.  We repeat the same experiment for the second image in Figure \ref{fig:real2}. Here, the size of the image is , the desired rank is set to  and we observe the  of the image pixels. In constrast to the image denoising procedure above, we measure the reconstruction error of the computed solutions with respect to the {\it best rank- approximation} of the true image. In both cases,  we note that \textsc{Matrix ALPS II} has a better phase transition performance as compared to the rest of the algorithms.
\begin{figure*}[!htp]
\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Original}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Low Rank Approximation}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Observed Image}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{boat-original-crop} 
\includegraphics[width = 0.28\linewidth]{boat-lowrank-crop} 
\includegraphics[width = 0.28\linewidth]{boat-MC-crop}\\

\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{SVP -  dB}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{ALM -  dB}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{LMaFit -  dB}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{boat-SVP-crop} 
\includegraphics[width = 0.28\linewidth]{boat-ALM-crop} 
\includegraphics[width = 0.28\linewidth]{boat-LMaFit-crop} \\

\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{\textsc{\textsc{Matrix ALPS I}} -  dB}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{ADMiRA -  dB}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{\textsc{\textsc{Matrix ALPS II}} -  dB}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{boat-MatrixALPSI-crop} 
\includegraphics[width = 0.28\linewidth]{boat-ADMiRA-crop} 
\includegraphics[width = 0.28\linewidth]{boat-MatrixALPSII-crop}\\
\caption{\small{Reconstruction performance in image denoising settings. The image size is  and the desired rank is preset to . We observe  of the pixels of the true image. We depict the median reconstruction error with respect to the true image in dB over  Monte Carlo realizations.}} {\label{fig:real1}}
\end{figure*}


\begin{figure*}[!htp]
\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Original}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Low Rank Approximation}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{Observed Image}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{house-original-crop} 
\includegraphics[width = 0.28\linewidth]{house-lowrank-crop} 
\includegraphics[width = 0.28\linewidth]{house-MC-crop}\\

\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{SVP -  dB}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{ALM -  dB}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{LMaFit -  dB}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{house-SVP-crop} 
\includegraphics[width = 0.28\linewidth]{house-ALM-crop} 
\includegraphics[width = 0.28\linewidth]{house-LMaFit-crop} \\

\centering
\begin{minipage}{0.28\linewidth}
\centering \normalsize{\textsc{\textsc{Matrix ALPS I}} -  dB}
\end{minipage} 
\begin{minipage}{0.28\linewidth}
\centering \normalsize{ADMiRA -  dB}
\end{minipage}
\begin{minipage}{0.28\linewidth}
\centering \normalsize{\textsc{\textsc{Matrix ALPS II}} -  dB}
\end{minipage} \vspace{0.1cm}\\

\includegraphics[width = 0.28\linewidth]{house-MatrixALPSI-crop} 
\includegraphics[width = 0.28\linewidth]{house-ADMiRA-crop} 
\includegraphics[width = 0.28\linewidth]{house-MatrixALPSII-crop}\\
\caption{\small{Reconstruction performance in image denoising settings. The image size is  and the desired rank is preset to . We observe  of the pixels of the best rank- approximation of the image. We depict the median reconstruction with respect to the best rank- approximation in dB over  Monte Carlo realizations}} {\label{fig:real2}}
\end{figure*}

\section{Discussion}{\label{sec: conc}}

In this paper, we present new strategies and review existing ones for hard thresholding methods to recover low-rank matrices from dimensionality reducing, linear projections. Our discussion revolves around four basic building blocks that exploit the problem structure to reduce computational complexity without sacrificing stability.  

In theory, constant  selection schemes are accompanied with strong RIP constant conditions but empirical evidence reveal signal reconstruction vulnerabilities. While convergence derivations of adaptive schemes are characterized by weaker bounds, the performance gained by this choice in terms of convergence rate, is quite significant. Memory-based methods lead to convergence speed with (almost) no extra cost on the complexity of hard thresholding methods---we provide theoretical evidence for convergence for simple cases but more theoretical justification is needed to generalize this part as future work. Lastly, further estimate refinement over low rank subspaces using gradient update steps or pseudoinversion optimization techniques provides signal reconstruction efficacy, but more computational power is needed per iteration. 

We connect -approximation low-rank revealing schemes with first-order gradient descent algorithms to solve general affine rank minimization problems; to the best of our knowledge, this is the first attempt to theoretically characterize the performance of iterative greedy algorithms with -approximation schemes. In all cases, experimental results illustrate the effectiveness of the proposed schemes on different problem configurations.

\section*{Acknowledgments}
This work was supported in part by the European Commission under Grant MIRG-268398, ERC Future Proof, SNF 200021-132548 and DARPA KeCoM program \#11-DARPA-1055. VC also would like to acknowledge Rice University for his Faculty Fellowship.

\appendix

\section{Appendix}
\begin{remark}
Let  with SVD: , and  with SVD: . Assume two sets:    where  is the -th singular vector of  and   and,    where  is the -th singular vector of ,  and, . We observe that the subspaces defined by  and  are not necessarily orthogonal. 

To this end, let ; this operation can be easily computed via SVD. Then, the following commutativity property holds true for any matrix :
 
\end{remark}
\subsection{Proof of Lemma \ref{lemma:act_subspace_exp}}

Given  using SVD factorization, we define the following quantities: . Then, given the structure of the sets  and 
 and 
 Since the subspace defined in  is the best rank- subspace, orthogonal to the subspace spanned by , the following holds true:
 Removing the common subspaces in  and  by the commutativity property of the projection operation and using the shortcut  for sets , we get:
 Next, we assume that  denotes the orthogonal projection onto the subspace spanned by . Then, on the left hand side of (\ref{ser:eq:01}), we have:


 where  due to triangle inequality over Frobenius metric norm,  since ,  by using the fact that ,  due to Lemma \ref{lemma:3},  due to Lemma \ref{lemma:4} and  since .

For the right hand side of (\ref{ser:eq:01}), we calculate:
 by using Lemmas \ref{lemma:3} and \ref{lemma:4}. Combining (\ref{ser:eq:02}) and (\ref{ser:eq:03}) in (\ref{ser:eq:01}), we get:


\subsection{Proof of Theorem \ref{thm:mALPS0}}

Let  be a set of orthonormal, rank-1 matrices that span the range of . In Algorithm 1, . Thus:


From Algorithm 1, ,   and  . We define  where  and let  be the orthogonal projection onto the subspace defined by . 

Since  and , the following hold true:


Then, (\ref{eq:mALPS0:00}) can be written as:


In B, we observe:
 where  holds since  for ,  is due to Cauchy-Schwarz inequality and,  is easily derived using Lemma \ref{lemma:1}.

In A, we perform the following motions:
 where  is due to  and  follows from Cauchy-Schwarz inequality. Since , Lemma \ref{lemma:3} implies:
 and thus:
 Furthermore, according to Lemma \ref{lemma:4}:
 since  for . Since  where 
 then:
 using Lemma \ref{lemma:act_subspace_exp}. Combining the above in (\ref{eq:mALPS:04}), we compute:


Combining (\ref{eq:mALPS0:02}) and (\ref{eq:mALPS0:03}) in (\ref{eq:mALPS0:01}), we get:


Focusing on steps 5 and 6 of Algorithm 1, we perform similar motions to obtain:
 
Combining the recursions in (\ref{eq:mALPS0:04}) and (\ref{eq:mALPS0:05}), we finally compute:
 for  and 
 For the convergence parameter , further compute:
 for . Calculating the roots of this expression, we easily observe that  for . 




\subsection{Proof of Theorem \ref{thm:mALPS5}}

Before we present the proof of Theorem \ref{thm:mALPS5}, we list a series of lemmas that correspond to the motions Algorithm 2 performs.

\begin{lemma}{\label{lemma:greedy}}[Error norm reduction via least-squares optimization] Let  be a set of orthonormal, rank-1 matrices that span a rank-2 subspace in . Then, the least squares solution  given by:
 satisfies:

\end{lemma}

\begin{proof}
We observe that  is decomposed as follows:

In (\ref{eq:mALPS5:00}),  is the minimizer over the low-rank subspace spanned by  with . Using the optimality condition (Lemma \ref{lemma:5}) over the convex set , we have:
 for .
Given condition (\ref{eq:mALPS5:03a}), the first term on the right hand side of (\ref{eq:mALPS5:02}) becomes: 
 Focusing on the term , we derive the following:
 where  follows from the facts that  and thus  and  is due to  since . Then, (\ref{eq:mALPS5:08}) becomes:
 where  comes from Cauchy-Swartz inequality and  is due to Lemmas \ref{lemma:1} and \ref{lemma:3}. Simplifying the above quadratic expression, we obtain: 


As a consequence, (\ref{eq:mALPS5:02}) can be upper bounded by:


We form the quadratic polynomial for this inequality assuming as unknown variable the quantity . Bounding by the largest root of the resulting polynomial, we get:
 
\end{proof}

The following Lemma characterizes how subspace {\it pruning} affects the recovered energy:

\begin{lemma}{\label{lemma:comb_selection}}[Best rank- subspace selection] Let  be a rank- proxy matrix in the subspace spanned by  and let  denote the best rank- approximation to , according to (\ref{eq:svd_proj}). Then:

\end{lemma}

\begin{proof}
Since  denotes the best rank- approximation to , the following inequality holds for any rank- matrix  in the subspace spanned by , i.e. :
 Since , the left inequality in (\ref{eq:mALPS5:13}) is satisfied for  in (\ref{eq:mALPS5:14}). 
\end{proof}

\begin{lemma}{\label{lemma:noname}} Let  be the least squares solution in Step 2 of the ADMiRA algorithm
and let  be a proxy, rank- matrix to  according to:  Then,  can be expressed in terms of the distance from  to  as follows:

\end{lemma}

\begin{proof}
We observe the following

Focusing on the right hand side of expression (\ref{eq:18}),  can be similarly analysed as in Lemma 10 where we obtain the following expression:


Now, expression (\ref{eq:18}) can be further transformed as:
 where  is due to (\ref{eq:24}). Using Lemma \ref{lemma:comb_selection}, we further have:
 Furthermore, replacing  with its upper bound defined in (\ref{eq:mALPS5:10}), we get:
 where  is obtained by completing the squares and eliminating negative terms. 
\end{proof}

Applying basic algebra tools in (\ref{eq:73}) and (\ref{eq:mALPS5:01}), we get:
 

Since , we observe . Then, using Lemma \ref{lemma:act_subspace_exp}, we obtain:


Given ,  is upper bounded by . Then, 




\subsection{Proof of Theorem \ref{thm:mALPS0:memory}}

Let  be a set of orthonormal, rank-1 matrices that span the range of . In Algorithm 3,  is the best rank- approximation of . Thus:


From Algorithm 3, ,   and  . We define  where we observe  and let  be the orthogonal projection onto the subspace defined by . 

Since  and , the following hold true:
 and,
 

\begin{figure*}[!htp]
 
\hrulefill
\end{figure*}

Then, (\ref{eq:mALPS0_memory:00}) can be written as:
 where  is due to  and  follows from Cauchy-Schwarz inequality. 
Since , Lemma \ref{lemma:3} implies:
 and thus:
 Furthermore, according to Lemma \ref{lemma:4}:
 since  where . Since  where 
 then:
 using Lemma \ref{lemma:act_subspace_exp}. Using the above in (\ref{eq:mALPS_memory:04}), we compute:


Furthermore:
 Combining (\ref{eq:mALPS0_memory:04}) and (\ref{eq:mALPS_memory:05}), we get:
 Let  and . Then, (\ref{eq:mALPS_memory:06}) defines the following homogeneous recurrence:
 Using the {\it method of characteristic roots} to solve the above recurrence, we assume that the homogeneous linear recursion has solution of the form  for . Thus, replacing  in (\ref{eq:mALPS_memory:07}) and factoring out , we form the following characteristic polynomial:
 Focusing on the worst case where (\ref{eq:mALPS_memory:08}) is satisfied with equality, we compute the roots  of the quadratic characteristic polynomial as:
 Then, as a general solution, we combine the above roots with unknown coefficients  to obtain (\ref{eq:mALPS_memory:09}).
Using the initial condition , we get . Thus, we conclude to the following recurrence:





\subsection{Proof of Lemma \ref{lemma:appr_act_subspace_exp}}

Let 
 and 
Using Definition \ref{def:appr_svd}, the following holds true:

Furthermore, we observe:
 Here, we use the notation defined in the proof of Lemma 6. Since  is the best rank- approximation to , we have:
 where . Using (\ref{eq:appr_act:00}) in (\ref{eq:appr_act:02}), the following series of inequalities are observed:
 Now, in (\ref{eq:appr_act:01}), we compute the series of inequalities in (\ref{eq:start})-(\ref{eq:appr_act:04a}).
\begin{figure*}[!htp]

\hrulefill
\end{figure*}
Focusing on , we observe:
 

Moreover, we know the following hold true from Lemma \ref{lemma:act_subspace_exp}:
 and
 Combining (\ref{eq:appr_act:04})-(\ref{eq:appr_act:07}) in (\ref{eq:appr_act:04a}), we obtain:


\subsection{Proof of Theorem \ref{thm:mALPS0_appr}}

To prove Theorem \ref{thm:mALPS0_appr}, we combine the following series of lemmas for each step of Algorithm 1.

\begin{lemma}{\label{lemma:appr_greedy}}[Error norm reduction via gradient descent] Let  be a set of orthonormal, rank-1 matrices that span a rank-2 subspace in . Then (\ref{eq:appr_mALPS5:01}) holds.
\begin{figure*}[!htp]

\hrulefill
\end{figure*}
\end{lemma}

\begin{proof} We observe the following:

The following equations hold true:
 Furthermore, we compute:
 where  is due to Lemmas \ref{lemma:1}, \ref{lemma:3}, \ref{lemma:4} and .

Using the subadditivity property of the square root in (\ref{eq:appr_greedy:00}), (\ref{eq:appr_greedy:02}), Lemma \ref{lemma:appr_act_subspace_exp} and the fact that , we obtain:
 where 
\end{proof}

We exploit Lemma \ref{lemma:appr_comb_selection} to obtain the following inequalities:
 where the last inequality holds since  is the best rank- matrix estimate of  and, thus, .

Following similar motions for steps 6 and 7 in Matrix ALPS I, we obtain:
 Combining (\ref{eq:mALPS0_appr:04}), (\ref{eq:mALPS0_appr:01}) and (\ref{eq:mALPS0_appr:00}), we obtain the desired inequality.

\bibliographystyle{unsrt}
\bibliography{recipes}

\end{document}
