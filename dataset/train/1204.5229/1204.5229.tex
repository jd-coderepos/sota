\documentclass{llncs}

\usepackage{url}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{latexsym}
\usepackage{epsfig}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{wasysym}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{framed}
\usepackage{paralist}


\pagestyle{plain}

\usepackage{comment}

\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[pdf]{pstricks}
\usepackage{pstricks-add}
\usepackage{pdfpages}
\usepackage{titlepic}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\DontPrintSemicolon

\usepackage{nzproof,theorem}

\newcommand{\eqdef}{\stackrel{\rm{def}}{=}}

\begin{document}

\title{Selection in the Presence of Memory Faults, with Applications to In-place Resilient Sorting}
\author{
    Tsvi Kopelowitz
    \and
    Nimrod Talmon}
\institute{
    Weizmann Institute of Science, Rehovot, Israel.\\ \email{\{kopelot,nimrodtalmon77\}@gmail.com}}
\maketitle


\begin{abstract}

The selection problem, where one wishes to locate the  smallest element in an unsorted array of size , is one of the basic problems studied in computer science. The main focus of this work is designing algorithms for solving the selection problem in the presence of memory faults. These can happen as the result of cosmic rays, alpha particles, or hardware failures.

Specifically, the computational model assumed here is a faulty variant of the RAM model (abbreviated as \emph{FRAM}), which was introduced by Finocchi and Italiano~\cite{resilient_data_structures}. In this model, the content of memory cells might get corrupted adversarially during the execution, and the algorithm cannot distinguish between corrupted cells and uncorrupted cells. The model assumes a constant number of reliable memory cells that never become corrupted, and an upper bound  on the number of corruptions that may occur, which is given as an auxiliary input to the algorithm. An output element is correct if it has rank between  and  in the input array, where  is the number of corruptions that occurred during the execution of the algorithm. An algorithm is called \emph{resilient} if it always outputs a correct answer.

The main contribution of this work is a deterministic resilient selection algorithm with optimal  worst-case running time. Interestingly, the running time does not depend on the number of faults, and the algorithm does not need to know . As part of the solution, several techniques that allow to sometimes use non-tail recursion algorithms in the FRAM model are developed. Notice that using recursive algorithms in this model is problematic, as the stack might be too large to fit in reliable memory.

The aforementioned resilient selection algorithm can be used to improve the complexity bounds for resilient -d trees developed by Gieseke, Moruz and Vahrenhold~\cite{kd_trees}. Specifically, the time complexity for constructing a -d tree is improved from  to .

Besides the deterministic algorithm, a randomized resilient selection algorithm is developed, which is simpler than the deterministic one, and has  expected time complexity and  space complexity (i.e., is in-place). This algorithm is used to develop the first resilient sorting algorithm that is in-place and achieves optimal  expected running time.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Computing devices are becoming smaller and faster. As a result, the likelihood of soft memory errors (which are not caused by permanent failures) is increased. In fact, a recent practical survey~\cite{soft_error_rate} concludes that a few thousands of soft errors per billion hours per megabit is fairly typical, which would imply roughly one soft error every five hours on a modern PC with 24 gigabytes of memory~\cite{CDK11}. The causes of these soft errors vary and include cosmic rays~\cite{radiation}, alpha particles~\cite{alpha_particles}, or hardware failures~\cite{hardware_errors}.

\subsection{The Faulty RAM Model}

To deal with these faults, the faulty RAM (FRAM) model has been proposed by Finocchi and Italiano~\cite{resilient_data_structures}, and has received some attention \linebreak \cite{optimal_resilient_dictionaries,resilient_and_external_memory,resilient_counters,dynamic_programming,resilient_sorting,resilient_dictionaries,kd_trees,resilient_priority_queues}. \linebreak In this model, an upper bound on the number of corruptions is given to the algorithm, and is denoted by , while the \emph{actual} number of faults is denoted by  (. Memory cells may become corrupted at any time during an algorithm's execution and the algorithm cannot distinguish between corrupted cells and uncorrupted cells. The same memory cell may become corrupted multiple times during a single execution of an algorithm. In addition, the model assumes the existence of  reliable memory cells, which are needed, for example, to reliably store the code itself. A cell is assumed to contain  bits, where  is the size of the input, as is usual in the RAM model.

One of the interesting aspects of developing algorithms in the FRAM model is that the notion of correctness is not always clear. Usually, correctness is defined with respect to the subset of uncorrupted memory cells and in a worst-case sense, implying that for an algorithm to be correct, it must be correct in the presence of any faulty environment, including an adversarial environment. For example, in the sorting problem the goal is to order the input elements such that the uncorrupted subset of the array is guaranteed to be sorted~\cite{resilient_data_structures}. In the FRAM model, an algorithm that is always correct (which is problem dependent) is called \emph{resilient}.

A naive way of implementing a resilient algorithm is by storing  copies of every piece of data. Writing is done by writing the same value to all copies, and reading is done by computing the majority of the copies. Using this technique, most if not all\footnote{The reason this might not be true is because it could depend on the correctness of the problem under the FRAM model. For example, the goal of finding the \emph{exact} -order statistics is not achievable  in this model, as is explained in Section~\ref{sec:preliminaries}.} non-resilient algorithms can be made resilient with  multiplicative overhead in time and space complexity.



\subsection{Previous Work}

A summary of the algorithms and data structures that have been developed in the FRAM model is given next.

\paragraph{Resilient Searching:} 
		
		Finocchi and Italiano~\cite{resilient_data_structures} and
		Finocchi, Grandoni and Italiano~\cite{resilient_sorting},
		developed an almost optimal resilient searching algorithm,
		which finds an element in a sorted array of size  in ,
		where uncorrupted elements are guaranteed to be found.
		The main idea is to perform a slow reliable verification step once in every 
		fast but unreliable binary search steps.    
		A somewhat natural lower bound of  was proven there as well.
		A matching upper bound was developed by
		Brodal, Fagerberg, Finocchi, Grandoni, Italiano, J{\o}rgensen, Moruz and M{\o}lhave~\cite{optimal_resilient_dictionaries},
		using a different method.

\paragraph{Resilient Dictionaries:}

	The dynamic counterpart of searching is the dictionary data structure.
	An optimal resilient dictionary,
	supporting updates (insertions and deletions) and queries (searches)
	in  amortized time per operation,
	was developed by Brodal et al.~\cite{optimal_resilient_dictionaries}.
	Again, uncorrupted elements are guaranteed to be found.

\paragraph{Resilient Sorting:}

	Finocchi et al.~\cite{resilient_data_structures,resilient_sorting},
	developed a resilient sorting algorithm,
	sorting an array of size  in  time.
	The uncorrupted subset of the array is guaranteed to be sorted.
	The algorithm is an iterative version of Mergesort,
	with a resilient merging step.
	A matching (and somewhat surprising) lower bound
	was proven there as well.
	
\paragraph{Resilient Priority Queues:}

	Another basic data structure, a resilient priority queue,
	was developed by J{\o}rgensen, Moruz and M{\o}lhave~\cite{resilient_priority_queues}.
	The data structure supports \emph{insert} and \emph{deletemin} in  amortized time,
	where the \emph{deletemin} operation returns either the minimum element among the uncorrupted elements,
	or a corrupted element.
	A matching lower bound was given there as well.	
		
\paragraph{Resilient Counters:}

	Brodal, Gr{\o}nlund, J{\o}rgensen, Moruz and \linebreak M{\o}lhave~\cite{resilient_counters},
	developed several resilient counters,
	supporting increments and queries,
	where the result of a query is an -additive approximation
	to the number of increments performed until the query.
	While the proven lower bound of  space and time
	is not achieved, several interesting tradeoffs are presented there.

\paragraph{Dynamic Programming:}	
	
	Caminiti, Finocchi and Fusco~\cite{first_dynamic_programming}
	and Caminiti, Finocchi, Fusco and Silvestri~\cite{dynamic_programming},
	developed a resilient and cache-oblivious dynamic programming meta algorithm,
	computing the correct answer with high probability,
	using  and  space,
	where  is the dimension of the table of the dynamic programming.

\paragraph{Resilient External Memory Algorithms:}

	The problem of designing algorithms that are simultaneously
	cache efficient and resilient was addressed by
	Brodal, J{\o}rgensen, Gr{\o}nlund and M{\o}lhave~\cite{resilient_and_external_memory}.
	They showed matching upper \linebreak bounds and lower bounds
	for a deterministic and randomized dictionary,
	a deterministic priority queue,
	and a deterministic sorting algorithm.

\paragraph{-d Trees:}

	The problem of -means clustering in the presence of memory faults
	was addressed by Gieseke et al.~\cite{kd_trees}.
	They developed a resilient -d tree,
	supporting orthogonal range queries in
	 where  is the is the size of the output.










\subsection{Results}

\paragraph{Deterministic Resilient Selection Algorithm:}

The main focus of this work is on the \emph{selection problem} (sometimes called the -order statistic problem) in the FRAM model, where one wishes to locate the  smallest element in an unsorted array of size , in the presence of memory faults. The following main theorem is proved in Section~\ref{sec:resilient_deterministic_selection_algorithm}.

\begin{theorem}
There exists a deterministic resilient selection algorithm with time complexity .
\end{theorem}

Interestingly, the running time does not depend on the number of faults. Moreover, the algorithm does not need to know  explicitly. The selection problem is a classic problem in computer science. Along with searching and sorting, it is one of the basic problems studied in the field, taught already at undergraduate level (e.g.,~\cite{CLRS}). The -order statistic of a set of samples is a basic concept in statistics as well (e.g.,~\cite{order_statistics}). There are numerous applications for the selection problem, thus devising efficient algorithms is of practical interest. The textbook algorithm by Blum, Floyd, Pratt, Rivest and Tarjan~\cite{median_of_medians_algorithm}
achieves linear time complexity in the (non-faulty) RAM model.

When considering the selection problem in the FRAM model, the first difficulty is to define correctness\footnote{The common notion of considering only the non-corrupted elements is somewhat misleading in the selection problem. This is because of the difficulty of not being able to distinguish between corrupted and uncorrupted data.}.  To this end, the correctness definition used here allows to return an element, which may even be corrupted, whose rank is between  to  in the input array. Notice that when  this definition coincides with the non-faulty definition (for a formal definition see Section~\ref{sec:preliminaries}).



\paragraph{Randomized Resilient Selection Algorithm:}

Besides the deterministic algorithm, a randomized and in-place counterpart is developed as well.
A randomized algorithm in the FRAM model is an algorithm that can use random coins. The faults are still adversarial, but the adversary cannot see the random coins of the algorithm, and the algorithm must be correct with probability , regardless of the coin tosses. The randomized selection algorithm is simpler than to the deterministic one, and is likely to beat the deterministic algorithm in practice.
The following theorem is proven in Section~\ref{sec:resilient_randomized_selection_algorithm}.

\begin{theorem}
There exists a randomized in-place resilient selection algorithm with expected time complexity .
\end{theorem}




\paragraph{Resilient -d Trees:}

The selection algorithm presented here can be used to improve the complexity bounds for resilient -d trees developed by Gieseke et al.~\cite{kd_trees}. There, a deterministic resilient algorithm for constructing a -d tree with  time complexity is shown. This can be improved to  by using the deterministic resilient selection algorithm developed here.

\begin{theorem}
There exists a resilient -d tree which can be constructed in deterministic  time.
It supports resilient orthogonal range queries in  time for reporting  points.
\end{theorem}



\paragraph{Resilient Quicksort Algorithms:}

The problem of sorting in the FRAM model is also revisited, as an application of the resilient selection algorithm. Finocchi et al.~\cite{resilient_sorting}, already developed a resilient Mergesort algorithm, sorting an array of size  in  time, where the uncorrupted subset of the array is guaranteed to be sorted. They also proved that this bound is tight. In Section~\ref{sec:resilient_quicksort_algorithms}, a new in-place randomized sorting algorithm which resembles Quicksort and runs in  expected time is presented. This sorting algorithm uses the randomized selection algorithm as a black box.
The following theorem is proven in Section~\ref{sec:resilient_quicksort_algorithms}.

\begin{theorem}
There exists a resilient deterministic sorting algorithm with worst-case running time of , and a resilient randomized in-place sorting algorithm with expected running time of .
\end{theorem}








\subsection{Recursion}

In the (non-faulty) RAM model the recursion stack needs to reliably store the local variables, as well as the frame pointer and the program counter. Corruptions of this data can cause the algorithm to behave unexpectedly, and in general the recursion stack cannot fit in reliable memory. Some new techniques for implementing a specific recursion stack which suffices for solving the selection problem are developed in Section~\ref{sec:recursion_implementation}. These techniques are used to develop the resilient deterministic selection algorithm presented in Section~\ref{sec:resilient_deterministic_selection_algorithm}. It is likely that these techniques can be used to help implement recursive algorithms for other problems in the FRAM model. The main technique developed here which allows to use non-tail recursion in the FRAM model is somewhat general, and can be used due to the following four points:

\begin{enumerate} 

\item \emph{Easily Inverted Size Function:} When performing a recursive call, the function which determines the size of the input to the recursive call can be easily inverted, while needing only  bits to maintain the data needed to perform the inversion.

\item \emph{Small Depth:} The depth of the recursion is bounded by  and so using  bits per level can fit in reliable memory.

\item \emph{Verification:} A linear verification procedure is used such that once a recursive call finishes, if the procedure accepts, then the algorithm may proceed even if some errors did occur in the recursive call. The main point here is that even though errors occurred, continuing onwards does not hurt the correctness.

\item \emph{Amortization:} If the verification procedure fails, then the number of errors which caused the failure is linear in the amount of time spent on the recursive call (not counting other verification procedures that failed within it). This means that the amortized cost of each corruption is .

\end{enumerate}

The only previous work done in the FRAM model for non-tail recursion was done by Caminiti et al.~\cite{dynamic_programming} where they developed a recursive algorithm for solving dynamic programming. However, the recursion inherited in the problem of dynamic programming is simpler compared to the recursion treated in the selection problem, due to the structural behavior of the dynamic programming table (the recursions depend on positioning within the table, and not on the actual data). Moreover, their solution only works with high probability (due to using fingerprints for the verification procedure).





\subsection{Related Work}

Other models and techniques to deal with memory corruptions do exist.
Some of them are given here, with an emphasis on their relation to the FRAM model.

\paragraph{Error Correcting Codes:}
		
		The field of error correcting codes and error detecting codes
		deals with the problem of reliably
		transmitting a message over a faulty communication channel.
		This is achieved by adding redundancy to the message (e.g., checksums).
		For a survey, see, e.g., ~\cite{ecc_survey}.
		The solutions developed in this field do not treat the implications of corruptions
		to the computation performed on the data.
		Therefore, applying these methods to the FRAM model
		in a non-naive way is not trivial.   
		
\paragraph{Error Correcting Memory:}
		
		Error detecting and correcting codes can be 
		implemented in the hardware itself (e.g., \cite{error_correcting_memory}).
		While this solution has its advantages,
		it imposes some costs in performance and money.
		
\paragraph{Pointer-Based Data Structures:}

		Aumann and Bender~\cite{aumann_bender} addressed the problem of losing
		data in a pointer-based data structures due to pointer corruptions.
		The data structures suggested by them incur only a small overhead in space and time,
		and guarantee an upper bound on the amount of uncorrupted data that can be lost due
		to pointer corruptions.
		This is in contrast to the FRAM model, where no uncorrupted  data is allowed to be lost.
		
\paragraph{Fault-Tolerant Parallel and Distributed Computation:}
	
		Extensive research on fault tolerance have been done in the field of 
		parallel and distributed computation.
		For a survey, see~\cite{fault_tolerant_distributed_computation}.
		The work done in this field deals with resiliency with respect to
		faulty processors or communication links, in contrast to the faulty memory
		which is assumed in the FRAM model.
		Some of the work assume the existence of fault detection
		hardware, therefore allowing the system to distinguish between faulty and non-faulty data,
		differently from the FRAM model.

\paragraph{Checkers:}

		Blum, Evans, Gemmell, Kannan and Naor~\cite{checkers} 
		addressed the problem of checking memory correctness in the presence of faults.
		In this model, the data structure is viewed as being controlled by an adversary.
		The goal of the checker,
		which is allowed to use a small amount of reliable memory,
		is to detect every deviation from the expected data, 
		with high probability. In the FRAM model, the goal is not to detect the 
		memory corruptions, but instead, to always behave correctly on the uncorrupted subset of the data.

\paragraph{Fault-Tolerant Sorting Networks:}
		
		Fault tolerance have been investigated in the context of sorting networks.
		Assaf and Upfal~\cite{fault_tolerant_sorting_networks} developed a resilient sorting network,
		with an  multiplicative overhead in the size of the network.
		The computational model is a sorting network and not a general purpose machine, as in the FRAM model.
				 
\paragraph{The Liar Model:} 

		In this model, the algorithm can access the data only through a noisy oracle.
		The algorithm queries the oracle and can possibly get a faulty answer (i.e., a lie).
		An upper bound on the number of these lies or a probability of a lie is assumed.
		See, e.g., ~\cite{liar_1} and~\cite{liar_2}.
		The data itself cannot get corrupted, therefore, 
		in this model, query replication strategies can be exploited,
		in contrast to the FRAM model.

\paragraph{Other Noisy Computational Model:}
		
		Several other noisy computational models have been investigated.
		Sherstov~\cite{robust_polynomials}, showed an optimal (in terms of degree) approximation polynomial
		that is robust to noise. Gacs and Gal~\cite{robust_circuits}, proved a lower bound on the number of gates
		in a noise resistant circuit.
		These works, as well as others, have more computational complexity theory flavour than the FRAM model,
		and treat different computational models from the FRAM model.










\subsection{Organization}

The paper is organized as follows.
In Section~\ref{sec:preliminaries} some definitions and preliminaries are given.
In Section~\ref{sec:resilient_randomized_selection_algorithm} the randomized selection algorithm is discussed,
followed by a discussion of the deterministic selection algorithm, in Section~\ref{sec:resilient_deterministic_selection_algorithm}.
The discussion of the stack and recursion implementation is treated independently and deferred to Section~\ref{sec:recursion_implementation}.
A discussion on the application of the resilient selection algorithm to resilient -d trees
is in Section~\ref{sec:resilient_kd_trees}. 
Finally, the in-place quicksort sorting algorithm is shown in Section~\ref{sec:resilient_quicksort_algorithms}.

















\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Definitions}

Let  be an array of size  of elements taken from a totally ordered set. Let  denote the state of  at the beginning of the execution of an algorithm  executed on . Let  be the number of corruptions that occurred during such execution.

\begin{definition}
Let  be an array and let  be an element. The \emph{rank of  in } is defined as . The \emph{-rank of  in } is defined as .
\end{definition}

Notice that the -rank of  in  is an interval containing the elements whose rank in  is not smaller than  and not larger than . In particular, if , this interval is equal to .
Moreover, if , then this interval is equal to the -order statistic, thus coincides with the non-faulty definition.

\begin{definition}
\label{def:resilient-selection-algorithm}
A \emph{resilient -selection algorithm} is an algorithm that is given an array  of size  and an integer , and returns an element , where  is the number of faults that occurred during the execution of the algorithm.~\end{definition}

Notice that if , then this definition coincides with the common non-faulty definition. That is, if no faults occur during an execution of a resilient selection algorithm, it should locate the exact -order statistic.
Moreover, if , no algorithm can return the \emph{exact} -order statistics, due to corruptions that can happen at the beginning of the execution.
Notice also that because the algorithm cannot distinguish between corrupted and uncorrupted memory cells, it may return an element which was not present in the array at the beginning of the execution.


















\subsection{Basic Procedures}

\begin{lemma}
\label{def:ranking-procedure}
There exists a \emph{resilient ranking procedure} with time complexity , that is given an array  of size  and an element , and returns an integer  such that .
\end{lemma}

\begin{pf}
A resilient ranking procedure can be implemented by scanning  while counting the number of elements smaller or equal to , denoted by . If , then . If , then , because each corruption can change at most one memory cell, changing the rank of  in  by \linebreak at most .
\end{pf}

\begin{lemma}
\label{resilient_partition_algorithm}
There exists a \emph{resilient partition procedure} with time complexity  and space complexity , that is given an array  of size  and an element , and reorders  such that the uncorrupted elements smaller (larger) than  are placed before (after) , and returns an element  such that .
\end{lemma}

\begin{pf}
A resilient partition procedure can be implemented by scanning  while counting the number of elements smaller or equal to , denoted by , such that whenever an element smaller than  is encountered it is swapped with the element at position .
\end{pf}

Notice that both procedures compute an integer  such that . Let  denote the value  computed by either procedure, such that whenever the notation  will be used, it will be understood from the context which procedure is used. Notice that if , then .

















\section{Randomized Resilient Selection Algorithm}
\label{sec:resilient_randomized_selection_algorithm}

As a starter, consider the following randomized resilient selection algorithm, denoted by \emph{Randomized-Select}. The algorithm is an adaptation of the randomized non-resilient selection algorithm by Hoare~\cite{hoare_selection}, with the following modification. The algorithm maintains an interval , where  () is a lower (upper) bound. When the algorithm queries the array  at index , the value  is chosen to be . This guarantees that even a faulty value is within the bounds.

All variables (i.e., , , , , , , ) are stored using reliable memory cells.

\vspace{15px}
\begin{algorithm}[H]
\SetKwFor{Loop}{repeat}{}{}

, , , \;
\Loop{}{
	 random element from \;
	\;
	partition  around  \# using the algorithm from Lemma~\ref{resilient_partition_algorithm}\;
	\# Let  denote \;
	\uIf{}
	{\Return \;}
	\uElseIf{}
	{, \;}
	\ElseIf{}
	{, , \;}
}

\caption{Randomized-Select(, )}
\end{algorithm}
\vspace{15px}

\begin{theorem}\label{theorem:random_select}
There exists a randomized in-place resilient selection algorithm with expected time complexity .
\end{theorem}




\begin{pf}
Correctness is proven by induction on the size of the array. The base case of size  is obvious. For the induction step, assume that for arrays of size smaller than  the algorithm returns an element . Consider an execution of the algorithm on an array of size . Let  denote the number of corruptions that occurred during the first iteration, and let  denote the number of corruptions that occurred during the rest of the execution (). During the first iteration of the algorithm, if , then  is returned and correctness follows from the definition of the resilient partition procedure, and from the fact that  is maintained in reliable memory. Otherwise, assume without loss of generality, that . The case where  is symmetric.

The second iteration considers a sub-array  of size . Therefore, by the induction hypothesis, . It is guaranteed that , because  is taken to be . Therefore,  is larger than all the uncorrupted elements in . Each corruption that occurred during the first iteration can change the rank of  by at most , therefore \linebreak . Notice that the above proves that the algorithm is correct with probability .

With regard to the expected time complexity, let  denote the number of iterations the algorithm does. If there are no faults (i.e., ), then the probability of choosing a pivot  such that  is . However, there are two types of possible corruptions. The first type is corruptions of elements that are used as pivot elements. The second type is corruptions of elements that are not used as pivot elements. Let  () denote the number of corruptions of the first (second) type.

Consider corruptions of the first type. Let  be indices of iterations such that  is the first iteration,  is the last iteration, and for every ,  is the first iteration after  such that , where  denotes the size of the sub-array at the beginning of the  iteration and  denotes the number of corruptions that occurred between the  iteration and the  iteration. It follows that  and . Let  denote the number of iterations between the  iteration and the  iteration (i.e., ).  is a random variable with a geometric distribution, and , by a similar reasoning as in the non-faulty case. Notice that  even when conditioned on earlier iterations. It follows that if there are only corruptions of the second type, then the running time is bounded by .

Consider corruptions of the second type. For a sub-array of size , the probability that the adversary corrupts the pivot element using  corruption is , because the adversary cannot see the random coins used by the algorithm. A corrupted pivot can result in up to  extra work. Therefore, the expected cost of a corrupted pivot is . To conclude, the expected time complexity is as follows\footnote{For simplicity, for ,  and  are defined to be .}:



Notice that the expectation of  is at most , even when conditioned on , for  (i.e., , for ). Therefore, using total expectation, it follows that, for :


Therefore,

\end{pf}





















\section{Deterministic Resilient Selection Algorithm}
\label{sec:resilient_deterministic_selection_algorithm}

The following deterministic resilient selection algorithm is similar in nature to the non-resilient algorithm by Blum, Floyd, Pratt, Rivest, and Tarjan~\cite{median_of_medians_algorithm}, but several major modifications are introduced in order to make it resilient. The algorithm is presented in a recursive form, but the recursion is implemented in a very specific way, as explained in Section~\ref{sec:recursion_implementation}.

In the non-faulty RAM model, the recursion stack needs to reliably store the local variables, as well as the frame pointer and the program counter. Corruptions of this data can cause the algorithm to behave unexpectedly, and in general the recursion stack cannot fit in reliable memory. Therefore, a special recursion implementation is needed. 

Generally, a recursive computation can be thought of as a traversal on a recursion tree , where the computation begins at the root. Each internal node  performs several recursive calls, which can be partitioned into two types: the \emph{first} type and the \emph{second} type. Each node performs at least one call of each type, and the calls may be interleaved. The idea is for each node , to locate the  smallest element in the array  of size . However, due to corruptions, this cannot be guaranteed, therefore a weaker guarantee is used, as explained later.















\subsection{Algorithm Description}

The root of the recursion tree is a call to \emph{Determinstic-Select(, , , )}.
The computation of an inner node  has two phases.









\subsubsection{First phase}

The goal of the first phase is to find a \emph{good} pivot, specifically, a pivot whose rank is in the range , where .\footnote{The exact choice of  (which is a function of , the size of the node ) relates to the recursion implementation as explained in Section~\ref{sec:recursion_implementation}. The idea is to always partition the array at a predetermined ratio, in order to provide more structure to the recursion, and this is what allows for the recursion size function to be easily invertible, as mentioned in Section~\ref{sec:introduction}. Notice that the  could be picked to be  for any constant , because this is needed for the running time of the algorithm, as explained in the proof of Theorem~\ref{theorem:det_select_alpha}.} Finding a pivot is done by computing the median of each group of five consecutive elements in , followed by a recursive call of the first type, to compute the median of these medians. The process is repeated until a \emph{good} pivot is found.

\subsubsection{Second phase}

The goal of the second phase is to find a \emph{good} element. Specifically, an element whose rank is in  where  is a second type child of . This will be shown to be sufficient\footnote{The exact choice of  relates to the proof by induction for the correctness of the algorithm. The idea is that as long as less then  corruptions occurred during the computation of , the rank of the element located by  is guaranteed, by induction, to be in these bounds. See the proof of Lemma~\ref{lem:analysis_1} and the proof of Lemma~\ref{lem:second_phase_repetitions}.}. This is done by making a recursive call of the second type, which considers only the relevant sub-array with the updated order statistic. Notice that, unlike the non-faulty selection algorithm, here the appropriate sub-array might be padded with more elements, so that the size of the sub-array is . This is important for the recursion implementation, as explained in Section~\ref{sec:recursion_implementation}. If the returned value from the recursive call is not in the accepted range, the entire computation of the node repeats, starting from the first phase. Once a \emph{good} element is found, it is returned to the caller.

\newpage








\vspace{10mm}

\begin{algorithm}[H]

\SetKw{Or}{or}
\SetKw{Goto}{goto}

\# The algorithm uses the recursion implementation from Lemma~\ref{lem:recursion_lemma} \;
\Repeat{
	 \#  is a second type child of the node
}{	
	\# Let  denote \;
	\Begin(First Phase){
		\Repeat{
			
		}{
			\;
			\For{}{ median of \;}
			 Deterministic-Select(, , , )\;
			partition  around  \# using the algorithm from Lemma~\ref{resilient_partition_algorithm}\;
			\# Let  denote \;
		}
	}
	
	\Begin(Second Phase){
		\uIf{}{\Return \;}
		\uElseIf{}{ Deterministic-Select(, , , )\;}
		\ElseIf{}{ Deterministic-Select(, , , )\;}
	}
}

\Return \;

\caption{Deterministic-Select(, , , , )}
\end{algorithm}



\vspace{10mm}






Let  be the number of corruptions that occurred in 's sub-tree. Each node uses two boundary values  and  which are used similarly to the bounds used in the randomized resilient algorithm.

The recursive calls are made with the parameters , , , , , and each recursive call returns an element . In Section~\ref{sec:recursion_implementation}, a recursion implementation with the following properties is described.

\begin{lemma}
\label{lem:recursion_lemma}
There exists a recursion implementation for the resilient deterministic selection algorithm with the following properties:
\begin{enumerate}
	\item
		The position of , , the return value, and program counter are reliable.\footnote{This means that these variables are correct,
		as long as no more than  faults occurred.}
	\item 
		If , then , ,  are reliable.\footnote{This means that these variables are correct,
		as long as no more than  faults occurred.}
	\item
		The time overhead induced by the implementation is  per call.
\end{enumerate}
\end{lemma}
The proof of the Lemma is given in Section~\ref{sec:recursion_implementation}.











\subsection{Analysis}

Let  be a node. Let  be 's children.  is always a first type node, and  is always a second type node. Every second type child, except , is followed by a first type child, therefore there cannot be two adjacent second type children (see Fig.~\ref{fig:recursion_tree}). Let  denote the number of corruptions that occur in 's sub-tree and let  denote the number of corruptions that occur only in 's data. Let  denote the number of corruptions that occur in 's data between the execution of  and the execution of  (or until  finishes its computation, if  is the last child of ) and let  denote the number of corruptions that occur in 's data before the execution of . It follows that, . Let  denote the state of  at the beginning of 's computation. Let  denote the state of  at the moment of the call to .






\vspace{0.4in}


\begin{figure}
\psset{gridcolor=red,subgridcolor=blue}

\psset{unit=1.5cm}

\hspace*{-1.0in}
\begin{pspicture}(-2.5,0)(5,3)

\pscircle(3.5,3){0.5}
\rput(3.5,3){}

\pscircle[linestyle=dashed](1,1.5){0.5}
\rput(1,1.5){}
\pscircle(2.25,1.5){0.5}
\rput(2.25,1.5){}
\pscircle[linestyle=dashed](3.5,1.5){0.5}
\rput(3.5,1.5){}
\pscircle[linestyle=dashed](4.75,1.5){0.5}
\rput(4.75,1.5){}
\pscircle(6,1.5){0.5}
\rput(6,1.5){}

\psline(3.5,2.5)(1,2)
\psline(3.5,2.5)(2.25,2)
\psline(3.5,2.5)(3.5,2)
\psline(3.5,2.5)(4.75,2)
\psline(3.5,2.5)(6,2)

\psbrace[rot=90,ref=t,braceWidth=0.01](0.5,1)(2.75,1){}
\psbrace[rot=90,ref=t,braceWidth=0.01](3,1)(4,1){}

\end{pspicture}


\caption{A node  with five children:  is depicted. The nodes ,, are first type children of , while the nodes , are second type children of . The braces show the corruptions amortization, specifically,  pays for  and for itself and  pays for itself.}
\label{fig:recursion_tree}
\vspace{0.2in}
\end{figure}












The following Lemmas are used to prove the correctness and the running time of \emph{Deterministic-Select} in Thm.~\ref{theorem:det_select_alpha}.




\begin{lemma}
\label{lem:analysis_1}
If , then .
\end{lemma}

\begin{pf}
The proof is by induction on . The base case is defined to be where  is . In this case, , and the claim is correct. For the induction step, note that each corruption of an element in  can result in at most one rank error. In contrast, corruptions in auxiliary information can result in more than one rank error per corruption, but this is taken care of, as shown next.

By Lemma~\ref{lem:recursion_lemma}, the recursion implementation guarantees that if , then  is correct. If the return statement in line  is used, then the pivot  is returned as . The test at line  guarantees that . From the definition of the resilient partition procedure, , as needed.

If the return statement in line  is not used, then the return statement in line  is used. Let the last child of  be denoted by . The test at line  guarantees that . Notice that the element  is the element located by . Therefore, from the definition of the resilient ranking procedure, . If , then , as needed.

Otherwise (i.e., if ), then by induction, . Also, the recursion implementation guarantees that , , and , are resilient in this case. If , then , because both are resilient. Also, being that  is resilient,  is smaller than all the uncorrupted elements in , which are larger than . Therefore, , as needed. If , then , because both are resilient. Also, being that  is resilient,  is larger than all the uncorrupted elements in , which are smaller than . Therefore, , as needed.
\end{pf}

\begin{lemma}
\label{lem:analysis_2}
Let  be a first type child of . If , then , where  is the element returned from  to .
\end{lemma}

\begin{pf}
, therefore from Lemma~\ref{lem:analysis_1}, it follows that . Also, the recursion implementation guarantees that  is resilient in this case, therefore, . There exists at least  elements in  which are smaller than . This is because each non corrupted median of five consecutive elements corresponds to at least  elements in  which are smaller than , and each corrupted element either in  or in  which is not a median of five consecutive elements can change the rank of  by at most . A similar argument establishes the second inequality.
\end{pf}





\begin{lemma}
\label{lem:first_phase_repetitions}
Let  be a first type child of . If  is not a second type node, then .
\end{lemma}

\begin{pf}
Being that  is not followed by a second type node,  did not pass the test at line  (i.e., ). There are two cases to consider.

If , then, in particular, .

Otherwise, assume that . It will be shown that . Assume, in contradiction, that this is not the case. It follows, from Lemma~\ref{lem:analysis_2}, that . This contradicts the assumption that  did not pass the test at line  (i.e., that ).~\end{pf}











\begin{lemma}
\label{lem:second_phase_repetitions}
Let  be a second type child of . If  is not the last child of , then .
\end{lemma}

\begin{pf}
Being that  is not the last child of ,  did not pass the test at line  (i.e., ). Again, there are two cases to consider.

If , then, in particular, .

Otherwise, if , then, by Lemma~\ref{lem:analysis_1}, . Moreover, , and each corruption in  can cause the rank of  to change by at most . Therefore, . However,  did not pass the test at line , therefore .
\end{pf}






























\begin{theorem}\label{theorem:det_select_alpha}
\emph{Deterministic-Select} is a deterministic resilient selection algorithm with time complexity .
\end{theorem}

\begin{pf}
First, \emph{Deterministic-Select} is shown to be resilient. Let  be the root of the recursion tree, . If , then by Lemma~\ref{lem:analysis_1}, , as needed. Otherwise, if , then there are two cases to consider. If , then by Lemma~\ref{lem:analysis_1}, , as before. Otherwise, if , then by definition, . Therefore, for any element , . In particular, the element returned is correct.

With regard to the time complexity, consider a non-faulty execution (i.e., ). The time complexity  follows, because .

If , then there might be some repetitions. Lemma~\ref{lem:first_phase_repetitions} and Lemma~\ref{lem:second_phase_repetitions} show that enough corruptions can be charged for the time spent in those repetitions. In particular, the  corruptions that cause a first type child repetition pay for the  computation time of the child, and the  corruptions that cause a second type child repetition pay for the  computation time of the child, and for the  computation time of the first type child that precedes it. Figure~\ref{fig:recursion_tree} shows a visualization of this amortization. In both cases there is  amortized cost per corruption. Therefore, the overall time complexity is .
\end{pf}


























\begin{theorem}\label{theorem:det_select}
There exists a deterministic resilient selection algorithm with time complexity .
\end{theorem}

\begin{pf}
The algorithm \emph{Deterministic-Select} can be modified to achieve worst-case time complexity . The algorithm maintains a counter , initialized to , which is a lower bound on the number of corruptions that occurred. Notice that  can be maintained in a reliable memory cell.

The proof of Lemma~\ref{lem:first_phase_repetitions} shows that if a first phase repetition occurred, it must be due to at least  corruptions, where  is the current node. Therefore, in this case, the counter is incremented by . The proof of Lemma~\ref{lem:second_phase_repetitions} shows that if a second phase repetition occurred, it must be due to at least  corruptions, where  is the second type child of the current node that caused the repetition. Therefore, in this case, the counter is incremented by . If the counter is equal to or larger than , the algorithm halts with an arbitrary element.

\newpage
The modified algorithm is correct, because the counter is a lower bound of the number of corruptions. If , then . Therefore, any element is in the -rank of . With regard to the time complexity, notice that the counter is also an upper bound, up to a multiplicative constant, for the amount of extra work performed due to corruptions. Therefore, as long as , which is always the case, the total work is .
\end{pf}















\section{Recursion Implementation}
\label{sec:recursion_implementation}

In this section, an abstract recursion stack for \emph{Deterministic-Select} is developed. The data structures used by this abstract stack are described, followed by the implementation of the operations on it. This leads to the proof of Lemma~\ref{lem:recursion_lemma} at the end of this section.

\subsection{Data Structures}
\label{subsec:recursion_data_structures}

Two stacks, one reliable and the other one faulty, together with a constant number of reliable memory cells, are used to implement the recursion for the algorithm \emph{Deterministic-Select}. An execution path in the recursion tree, , starts from the root and ends at the current node. In each stack, the entire execution path is stored in a contiguous region in memory, where the root is at the beginning, and the current node is at the end. The stacks are depicted schematically in Fig.~\ref{fig:recursion_stacks}.

\subsubsection{Reliable Stack}

The reliable stack stores only  bits of information per node. The height of  is , therefore it can be stored in a constant number of reliable memory cells. For each inner node , the reliable stack stores  bit to distinguish between a first type child and a second type child. Let  denote the remainder of the division of  by . For a node of the first type,  is stored. For a node of the second type,  and  are stored. Notice that the  reliable memory cells are used down to the bit level.

\subsubsection{Faulty Stack}

The faulty stack stores  words of information per node. For each node , the faulty stack stores the elements of , as well as , , and . The elements of  are stored using  copy per element, while , , and  are stored using  copies per variable.

\subsubsection{Global Variables}

Each one of the following global variables is stored using a reliable memory cell:

\begin{itemize}
	\item The current array size
	\item The reliable stack's frame pointer
	\item The faulty stack's frame pointer
	\item The program counter
	\item The return value
\end{itemize}

Notice that at a given moment in an execution only one value per each global variable needs to be stored.










\vspace{0.4in}

\begin{figure}
\begin{center}
\psset{gridcolor=red,subgridcolor=blue}

\psset{unit=0.47cm}

\begin{pspicture}(26,9)

\pspolygon(1,7)(9,7)(9,8)(1,8)
\psline(3,7)(3,8)
\psline(7,7)(7,8)

\psbrace[rot=270,ref=b,braceWidth=0.01](3,8)(1,8){}
\psbrace[rot=270,ref=b,braceWidth=0.01](7,8)(3,8){}
\psbrace[rot=270,ref=b,braceWidth=0.01](9,8)(7,8){}

\rput(1.5,7.5){}
\psline[linestyle=dotted](2,7)(2,8)
\rput(2.5,7.5){}

\rput(3.5,7.5){}
\psline[linestyle=dotted](4,7)(4,8)
\rput(5,7.5){}
\psline[linestyle=dotted](5.85,7)(5.85,8)
\rput(6.5,7.5){}

\pscurve{->}(15,6.75)(10,6.25)(7,6.75)
\rput(15,7.5){Frame pointer}

\pspolygon(1,2)(26,2)(26,4)(1,4)
\psline(15,2)(15,4)
\psline(21,2)(21,4)

\psbrace[rot=270,ref=b,braceWidth=0.01](15,4)(1,4){}
\psbrace[rot=270,ref=b,braceWidth=0.01](21,4)(15,4){}
\psbrace[rot=270,ref=b,braceWidth=0.01](26,4)(21,4){}

\psline[linestyle=dotted](12,2)(12,4)
\psline[linestyle=dotted](13,2)(13,4)
\psline[linestyle=dotted](14,2)(14,4)

\psline[linestyle=dotted](18,2)(18,4)
\psline[linestyle=dotted](19,2)(19,4)
\psline[linestyle=dotted](20,2)(20,4)

\psline[linestyle=dotted](23,2)(23,4)
\psline[linestyle=dotted](24,2)(24,4)
\psline[linestyle=dotted](25,2)(25,4)

\rput(1.5,3){}
\rput{270}(12.5,3){}
\rput{270}(13.5,3){}
\rput{270}(14.5,3){}

\rput(15.5,3){}
\rput{270}(18.5,3){}
\rput{270}(19.5,3){}
\rput{270}(20.5,3){}

\psline{->}(21,7)(21,4.5)
\rput(21,7.5){Frame pointer}

\rput(21.5,3){}
\rput{270}(23.5,3){}
\rput{270}(24.5,3){}
\rput{270}(25.5,3){}

\end{pspicture}
\end{center}

\caption{The stacks used by the recursion implementation are depicted. The reliable stack is at the top and the faulty stack is at the bottom. The execution path is composed of the root, , it's first type child, , and 's second type child, . The figure shows the situation when  begins its computation. For each node, the reliable stack stores the traversal direction to its child (drawn as a pointed arrow), as well as the remainders,  or  and , while the faulty stack stores the sub-array , as well as  copies of , , and . The frame pointers are also shown.}

\label{fig:recursion_stacks}

\begin{center}
\end{center}

\vspace{-0.5in}
\end{figure}













\subsection{Operations}

Two operations are implemented by the recursion implementation. A push operation corresponds to a recursive call, and a pop operation corresponds to returning from a recursive call.

\subsubsection{Push}

When a node  calls its child , the following is done. The information of whether  is a first type child or a second type child of  is written to the reliable stack, as well as the relevant remainders (i.e.,  or  and ), and the reliable stack's frame pointer is incremented by  bits. Then, the relevant sub-array is pushed to the faulty stack, followed by the values , , and . If  is a first type child, then  is updated to . If  is a second type child, then  is updated to . The faulty stack's frame pointer is updated accordingly, and the program counter is set to line . Then, the computation continues to .

\subsubsection{Pop}

When  finishes its computation, the following is done. First, the reliable stack's frame pointer is decremented by  bits, and the information of whether  is a first type or a second type child of  is read, as well as the remainder (i.e.,  or  and ).

If  is a first type child, then  is updated to . If  is a second type child, then  is updated to . Notice that this function is the inverse function of , which is the function used to update  when calling a second type child, as explained before. The faulty stack's frame pointer is decremented by  words.

The  copies of , , and  are read, and the computed majority of their copies are stored in reliable memory and used as the values for , , and . Then, the computation returns to , either to line  or to line , depending on the type of .













\subsection{Proof of Lemma~\ref{lem:recursion_lemma}}

\begin{pf}
The frame pointers, the return value, and the program counter were shown to be reliable, as well as the location of the array  and its size . , , and  are stored using  copies each, therefore, if , then these parameters are reliable. The time overhead induced by the frame pointers, return value, program counter, location of the array  and its size  is a constant. The time overhead induced by , , and  is . Therefore, the time overhead of the recursive implementation is .
\end{pf}











\section{Resilient -d Trees}
\label{sec:resilient_kd_trees}

Gieseke et al.~\cite{kd_trees}, developed a resilient -d tree, where  denotes the dimension (this  is not related to the  in the selection algorithm). As is the case with non-resilient -d trees,
the construction involves multiple partitioning of the points by the median.
For example, if , then at even-depth nodes, the points are partitioned by the -coordinate median,
and at odd-depth nodes, the points are partitioned by the -coordinate median.
In a resilient -d tree, the partitioning ends at the leaves, which contain  points each,
where  is a parameter.

Gieseke et al. developed a randomized resilient selection algorithm, which is somewhat different
from the randomized resilient selection algorithm developed in this work.
Both algorithms achieve the same expected time complexity, .
Using these algorithms to build a resilient -d tree results in  expected time complexity.
However, the selection algorithm developed here guarantees that the element returned has rank
between  and  in the input array,
while the algorithm developed in~\cite{kd_trees} only guarantees a rank between  and .
This difference does not have asymptotical consequences on the height of the resulting -d tree.

For a deterministic -d tree construction algorithm, Gieseke et al. used the resilient sorting algorithm
developed by Finocchi et al.~\cite{resilient_sorting} in order to partition the points around the median.
This results in  time complexity.
By using the deterministic resilient selection algorithm developed here,
the time complexity is reduced to  and implies the following theorem.

\begin{theorem}\label{theorem:kd_trees}
There exists a resilient -d tree which can be constructed in deterministic  time.
It supports resilient orthogonal range queries in  time for reporting  points.
\end{theorem}















\section{Resilient Quicksort Algorithms}
\label{sec:resilient_quicksort_algorithms}

The famous quicksort algorithm is based on the idea of selecting a pivot, partitioning the input by it, and recursively sorting each side of the partition. In the FRAM model the difficulty is in having to maintain the  partitioning locations. This is true for both a recursive and iterative implementation. One natural idea for dealing with this difficulty is to partition the array at the median. For sake of simplicity assume that the size of the input is a power of two\footnote{If this is not the case then careful padding can take place. Being that the interest here is in an in-place algorithm, the padding can be done abstractly by knowing that each access to an array location which does not exist can be considered as .}. However, using a resilient selection algorithm for locating the median in the FRAM model and partitioning around the element returned does not guarantee that the array is split into two parts of equal size, due to corruptions that may occur during the execution of the selection algorithm, returning an element which is only roughly the median. Thus, there is a need to develop a resilient splitting algorithm, which is defined as follows.

\begin{definition}
A \emph{resilient splitting algorithm} is an algorithm that is given an array  of size  and an integer , and reorders the array such that any uncorrupted element in  is smaller than any uncorrupted element in .
\end{definition}

In section~\ref{sandboxed_splitting_algorithms}, two non-efficient resilient splitting algorithms are shown: one is deterministic and runs in  worst-case time, and the second is randomized and in-place and runs in  expected time.

In section~\ref{generic_splitting_algorithms}, two efficient resilient splitting algorithms are shown: one is deterministic and runs in  worst-case time, and the second is randomized and in-place and runs in  expected time. These efficient algorithms use the non-efficient algorithms from Section~\ref{sandboxed_splitting_algorithms}.











\subsection{Sandboxed Splitting Algorithms}
\label{sandboxed_splitting_algorithms}

The basic idea behind the resilient splitting algorithms is to test the rank of the element returned by the selection algorithm, and \emph{fix} it, as needed. In order to achieve this goal, the notion of \emph{Sandboxing} an algorithm is introduced. The idea is to convert a non-resilient algorithm , with a known bound on its running time and space usage into a resilient algorithm . However, in order to be able to do this, there must exist a verification procedure which can verify that the output of  is correct, and the algorithm  needs to be \emph{non-destructive}, a notion which is defined later.

Finocchi, Grandoni and Italiano~(\cite{resilient_dictionaries}, Lemma 4) already considered a similar reduction. However, there is an unfortunate flaw in their proof given there, because it does not take into consideration the following two cases: A corrupted variable that can cause the non-resilient procedure to require a much larger time complexity (maybe even getting stuck in an infinite loop), and memory corruptions that can cause the non-resilient procedure to alter memory cells used by other parts of the system. These problems can be overcome by confining the execution to a predetermined area in memory and having an upper bound on the running time of . The area in memory is referred to as the \emph{sandbox}. For a problem  and an input , let  denote the set of correct solutions of  on .

\begin{definition}
Let  be an algorithm for a problem . Assume that an execution of  on an input  can be interrupted at any point in time, and let  denote the state of the input after such an interruption.  is \emph{non-destructive} if for any execution of  on any input  and on any set of random coins, and for any interruption with any possible sequence of faults, .
\end{definition}

\begin{lemma}
\label{lem:sandbox_lemma}
Let  be a non-resilient and a non-destructive algorithm solving problem  with time complexity  (either worst-case or expected) and space complexity . Let  be a resilient verification procedure for  with worst-case time complexity  and space complexity  which decides the correctness of an execution of .
Then there exists a resilient algorithm  which solves , and has time complexity  which is either worst-case or expected, depending on , and space complexity .
\end{lemma}

\begin{pf}
A \emph{sandboxed} version of , denoted by , is defined as follows. The algorithm works in rounds. In each round,  runs a modified version of , as defined next. If the running time of  is worst-case, then, to guarantee that  will not run for too long,  runs  for no more than  steps. If the running time of  is in expectation, then, to guarantee that  will not run for too long,  runs  for no more than  steps. This is done by counting the number of computational steps that  performs. To guarantee that  will not alter memory cells other than its own,  runs  confined to a memory region of size . The counter which counts the computational steps as well as the two boundaries for the memory region are stored in reliable memory cells. After running the modified  algorithm,  calls  to check the correctness of 's computation. If  returned a positive answer,  halts. Otherwise, a new round begins, but only after the memory sandbox is flushed. That is, immediately after a non-successful round ends, all of the working memory is erased, but the input is left as it is, for the next round.

The memory sandbox guarantee that the (non-resilient) computation of  would not alter memory cells outside of 's computation.  halts only after the resilient verification procedure  returned a positive answer. Therefore,  is correct, even in the presence of memory faults.

If the running time of  is worst-case, then each round takes  time. In a non-faulty round,  is correct. By the pigeon hole principle, if there are more than  rounds, at least one of them is non-faulty. Denote the state of the input at the beginning of this non-faulty round by .  is a (non-resilient) algorithm for , therefore, in this non-faulty round, it computes a correct output .  is non-destructive, therefore . It follows that , i.e.,  is correct\footnote{If  is a Monte Carlo algorithm then , and because of the non-destructiveness of , it follows that , as needed.}. Therefore, there are at most  rounds.

If the running time of  is expected, then each round takes  time. In a non-faulty round, the probability that  would halt within  computational steps is at least , by Markov's inequality. Therefore, the expected number of rounds is at most .

The space used by the calls to  and  can be reused, therefore, the space complexity is .~\end{pf}

This general notion of sandboxed algorithms can be used for designing resilient splitting algorithms. For the deterministic resilient splitting algorithm, algorithm  is executed by using the non-resilient deterministic selection algorithm to locate the median, and partitioning the array around the element returned. The verification procedure  is implemented by testing that each side of the partition has the same size. For the randomized resilient splitting algorithm, algorithm  is executed by using the non-resilient randomized selection algorithm to locate the median. Notice that in the randomized case, .

Notice that both the non-resilient deterministic selection algorithm and the non-resilient randomized selection algorithm needs to slightly be altered in order to be non-destructive. The only operation that these algorithms perform which might alter the input is swapping. The idea is to make these swaps atomic, i.e., only stopping the algorithm after such a swap is fully completed. Notice that the -order statistic of an input array does not depend on the specific permutation of the input array\footnote{Another way of altering these algorithms to make them non-destructive is by copying the input array to a second and temporary array. Then, performing all of the swaps only on the temporary array, and making sure that the input array is not altered at all, by putting it outside the memory sandbox. This solution, however, has a cost in time and space.}.

\begin{corollary}\label{lem:sandbox_split}
There exists a deterministic resilient splitting algorithm with worst-case time complexity , and a randomized in-place resilient splitting algorithm with expected time complexity .
\end{corollary}

\begin{pf}
The proof follows from Lemma~\ref{lem:sandbox_lemma} and from the discussion above.
\end{pf}


Denote the algorithm from Lemma~\ref{lem:sandbox_split} by \emph{Sandboxed-Split}. The running time of such an algorithm is rather costly, but it is still useful when considering small arrays. For the resilient splitting algorithm, the idea is to reduce the size of the array, and then execute Sandboxed-Split.










\subsection{Efficient Splitting Algorithms}
\label{generic_splitting_algorithms}

Consider the following generic algorithm, denoted by \emph{Generic-Resilient-Split}. The algorithm uses either \emph{Deterministic-Select} or \emph{Randomized-Select}, denoted here by \emph{Generic-Resilient-Select}, to locate both the  and the  order statistics. Then, it uses \emph{Sandboxed-Split} to split the remaining  elements.\\ \ \\

\begin{algorithm}[H]

 Generic-Resilient-Select(, )\;
partition  around \;
\If{}{\Return}

 Generic-Resilient-Select(, )\;
partition  around \;
\If{}{\Return}

Sandboxed-Split(, )\;

\caption{Generic-Resilient-Split(, )}
\end{algorithm}
\vspace{0.4cm}

\begin{lemma}
\label{lem:generic_resilient_split_lemma}
\emph{Generic-Resilient-Split} is a resilient splitting algorithm.
\end{lemma}

\begin{pf}
After the array is partitioned around , the uncorrupted elements in  are smaller than the uncorrupted elements in . After the array is partitioned around , the uncorrupted elements in  are smaller than the uncorrupted elements in . After the call to \emph{Sandboxed-Split}, the uncorrupted elements in  are smaller than the uncorrupted elements in . It follows that the uncorrupted elements in  are smaller than the uncorrupted elements in , as needed.~\end{pf}




The following corollaries follow by substituting Generic-Resilient-Select by either the deterministic or randomized versions. Notice that in both cases, the call to \emph{Generic-Resilient-Select} takes  (either in expectation or worst-case as needed). The size of the sub-array  is , therefore the call to \emph{Sandboxed-Select} takes  time.

\begin{corollary}
\label{cor:resilient_split}
There exists a deterministic resilient splitting algorithm with worst-case running time , and a randomized in-place resilient splitting algorithm with expected running time .
\end{corollary}




\subsection{Resilient Quicksort Algorithms}
Using the generic resilient splitting algorithm as a black box, one can sort resiliently using \emph{Generic-Resilient-Quicksort}. Notice that this algorithm does not use more than  space, except for the space used by the splitting algorithm.\\


\begin{algorithm}[H]
\label{alg:Resil_quicksort}

\For{}{
	\For{}{
		 \;
		\;
		\# The array is split in-place. \;
		Generic-Resilient-Split(, )\;
	}
}
\caption{Generic-Resilient-Quicksort()}
\end{algorithm}


\begin{lemma}\label{lem:generic_resil_quicksort}
\emph{Generic-Resilient-Quicksort} is a resilient sorting algorithm.
\end{lemma}

\begin{pf}
Consider two uncorrupted elements  and  from the input, where . There exists some element  which partitions them, at which point  will be put before  in the array, and from then onwards their order will remain the same.
\end{pf}


The following theorem follows.

\begin{theorem}
There exists a deterministic sorting algorithm with worst-case running time of , and a resilient randomized in-place sorting algorithm with expected running time of .
\end{theorem}

\begin{pf}
Using Corollary~\ref{cor:resilient_split} and Lemma~\ref{lem:generic_resil_quicksort}, the theorem follows.
\end{pf}















\newpage

\bibliographystyle{alpha}
\bibliography{arxiv_bib}

\end{document}
