

\documentclass{CSML}

\def\dOi{11(4:2)2015}
\lmcsheading {\dOi}
{1--38}
{}
{}
{Sep.~30, 2014}
{Oct.~15, 2015}
{}

\ACMCCS{[{\bf Theory of computation}]: Models of computation; Logic;
  Formal languages and automata theory}
 \subjclass{F.1.1 Models of Computation, F.4.1 Mathematical Logic, F.4.3 Formal Languages}

\usepackage{multicol}
\usepackage{synttree}
\usepackage{hyperref}

\graphicspath{{./}}

\title[Logic and branching automata]{Logic and branching automata\rsuper*}

\author[N.~Bedon]{Nicolas Bedon}
\address{LITIS (EA 4108) -- Universit\'e de Rouen -- France}
\email{Nicolas.Bedon@univ-rouen.fr}

\titlecomment{{\lsuper*}This paper is a long version, with full proofs, of~\cite{DBLP:conf/mfcs/Bedon13}}
\keywords{N-free posets, series-parallel posets, sp-rational languages, automata, commutative monoids, monadic second-order logic, Presburger logic.}


\usepackage{diagrams}
\usepackage{epic,eepic,latexsym,amsmath,amssymb,xspace,ifthen}
\usepackage[pst-pdf=md5]{gastex}

\newcommand{\true}{\text{true}}
\newcommand{\false}{\text{false}}

\newcommand{\Pf}[1]{\ensuremath{{\mathcal P}(#1)}}

\newcommand{\quotientparallel}[2]{\ensuremath{#1\backslash\kern-3pt\backslash#2}}


\begin{document}

\begin{abstract}
In this paper we study the logical aspects of \emph{branching automata}, as defined by Lodaya and Weil.
We first prove that the class of languages of finite N-free posets recognized by branching automata is closed under complementation.
Then we define a logic, named P-MSO as it is a extension of monadic second-order logic with Presburger arithmetic, and show that it is precisely as expressive as branching automata.
As a consequence of the effectiveness of the construction of one formalism from the other, the P-MSO theory of the class of all finite N-free posets is decidable. 
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:intro}

Sequential programs can naturally be modeled with Kleene automata, or equivalently with rational expressions, finite monoids, or monadic second-order (MSO) logic.
The algebraic approach of automata provides an huge toolbox for the study of properties of programs, and has been widely used as a base for a lot of algorithms that manipulate logic formulas. The links between Kleene automata, rational expressions, finite monoids and MSO have important consequences in a lot of domains of computer science and mathematics, some of them are concretely applied as for example in program verification, others are more theoretical as for example in set theory.

Introducing commutativity allows access to models of programs with permutation of instructions, or to concurrent programming. Among the formal tools for the study of commutativity in programs, let us mention for example Mazurkiewicz's traces, integer vector automata or commutative monoids. In this paper we focus on the notion of \emph{branching automata} introduced by Lodaya and Weil~\cite{lodaya98kleene,LW98:Algebra,LW00:sp,lodaya01kleene}. Branching automata are an extension of Kleene automata with particular transitions that naturally model parallelism. Traces of paths in branching automata are not (totally ordered) words as in Kleene automata, but partially ordered sets (posets) of letters, which are structured as traces of programs using the fork-join primitive for concurrency. Those particular posets, called \emph{N-free}, are widely used in the study of concurrency. The fork-join primitive splits an execution flow  into  concurrent execution flows and joins  before it continues. Divide-and-conquer concurrent programming naturally uses this fork-join principle. Lodaya and Weil generalized several important results of the theory of Kleene automata to branching automata, for example, a notion of rational expression with the same expressivity as branching automata. They also investigated the question of the algebraic counterpart of branching automata: the sp-algebras are sets equipped with two different associative products, one of them being also commutative. Contrary to the theory of Kleene automata, branching automata do not coincide any more with finite sp-algebras. 

An interesting particular case is the bounded-width rational languages~\cite{LW00:sp}, where the cardinality of the antichains of the posets of languages are bounded by an integer . They correspond to fork-join models of concurrent programs with  as the upper bound of the number of execution flows ( is the number of physical processors). Bounded-width rational languages have a natural characterization in rational expressions, branching automata, and sp-algebras. Taking into account those characterizations, the expressiveness of branching automata corresponds exactly to the finite sp-algebras. Furthermore, Kuske~\cite{Kus00:SPInf} proved that in this case, branching automata coincide also with monadic second-order logic, as it is the case for the rational languages of finite words. As in the general case monadic-second order logic is less expressive than branching automata, the question of an equivalent logic was left open.

In this paper we investigate the question of defining a logic equivalent to branching automata in the general case. 

This paper contains two results regarding branching automata:
\begin{itemize}
\item we prove that the class of languages defined by branching automata is closed under complementation;
\item we define a logic, named \emph{P-MSO} as it is basically monadic second-order logic enriched with Presburger arithmetic, that is exactly as expressive as branching automata.
\end{itemize}

\noindent The (effective) proof of the first result essentially relies on the closure under complementation of rational languages of a finitely generated commutative monoid (Theorem~\ref{th:schutz}, by Sch\"utzenberger and Eilenberg).
The proof of the second result relies on effective constructions from one formalism to the other.
As a consequence, the P-MSO theory of the class of finite N-free posets is decidable.

The paper is organized as follows. Section~\ref{sec:not} recalls basic definitions on posets. Section~\ref{sec:languages} is devoted to branching automata, rational expressions and sp-algebras. The complementation of rational languages is discussed in Section~\ref{sec:complementation}. Section~\ref{sec:PMSO} is devoted to the logical approach of branching automata. Finally, we present an alternative definition for branching automata in Section~\ref{sec:PBranching}.

\section{Notation and basic definitions}
\label{sec:not}

Let  be a set. We denote by ,  and  respectively the set of subsets of , the set of non-empty subsets of  and the set of multi-subsets of  with at least two elements. 
For any integer , the set  is denoted  and the group of permutations of  by .
The cardinality of  is denoted by .
We use the same notation for sets and multi-sets. We sometimes denote by  the multiplicity  of an element  of a multi-set. 

A \emph{poset}  is composed of a set  equipped with a partial ordering .
In this paper we consider only finite posets.
For simplicity, by \emph{poset} we always mean \emph{finite} poset.
A \emph{chain} of length  in  is a sequence  of elements of .
An \emph{antichain}  in  is a set of elements of  mutually incomparable for .
The \emph{width} of  is the size of a maximal antichain of .
An \emph{alphabet} is a nonempty finite set whose elements are called \emph{letters}.
A poset  \emph{labeled} by  is composed of a poset  and a map  which associates a letter  with any element of . 
Observe that the posets of width 1 labeled by  correspond precisely to the usual finite words: finite totally ordered sequences of letters.
Throughout this paper, we use labeled posets as a generalization of words.
In order to lighten the notation we write  for  when no confusion is possible.
The unique empty poset is denoted by .

Let  and  be two disjoint posets labeled respectively by the alphabets  and .
The \emph{parallel product} of  and , denoted , is the set  equipped with the orderings on  and  such that the elements of  and  are incomparable, and labeled by  by preservation of the labels from  and . 
It is defined as  where  if and only if:
\begin{itemize}
\item  and  or
\item  and 
\end{itemize}
and  if ,  if .

The \emph{sequential product} of  and , denoted by  or  for simplicity, is the poset  labeled by , such that  if and only if one of the following conditions is true:
\begin{itemize}
\item ,  and ;
\item ,  and ;
\item  and 
\end{itemize}
and  if ,  if .

Observe that the parallel product is an associative and commutative operation on posets, whereas the sequential product does not commute (but is associative). 
The parallel and sequential products can be generalized to finite sequences of posets. Let  be a sequence of posets. We denote by  and .

The class of \emph{series-parallel} posets, denoted , is defined as the smallest set containing the posets with zero and one element and closed under finite parallel and sequential product. It is well known that this class corresponds precisely to the class of N-free posets~\cite{Val78,VTL82:SPDigraphs}, in which the exact ordering relation between any four elements  cannot be ,  and . The class of series-parallel posets labeled by an alphabet  is denoted . We write  for  and  for .

A poset  has a \emph{sequential (resp. parallel) factorization} if  (resp. ) for some nonempty posets  and . A sequential factorization  is \emph{maximal} if each , , has no sequential factorization. The definition of the notion of \emph{maximal parallel factorization} is similar. Posets having a parallel factorization are called \emph{parallel posets}. The \emph{sequential posets} are those of cardinality 1 and those having a sequential factorization.

\section{Rational languages, automata and recognizability}
\label{sec:languages}

A \emph{language} of a set  is a subset of .
Let  be an alphabet.
The sequential and parallel product of labeled posets can naturally be extended to languages of .
If , then  and .

\subsection{Rational languages}

Let  and  be two alphabets and let ,  and .
We define the language  by substituting non-uniformly in  each element labeled by  by a labeled poset of .
This substitution  is the homomorphism from  into the power-set algebra  with  for all , , and . 
It can be easily extended from labeled posets to languages of posets.
Using this, we define the substitution and the iterated substitution on languages. By the way the usual Kleene rational operations~\cite{Kle56} are recalled.
Let  and  be languages of :

A language  is
\emph{rational} if it is empty, or obtained from the letters of the alphabet~ using usual rational operators~: finite union ,
finite concatenation , and finite iteration , 
and using also the finite parallel product , substitution  and iterated substitution , provided that in  any element labeled by  in a labeled poset  is incomparable with another element of . This latter condition excludes from the rational languages those of the form , for example, which are known to be not Kleene rational. Observe also that the usual Kleene rational languages are a particular case of the rational languages defined above, in which the operators ,  and  are not allowed.

\begin{exa}
  \label{ex:abc}
  Let  and . Then  is the smallest language containing  and such that if , then :
  
\end{exa}

Let  be a language where the letter  is not used.
In order to lighten the notation we use the following abbreviation:

 and  are the sequential iterations of  whereas  and  are its parallel iterations.

\subsection{Branching automata}
\label{subsec:automata}

Branching automata are a generalization of usual Kleene automata.
They were introduced by Lodaya and Weil~\cite{lodaya98kleene,LW98:Algebra,LW00:sp}.

A \emph{branching automaton} (or just \emph{automaton} for short) is a tuple  where  is a finite set of
states,  is an alphabet,  is the set of \emph{initial states},
 the set of \emph{final states}, and  is the set of \emph{transitions} of .
The set of transitions of  is partitioned into , according to the different kinds of transitions:
\begin{itemize}
\item  contains the \emph{sequential} transitions, which are usual transitions of Kleene automata;
\item  and  are respectively the sets of \emph{fork} and \emph{join} transitions.
\end{itemize}
Sequential transitions   are sometimes denoted by .
The \emph{arity} of a fork (resp. join) transition  (resp. ) is . 

We now turn to the definition of paths in automata. The definition we use in this paper is different, but equivalent to, the one of Lodaya and Weil~\cite{lodaya98kleene,LW98:Algebra,LW00:sp,lodaya01kleene}.
Paths in automata are posets labeled by transitions.
A \emph{path}  from a state  to a state  is either the empty poset (in this case ), or a non-empty poset labeled by transitions, with a unique minimum and a unique maximum element. The minimum element of  is mapped either to a sequential transition of the form  for some  and  or to a fork transition of the form  for some . Symmetrically, the maximum element  of  is mapped either to a sequential transition of the form  for some  and  or to a join transition of the form  for some . The states  and  are respectively called \emph{source} (or \emph{origin}) and \emph{destination} of . Two paths  and  are \emph{consecutive} if the destination of  is also the source of .
Formally, the paths  labeled by  in  are defined by induction on the structure of~:
\begin{itemize}
\item for any transition , then  is a path from  to , labeled by ;
\item for any finite set of paths  () respectively labeled by , from  to , if  is a fork transition and  a join transition, then  is a path from  to  and labeled by ;
\item for any non-empty finite sequence  of consecutive paths respectively labeled by , then  is a path labeled by  from the source of   to the destination of ;
\end{itemize}
Observe that non-empty paths are labeled posets of two different forms:  or  for some transitions  and some labeled poset .
In an automaton , the existence of a path  from  to  labeled by  is denoted by . 
A state  is a \emph{sink} if  is the destination of any path originating in~.

A labeled poset is \emph{accepted} by an automaton if it is the nonempty label of a path, called \emph{successful}, leading from an initial state to a final state. The language  is the set of labeled posets accepted by the automaton . A language  is \emph{regular} if there exists an automaton  such that .

\begin{exa}
  \label{ex:oneAAtLeast}
  Figure~\ref{fig:ontAAtLeast} represents an automaton on the alphabet  that accepts  iff  contains at least one .
  It has one initial state  and one final state , two sequential transitions labeled by  from  to  and from  to , two sequential transitions labeled by  from  to  and from  to , two fork transitions  and , and three join transitions ,  and . 
  \begin{figure}[htbp]
  \begin{center}
    \gasset{Nw=6,Nh=6,loopdiam=4}
    \begin{gpicture}\node(1)(0,0){}\imark[iangle=295](1)
      \node(2)(16,0){}\fmark[fangle=135](2)
      \drawedge(1,2){}
      \drawloop[loopangle=60](1){}
      \drawloop[loopangle=90](2){}

      \drawloop[loopangle=135](1){}
      {\gasset{AHnb=0,ATnb=1}
      \drawloop[loopangle=235](1){}}
      \drawcurve[AHnb=0](-4,1.5)(-5,0)(-4,-2)

      \drawcurve[AHnb=0](-8,3)(-11,6)(-8,0)
      \drawcurve[AHnb=0](-8,-3)(-11,-6)(-8,0)
      \drawcurve[nb=1](-8,0)(-7,0)(-6,0)
      \drawcurve[AHnb=0](-9,1.5)(-10,0)(-9,-2)

      \drawcurve[AHnb=0](23,3)(26,6)(23,0)
      \drawcurve[AHnb=0](23,-3)(26,-6)(23,0)
      \drawcurve[nb=1](23,0)(22,0)(21,0)
      \drawcurve[AHnb=0](24,1.5)(25,0)(24,-2)

      \drawcurve[AHnb=1](27,0)(30,6)(27,3)
      \drawcurve[AHnb=1](27,0)(30,-6)(27,-3)
      \drawcurve[AHnb=0](28,1.5)(29,0)(28,-2)

      {\gasset{AHnb=1,ATnb=0}
      \drawloop[loopangle=270](2){}}
      \drawcurve[AHnb=0](2.5,-2.5)(12,-6)(14.3,-4)
      \drawcurve[AHnb=0](12,-6)(13,-7)(14,-6)
    \end{gpicture}
  \caption{An automaton that accepts  iff  contains at least one .}
  \label{fig:ontAAtLeast}
  \end{center}
\end{figure}
\end{exa}

\begin{thm}[Lodaya and Weil~\cite{lodaya98kleene}]
  \label{th:KleeneBranching}
  Let  be an alphabet, and .
  Then  is regular if and only if it is rational.
\end{thm}

\begin{exa}
  \label{ex:anbnAuto}
  On its left side, Figure~\ref{fig:autoAB} represents the automaton  where the set of sequential transitions is , the set of fork transitions is  and finally the set of join transitions is .
  On the right side of the Figure is pictured an accepting path labeled by . 
  Actually, .
  \begin{figure}[htbp]
    \begin{center}
      \gasset{Nw=6,Nh=6,loopdiam=4}
      \begin{gpicture}
        \node(1)(-10,-12){}\imark[iangle=90](1)
        \node(2)(0,-8){}
        \node(3)(0,-16){}
        \node(4)(10,-8){}
        \node(5)(10,-16){}
        \node(6)(20,-12){}\fmark[fangle=90](6)
        \drawedge(2,4){}
        \drawedge(3,5){}
        \drawedge(1,2){}
        \drawedge(1,3){}
        \drawloop[loopangle=135](1){}
        {\gasset{AHnb=0,ATnb=1}
          \drawloop[loopangle=235](1){}}
        \drawcurve[AHnb=0](-6,-10.3)(-5,-12)(-6,-13.7)
        \drawcurve[AHnb=0](-14,-10.5)(-15,-12)(-14,-14)
        \drawedge(4,6){}
        \drawedge(5,6){}
        {\gasset{AHnb=0,ATnb=1}\drawloop[loopangle=45](6){}}
        \drawloop[loopangle=-45](6){}
        \drawcurve[AHnb=0](24,-10.3)(25,-12)(24,-13.7)
        \drawcurve[AHnb=0](16,-10.5)(15,-12)(16,-14)
\node[Nframe=n](7)(50,-12.5){}
        \node[Nframe=n](8)(60,-7.5){}
        \node[Nframe=n](9)(70,-5){}
        \node[Nframe=n](10)(60,-17.5){}
        \drawedge(7,8){}
        \drawedge(7,10){}
        \node[Nframe=n](11)(70,-10){}
        \node[Nframe=n](12)(70,-15){}
        \node[Nframe=n](13)(70,-20){}
        \drawedge(10,12){}
        \drawedge(10,13){}
        \node[Nframe=n](14)(90,-10){}
        \node[Nframe=n](15)(90,-15){}
        \node[Nframe=n](16)(90,-20){}
        \node[Nframe=n](17)(100,-17.5){}
        \drawedge(15,17){}
        \drawedge(16,17){}
        \node[Nframe=n](18)(100,-7.5){}
        \node[Nframe=n](19)(90,-5){}
        \node[Nframe=n](20)(110,-12.5){}
        \drawedge(17,20){}
        \drawedge(18,20){}
        \drawedge(19,18){}
        \drawedge(14,18){}
        \drawedge(8,9){}
        \drawedge(8,11){}
        \drawedge(9,19){}
        \drawedge(13,16){}
        \drawedge(11,14){}
        \drawedge(12,15){}
      \end{gpicture}
      \caption{An automaton  with  and an accepting path labeled by .}
      \label{fig:autoAB}
    \end{center}
  \end{figure}
\end{exa}

\begin{exa}
  \label{ex:abcAuto}
  Let  and  be the language of Examples~\ref{ex:abc} and~\ref{ex:abcAlgebra}.
  Figure~\ref{fig:autoAXIB} represents an automaton  such that .
  \begin{figure}[htbp]
  \begin{center}
    \gasset{Nw=6,Nh=6,loopdiam=4}
    \begin{gpicture}\node(2)(0,-8){}
      \node(3)(0,-16){}
      \node(4)(10,-8){}
      \node(5)(20,-8){}
      \node(6)(10,-16){}
      \drawedge(2,4){}
      \drawedge(4,5){}\imark[iangle=90](4)\fmark[fangle=90](5)
      \drawedge[ELside=r](3,6){}
      \drawedge[syo=-1,eyo=-1,ELside=r](4,2){}
      \drawedge(4,3){}
      \drawcurve[AHnb=0](6,-9.3)(5.5,-10)(6,-10.9)

      \drawedge(6,5){}
      {\gasset{AHnb=1,ATnb=0}
      \drawloop[loopangle=260](5){}}
      \drawcurve[AHnb=0](15,-12)(16,-12.5)(17,-12)
   
    \end{gpicture}
  \caption{An automaton  such that .}
  \label{fig:autoAXIB}
  \end{center}
\end{figure}
\end{exa}

\begin{prop}[Lodaya and Weil~\cite{LW00:sp}]\label{prop:union}
  Let  be an alphabet.
  The class of regular languages of  is closed under finite union.
  Furthermore, if  is an alphabet,  a morphism of free sp-algebras, and  a regular language of , then  is a regular language of .
\end{prop}

\begin{proof}
  The closure under finite union is a direct consequence of the generalization of the notion of cartesian product of automata to branching automata. The closure under direct image by  is also an easy generalization of the construction for Kleene rational languages.
\end{proof}

\begin{prop}[Lodaya and Weil~\cite{lodaya01kleene}]\label{prop:findPath}
  Let  and  be two states of a branching automaton .
  It is decidable, in polynomial time, if there is a path from  to  in .
\end{prop}

An automaton is \emph{sequentially separated} if, for all pairs  of states, all labels of paths from  to  are parallel posets, or all labels of paths from  to  are sequential posets.

The following proposition will be used later in the paper.
\begin{prop}
  \label{prop:seqSepAuto}
  For every automaton  there is a sequentially separated automaton  such that .
\end{prop}

\begin{proof}
  Let .
  The states of  are the elements of .
  In , there is 
  \begin{itemize}
    \item a sequential transition  iff ,
    \item a fork transition  iff ,
    \item a join transition  iff .
  \end{itemize}
  The initial (resp. final states) of  are those of the form  with  (resp. ).
  Clearly  and  is sequentially separated.
\end{proof}

\subsection{Rationality and semi-linearity}
\label{subsec:ratSemiLin}

A subset  of  is \emph{linear} if it has the form  where the  and  are elements of  and  is a finite set. It is \emph{semi-linear} if it is a finite union of linear sets.

The class of \emph{-rational} languages of  is the smallest containing the empty set, , and closed under finite union, parallel product , and finite parallel iteration . 
We refer to~\cite{EilSch69} for a proof of the following result:
\begin{thm}
  \label{th:ratSemLin}
  Let  be an alphabet and . Then  is -rational if and only if it is semi-linear. Furthermore, the construction from one formalism to the other is effective.
\end{thm}

\begin{prop}
  \label{prop:parallelRational}
  Let  be an alphabet and  be a rational language of .
  Then  if and only if  is -rational.
\end{prop}

\begin{proof}
  The inclusion from right to left follows immediately from the definition.
  Let us turn to the inclusion from left to right. There exists an automaton  such that . For each pair  of states of  define  as the set of posets labeling paths from  to . As  for all  we can assume that  for all  and . Then 

The set of all such equalities forms a finite system of equations, which can immediately be re-written as a context-free grammar  where the usual concatenation is replaced by , which commutes. By Parikh's Theorem (see~\cite{Parikh:1966:CL:321356.321364}, Theorem~2), each  is a semi-linear set of  with , which can be effectively be computed from . As , and the class of semi-linear sets is closed under finite union, then  is also semi-linear, hence -rational by Theorem~\ref{th:ratSemLin}. 
\end{proof}

The definitions of linearity, semi-linearity, rationality and -rationality, which are given above over free algebras, can naturally be generalized over (non-free) algebras.
 
\section{Complementation of rational languages}
\label{sec:complementation}

The first result of this paper is stated by the following Theorem which claims, together with Proposition~\ref{prop:union}, that the class of rational languages of N-free posets is closed under boolean operations.
\begin{thm}
  \label{th:complement}
  Let  be an alphabet.
  The class of rational languages of  is effectively closed under complement.
\end{thm}

The proof of Theorem~\ref{th:complement} relies on the closure under complementation of the class of -rational languages of commutative monoids (Theorem~\ref{th:schutz}).
\begin{thm}[Eilenberg and Sch\"utzenberger, Theorem~III of~\cite{EilSch69}]
  \label{th:schutz}
  If  and  are -rational subsets of a commutative monoid , then  and  are also -rational subsets of~.
\end{thm}
As emphasized in~\cite{Saka:thAutoFr}, if  is finitely generated then Theorem~\ref{th:schutz} is effective.
Theorem~\ref{th:schutz} was first proved by Ginsburg and Spanier~\cite{GS:AMS64} in the case of finitely generated free commutative monoids. The following proposition is a corollary of Theorem~\ref{th:schutz}:
\begin{prop}[Eilenberg and Sch\"utzenberger, Corollary~III.2 of~\cite{EilSch69}]
  \label{prop:morphInv}
  If  is a morphism of commutative monoids,  is finitely generated and  is a -rational subset of , then  is a -rational subset of~.
\end{prop}

\medskip

Before going into the details we need to introduce the necessary notions on algebras for languages of N-free posets.
For the basic notions on algebra we refer to~\cite{Alm94}.
An \emph{sp-algebra}  consists of a set  equipped with two operations  and , respectively called \emph{sequential} and \emph{parallel product}, such that  is a semigroup ( is associative) and  is a commutative semigroup. Observe that the notion of an sp-algebra equipped with a \emph{neutral element} 1 (verifying  for any element  of the sp-algebra) corresponds to bimonoid in~\cite{Bloom199655}. For each alphabet  there exists a free sp-algebra which is isomorphic to  (and which is also denoted by ). 
For simplicity we often denote an sp-algebra  by .
A morphism  between two sp-algebras \emph{recognizes}  if  for some . Sometimes the reference to  is omitted and we say that  recognizes .
The following propositions are easy generalizations of well-known results on semigroups (see~\cite[Prop.~1.8 and 1.9]{Pin84} for the semigroup versions).
\begin{prop}
  If  is a map from an alphabet  to an sp-algebra , there exists a unique morphism  such that  for all . Furthermore,  is surjective iff  is a generator of .
\end{prop}
\begin{prop}
  Let  be an alphabet,  and  two morphisms of sp-algebras, with  surjective. There exists a morphism  such that . Furthermore,  recognizes any  recognized by .
\end{prop}
A subset  of an sp-algebra  is \emph{recognizable} if there exists a \emph{finite} sp-algebra  and a morphism  such that  recognizes . A \emph{congruence}  of sp-algebras is an equivalence relation compatible with the operations, ie.  implies that  and  for all . Actually, as the parallel product commutes in sp-algebras, the condition~(2) is equivalent to  for all . An equivalence relation has \emph{finite index} if it has a finite number of equivalence classes.
It is well-known that the map  which associates to any element of  its equivalence class in the quotient sp-algebra  can be extended in a unique way into a morphism of sp-algebras.
Let  be a set whose elements are called \emph{variables} and  be an sp-algebra. 
A \emph{term} on  is a full binary tree whose leafs are either variables or elements of , and nodes are a sequential or a parallel product.
Formally, the set  of terms on  is defined inductively by , each element of  is in  and, for all ,  and . 
Observe that a N-free poset labeled by  can be thought of as a term of  (which may not be unique) without variables, and reciprocally (note that a term corresponds to a unique N-free poset).
A value can be associated to any term  whose leaves are all elements of  by the partial function  inductively defined by  for all ,  and .
Let . The \emph{syntactic congruence}  of  on  is defined by: for all ,  if, for any term  on  and any , 
It is well-known that the quotient sp-algebra  recognizes . Furthermore, the following property holds on :
\begin{prop}[see~\cite{Alm94} or~\cite{LW00:sp}]
  \label{prop:synt}
  Let  and  be two sp-algebras,  and  be an onto morphism.
  Then  if and only if, for any ,  implies .
\end{prop}

\begin{exa}
  \label{ex:abcAlgebra}
  Let  and  be the language of Example~\ref{ex:abc}.
  Let  be the sp-algebra defined by , , ,  is the neutral element for both sequential and parallel products, and all other products are mapped to . 
  Then  recognizes .
  Indeed, let  be the morphism defined by ,  and .
  Then  and .
  Furthermore .
\end{exa}

Lodaya and Weil have proved the following connection between recognizable and rational languages:
\begin{thm}[Lodaya and Weil, Theorem~1 of~\cite{lodaya98kleene}]
  \label{th:RecRat}
  Recognizable languages are rational.
\end{thm}

However, the following example (from~\cite{lodaya98kleene}) shows that in general, rational languages are not recognizable.
\begin{exa}
  \label{ex:anbnAlgebra}
  Let  and .
  Let  the morphism defined by , ,  for all .
  Then , and thus  recognizes .
  Furthermore,  is isomorphic to , thus  is not recognizable as a consequence of Proposition~\ref{prop:synt}.
  Example~\ref{ex:anbnAuto} gives an automaton  with .
\end{exa}

\medskip

Let us return to the proof of Theorem~\ref{th:complement}.
The first step is the construction of an algebra from an automaton.
We need to introduce some new definitions, which are applied in Example~\ref{ex:complement} at the end of this section.

\medskip

Let  and  be an automaton such that .

For every pair  of states, define  to be the set of multi-sets of pair of states as follows:

\mathcal{F}^0_{p,q}=
\begin{cases}
\{\{(p,q)\}\} &\text{ if there exists } p \mathop{\Longrightarrow}^P\limits_{\mathcal{A}} q, P\in SP^+(A),\\
\emptyset &\text{ otherwise.}
\end{cases}

\mathcal{F}_{p,q}^{i+1}=\mathcal{F}_{p,q}^{i}\cup\{ M-(p_j,q_j)\cup X :
M = \{(p_1,q_1)^{k_1},\dots,(p_n,q_n)^{k_n}\}\in \mathcal{F}_{p,q}^{i},\\
j\in[n], k_j>0, X\in K_{(p_j,q_j)} \}
\quotientparallel{\{X_i:i\in I\}}{Y}=\{X_i-Y : Y\subseteq X_i, i\in I\}
\mathcal{R}(P)=\{\{ (p_1,q_1),\dots,(p_n,q_n) : p_i \mathop{\Longrightarrow}\limits_{\mathcal{A}}^{P_i} q_i \text{ for all }i\in[n]\} : \\ P=P_1\parallel\dots\parallel P_n, P_i\in SP^+(A)\text{ for all }i\in[n]\}

\label{eq:cong}
\mathop\bigcup_{x\in \mathcal{R}(P)} \quotientparallel{\mathcal{F}_{p,q}}{x}
=
\mathop\bigcup_{x\in \mathcal{R}(P')} \quotientparallel{\mathcal{F}_{p,q}}{x}
\{(p'_j,q'_j):j\in J\}\cup\{(r_i,s_i) : i\in[k]\}\in (\quotientparallel{\mathcal{F}_{p,q}}{\{(p'_i,q'_i):i\in I\}})\cap (\quotientparallel{\mathcal{F}_{p,q}}{x})
X=\{\varphi_{\sim_{\mathcal{A}}}(P) : \emptyset\in\mathop\bigcup_{x\in \mathcal{R}(P)}\quotientparallel{\mathcal{F}_{i,f}}{x}\text{ for some }(i,f)\in I\times F\}

  Seq(X) &= \{P\in X : P\in A\text{ or }\exists P_1,P_2\in SP^+(A)\text{ such that }P=P_1P_2\}
L_{p,q}=\mathop\bigcup_{X\in \mathcal{F}_{p,q}}\mathop\parallel_{(r,s)\in X} Seq(L_{r,s}) \hskip1cm \text{ and } \hskip1cm \varphi_{\sim_\mathcal{A}}(L_{p,q})=\mathop\bigcup_{X\in \mathcal{F}_{p,q}}\mathop\parallel_{(r,s)\in X} \varphi_{\sim_\mathcal{A}}(Seq(L_{r,s}))L_{p,q}=\mathop\bigcup_{D\in\mathcal{P}(Q^2)\atop(p,q)\in D}\varphi^{-1}(\varphi(\Delta^{SP^+(A)}_D))\quotientparallel{L'}{L}=\{P\in SP(A) : \exists P'\in L\text{ such that } P\parallel P'\in L'\}\varphi_{\quotientparallel{Y}{X}}(z_1,\dots,z_n)=\exists x_1,\dots,x_n,y_1,\dots,y_n\ \varphi_X(x_1,\dots,x_n)\land\varphi_Y(y_1,\dots,y_n)\land_{i\in[n]}z_i+x_i=y_is\oplus s'=
\begin{cases}
  \delta(s+s')&\text{if }s,s'\in S_1,\\
  \Delta_{D,i}&\text{if }s=\Delta_{D,i}\text{ and } s'\in B_{D,i},\\
  \Delta_{D,i}&\text{if }s\in B_{D,i}\text{ and } s'=\Delta_{D,i},\\
  \text{undefined }&\text{otherwise}
\end{cases}
\delta(n)=
\begin{cases}
  n & \text{if }n\leq m,\\
  \Delta_{D,i} & \text{if }n\in\Delta_{D,i}^{\mathbb{N}^{k*}}\text{ and not }n\leq m.
\end{cases}
    \mathcal{F}_{(p,q)}=
    \begin{cases}
      \bigcup_{n,m\in\mathbb{N}\atop n+m>0}\{\{(1,7)^n,(2,5)^m,(3,6)^m\}\} & \text{if }(p,q)=(1,7);\\
      \{\{(p,q)\}\} & \text{if }(p,q)\in\{(2,4),(4,5),(2,5),\\&\hfill (3,6),(7,8),(1,8)\};\\
      \emptyset & \text{otherwise.}
    \end{cases}
  
    \bigcup_{x\in \mathcal{R}((aa)^{\parallel k})}\quotientparallel{\mathcal{F}_{(1,7)}}{x}=&\bigcup_{n,m\in\mathbb{N}\atop m\geq k}\{\{(1,7)^n,(2,5)^{m-k},(3,6)^m\}\}\\
    \bigcup_{x\in \mathcal{R}(a^{\parallel k})}\quotientparallel{\mathcal{F}_{(1,7)}}{x}=&\bigcup_{n,m\in\mathbb{N}\atop m\geq k}\{\{(1,7)^n,(2,5)^{m},(3,6)^{m-k}\}\}\\
    \bigcup_{x\in \mathcal{R}((a\parallel (aa))^{\parallel k})}\quotientparallel{\mathcal{F}_{(1,7)}}{x}=&\bigcup_{n,m\in\mathbb{N}}\{\{(1,7)^{n},(2,5)^{m},(3,6)^{m}\}\}\\
  
    \mathcal{R}(a^{\parallel k})=&\{x_1,\dots,x_k\}\text{ with } x_i\in\{(2,4),(3,6),(4,5),(7,8)\}\text{ for all }i\in[k]\\
    \mathcal{R}((aa)^{\parallel k})=&\{\{(2,5)^k\}\}\\
    \mathcal{R}((a\parallel (aa))^{\parallel k})=&\{\{(1,7)^k\}\}
  
    a^{\parallel k}\parallel (aa)^{\parallel k'} =&
    \begin{cases}
      a^{\parallel (k-k')} & \text{if }k>k'\\
      (aa)^{\parallel (k'-k)} & \text{if }k'>k\\
      (aa)\parallel a & \text{otherwise}
    \end{cases}
    
    \mathbb{N}^{4*}-\{(0,0,1,0)\} =& (1,0,0,0)\parallel B^\circledast + (0,1,0,0)\parallel B^\circledast + (0,0,1,0)\parallel B^\oplus + (0,0,0,1)\parallel B^\circledast
  \varphi(n_a,n_b,n_c)\equiv(\exists x\ n_b=n_a+x)\land (\exists y\ n_c=n_b+y)\mathcal{Q}_X(Z,(\psi_1(X),x_1),\dots,(\psi_n(X),x_n),\varphi(x_1,\dots,x_n))\mathcal{Q}_X(Z,(\psi_1(X),x_1),\dots,(\psi_n(X),x_n),\varphi(x_1,\dots,x_n))\forall P\ (\forall p\ p\in P)\rightarrow \mathcal{Q}_X(P,(\psi_a(X),n_a),(\psi_b(X),n_b),(\psi_c(X),n_c),\varphi(n_a,n_b,n_c))
  y<X\equiv& \forall x\ x\in X\rightarrow y<x\\
  y\parallel X\equiv& (\lnot y\in X)\land(\forall x\ x\in X\rightarrow y\parallel x)\\
  X\parallel Y\equiv& X\cap Y=\emptyset\land\forall x\forall y (x\in X\land y\in Y)\rightarrow x\parallel y\\
  \texttt{Pred}(X,Y)\equiv&\forall x\ x\in X\rightarrow\exists y\ y\in Y\land x<y\land\lnot\exists z\ x<z\land z<y\\
  &\land\forall y\forall x( y\in Y\land x<y\land\lnot\exists z\ x<z<y )\rightarrow x\in X\\
  \texttt{Antichain}(X)\equiv&\forall^X x\forall^X x'\ \lnot(x<x'\lor x'<x)\\
  \texttt{Min}(M,X)\equiv&M\subseteq X\land \texttt{Antichain}(M)\land\forall^X x\exists^M m\ m\leq x                 

   \texttt{ConnectedBlock}(C,X)\equiv& \texttt{Block}(C,X)\land(\forall^C c\forall^C c'\ (c\not=c'\land\texttt{Incomp}(c,c')) \rightarrow\\&\ \hskip4cm\exists^C c''\ \texttt{Comp}(c,c'')\land\texttt{Comp}(c',c''))\\    
   \texttt{GoodBlock}(R,X)\equiv&
   \texttt{Block}(R,X)\land
   (\forall^R r\forall^R r'\forall^X x (\texttt{Comp}(x,r)\land\texttt{Incomp}(x,r'))\rightarrow R(x))\\
   \texttt{Comp}(x,y)\equiv& x<y\lor y<x\\
   \texttt{Incomp}(x,y)\equiv& (\lnot x<y)\land(\lnot y<x)\\
   \texttt{Block}(R,X)\equiv&R\subseteq X\land\texttt{Card}_{>0}(R)\land(\forall^R r\forall^X x\forall^R r'\ r<x\land x<r'\rightarrow R(x))
 
  \texttt{MarkSeq}\equiv \forall x\mathop\land_{a\in A}(a(x)\rightarrow\mathop\lor_{(p,a,q)\in E}X_{(p,a,q)}(x))\\
  \land(\forall x\mathop\land_{(p,a,q)\in E}(X_{(p,a,q)}(x)\rightarrow\lnot\mathop\lor_{a'\in A\atop {(p',a',q')\in E\atop(p',a',q')\not=(p,a,q)}}X_{(p',a',q')})))

  \texttt{ConsistentSeq}\equiv \forall x\forall y(\texttt{Succ}(\{y\},\{x\})\land \texttt{Pred}(\{x\},\{y\}))\\
  \rightarrow \mathop\land_{(p,a,q)\in E}(X_{(p,a,q)}(x)\rightarrow\mathop\lor_{(q,b,r)\in E}X_{(q,b,r)}(y))

  \texttt{GMPB}(R,X)\equiv
  R\subseteq X \land
  \texttt{GoodBlock}(R,X) \land
  (\overline{\exists} R_1\overline{\exists} R_2\ R=R_1\parallel R_2)\land\\
  \forall R'\ (R'\subseteq X\land \texttt{GoodBlock}(R',X) \land \overline{\exists} R_1\overline{\exists} R_2\ R'=R_1\parallel R_2)\rightarrow \lnot\overline{\exists} T\ R'=R\parallel T

Wit_L(G) :& \text{the greatests }x\in P\text{ such that }x<G\text{ and there is no }y\in P-G\\&\text{ such that }y\parallel G\text{ and }x<y;\\
Wit_R(G) :& \text{the smallests }x\in P\text{ such that }x>G\text{ and there is no }y\in P-G\\&\text{ such that }y\parallel G\text{ and }x>y.

  Wit_L(G)=\{ w\in\max\{x\in P : x<G\} : Succ(w)=\min(G)\}\\
  Wit_R(G)=\{ w\in\min\{x\in P : G<x\} : Pred(w)=\max(G)\}

  \texttt{Wit}_L(x,G)\equiv 
  \exists M\exists R\ \texttt{Min}(M,G)\land\texttt{Pred}(R,M)\land R(x) 

  \texttt{MarkPar}\equiv\forall X\forall G\ \texttt{Universe}(X)\land\texttt{GMPB}(G,X)\rightarrow\\
  \mathop\lor_{(p,q)\in Q\times Q}(\forall^X x (\texttt{Wit}_L(x,G)\rightarrow X^-_{p,q}(x))\land (\texttt{Wit}_R(x,G)\rightarrow X^+_{p,q}(x)) )\\
  \land (\forall^X x\mathop\land_{(p,q)\in Q\times Q} ((\texttt{Wit}_L(x,G)\land X^-_{p,q}(x))\rightarrow \lnot\mathop\lor_{(p',q')\in Q\times Q\atop (p',q')\not=(p,q)}X^-_{p',q'}(x)))\\
  \land (\forall^X x\mathop\land_{(p,q)\in Q\times Q} ((\texttt{Wit}_R(x,G)\land X^+_{p,q}(x))\rightarrow \lnot\mathop\lor_{(p',q')\in Q\times Q\atop (p',q')\not=(p,q)}X^+_{p',q'}(x)))

  \texttt{GMPBMinStarts}_q(M,G,X)\equiv \texttt{GMPB}(G,X)\land \texttt{Min}(M,G)\rightarrow\\
  \forall x ((\texttt{Wit}_L(x,G)\rightarrow \mathop\lor_{r\in Q}X^-_{q,r}(x))\land(\texttt{Wit}_R(x,G))\rightarrow \mathop\lor_{r\in Q}X^+_{q,r}(x)) 

  \texttt{ConsistentPar}_1\equiv\forall X\forall G\forall M^-\forall M^+\forall Y^-\forall Y^+\\
  \texttt{Universe}(X)\land\texttt{GMPB}(G,X)\land\texttt{Min}(M^-,G)\land\texttt{Max}(M^+,G)\land \texttt{Pred}(Y^-,M^-)\land \texttt{Succ}(Y^+,M^+)\rightarrow\\
  \forall x\mathop\land_{(p,q)\in Q\times Q}((\texttt{Wit}_L(x,G)\land X^-_{p,q}(x))\lor(\texttt{Wit}_R(x,G)\land X^+_{p,q}(x)))\rightarrow\\
  ( (\texttt{Card}_1(Y^+)\rightarrow \forall y\ Y^+(y)\rightarrow \mathop\lor_{a\in A\atop{r\in Q\atop (q,a,r)\in E}}X_{q,a,r}(y))\land\\
    \hfill(\texttt{Card}_{>1}(Y^+)\rightarrow \forall G'\ \texttt{GMPBMinStarts}_q(Y^+,G',X))  )\\
  \land\hskip6cm\\
  ( (\texttt{Card}_1(Y^-)\rightarrow \forall y\ Y^-(y)\rightarrow \mathop\lor_{a\in A\atop{r\in Q\atop (r,a,p)\in E}}X_{r,a,p}(y))\land\\
    \hfill(\texttt{Card}_{>1}(Y^-)\rightarrow \forall G'\ \texttt{GMPBMaxEnds}_p(Y^-,G',X))  )\\

  \psi_{p,q}(X)\equiv
  \forall^X M^-\forall^X M^+\ \texttt{Min}(M^-,X)\land \texttt{Max}(M^+,X) \rightarrow\\
  ( (\texttt{Card}_1(M^-)\rightarrow \forall m\ M^-(m)\rightarrow \mathop\lor_{a\in A\atop r\in Q} X_{p,a,r}(m))
    \land\\
    \hfill(\texttt{Card}_{>1}(M^-)\rightarrow \forall G'\ \texttt{GMPBMinStarts}_{p}(M^-,G',X)) )\\
  \land\hskip6cm\\
  ( (\texttt{Card}_1(M^+)\rightarrow \forall m\ M^+(m)\rightarrow \mathop\lor_{a\in A\atop r\in Q} X_{r,a,q}(m))
    \land\\
    \hfill(\texttt{Card}_{>1}(M^+)\rightarrow \forall G'\ \texttt{GMPBMaxEnds}_{q}(M^+,G',X)) )
P,G\models \mathcal{Q}_Y(G,(\psi_{p_1,q_1}(Y),x_1),\dots,(\psi_{p_n,q_n}(Y),x_n),\varphi_{p,q}(x_1,\dots,x_n))\mathcal{Q}_Y(G,(\psi_{p_1,q_1}(Y),x_1),\dots,(\psi_{p_n,q_n}(Y),x_n),\varphi_{p,q}(x_1,\dots,x_n))
  \texttt{ConsistentPar}_2\equiv \forall X\forall G (X\subset P\land\texttt{GMPB}(G,X))\rightarrow \\
  \forall x\mathop\land_{(p,q)\in Q\times Q}( ((\texttt{Wit}_L(x,G)\land X^-_{p,q}(x))\lor(\texttt{Wit}_R(x,G)\land X^+_{p,q}(x)))\rightarrow\\
  \mathcal{Q}_Y(G,(\psi_{p_1,q_1}(Y),x_1),\dots,(\psi_{p_n,q_n}(Y),x_n),\varphi_{p,q}(x_1,\dots,x_n)) )

\phi_\mathcal{A}\equiv\exists X_{(p_1,a,q_1)}\exists X_{(p_1,b,q_1)}\exists X^-_{p_1,q_1}\exists X^+_{p_1,q_1}\dots \exists X_{(p_n,a,q_n)}\exists X_{(p_n,b,q_n)}\exists X^-_{p_n,q_n}\exists X^+_{p_n,q_n}\\
\texttt{MarkSeq}\land\texttt{ConsistentSeq}\land\texttt{MarkPar}\land\texttt{ConsistentPar}
\land
( \forall X\ \texttt{Universe}(X)\rightarrow \\
  ((\texttt{Card}_{>0}(X)\rightarrow
    ((\texttt{GMPB}(X,X) \rightarrow\\\hfill \mathop\lor_{i\in I\atop f\in F} \mathcal{Q}_Y(X,(\psi_{p_1,q_1}(Y),x_1),\dots,(\psi_{p_n,q_n}(Y),x_n),\varphi_{i,f}(x_1,\dots,x_n))\\
    \land
    ((\lnot\texttt{GMPB}(X,X)) \rightarrow \mathop\lor_{i\in I\atop f\in F} \psi_{i,f}(X)))
  )\\
  \land
  (\texttt{Card}_{0}(X)\rightarrow \mathop\lor_{i\in I\cap F}\texttt{true}
  ))\hskip4.3cm
)\hskip4cm
\mathcal{Q}_X(Z,(\psi_1(X),x_1),\dots,(\psi_n(X),x_n),\varphi(x_1,\dots,x_n))
    \texttt{Lin}(X)\equiv& \forall^X x\forall^X y\forall^X z\ (\texttt{Succ}(y,x)\land \texttt{Succ}(z,x)\rightarrow y=z)\land\\&\hskip6cm (\texttt{Pred}(y,x)\land \texttt{Pred}(z,x)\rightarrow y=z)\\
    \psi_1(X)\equiv& \texttt{Lin}(X)\land\exists^X x\ a(x)\land\forall^X y\ x=y\lor x<y\\
    \psi_2(X)\equiv& \texttt{Lin}(X)\land\exists^X x\ b(x)\land\forall^X y\ x=y\lor x<y\\
    \varphi(n_a,n_b)\equiv& n_a=2n_b
    
    \psi\equiv \forall P (\forall p\ p\in P)\rightarrow \exists X_1\exists X_2\ P=X_1\oplus X_2\ \\ \land\forall U ((\texttt{MaxBlock}(U,X_1)\lor\texttt{MaxBlock}(U,X_2))\rightarrow \mathcal{Q}_Y(U,(\psi_1(Y),n_a),(\psi_2(Y),n_b),\varphi(n_a,n_b))
  
L_\varphi=\bigcup_{i\in I}q_{j_{i,1}}\parallel\dots\parallel q_{j_{i,l_i}}\parallel(\bigcup_{k\in K_i} q_{j_{k,1}}\parallel\dots\parallel q_{j_{k,l_k}})^\circledast

for some finite set , disjoint finite sets , , with  for all , , . Wlog. we may assume that each multi-set of  has at least two elements, so  for all . Then  is composed of one initial state , one final state , two states  and  and one sequential transition  for all , , two states  and  and one sequential transition  for all , , . For each , there is one fork transition from  to all the , , and symmetrically, one join transition from all the , , to . For each , add also two states  and , a fork transition , a join transition , and, for all , a fork transition  and a join transition  if , a sequential transition  if . For each , add a fork transition  and a join transition . We have . Now, remove all sequential transitions, all join transitions,  and all states of the form  from  and name  the new automaton. Consider the disjoint union of  and . Remove . Replace  by  and all states of the form , , by . 
Join transitions  are removed with a similar mechanism.
\end{Proof}

\section{Conclusion}
\label{sec:conclusion}

The effectiveness of the constructions involved in the proof of Theorem~\ref{th:PMSORat} have several consequences.
The \emph{P-MSO theory  of } consists of all sentences  of P-MSO such that  for every . The P-MSO theory of  is \emph{decidable} if there exists a decision procedure that tests if .
Because emptiness is decidable for languages of branching automata (see Proposition~\ref{prop:findPath}), we have:
\begin{thm}
  \label{th:PMSODecidable}
  Let  be an alphabet.
  The P-MSO theory of  is decidable.
\end{thm}

In~\cite{LW00:sp}, Lodaya and Weil asked for logical characterizations of several classes of rational languages. 
As it is equivalent to branching automata, P-MSO is the natural logic to investigate such questions, that are still open.

Extending the work of Lodaya and Weil, and those of Kleene-Sch\"utzenberger, Kuske and Meinecke~\cite{Kuske200453} proposed to attach costs to paths in branching automata. They defined and studied branching automata with costs, and extended to this case the machinery from the theory of weighted automata. They provided in particular a Kleene-like theorem for branching automata with costs, in the particular case of bounded-width languages.

Among the works connected to ours, let us mention \'Esik and N{\'e}meth~\cite{EN01}, which itself has been influenced by the work of Hoogeboom and ten Pas~\cite{HtP:1996,HtP:1997} on text languages. They study languages of bi-posets from an algebraic, automata and regular expressions based point of view, and the connections with MSO. A bi-poset is a set equipped with two partial orderings; thus, N-free posets are a generalization of N-free bi-posets, where commutation is allowed in the parallel composition. 

MSO and Presburger logic were also mixed in other works, but for languages of trees instead of N-free posets. Motivated by reasoning about XML documents, Dal Zilio and Lugiez~\cite{DBLP:conf/rta/Dal-ZilioL03}, and independently Seidl, Schwentick and Muscholl~\cite{DBLP:conf/birthday/SeidlSM08}, defined a notion of tree automata which combines regularity and Presburger arithmetic. In particular in~\cite{DBLP:conf/birthday/SeidlSM08}, MSO is enriched with Presburger conditions on the children of nodes in order to select XML documents, and proved equivalent to unranked tree automata. Observe that unranked trees are a particular case of N-free posets.

\section*{Acknowledgement}

The author would like to thank the referees of this paper, whose comments helped in improving its quality. Among many remarks, the content of Section~\ref{sec:PBranching} was suggested by one of them.



\begin{thebibliography}{LW98b}

\bibitem[Alm94]{Alm94}
Jorge Almeida.
\newblock {\em Finite semigroups and universal algebra}, volume~3 of {\em
  Series in algebra}.
\newblock World Scientific, 1994.

\bibitem[B{\'E}96]{Bloom199655}
Stephen~L. Bloom and Zolt{\'a}n {\'E}sik.
\newblock Free shuffle algebras in language varieties.
\newblock {\em Theoretical Computer Science}, 163(1-2):55--98, 1996.

\bibitem[Bed13]{DBLP:conf/mfcs/Bedon13}
Nicolas Bedon.
\newblock Logic and branching automata.
\newblock In Krishnendu Chatterjee and Jiri Sgall, editors, {\em MFCS}, volume
  8087 of {\em Lecture Notes in Computer Science}, pages 123--134. Springer,
  2013.

\bibitem[B{\"u}c60]{Buc60}
J.~Richard B{\"u}chi.
\newblock Weak second-order arithmetic and finite automata.
\newblock {\em Zeit. Math. Logik. Grund. Math.}, 6:66--92, 1960.

\bibitem[DZL03]{DBLP:conf/rta/Dal-ZilioL03}
Silvano Dal-Zilio and Denis Lugiez.
\newblock {XML} {S}chema, {T}ree {L}ogic and {S}heaves {A}utomata.
\newblock In Robert Nieuwenhuis, editor, {\em RTA}, volume 2706 of {\em Lecture
  Notes in Computer Science}, pages 246--263. Springer, 2003.

\bibitem[EF99]{EF99}
Heinz-Dieter Ebbinghaus and J{\"o}rg Flum.
\newblock {\em Finite model theory}.
\newblock Springer monographs in mathematics. Springer, 2nd edition, 1999.

\bibitem[Elg61]{Elgot61}
Calvin~C. Elgot.
\newblock Decision problems of finite automata design and related arithmetics.
\newblock {\em Trans. Amer. Math. Soc.}, 98:21--51, January 1961.

\bibitem[{\'E}N02]{EN01}
Zolt{\'a}n {\'E}sik and Z.L. N{\'e}meth.
\newblock Automata on series-parallel biposets.
\newblock In W.~Kuich, G.~Rozenberg, and A.~Salomaa, editors, {\em DLT'2001},
  volume 2295 of {\em Lect. Notes in Comput. Sci.}, pages 217--227.
  Springer-Verlag, 2002.

\bibitem[ES69]{EilSch69}
Samuel Eilenberg and Marcel-Paul Sch\"utzenberger.
\newblock Rational sets in commutative monoids.
\newblock {\em Journal of Algebra}, 13(2):173--191, 1969.

\bibitem[GS64]{GS:AMS64}
Seymour Ginsburg and Edwin~H. Spanier.
\newblock Bounded algol-like languages.
\newblock {\em Transactions of the American Mathematical Society},
  113(2):333--368, November 1964.

\bibitem[GS66]{GS:PJM66}
Seymour Ginsburg and Edwin~H. Spanier.
\newblock Semigroups, {P}resburger formulas, and languages.
\newblock {\em Pacific Journal of Mathematics}, 16(2):285--296, 1966.

\bibitem[HtP96]{HtP:1996}
H.~J. Hoogeboom and P.~ten Pas.
\newblock Text languages in an algebraic framework.
\newblock {\em Fund. Inform.}, 25:353--380, 1996.

\bibitem[HtP97]{HtP:1997}
H.~J. Hoogeboom and P.~ten Pas.
\newblock Monadic second-order definable languages.
\newblock {\em Theory Comput. Syst.}, 30:335--354, 1997.

\bibitem[Kle56]{Kle56}
Stephen~C. Kleene.
\newblock Representation of events in nerve nets and finite automata.
\newblock In Shannon and McCarthy, editors, {\em Automata studies}, pages
  3--42, Princeton, New Jersey, 1956. Princeton University Press.

\bibitem[KM04]{Kuske200453}
Dietrich Kuske and Ingmar Meinecke.
\newblock Branching automata with costs—a way of reflecting parallelism in
  costs.
\newblock {\em Theoret. Comput. Sci.}, 328(1--2):53--75, 2004.
\newblock Implementation and Application of Automata.

\bibitem[Kus00]{Kus00:SPInf}
Dietrich Kuske.
\newblock Infinite series-parallel posets: logic and languages.
\newblock In {\em ICALP 2000}, volume 1853 of {\em Lect. Notes in Comput.
  Sci.}, pages 648--662. Springer-Verlag, 2000.

\bibitem[LW98a]{lodaya98kleene}
Kamal Lodaya and Pascal Weil.
\newblock A {K}leene iteration for parallelism.
\newblock In {\em Foundations of Software Technology and Theoretical Computer
  Science}, pages 355--366, 1998.

\bibitem[LW98b]{LW98:Algebra}
Kamal Lodaya and Pascal Weil.
\newblock Series-parallel posets: algebra, automata and languages.
\newblock In M.~Morvan, Ch. Meinel, and D.~Krob, editors, {\em STACS'98},
  volume 1373 of {\em Lect. Notes in Comput. Sci.}, pages 555--565.
  Springer-Verlag, 1998.

\bibitem[LW00]{LW00:sp}
Kamal Lodaya and Pascal Weil.
\newblock Series-parallel languages and the bounded-width property.
\newblock {\em Theoret. Comput. Sci.}, 237(1--2):347--380, 2000.

\bibitem[LW01]{lodaya01kleene}
Kamal Lodaya and Pascal Weil.
\newblock Rationality in algebras with a series operation.
\newblock {\em Inform. Comput.}, pages 269--293, 2001.

\bibitem[Par66]{Parikh:1966:CL:321356.321364}
Rohit~J. Parikh.
\newblock On context-free languages.
\newblock {\em J. ACM}, 13(4):570--581, October 1966.

\bibitem[Pin84]{Pin84}
Jean-{\'E}ric Pin.
\newblock {\em Vari{\'e}t{\'e}s de langages formels}.
\newblock Masson, Paris, France, 1984.
\newblock English version: {\it Varieties of formal languages}, Plenum Press,
  New-York, 1986.

\bibitem[PP86]{PP86}
Dominique Perrin and Jean-{\'E}ric Pin.
\newblock First order logic and star-free sets.
\newblock {\em J. Comput. System Sci.}, 32:393--406, 1986.

\bibitem[Pre30]{Presburger1930}
Mojzesz Presburger.
\newblock {\"U}ber die vollstandigkeit eines gewissen systems der arithmetic
  ganzer zahlen, in welchem die addition als einzige operation hervortritt.
\newblock In {\em Proc. Sprawozdaniez I Kongresu Matematykow Krajow
  Slowianskich, Warsaw}, pages 92--101, 1930.
\newblock English translation: On the completeness of certain system of
  arithmetic of whole numbers in which addition occurs as the only operation.
  {\em Hist. Philos. Logic}, 12:92--101, 1991.

\bibitem[Sak03]{Saka:thAutoFr}
Jacques Sakarovitch.
\newblock {\em {\'E}l{\'e}ments de th{\'e}orie des automates}.
\newblock Vuibert, 2003.
\newblock English (and revised) version: {\it Elements of automata theory},
  Cambridge University Press, 2009.

\bibitem[SSM08]{DBLP:conf/birthday/SeidlSM08}
Helmut Seidl, Thomas Schwentick, and Anca Muscholl.
\newblock Counting in trees.
\newblock In J{\"o}rg Flum, Erich Gr{\"a}del, and Thomas Wilke, editors, {\em
  Logic and Automata}, volume~2 of {\em Texts in Logic and Games}, pages
  575--612. Amsterdam University Press, 2008.

\bibitem[Str94]{Str94}
Howard Straubing.
\newblock {\em Finite automata, formal logic and circuit complexity}.
\newblock Birkh{\"a}user, 1994.

\bibitem[Tho97]{Thomas97a}
Wolfgang Thomas.
\newblock Languages, automata, and logic.
\newblock In G.~Rozenberg and A.~Salomaa, editors, {\em Handbook of Formal
  Languages}, volume III, pages 389--455. Springer-Verlag, 1997.

\bibitem[Tra62]{Trakhtenbrot62}
Boris~Avraamovich Trakhtenbrot.
\newblock Finite automata and monadic second order logic.
\newblock {\em Siberian {M}ath.}, 3:101--131, 1962.
\newblock (Russian). English translation in AMS Transl. 59 (1966), 23-55.

\bibitem[Val78]{Val78}
Jacobo Valdes.
\newblock Parsing flowcharts and series-parallel graphs.
\newblock Technical Report STAN-CS-78-682, Computer science departement of the
  Stanford University, Standford, Ca., 1978.

\bibitem[VTL82]{VTL82:SPDigraphs}
Jacobo Valdes, Robert~E. Tarjan, and Eugene~L. Lawler.
\newblock The recognition of series parallel digraphs.
\newblock {\em SIAM J. Comput.}, 11:298--313, 1982.

\end{thebibliography}



\end{document}
