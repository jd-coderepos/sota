\pdfoutput=1
\def\spaa{0} \ifnum\spaa=0
\documentclass[11pt]{article}
\usepackage{times}
\usepackage{amsthm}
\usepackage{fullpage}
\else
\documentclass[9pt]{sig-alternate}
\paperwidth=8.5in
\paperheight=11in
\fi

\usepackage{xspace}

\usepackage{enumerate}
\usepackage{comment}
\usepackage{url}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{graphicx}
\graphicspath{{./Figs/}}
\usepackage{paralist}
\usepackage[active]{srcltx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\newtheorem{theorem}{Theorem}
\newtheorem{rem}[theorem]{Remark}
\newtheorem{coro}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\usepackage[colorlinks,linkcolor=blue,filecolor=blue,citecolor=blue,urlcolor=blue,pdfstartview=FitH,plainpages=false]{hyperref}

\newcommand{\namedref}[2]{\hyperref[#2]{#1~\ref*{#2}}}
\newcommand{\sectionref}[1]{\namedref{Section}{#1}}
\newcommand{\appendixref}[1]{\namedref{Appendix}{#1}}
\newcommand{\subsectionref}[1]{\namedref{Subsection}{#1}}
\newcommand{\theoremref}[1]{\namedref{Theorem}{#1}}
\newcommand{\defref}[1]{\namedref{Definition}{#1}}
\newcommand{\figureref}[1]{\namedref{Figure}{#1}}
\newcommand{\figref}[1]{\namedref{Figure}{#1}}
\newcommand{\claimref}[1]{\namedref{Claim}{#1}}
\newcommand{\lemmaref}[1]{\namedref{Lemma}{#1}}
\newcommand{\tableref}[1]{\namedref{Table}{#1}}
\newcommand{\corollaryref}[1]{\namedref{Corollary}{#1}}
\newcommand{\propertyref}[1]{\namedref{Property}{#1}}
\newcommand{\appref}[1]{\namedref{Appendix}{#1}}
\newcommand{\propref}[1]{\namedref{Proposition}{#1}}
\newcommand{\Algref}[1]{\namedref{Algorithm}{#1}}
\newcommand{\lineref}[1]{\namedref{Line}{#1}}
\newcommand{\conditionref}[1]{\namedref{Condition}{#1}}
\newcommand{\Lineref}[1]{\namedref{Line}{#1}}
\newcommand{\equalityref}[1]{\hyperref[#1]{Equality~\eqref{#1}}}
\newcommand{\inequalityref}[1]{\hyperref[#1]{Inequality~\eqref{#1}}}

\usepackage{color}
\usepackage{soul}
\newcommand{\boaz}[1]{\hl{\textbf{BPS}: #1}}

\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }
\newcommand{\moti}[1]{\hlc[green]{\textbf{MM}: #1}}

\newcommand{\guy}[1]{\hlc[red]{\textbf{GE}: #1}}

\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}

\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}\algtext*{EndSwitch}\algtext*{EndCase}


\newtheorem{observation}[theorem]{observation}
\newtheorem{defn}[theorem]{Definition}
\newcommand{\INDSTATE}[1][1]{\State\quad}

\newcommand{\eps}{\varepsilon}
\newcommand{\route}{\text{\sc{ipp}}\xspace}
\newcommand{\IPP}{\route}
\newcommand{\routenear}{\text{\sc{route-near}}\xspace}
\newcommand{\routefar}{\text{\sc{route-far}}\xspace}
\newcommand{\initroute}{\text{\sc{initial-route}}\xspace}
\newcommand{\detailedroute}{\text{\sc{detailed-route}}}
\newcommand{\MDPR}{\text{\sc{Mmega}}}
\newcommand{\INJECT}{\text{\sc{inject}}}
\newcommand{\flow}{\text{\emph{flow}}}
\newcommand{\poly}{\text{\emph{poly}}}
\newcommand{\source}{\text{\emph{source}}}
\newcommand{\target}{\text{\emph{target}}}
\newcommand{\demand}{\text{\emph{demand}}}
\newcommand{\reject}{\text{\emph{reject}}}
\newcommand{\opt}{\text{\textsc{opt}}}
\newcommand{\iopt}{I^*}
\newcommand{\pmax}{p_{\max}}
\newcommand{\pmaxst}{p_{\max}^{st}}
\newcommand{\ctr}{\text{ctr}}
\newcommand{\eqdf}{\triangleq}
\newcommand{\cube}{\text{\emph{cube}}}
\newcommand{\alg}{\text{\sc{alg}}}
\newenvironment{proof sketch}[1]{\noindent {\emph{Proof sketch of #1:}}}{\hfill \qed}
\newcommand{\cut}{\textit{cut}}
\newcommand{\diam}{\textit{diam}}
\newcommand{\dist}{\textit{dist}}

\newcommand{\Set}[1]{\left\{#1\right\}}
\def\Pm{p_{\max}}
\def\DEF{\triangleq}
\newcommand{\row}{\text{\emph{row}}\xspace}
\newcommand{\far}{\text{\emph{Far}}\xspace}
\newcommand{\sw}{\text{\sc{sw}\xspace}\xspace}
\newcommand{\Gst}{G^{st}}


\newcommand{\near}{\text{\emph{Near}}\xspace}
\newcommand{\algf}{\alg_{\far^+}\xspace}
\newcommand{\algn}{\alg({\near})\xspace}

\newcommand{\algcon}{\alg}

\newcommand{\RIPP}{\IPP(\far^+ \mid \pmax)}\newcommand{\RIPPt}{\IPP^{\lambda}}
\newcommand{\Rinj}{\RIPPt_{1/4}}
\newcommand{\algfar}{\algf}
\newcommand{\Hl}{\ell_h}
\newcommand{\vl}{\ell_v}
\newcommand{\ppp}[2]{\text{\rm req}(#1\!\!\rightarrow\!\!#2)}
\newcommand{\WE}{\ppp{W}{E}}
\newcommand{\SE}{\ppp{S}{E}}
\newcommand{\SN}{\ppp{S}{N}}
\newcommand{\WN}{\ppp{W}{N}}


\ifnum\spaa=0
\title{\textbf{Better Online Deterministic Packet Routing on Grids}}
\else
\title{Better Online Deterministic Packet Routing on Grids}
\subtitle{[Regular Paper]}
\fi

\ifnum\spaa=0
\begin{comment} Commented out for arXiv submission
\author{
\begin{tabular}{c@{\extracolsep{20pt}}c@{\extracolsep{20pt}}c}
  Guy Even\thanks{Supported in part by }
  &Moti Medina\thanks{Supported in part by }
  &Boaz Patt-Shamir\thanks{Supported in part by ISF, MoST and
    Neptune.}
\\
\multicolumn{3}{c}{School of Electrical Engineering}\\
\multicolumn{3}{c}{Tel Aviv University}\\
\multicolumn{3}{c}{Israel}
\end{tabular}
}
\end{comment}

 \author{Guy Even \thanks{School of Electrical Engineering, Tel Aviv Univ., Tel-Aviv 69978, Israel. ({\tt guy@eng.tau.ac.il}).}
 \and
 Moti Medina
 \thanks{LIAFA, Universit\'{e} Paris Diderot, 75205 Paris Cedex 13, France. ({\tt moti.medina@liafa.univ-paris-diderot.fr}).
 }
 \and
 Boaz Patt-Shamir\thanks{School of Electrical Engineering, Tel Aviv Univ., Tel-Aviv 69978, Israel. ({\tt boaz@tau.ac.il}).}
 ~\protect\footnote{Supported in part by ISF, MoST and Neptune.}
 }
\else
\numberofauthors{3}
\author{
\alignauthor Guy Even\\
       \affaddr{School of Electrical Engineering}\\
       \affaddr{Tel Aviv University}\\
       \affaddr{Tel Aviv 6997801, Israel}\\
       \email{guy@eng.tau.ac.il}
\alignauthor Moti Medina\\
       \affaddr{LIAFA}\\
       \affaddr{Universit\'{e} Paris Diderot}\\
       \affaddr{75205 Paris Cedex 13, France}\\
       \email{moti.medina@liafa.univ-paris-diderot.fr}
\alignauthor Boaz Patt-Shamir\thanks{Supported in part by ISF, MoST and
    Neptune.}\\
       \affaddr{School of Electrical Engineering}\\
       \affaddr{Tel Aviv University}\\
       \affaddr{Tel Aviv 6997801, Israel}\\
       \email{boaz@tau.ac.il}
}
\fi
\begin{document} 

\if\spaa=0
\def\thepage{}
\begin{titlepage}
\fi

 \maketitle
\begin{abstract}We consider the following fundamental routing problem.
  An adversary inputs packets arbitrarily at sources,
  each packet with an arbitrary destination. Traffic is
  constrained by link capacities and buffer sizes, and
  packets may be dropped at any time. The goal of the
  routing algorithm is to maximize throughput, i.e.,
  route as many packets as possible to their destination.
  Our main result is an -competitive deterministic algorithm for an
-node line network (i.e., -dimensional grid),
requiring only that buffers can store at least 
packets, and that links can deliver at least  packets
per step. We note that  is the best ratio
known, even for randomized
  algorithms, even when allowed large buffers and wide
  links. The best previous deterministic algorithm for
  this problem with constant-size buffers and
  constant-capacity links was -competitive.
  Our algorithm works like admission-control algorithms
  in the sense that if a packet is not dropped
  immediately upon arrival, then it is ``accepted'' and
  guaranteed to be delivered.
We also show how to extend our algorithm to a polylog-competitive
algorithm for any constant-dimension grid.
\end{abstract}

\ifnum\spaa=1
\keywords{
\else
\paragraph{Keywords.}
\fi
Online Algorithms, Packet Routing,  Bounded Buffers, Admission Control, Grid Networks
\ifnum\spaa=1
}
\fi



\if\spaa=0
\end{titlepage}
\pagenumbering{arabic}
\fi
\section{Introduction}
The core function of any packet-switching network is to route packets
from their origins to their destinations, but many
fundamental questions about packet routing are far from being well
understood. In this paper we consider one of these
questions, namely the \emph{competitive throughput network model}, introduced
by~\cite{AKOR}.


Briefly, the model is as follows.  The network consists of  nodes
(switches) connected by point-to-point unidirectional communication
links, and we are given
two positive integer parameters,  and , called the buffer size
and link capacity, respectively.
Executions proceed as follows.
Packets are input by an adversary over time. Each packet is input at its \emph{source} node with a
given \emph{destination} node.
At each step, each packet is either forwarded over an incident link,
stored in its current location buffer, or dropped (i.e., removed from
the system).
Storing and forwarding are subject to the constraints that a buffer
can store at most  packets simultaneously and that a link can carry
at most  packets in a time step.  These constraints can be met for
all input sequences since the model allows for packets to be
{dropped} at any time.  The \emph{routing algorithm} selects, at
each step, which packets are forwarded, which are stored, and which
are dropped.  The goal of the algorithm is to maximize the number of
packets delivered at their destination.  Since we consider on-line
algorithms, we evaluate algorithms by their competitive ratio, i.e.,
the minimum ratio, over all finite packet input sequences, between the
number of packets delivered by the on-line algorithm and the maximum
number of packets that can be delivered by any (off-line)
constraint-respecting schedule.

It is nearly an embarrassment to find that very little is known about
this problem, even in the simplest case, where the network topology is
the trivial -node unidirectional line. In this work we provide
an improved deterministic algorithm  for networks whose topology is
a -dimensional grid.

\renewcommand{\arraystretch}{1.3}
\begin{table*}
\ifnum\spaa=0  \scriptsize \fi
\begin{center}
\begin{tabular}{|c|c|c|c|c|l|}
\hline
Ref. & Dim.& Comp.\ Ratio  & Deterministic?& Range of & Remarks \tabularnewline
\hline
\hline
\cite{DBLP:conf/icalp/EvenM10,DBLP:conf/spaa/EvenM11,EM14}&1&&\checkmark&&immediate from s-t reduction\\
\cite{AKK} &  &   &---  &  &  \tabularnewline
\cite{AZ}   &  &  & --- &   &  FIFO buffers\tabularnewline
\cite{DBLP:conf/icalp/EvenM10,EM14}  &  &  & --- &   &  {also for }
\tabularnewline
\cite{DBLP:conf/spaa/EvenM11,EM14}   &  &  &
\checkmark &   &  preemptive \tabularnewline
\cite{DBLP:conf/spaa/EvenM11,EM14}   & &  &
\checkmark &   &  preemptive\tabularnewline
\hline
\theoremref{thm:main}& &  & \checkmark &    & \tabularnewline
\theoremref{thm:d dim}& &  & \checkmark &    & \tabularnewline
\hline
\end{tabular}
\end{center}
\caption{\it Some results for centralized online algorithms for packet routing. The networks are
  uni-directional grids. In the special case
  of  and , the algorithm in \cite{DBLP:conf/spaa/EvenM11,EM14}
  is -competitive.
}
\label{table:previous work}
\end{table*}
\renewcommand{\arraystretch}{1}

\subsection{Our Results}
Our main result is a centralized \emph{deterministic} -competitive packet routing algorithm for
unidirectional lines with  nodes. The algorithm requires buffer size  and link capacity . In
addition, both  and  must be . We show how to extend the
algorithm to  dimensions, where the competitive ratio is ,
assuming that . Our algorithm is \emph{nonpreemptive}, namely,
packets are dropped only at the time of their arrival (similarly to admission control
policies, which ``accept'' or ``reject'' requests upon arrival). By contrast,
{preemptive} algorithms may drop packets at any time, i.e., packets are not
guaranteed to reach the destination even after they start traversing the
network. The best previous deterministic algorithm \cite{DBLP:conf/spaa/EvenM11,EM14} is
preemptive.

\tableref{table:previous work} provides  a summary of our
results and a comparison of our algorithm with some
previous results along various aspects.


\newpage
\subsection{Overview of Techniques}\label{sec:tech}


We first explain
our approach  for the 1-dimensional case.


The high-level idea is to reduce packet routing in a graph
 to circuit switching (or path packing,
see~\cite{KT,AAP}) in the \emph{space-time graph}  , where  denotes the set of time steps. This so-called
{space-time transformation} has been used extensively in
this context~\cite{AAF,ARSU,AZ,RR,
DBLP:conf/icalp/EvenM10,DBLP:conf/spaa/EvenM11,EM14}.
To be effective, the space-time
transformation requires an upper bound on path lengths which does not
result in losing too
much throughput. We use the bound of \cite{DBLP:conf/spaa/EvenM11, EM14}
(which extends \cite{AZ}),
that ensures that the loss is at most some constant fraction.
After the transformation, we have an instance of
\emph{online path packing}~\cite{AAP,
BN06}. It is known that if the capacities are
large enough, i.e., , then online path
packing is solvable with logarithmic competitive
ratio~\cite{AAP,DBLP:conf/icalp/EvenM10,DBLP:conf/spaa/EvenM11,EM14}. We overcome the difficulty that  and  are  by employing a technique
called \emph{tiling}, i.e., partitioning the network nodes into large enough subgrids.
Tiling has been used in the past
\cite{KT,BL,DBLP:conf/icalp/EvenM10,DBLP:conf/spaa/EvenM11,EM14}; in
our algorithm, we use  distinct tilings, and work on each of them independently.  Each tiling induces a new graph called the
\emph{sketch graph} whose nodes are the tiles. The capacity of the edges in the
space-time graph between adjacent tiles is  to allow for applying -competitive path packing algorithms.  Path packing algorithms over the sketch
graph produce sketch paths for accepted packets. Thus, after these preliminary
simplifications, we arrive at the sub-task of \emph{detailed routing}, in which
coarse sketch  paths must be expanded to paths in the original space-time graph.


\emph{Fractional Optimum.}
Key to our application of the path-packing algorithm is
the analysis of Buchbinder and Naor~\cite{BN06,BNsurvey}, which
bounds the performance of the algorithm w.r.t.\ the \emph{fractional}
optimum, which may deliver packet fractions.
This result allows us to scale buffer sizes and link
capacities up and down while keeping the competitive ratio
under control.


\emph{Combining algorithms.} Another central component in the analysis of our
algorithm is the combination technique introduced by Kleinberg and Tardos \cite{KT}.
Loosely speaking, this technique deals with an admission control algorithm that is
the conjunction of two competitive algorithms, the state of which depends only on the
requests accepted by both. The technique enables one to prove that the competitive
ratio of the combined algorithm is the sum (rather than the product) of the
competitive ratios of the constituent algorithms.



\subsection{Previous Work}
Algorithms for dynamic routing on networks with bounded
buffers have been studied extensively both in theory and in practice
(see, e.g.,~\cite{AKRR} and references therein).
Let us first focus on centralized algorithms for -dimensional grids.
We note that while centralized algorithms for packet routing were
always relevant for switch scheduling, recently the idea of centralization of
network functions, including route computation, gained substantial
additional traction due to
the concept of software-defined networks (SDN). See, e.g.,~\cite{nox}.
 The special case of -dimensional grids (with or without
buffers) is of particular interest as this is the underlying
topology of crossbars in switches \cite{T}.


\emph{Online Algorithms for Unidirectional Lines.}
There is a series of papers on uni-directional line
networks, starting with~\cite{AKOR}, which introduced the
model. In~\cite{AKOR}, a lower bound of 
was proved for the greedy algorithm on unidirectional lines
if the buffer size .  For the case  (in a
slightly different model), an  lower bound for
any deterministic algorithm was proved by~\cite{AZ,AKK}.
Both~\cite{AZ} and~\cite{AKK} developed, among other
things, online randomized centralized algorithms for
uni-directional lines with . In~\cite{AKK} an
-competitive randomized centralized algorithm
was presented for .  In addition,  it is proved in \cite{AKK}
that nearest-to-go is
-competitive for .  For the case ,
~\cite{AKK} presented a randomized
-competitive distributed algorithm.
(This algorithm also applies to rooted trees when all
packet are destined at the root.) In~\cite{AZ}, an
-competitive randomized algorithm was
presented for the case .  (This algorithm also
applies to rings and trees.)
In~\cite{DBLP:conf/icalp/EvenM10}, an -competitive,
nonpreemptive, randomized algorithm was presented. The algorithm
in~\cite{DBLP:conf/icalp/EvenM10} is applicable to a wide range of
buffer sizes and link capacities, including the case .  In~\cite{DBLP:conf/spaa/EvenM11}, an -competitive deterministic algorithm was
presented. The algorithm in~\cite{DBLP:conf/spaa/EvenM11} is
applicable for .

\sloppy
\emph{Online Algorithms for Unidirectional Grids.} Angelov et al.~\cite{AKK} showed that the
competitive ratio of greedy algorithms in unidirectional
-dimensional grids is  and that
nearest-to-go policy achieves a competitive ratio of
.
In~\cite{DBLP:conf/spaa/EvenM11}, an -competitive deterministic algorithm was
presented.An extension of
this algorithm to -dimensional unidirectional grids, with competitive
ratio ,  is
presented in~\cite{DBLP:conf/spaa/EvenM11}.

For more related results, refer to~\cite{EM14}.


\paragraph{Organization\ifnum\spaa=0.\fi}
The problem is formalized in \sectionref{sec:problem}.
In \sectionref{sec:prelim} we explain the reduction of
packet-routing to path packing, and the construction of sketch graph.
In \sectionref{sec:alg} we describe the overall algorithm,
and in \sectionref{sec:analysis} we analyze it. Sections
\ref{sec:prelim}--\ref{sec:analysis} deal with the
-dimensional grid (line); extension to the 
dimensional case is also discussed in
\sectionref{sec:d dim}.






\section{Model and Problem Statement}
\label{sec:problem}
\label{sect:problem}

We consider the standard model of synchronous store-and-forward packet
routing networks~\cite{AKOR,AKK,AZ}. The network is modeled by a
directed graph , and by two integer parameter .
For the most part of this paper, we consider a network whose topology
is  a \emph{directed line} of 
vertices, i.e.,
, .


Execution proceeds in discrete steps. In step , an arbitrary set of
\emph{requests} is input to the algorithm. Each request represents a
packet, and we will use both terms interchangeably. A request is
specified by a -tuple
, where  is the \emph{source node} of the
packet,  is its \emph{destination node}, and  is
the time step in which the request is input.

In each time step, the \emph{routing algorithm} removes packets that
reached their destination, and  decides, for each
packet currently in the network, including
packets input in the current
step, whether
\begin{inparaenum}[(i)]
\item to drop the packet, or
\item to send it over an incident link, or
\item to store it in the current node.
\end{inparaenum}
The selection of the action is done subject to the following
considerations.
\begin{compactitem}
\item If a packet is dropped, it is lost forever.
\item A packet sent from node  over link  at time  will
  be located at node  at time . The \emph{link capacity constraint} asserts that at any step,
  at most  packets can be sent over each link.
\item A packet stored at node  at time  will
  be located at node  at time . The \emph{buffer capacity
    constraint} asserts that at any step,
  at most  packets can be stored in each buffer.
\end{compactitem}
We use the following terminology.  A packet
 is said to be \emph{input} (or arrive)
at  at time . We say that  is
\emph{rejected} if it is dropped at time , otherwise
it is \emph{accepted}. (Our algorithm will guarantee that
all accepted packets arrive at their destination.)

Given a set of requests, the \emph{throughput} of a packet routing
algorithm is the number of
packets that are delivered to their destination.  We consider the
problem of maximizing the throughput of an online centralized
deterministic packet-routing algorithm.
By \emph{online} we mean that by time , the algorithm received as
input only requests that have been input by time .
By \emph{centralized} we mean that the algorithm receives
all
requests and controls all  packets currently in the system without delay.
By \emph{nonpreemptive} we mean that every accepted packet reaches its
destination.








\emph{Competitive Ratio.}
Let  denote an input sequence. Let  denote a
packet-routing algorithm.  Let  denote the throughput obtained by  on input . Let  denote the largest possible subset of
requests in  that can be delivered without
violating the capacity constraints. We say that an online
deterministic \alg\ is \emph{-competitive}, if for
every input sequence , . Our goal is to design an
algorithm with the smallest possible competitive ratio.

\section{First Steps}
\label{sec:prelim}
In this section we present preliminary simplifications we apply to the
problem. They include reducing the packet routing on a line problem to path
packing on grids, and then path packing on sketch graphs.

\subsection{From Packet-Routing on a Line to Path Packing in a Grid}
\label{sec:reduction}



Let  denote a directed line with link capacities  and
buffer sizes . The space-time grid of  is a directed
acyclic infinite graph  with edge capacities
, where
\begin{inparaenum}[(i)]
\item . Each vertex 
  has infinitely many copies in the space-time grid ; namely,
  vertex  is the copy of  that corresponds to time
  .
\item  where  denotes forward edges
  and  denotes the store edges.  Formally,  and .
\item The capacity of all edges in  is , and all edges in
   have capacity .
\end{inparaenum}

\emph{The transformation.} We transform a request
 for routing a packet in the directed
line  to a path request 
in the grid . The correctness of the reduction is
based on a one-to-one correspondence between paths in
 and a routing of a packet in . Each vertical
edge  in 
corresponds to forwarding a packet from  to 
in step , and each horizontal edge
 in  corresponds to
storing a packet in  in step .

\emph{Embedding in the plane.} The na\"ive depiction of
 maps vertex  to the point  in the
plane (i.e., the -axis is the time axis and the -axis
is the ``vertex-index'' axis). This embedding of 
results with a lattice of vertices in which edges are
either horizontal or diagonal.  We prefer the embedding in
which the edges are axis parallel, which means that vertex
 is mapped to the point .  In the
axis-parallel depiction, all the copies of a vertex  still reside in the th row. However, column 
corresponds to a traversal  of the complete line, starting
at  at time  and ending at  at time
.



\subsection{From One Grid to Four Sketch Graphs}\label{sec:sketch graph}
Given a grid generated by the transformation above, we apply another
transformation to produce a coarsened version, called the \emph{sketch
  graph}. Specifically, we use
\emph{tiling}. Tiling is a partition of the grid nodes into
  subgrids, where  and   are parameters to
 be determined later.  We also add dummy nodes to the space-time grid
 to complete all tiles.  This augmentation has no effect on
routing because a dummy vertex
does not belong to any route between real vertices.

The tiling is specified by two additional parameters  and  called
\emph{offsets}.  The offsets determine the positions of the corners of the tiles;
namely, the left bottom corner of the tiles are located in the points
, for . The algorithm
uses four offsets .  We
denote these four tilings by .

\begin{proposition}\label{prop:sw}
  For every vertex  of the space-time grid , there exists exactly one
  tiling  such that  is in the south-west quadrant of a tile of .
\end{proposition}
\noindent \propref{prop:sw} suggests a partitioning of the requests.
\begin{definition}
  A request  is in  if the source vertex  of request 
  belongs to the south-west quadrant of a tile in the tiling .
\end{definition}


\emph{The Sketch Graphs.}  Each tiling  induces a grid, called the sketch graph,
each vertex of which corresponds to a tile. The sketch graph induced by  is
denoted by , where  is the set of tiles in .
There is a directed edge  if  and .  All edges in the sketch graph are assigned unit capacity.


\subsection{Online Packing of Paths}\label{sec:IPP}
We use  the sketch graphs to solve \emph{path packing} problems.
Intuitively, the path packing model resembles the packet routing
model, except that there are no buffers, and that each link  may
have a different capacity .
In addition,  we
generalize the notion of a request to allow for a set of destinations
(similar to ``anycast'') as follows. Usually, the destination of a request consists of a
single vertex. If  is a directed graph, then it is easy to reduce
the case in which the destination is a subset to the case in which
the destination is a specific vertex. The reduction simply adds a
sink node that is connected to every vertex in the destination
subset. In our setting of space-time grid, the destination subset is
a row. Thus it suffices to add a sink node for each row (as in~\cite{AZ}).

Formally, a \emph{path request}  in  is a pair , where 
is the source vertex and  is the destination subset.  Let 
denote the set of paths that can be used to serve request ; namely, every path
 begins in , ends in a vertex in , and satisfies some
additional constraint (e.g., bounded length, bounded number of turns, etc.).  Given a sequence 
of path requests, we call a sequence  a \emph{partial routing}
of  if  and  for every .  The \emph{load} of
an edge  induced by  is the ratio . A partial routing of a set of path requests is called a \emph{-packing} if the
load induced on each edge is at most .  The \emph{throughput} of  is simply
the number  of paths in .

\paragraph{Integral and Fractional Partial Routings\ifnum\spaa=0.\fi}
In the integral scenario,
a path request is either  served by a single path or is not served.
In \emph{fractional routing},
a request  can be (partially) served by a combination of paths
. Namely, each path  serves a fraction
 of the request, where  for all
 and  . We refer to  as the \emph{flow
amount} of request . The \emph{load} of an edge  induced by request  is the ratio . A fractional solution is
-packing if the total load on in each edge, from all
requests, is at most .   The \emph{throughput} of a
fractional routing is the sum of the flow amounts of all requests. Given a
fractional routing , we use  to denote its
throughput.
Trivially, the maximum throughput attainable
by a fractional -packing is an upper bound on the maximum
throughput attainable by an integral -packing.  An
optimal-throughput fractional -packing can be computed off-line
by
solving a linear program.

\paragraph{Online Path Packing: Problem and Solution\ifnum\spaa=0.\fi}
In the
online path packing problem, the input is a sequence of
path requests .  Upon arrival of a
request , the algorithm must either allocate a path
 to  or reject .  An online path
packing algorithm is said to be
\emph{-competitive} if it computes a
-packing whose throughput is at least 
times the maximum throughput over all -packings. Note
that for online path packing, we assume that all edges have
capacity at least .

The online path packing algorithm in~\cite{AAP} (analyzed also by~\cite{BN06})
assigns weights to the edges that are exponential in the load of the edges. This load
is the load incurred by the paths allocated to the requests that have been accepted
so far. The algorithm is based on an oracle that is input  and the edge weights,
and outputs a lightest path  in . If the weight of  is large, then
request  is rejected; otherwise, request  is routed along .
We refer to the online algorithm for online integral path packing by
.
The competitive ratio of the \route\ algorithm is summarized in the following theorem.
\begin{theorem}[\cite{EM14}, following~\cite{AAP, BN06}]
\label{thm:IPP}\sloppy Consider an online path packing
problem on an infinite graph with edge capacities such that .
Assume that, for every request , the length of every legal path in  is
bounded by .  Then algorithm  is -competitive online integral path packing algorithm.  Moreover, the
throughput of  for any request sequence is at least  the throughput of
any fractional packing for that sequence.
\end{theorem}

\paragraph{Bounded Path Lengths\ifnum\spaa=0.\fi}
The load obtained by the \IPP\ algorithm is logarithmic in the maximum path length
. This suggests that  should be polynomial in .
Lemma~\ref{lemma:nB} states that limiting the number of store steps per packet by a
polynomial in  decreases the fractional throughput only by a constant factor.

We use the following notation. Given a request sequence , let
 denote a maximum throughput fractional -packing of , and let
 denote a maximum throughput fractional -packing with respect to
 under the constraint that each path is of length at most .
\begin{lemma}[after \cite{AZ}]\label{lemma:nB}
  Let .  Then .
\end{lemma}

\begin{figure}[t]
      \centering
        \includegraphics[width=0.35\textwidth]{parallel}
        \caption{\em An   grid. The four types
        of requests (i.e., ) are depicted
        by the four arrows.}
      \label{fig:crossbar}
    \end{figure}

\subsection{Routing paths across 2-d
  Grids}
Consider the following special case of routing in grids.
Suppose that each path request has a specific source vertex which
resides on either the south of the west side, and the destination is
either the north or the east \emph{side} (i.e., we can route to any
vertex on the requested side).
  For  and , let
 denote the set of path requests whose source
is in the  side and whose destination is the  side
(see \figref{fig:crossbar}).
The following claim establishes  sufficient and necessary conditions
for satisfying such path requests. We refer to the routing algorithm used in this
case as \emph{crossbar routing}.
\begin{proposition}[Crossbar routing]
\label{prop:crossbar}\sloppy
The path requests can be packed in the -dimensional 
directed grid  if and only if  and
.
\end{proposition}
\begin{proof}
  The ``only if'' part is obvious. We now present a distributed
  algorithm that proves the ``if'' part.  Without loss of generality,
  we may assume that  and  are empty. This
  assumption is satisfied by routing such requests along straight
  paths and giving them precedence over other requests. Thus we may
  ignore these lines henceforth, and we are left with the task of
  routing  and  under the assumption that
   and .

  These requests are served as follows.  Order the rows from bottom
  to top and the columns from left to right. Assume, w.l.o.g.,  that 
  (the case that  is solved analogously).

  Requests whose source vertex is in the first  rows or columns
  turn in the vertex along the diagonal emanating from the SW
  corner. For example, a request in  whose source
  is in row  is routed eastward for  hops, and then
  north for  hops (i.e., to the north side of the grid). See
  \figref{fig:crossbar2}.

  The requests whose source vertex is in the last  columns are
  routed northward until they reach a vertex that does not receive an
  east-bound path from its west neighbor. Once such a vertex is found,
  the path turns east and continues straight until it reaches the east
  side of the grid.  Indeed, such a right turn is always possible
  because  and hence a ``vacant row'' is always
  found.
\end{proof}

\begin{figure}[t]
      \centering
        \includegraphics[width=0.35\textwidth]{parallel2}
        \caption{\em Satisfying the path requests in the  two
          dimensional directed grid, where . }
      \label{fig:crossbar2}
    \end{figure}

\begin{rem}
  \propref{prop:crossbar} extends to the case of capacitated edges
assuming all horizontal edges have the same capacity and all
  vertical edges have the same capacity.
In this case, the requests can be routed iff
  the number of requests for each destination side is bounded by
  total capacity of edges crossing that side.
\end{rem}
\section{The Packet Routing Algorithm}
\label{sec:alg}
\begin{algorithm}[t]
\ifnum\spaa=1
\small
\fi
\caption{Top-level algorithm for packet routing in the -dimensional
  grid. Code for step .}
\label{alg:outline}
\begin{algorithmic}[1]
\State Let  be a list of new requests, sorted by
source-destination distance. \label{l0}
\State For each vertex , let  the first  requests in 
whose source is .\Comment{filter requests}
\label{line:filter}
  \For{each request }\label{l00}

\If {}{ } \label{l1}
\Else
\State Let  be s.t.\  \Comment{classify }\label{l2}
\State \label{item:IPP} 
\label{l5}\Comment{path lengths bounded by }
\State \label{item:init-route}  \label{l6}

\If { \text{ and } }

\State add  to 
\State \Comment{update  routes}

\Else {~Reject }
\EndIf
\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

We now present the routing algorithm. Pseudo-code is provided in
\Algref{alg:outline}.  The algorithm works as follows. First, in lines
\ref{l0}-\ref{l00}, an initial filtering of the requests removes requests if too many
requests originate in the same space-time vertex (see~\defref{def:R'}). Then each
remaining new request is processed. In lines \ref{l1}-\ref{l2}, it is classified as
either \near or \far, based on its source-destination distance (see paragraph on
packet classification).  \near requests are routed by the \routenear\ algorithm,
described in \sectionref{sec:near}.
Each \far request is associated with the tiling
 in which its source vertex belongs to a south-west quadrant of a tile. Each
tiling is processed separately by three procedures: (i)~The \IPP\ algorithm, which
performs online path packing over the sketch graph  (line~\ref{l5}). The outcome
 is either ``REJECT'' or a path in a sketch graph , i.e., a sequence
of tiles from the initial tile to the destination tile.  (ii)~The 
procedure looks for a routing within the SW-quadrant of the first tile of : its
outcome is either such a path denoted  or ``REJECT''. Only  and
 may reject a far request. If both procedures are
successful, then  is called (line~\ref{l6}). Detailed routing computes a path in
the space-time graph, i.e., a complete schedule for each packet.  In our algorithm,
the sketch path for each accepted request is computed once and it is fixed, but
the future part of a detailed route of a request may change due to the insertion of new packets.
Therefore, the procedure  not only computes a path for  in
, but may also alter the detailed routes of other requests (without changing
the high-level sketch-graph routes).

An important property of  and  is that their state
is determined by the requests that are actually in the system, i.e.,
accepted by both.  (Rejected requests by either do not affect the
state of the system.)  This property enables us to employ the
combination technique of~\cite{KT}.  The listing emphasizes this
property by explicitly managing the sets of accepted requests for
each class (denoted by ). These sets are arguments of
 and  and determine their states. We now proceed to
explain the algorithm in detail.


\paragraph{Packet classification\ifnum\spaa=0.\fi}
A request  is called \emph{near} if , and
\emph{far} otherwise. We denote the sets of near and far requests by \near\ and \far,
respectively. The far requests are further classified into four classes denoted by
, where . Namely,  is the set of far
requests whose source node is in the SW-quadrant of a tile  in the tiling .

\paragraph{Link Multiplexing\ifnum\spaa=0.\fi}
After classification, there are five classes of
requests: one for \near and one for each tiling. Routes for each class
are computed independently and the final result is the union of routes
over all classes. This is made possible by partitioning the capacity
of each edge in the space-time
grid into virtual \emph{tracks}, one track per class.  The capacity of each
track is  of the capacity of the edge, rounded
down, i.e., track capacities are  and
{}.  (This explains why
we require that .)

\paragraph{Tiling Parameters\ifnum\spaa=0.\fi}
Tile side lengths are set so that the trivial greedy routing algorithm
is -competitive for requests that can be satisfied within a
tile. Each tile
has length  and height , defined as follows.
Recall that the maximum path length  (cf.~\lemmaref{lemma:nB}).
\begin{defn}\label{def:xy}
We use the following parameters.
\begin{compactitem}
\item 
\item  and 
\end{compactitem}
\end{defn}
\noindent
We summarize with the following claim.


\begin{proposition}\label{prop:tiling}
If  is bounded by a polynomial in , then the tiling parameters
satisfy the following properties.
  \begin{compactenum}
  \item .
  \item The sum of the edge capacities along each tile side is .
  \item For each track, the sum of the track capacities along a tile side is at least .
\end{compactenum}
\end{proposition}

\begin{proof}
  Clearly . If  is polynomial in , then
  .  The sum of the edge capacities along a vertical side
  is .  The sum of the track capacities
  crossing a vertical side of a tile is at least . The capacities along a horizontal edge is bounded similarly.
\end{proof}


\paragraph{Filtering superfluous simultaneous requests with identical sources\ifnum\spaa=0.\fi}
Since we do not impose any restriction on the requests, it could well be that many
requests arrive at the same source vertex in a single time step. To deal with that,
we use that fact that for each node  and step , no more than  requests can
leave  in \emph{any} routing. The partition of link capacities for tracks
imposes a stricter limitation in the sense that within each class, no more than
 paths can have the same source vertex.
\begin{definition}\label{def:R'}
  Given a sequence  of requests, let  denote the subsequence of  defined as
  follows.  For each source vertex , choose 
  packets whose destination is closest to the source node. (If at most 
  requests originate at the same node, then all of them are kept
  in .)
\end{definition}
\noindent
\propref{prop:R'} shows that rejecting the requests in  reduces the
fractional optimal throughput only by a constant factor.
\subsection{Routing Rules}
The routing at the high level (sketch path) is determined by the
 algorithm.We now explain the
ideas behind refining these rough paths (in the sketch graph) into
actual paths (in the space-time grid). Throughout this section we
consider, w.l.o.g.,  a single tiling .

Fix a tile  IN . We distinguish between the following three types of requests in
 (we deal with \near requests in \sectionref{sec:near}).
\begin{compactitem}
\item \emph{Initial requests:} requests whose source vertex is in the
  south-west
  quadrant of the tile .
\item \emph{Traversing requests:} these are requests that enter  from a
  specific vertex on one side (either west or south) and must leave
  through any vertex of another side (either east or north).  The
  entry vertex is determined by a previously-invoked detailed routing,
  and the exit side is determined by the sketch path.
\item \emph{Final requests:} these are requests whose sketch path ends in
  tile .  The destination of a final request is the north side of
  .\footnote{The detailed path for  should end in a copy of the
    destination vertex  in . As any path that reaches the
    north side of  also reaches a copy of , we use the
    pessimistic assumption that  is the northmost row of
    tile .}
\end{compactitem}

    \begin{figure}
      \centering
        \includegraphics[width=0.35\textwidth]{detail-flows}
        \caption{The quadrants of a tile. Traversing requests may not cross the thick
          border lines. Upper bounds on the number of paths in each class that
          traverse the quadrant sides follow from the path packing algorithm \IPP. }
      \label{fig:detail}
    \end{figure}

Each tile is partitioned into  quadrants,
denoted NE, SE, SW and NW.  We constrain the way requests are routed
within a tile
using the following rules (see \figureref{fig:detail}; no request
may cross a thick line).

\begin{compactenum}
\item Initial requests always start in the SW-quadrant and are routed to the north or
  east side of the SW-quadrant along a straight path.  The SW-quadrant
  of each tile is reserved for routing of initial requests.
\item Traversing requests whose source and destination sides are
  opposite (e.g., from the south to the north side) are routed along a
  straight path.
\item Paths enter the tile either in the
  east half of the
  south side or the north half of the west side.
\item Paths exit the tile through either the east half of the north side or the
  north half of the east side.
\end{compactenum}

\subsection{Procedure \initroute}
Initial routing takes place in the SW-quadrant of the first tile of a
\far request.  The goal of \initroute is modest:  route the request
to the boundary of the SW-quadrant. This is done greedily  along
straight paths if possible: it may be the case that some of the edges
are already reserved for another request (also routed by \initroute of
the same tile). If no straight path is available, \initroute returns REJECT.
 This means that incoming traffic (of earlier requests)
continues uninterrupted along a straight path. Only remaining capacity
along edges that emanate from a vertex , if any, is used for
routing the requests that originate in . 

\subsection{Procedure \detailedroute}
The goal in detailed routing is to compute a detailed path  in
the space-time graph  given a sketch path  in the
sketch graph  and the initial part of the route .  The
sketch path specifies the sequence of tiles to be traversed by the
detailed path.  In addition, the sketch path specifies the tile sides
through which the detailed path should enter and exit each tile. Requests that have been
assigned a sketch path and an initial route must be successfully
routed by detailed routing.

Detailed routing is computed by applying crossbar routing (cf.\
\propref{prop:crossbar}) to the NW, SE and NE quadrants. This routing is computed
based on the present requests.  As new requests arrive, the future portions of the
detailed routes may change dynamically so that all requests which are ``in
progress'' will reach their destination. Below we argue that crossbar routing indeed succeeds.
\begin{claim}
Detailed routing successfully completes the route of each accepted far request.
\end{claim}
\begin{proof}
By \propref{prop:crossbar}, to ensure successful routing
it is sufficient to bound the number of paths
that need to traverse a quadrant by the capacity of the
quadrant side.
  By~\propref{prop:tiling}, the track capacity of each quadrant side
  is at least .  We now prove upper bounds on the number of paths
  that traverse each quadrant side (see~\figref{fig:detail}).  The
  \IPP\ path packing algorithm is a -packing over the sketch graph
  (whose edges have unit capacity). It follows that at most  paths
  traverse each side of the tile.  As every request that originates in
  the SW-quadrant of a tile must exit the tile, there are at most 
  paths that traverse each side of the SW-quadrant (although their sum
  is also bounded by ).  Hence the upper bounds depicted
  in~\figref{fig:detail} follow. We need to elaborate more on the
  NE-quadrant because it is also used for routing final requests
  (i.e., requests that do not exit the tile, but do want to reach its
  top row). Consider the north side of the NE-quadrant. There are at
  most  traversing requests that wish to exit the tile. In
  addition, there are at most  final requests that wish to reach
  to top row (as each final far request must have entered the
  tile). Thus, in total there are at most  paths that wish to
  reach the top side of the NE-quadrant. To summarize, the number of
  paths that wish to reach any quadrant side is bounded by the side's
  capacity, and hence by~\propref{prop:crossbar}, detailed routing
  succeeds.
\end{proof}

Finally, we note that in order for \detailedroute\ to be well defined, we compute it
in tiles in column-major order, i.e., we start with the bottom tile of the leftmost
row and go up, then the bottom tile of the second-from left column and go up etc.
This ensures that when we reach a tile, all input vertices are fixed. We remark that
detailed routing can be executed in a local distributed manner; in each time step,
each vertex needs only to know the initial paths the sketch paths of the incoming
packets.

\subsection{Procedure \routenear}\label{sec:near}


Finally, we describe the algorithm for the near requests.  The
\routenear\ Algorithm is extremely simple: it never stores a packet
(i.e., it uses only vertical edges in , and gives precedence
to older requests). In more detail, upon arrival of a request , the algorithm checks the number of requests already routed
along the outgoing vertical edge (from  to ). If
this number is less than , then the algorithm routes  along
the vertical path in  from  to
. Note that these edges occur in the future, and
hence cannot have been saturated by \routenear if the edge outgoing
from  is not saturated.  If there is no free capacity in the
outgoing vertical edge,  is rejected. Note that if  is
accepted, then it guaranteed to reach its destination.


\section{Analysis of Competitive Ratio of the Routing Algorithm}
\label{sec:analysis}


Our goal is to prove the following theorem for a directed line  of  vertices with
buffer sizes  and link capacities , where .
\begin{theorem}\label{thm:main}
  \Algref{alg:outline} is -competitive with respect to the throughput of a
  maximum fractional routing.
\end{theorem}

We translate the problem to a path packing problem over the space-time graph .
Let  denote a maximum throughput fractional  routing, and let
 denote its throughput. Let  denote the throughput of the
online packet algorithm. \theoremref{thm:main} follows directly from the following
lemma.

\begin{lemma}\label{lemma:frac cr} For every sequence of requests ,
  .
\end{lemma}

We outline the proof of~\lemmaref{lemma:frac cr}.  We scale the capacities down by a
factor of  in the sketch graph.  By linearity, this reduces
the optimal fractional throughput by the same factor (see~\propref{prop:scale}).  We
show that the filtering stage in~\lineref{line:filter} incurs only a constant factor
reduction to the optimal fractional throughput (see \propref{prop:R'}).  The filtered
requests  are partitioned into near requests and far requests (which are further
partitioned into  classes, one per tiling). The far and near requests are analyzed
separately.  The analysis of the throughput for far requests builds on the competitive
ratio of the \IPP\ algorithm and the \initroute\ algorithm (see~\claimref{claim:IPP}
and~\claimref{claim:init}). By applying the combining analysis of Kleinberg and
Tardos~\cite{KT}, we show that the competitive ratio for the combined algorithm is
the sum of the two algorithms (see~\claimref{claim:combine}).
In~\theoremref{thm:near}, we show that the \routenear\ algorithm succeeds in routing
a logarithmic fraction of the filtered near requests.  In~\sectionref{sec:ptt}, the
parts of the proof are combined together to prove~\lemmaref{lemma:frac cr}.

\subsection{Scaling and Filtering}
One advantage of working with fractional routings is that, by linearity, the
throughput scales exactly with the capacities.  Let  denote a maximum
throughput fractional routing in the sketch graph .  Recall that the sketch
graph has unit capacities. Coalescing of vertices of  in each tile results with
edge capacities that are . Hence, we obtain the following
proposition.
\begin{proposition}\label{prop:scale}
  .
\end{proposition}

\noindent
Recall that by~\defref{def:R'}, in the input sequence , at most  requests
originate in each space-time vertex.
\begin{proposition}\label{prop:R'}
.
\end{proposition}
\begin{proof}
  Fix a space-time vertex .  Let  (reps. ) denote requests in
   (reps. ) that originate in . Let . Consider the flow .  For
  every vertex , the amount of flow that originates in  is bounded by .  Divert flow from in  from  to  along shorter
  paths, to obtain a flow  with respect to  such that . Since
  , the proposition follows.
\end{proof}


\subsection{Far Requests}
Two algorithms determine whether a far request is rejected: (i)~the \IPP\ path
packing algorithm over the sketch graph, and (ii)~the \initroute\ algorithm that
deals with routing in the initial SW-quadrant of the source tile. We begin by showing
that, if invoked separately, each of these algorithms accepts at least a constant
fraction of the maximum fractional throughout over the sketch graph.

Let  denote the subsequence of requests in  that are in the class .
Suppose we invoke the \IPP\ algorithm in isolation over the sketch graph  with
the input sequence . By isolation we mean that the accepted requests are
determined solely by . Let  denote the number of requests
that are accepted by this invocation.
\begin{claim}\label{claim:IPP}
.
\end{claim}
\begin{proof}
  By \lemmaref{lemma:nB}, the restriction of the path lengths by  only reduces
  the fractional throughput by a factor less than .  By \theoremref{thm:IPP}, the \IPP\
  algorithm is -competitive, and hence its throughput is half the optimal
  fractional throughput with bounded path lengths.
\end{proof}

Let  denote the number of requests
that are accepted by  if invoked in isolation with
the input sequence .
\begin{claim}\label{claim:init}
.
\end{claim}
\begin{proof}
  A far request must exit the tile in which it begins.  The edge capacities in the
  sketch graph are unit. Hence, the amount of flow in  that
  originates in each tile is at most .  On the other hand, if a positive amount of
  flow originates in a tile , then at least one request starts in the SW-quadrant
  of . Hence  accepts at least one request that begins in .
\end{proof}

A na\"{\i}ve analysis of the requests accepted by the
conjunction of the \IPP\ and \initroute\ algorithms implies
that the accepted requests are in the intersection, which
might be empty. However, in our algorithm the subsequence
of accepted requests is determined by both algorithms, and
this set of accepted requests determines the state of both
algorithms. Hence, by applying the combining analysis of
Kleinberg and Tardos~\cite{KT}, the combined competitive
ratio is shown to be the sum of the isolated competitive
ratios.

\begin{claim}\label{claim:combine}
  .
\end{claim}
\begin{proof}
  To simplify notation, let  denote the \IPP\ algorithm in isolation, 
  denote the \initroute\ algorithm in isolation, and  denote the combined
  algorithm. Let  denote the input sequence .

  Consider the execution of  with the input sequence .  Let  denote the
  subsequence of requests accepted by the combined algorithm  on input  (i.e.,
  ).  Let  denote the subsequence of requests accepted by algorithm
   during this same execution. Note that .  Let us rewrite
   as a function  in which  equals
  the amount of flow assigned to request  by . We abuse
  notation and view  also as its characteristic function (i.e.,  if and
  only if ).

  Consider the packet routing version in which requests have demands in . A
  demand of  corresponds to the situation till now. A demand of zero means that
  the request does not appear (the input skips over this request). A fractional
  demand means that (i)~at most this fraction can be routed by the fractional
  routing, and (ii)~the request only occupies this fraction of the capacity of an
  edge. Fractional demand functions can be added and multiplied. If both
  functions are integral, then addition corresponds to the union, and
  multiplication corresponds to the intersection.

  Consider the demand function , for
  . First, note that it attains values in  because (i)~an
  accepted request  satisfies , and (ii)~a rejected request
   satisfies .  Note also that  is a
  feasible fractional flow with respect to the demand , hence
   

   We claim that the isolated algorithm  on input  accepts
   exactly .  To prove this consider the sequence of states of
    and . Let  denote the prefix of accepted
   requests by  till but not including the arrival of request
   .  Similarly, let  denote the prefix of accepted requests by  till
   but not including the arrival of request . If , for every , then
   . Now we prove that  by induction on . Before
   the first request, both sets are empty. The induction step for  is easy
   because  accepts  when the state is . On the other hand, if
    and , then .

Let  denote the competitive ratio of . Then


By Equations~\ref{eq:1} and~\ref{eq:2}

Observe that . Indeed, if , then
, so both sides equal . If , then  or 
equals zero (perhaps both), and hence the right hand side is at least .
Hence,

and the claim follows.
\end{proof}

\subsection{Near Requests}
In this section we analyze the competitive ratio of the \routenear\ algorithm with
respect to near requests.  Recall that: (1)~A request is a near request if
the distance from the source to the destination is at most . Note that
 and .  (2)~The
incoming requests are filtered so that at most  requests originate in every
space-time vertex.

The following theorem states that \routenear\ succeeds in routing at least a
logarithmic fraction of the filtered near requests. This theorem implies that the
throughput is at least a logarithmic fraction of the optimal fractional routing of
the filtered near requests.
\begin{theorem} \label{thm:near}
.
\end{theorem}
\begin{proof}\sloppy
  It suffices to prove that .  Consider the following bipartite conflict graph.  Nodes on
  side  are the requests of , and nodes on side  are the requests of
  .  There is an edge  if  is
  rejected by the \routenear\ Algorithm and the vertical route of  traverses the
  source vertex  of .  A request  conflicts with at most
   requests in each vertex. Hence, the degree of  in the conflict graph is
  at most .  On the other hand, the degree of  equals 
  (where  is the capacity of the track reserved for the near requests).
  \medskip\noindent By counting edges on each side we conclude that

Hence,

We conclude that

As ,
and the theorem follows.
\end{proof}

\subsection{Putting Things Together}\label{sec:ptt}\label{sec:together}
In this section we prove~\lemmaref{lemma:frac cr}.  We partition the input sequence
 into  and , for   (recall that
). By subadditivity,

In order to bound the ratio , it suffices to
separately bound the ratios of the terms. Indeed, by~\theoremref{thm:near}
 
By~\propref{prop:scale} and~\claimref{claim:combine},

Finally, by~\propref{prop:R'}, .
Since , the lemma follows.

\section{Extension to -Dimensional Grids}\label{sec:d dim}

The following theorem is proved by extending~\Algref{alg:outline} for a
line network to -dimensional grid.
\begin{theorem}\label{thm:d dim}
  For , there is a deterministic -competitive online algorithm for the throughput maximization problem.
\end{theorem}
\begin{proof}[(sketch)]
  As in the one-dimensional case, perform a space-time transformation on the
  -dimensional -node grid  to obtain the -dimensional space-time grid
  . Partition  to  subgrids (or
  subcubes). The side length of a subgrid equals  for directions that correspond
  to forward steps and  in the direction that corresponds to store steps.  There
  are two offsets per dimension, resulting with  tilings. The number of
  tracks equals the number of offsets plus one (the extra one is for the near requests), hence we
  require that .  Similarly to the -dimensional case, a
  request is classified as a near request if the distance from the source to the
  destination is at most .  Detailed routing within a tile is successful
  by the following observation. Every time a packet cannot turn to the direction that
  is dictated by its sketch path, there is a packet that did turn to its desired direction.
  Since the number of path emanating from each tile is bounded by the quadrant-side
  capacity, we conclude that every packet will eventually turn, if needed, within its
  quadrant, thus respecting its sketch path.

  Since the link capacity to track capacity ratio is , this scaling of
  capacities incurs an   factor to the competitive ratio.  The
  sketch graph is obtained in the same way, with the exception that edge capacities
  are set to  (so that that the number of paths that \IPP\ routes out
  of a -dimensional tile is at most ). The ratio of edge capacities
  in  between adjacent faces of tiles and the capacity of the edge in the
  sketch graph is . This incurs an additional factor of 
  for routing far requests due to capacity scaling.
The routing of near requests succeeds in routing at least a fraction of  of the near requests. We conclude that the competitive ratio is determined by the
fasr requests, and hence the theorem follows.
\end{proof}




\begin{comment}
\subsection{\moti{An -competitive Algorithm with Deferred Dispatch}} In the following theorem we state that if (a variant of)
Algorithm~\ref{alg:outline} is allowed to defer dispatching
of packets for  steps (not immediately), then
the competitive ratio drops to . The required
changes to Algorithm~\ref{alg:outline} are elaborated
within the proof sketch.

\begin{theorem}\label{thm:logn}
\moti{
  If , then there is an
  -competitive algorithm  in the -deferred dispatch model.
}
\end{theorem}
\begin{proof sketch}{Thm.~\ref{thm:logn}}
  We prove that it suffices \moti{to defer the dispatching of a packet by  time steps to obtain an -competitive algorithm.}
  In the first  time steps the algorithm
  ``observes'' which of the packets are rejected by the
  path packing algorithm \IPP. The \IPP\ algorithm packs at
  most  initial request in the SW-quadrant at hand. Proposition~\ref{prop:tiling}
  implies that the  capacity of the north side of the SW-quadrant is at least
  .
  Now, the algorithm orders the packets and \moti{dispatches} them
  to the north, one after the other (see Figure~\ref{fig:rearrange}).
  Note that to retain modularity the algorithm \moti{dispatches} the
  packets in the ``next'' SW-quadrant. Hence, the algorithm
  \moti{defers each packet by at most  time steps}, as required.
\end{proof sketch}

\begin{figure}
      \centering
        \includegraphics[width=0.48\textwidth]{rearrange}
        \caption{The algorithm observes which of the packets are rejected in the first  time steps.
        There are at most  non-rejected packets.
        The algorithm, then, orders the non-rejected packets and injects them to the north side of the SW-quadrant.
        Note that, since the capacity of the north side of each SW-quadrant is at least , the grey packets will not
        ``block'' the packets beneath them as depicted in the figure.}
      \label{fig:rearrange}
    \end{figure}
\end{comment}
\begin{comment}
\subsection{Large Buffers} \label{sec:largeB}

In this section we consider a special setting in which the buffers are large.
Note that the Algorithm fails if  both with near and far requests.
Formally, assume that .

We briefly mention the required modifications.  The tiling parameters are 
and .  This implies that there are no near requests and all requests are
classified as far.  Each tiles is partitioned in to a left half and a right half.
The algorithm considers only requests whose source vertex is in the left half of a
tile; such requests are denoted by . Note that random shifting is employed so
that on the average  contains half the requests.

The north and south side of the left half of each tile are ``blocked'' so that
detailed routing does not traverse these sides.  This means that -routing is only
along horizontal edges.  In the right half of each tile, three -routing are super
imposed. The first -routing is for the paths that enter the tile from the west
side. These paths traverse the left half horizontally and then in the right half
undergo -routing (so that they exit from the east or north side of the right
half).  The second -routing is for the paths that enter the tile from the south
side of the right half. Finally, the third -routing is for continuing the paths of
the -routing from the border between the halves to the north and east sides of
the right half of the tile.

Path lengths are bounded as before (this is why we require
that  is polynomial).  In addition the random
sparsification parameter  is the same.

The algorithm proceeds as follows:
\begin{enumerate}
\item Execute the \route\ algorithm with respect to the path requests in  over
  the sketch graph.

\item \label{line:toss 2} Toss a biased - coin  such that . If , then \textbf{reject} .

\item
\label{line:load 2}\label{item:quarter 2}
If the addition of  causes the load of any sketch edge to be at least
, then \textbf{reject} .

\item\label{line:I 2} Apply -routing to .  If -routing fails, then
  \textbf{reject} . Otherwise, \textbf{inject}  with the sketch path  and apply -routing till the destination is reached.
\end{enumerate}

In this setting, the ratio between the capacity of the sketch edges that emanate from
a tile to the number of requests whose source vertex is in the tile is constant. This
constant ratio simplifies the proof of the following theorem compared to the proof of
Theorem~\ref{thm:algrand}.

\begin{theorem}
  If , then there exists a randomized online algorithm
  that achieves a logarithmic competitive ratio for packet routing in a
  uni-directional line.
\end{theorem}

Recall that for the case where  and , there is an even simpler
and \emph{deterministic} online algorithm with 
competitive ratio, as stated in Theorem~\ref{thm:largeBc}.

\subsection{Small Buffers \& Large Link Capacities}\label{sec:smallBlargec}
The case  and  is dealt with
by simplifying the algorithm. We briefly mention the required
modifications. The tile size is  and .  The maximum
path length is set to  which is polynomial (i.e.,
tiling is not needed to reduce the path length).  Instead of
partitioning a tile into quadrants, we partition each tile into an
upper half and a lower half. The set  is defined to the set of
requests whose origin is in the lower half of a tile.

The set  is dealt by a vertical path. Since in every
tile ,  and
since , it follows that .

The set  is dealt by invoking a variation of the
-Algorithm. The modified invariants for detailed
routing are that paths may not enter or exit horizontally
through the lower half of a tile (but, of course, may
traverse the tile vertically).  -routing simply routes
the first  requests vertically. The
remaining capacity of  is reserved for incoming
paths from the south side. In the upper half of each tile,
-routing on a single column is employed.

We conclude with the following theorem.
\begin{theorem}
  If  and , then there exists a randomized
  online algorithm that achieves a logarithmic competitive ratio for packet routing
  in a uni-directional line.
\end{theorem}


\paragraph{Remark.}
The space-time graph seems to assign symmetric roles to the time axis and the space
axis.  Such a symmetry would imply that one could reduce the case of large buffers to
the case of large link capacities. However, this is not true due to the definition of
a destination.  A destination (in the space-time graph) is a row of
vertices (namely, the set of copies of an original vertex).
This implies that one cannot simply transpose the graph and exchange the roles of
space and time.
\end{comment}

\section{Conclusion}
\label{sec:conc}
In this paper we presented an online deterministic packet routing algorithm.  For the
one dimensional grid (with constant-size buffers and constant-capacity links), this
algorithm closes the gap with the best throughput achieved by a randomized
algorithm.  This closes a problem which was open for more than a decade, but still
leaves open quite a few problems. The most urgent one is to reduce the gap between
the upper and lower bounds on the competitive ratio. Currently the best upper bound
is  for the line, and we are not aware of any no non-trivial lower bound.
We note that reducing the upper bound to  seems to require new techniques,
as the reduction to online path packing introduces a logarithmic factor in the
competitive ratio.

Another important question is to come up with reasonable distributed
algorithms. Even though, as mentioned above, the SDN model shifts many
network operation tasks to the centralized setting, it is very
interesting to find out what can be done without a central
coordinator.

\begin{comment}
---------------------------------------

\begin{enumerate}
\item The algorithm can be extended to a wide combination
    of parameters of  and . Also, the algorithm can
    be extended to -dimensional grids and to support
    requests with deadlines(\moti{??}).
\item We did not optimize the lower bound on the capacities  (perhaps
can be reduced to 2, and randomized 1).
\item the boundry of AAP must be broken - designing
    p.routing algorithms that does not reduce to path
    packing seems to be imperative.
\item The alg presented here is a "derandomization" of
    the ICALP alg. with combining of online algs
    technique [KT95]. Moreover, only 4 phase shifts are
    required (rather than uniform dist. over the phase
    shifts). Randomization helped us to get an alg. that
    is  competitive w.r.t to .
\end{enumerate}



Two basic problems related to the design and analysis of online packet
routing remain open even for unidirectional lines.
\begin{inparaenum}[(i)]
\item Achieve a constant competitive ratio or prove a lower
    bound that rules out a
  constant competitive ratio.
\item Achieve a logarithmic competitive ratio by a distributed algorithm
(as opposed
  to a centralized algorithm).
\end{inparaenum}
\end{comment}



\bibliographystyle{abbrv}
\bibliography{packet}
\appendix
\section{-competitiveness of initial routing}
\begin{lemma}\label{lemma:SW}
  Fix a tile  and let  denote its SW quadrant.
  Suppose that the sources of   path requests are in . Then
   path requests are served by the initial
  routing in .
\end{lemma}
\begin{proof}
We restrict attention to rows of  which contain at least 
  sources and  columns of  which contain at least  sources of requests
  which cannot be
  routed horizontally. Since all other packets are trivially routed by the
  algorithm, we may assume w.l.o.g.\ that there are no other packets
  with sources in .


{Let  denote the number of rows that contain a source vertex of
  an initial request, and let  denote the number of columns that
  contain a source vertex of an initial request that is not routed
  horizontally.}
  Clearly, . On the other hand, detailed routing in
   serves  requests. We now prove that .

Without loss of generality, assume that
  . Thus it suffices to prove that



We proceed with case analysis.  If , then , as
  required.
Otherwise .  We further distinguish between two cases:
  \begin{enumerate}
  \item If , then , as required.
  \item If , then , as
      required.
  \end{enumerate}
\end{proof}

Note that, if a single requested is input to a SW-quadrant,
then intial routing accepts it.
\end{document}
