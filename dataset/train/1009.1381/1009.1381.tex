



\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[vlined,boxed]{algorithm2e}
\usepackage{graphicx}

\usepackage{color} \definecolor{tagada}{rgb}{1,0.15,0.15}

\usepackage{enumerate}
\usepackage{vmargin}

\setpapersize{A4}
\setmarginsrb{3cm}{2.5cm}{3cm}{2.5cm}{0.5cm}{0.5cm}{0.5cm}{1cm}

\theoremstyle{plain}
  \newtheorem{theorem}{Theorem}
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem*{problem}{Problem}
  \newtheorem{conjecture}{Conjecture}

\theoremstyle{remark}
  \newtheorem*{remark}{Remark}
  \newtheorem*{observation}{Observation}



\newcommand{\ids}{independent dominating set\xspace}
\newcommand{\MIDSpb}{\textsc{MIDS}\xspace}
\newcommand{\mids}{mids\xspace}
\newcommand{\MISpb}{\textsc{MIS}\xspace}
\newcommand{\MDSpb}{\textsc{MDS}\xspace}
\newcommand{\CSPpb}{\textsc{CSP}\xspace}

\newcommand{\branchm}{\mathbf{branch\_mark}}
\newcommand{\brancha}{\mathbf{branch\_all}}
\newcommand{\brancho}{\mathbf{branch\_one}}
\newcommand{\runtime}{1.3569}
\newcommand{\runtimeprec}{1.35684}


\title{A Branch-and-Reduce Algorithm for Finding a Minimum Independent
Dominating Set
\footnote{A preliminary version of this paper appeared in the
\textit{proceedings of WG 2006} \cite{WG2006}.}
}



\author{Serge~Gaspers\thanks{Center for Mathematical Modeling,
Universidad de Chile, 8370459 Santiago, Chile.
\texttt{sgaspers@dim.uchile.cl}}
\and Mathieu~Liedloff\thanks{Laboratoire d'Informatique Fondamentale d'Orl\'eans,
Universit{\'e} d'Orl{\'e}ans, 45067 Orl{\'e}ans Cedex 2, France.
\texttt{mathieu.liedloff@univ-orleans.fr}}
}


\date{}


\begin{document}

\SetAlgoSkip{}

\maketitle



\begin{abstract}
An \ids  of a graph  is a subset of vertices such that
every vertex in  has at least one neighbor in  and
 is an independent set, i.e. no two vertices of 
are adjacent in . Finding a minimum \ids in a graph is an NP-hard problem.
Whereas it is hard to cope with this problem using parameterized
and approximation algorithms, there is a simple exact -time algorithm
solving the problem by enumerating all maximal independent sets.
In this paper we improve the latter result, providing the first non trivial algorithm computing a minimum \ids of a
graph in time .
Furthermore, we give a lower bound of  on the worst-case running time of this algorithm,
showing that the running time analysis is almost tight.
\end{abstract} 


\section{Introduction}


During the last years the interest in the design of
exact exponential time algorithms has grown significantly.
Several nice surveys have been written on this subject.
In Woeginger's first survey \cite{Woeginger}, he presents the
major techniques used to design exact exponential time algorithms.
We also refer the reader to the survey of Fomin et al. \cite{SurveyFGK}
discussing some more recent techniques for the design and the analysis of exponential time algorithms. 
In particular, they discuss Measure \& Conquer and lower bounds.

In a graph , a subset of vertices  is \emph{independent} if no two vertices
of  share an edge, and  is \emph{dominating} if every vertex from  has at least one neighbor
in .
In the \textsc{Maximum Independent Set} problem (\MISpb), the input is a graph and the task is to find a largest
independent set in this graph. In the \textsc{Minimum Dominating Set} problem (\MDSpb), the input is
a graph and the task is to find a smallest dominating set in this graph.
A natural and well studied combination of these two problems asks for a subset of vertices
of minimum cardinality that is both independent and dominating. This problem is called
\textsc{Minimum Independent Dominating Set} (\MIDSpb).
It is also known as
\textsc{Minimum Maximal Independent Set}, since every \ids is a maximal independent set.
Whereas there has been a lot of work on \MISpb and \MDSpb
in the field of exact algorithms, the best known exact algorithm for
\MIDSpb\ -- prior to our work -- trivially enumerates all maximal independent sets.

\smallskip

\noindent {\bf Known results.}
The \MISpb problem was among the first problems shown to be NP-hard \cite{GareyJ79}.
It is known that a maximum independent set of a graph on  vertices can be computed in  time
by combining a result due to Moon and Moser, who showed in 1965 
that the number of maximal independent sets of a graph is upper
bounded by  \cite{MoonMoser} (see also \cite{MillerM60}), and a result due to Johnson, Yannakakis and Papadimitriou,
providing in \cite{Johnson} a polynomial delay algorithm to generate all maximal
independent sets.
Moreover many exact algorithms for this problem have been published, starting
in 1977 by an  algorithm by Tarjan and Trojanowski \cite{Tarjan}.
To date, the fastest known exponential space algorithms for \MISpb have been
designed by Robson. His algorithm from 1986 \cite{Robson} has running time  and
his unpublished computer-generated algorithm from 2001 \cite{RobsonTR} has
running time .
Among the currently leading polynomial space algorithms, there is a very simple algorithm with running
time  by Fomin et al. \cite{soda2006,AcmFGK} from 2006,
an  time algorithm by Kneis et al. \cite{KneisFSTTCS2009} from 2009,
and a very recent  time algorithm by Bourgeois et al. \cite{BourgeoisSWAT2010}.

\smallskip

The \MDSpb problem
is also well known to be NP-hard \cite{GareyJ79}.
Until 2004, the only known exact exponential time algorithm to solve \MDSpb
asked for trivially enumerating the  subsets of vertices. The year 2004 saw a particular
interest in providing some faster algorithms for solving
this problem. Indeed, three papers with exact algorithms for \MDSpb were published.
In \cite{WG2004} Fomin et al. present an  time algorithm, in
\cite{Randerath} Randerath and Schiermeyer establish an  time algorithm
and Grandoni \cite{Grandoni} obtains an  time algorithm.

In 2005, Fomin et al. \cite{icalp2005,AcmFGK} use the Measure \& Conquer approach to obtain an algorithm with
running time 
and using polynomial space. By applying a memorization technique they show that this running
time can be reduced to  when allowing exponential space usage.
Van Rooij and Bodlaender \cite{vanRooijSTACS2008} further improved the polynomial-space algorithm
to  and the exponential-space algorithm to .
By now, the fastest published algorithm is due to Van Rooij et al. In \cite{vanRooijESA2009}, they provide
a  time needing exponential space to solve the more general counting version of \MDSpb, 
i.e. the problem of computing the number of distinct minimum dominating sets.

\medskip

It is known that a minimum \ids (a \mids, for short) can be found in polynomial time for
several graph classes like interval graphs \cite{Chang}, chordal graphs \cite{Farber},
cocomparability graphs \cite{Kratsch} and AT-free graphs \cite{Broersma}, whereas the problem
remains NP-complete for bipartite graphs \cite{Corneil} and comparability
graphs \cite{Corneil}.
Concerning approximation results, Halld\'orsson proved in \cite{Halldorsson}
that there is no constant  such that \MIDSpb can be approximated
within a factor of  in polynomial time, assuming .
The same inapproximation result even holds for circle graphs and bipartite graphs~\cite{Damian}.

The problem has also been considered in parameterized approximability.
Downey et al. \cite{Downey} have shown 
that it is -hard to approximate -\textsc{Independent Dominating Set}
with a factor , for any computable function .
In other words, unless ,
there is no algorithm with running time  (where  is any computable
function independent of ) which either asserts that there is no \ids
of size at most  for a given graph , or otherwise asserts
that there is one of size at most , for any computable function .

The first exponential time algorithm for \MIDSpb has been observed by Randerath and Schiermeyer \cite{Randerath}.
They use the result due to Moon and Moser \cite{MoonMoser} as explained
previously and an algorithm enumerating all the maximal independent sets
to obtain an  time algorithm for \MIDSpb.
In 2006, an earlier conference version of this paper claimed an
 time algorithm \cite{WG2006}. However, a flaw concerning 
the main reduction rule was discovered
by the authors and is repaired in the present paper.
Very recently, Bourgeois et al. \cite{BourgeoisSIROCCO2010} proposed a branch-and-reduce  time algorithm,
reusing several of the ideas introduced in \cite{WG2006}.


\smallskip

\noindent {\bf Our results.}
In this paper we present an  time algorithm for solving \MIDSpb
using the Measure \& Conquer approach to analyze its running time.
As the bottleneck
of the algorithm in \cite{Randerath} are the vertices of degree two, we develop several methods
to handle them more efficiently such as marking some vertices and a
reduction described in Subsection \ref{sec:cliques} to a constraint satisfaction problem.
Combined with some elaborated branching rules, this enables
us to lower bound shrewdly the progress made by the algorithm at each
branching step, and thus to obtain a polynomial-space algorithm with running time .
Furthermore, we obtain a very close lower bound of  on the running
time of our algorithm, which is very rare for non trivial exponential time algorithms.


\smallskip

This paper is organized as follows. In Section 2, we introduce the necessary concepts and definitions.
Section 3 presents the algorithm for \MIDSpb. We prove
its correctness and an upper bound on its worst-case running time in Section 4.
In Section 5, we establish a lower bound on its worst-case running time, which is very close
to the upper bound
and we conclude with Section 6.


\section{Preliminaries}


Let  be an undirected and simple graph. For a vertex  we denote 
by  the neighborhood of  and by  the closed neighborhood of .
The degree  of  is the cardinality of . For a given subset of vertices
,  denotes the subgraph of  induced by ,  denotes the set of
neighbors in  of vertices in  and . 
We also define  as ,  as , and  (called the -\emph{degree} of ) as the cardinality of
. In the same way, given two subsets of vertices  and , we define
.

A \emph{clique} is a set  of pairwise adjacent vertices.
A graph  is \emph{bipartite} if  admits a partition into two
independent sets.
A bipartite graph  is \emph{complete bipartite} if every vertex
of one independent set is adjacent to every vertex of the other independent set.
A \emph{connected component} of a graph is a maximal subset of vertices inducing a
connected subgraph.

\medskip

In a branch-and-reduce algorithm, a solution for the current problem instance is computed by
recursing on smaller subinstances such that
an optimal solution, if one exists, is computed for at least one subinstance.
If the algorithm considers only one subinstance in a given case, we speak of a reduction rule,
otherwise of a branching rule.

Consider a vertex  of degree two with two non adjacent neighbors  and .
In such a case, a branch-and-reduce algorithm will typically branch into three subcases when considering :
either , or , or  are in the solution set. In the third branch, one can consider that
 is not in the solution set as the second branch considers all solution sets containing . In order
to memorize that  is not in the solution set but still needs to be dominated, we mark .

\begin{definition}
A \emph{marked graph}  is a triple where 
 denotes the set of vertices of  and
 denotes the set of edges of .
The vertices in  are called \emph{free vertices} and the ones in 
\emph{marked vertices}.
\end{definition}

\begin{definition}
\label{defidsmarked}
Given a marked graph , an \ids 
of  is a subset of free vertices such that
 is an \ids of the graph .
\end{definition}

\begin{remark}
It is possible that such an \ids does not exist in a marked graph,
for example if some marked vertex has no free neighbor.
\end{remark}

\noindent Finally, we introduce the notion of an \emph{induced marked subgraph}.

\begin{definition}
Given a marked graph  and two subsets , an
\emph{induced marked subgraph}  is the marked graph

where  are the edges of  with
both end points in .
\end{definition}

\noindent Notions like neighborhood and degree in a marked graph  are
the same as in the corresponding simple graph .



\section{Computing a \mids on Marked Graphs}


In this section we present an algorithm
solving \MIDSpb on marked graphs, assuming that no marked vertex has -degree larger than .

{F}rom the previous definitions it follows that
a subset  is a \mids of a graph 
if and only if  is a \mids of the
marked graph . Hence the algorithm
of this section is able to solve the problem on simple graphs as well.
Also due to the definitions, edges incident to two marked vertices
are irrelevant; throughout this paper we assume that there are no such edges.


\medskip

Given a marked graph , consider the graph  induced by
its free vertices. In the following subsection we consider the special case
when  is a disjoint union of cliques with some additional properties.


\subsection{ is a disjoint union of cliques}
\label{sec:cliques}

Assume in this subsection that the graph  is a disjoint union of cliques such that:
\begin{itemize}
\item each clique has size at most , and
\item each marked vertex has at most  free neighbors.
\end{itemize}

We will transform this instance  of \MIDSpb into an instance
 of the Constraint Satisfaction Problem (\CSPpb). Let us
briefly recall some definitions about \CSPpb.
Given a finite set  of  variables over domains ,
, and a set  of  constraints, \CSPpb asks for
an assignment of values to the variables, such that each variable is assigned a value from its domain,
satisfying all the constraints.
Formally, -\CSPpb is defined as follows:



\begin{description}
\item[Input:]  where 
is a finite set of variables over domains  of
cardinality at most , ,
and  is a set of constraints.
Each constraint  is a couple 
where  is a -tuple of variables, with ,
and  is a set of -tuples of values over .

\item[Question:] Is there a function  assigning to each variable , ,
a value of  such that for each constraint , ,
 ?
\end{description}


Given a marked graph  fulfilling the previous conditions,
we describe the construction of a -\CSPpb instance.
We label the cliques  of  respectively by .
For each clique , , label its vertices from  to .
For each variable , , we define its domain as .

Let  be a marked vertex and let 
be the free neighbors of . Thus, .
Let  be the -tuple of variables corresponding respectively
to the cliques containing .
Let  be the set of all -tuples 
over 
such that for at least one , , the value of  is 
and  is an edge of the graph.

Finally, each marked vertex  leads to a constraint 
of the set . Due to the conditions on the given marked graph,
the size of the domain of each variable is at most 
and the number of variables involved in each constraint is at most .





We now use the following theorem of Angelsmark \cite{Angelsmark05}
showing that it is possible to restrict our attention to
-\CSPpb.

\begin{theorem}[Theorem~11 of \cite{Angelsmark05}]
If there exists a deterministic  time algorithm for
solving -\CSPpb, then for all , there exists a deterministic
 time algorithm for solving
-\CSPpb, for any .
\end{theorem}

The constructive proof of this theorem
shows how to transform a -\CSPpb instance on  variables into a set of
-\CSPpb instances on at most  variables each, such that the -\CSPpb instance has a solution
if and only if at least one of the -\CSPpb instances has a solution. The number
of -\CSPpb instances of this construction is bounded by ,
where  is the number of variables with domain size  in the -\CSPpb instance and  can
be taken arbitrarily small.

We use this construction to transform our -\CSPpb instance into a set of 
-\CSPpb instances, where  is the number of cliques of size  in .
Then, it is not hard to see that
there exists a \mids for  if and only if at least one of the -\CSPpb instances has
an assignment of the variables which satisfies all the constraints of this \CSPpb instance.
Given a satisfying assignment  to such a \CSPpb instance,
the set 
is a solution to \MIDSpb for .
We obtain the following theorem.



\begin{theorem}
Let ,  and  be the number of variables (i.e. the number of cliques of )
with domain size (resp. of size) ,  and , respectively.
The corresponding \CSPpb instance can be solved in time

where  is the running time needed to solve a -\CSPpb instance on  variables,
for any .
\end{theorem}

The theorem can be combined with the following result of Moser and Scheder \cite{MoserS10}
providing an algorithm for solving -\CSPpb.



\begin{theorem}[\cite{MoserS10}]\label{thm:MoserS10}
Any -\CSPpb instance can be solved deterministically in time , for any .
\end{theorem}

\begin{corollary}\label{cor:csp}
Let  be a marked graph such that
 is a disjoint union of cliques
of size at most , and each marked vertex has -degree at most 4.
Let , , be the number of free vertices with  free neighbors in 
(thus  has  cliques of size ).
A \mids, if one exists, can be computed in time

or it can be decided within the same running time that the marked graph has no \mids, for
any .
\end{corollary}

We remark that the procedure of Corollary \ref{cor:csp} will not be a bottleneck in the final
running time analysis of our algorithm, even if we use the  by Dantsin et al. \cite{Dantsin}
to solve -\CSPpb instances instead of Theorem \ref{thm:MoserS10}.

















\subsection{The Algorithm}
\label{sec:algo}

In this subsection, we give Algorithm {\bf ids} computing the size of a \mids
of a marked graph. Although the number of branching rules is quite large
it is fairly simple to check that the algorithm computes the size of
a \mids (if one exists). It is also not difficult to transform {\bf ids} into
an algorithm that actually outputs a \mids.
In the next section we prove the correctness and give a detailed analysis
of the running time of Algorithm {\bf ids}.

Once it has selected a vertex , the algorithm makes recursive calls (that is, it branches)
on subinstances of the marked graph. There are different ways the algorithm branches and we
give the most common ones now. Let  denote the free neighbors of , ordered by increasing -degree.
The branching procedure  explores all possibilities that  or a free neighbor of  is in the solution set. It returns

The branching procedure  additionally makes sure that the free neighbors of  are considered by
increasing -degree and when considering the possibility that  is in the solution set, it marks all vertices , .
It returns

Finally, the branching procedure  considers the two possibilities where  is in the solution set or
where  is not in the solution set. In the recursive call corresponding to the second possibility,  is marked.
The procedure returns




\begin{algorithm}[htbp]
{\small
\DontPrintSemicolon
\SetVlineSkip{0.44pt}
\Indm
\textbf{Algorithm ids()\\}
\KwIn{A marked graph  with  for each .}
\KwOut{The size of a \mids of .}
\SetKwComment{LabRule}{}{}
\BlankLine
\Indp
   \If{} {
     \Return \LabRule*[r]{}
   }
   \ElseIf{ is a disjoint union of cliques} {
      \If{} {
        \Return \LabRule*[r]{}
      }
      \ElseIf{} {
        \Return \LabRule*[r]{}
      }
      \Else {
        \Return the solution determined by the algorithm of Corollary~\ref{cor:csp}\LabRule*[r]{}
      }
   }
   \ElseIf{} {
      let  be the free neighbor of \;
      \Return \LabRule*[r]{}
   }
   \ElseIf{} {
      let  be partitioned into two independent sets  and \;
      \Return \LabRule*[r]{}
   }
   \ElseIf{} {
      \Return \LabRule*[r]{}
   }
   \Else {
      choose  such that\;
      \Indp
        (a)  is not contained in a connected component in  that is a clique,\;
        (b) according to (a),  has minimum -degree, and\;
        (c) according to (a) and (b),  has a neighbor in  of maximum -degree.\;
      \Indm
      \If{} {
         \Return \LabRule*[r]{}
      }
      \ElseIf{}{
         \If{ has a neighbor of -degree at most }{
             \Return \LabRule*[r]{}
         }
         \Else{
             \Return \LabRule*[r]{}
         }
      }
      \ElseIf{} {
         \If{all free neighbors of  have -degree 3}{
             Let  such that  has at most  edge\;
             \Return \LabRule*[r]{}
         }
         \ElseIf{ has a neighbor  of -degree 4} {
             \Return \LabRule*[r]{}
         }
         \ElseIf{ has a neighbor  of -degree 5} {
            \Return \LabRule*[r]{}
         }
         \ElseIf{ has two free neighbors of -degree 3} {
            \If{ is a clique} {
            	Let  with maximum -degree\;
                \Return \LabRule*[r]{}
            }
            \Else {
                \Return \LabRule*[r]{}
            }
	     }
         \Else {
            \Return \LabRule*[r]{}
         }
      }
      \ElseIf{} {
         \Return \LabRule*[r]{}
      }
      \Else(\tcp*[h]{}){
         \Return \LabRule*[r]{}
      }
   }
}\end{algorithm}


The branching procedure  is favored over  if  would create marked vertices of degree at least .
Thus, starting with a graph where all the
marked vertices have -degree at most , Algorithm {\bf ids} will keep this invariant.
This property allows us to use the procedure described in the previous subsection whenever the
graph induced by its free vertices is a collection of cliques of size at most .
The correctness and running time analysis of {\bf ids} are described in the next section.


\section{Correctness and Analysis of the Algorithm}
\label{sec:correctanaly}

In our analysis, we assign so-called weights to free vertices.
{F}ree vertices having only marked neighbors can be handled without
branching. Hence, it is an advantage when the -degree of a vertex decreases.
The weights of the free vertices will therefore depend on their
-degree.

Let  denote the number of free vertices having -degree .
For the running time analysis we consider the following measure of the size of :

with the weights .
In order to simplify the running time analysis, we make the following assumptions:

\begin{itemize}
\item ,
\item  for ,
\item , and
\item  where .
\end{itemize}

\begin{theorem}
\label{upperbound}
Algorithm {\bf ids} solves \MIDSpb in time .
\end{theorem}
\begin{proof}
An instance  is \emph{atomic} if Algorithm \textbf{ids} does not make a recursive call on input .
Let  denote the maximum number of atomic subinstances recursively processed to compute a
solution for an instance of size . As the time spent in each call of {\bf ids}, excluding the time
spent by the corresponding recursive calls, is polynomial, except for Case (4), it is sufficient to show
that for a valid choice of the weights, , and that the time spent in Case (4) does not exceed . Each recursive call made
by the algorithm is on an instance with at least one edge fewer, which means that the
running time of {\bf ids} can be upper bounded by a polynomial factor of . Moreover, as no reduction or
branching rule increases ,  can be bounded
by analyzing recurrences
based on the measure of the created subinstances in those cases where the algorithm makes
at least  recursive calls.
We will analyze these cases one by one.

{\bf Case (1)}
A marked vertex that has no free neighbor cannot be dominated. Thus, such an instance has no \ids.

{\bf Case (2)}
In this case,  is a disjoint union of cliques and  is a vertex from a clique
of size  in . The branching  creates  subinstances
whose measure is bounded by . The corresponding recurrence relation is

For , the tightest of these recurrences is when :


{\bf Case (3)}
In this case,  is a disjoint union of cliques and  is a vertex from a clique
of size  in . The branching  creates  subinstances
whose measure is bounded by  and , respectively. Note that the marked vertex which is created in the second branch has -degree . The corresponding recurrence is


{\bf Case (4)} The graph induced by the free vertices is a disjoint union of cliques of size no more
than . Corollary~\ref{cor:csp} is applied on the remaining marked graph and we note that
the number  of vertices of -degree , , in this graph is no more than
,
 and

with .


{\bf Case (5)}
A marked vertex  with exactly one free neighbor  must be dominated by . Thus,  is added to the \mids and all
its neighbors are deleted.

{\bf Case (6)}
If there is a subset  of free vertices such that  induces a complete bipartite
graph and no vertex of  is adjacent to a free vertex outside , then the algorithm branches
into two subcases. Let  and  be the two maximal independent sets of . Then
a \mids contains either  or . In both cases we delete 
and the marked neighbors of either  or .
The smallest possible subset  satisfying the conditions of this case
is a , that is a path on three vertices,
as . Note that all smaller complete bipartite graphs are cliques and will be handled by Case (4).
Since we only count the number of free vertices, we obtain the following recurrence:

It is clear that any complete bipartite component with more than three
vertices would lead to a better recurrence.

{\bf Case (7)}
If there is a subset  of three free vertices which form a clique and exactly one vertex 
has free neighbors outside , the algorithm either includes  in the solution set or it
excludes this vertex. In the first branch, all the neighbors of  are deleted
(including ). In the second branch, note that  is not marked. Indeed, 's -degree
might be too high to be marked, and 's neighborhood contains a clique component in  of which one vertex is in every
\ids of the resulting marked graph, making the marking of  superfluous.
We distinguish two cases based on the number of free neighbors of some free vertex .
\begin{enumerate}
\item Vertex  has one free neighbor. In the first branch, all of  are deleted, and in the second branch,  is removed,
's -degree decreases to , and the -degree of both vertices in  decreases to .
This gives the recurrence:

\item Vertex  has -degree at least . Then we obtain the recurrence:

\end{enumerate}

{\bf Case (8)}
If there is a free vertex  such that , a \mids either includes 
or its free neighbor . Vertex  cannot have -degree one
because this would contradict the first choice criterion (a) of . For the analysis, we
consider two cases:
\begin{enumerate}
\item . Let  denote the other free neighbor of . Note that 
 as this would have been handled by Case (6).
We consider again two subcases:
\begin{enumerate}
\item . When  is chosen in the \ids,  and  are deleted and the
degree of  decreases to one. When  is chosen in the \ids,  and 
are deleted from the marked graph. So, we obtain the following recurrence for
this case:


\item . Vertices  and  are deleted in the first branch,
and ,  and  are deleted in the
second branch. The recurrence for this subcase is:

\end{enumerate}

\item . At least one free neighbor of  has -degree at
least 2, otherwise Case (6) would apply. Therefore the recurrence
for this subcase is:

\end{enumerate}

{\bf Case (9)}
If there is a free vertex  such that  and  has a neighbor
of -degree at most  (as the neighbors  of  are ordered by increasing
-degree,  has -degree at most ), the algorithm uses  to branch into three subcases. 
Either  belongs to the \mids, or  is
taken in the \mids, or  is marked and  is taken in the \mids.
We distinguish three cases:
\begin{enumerate}
\item . In this case, due to the choice of the vertex 
by the algorithm, all free vertices of this connected component  in
 have -degree 2.  cannot be a  (a cycle on 4 vertices)
as this is a complete bipartite graph and would have
been handled by Case (6).
In the branches where  or  belong to the \mids, the three free vertices
in  or  are deleted and two of their neighbors ( is a cycle on
at least  vertices) have their -degree reduced from  to .
In the branch where  is marked and  is added to the \mids, 
 is deleted and by Case (5), the other neighbor  of  is
added to the \mids, resulting in the deletion of  as well. In total,
at least  free vertices of -degree  are deleted in the third branch.
Thus, we have the recurrence

for this case.

\item . The vertices  and  are not adjacent,
otherwise Case (7) would apply. In the last branch,  is marked and  is added
to the solution. If  and  have a common neighbor besides , then the last
branch is atomic because Case (1) applies as no vertex can dominate . Otherwise, the
reduction rule of Case (5) applies in the last branch and the other neighbor 
is added to the solution as well. Thus, we have the recurrence


\item . We distinguish between two cases depending on whether there 
is an edge between  and .
\begin{enumerate}
\item  and  are not adjacent. Branching on ,  and 
leads to the following recurrence:


\item  and  are adjacent. We distinguish two subcases depending on whether there is a degree- vertex in .
\begin{enumerate}
\item There is a degree- vertex in . Then,

\item No vertex in  has degree . Then,

\end{enumerate}
\end{enumerate}
\end{enumerate}

{\bf Case (10)}
If there is a free vertex  such that  and none of the above cases
apply, then  and  have degree at least  and the algorithm branches into the 
three subinstances of : either  or  belongs to the \mids, leading to the recurrence


{\bf Case (11)}
If all neighbors of  have degree , then the connected component in  containing 
 is -regular due to the selection criteria of . As (by criterion (a)) this 
component is not a clique,  is not empty. Thus, there exists some  
such that  has at most one edge. This means that there are at least  edges 
with one endpoint in  and the other endpoint in . If , the recurrence corresponding to the 
branching  is

if  it is

and if  it is a mixture of the above two recurrences and is majorized by one
or the other.

{\bf Case (12)}
If  has a neighbor  of -degree , then the algorithm uses the branching procedure
. If  is taken in the \mids,  vertices of degree at least  are
removed from the instance. If  is marked, the -degree of  decreases from  to . The corresponding recurrence is


{\bf Case (13)}
If  has a neighbor  of -degree , then the algorithm either takes  in the 
\mids, or , or it marks both  and  (note that  will have -degree 4). The recurrence corresponding to this case is


{\bf Case (14)}
In this case,  is a clique and  is the only vertex from this clique that has
free neighbors outside . The algorithm either takes  in the \mids or deletes 
it. Note that  includes a clique and that any \mids of  contains one vertex from this clique, which makes the marking of  superfluous. 


{\bf Case (15)}
We distinguish two cases based on the neighborhood of .
\begin{enumerate}
\item  is adjacent to  and . Then,  is not adjacent to , otherwise
Case (14) would apply. In the second branch, 's -degree drops to  and in the
third branch, 's neighbor in  is also selected by Case (5). This gives the
recurrence

\item  is not adjacent to  or to . In the last branch,  vertices are deleted and one vertex is marked, giving

\end{enumerate}

{\bf Case (16)}
In this case,  has at least two neighbors of degree at least . The recurrence corresponding to the branching  is


{\bf Case (17)}
If  has degree , the algorithm branches along , giving the recurrence


{\bf Case (18)}
If  has degree , the algorithm branches along . The corresponding recurrence is , the tightest of which is
obtained for :


Finally the values of weights are computed with a convex optimization program \cite{GaspersS09} (see also \cite{Gaspers08})
to minimize the bound on the running time.
Using the values  and  for the weights, one can
easily verify that . In particular by this choice of the weights, the running-time required
by Corollary~\ref{cor:csp} to solve the \CSPpb instance whenever Case (2) is applied is no more than 
(it would be bounded by  if we used the algorithm of Dantsin et al. \cite{Dantsin} for solving (2,4)-\CSPpb).
Thus, Algorithm \textbf{ids} solves \MIDSpb in time .
\end{proof}

The tight recurrences of the latter proof (i.e. the worst case
recurrences) are (\ref{rec:tight1}), (\ref{rec:tight2}), (\ref{rec:tight3}), and (\ref{rec:tight4}).



\section{A Lower Bound on the Running Time of the Algorithm}
In order to analyze the progress of the algorithm during the computation of a
\mids, we used a non standard measure. In this way we have been able to
determine an upper bound on the size of the subinstances recursively processed by the
algorithm, and consequently we obtained an upper bound on the
worst case running time of Algorithm \textbf{ids}. However the use of another measure
or a different method of analysis could perhaps provide a
``better upper bound'' without changing the algorithm but only improving the
analysis.

How far is the given upper bound of Theorem~\ref{upperbound} from the best upper
bound we can hope to obtain?
In this section, we establish a lower bound on the worst case running time of
our algorithm. This lower bound gives a really good estimation on the precision of
the analysis. For example, in \cite{icalp2005} (see also \cite{AcmFGK}) Fomin et al. obtain a
 time algorithm for solving the dominating set problem and
they exhibit a construction of a family of graphs giving a lower bound of 
for its running time. They say that the upper bound of many exponential time
algorithms is likely to be overestimated only due to the choice of the measure
for the analysis of the running time, and they note the gap between their upper
and lower bound for their algorithm.
However, for our algorithm we have the following result:

\begin{theorem}
\label{lowerbound}
Algorithm {\bf ids} solves \MIDSpb in time .
\end{theorem}


To prove Theorem~\ref{lowerbound} on the lower bound of the worst-case running time of
algorithm {\bf ids},
consider the graph  (see Fig. \ref{lbgraph}) defined by:
\begin{itemize}
\item ,
\item .
\end{itemize}

We denote by  the marked graph corresponding
to the graph .

\begin{figure}
\centering
      \includegraphics[scale=0.55]{lbgraph_new}
      \caption{\label{lbgraph}graph }
\end{figure}


For a marked graph  we define

and
 as the set of free vertices
with smallest -degree.

We denote the highest -degree of the free neighbors of the vertices in  by
.

Let 
be the set of candidate
vertices that {\bf ids} can choose in Case (9).
W.l.o.g. suppose that when  and {\bf ids} would
apply Case (9), it chooses the vertex
with smallest index (e.g. if , the algorithm would
choose ).


\begin{lemma}\label{LBLemma1}
Let  be the input of Algorithm {\bf ids}.
Suppose that {\bf ids} only applies Case (9) in each recursive call
(with respect to the previous rule for choosing a vertex).
Then, in each call of {\bf ids} where the remaining input graph has more
than four vertices, one of the following two properties is fulfilled:

\begin{enumerate}[(1)]
\item  for a certain , , and
\begin{enumerate}[(i)]
\item the set of vertices  has been deleted from
the input graph, and
\item all vertices in  remain free in
the input graph.
\end{enumerate}

\item  for a certain , , and
\begin{enumerate}[(i)]
\item the set of vertices  has
been deleted from the input graph, and
\item all vertices in  remain
free in the input graph.
\end{enumerate}
\end{enumerate}
\end{lemma}

\begin{proof}
We prove this result by induction. It is not hard to see that 
for  and that Property (1) is verified.

Suppose now that Property (1) is fulfilled. Then there exists an integer , ,
such that .
Since {\bf ids} applies Case (9) respecting the rule for choosing the vertex in ,
the algorithm chooses vertex .
Then we branch on three subinstances:
\begin{enumerate}[(b1)]
\item Take  in the \mids and remove .
Thus, the remaining free vertices are 
whereas all other vertices are removed. Moreover for this remaining
subinstance, we obtain . So, Property
(2) is verified.
(Note also that .)

\item Take  in the \mids and remove :
 is the set of the remaining free vertices
and all other vertices are removed. For the remaining
subinstance we obtain 
and Property (1) is verified.
(Note also that .)

\item Take  in the \mids and remove . Thus,
the remaining free vertices are 
and all other vertices are removed. For this remaining
subinstance we obtain 
and Property (2) is verified.
(Note also that .)
\end{enumerate}

If we suppose now that Property (2) is fulfilled, branching on
a vertex  gives us the same kind of subproblems.
\end{proof}

Now, we prove that, on input ,
Algorithm {\bf ids} applies Case (9) as long as
the remaining graph has ``enough'' vertices.

\begin{lemma}
Given the graph  as input,
as long as the remaining graph has more than four vertices,
Algorithm {\bf ids} applies Case (9) in each recursive call.
\end{lemma}

\begin{proof}
We prove this result also by induction.
First, when the input of the algorithm is the graph ,
it is clear that none of Cases (1) to (8) can be applied.
So, Case (9) is applied since  according
to Lemma~\ref{LBLemma1}.

Consider now a graph obtained from  by repeatedly
branching using Case (9).
By Lemma~\ref{LBLemma1}, the remaining graph
has no marked vertices (this excludes that
Cases (1) and (5) are applied). It has no clique component induced by the set of free vertices
since the graph is connected and there is no edge between
 and  (this excludes Cases (2)--(4)). The free vertices do not induce a bipartite graph
since  induces a  (this excludes Case (6)). There is no clique 
such that only one vertex of  has neighbors outside : the largest induced clique in the remaining
graph has size 3 and each of these cliques has at least two vertices having some neighbors outside
the clique (this excludes Case (7)). Also, according to Lemma~\ref{LBLemma1}, the remaining graph
has no vertex of degree 1 (this excludes Case (8)) and .
Consequently, the algorithm applies Case (9).
\end{proof}

\begin{figure}[htb]
\centering
      \includegraphics[scale=0.6]{lbsearchtree}
      \caption{\label{lbsearchtree}a part of the search tree}
\end{figure}


Figure \ref{lbsearchtree} gives a part of the search tree illustrating the fact that
our algorithm recursively branches on three subinstances with respect to Case (9).

\begin{proof}[Proof of Theorem~\ref{lowerbound}]
Consider the graph  and the search tree which results from branching using
Case (9) until  vertices, , have been removed from the
given input graph  ( has  vertices).
Denote by  the number of leaves in this search tree.
It is not hard to see that this leads to the following recurrence
(see the notes in the proof of Lemma \ref{LBLemma1}):
 and therefore .
Consequently, the maximum number of leaves that
a search tree for {\bf ids} can contain, given an input graph on 
vertices, is .
\end{proof}














\section{Conclusions and Open Questions}


In this paper we presented a non trivial algorithm solving
the \textsc{Minimum Independent Dominating Set} problem. Using a non standard measure on
the size of the considered graph, we proved that our algorithm achieves a running
time of . Moreover we showed that  is a lower bound on
the running time of this algorithm by exhibiting a family of graphs for which
our algorithm has a high running time.

A natural question here is: is it is possible to obtain a better upper bound on
the running time of the presented algorithm by considering another measure or
using other techniques. Or is it possible that this upper bound is tight?




\begin{thebibliography}{99}





\bibitem{Angelsmark05}Angelsmark,~O.
Constructing Algorithms for Constraint Satisfaction and Related Problems : Methods and Applications,
{\em PhD thesis\/}, {\em Link\"oping University, Sweden}, (2005).

\bibitem{BourgeoisSIROCCO2010}Bourgeois,~M., B.~Escoffier, and V.~Th.~Paschos,
Fast Algorithms for min independent dominating set,
{\em Proceedings of SIROCCO 2010\/}, {\em LNCS}
{\bf 6058}, (2010), pp.~247--261.

\bibitem{BourgeoisSWAT2010}Bourgeois,~M., B.~Escoffier, V.~Th.~Paschos and J.~M.~M.~van Rooij,
A Bottom-Up Method and Fast Algorithms for max independent set,
{\em Proceedings of SWAT 2010\/}, {\em LNCS}
{\bf 6139}, (2010), pp.~62--73.

\bibitem{Broersma}Broersma,~H., T.~Kloks, D.~Kratsch, and H.~M\"uller,
Independent sets in Asteroidal Triple-free graphs,
{\em SIAM Journal on Discrete Mathematics\/},
{\bf 12}, (1999), pp.~276--287.

\bibitem{Chang}Chang,~M.-S.,
Efficient algorithms for the domination problems on interval and circular-arc graphs,
{\em SIAM Journal on Computing\/},
{\bf 27}, (1998), pp.~1671--1694.

\bibitem{Corneil}Corneil,~D.-G. and Y.~Perl,
Clustering and domination in perfect graphs,
{\em Discrete Applied Mathematics\/},
{\bf 9}, (1984), pp.~27--39.


\bibitem{Dantsin}
Dantsin~E., A.~Goerdt, E.A.~Hirsch, R.~Kannan, J.M.~Kleinberg, C.H.~Papadimitriou,
P.~Raghavan, and U.~Sch√∂ning,
A deterministic (2-2/(k+1))n algorithm for k-SAT based on local search,
{\em Theoretical Computer Science\/},
{\bf 289}, (2002), pp.~69--83.

\bibitem{Damian}Damian-Iordache,~M. and S.~V.~Pemmaraju,
Hardness of Approximating Independent Domination in Circle Graphs,
{\em Proceedings of ISAAC 1999\/}, {\em LNCS}
{\bf 1741}, (1999), pp.~56--69.

\bibitem{Downey}Downey,~R.~G., Fellows,~M.~R., and McCartin,~C.,
Parameterized Approximation Problems,
{\em Proceedings of IWPEC 2006\/}, {\em LNCS\/}
{\bf 4169}, (2006), pp.~121--129.

\bibitem{Farber}Farber,~M.,
Independent domination in chordal graphs,
{\em Operation Research Letters\/},
{\bf 1}, (1982), pp.~134--138.

\bibitem{soda2006}Fomin,~F.~V., F.~Grandoni, and D.~Kratsch,
Measure and Conquer: A Simple  Independent Set Algorithm,
{\em Proceedings of SODA 2006\/}, (2006), pp.~18--25.

\bibitem{icalp2005}Fomin,~F.~V., F.~Grandoni, and D.~Kratsch,
Measure and conquer: Domination - A case study,
{\em Proceedings of ICALP 2005\/}, {\em LNCS\/}
{\bf 3380}, (2005), pp.~192--203.

\bibitem{SurveyFGK}Fomin,~F.~V., F.~Grandoni, and D.~Kratsch,
Some new techniques in design and analysis of exact (exponential) algorithms,
{\em Bulletin of the EATCS\/}, {\bf 87}, (2005), pp.~47--77.

\bibitem{AcmFGK}Fomin,~F.~V., F.~Grandoni, and D.~Kratsch,
A measure {\&} conquer approach for the analysis of exact algorithms,
{\em Journal of the ACM\/}, {\bf 56}, (2009).

 
\bibitem{WG2004}Fomin,~F.~V., D.~Kratsch, and G.~J.~Woeginger,
Exact (exponential) algorithms for the dominating set problem,
{\em Proceedings of WG 2004\/}, {\em LNCS\/}
{\bf 3353}, (2004), pp.~245--256.

\bibitem{GareyJ79}Garey,~M.~R. and D.~S.~Johnson,
{\em Computers and intractability. A guide to the theory
of NP-completeness}.
W.H. Freeman and Co., San Francisco, 1979.

\bibitem{Gaspers08}Gaspers,~S.,
Exponential Time Algorithms: Structures, Measures, and Bounds,
PhD thesis, University of Bergen, Norway, (2008).



\bibitem{WG2006}Gaspers,~S., and M.~Liedloff,
A Branch-and-Reduce Algorithm for Finding a Minimum Independent Dominating Set in Graphs,
{\em Proceedings of WG 2006\/}, {\em LNCS\/}
{\bf 4271}, (2006), pp.~78--89.

\bibitem{GaspersS09}Gaspers,~S., and G.~B. Sorkin,
A universally fastest algorithm for Max 2-Sat, Max 2-CSP, and everything in between,
{\em Proceedings of SODA 2009\/}, {\em SIAM\/}, (2009), pp.~606--615.

\bibitem{Grandoni}Grandoni,~F.,
A note on the complexity of minimum dominating set,
{\em Journal of Discrete Algorithms\/},
{\bf 4}, (2006), pp.~209--214.

\bibitem{Halldorsson}Halld\'orsson,~M.~M.,
Approximating the Minimum Maximal Independence Number,
{\em Information Processing Letters\/},
{\bf 46}, (1993), pp.~169--172.

\bibitem{Johnson}Johnson,~D.~S., M.~Yannakakis, and C.~H.~Papadimitriou,
On generating all maximal independent sets,
{\em Information Processing Letters\/},
{\bf 27}, (1988), pp.~119--123.

\bibitem{KneisFSTTCS2009}Kneis,~J., A.~Langer and P.~Rossmanith,
A Fine-grained Analysis of a Simple Independent Set Algorithm,
{\em Proceedings of FSTTCS 2009\/}, {\em LIPIcs\/}
{\bf 4}, (2009), pp.~287--298.

\bibitem{Kratsch}Kratsch,~D., and L.~Stewart,
Domination on Cocomparability Graphs,
{\em SIAM Journal on Discrete Mathematics\/},
{\bf 6}, (1993), pp.~400--417.

\bibitem{MillerM60} Miller,~R.~E., and D.~E.~Muller,
A problem of maximum consistent subsets,
{\em IBM Research Report},
{\bf RC-240}, J. T. Watson Research Center, Yorktown Heights, NY, 1960.

\bibitem{MoserS10} Moser,~R.~A., and D. Scheder,
A Full Derandomization of Schoening's k-SAT Algorithm,
{\em CoRR},
{abs/1008.4067},
available on http://arxiv.org.

\bibitem{MoonMoser}Moon,~J.~W., and L.~Moser,
On cliques in graphs,
{\em Israel Journal of Mathematics\/},
{\bf 3}, (1965), pp.~23--28.

\bibitem{Randerath}Randerath,~B., and I.~Schiermeyer,
Exact algorithms for Minimum Dominating Set,
Technical Report zaik-469, Zentrum fur Angewandte Informatik,
K\"oln, Germany, April 2004.

\bibitem{Robson}Robson,~J.~M.,
Algorithms for maximum independent sets,
{\em Journal of Algorithms}, {\bf 7}, (1986), pp.~425--440.

\bibitem{RobsonTR}Robson,~J.~M.,
Finding a maximum independent set in time ,
Technical Report 1251-01, LaBRI, Universit\'e Bordeaux I, 2001.



\bibitem{Tarjan}Tarjan,~R.~E., and A.~E.~Trojanowski,
Finding a maximum independent set,
{\em SIAM Journal on Computing\/},
{\bf 6}, (1977), pp.~537--546.

\bibitem{vanRooijSTACS2008}van Rooij,~J.~M.~M., and H.~L.~Bodlaender,
Design by Measure and Conquer, A Faster Exact Algorithm for Dominating Set,
{\em Proceedings of STACS 2008\/}, {\em LIPIcs\/}
{\bf 1}, (2008), pp.~657--668.

\bibitem{vanRooijESA2009}van Rooij,~J.~M.~M., J.~Nederlof, and T.~C.~van Dijk,
Inclusion/Exclusion Meets Measure and Conquer,
{\em Proceedings of ESA 2009\/}, {\em LNCS\/}
{\bf 5757}, (2009), pp.~554--565.


\bibitem{Woeginger}Woeginger,~G.~J.,
Exact algorithms for NP-hard problems: A survey,
{\em Combinatorial Optimization - Eureka, You Shrink!\/}, {\em LNCS\/}
{\bf 2570}, (2003), pp.~185--207.



\end{thebibliography}


\end{document}
