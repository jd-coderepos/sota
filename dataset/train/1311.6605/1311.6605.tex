\documentclass[]{llncs}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[english]{babel}
\usepackage{amsmath,amssymb,latexsym,eufrak,euscript}
\usepackage{subfigure,pstricks,pst-node,pst-coil}

\usepackage{url,tikz}


\usepackage{multicol} \usepackage{multirow} 

\usepackage{bigcenter} 

\definecolor{darkblue}{rgb}{0,0,.3}					\PassOptionsToPackage{bookmarksdepth=2}{hyperref}	\usepackage[pdftex, colorlinks=true, linkcolor=darkblue,anchorcolor=darkblue, citecolor=darkblue, filecolor=darkblue, menucolor=darkblue, runcolor=darkblue, urlcolor=darkblue]{hyperref}			

\usetikzlibrary{arrows,snakes,automata,shapes}


\newcommand{\mlabel}[1]{\label{#1}\marginpar{\fbox{#1}}}
\newcommand{\flsup}[1]{\stackrel{#1}{\longrightarrow}}

\newenvironment{algo}
{ \vspace{1em}
\begin{algor}\mbox
\newline \vspace{-0.1em}
\begin{quote}\begin{rm}} 
{\end{rm}\end{quote}\end{algor}\vspace{-1.5em}\vspace{2em}}


\newenvironment{exe}
{\begin{example}\rm } 
{\end{example}\vspace{-1.5em}
\null  \hfill  \par\medskip}




\renewenvironment{proof}
{ \noindent {\sc Proof.\/}  }
{\null  \hfill  \par\medskip \vspace{1em}}


\newcommand {\pb}[3] {
\medskip
\noindent
\fbox{
\parbox[c]{11.5cm}{
{\bf #1}

\noindent
{\bf Input:} #2

\noindent
{\bf Output:} #3

\medskip
}
}

\medskip
}


\def \top {1.8}
\def \topt {2.3}
\def \sp {\hspace*{0.8cm}}
\def \spt {\hspace*{0.3cm}}
\def \A {\mathcal{A}}
\def \T {\mathcal{T}}
\def \R {\mathcal{R}}
\def \B {\mathcal{B}}
\def \C {\mathcal{C}}
\def \D {\mathcal{D}}
\def \E {\mathcal{E}}
\def \N {\mathbb{N}}
\def \cost {{\rm cost}}
\def \ov {\overline}
\def \s {\preceq}

\def \Det {\mathbf{D}}
\def \ua {\mathbf{UA}}
\def \fa {\mathbf{FA}}
\def \wa {\mathbf{WA}}
\def \uw {\mathbf{UW}}

\def\gauche {\mathcal{R}_\mathrm{left}}
\def\droit {\mathcal{R}_\mathrm{right}}
\def\gd {\mathcal{R}_\mathrm{l+r}}
\def\In {\mathcal{R}_\mathrm{In}}
\def\Out {\mathcal{R}_\mathrm{Out}}
\def\IO {\mathcal{R}_\mathrm{In+Out}}

\newcommand{\Lg}[2]{#1^{Left,#2}}
\newcommand{\Ld}[2]{#1^{Right,#2}}

\newtheorem{cor}[theorem]{Corollary}






\begin{document}


\label{firstpage}


  \title{Enhancing Approximations for Regular Reachability Analysis} 

\author{Alo\"is Dreyfus \and Pierre-Cyrille H\'eam \and Olga Kouchnarenko} \institute{FEMTO-ST CNRS 6174, University of Franche-Comt\'e \& Inria/CASSIS, France\\
\email{firstname.name@femto-st.fr}
}
 
\maketitle
\begin{abstract}
  This paper introduces two
  mechanisms for computing over-approximations of sets of reachable states, 
  with the aim of ensuring termination of state-space exploration. 
  The first mechanism consists in over-approximating the automata
  representing reachable sets by merging some of their states 
  with respect to simple syntactic criteria, or a combination of such criteria. 
  The second approximation mechanism consists in manipulating 
  an auxiliary automaton when applying a transducer
  representing the transition relation to an automaton encoding the initial states.  
  In addition, for the second mechanism we propose
  a new approach to refine the approximations depending on a property of interest. 
  The proposals are evaluated on examples of mutual
  exclusion protocols.
\end{abstract}


\section{Introduction and Problem Statement}

Reachability analysis is a challenging issue in formal software verification. 
Since the reachability problem is in general undecidable in most
formalisms, several ad-hoc approaches have been developed, such as symbolic 
reachability analysis using finite representations of infinite sets of
states.  {\it Regular model checking} (RMC for short) -- a symbolic approach using regular sets to represent sets
of states -- tackles undecidability in either of two ways: pointing out classes of regulars sets and relations for which the
reachability problem is decidable (see for
instance~\cite{DBLP:conf/icalp/GomezGP08}), or developing semi-algorithmic and/or approximation-based
approaches (see for instance~\cite{dams_iterating_2001,dams_iterating_2002}) to
semi-decide the reachability problem.  

In this paper we present new approximation techniques for RMC,  with the aim of 
providing quite efficient (semi-)algorithms.  The first technique consists in over-approximating the automata
  representing reachable sets by merging some of their states with respect to simple syntactic criteria, or a combination of such criteria (Section~\ref{quotient-based-approximations}).  
The second approximation technique consists in using  an auxiliary automaton when applying a transducer
  representing the transition relation to an automaton encoding the initial states (Section~\ref{transducer-based-approximations}). Moreover, for the second technique we develop  a new approach to refine the approximations, close to 
the well-known CEGAR technique (Section~\ref{transducer-based-approximations-CEGAR}).  The proposals are evaluated on examples of mutual
  exclusion protocols (Section~\ref{sec:experimentations}).
Omitted proofs are available online\footnote{\url{http://disc.univ-fcomte.fr/~adreyfus/ciaa13/version_longue.pdf}}.


\paragraph*{Related Work.}\label{sec:relatedwork}
Regular model-checking remains an active research domain in
computer science (see \cite{clarke_model_2000} and
\cite{baier_principles_2008} for a thorough overview).
In~\cite{kesten_symbolic_1997} the authors propose to use regular sets of
strings to represent states of parametrized arrays of processes, and to
represent the effect of performing an action by a predicate transformer
(transducer). In this work only transducers representing the effect of a
single application of a transition are considered, and consequently the
reachability analysis does not terminate for a lot of protocols. To bypass
this problem and still reach a fixpoint, the principal methods are
acceleration (providing exact computations)
\cite{jonsson_transitive_2000,bouajjani_regular_2000,dams_iterating_2001,dams_iterating_2002,abdulla_algorithmic_2003,boigelot_iterating_2003},
widening (extrapolating)
\cite{bouajjani_regular_2000,touili_regular_2001,legay_extrapolating_2012},
and automata abstraction \cite{bouajjani_abstract_2004}. Recently, new
results in RMC have been obtained for specific protocols (i.e.,
CLP~\cite{fioravanti_program_2011}, communicating
systems~\cite{Abstract_interpretation_of_FIFO_channels}, tree
language~\cite{abdulla_regular_tree_2002,bouajjani_widening_2011}, or
relational string verification using multi-track
automata~\cite{yu_relational_2011}), using domain-specific
techniques~\cite{boigelot_domain-specific_2012}. Our contributions aim at 
improving the generic method in~\cite{bouajjani_abstract_2004} by giving means
to build over-approximations by merging abstract states of the system
(and not of the transducer, which is never modified).
Unlike~\cite{bouajjani_regular_2000,bouajjani_abstract_2004}, our proposals 
do not require the subset-construction, minimization and 
determinization of the obtained automaton at each RMC step. 

\paragraph*{Formal Background.}
We assume the reader familiar with basic notions of language theory.
An {\it automaton}  on an alphabet  is a tuple
 where  is the finite set of {\it states},  is the set of {\it transitions},  is
the set of {\it initial states} and  is the set of {\it final
  states}. We define the size of  by . An automaton is
{\it deterministic} [resp. {\it complete}] if  is a singleton and for
each  there is at most [resp. at least] one  such that . A path in  is a (possibly empty) finite
sequence of transitions  such that for
each , . The integer  is the length of the path and the
word  is its label. A path is {\it successful} if  is
initial and  is final. A word  is {\it accepted} by  if  is
the label of a successful path. The set of words accepted by  is denoted
. If  is deterministic and complete, for every state  and
every word , there exists a unique state of , denoted 
reachable from  by reading a path labeled by . If there is no
ambiguity on , it is simply denoted . By convention, . A state  is {\it accessible} [resp. {\it
    co-accessible}] if there exists a path from an initial state to 
                 [resp. if there exists a path from  to a final state].
                 An automaton whose states are all both accessible and
                 co-accessible is called {\it trim}. If  is not a trim
                 automaton, removing from  all states that are not both
                 accessible and co-accessible together with all related
                 transitions provides an equivalent trim automaton. Let
                  and
                  be two automata over the
                 same alphabet, the product of  and  is the
                 automaton , denoted , where
                 . By definition, . Let
                 
                 be the trim automaton obtained from , given an
                 equivalence relation ,
                  denotes the automaton
                  where
                 . One can easily check
                 that . For instance,
                 given the automata of Fig.~\ref{fig:def} and the
                 relation  whose classes are  and , the automaton
                  is depicted on
                 Fig.~\ref{fig:def}. Two automata
                  and
                  are isomorphic if
                 there exists a one-to-one function  satisfying  iff
                 , and , 
                 when lifted to sets. Informally, two automata are
                 isomorphic if they are equal up to state names.












Let  and  be two alphabets, a {\it
  transducer} on  is an automaton on
. Each transducer  on 
induces a relation  on  defined by:
for the 's in  and the 's in ,  
 iff  and the word
 is accepted by .
The reflexive transitive closure of  is denoted .
Let  be an automaton on , and 
 a transducer on
, we denote by  the automaton  on  where
  . 
An example is depicted on Fig.~\ref{fig:def}.
By definition,  is the set of words
 satisfying  for some words . 
If  is a transducer, we denote
by  the transducer 
with . One can check that
 iff .

\begin{figure}[tb]
\centering
\begin{minipage}{0.3\textwidth}
\centering
 \subfigure[]{
 \begin{tikzpicture}[scale=0.6, every node/.style={scale=0.9}]
 \node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
 \node (2)[state,draw,fill=blue!20,initial, initial text=,accepting,] at (3,0)
       {};
 \path[->,>=triangle 90] (1) edge[out=45] node [above] {} (2);
 \path[->,>=triangle 90] (1) edge[loop left] node [above] {} ();
 \path[->,>=triangle 90] (2) edge[loop right] node [above] {} ();
 \end{tikzpicture}
 }
\subfigure[]{
\begin{tikzpicture}[scale=0.6, every node/.style={scale=0.9}]
\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
\node (2)[state,draw,fill=blue!20,accepting,] at (3,0)
      {};
\path[->,>=triangle 90] (1) edge[out=45] node [above] {} (2);
\path[->,>=triangle 90] (1) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (2) edge[out=-125,in=-45] node [above] {} (1);
\path[->,>=triangle 90] (2) edge[loop above] node [above] {} ();
\end{tikzpicture}
}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\centering
\subfigure[]{
\begin{tikzpicture}[scale=0.7]
\node (14)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
\node (24)[state,draw,fill=blue!20,initial, initial text=] at (3,0)
      {};
\node (13)[state,draw,fill=blue!20] at (0,-3) {};
\node (23)[state,draw,fill=blue!20,accepting,] at (3,-3) {};
\path[->,>=triangle 90] (14) edge[] node [above] {} (23);
\path[->,>=triangle 90] (14) edge[] node [left] {} (13);
\path[->,>=triangle 90] (23) edge[] node [left] {} (24);
\path[->,>=triangle 90] (13) edge[] node [below] {} (23);
\path[->,>=triangle 90] (13) edge[out=45,in=-60] node [right] {} (14);

\path[->,>=triangle 90] (14) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (24) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (13) edge[loop left] node [] {} ();
\end{tikzpicture}
}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\centering
\subfigure[]{
\begin{tikzpicture}[scale=0.7]
\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
\node (2)[state,draw,fill=blue!20,accepting] at (3,0) {2,3};
\path[->,>=triangle 90] (1) edge[out=45] node [above] {} (2);
\path[->,>=triangle 90] (2) edge[out=225,in=-45] node [above] {} (1);
\path[->,>=triangle 90] (1) edge[loop above] node [above] {} ();
\end{tikzpicture}
}
\end{minipage}
\vspace{-1em}
\caption{Illustrating examples}\label{fig:def}
\end{figure}


\paragraph*{Regular Reachability Problem.}
The following regular reachability problem -- central for RMC -- is known to be undecidable in general; its variants have
been addressed in most of the papers in Sect.~\ref{sec:relatedwork}. \smallskip

\noindent
{\bf Input:} Two finite automata  and  on a same alphabet , 
and a transducer  on .\\
{\bf Output:} {\bf 1} if , and {\bf 0}
otherwise. 
\smallskip

 


Since the problem is concerned with the reflexive-transitive closure, we may
assume without loss of generality that for every ,
. In the rest of the paper, all considered relations contain the
identity.




\section{Quotient-based Approximations}
\label{quotient-based-approximations}

This section introduces the first mechanism for computing
over-approximations of sets of reachable states, which consists in
over-approximating the automata representing reachable sets by merging
some of their states. For doing this, basic elementary policies as
well as their combinations are introduced.
  
Given an automaton , we define an {\it approximation} as a
function mapping each automaton  to an equivalence relation
 over the states of . The approximation function
 is {\it isomorphism-compatible} if for every pair of
automata  and , every isomorphism  from  to ,
 iff . We denote
 the automaton ,
where  is the trim automaton obtained from . We
inductively define  by , and
 for .



Let us now introduce two isomorphism-compatible approximation
functions. They are easily computable, and represent simple criteria
naturally used by the specifier, as for example 
in~\cite{bouajjani_abstract_2004} for computing equivalence relations, or 
in~\cite{DBLP:conf/fm/BauerF12} for monitoring LTL properties.
\begin{itemize}
\item , mapping each automaton  to the reflexive-transitive \linebreak[4]
closure of the relation ,
  defined by   iff .

\item , mapping each automaton  to the
  reflexive-transitive closure of the relation , defined by
   iff .




\end{itemize}

Let us consider the example of the token ring protocol for which the
automata are depicted on Fig.~\ref{fig:tr1}. Let  be the
automaton obtained by trimming . The relation  is the identity
relation, therefore . However, for the relation , the states
 and  are equivalent since they can be reached from the
initial state by reading . The automaton  is depicted on Fig.~\ref{fig:tr-Ta} (up).

\begin{figure}[tb]
\subfigure[ (down) and  (up)]{\label{fig:tr-Ta}
\begin{tikzpicture}[scale=0.7]

\node (1a)[state,draw,fill=blue!20,initial, initial text=] at (0,2) {1};
\node (2a)[state,draw,fill=blue!20,accepting] at (3,2)
      {2};

\path[->,>=triangle 90] (1a) edge[] node [above] {} (2a);
\path[->,>=triangle 90] (1a) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (2a) edge[loop above] node [above] {} ();


\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {1};
\node (2)[state,draw,fill=blue!20,accepting] at (3,0)
      {2};

\path[->,>=triangle 90] (1) edge[] node [above] {} (2);
\path[->,>=triangle 90] (1) edge[loop left] node [above] {} ();
\end{tikzpicture}
}
\subfigure[]{\label{fig:tr-T}
\begin{tikzpicture}[scale=0.7]
\node (1)[state,draw,fill=blue!20,initial, initial text=,accepting] at (0,0) {};
\node (2)[state,draw,fill=blue!20] at (3,0)
      {};

\path[->,>=triangle 90] (1) edge[out=45] node [below] {} (2);
\path[->,>=triangle 90] (1) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (2) edge[out=-125,in=-45] node [above] {} (1);

\end{tikzpicture}
}
\subfigure[= after trimming]{
\begin{tikzpicture}[scale=0.7]
\node (14)[state,draw,fill=blue!20] at (0,0) {};

\node (13)[state,draw,fill=blue!20,initial, initial text=] at (0,-3) {};
\node (23)[state,draw,fill=blue!20,accepting,] at (3,-3)
      {};

\path[->,>=triangle 90] (14) edge[] node [left] {} (23);
\path[->,>=triangle 90] (13) edge[] node [left] {} (14);
\path[->,>=triangle 90] (13) edge[] node [below] {} (23);

\path[->,>=triangle 90] (13) edge[loop left] node [] {} ();
\end{tikzpicture}
}

\caption{Token ring}\label{fig:tr1}
\end{figure}




\begin{proposition}\label{prop-iso}
  For each automaton , if  is an isomorphism-compatible approximation function, then the sequence
   is ultimately constant, up to
  isomorphism. Let  denote the limit of
  . Moreover, if for each automaton
   and each pair of states  of , one can check in
  polynomial time whether , then  can
  be computed in polynomial time as well.
\end{proposition}





\begin{figure}[tb]
\subfigure[]{\label{fig:approx-A}
\begin{tikzpicture}[scale=0.7]
\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,1) {};

\node (2)[state,draw,fill=blue!20,] at (2,1) {};

\node (3)[state,draw,fill=blue!20,accepting] at (4,1) {};

\node (4)[state,draw,fill=blue!20,] at (0,-1) {};

\node (5)[state,draw,fill=blue!20,] at (2,-1) {};

\node (6)[state,draw,fill=blue!20] at (4,-1) {};

\path[->,>=triangle 90] (1) edge[] node [above] {} (2);
\path[->,>=triangle 90] (1) edge[] node [right] {} (4);

\path[->,>=triangle 90] (2) edge[] node [above] {} (3);
\path[->,>=triangle 90] (2) edge[] node [right] {} (6);

\path[->,>=triangle 90] (4) edge[] node [above] {} (5);

\path[->,>=triangle 90] (5) edge[] node [above] {} (6);

\path[->,>=triangle 90] (6) edge[] node [right] {} (3);

\end{tikzpicture}
}
\subfigure[]{\label{fig:approx-Right-A}
\begin{tikzpicture}[scale=0.7]
\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,1) {};

\node (3)[state,draw,fill=blue!20,accepting] at (2,1) {};

\node (4)[state,draw,fill=blue!20,] at (0,-1) {};

\node (256)[state,draw,fill=blue!20,] at (2,-1) {};

\path[->,>=triangle 90] (1) edge[] node [above] {} (256);
\path[->,>=triangle 90] (1) edge[] node [right] {} (4);

\path[->,>=triangle 90] (256) edge[] node [right] {} (3);
\path[->,>=triangle 90] (256) edge[loop right] node [right] {} ();

\path[->,>=triangle 90] (4) edge[] node [above] {} (256);

\end{tikzpicture}
}
\subfigure[{\tiny =}]{\label{fig:approx-Right2-A}
\begin{tikzpicture}[scale=0.7]
\node (1)[state,draw,fill=blue!20,initial, initial text=] at (0,1) {};

\node (3)[state,draw,fill=blue!20,accepting] at (2,1) {};

\node (2456)[state,draw,fill=blue!20,] at (1,-1) {};

\path[->,>=triangle 90] (1) edge[] node [above] {} (2456);

\path[->,>=triangle 90] (2456) edge[] node [right] {} (3);
\path[->,>=triangle 90] (2456) edge[loop right] node [right] {} ();

\end{tikzpicture}
}
\caption{Computing }\label{fig:approx}
\end{figure}

\begin{figure}[tb]
\subfigure[{\tt FixPoint}]{\label{algo:fp}
\begin{tabular}{l}
{\bf Semi-Algorithm} {\tt FixPoint}\\
{\bf Input:} , , , \\
\sp {\bf If}  {\bf then}\\
\sp\sp {\bf return} {\it Inconclusive}\\
\sp {\bf EndIf}\\
\sp {\bf If}   {\bf then}\\
\sp\sp {\bf return} {\it Safe}\\
\sp {\bf EndIf}\\
\sp {\bf Return} {\tt FixPoint}(,,)\\
 \\
\\
\\
\end{tabular}
}\subfigure[{\tt FixPointT}]{\label{algo:fpT}
\begin{tabular}{l}
{\bf Semi-Algorithm} {\tt FixPointT}\\
{\bf Input:} , , , \\
{\bf Variable:} \\
\sp k:=0\\
\sp {\bf While} () {\bf do}\\
\sp\sp \\
\sp {\bf EndWhile}\\
\sp {\bf If} () {\bf then}\\
\sp\sp {\bf Return} {\it Safe}\\
\sp {\bf Else}\\
\sp\sp {\bf Return} {\it Inconclusive}\\
\sp {\bf EndIfElse}
\end{tabular}
}
\caption{Fixpoint algorithms}\label{algo:master}
\end{figure}

In the {\tt FixPoint} algorithm depicted in Fig. \ref{algo:fp},
given a finite automaton  (state of the system), a transducer  (transition relation), a finite automaton  (bad property), and an isomorphism-compatible function  (approximation criterion), the first check (emptiness) can be performed in polynomial time. Then, unfortunately, the equality of the languages cannot
be checked in polynomial time, since the involved automata are not
deterministic. Nevertheless, recently developed
algorithms~\cite{DBLP:conf/tacas/DoyenR10,DBLP:conf/tacas/AbdullaCHMV10,BONCHI-2012-674660}
allow solving this problem very efficiently. Note also that the
equality test can be replaced by another test -- e.g., isomorphism or
(bi)simulation -- implying language equality or inclusion, as
) by construction.

\begin{proposition}\label{prop-fixed}
The {\tt FixPoint}  semi-algorithm is correct: if it returns {\em Safe}, then .
\end{proposition}
 





The approach can be illustrated on the example in Fig.~\ref{fig:tr1} with
:  One can check that
  and  are isomorphic. Therefore {\tt FixPoint} stops after one
recursive call and returns {\it Safe}.



From now on, given two approximation functions  and
, we denote  the
approximation function defined by
 for every automaton . In addition, the
approximation function  is defined by: for
every automaton ,  is the
smallest equivalence relation containing both  and
. Then using several approximation functions and
combining them allow us to obtain new -- stronger or weaker --
approximations. Section~\ref{sec:experimentations}
gives experimental results for the ,  approximations together with the  and  approximations, and for their combinations. 




\section{Transducer-based Approximations}
\label{transducer-based-approximations}

This section introduces another approximation mechanism consisting in
reasoning about the application of  copies of a transducer
representing the transition relation to an automaton representing the initial states.  The states reached in the transducers are encoded as a finite word, and an additional automaton is used for specifying
what are the combinations of transducer states that have to be
merged. This technique is inspired by an automata theoretic construction in~\cite{bouajjani_regular_2000}, 
with the difference concerning the equivalence relation, and the use of automata at step  (the transducer is never modified).  


Let  be a finite automaton,
 a transducer, and 
 a deterministic complete finite
automaton on  (i.e., the transitions of  are labeled with states of
).
Let  be a one-to-one mapping from the set
 of states of  to
, where  is the set of words of length  on . We
set a relation  on states of  as follows: if  and 
are states of  such that  and
, then  iff  and . The automaton 
is denoted  One can easily check that  is an
equivalence relation.

Let us consider again  and  from
Fig.~\ref{fig:tr1}. We consider the automaton  depicted in
Fig.~\ref{fig:tr2-a}. The automaton  (after trimming) is depicted in Fig.~\ref{fig:tr2-b}. The
automata  and
 are depicted in
Fig.~\ref{fig:tr3}. For instance, in  states  and  are -equivalent since
they have both  as the first element, and .

\begin{figure}[tb]
\subfigure[]{\label{fig:tr2-a}
\begin{tikzpicture}[scale=0.7]
\node (init)[state,draw,fill=blue!20,initial, initial text=] at (0,0)
      {};
\node (rond)[state,draw,fill=blue!20,] at (2,1)
      {};

\node (carre)[state,draw,fill=blue!20,] at (2,-1)
      {};

\node (nabla)[state,draw,fill=blue!20,] at (4,0)
      {};

\path[->,>=triangle 90] (init) edge[] node [above] {} (rond);
\path[->,>=triangle 90] (init) edge[bend left] node [above] {} (carre);
\path[->,>=triangle 90] (carre) edge[bend left] node [above] {} (init);
\path[->,>=triangle 90] (rond) edge[] node [above] {} (nabla);
\path[->,>=triangle 90] (carre) edge[] node [above] {} (nabla);
\path[->,>=triangle 90] (nabla) edge[loop above] node [above] {} ();
\end{tikzpicture}
}\subfigure[]{\label{fig:tr2-b}
\begin{tikzpicture}[scale=0.7]
\node (133)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};

\node (233)[state,draw,fill=blue!20,accepting] at (3,0) {};

\node (134)[state,draw,fill=blue!20,] at (6,1) {};

\node (143)[state,draw,fill=blue!20,] at (6,-1) {};

\path[->,>=triangle 90] (133) edge[loop above] node [right] {} ();
\path[->,>=triangle 90] (133) edge[bend left] node [above] {} (134);
\path[->,>=triangle 90] (133) edge[bend right] node [above] {} (143);
\path[->,>=triangle 90] (133) edge[] node [above] {} (233);

\path[->,>=triangle 90] (134) edge[] node [above] {} (233);
\path[->,>=triangle 90] (134) edge[] node [left] {} (143);

\path[->,>=triangle 90] (143) edge[] node [above] {} (233);
\end{tikzpicture}
}
\caption{Token ring: Transducer-based approximation (1)}\label{fig:tr2}
\end{figure}


\begin{figure}[tb]
\subfigure[]{\label{fig:tr3-a}
\begin{tikzpicture}[scale=0.7]
\node (14)[state,draw,fill=blue!20] at (0,-1) {};

\node (13)[state,draw,fill=blue!20,initial, initial text=] at (0,-3) {};
\node (23)[state,draw,fill=blue!20,accepting,] at (3,-3)
      {};

\path[->,>=triangle 90] (14) edge[] node [left] {} (23);
\path[->,>=triangle 90] (13) edge[] node [left] {} (14);
\path[->,>=triangle 90] (13) edge[] node [below] {} (23);

\path[->,>=triangle 90] (13) edge[loop left] node [] {} ();
\end{tikzpicture}
}\subfigure[]{\label{fig:tr3-b}
\begin{tikzpicture}[scale=0.7]
\node (133)[state,draw,fill=blue!20,initial, initial text=] at (0,-1)
      {};


\node (233)[state,draw,fill=blue!20,accepting] at (2,1)
      {};

\node (134)[state,draw,fill=blue!20,] at (4,-1)
      {};


\path[->,>=triangle 90] (133) edge[loop left] node [left] {} ();
\path[->,>=triangle 90] (134) edge[loop right] node [right] {} ();
\path[->,>=triangle 90] (133) edge[] node [above] {} (134);
\path[->,>=triangle 90] (133) edge[] node [below] {} (233);
\path[->,>=triangle 90] (134) edge[] node [left] {} (233);
\end{tikzpicture}
}
\caption{Token ring: Transducer-based approximation (2)}\label{fig:tr3}
\end{figure}

\begin{proposition}\label{prop-main}
An automaton isomorphic to  can be computed in
polynomial time in  and in the sizes of ,  and .
\end{proposition}  






















Now, given a finite automaton , we can use the computed automata
when applying the {\tt FixPointT} semi-algorithm described in
Fig.~\ref{algo:fpT}. It may provide an over-approximation of reachable
states: if {\tt FixPointT} stops on a not too coarse approximation we
can deduce that \hbox{}. The proof
of Proposition~\ref{prop-FixedPointT} is similar to this of
Proposition~\ref{prop-fixed}.



\begin{proposition}\label{prop-FixedPointT}
The {\tt FixPointT} semi-algorithm  is correct: if it returns {\it safe}
then .
\end{proposition}

\section{Refining Transducer-based Approximations}
\label{transducer-based-approximations-CEGAR}

In this section we propose to refine transducer-based approximations when the approximate iteration is inconclusive. 
Intuitively, this happens when the sequence of approximations is too coarse: the result intersects with the set of bad states after  steps while the backward iteration of  copies of the transducer from the bad states does not intersect with the initial states.
Our algorithm can be seen as a kind of CEGAR algorithms -- the paradigm introduced in~\cite{DBLP:conf/cav/ClarkeGJLV00} and intensively studied during the last decade (see for
example~\cite{bouajjani_abstract_2004,DBLP:conf/rta/BoichutCHK08}), with the aim of obtaining finer approximations/abstractions by exploiting counter-examples.


\begin{proposition}\label{prop-raff1}
If , then either , or there exists ,  such that
 and .
\end{proposition}


\begin{figure}[tb]
\centering{
\begin{tikzpicture}[scale=0.9]

\node (A0text) at (-0.7,1.2) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=2cm, fill=blue!20] (A0) at (0,0){};
\path (A0text) edge node {} (A0);


\node (A1text) at (1.3,1.5) {{\footnotesize }};
\node (A1etext) at (1.3,-1.4) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=2.4cm, fill=blue!20] (A1) at (2,0){};
\node[draw, ellipse, text width=0.5cm, minimum height=2.1cm,fill=blue!10] (A1e) at (2,0){};
\path (A1text) edge node {} (A1);
\path (A1etext) edge node {} (A1e);

\node (Aktext) at (4.3,1.7) {{\footnotesize }};
\node (Aketext) at (3.7,-.6) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=2.6cm, fill=blue!20] (Ak) at (5,0){};
\node[draw, ellipse, text width=0.5cm, minimum height=2.1cm,fill=blue!10] (Ake) at (5,0){};
\path (Aktext) edge node {} (Ak);
\path (Aketext) edge node {} (Ake);

\node (Ak+text) at (6.3,1.8) {{\footnotesize }};
\node (Ak+etext) at (7.7,1.8) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=2.8cm, fill=blue!20] (Ak+) at (7,0){};
\node[draw, ellipse, text width=0.5cm, minimum height=2.4cm,fill=blue!10] (Ak+e) at (7,0){};
\path (Ak+text) edge node {} (Ak+);
\path (Ak+etext) edge node {} (Ak+e);



\node (Aitext) at (9.3,1.8) {{\footnotesize }};
\node (Aietext) at (8.5,-.8) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=3cm, fill=blue!20] (Ai) at (10,0){};
\node[draw, ellipse, text width=0.5cm, minimum height=2.7cm,fill=blue!10] (Aie) at (10,0){};
\path (Aitext) edge node {} (Ai);
\path (Aietext) edge node {} (Aie);


\node (Ai+text) at (11,1.4) {{\footnotesize }};
\node (Ai+etext) at (11.3,2) {{\footnotesize }};
\node[draw, ellipse, text width=0.7cm, minimum height=3.2cm, fill=blue!20] (Ai+) at (12,0){};
\node[draw, ellipse, text width=0.5cm, minimum height=2.9cm,fill=blue!10] (Ai+e) at (12,0){};
\path (Ai+text) edge node {} (Ai+);
\path (Ai+etext) edge node {} (Ai+e);



\path[->,>=triangle 60] (A0) edge[above,bend left] node
    {} (A1);
\path[->,>=triangle 60] (A1) edge[above,bend left,dashed] node
    {} (Ak);
\path[->,>=triangle 60] (Ak) edge[above,bend left] node
    {} (Ak+);
\path[->,>=triangle 60] (Ai) edge[above,bend left] node
    {} (Ai+);

\path[->,>=triangle 60] (Ak+) edge[above,bend left,dashed] node
    {} (Ai);

\node (Aproptext) at (11.8,-3.3) {{\footnotesize }};
\node[draw, ellipse, text width=0.5cm, minimum height=1.2cm, fill=red!20, opacity=0.8] (Aprop) at (12,-2){};
\path (Aproptext) edge node {} (Aprop);


\node (A1proptext) at (8.8,-3.3) {{\footnotesize }};
\node[draw, ellipse, text width=0.5cm, minimum height=1.4cm, fill=red!20, opacity=0.8] (A1prop) at (10,-2){};
\path (A1proptext) edge node {} (A1prop);

\node (Ai+proptext) at (5.8,-3.3) {{\footnotesize }};
\node[draw, ellipse, text width=0.5cm, minimum height=1.6cm, fill=red!20, opacity=0.8] (Ai+prop) at (7,-2){};
\path (Ai+proptext) edge node {} (Ai+prop);


\node (Aiproptext) at (3,-2.8) {{\footnotesize }};
\node[draw, ellipse, text width=0.5cm, minimum height=1.8cm, fill=red!20, opacity=0.8] (Aiprop) at (4.4,-2){};
\path (Aiproptext) edge node {} (Aiprop);




\path[->,>=triangle 60] (Aprop) edge[above,bend right] node
    {} (A1prop);

\path[->,>=triangle 60] (A1prop) edge[above,bend right,dashed] node
    {} (Ai+prop);

\end{tikzpicture}
}
\caption{Refinement: 's represent the languages 
's.}\label{fig-raffinement}
\end{figure}







Assume that  and
. As it is
classically done in the CEGAR framework, one can compute a relation
 on  such that  and . The existence of  is trivial since
the results hold for the identity relation.  However, when using the
CEGAR approach, our goal is to compute a relation  as large as
possible, with the aim of ensuring termination of state-space exploration. 



To achieve this goal, several heuristics may be used.  Instead of
computing the  relation, building the corresponding
 automaton, and then performing the fixpoint
computation, we propose to use a dynamic approach.  More precisely, we
prefer to modify  according to  to avoid similar states
merging which may lead to a coarser over-approximation. To modify 
according to , we propose to use the algorithms in
Figs.~\ref{algo:raff} and~\ref{algo:raff2}. The {\tt Split} algorithm
modifies the given deterministic automaton to provide a weaker
abstraction.  Its idea is quite natural: if two equivalent states must
be distinguished, the automaton  is refined to take this
constraint into account.  For example, Figure~\ref{fig:split-a}
displays the automaton  resulting from
, where  is the automaton
from Fig.~\ref{fig:tr2-a}. The {\tt Split} algorithm dissociating two states, can be used so far
as necessary to obtain the refined approximation in the {\tt Refine}
algorithm in Fig.~\ref{algo:raff2}.


\begin{figure}[tb]
{\bf Algorithm} {\tt Split}\\
{\bf Input:}  a deterministic automaton,  and  such that \\
\spt  where \\
\spt \\
\spt \\
\spt \\
\spt \\
\spt {\bf Return} 
\caption{Algorithm {\tt Split}}\label{algo:raff}
\end{figure}


\begin{figure}[tb]
\subfigure[]{\label{fig:split-a}
\begin{tikzpicture}[scale=0.7]
\node (init)[state,draw,fill=blue!20,initial, initial text=] at (0,0)
      {};
\node (rond)[state,draw,fill=blue!20,] at (2,1)
      {};

\node (carre)[state,draw,fill=blue!20,] at (2,-1)
      {};

\node (nabla)[state,draw,fill=blue!20,] at (4,1)
      {};
\node (r2)[state,draw,fill=blue!20,] at (4,-1)
      {};

\path[->,>=triangle 90] (init) edge[] node [above] {} (rond);
\path[->,>=triangle 90] (init) edge[bend left] node [above] {} (carre);
\path[->,>=triangle 90] (carre) edge[bend left] node [above] {} (init);
\path[->,>=triangle 90] (rond) edge[] node [above] {} (nabla);
\path[->,>=triangle 90] (carre) edge[] node [above] {} (r2);
\path[->,>=triangle 90] (nabla) edge[loop above] node [above] {} ();
\path[->,>=triangle 90] (r2) edge[loop right] node [above] {} ();
\end{tikzpicture}
}\subfigure[]{\label{fig:split-b}
\begin{tikzpicture}[scale=0.7]
\node (133)[state,draw,fill=blue!20,initial, initial text=] at (0,-1)
      {};
\node (143)[state,draw,fill=blue!20,] at (-2,1)
      {};

\node (233)[state,draw,fill=blue!20,accepting] at (2,1)
      {};

\node (134)[state,draw,fill=blue!20,] at (4,-1)
      {};



\path[->,>=triangle 90] (133) edge[loop left] node [above] {} ();
\path[->,>=triangle 90] (133) edge[] node [left] {} (143);
\path[->,>=triangle 90] (133) edge[] node [above] {} (134);
\path[->,>=triangle 90] (133) edge[] node [below] {} (233);
\path[->,>=triangle 90] (143) edge[] node [above] {} (233);
\path[->,>=triangle 90] (134) edge[] node [left] {} (233);
\path[->,>=triangle 90] (134) edge[] node [left] {} (143);
\path[->,>=triangle 90] (143) edge[] node [above] {} (233);
\end{tikzpicture}
}
\caption{Examples for the {\tt Split} and {\tt Refine} algorithms}\label{fig:split}
\end{figure}



\begin{figure}[tb]
{\bf Algorithm} {\tt Refine}\\
{\bf Input:}  (transducer),  a deterministic automaton,
 a finite automaton, a relation 
such that  and 
\\
\sp {\bf While} () {\bf do}\\
\sp\sp {\bf Choose}  {\bf and} 
states of  {\bf such that}\\
\sp\sp\sp but
 \\
\sp\sp {\tt Split} \\
\sp {\bf EndWhile}\\ 
\sp {\bf Return} 
\caption{Algorithm {\tt Refine}}\label{algo:raff2}
\end{figure}

\begin{proposition}\label{prop-refine}
  The  {\tt Refine} algorithm always terminates.
\end{proposition}




























For example, let us consider the  relation whose classes are
, , 
and .  We apply the {\tt
  Refine} algorithm to the automata 
(Fig.~\ref{fig:tr-T}),  (Fig.~\ref{fig:tr2-a}),  (Fig.~\ref{fig:tr3-a}).  Since
, . Therefore, the algorithm may compute
 as depicted in
Fig.~\ref{fig:split-a}. Then one can check that
. The automaton  is depicted in
Fig.~\ref{fig:split-b}.




\begin{figure}[tb]
{\bf Semi-Algorithm} {\tt Reach-CEGAR}\\
{\bf Input:}   finite automata,  (transducer),  a
deterministic automaton, an integer~\\
{\bf Variables:} integers , and equivalence relation \\
\sp \\
\sp {\bf While} ( {\bf and}
 ) {\bf do}\\
\sp\sp \\
\sp {\bf EndWhile}\\
\sp {\bf If} ( {\bf and}  ) {\bf then}\\
\sp\sp {\bf Return} {\it Safe}\\
\sp {\bf EndIf}\\
\sp {\bf If}   {\bf then}\\
\sp\sp {\bf Return} {\it Unsafe}\\
\sp{\bf EndIf}\\
\sp \\
\sp {\bf Let}  be such that  and 
\\
\sp {\bf Return}  {\tt Reach-CEGAR}
\caption{Semi-algorithm {\tt Reach-CEGAR}}\label{algo:cegar}
\end{figure}

If  and , then we denote by
 the maximal integer  such that  and  and
. Now, the {\tt
  Reach-CEGAR} semi-algorithm in Fig.~\ref{algo:cegar}
encodes the whole approach: each time a too strong approximation is
detected, it is refined. This semi-algorithm may terminate by
returning {\it Safe} if an over-approximation of accessible states
that does not contain any bad states. It may also
terminate by returning {\it Unsafe} if it detects a reachable bad state. 
It may also diverge if the computed approximations have to
be refined again and again.





\section{Experimental Results}\label{sec:experimentations}

Thanks to a prototype tool, the present paper's proposals have been evaluated on the
well-known examples of the
Bakery algorithm by Lamport, the token ring algorithm, Dijkstra's, and
Burns~\cite{touili_regular_2001} protocols.



For the quotient-based approximations
(Sect.~\ref{quotient-based-approximations}), the results are displayed in
Fig.~\ref{tableau_resultats_master}. 
In addition to  and , 
two additional simple isomorphism-compatible approximations are examined: \\
\noindent -- , mapping each automaton  to the
   reflexive-transitive closure of the relation , defined by  iff
 ; and \\
\noindent -- , mapping each automaton  to the
   reflexive-transitive closure of the relation , defined by  iff
 .\\
In Fig.~\ref{tableau_resultats_master}, the first column describes
 the protocol to verify: its name, the size (i.e., ) of the
 initial automaton, and that of the transducer. The remaining columns give the results for each specific criterion:
the first line gives the step of the language equality, or No when not reached;
the second line indicates the step when the intersection with the bad-property language is non empty, or  if it remains empty;
the third line gives the size of the last obtained automaton.
If a step of the languages equality occurs while having the empty intersection with the bad-property language (cf. values highlighted in bold), the protocol is safe.




For the refinement method, the above mentioned protocols have been studied using
different kinds of -automata: either a {\it one-state} , or a
{\it specific} .  When starting the refinement with a one-state
 in Fig.~\ref{fig:one-state-b}, all the states are obviously
considered as -equivalent. On the contrary, a specific  models
a property of interest. For example, if two consecutive  are
forbidden, and there is a transition  in the
transducer of the considered protocol, then the
specific  is like in Fig.~\ref{fig:specific-B}.  The two token
ring protocols are shown to be safe  in four
steps using the refinement approach with a one-state automaton. Dijkstra's protocol was proved
safe without refinement in 15 steps using a specific automaton. The
Bakery and Burns protocols are proved safe  in respectively 6 and 14 steps, by 
using the refinement and specific automata. For all these
protocols, the obtained automata have sizes similar to the sizes of
the input automata: there is no state explosion. To conclude, the experiments show that our techniques work for all the
considered cases,  and that they are complementary. 



\begin{figure}[tb]
\hfill
\subfigure[one-state ]{\label{fig:one-state-b}
\begin{tikzpicture}[scale=0.7]
\node (i)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
\path[->,>=triangle 90] (i) edge[loop above] node [above] {} ();
\end{tikzpicture}
}\hfill
\subfigure[specific  for mutual exclusion protocols]{\label{fig:specific-B}
\begin{tikzpicture}[scale=0.7]
\node (i)[state,draw,fill=blue!20,initial, initial text=] at (0,0) {};
\node (bp)[state,draw,fill=blue!20] at (3,0.9) {};
\node (bq)[state,draw,fill=blue!20] at (3,-0.9) {};
\path[->,>=triangle 90] (i) edge[out=45] node [below] {} (bp);
\path[->,>=triangle 90] (i) edge[out=-45, in=225] node [above] {} (bq);
\path[->,>=triangle 90] (i) edge[loop above] node [above] {} ();

\path[->,>=triangle 90] (bp) edge[out=225, in=135] node [left] {} (bq);
\path[->,>=triangle 90] (bp) edge[out=10, in=40, looseness=7] node [right] {} (bp);

\path[->,>=triangle 90] (bq) edge[out=45, in=-45] node [right] {} (bp);
\path[->,>=triangle 90] (bq) edge[out=-10, in=-40, looseness=7] node [right] {} (bq);
\end{tikzpicture}
}
\hfill
\caption{Different kinds of  automata}
\end{figure}

\begin{figure}[tb]
\begin{bigcenter}
\begin{scriptsize}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
			&			&			&			&			&				&				&				&				&		\\
\hline
Token ring		&	\textbf{Step 3}			&	\textbf{Step 3}			&	\textbf{Step 3}			&	\textbf{Step 4}			&	\textbf{Step 3}	&	\textbf{Step 2}	&	\textbf{Step 2}	&	\textbf{Step 3}	&	\textbf{Step 3}	\\
size I : 4		&		&		&		& 		&			&			&			&			&			\\
size T : 6		&	8					&	8					&	5					&	12					&	8				&	5				&	5				&	8				&	5				\\
\hline
Token ring		&	\textbf{Step 3}			&	\textbf{Step 3}			&	\textbf{Step 3}			&	\textbf{Step 4}			&	T.o(Step 10)		&	\textbf{Step 2}	&	\textbf{Step 2}	&	T.o(Step 10)		&	\textbf{Step 3}	\\
size I : 4		&		&		&		& 		&					&			&			&					&			\\
size T : 9		&	8					&	8					&	5					&	12					&	109				&	5				&	5				&	109				&	5				\\
\hline
Dijkstra		&	\textbf{Step 6}			&	\textbf{Step 6}			&	\textbf{Step 5}			&	\textbf{Step 7}			&	T.o(Step 10)		&	\textbf{Step 5}	&	\textbf{Step 5}	&	T.o(115 hours)		&	\textbf{Step 5}	\\
size I : 5		&		&		&		&		&					&			&			&	T.o(115 hours)		&			\\	
size T : 62		&	49					&	118					&	20					&	246					&	745				&	11				&	10				&	T.o(115 hours)		&	15				\\	
\hline
Bakery		&	\textbf{Step 7}			&	No					&	No					&	\textbf{Step 10}			&	T.o(Step 10)		&	No				&	No				&	T.o(Step 10)		&	No				\\
size I : 2		&		&	Step 7				&	Step 6				&		&					&	Step 3			&	Step 3			&					&	Step 6			\\
size T : 24		&	43					&	75					&	89					&	97					&	368				&	31				&	31				&	1253			&	101				\\	
\hline
Burns		&	No					&	\textbf{Step 6}			&	No					&	No					&	No				&	No				&	No				&	No				&	No				\\
size I : 2		&	Step 5				&		&	Step 3				&	Step 7				&	Step 4			&	Step 3			&	Step 3			&	Step 4			&	Step 3			\\	
size T : 22		&	100					&	46					&	53					&	365					&	22				&	18				&	18				&	50				&	53				\\	
\hline
\end{tabular}
\end{scriptsize}
\caption{Results with syntactic criteria}
\label{tableau_resultats_master}
\end{bigcenter}
\end{figure}























\section{Conclusion}

Developing efficient approximation-based techniques is a critical
challenging issue to tackle reachability problems when exact
approaches do not work.  In this paper
two new approximation techniques for the regular reachability problem
have been presented. 
Our techniques use polynomial time algorithms, provided that 
recent algorithms for checking automata equivalence are used; the only exception being language inclusion testing 
as in~\cite{DBLP:conf/tacas/DoyenR10,DBLP:conf/tacas/AbdullaCHMV10,BONCHI-2012-674660}.
As a future direction, we plan to upgrade our refinement approach, both on the precision of the
approximations and on computation time. Another possible direction is to generalize 
our approximation mechanisms and to apply them to 
other RMC applications, e.g.,  
counter systems or push-down systems.

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
