\documentclass[conference]{IEEEtran}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage{pbox}
\usepackage{paralist}
\usepackage{hhline}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{proof}{IEEEproof}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newcommand{\qed}{\IEEEQEDopen}


\def\olg#1{\mathit{Olg}(#1)}
\def\A{\mathcal{A}}
\def\phi{\varphi}
\def\theta{\vartheta}
\newcommand{\tran}[1]{\xrightarrow[]{#1}}
\def\lz#1{\color{red}LZ: \texttt{#1} :ZL\color{black}}
\def\pu#1{\color{red}PU: \texttt{#1} :PU\color{black}}
\def\li#1{\color{blue}LI: \texttt{#1} :LI\color{black}}

\def\ff{\mathit{ff}}
\def\tt{\mathit{tt}}
\def\sat#1{\mathit{SAT}(#1)}
\def\Polsat{{Polsat}}
\def\Aalta{{Aalta}}
\def\expand{\mathit{NF}}
\def\of#1{\mathit{of}(#1)}
\def\ofp#1{\mathit{ofp}(#1)}
\def\nondeter{\perp}
\def\cur{\mathit{cur}}
\def\inf{\mathit{inf}}
\def\all{\geq}

\title{Fast LTL Satisfiability Checking by SAT Solvers}


\author{
    \IEEEauthorblockN{Jianwen Li\IEEEauthorrefmark{1}, Geguang Pu\IEEEauthorrefmark{1}, Lijun Zhang\IEEEauthorrefmark{2},
    Moshe Y. Vardi\IEEEauthorrefmark{3} and Jifeng He\IEEEauthorrefmark{1}}
    \IEEEauthorblockA{\IEEEauthorrefmark{1}Software Engineering, East China Normal University
   }
    \IEEEauthorblockA{\IEEEauthorrefmark{2}State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences 
   }
    \IEEEauthorblockA{\IEEEauthorrefmark{3}Computer Science, Rice University
        }
}


\iffalse
\author{Jianwen Li\inst{1} \and
Geguang Pu\inst{1} \and
Lijun Zhang\inst{2} \and \\
Moshe Y. Vardi\inst{3} \and
Jifeng He\inst{1}
}


\institute
{
  \inst{}Shanghai Key Laboratory of Trustworthy Computing, East China Normal University, P. R.China
  \and
  \inst{}State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences
\and
\inst{}
Department of Computer Science, Rice University, USA
}
\fi


\begin{document}

\maketitle


\begin{abstract}
Satisfiability checking for Linear Temporal Logic (LTL) is a fundamental 
step in checking for possible errors in LTL assertions. Extant LTL
satisfiability checkers use a variety of different search procedures. With 
the sole exception of LTL satisfiability checking based on bounded model
checking, which does not provide a complete decision procedure,
LTL satisfiability checkers have not taken advantage of the remarkable 
progress over the past 20 years in Boolean satisfiability solving.
In this paper, we propose a new LTL satisfiability-checking framework that 
is accelerated using a Boolean SAT solver.  Our approach is based on the 
variant of the \emph{obligation-set method}, which we proposed in
earlier work. We describe here heuristics that allow the use of a
Boolean SAT solver to analyze the obligations for a given LTL formula. 
The experimental evaluation indicates that the new approach provides
a significant performance advantage.
\end{abstract}



\section{Introduction}

\iffalse
The \emph{satisfiability problem} for Linear Temporal Logic (LTL)
asks whether a given LTL formula is satisfiable \cite{SC85}.  LTL 
satisfiability checking plays an important role in inspecting the 
consistency of temporal specifications that are often used in an early 
stage of system design \cite{RV10,RV11}.  Thus, efficient decision 
procedures to reason about large LTL formulas are quite desirable in 
practice.  

There have been several approaches proposed to deal with the LTL
satisfiability checking problem.  The model-checking 
approach reduces LTL satisfiability to LTL model checking by model checking
the \emph{negation} of the given formula against a \emph{universal} model.
This approach uses either explicit \cite{RV10} or symbolic \cite{RV11}
model checking.  The tableau-based \cite{Sch98} and antichain-based
\cite{DDMR08} approaches apply an on-the-fly search in the underlying 
automaton transition system.  The temporal-resolution-based method 
explores the unsatisfiable core using a deductive system \cite{HK03}. 
Our own previous work, embodied in the \Aalta\ LTL satisfiability checker,
follows the automata-based approach and reduces satisfiability checking to 
emptiness checking of the transition system by adopting two
new heuristic techniques, using \emph{on-the-fly search} and 
\emph{obligation sets} \cite{LZPVH13}.

Previous experimental evaluations across a wide spectrum of benchmarks 
\cite{RV10,RV11,SD11} concluded that none of existing approaches
described above dominate others. To establish a high-performed LTL 
satisfiability checker, we introduced a \emph{portfolio} LTL solver named 
\Polsat\ \cite{LPZVHCoRR13}, which runs several approaches in parallel,
terminating with the fastest thread. By definition, \Polsat\ is the
best-performing LTL satisfiability checker (subject to
constraints on the number of parallel threads).

An interesting observation in \cite{LPZVHCoRR13} is that the 
bounded-model-checking (BMC) technique \cite{CBRZ01} is the fastest 
on satisfiable formulas, as it leverages the tremendous progress 
demonstrated by Boolean satisfiability (SAT) solvers over the last 20 years 
\cite{MZ09}.  At the same time, BMC can detect satisfiability, but not 
unsatisfiability, which means that this approach does not provide a 
complete decision procedure. Nevertheless, the impressive performance of the
BMC-based approach inspired us to explore other possibilities of leveraging 
SAT solvers in LTL satisfiability checking.

We propose here an LTL satisfiability-checking framework that can be greatly
accelerated by using SAT solvers. The key idea here is of using
\emph{obligation formulas}, which are Boolean formulas
collecting satisfaction information from the original LTL
formula.  Intuitively, an LTL formula is satisfiable if the
corresponding Boolean \emph{obligation formula} is satisfiable. 
Using obligation formulas makes it possible to utilize SAT solving, 
since it eliminates the temporal information of LTL formula. Based on
obligation formulas, we extend the approach proposed in \cite{LZPVH13}
by presenting two novel techniques to accelerate satisfiability
checking procedure with SAT solvers.  In contrast to the BMC-based approach,
our method is both sound and complete, as it can also check unsatisfiable 
formulas.

To illustrate the efficiency of our new approach, we integrate our
implementation, \Aalta\_v0.2 into \Polsat, which also provides a
testing environment for LTL solvers.  The experiments show that 
while still no solver dominates across all benchmarks,  \Aalta\_v0.2
is much more competitive with other LTL satisfiability checkers than
\Aalta\_v0.1. More significantly, the performance of \Polsat\ improves dramatically 
as a result of replacing  \Aalta\_v0.1 by  \Aalta\_v0.2.

\noindent
\textbf{Contributions}: The three main contributions of the paper are as 
follows: 1) We extend the concept of \emph{obligation set} to that of
\textit{obligation formulas}, which enables us to leverage Boolean
satisfiability solving in LTL satisfiability solving.
2) We offer two novel SAT-based heuristics to boost the checking of 
satisfiable and unsatisfiable formulas respectively. 
3) We present a new tool, \Aalta\_v0.2, which is integrated into \Polsat\ 
and evaluated over large set of benchmark formulas. The experiments show 
that the new approach is both effective and efficient: the performance of
\Polsat\ improves 10-fold in some cases, and an average of 30\% to 60\% 
speed-up on random formulas.


\noindent
\textbf{Paper Structure}: The paper is organized as
follows. Section \ref{sec:pre} introduces the preliminaries about LTL and our
previous work~\cite{LZPVH13}. Section \ref{sec:of} provides the theoretical
framework of this paper. In Section \ref{sec:ofa}, we describe two techniques, 
based on SAT solving, to accelerate satisfiability checking respectively for
satisfiable and unsatisfiable formulas. The empirical framework
is described in Section \ref{sec:exp}. Section \ref{sec:related} discusses the related work, and finally Section \ref{sec:con} concludes the paper.\fi

The \emph{satisfiability problem} for Linear Temporal Logic (LTL)
asks whether a given LTL formula is satisfiable \cite{SC85}.  LTL 
satisfiability checking plays an important role in checking the 
consistency of linear temporal specifications that are often used 
in an early stage of system design \cite{RV10,RV11}.  Thus, efficient 
decision procedures to reason about large LTL formulas are quite 
desirable in practice.  

There have been several approaches proposed to deal with the LTL
satisfiability checking problem.  The model-checking 
approach reduces LTL satisfiability to LTL model checking by model checking
the \emph{negation} of the given formula against a \emph{universal} model.
This approach uses either explicit \cite{RV10} or symbolic \cite{RV11}
model checking.  The tableau-based \cite{Sch98} and antichain-based
\cite{DDMR08} approaches apply an on-the-fly search in the underlying 
automaton transition system.  The temporal-resolution-based method 
explores the unsatisfiable core using a deductive system \cite{HK03}. 
Our own previous work \cite{LZPVH13}, embodied in the \Aalta\ LTL 
satisfiability checker, follows the automata-based approach and reduces 
satisfiability checking to emptiness checking of the transition system 
by adopting two new heuristic techniques, using \emph{on-the-fly search} and 
\emph{obligation sets}.

Previous experimental evaluations across a wide spectrum of benchmarks 
\cite{RV10,RV11,SD11} concluded that none of existing approaches
described above dominate others. To establish a high-performance LTL 
satisfiability checker, we introduced a \emph{portfolio} LTL solver named 
\Polsat\ \cite{LPZVHCoRR13}, which runs several approaches in parallel,
terminating with the fastest thread. By definition, \Polsat\ is the
best-performing LTL satisfiability checker (subject to
constraints on the number of parallel threads).

An interesting observation in \cite{LPZVHCoRR13} is that the 
bounded-model-checking (BMC) technique \cite{CBRZ01} is the fastest 
on satisfiable formulas, as it leverages the tremendous progress 
demonstrated by Boolean satisfiability (SAT) solvers over the last 20 years 
\cite{MZ09}.  At the same time, BMC can detect satisfiability, but not 
unsatisfiability, which means that this approach does not provide a 
complete decision procedure. Nevertheless, the impressive performance of the
BMC-based approach inspired us to explore other possibilities of leveraging 
SAT solvers in LTL satisfiability checking.

We propose here an LTL satisfiability-checking framework that can be greatly
accelerated by using SAT solvers. The key idea here is of using
\emph{obligation formulas}, which are Boolean formulas
collecting satisfaction information from the original LTL
formula.  Intuitively, an LTL formula is satisfiable if the
corresponding Boolean \emph{obligation formula} is satisfiable. 
Using obligation formulas makes it possible to utilize SAT solving, 
since it eliminates the temporal information of LTL formula. Based on
obligation formulas, we extend the approach proposed in \cite{LZPVH13}
by presenting two novel techniques to accelerate satisfiability
checking procedure with SAT solvers.  In contrast to the BMC-based approach,
our method is both sound and complete, as it can also check unsatisfiable 
formulas.

To illustrate the efficiency of our new approach, we integrate our
implementation, \Aalta\_v0.2 into \Polsat, which also provides a
testing environment for LTL solvers.  The experiments show that 
while still no solver dominates across all benchmarks,  \Aalta\_v0.2
is much more competitive with other LTL satisfiability checkers than
\Aalta\_v0.1. More significantly, the performance of \Polsat\ improves 
dramatically as a result of replacing  \Aalta\_v0.1 by  \Aalta\_v0.2.

\noindent
\textbf{Contributions}: The three main contributions of the paper are as 
follows: 1) We extend the concept of \emph{obligation set} to that of
\textit{obligation formulas}, which enables us to leverage Boolean
satisfiability solving in LTL satisfiability solving.
2) We offer two novel SAT-based heuristics to boost the checking of 
satisfiable and unsatisfiable formulas respectively. 
3) We present a new tool, \Aalta\_v0.2, which is integrated into \Polsat\ 
and evaluated over large set of benchmark formulas. The experiments show 
that the new approach is both effective and efficient: the performance of
\Polsat\ improves 10-fold in some cases, and an average of 30\% to 60\% 
speed-up on random formulas.


\noindent
\textbf{Paper Structure}: The paper is organized as
follows. Section \ref{sec:pre} introduces the preliminaries about LTL and our
previous work~\cite{LZPVH13}. Section \ref{sec:of} provides the theoretical
framework of this paper. In Section \ref{sec:ofa}, we describe two techniques, 
based on SAT solving, to accelerate satisfiability checking respectively for
satisfiable and unsatisfiable formulas. The empirical framework
is described in Section \ref{sec:exp}. Section \ref{sec:related} discusses 
related work, and finally Section \ref{sec:con} concludes the paper.
\section{Preliminaries}\label{sec:pre}
\subsection{Linear Temporal Logic}\label{sec:ltl}
Let  be a set of atomic properties. 
The syntax of LTL formulas is defined by:

where ,  is an LTL formula.  We use the usual
abbreviations: 
, and . 

We say  is a propositional formula if it does not contain
temporal operators. We say  is a \emph{literal}
if it is an atomic proposition or its negation.  We use  to denote
the set of literals, lower case letters  to denote
literals,  to denote propositional
formulas, and  for LTL formulas.  
In this paper, we consider LTL formulas in negation normal form (NNF) -- all negations are 
pushed in front of atomics. 
LTL formulas are often interpreted over . Since we consider LTL in NNF, formulas are interpreted on infinite literal sequences
. 


A \emph{trace}  is an infinite sequence over
. For  and  we use  to denote the prefix of  up to its -th element,
and  to denote the suffix of 
from its -th element.  Thus, . 
\iffalse
To introduce the semantics of LTL formulas, we need the notion of \emph{consistent traces} 
at first:

\begin{definition}[Consistent Trace]
  We say a literal set  is \emph{consistent} iff for all 
  we have that . A trace  is
  consistent iff  is consistent for all .
\end{definition}

In the remainder of this paper, if not stated explicitly, all traces
considered are assumed to be consistent. 
\fi
The semantics of temporal operators with respect to an infinite trace  is 
given by:  iff ;
 iff ; and
\begin{itemize}
\item  iff there exists 
such that  and for all ;
\item  iff either
   for all , or there exists 
  with  and  for
  all .
\end{itemize}
According to the semantics, it holds . Now we define the satisfiability of LTL formulas as follows:

\begin{definition}[Satisfiability]
We say  is satisfiable if there
exists an infinite trace  such that .
\end{definition}




\iffalse
\textbf{Notation.} We define some notation that we use throughout this 
paper.
\begin{itemize}
\item For a formula , we use  to denote the set of
  subformulas of . We denote by  the set of atoms
  appearing in , by  the set of literals over ,
  and by  the set of consistent literal sets over .
\item Let  such that the root
operator of  is not a conjunctive.  We define the set of
conjuncts of  as .
When  does not include a conjunctive as a root operator,
 includes only  itself. The set of
disjuncts  is defined in an analogous way.
\iffalse
\item 
For a formula  of the form  or ,
let  () be left (right) 
subformulas of .
\fi
\item For all propositional formula
 appearing in the paper, we always check first whether
 is satisfiable. If not, we shall replace  by .
\end{itemize}
\fi


\subsection{Obligation-Based Satisfiability Checking}

This section recalls the fundamental theories on obligation-based satisfiability 
checking in our previous work \cite{LZPVH13}. For more details readers can refer to the literature.

\iffalse
\noindent
\textbf{Tagging Input Formula}
The framework requires that the input formula  has distinguished atomic propositions. 
To achieve this goal, we actually use the tagging technique, which we skipped the  
details here. In the rest of the paper, we consider the input formulas after tagging. We refer 
readers to \cite{LZPVH13} for more details. 


Given an input formula , our approach requires it to be tagged at first. 
The reason is that the search is processed on the \textit{LTL Transition System} we defined, 
which compared to traditional (Generalized-)B\"uchi automaton includes less information. 
As the states of the transition system are just LTL formulas, the tagging is needed to mark 
which until formulas have been satisfied on the edges (literal level). As a result, two same 
copies  of  may be syntactically different because they are marked with different until 
formulas. But still they are semantically equivalent, i.e. . 
In the rest of paper,  is used to be the input formula after tagging for simplicity: all our theories are based on tagging. 


Given an input formula , our approach requires it to be tagged at first. 
The reason is that the search is processed on the \textit{LTL Transition System} we defined, 
which compared to traditional (Generalized-)B\"uchi automaton includes less information. 
As the states of the transition system are just LTL formulas, the tagging is needed to mark 
which until formulas have been satisfied on the edges (literal level). For a formula ,
we denote  the set of until
subformulas of . Then:
\begin{definition}[Tagging Formula]\label{def:tagging}
  Let  be an atom appearing in .  Then, the tagging
  function  is defined as:
   iff  appears in , i.e. the set of right subformulas of .

  We define the \emph{tagged formula}  as the formula obtained
  by replacing  by  for each . 
\end{definition}

After tagging  may contain more atoms, and 
all these new copies are semantically equivalent. Given a tagging
function , two copies  are syntactically equivalent iff
.
As an example, consider . Let
, and .  From Definition
\ref{def:tagging} we know the tagged formula  
where , and
. 
Here  and  are syntactically different but semantically equivalent.
So it holds for example . 

Because of the tagging, the  
notation defined below is required in the following:


\begin{definition}\label{def:subseteqw}
  Given two literal sets  and , we define  holds iff for all 
   there exists a  such that .
\end{definition}
Note here, the  and  may be syntactic different but equivalent 
in the semantics due to the tagging process. For example, it is true that 
 as . From the definition, it is easy to check 
that  and  imply 
.


In the rest of paper,  is used to be the input formula after tagging for simplicity: all our theories are based on tagging. 

\fi

\noindent
\textbf{Obligation Set} The \textit{obligation set} defined below is the fundamental part of the generalized satisfiability checking in our previous work. 


\begin{definition}[Obligation Set]\label{def:os}
  For a formula , we define its obligation set, denoted by
  , as follows:
  \begin{itemize}
  \item  and ;
   \item If  is a literal, ;
    \item If , ;
    \item If , ;
    \item If , ;
    \item If  or , .
 \end{itemize}
 For , we refer to it as an \emph{obligation} of
 . Moreover, we say  is a consistent obligation iff  holds, 
 where .
\end{definition}

From the definition of \textit{obligation} above, one can check easily the following theorem 
is true:
\begin{theorem}[Obligation Acceleration \cite{LZPVH13}]\label{thm:oa}
  Assume  is a consistent obligation. Then,
  .
\end{theorem}

\noindent
\textbf{Obligation-Based Satisfiability Checking}
Theorem \ref{thm:oa} is sound but not complete. If no consistent
obligations are found, we shall then explore the \textit{LTL
  Transition System}, which uses the \textit{Normal Form} defined as
follows:

\begin{definition}[Normal Form]\label{def:expansion}
  The \textit{normal form} of an LTL formula , denoted as
  , is a set defined as follows:
\begin{compactenum}
\item  if  is a
  propositional formula. If , we define ;
\item ;
\item ;
\item ;
\item ;
\item .
\end{compactenum}
\end{definition}

Note here let  such that the root
operator of  is not a disjunction, and then  
is defined as the set of
disjuncts of . Now we introduce the \textit{LTL transition system}:

\begin{definition}[LTL Transition System]\label{def:lts}
  Let  be the input formula. The
  labeled transition system  is a tuple  where: 
  
  \iffalse
  1).  is the initial state; 
  2).  is the set of conjunctive formulas over ; 
  3). the transition relation  is defined by:
     iff there exists ; and 4).  is the smallest set of formulas such that , and  implies
  .
  \fi
  \begin{compactenum}
  \item   is the initial state, 
  \item  is the set of conjunctive formulas over ,
 \item the transition relation  is defined by:
     iff there exists ,
\item  is the smallest set of formulas such that , and  implies
  .
  \end{compactenum}
\end{definition}

For a strong connected component (SCC) , we use  to denote the set of literals that along with . 
Then we have the following theorem:

\begin{theorem}[Obligation-Based Satisfiability Checking \cite{LZPVH13}]\label{thm:scc}
  The formula  is satisfiable iff there exists a SCC
   of  and a state  in  such that  is a
  superset of some obligation .
\end{theorem}

\begin{example}
  \begin{enumerate}
    \item Consider the formula : Since   in 
    which  is 
    obviously a consistent obligation, so  is also satisfiable from Theorem \ref{thm:oa}.
    \item Consider the formula : since 
     which does not contain any consistent obligation, so Theorem 
    \ref{thm:oa} is not available. Actually,  contains only one state  with a 
    self-loop labeling : Thus we cannot find a  satisfying Theorem \ref{thm:scc}, 
    which implies  is unsatisfiable. 
  \end{enumerate}
\end{example}


\section{Satisfiability Checking with Obligation Formula}\label{sec:of}

\subsection{Obligation Formula}


The \textit{Obligation}-based satisfiability checking has been proven more efficiently than 
traditional model-checking-based approach \cite{LZPVH13}. However the size of obligation set 
can be exponential in the number of conjuncts. 
For example, consider the pattern formula 
, which obviously is satisfiable. 
By applying our previous approach, the extra exponential cost must be paid to compute the 
whole \textit{obligation set}. We may view the \textit{obligation set} 
as a DNF, with  each element in \textit{obligation set} a clause in DNF. 
It hints that we can replace the \textit{obligation set} by an \textit{obligation formula}.

\begin{definition}[Obligation Formula]\label{def:of}
Given an LTL formula , the corresponding \textit{obligation formula}, 
which is denoted as , is defined recursively as follows:
     \begin{itemize}
       \item  and ;
       \item If  where  is a literal, then ;
       \item If , then ;
       \item If  or , then ;
       \item If , then ;
       \item If , then ;
     \end{itemize}
\end{definition}

The \textit{obligation formula} is virtually a Boolean formula.
Compared to the definition of \textit{obligation set} (Definition
\ref{def:os}), the \textit{obligation formulas} avoid the generation
of DNF, and thus avoid the extra exponential cost. It succeeds to
reduce the computation of \textit{obligation set} to the checking on
the \textit{obligation formula}.

The following lemma explains the relationship between the \textit{obligation formula} and \textit{obligation set}:

\begin{lemma}\label{lemma:ofandos}
  Given an LTL formula , then
  ,
  i.e. the DNF of  is
  .
\end{lemma}
\begin{proof}
  We can prove this lemma by structural induction over :
  \begin{enumerate}
    \item If  or , one can prove easily the lemma holds;
    \item If  is a literal, then we know  and . Thus 
     is true;
    \item If , then we know  and . By induction 
    hypothesis we have  holds. So 
    it is also true that ;
    \item If  or , then we know  and 
    . By induction hypothesis we have  holds. So 
    it is also true that ;
    \item If , then we know  and 
    . By induction hypothesis we have  holds, where . Then it is true that 
    ;
    \item If , then we know  and 
    .  By induction hypothesis we have  holds, where . Then it is true that 
    . The proof is done.
  \end{enumerate}
\end{proof}

\iffalse
The correctness of the lemma is directly guaranteed by the definitions of \textit{obligation formula} (Definition \ref{def:of}) and \textit{obligation set} (Definition \ref{def:os}).
\fi



\subsection{Obligation-based Satisfiability Checking Revisited}


In this section, we adapt our general checking theorem (Theorem
\ref{thm:scc}) via reducing checking the containment of an obligation
to the satisfiability of the corresponding obligation formula. Lemma
\ref{lem:reduction_2} below shows the reduction first and Theorem
\ref{thm:satscc} tells how to achieve the general checking via the
obligation formula. Before that, we introduce the  (weak satisfaction relation) 
operator appeared in the theorem.

Let  be a set of literals of , and  a
propositional formula in NNF. We define  in
a syntactic way: if  is a literal,  or  then 
iff ,  iff
 and , and
 iff  or
. Note  needs not to be
consistent, e.g.,  holds according to the definition.


\begin{lemma}\label{lem:reduction_2}
  Given an LTL formula  and a literal set , then  iff there exists 
  an obligation  such that .
\end{lemma}
\begin{proof}
   According to Lemma \ref{lemma:ofandos},  is semantically equivalent to the DNF of . 
   Then from Definition \ref{def:os} we know an obligation in  is essentially a clause of the DNF of . 
   And it is obvious that  iff there is a clause  in the DNF of  which 
   satisfies , i.e., . Let 
   and we know  is an obligation in . The proof is done.
   
\end{proof}




\begin{theorem}[SAT-Based Generalized Satisfiability Checking]\label{thm:satscc}
  The LTL formula  is satisfiable iff there exists a SCC scc and a state  
  in  such that .
\end{theorem}
\begin{proof}
  First according to Lemma \ref{lem:reduction_2} we know  holds iff 
  there exists an obligation  such that . Then from  
  Theorem \ref{thm:scc} we can directly conclude this theorem.
\end{proof}

In Theorem \ref{thm:satscc} the set  collects all literals along , thus it may 
be inconsistent. So it is necessary to introduce the notation .
  
\section{Satisfiability Checking Acceleration}\label{sec:ofa}

In this section we present accelerating techniques exploiting
obligation formulas that are tailored to both satisfiable and
unsatisfiable formulas.

\subsection{Acceleration on Satisfiable formulas }
Recall that we need to find a consistent obligation in  in Theorem \ref{thm:oa}. 
Now the problem can be reduced to that of  
checking whether  is satisfiable. The following lemma shows that if  is 
satisfiable then there exists a consistent obligation in . 

\begin{lemma}\label{lem:reduction}
  For an LTL formula , if  is satisfiable, then there exists a consistent 
  obligation . 
\end{lemma}
\begin{proof}
  According to Lemma \ref{lemma:ofandos},  is semantically
  equivalent to the DNF of . So every
  obligation in  is actually a clause in the DNF of
  . And it is apparently true that  is
  satisfiable implies there exists a clause  in the DNF of
   which is satisfiable. Thus  is consistent,
  i.e. . Let  and we know that  is an
  consistent obligation in . The proof is done.
  
\end{proof}

From Lemma \ref{lem:reduction}, Theorem \ref{thm:oa} can be slightly adapted to obtain 
our SAT-based obligation acceleration for satisfiable formulas:

\begin{theorem}[SAT-Based Obligation Acceleration]\label{thm:satoa}
  For an LTL formula , if  is satisfiable, then  is also satisfiable. 
\end{theorem}
\iffalse
\begin{proof}
First from Lemma \ref{lem:reduction} we know  is satisfiable implies there exists a 
consistent obligation  in . Then according to Theorem \ref{thm:oa} we can conclude 
that  is satisfiable. 
\end{proof}
\fi


\subsection{Acceleration on Unsatisfiable formulas}
The previous section proposes a heuristic for checking satisfiability
of obligation formulas. In this section we further
exploit SAT solvers to develop heuristics for checking unsatisfiable
formulas by using the obligation formulas. We first use an example to
explain our idea. Consider the formula .  One
can see that  is unsatisfiable. If we look into the formula, 
must be true in every position from the beginning (position ) in
, on the other side,  must be false in the position  due to
: this is obviously a contradiction.  Now recall our approach:  is unsatisfiable, so Theorem \ref{thm:satoa} cannot
apply. The observation we get here is that there is no
positional information for literals in  so that we lost the
information that  and  must both be true in position .

For this purpose, we extend the \textit{obligation formula} for a
formula , denoted as , with additional positional
information for each literal. Besides the literal itself, the start
position and its duration are also recorded in . We denote
the alphabet of  as , where
each  consists of three elements:
\begin{itemize}
\item the propositional property (),
\item start position () from which the property must be
  satisfied. The symbol  means the start position is not
  determined.
\item its duration () where  means the duration
  is just the start position,  means the duration is all from
  the start position; and  means the duration is
  infinitely many from the start position, but not all. 
\end{itemize}


For convenience in the following, we use the notations ,
, and  to represent its corresponding first,
second and third elements for . So, if , then ,  and
. We also use the notation  () to represent 
the set of literals appearing in  ().  Now we give the
formal definition of :

\begin{definition}[Obligation Formula with Position]\label{def:ofp}
    Given an LTL formula , the corresponding \textit{obligation formula with position}, denoted 
    as , is defined recursively as follows:
    \begin{itemize}
      \item If : ;
      \item If : ;
      \item If : 
      \begin{itemize}
        \item if for every 
       it holds that , then 
      ; 
    \item Otherwise ,
      where  is acquired from  by setting
       and  for every ;
      \end{itemize}
      \item If : ; 
      \item If : ;
      \item If  : ;       
      \item If : ;
    \end{itemize}
    where the function  updates 
    via the .  Explicit rules are listed in
    Table \ref{tab:pos}.
  
\begin{table}
\caption{The explicit rules for the  function}\label{tab:pos}
\centering
\scalebox{1}{
    \begin{tabular}{|c|c|c|c|c|}
    \hline
      Literal & X & U & R & G \\
      \hline
       &  &  &  & \\
      \hline
       &  &  &  & \\
      \hline
       &  &  &  & \\
      \hline
       &  &  &  & \\
      \hline
       &  &  &  & \\
      \hline
       &  &  &  & \\
    \hline
    \end{tabular}
}
    
\end{table}
\end{definition}

The  operator is a key which causes nondeterminism. So every start position and duration in 
literals should be updated to  and  respectively -- unless we make sure all literals' start 
positions are the same.
The first column of Table \ref{tab:pos} shows all possible compositions for literals. The second to 
fifth columns show the new composition after the corresponding temporal operator acting on the 
literal. The  operator only add 1 to the start position if it is determined, and the  operator 
does not change the original information at all. For the  operator it makes every start 
position undetermined. The  operator is distinguished with  as it causes the duration. If its 
nested literal  satisfies  or , then it will update 
; otherwise it updates .

It should be mentioned that  is essentially an extended propositional formula whose alphabet is 
. Definition 
\ref{def:ofp} only involves in the syntactic level of , and its semantics is skipped as 
we treat  an intermediate structure but actually set up the decision procedure on the \textit{positional projection formulas} 
created from . The definition is shown below. 

So far we have encoded the positional information into the literals and \textit{obligation formulas}. 
The following definition provides us a mechanism to project the \textit{obligation formula} into each position we 
concern. We try to make the projection loose enough to guarantee the correctness: In the definitions, if 
the literal is not determined in the projecting position, then we just assign 
its projection to be .

\iffalse
\begin{definition}[Positional Projection on Literals]\label{def:literal_projection}
    Let , then we denote  as 
    's projection under the position , and we define  iff 
    1). , or 2).  and . Otherwise we define 
\end{definition}

The projection on a literal tells us whether the literal needs to be satisfied at the given position. For example, 
consider the formula  and thus . 
Let  and , then according to 
Definition \ref{def:literal_projection} we have , 
 (since ) and  for every  (since  and 
). Note also  for all , and it is because  which is 
undetermined so that its projection for every position is . Next, we extend the projection to the obligation formula:
\fi
  
\begin{definition}[Positional Projection on Obligation Formulas]\label{def:ofp_projection}
    Given an obligation formula with positions  from , its projection under the 
    position , denoted 
    as , is defined recursively as follows:
    \begin{itemize}
      \item If : 
      \item If : ;
      \item If : .
    \end{itemize}
\end{definition}

Informally speaking,  keeps the first part of literals whose projection on position  is true. For these , it is either  holds or  and  hold. Otherwise the literals are substituted  
by . So  is a pure propositional formula. 

For example, 
consider the formula  and thus . 
Let  and  and we start from the literals. According to 
Definition \ref{def:ofp_projection} we have , 
 (since ) and  for every  (since  and 
). Note also  for all , and it is because  which is 
undetermined so that its projection for every position is . 
Thus, recursively we know that ,  and etc.

Now the whole framework has been established, and we can conclude the formula  is 
unsatisfiable via finding there is a position which cannot be satisfied in all its models: this is exactly what 
Theorem \ref{thm:satunsat} below talks about. Before that, Lemma \ref{lem:reduction_3}  should be introduced at first, which shows the truth of the reverse of Theorem \ref{thm:satunsat}. In the lemma, the notation  represents the th 
element of the infinite trace .

\begin{lemma}\label{lem:reduction_3}
    Given an infinite word  and an LTL formula , if , then 
    for every position  it holds that .
\end{lemma}
\begin{proof}
  We prove this lemma by structural induction over . 
  \iffalse
  The proof is trivial for 
  the cases when the type of  is the 
  literal, next, until, release, or  formula, so we here focus on the cases when 
  it is Global (G) and :
  \fi
  \begin{enumerate}
  
    \item If  is a literal, from Definition \ref{def:ofp} we know 
    , and from Definition \ref{def:ofp_projection} 
    we know  and 
    . Since  so  must 
    hold according to the LTL semantics. For  it is obviously true that 
    ; 
    
    \item If , since  so  according to the 
    LTL semantics. By induction hypothesis, we know that  
    for every . Then according to the  rules on  operator in Table \ref{tab:pos}, we 
    know that  for every . Also we know 
    , so it is apparent that ;
    
    \item If , then according to the  rule on  operator in Table 
    \ref{tab:pos} we know that  for all . Thus from Definition 
    \ref{def:ofp_projection},  holds 
    for every . Hence  holds for all ;
    
    \item If , then first we know  implies 
     from the LTL semantics on R operator. Thus by induction hypothesis we already 
    have  for every . Moreover it is true that 
     according to the  rules on  operator in Table \ref{tab:pos}, so 
    does  for all . Thus it concludes that 
     for every ;
    
    
    \item If , then  implies that  for all . 
    By induction hypothesis, for every  and  we have the assumption that 
    . Now we consider the possibilities of :
    \begin{itemize}
      \item If , then from Definition \ref{def:ofp} 
      we know . For  we have  according to Definition \ref{def:ofp_projection}. And for  we know 
      that . Since  for every  and , so  also holds for . 
      Thus for every  we have ;
      \item If , then from Definition \ref{def:ofp} 
      we know . For  we have . And  holds if . For  we know  so  is always true;
      \item If  where  can be ,  or , then 
      from Definition \ref{def:ofp} we have . Thus according to Definition \ref{def:ofp_projection} we know  for every 
      . So  is always true;
      \item Inductively if , then we know  and  implies  and  hold for every . By inductive hypothesis we have proven that  and  for , so  also holds. As we know , so it is true that 
       for ;
      \item If , then we know  and  implies  or  holds for every . By inductive hypothesis we have proven that  or  for , so  also holds. 
      According to Definition \ref{def:ofp} if  then it is true that  for . And if  from Definition \ref{def:ofp} then we know  for every , so  holds as well. 
    \end{itemize}
    Thus, we prove that  holds for every ;
    
    
    \item If , then from Definition \ref{def:ofp} we know that 
    , and so does 
     
    for  via Definition \ref{def:ofp_projection}. 
    Also  implies  and . 
    By induction hypothesis, it holds that  and 
     for every . 
    So , 
    which proves that  for ;
    
    
    \item If , then  implies either  or 
     holds. Assume that  holds. 
    Also according to Definition \ref{def:ofp}, there are two possibilities 
    on : 1) If , then by induction hypothesis 
    we know that  implies  for all 
    . Moreover, we can conclude that 
     from Definition 
    \ref{def:ofp_projection}. Combining the conclusion above we can 
    finally prove  for all 
    ; 2) If , then since  is updated to 
     for every  in 
     and : it causes that  and 
     are assigned to  according to Definition 
    \ref{def:ofp_projection}, and so does . Hence it is 
    easy to check that  for all 
    . Finally the proof is done.
  \end{enumerate}
  
\end{proof}

Lemma \ref{lem:reduction_3} directly implies the following theorem for checking unsatisfiable 
formulas:  

\begin{theorem}[SAT-Based Unsatisfiable Checking]\label{thm:satunsat}
    Given an LTL formula , if there exists a position  such that 
     
    is unsatisfiable, then  is also unsatisfiable. 
\end{theorem}

\iffalse
\begin{proof}
  One can check easily that, this theorem is immediately proven by applying the reverse law on 
  Lemma \ref{lem:reduction_3}.
\end{proof}
\fi

However, this theorem can only be implemented as a heuristics technique because we cannot check 
every position of an infinite model in the worst case. On the other hand, it is also not necessary 
to check the 
accurate position every time: instead we can find the unsatisfiable position in a more 
abstract way. 
To achieve this, we need to introduce a more abstract definition for projection on obligation formulas.

\begin{definition}[Abstract Projection on Obligation Formulas]\label{def:ofp_abstract}
  Given an obligation formula with positions  from 
  and a literal set , we define its projection under , denoted
  as , as follows:
    \begin{itemize}
      \item : if  then , else 
      ;
      \item : ;
      \item : ;
    \end{itemize}

\end{definition}

Informally speaking,  is a Boolean formula in which literals not in  are 
replaced by , and those in  are replaced by their first elements. 
The following corollary lists the strategies we apply in our algorithm. 

\begin{corollary}\label{coro:abstract}
  Given an LTL formula , let , then  is unsatisfiable if one of the
  following conditions is true:
  \begin{enumerate}
    \item There exists  such that , and ;
    \item ;
    \item There exists  such that , and ,
      where  and  for each ;
    \item There exists  such that , and 
    .
  \end{enumerate}
\end{corollary}

\iffalse
\begin{corollary}\label{coro:abstract}
  Given an LTL formula  and let , then  is unsatisfiable if one of the following conditions is true:
  \begin{enumerate}
    \item There exists  such that , and ;
    \item ;
    \item There exists  such that , and 
    , where  and  for each 
    ;
    \item There exists  such that , and 
    ;
  \end{enumerate}
\end{corollary}
\fi

Note here  cannot be empty. The correctness of the corollary is
guaranteed by Theorem \ref{thm:satunsat}: An unsatisfiable position
can always be found in above four conditions. Since the number of
literals is linear to the size of , so the additional cost for
the unsatisfiable checking is polynomial to the size of . Below
we use several examples to demonstrate the efficiency of our approach:

\begin{example}
  \begin{enumerate}
  \item Consider the formula . We have
    . According to the first item of Corollary
    \ref{coro:abstract} we know . So  is unsatisfiable;
  \item Consider the formula . We
    have . Then from the
    second item of Corollary \ref{coro:abstract} we know  is
    unsatisfiable;
    \item For the formula , we can use the third item of Corollary 
    \ref{coro:abstract} to check it is unsatisfiable;
    \item For the formula , the fourth item of Corollary 
    \ref{coro:abstract} can be used to check it is unsatisfiable.
  \end{enumerate}
\iffalse
  Consider the pattern formula 
  , apply our approach and we get , in which . Then according to the second strategy in Corollary \ref{coro:abstract} we can conclude 
   is unsatisfiable due to . As a result, the checking result is 
  benefit from the high performance of SAT solvers.
\fi
\end{example}

Note  is treated as a proposition formula with the
extended alphabet . Each element  in  is
a triple, to keep the positional information. The projections
 and  are
propositional formulas over the literals , and they are the real ones used
for checking satisfiability in our algorithms.

\iffalse
\section{Experiments}\label{sec:exp}

In this section we talk about the details of experiments in the paper. We first introduce the 
strategies used in our experiments, and then present the corresponding results.  

\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.53]{Qformulas}
\caption{Experimental results on Q pattern formulas ().}
\label{fig:Qformulas}
\vspace{0.3cm}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.53]{O2formulas}
\caption{Experimental results on O2 pattern formulas ().}
\label{fig:O2formulas}

\end{minipage}
\end{figure}
\fi


\begin{table*}
\renewcommand{\arraystretch}{1.3} 
\caption{Comparison results for the \textbf{Schuppan-collected} benchmarks. Each cell in the
table lists the checking time on satisfiable (above) and unsatisfiable (below)
cases in the given pattern. For
some patterns the results on unsatisfiable formulas are empty as no unsatisfiable cases are in the patterns.}\label{tab:schuppan-collected}
\centering
\scalebox{1.0}{
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
  \hline
  Formula Type  &  pltl  &  ls4  &  TRP++  &  NuSMV-BDD  &  Aalta\_v0.1  &  Aalta\_v0.2\\
\hline
acacia/demo-v3  &  366.8  & 10.9  & \cellcolor{blue!35} 5.9  &  2753.5  &  1765.4  &  495.8\\

\hline
\multirow{2}{*}{alaska/lift}  &  3615.5  &  2155.4  &  12525.9  &  11513.4  &  5828.8  &  \cellcolor{blue!35}1483.4\\

 & 1264.5 & \cellcolor{green!35}302.4 & 1079.6 &  1044.7 & 1521.8 & 1520.1\\
\hline

anzu/amba  & \cellcolor{blue!35} 605.3  &  3913.8  &  5554.2  &  5728.4  &  3421.1  &  1958.9\\

\hline
anzu/genbuf  &  2849.7  &  3725.7  &  6609.2  &  7085.3  &  6207.7  & \cellcolor{blue!35} 1742.9\\
\hline

rozier/counter  &  \cellcolor{blue!35}1415.3  &  2735.1  &  1570.3  &  5639.6  &  3981.3  &  3562.5\\

\hline
\multirow{2}{*}{rozier/formulas}  &  178.5  & \cellcolor{blue!35} 65.3  &  49514.1  &  3914.5  &  2308.7 &  137.3\\

  & 185.8 & \cellcolor{green!35}1.2 & 551.9 &  3.8 & 124.0 & 93.3\\
\hline

rozier/pattern  &  15.1  &  9105.1  &  5530.0  &  17644.4  &  31.484  &  \cellcolor{blue!35} 14.3\\

\hline
\multirow{2}{*}{schuppan/O1formula}  & \cellcolor{blue!35} 0.3  &  629.8  &  1080.6  &  1028.0  &  517.1  &  1.5\\

  & 1026.9 & 646.1 & 68.8 & 1058.8 & 12.9 & \cellcolor{green!35} 6.1\\
\hline
\multirow{2}{*}{schuppan/O2formula}  & \cellcolor{blue!35} 2.7  &   748.0  &  291.0  &  1084.4  &  632.7  &   11.1\\

  & 1081.5 & 1081.4 & 1300.6 & 1083.3 & 1351.2 & \cellcolor{green!35} 3.2\\
\hline

\multirow{2}{*}{schuppan/phltl}  &  120.5  &  622.1  &  1020.9  &  847.9  &  121.0  & \cellcolor{blue!35} 7.1 \\
 & 300.4  &  455.5  &  308.9  & \cellcolor{green!35} 27.2  &  480.0  &  364.8\\
\hline

\multirow{2}{*}{trp/N5x}  & \cellcolor{blue!35} 2.7  &  41.9  &  11711.6  &  10.2  &  1556.7  &  11.3\\

  & 11.7 & 14.4 & 863.5 & \cellcolor{green!35} 2.4 & 3669.0 & 1345.3\\
\hline
\multirow{2}{*}{trp/N5y}  & \cellcolor{blue!35} 1.1  &  30.6  &  8578.4  &  955.0  &  5715.1  &  6.1\\

  & 2760.3 &   380.9 & \cellcolor{green!35} 354.8 & 440.4 & 6760.6 & 2760.4\\
\hline
\multirow{2}{*}{trp/N12x}  &  10095.9  &  431.1  &  2527.6  &  17191.0  &  14836.4  & \cellcolor{blue!35} 36.2\\

  & 9816.5 & \cellcolor{green!35}334.4 & 5157.4 & 8027.0 & 9487.2 &  1623.4\\
\hline
trp/N12y  &  106.5  &  591.6  &  18208.7  &  18786.2  &  8677.8  & \cellcolor{blue!35} 12.4\\

\hline
\multirow{2}{*}{Total}  &  19375.9  &  24806.4  &  124728.4  &  94181.8  &  76398.6  & \cellcolor{red!35} 9480.8\\

& 16447.3 &  3216.3 & 9685.5 & 11687.6 & 24428.9 & \cellcolor{red!35} 7716.6\\
\hline

\end{tabular}
}

\end{table*}

\subsection{Experimental Strategies}

We use the SUG@R cluster\footnote{\url{http://www.rcsg.rice.edu/sharecore/sugar/}} in Rice university as the experimental
platform. The cluster contains 134 Sun Microsystems SunFire x4150 nodes, each of which includes
8 cores of 2.83GHz Intel Xeon Harpertown CPUs with 16GB RAM. In our experiments, we use the Polsat as the testing platform
\cite{LPZVHCoRR13} to evaluate our tool with other LTL satisfiability solvers. Polsat is run on a node of SUG@R, and all tested tools, which are integrated into Polsat,
occupy each unique core (the number of tools is less than 8). The timeout for every running case is set to be 60 seconds. 

There are two \Aalta\ versions in our experiments: \Aalta\_v0.1 for
the old one and \Aalta\_v0.2 the current one which implements the
algorithms in this paper\footnote{\url{http://www.lab205.org/aalta/}}.  \Aalta\_v0.2 uses MiniSat
\cite{ES03} solver as the SAT engine, and the bool2cnf
\footnote{\url{http://www-ise4.ist.osaka-u.ac.jp/~t-tutiya/sources/bool2cnf/}}
tool to provide the ``DIMACS CNF'' input format for MiniSat. 
\iffalse
Both these tools are invoked
externally. That means, \Aalta\_v0.2 provides the input for bool2cnf, the output of bool2cnf is the input of MiniSat, and then \Aalta\_v0.2 obtains Minisat's output for further processing. Although they can be integrated in the code level we deploy them directly for 
experimental usage, and the integration will be achieved when our new tool is released. These two 
tools are purely invoked and not parameters are used.  
\fi
Several
other LTL satisfiability solvers are also involved in the
experiments. Among them, the pltl tool\footnote{Three tool versions can be found at \url{http://users.cecs.anu.edu.au/~rpg/PLTLProvers/}, and we choose the first one following \cite{SD11}.} 
\cite{Sch98} is the
representative of tableau-based approach; the TRP++ tool \cite{HK03}
implements the temporal resolution strategy; the NuSMV tool
\cite{CCGGPRST02} uses the model-checking-based method. Since NuSMV
applies BDD technique, we use NuSMV-BDD to denote it. Note that
NuSMV-BMC (bounded model checking) can also be used to check satisfiable formulas, but fails to
check unsatisfiable formulas, so we skip it in our experimental
results. Moreover, the alaska tool~\cite{DDMR08}, which is the
implementation of antichain-based checking, is not involved here as it fails to run on SUG@R. 
Recently a new solver ls4 is released, which is a SAT-based PLTL prover\cite{SW12}
\footnote{\url{http://www.mpi-inf.mpg.de/~suda/ls4.html}}. We here thus 
make a comparison with this tool as well. The input of ls4 is the same as that of TRP++. 
Since the input of TRP++ must be in SNF (Separated Normal Form \cite{Fish97}), a SNF generator is also required. 
One can download the \textit{translate} generator from the TRP++ website\footnote{\url{http://cgi.csc.liv.ac.uk/~konev/software/trp++/}}. 

The tools introduced above contain several parameters and their performance may vary on their selection. 
In \cite{SD11}, Schuppan and Darmawan collected the winning configurations for each tool. 
However some of the parameters in them are not available in the tools' new versions. 
To compare the best results those in \cite{SD11}, we choose the parameters as close as to the ones in the winning configurations, which are also suggested from the tool authors. Summarily, the pltl tool uses the ``-tree'' parameter; TRP++ uses ``-sBFS -FSR'' and the SNF generator \textit{translate} uses ``-s -r''; NuSMV-BDD applies ``-dcx -f -flt -dynamic''; ls4 runs with ``-r2l''. In our experiments, pltl, TRP++, NuSMV and ls4 versions are r1424, 2.2, 2.5.4 and 1.0.1 respectively. 

In the experiments we consider all benchmarks from
\cite{RV10,SD11,LZPVH13}.
For simplicity, we call the formulas from
\cite{SD11} as \textit{schuppan-collected} benchmarks in the following. This benchmark contains a total amount of 7446 formulas. To test the scalability of the tools on random formulas, we choose those in \cite{RV10} with length varying from 100 to 200 and variables number fixed to 3. For each length we test a group of 500 cases.   The \textit{random conjunction formulas} introduced in \cite{LZPVH13} are also fully tested. It has the form of , where each  is a specification pattern randomly chosen from \cite{DAC98}\footnote{\url{http://patterns.projects.cis.ksu.edu/documentation/patterns/ltl.shtml}}. The number
 here is extended to 20, each of which contains 500 cases. To sum up, we test the tools on approximately 50 patterns and 27,446 formulas. And we do not find any inconsistency among the results from different tools unless timeout occurs. 

\subsection{Experimental Results}



\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.52]{random}
\caption{Experimental results on extended random formulas with 3 variables.}
\label{fig:random}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.52]{random_conjunction}
\caption{Experimental results on random conjunction formulas.}
\label{fig:random_conjunction}
\vspace{0.3cm}
\end{minipage}
\end{figure}
\fi







Table \ref{tab:schuppan-collected} shows the evaluation results on formulas from the 
\textit{schuppan-collected} benchmark.
The first column lists the pattern types, and the second to seventh columns show the checking time (seconds) of involved solvers on
each pattern respectively. 
Normally, a test benchmark of the given pattern involves two types of
formulas: satisfiable and unsatisfiable ones. We separate them in two
rows for each entry of benchmark pattern: the upper one is the
checking time for satisfiable formulas and the below one for
unsatisfiable formulas. However, some patterns do not have
unsatisfiable formulas in their data set, we just keep one row in the
table, such as \textsf{acacia/demo-v3}, \textsf{anzu/amba}
patterns. We also rule out those cases that cannot be decided within
the timeout by all solvers, since we do not know if the formulas are
satisfiable or not. We highlight the entry of the best checking result
for each pattern: the blue for satisfiable cases and the green for
unsatisfiable ones. (Note some patterns in the benchmark are not shown in the table as they are not 
important: they can be checked within 10 seconds by all solvers.)



From Table~\ref{tab:schuppan-collected}, we can see that the  proposed SAT-based approach dramatically improves the performance of the obligation-based satisfiable checking method, which is our previous work~\cite{LZPVH13}. For instance, compared to \Aalta\_v0.1, \Aalta\_v0.2 has a nearly 1000 times improvement
for the satisfiable cases in \textsf{trp/N5y}, and nearly 500 times speedup for the unsatisfiable cases in
\textsf{schuppan/O2formula}. Totally, \Aalta\_v0.2 performs about 5 times better than \Aalta\_v0.1.

Although the experiments confirms the fact
that none of involved solvers dominates all the cases, our new tool (\Aalta\_v0.2) apparently 
takes the advantage. Among all the patterns, it owns 8 best results while pltl takes 6 best 
places, ls4 wins in 4 patterns, and both TRP++ and NuSMV-BDD perform best in 2 patterns each. 
Moreover, \Aalta\_v0.2 successfully gets the best overall performance for the whole 
benchmark, as the red cell in the table shown. For the ls4 tool, which gets the second place 
in total, costs nearly 2 times more for the checking.  

There are also some other observations we can make: 1). Compared to other tools, pltl performs 
really stable except for the \textsf{trp/N12x} pattern. So it can improve rapidly if it takes over 
this pattern; 2). TRP++ and NuSMV-BDD may be better at checking satisfiability rather than 
unsatisfiability, from their results in the table; 3). ls4 is quite advantageous on checking 
unsatisfiability, as it takes the most amount of best unsatisfiable checking cases; 4). For our 
tool \Aalta\_v0.2, its results show clearly that the SAT-based 
obligation acceleration (Theorem \ref{thm:satoa}) dramatically performs well on satisfiable formulas. 
For unsatisfiable cases, Theorem \ref{thm:satunsat} contributes two best results on 
\textsf{schuppan/O1formula} and \textsf{schuppan/O2formula} patterns. Compared to our previous 
version, \Aalta\_v0.2 has improved more than 3 times for the whole unsatisfiable cases. (See the 
last two cells in the last row.) So the heuristics is also very useful. 

\begin{figure}
\centering
\includegraphics[scale = 0.8]{random}
\caption{Experimental results on extended random formulas with 3 variables.}
\label{fig:random}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale = 0.8]{random_conjunction}
\caption{Experimental results on random conjunction formulas.}
\label{fig:random_conjunction}
\end{figure} 




\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.5]{polsat_sat}
\caption{Polsat improvement on extended satisfiable random formulas with 3 variables.}
\label{fig:polsat_sat}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.5]{polsat_unsat}
\caption{Polsat improvement on extended unsatisfiable random formulas with 3 variables.}
\label{fig:polsat_unsat}
\end{minipage}
\end{figure}
\fi


To test the scalability of solvers, we use large random patterns 
including both \textit{random formulas} and \textit{random
  conjunction formulas} (the length of formula is from 100 to
200). The results are shown in Fig. \ref{fig:random} and
Fig. \ref{fig:random_conjunction} respectively. Note the figures are drawn by 
Cactus Plot\footnote{\url{http://en.wikipedia.org/wiki/Cactus_graph}}, in 
which the ordering of formula lengths is missing but preserves the one of checking costs. 
That means, the Y axis in the figures represent the checking cost for a group of formulas (500 cases), and the X axis represent the resorted instances (groups with different lengths) by 
the corresponding costs. Using this drawing style one can see clearly the increasing trends of 
the checking cost for each solver. 

In Fig. \ref{fig:random} and Fig. \ref{fig:random_conjunction}, we do not
separate the satisfiable and unsatisfiable cases.  From
Fig. \ref{fig:random}, one can see the tremendous improvement of total
performance by our proposed SAT-based checking framework. (From the
huge gap between the results from \Aalta\_v0.1 and
\Aalta\_v0.2.). Secondly, it shows that \Aalta\_v0.2 has the best
performance for large random formulas. From
Fig. \ref{fig:random_conjunction}, our new tool achieves almost the
best for random conjunction ones -- here ls4 and NuSMV-BDD can be competitive
with \Aalta\_v0.2 from the results. Based on these experiments above,
it shows that our approach has a good advantage on random pattern
formulas.



As mentioned earlier, Polsat is not only a testing platform for LTL satisfiability
solvers, but also a portfolio solver which provides the best result by integrating other solvers. We also would like to know   how much the performance of Polsat is improved via integrating \Aalta\_v0.2 in replace of \Aalta\_v0.1.  We can also see the direct results from Table \ref{tab:schuppan-collected}: for those cases \Aalta\_v0.2 gets best, there
can be even 10 times speedup in Polsat with \Aalta\_v0.2 (see \textsf{schuppan/O1formula},
\textsf{schuppan/O2formula} patterns and etc.). Moreover, Fig. \ref{fig:polsat_sat} and
\ref{fig:polsat_unsat} show the performance comparison between Polsat with \Aalta\_v0.1/\Aalta\_v0.2 on
extended satisfiable/unsatisfiable random formulas. These two figures are also drawn by Cactus Plot. The experiments show the new proposed SAT-based approach boosts the performance of Polsat  by 30\% to 60\% on average for the random formulas. 


From the statistics above, knowing how other tools perform in their best cases may help to improve our algorithms, and we leave 
it to future work here. 


\begin{figure}
\centering
\includegraphics[scale = 0.75]{polsat_sat}
\caption{Polsat improvement on extended satisfiable random formulas with 3 variables.}
\label{fig:polsat_sat}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale = 0.75]{polsat_unsat}
\caption{Polsat improvement on extended unsatisfiable random formulas with 3 variables.}
\label{fig:polsat_unsat}
\end{figure}

\fi















\section{Experiments}\label{sec:exp}

In this section we first introduce the experimental approach, and then 
present the results.  

\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.53]{Qformulas}
\caption{Experimental results on Q pattern formulas ().}
\label{fig:Qformulas}
\vspace{0.3cm}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.53]{O2formulas}
\caption{Experimental results on O2 pattern formulas ().}
\label{fig:O2formulas}

\end{minipage}
\end{figure}
\fi


\begin{table*}
\renewcommand{\arraystretch}{1.3} 
\caption{Comparison results for the \textbf{Schuppan-collected} benchmarks.
Each cell in the table lists the checking time on satisfiable (above) and 
unsatisfiable (below) cases in the given pattern. For some patterns, the 
results on unsatisfiable formulas are empty as no unsatisfiable cases are 
in these patterns.}\label{tab:schuppan-collected}
\centering
\scalebox{1.2}{
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
  \hline
  Formula Type  &  pltl  &  ls4  &  TRP++  &  NuSMV-BDD  &  Aalta\_v0.1  &  Aalta\_v0.2\\
\hline
acacia/demo-v3  &  366.8  & 10.9  & \cellcolor{blue!35} 5.9  &  2753.5  &  1765.4  &  495.8\\

\hline
\multirow{2}{*}{alaska/lift}  &  3615.5  &  2155.4  &  10959.3  &  7214.3  &  5828.8  &  \cellcolor{blue!35}1483.4\\

 & 1264.5 & 302.4 & 1604.1 & \cellcolor{green!35} 44.7 & 1521.8 & 1520.1\\
\hline

anzu/amba  & \cellcolor{blue!35} 605.3  &  3913.8  &  4787.6  &  5524.4  &  3421.1  &  1958.9\\

\hline
anzu/genbuf  &  2849.7  &  3725.7  &  5101.4  &  5759.3  &  6207.7  & \cellcolor{blue!35} 1742.9\\
\hline

rozier/counter  &  \cellcolor{blue!35}1415.3  &  2735.1  &  1570.3  &  1502.1  &  3378.9  &  3562.5\\

\hline
\multirow{2}{*}{rozier/formulas}  &  178.5  & \cellcolor{blue!35} 65.3  &  41922.5  &  2433.5  &  2308.7 &  137.3\\

  & 185.8 & \cellcolor{green!35}1.2 & 312.1 &  3.8 & 124.0 & 93.3\\
\hline

rozier/pattern  &  15.1  &  9105.1  &  9897.3  &  9408.6  &  31.484  &  \cellcolor{blue!35} 14.3\\

\hline
\multirow{2}{*}{schuppan/O1formula}  & \cellcolor{blue!35} 0.3  &  629.8  &  461.9  &  505.8  &  517.1  &  1.5\\

  & 1026.9 & 646.1 & 461.3 & 499.8 & 12.9 & \cellcolor{green!35} 1.1\\
\hline
\multirow{2}{*}{schuppan/O2formula}  & \cellcolor{blue!35} 2.7  &   748.0  &  547.7  &  747.1  &  632.7  &   11.1\\

  & 1081.5 & 1081.4 & 1330.9 & 913.7 & 1351.2 & \cellcolor{green!35} 1.2\\
\hline

\multirow{2}{*}{schuppan/phltl}  &  120.5  &  622.1  &  625.5  &  668.7  &  121.0  & \cellcolor{blue!35} 7.1 \\
 & 300.4  &  455.5  &  241.7  & \cellcolor{green!35} 23.4  &  480.0  &  364.8\\
\hline

\multirow{2}{*}{trp/N5x}  & \cellcolor{blue!35} 2.7  &  41.9  &  127.8  &  5.0  &  1556.7  &  11.3\\

  & 21.7 & \cellcolor{green!35}14.4 & 25.3 &  42.4 & 3669.0 & 1345.3\\
\hline
\multirow{2}{*}{trp/N5y}  & \cellcolor{blue!35} 1.1  &  30.6  &  67.9  &  94.3  &  5715.1  &  6.1\\

  & 2760.3 &   380.9 & \cellcolor{green!35} 16.2 &  18.5 & 6760.6 & 2760.4\\
\hline
\multirow{2}{*}{trp/N12x}  &  10095.9  &  431.1  &  1022.1  &  13326.3  &  14836.4  & \cellcolor{blue!35} 36.2\\

  & 9816.5 & \cellcolor{green!35}334.4 & 570.6 & 9465.0 & 9487.2 &  1623.4\\
\hline
trp/N12y  &  106.5  &  591.6  &  1502.1  &  11547.1  &  8677.8  & \cellcolor{blue!35} 12.4\\

  & 4020.5  &  294.3  &  565.8  & \cellcolor{green!35} 74.9  &  4020.9  &  2020.6\\

\hline
\multirow{2}{*}{Total}  &  19375.9  &  24806.4  &  78288.4  &  61069.8  &  76398.6  & \cellcolor{red!35} 9480.8\\

& 20477.8 &  3555.6 & 5217.0 & 11090.2 & 28428.9 & \cellcolor{red!35} 9730.6\\
\hline

\end{tabular}
}

\end{table*}

\subsection{Experimental Strategies}

We use Rice University's SUG@R cluster\footnote{\url{http://www.rcsg.rice.edu/sharecore/sugar/}} 
as the experimental platform. The cluster contains 134 Sun Microsystems 
SunFire x4150 nodes, each of which includes 8 cores of 2.83GHz Intel Xeon 
Harpertown CPUs with 16GB RAM. In our experiments, we use Polsat as the 
testing platform \cite{LPZVHCoRR13} to compare the tool with other LTL 
satisfiability solvers. Polsat is run on a node of SUG@R, and the tested 
tools, which are integrated into Polsat, occupy each a unique core (the 
number of tools is less than 8). Timeout limit was set to 60 seconds. 

There are two \Aalta\ versions in our experiments: \Aalta\_v0.1 for
the old tool \cite{LZPVH13} and \Aalta\_v0.2 the current one, which implements 
the algorithms described in this paper\footnote{\url{http://www.lab205.org/aalta/}}.  
\Aalta\_v0.2 uses MiniSat \cite{ES03} solver as the SAT solver, and the 
bool2cnf\footnote{\url{http://www-ise4.ist.osaka-u.ac.jp/~t-tutiya/sources/bool2cnf/}}
tool to provide the ``DIMACS CNF'' input format for MiniSat. 
\iffalse
Both these tools are invoked externally. That is, \Aalta\_v0.2 provides 
the input for bool2cnf, the output of bool2cnf is the input of MiniSat, 
and then \Aalta\_v0.2 obtains Minisat's output for further processing. 
(We plan full integration when the new tool is released. These two 
tools are purely invoked and not parameters are used.  
\fi 
Several other LTL satisfiability solvers are also involved in the
experiments. Among them, the pltl tool\footnote{Three tool versions can be found at 
\url{http://users.cecs.anu.edu.au/~rpg/PLTLProvers/}; we use the first one, 
following \cite{SD11}.} 
\cite{Sch98} is the representative of tableau-based approach; 
the TRP++ tool \cite{HK03} implements a temporal-resolution strategy; 
the NuSMV tool \cite{CCGGPRST02} uses a model-checking-based method. 
Since NuSMV applies BDD technique, we use NuSMV-BDD to denote it. 
We did not use here NuSMV-BMC (bounded model checking), which can be used 
to check satisfiability, but fails to check unsatisfiability.
We also did not use here the Alaska tool~\cite{DDMR08}, which is the
implementation of antichain-based checking, as it fails to run on SUG@R. 
We did use the fairly recent ls4 tool, which is a SAT-based PLTL 
prover\cite{SW12}\footnote{\url{http://www.mpi-inf.mpg.de/~suda/ls4.html}}. 
The input of ls4 is the same as that of TRP++. 
Since the input of TRP++ must be in SNF (Separated Normal Form 
\cite{Fish97}), a SNF generator is also required. 
The \textit{translate} generator is available from the TRP++ website\footnote{\url{http://cgi.csc.liv.ac.uk/~konev/software/trp++/}}. 

The tools introduced above use several parameters and their performance may
vary on their selection.  In \cite{SD11}, Schuppan and Darmawan collected 
the winning configurations for each tool.  Some of the parameters in these 
configurations are not, however, available in the tools' new versions; 
instead we chose the parameters that are the closest to the ones in the 
winning configurations. Specifically, for pltl we used the ``-tree'' 
parameter;  for TRP++ we used ``-sBFS -FSR''; for the SNF generator 
\textit{translate} we used ``-s -r''; for NuSMV-BDD we used 
``-dcx -f -flt -dynamic''; and for ls4 we used ``-r2l''. In our experiments,
pltl, TRP++, NuSMV and ls4 versions are r1424, 2.2, 2.5.4 and 1.0.1, 
respectively. 

In the experiments we consider all benchmarks from \cite{RV10,SD11,LZPVH13}.
For simplicity, we call the formulas from \cite{SD11} as 
\textit{schuppan-collected} benchmarks in the following. This benchmark 
contains a total amount of 7446 formulas. To test the scalability of the 
tools on random formulas, we followed \cite{RV10} with length varying from 
100 to 200 and variables number set to 3. For each length we tested a group
of 500 formulas.  We also tested the \textit{random conjunction formulas} 
introduced in \cite{LZPVH13}. A random conjunction has the form of 
, where each  is a 
\emph{specification pattern} randomly chosen from \cite{DAC98}\footnote{\url{http://patterns.projects.cis.ksu.edu/documentation/patterns/ltl.shtml}},
where  here varies from 1 to 20 and for each  we created 500 cases. 
In summary, we tested the tools on approximately 50 patterns and 27,446 
formulas. We do not find any inconsistency among the results from different
tools.

\subsection{Experimental Results}

\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.52]{random}
\caption{Experimental results on extended random formulas with 3 variables.}
\label{fig:random}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.52]{random_conjunction}
\caption{Experimental results on random conjunction formulas.}
\label{fig:random_conjunction}
\vspace{0.3cm}
\end{minipage}
\end{figure}
\fi





Table \ref{tab:schuppan-collected} shows the evaluation results on 
formulas from the \textit{schuppan-collected} benchmark.
The first column lists the pattern types, and the second to seventh columns
show the checking time (seconds) of various solvers on each pattern, 
respectively.  Normally, a test benchmark of the given pattern involves two
types of formulas: satisfiable and unsatisfiable ones. We separate them in 
two rows for each entry of benchmark pattern: the upper one is the
checking time for satisfiable formulas and the lower one for
unsatisfiable formulas. Some patterns, however, do not have
unsatisfiable formulas in their data set; we just keep one row in the
table for these patterns, such as \textsf{acacia/demo-v3} and
\textsf{anzu/amba} patterns. We ignored those patterns that cannot 
be decided within the timeout by all solvers.  We also ignored those 
patterns that can be solved within 10 second by all solvers.
We highlight the entry of the best checking result for each pattern: 
blue for satisfiable cases and green for unsatisfiable cases. 

\begin{figure}
\centering
\includegraphics[scale = 0.8]{random}
\caption{Experimental results on extended random formulas with 3 variables.}
\label{fig:random}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale = 0.8]{random_conjunction}
\caption{Experimental results on random conjunction formulas.}
\label{fig:random_conjunction}
\end{figure}


From Table~\ref{tab:schuppan-collected}, we can see that the  proposed 
SAT-based approach dramatically improves the performance of the 
obligation-based satisfiability checking method of previous 
work~\cite{LZPVH13}. For instance, compared to \Aalta\_v0.1, \Aalta\_v0.2 
has a nearly 1000X speedup for the satisfiable cases in 
\textsf{trp/N5y}, and nearly 500X speedup for the unsatisfiable cases in
\textsf{schuppan/O2formula}. In total, \Aalta\_v0.2 performs about 5 times 
better than \Aalta\_v0.1.



Although the experiments confirms the fact that none of investigated solvers
dominates across all patterns, the new tool (\Aalta\_v0.2) has the most 
``wins'' with 8 best results, while pltl has 6 best results, ls4 has 4 best
results, NuSMV-BDD has 3 and TRP++ has another 2 best results. 
Moreover, \Aalta\_v0.2 has the best total time performance,
with the ls4 tool in the second place.


 

\iffalse
\begin{figure}[t]
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.5]{polsat_sat}
\caption{Polsat improvement on extended satisfiable random formulas with 3 variables.}
\label{fig:polsat_sat}
\end{minipage}
\hspace{0.6cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\includegraphics[scale = 0.5]{polsat_unsat}
\caption{Polsat improvement on extended unsatisfiable random formulas with 3 variables.}
\label{fig:polsat_unsat}
\end{minipage}
\end{figure}
\fi

To test the scalability of solvers, we use large random formulas, 
including both \textit{random formulas} and 
\textit{random conjunction formulas}.
The results are shown in Fig. \ref{fig:random} and
Fig. \ref{fig:random_conjunction}, respectively. (We show cactus plots\footnote{\url{http://en.wikipedia.org/wiki/Cactus_graph}}, 
where the -axis sorts the instances (a suite of 500 formulas) by 
hardness rather than by length.
Here we do not separate satisfiable and unsatisfiable formulas.

In Fig. \ref{fig:random} one can see the significant improvement 
by the new SAT-based checking framework. (See the gap between the results 
from \Aalta\_v0.1 and \Aalta\_v0.2.). It also see that \Aalta\_v0.2 has 
the best performance for large random formulas. 
In Fig. \ref{fig:random_conjunction} we see that the new tool is almost
best for random conjunction formulas; ls4 and NuSMV-BDD can be competitive
with \Aalta\_v0.2. 

As mentioned earlier, Polsat is not only a testing platform for LTL 
satisfiability solvers, but also a portfolio solver that provides the best 
result by integrating several solvers. We want like to know  how much the 
performance of Polsat is improved via integrating \Aalta\_v0.2 to replace 
\Aalta\_v0.1.  The answer is available in 
Table \ref{tab:schuppan-collected}. For those cases where \Aalta\_v0.2 is
best, there can be a 10X speedup in Polsat with \Aalta\_v0.2;
see \textsf{schuppan/O1formula} and \textsf{schuppan/O2formula} patterns.
\ref{fig:polsat_unsat} show the performance comparison between Polsat with 
\Aalta\_v0.1/\Aalta\_v0.2 on extended satisfiable/unsatisfiable random 
formulas (with lengths from 100 to 200). 
The plots show that the new proposed SAT-based approach boosts the 
performance of Polsat  by 30\% to 60\% on average for random formulas. 

\begin{figure}
\centering
\includegraphics[scale = 0.75]{polsat_sat}
\caption{Polsat improvement on extended satisfiable random formulas with 3 variables.}
\label{fig:polsat_sat}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale = 0.75]{polsat_unsat}
\caption{Polsat improvement on extended unsatisfiable random formulas with 3 variables.}
\label{fig:polsat_unsat}
\end{figure}


\section{Discussion and Related Work}\label{sec:related} 

The satisfiability-checking framework proposed in this paper is based on LTL 
\textit{normal forms}, which follows the traditional tableau-based expanding 
rules \cite{GPVW95}. By iteratively utilizing the normal-form generation we can 
obtain a \textit{transition system} for a given formula. 
Based on that, a decision procedure leveraging the power of modern SAT solvers is 
achieved, in which the \textit{obligation formula} plays the crucial role. 
It should be mentioned, however that a \emph{tagging} process is required to 
complete this approach.  For example consider , in which 
the atom  appears twice.  Without tagging, we can see that there exists a transition
, which forms a SCC , and
 is a superset of the obligation . 
But, obviously, the infinite path through this SCC can not satisfy
. This problem can be solved by tagging the input formula. To simplify 
the presentation here, we omit the details in this paper and refer readers to 
our previous work \cite{LZPVH13}.
  
Several similar ideas about the normal form and transition system are also used 
in other works.  For example, Gerth et al. pointed out every LTL formula has an 
equivalent form of , when they proved the correctness 
of their LTL-to-GBA (Generalized B\"uchi Automata) translation \cite{GPVW95}. 
Also Duan et al. proposed a similar normal form and normal form graph for PPTL, 
which is considered as a superset of LTL\cite{DTZ08}.  Based on these two concepts, 
they presented a decision procedure for PPTL that can be used in both model checking 
and satisfiability checking. Compared to their work, our contribution 
is the obligation-formula-based checking and the heuristics that can utilize SAT solving. 
We also provide a detailed performance evaluation, which is not included in \cite{DTZ08}.

Bounded model checking (BMC) is the first approach that reduces model checking into SAT 
framework \cite{CBRZ01,CPRS02}. It encodes both the system and property symbolically, and 
unrolls the system step by step to check whether the property is satisfied. As one can keep
unrolling, this approach does not terminate, and one has to select an upper bound
 for unrolling to obtain termination. In the context of LTL satisfiability checking,
BMC provides a method for detecting satisfiability, but not for detecting unsatisfiability.
To overcome this shortage of BMC, full SAT-based model-checking techniques need to be explored. 

Interpolation model checking (IMC) \cite{McM03} extends BMC by separating the -reachability formula
steps into two parts, and generates an interpolant from these sets if the formula is unsatisfiable. 
Here the bound  also needs to be repeatedly incremented, but, unlike BMC, this method is
guaranteed to terminate \cite{McM03}. Other SAT-based model checking techniques are evaluated
in \cite{ADKKM05}, where it is shown that no method dominates across all benchmarks.
One way to obtain a complete SAT-based model checker is by finding the ``threshold''  such 
that  holds: here  is the system model and  is 
a property \cite{CKOS05}. This threshold, however, can be exponential in the size of the system
and the property, and this method does not perform well in practice.

In the experimental part we compare our tool with ls4, which is considered as a SAT-based PLTL prover \cite{SW12}. 
The approach behind the tool does not directly work on PLTL but requires the SNF (Separated Normal Form \cite{Fish97}) input. The 
interesting observation in this strategy is that, the BMC process can become complete by facilitating the SNF's structural 
features. It then takes such a complete SAT-based checking as a ``block'' and successfully extends its application from 
reachability cases to general ones. Our experiments above confirm that this approach performs well on unsatisfiability 
checking. 

Recently IC3 \cite{Bra11} emerged as a popular full SAT-based model-checking technique. 
This approach does not need to unroll the system more than one step, and it keeps an 
inductive invariant inductively during the checking process until the invariant finally 
reaches the desired property. In other words, it gradually checks whether there exist states 
in the system falsifying the property, and if so the algorithm returns false, otherwise 
returns true after exploring the whole system. Thus IC3 has the advantage that it checks also 
unsatisfiable cases.  (Note that both IMC and IC3 were proposed for checking safety properties 
first, and afterwards adapted to check the liveness ones by using the techniques shown in \cite{BAS02} and \cite{BSHZ11}.)

Compared to IMC and IC3, ours approach uses explicitly formula expanding instead of over-approximate 
inductive invariants. So the states information are stored during our checking process, easily making
it complete. In our approach, SAT invoking occurs when we extract the obligation formula (or its variant) 
from each expanded state. Hence our approach is hybrid, combining the explicit and symbolic ways together. 
Moreover, our approach applies for the whole LTL class, while IMC and IC3 are directly applicable
only for safety checking, as mentioned above. In this paper we compare our method with all LTL 
satisfiable-checking algorithms appearing in \cite{SD11} and find it is quite efficient. We leave to
future work to set up a comprehensive comparison with the full SAT-based model checking approaches 
such as IMC and IC3. And the comparison on SAT solver invoking times among different solvers will 
also be involved, which is well concerned in SAT community.

 

\section{Conclusion}\label{sec:con}

In this paper we proposed a fully-SAT-based LTL-satisfiability-checking approach. Our experiments show the new method significantly improves
the performance of Polsat, a portfolio-based LTL satisfiability solver. Thus, we believe that SAT-based LTL satisfiability checking has a promising future.

\section{Acknowledgement}
The authors are thankful for valuable comments and tool guidance from Rajeev Gor\'e, Ullrich Hustadt and Victor Schuppan. 

\bibliographystyle{plain}
\bibliography{ok,cav}

\end{document}
