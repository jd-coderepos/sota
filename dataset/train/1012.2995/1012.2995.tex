\documentclass[10pt,twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{tabularx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[usenames]{color}
\usepackage{multirow}
\usepackage{url}
\usepackage{epic}
\usepackage{eepic}
\usepackage{stmaryrd}

\newlength{\innerboxwidth}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{property}{Property}
\newtheorem{notation}{Notation}
\newtheorem{fact}{Fact}

\newcommand{\comment}[1]{}
\newcommand{\RESULT}{\textbf{result}}
\newcommand{\Req}{\mathit{req}}
\newcommand{\Ens}{\mathit{ens}}
\newcommand{\Exs}{\mathit{exs}}
\newcommand{\Pre}{\mathit{pre}}
\newcommand{\Post}{\mathit{post}}
\newcommand{\Inv}{\phi}
\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}
\newcommand{\WP}{{\it wp}}
\newcommand{\DEFS}{\mathit{defs}}
\newcommand{\SHIFT}{\mathit{shift}}
\newcommand{\IF}{\mbox{\sc if}}
\newcommand{\UNSHIFT}{\mathit{unshift}}
\newcommand{\VAL}{{\it val}}
\newcommand{\SELECT}{\mbox{\sc select}}
\newcommand{\TYPEOF}{{\it typeof}}
\newcommand{\EXCEPTIONAL}{\mathit{exceptional}}
\newcommand{\ANNO}{\mathit{anno}}
\newcommand{\SIMP}{\mathit{simp}}
\newcommand{\IL}{\mathit{IL}}
\newcommand{\COLLAPSE}{\mathit{collapse}}
\newcommand{\ghost}[1]{{\it #1}^g}
\newcommand{\VC}{{\it VC}}

\newcommand{\MS}{{\bf ms}}

\newcommand{\cmAF}{c.m^{\it af}}
\newcommand{\cmEX}{c.m^{\it ex}}
\newcommand{\cmBF}{c.m^{\it bf}}

\newcommand{\say}[3]{~\\
    \framebox[.9\linewidth]{\parbox{.85\linewidth}{\color{#1}#2 #3}}~\\}
\newcommand{\mads}[1]{\say{Blue}{Mads says:}{#1}}
\newcommand{\andreas}[1]{\say{Red}{Andreas says:}{#1}}

\newcommand{\figframe}[1]{\setlength{\fboxsep}{0.3cm}
\addtolength{\innerboxwidth}{\textwidth}
\addtolength{\innerboxwidth}{-2\fboxsep}
\framebox{\parbox{\innerboxwidth}{#1}}}















\newcommand{\True}{\mbox{\it tt}}
\newcommand{\False}{\mbox{\it  ff}}

\newcommand{\Int}{\mbox{\tt int}}
\newcommand{\String}{\mbox{\tt string}}
\newcommand{\Void}{\mbox{\tt Void}}
\newcommand{\classes}{\mathbb{C}}
\newcommand{\methods}{\mathbb{M}}
\newcommand{\fields}{\mathbb{F}}
\newcommand{\heaps}{\mathbb{H}}
\newcommand{\Objects}{\mathbb{O}}
\newcommand{\Object}{o}
\newcommand{\PrimType}{\mathit{PrimType}}
\newcommand{\Type}{\mathit{Type}}
\newcommand{\type}{\mathit{type}}
\newcommand{\void}{\mathit{void}}
\newcommand{\defines}{\mathit{defines}}
\newcommand{\Dom}{\mathit{Dom}}
\newcommand{\Val}{\mathit{Val}}
\newcommand{\PrimVal}{\mathit{PrimVal}}
\newcommand{\ADDR}{\mathit{ADDR}}
\newcommand{\PC}{\mathit{pc}}
\newcommand{\LV}{\mathit{lv}}
\newcommand{\sg}{\mathit{sg}}
\newcommand{\Init}{\mathit{Init}}
\newcommand{\loca}{\ell}
\newcommand{\Act}{\mathit{act}}
\newcommand{\Extract}{\mathit{extract}}
\newcommand{\Stack}{\mathrm{s}}
\newcommand{\Annot}{A}
\newcommand{\Requires}{\mathit{Requires}}
\newcommand{\Exsures}{\mathit{Exsures}}
\newcommand{\Ensures}{\mathit{Ensures}}
\newcommand{\Assert}{\mathit{Assert}}

\newcommand{\SRA}{\mathit{SRA}}
\newcommand{\Method}{M}
\newcommand{\Unhandled}{\mathit{Unhandled}}
\newcommand{\Defined}{\mathit{Defined}}
\newcommand{\unhandled}{\mathit{Unhandled}}
\newcommand{\Heap}{\mathit{heap}}
\newcommand{\this}{\mathrm{this}}
\newcommand{\pc}{\mathrm{pc}}
\newcommand{\ttiny}[1]{\tiny{\texttt{#1}}}

\newcommand{\transJVM}{\rightarrow_{\mbox{\scriptsize{JVM}}}}

\newcommand{\staticfieldref}[3]{ \{\!|#1, #2, #3|\!\}_{\mathrm{SF}}}

\newcommand{\tupled}[1]{(#1)}
\newcommand{\vect}[1]{\overrightarrow{#1}}
\newcommand{\methodref}[3]{\{\!|#1, #2, #3|\!\}_{\mathrm{M}}}
\newcommand{\methodrefprime}{\methodref{c}{m'}{\Upsilon \rightarrow \gamma}}
\newcommand{\pmethodref}[1]{\methodref{#1}{m}{\Upsilon \rightarrow \gamma}}
\newcommand{\noargmethodref}{\methodref{c}{m}{\epsilon \rightarrow \gamma}}
\newcommand{\intmethodref}{\methodref{c}{m}{\Upsilon \rightarrow \int}}
\newcommand{\voidmethodref}{\methodref{c}{m}{\Upsilon \rightarrow \void}}
\newcommand{\noargvoidmethodref}{\methodref{c}{m}{\epsilon \rightarrow \void}}
\newcommand{\anymethodref}{\methodref{c}{m}{\Upsilon \rightarrow \gamma}}
\newcommand{\anypmethodref}{\methodref{c'}{m'}{\Upsilon \rightarrow \gamma}}
\def\invokevirtual{\texttt{invokevirtual }}
\def\invokespecial{\texttt{invokespecial }}
\def\getfield{\texttt{getfield}}
\def\putfield{\texttt{putfield}}
\def\getstatic{\texttt{getstatic}}
\def\putstatic{\texttt{putstatic}}
\def\istore{\texttt{istore}}
\def\iload{\texttt{iload}}
\def\astore{\texttt{astore}}
\def\aload{\texttt{aload}}
\def\return{\texttt{return}}
\def\ireturn{\texttt{ireturn}}
\def\areturn{\texttt{areturn}}

\newcommand{\before}{\mathrm{before}}
\newcommand{\after}{\mathrm{after}}
\newcommand{\exc}{\mathrm{exc}}
\newcommand{\BEFORE}{\texttt{BEFORE}}
\newcommand{\AFTER}{\texttt{AFTER}}
\newcommand{\EXC}{\texttt{EXCEPTIONAL}}

\newcommand{\bmid}{\mid}
\newcommand{\Wrong}{\bot}

\newcommand{\BinOp}{\circ}
\newcommand{\BinRel}{\mathit{r}} 

\newcommand{\Sem}[1]{\mbox{}{{#1}}\mbox{}}
\newcommand{\Length}{\mbox{lth}}
\newcommand{\Null}{\mbox{\it null}}
\newcommand{\Alength}{\mbox{\it length}}
\newcommand{\Array}{\mbox{\it array}}

\newcommand{\ArrayIndexOutOfBoundsExc}{\mbox{ArrayIndexOutOfBoundsException}}
\newcommand{\ArrayStoreExc}{\mbox{ArrayStoreException}}
\newcommand{\NullPointerExc}{\mbox{NullPointerException}}
\newcommand{\NegativeArraySizeExc}{\mbox{NegativeArraySizeException}}
\newcommand{\Update}{\mbox{\it upd}}
\newcommand{\ArithExc}{\mbox{ArithmeticException}}
\newcommand{\Matches}{\mbox{\it matches}}
\newcommand{\ClearStack}{\mbox{\it clr}}
\newcommand{\Size}[1]{\mbox{}{#1}\mbox{}}
\newcommand{\Local}{\mathrm{l}}
\newcommand{\Ast}{\mbox{\it Assertion}}
\newcommand{\SRT}{\mathit{SRT}}

\newcommand{\Policy}{\mathcal{P}}
\newcommand{\Contract}{\mathcal{C}}

\newcommand{\transAUT}[1]{\stackrel{{#1}}{\longrightarrow}}

\newcommand{\Inline}{{\cal I}}
\newcommand{\GI}{\ghost{\Inline}}


\bibliographystyle{plain}

\begin{document}

\title{A Proof Carrying Code Framework for Inlined Reference Monitors in Java Bytecode}

\author{Mads Dam, Andreas Lundblad\\Royal Institute of Technology, KTH}

\maketitle

\begin{abstract}
We propose a light-weight approach for certification of monitor inlining 
for sequential Java bytecode using proof-carrying code. The goal is to 
enable the use of monitoring for quality assurance at development time, 
while minimizing the need for post-shipping code rewrites as well as 
changes to the end-host TCB. Standard automaton-based security policies 
express constraints on allowed API call/return sequences. Proofs are
represented as JML-style program annotations. This is adequate in our
case as all proofs generated in our framework are recognized in time
polynomial in the size of the program. Policy adherence is proved
by comparing the transitions of an inlined monitor with those of a 
trusted ``ghost'' monitor represented using JML-style annotations.
At time of receiving a 
program with proof annotations, it is sufficient for the receiver to plug 
in its own trusted ghost monitor and check the resulting verification 
conditions, to verify that inlining has been  performed correctly, of the 
correct policy. We have proved correctness of the approach at the Java 
bytecode level and formalized the proof of soundness in Coq. An
implementation, including an application loader running on a mobile device, 
is available, and we conclude by giving benchmarks for two sample applications.
\end{abstract}



\section{Introduction}
Program monitoring \cite{Lig06,javamac,javamop} is a well-established technique for software quality assurance, used for a wide range of purposes such as performance monitoring, protocol compliance checking, access control, and general security policy enforcement. The conceptual model is simple: Monitorable events by a client program are intercepted and routed to a decision point where the appropriate action can be taken, depending on policy state such as access control lists, or on application history. This basic setup can be implemented in a huge variety of ways. In this paper our focus is monitor inlining \cite{ErlSch00}. In this approach, monitor functionality is weaved into client code in AOP style, with three main benefits:
\begin{itemize}
\item Extensions to the TCB needed for managing execution of the client, intercepting and routing events, and policy decision and enforcement are to a large extent eliminated.
\item Overhead for marshalling and demarshalling policy information between the various decision and enforcement points in the system is eliminated.
\item Moreover, there is no need to modify and maintain a custom API or Virtual Machine.
\end{itemize}
This, however, presupposes that the user can trust that inlining has been
performed correctly. This is not a problem if the inliner is known to be
correct, and if inlining is performed within the users jurisdiction.
But it could of interest to make inlining available as a quality assurance
tool to third parties (such as developers or operators) as well. In this
paper we examine if proof-carrying code can be used to this effect in the
context of Java and mobile applications, to enable richer, history-dependent
access control than what is allowed by the current, static sandboxing regime.

Our approach is as follows: We assume that J2ME applications
are equipped with {\em contracts} that express the provider commitments on
allowed sequences of API calls performed by the application. Contracts are given as security automata in 
the style of Schneider \cite{Sch00} in a simple contract specification 
language ConSpec \cite{AktNal07}.  The contract is compiled into bytecode and inlined
into the application code as in PoET/PSLang \cite{ErlSchb00}, and a proof
is generated asserting that the inlined program adheres to the contract,
producing in the end a self-certifying code ``bundle'' consisting of the 
application code, the contract, and an embedded proof object.

Upon reception the remote device first determines whe\-ther the received
bundle should be accepted for execution, by comparing the received
contract with the device policy. This test uses a simulation or language 
containment test, and is explored in detail by K. Naliuka et al. \cite{Bielova2009340}. 

The contribution of this paper is the efficient representation, generation, 
and checking of proof objects. The key idea is to compare the 
effects of the inlined, untrusted, monitor with a ``ghost''  monitor
which implements the intended contract. A ghost monitor is 
a virtual monitor which is never actually executed, and which is represented
using program annotations.
Such a ghost monitor is readily available by simply interpreting the 
statements of the ConSpec contract as monitor updates performed before 
and after security relevant method calls. No JVM compilation is required 
at this point, since these updates are present solely for proof 
verification purposes.

The states of the two monitors are compared statically through a 
{\em monitor invariant}, expressing that the state of the embedded 
monitor is in synchrony with that of the ghost monitor. This monitor 
invariant is then inserted as an assertion at each security relevant method call. The assertions for the remaining program points could then in principle 
be computed using a weakest pre-condition (WP) calculus. Unfortunately, 
there is no guarantee that such an approach would be feasible. 
However, it turns out that it is sufficient to perform the WP computations 
for the inlined code snippets and not for the client code, under some 
critical assumptions:
\begin{itemize}
\item The inlined code appears as contiguous subsequences of the entire 
instruction sequences in the inlined methods.
\item Control transfers in and out of these contiguous code snippets are allowed 
only when the monitor invariant is guaranteed to hold.
\item The embedded monitor state is represented in such a way that a 
simple syntactic check suffices to determine if some non-inlined 
instruction can have an effect on its value.
\end{itemize}
The last constraint can be handled, in particular, by implementing the 
embedded monitor state as a static member of a final security state class. 
The important consequence is that instructions that do not appear in 
the inlined snippets, and do not include {\tt putstatic} instructions to 
the security state field, may  be annotated with the monitor invariant 
to obtain a fully annotated program. This means, in particular, that a simple 
syntactic check is sufficient to eliminate costly WP checks in almost all 
cases and allows a very open-ended treatment of the JVM instruction set. 

The resulting annotations are 
locally valid in the sense that method pre- and post-conditions match, 
and that each program point annotation follows from successor point 
annotations by elementary reasoning. This allows to robustly and efficiently
generate and check assertions using a standard verification condition (VC) 
approach, as indicated in Figure \ref{fig:framework}.

\begin{figure}[ht]
\centering\scriptsize
\ifx\JPicScale\undefined\def\JPicScale{1}\fi
\unitlength \JPicScale mm
\begin{picture}(81.25,70)(0,0)
\put(7.5,62.5){\makebox(0,0)[cc]{Bytecode}}

\put(22.5,62.5){\makebox(0,0)[cc]{Contract}}

\linethickness{0.3mm}
\put(7.5,55){\line(0,1){5}}
\put(7.5,55){\vector(0,-1){0.12}}
\linethickness{0.3mm}
\put(22.5,55){\line(0,1){5}}
\put(22.5,55){\vector(0,-1){0.12}}
\put(15,52.5){\makebox(0,0)[cc]{Inliner}}

\put(15,12.5){\makebox(0,0)[cc]{Proof Generator}}

\linethickness{0.3mm}
\put(1.25,15){\line(1,0){27.5}}
\put(1.25,10){\line(0,1){5}}
\put(28.75,10){\line(0,1){5}}
\put(1.25,10){\line(1,0){27.5}}
\linethickness{0.3mm}
\put(15,45){\line(0,1){5}}
\put(15,45){\vector(0,-1){0.12}}
\put(15,42.5){\makebox(0,0)[cc]{Inlined Classes}}

\linethickness{0.3mm}
\put(15,35){\line(0,1){5}}
\put(15,35){\vector(0,-1){0.12}}
\put(15,32.5){\makebox(0,0)[cc]{Ghost Annotator}}

\linethickness{0.3mm}
\put(15,25){\line(0,1){5}}
\put(15,25){\vector(0,-1){0.12}}
\put(15,22.5){\makebox(0,0)[cc]{Classes + Ghost monitor}}

\linethickness{0.3mm}
\put(15,15){\line(0,1){5}}
\put(15,15){\vector(0,-1){0.12}}
\put(15,22.5){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\put(1.25,35){\line(1,0){27.5}}
\put(1.25,30){\line(0,1){5}}
\put(28.75,30){\line(0,1){5}}
\put(1.25,30){\line(1,0){27.5}}
\linethickness{0.3mm}
\put(1.25,55){\line(1,0){27.5}}
\put(1.25,50){\line(0,1){5}}
\put(28.75,50){\line(0,1){5}}
\put(1.25,50){\line(1,0){27.5}}
\put(67.5,52.5){\makebox(0,0)[cc]{Ghost Annotator}}

\put(67.5,12.5){\makebox(0,0)[cc]{VC Checker}}

\linethickness{0.3mm}
\put(53.75,15){\line(1,0){27.5}}
\put(53.75,10){\line(0,1){5}}
\put(81.25,10){\line(0,1){5}}
\put(53.75,10){\line(1,0){27.5}}
\linethickness{0.3mm}
\put(67.5,45){\line(0,1){5}}
\put(67.5,45){\vector(0,-1){0.12}}
\put(67.5,42.5){\makebox(0,0)[cc]{Classes + Ghost monitor}}

\linethickness{0.3mm}
\put(75,35){\line(0,1){5}}
\put(75,35){\vector(0,-1){0.12}}
\put(67.5,32.5){\makebox(0,0)[cc]{VC Generator}}

\linethickness{0.3mm}
\put(67.5,25){\line(0,1){5}}
\put(67.5,25){\vector(0,-1){0.12}}
\put(67.5,22.5){\makebox(0,0)[cc]{Verification Conditions}}

\linethickness{0.3mm}
\put(67.5,15){\line(0,1){5}}
\put(67.5,15){\vector(0,-1){0.12}}
\put(67.5,22.5){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\put(53.75,35){\line(1,0){27.5}}
\put(53.75,30){\line(0,1){5}}
\put(81.25,30){\line(0,1){5}}
\put(53.75,30){\line(1,0){27.5}}
\linethickness{0.3mm}
\put(53.75,55){\line(1,0){27.5}}
\put(53.75,50){\line(0,1){5}}
\put(81.25,50){\line(0,1){5}}
\put(53.75,50){\line(1,0){27.5}}
\linethickness{0.3mm}
\put(15,5){\line(0,1){5}}
\put(15,5){\vector(0,-1){0.12}}
\put(15,2.5){\makebox(0,0)[cc]{Adherence Proof}}

\put(15,2.5){\makebox(0,0)[cc]{}}

\linethickness{0.3mm}
\put(67.5,5){\line(0,1){5}}
\put(67.5,5){\vector(0,-1){0.12}}
\put(67.5,2.5){\makebox(0,0)[cc]{Valid/Invalid}}

\put(67.5,2.5){\makebox(0,0)[cc]{}}

\linethickness{0.15mm}
\put(42.5,0){\line(0,1){70}}
\linethickness{0.15mm}
\multiput(30,42.5)(5,0){2}{\line(1,0){2.5}}
\linethickness{0.15mm}
\multiput(37.5,42.5)(0,5){4}{\line(0,1){2.5}}
\linethickness{0.15mm}
\multiput(37.5,60)(5,0){5}{\line(1,0){2.5}}
\linethickness{0.15mm}
\multiput(60,55)(0,3.33){2}{\line(0,1){1.67}}
\put(60,55){\vector(0,-1){0.12}}
\linethickness{0.15mm}
\multiput(30,62.5)(4.74,0){10}{\line(1,0){2.37}}
\linethickness{0.15mm}
\multiput(75,55)(0,5){2}{\line(0,1){2.5}}
\put(75,55){\vector(0,-1){0.12}}
\linethickness{0.15mm}
\multiput(25,2.5)(3.57,0){4}{\line(1,0){1.79}}
\linethickness{0.15mm}
\multiput(37.5,2.5)(0,4.12){9}{\line(0,1){2.06}}
\linethickness{0.15mm}
\multiput(37.5,37.5)(4.09,0){6}{\line(1,0){2.05}}
\linethickness{0.15mm}
\put(60,35){\line(0,1){2.5}}
\put(60,35){\vector(0,-1){0.12}}
\put(15,70){\makebox(0,0)[cc]{Code Producer}}

\put(67.5,70){\makebox(0,0)[cc]{Code Consumer}}

\end{picture}
 \caption{\label{fig:framework} The architecture of our PCC implementation.}
\end{figure}

Our approach is general enough to handle a wide range of inliners. The developer (who has a better insight in the application in question) is free to tweak the inlining process for his specific application and could for instance optimize for speed in certain security relevant call sites, and for code size elsewhere.



\subsection{Related Work}
Our approach adopts the Security-by-Contract (SxC) para\-digm (cf. \cite{Bielova2009340,DraMasNalSia07,Desmet200825,javamac,javamop}) which has been explored and developed mainly within the SMS project \cite{s3ms}.

Monitor inlining has been considered by a number of authors, cf.~\cite{ErlSch00,ErlSchb00,Erli04,AktDamGur08,VanPie08}.

Erlingsson and Schneider \cite{ErlSchb00} represents security automata directly as Java code snippets, making the resulting code difficult to reason about. The ConSpec contract specification language used here is for tractability restricted to API calls and (normal or exceptional) returns, and uses an independent expression syntax. This corresponds roughly to the call/return fragment of PSLang which includes all policies expressible using Java stack inspection \cite{ErlSch00}.



Edit automata \cite{LigBauWal05,Lig06} are examples of security automata that go beyond pure monitoring, as truncations of the event stream, to allow also event insertions, for instance to recover gracefully from policy violations. This approach has been fully implemented for Java by J. Ligatti et al. in the Polymer tool~\cite{BauLig05} which is closely related to Naccio~\cite{EvaTwy99} and PoET/PSLang~\cite{ErlSchb00}.

Certified reference monitors has been explored by a number of authors, mainly through type systems, e.g. in \cite{SkalkaSmith04,Bauer02typesand,Wal00,HamMor06,RobMan01}, but more recently also through model checking and abstract interpretation \cite{Srid10,Sridb10}. Directly related to the work reported here is the type-based Mobile system due to Hamlen et al. \cite{HamMor06}. The Mobile system uses a simple library extension to Java bytecode to help managing updates to the security state. The use of linear types allows a type system to localize security-relevant actions to objects that have been suitably unpacked, and the type system can then use this property to check for policy compliance. Mobile enforces per-object policies, whereas the policies enforced in our work (as in most work on IRM enforcement) are per session. Since Mobile leaves security state tests and updates as primitives, it is quite likely that Mobile could be adapted, at least to some forms of per session policies. On the other hand, to handle per-object policies our approach would need to be extended to track object references. Finally, it is worth noting that Mobile relies on a specific inlining strategy, whereas our approach, as mentioned in the previous section, is less sensitive to this.

In \cite{Srid10,Sridb10} Sridhar et al. explores the idea of certifying inlined reference monitors for ActionScript using model-checking and abstract interpretations. The approach is not tied to a specific inlining strategy and is general enough to handle different inlining techniques including non-trivial optimizations of inlined code. Although the certification process is efficient, the analysis however, has to be carried out by the consumer.

For background on proof-carrying code we refer to \cite{Nec97}. Our approach is based on simple Floyd-like program point annotations in the style of Bannwarth and M\"uller \cite{BanMue05}, and method specifications extended by pre- and post-conditions in the style of JML \cite{jmldbc}. Recent work related to proof-carrying code for the JVM include \cite{mobiuspcc}, all of which has been developed in the scope of the Mobius project.

An alternative to inline reference monitoring and proof-carrying code, is to produce binaries that are structurally simple enough for the consumer to analyze himself. This is currently explored by B. Chen et al. in the Native Client project~\cite{nacl} which handles untrusted x86 native code. This is done through a customized compile chain that targets a subset of the x86 instruction set, which in effect puts the application in a sandbox. When applicable it has a few advantages in terms of runtime overhead, as it eliminates the monitoring altogether, but is constrained in terms of application and policy complexity.





\subsection{Overview of the Paper}
The JVM machine model is presented in Section 2. In Section 3 the state assertion language is introduced, and in Section 4 we address method and program annotations and give the conditions for (local and global) validity used in the paper. We briefly describe the ConSpec language and (our version of) security automaton in Section 5. The example inlining algorithm is described briefly is Section 6. Section 7 introduces the ghost monitor, and Section 8, then, presents the main results of the paper, namely the algorithms for proof generation and proof recognition, including soundness proofs. Finally, Section 9 reports briefly on our prototype implementation, and we conclude by discussing some open issues and directions for future work.


\section{Program Model}\label{sect:prog_model}
We assume that the reader is familiar with Java bytecode syntax and the Java Virtual Machine (JVM). Here, we only present components of the JVM, that are essential for the definitions in the rest of the text. Much of this is standard and can be skipped in a first reading. A few simplifications have been made in the presentation. In particular we disregard static initializers, and to ease notation a little we ignore issues concerning overloading. We use  for (fully qualified) class names,  for method names, and  for field names. Types are either primitive or object types, i.e. classes, or arrays. Class declarations induce a class hierarchy, denoted by . If  defines  (declares ) explicitly, then  defines (declares)  (). Otherwise,  defines  (declares ) if  is the smallest superclass of  that contains an explicit definition (declaration) of   (). Single inheritance ensures that definitions/declarations are unique, if they exist.

We let  range over the set of all values of all types. Values of object type are (typed) locations, mapped to objects, or arrays, by a heap . The typing assertion  asserts that  is some location , and that in the typed heap ,  is defined and of type , and similarly for arrays. Typing preserves the subclass relation, in the sense that if  and  then  as well. For objects, it suffices to assume that if  then the object  determines a field  (method ) whenever  () is declared (defined) in . Static fields are identified with field references of the form . To handle those, heaps are extended to assignments of values to field references.

A program is a set of classes, and for our purposes each class denotes a mapping from method identifiers to definitions  consisting of an instruction array  and an exception handler array .

We write  to indicate that  and that  is defined and equal to the instruction . The exception handler array  is a list of of exception handlers. An exception handler  catches exceptions of type  and its subtypes raised by instructions in the range  and transfers control to address , if it is the first handler in the handler array that catches the exception for the given type and instruction.

A \emph{configuration} of the JVM is a pair  of a heap  and a stack  of activation records. For normal execution, the activation record at the top of the execution stack has the shape , where  is the currently executing method,  is the program counter,  is the operand stack, and  is the local variable store. Except for API calls (see below) the transition relation  on JVM configurations is standard. A configuration  is {\em calling}, if  is an invoke instruction, and it is {\em returning normally}, if  is a return instruction. For exceptional configurations the top frame has the form  where  is the location of an exceptional object, i.e. of class Throwable. Such a configuration is called {\em exceptional}. We say that  is {\em returning exceptionally} if  is exceptional, and if  implies that  is exceptional as well. I.e. the normal frame immediately succeeding the top exceptional frame in  is popped in , if  is exceptional as well.

An \emph{execution}  of a program  is a (possibly infinite) sequence of JVM configurations  where  is an initial configuration consisting of a single, normal activation record with an empty stack, no local variables,  as a reference to the main method of ,  and for each , . We restrict attention to configurations that are \emph{type safe}, in the sense that heap contents match the types of corresponding locations, and that arguments and return/exceptional values for primitive operations as well as method invocations match their prescribed types. The Java bytecode verifier serves, among other things, to ensure that type safety is preserved under machine transitions.

The only non-standard aspect of  is the treatment of API methods. We assume a fixed API for which we have access only to the signature (types), but not the implementation, of its methods. We therefore treat API method calls as atomic instructions with a non-deterministic semantics. In this sense, we do not practice \emph{complete mediation}~\cite{saltzer75}. When an API method is called either the  is incremented and arguments popped from the operand stack and replaced by an arbitrary return value of appropriate type, or else an arbitrary exceptional activation record is returned. Similarly, 
the return configurations for API method invocations contain an arbitrary heap, since we do not know how API method bodies change heap contents. Our approach hinges on our ability to recognize API calls. This property is destroyed by the \emph{reflect} API, which is consequently not considered.



\section{Assertions}
Annotations are given in a language similar to the one described by F. Y. Bannwart and P. M{\"u}ller in \cite{BanMue05}. 
The syntax of assertions  and (partial) expressions  
are given in the following BNF grammar:
2mm]
a & \True \bmid \False \bmid e\ \BinRel\ e \bmid a \AND a \bmid \neg a \bmid e : c
\end{array} 2mm]
\end{tabular}
}
\caption{\label{fig:conspec_example} A security specification example written in ConSpec.}
\end{figure}


A ConSpec specification tells when and with what arguments an API method 
may be invoked. If the specification has one or more constraints on a 
method, the method is \emph{security relevant}. In 
the example there are two security relevant methods, 
{\tt GUI\!.fileSendQuery} and {\tt Bluetooth\!.\!obexSend}. The specification 
expresses constraints in terms 
{\sc before}, {\sc after} and {\sc exceptional} clauses. Each clause is 
a guarded command where the guards are side-effect free and terminating 
boolean expressions, and the assignment updates the security state. 
Guards may involve constants, method call parameters, object fields, 
and values returned by accessor or test methods that are guaranteed to 
be side-effect free and terminating. Guards are evaluated top to bottom 
in order to obtain a deterministic semantics. If no clause guard holds, 
the policy is violated. In return clauses the guards must be 
exhaustive.


\subsection{Security Automata}
A ConSpec contract determine a security automaton   where  is a countable (not necessarily finite) 
set of states,  is the alphabet of security relevant actions, 
 is the initial state, and  
is the transition function. We assume a special error state 
and view all states in  except  as accepting. We require that
security automata are strict in the sense that .

A security automata is generated by a ConSpec contract in a straightforward manner (cf.~\cite{AktDamGur08}). The alphabet  is partitioned into 
pre-actions (for calls) and (normal or exceptional) post-actions 
(for normal or exceptional returns). Pre-actions have the form 
, normal post-actions have the form 
 and exceptional post-actions have 
the form , where  is the 
relevant API-method,  is the arguments used when 
calling the method, and  is the returned value.

Executions produce security relevant actions in the expected manner.
A calling configuration generates a pre-action determined 
by the called method and the current arguments (top  operand stack 
values for an -ary method). A returning configuration then gives 
rise to a normal post-action determined by the identifier of the 
returning method and the return value (top operand stack value). 
For sake of simplicitly we assume that all API methods return a value. 
An exceptionally returning configuration generates an exceptional 
post-action determined by the method identifier of the returning method. 
The security relevant actions (the security relevant trace) of an 
execution  is denoted by  and formally defined below.

\begin{definition}[Security Relevant Trace] The security relevant trace, 
, of an execution  is defined as
1mm]
    \hspace{4mm} \parbox{5cm}{if  is calling } \1mm]
    \hspace{4mm} \parbox{5cm}{if  is returning  and }\1mm]
    \hspace{4mm} \parbox{5cm}{if  is returning exceptionally and }\
\end{definition}

We generally identify a ConSpec contract with its set of security relevant
traces, i.e. the language recognized by its corresponding security automaton.
A program is said to \emph{adhere} to a contract if all its security 
relevant traces are accepted by the contract.
\begin{definition}[Contract Adherence]
The program  adheres to contract  if for all 
executions  of , .
\end{definition}

\section{Example Inliner}\label{sect:inlining}
In this section we give an algorithm for monitor inlining (from now on referred to as an inlining algorithm, or simply an inliner) in the style of Erlingsson~\cite{ErlSch00}. As previously mentioned, the developer is free to decide what inlining strategy to use, so the algorithm presented here serves merely as an example and does for instance not include any optimizations. For the implementation details and an example, we refer to Appendix \ref{app:example_inliner}.

The inliner traverses the instructions and replaces each invoke instruction with a block of monitoring code. This block of code first stores the method arguments in local variables for use in post-actions. Then the class hierarchy is traversed bottom up for virtual call resolution, and when a match is found the relevant clauses, guards, and updates are enacted. For post-actions the main difference is in exception handling; exceptions are rerouted for clause evaluation, and then rethrown.

We refer to the method resulting from inlining a method  (program ) with a contract  as  (). The main correctness property we are after for inlined code is contract compliance:
\begin{theorem}[Inliner Correctness]
The inlined program   adheres to .
\end{theorem}
\begin{proof}
This follows from the fact that we are always able to generate a valid adherence proof (theorem \ref{thm:proof_generation}) and that the existence of such adherence proof ensures contact adherence (theorem \ref{thm:proof_soundness}). (Both statements are proved in later sections.)
\end{proof}


\section{The Ghost Monitor}
The purpose of the ghost monitor is to keep track of what the embedded
monitor state should be at key points during method execution. This provides
a useful reference for verification. Moreover, since the ghost monitor assigns only to 
special ghost variables that are invisible to the client program, and
since it is incapable of blocking, it does not in fact
have any observable effect on the client program.

The ghost monitor uses
special assignments which we refer to as ghost updates: Guarded multi-assignment 
commands used for updating the state of the ghost monitor and for 
storing method call 
arguments and dynamic class identities in temporary variables.
A ghost update has the 
shape  where  is a tuple of 
ghost variables, special variables used only by the ghost monitor, and 
 is an expression of matching type. Typically, 
 is a conditional of similar shape as the policy expressions, and 
 may mention security state ghost variables as well as other ghost 
variables holding security relevant call parameters. Given the 
post-condition , the weakest pre-condition for the ghost 
instruction  at label  is 
.

The ghost updates are embedded right before and after each security 
relevant invoke instruction as well as in an exception handler catching 
any exception ({\tt Throwable}) thrown by the invoke instruction and 
nothing else. Note that the existence of such an exception handler is 
easily checked, and that the code delivered 
by our inliner always has exception handlers of this form. The details are 
presented in Figure \ref{fig:ghost_embedding}. A method  with ghost 
updates embedded, corresponding to the security automaton of a 
contract  is denoted by .
\begin{figure}
\centering
\begin{tabular}{@{}r@{~}l@{}}
: &  \\
   & \-1.5mm]
                       &  &           & \vdots \\
                       &| & t^g : c^1 & \rightarrow \delta(\MS^g, (c^1.m, \mathit{args}^g)^\uparrow) \\
                       &| & \MS^g\rangle & \\
         \end{array}\begin{array}[t]{@{}l@{~}c@{~}l@{~}l}
         \langle \MS^g &:=& t^g : c^k & \rightarrow \delta(\MS^g, (c^k.m, \mathit{args}^g, s_0)^\downarrow) \-3mm]
   & \\
   &\-1.5mm]
                       &  &           & \vdots                                   \\
                       &| & t^g : c^1 & \rightarrow \delta(\MS^g, (c^1.m, \mathit{args}^g)^\Downarrow) \\
                       &| & \MS^g \rangle &
         \end{array}(Q, \Sigma, \delta, q_0)c.mt^g\mathit{args}^gc^1 <: \ldots <: c^km\GI(M, \Contract)\ContractME\SRT(E)EE = C_0\ldots C_k{\cal I}^g(P, \Contract)\MS^g_iC_i0 \leq i \leq k\MS^g_i \neq \bot\SRT(E) \in \Contract\MS{\cal I}^g(P, \Contract)\MS^gP\ContractM = (I,H){\cal I}^g(P, \Contract)A(I,H,A,\MS = \MS^g,\MS = \MS^g)P\ContractP\Contract\PiP\Contract{\cal I}^g(P, \Contract)\MS = \MS^g\bot\MS = \MS^g\MS^g \neq \bot\SRT(E) \in \ContractP\Contract\MS = \MS^g\WPM = (I, H){\cal I}^g(P, \Contract)\ILIA(I,H,A, \MS=\MS^g, \MS=\MS^g)\WPP\Contract\Size{P}+\Size{\Contract}\Inline(P, \Contract)\vdots\{ \Psi \}\left\{ \begin{tabular}{@{}l@{}} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \end{tabular} \right.\{ \IF(0 \neq {\tt SS.haveRead}, \True,\phantom{\{} \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead})) \}\{ \IF(0 \neq {\tt SS.haveRead}, \True, \phantom{\{} \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead})) \} \{ \IF(0 \neq \Stack_0, \True, \phantom{\{} \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead})) \} \{ \IF(\Stack_0 \neq \Stack_1, \True, \phantom{\{} \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead})) \}\{ \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead}) \} \{ \True \}\{ \True \}\{ \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead}) \} \{ \IF(\ghost{haveRead} = \False, \Psi, \bot = {\tt SS.haveRead}) \} \langle \ghost{haveRead} := \ghost{haveRead} = \False \rightarrow \ghost{haveRead} \rangle \{ \Psi \}\{ \Psi \}\vdots\PsiP\TrueA_L \Rightarrow \WP_M(L)LA_L \MS = \MS^g \AND \ghost{a}_0 = a_0 = s_0 \AND \ldots \AND \ghost{a}_m = a_m = s_m \WP_M(L)\SELECT((t:c^n \AND \ghost{t}:c^n, \ldots, t:c^1 \AND \ghost{t}:c^1),(\SELECT((c^n.m_{G_1} \AND c^n.m\ghost{}_{G_1},
                             \ldots,c^n.m_{G_i}\AND c^n.m\ghost{}_{G_i}), (c^n.m_{f_1}(\MS, \mathbf{a})
             =c^n.m\ghost{}_{f_1}(\ghost{\MS}, \ghost{\mathbf{a}}),\ldots,c^n.m_{f_i}(\MS, 
                      \mathbf{a})=c^n.m\ghost{}_{f_i}(\ghost{\MS}, 
                                             \ghost{\mathbf{a}})), \True),\vdots\vdots\SELECT((c^1.m_{G_1} \AND 
                      c^1.m\ghost{}_{G_1},\ldots,c^1.m_{G_j}\AND 
                                                c^1.m\ghost{}_{G_j}), c^1.m_{f_1}(\MS, \mathbf{a})=
                               c^1.m\ghost{}_{f_1}(\ghost{\MS}, 
                                        \ghost{\mathbf{a}}),\ldots,c^1.m_{f_j}(\MS, \mathbf{a})=
                           c^1.m\ghost{}_{f_j}(\ghost{\MS}, 
                                            \ghost{\mathbf{a}})), \True)), \MS = \ghost{\MS})x = y \Rightarrow \phi \longrightarrow \phi[z/x][z/y]xyz\phixyz\True(\psi \Rightarrow \phi) \AND (\neg\psi \Rightarrow \phi) \longrightarrow \phi\phi = \phi \longrightarrow \True\Pre_M \Rightarrow A_0A_L \Rightarrow \WP_M(L)L\MScfC=(h, (M, \PC,s,r)::R)\transJVM C'M[\PC] \neq {\tt putstatic}\ c.f\Sem{c.f}C = \Sem{c.f}C'fcc.fc.mm : {\tt int} \rightarrow {\tt int}cdm_{g_1}_{s_1}_{g_2}_{s_2}_{g_1}_{s_1}_{g_2}_{s_2}_{g_1}_{s_1}_{g_2}_{s_2}_{g_1}_{s_1}_{g_2}_{s_2}_{g_1}_{s_1}_{g_2}_{s_2}_{g_1}_{s_1}_{g_2}_{s_2}g(h, (M, pc, s, r)::R)(h, (M, pc', v::s, r)::R)vg{\it stmts}(h, (M, pc, s, r)::R)(h[\llbracket stmts \rrbracket (\MS) /\MS],(M,pc', s, r)::R)\>\>\>r_ar_tr_tr_tr_ar_t_{g_1}_{g_1}_{s_1}_{s_1}_{g_2}_{g_2}_{s_2}_{s_2}r_tr_t_{g_1}_{g_1}_{s_1}_{s_1}_{g_2}_{g_2}_{s_2}_{s_2}r_tr_t_{g_1}_{s_1}_{g_1}_{g_2}_{s_1}_{s_2}_{g_2}_{s_2}m : {\tt int} \rightarrow {\tt int}c(30, 32, 34, \mathit{any})\sigma_{\it bef}\sigma_{\it aft}\sigma_{\it exc}\MSc.m_s\sigma_{\it bef}[(\MS \cdot x) - 5 / \MS]_g_s_g_s_g_s\MS = \MS^g\MS = \MS^g\IF(t:c, A_{28}, A_{30})\IF(\mbox{bef}_g, \IF(s_1:c, \IF(\mbox{bef}_g, \MS\sigma_{\it bef}(a) = \MS^g\sigma_{\it bef}(s_0), \MS\sigma_{\it bef} = \bot), \MS = \MS^g) \AND a = s_0 \AND t = s_1, \True) _g_s\True\IF(s_1:c, \IF(\mbox{bef}_g, \MS = \MS^g\sigma_{\it bef}(s_0), \MS = \bot), \MS = \MS^g)\ \AND a = s_0 \AND t = s_1 \langle (t^g, a^g) := (s_1, s_0) \rangle\langle \MS^g := t^g : c \rightarrow \delta(\MS^g, (c.m, a^g)^\uparrow) \mid \MS^g \rangle\MS = \MS^g \AND a = a^g \AND t = t^g \MS = \MS^g \AND a = a^g \AND t = t^g  \langle r^g := s_0 \rangle \langle \MS^g := t^g : c \rightarrow \delta(\MS^g, (c.m, a^g, r^g)^\downarrow) \mid \MS^g \rangleA_{43}[r/\Stack_0]A_{43}\MS = \MS^g \AND a = a^g \AND t = t^g  \langle \MS^g := t^g:c \rightarrow \delta(\MS^g, (c.m, a^g)^\Downarrow) \mid \MS^g \rangle\IF(t : c, A_{40}, A_{42})\IF(\mbox{exc}_g, \MS\sigma_{\it exc}(a) = \MS^g, A_{41})_g_s\True\MS = \MS^g\IF(t:c, A_{44}, A_{46})\IF(\mbox{aft}_g, \MS\sigma_{\it aft}(r, a) = \MS^g, \True)_g_s\True\MS = \MS^g$ \\
        & NON-INLINED INSTRUCTION
\end{tabular}
\end{center}
}
\caption{\label{fig:schematic_annotations} Schematic annotation for contract displayed Figure \ref{fig:schematic_contract}}
\end{figure}






\end{document}
