\documentclass[11pt,letter]{article}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[all]{xy}
\usepackage[noend]{algorithmic}
\usepackage{hyperref}
\usepackage{verbatim} 
\usepackage{color}
\newcommand{\red}[1]{\textcolor{red}{ #1}}

\setlength{\textheight}{8.8in}
\setlength{\textwidth}{6.5in}
\setlength{\evensidemargin}{-0.18in}
\setlength{\oddsidemargin}{-0.18in}
\setlength{\headheight}{10pt}
\setlength{\headsep}{10pt}
\setlength{\topsep}{0in}
\setlength{\topmargin}{0.0in}
\setlength{\itemsep}{0in}
\parskip=0.035in
\newcommand{\Paragraph}[1]{\vspace{-0.03in}\paragraph{#1}}
\def\dnsbibitem{\vspace{-5pt}\bibitem}

\def\EQ{\mbox{\tt EQ}}
\def\DOM{\mbox{\tt DOM\_Part}}
\def\LAB{\mbox{\tt MAX\_Label}}
\def\ID{\mbox{\tt ID}}

\def\cP{\mathcal{P}}
\def\cM{\mathcal{M}}
\def\cD{\mathcal{D}}
\def\cE{\mathcal{E}}
\def\cH{\mathcal{H}}
\def\cA{\mathcal{A}}
\def\cD{\mathcal{D}}
\def\cC{\mathcal{C}}
\def\cJ{\mathcal{J}}
\def\cF{\mathcal{F}}
\def\hC{\hat{\mathcal{C}}}
\def\tO{{\tilde{O}}}
\def\INPUT{\bar{X}^s,\bar{X}^r}
\def\INPUTPrime{\bar{X'}^s,\bar{X'}^r}
\def\INPUTS{\bar{X}^s}
\def\INPUTR{\bar{X}^r}
\def\indVarS{\bar{X}^s}
\def\indVarR{\bar{X}^r}
\def\partyA{P_A}
\def\partyB{P_B}
\def\sminus{\smallsetminus}



\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{sublemma}{Lemma}[theorem]
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{subclaim}{Claim}[theorem]
\newtheorem{fact}[theorem]{Fact}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{open}[theorem]{Open Problem}


\newcommand{\qed}{\rule{7pt}{7pt}}
\newenvironment{proof}{\noindent{\bf Proof}\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-sketch}{\noindent{\bf Sketch of Proof}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-idea}{\noindent{\bf Proof Idea}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-of-lemma}[1]{\noindent{\bf Proof of Lemma #1}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{sketch-of-claim}[1]{\noindent{\bf Proof Sketch of Claim #1}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-of-claim}[1]{\noindent{\bf Proof of Claim #1}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-claim}{\noindent{\bf Proof of Claim}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{proof-lemma}{\noindent{\bf Proof of Lemma}
\hspace*{1em}}{\qed\bigskip}
\newenvironment{sketch-of-lemma}[1]{\noindent{\bf Proof Sketch of Lemma #1}
\hspace*{1em}}{\qed\bigskip}


\title{{\bf\Large Tight Bounds For Distributed Minimum-weight Spanning Tree
Verification}}

\date{\today}

\author{
Liah Kor
\thanks{Department of Computer Science and Applied Mathematics, The Weizmann
Institute of Science, Rehovot, 76100 Israel. 
E-mail: {\tt \{liah.kor,david.peleg\}@weizmann.ac.il}.
Supported by a grant from the United States-Israel Binational Science 
Foundation (BSF).}
\and
Amos Korman
\thanks{CNRS and LIAFA, Univ. Paris 7, Paris, France. 
E-mail: {\tt amos.korman@liafa.univ-paris-diderot.fr}. 
Supported by the ANR project DISPLEXITY, 
and by the INRIA project GANG.}
\and 
David Peleg~
}

\date{}
\begin{document}

\maketitle

\begin{abstract}
This paper introduces the notion of distributed verification without 
preprocessing. It focuses on the Minimum-weight Spanning Tree (MST) 
verification problem and establishes tight upper and lower bounds for 
the time and message complexities of this problem. Specifically, we
provide an MST verification algorithm that achieves {\em simultaneously} 
 messages and  time, where  is 
the number of edges in the given graph ,  is the number of nodes, 
and  is 's diameter. On the other hand, we show that any MST 
verification algorithm must send  messages and incur 
 time in worst case.

Our upper bound result appears to indicate that the verification of an MST may be easier than 
its construction, since for MST construction, both lower bounds of
 messages and  time hold, but at the moment 
there is no known distributed algorithm that constructs an MST and  achieves 
{\em simultaneously}  messages and  time.
Specifically, the best known time-optimal algorithm (using  
time) requires  messages, and the best known message-optimal 
algorithm (using  messages) requires  time.
On the other hand, our lower bound results indicate that the verification of an MST is not significantly easier than its construction.
\end{abstract}



\noindent {\bf keywords:} Distributed algorithms, distributed verification, labeling schemes, minimum-weight spanning tree.

\section {Introduction}

\subsection{Background and Motivation}
The problem of computing a Minimum-weight Spanning Tree (MST)  received considerable attention in both the 
distributed setting as well as in the  centralized setting. In the distributed setting, constructing such a tree distributively
requires a collaborative computational effort by all the network vertices, 
and involves sending messages to remote vertices and waiting for their replies. This is particularly interesting in the  model of computation, where due to congestion constrains, each message can encode only a limited number of bits, specifically, this number is typically assumed to be , where  denotes the number of nodes in the network.
The main measures considered for evaluating a distributed MST protocol are the {\em message} complexity, namely, the maximum 
number of messages sent in the worst case scenario, 
and the {\em time} complexity, namely, the maximum number of communication rounds 
required for the protocol's execution in the worst case scenario.
The line of research on the distributed MST computation problem was initiated 
by the seminal work of Gallager, Humblet, and Spira \cite{GHS_83} 
and culminated in the  time and  messages algorithm 
by Awerbuch \cite{A87}, where  denotes the number of edges in the network. 
Both of these algorithms apply also to asynchronous systems.
As pointed out in \cite{A87}, the results of 
\cite{AGVP_90,B_80,FL_84} establish an  lower bound 
on the number of messages required to construct a MST.  
Thus, the algorithm of \cite{A87} is essentially optimal. 

This was the state of affairs until the mid-nineties when Garay, Kutten, 
and Peleg \cite{GKP98} initiated the analysis of the time complexity 
of MST construction as a function of additional parameters (other than ), 
and gave the first sublinear time distributed algorithm for the MST problem, 
running in time , where  is the diameter of the network. 
This result was later improved to  by 
Kutten and Peleg \cite{KP_98}.
The tightness of this latter bound was shown by  
Peleg and Rubinovich \cite{PR_00} who proved that 
 is essentially\footnote{ 
(respectively ) is a relaxed variant of the  (rep., ) 
notation that ignores polylog factors.}
a lower bound on the time for constructing MST on graphs with
diameter . This result was complemented by the work 
of Lotker,  Patt-Shamir and  Peleg \cite{LPP_01} that showed an 
 lower bound on the time required for 
MST construction on graphs with small diameter. 
Note, however, that the time-efficient algorithms of \cite{GKP98,KP_98} 
are not message-optimal, i.e., they take asymptotically much more than 
 messages. For example, the time-optimal protocol 
of \cite{KP_98} requires sending  messages. 
The question of whether there exists an optimal distributed algorithm for MST 
construction that achieves {\em simultaneously}  messages 
and  time still remains open.

This paper addresses the MST verification problem in the  model. 
Informally, the setting we consider is as follows. 
A subgraph is given in a distributed manner, namely, some of 
the edges incident to every vertex are locally marked, and the collection of 
marked edges at all the vertices defines a {\em marked subgraph}; see, e.g., 
\cite{CGKK95,GHS_83,KK07,KKP10}. The verification task requires checking 
distributively whether the marked subgraph is indeed an MST of the given graph. 
Similarly to the papers dealing with sub-linear time MST construction 
\cite{GKP98,KP_98}, we consider a synchronous environment. 


\subsection{Our Results}

We consider the MST verification problem and establish asymptotically tight 
upper and lower bounds for the time and message complexities of this problem.
Specifically, in the positive direction we show the following:

\begin{theorem}
\label{thm:upper-bound}
There exists a distributed MST verification algorithm that uses
 time and  messages.
\end{theorem}


This result appears to indicate that MST verification may be easier than 
MST construction, since, at the moment,  it is not known whether there exists an algorithm that constructs an MST simultaneously in  time and  messages. 
Conversely, we show that the verification problem 
is not much easier than the construction, by proving that the known lower bounds for MST construction
also hold for the verification problem. Specifically, we prove the following two matching lower bounds.

 
\begin{theorem} 
\label{thm:lower-bound-msgs}
Any distributed algorithm for 
MST verification 
requires  messages.
\end{theorem}

\begin{theorem} 
\label{thm:lower-bound-time}
Any distributed algorithm for 
MST verification 
requires  time.
\end{theorem}


To the best of our knowledge, this paper is the first to investigate
distributed verification  without assuming any kind of preprocessing (see Section~\ref{preprocessing}). Following this paper, several other works on distributed verification have already been published. More specifically, a systematic study of distributed verification is established for various verification tasks \cite{DHKKNPPW}. Distributed verification in the  model has been studied in \cite{FKP11,FKPP12}, mostly focusing on computational complexity issues.

Our  time lower bound for verifying an MST is achieved by a (somewhat involved) 
modification of the corresponding lower bound for the computational task 
\cite{PR_00}. 
The idea behind our time lower bound was already found useful in several 
continuation studies. Specifically, a modification of our proof technique 
was used in \cite{DHKKNPPW} to yield time lower bounds for several other 
verification tasks, and for establishing a lower bound on the hardness 
of approximating an MST. Somewhat surprisingly, in \cite{NDP11}, 
the proof technique was extended even further to yield a result 
in the (seemingly unrelated) area of distributed random walks. 


\subsection{Other related work}
\subsubsection{MST computation and verification in the centralized setting}  In the centralized setting, there is a large body of literature concerning the
problem of efficiently computing an MST of a given weighted graph.
Reviews can be found, e.g., in the survey paper by Graham and Hell \cite{GH85} 
or in the book by Tarjan \cite{T83} (Chapter 6). 
The fastest known algorithm for finding an MST is that of 
Pettie and Ramachandran  \cite{optimalMST}, which runs
in  time, where  is 
 the inverse Ackermann function, 
 is the number of vertices 
and  is the number of edges in the graph. 
Unfortunately, a linear (in the number of edges) time algorithm 
for computing an MST is known only in certain cases, or by using randomization
\cite{FredmanWillard,KargerKleinTarjan}. 

The separation between computation and verification, and specifically,
the question of whether verification is easier than computation, is a central 
issue of profound impact on the theory of computer science. 
In the context of MST, the  verification problem 
(introduced by Tarjan \cite{Tarjan79}) is the following:
given a weighted graph, together with a subgraph, 
it is required to decide whether this subgraph forms an MST of the graph. 
At the time it was published, the running time of the MST verification 
algorithm of \cite{Tarjan79} was indeed superior to the best known bound
on the computational problem. Improved verification  algorithms in different
centralized models were then given by Harel \cite{Harel85},
Komls \cite{Komlos}, and Dixon, Rauch, and Tarjan
\cite{DixonRauchTarjan}, and parallel algorithms were presented by Dixon and
Tarjan \cite{DixonTarjan} and by King, Poon, Ramachandran, and Sinha
\cite{king2}. 
Even though it is not known whether there exists a deterministic algorithm that 
computes an MST in   time, the verification algorithm of 
\cite{DixonRauchTarjan} is in fact linear, i.e., runs in time  (the same result with a simpler 
algorithm was later presented by King \cite{king97} and by Buchsbaum \cite{BGKRTW_08}). 
For the centralized setting, this may indicate that the verification 
of an MST is indeed easier than its computation.

\subsubsection{Distributed verification with preprocessing}\label{preprocessing}

Some previous 
papers investigated distributed verification tasks assuming that the algorithm 
designer can perform a preprocessing stage to help the verification, 
cf. ~\cite{AKY97,APV,silent,KK07,KKP10}. 
Typically, in this preprocessing stage, data structures (i.e., labels, proofs) 
are provided to the nodes of the graph, and using these data structures, 
the verification proceeds in a constant number of rounds. The focus in those 
studies was on the  minimum size of a data structure (i.e., amount of 
information stored locally), while the complexities of the preprocessing stage 
providing the data structures were not analyzed. 

 \section{Preliminaries}

\subsection{The Model}

A point-to-point communication network is modeled as an undirected
graph ,
where the vertices in  represent the network processors and the
edges in  represent the communication links connecting them. We denote by  the number of vertices in , i.e., , and let  denote the number of edges, i.e., .
The {\em length} of a path in   is the number of edges it
contains. The {\em distance} between two vertices  and  is
 the length of the shortest path connecting them. 
The {\em diameter} of , denoted , is the maximum distance
between any two vertices of .

Vertices are assumed to have unique {\em identifiers}, 
and each vertex  knows its own identifier .
A weight function  associated with the
graph assigns a nonnegative integer {\em weight}  to each edge
.  The vertices do not know the topology or the edge weights of the
entire network, but they  know the weights of the edges incident to them, that is, the weight  is known to   and . 
Similarly to corresponding works on MST computation,  we assume that the edge weights are bounded by a polynomial in  
(this assumption implies that a weight of an edge can be encoded using  bits, and hence can be encoded in one message). 
 

Similarly to previous work, we consider the  model. 
Specifically, the vertices can communicate only by sending and receiving
messages over the communication links. 
Each vertex can distinguish between its incident edges. Moreover, 
if vertex  sends a message to vertex  along the edge ,
then upon receiving the message, vertex  knows that the message 
was delivered over the edge . At most one  bits can be sent 
on each link in each message. 
Similarly to  \cite{GKP98,KP_98}, we assume that the communication 
is carried out in a synchronous manner,
i.e., all the vertices are driven by a global clock.
Messages are sent at the beginning of each round, and are received at
the end of the round.
(Clearly, our lower bounds hold for asynchronous networks as well.)
Relevant studies typically assume that computations start 
either at a single {\em source} node or simultaneously at all nodes.
Our results hold for both of these settings.

\subsection{The distributed MST Verification problem}

Formally, the {\em minimum-weight spanning tree (MST) verification} problem can be 
stated as follows. Given a graph , a weight function  
on the edges, and a subset of edges , referred as the 
{\em MST candidate},  it is required to decide whether   forms a minimum  
spanning tree on , i.e., a spanning tree  whose total weight 
 is minimal.
In the distributed model, the input and output of the 
{\em MST verification problem} are represented as follows.
Each vertex knows the weights of the edges connected to its 
immediate neighbors. A degree- vertex  with
neighbors  has  {\em weight variables}
, with  containing the weight of the edge
connecting  to , i.e., , and  
{\em boolean indicator variables}   indicating which 
of the edges adjacent to   participate in the MST candidate that we wish 
to verify. The indicator variables must be consistent, namely, 
for every edge , the indicator variables stored at  and  
for this edge must agree (this is easy to verify locally). 
Let  be the set of edges marked by the indicator variables 
(i.e., all edges for which the indicator variable is set to~1).
The output of the algorithm at each vertex  
is an assignment to a (boolean) output variable  that must satisfy 
if  is an MST of , and  otherwise.

\section{An MST Verification Algorithm}
\label{sec:alg}

In this section we describe our MST verification algorithm, 
prove its correctness and analyze its time and message complexities.

First, we note that in this section we assume that the verification algorithm 
is initiated by a designated source node. The case in which all nodes wake up 
simultaneously can be reduced to the single source setting using the 
leader election algorithm of \cite{KPPRT12}, which employs  
messages and runs in  time.

\subsection{Definitions and Notations}

Following are some definitions and notations used in the description 
of the algorithm.
For a graph , an edge  is said to be {\em cycle-heavy} 
if there exists a cycle  in  that contains , and  has 
the heaviest weight in .
For a graph , a set of edges  is said to be an 
{\em MST fragment} of  if there exists a minimum spanning tree  
of  such that  is a subtree of  
(i.e.,  and  is a tree). 
Similarly, a collection   of edge sets is referred to as an 
{\em MST fragment collection} 
of  if there exists an MST   of  
such that 
(1)  is a subtree of   for every ,
(2) ,
and 
(3)  for every , where .

Consider a graph , an MST fragment collection ,
a subgraph  of  and a vertex  in .
The {\em fragment graph} of , denoted , is defined as a graph 
whose vertices are the MST fragments , and whose edge set contains 
an edge   if and only if there exist vertices  and  
such that . Similarly,
the {\em fragment graph induced by} , denoted ,  
is defined as a graph whose vertices are the MST fragments , 
and whose edge set contains an edge  for   if and only if there exist vertices 
 and  such that . The edges of  
are also referred to as the {\em inter-cluster} edges induced by .

For each vertex , let  denote the set of edges of  incident to .
For each fragment , the set of {\em fragment internal} 
edges of  induced by , denoted , consists of all edges of  with both 
endpoints in , i.e., 
.
The fragment of , denoted by , is the fragment 
 such that .
Denote by  the set of edges in  that are incident to  
(i.e., ).
Similarly, denote by  the set of fragment internal edges of  induced by  
and incident to~.

Throughout the description of the verification algorithm we assume that 
the edge weights are distinct. Having distinct edge weights simplifies our arguments   
since it guarantees the uniqueness of the MST. Yet,  this assumption is not essential. Alternatively, in case the graph is not guaranteed 
to have distinct edge weights, we may use a modified weight function 
, which orders edge weights lexicographically. 
At this point we would like to note that the standard technique (e.g., \cite{GHS_83}) for obtaining unique weights is not sufficient for our purposes. 
Indeed, that technique orders edge weights lexicographically:  
first, by their original weight , and then, by the identifiers of 
the edge endpoints (say, first comparing the smaller of the two identifiers of the endpoints, and then the larger one). 
This yields a modified graph with unique edge weights, and an MST of the modified graph is necessarily an MST of the original graph. 
For construction purposes it is therefore sufficient to consider only 
the modified graph. However, this is not the case for verification purposes, 
as the given subgraph can be an MST of the original graph but not necessarily 
an MST of the modified graph. 

While we cannot guarantee than any MST of the original graph is an MST of 
the modified graph (having unique edge weights), we make sure that 
the particular given subgraph  is an MST of the original graph 
if and only if it is an MST of modified one. This condition is sufficient for our purposes, and allows us to consider only the modified graph.
Specifically, to obtain the modified graph, we employ a slightly different 
technique than the classical one. 
That is, edge weights are lexicographically ordered as follows.
For an edge  connecting  to its th neighbor , 
consider first its original weight , 
next, the value  where  is the indicator variable of the edge
 (indicating whether  belongs to the candidate MST to be verified), 
and finally, the identifiers of the edge endpoints,  and 
(say, first comparing the smaller of the two identifiers of the endpoints, 
and then the larger one). 
Formally, let 

where 
and .
Under this weight function , edges with indicator variable set to 1
will have lighter weight than edges with the same weight under  
but with indicator variable set to 0 
(i.e., for edges  and  such that 
, we have ).
It follows that  the given subgraph  
 is an MST of  if and only if   is an MST
of . Moreover, since  takes into account  
the unique vertex identifiers, it assigns distinct edge weights.

The MST verification algorithm makes use of Procedures  and , 
presented in \cite{KP_98} and \cite{KKKP_05} respectively. Before we continue, let us first recall what these procedures guarantee. 

\paragraph{Procedure :} 
The distributed Procedure , used in \cite{KP_98}, partitions a given 
graph into an {\em MST fragment collection (MFC)} , where each fragment 
is of size at least  and depth , for a parameter  to be 
specified later (aiming to optimize the total costs). 
A {\em fragment leader} vertex is associated with each constructed fragment 
(the identifier of the fragment is defined as the identifier of the 
fragment's leader). 
After Procedure  is completed, 
each vertex  knows the identifier of the fragment 
to which it belongs  and 's incident edges that belong to the fragment.
(To abide by the assumption of \cite{KP_98} that each vertex 
knows the identifiers of its neighbors, before applying Procedure , 
the algorithm performs a single communication round that exchanges 
vertex identifiers between neighboring vertices.) The execution of 
Procedure , requires  time and 
 messages. 
The parameter  to be used by our protocol, chosen as a suitable breakpoint 
so as to optimize the total costs, satisfies , 
hence, our invocation of Procedure  will require 
 time and  messages.

\paragraph{The   labeling scheme:} 
The labeling scheme  
of \cite{KKKP_05} is a centralized procedure designed for the family of 
weighted trees. The procedure involves two components: 
an encoder algorithm  and 
a decoder algorithm . These two components satisfy the following.
\begin{enumerate}
\item Given a weighted tree , the encoder algorithm  
assigns a label  to each vertex~~of~.
\item Given two labels  and  assigned by  to two vertices  and  in some weighted tree~, the decoder 
algorithm  outputs , which is the maximum weight 
of an edge on the path connecting  and  in . (The decoder 
algorithm  bases its answer on the pair of labels    and  only, without knowing any additional information regarding the tree~.)
\end{enumerate} 

The labeling scheme    produces -bit labels, 
where  is the largest weight of an edge. Since  is assumed to be 
polynomial in , the label size is  bit.

\subsection{The algorithm}

\paragraph{Overview:} The algorithm consists of three  phases. The first phase  starts by letting the source node  construct a BFS tree rooted at , and calculating the values of the number of nodes  and a 2-approximation  to the diameter  of the graph. Then, the distributed 
Procedure  of \cite{KP_98} in invoked with parameter , where  is the diameter of the graph. This procedure constructs an MST fragment collection 
(MFC) , where every fragment in 
is of size at least  and depth . As mentioned, our invocation of Procedure  requires  time and 
 messages.
The algorithm verifies that the set of edges contained in the constructed MFC 
is equal to the set of fragment internal edges induced by the MST candidate , i.e., 
 
(this verifies that each  is contained in  and that   does not contain additional fragment internal edges.)
Note that this is a necessary  condition for correctness since the graph is assumed to have  a unique MST. 

In the following phases, the algorithm verifies that all remaining edges of   form an MST on the fragment graph . Let  be the fragment 
graph induced by  with respect to the MFC  found in the previous phase.
In order to verify that  forms an MST on the 
fragment graph , it suffices to verify that  is a tree and 
that none of the edges of  is  a {\em cycle heavy} edge in  .
The above is done as follows. 

In the second phase, the structure of   is aggregated over the BFS tree to the source node , which in turn verifies that
  is indeed a tree. Note that this aggregation is not very wasteful, and requires  time and  messages, where  is the number of nodes in . As shown later, , and hence, this aggregation can be done using  time and 
 messages.

In the third phase, the source node  employs the (centralized) labeling scheme  of \cite{KKKP_05} (or \cite{KK07}) on . 
Informally, the labeling scheme assigns a label  to each vertex  of  
using  the encoder algorithm  applied on . The label  is then efficiently delivered to each vertex in .
More specifically, the  labels are broadcasted over the BFS tree, so that eventually, each node in a fragment knows its corresponding label. This broadcasts costs  time and  messages.
Recall, that given the labels of two fragments  and  it is now possible to 
compute the weight of the heaviest edge on the path connecting the fragments 
in  by applying the decoder algorithm . Once all vertices obtain the labels of their corresponding fragments, each vertex of  can verify  (using the decoder~) by communicating with its neighbors only,
that each inter fragment edge incident to it and not participating in 
 forms a cycle when added to  for which it is a cycle heavy 
edge. Following is a more detailed description of the algorithm.

\begin{enumerate}
\item
{\bf\underline{Phase 1}}

\begin{enumerate}
\item \label{send_ids} The source node  (which initiates the algorithm) constructs a BFS tree rooted at , computes the values  and , where  is the number of nodes and  is the depth of the BFS tree. (Note that  is a 2-approximation to the diameter  of the graph.) Subsequently, the source node  broadcasts a signal over the BFS tree containing the values  and  and instructing each vertex to send its identifier to all its neighbors. 
This guarantees that all nodes know the values of  and  as well as the identifiers of their neighbors. 
In addition, to start the next step (i.e., Step 2.b) at the same time, the broadcast is augmented with a counter that is initialized by the source   to  is decreased by one when delivered to a child in the BFS tree. Let  denote the counter received at node . Before starting the next step each node  waits for  rounds after receiving the counter.

\item \label{dom} 
Perform  Procedure , with parameter . 
The result is an MFC , where each fragment 
 is of size  
and depth , having a fragment leader and a distinct fragment identifier 
known to all vertices in the fragment.
\item \label{send_fragment} 
Each vertex sends its fragment identifier to all its neighbors.
\item  \label{identify_int_vs_ext_edges}
By comparing the fragment identifiers of its neighbors with its own fragment identifier, each vertex  identifies the sets of  edges   and .
\item \label{verify_internal_edges}
Verify that 
 
by verifying at each vertex  that .
(Else return `` is not an MST''.)
\end{enumerate}

\item 
{\bf \underline{Phase 2}}
\begin{enumerate}

\item \label{count_fragments}  
Vertex  counts the number of fragments, denoted by . This is implemented by letting  broadcast a signal over the BFS tree instructing the nodes to perform a convergecast 
over the BFS tree. During this convergecast the number of fragments is aggregated to the root  by letting only fragment leader vertices increase 
the fragment counter. This guarantees that the fragment  counter at the root  is .
\item \label{count_inter_fragment}
Vertex  counts the number of inter fragment 
edges induced by  (i.e., the number of edges in ) by performing another convergecast over the BFS tree. Then,  verifies that the number of edges is equal to . 
(Else return `` is not an MST''.) 
\item \label{send_Tf}
Vertex  broadcasts a signal over the BFS tree instructing all vertices to send  the description of all their incident edges in  
to , by performing a convergecast over the BFS tree. (The edges of  are 
all edges of  that connect vertices from different fragments.)
\item \label{verify_tree}Vertex  verifies that  is a tree. 
(Else return `` is not an MST''.)
\end{enumerate}

\item 
{\bf \underline{Phase 3}}
\begin{enumerate} 
\item \label{route}
Each fragment leader sends a message to vertex  over the BFS tree. 
Following these messages, all vertices save routing information regarding the fragment leaders.
I.e., if  is a fragment leader and  is a descendant of some other vertex  in the BFS tree, then, 
after this step is applied,  knows which of its children is on the path connecting it to  the fragment leader .
\item \label{encode}
Vertex  computes  the labels  for all vertices  in 
(i.e., assigns a label to each of the fragments) 
using the encoder algorithm . Subsequently,  sends to each 
fragment leader its fragment label 
(the label of each fragment is sent to the fragment leader over the BFS tree 
using the routing information established in Step \ref{route} above).
(Recall that each label is encoded using  bits.)
\item \label{send_labels_leaders}
Each fragment leader broadcasts its fragment label to all vertices in the fragment. The broadcast is done over the fragment edges.
\item \label{send_labels_neig}
Each vertex  sends its fragment label to all its neighbors in other 
fragments. (Recall that  already knows  by step 
\ref{identify_int_vs_ext_edges}.)
\item \label{verify_cycle_heavy}Each vertex  verifies, for every 
neighbor  such that  does not belong to s fragment and 
, that . 
(The value  is computed by applying 
the decoder algorithm  to the labels  and .) 
(Else return `` is not an MST''.)
\end{enumerate}
\end{enumerate}

\subsection{Correctness}

We now show that our MST verification algorithm correctly identifies whether 
the given subgraph  is an MST. We begin with the following claim.

\begin{claim} \label{clm_fragmet_mst}
Let  be a spanning tree of  such that  contains all edges of the MFC 
 and  forms an MST on the fragment graph of  (with respect 
to  the MFC ). Then  is an MST on .
\end{claim}
\begin{proof} 
Since  is an MST fragment collection, there exists an MST  of  
such that  contains all edges of . Due to the minimality 
of , the fragment graph  induced by  necessarily forms 
an MST on , the fragment graph of . 
Hence we get that , thus  is an MST of~.
\end{proof}

Due to the assumption that edge weights are distinct, we get:
\begin{observation} 
\label{unique_mst}
The MST of  is unique.
\end{observation}
By combining Claim \ref{clm_fragmet_mst} and Observation \ref{unique_mst} 
we get the following.
\begin{claim} \label{show_mst}
A spanning tree  of  is an MST if and only if   contains all edges 
of the MFC  and  forms an MST on .
\end{claim}

\begin{lemma}
\label{lem:correct}
The MST verification algorithm correctly identifies whether the given tree  
is an MST of the graph .
\end{lemma}

\begin{proof} 
By Claim \ref{show_mst}, to prove the correctness of the algorithm it suffices 
to show that given an MST candidate , the algorithm  verifies that: 
\begin{description}
\item{(1)}  is a spanning tree of ,
\item{(2)}  contains all edges of , and
\item{(3)}  forms an MST on  .
\end{description}

Since  as constructed by Procedure  
in the first phase is an MFC, it spans all vertices of . 
Step \ref{verify_internal_edges} verifies that 
, 
thus after this step, it is verified that  does not contain a cycle that 
is fully contained in some fragment  (since every  
is a tree). On the other hand, step \ref{verify_tree} verifies that  
does not contain a cycle that contains vertices from different fragments. 
Hence, the algorithm indeed verifies that  is a spanning tree of , 
and Property (1) follows. 
Property (2) is clearly verified by step \ref{verify_internal_edges} of the algorithm.
Finally, to verify that  forms an MST on the fragment graph 
of  it suffices to verify that inter-fragment edges not in  
are cycle heavy, which is done in step \ref{verify_cycle_heavy}.
Property (3) follows.
\end{proof}

\subsection{Complexity}

Consider first the Phase 1. Steps \ref{send_ids} and \ref{send_fragment} clearly take  time and  messages.
Step \ref{dom}, i.e., the execution of 
Procedure , requires  time and 
 messages. 
(A full analysis appears in \cite{Vitaly}.) 
The remaining steps of the first phase are local computations performed by 
all vertices. Thus, since  is set to ,
the first phase of the MST verification algorithm requires 
requires  time and 
 messages.


Observe now, that since the fragments are disjoint and each fragment contains at least  vertices, 
we have the following.
\begin{observation} 
\label{num_of_fragments}
The number of MST fragments constructed during the first phase of the 
algorithm is . 
\end{observation} 

The first two steps of phase 2, namely, steps \ref{count_fragments}
and \ref{count_inter_fragment} consist of simple broadcasts over the BFS tree, hence they require 
 time and  messages. Step \ref{send_Tf} consists of upcasting all 
the edges in  
to . Note that the number of edges in  can potentially be as high as . However, given that the verification did not fail in Step 
\ref{count_inter_fragment}, we are guaranteed that the number of edges in  is .
Thus, Step \ref{send_Tf} amounts to upcasting  messages and can therefore be performed in  time and  messages.
Step \ref{route}  consists of an upcast of  messages over the BFS tree and thus requires the same time and message complexities as that of step \ref{send_Tf}.
Step \ref{encode} consists of a BFS downcast of  messages (each of size 
); it therefore requires  time and  messages. Step \ref{send_labels_leaders} consists of a broadcast of a label (of size ) in each of the MST fragments; this can be performed in   time and
 messages. Finally, step \ref{send_labels_neig} can be performed in  time and  messages, and step 
\ref{verify_cycle_heavy} amounts to  local computations.
Table~1 below
summarizes the time and message complexities of the second and third phases 
of the algorithm.

\begin{table}[h!]
\label{t:table}
\noindent
\begin{tabular}{|l||*{3}{l|}}
\hline
Step
&\makebox[5em]{Description}&\makebox[5em]{Time}&\makebox[5em]{Messages}
\\\hline\hline
\ref{count_fragments},\ref{count_inter_fragment}& BFS convergecast & & 

\\ \hline
\ref{send_Tf}, \ref{route} & BFS upcast of  messages&& 

\\ \hline
\ref{verify_tree},\ref{verify_cycle_heavy} & Local computation& & none 

\\ \hline
\ref{encode} & BFS downcast of  messages (each of size 
)&& \\ \hline
\ref{send_labels_leaders} & Broadcast in each of the MST fragments &  & 


\\ \hline
 \ref{send_labels_neig} & 
Communication between neighbors & 
 &  
\\\hline
\end{tabular}
\caption{Time and message complexities of phases 2 and 3 of the algorithm. 
 is the diameter of the graph, and  is the number of MST\ fragments 
constructed in phase 1.}
\end{table}

\noindent
Combining 
the above arguments, and using the fact that  (see Observation \ref{num_of_fragments}), we obtain the following. 

\begin{lemma}
The  algorithm describes above requires   time
and  messages.
\end{lemma}

Theorem \ref{thm:upper-bound} follows by combining the
 lemma above   with Lemma \ref{lem:correct}.


\section{Time Complexity Lower Bound}
\label{sec:time-lb}

In this section, we prove an  lower bound 
on the time required to solve the MST verification. 
Clearly,  time is inevitable in the case of a single source node. 
The case in which all nodes start at the same time is also very simple.
Indeed, in this case, the  time bound follows by considering 
a cycle  of size  with all edges having weight 1 except for two edges 
 and  located at opposite sides. The given candidate spanning tree is 
. The two edges  and  can have arbitrary weights, 
hence, to decide whether  is an MST one needs to transfer information 
along at least half of the cycle.
This shows a lower bound of  for the case where . 
A similar argument can be applied for arbitrary values of .

The difficult part is to prove a time lower bound of .
We prove this lower bound for the case where all nodes start at the execution 
at the same time. The lower bound for the case of a single source node follows 
directly from this lower bound, relying on the leader election algorithm 
of \cite{KPPRT12}, which runs  in  time.

In the remaining of this section we consider the case where all nodes start the execution simultaneously at the same time, and prove a lower bound of .
To show the lower bound, 
we first define a new problem named {\em vector equality}, and then show 
a lower bound for the time required to solve it. 
This is established in Section \ref{sec:VEprob}.
More specifically, for the purposes of this lower bound proof, we consider the collection of graphs denoted , for
, as defined in \cite{PR_00}. Each graph graph  consists of
 vertices, and its diameter is . In Section \ref{subsec:ITN}, we establish a time lower bound 
of  for solving vector equality in each graph .

In Section \ref{sec:lb_ver_prob}, for
, we consider a family  of weighted
graphs (these are weighted versions of the graph ), and show that any algorithm solving 
the MST verification problem on the graphs in  can also be used to 
solve the vector equality problem on  with the same time complexity.
This establishes the desired  time lower bound for the distributed MST verification problem.


\subsection{A lower bound for the vector equality problem}
\label{sec:VEprob}

\paragraph{The vector equality problem .}
Consider a graph  and two specified distinguished vertices  and , 
each storing  boolean variables, 
 and
 respectively,
for some integer . An instance of the problem 
consists of initial assignments
 and 
, 
where ,
to the variables of  and  respectively. Given such
an instance, the vector equality problem requires  to decide whether 
,  i.e.,  for every .  

\subsubsection{The graphs }
\label{ss:graphs}

Let us recall the collection of graphs denoted , for
, as defined in \cite{PR_00}. (See Figure \ref{f:Ti}). The components used 
are the {\em ordinary path}  on  vertices, where
, 
,
and the {\em highway}  on  vertices, where
 and
.
Each highway vertex  is connected to the corresponding 
path vertex  by a {\em spoke} edge . 

The graph  is constructed of  copies of the path, 
, and connecting them to the highway .
The two distinguished vertices are  and .
The spoke edges are grouped into  {\em stars} , , 
with each  consisting of the vertex  and the  vertices 
 connected to it by spoke edges. Hence

and .
The graph  consists of

and .
Thus  has  vertices and diameter .

\subsubsection{The lower bound for }
\label{subsec:ITN}

Our goal now is to prove that solving the vector equality problem on  with a -bit input strings  requires
 time, assuming each message is encoded using  bits. (Later, we shall take .)
\newline\indent
Consider some arbitrary algorithm , and let 
denote the execution of  on -bit inputs  on
the graph . For simplicity, we assume that  is an integer. For , 
define the {\em i-middle set}
of the graph , denoted , as follows. For every , define the {\em i-middle} of the path  as
.
Let  denote the least integer  such that
 and  denote the largest integer  such that 
. Define the {\em i-middle} of  as
.
Now, the {\em i-middle set} of  is the union of those middle sets,

(See Fig.~\ref{f:Ti}.)
For , the definition is slightly different, letting
.

\begin{figure} [htb]
\begin{center}

\centerline{\includegraphics[scale=0.60]{Mi.pdf}}

\caption[]{
\label{f:Ti}
\sf
The middle set  in the graph  }
\end{center}
\end{figure}

Denote the {\em state} of the vertex  at the beginning of round 
during the execution  on the input  by
. Without loss of generality, we may assume that in two different executions  and
, a vertex reaches the same state at time
, i.e., , 
if and only if  it receives the same sequence of messages on each of its incoming links; for different sequences, the states are distinguishable.
\newline\indent
For a given set of vertices ,
a {\em configuration}  is a vector

of the states of the vertices of  at the beginning of
round  of the execution .
Denote by  the collection of all possible
configurations of the subset  at time  over all
executions  of algorithm  (i.e., on all legal
inputs ), and let .
\newline\indent
Prior to the beginning of the execution (i.e., at the beginning of
round ), the input strings  are known only to vertices 
 and  respectively. The rest of the vertices
are found in some initial state, described by the configuration
, which is independent of .
Thus in particular .
(Note, however, that .)


\begin{lemma}
\label{step}
For every ,
.
\end{lemma}


\begin{proof}
The lemma is proved by showing that in round  of the algorithm,
each configuration in  branches off into at most 
different configurations of .

Fix a configuration , and let  and 
.
The -middle set  is connected to the rest of the graph by the
highway edges  and 

and by the  path edges 
,
. (See Fig. \ref{f:Tt+1}.)
\begin{figure} [htb]
\begin{center}

\centerline{\includegraphics[scale=0.6]{Mt+1.pdf}}

\caption[]{
\label{f:Tt+1}
\sf
The edges entering the middle set . }
\end{center}
\end{figure}

Let us count the number of different configurations in

that may result of the configuration .
Starting from the configuration , each vertex  is
restricted
to a single state, and hence it sends a single (well determined)
message over the edge  to 
thus not introducing any divergence in the execution. Similarly, each vertex 
  is restricted to a single state, and hence it sends a single
message over the edge  to .
The same applies to all the edges internal to .
As for the highway edges , the vertices 
  and  are not in the set , 
hence they may be in any one of many possible states, 
and the values passed over these edges into the set 
are not determined by the configuration . However, due to the
restriction of the -bounded-message model, at most 
different behaviors of  can be observed by  
and at most  different behaviors of  can be observed 
by .
Thus altogether, the configuration  branches off into at most
 possible configurations 
, 
differing only by the states , 
.
The lemma follows.
\end{proof}

Applying Lemma \ref{step} and the fact that ,
we get the following result. 

\begin{corollary}
\label{cl:bound-rho}
For every , .
\end{corollary}

To prove the time lower bound for the vector equality problem we introduce 
the following restricted model of computation as defined in \cite{KUS_97}.
A {\em two party communication model} consists of parties  
and  connected via a bidirectional communication link. 
Let  be arbitrary finite sets. We say that Protocol  computes 
function   if, when given input  
known to party  and input  known to party , 
the parties are able to determine   by a sequence of bit exchanges. 
The following observation follows from \cite[1.14]{KUS_97}, and is used to prove Lemma \ref{l:EQ-LB}.



\begin{observation} \label{l:similar-executions}
Consider a protocol .  Suppose that there exist inputs 
 for party  and  for party  
for which   in the executions of  on input  and 
on input , identical sequences of bits are exchanged by both parties. 
Then  the same sequence of bits is exchanged in the execution of 
 on input .
\end{observation}

\begin{lemma}
\label{l:EQ-LB}
For every , solving the vector equality problem 
 requires  time.
\end{lemma}

\begin{proof}
Assume, towards contradiction, that there exists a protocol  that 
correctly solves   and has worst case time complexity 
. Let  be the middle set of , 
as previously defined, corresponding to . Let  be 
the set of vertices  that reside on the left side of  in  
and  be the set of vertices that reside on the right side of 
. Note that  and 
.
Consider a simulation of protocol  by two parties  and .
The simulation works so that party  simulates the execution of  
in  and in , and party  simulates the 
execution of  in  and in . 
At the end of the simulation, party  outputs the output of vertex  
in the execution of . Every step of the distributed protocol  
is simulated by multiple bit exchanges between the parties  and . 
Party  sends to party   all messages sent in  by vertices in 
 to vertices in  and  party sends to party  
all messages sent in  by vertices in  to vertices in 
. Hence, the parties  and  have full knowledge of the 
configuration of vertices in  and are able to compute the 
configurations of vertices in  and vertices in  
respectively. Thus, parties  and   correctly simulate .

Combining the assumption that  with Corollary 
\ref{cl:bound-rho}, we get that the number of possible configuration of 
 in all possible executions of protocol  is smaller than 
. 
Hence there exist inputs  such that  
and protocol  reaches the same configuration of  when 
executed with input 
 or . 
Denote by  the execution of  on  with input 
, and by  the execution of  on  with 
input .
During both simulations of  and , parties  and 
 exchange the same sequence of messages (induced by the configuration 
of ). By Obs. \ref{l:similar-executions} we get that in the 
simulation of  on input 
,  and  exchange the same 
sequence of messages as in the simulation of .  Thus in both executions 
of protocol  ( and  with input ), 
vertex  has identical initial configuration and receives the same 
sequence of messages, hence it reaches the same decision,
in contradiction to the correctness of .
\end{proof}

\subsection {A lower bound for the MST problem on }
\label{sec:lb_ver_prob}

In this section we use the results achieved in the previous subsection,
and show that 
the distributed MST verification
problem cannot be solved faster than  rounds on weighted
versions of the graphs .
In order to prove this lower bound, 
we recall the definition given in  
of a family of weighted graphs , based on  but differing 
in their weight assignments.
Then, 
we show that any algorithm solving 
the MST verification problem on the graphs of  can also be used to 
solve the vector equality problem on  with the same time complexity.
Subsequently, the lower bound for the distributed MST verification problem 
follows from 
the lower bound given in the previous subsection for the vector 
equality problem on .

\subsubsection{The graph family }
The graphs  defined earlier were unweighted.
In this subsection, we define for every graph  a family of
weighted graphs
,
where  is an edge weight function.
In all the weight functions , all the edges of the
highway  and the paths  are assigned the weight .
The spokes of all stars except  and  are assigned
the weight 4. The spokes of the star  are assigned the weight 2.
The only differences between different weight functions 
occur on the  spokes of the star .
Specifically, each of these  spokes is assigned a weight of
either 1 or 3; there are thus  possible 
weight assignments. 
\newline\indent
Since discarding all spoke edges of weight 4 from the
graph  leaves it connected, and since every spoke
edge of weight 4 is the heaviest edge on some cycle in the graph, the
following is clear.

\begin{lemma}
\label{infWE}
No spoke edge of weight 4 belongs to the MST of ,
for every .
\end{lemma}

Let us pair the spoke edges of  and , denoting the th
pair (for ) by
.
The following is also clear.
\begin{lemma}
\label{finWE}
For every  and , exactly
one of the two edges of 
belongs to the MST of , namely, the lighter one.
Moreover, for every  and ,
all the edges of the highway  and the paths ,
for , belong to the MST of .
\end{lemma}

Note that the horizontal edges belong to the MST under any edge weight 
function. Of the remaining edges, exactly one of each pair will join the MST,
depending on the particular weight assignment to the spoke edges of
the star .

\subsubsection{The lower bound}

\begin{lemma}
\label{reduc2}
Any distributed algorithm for  MST verification on the graphs of the
class , can be used to solve the
 problem on  with the same
time complexity.
\end{lemma}

\begin{proof}
Consider an algorithm  for the MST verification problem, and 
suppose that we are given an instance of the 
problem with input strings  (stored in variables 
 and  respectively). We use the algorithm 
to solve this instance of vector equality problem as follows.
Vertices  and  initiate the construction of an
instance of the MST verification by turning  into a weighted graph from
, setting the edge weights and marking the edges participating in 
the MST candidate as follows:
for each , , vertex  sets the weight
variable  corresponding to the spoke edge ,
to be

In addition vertices  and  mark the edges participating in the MST 
candidate (that we wish to verify) in the following manner:  
for each , , vertex  sets 
the indicator variable  corresponding to the spoke edge 
,
to be

for each , , vertex  sets 
the indicator variable  corresponding to the spoke edge 
,
to be

The rest of the graph edges are assigned fixed weights as specified above.
All path edges and highway edges are marked 
as participating in the MST candidate. All spoke edges not belonging to stars 
 are marked as not participating in the MST candidate.  
Note that the weights of all the edges except those connecting  to its 
immediate neighbors in  do not depend on the particular input instance 
at hand. Similarly, for all edges except the spoke edges belonging to 
 the indicator variable for participating in the MST candidate 
does not depend on the instance at hand.  Hence a constant number of rounds
of communication between  and their   neighbors suffices 
for performing this assignment;  assigns its edges weights and indicator 
variables according to its input string , and needs to send at most 
a constant number of messages to each of its neighbors in , to notify it 
about the weight and the indicator variable of the spoke edge connecting them.
(Same argument holds for vertex ).
Every vertex  in the network,
upon receiving the first message of algorithm , assigns the
values defined by the edge weight function  to its
variables  and the corresponding indicator variable  
as described above.
(As discussed earlier, this does not require  to know , as
its assignment is identical under all weight functions ,
).
From this point on,  may proceed with executing algorithm
 for the MST verification problem.

Once algorithm  terminates,  vertex  
determines its output for the vector equality problem by stating that both input vectors are equal if and only if the MST verification algorithm verified that the given MST candidate is indeed a minimum spanning tree.
By Lemma \ref{finWE}, the lighter edge of each pair , for
, belongs to the MST; 
thus, by the construction of the MST candidate and the weight assignment 
to the edges of  the MST candidate forms a minimum spanning tree 
if and only if  the input vectors  for the vector equality problem are equal.
Hence the resulting algorithm  correctly solves the given instance
of the vector equality  problem.
\end{proof}

Combined with Lemma \ref{l:EQ-LB}, we now have:
\begin{theorem}
For every , any distributed algorithm for solving  MST verification 
problem on the graphs of the family  
requires  time.
\end{theorem}

\begin{corollary}
\label{cl:sqrtn2}
Any distributed algorithm for the MST verification problem 
requires  time on
some -vertex graphs of diameter .
\end{corollary} 

Theorem \ref{thm:lower-bound-time} follows.

\section{Message Complexity Lower Bound}
\label{sec:msg-lb}

We prove a message complexity lower bound of  on the 
{\em Spanning Tree (ST) verification} problem, which is a relaxed version 
of the MST verification problem defined as follows. 
Given a connected graph  and a subgraph  
(referred to as the {\em ST candidate}), we wish to decide whether  
is a spanning tree\footnote{Equivalently, we may consider also disconnected 
graphs, and require  to be a spanning forest of .}
of  (not necessarily of minimal weight). 
Clearly, a lower bound on the {\em ST verification} problem also applies 
to the {\em MST verification} problem. Since spanning tree verification 
is independent of the edge weights, for convenience 
we consider unweighted networks throughout this lower bound proof.

The case of single source node is easy. Here, given a  with spanning tree 
, if the execution does not send a message on some edge 
, then we simply break  to two edges by adding 
another vertex in the middle of . This brings us to the case where  
is no longer spanning, but the execution (and hence the output of nodes) 
remains the same.

In what follows, we consider the somewhat more difficult case where 
all nodes start the execution at the same time. 
We begin with a few definitions. Recall that a \textit{protocol} is a local 
program executed by all vertices in the network. 
In every step, each processor performs local computations, 
sends and receives messages, and changes its state according to the 
instructions of the protocol. A protocol achieving a given task should work 
on every network   and every ST candidate .

Following \cite{AGVP_90}, we
denote the {\em execution} of protocol  on network  with 
ST candidate  by  .
The {\em message history} of an execution 
is a sequence
describing the messages sent during the execution .
Consider a protocol , two graphs  and  over the 
same set of vertices , and two ST candidates  and  for  
and  respectively, 
and the corresponding executions  and 
. We say that the executions are {\em similar} 
if their message history is identical.

\begin{figure*}[htb]
\begin{center}
\begin{minipage}{\textwidth}
\centerline{\includegraphics[scale=0.6]{graph_G_MST-nonhomologous.pdf}}
\end{minipage}
\caption[]{
\label{f:Graph_G_MST}
\sf Graph  with ST candidate  (the bold edges belong to )}
\end{center}
\end{figure*}

Let  be a graph (together with an assignment 
of vertex identifiers), 
 be a subgraph and let  and  be two of its edges.
(See example in Figure \ref{f:Graph_G_MST}.) 
Let   be some copy of , where the identifiers of 
the vertices in  are not only pairwise distinct but also distinct 
from the given identifiers on . Consider the following graphs 
 and  and the subgraph~. 
\begin{itemize}
\item
 Graph  is simply .
The subgraph  of  is defined as the union of the two copies of , 
one in  and the other in . See example in Figure~\ref{f:Graph_G2_MST}.
Note that  is not connected, hence it is not a legal input to our problem.
\item
The graph  is a ``cross-wired'' version of . 
Formally,
, where 
. 
(Observe that for ,  is also a subgraph of .) 
See example in Figure~\ref{f:Graph_G2_e_MST}.
\end{itemize}

\begin{figure*}[htb]
\begin{center}
\begin{minipage}{\textwidth}
\centerline{\includegraphics[scale=0.6]{graph_G2_MST-nonhomologous.pdf}}
\end{minipage}
\caption[]{
\label{f:Graph_G2_MST}
\sf Graph  with ST candidate  (the bold edges belong to )}
\end{center}
\end{figure*}

\begin{figure*}[htb]
\begin{center}
\begin{minipage}{\textwidth}
\centerline{\includegraphics[scale=0.6]{graph_G2_e_MST-nonhomologous.pdf}}
\end{minipage}
\caption[]{
\label{f:Graph_G2_e_MST}
\sf Graph  with ST candidate  (the bold edges belong to )}
\end{center}
\end{figure*}

Let  be a protocol that correctly solves the ST verification problem.
Fix  to be some arbitrary graph, fix a copy  of , 
fix a spanning tree  of , 
and consider  the execution of  on either of the graphs  and  
with the ST candidates  and , respectively. 
We stress  that  (with candidate ) is not a valid input for the ST 
(or the MST) verification problem since it is not connected. 
Still, we can consider the execution , 
without requiring anything from its output.

\begin{lemma} 
\label{lem_similarity} 
Let  and , such that no 
message is sent over the edges  and  in execution . 
Then executions  and  
are similar.
\end{lemma}

\begin{proof}
We show that in both executions each vertex sends and receives identical 
sequences of messages in each communication round of the protocol. 
Note that at each round the messages sent by some vertex  are dependent 
on 's topological view (neighbors of ), 's initial input 
(its identity and the indicator variables of the edges incident to ), and 
the set of messages sent and received by  in previous communication rounds.
Denote by  and   executions  and  
 respectively. Note that any vertex 
 has identical topological view and 
identical initial input in both executions. Vertex  has identical 
initial input and  identical number of neighbors in both  executions. 
Although the communication link connecting  to  in  connects 
 to  in , vertex  is initially unaware of this difference 
between the executions since it does not know the identifiers of its neighbors.
(The same holds for vertices ,  and .) 
The proof is by induction on , 
the number of communication rounds of protocol .

\noindent\textbf{Induction base:} For . In the first communication round, 
the messages sent by each vertex depend solely on its topological view 
and initial input. Let us analyze the sequence of messages sent by vertices 
in  (the vertices of graphs  and  that belong to the first copy 
of ). Following are the possible cases.

\begin{itemize}
\item Vertex : Vertex  has identical topological view 
and identical initial input in both execution, thus it sends identical 
sequences of messages in the first round of both executions.
\item
Vertex : As mentioned above, although in execution  vertex  
is connected to  instead of , it has no knowledge of this difference. 
Thus   sends identical sequences of messages over each of its communication 
links. The fact that no messages are sent over edge  in execution , 
implies that in execution  no message is sent by  to its 
neighbor . Thus,  sends identical sequences of messages in the 
first communication round of both executions.
\item
Vertex : can be analyzed in the same manner as vertex .
\end{itemize}
\noindent
The above shows that  vertices in  send the same sequence of messages 
in the first communication round of both executions. The induction base claim 
follows by applying the same argument on vertices of .

\noindent\textbf{Inductive step:} Can be shown using a similar case analysis as 
in the induction base.
\end{proof}

Theorem \ref{thm:lower-bound-msgs} follows as a consequence of the following 
Lemma.
\begin{lemma}
\label{clm_msg_lb}
Execution 
 requires  messages.
\end{lemma}

\begin{proof}
Assume, towards contradiction, that there exists a protocol  
that correctly solves the ST verification problem for every graph  and 
ST candidate , such that execution  sends fewer than
 messages over edges from .

For the rest of the proof we fix  to be an arbitrary connected graph 
and denote the ST candidate by .
We take  to be a spanning tree and not just any subgraph.
(See Figure \ref{f:Graph_G_MST}).
 
Consider the graph  as previously defined with ST candidate 
 
(See Figure \ref{f:Graph_G2_MST}).  

Then by the assumption on , 
execution  sends fewer than 
 messages over edges from . 
Hence there exist  and  such that 
 and no message is sent over  and  
in execution . Consider the graph  with ST candidate  
as previously defined (See Figure \ref{f:Graph_G2_e_MST}).

By Lemma \ref{lem_similarity}, executions  and  
are similar. Note that , 
thus  is not a spanning tree of  (since the two copies of    
contained in  are connected solely by edges  and ). 
Since   correctly solves the ST verification problem, the output 
of all vertices in  is ``0'' (i.e., the given ST candidate  is not 
a spanning tree of the graph ). 

On the other hand, consider the execution 
 with ST candidate . Note that  is exactly the 
restriction of  on the first copy of  contained in . 
Since  contains two disconnected copies of  the output of all vertices 
in execution  will be identical to the output of the same vertices 
in  (since in both executions the vertices have identical topological view 
and the input variables contain identical values). 
Since executions  and  are similar, the output of  is ``0'', 
in contradiction to the correctness of .
\end{proof}

\clearpage


\begin{thebibliography}{10}

\dnsbibitem{AKY97}
Y.~Afek, S.~Kutten, and M.~Yung.
\newblock The local detection paradigm and its applications to self
  stabilization.
\newblock {\em Theoretical Computer Science}, 186(1-2):199--230, 1997.

\dnsbibitem{A87}
B.~Awerbuch.
\newblock Optimal distributed algorithms for minimum weight spanning tree,
  counting, leader election, and related problems.
\newblock In {\em Proc. 19th ACM Symp. on Theory of computing (STOC)}, 
  230--240, NY, 1987.

\dnsbibitem{APV}
B.~Awerbuch, B.~Patt-Shamir, and G.~Varghese.
\newblock Self-stabilization by local checking and correction.
\newblock In {\em Proc. IEEE Symp. on the Foundations of Computer Science},
  268--277, 1991.

\dnsbibitem{AGVP_90}
B. Awerbuch, O. Goldreich, R. Vainish, and D. Peleg.
\newblock A trade-off between information and communication in broadcast
  protocols.
\newblock {\em J. ACM}, 37(2):238--256, 1990.

\dnsbibitem{BGKRTW_08}
A.L. Buchsbaum, L. Georgiadis, H. Kaplan, A. Rogers, R.E. Tarjan, and 
J.R. Westbrook.
\newblock Linear-time algorithms for dominators and other path-evaluation
  problems.
\newblock {\em SIAM J. on Computing}, 38(4):1533--1573, 2008.

\dnsbibitem{B_80}
J.E. Burns.
\newblock A formal model for message passing systems.
\newblock Technical Report TR-91, Computer Science Dept., Indiana University,
  Bloomington, 1980.

\dnsbibitem{CGKK95}
I.~Cidon, I.~Gopal, M.~Kaplan, and S.~Kutten.
\newblock A distributed control architecture of high-speed networks.
\newblock {\em IEEE Trans. on Communications}, 43(5):1950--1960, 1995.

\dnsbibitem{DHKKNPPW}
A.~Das Sarma, S.~Holzer, L.~Kor, A.~Korman, D.~Nanongkai, G.~Pandurangan,
  D.~Peleg, and R.~Wattenhofer.
\newblock Distributed verification and hardness of distributed approximation.
\newblock In {\em Proc. 43th ACM Symp. on Theory of computing (STOC)}, 2011.

\dnsbibitem{NDP11}
A.~Das Sarma, D.~Nanongkai, and G.~Pandurangan.
\newblock A tight unconditional lower bound on distributed random walk
  computation.
\newblock In {\em Proc. 30th ACM SIGACT-SIGOPS Symp. on Principles of
  Distributed Computing (PODC)}, 2011.


\dnsbibitem{DixonRauchTarjan}
B.~Dixon, M.~Rauch, and R.E. Tarjan.
\newblock Verification and sensitivity analysis of minimum spanning trees in
  linear time.
\newblock {\em SIAM J. on Computing}, 21(6):1184--1192, 1992.

\dnsbibitem{DixonTarjan}
B.~Dixon and R.E. Tarjan.
\newblock Optimal parallel verification of minimum spanning trees in
  logarithmic time.
\newblock {\em Algorithmica}, 17(1):11--18, 1997.

\dnsbibitem{silent}
S.~Dolev, M.~Gouda, and M.~Schneider.
\newblock Requirements for silent stabilization.
\newblock {\em Acta Informatica}, 36(6):447--462, 1999.

\dnsbibitem{FKP11}
P. Fraigniaud, A. Korman, and D.  Peleg.
\newblock Local Distributed Decision. 
\newblock FOCS 2011: 708-717

\dnsbibitem{FKPP12}
P. Fraigniaud, A. Korman, M. Parter, and D. Peleg.
\newblock Randomized Distributed Decision. 
\newblock DISC 2012: 371-385

\dnsbibitem{FL_84}
G.N. Frederickson and N.A. Lynch.
\newblock The impact of synchronous communication on the problem of electing a
  leader in a ring.
\newblock In {\em Proc. 16th ACM Symp. on Theory of computing (STOC)}, 
  493--503, NY, 1984.

\dnsbibitem{FredmanWillard}
M.~L. Fredman and D.~E. Willard.
\newblock Trans-dichotomous algorithms for minimum spanning trees and shortest
  paths.
\newblock {\em Proc. 31st IEEE FOCS}, 719--725, 1990.

\dnsbibitem{GHS_83}
R.~G. Gallager, P.~A. Humblet, and P.~M. Spira.
\newblock A distributed algorithm for minimum-weight spanning trees.
\newblock {\em ACM Trans. Program. Lang. Syst.}, 5(1):66--77, 1983.

\dnsbibitem{GKP98}
J.~Garay, S.~A. Kutten, and D.~Peleg.
\newblock A sub-linear time distributed algorithm for minimum-weight spanning
  trees.
\newblock {\em SIAM J. on Computing}, 27(1):302--316, 1998.

\dnsbibitem{GH85}
R.~L. Graham and P.~Hell.
\newblock On the history of the minimum spanning tree problem.
\newblock {\em Ann. Hist. Comput.}, 7(1):43--47, 1985.

\dnsbibitem{Harel85}
D.~Harel.
\newblock A linear time algorithm for finding dominators in flow graphs and
  related problems.
\newblock In {\em Proc. 17th ACM Symp. on Theory of computing (STOC)}, 
  185--194, 1985.

\dnsbibitem{KargerKleinTarjan}
D.R Karger, P.N. Klein, and R.~E. Tarjan.
\newblock A randomized linear-time algorithm to find minimum spanning trees.
\newblock {\em J. ACM}, 42(2):321--328, 1995.

\dnsbibitem{KKKP_05}
M.~Katz, N.A. Katz, A.~Korman, and D.~Peleg.
\newblock Labeling schemes for flow and connectivity.
\newblock {\em SIAM J. Comput.}, 34(1):23--40, 2005.

\dnsbibitem{king97}
V.~King.
\newblock A simpler minimum spanning tree verification algorithm.
\newblock {\em Algorithmica}, 18:263--270, 1997.

\dnsbibitem{king2}
V.~King, C.K Poon, V~Ramachandran, and S.~Sinha.
\newblock An optimal erew pram algorithm for minimum spanning tree
  verification.
\newblock {\em Information Processing Letters}, 62(3):153--159, 1997.

\dnsbibitem{Komlos}
J.~Komls.
\newblock Linear verification for spanning trees.
\newblock {\em Combinatorica}, 5:57--65, 1985.

\dnsbibitem{KK07}
A.~Korman and S.~Kutten.
\newblock Distributed verification of minimum spanning trees.
\newblock {\em Distributed Computing}, 20(4):253--266, 2007.

\dnsbibitem{KKP10}
A.~Korman, S.~Kutten, and D~Peleg.
\newblock Proof labeling schemes.
\newblock {\em Distributed Computing}, 22(4):215--233, 2010.

\dnsbibitem{KUS_97}
E. Kushilevitz and N. Nisan.
\newblock {\em Communication complexity}.
\newblock Cambridge Univ. Press, NY, 1997.

\dnsbibitem{KP_98}
S. Kutten and D. Peleg.
\newblock Fast distributed construction of small k-dominating sets and
  applications.
\newblock {\em J. Algorithms}, 28(1):40--66, 1998.

\dnsbibitem{KPPRT12}
S. Kutten, G. Pandurangan, D. Peleg, P. Robinson, and A. Trehan.
Universal Bounds for Leader Election.
Unpublished manuscript, 2012.

\dnsbibitem{LPP_01}
Z. Lotker, B. Patt-Shamir, and D. Peleg.
\newblock Distributed mst for constant diameter graphs.
\newblock In {\em Proc. 20th ACM Symp. on Principles of distributed computing
  (PODC)}, 63--71, NY, 2001.

\dnsbibitem{PR_00}
D.~Peleg and V.~Rubinovich.
\newblock A near-tight lower bound on the time complexity of distributed
  minimum-weight spanning tree construction.
\newblock {\em SIAM J. Comput.}, 30(5):1427--1442, 2000.

\dnsbibitem{optimalMST}
S.~Pettie and V.~Ramachandran.
\newblock An optimal minimum spanning tree algorithm.
\newblock {\em J. ACM}, 49(1):16--34, 2002.

\dnsbibitem{Vitaly}
V. Rubinovich.
\newblock Distributed minimum spanning tree construction.
\newblock Master's thesis, Department of Computer Science and Applied
  Mathematics, The Weizmann Institute of Science, 1999.

\dnsbibitem{Tarjan79}
R.E. Tarjan.
\newblock Applications of path compression on balanced trees.
\newblock {\em J. ACM}, 26:690--715, 1979.

\dnsbibitem{T83}
R.E. Tarjan.
\newblock {\em Data Structures and Network Algorithms}.
\newblock SIAM, 1983.

\end{thebibliography}

\end{document}
