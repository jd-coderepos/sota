

\documentclass[submission,copyright,creativecommons]{eptcs}
\usepackage{amssymb,latexsym,leqno,breakurl}
\usepackage{theorem} \usepackage{amsmath} 

\usepackage{hyperref} 

\newsavebox{\blah}
\savebox{\blah}{\scriptsize }
\newsavebox{\blahb}
\savebox{\blahb}{\scriptsize }

\newcommand{\ab}[1]{(\emph{\small AB:\ #1})\marginpar{}}
\newcommand{\dn}[1]{(\emph{\small DN:\ #1})\marginpar{}}

\newcommand{\comment}[1]{{\bf #1}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\eg}{{\em e.g.}}
\newcommand{\etc}{{\em etc}}
\newcommand{\viz}{{\em viz.}}
\newcommand{\cf}{{\em cf.}}

\newcommand{\inj}{{\mathit{inj}}}
\newcommand{\reds}{\rightarrow^*}
\renewcommand{\i}[1]{{\it #1\/}}       \newcommand{\rom}[1]{{\rm #1}}         \newcommand{\s}[1]{{\cal #1}}          \renewcommand{\b}[1]{{\bf #1}}         \newcommand{\mathify}[1]{\ifmmode{#1}\else\mbox{}\fi}
\newcommand{\blackslug}{\rule{7pt}{7pt}}
\newcommand{\Rule}[2]{          \begin{array}{c}
  #1 \\\hline
  #2
  \end{array}}

\newcommand{\RuleSide}[3]{
  \begin{array}{c}
  #1 \\\hline #2
  \end{array}
  {~~#3}}
\newcommand{\RuleSideAlt}[3]{
  \begin{array}{c}
  #1 \\\hline #2
  \end{array}
  ~~~~[#3]}





\newcommand{\sierp}{{\bf O}}
\newcommand{\Def}{{\bf Def}}

\newcommand{\sequence}[3]{\SEQ\; #1=#2\;\IN\;#3}
\newcommand{\letml}[3]{\LET\; #1=#2\;\IN\;#3}
\newcommand{\mletml}[3]{\MLET\;#1=#2\;\MIN\;#3}
\newcommand{\lift}[1]{\LIFT\;#1}
\newcommand{\ifthenelse}[3]{\IF\;#1\;\THEN\;#2\;\ELSE\;#3}
\newcommand{\mifthenelse}[3]{\MIF\;#1\;\MTHEN\;#2\;\MELSE\;#3}
\newcommand{\enable}[2]{\ENABLE\;#1\;\IN\;#2}
\newcommand{\chk}[2]{\CHK\;#1\;\FOR\;#2}
\newcommand{\test}[3]{\TEST\;#1\;\THEN\;#2\;\ELSE\;#3}
\newcommand{\signs}[2]{\SIGNS\;#1\;#2}
\newcommand{\vsequence}[3]{\!\!\!\!\!\begin{array}[t]{l}
                            \SEQ\:{#1} = {#2}\;\IN\\
                            {#3}
                            \end{array}}
\newcommand{\vlet}[4]{\!\!\!\!\!\begin{array}[t]{l}
                            \LET\;{#1}\\
                            \;\;\;\;\;\;\;{#2}\\
                            \;\;\;\;\;\;\;{#3}\\
                            \IN\;\;{#4}
                            \end{array}}
\newcommand{\vmlet}[2]{\begin{array}[t]{l} \MLET\;{#1}\;\MIN\\
                            {#2}
                            \end{array}}
\newcommand{\vletcaml}[5]{\!\!\!\!\!\begin{array}[t]{l}
                            \LET\:{#1} = {#2}\;\IN\\
                            \LET\:{#3} = {#4}\;\IN
                             {#5}
                            \end{array}}
\newcommand{\letrecml}[3]{\LETREC\; #1=#2\;\IN\;#3}
\newcommand{\BOOL}{\mbox{\texttt{bool}}}
\newcommand{\ELSE}{\mbox{\texttt{else}}}
\newcommand{\FALSE}{\mbox{\texttt{false}}}
\newcommand{\IF}{\mbox{\texttt{if}}}
\newcommand{\FOR}{\mbox{\texttt{for}}}
\newcommand{\IN}{\mbox{\texttt{in}}}
\newcommand{\MIN}{\mbox{\textbf{in}}}
\newcommand{\INJ}{\mbox{\texttt{inj}}}
\newcommand{\LET}{\mbox{\texttt{let}}}
\newcommand{\MLET}{\mbox{\textbf{let}}}
\newcommand{\LETREC}{\mbox{\texttt{let\ rec}}}

\newcommand{\LIFT}{{\texttt{lift}}}
\newcommand{\REC}{{\texttt{rec}}}
\newcommand{\SEQ}{{\texttt{seq}}}
\newcommand{\THEN}{{\texttt{then}}}
\newcommand{\MTHEN}{{\textbf{then}}}
\newcommand{\MELSE}{{\textbf{else}}}
\newcommand{\MIF}{{\textbf{if}}}
\newcommand{\TRUE}{{\texttt{true}}}
\newcommand{\UNIT}{\ifmmode \mathchoice{{\texttt{unit}}}
           {{\texttt{unit}}}
           {\mbox{\scriptsize\tt unit}}
           {\mbox{\tiny\tt unit}}
\else{\texttt{unit}}
\fi}



\newcommand{\M}{\s{M}}
\newcommand{\N}{\s{N}}
\newcommand{\C}{\s{C}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\s{B}}
\newcommand{\K}{\s{K}}
\newcommand{\R}{\s{R}}
\renewcommand{\L}{\s{L}}
\renewcommand{\P}{\mathcal{P}}



\newcommand{\dom}{{\it dom}}
\newcommand{\range}{{\it range}}




\newcommand{\vpcf}{{\textsf{VPCF}}}
\newcommand{\pc}{{{PCFA}}}

\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\means}[1]{\ldb {#1}\rdb}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\proves}{\vdash}
\newcommand{\ext}[3]{[#1\mid#2\!\mapsto\!#3]}
\newcommand{\recext}[5]{[#1\mid#2\!\mapsto\!#3,#4\!\mapsto\!#5]}
\newcommand{\comp}{\circ}
\newcommand{\lam}[2]{\lambda #1.\; #2} \newcommand{\all}[2]{\forall #1.\; #2}
\newcommand{\logor}{\vee}
\newcommand{\Empty}{\varnothing}
\newcommand{\Union}{\bigcup}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\def\lpields#1{\stackrel{#1}{\longrightarrow}}
\newcommand{\annoto}[1]{\lpields {\scriptscriptstyle #1}}
\newcommand{\To}{\Rightarrow}
\newcommand{\rto}{\leftrightarrow}
\newcommand{\pto}{\rightharpoonup}
\newcommand{\haltsat}{\Downarrow}

\newcommand{\Coerce}{{\mathit{Coerce}}}
\newcommand{\coerce}[2]{\Coerce_{#1}^{#2}}
\newcommand{\Coercec}{\Coerce^{\C}}

\newcommand{\recdecl}[3]{\REC\;#1(#2) = #3}
\newcommand{\inl}[1]{\INJ_1\;#1}
\newcommand{\inr}[1]{\INJ_2\;#1}
\newcommand{\fst}[1]{\PROJ_1\;#1}
\newcommand{\snd}[1]{\PROJ_2\;#1}
\newcommand{\fix}{\textit{fix}}
\newcommand{\lub}{\sqcup}
\newcommand{\Lub}{\bigsqcup}
\newcommand{\sectionrule}[2]{\subsection*{{\bf#1}\hfill\fbox{}}}
\newcommand{\infrule}[2]
 {}
\newcommand{\infrulelabel}[3]
 {}

\newcommand{\nats}{{\mathbb{N}}}
\newcommand{\PRINC}{{\mathsf{Principals}}}
\newcommand{\PRIV}{{\mathsf{Privileges}}}
\newcommand{\ENABLE}{\mbox{\texttt{dopriv}}}
\newcommand{\CHK}{\mbox{\texttt{check}}}
\newcommand{\TEST}{\mbox{\texttt{test}}}
\newcommand{\SIGNS}{\mbox{\texttt{signs}}}

\newcommand{\safe}{\textsf{safe}}
\newcommand{\pure}{\textsf{pure}}
\renewcommand{\check}{\textsf{chk}}
\newcommand{\privs}{\textsf{privs}}
\newcommand{\Sim}{\textsf{sim}}
\newcommand{\Rel}{\textsf{rel}}

\newcommand{\stacks}{\textsf{Stacks}}

\newcommand{\letdecl}[2]{\LET#1\;\IN\;#2}
\newcommand{\LAM}[2]{{\mathtt{fun}\; #1.\; #2}}

\newcommand{\D}{D} \newcommand{\ty}{t} \renewcommand{\th}{\theta} 

\newcommand{\n}{n} \newcommand{\p}{p} \newcommand{\Ps}{\Pi} \newcommand{\h}{h} 

\newcommand{\meanss}[1]{(\![ {#1}]\!)} 

\renewcommand{\implies}{\mathbin{\:\Rightarrow\:}}
\renewcommand{\iff}{\mathbin{\:\Leftrightarrow\:}}
\newcommand{\eqdef}{\mathrel{\:\widehat{=}\:}}
\newcommand{\Iacute}{\'{i}}



{\theorembodyfont{\rmfamily} 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{factx}[theorem]{Fact}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
}

\newenvironment{proof}{\begin{trivlist}\item[\hskip\labelsep{\bf
Proof:}]}{\blackslug\end{trivlist}}
\newenvironment{xproof}{\begin{trivlist}\item[\hskip\labelsep{\bf  
Proof:}]}{\end{trivlist}}





\DeclareSymbolFont{italics}{OT1}{cmr}{m}{it}

\DeclareMathSymbol{a}{\mathalpha}{italics}{"61}
\DeclareMathSymbol{b}{\mathalpha}{italics}{"62}
\DeclareMathSymbol{c}{\mathalpha}{italics}{"63}
\DeclareMathSymbol{d}{\mathalpha}{italics}{"64}
\DeclareMathSymbol{e}{\mathalpha}{italics}{"65}
\DeclareMathSymbol{f}{\mathalpha}{italics}{"66}
\DeclareMathSymbol{g}{\mathalpha}{italics}{"67}
\DeclareMathSymbol{h}{\mathalpha}{italics}{"68}
\DeclareMathSymbol{i}{\mathalpha}{italics}{"69}
\DeclareMathSymbol{j}{\mathalpha}{italics}{"6A}
\DeclareMathSymbol{k}{\mathalpha}{italics}{"6B}
\DeclareMathSymbol{l}{\mathalpha}{italics}{"6C}
\DeclareMathSymbol{m}{\mathalpha}{italics}{"6D}
\DeclareMathSymbol{n}{\mathalpha}{italics}{"6E}
\DeclareMathSymbol{o}{\mathalpha}{italics}{"6F}
\DeclareMathSymbol{p}{\mathalpha}{italics}{"70}
\DeclareMathSymbol{q}{\mathalpha}{italics}{"71}
\DeclareMathSymbol{r}{\mathalpha}{italics}{"72}
\DeclareMathSymbol{s}{\mathalpha}{italics}{"73}
\DeclareMathSymbol{t}{\mathalpha}{italics}{"74}
\DeclareMathSymbol{u}{\mathalpha}{italics}{"75}
\DeclareMathSymbol{v}{\mathalpha}{italics}{"76}
\DeclareMathSymbol{w}{\mathalpha}{italics}{"77}
\DeclareMathSymbol{x}{\mathalpha}{italics}{"78}
\DeclareMathSymbol{y}{\mathalpha}{italics}{"79}
\DeclareMathSymbol{z}{\mathalpha}{italics}{"7A}

\DeclareMathSymbol{A}{\mathalpha}{italics}{"41}
\DeclareMathSymbol{B}{\mathalpha}{italics}{"42}
\DeclareMathSymbol{C}{\mathalpha}{italics}{"43}
\DeclareMathSymbol{D}{\mathalpha}{italics}{"44}
\DeclareMathSymbol{E}{\mathalpha}{italics}{"45}
\DeclareMathSymbol{F}{\mathalpha}{italics}{"46}
\DeclareMathSymbol{G}{\mathalpha}{italics}{"47}
\DeclareMathSymbol{H}{\mathalpha}{italics}{"48}
\DeclareMathSymbol{I}{\mathalpha}{italics}{"49}
\DeclareMathSymbol{J}{\mathalpha}{italics}{"4A}
\DeclareMathSymbol{K}{\mathalpha}{italics}{"4B}
\DeclareMathSymbol{L}{\mathalpha}{italics}{"4C}
\DeclareMathSymbol{M}{\mathalpha}{italics}{"4D}
\DeclareMathSymbol{N}{\mathalpha}{italics}{"4E}
\DeclareMathSymbol{O}{\mathalpha}{italics}{"4F}
\DeclareMathSymbol{P}{\mathalpha}{italics}{"50}
\DeclareMathSymbol{Q}{\mathalpha}{italics}{"51}
\DeclareMathSymbol{R}{\mathalpha}{italics}{"52}
\DeclareMathSymbol{S}{\mathalpha}{italics}{"53}
\DeclareMathSymbol{T}{\mathalpha}{italics}{"54}
\DeclareMathSymbol{U}{\mathalpha}{italics}{"55}
\DeclareMathSymbol{V}{\mathalpha}{italics}{"56}
\DeclareMathSymbol{W}{\mathalpha}{italics}{"57}
\DeclareMathSymbol{X}{\mathalpha}{italics}{"58}
\DeclareMathSymbol{Y}{\mathalpha}{italics}{"59}
\DeclareMathSymbol{Z}{\mathalpha}{italics}{"5A}
 \title{A Simple Semantics and Static Analysis for Stack Inspection}
\author{Anindya Banerjee 
\institute{IMDEA Software Institute\\ Madrid, Spain}\thanks{Partially 
supported by NSF grant EIA-980635, by Madrid Regional Government MINECO Project TIN2009-14599-C03-02 Desafios and EU NoE Project 256980 Nessos.
}
\email{anindya.banerjee@imdea.org}
\and
David A.~Naumann
\institute{Stevens Institute of Technology\\ Hoboken, NJ 07030, USA}\thanks{Partially supported by NSF grants INT-9813854 and CNS-1228930.}
\email{naumann@cs.stevens.edu}
}
\def\titlerunning{A Simple Semantics and Static Analysis for Stack Inspection}
\def\authorrunning{A.~Banerjee \& D.~A.~Naumann}
\begin{document}
\maketitle

\begin{abstract}
The Java virtual machine and the .NET common language runtime feature an access control mechanism specified operationally in
terms of run-time stack inspection.
We give a denotational semantics in ``eager'' form, and show that it is equivalent to
the ``lazy'' semantics using stack inspection.  
We give a static analysis of safety, \ie, the absence of security errors,
that is simpler than previous proposals.   
We identify several program transformations that can be used to remove run-time
checks.  We give complete, detailed proofs for safety of the analysis and for the
transformations, exploiting compositionality of the eager semantics.
\end{abstract}



\section{Introduction}
\label{sec:intro}

System security depends in part on protecting resources through
specified access control policies. For example, a policy may allow
only some users the privilege to write the password file.  A typical
implementation of the policy found \eg, in UNIX operating systems,
involves an access control list  which associates with each user
name  their set of privileges .  When a program is running
it has an associated user, normally the user who invoked the program.
To write a file, a program for user  must make a system call, and
that system code checks whether  includes the privilege of
writing to the file. In order for users to be able to change their
passwords, the system code for this task executes in a special mode
(``setuid'' in UNIX); the effective user is the owner of the code
(say, \textit{root}) rather than the originator of the call (,
which can write some files but not the password file).

The Java and .NET platforms offer a similar but more general security system \cite{Gong99,LaMacchiaEtal02}.
Instead of code being owned by a user or
by ``the system'', there can be code from a number of sources, called
\emph{principals}, which can be offered varying degrees of trust.
Moreover, instead of associating a principal with a loadable
executable file, principals can be associated with fragments such as
class declarations.  Another refinement is that
privileges must be explicitly enabled, by an operation called
\texttt{doPrivileged}.  The intent is that a program only enables its
privileges when they are needed; this ``principle of least privilege''
\cite{Gong99} may help isolate the effect of security bugs and may
facilitate static analysis.  Before executing a dangerous operation, a
check is made that the associated privilege has been enabled and is
authorized for the current principal.  This check is specified in
terms of an implementation called \textit{stack inspection}.  Each
stack frame is marked with the principal associated with the code for
that frame, and the frame also records the privileges that have been
enabled.  This is used by procedure \texttt{checkPermission} which
inspects the current stack.    

The above description of the security system is an operational one.
While the mechanism itself is easy to understand, it may over-constrain implementations,
and it is difficult to analyze.
Analysis is of interest, e.g., to determine whether a program can exhibit security exceptions when given its expected permissions.  
Implementations of procedure calls do not always push stack, e.g., owing to inlining or tail call optimization.  
To understand the security properties achieved, and to optimize performance, we need analyses that capture the security model more abstractly.  

Our contribution is threefold: 
(i) We give a denotational semantics in ``eager'' form,
and show that it is equivalent to the ``lazy'' semantics using stack inspection.
(ii) We give a static analysis of \emph{safety}, \ie, the absence of security errors.
(iii) We identify several program transformations including some that can be used to remove run-time
checks. 
We give detailed proofs for the analysis and for the transformations, exploiting compositionality of the eager semantics and simplicity of program equivalence in denotational semantics.




\paragraph{Related work.}

Skalka and Smith \cite{SkalkaS:ICFP00} give an operational semantics
and use it to justify a static analysis of safety specified by a type system.  
Their type system is complicated by the choice of using a constraint system
which is the basis for a type inference algorithm.  We use a similar type system, but 
prefer to separate the specification of an analysis from algorithms to perform the
analysis.  We also include recursion in the language.
Their semantics is easily seen to model the operational descriptions of stack
inspection, but it has the usual shortcomings of operational semantics; for example, proofs ultimately go by induction on computations. 


Wallach, Appel and Felten~\cite{WallachAF00} model the mechanism with
an operational semantics that manipulates formulas in a logic
of authentication \cite{AbadiBLP93}.  They show that the particular logical
deductions corresponding to \texttt{checkPermission} can be decided
efficiently, and propose an implementation called ``security passing
style'' in which the security state is calculated in advance.  The
only result proven is equivalence of the two implementations.  They do
not include recursion or higher order functions, and
the formal semantics is not made explicit.  Although the use of logic
sheds some light on the security properties achieved by the mechanism,
the approach requires a considerable amount of theory that is not
directly germane to analyzing safety or justifying optimizations.

Security passing style can be seen as a presentation of the eager
means of evaluating security checks mentioned by Li Gong~\cite{Gong99}.  
The eager semantics facilitates proofs, but JVM and CLR implementations
use lazy semantics which appears to have better performance \cite{Gong99,WallachAF00,LaMacchiaEtal02}.  

Pottier \emph{et al.} \cite{PottierSS05} formalize the eager semantics by a
translation into a lambda calculus, , with operations on sets.  Using an operational semantics for the
calculus, a proof is sketched of equivalence with stack semantics.  Using a very
general framework for typing, a static analysis is given and a safety
result is sketched.  The language extends the language of 
Skalka and Smith \cite{SkalkaS:ICFP00} by adding permission tests.
The works \cite{SkalkaS:ICFP00} and \cite{PottierSS05} aim to replace dynamic checks by static ones, 
but do not consider program transformations as such.

This paper originated as a technical report more than a decade ago \cite{tr2001-1}.
At about the same time, and independently, Fournet and Gordon~\cite{FournetG03} 
investigated an untyped variant of . They develop an equational theory that can be used to prove the correctness of code optimizations in the presence of stack inspection. A prime motivation for their work was the folklore that well-known program optimizations such as inlining and tail call elimination are invalidated by stack inpection. Their technical development uses small-step operational semantics and contextual equivalence of programs.
To prove an extensive collection of program equivalences they develop a form of applicative bisimilarity. Additionally, they prove the equivalence of the lazy and eager implementations of stack inspection. This equivalence is also proved in Skalka's Ph.D. dissertation~\cite[Theorem 4.1, Chapter 4]{skalka:phd}, where lazy and eager are termed ``backward'' and ``forward'' stack inspection respectively.





Where Fournet and Gordon point out how tail call elimination can be invalidated by stack inspection, Clements and Felleisen~\cite{ClementsF04}
consider program semantics at the level of an abstract machine, namely the 
CESK machine. With this semantics they are able to show tail call optimization can be validated in full generality, and with its expected space savings. This is explored further by Ager et al~\cite{Ager05afunctional}.
They inter-derive a reduction semantics for the untyped
variant of the -calculus, an abstract machine,
and a natural semantics, both without and with tail-call optimization.
By unzipping the context in the abstract machine, they connect these
semantics to Wallach \emph{et al.}'s security passing
style, characterize stack inspection as a
computational monad, and combine this monad with the monad of
exceptions.\footnote{Thanks to Olivier Danvy for communicating this explanation.}

We treat a simply typed language similar to , but with recursion.
In contrast to the cited works we use a denotational semantics, which is 
straightforward; 
in fact, once the meanings
of types are specified, the rest of the specification (\ie, meanings of
expressions) follows easily.\footnote{Adding state is straightforward \cite{BanerjeeNaumann02a}, but here  we follow the cited works and confine attention to applicative expressions.}
The simplicity of our model makes it
possible to give a self-contained formal semantics and succinct but complete formal
proofs.  For example, denotational equality is a congruence simply because the semantics is compositional.
We have not formally connected the semantics with an operational one.
Adequacy seems obvious. Full abstraction is not obvious, but we have proved many of the contextual equivalences of Fournet and Gordon~\cite{FournetG03} and expect the remainder to be straightforward to show.

In addition to considering program transformations, Fournet and Gordon~\cite{FournetG03} 
 address the question of what security properties can be enforced by stack inspection.  They consider a variation that tracks history in the sense of what code has influenced the result of a computation.  Pistoia et al \cite{PistoiaBanerjeeNaumann} propose a variation that tracks implicit influences as well.  The authors \cite{BanerjeeNaumann03b} propose another combination of information flow tracking with stack inspection, using a type and effect system  where security types for functions are dependent on available permissions. 
In the interim, other code-based access mechanisms have been introduced (e.g., static permissions in the Android platform) and there have been further development of static analyses for security properties based on linear temporal logic~\cite{BessonJM01,BessonBFG04,BessonLJ05,skalkaSVh08},
but there seems to be little additional work on program equivalence in the presence of stack inspection. 



\paragraph{Outline.}

The next section explains stack inspection informally, and it introduces our language.
Section~\ref{sec:ds} gives the eager denotational semantics.
Section~\ref{sec:sa} gives the static analysis for safety, including examples and correctness proof.
Section~\ref{sec:tran} proves a number of representative program transformations.
Section~\ref{sec:use} shows how all checks can be removed from safe programs.
Section~\ref{sec:stk} gives the stack-based denotational semantics and shows that it is equivalent to the eager semantics.
Section~\ref{sec:disc} concludes.

\section{Overview and language} 
\label{sec:ov}


Each declared procedure is associated with a principal .  We call
 the \emph{signer}, and write  for a signed
expression, because typically  is given by a cryptographic
signature on a downloaded class file.  During execution, each stack
frame is labeled with the principal that signs the function, as well
as the set  of privileges that have been explicitly enabled during
execution of the function.  For our purposes, a frame is a pair
, and a nonempty stack is a list  with
 the top.  There should be an initial stack  for some designated .  An expression
is evaluated in a stack  and with an environment  that provides
values for its free variables.

Java provides operations to enable and disable a privilege, \ie, to
add it to the stack frame or remove it.  Normally these are used in
bracketed fashion, as provided by procedure \texttt{doPrivileged} which is given a
privilege  and an expression  to evaluate.  It enables ,
evaluates , and then disables .  Our construct is written
.  The effect of  in stack
 is to evaluate  in stack
, that is, to assert  in the
current frame.
This is done regardless of whether  is authorized for .


Java's \texttt{checkPermission} operation checks whether a certain
privilege has been enabled and is authorized for the current
principal.  Checking is done by inspecting the current stack.  Each
dangerous code fragment should be guarded by a check for an associated
privilege, so that the code cannot be executed unless the check has succeeded.  
(This can be assured by inspection of the code, or by other forms of analysis 
\cite{CentonzeFP07} but is beyond the scope of our paper.)
In our syntax, a guarded expression is written
.  The execution of an expression checked for privilege
 is to raise a security error, which we denote by , unless
the following predicate is true of  and the current stack.

That is, a privilege is enabled for a stack provided
there is some frame  with  and  is authorized for
 and is authorized for all principals in frames below this one. 



A direct implementation in these terms requires inspecting some or all
of the stack frames.  The implementation is lazy in that no
checking is performed when a privilege is enabled, only when it is
needed to actually perform a guarded operation. On the other hand,
each check incurs a significant cost, and in secure code the checks
will never fail.  Static analysis can detect unnecessary checks, and
justify security-preserving transformations.

A stack  determines a set  of enabled, authorized
privileges, to wit:

This gives rise to a simple form of eager semantics: instead of
evaluating an expression in the context of a stack , we use
, along with the current principal which appears on top of
.  The eager, stack-free semantics is given in Section~\ref{sec:ds}
and we will use this semantics exclusively in the static analysis and 
program transformations that follow in Sections~\ref{sec:sa} and ~\ref{sec:tran}.

A denotational semantics that uses explicit stacks will be deferred until Fig.~\ref{fig:ss} of Section~\ref{sec:stk}. As mentioned previously, we will then take up the equivalence of the two semantics.

The language constructs are strict in : if a subexpression
raises a security error, so does the entire expression.  In Java, security
errors are exceptions that can be caught.  Thus it is possible for a
program to determine whether a \texttt{checkPermission} operation will
succeed.  Rather than model the full exception mechanism, we
include a construct  which evaluates  if
 succeeds in the current stack , and evaluates 
otherwise.  Note that security error  is raised only by the
 construct, not by  or .

In Java, the call of a procedure of a class signed by, or otherwise
associated with, , results in a new stack frame for the method,
marked as owned by .  We model methods as function abstractions,
but whereas Skalka and Smith use signed abstractions, we include a
separate construct
.\footnote{\label{fn:pfg}Fournet and Gordon~\cite{FournetG03} also use a freely applicable construct for signing.
Moreover they identify principals with sets of permissions: their ``framed'' expression  
is like our  for  with .}  
Evaluation of  in stack  goes by evaluating  in
stack .  For example, given a stack , the
evaluation of the application

amounts to evaluating 
in the stack . 

We separate  from abstractions because it helps disentangle
definitions and proofs, \eg, these constructs are treated
independently in our safety result.  On the other hand, unsigned
abstractions do not model the Java mechanism.  In our consistency
result, Theorem~\ref{thm:cons}, we show that our semantics is
equivalent to stack inspection for all \emph{standard expressions},
\ie, those in which the body of every abstraction is signed.

\subsection{Syntax and typing}
\label{sec:la}

Given are sets  and , and a fixed access control list
 that maps  to sets of privileges.  In the grammar for
data types and expressions,  ranges over  and  over
.  Application associates to the left.  We include recursive
definitions for expressiveness, and simple abstractions 
which, while expressible using , are easier to
understand in definitions and proofs.  For simplicity, the only
primitive type is , and the only type constructor is for
functions.  Products, sums, and other primitive types can be added
without difficulty. Throughout the paper we use  to exemplify the treatment of constants in general.


A signed abstraction  in the language of Skalka and
Smith is written  in ours.  Our
safety result can be proved without restriction to expressions of this
form.  But for the eager semantics to be equivalent to stack
semantics, it is crucial that function bodies be signed so the
semantics correctly tracks principals on behalf of which the body of
an abstraction is evaluated.

\begin{definition}[Standard expression]\label{def:std}
An expression is standard if for every subexpression
 or  we have that  is
 for some .
\end{definition}



Well-formed expressions are characterized by typing judgements
 which express that  has type  where free
identifiers are declared by .  A typing context  is a labeled
tuple of declarations . We write
 for the extended context , and  for the type of .  The typing rules are given in
Figure~\ref{fig:typing}.

\begin{figure*}
\hrule
\medskip
2ex]
\Rule{\D,x:\ty_1\proves e:\ty_2}
     {\D\proves\LAM{x}{e}:\ty_1\to\ty_2} &
\Rule{\D\proves e_1: \ty_1\to\ty_2\qquad 
      \D\proves e_2: \ty_1}
     {\D\proves e_1\;e_2: \ty_2} 
\2ex]
\Rule{\D\proves e:\ty}
     {\D\proves \signs{\n}{e}:\ty} &
\Rule{\D\proves e:\ty}
     {\D\proves \enable{\p}{e}:\ty} 
\
\medskip
\hrule
\medskip
\caption{Typing rules.}
\label{fig:typing}
\end{figure*}


\subsection{The password example}
\label{sec:pass}

As an example of the intended usage, we consider the problem of protecting the
password file, using a privilege  for changing password and  for writing to
the password file.
The user is authorized to change passwords:
.
Root is authorized to change passwords and to write the password file:
.
Suppose  is the operating system call which needs to be protected from
direct user access. The system provides the following code, which guards
 with the privilege .

Consider the following user programs.

Here  raises a security exception because  checks for privilege 
which is not possessed by .  The user can try to enable , as in , but
because  is not authorized for  the exception is still raised.  By contrast,
 does not raise an exception: function  checks for privilege 
which is possessed by , and it enables the privilege  needed by
.  
Using transformations discussed in Section~\ref{sec:tran}, checks that never fail can
be eliminated. 
For example, the analysis will show that  is safe, and the transformations will
reduce  to 






\section{Denotational semantics}
\label{sec:ds}


This section gives the eager denotational semantics. 

\subsection{Meanings of types and type contexts}

A \emph{cpo} is a partially ordered set with least upper bounds of
ascending chains; it need not have a least element. 
Below we define, for each type , a cpo .
We assume that  and  are two values not in 
 and not functions; this will ensure that 
 for all . We will identify
 with non-termination and  with security errors.
For cpo , define ,  
ordered as the disjoint union of  with , lifted with .  
That is, for any , define
 iff , , or  and  are in  and  in .

We define ,
ordered by equality. We also take the powerset  to be a cpo ordered by 
equality.  
Define  where  associates to the right and 
denotes continuous function space, ordered pointwise.  Note that lubs are 
given pointwise. Also,  does not contain  but it 
does have a least element, namely the constant function 
.

Principals behave in a lexically scoped way.  By contrast, privileges are
dynamic and vary during execution; this is reflected in the semantics of the function
type.  

Let  be a type context. Then
 is defined to be the set
 of labeled tuples of
appropriate type.  If  is such a record, we write  for the
value of field .  If  is the empty type context ,
then the only element of  is the empty record .  For
 and  we write  for the
extended record in .

\subsection{Meanings of expressions}\label{sec:mexpr}

An expression judgement denotes a function

Given a principal , a set  denoting privileges required
by , and environment , the meaning of 
is either  or  or an element of .

In contrast with the work of Fournet and Gordon we do not restrict  to be a subset of ,
though it can easily be done ---simply by giving the denotation this dependent type:

In programs of interest, signed at the top level, most expressions will in fact be applied to permission sets that satisfy the restriction. 
Later we observe that the restriction is need for validity of some transformations, but surprisingly few of them.  



In the denotational semantics (Figure~\ref{fig:ds}), we use the metalanguage 
construct, , with the following semantics: if the value 
of  is either  or  then that is the value of the entire let 
expression; otherwise, its value is the value of  with  bound to
the value of . 
The semantics of if-then-else is -strict in the guard.
We also write  for 
.

The semantics is standard for the most part. We will only explain the
meanings of the expressions that directly concern security. In what follows,
we will assume, unless otherwise stated, that expression  is signed by 
principal  and is computed with privilege set  and in environment .

The meaning of  is the meaning of , signed by
, computed with privilege set , in . 
To illustrate the idea, consider Li Gong's
example~\cite[Section 3.11.2]{Gong99}. A game applet, \textit{applet},
has a method that calls \textit{FileInputStream} to open the file containing
the ten current high scores. In our semantics, this scenario entails finding
the meaning of , as invoked under some privilege set ; and, this means we need to
find the meaning of \textit{FileInputStream} (\ie, whether read privileges
are enabled) under the privilege set . Assuming 
\textit{system} has all privileges, this reduces to checking if 
\textit{applet} has been granted permission to read. If it has not been granted
the permission, the file will not be read, even though it calls system code
to do so.

The meaning of  is the meaning of
 computed with privilege set  if , and is the 
meaning of  computed with privilege set  if . 
The meaning of  is a security error if ; otherwise, 
the meaning is that of . Finally, the meaning of 
is the meaning of  or  according as  or .



\begin{figure*}
\hrule
\medskip

\medskip
\hrule
\medskip
\caption{Denotational semantics}
\label{fig:ds}
\end{figure*}

We leave it to the reader to check that the semantics of each construct is a
continuous function of the semantics of its constituent expressions,
so the semantics of recursion is well defined. 

\section{Static Analysis}
\label{sec:sa}
The denotational semantics in Section~\ref{sec:ds} gives a dynamic or run-time
view of safety; if a program is safe, its execution will not yield .
In this section, we specify a type system that statically 
guarantees safety; if a program is well-typed in the system then it is safe. 
One may utilize the static analysis for optimizing programs \eg, 
removing redundant checks of privileges at run-time.

The static analysis is specified by an extended form of typing judgement.
The idea is to give not only the type of an expression, but a
principal  and set  of privileges for which the expression is
safe.  An arrow type  denotes functions dependent on a
set of privileges, and the static analysis uses annotated types to
track sets of privileges adequate for safety.  We adopt a Greek
notational style for types in the static analysis.  Letting 
range over sets of privileges, annotated types, , are defined by

For this syntax to be finitary, one could restrict  to finite sets, 
but we have no need for such restriction in our proofs.  
An expression typed 
signifies that its application may require at least the privileges  
for safe execution.


\subsection{Type-based analysis}
The analysis is specified by the typing judgement .  In words, expression  signed by principal  and
typed in context , has (annotated) type  and is safe
provided at least the set  of privileges are
enabled. Figure~\ref{fig:sa} gives the specification.
\begin{figure*}
\hrule
\medskip
2ex]
\multicolumn{2}{c}{
\Rule{\Delta;\;\n\proves e_1: \th_1\annoto{\Ps}\th_2, ~\Ps_1 \qquad 
      \Delta;\;\n\proves e_2: \th'_1, ~\Ps_2 \qquad \th'_1\leq\th_1}
     {\Delta;\;\n\proves e_1\;e_2: \th_2, ~\Ps\union\Ps_1\union\Ps_2}
}
\2ex]
\multicolumn{2}{c}{
\Rule{\Delta, f:\th_1\annoto{\Ps}\th_2, x:\th_1;\;\n
      \proves e_1:\th_2, ~\Ps
      \qquad
      \Delta, f:\th_1\annoto{\Ps}\th_2;\;\n\proves e_2:\th, ~\Ps_1}
     {\Delta;\;\n\proves\letdecl{\recdecl{f}{x}{e_1}}{e_2}: \th, 
      ~\Ps\union\Ps_1}
}
\2ex]
\Rule{\Delta;\;\n'\proves e:\th, \;\Ps \qquad \Ps\subseteq\A(\n') }
     {\Delta;\;\n\proves \signs{\n'}{e}:\th,~\Ps} &
\Rule{\Delta;\;\n\proves e_1:\th, ~\Ps_1\qquad
      \Delta;\;\n\proves e_2:\th, ~\Ps_2}
     {\Delta;\;\n\proves \test{\p}{e_1}{e_2}:\th,~\Ps_1\union\Ps_2}
\end{array}

\begin{array}{l}
\Empty; \ \n\proves writepass: string\annoto{\{w\}} void,\ \Empty \\
\Empty; \ \n\proves passwd: string\annoto{\{p\}} void,\ \Empty \\
\Empty; \ \n\proves use:  void,\ \Empty 
\end{array}

lp &=& \LAM{f}
           {\signs{\n}
                  {(\LAM{x}
                        {\signs{\n}
                               {(\enable{\p}{(f\ x)})}})}} \\
cp &=& \LAM{x}{\signs{\n}
                     {(\chk{\p}{x})}}

\begin{array}{lcl}
\means{lp}\n P\h 
&=& \lam{P_1}
        {\lam{d_1}
             {\lam{P_2}
                  {\lam{d_2}
                       {\means{\enable{\p}{f\;x}}\n(P_2\intersect\A(\n))
                                      [\h\mid f\mapsto d_1, x\mapsto d_2]}}}}\\
&=& \{\mathrm{letting}\;P_3=P_2\intersect\A(\n)\}\\
& & \lam{P_1}
        {\lam{d_1}
             {\lam{P_2}
                  {\lam{d_2}
                       {d_1(P_3\sqcup_{\n}\{\p\})d_2}}}}\\
\means{cp}\n P\h
&=&
\lam{P'_1}
    {\lam{d'_1}
         {\mifthenelse{\p\in(P'_1\intersect\A(\n))}
                      {\means{x}\n(P'_1\intersect\A(\n))\ext{\h}{x}{d'_1}}
                      {\star}}}\\
&=& \lam{P'_1}
    {\lam{d'_1}
         {\mifthenelse{\p\in(P'_1\intersect\A(\n))}{d'_1}{\star}}}
\end{array}

\begin{array}{lcl}
\means{(lp\;cp)}\n P\h
&=&
FPd\\
&=&
\lam{P_2}
    {\lam{d_2}
         {\mifthenelse{\p\in((P_3\sqcup_{\n}\{\p\})\intersect\A(\n))}
                      {d_2}{\star}}} \\
&= &
\lam{P_2}{\lam{d_2}{d_2}}
 \quad \mathrm{because\;}\p\in\A(\n)
\\
\means{(lp\;cp)\TRUE}\n P\h
&=&
GP(\means{\TRUE}\n P\h)\\
&=&
\mathsf{true}
\end{array}

\begin{array}{lcl}
\safe~ {\BOOL}(b) &\iff & \mathsf{true} \\
\safe~(\th_1\annoto\Ps\th_2)(f) &\iff &
\forall P\in\P(\PRIV) .\forall d\in\means{\th_1^*} .\; \\
&&  \Ps\subseteq P \land 
\safe~ {\th_1}(d)\implies \safe~ {\th_2}(f P d)
\end{array}
 u=\mifthenelse{b}{\means{\Delta^*\proves e_1:\th^*}\n P \h}
                  {\means{\Delta^*\proves e_2:\th^*}\n P \h} 
G(g)=\lam{P'}
         {\lam{d}
              {\means{\Delta^*,f:\th_1^*\to\th_2^*,x:\th_1^*
               \proves e_1:\th_2^*}\n P'\recext{\h}{f}{g}{x}{d}}}

\safe~ {(\Delta,f:\th_1\annoto{\Ps}\th_2)}\ext{\h}{f}{\fix\;G} 
  \label{eq:one}
& \forall i.\; \safe~(\th_1\annoto{\Ps}\th_2)(g_i) 

g_{i+1}P''(v)=\means{\Delta^*,f:\th_1^*\to\th_2^*,x:\th_1^*
\proves e_1:\th_2^*}\n P'' \recext{\h}{f}{g_i}{x}{v}
 u=\mifthenelse{\p\in P}{\means{\Delta^*\proves e:\th^*}\n P \h}{\star}  u=\mifthenelse{\p\in P}{\means{\Delta^*\proves e_1:\th^*}\n P \h}
               {\means{\Delta^*\proves e_2:\th^*}\n P \h} 
\begin{array}{lcl}
\ifthenelse{e}{\chk{\p}{e_1}}{\chk{\p}{e_2}}
&=&
\chk{\p}{\ifthenelse{e}{e_1}{e_2}}\\
e_1(\chk{\p}{e_2}) 
&=&
\chk{\p}{e_1e_2}\\
\test{\p}{e_1}{\chk{\p}{e_2}}
&=&
\chk{\p}{\test{\p}{e_1}{e_2}}\\
\test{\p'}{\chk{\p}{e_1}}{\chk{\p}{e_2}}
&=&
\chk{\p}{\test{\p'}{e_1}{e_2}}\\
\letdecl{\recdecl{f}{x}{e_1}}{\chk{\p}{e_2}}
&=&
\chk{\p}{\letdecl{\recdecl{f}{x}{e_1}}{e_2}}\\
\chk{\p}{\chk{\p}{e}}
&=&
\chk{\p}{e} 
\end{array}

\begin{array}{lcl}
\pure~\p~ {\BOOL}(b) &\iff & \mathsf{true} \\
\pure~\p~(\ty_1\to \ty_2)(f) &\iff &
\forall P\in\P(\PRIV) .\forall d\in\means{\ty_1} .\; \\
&& \pure~\p~ {\ty_1}(d)\implies \pure~\p~ {\ty_2}(f P d)
\land f P d = f (P-\{\p\}) d 
\end{array}
 \means{ D\proves e:\ty} \n P \h =
   \means{ D\proves e:\ty} \n (P-\{\p\}) \h 
\begin{array}{cll}
 & \means{\D\proves\enable{\p'}{e}:\ty}\n P \h \\
= & \means{\D\proves e:\ty}\n (P\sqcup_{\n} \{\p'\} ) \h& \mbox{semantics}\\
= & \means{\D\proves e:\ty}\n ((P\sqcup_{\n} \{\p'\} )-\{\p\}) \h & \mbox{induction hyp.}\\
= & \means{\D\proves e:\ty}\n ((P-\{\p\}\sqcup_{\n} \{\p'\} ) \h & \p,\p'\mbox{distinct}\\
= & \means{\D\proves\enable{\p'}{e}:\ty}\n (P-\{\p\}) \h& \mbox{semantics}
\end{array} \begin{array}{cll}
 & \means{\D\proves\enable{\p}{e}:\ty}\n P \h\\
= & \means{\D\proves e:\ty}\n (P\sqcup_{\n} \{\p\} ) \h& \mbox{semantics}\\
= & \means{\D\proves e:\ty}\n ((P-\{\p\}) \sqcup_{\n} \{\p\} ) \h&\mbox{see below}\\
= & \means{\D\proves\enable{\p}{e}:\ty}\n (P-\{\p\}) \h& \mbox{semantics}
\end{array} \begin{array}{cll}
 & \means{\D\proves \chk{\p'}{e}:\ty}\n P \h\\
= & \mifthenelse{\p'\in P}{ \means{\D\proves e:\ty}\n P\h}{\star} &\mbox{  semantics}\\
= & \mifthenelse{\p'\in P-\{\p\}}{ \means{\D\proves e:\ty}\n (P-\{\p\}) \h}{\star} 
     &\mbox{   distinct, ind. for }\\ 
= & \means{\D\proves \chk{\p'}{e}:\ty}\n (P-\{\p\}) \h
\end{array}

\begin{array}{lcl}
\signs{\n}{ \enable{\p}{ \chk{\p}{e}}} 
& = & \signs{\n}{ e } 
\end{array}
\begin{array}{cll}
& \means{ \signs{\n}{ \enable{\p}{ \chk{\p}{e}}} }\n' P\h \\
=&\means{ \enable{\p}{ \chk{\p}{e}} }\n(\A(\n)\intersect P)\h & \mbox{ semantics}\\
=&\means{  \chk{\p}{e} }\n((\A(\n)\intersect P)\sqcup_{\n}\{\p\})\h & \mbox{ semantics}\\
=&\means{  \chk{\p}{e} }\n((\A(\n)\intersect P)\union\{\p\})\h & 
  \mbox{ def , using }\\ 
=&\means{  e }\n((\A(\n)\intersect P)\union\{\p\})\h & \mbox{ semantics}\\
=&\means{  e }\n(\A(\n)\intersect P)\h & \mbox{  and  are -pure,
  Lemma~\ref{lem:pur} } \\
=&\means{ \signs{\n}{e} }\n' P\h & \mbox{ semantics}
\end{array} 
\begin{array}{lcl}
\signs{\n}{\chk{\p}{e}}
& = & \chk{\p}{\signs{\n}{e}}
\end{array}
\begin{array}{cll}
& \means{\signs{\n}{\chk{\p}{e}}}\n' P\h \\
=&\means{\chk{\p}{e}}\n(P\intersect \A(\n))\h & \mbox{ semantics}\\
=&\mifthenelse{\p\in(P\intersect\A(\n))}{\means{e}\n(P\intersect\A(\n))\h}{\star} &\mbox{ semantics}\\
=&\mifthenelse{\p\in P}{\means{e}\n(P\intersect\A(\n))\h}{\star} &\mbox{ sets, since }\\
=&\mifthenelse{\p\in P}{\means{\signs{\n}{e}}\n' P \h}{\star} &\mbox{ semantics}\\
=&\means{\chk{\p}{\signs{\n}{e}}}\n' P \h &\mbox{ semantics }\end{array} 
\begin{array}{cll}
& passwd(\mbox{``mypass''}) \\
=& \{\mbox{because }passwd=(\LAM{x}{\signs{r}{\chk{p}{\enable{w}{writepass(x)}}}})\}\\
& \signs{r}{\chk{p}{\enable{w}{writepass(\mbox{``mypass''})}}}  \\
=& \{\mbox{because }writepass=(\LAM{x}{\signs{r}{\chk{w}{hwWrite(x,\mbox{``/etc/password''})}}})\}\\
& \signs{r}{\chk{p}{\enable{w}{
    \signs{r}{\chk{w}{hwWrite(\mbox{``mypass''},\mbox{``/etc/password''})}}}}} \\
=&\{\mbox{by Theorem~\ref{thm:commute} since }\A(r)=\{p,w\}\}\\
 &\chk{p}{\signs{r}
                 {\enable{w}
                         {\chk{w}
                              {\signs{r}
                                     {hwWrite(\mbox{``mypass''},
                                              \mbox{``/etc/password''})}}}}}\\
=&\{\mbox{by Theorem~\ref{thm:elim} since  and }
    \signs{r}{hwWrite(\ldots)}
    \mbox{ is -pure closed}\}\\
&\chk{\p}{\signs{r}
           \signs{r}{hwWrite(\mbox{``mypass''},\mbox{``/etc/password''})}}\\
=&\{\mbox{because }\signs{\n}{\signs{\n}{e}}=\signs{\n}{e}\}\\
&\chk{\p}{\signs{r}{hwWrite(\mbox{``mypass''},\mbox{``/etc/password''})}}
\end{array}

\begin{array}{cll}
& use=\signs{u}{\enable{\p}{passwd(\mbox{``mypass''})}}\\
=&\signs{u}{\enable{\p}{\chk{\p}
                        \signs{r}{hwWrite(\mbox{``mypass''},
                                          \mbox{``/etc/password''})}}}\\
=&\{\mbox{by Theorem~\ref{thm:elim} since  and }
    \signs{r}{hwWrite(\ldots)}
    \mbox{ is -pure closed}\}\\
&\signs{u}{\signs{r}{hwWrite(\mbox{``mypass''},\mbox{``/etc/password''})}}
\end{array}

\label{eq:tg}
\means{\test{p}{e_1}{e_2}}\n P h = \means{\test{p}{\enable{p}{e_1}}{e_2}}\n P h

\begin{array}{lcl}
\mifthenelse{p\in P}{\means{e_1}\n P h}{\means{e_2}\n P h}
&=&
\mifthenelse{p\in P}{\means{\enable{p}{e_1}}\n P h}{\means{e_2}\n P h}
\end{array}

\begin{array}{cll}
& \means{\enable{p}{e_1}}\n P h\\
= & \means{e_1}\n (P \lub_n \{p\}) h & \mbox{ semantics}\\
= & \means{e_1}\n P h & \mbox{ because  and  implies }
\end{array}
\label{eq:tail}
 \signs{\n_2}{ ((\LAM{x}{ \signs{\n_1}{e_1}}) \; e_2) }
  = ((\LAM{x}{ \signs{\n_1}{e_1}}) \; e_2)
\label{eq:appLam}
\means{D\proves (\LAM{x}{ e_1 }) \; e_2 }\n P \h
\;=\;
\means{D,x:t\proves  e_1 }\n P \ext{\h}{x}{ \means{D\proves e_2}\n P \h }
\begin{array}{clll}
  & \means{D\proves \signs{\n_2}{ ((\LAM{x}{ \signs{\n_1}{e_1}}) \; e_2) }}\n P \h \\
=  & \means{D\proves ((\LAM{x}{ \signs{\n_1}{e_1}}) \; e_2) }\n (P\intersect \A(\n_2)) \h 
      & \mbox{by semantics of signs} \\
=  & \means{D,x:t\proves \signs{\n_1}{e_1}}\n (P\intersect \A(\n_2)) 
                                         \ext{\h}{x}{ \means{D\proves e_2}\n (P\intersect \A(\n_2)) \h} 
      & \mbox{lemma (\ref{eq:appLam})}  \\
=  & \means{D,x:t\proves e_1}\n (P\intersect \A(\n_1)) 
                                          \ext{\h}{x}{ \means{D\proves e_2}\n (P\intersect \A(\n_2)) \h}
        & \mbox{sem., } \\
=  & \means{D,x:t\proves e_1}\n (P\intersect \A(\n_1)) 
                                          \ext{\h}{x}{ \means{D\proves e_2}\n P \h}
         & \mbox{ value, Note above} \\
=  & \means{D,x:t\proves \signs{n_1}{e_1}}\n P \ext{\h}{x}{ \means{D\proves e_2}\n P \h}
         & \mbox{semantics of signs} \\
=  & \means{D\proves ((\LAM{x}{ \signs{\n_1}{e_1}}) \; e_2)}\n P h
       & \mbox{lemma (\ref{eq:appLam})} 
\end{array}
\begin{array}{lcl}
\TRUE^- &=& \TRUE\\
x^-&=& x\\
(\ifthenelse{e_1}{e_2}{e_3})^- &=& \ifthenelse{e_1^-}{e_2^-}{e_3^-}\\
(\LAM{x}{e})^- &=& \LAM{x}{e^-} \\
(\letdecl{\recdecl{f}{x}{e_1}}{e_2})^- &=&
\letdecl{\recdecl{f}{x}{e_1^-}}{e_2^-}\\
(\signs{\n}{e})^- &=& \signs{\n}{e^-}\\
(\enable{\p}{e})^-&=& e^-\\
(\chk{\p}{e})^- &=& e^-\\
(\test{\p}{e_1}{e_2})^- & 
\multicolumn{2}{l}{\mbox{ is undefined}.}
\end{array}

\Rel~ {\BOOL}~b~b' &\iff & b=b' \\
\Rel~(\th_1\annoto\Ps\th_2)~f~f' &\iff &
\forall P\in\P(\PRIV) .\forall d,d'\in\means{\th_1^*}.\; \\
&&  \Ps\subseteq P \land 
\Rel~{\th_1}~d~d'\implies \Rel~ {\th_2}~(f P d)~(f' P d')

u&=&\mifthenelse{b}{\means{\Delta^*\proves e_1:\th^*}\n P \h}
                   {\means{\Delta^*\proves e_2:\th^*}\n P \h}\\
u^-&=&\mifthenelse{b^-}{\means{\Delta^*\proves e_1^-:\th^*}\n P \h^-}
                       {\means{\Delta^*\proves e_2^-:\th^*}\n P \h^-}
\begin{array}[t]{rcl}
u&=&
\lam{P'}
   {\lam{d}
        {\means{\Delta^*,x:\th_{1}^*\proves e:\th_{2}^*}\n P'\ext{\h}{x}{d}}}\\
u^-&=&
\lam{P'}
   {\lam{d^-}
        {\means{\Delta^*,x:\th_{1}^*\proves e^-:\th_{2}^*}\n P'\ext{\h^-}{x}{d^-}}}
\end{array}
u P' d &=& 
\means{\Delta^*,x:\th_{1}^*\proves e:\th_{2}^*}\n P'\ext{\h}{x}{d}\\
u^- P' d^- &=& 
\means{\Delta^*,x:\th_{1}^*\proves e^-:\th_{2}^*}\n P'\ext{\h^-}{x}{d^-}
\begin{array}[t]{rcl}
u&=&\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2^)*\proves e_2:\th^*}\n P \ext{\h}{f}{\fix\;G}\\
u^-&=&\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2^)*\proves e_2^-:\th^*}\n P \ext{\h^-}{f}{\fix\;G^-}
\end{array}\begin{array}[t]{rcl}
G(g)&=&
\lam{P'}
    {\lam{d}
         {\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
                 \proves e_1:\th_2^*}\n P'\recext{\h}{f}{g}{x}{d}}}\\
G^-(g^-)&=&
\lam{P'}
    {\lam{d^-}
         {\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
                 \proves e_1^-:\th_2^*}\n P'\recext{\h^-}{f}{g^-}{x}{d^-}}}
\end{array}
\Rel~ {(\Delta,f:\th_1\annoto{\Ps}\th_2)}~\ext{\h}{f}{\fix\;G}~\ext{\h^-}{f}{\fix\;G^-} 
  \label{eq:rel1}
& \forall i.\; \Rel~(\th_1\annoto{\Ps}\th_2)~g_i~g_i^- 
 \begin{array}[t]{rcl}
g_{i+1}&=&
\lam{P'}{\lam{d}{\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
\proves e_1:\th_2^*}\n P \recext{\h}{f}{g_i}{x}{d}}}\\
g_{i+1}^-&=&
\lam{P'}{\lam{d^-}{\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
\proves e_1^-:\th_2^*}\n P \recext{\h^-}{f}{g_i^-}{x}{d^-}}} 
\end{array}

g_{i+1}P'v
&=&
\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
\proves e_1:\th_2^*}\n P' \recext{\h}{f}{g_i}{x}{v}\\
g_{i+1}^-P'v^-
&=&
\means{\Delta^*,f:(\th_1\annoto{\Ps}\th_2)^*,x:\th_1^*
\proves e_1:\th_2^*}\n P' \recext{\h^-}{f}{g_i^-}{x}{v^-}
 u=\mifthenelse{\p\in P}{\means{\Delta^*\proves e:\th^*}\n P \h}{\star} \begin{array}{lcll}
\p\in\privs(\tuple{\n,\Empty}::S) 
&\iff& \check(\p,(\tuple{\n,\Empty}::S)) &\mbox{ by def } \\
&\iff& \p\in\A(\n) \land \check(\p,S) 
  &\mbox{ by def  and } \\
&\iff& \p\in\A(\n) \land \p\in\privs(S)&\mbox{ by def  \; \blackslug} 
\end{array}  \meanss{\D\proves e:\ty}\in \stacks
\to\meanss{\D}\to\meanss{\ty}_{\bot\star} 
\begin{array}{lcl}
\meanss{\BOOL} &=& \{ \mathsf{true},  \mathsf{false} \} 
\\
\meanss{\ty_1\to\ty_2} &=& \stacks\to\meanss{\ty_1}\to\meanss{\ty_2}_{\bot\star}
\end{array}

\begin{array}{lcl}
\meanss{\D\proves\TRUE:\BOOL}S \h &=& \mathsf{true}
\\
\meanss{\D\proves x:\ty}S \h &=& h.x 
\\
\meanss{\D\proves\ifthenelse{e}{e_1}{e_2}:\ty}S \h &=&
  \vmlet{b\;=\;\meanss{\D\proves e:\BOOL}S \h}
       {\;\;\mifthenelse{b}
                    {\meanss{\D\proves e_1:\ty}S \h}
                    {\meanss{\D\proves e_2:\ty}S \h}}
\\
\meanss{\D\proves\LAM{x}{e}:\ty_1\to\ty_2}S \h &=&
\begin{array}[t]{l}
  \lam{S' \in \stacks }{
       \lam{d\in\meanss{\ty_1}}}{} \\
        \meanss{\D, x:\ty_1\proves e:\ty_2}S' \ext{\h}{x}{d}
\end{array}
\\
\meanss{\D\proves e_1\;e_2:\ty_2}S \h &=&
  \vmlet{f\;=\;\meanss{\D\proves e_1:\ty_1\to\ty_2}S \h}
        {\mletml{d}{\meanss{\D\proves e_2:\ty_1}S \h}{f S d}}
\\
\multicolumn{3}{l}{
\meanss{\D\proves\letdecl{\recdecl{f}{x}{e_1}}{e_2}:\ty}S \h} \\
\multicolumn{3}{l}{
\qquad 
= \vmlet{G(g)\;=\;
\lam{S'}
    {\lam{d}
         {\meanss{\D,f:\ty_1\to\ty_2,x:\ty_1\proves e_1:\ty_2}S
          \recext{\h}{f}{g}{x}{d}}}}
{\meanss{\D,f:\ty_1\to\ty_2\proves e_2:\ty}S \ext{\h}{f}{\fix\;G}}} 
\\
\meanss{\D\proves\signs{\n'}{e}:\ty}S \h &=&
\meanss{\D\proves e:\ty} (\tuple{\n',\Empty}::S) \h
\\
\meanss{\D\proves\enable{\p}{e}:\ty}(\tuple{\n,P}::S) \h 
&=&
\meanss{\D\proves e:\ty}(\tuple{\n,P\union\{\p\}}::S) \h
\\
\meanss{\D\proves\chk{\p}{e}:\ty}S \h &=&
\mifthenelse{\check(\p,S)}{\meanss{\D\proves e:\ty}S \h}{\star}
\\
\meanss{\D\proves\test{\p}{e_1}{e_2}:\ty}S \h &=&
\mifthenelse{\check(\p,S)}{\meanss{\D\proves e_1:\ty}S \h }
            {\meanss{\D\proves e_2:\ty}S \h }
\end{array}
 \means{\Empty\proves e:\BOOL}\n P \{\}~=~
\meanss{\Empty\proves e:\BOOL}(\tuple{\n, P'}::S) \{\} 
\qquad\mbox{where }.

\Sim~ {\BOOL}~b~b' &\iff & b=b' \\
\Sim~(\ty_1\to\ty_2)~f~f' &\iff &
\forall S\in\stacks . \forall d\in\means{\ty_1} . \forall d'\in\meanss{\ty_1} . \\
&&  \Sim~\ty_1~d~d' \implies
\Sim~\ty_2~  (f~(\privs~S)~d) ~ (f'~S~d') 
 u'=\meanss{\D\proves e:\ty}(\tuple{\n,P'}::S)\h' u'=\meanss{\D\proves\LAM{x}{e}:\ty_1\to\ty_2}S \h' \begin{array}[t]{rcl}
u &=&
\lam{P'}
    {\lam{d}
    {\means{\D,x:\ty_{1}\proves e:\ty_{2}}\n P'\ext{\h}{x}{d}}}\\
u'&=&
\lam{S'}
    {\lam{d'}
         {\meanss{\D,x:\ty_{1}\proves e:\ty_{2}}S' \ext{\h'}{x}{d'}}}
\end{array}

u~(\privs~S'')~d''
&=&
\means{\D,x:\ty_1\proves e:\ty_2}\n~(\privs~S'')~\ext{\h}{x}{d''}\\
&=& 
\means{\D,x:\ty_1\proves e':\ty_2}\n'~(\privs(S'')\intersect\A(\n'))~\ext{\h}{x}{d''}\
Note that by definition  and by assumption ,
we have, . Furthermore,
by Fact~\ref{fac:emp}, 
. 
Therefore, by induction for , we obtain, . This is where we need Definition~\ref{def:std}.
\item Case :
\\
Need to show . Since  and
, therefore, by induction for , we have
. Similarly, by induction for , we have
. Hence the result follows by definition   
since . This case of the proof shows the necessity of defining
the relation .
\item Case :

To show the result, it suffices to show 
, because then we can use induction
for , noting that 
,
and that .
Accordingly, we demonstrate the following claim:

Then from Lemma~\ref{lem:lub}, we get 
. This completes the
proof. To show (\ref{sim:1}), we proceed by induction on . We have:
3mm]
g'_0 &=& 
\lam{S'}{\lam{d'}{\bot}}\\
g'_{i+1} &=&
\lam{S'}{\lam{d'}
             {\meanss{\D,f:\ty_1\to\ty_2,x:\ty_1\proves e_1:\ty_2} S'
              \recext{\h'}{f}{g'_i}{x}{d'}}}\\
&=&\{\mathrm{because}\; e_1\equiv\signs{\n'}{e'_1}\}\\
& &\lam{S'}{\lam{d'}
             {\meanss{\D,f:\ty_1\to\ty_2,x:\ty_1\proves e'_1:\ty_2} 
              (\tuple{\n',\Empty}::S')\recext{\h'}{f}{g'_i}{x}{d'}}}

\Sim~(\D,f:\ty_1\to\ty_2,x:\ty_1)~\recext{\h}{f}{g_i}{x}{d}~\recext{\h'}{f}{g'_i}{x}{d'}
\begin{array}{lcll}
& & \p'\in P\sqcup_{\n}\{\p\} \\
&\iff& \p'\in P \lor (\p'\in \A(\n) \land \p'=\p) & \mbox{by def } \\
&\iff& \check(\p', \tuple{\n,P'}::S ) 
       \lor (\p'\in \A(\n) \land \p'=\p) & \mbox{assumption, def } \\
&\iff& (\p'\in \A(n)\land (\p'\in P'\lor \check(\p', S )) 
       \lor (\p'\in \A(\n) \land \p'=\p) & \mbox{def } \\
&\iff& \p'\in \A(n)\land (\p'\in P'\union\{\p\} \lor \check(\p', S ) ) & \mbox{logic
  and sets}\\
&\iff& \p'\in \privs( \tuple{\n,P'\union\{\p\}}::S ) & \mbox{defs  and
  } 
\end{array} 
\item Case :
Both semantics are conditional; the condition in one case is  and 
in the other case , and these are equivalent conditions by 
assumption  for the Lemma.   In case the condition is true, 
the result holds by induction, which applies because for both semantics the 
security arguments for  are unchanged.
If the condition is false, the result holds because both semantics are 
and .
\item Case :
Similar to the case for .
\end{itemize}
\end{xproof}

\section{Conclusion}
\label{sec:disc}


Our work was motivated by the hope, inspired by discussions with Dave Schmidt, for more principled semantics of static analyses presented in the form of type and effect systems.  
Our work serves to demonstrate two attractive features of denotational semantics, which a decade ago seemed largely eclipsed by operational semantics.  
The first is proof of program equalities via equational reasoning on denotations.
The second is logical relations, defined by structural recursion on types.
We are glad for the opportunity to demonstrate the utility of denotational semantics while celebrating the contributions of Dave Schmidt, so adept a practitioner of all forms of semantic modeling.










\bibliographystyle{eptcs}
\bibliography{schmidt.bib}



















\end{document}
