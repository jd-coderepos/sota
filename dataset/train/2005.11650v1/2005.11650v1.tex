\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{tabularx}
\usepackage[mathscr]{euscript}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcommand{\minimize}{\mathop{\mathrm{minimize}}}
\usepackage{mwe}
\usepackage{subcaption}
\usepackage{balance}
\usepackage{color}


\AtBeginDocument{\providecommand\BibTeX{{\normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2020} 
\acmYear{2020} 
\setcopyright{acmcopyright}
\acmConference[KDD '20] {26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining}{August 23--27, 2020}{Virtual Event, USA}
\acmBooktitle{26th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD '20), August 23--27, 2020, Virtual Event, USA}
\acmPrice{15.00}
\acmDOI{10.1145/XXXXXX.XXXXXX}
\acmISBN{978-1-4503-7998-4/20/08} 


\settopmatter{printacmref=true}







\begin{document}
\fancyhead{}




\title{Connecting the Dots:  Multivariate Time Series Forecasting with Graph Neural Networks}




\author{Zonghan Wu}
\affiliation{\institution{University of Technology Sydney}
}
\email{zonghan.wu-3@student.uts.edu.au}

\author{Shirui Pan}
\authornote{Corresponding Author.}
\affiliation{\institution{Monash University}
}
\email{shirui.pan@monash.edu}

\author{Guodong Long}
\affiliation{\institution{University of Technology Sydney}
}
\email{guodong.long@uts.edu.au}

\author{Jing Jiang}
\affiliation{\institution{University of Technology Sydney}
}
\email{jing.jiang@uts.edu.au}

\author{Xiaojun Chang}
\affiliation{\institution{Monash University}
}
\email{xiaojun.chang@monash.edu}

\author{Chengqi Zhang}
\affiliation{\institution{University of Technology Sydney}
}
\email{chengqi.zhang@uts.edu.au}


\renewcommand{\shortauthors}{Wu, et al.}

\begin{abstract}
Modeling multivariate time series has long been a subject that has attracted researchers from a diverse range of fields including economics, finance, and traffic. A basic assumption behind multivariate time series forecasting is that its variables depend on one another but, upon looking closely, it's fair to say that existing methods fail to fully exploit latent spatial dependencies between pairs of variables. In recent years, meanwhile, graph neural networks (GNNs) have shown high capability in handling relational dependencies. GNNs require well-defined graph structures for information propagation which means they cannot be applied directly for multivariate time series where the dependencies are not known in advance. In this paper, we propose a general graph neural network framework designed specifically for multivariate time series data. Our approach automatically extracts the uni-directed relations among variables through a graph learning module, into which external knowledge like variable attributes can be easily integrated. A novel mix-hop propagation layer and a dilated inception layer are further proposed to capture the spatial and temporal dependencies within the time series. The graph learning, graph convolution, and temporal convolution modules are jointly learned in an end-to-end framework. Experimental results  
show that our proposed model outperforms the state-of-the-art baseline methods on 3 of 4 benchmark datasets and achieves on-par performance with other approaches on two traffic datasets which provide extra structural information.
\end{abstract}



\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010178</concept_id>
<concept_desc>Computing methodologies~Artificial intelligence</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010257.10010293.10010294</concept_id>
<concept_desc>Computing methodologies~Neural networks</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}


\ccsdesc[500]{Computing methodologies~Neural networks}
\ccsdesc[100]{Computing methodologies~Artificial intelligence}

 
\keywords{Graph neural networks, graph structure learning, multivariate time series forecasting, spatial-temporal graphs}

\maketitle



\section{Introduction}
Modern societies have benefited from a wide range of sensors to record changes in temperature, price, traffic speed, electricity usage, and many other forms of data. Recorded time series from different sensors can form multivariate time series data and can be interlinked. For example, the rise in daily temperature may cause an increase in electricity usage. To capture systematic trends over a group of dynamically changing variables, the problem of multivariate time series forecasting has been studied for at least sixty years. It has seen tremendous applications in the domains of economics, finance, bioinformatics, and traffic. 


Multivariate time series forecasting methods inherently assume interdependencies among variables. In other words, each variable depends not only on its historical values but also on other variables. However, existing methods do not exploit latent interdependencies among variables efficiently and effectively. Statistical methods, such as vector auto-regressive model (VAR) and Gaussian process model (GP), assume a linear dependency among variables. The model complexity of statistical methods grows quadratically with the number of variables. They face the problem of overfitting with a large number of variables. Recently developed deep-learning-based methods, including LSTNet \cite{lai2018modeling} and TPA-LSTM \cite{shih2019temporal}, are powerful to capture non-linear patterns. LSTNet encodes short-term local information into low dimensional vectors using 1D convolutional neural networks and decodes the vectors through a recurrent neural network. TPA-LSTM processes the inputs by a recurrent neural network and employs a convolutional neural network to calculate the attention score across multiple steps. LSTNet and TPA-LSTM do not model the pair-wise dependencies among variables explicitly, which weakens model interpretability. 

Graphs are a special form of data which describes the relationships between different entities. Recently, graph neural networks have achieved great success in handling graph data due to their permutation-invariance, local connectivity, and compositionality. By propagating information through structures, graph neural networks allow each node in a graph to be aware of its neighborhood context. Multivariate time series forecasting can be viewed naturally from a graph perspective. Variables from multivariate time series can be considered as nodes in a graph, and they are interlinked through their hidden dependency relationships. It follows that modeling multivariate time series data using graph neural networks can be a promising way to preserve their temporal trajectory while exploiting the interdependency among time series.

The most suitable type of graph neural networks for multivariate time series is spatial-temporal graph neural networks. Spatial-temporal graph neural networks take multivariate time series and an external graph structure as inputs, and they aim to predict future values or labels of multivariate time series. Spatial-temporal graph neural networks have achieved significant improvements compared to methods that do not utilize structural information. 
However, these approaches still fall short for modeling multivariate time series due to the following challenges:
\begin{itemize}
    \item \textit{Challenge 1: Unknown Graph Structure.} Existing GNN approaches rely heavily on a pre-defined graph structure in order to perform time series forecasting. In most cases, multivariate time series does not have an explicit graph structure. The relationships among variables has to be discovered from data rather than being provided as ground truth knowledge.
    \item \textit{Challenge 2: Graph Learning \& GNN Learning. } Even though a graph structure is available, most GNN approaches focus only on message passing (GNN Learning) and overlook the fact that the graph structure is not optimal and should be updated during training. The question then is how to simultaneously learn the graph structure and the GNN for time series in an end-to-end framework.
\end{itemize}

In this paper, we propose a novel approach to overcome these challenges. As demonstrated by Figure \ref{fig:concept}, our framework consists of three core components - the graph learning layer, the graph convolution module, and the temporal convolution module. For \textit{Challenge 1}, we propose a novel graph learning layer, which extracts a sparse graph adjacency matrix adaptively based on data. Furthermore, we develop a graph convolution module to address the spatial dependencies among variables, given the adjacency matrix computed by the graph learning layer. This is designed specifically for directed graphs and avoids the over-smoothing problem that frequently occurs in graph convolutional networks. Finally, we propose a temporal convolution module to capture temporal patterns by modified 1D convolutions. It can both discover temporal patterns with multiple frequencies and process very long sequences.

As all parameters are learnable through gradient descent, the proposed framework is able to model multivariate time series data and learn the internal graph structure simultaneously in an end-to-end manner (for \textit{Challenge 2}). To reduce the difficulty of solving a highly non-convex optimization problem and to reduce memory occupation in processing large graphs, we propose a learning algorithm that uses a curriculum learning strategy to find a better local optimum and splits multivariate time series into subgroups during training. The advantages here are that our proposed framework is generally applicable to both \textbf{small and large graphs, short and long time series, with and without externally defined graph structures}. In summary, our main contributions are as follows:

\begin{itemize}
    \item To the best of our knowledge, this is the first study on multivariate time series data generally from a graph-based perspective with graph neural networks.
    
    \item We propose a novel graph learning module to learn hidden spatial dependencies among variables. Our method opens a new door for GNN models to handle data without explicit graph structure. 

    \item We present a joint framework for modeling multivariate time series data and learning graph structures. Our framework is more generic than any existing spatial-temporal graph neural network as it can handle multivariate time series with or without a pre-defined graph structure.
    
    \item Experimental results show that our method outperforms the state-of-the-art  methods on 3 of 4 benchmark datasets and achieves on-par performance with other GNNs on two traffic datasets which provide extra structural information.
\end{itemize}



\begin{figure}
	\centering
	\scalebox{0.5}{\includegraphics[width=\textwidth]{./FIG/concept.pdf}}
	\caption{A concept map of our proposed framework. }
	\label{fig:concept}
\end{figure}


\begin{comment}
\begin{figure}
	\centering
	\scalebox{0.4}{\includegraphics[width=\textwidth]{FIG/demo.pdf}}
	\caption{Multivariate time series data viewed from a graph perspective. Each node represents a dynamically changing variable. Each edge represents the hidden dependency relationship between two variables.}
	\label{fig:demo}
\end{figure}
\end{comment}



\section{Backgrounds}
\subsection{Multivariate Time Series Forecasting}
Time series forecasting has been studied for a long time. The majority of existing methods follow a statistical approach. The auto-regressive integrated moving average (ARIMA) \cite{box2015time} generalizes a family of a linear model, including auto-regressive (AR), moving average (MA), and auto-regressive moving average (ARMA). The vector auto-regressive model (VAR) extends the AR model to capture the linear interdependencies among multiple time series. Similarly, the vector auto-regressive moving average model (VARMA) is proposed as a multivariate version of the ARMA model. Gaussian process (GP), as a Bayesian approach, models the distribution of a multivariate variable over functions. GP can be applied naturally to model multivariate time series data \cite{frigola2015bayesian}. Although statistical models are widely used in time series forecasting due to their simplicity and interpretability, they make strong assumptions with respect to a stationary process and they do not scale well to multivariate time series data. Deep-learning-based approaches are free from stationary assumptions and they are effective methods to capture non-linearity. Lai et al. \cite{lai2018modeling} and Shih et al. \cite{shih2019temporal} are the first two deep-learning-based models designed for multivariate time series forecasting. They employ convolutional neural networks to capture local dependencies among variables and recurrent neural networks to preserve long-term temporal dependencies.
Convolutional neural networks encapsulate interactions among variables into a global hidden state. Therefore, they cannot fully exploit latent dependencies between pairs of variables. 

\subsection{Graph Neural Networks}
Graph neural networks have enjoyed great success in handling spatial dependencies among entities in a network. Graph neural networks assume that the state of a node depends on the states of its neighbors. To capture this type of spatial dependency,  various kinds of graph neural networks have been developed through message passing \cite{gilmer2017neural},
information propagation \cite{klicpera2019predict},
and graph convolution \cite{kipf2017semi}. 
Sharing similar roles, they essentially capture a node's high-level representation by passing information from a node's neighbors to the node itself. Most recently, we have seen the emergence of a type of graph neural networks known as spatial-temporal graph neural networks. This form of neural networks is proposed initially to solve the problem of traffic prediction \cite{li2018diffusion,yu2018spatio,wu2019graph,zheng2020gman,chen2020multi} and skeleton-based action recognition \cite{yan2018spatial, shi2019two}.  The inputs to spatial-temporal graph neural networks are multivariate time series with an external graph structure which describes the relationships among variables in multivariate time series. For spatial-temporal graph neural networks, spatial dependencies among nodes are captured by graph convolutions, while temporal dependencies among historical states are preserved by recurrent neural networks \cite{seo2018structured,li2018diffusion} or 1D convolutions \cite{yu2018spatio,yan2018spatial}.
Although existing spatial-temporal graph neural networks have achieved significant improvements compared to methods without using a graph structure, they are incapable of handling pure multivariate time series data effectively due to the absence of a pre-defined graph and lack of a general framework. 


\section{Problem Formulation}

In this paper, we focus on the task of multivariate time series forecasting.  Let  denote the value of a multivariate variable of dimension  at time step t, where  denote the value of the  variable at time step t.  Given a sequence of historical  time steps of observations on a multivariate variable,  , our goal is to predict the -step-away value of , or a sequence of future values  . 
More generally, the input signals can be coupled with other auxiliary features such as time of the day, day of the week, and day of the season.
Concatenating the input signals with auxiliary features, we assume the inputs instead are   where ,  is the feature dimension, the first column of  equals to , and the rest are auxiliary features. We aim to build a mapping  from  to   by minimizing the absolute loss with  regularization. 

\begin{comment}
In a single step forecasting setting, the optimization objective is 


In a multi-step forecasting setting, the optimization objective is 


\end{comment}




Graphs describe the relationships among entities in a network. We give a formal definition of graph-related concepts below.
	\begin{definition}[Graph]
		A graph is formulated as  =  where  is the set of nodes, and  is the set of edges. We use  to denote the number of nodes in a graph.
	\end{definition}

	\begin{definition}[Node Neighborhood]
    Let  to denote a node and  to denote an edge pointing from  to . The neighborhood of a node  is defined as .
	\end{definition}


    \begin{definition}[Adjacency Matrix]
		The adjacency matrix is a mathematical representation of a graph, denoted as  with  if  and  if . 
	\end{definition}


From a graph-based perspective, we consider variables in multivariate time series as nodes in graphs. We describe the relationships among nodes using the graph adjacency matrix. The graph adjacency matrix is not given by the multivariate time series data in most cases and will be learned by our model. 

\begin{comment}
\subtscommenection{Graph Convolution}
Rooted from graph signal processing, graph convolution have been widely used to extract relational information within graphs. Analogous to image convolution, graph convolution takes the weighted average of a node's neighborhood information. Assuming an undirected graph, the most common graph convolution is defined as \cite{kipf2017semi},

where  is a node feature matrix,  is a parameter matrix, ,  is an identity matrix, and  is a diagonal matrix with . Equation \ref{eq:gcn} can be better understood from an individual node level, 

In simple words, graph convolution computes the hidden state of a node by passing its neighborhood feature information to the central node with a linear transformation. 
\end{comment}



\section{Framework of MTGNN}\label{sec:met}

\begin{figure*}
	\centering
	\scalebox{.8}{\includegraphics[width=\textwidth]{FIG/model.pdf}}
	\caption{The framework of MTGNN. A  standard convolution first projects the inputs into a latent space. Afterward, temporal convolution modules and graph convolution modules are interleaved with each other to capture temporal and spatial dependencies respectively. The hyper-parameter, dilation factor , which controls the receptive field size of a temporal convolution module, is increased at an exponential rate of . The graph learning layer learns the hidden graph adjacency matrix, which is used by graph convolution modules. Residual connections and skip connections are added to the model to avoid the problem of gradient vanishing. The output module projects hidden features to the desired dimension to get the final results.}
	\label{fig:model}
\end{figure*}


\begin{figure}
	\centering
	\scalebox{0.4}{\includegraphics[width=\textwidth]{FIG/cube.pdf}}
	\caption{\small A demonstration of how a temporal convolution module and a graph convolution module collaborate with each other. A temporal convolution module filters the inputs by sliding a 1D window over the time and node axes, as denoted by the red. A graph convolution module filters the inputs at each step, denoted by the blue.}
	\label{fig:cube}
\end{figure}




\subsection{Model Architecture}
We first elaborate on the general framework of our model. As illustrated in Figure \ref{fig:model}, MTGNN on the highest level consists of a \textit{graph learning layer},  \textit{graph convolution modules},  \textit{temporal convolution modules}, and an output module. To discover hidden associations among nodes, a graph learning layer computes a graph adjacency matrix, which is later used as an input to all graph convolution modules. Graph convolution modules are interleaved with temporal convolution modules to capture spatial and temporal dependencies respectively. Figure \ref{fig:cube} gives a demonstration of how a temporal convolution module and a graph convolution module collaborate with each other. To avoid the problem of gradient vanishing, residual connections are added from the inputs of a temporal convolution module to the outputs of a graph convolution module. Skip connections are added after each temporal convolution module. To get the final outputs,  the output module projects the hidden features to the desired output dimension. In more detail, the core components of our model are illustrated in the following:



\subsection{Graph Learning Layer}
The graph learning layer learns a graph adjacency matrix adaptively to capture the hidden relationships among time series data.  To construct a graph, existing studies measure the similarity between pairs of nodes by a distance metric, such as dot product and Euclidean distance \cite{li2018diffusion}.  This leads inevitably to the problem of high time and space complexity with . It means the computation and memory cost grows quadratically with the increase of graph size. This restricts the model's capability of handling larger graphs. To address this limitation, we adopt a sampling approach, which only calculates pair-wise relationships among a subset of nodes. This cuts off the bottleneck of computation and memory in each minibatch. More details will be provided in Section \ref{sec:algo}. 

Another problem is that existing distance metrics are often symmetric or bi-directional. In multivariate time series forecasting, we expect that the change of a node's condition causes the change of another node's condition such as traffic flow. Therefore the learned relation is supposed to be uni-directional. Our proposed graph learning layer is specifically designed to extract uni-directional relationships, illustrated as follows:

where  represents randomly initialized node embeddings, which are learnable during training,  are model parameters,  is a hyper-parameter for controlling the saturation rate of the activation function, and  returns the index of the top-k largest values of a vector. The asymmetric property of our proposed graph adjacency matrix is achieved by Equation \ref{eq:adp}. The subtraction term and the ReLU activation function regularize the adjacency matrix so that if  is positive, its diagonal counterpart  will be zero.  Equation \ref{eq:argtop}-\ref{eq:adpo} is a strategy to make the adjacency matrix sparse while reducing the computation cost of the following graph convolution. For each node, we select its top-k closest nodes as its neighbors. While retaining the weights for connected nodes, we set the weights of non-connected nodes as zero. 


\textit{Incorporate External Data.} The inputs to the graph learning layer are not limited to node embeddings. In case that external knowledge about the attributes of each node is given, we can also set , where  is a static node feature matrix. Some works have considered capturing dynamic spatial dependencies \cite{guo2019attention,shi2019two}. In other words, they dynamically adjust the weight of two connected nodes based on temporal inputs. However, assuming dynamic spatial dependencies makes the model extremely hard to converge when we need to learn the graph structure at the same time. The advantage of our approach is that we can learn stable and interpretable node relationships over the period of the training dataset. Once the model is trained in an on-line learning version, our graph adjacency matrix is also adaptable to change as new training data updates the model parameters.

\subsection{Graph Convolution Module}
The graph convolution module aims to fuse a node's information with its neighbors' information to handle spatial dependencies in a graph. The graph convolution module consists of two mix-hop propagation layers to process inflow and outflow information passed through each node separately. The net inflow information is obtained by adding the outputs of the two mix-hop propagation layers.  Figure \ref{fig:gc} shows the architecture of the graph convolution module and the mix-hop propagation layer. 
 \begin{figure}
        \centering
        \begin{subfigure}[b]{0.23\textwidth}
            \centering
            \includegraphics[width=\textwidth]{./FIG/gcm.pdf}
            \caption[GC module]{{\small GC module}}    
            \label{fig:gcm}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.23\textwidth}  
            \centering 
            \includegraphics[width=\textwidth]{./FIG/mixprop.pdf}
            \caption[]{{\small Mix-hop propagation layer}}    
            \label{fig:mixprop}
        \end{subfigure}
        \caption[Graph convolution module and mix-hop propagation layer]
        {\small Graph convolution and mix-hop propagation layer.} 
        \label{fig:gc}
\end{figure}


\paragraph{Mix-hop Propagation Layer.}
Given a graph adjacency matrix, we propose the mix-hop propagation layer to handle information flow over spatially dependent nodes. The proposed mix-hop propagation layer consists of two steps - the information propagation step and the information selection step. We first give the mathematical form of these two steps and then illustrate our motivations. The information propagation step is defined as follows:

where  is a hyper parameter, which controls the ratio of retaining the root node's original states. The information selection step is defined as follows

where  is the depth of propagation,  represents the input hidden states outputted by the previous layer,  represents the output hidden states of the current layer, , , and .
In Figure \ref{fig:mixprop}, we demonstrate the information propagation step and information selection step in the proposed mix-hop propagation layer. It first propagates information horizontally and selects information vertically.

The information propagation step propagates node information along with the given graph structure recursively.  A severe limitation of graph convolutional networks is that node hidden states converge to a single point as the number of graph convolution layers goes to infinity. This is because the graph convolutional network with many layers reaches the random walk's limit distribution regardless of the initial node states.  To address this problem,  motivated by Klicpera et al. \cite{klicpera2019predict}, we retain a proportion of nodes' original states during the propagation process so that the propagated node states can both preserve locality and explore a deep neighborhood. However, if we only apply Equation \ref{eq:ppnp}, some node information will be lost. Under the extreme circumstance that no spatial dependencies exist, aggregating neighborhood information simply adds useless noises to each node. Therefore, the information selection step is introduced to filter out important information produced at each hop. According to Equation \ref{eq:mix}, the parameter matrix  functions as a feature selector. When the given graph structure does not entail spatial dependencies, Equation \ref{eq:mix} is still able to preserve the original node-self information by adjusting  to 0 for all .

\textit{Connection to existing works.} The idea of mix-hop has been explored by \cite{kapoor2019mixhop} and \cite{chen2019dagcn}. Kapoor et al. \cite{kapoor2019mixhop} concatenate information from different hops. Chen et al. \cite{chen2019dagcn} propose an attention mechanism to weight information among different hops. They both apply GCN for information propagation. However, as GCN faces the over-smoothing problem, information from higher hops may not or negatively contribute to the overall performance.  To avoid this, our approach keeps a balance between local and neighborhood information.  Furthermore, Kapoor et al. \cite{kapoor2019mixhop} show that their proposed model with two mix-hop layers has the capability to represent the delta difference between two consecutive hops. Our approach can achieve the same effect with only one mix-hop propagation layer. Suppose , , , and ,  then

From this perspective, using summation is more efficient to represent all linear interactions of different hops compared with the concatenation method.

\begin{figure}
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/tcm.pdf}
            \caption[TC module]{{\small TC module}}    
            \label{fig:tcm}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/dilin.pdf}
            \caption[Dilated inception layer]{{\small Dilated inception layer}}    
            \label{fig:dil}
        \end{subfigure}
        \caption[Temporal convolution module and dilated inception layer.]
        {\small The temporal convolution and dilated inception layer.} 
        \label{fig:tc}
\end{figure}
\subsection{Temporal Convolution  Module}
The temporal convolution module applies a set of standard dilated 1D convolution filters to extract high-level temporal features. This module consists of two dilated inception layers. One dilated inception layer is  followed by a tangent hyperbolic activation function and works as a filter. The other layer is followed by a sigmoid activation function and functions as a gate to control the amount of information that the filter can pass to the next module. Figure \ref{fig:tc} shows the architecture of the temporal convolution module and the dilated inception layer. 

\paragraph{Dilated Inception Layer}
The temporal convolution module captures sequential patterns of time series data through 1D convolutional filters. To come up with a temporal convolution module that is able to both discover temporal patterns with various ranges and handle very long sequences, we propose the dilated inception layer which combines two widely applied strategies from convolutional neural networks, i.e., using filters with multiple sizes \cite{szegedy2015going} and applying dilated convolution \cite{yu2016multi}.

First, choosing the right kernel size is a challenging problem for convolutional networks. The filter size can be too large to represent short-term signal patterns subtly, or too small to discover long-term signal patterns sufficiently.
In image processing, a widely employed strategy is called inception, which concatenates the outputs of 2D convolution filters with three different kernel sizes, , , and . Moving from 2D images to 1D time series, the set of , , and  filter sizes do not suit the nature of temporal signals. As temporal signals tend to have several inherent periods such as , , , , and , a stack of inception layers with filter size , , and  cannot well encompass those periods. Alternatively, we propose a temporal inception layer consisting of four filter sizes, viz. , , , and . The aforementioned periods can all be covered by the combination of these filter sizes. For example, to represent the period , a model can pass the inputs through a  filter from the first temporal inception layer followed by a  filter from the second temporal inception layer. 

Second, the receptive field size of a convolutional network grows in a linear progression with the depth of the network and the kernel size of the filter. Consider a convolutional network with   convolution layers of kernel size , the receptive field size of the convolutional network is, 

To process very long sequences, it requires either a very deep network or very large filters. We adopt dilated convolution to reduce model complexity. Dilated convolution operates a standard convolution filter on down-sampled inputs with a certain frequency.  For example, where the dilation factor is 2, it applies standard convolution on inputs sampled every two steps. 
Following \cite{oord2016wavenet}, we let the dilation factor for each layer increase exponentially at a rate of . Suppose the initial dilation factor is , the receptive field size of a  layer dilated convolutional network with kernel size  is 

This indicates that the receptive field size of the network also grows exponentially with an increase in the number of hidden layers at the rate of . Therefore, using this dilation strategy can capture much longer sequences than proceeding without it.

Formally, combining inception and dilation, we propose the dilated inception layer, demonstrated by Figure \ref{fig:dil}. Given a 1D sequence input  and filters consisting of , , , and , our dilated inception layer takes the form,


where the outputs of the four filters are truncated to the same length according to the largest filter and concatenated across the channel dimension, and the dilated convolution denoted by  is defined as

where  is the dilation factor.




\begin{comment}

We can derive the upper bound for choosing ,

where  and  is considered as constants.
\end{comment}

\subsection{Skip Connection Layer \& Output Module}
Skip connection layers are essentially  standard convolutions where  is the sequence length of the inputs to the  skip connection layer. It standardizes information that jumps to the output module to have the same sequence length . The output module consists of two  standard convolution layers, transforming the channel dimension of the inputs to the desired output dimension. In case we want to predict a certain future step only, the desired output dimension is . When we want to predict  consecutive steps, the desired output dimension is .


\subsection{Proposed Learning Algorithm}
\label{sec:algo}
We propose a learning algorithm to enhance our model's capability of handling large graphs and stabilizing in a better local optimum. Training on a graph often requires storing all node intermediate states into memory. If a graph is large, it will face the problem of memory overflow. Most relevant to us, Chiang et al.  \cite{chiang2019cluster} propose a sub-graph training algorithm to tackle the memory bottleneck. They apply a graph clustering algorithm to partition a graph into sub-graphs and train a graph convolutional network on the partitioned sub-graphs. In our problem, it is not practical to cluster nodes based on their topological information because our model learns the latent graph structure at the same time. Alternatively, in each iteration, we randomly split the nodes into several groups and let the algorithm learn a sub-graph structure based on the sampled nodes. This gives each node the full possibilities of being assigned with another node in one group so that the similarity score between these two nodes can be computed and updated. As a side benefit, if we split the nodes into  groups, we can reduce the time and space complexity of our graph learning layer from  to  in each iteration. After training, as all node embeddings are well-trained, a global graph can be constructed to fully utilize spatial relationships. Although it is computationally expensive, the adjacency matrix can be pre-computed in parallel before making predictions. 

The second consideration of our proposed algorithm is to facilitate our model stabilize in a better local optimum. In the task of multi-step forecasting, we observe that long-term predictions often achieve greater improvements than those in the short-term in terms of model performance. We believe the reason is that our model predicts multi-steps altogether, and long-term predictions produce a much higher loss than short-term predictions. As a result, to minimize the overall loss, the model focuses more on improving the accuracy of long-term predictions. To address this issue we propose a \textit{curriculum learning} strategy for the multi-step forecasting task. The algorithm starts with solving the easiest problem, predicting the next one-step only. It is very advantageous for the model to find a good starting point. With the increase in iteration numbers, we increase the prediction length of the model gradually so that the model can learn the hard task step by step.
Covering all this, our algorithm is given in Algorithm 1.  Further complexity analysis of our model can be found in Appendix \textbf{A.1}.


\begin{algorithm}[t]
\caption{The learning algorithm of MTGNN.}\label{alg}
\begin{algorithmic}[1]
\small
\State \textbf{Input}: The dataset , node set , the initialized MTGNN model  with , learning rate , batch size , step size , split size  (default=1).
\State set 
\Repeat
\State sample a batch  from .
\State random split the node set  into  groups, .
\If{ and }
\State 
\EndIf

\For{i in 1:m}
\State compute 
\State compute  
\State compute the stochastic gradient of  according to .
\State update model parameters  according to their gradients and the learning rate .
\EndFor
\State .
\Until{convergence}
\end{algorithmic}
\end{algorithm}

\section{Experimental Studies}
We validate MTGNN on two tasks - both single-step and multi-step forecasting. First, we compare the performance of MTGNN with other multivariate time series models on four benchmark datasets for multivariate time series forecasting, where the aim is to predict a single future step.
Furthermore, to show how well MTGNN performs, compared with other spatial-temporal graph neural networks which, in contrast, use pre-defined graph structural information, we evaluate MTGNN on two benchmark datasets for spatial-temporal graph neural networks, where the aim is to predict multiple future steps. Further results on parameter study can be found in Appendix \textbf{A.4}.

\subsection{Experimental Setting}
In Table \ref{tb:data-stats}, we summarize statistics of benchmark datasets.
More details about the datasets is given in Appendix \textbf{A.2}. 
We use five evaluation metrics, including Mean Absolute Error (MAE), Root Mean Squared Error (RMSE), Mean Absolute Percentage Error (MAPE), Root Relative Squared Error (RRSE), and Empirical Correlation Coefficient (CORR). For RMSE, MAE, MAPE, and RRSE, lower values are better. For CORR, higher values are better. 
Other experimental setups are given in Appendix \textbf{A.3}.
\begin{table}
	\begin{center}
		\caption{\small Dataset statistics.}
		\label{tb:data-stats}
		\resizebox{\columnwidth}{!}{\begin{tabular}{lrrrrrr} 
				\toprule
				Datasets 		& \# Samples		& \# Nodes	& Sample Rate	& Input Length & Output Length	 \\
				\midrule
				traffic 		& 17,544 	& 862 	& 1 hour & 168 & 1	\\
				solar-energy			& 52,560	& 137	& 10 minutes & 168 & 1\\
				electricity 	& 26,304 	& 321 	& 1 hour & 168 & 1	\\
				exchange-rate		& 7,588		& 8		& 1 day	& 168 & 1	\\
				\midrule
				metr-la & 34272 & 207 & 5 minutes & 12 & 12 \\
				pems-bay & 52116 & 325 & 5 minutes & 12 & 12 \\
				\bottomrule
		\end{tabular}}
	\end{center}
\end{table}

\subsection{Baseline Methods for Comparision}
MTGNN and MTGNN+sampling are our models to be evaluated. MTGNN is our proposed model.   MTGNN+sampling is our proposed model trained on a sampled subset of a graph in each iteration. 
Baseline methods are summarized in the following:

\subsubsection{Single-step forecasting}
\begin{itemize}
	\item AR: An auto-regressive model.
\item VAR-MLP: A hybrid model of the multilayer perception (MLP) and auto-regressive model (VAR) \cite{zhang2003time}.
	\item GP: A Gaussian Process time series model \cite{roberts2013gaussian,frigola2016bayesian}.
	\item RNN-GRU: A recurrent neural network with fully connected GRU hidden units.
	\item LSTNet: A deep neural network, which combines convolutional neural networks and recurrent neural networks  \cite{lai2018modeling}.
	\item TPA-LSTM: An attention-recurrent neural network \cite{shih2019temporal}.
\end{itemize}
\subsubsection{Multi-step forecasting}
\begin{itemize}
	\item DCRNN: A diffusion convolutional recurrent neural network, which combines diffusion graph convolutions with recurrent neural networks \cite{li2018diffusion}.
	\item STGCN: A spatial-temporal graph convolutional network,  which incorporates graph convolutions with 1D convolutions \cite{yu2018spatio}.
	\item Graph WaveNet: A spatial-temporal graph convolutional network, which integrates diffusion graph convolutions with 1D dilated convolutions \cite{wu2019graph}.
	\item ST-MetaNet: A sequence-to-sequence architecture, which employs meta networks to generate parameters \cite{pan2019urban}.
	\item GMAN: A graph multi-attention network with spatial and temporal attentions \cite{zheng2020gman}. 
	\item MRA-BGCN: A multi-range attentive bicomponent GCN \cite{chen2020multi}.
\end{itemize}





\subsection{Main Results}

\begin{table*}
	\centering
	\caption{Baseline comparison under single-step forecasting for multivariate time series methods.}
	\label{table:single}
	\resizebox{\textwidth}{!}{
		
		\begin{tabular}{ll|cccc|cccc|cccc|cccc}
			
			
			\toprule
			\-1em]
			\-1em]
			\-1em]
			\midrule
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\hline\hline
			\-1em]
			\-1em]
			\-1em]
			\hline
			\-1em]
			\-1em]
			\-1em]
			\bottomrule
		\end{tabular}
	}
\end{table*}

Table \ref{table:single} and Table \ref{table:multi} provide the main experimental results of MTGNN and MTGNN+sampling. We observe that MTGNN achieves state-of-the-art results on most of the tasks, and the performance of MTGNN only degrades marginal when it samples sub-graphs for training. In the following, we discuss experimental results of single-step and multi-step forecasting respectively.

\subsubsection{Single-step forecasting} In this experiment, we compare MTGNN with other multivariate time series models.  Table \ref{table:single} shows the experimental results for the single-step forecasting task. In general, our MTGNN achieves state-of-the-art results over almost all horizons on Solar-Energy, Traffic, and Electricity data. In particular, on Traffic data, the improvement of MTGNN in terms of RSE is significant. MTGNN lowers down RSE by 7.24\%, 3.88\%, 4.83\%  over the horizons of 3, 12, 24 on the traffic data. The main reason why MTGNN improves the results of traffic data evidently is that the nature of traffic data is better suited for our model assumption about the spatial-temporal dependencies. Obviously, the future traffic occupancy rate of a road not only depends on its past but also on its connected roads' occupancy rates. MTGNN fails to make improvements on the exchange-rate data, possibly due to the smaller graph size and fewer training examples of exchange-rate data.


\subsubsection{Multi-step forecasting}
In this experiment, we compare MTGNN with other spatial-temporal graph neural network models. Table \ref{table:multi} shows the experimental results for the task of multi-step forecasting. The significance of MTGNN lies in that it achieves on-par performance with state-of-the-art spatial-temporal graph neural networks without using a pre-defined graph, while DCRNN, STGCN, and MRA-BGCN fully rely on pre-defined graphs. Graph Wavenet proposes a self-adaptive adjacency matrix, but it needs to combine with a pre-defined graph in order to achieve optimal performance. ST-MetaNet employs attention mechanisms to adjust the edge weights of a pre-defined graph. GMAN leverages node2vec algorithm to preserve node structural information while performing attention mechanisms.  When a graph is not defined, these methods cannot model multivariate times series data efficiently. 


\begin{table}[tb]
	\centering
	\caption{Baseline comparison under multi-step forecasting for spatial-temporal graph neural networks.} 
	\label{table:multi}
	\resizebox{0.48\textwidth}{!}{
		
		\begin{tabular}{ l  r r r | r r r |r r r}
			\toprule
			\multirow{2}{*}{}   & \multicolumn{3}{c}{Horizon 3} & \multicolumn{3}{c}{Horizon 6}  & \multicolumn{3}{c}{Horizon 12} \\
			\cline{2-4}  \cline{5-7} \cline{8-10}   		    \-1em]  
			
			DCRNN  & 2.77 & 5.38 & 7.30\% & 3.15 & 6.45 & 8.80\% & 3.60 & 7.60 & 10.50\% \\ 
			STGCN  & 2.88 & 5.74 & 7.62\% & 3.47 & 7.24 & 9.57\% & 4.59 & 9.40 & 12.70\%\\
			Graph WaveNet  & 2.69 & 5.15 & 6.90\% & 3.07 & 6.22 & 8.37\% & 3.53 & 7.37 & 10.01\%\\
			ST-MetaNet & 2.69 & 5.17 & 6.91\% & 3.10 & 6.28 & 8.57\% & 3.59 & 7.52 & 10.63\% \\
			MRA-BGCN  & \textbf{2.67} & \textbf{5.12} & 6.80\% & 3.06 & 6.17 & 8.30\% & 3.49 & 7.30 & 10.00\%\\
			GMAN & 2.77 & 5.48 & 7.25\% & 3.07 & 6.34 & 8.35\% & \textbf{3.40} & \textbf{7.21} & \textbf{9.72\%} \\  		    
			\-1em]
			MTGNN & 2.69 &  5.18 & 6.86\% & \textbf{3.05} & \textbf{6.17} & \textbf{8.19\%} & 3.49 & 7.23 & 9.87\%\\
			MTGNN+sampling & 2.76  & 5.34 & \textbf{5.18\%} & 3.11  &  6.32 & 8.47\%  & 3.54 & 7.38 & 10.05\%\\
			\hline \hline 
			PEMS-BAY  \\ \cline{1-1}
			\-1em]  
			\hline
			\-1em]  
			\midrule
			\-1em]  
			\hline
			\-1em]  
			\hline
			\-1em]
			Methods & Equation & MAE & RMSE & MAPE\\
			\-1em]
			Pre-defined-A & - & 2.90170.0078 & 6.12880.0345 & 0.08360.0009\\
			\-1em]
			Global-A &  & 2.84570.0107 & 5.99000.0390 & 0.08050.0009 \\ 
			\-1em]
			Undirected-A  &   & 2.77360.0185 & 5.84110.0523 & 0.07830.0012\\ 
			\-1em]
			Directed-A  &   & 2.77580.0088 & 5.82170.0451 & 0.07830.0006\\ \-1em]
			Dynamic-A &  & 2.81240.0102 & 5.91890.0281
			& 0.07940.0008 \\ \-1em]
			Uni-directed-A (ours) &  & \textbf{2.77150.0119} & \textbf{5.80700.0512} & \textbf{0.07780.0009} \\
			\-1em]  
			\midrule
			\-1em]  
			\hline
			\-1em]  
			\hline
			\-1em]
			Temporal Convolution Module & \\ 
			
			\bottomrule 
		\end{tabular}
	}
	\caption{Time Complexity Analysis}
	\label{tab:time}
\end{table}

\subsection{Data}\label{sec:dataset}
In Table \ref{tb:data-stats}, we summarize statistics of benchmark datasets. Details of these datasets are introduced below.

\subsubsection{Single-step forecasting}
\begin{itemize}
    \item Traffic: the traffic dataset from the California Department of Transportation contains road occupancy rates measured by 862 sensors in San Francisco Bay area freeways during 2015 and 2016.
    \item Solar-Energy: the solar-energy dataset from the National Renewable Energy Laboratory contains
    the solar power output collected from 137 PV plants in Alabama State in 2007.
    \item Electricity:  the electricity dataset from the UCI Machine Learning Repository contains electricity consumption for 321 clients from 2012 to 2014.
    \item Exchange-Rate: the exchange-rate dataset contains the daily exchange rates of eight foreign countries including Australia, British, Canada, Switzerland, China, Japan, New Zealand, and Singapore ranging from 1990 to 2016.
\end{itemize}
Following \cite{lai2018modeling}, we split these four datasets into a training set (60\%), validation set (20\%), and test set (20\%) in chronological order. The input sequence length is 168 and the output sequence length is 1.
Models are trained independently to predict the target future step (horizon) 3, 6, 12, and 24.

\subsubsection{Multi-step forecasting}
\begin{itemize}
    \item METR-LA: the METR-LA dataset from the Los Angeles Metropolitan Transportation Authority contains average traffic speed measured by 207 loop detectors 
    on the highways of Los Angeles County ranging from Mar 2012 to Jun 2012.
    \item PEMS-BAY: the PEMS-BAY dataset from California Transportation Agencies (CalTrans) contains average traffic speed measured by 325 sensors 
    in the Bay Area ranging from Jan 2017 to May 2017.
\end{itemize}
Following \cite{li2018diffusion}, we split these two datasets into a training set (70\%), validation set (20\%), and test set (10\%) in chronological order. The input sequence length is 12, and the target sequence contains the next 12 future steps.
The time of the day is used as an auxiliary feature for the inputs. For the selected baseline methods, the pairwise road network distances are used as the pre-defined graph structure.


\subsection{Experimental Setup}\label{sec:expsetup}
We repeat the experiment 10 times and report the average value of evaluation metrics. The model is trained by the Adam optimizer with gradient clip 5. The learning rate is 0.001. The l2 regularization penalty is 0.0001. Dropout with 0.3 is applied after each temporal convolution module. Layernorm is applied after each graph convolution module. The depth of the mix-hop propagation layer is set to 2. The retain ratio from the mix-hop propagation layer is set to . 
The saturation rate of the activation function from the graph learning layer is set to .
The dimension of node embeddings is 40. Other hyper-parameters are reported according to different tasks.  

\subsubsection{Single-step forecasting}
We use 5 graph convolution modules and 5 temporal convolution modules with the dilation exponential factor 2. The starting  convolution has 1 input channel and 16 output channels. The graph convolution module and the temporal convolution modules both have 16 output channels. The skip connection layers all have 32 output channels. The first layer of the output module has 64 output channels and the second layer of the output module has 1 output channel. The number of training epochs is 30. For Traffic, Solar-Energy, and Electricity, the number of neighbors for each node is 20. For Exchange-Rate, the number of neighbors for each node is 8. The batch size is set to 4.  For the MTGNN+sampling model, we split the nodes of a graph into three partitions randomly with a batch size of 16. Following \cite{lai2018modeling}, we use RSE and CORR as evaluation metrics.

\subsubsection{Multi-step forecasting}
We use 3 graph convolution modules and 3 temporal convolution modules with the dilation exponential factor 1. The starting  convolution has 2 input channels and 32 output channels. The graph convolution module and the temporal convolution module both have 32 output channels. The skip connection layers all have 64 output channels. The first layer of the output module has 128 output channels and its second layer has 12 output channels. The number of neighbors for each node is 20. The number of training epochs is 100. The batch size is set to 64. Following \cite{li2018diffusion}, we use MAE, RMSE , and MAPE as evaluation metrics.

\subsection{Parameter Study}
We conduct a parameter study on eight core hyper-parameters which influence the model complexity of MTGNN. We list these hyper-parameters as follows: Number of layers, the number of temporal convolution modules, ranges from 1 to 6. Number of filters, the number of output channels for temporal convolution modules and graph convolution modules, ranges from 4 to 128. Number of neighbors, the parameter  in Equation \ref{eq:argtop}, ranges from 10 to 60. Saturation rate, the parameter  in Equation \ref{eq:m1}, \ref{eq:m2}, and \ref{eq:adp}, ranges from 0.5 to 5. Retain ratio of mix-hop propagation layer, the parameter  in Equation \ref{eq:ppnp}, ranges from 0 to 0.8. Depth of mix-hop propagation layer, the parameter  in Equation \ref{eq:mix}, ranges from 1 to 6. 

We repeat each experiment 10 times with 50 epochs each time and report the average of MAE with a standard deviation over 10 runs on the validation set. We change the parameter under investigation and fix other parameters in each experiment.  Figure \ref{fig:para} shows the experimental results of our parameter study. As shown in Figure \ref{fig:6a} and Figure \ref{fig:6b}, increasing the number of layers and filters enhances our model's expressive capacity, while reducing the MAE loss. Figure \ref{fig:6c} shows that a small number of neighbors gives better results. It is possibly because a node may only depend on a limited number of other nodes, and increasing its neighborhood merely introduces noises to the model. The model performance is not sensitive to the saturation rate, as shown in Figure \ref{fig:6d}. However, a large saturation rate can impose values of the adjacency matrix produced by the graph learning layer approach to 0 or 1. As shown in Figure \ref{fig:6e}, a high retain ratio degrades the model performance significantly. We think it is because by default the propagation depth of the mix-hop propagation layer is set to , and as a result, keeping a high proportion of root information constrains a node from exploring its neighborhood. Figure \ref{fig:6f} shows that it is enough to propagate node information with 2 or 3 steps. With the increase of the depth of propagation, the proposed mix-hop propagation layer does not suffer from the over-smoothing problem incurred by information aggregation. With the depth of propagation equal to 6, it has the lowest mean MAE with a larger variation.

\begin{figure}
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/layer.pdf}
            \caption[Number of layers]{{\small Number of layers}}    
            \label{fig:6a}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/filter.pdf}
            \caption[Number of filters]{{\small Number of filters}}    
            \label{fig:6b}
        \end{subfigure}
        \newline
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/numneigbhor.pdf}
            \caption[Number of neighbors]{{\small Number of neighbors}}    
            \label{fig:6c}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/tanhalpha.pdf}
            \caption[Saturation rate]{{\small Saturation rate}}    
            \label{fig:6d}
        \end{subfigure}
        \newline
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/propalpha.pdf}
            \caption[Retain ratio]{{\small Retain ratio}}    
            \label{fig:6e}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.23\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{./FIG/plots/gcndepth.pdf}
            \caption[Depth of propagation]{{\small Depth of propagation}}    
            \label{fig:6f}
        \end{subfigure}
        \caption[Parameter Study]
        {\small Parameter Study} 
        \label{fig:para}
\end{figure}



\end{document}
