\documentclass[a4paper]{article}
\usepackage{INTERSPEECH2016,amssymb,amsmath,epsfig}
\setcounter{page}{1}
\sloppy     \ninept


\def\reg{{\rm\ooalign{\hfil
     \raise.07ex\hbox{\scriptsize R}\hfil\crcr\mathhexbox20D}}}
\title{Segmental Recurrent Neural Networks for End-to-end Speech Recognition}

\makeatletter
\def\name#1{\gdef\@name{#1\\}}
\makeatother \name{{\em Liang Lu, Lingpeng Kong, Chris Dyer, Noah A. Smith, and Steve Renals}
\thanks{ Equal contribution.  Lu and Renals are funded by the UK EPSRC Programme Grant EP/I031022/1, Natural Speech Technology (NST). The NST research data collection may be accessed at http://datashare.is.ed.ac.uk/handle/10283/786.}}

\address{Centre for Speech Technology Research, The University of Edinburgh, Edinburgh, UK \\
School of Computer Science, Carnegie Mellon University, Pittsburgh, USA\\
Computer Science \& Engineering, The University of Washington, Seattle, USA \\
{\small \tt \{liang.lu, s.renals\}@ed.ac.uk, \{lingpenk, cdyer\}@cs.cmu.edu, nasmith@cs.washington.edu}}
\newcommand{\lpkcomment}[1]{\textcolor{red}{\bf [#1 --\textsc{lpk}]}}

\begin{document}
\maketitle

\begin{abstract}
We study the segmental recurrent neural network for end-to-end acoustic modelling. This model connects the segmental conditional random field (CRF) with a recurrent neural network (RNN) used for feature extraction. Compared to most previous CRF-based acoustic models, it does not rely on an external system to provide features or segmentation boundaries. Instead, this model marginalises out all the possible segmentations, and features are extracted from the RNN trained together with the segmental CRF. Essentially, this model is self-contained and can be trained end-to-end. In this paper, we discuss practical training and decoding issues as well as the method to speed up the training in the context of speech recognition. We performed experiments on the TIMIT dataset. We achieved 17.3\% phone error rate (PER) from the first-pass decoding --- the best reported result using CRFs, despite the fact that we only used a zeroth-order CRF and without using any language model. 

\end{abstract}
\noindent{\bf Index Terms}: end-to-end speech recognition, segmental CRF, recurrent neural networks.


\section{Introduction}
\label{sec:intro}

Speech recognition is a typical sequence to sequence transduction problem, i.e., given a sequence of acoustic observations, the speech recognition engine decodes the corresponding sequence of words or phonemes. A key component in a speech recognition system is the acoustic model, which computes the conditional probability of the output sequence given the input sequence. However, directly computing this conditional probability is challenging due to many factors including the variable lengths of the input and output sequences. The hidden Markov model (HMM) converts this sequence-level classification task into a frame-level classification problem, where each acoustic frame is classified into one of the hidden states, and each output sequence corresponds to a sequence of hidden states. To make it computationally tractable, HMMs usually rely on the conditional independence assumption and the first-order Markov rule --- the well-known weaknesses of HMMs~\cite{gillick2011don}. Furthermore, the HMM-based pipeline is composed of a few relatively independent modules, which makes the joint optimisation nontrivial. 

There has been a consistent research effort to seek architectures to replace HMMs and overcome their limitation for acoustic modelling, e.g., ~\cite{ostendorf1996,smith2001speech, gunawardana2005hidden, hifny2009speech}; however these approaches have not yet improved speech recognition accuracy over HMMs. In the past few years, several neural network based approaches have been proposed and demonstrated promising results. In particular, the connectionist temporal classification (CTC) ~\cite{graves2014towards, Hannun2014Deep, sak2015fast, miao2015eesen} approach defines the loss function directly to maximise the conditional probability of the output sequence given the input sequence, and it usually uses a recurrent neural network to extract features. However, CTC simplifies the sequence-level error function by a product of the frame-level error functions (i.e., independence assumption), which means it essentially still does frame-level classification. It also requires the lengths of the input and output sequence to be the same, which is inappropriate for speech recognition. CTC deals with this problem by replicating the output labels so that a consecutive frames may correspond to the same output label or a {\it blank} token. 


Attention-based RNNs have been demonstrated to be a powerful alternative sequence-to-sequence transducer, e.g., in machine translation ~\cite{bahdanau2014neural}, and speech recognition ~\cite{chorowski2015attention, lu2015study, chan2015listen}. A key difference of this model from HMMs and CTCs is that the attention-based approach does not apply the conditional independence assumption to the input sequence. Instead, it maps the variable-length input sequence into a fixed-size vector representation at each decoding step by an attention-based scheme (see ~\cite{bahdanau2014neural} for further explanation). It then generates the output sequence using an RNN conditioned on the vector representation from the source sequence. The attentive scheme suits the machine translation task well, because there may be no clear alignment between the source and target sequence for many language pairs. However, this approach does not naturally apply to the speech recognition task, as each output token only corresponds to a small size window of acoustic spectrum. 

In this paper, we study segmental RNNs~\cite{kong2015segmental} for acoustic modelling. This model is similar to CTC and attention-based RNN in the sense that an RNN encoder is also used for feature extraction, but it differs in the sense that the sequence-level conditional probability is defined using an segmental (semi-Markov) CRF~\cite{sarawagi2004semi}, which is an extension on the standard CRF~\cite{lafferty2001conditional}. There have been numerous works on CRFs and their variants for speech recognition, e.g, ~\cite{gunawardana2005hidden, hifny2009speech, zweig2011speech} (see \cite{fosler2013conditional} for an overview). In particular, feed-forward neural networks have been used with segmental CRFs for speech recognition~\cite{abdel2013deep, he2015segmental}. However, segmental RNNs are different in that they are end-to-end models --- they do not depend on external systems to provide segmentation boundaries and features, instead, they are trained by marginalising out all possible segmentations, while the features are derived from the encoder RNNs, which are trained jointly with the segmental CRFs. Our experiments were performed on the TIMIT dataset, and we achieved 17.3\% PER from first-pass decoding with zeroth-order CRF and without using any language model --- the best reported result using CRFs. 
 




\section{Segmental Recurrent Neural Networks}



\subsection{Segmental Conditional Random Fields}

Given a sequence of acoustic frames  and its corresponding sequence of output labels , where , segmental (or semi-Markov) conditional random field defines the sequence-level conditional probability with the auxiliary segment labels  as

where  is a tuple of the beginning () and the end () time tag for the segment of , and  while ;  and  denotes the vocabulary set;  is the normaliser that that sums over all the possible  pairs, i.e.,

Here, we only consider the zeroth-order CRF, while the extension to higher order models is straightforward. Similar to other CRF-based models, the function  is defined as

where  denotes the feature function, and  is the weight vector. Previous works on CRF-based acoustic models mainly use heuristically handcrafted feature function . They also usually rely on an external system to provide the segment labels. In this paper, we define  using neural networks, and the segmentation  is marginalised out during training, which makes our model self-contained. 

\subsection{Feature Representations}

We use neural networks to define the feature function , which maps the acoustic segment and its corresponding label into a joint feature space. More specifically,  is firstly represented as a one-hot vector , and it is then mapped into a continuous space by a linear embedding matrix  as

Given the segment label , we use an RNN to map the acoustic segment to a fixed-dimensional vector representation,  i.e.,

where  denotes the initial hidden state,  denotes the duration of the segment and  is a non-linear function. We take the final hidden state  as the segment embedding vector, then  can be represented as 

where  corresponds to one layer or multiple layers of linear or non-linear transformation. In fact, it is flexible to include other relevant features as additional inputs to the function , e.g., the duration feature which can be obtained by converting  into another embedding vector. In practice, multiple RNN layers can be used transform the acoustic signal  before extracting the segment embedding vector  as Figure \ref{fig:segrnn}. 

\begin{figure}[t]
\small
\centerline{\includegraphics[width=0.45\textwidth]{segrnn}} \vskip -4mm
\caption{Segmental RNN using a first-order CRF. The coloured circles denote the segment embedding vector  in Eq.\eqref{eq:emb}. Using bi-directional RNNs is straightforward. }  
\label{fig:segrnn}
\vskip -5mm
\end{figure}

\subsection{Conditional Maximum Likelihood Training}

For speech recognition, the segmentation labels  are usually unknown,  training the model by maximising the conditional probability as Eq. \eqref{eq:crf} is therefore not practical. The problem can be addressed by defining the loss function as the negative marginal log-likelihood as

where  denotes the set of model parameters, and  denotes the summation over all the possible segmentations when only  is observed. To simplify notations, the objective function  is define with only one training utterance. 

However, the number of possible segmentations is exponential with the length of , which makes the naive computation of both  and  impractical. Fortunately, this can be addressed by using the following dynamic programming algorithm as proposed in~\cite{sarawagi2004semi}:

In Eq. \eqref{eq:alpha}, the first summation is over all the possible segmentation up to timestep , and the second summation is over all the possible labels from the vocabulary. The computation cost of this algorithm is , where  is the size of the vocabulary. The cost can be further reduced by introducing an upper bound of  the segment length, in which case Eq. \eqref{eq:alpha} can be rewritten as

where  denotes the maximum value of the segment length. The cost is then reduced to , and for long sequences like speech signals where , the computational savings are substantial. 

The term  can be computed similarly. In this case, since the label  is now observed, the summation over all the possible labels  in Eq. \eqref{eq:alpha} is not necessary, i.e.,

Again, we can limit the length of the possible segments as Eq. \eqref{eq:alpha2}. Given  and , the loss function  can be minimised using the stochastic gradient decent (SGD) algorithm similar to training other neural network models. Other losses, for example, hinge, can be considered in future work.

\begin{figure}[t]
\small
\centerline{\includegraphics[width=0.3\textwidth]{subsample}} \vskip -4mm
\caption{ Hierarchical subsampling recurrent network~\cite{graves2012hierarchical} . The size of the subsampling window is two in this example.  }  
\label{fig:hsrnn}
\vskip -5mm
\end{figure}

\subsection{Viterbi Decoding}

During decoding, we need to search the target label sequence  that yields the highest posterior probability given  by marginalising out all the possible segmentations:

This involves minor modification of the recursive algorithm in Eq. \eqref{eq:alpha} that instead of summing over all the possible labels, the Viterbi path up to the timestep  is

However, marginalising out all the possible segmentations is still expensive. The computational cost can be further reduced by greedy searching the most likely segmentation,  i.e.,

which corresponds to the decoding objective as

This joint maximization algorithm may yield high search error, because it only considers one segmentation.  In the future, we shall investigate the beam search algorithm which may yield a lower search error.

\subsection{Further Speedup}
\label{sec:subsample}

It is computationally expensive for RNNs to model long sequences, and the number of possible segmentations is exponential with the length of the input sequence as mentioned before. The computational cost can be significantly reduced by using the hierarchical subsampling RNN~\cite{graves2012hierarchical} to shorten the input sequences, where the subsampling layer takes a window of hidden states from the lower layer as input as shown in Figure \ref{fig:hsrnn}.  In this work, we consider three variants: a) {\it concatenate} -- the hidden states in the subsampling window are concatenated before been fed into the next layer; b) {\it add} -- the hidden states are added into one vector for the next layer; c) {\it skip} -- only the last hidden state in the window is kept and all the others are skipped. The last two schemes are computationally cheaper as they do not introduce extra model parameters. 

\section{Experiments}
\label{sec:exp}


 \begin{table}
 \centering \small
\caption{Speedup by hierarchical subsampling networks. }\vskip 1.5mm

\label{tab:speedup}
\begin{tabular}{l|cc}
\hline

\hline
subsampling   &  &  speedup  \\ \hline
No & 30  & 1 \\
1 layer & 15   & 3x\\
2 layers & 8 & 10x \\

\hline

\hline
\end{tabular}
\vskip-4mm
\end{table}

 \begin{table}
 \centering \small
\caption{Results of hierarchical subsampling networks.  and  denote the dimension of  and  in Eqs. \eqref{eq:phi} and \eqref{eq:emb} respectively. {\tt layers} denotes the number of LSTM layers and {\tt hidden} is the dimension of the LSTM  cells. We reduced the dimension of  from the LSTM output for computational reasons. {\tt conc} is short for the concatenating operation. }\vskip 1.5mm

\label{tab:hsrnn}
\begin{tabular}{l|ccccc}
\hline

\hline
System  & ) &  & layers & hidden &  PER(\%) \\ \hline
{\tt skip} & 64 & 64 & 3 & 128 & 21.2 \\
{\tt conc} & 64 & 64 & 3 & 128  & 21.3 \\
{\tt add}  & 64 & 64 & 3 & 128  & 23.2 \\ \hline
{\tt skip} & 64 & 64 & 3 & 250 & 20.1 \\
{\tt conc} & 64 & 64 & 3 & 250 & 20.5 \\ 
{\tt add} & 64 & 64 & 3 & 250 & 21.5  \\

\hline

\hline
\end{tabular}
\vskip-5mm
\end{table}

\subsection{System Setup}

We used the TIMIT dataset to evaluate the segmental RNN acoustic models. This dataset was preferred for the rapid evaluation of different system settings, and for the comparison to other CRF and end-to-end systems. We followed the standard protocol of the TIMIT dataset, and our experiments were based on the Kaldi recipe~\cite{povey2011kaldi}. We used the core test set as our evaluation set, which has 192 utterances. We used 24 dimensional log fiterbanks (FBANKs) with delta and double-delta coefficients, yielding 72 dimensional feature vectors. Our models were trained with 48 phonemes, and their predictions were converted to 39 phonemes before scoring. The dimension of  was fixed to be 32. For all our experiments, we used the long short-term memory (LSTM) networks~\cite{hochreiter1997long} as the implementation of RNNs, and the networks were always bi-directional. We set the initial SGD learning rate to be 0.1, and we exponentially decay the learning rate by a factor of 2 when the validation error stopped decreasing. Our models were trained with dropout regularisation~\cite{srivastava2014dropout}, using an specific implementation for recurrent networks~\cite{zaremba2014recurrent}. The dropout rate was 0.2 unless specified otherwise. Our models were randomly initialised with the same random seed.

\subsection{Results of Hierarchical Subsampling}

We first demonstrate the results of the hierarchical subsampling recurrent network, which is the key to speed up our experiments. We set the size of the subsampling window to be 2, therefore each subsampling layer reduced the time resolution by a factor of 2. We set the maximum segment length  in Eq. \eqref{eq:seglen} to be 300 milliseconds, which corresponded to 30 frames of FBANKs (sampled at the rate of 10 milliseconds).  With two layers of subsampling recurrent networks, the time resolution was reduced by a factor of 4, and the value of  was reduced to be 8, yielding around 10 times speedup as shown in Table \ref{tab:speedup}. 

Table \ref{tab:hsrnn} compares the three implementations of the recurrent subsampling network detailed in section \ref{sec:subsample}. We observed that concatenating all the hidden states in the subsampling window did not yield lower phone error rate (PER) than using the simple {\it skipping} approach, which may be due to the fact that the TIMIT dataset is small and it prefers a smaller model. On the other hand, adding the hidden states in the subsampling window together worked even worse, possibly due to that the sequential information in the subsampling window was flattened. In the following experiments, we sticked to the {\it skipping} method, and using two subsampling layers.

 \begin{table}
 \centering \small
\caption{Results of tuning the hyperparameters. }\vskip 1.5mm
\label{tab:tune}
\begin{tabular}{c|cccccc}
\hline

\hline
Dropout  & ) &  & layers & hidden & PER  \\ \hline
 & 64 & 64 & 3 & 128  & 21.2 \\
& 64 & 32 & 3 & 128 & 21.6 \\
 & 32 & 32 & 3 & 128  & 21.4 \\ \cline{2-6}
  & 64 & 64 & 3 & 250 & 20.1 \\
 0.2 & 64 & 32 & 3 & 250 & 20.4 \\
 & 32 & 32 & 3 & 250 & 20.6 \\ \cline{2-6}
 & 64 & 64 & 6 & 250 & 19.3 \\
 & 64 & 32 & 6 & 250 & 20.2  \\
 & 32 & 32 & 6 & 250 & 20.2 \\ \hline
 & 64 & 64 & 3 & 128 & 21.3 \\
0.1 & 64 & 64 & 3 & 250 & 20.9 \\
 & 64 & 64 & 6 & 250 & 20.4 \\ \hline
  & 64 & 64 & 6 & 250 & 21.9 \\
\hline

\hline
\end{tabular}
\vskip-4mm
\end{table}

\begin{table}
 \centering \small
\caption{Results of three types of acoustic features. }\vskip 1.5mm
\label{tab:feautre}
\begin{tabular}{l|cccccc}
\hline

\hline
Features  & Deltas &  & PER  \\ \hline
 24-dim FBANK &  & 72 & 19.3 \\
 40-dim FBANK &  & 120 & 18.9 \\
 Kaldi &  & 40 &  17.3 \\ 
 \hline

\hline
\end{tabular}
\vskip-5mm
\end{table}

\subsection{Hyperparameters and Different Features}

We then evaluated the model by tuning the hyperparameters, and the results are given in Table \ref{tab:tune}. We tuned the number of LSTM layers, and the dimension of LSTM cells, as well as the dimensions of  and the segment vector . In general, larger models with dropout regularisation yielded higher recognition accuracy. Our best result was obtained using 6 layers of 250-dimensional LSTMs. However, without the dropout regularisation, the model can be easily overfit due to the small size of training set. In the future, we shall evaluate this model with a large dataset. 

We then evaluated another two types of features using the same system configuration that achieved the best result in Table \ref{tab:tune}. We increased the number of FBANKs from 24 to 40, which yielded slightly lower PER. We also evaluated the standard Kaldi features --- 39 dimensional MFCCs spliced by a context window of 7, followed by LDA and MLLT transform and with feature-space speaker-dependent MLLR, which were the same features used in the HMM-DNN baseline in Table \ref{tab:compare}. The well-engineered features improved the accuracy of our system by more than 1\% absolute.

 \begin{table}
 \centering \small
\caption{Comparison to Related Works. {\tt LM} denotes the language model, and {\tt SD} denotes speaker-dependent transform. The HMM-DNN baseline was trained with cross-entropy using the Kaldi recipe. Sequence training did not improve it due to the small amount of data. Note that RNN transducer and attention-based RNN are equipped with built-in RNNLMs.}\vskip 1.5mm

\label{tab:compare}
\begin{tabular}{l|ccc}
\hline

\hline
System  & LM & SD & PER  \\ \hline
HMM-DNN &  &   & 18.5 \\
first-pass SCRF~\cite{zweig2012classification} &  &  & 33.1  \\
Boundary-factored SCRF~\cite{he2012efficient} &   &  & 26.5 \\
Deep Segmental NN~\cite{abdel2013deep} &  &  & 21.9 \\
Discriminative segmental cascade~\cite{tang2015discriminative} &  &  & 21.7 \\
 + 2nd pass with various features &  &  & 19.9 \\ \hline
CTC~\cite{graves2013speech} &  &  & 18.4 \\
RNN transducer~\cite{graves2013speech} & -- &  & 17.7 \\
Attention-based RNN~\cite{chorowski2015attention} & -- &  & 17.6 \\
Segmental RNN & &  & 18.9 \\
Segmental RNN & &  & 17.3 \\
 
\hline

\hline
\end{tabular}
\vskip-4mm
\end{table}


\subsection{Comparison to Related Works }

In Table \ref{tab:compare}, we compare our result to other reported results using segmental CRFs as well as recent end-to-end systems. Previous state-of-the-art result using segmental CRFs on the TIMIT dataset is reported in~\cite{tang2015discriminative}, where the first-pass decoding was used to prune the search space, and the second-pass was used to re-score the hypothesis using various features including neural network features. Besides, the ground-truth segmentation was used in~\cite{tang2015discriminative}. We achieved considerably lower PER with first-pass decoding, despite the fact that our CRF was zeroth-order, and we did not use any language model. Furthermore, our results are also comparable to that from the CTC and attention-based RNN end-to-end systems. The accuracy of segmental RNNs may be further improved by using higher-order CRFs or incorporating a language model into the decode step, and using beam search to reduce the search error.

\section{Conclusions}
In this paper, we present the segmental RNN --- a novel acoustic model that combines the segmental CRF with an encoder RNN for end-to-end speech recognition. We discuss the practical training and decoding algorithms of this model for speech recognition, and the subsampling network to reduce the computational cost. Our experiments were performed on the TIMIT dataset, and we achieved strong recognition accuracy using zeroth-order CRF, and without using any language model. In the future, we shall investigate discriminative training criteria, and incorporating a language model into the decoding step. Future works also include implementing a weighted finite sate transducer (WFST) based decoder and scaling this model to large vocabulary datasets.  

\newpage
\small
\bibliographystyle{IEEEtran}
\bibliography{bibtex}

\end{document}
