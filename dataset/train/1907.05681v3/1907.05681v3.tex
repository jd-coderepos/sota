\documentclass{article}
\usepackage{iclr2020_conference,times}



\PassOptionsToPackage{numbers, compress}{natbib}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{arg\,max}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{makecell}





\title{Adversarial Lipschitz Regularization}



\author{D\'avid Terj\'ek \\
  Robert Bosch Kft. \\
  Budapest, Hungary \\
  \texttt{david.terjek@hu.bosch.com} \\
}


\iclrfinalcopy
\begin{document}

\maketitle

\begin{abstract}
Generative adversarial networks (GANs) are one of the most popular approaches when it comes to training generative models, among which variants of Wasserstein GANs are considered superior to the standard GAN formulation in terms of learning stability and sample quality. However, Wasserstein GANs require the critic to be 1-Lipschitz, which is often enforced implicitly by penalizing the norm of its gradient, or by globally restricting its Lipschitz constant via weight normalization techniques. Training with a regularization term penalizing the violation of the Lipschitz constraint explicitly, instead of through the norm of the gradient, was found to be practically infeasible in most situations. Inspired by Virtual Adversarial Training, we propose a method called Adversarial Lipschitz Regularization, and show that using an explicit Lipschitz penalty is indeed viable and leads to competitive performance when applied to Wasserstein GANs, highlighting an important connection between Lipschitz regularization and adversarial training.
\end{abstract}

\section{Introduction}
\label{intro}
In recent years, Generative adversarial networks (GANs) \citep{Goodfellowetal2014a} have been becoming the state-of-the-art in several generative modeling tasks, ranging from image generation \citep{Karrasetal2017} to imitation learning \citep{Hoetal2016}. They are based on an idea of a two-player game, in which a discriminator tries to distinguish between real and generated data samples, while a generator tries to fool the discriminator, learning to produce realistic samples on the long run. Wasserstein GAN (WGAN) was proposed as a solution to the issues present in the original GAN formulation. Replacing the discriminator, WGAN trains a critic to approximate the Wasserstein distance between the real and generated distributions. This introduced a new challenge, since Wasserstein distance estimation requires the function space of the critic to only consist of 1-Lipschitz functions.

To enforce the Lipschitz constraint on the WGAN critic, \citet{Arjovskyetal2017} originally used weight clipping, which was soon replaced by the much more effective method of Gradient Penalty (GP) \citep{Gulrajanietal2017}, which consists of penalizing the deviation of the critic's gradient norm from 1 at certain input points. Since then, several variants of gradient norm penalization have been introduced \citep{Petzkaetal2018, Weietal2018, Adleretal2018, Zhouetal2019a}.

Virtual Adversarial Training (VAT) \citep{Miyatoetal2017} is a semi-supervised learning method for improving robustness against local perturbations of the input. Using an iterative method based on power iteration, it approximates the adversarial direction corresponding to certain input points. Perturbing an input towards its adversarial direction changes the network's output the most.

Inspired by VAT, we propose a method called Adversarial Lipschitz Regularization (ALR), enabling the training of neural networks with regularization terms penalizing the violation of the Lipschitz constraint explicitly, instead of through the norm of the gradient. It provides means to generate a pair for each input point, for which the Lipschitz constraint is likely to be violated with high probability. In general, enforcing Lipschitz continuity of complex models can be useful for a lot of applications. In this work, we focus on applying ALR to Wasserstein GANs, as regularizing or constraining Lipschitz continuity has proven to have a high impact on training stability and reducing mode collapse. Source code to reproduce the presented experiments is available at \href{https://github.com/dterjek/adversarial_lipschitz_regularization}{https://github.com/dterjek/adversarial\_lipschitz\_regularization}.

Our contributions are as follows:

\begin{itemize}
\item We propose Adversarial Lipschitz Regularization (ALR) and apply it to penalize the violation of the Lipschitz constraint directly, resulting in Adversarial Lipschitz Penalty (ALP).
\item Applying ALP on the critic in WGAN (WGAN-ALP), we show state-of-the-art performance in terms of Inception Score and Fr\'echet Inception Distance among non-progressive growing methods trained on CIFAR-10, and competitive performance in the high-dimensional setting when applied to the critic in Progressive Growing GAN trained on CelebA-HQ.
\end{itemize}

\section{Background}
\label{background}
\subsection{Wasserstein Generative Adversarial Networks}
Generative adversarial networks (GANs) provide generative modeling by a generator network  that transforms samples of a low-dimensional latent space  into samples from the data space , transporting mass from a fixed noise distribution  to the generated distribution . The generator is trained simultaneously with another network  called the discriminator, which is trained to distinguish between fake samples drawn from  and real samples drawn from the real distribution , which is often represented by a fixed dataset. This network provides the learning signal to the generator, which is trained to generate samples that the discriminator considers real. This iterative process implements the minimax game

played by the networks  and . This training procedure minimizes the approximate Jensen-Shannon divergence (JSD) between  and  \citep{Goodfellowetal2014a}. However, during training these two distributions might differ strongly or even have non-overlapping supports, which might result in gradients received by the generator that are unstable or zero \citep{Arjovskyetal2017b}.

Wasserstein GAN (WGAN) \citep{Arjovskyetal2017} was proposed as a solution to this instability. Originating from Optimal Transport theory \citep{Villani2008}, the Wasserstein metric provides a distance between probability distributions with much better theoretical and practical properties than the JSD. It provides a smooth optimizable distance even if the two distributions have non-overlapping supports, which is not the case for JSD. It raises a metric  from the space  of the supports of the probability distributions  and  to the space of the probability distributions itself. For these purposes, the Wasserstein- distance requires the probability distributions to be defined on a metric space and is defined as

where  is the set of distributions on the product space  whose marginals are  and , respectively. The optimal  achieving the infimum in \eqref{wasspdist} is called the optimal coupling of  and , and is denoted by . The case of  has an equivalent formulation

called the Kantorovich-Rubinstein formula \citep{Villani2008}, where  is called the potential function,  is the set of all functions that are 1-Lipschitz with respect to the ground metric , and the Wasserstein-1 distance corresponds to the supremum over all 1-Lipschitz potential functions. The smallest Lipschitz constant for a real-valued function  with the metric space  as its domain is given by

Based on \eqref{kantrub}, the critic in WGAN \citep{Arjovskyetal2017} implements an approximation of the Wasserstein-1 distance between  and . The minimax game played by the critic  and the generator  becomes

a formulation that proved to be superior to the standard GAN in practice, with substantially more stable training behaviour and improved sample quality \citep{Arjovskyetal2017}, although recent GAN variants do not always use this objective \citep{Brocketal2018}. With WGAN, the challenge became effectively restricting the smallest Lipschitz constant of the critic , sparking the birth of a plethora of Lipschitz regularization techniques for neural networks.

\subsection{Lipschitz Function Approximation}
A general definition of the smallest Lipschitz constant of a function  is

where the metric spaces  and  are the domain and codomain of the function , respectively. The function  is called Lipschitz continuous if there exists a real constant  for which  for any . Then, the function  is also called K-Lipschitz. Theoretical properties of neural networks with low Lipschitz constants were explored in \citet{Obermanetal2018}, \citet{Bartlett98} and \citet{Druckeretal92}, showing that it induces better generalization.

Learning mappings with Lipschitz constraints became prevalent in the field of deep learning with the introduction of WGAN \citep{Arjovskyetal2017}. Enforcing the Lipschitz property on the critic was first done by clipping the weights of the network. This approach achieved superior results compared to the standard GAN formulation, but still sometimes yielded poor quality samples or even failed to converge. While clipping the weights enforces a global Lipschitz constant, it also reduces the function space, which might not include the optimal critic any more. Soon this method has been replaced by a softened one called Gradient Penalty (GP) \citep{Gulrajanietal2017}. Motivated by the fact that the optimal critic should have unit gradient norm on lines connecting the coupled points  according to \eqref{wasspdist}, they proposed a regularizer that enforces unit gradient norm along these lines, which not only enforces the Lipschitz constraint, but other properties of the optimal solution as well. However,  is not known in practice, which is why \citet{Gulrajanietal2017} proposed to apply GP on samples of the induced distribution , by interpolating samples from the marginals  and . The critic in the WGAN-GP formulation is regularized with the loss

where  denotes the distribution of samples obtained by interpolating pairs of samples drawn from  and , and  is a hyperparameter acting as a Lagrange multiplier.

Theoretical arguments against GP were pointed out by \citet{Petzkaetal2018} and \citet{Gemicietal2018}, arguing that unit gradient norm on samples of the distribution  is not valid, as the pairs of samples being interpolated are generally not from the optimal coupling , and thus do not necessarily need to match gradient norm 1. Furthermore, they point out that differentiability assumptions of the optimal critic are not met. Therefore, the regularizing effect of GP might be too strong. As a solution, \citet{Petzkaetal2018} suggested using a loss penalizing the violation of the Lipschitz constraint either explicitly with

or implicitly with

where in both cases  denotes . The first method has only proved viable when used on toy datasets, and led to considerably worse results on relatively more complex datasets like CIFAR-10, which is why \citet{Petzkaetal2018} used the second one, which they termed Lipschitz Penalty (LP). Compared to GP, this term only penalizes the gradient norm when it exceeds . As  they evaluated the interpolation method described above, and also sampling random local perturbations of real and generated samples, but found no significant improvement compared to . \citet{Weietal2018} proposed dropout in the critic as a way for creating perturbed input pairs to evaluate the explicit Lipschitz penalty \eqref{explicit}, which led to improvements, but still relied on using GP simultaneously.

A second family of Lipschitz regularization methods is based on weight normalization, restricting the Lipschitz constant of a network globally instead of only at points of the input space. One such technique is called spectral normalization (SN) proposed in \citet{Miyatoetal2018}, which is a very efficient and simple method for enforcing a Lipschitz constraint with respect to the -norm on a per-layer basis, applicable to neural networks consisting of affine layers and K-Lipschitz activation functions. \citet{Gouketal2018} proposed a similar approach, which can be used to enforce a Lipschitz constraint with respect to the -norm and -norm in addition to the -norm, while also being compatible with batch normalization and dropout. \citet{Aniletal2018} argued that any Lipschitz-constrained neural network must preserve the norm of the gradient during backpropagation, and to this end proposed another weight normalization technique (showing that it compares favorably to SN, which is not gradient norm preserving), and an activation function based on sorting.

\subsection{Virtual Adversarial Training}
VAT \citep{Miyatoetal2017} is a semi-supervised learning method that is able to regularize networks to be robust to local adversarial perturbation. Virtual adversarial perturbation means perturbing input sample points in such a way that the change in the output of the network induced by the perturbation is maximal in terms of a distance between distributions. This defines a direction for each sample point called the virtual adversarial direction, in which the perturbation is performed. It is called virtual to make the distinction with the adversarial direction introduced in \citet{Goodfellowetal2014b} clear, as VAT uses unlabeled data with virtual labels, assigned to the sample points by the network being trained. The regularization term of VAT is called Local Distributional Smoothness (LDS). It is defined as

where  is a conditional distribution implemented by a neural network,  is a divergence between two distributions  and , for which \citet{Miyatoetal2017} chose the Kullback-Leibler divergence (KLD), and

is the virtual adversarial perturbation, where  is a hyperparameter. VAT is defined as a training method with the regularizer \eqref{vat} applied to labeled and unlabeled examples. An important detail is that \eqref{vat} is minimized by keeping  fixed and optimizing  to be close to it.

The adversarial perturbation is approximated by the power iteration , where

 is a randomly sampled unit vector and  is another hyperparameter. This iterative scheme is an approximation of the direction at  that induces the greatest change in the output of  in terms of the divergence . \cite{Miyatoetal2017} found that  iteration is sufficient in practical situations.

\section{Adversarial Lipschitz Regularization}
\label{alr}
\citet{Adleretal2018} argued that penalizing the norm of the gradient as in \eqref{implicit} is more effective than penalizing the Lipschitz quotient directly as in \eqref{explicit}, as the former penalizes the slope of  in all spatial directions around , unlike the latter, which does so only along .  We hypothesize that using the explicit Lipschitz penalty in itself is insufficient because if one takes pairs of samples  randomly from ,  or  (or just one sample and generates a pair for it with random perturbation), the violation of the Lipschitz penalty evaluated at these sample pairs will be far from its maximum, hence a more sophisticated strategy for sampling pairs is required. As we will show, a carefully chosen sampling strategy can in fact make the explicit penalty favorable over the implicit one.

Consider the network  as a mapping from the metric space  to the metric space . Let us rewrite \eqref{lip_const} with  to get

A given mapping  is K-Lipschitz if and only if for any given , taking the supremum over  in \eqref{lip_const_r} results in a value  or smaller. Assuming that this supremum is always achieved for some , we can define a notion of adversarial perturbation with respect to the Lipschitz continuity for a given  as

and the corresponding maximal violation of the K-Lipschitz constraint as


We define Adversarial Lipschitz Regularization (ALR) as the method of adding \eqref{alp} as a regularization term to the training objective that penalizes the violation of the Lipschitz constraint evaluated at sample pairs obtained by adversarial perturbation. We call this term Adversarial Lipschitz Penalty (ALP).

To put it in words, ALP measures the deviation of  from being K-Lipschitz evaluated at pairs of sample points where one is the adversarial perturbation of the other. If added to the training objective, it makes the learned mapping approximately K-Lipschitz around the sample points it is applied at. We found that in the case of the WGAN critic it is best to minimize \eqref{alp} without keeping  fixed. See Appendix~\ref{semisup} for the semi-supervised case and Appendix~\ref{vat_as_lr} for how VAT can be seen as a special case of Lipschitz regularization.

\subsection{Approximation of }
In general, computing the adversarial perturbation \eqref{alp_radv} is a nonlinear optimization problem. A crude and cheap approximation is , where

is the approximated adversarial direction with  being a randomly sampled unit vector. The derivation of this formula is essentially the same as the one described in \citet{Miyatoetal2017}, but is included in Appendix~\ref{r_adv_derivation} for completeness. Unlike in VAT, we do not fix , but draw it randomly from a predefined distribution  over  to apply the penalty at different scales.

Theoretically, ALR can be used with all kinds of metrics  and , and any kind of model , but the approximation of  imposes a practical restriction. It approximates the adversarial perturbation of  as a translation with length  with respect to the -norm in the adversarial direction, which is only a perfect approximation if the ratio in \eqref{alp} is constant for any . This idealized setting is hardly ever the case, which is why we see the search for other approximation schemes as an important future direction. There is a large number of methods for generating adversarial examples besides the one proposed in VAT \citep{Shafahietal2019, Wongetal2019, Khrulkovetal2018}, which could possibly be combined with ALR either to improve the approximation performance or to make it possible with new kinds of metrics. The latter is important since one of the strengths of the Wasserstein distance is that it can be defined with any metric , a fact that \citet{Adleretal2018} and \citet{Dukleretal2019} built on by extending GP to work with metrics other than the Euclidean distance. \citet{Adleretal2018} emphasized the fact that through explicit Lipschitz penalties one could extend WGANs to more general metric spaces as well.

\subsection{Hyperparmeters}
In practice, one adds the Monte Carlo approximation of the expectation (averaged over a minibatch of samples) of either \eqref{alp} or the square of \eqref{alp} (or both) to the training objective, multiplied by a Lagrange multiplier . While VAT adds the expectation of \eqref{vat} to the training objective, for WGAN we have added the square of the expectation of \eqref{alp}. To train the Progressive GAN, we have added both the expectation and its square. In the semi-supervised setting, we added only the expectation similarly to VAT. We have found these choices to work best in these scenarios, but a principled answer to this question is beyond the scope of this paper. The target Lipschitz constant  can be tuned by hand, or in the presence of labeled data it is possible to calculate the Lipschitz constant of the dataset \citep{Obermanetal2018}. The hyperparameters of the approximation scheme are ,  and those of .

Choosing the right hyperparameters can be done by monitoring the number of adversarial perturbations found by the algorithm for which the Lipschitz constraint is violated (and hence contribute a nonzero value to the expectation of \eqref{alp}), and tuning the hyperparameters in order to keep this number balanced between its maximum (which is the minibatch size) and its minimum (which is 0). If it is too high, it means that either  is too small and should be increased, or the regularization effect is too weak, so one should increase . If it is too low, then either the regularization effect is too strong, or ALR is parametrized in a way that it cannot find Lipschitz constraint violations efficiently. In the former case, one should decrease . In the latter, one should either decrease , tune the parameters of , or increase the number of power iterations  for the price of increased runtime. We have not observed any significant effect when changing the value of  in any of the tasks considered.

\subsection{Comparison with other Lipschitz regularization techniques}
In terms of efficiency when applied to WGANs, ALR compares favorably to the implicit methods penalizing the gradient norm, and to weight normalization techniques as well, as demonstrated in the experiments section. See Appendix~\ref{toy_example} for a showcase of the differences between weight normalization methods, implicit penalty methods and explicit penalty methods, represented by SN, LP and ALR, respectively. The key takeaways are that 
\begin{itemize}
\item penalty methods result in a softer regularization effect than SN, 
\item ALR is preferable when the regularized network contains batch normalization (BN) layers, and 
\item ALR gives more control over the regularization effect, which also means there are more hyperparameters to tune.
\end{itemize}

The performance of ALR mostly depends on the speed of the approximation of . The current method requires 1 step of backpropagation for each power iteration step, which means that running time will be similar to that of LP and GP with . SN is much cheaper computationally than each penalty method, although we believe ALR has the potential to become relatively cheap as well by adopting new techniques for obtaining adversarial examples \citep{Shafahietal2019}.

\section{WGAN-ALP}
We specialize the ALP formula \eqref{alp} with  being the critic, ,  and , and apply it to the WGAN objective to arrive at a version with the explicit penalty, which uses adversarial perturbations as a sampling strategy. It is formulated as

where  is a combination of the real and generated distributions (meaning that a sample  can come from both),  is the Lagrange multiplier, and the adversarial perturbation is defined as

This formulation of WGAN results in a stable explicit Lipschitz penalty, overcoming the difficulties experienced when one tries to apply it to random sample pairs as shown in \citet{Petzkaetal2018}.

To evaluate the performance of WGAN-ALP, we trained one on CIFAR-10, consisting of  RGB images, using the residual architecture from \citet{Gulrajanietal2017}, implemented in TensorFlow. Closely following \citet{Gulrajanietal2017}, we used the Adam optimizer \citep{Kingmaetal2014} with parameters ,  and an initial learning rate of  decaying linearly to 0 over  iterations, training the critic for  steps and the generator for  per iteration with minibatches of size  (doubled for the generator). We used \eqref{wgan_alp_loss} as a loss function to optimize the critic.  was an obvious choice, and we found  to be optimal (the training diverged for , and was stable but performed worse for  and ). The hyperparameters of the approximation of  were set to ,  being the uniform distribution over , and  power iteration. Both batches from  and  were used for regularization.

We used Inception Score \citep{Salimansetal2016} and FID \citep{Heuseletal2017} as our evaluation metrics. The former correlates well with human judgment of image quality and is the most widely used among GAN models, and the latter has been shown to capture model issues such as mode collapse, mode dropping and overfitting, while being a robust and efficient metric \citep{Xuetal2018}. We monitored the Inception Score and FID during training using  samples every  iteration, and evaluated them at the end of training using  samples. We ran the training setting described above  times with different random seeds, and calculated the mean and standard deviation of the final Inception Scores and FIDs, while also recording the maximal Inception Score observed during training. We report these values for WGAN-ALP and other relevant GANs \citep{Gulrajanietal2017, Petzkaetal2018, Zhouetal2019b, Weietal2018, Miyatoetal2018, Adleretal2018, Karrasetal2017} in Table~\ref{inception_scores}. We did not run experiments to evaluate competing models, but included the values reported in the corresponding papers (with the exception of the FID for WGAN-GP, which was taken from \citet{Zhouetal2019b}). They used different methods to arrive at the cited results, from which that of \citet{Adleretal2018} is the one closest to ours. We show some generated samples in Figure~\ref{cifar_samples_nobn}.

\begin{table}[h]
  \caption{Inception Scores and FIDs on CIFAR-10}
  \label{inception_scores}
  \centering
  \begin{tabular}{lccc}
    \toprule
    &\multicolumn{2}{c}{Inception Score}&\\
    \cmidrule(r){2-3}
    Method & Average & Best & FID\\
    \midrule
    WGAN-GP             &  &        &  \\
    WGAN-LP             &  &        &                 \\
    LGAN                &  &        &  \\
    CT-GAN              &  &        &                 \\
    SN-GAN              &  &        &  \\
    BWGAN               &  &        &          \\
    Progressive GAN     &  &  &                 \\
    \textbf{WGAN-ALP (ours)} &  &  &   \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{figure}[h]
\begin{subfigure}{\linewidth}
  \centering
  \begin{subfigure}{.495\linewidth}
  \includegraphics[width=\linewidth]{imgs/cifar_nobn.png}
  \caption{No BN in critic}
  \label{cifar_samples_nobn}
  \end{subfigure}\hfill
  \begin{subfigure}{.495\linewidth}
  \includegraphics[width=\linewidth]{imgs/cifar_bn.png}
  \caption{BN in critic}
  \label{cifar_samples_bn}
  \end{subfigure}
\end{subfigure}
  \caption{Generated CIFAR-10 samples}
  \label{cifar_samples}
\end{figure}

We also trained WGAN-LP in our implementation. During training, the best observed Inception Score and FID were 8.13 and 18.49, while at the end of training the best final Inception Score and FID were 8.01 and 15.42. To see that ALR indeed restricts the Lipschitz constant of the critic, we monitored the gradient norms during training, which converged to  with . This was also the case using LP with , but the number of Lipschitz constraint violations found by the algorithm were much higher in this case than with ALR.

Our toy example in Appendix~\ref{toy_example} showed that when the regularized network contains BN layers, ALR seems to work better than competing methods. In order to see if this still applies in more complex settings, we have trained a variant of WGAN in which the critic contains BN layers (WGAN-BN). \citet{Gulrajanietal2017} did not use BN in the critic as they argued that GP is not valid in that setting, and indeed when we trained WGAN-BN with GP, the best Inception Score observed during training was only . When we applied ALP to WGAN-BN, the results were nearly on par with the original setting without BN, producing an even better maximal Inception Score of . We leave the question of how BN affects Lipschitz continuity for future work. Generated samples are shown in Figure~\ref{cifar_samples_bn}.

\citet{Gulrajanietal2017} made the distinction between one-sided and two-sided penalties, represented by \eqref{implicit} and \eqref{twosided}. The latter is based on the fact that in WGAN, the optimal critic has unit gradient norm on lines connecting points from the optimal coupling . \citet{Petzkaetal2018} showed that since  is not known in practice, one should use the one-sided penalty, while \citet{Gemicietal2018} proposed a method to approximate  with an auto-encoding scheme. In the limit  the expression inside  the  operator in \eqref{wgan_alp_radv} is equivalent to the directional derivative of  along , and the vector  corresponding to the maximum value of the directional derivative at  is equivalent to . Since the critic  corresponds to the potential function in the dual formulation of the optimal transport problem, at optimality its gradient at  points towards its coupling , where . From this perspective, sampling pairs  using \eqref{wgan_alp_radv} can be seen as an approximation of the optimal coupling . To test how reasonable this approximation is, we have trained a WGAN variant with the two-sided explicit penalty formulated as

which performed similarly to the one-sided case with , but was less stable for other values of . The findings of \citet{Petzkaetal2018} were similar for the case of the implicit penalty. Improving the approximation scheme of  might render the formulation using the two-sided penalty \eqref{wgan_alp_loss_twosided} preferable in the future.

To show that ALR works in a high-dimensional setting as well, we trained a Progressive GAN on the CelebA-HQ dataset \citep{Karrasetal2017}, consisting of  RGB images. We took the official TensorFlow implementation and replaced the loss function of the critic, which originally used GP, with a version of ALP. Using \eqref{wgan_alp_loss} as the training objective was stable until the last stage of progressive growing, but to make it work on the highest resolution, we had to replace it with

meaning that we used the sum of the absolute and squared values of the Lipschitz constraint violation as the penalty. The optimal hyperparameters were ,  being the uniform distribution over ,  and  step of power iteration. The best FID seen during training with the original GP version was , while for the modified ALP version it was . The example shows that while ALP did not beat GP in this case (possibly because the implementation was fine-tuned using GP), it does work in the high-dimensional setting as well. For samples generated by the best performing ALR and GP variants see Appendix~\ref{proggan}.

\section{Conclusions}
\label{conclusions}
Inspired by VAT, we proposed ALR and shown that it is an efficient and powerful method for learning Lipschitz constrained mappings implemented by neural networks. Resulting in competitive performance when applied to the training of WGANs, ALR is a generally applicable regularization method. It draws an important parallel between Lipschitz regularization and adversarial training, which we believe can prove to be a fruitful line of future research.

\newpage


\section*{Acknowledgements}
The author would like to thank Michael Herman from Bosch Center for Artificial Intelligence (BCAI) for the fruitful discussions, and the Advanced Engineering team in Budapest, especially G\'eza Velkey.




\bibliography{valp}
\bibliographystyle{abbrvnat}

\newpage

\appendix
\section{Appendix}

\subsection{Semi-supervised learning} \label{semisup}
Since VAT is a semi-supervised learning method, it is important to see how ALR fares in that regime. To show this, we have replicated one of the experiments from \citet{Miyatoetal2017}. We trained the ConvLarge architecture to classify images from CIFAR-10 with the same setting as described in  \citet{Miyatoetal2017}, except that we did not decay the learning rate, but kept it fixed at . We split the  training examples into  samples for the classification loss,  samples for regularization and  for validation, with equally distributed classes. Test performance was evaluated on the  test examples. We have found that unlike in the unsupervised setting, here it was important to assume  fixed when minimizing the regularization loss, and also to complement the smoothing effect with entropy minimization \citep{Grandvaletetal2005}. The baseline VAT method was ALR specialized with ,  being the Euclidean metric,  being the KL divergence, fixed  and . This setting achieved maximal validation performance of  and test performance . After some experimentation, the best performing choice was ,  being the  metric,  the mean squared difference over the logit space (which parametrize the categorical output distribution over which the KL divergence is computed in the case of VAT),  being the uniform distribution over  and . This way the maximal validation performance was  and test performance . Although this  is improvement is not very significant, it shows that ALR can be a competitive choice as a semi-supervised learning method as well.

\subsection{Virtual Adversarial Training as Lipschitz regularization} \label{vat_as_lr}
VAT was defined by considering neural networks implementing conditional distributions , where the distribution over discrete labels  was conditioned on the input image  \cite{Miyatoetal2017}. To see why LDS \eqref{vat}, the regularization term of VAT, can be seen as special kind of Lipschitz continuity, we will use a different perspective. Consider a mapping  with domain  and codomain , where  is the space of images and  is the probability simplex (the space of distributions over the finite set of labels).

Since a divergence is in general a premetric (prametric, quasi-distance) on the space of probability measures \citep{Deza2009}, and Lipschitz continuity is defined for mappings between metric spaces, let us restrict the divergence  from the VAT formulation to be a metric . \citet{Miyatoetal2017} used KLD in their experiments, which is not a metric, but one can use e.g. the square root of JSD or the Hellinger distance, which are metrics. Let us metrize the space of images  with  being the Euclidean metric. From this perspective, the network  is a mapping from the metric space  to the metric space . Let us also assume that we aim to learn a mapping  with the smallest possible  by setting  to .

To enforce the condition  in \eqref{alp_radv}, we bound the Euclidean norm of  from above by some predefined . If we make the additional assumption that the supremum is always achieved with an  of maximal norm , the denominator in \eqref{alp_radv} will be constant, hence the formulas with and without it will be equivalent up to a scaling factor. With these simplifications, \eqref{alp_radv} and \eqref{alp} reduce to 

and

which are equivalent to \eqref{vat_radv} and \eqref{vat}, respectively. Let us consider the question of keeping  fixed when minimizing \eqref{alp_vat} an implementation detail. With this discrepancy aside, we have recovered VAT as a special case of Lipschitz regularization.

\subsection{Derivation of the approximation of } \label{r_adv_derivation}
We assume that  and  are both twice differentiable with respect to their arguments almost everywhere, the latter specifically at . Note that one can easily find a  for which the last assumption does not hold, for example the  distance. If  is translation invariant, meaning that  for each , then its subderivatives at  will be independent of , hence the method described below will still work. Otherwise, one can resort to using a proxy metric in place of  for the approximation, for example the  distance.

We denote  by  for simplicity. Because  and , it is easy to see that

so that the second-order Taylor approximation of  is , where  is the Hessian matrix. The eigenvector  of  corresponding to its eigenvalue with the greatest absolute value is the direction of greatest curvature, which is approximately the adversarial direction that we are looking for. The power iteration \citep{Householder1964} defined by

where  is a randomly sampled unit vector, converges to  if  and  are not perpendicular. Calculating  is computationally heavy, which is why  is approximated using the finite differences method as

where the equality follows from \eqref{derzero}. The hyperparameter  is introduced here. In summary, the adversarial direction is approximated by the iterative scheme

of which one iteration is found to be sufficient and necessary in practice.

\subsection{Toy example} \label{toy_example}
To showcase the differences between weight normalization methods, implicit penalty methods and explicit penalty methods, represented by SN, LP and ALR, respectively, we devised the following toy example. Suppose that we want to approximate the following real-valued mapping on the 2-dimensional interval :

for . In addition, we want the approximation to be 1-Lipschitz. It is easy to see that the optimal approximation with respect to the mean squared error is


This example has connections to WGAN, as the optimal critic is 1-Lipschitz, and its approximation will provide the learning signal to the generator in the form of gradients. Therefore, it is important to closely approximate the gradient of the optimal critic, which is achieved indirectly by Lipschitz regularization. In this example, we will see how closely the different Lipschitz regularization methods can match the gradient of the optimal approximation . 

We implemented the example in PyTorch. For the approximation , we use an MLP with 3 hidden layers containing 20, 40 and 20 neurons, respectively, with ReLU activations after the hidden layers, and a variant which also has batch normalization (BN) before the activations, since it has been found that BN hurts adversarial robustness \citep{Gallowayetal2019}, and hence it should also hurt Lipschitz continuity. We trained the networks for  iterations, with batches consisting of an input, a corresponding output, and an additional input for regularization. The inputs are drawn uniformly at random from  and the output is defined by \eqref{target}. The minibatch size was  for input-output pairs, and  for regularization inputs. We used heatmaps to visualize the gradient norm surfaces of the optimal and learned mappings, with the color gradient going from black at  to white at , see Figure~\ref{toy_mappings}. This example is not intended to rank the competing Lipschitz regularization methods, as it always depends on the particular application which one is the best suited, but to show that they are fundamentally different and competent in their own way.

\begin{figure}[h]

\begin{subfigure}{\linewidth}
\begin{subfigure}{.16\linewidth}
  \centering
  \includegraphics[width=1.\linewidth]{imgs/colormap}
  \caption{colormap}
\end{subfigure}
\begin{subfigure}{.16\linewidth}
  \centering
  \includegraphics[width=1.\linewidth]{imgs/opt_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/noreg_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/noreg_gradient}
  \caption{ (no regularization)}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/sn_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/sn_gradient}
  \caption{}
\end{subfigure}
\end{subfigure}\par

\begin{subfigure}{\linewidth}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/lp_l01_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/lp_l01_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/lp_l1_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/lp_l1_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/lp_l10_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/lp_l10_gradient}
  \caption{}
\end{subfigure}
\end{subfigure}\par

\begin{subfigure}{\linewidth}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l01_ip0_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l01_ip0_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l1_ip0_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l1_ip0_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l10_ip0_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l10_ip0_gradient}
  \caption{}
\end{subfigure}
\end{subfigure}\par

\begin{subfigure}{\linewidth}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l01_ip1_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l01_ip1_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l1_ip1_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l1_ip1_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l10_ip1_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l10_ip1_gradient}
  \caption{}
\end{subfigure}
\end{subfigure}\par

\begin{subfigure}{\linewidth}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l01_ip5_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l01_ip5_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l1_ip5_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l1_ip5_gradient}
  \caption{}
\end{subfigure}
\begin{subfigure}{.33\linewidth}
  \includegraphics[width=.5\linewidth]{imgs/2D/alp_l10_ip5_gradient}\hfill
  \includegraphics[width=.5\linewidth]{imgs/2D_bn/alp_l10_ip5_gradient}
  \caption{}
\end{subfigure}
\end{subfigure}\par

\caption{Gradient norm surfaces of optimal and learned approximations of }
\label{toy_mappings}
\end{figure}

Without any kind of regularization, the network learned to approximate the target function very well, but its gradients look nothing like that of , although somehow it is a better match with BN.

When we apply SN to the MLP layers, the result without BN will be a very smooth mapping with maximum gradient norm far below . SN is not compatible with BN, the result being only slightly better than the unregularized case. A detail not visible here is that because SN considers weight matrices as linear maps from  to  and normalizes them layer-wise, it regularizes globally instead of around actual data samples. In this case, on the whole of  instead of just . For WGANs trained on CIFAR-10, the input space consists of  RGB images with pixel values in , but the trained mapping is regularized on  instead of just  (which contains the supports of the real and fake distributions). This can hurt performance if the optimal mapping implemented by a particular network architecture is K-Lipschitz inside these supports, but not in some other parts of .

When the network is regularized using LP \eqref{implicit}, the regularization strength can be controlled by tuning the value of . We trained with  and . Without BN, the highest of these values seems to work the best. With BN, the resulting mapping is visibly highly irregular.

With ALR, in addition to , we have additional control over the regularization by the hyperparameters of the approximation scheme of . After some experimentation, we have found the best  for this case was the uniform distribution over . We trained with  and , and  and  power iterations. Arguably, both with and without BN the  and  case seems like the best choice. Without BN, the results are quite similar to the LP case, but when BN is introduced, the resulting mappings are much smoother than the ones obtained with LP.

\newpage

\subsection{Images generated by Progressive GAN trained on CelebA-HQ} \label{proggan}
\begin{figure}[h]
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000000.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000001.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000002.png}
  \end{subfigure}\par
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000003.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000004.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000005.png}
  \end{subfigure}\par
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000006.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000007.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000008.png}
  \end{subfigure}
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000009.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000010.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_alp/055-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-012400-000011.png}
  \end{subfigure}
  \caption{Images generated using Progressive GAN trained with ALR}
  \label{proggan_alp}
\end{figure}

\begin{figure}[h]
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000000.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000001.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000002.png}
  \end{subfigure}\par
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000003.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000004.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000005.png}
  \end{subfigure}\par
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000006.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000007.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000008.png}
  \end{subfigure}
  \begin{subfigure}{\linewidth}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000009.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000010.png}
  \includegraphics[width=.33\linewidth]{imgs/proggan/gen_gp/000-pgan-celebahq-preset-v2-1gpu-fp32-network-snapshot-011100-000011.png}
  \end{subfigure}
  \caption{Images generated using Progressive GAN trained with GP}
  \label{proggan_gp}
\end{figure}

\end{document}
