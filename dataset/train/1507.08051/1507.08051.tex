\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{LFMTP 2015} 
\newcommand{\hideshow}[1]{{\mbox{}}}




\newcommand{\dotminus}{\mathbin{\scriptstyle\dot{\smash{\textstyle-}}}}


\usepackage{multicol}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{latexsym}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}

\usepackage{esvect}
\usepackage{alltt}
\usepackage{bussproofs}
\usepackage[all]{xy}
\usepackage{tabularx}


\usepackage{multicol}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\newcommand{\code}[4]{\ensuremath{{\epsilon^{#1,#2}_{#3,#4}}}}
\newcommand{\decode}[2]{\ensuremath{{\delta^{#1}_{#2}}}}
\newcommand{\pred}[5]{\ensuremath{{(\mathcal{P}^{#1}_{#2}\ {#3}\  I_{\overline{#4}}\ \overline{#5})}}}
\newcommand{\termP}[5]{\ensuremath{{(c_{\mathcal{P}^{#1}_{#2}}\ {#3}\ I_{\overline{#4}}\ \overline{#5})}}}
\newcommand{\ED}{\ensuremath{\epsilon^{\mathcal D}}}
\newcommand{\EJ}{\ensuremath{\epsilon^{\mathcal J}}}
\newcommand{\EC}[1]{\ensuremath{\epsilon^{\mathcal C}_{#1}}}
\newcommand{\ES}{\ensuremath{\epsilon^{\mathcal S}}}
\newcommand{\E}[2]{\ensuremath{{\epsilon}}}
\newcommand{\ET}[2]{\ensuremath{{\theta^{#1}_{#2}}}}
\newcommand{\D}{\ensuremath{{\delta}}}
\newcommand{\M}[0]{\textsf{Merge}}


\newcommand{\LF}  {\mbox{}}
\newcommand{\GLF}  {\mbox{}}
\newcommand{\CLF}  {\mbox{}}
\newcommand{\LLF}  {\mbox{}}
\newcommand{\PLF}  {\mbox{}}


\newcommand{\LFP}   {\mbox{}}
\newcommand{\LFM}   {\mbox{}}
\newcommand{\LLFP}  {\mbox{}}
\newcommand{\CLFP}  {\mbox{}}
\newcommand{\CLLFP} {\mbox{}}
\newcommand{\CLLFPQ} {\mbox{}}
\newcommand{\FPST}   {\mbox{}}



\newcommand {\adhoc}     {{\textit{ad hoc}}}
\newcommand {\afortiori} {{\textit{a fortiori}}}
\newcommand {\aka}       {{\textrm{a}.\textrm{k}.\textrm{a}.}}
\newcommand {\ala}       {{\textit{\`a la}}}
\newcommand {\cf}        {{\textit{cf}.~}}
\newcommand {\eg}        {{\textit{e}.\textit{g}.}}
\newcommand {\Eg}        {{\textit{E}.\textit{g}.}}
\newcommand {\defacto}   {{\textit{de facto}}}
\newcommand {\etalt}     {{\textit{et al.}}}
\newcommand {\etc}       {{\textrm{etc}.}}
\newcommand {\ie}        {{\textit{i}.\textit{e}.}}
\newcommand {\intoto}    {{\textit{in toto}}}
\newcommand {\insitu}    {{\textit{in situ}}}
\newcommand {\perse}     {{\textit{per se}}}
\newcommand {\pletora}   {{\textit{pl\ae tora}}}
\newcommand {\look}       {{\textit{see}~}}
\newcommand {\vs}        {{\textrm{vs.}}}
\newcommand {\wrt}       {{\textrm{w}.\textrm{r}.\textrm{t}.}}

\newcommand {\FURIO}[1]  {\textbf{[Furio:~}  {{\sf #1}}\textbf{]}}
\newcommand {\GIGI}[1]   {\textbf{[Gigi:~}   {{\sf #1}}\textbf{]}}
\newcommand {\IVAN}[1]   {\textbf{[Ivan:~}   {{\sf #1}}\textbf{]}}
\newcommand {\MARINA}[1] {\textbf{[Marina:~} {{\sf #1}}\textbf{]}}
\newcommand {\PETAR}[1]  {\textbf{[Petar:~}  {{\sf #1}}\textbf{]}}
\newcommand {\PROP}[1]   {\textbf{[prop:~}   {{\sf #1}}\textbf{]}}



\newcommand {\at}   {\,}               \newcommand {\of}   {{:}}              \newcommand {\Type} {{\mathsf {type}}} \newcommand {\sig}  {{\mathsf {sig}}}  \newcommand {\ctx}  {{\mathsf {ctx}}}  \newcommand {\kind}  {{\mathsf {kind}}}  



\newcommand {\Dom} {{\mathsf {Dom}}} \newcommand {\FV}  {{\mathsf {Fv}}}  \newcommand {\BV}  {{\mathsf {Bv}}}  


\newcommand {\App}    [2] {{#1} \at {#2}}                         \newcommand {\Prod}   [3] {\Pi {#1} \of {#2}.{#3}}            \newcommand {\Abs}    [3] {\lambda {#1} \of {#2}.{#3}}   

\newcommand {\Lam}    [2] {\lambda {#1}.{#2}}                

\newcommand {\Lock}   [4] {{\mathcal{L}}^{#1}_{#2, #3}[{#4}]} \newcommand {\LockC} [3] {{\mathcal{L}}^{#1}_{#2}      [{#3}]} 

\newcommand {\Locknoarg}  {{\mathcal{L}}}                            \newcommand {\Unlock} [4] {{\mathcal{U}}^{#1}_{#2, #3}[{#4}]} \newcommand {\ELock}  [4] {{\mathcal{L}}^{#1}_{#3}[{#4}]}      \newcommand {\Catch}  [2] {{\langle {\sf #1};#2\rangle}}       



\newcommand {\VDASHP} {\vdash_\preceq} \newcommand {\VDASHPS} {\vdash_{\Sigma,\preceq}}  



\newcommand {\VDASH}  {\vdash}
\newcommand {\VDASHS} {\vdash_\Sigma} \newcommand {\VDASHO} {\vdash_\Omega} \newcommand {\VDASHCBV} {\vdash_{\Sigma_{{CBV}}}} \newcommand {\VDASHSIMP} {\vdash_{\Sigma_{{Imp}}}} \newcommand {\VDASHSHOARE} {\vdash_{\Sigma_{{Hoare}}}} \newcommand {\VDASHSERASE} {\vdash_{\Sigma^\Erase}}    \newcommand {\VDASHEAL} {\vdash_{EAL}} \newcommand {\VDASHSEAL} {\vdash_{\Sigma_{{EAL}}}} \newcommand {\VDASHFP} {\vdash_{\sf FPST}} 



\newcommand {\SIG} {{\mathcal S}}    \newcommand {\CTX} {{\mathcal C}}    \newcommand {\KK}  {{\mathcal K}}    \newcommand {\FF}  {{\mathcal F}}    \newcommand {\OO}  {{\mathcal O}}    


\newcommand {\CF}  {{\mathcal{F}_c}} \newcommand {\AF}  {{\mathcal{F}_a}} 

\newcommand {\CO}  {{\mathcal{O}_c}} \newcommand {\AO}  {{\mathcal{O}_a}} 


\renewcommand {\P} {\mathcal{P}} \newcommand {\Q} {\mathcal{Q}} 

\renewcommand {\L} {\mathcal{L}} \newcommand   {\C} {\mathcal{C}} \newcommand   {\T} {\mathcal{T}} \newcommand   {\U} {\mathcal{U}} 


\newcommand {\eqdef} {\stackrel{\tiny \Delta}{=}}
\newcommand {\eqB}  {{=}_{\!\beta}}            \newcommand {\eqBL} {{=}_{\!\beta\mathcal{L}}} 

\newcommand {\ELNF}  {-lnf}   \newcommand {\Subst} {{\mathcal S}}

\newcommand {\eval}   {\rightarrow}       \newcommand {\evalB}  {\eval_{\!\beta}}   \newcommand {\evalL}  {\eval_{\!\L}}      \newcommand {\evalBL} {\eval_{\!\beta\L}} 

\newcommand {\multieval}[1] {\mathop{\eval\!\!\!\!\!\eval_{#1}}} \newcommand {\multievalB}   {\multieval{\!\beta}}                \newcommand {\multievalBL}  {\multieval{\!\beta\mathcal{L}}}     

\newcommand{\rew}[1]  {\hspace{-#1mm}}
\newcommand{\fwd}[1]  {\hspace{#1mm}}
\newcommand{\up}[1]   {\vspace{-#1mm}}
\newcommand{\down}[1] {\vspace{#1mm}}

\newcommand{\Erase} {{-\U\L}}



\newcommand{\RSE}	{(S{\cdot}Empty)}			\newcommand{\RSF}	{(S{\cdot}C{\cdot}Fam)}	\newcommand{\RSO}	{(S{\cdot}C{\cdot}Obj)}	

\newcommand{\RCE}	{(C{\cdot}Empty)}		\newcommand{\RCV}	{(C{\cdot}Var)}			

\newcommand{\RKT}	{(K{\cdot}Type)}		\newcommand{\RKP}	{(K{\cdot}Prod)}		

\newcommand{\RFC}	{(F{\cdot}Const)}		\newcommand{\RFP}	{(F{\cdot}Prod)}		\newcommand{\RFA}	{(F{\cdot}App)}			\newcommand{\RFL}		{(F{\cdot}Lock)}		\newcommand{\RFE}	{(F{\cdot}Conv)}		

\newcommand{\ROC}	{(O{\cdot}Const)}		\newcommand{\ROV}	{(O{\cdot}Var)}			\newcommand{\ROAb}	{(O{\cdot}Abs)}			\newcommand{\ROAp}	{(O{\cdot}App)}			\newcommand{\ROL}	{(O{\cdot}Lock)}		\newcommand{\ROU}	{(O{\cdot}Unlock)}		\newcommand{\ROE}	{(O{\cdot}Conv)}		

\newcommand{\BOMain}	{(\beta{\cdot}O{\cdot}Main)}	\newcommand{\LOMain}	{(\L{\cdot}O{\cdot}Main)}	\newcommand{\COMain}	{(\C{\cdot}O{\cdot}Main)}	\newcommand{\TOMain}	{(\T{\cdot}O{\cdot}Main)}	

\newcommand{\BLEqMain}  {(\beta\L{\cdot}Eq{\cdot}Main)}
\newcommand{\BLEqRefl}  {(\beta\L{\cdot}Eq{\cdot}Refl)}
\newcommand{\BLEqSym}   {(\beta\L{\cdot}Eq{\cdot}Sym)}
\newcommand{\BLEqTrans} {(\beta\L{\cdot}Eq{\cdot}Trans)}

\newcommand{\CCKPa} {(K{\cdot}\Pi_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCKPb} {(K{\cdot}\Pi_2{\cdot}\beta\mathcal{L})}

\newcommand{\CCFPa} {(F{\cdot}\Pi_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCFPb} {(F{\cdot}\Pi_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCFAa} {(F{\cdot}A_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCFAb} {(F{\cdot}A_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCFLa} {(F{\cdot}\L_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCFLb} {(F{\cdot}\L_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCFLc} {(F{\cdot}\L_3{\cdot}\beta\mathcal{L})}

\newcommand{\CCOAba} {(O{\cdot}\lambda_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCOAbb} {(O{\cdot}\lambda_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCOApa} {(O{\cdot}A_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCOApb} {(O{\cdot}A_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCOLa}  {(O{\cdot}\L_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCOLb}  {(O{\cdot}\L_2{\cdot}\beta\mathcal{L})}
\newcommand{\CCOLc}  {(O{\cdot}\L_3{\cdot}\beta\mathcal{L})}
\newcommand{\CCOUa}  {(O{\cdot}\U_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCOUb}  {(O{\cdot}\U_1{\cdot}\beta\mathcal{L})}
\newcommand{\CCOUc}  {(O{\cdot}\U_1{\cdot}\beta\mathcal{L})}

\newcommand{\LOMainAlt}	{(L{\cdot}O{\cdot}Main{\cdot}Alt)}	\newcommand{\LFMainAlt}	{(L{\cdot}F{\cdot}Main{\cdot}Alt)}	








\def \grL	{\mbox {}}
\def \gra	{\mbox {}}
\def \grl	{\mbox {}}
\def \grw	{\mbox {}}

\def \arrow	{\mbox {}}
 
\def \Larrow	{\mbox {\grl \arrow}}
\def \Lomegau	{\mbox {\grl \underline{\grw}}}
\def \Ltwo	{\mbox {{\sf F}{=}\grl 2}}
\def \LomegaF	{\mbox {{\sf F}{=}\grl \grw}}
\def \Lomega	{\mbox {\grl \grw}}
\def \Fomega	{\mbox {{\sf F}}}
\def \LP	{\mbox {\grl {\it P}{={\sf LF}}}}
\def \LF	{\mbox {{\sf LF}}}
\def \LPomegau	{\mbox {\grl {\it P}\underline{\grw}}}
\def \LPtwo	{\mbox {\grl {\it P}2}}
\def \LPomega	{\mbox {\grl {\it P}\grw}{=}{\sf CC}}
\def \LCC	{\mbox {\grl {\it CC}}}

\newcommand{\LPIO}  {\mbox{}}

\newcommand{\SQRT}{\mathcal{SQRT}} 
\title{Gluing together Proof Environments: \\ Canonical extensions of\\
  LF Type Theories featuring \emph{Locks}\footnote{The work
    presented in this paper was partially supported by the Serbian
    Ministry of Education, Science, and Technological Development,
    projects ON174026 and III44006.}}

\author{Furio Honsell
\institute{Department of Mathematics and Computer Science\\
University of Udine, Italy}
\email{furio.honsell@uniud.it}
\and
Luigi Liquori
\institute{Inria Sophia Antipolis M\'editerran\'ee, France}
\email{luigi.liquori@inria.fr}
\and Petar Maksimovi\'{c}
\institute{Inria Rennes Bretagne Atlantique, France}
\institute{Mathematical Institute of the Serbian Academy\\ of Sciences
  and Arts, Serbia}
\email{petar.maksimovic@inria.fr}
\and Ivan Scagnetto
\institute{Department of Mathematics and Computer Science\\
University of Udine, Italy}
\email{ivan.scagnetto@uniud.it}
}
\def\titlerunning{Gluing together Proof Environments: \CLLFP\ \& \CLLFPQ}
\def\authorrunning{F. Honsell, L. Liquori, P. Maksimovi\'{c}, I. Scagnetto}

\begin{document}

\maketitle

\begin{abstract}
  We present two extensions of the \LF\ Constructive Type Theory
  featuring monadic \emph{locks}. A lock is a monadic type construct
  that captures the effect of an \emph{external call to an
    oracle}. Such calls are the basic tool for \emph{gluing together}
  diverse Type Theories and proof development environments.  The
  oracle can be invoked either to check that a constraint holds or to
  provide a suitable witness. The systems are presented in the
  \emph{canonical style} developed by the CMU School. The first
  system, \CLLFP, is the canonical version of the system \LLFP,
  presented earlier by the authors. The second system, \CLLFPQ,
  features the possibility of invoking the oracle to obtain a witness
  satisfying a given constraint. We discuss encodings of Fitch-Prawitz
  Set theory, call-by-value -calculi, and systems of Light
  Linear Logic. Finally, we show how to use Fitch-Prawitz Set Theory
  to define a type system that types precisely the strongly
  normalizing terms.
\end{abstract}



\section{Introduction}\label{sec:introduction}
In recent years, the authors have introduced in a series of papers
\cite{HLLMS12,Honsell:2013:YFP:2503887.2503896,llfp-mfcs2014,HLMS15}
various extensions of the Constructive Type Theory \LF, with the goal
of defining a simple \emph{Universal Meta-language} that can support
the effect of \emph{gluing together}, \ie\ interconnecting, different
type systems and proof development environments.

The basic idea underpinning these logical frameworks is to allow for
the user to express explicitly, in an \LF\ type-theoretic framework
the \emph{invocation}, and uniform \emph{recording} of the
\emph{effect}, of external tools by means of a new \emph{monadic}
type-constructor , called a \emph{lock}.
More specifically, locks permit to express the fact that, in order to
obtain a term of a given type, it is necessary to \emph{verify},
first, a constraint , \ie\ to
\emph{produce} suitable \emph{evidence}. No restrictions are enforced
on producing such evidence. It can be supplied by calling an
\emph{external proof search tool} or an \emph{external oracle}, or
exploiting some other epistemic source, such as diagrams, physical
analogies, or explicit computations according to the \emph{Poincar\'e
  Principle} \cite{bar02}. Thus, by using lock constructors, one can
\emph{factor-out} the goal, produce pieces of evidence using different
proof environments and \emph{glue} them back together, using the
\emph{unlock operator}, which \emph{releases} the locked term in the
calling framework. Clearly, the task of checking the validity of
external evidence rests entirely on the external tool. In our
framework we limit ourselves to recording in the proof term by means
of an -destructor this recourse to an external tool.

One of the original contributions of this paper is that we show how
locks can delegate to external tools not only the task of producing
suitable evidence but also that of exhibiting suitable
\emph{witnesses}, to be further used in the calling environment. This
feature is exhibited by \CLLFPQ\ (see Section~\ref{sec:cllfpq}).

Locks subsume different \emph{proof attitudes}, such as
proof-irrelevant approaches, where one is only interested in knowing
that evidence does exist, or approaches relying on powerful
terminating metalanguages. Indeed, locks allow for a straightforward
accommodation of many different \emph{proof cultures} within a single
Logical Framework; which otherwise can be embedded only very
deeply~\cite{deep,hirschkoff:bisimproofs} or axiomatically
\cite{HMS-01}.

Differently from our earlier work, we focus in this paper only on
systems presented in the \emph{canonical format} introduced by the CMU
school \cite{watkins-02,HarperLicata-jfp-07}. This format is
syntax-directed and produces a unique derivation for each derivable
judgement. Terms are all in normal form and equality rules are
replaced by \emph{hereditary substitution}. We present the systems in
canonical form, since this format streamlines the proof of adequacy
theorems.

First, we present the very expressive system \CLLFP\ and discuss the
relationship to its non-canonical counterpart \LLFP\ in \cite{HLMS15},
where we introduced \emph{lock-types} following the paradigm of
Constructive Type Theory (\ala\ Martin-L\"of), via
\emph{introduction}, \emph{elimination}, and \emph{equality rules}.
This paradigm needs to be rephrased for the canonical format used
here. Introduction rules correspond to \emph{type checking} rules of
\emph{canonical objects}, whereas elimination rules correspond to
\emph{type synthesis} rules of \emph{atomic objects}. Equality rules
are rendered via the rules of \emph{hereditary substitution}.  In
particular, we introduce a \emph{lock constructor} for building
canonical objects  of type
, via the \emph{type checking rule}
. Correspondingly, we introduce an \emph{unlock
  destructor}, , and an \emph{atomic rule}
, allowing elimination, in the hereditary substitution rules, of
the lock-type constructor, under the condition that a specific
predicate  is verified, possibly \emph{externally}, on a
judgement:


\noindent Capitalizing on the monadic nature of the lock constructor,
as we did for the systems in \cite{llfp-mfcs2014,HLMS15}, one can
use locked terms without necessarily establishing the
predicate, provided an \emph{outermost} lock is present. 
This increases the expressivity of the system, and allows
for reasoning under the assumption that the verification is
successful, as well as for postponing and reducing the number of verifications.  The rules which make all this work are:
3mm]
\infer[(O{\cdot}Nested{\cdot}Unlock)] {\Gamma \VDASHS {\Lock
    {\P} {S} {\sigma} {M'}}\Leftarrow {\Lock {\P} {S} {\sigma}
    {\rho'}}} {\begin{array}{l@{\qquad}l} \Gamma, x\of\tau \VDASHS
                 \Lock \P {S} {\sigma} {M}\Leftarrow \Lock \P {S} {\sigma} {\rho} &
                 \Gamma \VDASHS {A} \Rightarrow {\Lock \P {S} {\sigma} {\tau}}\
\noindent The (\emph{ONestedUnlock})-rule is the counterpart of
the elimination rule for monads, once we realize that the standard destructor of monads (see, e.g., \cite{Moggi-Computationallambda})
 can be
replaced, in our context, by . And this holds since
the -monad satisfies the property
 if ,
provided  occurs \emph{guarded} in , \ie\ within subterms of the
appropriate lock-type.  The rule
(\emph{FNestedUnlock}) takes care of elimination at the
level of types.

We proceed then to introduce \CLLFPQ. Syntactically, it might appear
as a minor variation of \CLLFP, but the lock constructor is used here
to express the \emph{request} for a witness satisfying a given
property, which is then \emph{replaced} by the unlock operation. In
\CLLFPQ, the lock acts as a \emph{binding operator} and the unlock as an
\emph{application}.

To illustrate the expressive power of \CLLFP\ and \CLLFPQ\ we discuss
various challenging encodings of subtle logical systems, as well as
some novel applications. First, we encode in \CLLFP\ Fitch-Prawitz
consistent Set-Theory (\FPST), as presented in \cite{prawitz}, and to
illustrate its expressive power, we show, by way of example, how
it can type all strongly normalizing terms. Next, we give signatures
in \CLLFP\ of a strongly normalizing -calculus and a system of
Light Linear Logic \cite{DBLP:conf/lics/BaillotCL07}. Finally, in
Section~\ref{subsec:square_roots}, we show how to encode functions in
\CLLFPQ.

The paper is organized as follows: in Section~\ref{sec:canonical} we
present the syntax, the type system and the metatheory of \CLLFP,
whereas \CLLFPQ\ is introduced in
Section~\ref{sec:cllfpq}. Section~\ref{sec:case_studies} is devoted to
the presentation and discussion of case studies. Finally, connections
with related work in the literature appear in
Section~\ref{sec:relwork}.

\section{The Canonical System \CLLFP} \label{sec:canonical}
In this section, we discuss the \emph{canonical} counterpart of \LLFP
\cite{HLMS15}, \ie\ \CLLFP, in the style of
\cite{watkins-02,HarperLicata-jfp-07}. This approach amounts to
restricting the language only to terms in long -normal
form. These are the normal forms of the original system which are
normal also \wrt\ typed -like expansion rules, namely
 and
 if  is atomic. The added value of
canonical systems such as \CLLFP\ is that one can streamline results
of adequacy for encoded systems. Indeed, reductions in the
                        meta-language of non-canonical terms reflect only the history of how
the proof was developed using lemmata.

\begin{figure}[t!]
 \up{2}
 {\small
 \begin{center}
   
 \end{center} }
 \up{4}
 \caption{Syntax of \CLLFP} \up{5}
 \label{fig:cllfsyntax}
\end{figure}



\begin{figure}[t!]
{\small
  \up{2}
  \noindent {\sf ~Valid signatures}
  \\
  
\begin{center}
  

 
\end{center}}
\up{4}
\caption{The \CLLFP\ Type System} \up{5}
\label{fig:cllftypesys}
\end{figure}



\subsection{Syntax and Type System for \CLLFP}\label{subsec:cllfp_syntax}
The syntax of \CLLFP\ is presented in Figure~\ref{fig:cllfsyntax}. The
type system for \CLLFP\ is shown in Figure~\ref{fig:cllftypesys}.
The judgements of  are the following:

\up{1}
{\small

}
The judgements , and , and
 are as in Section~2.1 of \cite{HLLMSJ12}, whereas
the remaining ones are peculiar to the canonical style.  Informally,
the judgment  uses  to
check the type of the canonical term , while the judgment
 uses the type information
contained in the atomic term  and  to synthesize .
Predicates  in \CLLFP\ are defined on judgements of the shape
.

There are two rules whose conclusion is the lock constructor
. But nevertheless, this system is still
\emph{syntax directed}: when there are subterms of the form
 in either  or , the type
checking algorithm always tries to apply the
 rule. If this is not possible, it
applies instead the  rule.

The type system makes use, in the rules  and
, of the notion of \emph{Hereditary Substitution},
which computes the normal form resulting from the substitution of one
normal form into another.  The general form of the hereditary
substitution judgement is , where  is the
term being substituted,  is the variable being substituted for, 
is the term being substituted into,  is the result of the
substitution,  is the \emph{simple-type} of , and  denotes
the syntactic class (\eg\ atomic families/object, canonical
families/objects, etc.) under consideration. We give the rules of the
Hereditary Substitution in the style of \cite{HarperLicata-jfp-07},
where the erasure function to simple types is necessary to simplify
the proof of termination, which we omit.

The simple-type  of  is obtained via the erasure function of
\cite{HarperLicata-jfp-07} (Figure~\ref{fig:erasure}), mapping
dependent into simple-types. The rules for Hereditary Substitution are
presented in Figures~\ref{fig:hsubstapp1} and \ref{fig:hsubstapp2},
using Barendregt's hygiene condition.

Notice that, in the rule  of the type system
(Figure~\ref{fig:cllftypesys}), the syntactic restriction of the
classifier to  atomic ensures that canonical forms are
\emph{long -normal forms} for the suitable notion of long
-normal form, which extends the standard one for
lock-types. For one, the judgement
 is not
derivable, as  is not atomic, hence

is not derivable. On the other hand,
,
where  is a family constant of kind , is
derivable. Analogously, for lock-types, the judgement

is not derivable, since  is not atomic.
As a consequence, we have that

is not derivable. However,

is derivable, if  is atomic. Hence, the judgment

is derivable.  Note that the unlock constructor takes an \emph{atomic}
term as its main argument, thus avoiding the creation of possible
-redexes under substitution. Moreover, since unlocks can
only receive locked terms in their body, no abstractions can ever
arise.  In Definition~\ref{def:etaexp}, we formalize the notion of
-expansion of a judgement, together with correspondence theorems
between \LLFP\ and \CLLFP.

\begin{figure}[t!]
{\small
 \up{2}
   }
   \up{1}
   \caption{Erasure to simple-types} \up{1}
   \label{fig:erasure}
\end{figure}

\begin{figure}[t!]
{\small
 \begin{center}
   
   \caption{Hereditary substitution, kinds and families of \CLLFP} \up{8}
   \label{fig:hsubstapp1}
 \end{center}}
\end{figure}

We present \CLLFP\ in a fully-typed style, \ie\ \ala\ Church, but we
could also follow~\cite{HarperLicata-jfp-07} and present a version
\ala\ Curry, where the canonical forms  and  do not carry type information. The type rules would then
be, \eg:

\down{1}
{\small
\hfill\hfill} \down{1}

\noindent This latter syntax is more suitable in implementations
because it simplifies the notation.  Following~\cite{HLLMS12}, we stick to the typeful
syntax because it allows for a more direct comparison with
non-canonical systems. This, however, is technically immaterial. Since
judgements in canonical systems have unique derivations, one can show
by induction on derivations that any provable judgement in the system
where object terms are \ala\ Curry has a \emph{unique} type decoration
of its object subterms, which turns it into a provable judgement in
the version \ala\ Church. Vice versa, any provable judgement in the
version \ala\ Church can forget the types in its object subterms,
yielding a provable judgement in the version \ala\ Curry.

\begin{figure}[t!]
{\small
 \up{2}
 \begin{center}
   
   \up{1}
   \caption{Hereditary substitution, objects and contexts of \CLLFP} \up{5}
   \label{fig:hsubstapp2}
 \end{center}} \up{3}
\end{figure}

\up{2}
\subsection{The Metatheory of \CLLFP}

For lack of space we omit proofs, but these follow the standard
patterns in \cite{HarperLicata-jfp-07,HLLMSJ12}.  We start by studying
the basic properties of hereditary substitution and the type
system. First of all, we need to assume that the predicates are
\emph{well-behaved} in the sense of \cite{HLLMSJ12}. In the context of
canonical systems, this notion needs to be rephrased as follows:


\begin{definition}[Well-behaved predicates for canonical systems]
  \label{def:wbred}
  A finite set of predicates  is
  \emph{well-behaved} if each  in the set satisfies the following
  conditions:

  \begin{enumerate}
    \setlength\itemsep{-0.3ex}
  \item {\bf \emph{Closure under signature and context weakening and
        permutation:}}\vspace{-0.5ex}
    \begin{enumerate}
      \setlength\itemsep{-0.3ex}
    \item If  and  are valid signatures such that
       and
      , then . \item If  and  are valid contexts such that
       and
      , then \mbox{.} \end{enumerate}
  \item{\bf \emph{Closure under {hereditary} substitution:}} If
     and , then\\
    .
  \end{enumerate}
\end{definition}

As canonical systems do not feature reduction, the ``classical'' third
constraint for well-behaved predicates (closure under reduction) is
not needed here. Moreover, the second condition (\emph{closure under
  substitution}) becomes ``closure under hereditary substitution''.
\begin{lemma}[Decidability of hereditary substitution]\hfill
  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
\item For any  in ,
  and any , , and , it is decidable whether there exists a
   such that  or there is no such .
  \item For any , , , and , it is decidable whether
    there exists an , such that , or there exist
     and , such that , or
    there are no such  and .
  \end{enumerate}
\end{lemma}
\begin{lemma}[Head substitution size] If , then  is a subexpression of .\vspace{-1ex}
\end{lemma}
\begin{lemma}[Uniqueness of substitution and synthesis] \hfill \vspace{-0.5ex}
  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
  \item It is not possible that  and
    .
  \item For any , if , and
    , then .
  \item If , and
    , then .
  \item If , and
    , then .
  \end{enumerate}\vspace{-1ex}
\end{lemma}
\begin{lemma}[Composition of hereditary substitution]
  Let  and . Then:\vspace{-0.5ex}

  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
\item For all  in , if
  , , and
  , then there exists a :
  , and .
  \item If ,
    , and ,
    then there exists an : ,
    and .
  \item If , ,
    and , then there exists an :
    , and
    .
    \end{enumerate}
\end{lemma}


\begin{theorem}[Transitivity]
  Let ,  and
  , and assume that all
  predicates are well-behaved. Then,\vspace{-0.5ex}

  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
  \item There exists a :  and .
  \item If  then there
    exists a :  and .
  \item If ,
    then there exists a :
     and .
  \item If 
    and , then there exist  and :
     and
     and .
  \end{enumerate}
\end{theorem}
\begin{theorem}[Decidability of typing]
  \label{thm:dectypcllf}
  If predicates in \CLLFP\ are decidable, then all of the judgements
  of the system are decidable.\vspace{-1ex}
\end{theorem}

We can now precisely state the relationship between \CLLFP\ and the
\LLFP\ system of \cite{HLMS15}:

\begin{theorem}[Soundness] For any predicate  of \CLLFP, we define
  a corresponding predicate in \LLFP\ as follows:
   holds if and only if
   is derivable in \LLFP\ and
   holds in \CLLFP. Then, we
  have:\vspace{-0.5ex}
  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
\item If  is derivable in \CLLFP, then 
  is derivable in \LLFP.
  \item If  is derivable in \CLLFP, then
     is derivable in \LLFP.
  \item If  is derivable in \CLLFP, then  is derivable in \LLFP.
  \item If  is derivable in
    \CLLFP, then  is derivable in \LLFP.
  \item If  is derivable in \CLLFP, then
     is derivable in \LLFP.
  \item If  is derivable in
    \CLLFP, then  is derivable in \LLFP.
  \item If  is derivable in \CLLFP,
    then  is derivable in \LLFP.
  \end{enumerate}
\end{theorem}

Vice versa, all \LLFP\ judgements in \emph{long -normal
  form} (\ELNF) are derivable in \CLLFP.  The definition of a
judgement in \ELNF\ is based on the following extension of the
standard -rule to the lock constructor
 and
.
\begin{definition}
  An occurrence  of a constant or a variable in a term of an
  \LLFP\ judgement is \emph{fully applied and unlocked} \wrt\ its type
  or kind
  ,
  where  are vectors of locks,
  if  appears only in contexts that are of the form
  , where
,
   have the same arities of
  the corresponding vectors of 's and locks.
\end{definition}
\begin{definition}[Judgements in long -normal form]
  \hfill \label{def:etaexp}\vspace{-0.5ex}
  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
  \item A term  in a judgement is in \emph{\ELNF} if  is in
    normal form and every constant and variable occurrence in  is
    fully applied and unlocked \wrt\ its classifier in the judgement.
  \item A judgement is in \emph{\ELNF} if all terms appearing in it are
    in \ELNF.
  \end{enumerate}
\end{definition}

\begin{theorem}[Correspondence]\label{thm:correspond} Assume that all
  predicates in \LLFP\ are well-behaved, according to Definition 2.1
  \cite{HLLMSJ12}. For any predicate  in \LLFP, we define a
  corresponding predicate in \CLLFP\ with:
   holds if
   is derivable in \CLLFP\ and
   holds in \LLFP. Then, we
  have:\vspace{-0.5ex}

  \begin{enumerate}
  \setlength\itemsep{-0.3ex}
\item If  is in \ELNF\ and is \LLFP-derivable, then
   is \CLLFP-derivable.
\item If  is in \ELNF\ and is \LLFP-derivable, then
   is \CLLFP-derivable.
\item If  is in \ELNF, and is \LLFP-derivable, then
   is \CLLFP-derivable.
\item If  is in \ELNF\ and is \LLFP-derivable, then
   is \CLLFP-derivable.
\item If  is in \ELNF\ and is
  \LLFP-derivable, then  is
  \CLLFP-derivable.
\item If  is in \ELNF\ and is \LLFP-derivable, then
   is \CLLFP-derivable.
  \item If  is in \ELNF\ and is
    \LLFP-derivable, then  is
    \CLLFP-derivable.
  \end{enumerate}
\end{theorem}
Notice that, by the Correspondence Theorem above, any well-behaved
predicate  in \LLFP\, in the sense of Definition 2.1
\cite{HLLMSJ12} induces a well-behaved predicate in \CLLFP. Finally,
notice that \emph{not} all \LLFP\ judgements have a corresponding
\ELNF. Namely, the judgement

does not admit an -expanded normal form when the predicate 
does \emph{not} hold on , as the rule  can be
applied only when the predicate holds.

\up{1.5}
\section{The Type System \CLLFPQ}\label{sec:cllfpq}
The main idea behind \CLLFPQ\ (see Figures~\ref{fig:cllfsyntaxQ},
\ref{fig:cllftypesysQ}, and \ref{fig:hsubstappQ})\footnote{{For lack
    of space, we present in these figures only the categories and
    rules of \CLLFPQ\ that differ from their \CLLFP\ counterparts.}}
is to ``empower'' the framework of \CLLFP\ by \emph{adding} to the
lock/unlock mechanism the possibility to receive from the external
oracle a \emph{witness} satisfying suitable constraints. Thus, we can
pave the way for gluing together different proof development
environments beyond proof irrelevance scenarios. In this context, the
lock constructor behaves as a \emph{binder}.
The new  rule is the following:


\noindent where the variable  is a placeholder bound in  and
, which will be replaced by the concrete term that will be
returned by the external oracle call. The intuitive meaning behind the
 rule is, therefore, that of recording the need to
delegate to the external oracle the inference of a suitable witness of
a given type. Indeed,  can be thought of as an ``incomplete'' term
which needs to be completed by an inhabitant of a given type 
satisfying the constraint . The actual term, possibly synthesized
by the external tool, will be ``released'' in \CLLFPQ, by the unlock
constructor in the  rule as follows:

\noindent The term  intuitively means that 
is precisely the synthesized term satisfying the constraint
 that will replace in \CLLFPQ\
all the free occurrences of  in . This replacement is
executed in the () hereditary
substitution rule (Figure~\ref{fig:hsubstappQ}).

Similarly to \CLLFP, also in \CLLFPQ\ it is possible to ``postpone''
or delay the verification of an external predicate in a lock, provided
an \emph{outermost} lock is present. Whence, the synthesis of the
actual inhabitant  can be delayed, thanks to the
 rule:

\noindent The Metatheory of \CLLFPQ\ follows closely that of \CLLFP\
as far as decidability. We have no correspondence theorem since we did
not introduce a non-canonical variant \CLLFPQ. This could have been
done similarly to \LLFP.

\begin{figure}
{\small
 \up{2}
  \begin{center}
    
  \end{center}} \up{4}
  \caption{\CLLFPQ\ Syntax {--- changes \wrt\ \CLLFP}}
  \label{fig:cllfsyntaxQ}   \up{2}
\end{figure}

\begin{figure}
{\small
  \begin{center}
    

    
  \end{center}}
  \up{4}
  \caption{The \CLLFPQ\ Type System {--- changes \wrt\ \CLLFP}}
  \label{fig:cllftypesysQ} \up{2}
\end{figure}


\begin{figure}[t!]
{\small
  \begin{center}
    
  \end{center}}

\up{5}
\caption{\CLLFPQ\ Hereditary Substitution {--- changes \wrt\ \CLLFP}}
\label{fig:hsubstappQ} \up{4}
\end{figure}

\section{Case studies}\label{sec:case_studies}
In this section, we discuss the encodings of a collection of logical
systems which illustrate the expressive power and the flexibility of
\CLLFP\ and \CLLFPQ. We discuss Fitch-Prawitz Consistent Set theory,
\FPST\ \cite{prawitz}, some applications of \FPST\ to normalizing
-calculus, a system of Light Linear Logic in \CLLFP, and an
the encoding of a \emph{partial} function in \CLLFPQ.

The crucial step in encoding a logical system in \CLLFP\ or \CLLFPQ\
is to define the predicates involved in locks. Predicates defined on
closed terms are usually unproblematic. Difficulties arise in
enforcing the properties of closure under hereditary substitution and
closure under signature and context extension, when predicates are
defined on open terms.  To be able to streamline the definition of
well-behaved predicates we introduce the following:
\begin{definition}
  Given a signature  let  (respectively
  ) be the set of \LLFP\ terms (respectively
  \emph{closed} \LLFP\ terms) definable using constants from
  . A term  has a \emph{skeleton} in  if
  there exists a term , whose
  free variables (called \emph{holes} of the skeleton) are in
  , and there exist terms  such
  that .
\end{definition}

\subsection{Fitch Set Theory \ala\ Prawitz - {\sf FPST}} \label{Fitch}
In this section, we present the encoding of a formal system of
remarkable logical as well as historical significance, namely the
system of consistent {\emph{Na\"ive} Set Theory}, \FPST, introduced by
Fitch \cite{fitch}. This system was first presented in Natural
Deduction style by Prawitz \cite{prawitz}. As Na\"ive Set Theory is
inconsistent, to prevent the derivation of inconsistencies from the
unrestricted \emph{abstraction} rule, only normalizable
\emph{deductions} are allowed in \FPST. Of course, this side-condition
is extremely difficult to capture using traditional tools.

In the present context, instead, we can put to use the machinery of
\CLLFP\ to provide an appropriate encoding of \FPST\ where the
\emph{global} normalization constraint is enforced \emph{locally} by
checking the proof-object. This encoding beautifully illustrates the
\emph{bag of tricks} that \CLLFP\ supports. Checking that a proof term
is normalizable would be the obvious predicate to use in the
corresponding lock-type, but this would not be a well-behaved
predicate if free variables, \ie\ assumptions, are not sterilized.  To
this end, 
We introduce a distinction between \emph{generic}
judgements, which cannot be directly utilized in arguments, but which
can be assumed, and \emph{apodictic} judgements, which are directly
involved in proof rules. In order to make use of generic judgements,
one has to downgrade them to an apodictic one. This is achieved by a
suitable coercion function.

\begin{definition}[Fitch Prawitz Set Theory, \FPST]
  For the lack of space, here we only
  give the crucial rules for implication and for
  \emph{set-abstraction} and the corresponding elimination rules of the full system of Fitch (see~\cite{prawitz}), as presented by
  Prawitz:
2mm]
    \infer[\rew{1} (\lambda I)]
    { \Gamma \VDASHFP T \in \lambda x. A }
    {\Gamma \VDASHFP A[T/x]}
    &
    \infer[\rew{1} (\lambda E)]
    {\Gamma \VDASHFP A[T/x]}
    { \Gamma \VDASHFP T \in \lambda x. A }
\end{array}
  \fwd{26}\iota\fwd{15.5}\delta\Pi\fwd{16.5}\mathtt{\lambda_{intro}}\Pi\iota\Pi\iota\epsilon\iota\iota\fwd{6.5}\mathtt{\lambda_{elim}}\Pi\iota\Pi\iota\epsilon\epsilon\iota{\iota}\fwd{9}\mathtt{\supset_{intro}}\Pi\supset\supset \hfill\mathtt{\supset_{elim}}\Pi\Pi\Pi\supset{\Lock{\scriptsize\tt{Fitch}}{\scriptsize{\mathtt{\langle{x},y\rangle}}}{\scriptsize\mathtt{{T(A)}\times\mathtt{T(A{\supset}B)}}}{\mathtt{T(B)}}}\mathtt{c_{beta}}\Pi\Lock{\scriptsize{\P\sp{\tt{N}}}}{{\!\!}\scriptsize\mathtt{\langle{M},N\rangle}}{\scriptsize\mbox{\tt{(o->o)o}}}{\mbox{Eq\ (app\ (lam\
x:v.M(var\ x))\ N)\ (M\ N)}}2mm]
      \infer[(Contr)]
      { \Gamma, \Delta \VDASHEAL  B}
      {\Gamma \VDASHEAL  !A &  \Delta, !A, \ldots, !A \VDASHEAL  B }
      \qquad
      \infer[(Prom)]
      { \Gamma_1 \ldots \Gamma_n \VDASHEAL  !A}
      {A_1,\ldots,A_n \VDASHEAL  A &  \Gamma_1 \VDASHEAL  !A_1\   & \ldots &
        \Gamma_n \VDASHEAL  !A_n }
    \end{array}
    \Sigma_{EAL}\multimap\mathtt !\mathtt{T}\mathtt{V(\cdot)}\Gamma\VDASHSEAL \mathtt{x \Leftarrow
    T(A)\rightarrow T(B)}\mathtt{A}\mathtt{!A}\mathtt{x}\mathtt{x}\Gamma\VDASHSEAL \mathtt{x
      \Leftarrow T(A)}\mathtt{T(B)}\mathtt{B : o}\mathtt{V(\cdot)}A_1,\ldots,A_nB_1,\ldots,B_m,AB_1\ldots B_m \VDASHEAL A \mathtt{M}\mathtt{A_1\of o,\ldots,A_n\of o,x_1\of}\mathtt{T(B_1),\ldots,x_m\of T(B_m)} \VDASHSEAL\mathtt{M \Leftarrow
    T(A)}\mathtt{A}\mathtt{B_i}AB_i1\leq i\leq m\mathtt{x_1 \ldots x_m}\mathtt{M}\mathtt{T(B_i)}\equiv \mathtt{T(!C_i)}\mathtt{C}_i\mathtt{{\langle} x,y{\rangle}}\mathtt{\sigma\times\tau}\tt y\sigma \equiv \mathtt{(eval\ (plus\ (minus\ x\ (mult\ z\ z))\ (minus\
    (mult\ z\ z)} \mathtt{\ x)\ O))}{\textit{SQRT}}(\Gamma\VDASHS \mathtt{y} \Leftarrow
\mathtt{nat}\times\sigma)\mathtt{(x\dotminus N\ast N)+(N\ast N\dotminus x)=0}+\mathtt \dotminus
\mathtt{x\dotminus y\eqdef } \left\{\begin{array}{l@{\quad}l}
                                         \mathtt{x-y} & \mathtt{if}~\mathtt{x\geq y}\\
                                         \mathtt{0}     & \mathtt{ otherwise}
                                       \end{array}\right.
{\textit{SQRT}}\lambda\lambda\Pi\pi\mathsf{L^{\!\!ax}\rew{.3}F}\pi$-calculus in (Co)Inductive Type Theories}.  \newblock {\em
    Theoretical Computer Science}, 253(2):239--285, 2001,
  \url{doi:10.1016/S0304-3975(00)00095-5}.

\bibitem{mendler1991constrained} M.~Mendler.  \newblock Constrained
  proofs: A logic for dealing with behavioral constraints in formal
  hardware verification.  \newblock In {\em Designing Correct
    Circuits}, pp. 1--28. Springer-Verlag, 1991,
  \url{doi:10.1007/978-1-4471-3544-9\_1}.

\bibitem{moggi1988partial} E.~Moggi.  \newblock {\em The partial
    lambda calculus}.  \newblock PhD thesis, University of Edinburgh,
  1988, \url{doi:10.1.1.53.8462}.

\bibitem{Moggi-Computationallambda} E.~Moggi.  \newblock Computational
  lambda-calculus and monads.  \newblock In {\em LICS 1989},
  pp. 14--23. IEEE Press, \url{doi:10.1.1.26.2787}.

\bibitem{NPP05:CMTT} A.~Nanevski, F.~Pfenning, B.~Pientka.  \newblock
  {Contextual Modal Type Theory}.  \newblock {\em ACM TOCL}, 9(3),
  2008, \url{doi:10.1145/1352582.1352591}.

\bibitem{pfenning1999system} F.~Pfenning, C.~Sch{\"u}rmann.  \newblock
  System description: Twelf -- a meta-logical framework for deductive
  systems.  \newblock In {\em CADE}, v. 1632 of {\em LNCS},
  pp. 202--206. Springer-Verlag, 1999, \url{doi:10.1007/3-540-48660-7\_14}.

\bibitem{Pientka08:DependentBeluga} B.~Pientka, J.~Dunfield.
  \newblock Programming with proofs and explicit contexts.  \newblock
  In {\em PPDP'08}, pp. 163--173, ACM, \url{doi:10.1145/1389449.1389469}.

\bibitem{belugasys} B.~Pientka, J.~Dunfield.  \newblock Beluga: A
  framework for programming and reasoning with deductive systems
  (system description).  \newblock In {\em IJCAR 2010}, v. 6173 of
  {\em LNCS}, pp. 15--21. Springer-Verlag,
  \url{doi:10.1007/978-3-642-14203-1\_2}.

\bibitem{prawitz} D.~Prawitz.  \newblock {\em
    {Natural\,Deduction.\,A\,Proof\,Theoretical\,Study}}.\,{Almqvist\,Wiksell,\,Stockholm},\,1965,
  ISBN: 978-0486446554.

\bibitem{celf} A.~Schack-Nielsen, C.~Sch{\"u}rmann.  \newblock Celf--A
  logical framework for deductive and concurrent systems (System
  description).  \newblock in {\em Automated Reasoning}, pp. 320--326,
  Springer, 2008, \url{doi:10.1007/978-3-540-71070-7\_28}.

\bibitem{schroeder2012honour} P.~Schroeder-Heister.  \newblock
  {Paradoxes and Structural Rules}.  \newblock {\em {Insolubles and
      consequences : essays in honor of Stephen Read}}, pp.
  203--211. College Publications, London, 2012, ISBN
  978-1-84890-086-8.

\bibitem{schroeder2012proof} P.~Schroeder-Heister.  \newblock
  Proof-theoretic semantics, self-contradiction, and the format of
  deductive reasoning.  \newblock {\em Topoi}, 31(1):77--85, 2012,
  \url{doi:10.1007/s11245-012-9119-x}.

\bibitem{stump-08}
A.~Stump.
\newblock Proof checking technology for satisfiability modulo
theories.  \newblock In {\em LFMTP 2008}, v. 228, pp. 121--133, 2009, \url{doi:10.1.1.219.1459}.

\bibitem{watkins-02} K.~Watkins, I.~Cervesato, F.~Pfenning, D.~Walker.
  \newblock {A Concurrent Logical Framework I: Judgments and
    Properties}.  \newblock Tech. Rep. CMU-CS-02-101, CMU, 2002,
  \url{doi:10.1.1.14.5484}.

\end{scriptsize}

\end{thebibliography}

}



\end{document}
