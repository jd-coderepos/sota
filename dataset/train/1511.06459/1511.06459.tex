\documentclass[11pt]{article}
\usepackage{multicol}
\usepackage{geometry}
\newgeometry{left=1.0in,right=1.0in,top=1.0in,bottom=1.0in}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\usepackage{mathpartir}
\usepackage{irule}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{irule}

\usepackage{amssymb, amscd,txfonts,stmaryrd,setspace,mathtools,makecell}
\usepackage{enumerate}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[bookmarks=true,colorlinks=true, linkcolor=MidnightBlue, citecolor=cyan]{hyperref}
\usepackage{lmodern}
\usepackage{graphicx,float}

\usepackage{titling}

\setlength{\droptitle}{-1in}   

\input xy
\xyoption{all} \xyoption{poly} \xyoption{knot}\xyoption{curve}
\usepackage{xypic,color}
\usepackage{tikz}

\newcommand{\comment}[1]{}
\newcommand{\dlongnote}[2][4.9in]{\fcolorbox{black}{yellow}{\parbox{#1}{\color{black} #2}}}
\newcommand{\dnote}[1]{\fcolorbox{black}{yellow}{\color{black} #1}}
\newcommand{\rlongnote}[2][4.9in]{\fcolorbox{black}{Apricot}{\parbox{#1}{\color{black} #2}}}
\newcommand{\rnote}[1]{\fcolorbox{black}{Apricot}{\color{black} #1}}


\newcommand{\start}[1]{\dnote{Start here: #1.}}
\newcommand{\q}[1]{\begin{question}#1\end{question}}
\newcommand{\g}[1]{\begin{guess}#1\end{guess}}

\def\tn{\textnormal}
\def\mf{\mathfrak}
\def\mc{\mathcal}

\def\ZZ{{\mathbb Z}}
\def\QQ{{\mathbb Q}}
\def\RR{{\mathbb R}}
\def\CC{{\mathbb C}}
\def\AA{{\mathbb A}}
\def\PP{{\mathbb P}}
\def\NN{{\mathbb N}}
\def\SS{{\mathbb S}}

\def\Hom{\tn{Hom}}
\def\Mor{\tn{Mor}}
\def\Fun{\tn{Fun}}
\def\RQry{\tn{RQry}}
\def\Path{\tn{Path}}
\def\Ob{\tn{Ob}}
\def\Arr{\tn{Arr}}
\def\Op{\tn{Op}}
\def\SEL*{\tn{SEL*}}
\def\Res{\tn{Res}}
\def\hsp{\hspace{.3in}}
\newcommand{\hsps}[1]{{\hspace{2mm} #1\hspace{2mm}}}
\newcommand{\tin}[1]{\text{\tiny #1}}

\def\singleton{{\{*\}}}
\def\Dom{{\bf Dom}}
\def\queryto{\leadsto}
\newcommand{\church}[1]{\llbracket #1\rrbracket}
\def\Loop{{\mcL oop}}
\def\LoopSchema{{\parbox{.5in}{\fbox{\xymatrix{\LMO{s}\ar@(l,u)[]^f}}}}}
\def\Wks{{\mcW ks}}
\def\lcone{^\triangleleft}
\def\rcone{^\triangleright}
\def\to{\rightarrow}
\def\from{\leftarrow}
\def\down{\downarrrow}
\def\Down{\Downarrow}
\def\cross{\times}
\def\taking{\colon}
\newcommand{\pathto}[1]{\stackrel{#1}\queryto}
\def\inj{\hookrightarrow}
\def\surj{\twoheadrightarrow}
\def\too{\longrightarrow}
\def\fromm{\longleftarrow}
\def\tooo{\longlongrightarrow}
\def\tto{\rightrightarrows}
\def\ttto{\equiv\!\!>}
\def\ss{\subseteq}
\def\superset{\supseteq}
\def\iso{\cong}
\def\down{\downarrow}
\def\|{{\;|\;}}
\def\m1{{-1}}
\def\op{^\tn{op}}
\def\loc{\tn{loc}}
\def\la{\langle}
\def\ra{\rangle}
\def\wt{\widetilde}
\def\wh{\widehat}
\def\we{\simeq}
\def\ol{\overline}
\def\ul{\underline}
\def\vect{\overrightarrow}
\def\qeq{\mathop{=}^?}

\def\rr{\raggedright}

\newcommand{\LMO}[1]{\stackrel{#1}{\bullet}}
\newcommand{\LTOO}[1]{\stackrel{\tt{#1}}{\circ}}
\newcommand{\LTO}[1]{\stackrel{\tt{#1}}{\bullet}}
\newcommand{\LA}[2]{\ar[#1]^-{\tn {#2}}}
\newcommand{\LAL}[2]{\ar[#1]_-{\tn {#2`}}}
\newcommand{\obox}[3]{\stackrel{#1}{\fbox{\parbox{#2}{#3}}}}
\newcommand{\labox}[2]{\obox{#1}{1.6in}{#2}}
\newcommand{\mebox}[2]{\obox{#1}{1in}{#2}}
\newcommand{\smbox}[2]{\stackrel{#1}{\fbox{#2}}}
\newcommand{\fakebox}[1]{\tn{#1}}
\newcommand{\sq}[4]{\xymatrix{#1\ar[r]\ar[d]&#2\ar[d]\\#3\ar[r]&#4}}
\newcommand{\namecat}[1]{\begin{center}\end{center}}


\def\ullimit{\ar@{}[rd]|(.3)*+{\lrcorner}}
\def\urlimit{\ar@{}[ld]|(.3)*+{\llcorner}}
\def\lllimit{\ar@{}[ru]|(.3)*+{\urcorner}}
\def\lrlimit{\ar@{}[lu]|(.3)*+{\ulcorner}}
\def\ulhlimit{\ar@{}[rd]|(.3)*+{\diamond}}
\def\urhlimit{\ar@{}[ld]|(.3)*+{\diamond}}
\def\llhlimit{\ar@{}[ru]|(.3)*+{\diamond}}
\def\lrhlimit{\ar@{}[lu]|(.3)*+{\diamond}}
\newcommand{\clabel}[1]{\ar@{}[rd]|(.5)*+{#1}}
\newcommand{\TriRight}[7]{\xymatrix{#1\ar[dr]_{#2}\ar[rr]^{#3}&&#4\ar[dl]^{#5}\\&#6\ar@{}[u] |{\Longrightarrow}\ar@{}[u]|>>>>{#7}}}
\newcommand{\TriLeft}[7]{\xymatrix{#1\ar[dr]_{#2}\ar[rr]^{#3}&&#4\ar[dl]^{#5}\\&#6\ar@{}[u] |{\Longleftarrow}\ar@{}[u]|>>>>{#7}}}
\newcommand{\TriIso}[7]{\xymatrix{#1\ar[dr]_{#2}\ar[rr]^{#3}&&#4\ar[dl]^{#5}\\&#6\ar@{}[u] |{\Longleftrightarrow}\ar@{}[u]|>>>>{#7}}}


\newcommand{\arr}[1]{\ar@<.5ex>[#1]\ar@<-.5ex>[#1]}
\newcommand{\arrr}[1]{\ar@<.7ex>[#1]\ar@<0ex>[#1]\ar@<-.7ex>[#1]}
\newcommand{\arrrr}[1]{\ar@<.9ex>[#1]\ar@<.3ex>[#1]\ar@<-.3ex>[#1]\ar@<-.9ex>[#1]}
\newcommand{\arrrrr}[1]{\ar@<1ex>[#1]\ar@<.5ex>[#1]\ar[#1]\ar@<-.5ex>[#1]\ar@<-1ex>[#1]}

\newcommand{\To}[1]{\xrightarrow{#1}}
\newcommand{\Too}[1]{\xrightarrow{\ \ #1\ \ }}
\newcommand{\From}[1]{\xleftarrow{#1}}
\newcommand{\Froom}[1]{\xleftarrow{\ \ #1\ \ }}

\newcommand{\Adjoint}[4]{\xymatrix@1{{#2}\ar@<.5ex>[r]^-{#1} &{#3} \ar@<.5ex>[l]^-{#4}}}

\def\id{\tn{id}}
\def\Top{{\bf Top}}
\def\Cat{{\bf Cat}}
\def\Grph{{\bf Grph}}
\def\Sig{{\bf Sig}}
\def\Monad{{\bf Monad}}
\def\cpo{{\bf cpo}}
\def\Vect{\text{Vect}}
\def\Rep{{\bf Rep}}
\def\HCat{{\bf HCat}}
\def\Cnst{{\bf Cnst}}
\def\Str{\tn{Str}}
\def\List{\tn{List}}
\def\Exc{\tn{Exc}}
\def\Sets{{\bf Set}}
\def\Rel{{\bf Rel}}
\def\Inst{{\bf Inst}}
\def\Type{{\bf Type}}
\def\Set{{\bf Set}}
\def\Qry{{\bf Qry}}
\def\set{{\text \textendash}{\bf Set}}
\def\inst{{{\text \textendash}\bf \Inst}}
\def\sSet{{\bf sSet}}
\def\sSets{{\bf sSets}}
\def\Grpd{{\bf Grpd}}
\def\Pre{{\bf Pre}}
\def\Shv{{\bf Shv}}
\def\Rings{{\bf Rings}}
\def\bD{{\bf \Delta}}
\def\dispInt{\parbox{.1in}{}}
\def\bhline{\Xhline{2\arrayrulewidth}}
\def\bbhline{\Xhline{2.5\arrayrulewidth}}


\def\colim{\mathop{\tn{colim}}}
\def\hocolim{\mathop{\tn{hocolim}}}

\def\mcA{\mc{A}}
\def\mcB{\mc{B}}
\def\mcC{\mc{C}}
\def\mcD{\mc{D}}
\def\mcE{\mc{E}}
\def\mcF{\mc{F}}
\def\mcG{\mc{G}}
\def\mcH{\mc{H}}
\def\mcI{\mc{I}}
\def\mcJ{\mc{J}}
\def\mcK{\mc{K}}
\def\mcL{\mc{L}}
\def\mcM{\mc{M}}
\def\mcN{\mc{N}}
\def\mcO{\mc{O}}
\def\mcP{\mc{P}}
\def\mcQ{\mc{Q}}
\def\mcR{\mc{R}}
\def\mcS{\mc{S}}
\def\mcT{\mc{T}}
\def\mcU{\mc{U}}
\def\mcV{\mc{V}}
\def\mcW{\mc{W}}
\def\mcX{\mc{X}}
\def\mcY{\mc{Y}}
\def\mcZ{\mc{Z}}
\def\undsc{\rule{2mm}{0.4pt}}



\newcommand{\subsub}[1]{\setcounter{subsubsection}{\value{theorem}}\subsubsection{#1}\addtocounter{theorem}{1}}

\def\Finm{{\bf Fin_{m}}}
\def\Bag{\tn{Bag}}
\newcommand{\back}[1]{\stackrel{\from}{#1}\!}
\newcommand{\Kls}[1]{{\bf Kls}({#1})}
\newcommand{\unding}[1]{{|#1|}}
\newcommand{\bkls}[1]{{\text \textendash}\Kls{#1}}
\newcommand{\kls}[1]{{\text \textendash}\wt{\bf Kls}({#1})}
\def\Dist{\text{Dist}}
\def\Supp{{\bf Supp}}
\def\Inp{\tn{Inp}}
\def\Tur{\tn{Tur}}
\def\Halt{\{\text{Halt}\}}
\def\Tape{{T\!ape}}
\def\Prb{{\bf Prb}}
\def\Prbs{{\wt{\bf Prb}}}
\def\El{{\bf El}}
\def\Gr{{\bf Gr}}
\def\DT{{\bf DT}}
\def\DB{{\bf DB}}
\def\Tables{{\bf Tables}}
\def\Sch{{\bf Sch}}
\def\TSig{{\bf TSig}}
\def\Fin{{\bf Fin}}
\def\P{{\bf P}}
\def\SC{{\bf SC}}
\def\ND{{\bf ND}}
\def\Poset{{\bf Poset}}
\def\Bool{\tn{Bool}}
\newcommand{\labelDisp}[2]{}

\newtheorem{lm}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}

\newtheorem{proposition}[theorem]{Proposition}

\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{fact}[theorem]{Fact}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{warning}[theorem]{Warning}
\newtheorem{question}[theorem]{Question}
\newtheorem{guess}[theorem]{Guess}
\newtheorem{answer}[theorem]{Answer}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{postulate}[theorem]{Postulate}
\newtheorem{construction}[theorem]{Construction}


\newcommand{\mainCatLarge}[1]{ 
	\stackrel{#1}{
		\parbox{4.1in}{\fbox{\parbox{4in}{\begin{center}\underline{{\tt Emp} manager worksIn  {\tt Emp} worksIn}\hsp  \underline{{\tt Dept} secretary worksIn  {\tt Dept}}\end{center}~\\\\\\
			\xymatrix@=10pt{&\LTO{Emp}\ar@<.5ex>[rrrrr]^{\tn{worksIn}}\ar@(l,u)[]+<8pt,10pt>^{\tn{manager}}\ar[dddl]_{\tn{first}}\ar[dddr]^{\tn{last}}&&&&&\LTO{Dept}\ar@<.5ex>[lllll]^{\tn{secretary}}\ar[ddd]^{\tn{name}}\\\\\\\LTO{FName}&&\LTO{LName}&~&~&~&\LTO{DName}
			}
		} }}
	}
}

\setcounter{tocdepth}{2}
\usepackage{diagrams}





\newcommand{\FOR}{{\tt for} \ }
\newcommand{\FORALL}{{\tt forall} \ }
\newcommand{\EXISTS}{{\tt exists} \ }
\newcommand{\WHERE}{{\tt where} \ }
\newcommand{\IN}{ \ {\tt in} \ }
\newcommand{\RETURN}{{\tt return} \ }
\newcommand{\DO}{{\tt do}}
\newcommand{\IF}{{\tt if} \ }
\newcommand{\THEN}{{\tt then} \ }
\newcommand{\ELSE}{{\tt else} \ }
\newcommand{\ZERO}{{\tt zero}}
\newcommand{\FALSE}{{\tt false}}
\newcommand{\BIND}{{\tt bind}}
\newcommand{\UNION}{{\tt union}}
\newcommand{\MAP}{{\tt map}}
\newcommand{\CONS}{{\tt Cons}}
\newcommand{\NIL}{{\tt Nil}}


\begin{document}

\title{QINL: Query-integrated Languages \\
{\large or, Co-(LINQ: Language-integrated Queries)}}
\author{Patrick Schultz, David I. Spivak
\\ Massachusetts Institute of Technology \\ {\sf \{pschultz, dspivak\}@math.mit.edu} 
\and
Ryan Wisnesky
\\
Categorical Informatics, Inc.
 \\ {\sf ryan@catinf.com}
}

\date{\today}

\maketitle




\vspace*{-.2in}
In this paper we describe an alternative solution to the impedance-mismatch problem between programming and query languages: rather than embed queries in a programming language, as done in LINQ~\cite{Tannen:1992:NEQ:645500.655920} systems, we embed programs  in a query language, and dub the result ``QINL''.  We have implemented our solution in a prototype software system, FQL, available at {\sf categoricaldata.net/fql.html}.  Because both LINQ and QINL extend a common language, type theory with products, we present this type theory first, then LINQ, and then QINL.

\section{Type theory with products}

To start our discussion, we now present a language, {\it type theory with products}, by the BNF grammar, typing rules, and equations in Figure 1.  In this language,  represents types,  represents typing contexts,  represents expressions, and  represents variables.  

\begin{figure}[h]
\caption{Type Theory with Products (TTP) over base types  and operations }

\setgroup{g1}
\irule{}{ }{\Gamma, x : T \vdash x : T}
\irule{}{\Gamma \vdash x : T \\ x' \neq x}{\Gamma, x' : T' \vdash x:T}
\irule{}{ }{\Gamma \vdash () : 1}
\irule{}{\Gamma \vdash E_1 : T_1 \\ \Gamma \vdash E_2 : T_2}{\Gamma \vdash (E_1, E_2) : T_1 \times T_2}
\irule{}{\Gamma \vdash E : T_1 \times T_2}{\Gamma \vdash E.1 : T_1}
\irule{}{\Gamma \vdash E : T_1 \times T_2}{\Gamma \vdash E.2 : T_2}
\irule{}{E_2 : T_1 \to T_2 \in \mathcal{E} \\ \Gamma \vdash E_1 : T_1 }{\Gamma \vdash E_2(E_1) : T_2}
\showrules{g1}

\setgroup{g2}
\irule{}{\Gamma \vdash E : 1}{\Gamma \vdash E = ()}
\irule{}{\Gamma \vdash E : T_1 \times T_2 }{\Gamma \vdash E = (E.1, E.2)}
\irule{}{\Gamma \vdash E_1 : T_1 \\ \Gamma \vdash E_2 : T_2}{\Gamma \vdash (E_1, E_2).1 = E_1}
\irule{}{\Gamma \vdash E_1 : T_1 \\ \Gamma \vdash E_2 : T_2}{\Gamma \vdash (E_1, E_2).2 = E_2}
\showrules{g2}

\end{figure}

A particular choice of  is called a {\it signature}, and the type-theory so generated is denoted TPP.  An {\it equational theory} over TPP is a set of equations of the form .

\section{LINQ}

LINQ~\cite{Tannen:1992:NEQ:645500.655920}, which stands for language-embedded query, is a technology that embeds comprehensions and other bulk-data operators into a general-purpose programming language.  LINQ technology is currently deployed in practical systems such as Microsoft's .NET, but the original LINQ system was conceived of at the University of Pennsylvania in the early 1990s and goes by the name ``nested relational calculus'' (NRC)~\cite{921235}.  Because of its simplicity, in this paper we will use the NRC as our canonical example of a LINQ system.  

The syntax and typing rules for the NRC are shown in Figure 2 and extend those of type theory with products from Figure 1.  In addition, the NRC posses an equational theory, not shown in Figure 2, that contains equations about sets, such as , for example.  For our purposes, it is enough to note that  is intended to denote the empty set of type , that  denotes union, that  denotes the singleton set of only , and that  denotes iteration.  Additionally, the NRC contains a boolean type {\sf Bool} and related operations.

\begin{figure}[h]
\caption{Nested Relational Calculus [extends Fig 1] (equations omitted)}

\setgroup{g3}
\irule{}{ }{\Gamma \vdash \emptyset_T : {\sf Set} \ T}
\irule{}{\Gamma \vdash E_1 : {\sf Set} \ T \\ \Gamma \vdash E_2 : {\sf Set} \ T}{\Gamma \vdash E_1 \cup E_2 : {\sf Set} \ T}
\irule{}{\Gamma \vdash E : T}{\Gamma \vdash \{ E \} : {\sf Set} \ T}
\irule{}{\Gamma \vdash E_1 : {\sf Set} \ T_1 \\ \Gamma, x:T_1 \vdash E_2 : {\sf Set} \ T_2}
{\Gamma \vdash {\sf for} \ x \in E_1. E_2 : {\sf Set} \ T_2}
\irule{}{\Gamma \vdash E_1 : {\sf Bool} \\ \Gamma \vdash E_2 : T \\ \Gamma \vdash E_3 : T}
{\Gamma \vdash {\sf if} \ E_1 \ {\sf then} \ E_2 \ {\sf else} \ E_3 : T}
\irule{}{ }{\Gamma \vdash {\sf t} : {\sf Bool}}
\irule{}{ }{\Gamma \vdash {\sf f} : {\sf Bool}}
\irule{}{\Gamma \vdash E_1 : T \\ \Gamma \vdash E_2 : T}{\Gamma \vdash E_1 = E_2 : {\sf Bool}}
\showrules{g3}
\end{figure}

Many relational queries can be written in the NRC; for example, projecting the first column from a binary relation (), taking the cartesian product of two unary relations (), and selecting those rows from a binary relation that have the same values in both columns :

\begin{figure}[h]
\caption{Some Relational Queries in NRC}



\end{figure}



To summarize, in the NRC, a database schema  is a type, an instance on  is a closed expression of type , and a query  from  to another type  is an open expression .  In this paper we will not dwell on the specifics of any particular LINQ system, but the following remarks about how particular LINQ systems are derived from the NRC are relevant:
\begin{itemize}
\item A particular LINQ system, such as .Net, can be modeled as the NRC generated by particular choice of , which we will denote as NRC.  A program (set of related definitions) in this LINQ system can be modeled as an equational theory over NRC).   
\item Some expressive LINQ systems, such as Haskell, require not only a particular choice of , but a more expressive type theory as well - for example, a type theory containing exponential types (which model Haskell's first-class functions).  Other collection types besides sets, such as lists and bags, are also a common extension, as are recursive and polymorphic types.
\item The NRC, as defined above, cannot perform aggregation except through predefined operations (i.e., choosing  to contain e.g., ).  However, the {\sf for} construct of the NRC can be extended to allow aggregation~\cite{755736}.  In this paper, we ignore aggregation.
\end{itemize}



\section{QINL}

Similarly to how we presented the NRC as the core of a LINQ system, we begin our discussion of QINL by presenting a language, FQL, that illustrates the core ideas of QINL.  For the purposes of this paper, we define FQL slightly differently than in the FQL IDE software tool.  Consider a particular signature .  An FQL {\it schema} is an equational theory over TTP. For example,

\begin{figure}[h]
\caption{Example FQL Schema [extends Figure 1]}




 
\end{figure}

Because an FQL schema contains an arbitrary set of types, operations, and equations, each FQL schema is in fact a programming language -- indeed, FQL schemas can even be Turing-complete languages which have finite equational axiomatizations, such as the SK-combinatory algebra.  It is because programming languages live inside FQL schemas that we call FQL a QINL system, although perhaps SINL, or schema-embedded programming language, would be more accurate.  In contrast, in LINQ, schemas/types live inside an ambient programming language (the NRC).  

Suppose we wish to describe a database schema with entities  and columns  in an ambient programming language with types  and operations .  In the QINL approach, the schema would simply be the language TTP.  In the LINQ approach, the schema would be a type, defined in terms of  and , in the language NRC.  In other words, in QINL, an entity set  is represented as a base type ; in LINQ, an entity set  is represented as a expression of type , for some appropriate .  QINL's  strategy of representing sets as types is common in type theory (e.g., Coq, Agda), but LINQ's strategy of representing sets as values/expressions is the dominant approach in database programming languages.  

Finally, we describe how instances an queries are handled in FQL. Let  be an FQL schema.  Then an instance  on this schema consists of, for each , a set , and for each , a function , such that all equations of  are true in .  Such instances can be described extensionally, for example as SQL database instances, or such instances can be described intensionally, for example, as initial models of set of equations; the FQL tool provides support for both kinds of descriptions.  For queries, FQL uses so-called data migration functors~\cite{Spivak:2012:FDM:2324905.2325108}: a {\it functor}  between two FQL schemas  and  is a function from base types in  to base types in , and from base operations in  to (open) expressions in , that preserves the equations of .  Associated with  are three operations, , for migrating instances on  to instances on , and vice versa; under suitable assumptions, compositions of these operations can be proved to be equivalence to unions of conjunctive relational queries~\cite{relfound}.  In fact, such queries may be written in a LINQ-like notation:

\begin{figure}[h]
\caption{Example FQL Query to find departments worked in by palindromic self-managers}

\end{figure}
\newpage

\section{Conclusion}

To summarize, LINQ adds type constructors to product type theory so as to encode any schema as a type, and such that instances for a schema are terms of that type. In QINL, a schema becomes itself an extension of a product type theory, adding types for each entity, and an instance on a schema can be represented as a context  in this extended type theory, together with equations in context .
















\bibliographystyle{plain}
\begin{thebibliography}{1}

\bibitem{755736}
S.~Kazem Lellahi and Val Tannen.
\newblock A calculus for collections and aggregates.
\newblock In {\em CTCS}, 1997.

\bibitem{Spivak:2012:FDM:2324905.2325108}
David~I. Spivak.
\newblock Functorial data migration.
\newblock {\em Inf. Comput.}, 217:31--51, August 2012.

\bibitem{relfound}
David~I. Spivak and Ryan Wisnesky.
\newblock Relational foundations for functorial data migration.
\newblock DBPL, 2015.

\bibitem{Tannen:1992:NEQ:645500.655920}
Val Tannen, Peter Buneman, and Limsoon Wong.
\newblock Naturally embedded query languages.
\newblock ICDT '92, pages 140--154, London, UK, 1992. Springer-Verlag.

\bibitem{921235}
Limsoon Wong.
\newblock {\em Querying nested collections}.
\newblock PhD thesis, University of Pennsylvania, Philadelphia, PA, USA, 1994.
\newblock Supervisor-Buneman, Peter.

\end{thebibliography}



\end{document}
