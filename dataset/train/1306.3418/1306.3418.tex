\documentclass[11pt, a4paper]{article}

\usepackage{fullpage}

\newcommand{\shortorlong}[2]{#2} 
      
\usepackage{microtype}

\bibliographystyle{plain}
\title{A Short Note on Two-Variable Logic with a Linear Order Successor and a Preorder Successor}


\author{Amaldev Manuel\\
\small LIAFA, Universit\'e Paris Diderot\\ 
\small  \texttt{amal@liafa.univ-paris-diderot.fr}
\and 
Thomas Schwentick\\
\small TU Dortmund University\\
\small \texttt{thomas.schwentick@cs.uni-dortmund.de}
\and 
Thomas Zeume\\
\small TU Dortmund University\\
\small  \texttt{thomas.zeume@cs.uni-dortmund.de}
}


\usepackage{	amssymb,
		amsmath,
		amsthm}

\usepackage{	xspace,
		enumerate,
		gensymb,
		xspace,
		graphicx,
		graphics,
		multirow,
		sidecap,
		enumerate}


\usepackage{	datetime}

\usepackage{	color, 
		colortbl, 
		hhline}

\usepackage{	arydshln}
\usepackage{	pst-node,
		pst-plot,
		pst-pdf}


\usepackage{	rotating}
\usepackage{	tikz}

\usepackage{hyperref}
\usepackage{ifmtarg}
\usepackage{chngcntr}

\clearpage{}\makeatletter{}\newcommand{\acomment}[2]{\ \\ \fbox{\parbox{\linewidth}{{\sc #1}:\\ #2}}}
  

\renewcommand{}{\right )}

\newcommand{\tuple}[2]{\begin{array}{c} #1 \\  #2 \\ \end{array}} 


\newcommand{\amal}[1]{\acomment{Amal}{#1}}
\newcommand{\thz}[1]{\acomment{Thomas Z.}{#1}}
\newcommand{\ts}[1]{\acomment{Thomas S.}{#1}}


\newcommand{\myemph}[1]{\emph{#1}}

\theoremstyle{plain}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{openquestion}{Open Question}
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}
\newenvironment{proofsketch}{\noindent{\bf Proof sketch.}\enspace}{\qed \vspace{2mm}}
\newenvironment{proofof} [1]{\noindent{\bf Proof (of #1).}\enspace}{\qed  \vspace{2mm}}



\makeatletter
\newcommand{\theoremcont}[3]{
   \def\Type{#1}
   \def\Number{#2}
   \def\Label{#3}
   \@ifmtarg{#3}{
     \vspace{2mm}\textbf{\Type\ \Number.}\itshape\noindent
   }{
    \vspace{2mm}\textbf{\Type\ \Number\ (\Label).}\itshape\noindent
  }
}

\newenvironment{applemma}[2]{\theoremcont{Lemma}{#1}{#2}}{}
\newenvironment{apptheorem}[2]{\theoremcont{Theorem}{#1}{#2}}{}
\newenvironment{appcorollary}[2]{\theoremcont{Corollary}{#1}{#2}}{}
\newenvironment{appproposition}[2]{\theoremcont{Proposition}{#1}{#2}}{}
\newenvironment{appexample}[1]{\vspace{2mm}\textit{Example #1.}}{}

\newcommand{\appnewstart}{}
\newcommand{\appnewend}{}


\newcommand{\appnew}[1]{
\marginpar{\appnewstart}
#1
\marginpar{\appnewend}
}

\newcommand{\fo}{\ensuremath{\mathrm{FO}}\xspace}
\newcommand{\fotwo}{\ensuremath{\mathrm{FO}^2}\xspace}
\newcommand{\mso}{\ensuremath{\mathrm{MSO}}\xspace}
\newcommand{\emso}{\ensuremath{\mathrm{EMSO}}\xspace}
\newcommand{\emsotwo}{\ensuremath{\mathrm{EMSO}^2}\xspace}

\newcommand{\odw}{ordered data word\xspace}
\newcommand{\odws}{ordered data words\xspace}
\newcommand{\tpo}{total preorder\xspace}
\newcommand{\tpos}{total preorders\xspace}
\newcommand{\tlo}{linear order\xspace}
\newcommand{\tlos}{linear orders\xspace}
\newcommand{\pro}[1]{\mathsf{pro}(#1)}

\newcommand{\lp}[1]{\mathit{sp}(#1)}
\newcommand{\pp}[1]{\mathit{pp}(#1)}
\newcommand{\msp}[1]{\mathit{msp}(#1)}
\newcommand{\pomsp}[1]{\mathit{msp}_{\po}(#1)}

\newcommand{\prop}{\calP}
\newcommand{\schema}{\tau}
\newcommand{\ordstruc}{\text{FinOrd}}
\newcommand{\ann}[2]{\mathsf{ann}(#1, #2)}
\newcommand{\annpp}[2]{\mathsf{annpp}_{\po, \psucc}(#1, #2)}
\newcommand{\annSigma}{\Sigma_\mathsf{ann}}


\newcommand{\poann}[2]{\mathsf{ann}_{\po}(#1, #2)}
\newcommand{\poannpp}[2]{\mathsf{annpp}_{\po}(#1, #2)}
\newcommand{\poenc}[2]{\mathsf{enc}(#1, #2)}


\newcommand{\marking}{\mathsf{m}}
\newcommand{\pomarking}{\mathsf{m^\po}}
\newcommand{\mSigma}{\Sigma^{\psucc, \po}_M}
\newcommand{\mpoSigma}{\Sigma^{\po}_M}

\newcommand {\nat}      {\mathbb{N}}
\newcommand {\rat}      {\mathbb{Q}}
\newcommand {\domain}	{\mathbb{D}}

\renewcommand{\hat}[1]{\widehat{#1}}
\newcommand{\df}{\ensuremath{\mathrel{\smash{\stackrel{\scriptscriptstyle{
    \text{def}}}{=}}}}}


\newcommand{\po}[1][]{\ensuremath{\leq_{p_{#1}}}}
\newcommand{\spo}[1][]{\ensuremath{<_{p_{#1}}}}
\newcommand{\lo}[1][]{\ensuremath{\leq_{l_{#1}}}}
\newcommand{\slo}[1][]{\ensuremath{<_{l_{#1}}}}
\newcommand{\psim}[1][]{\ensuremath{\sim_{p_{#1}}}}

\newcommand{\llpo}{\ensuremath{{\ll_{p}}}}



\newcommand{\psucc}[1][]{\ensuremath{{+1}_{p_{#1}}}}
\newcommand{\ps}[3][]{\ensuremath{{+1}_{p_{#1}} (#2, #3)}}
\newcommand{\ls}[3][]{\ensuremath{{+1}_{l_{#1}} (#2, #3)}}
\newcommand{\lds}[3][]{\ensuremath{{+2}_{l_{#1}} (#2, #3)}}
\newcommand{\peq}[3][]{\ensuremath{#2 \sim_{p_{#1}}#3}}

\newcommand{\spsucc}[1][]{\ensuremath{+1^s_{p_{#1}}}}
\newcommand{\lsucc}[1][]{\ensuremath{{+1_{l_{#1}}}}}
\newcommand{\ldsucc}[1][]{\ensuremath{+2_{l_{#1}}}}



\newcommand {\cA}      {{\cal A}\xspace}
\newcommand {\cF}      {{\cal F}\xspace}

\newcommand {\calA}      {{\cal A}\xspace}

\newcommand {\calB}      {{\cal B}\xspace}
\newcommand {\calC}      {{\cal C}\xspace}
\newcommand {\calD}      {{\cal D}\xspace}
\newcommand {\calE}      {{\cal E}\xspace}
\newcommand {\calF}      {{\cal F}\xspace}
\newcommand {\calM}      {{\cal M}\xspace}
\newcommand {\calN}      {{\cal N}\xspace}
\newcommand {\calP}      {{\cal P}\xspace}
\newcommand {\calR}      {{\cal R}\xspace}
\newcommand {\calS}      {{\cal S}\xspace}
\newcommand {\calT}      {{\cal T}\xspace}
\newcommand {\calU}      {{\cal U}\xspace}
\newcommand {\calL}      {{\cal L}\xspace}
\newcommand {\calO}      {{\cal O}\xspace}
\newcommand {\calV}      {{\cal V}\xspace}
\newcommand {\calW}      {{\cal W}\xspace}

\newcommand  {\N}   {\ensuremath{\mathbb{N}}}
\newcommand  {\B}   {\ensuremath{\mathbb{B}}}

\newcommand{\inc}{\ensuremath{\text{inc}}}
\newcommand{\dec}{\ensuremath{\text{dec}}}
\newcommand{\ifzero}{\ensuremath{\text{ifzero}}}
\newcommand{\ifz}{\ifzero}


\newcommand  {\myclass} [1]  {\ensuremath{\mbox{\sc #1}}\xspace}

\newcommand  {\TIME}    {\myclass{TIME}}
\newcommand  {\DTIME}   {\myclass{DTIME}}
\newcommand  {\NTIME}   {\myclass{NTIME}}
\newcommand  {\ATIME}   {\myclass{ATIME}}
\newcommand  {\SPACE}   {\myclass{SPACE}}
\newcommand  {\DSPACE}   {\myclass{DSPACE}}
\newcommand  {\NSPACE}  {\myclass{NSPACE}}
\newcommand  {\coNSPACE}        {\myclass{coNSPACE}}
\newcommand     {\LOGCFL}     {\myclass{LOGCFL}}
\newcommand     {\LOGDCFL}     {\myclass{LOGDCFL}}
\newcommand     {\LOGSPACE}     {\myclass{LOGSPACE}}
\newcommand     {\NLOGSPACE}     {\myclass{NLOGSPACE}}
\newcommand     {\classL}   {\myclass{L}}
\newcommand     {\NL}   {\myclass{NL}}
\newcommand     {\coNL}   {\myclass{coNL}}
\renewcommand   {\P}    {\myclass{P}}
\newcommand     {\myP}    {\myclass{P}}
\newcommand     {\PTIME}    {\myclass{PTIME}}
\newcommand     {\NP}   {\myclass{NP}}
\newcommand     {\NPC}   {\myclass{NPC}}
\newcommand     {\PH}   {\myclass{PH}}
\newcommand     {\coNP} {\myclass{coNP}}
\newcommand     {\NPSPACE}      {\myclass{NPSPACE}}
\newcommand     {\PSPACE}       {\myclass{PSPACE}}
\newcommand     {\IP}   {\myclass{IP}}
\newcommand     {\POLYLOGSPACE} {\myclass{POLYLOGSPACE}}
\newcommand     {\DET}  {\myclass{DET}}
\newcommand     {\EXP}  {\myclass{EXP}}
\newcommand     {\NEXP}  {\myclass{NEXP}}
\newcommand     {\EXPTIME}  {\myclass{EXPTIME}}
\newcommand     {\TWOEXPTIME}  {\myclass{2-EXPTIME}}
\newcommand     {\TWOEXP}  {\myclass{2-EXP}}
\newcommand     {\NEXPTIME}  {\myclass{NExpTime}}
\newcommand     {\coNEXPTIME}  {\myclass{coNEXPTIME}}
\newcommand     {\EXPSPACE}  {\myclass{ExpSpace}}
\newcommand     {\RP}   {\myclass{RP}}
\newcommand     {\RL}   {\myclass{RL}}
\newcommand     {\coRP} {\myclass{coRP}}
\newcommand     {\ZPP}  {\myclass{ZPP}}
\newcommand     {\BPP}  {\myclass{BPP}}
\newcommand     {\PP}   {\myclass{PP}}
\newcommand     {\NC}   {\myclass{NC}}
\newcommand     {\AC}   {\myclass{AC}}
\newcommand     {\SAC}   {\myclass{SAC}}
\newcommand     {\ACC}   {\myclass{ACC}}
\newcommand     {\tc}   {\myclass{TC}}   \newcommand     {\PPoly}{\myclass{\mbox{P}/\mbox{Poly}}} 
\newcommand     {\FO}   {\myclass{FO}}
\newcommand     {\NLIN}   {\myclass{NLIN}}
\newcommand     {\DLIN}   {\myclass{DLIN}}

\newcommand  {\APTIME}   {\myclass{APTIME}}
\newcommand  {\ALOGSPACE}   {\myclass{ALOGSPACE}}


\newcommand  {\problemdescr} [3] {
    \vspace{3mm}
    \def\Name{#1}
    \def\Input{#2}
    \def\Question{#3}
	  \hspace{5mm}\begin{tabular}{r p{11cm}r}	    \textit{Problem:} & \textsc{\Name} \\
	    \textit{Input:} & \Input \\
	    \textit{Question:} & \Question
 	  \end{tabular}
    \vspace{3mm}
    }
\newcommand  {\problem} [1] {    \textsc{#1}  }

\newcommand{\mytheo}[1]{\bf{#1}}
\newcommand{\dw}{\ensuremath{\leftarrow}}
\newcommand{\de}{\ensuremath{\rightarrow}}
\newcommand{\dn}{\ensuremath{\uparrow}}
\newcommand{\ds}{\ensuremath{\downarrow}}
\newcommand{\dsw}{\ensuremath{\swarrow}}
\newcommand{\dse}{\ensuremath{\searrow}}
\newcommand{\dne}{\ensuremath{\nearrow}}
\newcommand{\dnw}{\ensuremath{\nwarrow}}

\newcommand {\sfmin} {\ensuremath{\mathsf{min}}}
\newcommand {\sfmax} {\ensuremath{\mathsf{max}}}


\newcommand*\colvec[3][]{
    \begin{pmatrix}\ifx\relax#1\relax\else#1\\\fi#2\\#3\end{pmatrix}
}
\clearpage{}


\begin{document}


\maketitle

\begin{abstract}
  The finite satisfiability problem of two-variable logic extended by a linear order successor and a preorder successor is shown to be undecidable.
\end{abstract}


  \makeatletter{}The decidability of the finite satisfiability problem of two-variable logic extended by orders and preorders  as well as their corresponding successor relations has been currently investigated by several papers \cite{Manuel10, SchwentickZ11, ManuelZ13}. This short note extends \cite{ManuelZ13} which is work under submission. In the setting of \cite{ManuelZ13} only two cases remained open. One of them, namely the extension of two-variable logic by one successor relation of a linear order and one successor relation of a preorder, is settled here. We refer to \cite{Manuel10} and \cite{SchwentickZ11} for more background and motivation.

In the rest of this note we first introduce the necessary notation and then prove that the finite satisfiability problem of the extension of two-variable logic by one successor relation of a linear order and one successor relation of a preorder is undecidable.

\section{Notations}
A binary relation  over a finite set\footnote{In this note all sets are finite.}  is a \myemph{preorder} if it is reflexive, transitive and total, that is, if for all elements , and  from  (i)  (ii)  and  implies  and (iii)  or   holds. A \myemph{\tlo}  on  is an antisymmetric total preorder, that is, if  and  then .

Thus, the essential difference between a \tpo and a \tlo is that the former allows for two distinct elements  and  that both   and  hold. We call two such elements \myemph{equivalent with respect to } and denote this by .
Hence, a \tpo can be seen as an equivalence relation  whose equivalence classes are linearly ordered by a linear order. Clearly, every \tlo is a \tpo with equivalence classes of size one. We write   if  but not , analogously for a preorder order . Further, if  and  are the equivalence classes of  and , respectively, then we write  if .

For a linear order  an induced \myemph{successor relation}  can be defined in the usual way, namely by letting  if and only if  and there is no  with . Similarly a preorder  induces a successor relation  based on the linear order on its equivalence classes, i.e.  if  and only if  and there is no  with . Thus an element can have several successor elements in . 


An \myemph{ordered structure} is a finite structure with non-empty universe and some linear orders, some total preorders, some successor relations and some unary relations. Linear orders and their induced successor relations will be denoted by  and , respectively. Analogously, preorders  and their induced successor relations will be denoted by  and , respectively. For a set of binary relation symbols , an -structure is a finite structure with some unary relations and some binary relations of types indicated by . For example an -structure is a structure with some unary relations and, following the conventions from above, a linear order successor and a preorder successor.

\myemph{Two-variable logic}  is the restriction of first-order logic to formulas with at most two distinct variable  and . By  we denote two-variable logic over a vocabulary that contains some unary relation symbols and binary relation symbols from  which have to be interpreted by -structures. For example, formulas in  can use some unary relation symbols and the binary relation symbols  and , where   and  have to be interpreted as a linear successor and a preorder successor. 


 
  \makeatletter{}\section{Result}

\makeatletter{}\newcommand{\theoremlsps}{
  \begin{theorem} \label{prop:lsps}
    Finite satisfiability of  is undecidable. 
  \end{theorem}
}

\newcommand{\prooftextlsps}{
  We use the following notions. An element  is a \myemph{-successor} of an element  if  and . Observe that there does not need to be a -successor and that it is unique if it exists. Similarly  is a \myemph{-predecessor} of  if  and . 

  The proof is by a reduction from the non-emptiness problem for Minsky counter automata with two counters only.    
  Intuitively, from a given CA  with set  of counters (we refer to  and  as the red and blue counter in the following), we construct a -formula  such that for every accepting run 
 of  there is a -structure  that satisfies , and such that from 
every model of  an accepting run of  can be constructed. The formula  uses as propositions the set  of 
transitions of , the propositions . We will often say color instead of proposition.

 An accepting run  of  will be encoded as a -structure  as follows.  The idea is to represent configurations by equivalence classes with respect to , to encode transitions by propositions and counter values by the number of red and blue elements in a class. 

We will always assume in the following that  is non-trivial and thus  has at least one step.
More precisely, let,   for every ,  with  and  and  be the transition applied in the -th step. Let  be large enough such that for every configuration the value of the red counter plus the value of the blue counter is at most .
The intended structure  has exactly one -class  for each configuration . 
For every ,  has exactly  elements of which  elements carry the proposition  and  elements carry the proposition . The sets of -elements and of -elements are disjoint. 
The relation  induces bijections between successive -classes with the following additional properties. As the counter values of  can change by at most one in one step, the number of blue (or red) elements in successive classes at most differs by one. The relation  can thus be chosen such that 
\begin{itemize}
\item it is a bijection between the blue elements in  and
  , if  does not change the blue counter,
\item it is a bijection between the blue elements of  and the blue
  elements of  minus one, in case  increments
  the blue counter, and
\item  it is a bijection between the blue elements of  minus one and the blue
  elements of , in case  decrements
  the blue counter
\end{itemize}
Likewise for the red counter and red elements.  Furthermore, each element of  carries the transition  that yielded it from the previous configuration (with the exception of ).  



 We now state conditions (T1-T5), (B1-B5) and (R1-R5) that hold in a structure  if and only if it is (isomorphic to) a structure , for some accepting run .  The conditions (T1-T5) ensure the general structure of , the consistency of successive transitions and the initial and final state. Conditions (B1-B5) ensure that the counter values, i.e. the number of -labeled elements, are consistent with the transitions. Likewise for (R1-R5).

  \begin{itemize}
    \item[(T1)] Every element that is not in the first -class, carries exactly one label from , and all elements of a -class carry the same -label.    \item[(T2)] Elements of the second -class are labeled with a transition starting from the start state. 
    \item[(T3)] Elements of the last -class are labeled with a transition leading to a final state.  
    \item[(T4)] Transitions of successive -classes are consistent, i.e. if ,  are labeled with  and ,
and  , then .
   \item[(T5)] Every element that is not in the last -class has a -successor and every element that is not in the first class has a -predecessor.
  \end{itemize}

  \begin{itemize}
    \item[(B1)] Neither there are -labeled elements in the first -class nor in the last \psucc-class.
      \item[(B2)] If some element  carries a transition from  that does not change the -counter then  induces a bijection between the -labeled elements of the class of  and  the -labeled elements of its \psucc-predecessor class.
    \item[(B3)] If some element  carries a transition from  that increments the -counter, then 
      \begin{itemize}
	\item there is exactly one -labeled element  with  whose \lsucc-predecessor is not -labeled and
        \item  induces a bijection between the set of all other -labeled elements of the class of  and the -labeled elements of its \psucc-predecessor class.
    \end{itemize}
    \item[(B4)] If some element  carries a transition from  that decrements the -counter, then
      \begin{itemize}
	\item there is exactly one -labeled element  with  whose \lsucc-successor is not -labeled and
        \item  induces a bijection between the set of all other -labeled elements of the  predecessor class of  and the -labeled elements of 's class.
    \end{itemize}
      \item[(B5)] If some element  carries a transition that tests whether the -counter is equal to zero, then there is no -labeled element  with .
  \end{itemize}

(R1)-(R5) are as (B1)-(B5) with ``blue'' replaced by ``red'', throughout. 

  For proving the correctness of this construction, we first observe that the -structure  constructed from a given accepting run  as explained above, clearly satisfies all these conditions.


  Now, let  be a structure that satifies all conditions. Let  be the -classes of  in increasing order. By property (T1) there is, for every , a single transition  that labels all elements from . Let, for every ,  and  be the number of - and -labeled elements in . We claim that  with  and, for every , , is an accepting run of . The states  and  are consistent with  for all ; and  is an initial state and  is a final state, by properties (T2)-(T4). 


Thus it remains to verify that the counter values in  are consistent with the transitions. By (B1), both counters are zero in . By induction over , it can be shown that  is consistent with  with respect to the counter values. Condition (B2) ensures that  if  does not change the blue counter. Likewise, (B3) and (B4), respectively, ensure that   if  increments the counter and   if  decrements the counter. Finally, (B5) ensures that zero test transitions for the blue counter are only taken if . The correctness of the values of the red counter can be proved analogously.

It remains to show that  (T1-T5), (B1-B5) and (R1-R5) can be expressed by  formulas.
  
Conditions (T2)-(T5), (B1), (B2) and (B5) can be easily expressed by such formulas. 

We describe next how to construct a formula  that expresses that in the -class of  some element exists for which some unary formula  holds. The idea is simply to state that for some \psucc-predecesssor of a \psucc-successor of  it holds  or  for some \psucc-successsor of a \psucc-predeccessor of  it holds . Here, we make use of our assumption that  has at least two \psucc-classes.
That is, we define  as . It should be stressed that the quantification might bind  to some other element in the class of the ``original'' . Likewise, we let  be  and . 

In this way, a formula for (T1) is readily definable. For the second part of (T1) it is stated that there is no element in the current class with some other transition proposition. 


For the construction of the other formulas, we assume that (T1) and (T5) hold. 

The challenge when expressing (B3) is to make sure that there is exactly one -labeled element in the current class that does not take part in the bijection induced by . However, this can be expressed by stating that
\begin{enumerate}[(1)]
\item every -labeled \psucc-predecessor of the current element has a -labeled \lsucc-successor, and
\item there is a \psucc-predecessor of the current element  that is not -labeled but has a -labeled \lsucc-successor, but
\item all -labeled \psucc-successors of  besides 's \lsucc-successor have a -labeled \lsucc-predecessor.
\end{enumerate}
This condition can be easily expressed by a  formula.
Condition (B4) can be expressed analogously.
}

\newcommand{\prooflsps}{
  \begin{proof}
    \prooftextlsps
  \end{proof}
}

\newcommand{\proofoflsps}{
  \begin{proofof}{Theorem \ref{prop:lsps}}
    \prooftextlsps
  \end{proofof}
}

 

In this section we prove the only result of this note.
\theoremlsps

The proof is by a reduction from the non-emptiness problem for Minsky counter automata. Following \cite{BojanczykMSS2009}, a \myemph{Minsky counter automaton} (short: CA) is essentially a finite state automaton without input but equipped with a finite set of counters which can be incremented, decremented and tested for zero. More formally, a CA  is a tuple , where the set  of states, the initial state  and the set  of final states are as in usual finite state automata, and  is a finite set (the \myemph{counters}). The transition relation  is a subset of  

A \myemph{configuration} of a CA is a pair  where  is a state and  gives a value  for each counter  in . 
Transitions with  can be always applied, whereas transitions with  can only be applied to configurations with  and 
transitions with  can only be applied if . Applying a transition  to a configuration  yields 
a configuration  where  is obtained from  by incrementing  and keeping all other values unchanged. Analogously, applying a (applicable) transition  to a configuration  yields a configuration  where  is obtained from  by decrementing . Applying an (applicable) transition  to a configuration  yields configuration . A \myemph{run} is a sequence of configurations consistent with . A run is \myemph{accepting}, if it starts at configuration  and ends in some configuration  with . Without loss of generality we require that the counter values in the last configuration of an accepting run are equal to zero.

The emptiness problem for CA is the question whether a given CA has an accepting run. It is well known that the emptiness problem for CA with two counters is undecidable \cite{Minsky1967}.

\proofoflsps
 

We strongly conjecture that finite satisfiability for the other remaining open case from \cite{ManuelZ13}, namely the extension of two variable logic by one preorder relation and one successor relation of a linear order, is decidable. We are actually working on the details of the proof. However, we felt that the result presented in this note should be made public without further delay. 
  


\bibliography{bibliography}



\end{document}
