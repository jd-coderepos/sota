\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{iccv}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}


\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{import}
\usepackage{subcaption}


\iccvfinalcopy 

\def\iccvPaperID{2112} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}
\def\clstoken{\texttt{CLS}\xspace}
\def\patchtoken{\texttt{Patch}\xspace}
\def\ours{CrossViT\xspace}


\newcommand{\rc}[1]{{\color{blue}{\small\bf\sf [Richard: #1]}}}
\newcommand{\rp}[1]{{\color{magenta}{\small\bf\sf [Rameswar: #1]}}}
\newcommand{\QF}[1]{{\color{red}{\small\bf\sf [Quanfu: #1]}}}
\newcommand{\boldblue}[1]{{\color{blue}{\textbf{#1}}}}
\newcommand{\myparagraph}[1]{\vspace{1mm} \noindent {\textbf{#1}}}
\newcommand{\myparagraphfirst}[1]{\vspace{0mm} \noindent {\textbf{#1}}}


\ificcvfinal\pagestyle{empty}\fi

\graphicspath{{Main/},{Supplemental/}}
\newcommand*\InputTable[1]{\input{Tables/#1.tex}}

\begin{document}

\title{CrossViT: Cross-Attention Multi-Scale Vision Transformer for Image Classification}

\author{Chun-Fu (Richard) Chen, Quanfu Fan, Rameswar Panda\\
MIT-IBM Watson AI Lab\\
{\tt\small chenrich@us.ibm.com, qfan@us.ibm.com, rpanda@ibm.com}
}

\maketitle
\ificcvfinal\thispagestyle{empty}\fi

\begin{abstract}
The recently developed vision transformer (ViT) has achieved promising results on image classification compared to convolutional neural networks. Inspired by this, in this paper, we study how to learn multi-scale feature representations in transformer models for image classification. To this end, we propose a dual-branch transformer to combine image patches (i.e., tokens in a transformer) of different sizes to produce stronger image features. Our approach processes small-patch and large-patch tokens with two separate branches of different computational complexity and these tokens are then fused purely by attention multiple times to complement each other. Furthermore, to reduce computation, we develop a simple yet effective token fusion module based on cross attention, which uses a single token for each branch as a query to exchange information with other branches. Our proposed cross-attention only requires linear time for both computational and memory complexity instead of quadratic time otherwise. Extensive experiments demonstrate that our approach performs better than or on par with several concurrent works on vision transformer, in addition to efficient CNN models. For example, on the ImageNet1K dataset, with some architectural changes, our approach outperforms the recent DeiT by a large margin of 2\% with a small to moderate increase in FLOPs and model parameters. Our source codes and models are available at \url{https://github.com/IBM/CrossViT}.















   
\end{abstract}

\section{Introduction}
\label{sec:intro}


\begin{figure}[tb!]
    \centering
    \includegraphics[width=.9\linewidth]{./Main/Figures/Comparison}
    \caption{\textbf{Improvement of our proposed approach over DeiT~\cite{DeiT_touvron2020} and ViT~\cite{ViT_dosovitskiy2021an}}. The circle size is proportional to the model size. All models are trained on ImageNet1K from scratch. The results of ViT are referenced from~\cite{tokenstotoken_yuan2021}.
}  
    \label{fig:perf_comp} 
\end{figure}


The novel transformer architecture~\cite{Transformer_NIPS2017_Vaswani} has led to a big leap forward in capabilities for sequence-to-sequence modeling in NLP tasks~\cite{devlin2018bert}. The great success of transformers in NLP has sparked particular interest from the vision community in understanding whether transformers can be a strong competitor against the dominant Convolutional Neural Network based architectures (CNNs) in vision tasks such as ResNet~\cite{ResNet_He_2016_CVPR} and EfficientNet~\cite{efficientnet_pmlr_tan_19}. Previous research  efforts on transformers in vision have, until very recently,  been largely focused on combining CNNs with self-attention~\cite{bello2019attention, SAN_Zhao_2020_CVPR, SASA_Ramachandran_2019_NeurIPS, BoT_srinivas2021}. While these hybrid approaches achieve promising performance, they have limited scalability in computation compared to purely attention-based transformers. Vision Transformer (ViT)~\cite{ViT_dosovitskiy2021an}, which uses a sequence of embedded image patches as input to a standard transformer, is the first kind of convolution-free transformers that demonstrate comparable performance to CNN models. However, ViT requires very large datasets such as ImageNet21K~\cite{imagenet_deng2009} and JFT300M~\cite{JFT300M_ICCV_2017} for training. DeiT~\cite{DeiT_touvron2020} subsequently shows that data augmentation and model regularization can enable training of high-performance ViT models with fewer data. Since then, ViT has instantly inspired several attempts to improve its efficiency and effectiveness from different aspects~\cite{DeiT_touvron2020, tokenstotoken_yuan2021, TNT_han2021transformer,PVT_wang2021, perceiver_jaegle2021}.

Along the same line of research on building stronger vision transformers, in this work, we study \textit{how to learn multi-scale feature representations in transformer models for image recognition}. Multi-scale feature representations have proven beneficial for many vision tasks~\cite{chen2018big,cai2016unified,lin2017feature,SKNet_Li_2019_CVPR,hourglass,Deblurring_Nah_2017_CVPR,HigherHRNet_Cheng_2020_CVPR}, but such potential benefit for vision transformers remains to be validated. Motivated by the effectiveness of multi-branch CNN architectures such as Big-Little Net~\cite{chen2018big} and Octave convolutions~\cite{chen2019drop}, we  propose  a  dual-branch  transformer  to  combine image  patches  (i.e. tokens  in  a  transformer)  of  different sizes  to  produce  stronger visual features for image classification. Our approach processes  small and large patch tokens with two separate  branches of different computational complexities and  these  tokens are fused together multiple times to  complement each other. Our main focus of this work is to develop feature fusion methods that are appropriate for vision transformers, which has not been addressed to the best of our knowledge. We do so by an efficient cross-attention module, in which each transformer branch creates a non-patch token as an agent to exchange information with the other branch by attention.  This allows for linear-time  generation  of  the  attention  map  in fusion instead of quadratic time otherwise. With some proper architectural adjustments in computational loads of each branch, our proposed approach outperforms DeiT~\cite{DeiT_touvron2020} by a large margin of 2\% with a small to moderate increase in FLOPs and model parameters (See Figure~\ref{fig:perf_comp}).


The main contributions of our work are as follows:
\begin{itemize}
    \item We propose a novel dual-branch vision transformer to extract multi-scale feature representations for image classification. Moreover, we develop a simple yet effective token fusion scheme based on cross-attention, which is linear in both computation and memory to combine features at different scales. 
\item Our approach performs better than or on par with several concurrent works based on ViT~\cite{ViT_dosovitskiy2021an}, and demonstrates comparable results with EfficientNet~\cite{efficientnet_pmlr_tan_19} with regards to accuracy, throughput and model parameters. \end{itemize}
     \section{Related Works}
\label{sec:related_works}

Our work relates to three major research directions: convolutional neural networks with attention, vision transformer and multi-scale CNNs. Here, we focus on some representative methods closely related to our work.

\vspace{0.5mm}
\myparagraphfirst{CNN with Attention.} Attention has been widely used in many different forms to enhance feature representations, e.g., SENet~\cite{SENet_Hu_2018} uses channel-attention, CBAM~\cite{CBAM_Woo_2018_ECCV} adds the spatial attention and ECANet~\cite{ECA_wang2020} proposes an efficient channel attention to further improve SENet. There has also been a lot of interest in combining CNNs with different forms of self-attention~\cite{lambdanetworks_bello2021,BoT_srinivas2021,SAN_Zhao_2020_CVPR,SASA_Ramachandran_2019_NeurIPS,bello2019attention,hu2019local,wang2018non}. SASA~\cite{SASA_Ramachandran_2019_NeurIPS} and SAN~\cite{SAN_Zhao_2020_CVPR} deploy a local-attention layer to replace convolutional layer. Despite promising results, prior approaches limited the attention scope to local region due to its complexity. LambdaNetwork~\cite{lambdanetworks_bello2021} recently introduces an efficient global attention to model both content and position-based interactions that considerably improves the speed-accuracy tradeoff of image classification models.
BoTNet~\cite{BoT_srinivas2021} replaced the spatial convolutions with global self-attention in the final three bottleneck blocks of a ResNet resulting in models that achieve a strong performance for image classification on ImageNet benchmark.
In contrast to these approaches that mix convolution with self-attention, our work is built on top of pure self-attention network like Vision Transformer~\cite{ViT_dosovitskiy2021an} which has recently shown great promise in several vision applications. 

\myparagraph{Vision Transformer.} Inspired by the success of Transformers~\cite{Transformer_NIPS2017_Vaswani} in machine translation, convolution-free models that only rely on transformer layers have gone viral in computer vision. In particular, Vision Transformer (ViT)~\cite{ViT_dosovitskiy2021an} is the first such example of a transformer-based method to match or even surpass CNNs for image classification. Many variants of vision transformers have also been recently proposed that uses distillation for data-efficient training of vision transformer~\cite{DeiT_touvron2020}, pyramid structure like CNNs~\cite{PVT_wang2021}, or self-attention to improve the efficiency via learning an abstract representation instead of performing all-to-all self-attention~\cite{centroidvit_wu2021}. Perceiver~\cite{perceiver_jaegle2021} leverages an asymmetric attention mechanism to iteratively distill inputs into a tight latent bottleneck, allowing it to scale to handle very large inputs. T2T-ViT~\cite{tokenstotoken_yuan2021} introduces a layer-wise Tokens-to-Token (T2T) transformation to encode the important local structure for each token instead of the naive tokenization used in ViT~\cite{ViT_dosovitskiy2021an}.
Unlike these approaches, we propose a dual-path architecture to extract multi-scale features for better visual representation with vision transformers.



\myparagraph{Multi-Scale CNNs.} Multi-scale feature representations have a long  history in computer vision (e.g., image pyramids~\cite{adelson1984pyramid}, scale-space representation~\cite{perona1990scale}, and coarse-to-fine approaches~\cite{pedersoli2015coarse}).
In the context of CNNs, multi-scale feature representations have been used for detection and recognition of objects at multiple scales~\cite{cai2016unified,lin2017feature,yang2015multi,newell2016stacked}, as well as to speed up neural networks in Big-Little Net~\cite{chen2018big} and OctNet~\cite{chen2019drop}. bLVNet-TAM \cite{fan2019more} uses a two-branch multi-resolution architecture while learning temporal dependencies across frames. SlowFast Networks~\cite{feichtenhofer2019slowfast} rely on a similar two-branch model, but each branch encodes different frame rates, as opposed to frames with different spatial resolutions. While multi-scale features have shown to benefit CNNs, it's applicability for vision transformer still remains as a novel and largely under-addressed problem. 





 \section{Method}
\label{sec:proposed}
Our method is built on top of vision transformer~\cite{ViT_dosovitskiy2021an}, so we first present a brief overview of ViT and then describe our proposed method (\ours) for learning multi-scale features for image classification.

\begin{figure}[tb!]
    \centering
    \includegraphics[width=\linewidth]{./Figures/cross_attention}
    \caption{\textbf{An illustration of our proposed transformer architecture for learning multi-scale features with cross-attention (\ours).} Our architecture consists of a stack of  multi-scale transformer encoders. Each multi-scale transformer encoder uses two different branches to process image tokens of different sizes ( and , ) and fuse the tokens at the end by an efficient module based on cross attention of the \clstoken tokens. Our design includes different numbers of regular transformer encoders in the two branches (i.e. N and M) to balance computational costs. 
    }
    \label{fig:cross_attention} 
\end{figure}

\subsection{Overview of Vision Transformer}

Vision Transformer (ViT)~\cite{ViT_dosovitskiy2021an} first converts an image into a sequence of patch tokens by dividing it with a certain patch size and then linearly projecting each patch into tokens.  An additional classification token (\clstoken) is added to the sequence, as in the original BERT~\cite{devlin2018bert}.
Moreover, since self-attention in the transformer encoder is position-agnostic and vision applications highly need position information, ViT adds position embedding into each token, including the \clstoken token. Afterwards, all tokens are passed through stacked transformer encoders and finally the \clstoken token is used for classification. A transformer encoder is composed of a sequence of blocks where each block contains multiheaded self-attention () with a feed-forward network (). 
 contains two-layer multilayer perceptron with expanding ratio  at the hidden layer, and one GELU non-linearity is applied after the first linear layer.
Layer normalization () is applied before every block, and residual shortcuts after every block. 
The input of ViT, , and the processing of the -th block can be expressed as


where  and  are the \clstoken and patch tokens respectively and  is the position embedding.  and  are the number of patch tokens and dimension of the embedding, respectively. 


\begin{figure*}[tbh!]
    \centering
    \includegraphics[width=\linewidth]{./Figures/fusions}
\caption{\textbf{Multi-scale fusion}. 
    (a) All-attention fusion where all tokens are bundled together without considering any characteristic of tokens. 
    (b) Class token fusion, where only \clstoken tokens are fused as it can be considered as global representation of one branch. (c) Pairwise fusion, where tokens at the corresponding spatial locations are fused together and \clstoken are fused separately. (d) Cross-attention, where \clstoken token from one branch and patch tokens from another branch are fused together. 
    }
    \label{fig:fusions} 
\end{figure*}

It is worth noting that one very different design of ViT from CNNs is the \clstoken token. In CNNs, the final embedding is usually obtained by averaging the features over all spatial locations while ViT uses the \clstoken that interacts with patch tokens at every transformer encoder as the final embedding. Thus, we consider \clstoken as an agent that summarizes all the patch tokens and hence the proposed module is designed based on \clstoken to form a dual-path multi-scale ViT.

\subsection{Proposed Multi-Scale Vision Transformer}
\label{subsec:crossvit_overview}
The granularity of the patch size affects the accuracy and complexity of ViT; with fine-grained patch size, ViT can perform better but results in higher FLOPs and memory consumption. For example, the ViT with a patch size of 16 outperforms the ViT with a  patch size of 32 by 6\% but the former needs 4 more FLOPs. Motivated by this, our proposed approach is trying to leverage the advantages from more fine-grained patch sizes while balancing the complexity. More specifically, we first introduce a dual-branch ViT where each branch operates at a different scale (or patch size in the patch embedding) and then propose a simple yet effective module to fuse information between the branches.

Figure~\ref{fig:cross_attention} illustrates the network architecture of our proposed Cross-Attention Multi-Scale Vision Transformer (\ours). Our model is primarily composed of  multi-scale transformer encoders where each encoder consists of two branches: (1) \textbf{L-Branch}: a \textit{large (primary)} branch that utilizes coarse-grained patch size () with more transformer encoders and wider embedding dimensions, (2) \textbf{S-Branch}: a \textit{small (complementary)} branch that operates at fine-grained patch size () with fewer encoders and smaller embedding dimensions. Both branches are fused together  times and the \clstoken tokens of the two branches at the end are used for prediction. 
Note that for each token of both branches, we also add a learnable position embedding before the multi-scale transformer encoder for learning position information as in ViT~\cite{ViT_dosovitskiy2021an}.

Effective feature fusion is the key for learning multi-scale feature representations. We explore four different fusion strategies: three simple heuristic approaches and the proposed cross-attention module as shown in Figure~\ref{fig:fusions}. Below we provide the details on these fusion schemes. 


\subsection{Multi-Scale Feature Fusion}
\label{subsec:ms_fusion}

Let  be the token sequence (both patch and \clstoken tokens) at branch , where  can be  or  for the large (primary) or small (complementary) branch. 
 and  represent \clstoken and patch tokens of branch , respectively. 

\vspace{1mm}
\myparagraph{All-Attention Fusion.}
A straightforward approach is to simply concatenate all the tokens from both branches without considering the property of each token and then fuse information via the self-attention module, as shown in Figure~\ref{fig:fusions}(a). 
This approach requires quadratic computation time since all tokens are passed through the self-attention module. 
The output  of the all-attention fusion scheme can be expressed as 
 
where  and  are the projection and back-projection functions to align the dimension.

\vspace{1mm}
\myparagraph{Class Token Fusion.} 
The \clstoken token can be considered as an abstract global feature representation of a branch since it is used as the final embedding for prediction. Thus, a simple approach is to sum the \clstoken tokens of two branches, as shown in Figure~\ref{fig:fusions}(b). This approach is very efficient as only one token needs to be processed. Once \clstoken tokens are fused, the information will be passed back to patch tokens at the later transformer encoder. More formally, the output  of this fusion module can be represented as 
 
where  and  play the same role as Eq.~\ref{eq:all_attn}.

\vspace{1mm}
\myparagraph{Pairwise Fusion.} 
Figure~\ref{fig:fusions}(c) shows how both branches are fused in pairwise fusion. Since patch tokens are located at its own spatial location of an image, a simple heuristic way for fusion is to combine them based on their spatial location. However, the two branches process patches of different sizes, thus having different number of patch tokens. We first perform an interpolation to align the spatial size, and then fuse the patch tokens of both branches in a pair-wise manner. On the other hand, the two \clstoken are fused separately. The output  of pairwise fusion of branch  and  can be expressed as
 
where  and  play the same role as Eq.~\ref{eq:all_attn}.


\begin{figure}[tb!]
    \centering
    \includegraphics[width=.7\linewidth]{./Figures/ca_module}
    \caption{\textbf{Cross-attention module for Large branch}. The \clstoken token of the large branch (circle) serves as a query token to interact with the patch tokens from the small branch through attention.
     and  are projections to align dimensions. The small branch follows the same procedure but swaps \clstoken and patch tokens from another branch. 
    }
    \label{fig:ca_module} 
\end{figure}


\myparagraph{Cross-Attention Fusion.}
Figure~\ref{fig:fusions}(d) shows the basic idea of our proposed cross-attention, where the fusion involves the \clstoken token of one branch and patch tokens of the other branch. 
Specifically, in order to fuse multi-scale features more efficiently and effectively, we first utilize the \clstoken token at each branch as an agent to exchange information among the patch tokens from the other branch and then back project it to its own branch. Since the \clstoken token already learns abstract information among all patch tokens in its own branch, interacting with the patch tokens at the other branch helps to include information at a different scale. After the fusion with other branch tokens, the \clstoken token interacts with its own patch tokens again at the next transformer encoder, where it is able to pass the learned information from the other branch to its own patch tokens, to enrich the representation of each patch token. In the following, we describe the cross-attention module for the large branch (L-branch), and the same procedure is performed for the small branch (S-branch) by simply swapping the index  and . 

An illustration of the cross-attention module for the large branch is shown in Figure~\ref{fig:ca_module}. 
Specifically, for branch , it first collects the patch tokens from the S-Branch and concatenates its own \clstoken tokens to them, as shown in Eq.~\ref{eq:ca_1}.

 
where  is the projection function for dimension alignment.
The module then performs cross-attention () between  and , where \clstoken token is the only query as the information of patch tokens are fused into \clstoken token. Mathematically, the  can be expressed as  

where , ,   are learnable parameters,  and  are the embedding dimension and number of heads.
Note that since we only use \clstoken in the query, the computation and memory complexity of generating the attention map () in cross-attention are linear rather than quadratic as in all-attention, making the entire process more efficient. Moreover, as in self-attention, we also use multiple heads in the  and represent it as (). However, we do not apply a feed-forward network  after the cross-attention. 
Specifically, the output  of a cross-attention module of a given  with layer normalization and residual shortcut is defined as follows.

where  and  are the projection and back-projection function for dimension alignment, respectively.
We empirically show in Section~\ref{subsec:ablations} that cross-attention achieves the best accuracy compared to other three simple heuristic approaches while being efficient for mult-scale feature fusion. 

 
 
\section{Experiments}
\label{sec:exp}

In this section, we conduct extensive experiments to show the effectiveness of our proposed \ours over existing methods. First, we check the advantages of our proposed model over the baseline DeiT in Table~\ref{table:baseline}, and then we compare with serveral concurrent ViT variants and CNN-based models in Table~\ref{table:sota} and Table~\ref{table:compare_cnn}, respectively. Moreover, we also test the transferability of \ours on 5 downstream tasks (Table~\ref{table:transfer}). Finally, we perform ablation studies on different fusion schemes in Table~\ref{table:ablation_fusion} and discuss the effect of different parameters of \ours in Table~\ref{table:ablation}.

\subsection{Experimental Setup}
\myparagraphfirst{Dataset.}
We validate the effectiveness of our proposed approach on the ImageNet1K dataset~\cite{imagenet_deng2009}, and use the top-1 accuracy on the validation set as the metrics to evaluate the performance of a model. ImageNet1K contains 1,000 classes and the number of training and validation images are 1.28 millions and 50,000, respectively. 
We also test the transferability of our approach using several smaller datasets, such as CIFAR10~\cite{cifar_krizhevsky2009learning} and CIFAR100~\cite{cifar_krizhevsky2009learning}. 


\myparagraph{Training and Evaluation.}
The original ViT~\cite{ViT_dosovitskiy2021an} achieves competitive results compared to some of the best CNN models but only when trained on very large-scale datasets (e.g. ImageNet21K~\cite{imagenet_deng2009} and JFT300M~\cite{JFT300M_ICCV_2017}). Nevertheless, DeiT~\cite{DeiT_touvron2020} shows that  with the help of a rich set of data augmentation techniques, ViT can be trained from ImageNet alone to produce comparable results to CNN models. Therefore, in our experiments, we build our models based on DeiT~\cite{DeiT_touvron2020}, and apply their default hyper-parameters for training. These data augmentation methods include rand augmentation~\cite{RandAug_NEURIPS2020_Cubuk}, mixup~\cite{Mixup_zhang2018} and cutmix~\cite{CutMix_Yun_2019_ICCV} as well as random erasing~\cite{RandomErasing_Zhong_2020}. We also apply drop path~\cite{efficientnet_pmlr_tan_19} for model regularization but instance repetition~\cite{InstanceRepetition_Hoffer_2020_CVPR} is only enabled for \ours-18 as it does not improve small models. 

We train all our models for 300 epochs (30 warm-up epochs) on 32 GPUs with a batch size of 4,096. Other setup includes a cosine linear-rate scheduler with linear warm-up, an initial learning rate of 0.004 and a weight decay of 0.05. During evaluation, we resize the shorter side of an image to 256 and take the center crop 224224 as the input.
Moreover, we also fine-tuned our models with a larger resolution (384384) for fair comparison in some cases. Bicubic interpolation was applied to adjust the size of the learnt position embedding, and the finetuning took 30 epochs. More details can be found in supplementary material.


\myparagraph{Models.}
Table~\ref{table:models} specifies the architectural configurations of the \ours models used in our evaluation. Among these models, \ours-Ti, \ours-S and \ours-B set their large (primary) branches identical to the tiny (DeiT-Ti), small (DeiT-S) and base (DeiT-B) models introduced in DeiT~\cite{DeiT_touvron2020}, respectively. 
The other models vary by different expanding ratios in  (), depths and embedding dimensions. In particular, the ending number in a model name tells the total number of transformer encoders in the large branch used. For example, \ours-15 has 3 multi-scale encoders, each of which includes 5 regular transformers, resulting in a total of 15 transformer encoders. 

The original ViT paper~\cite{ViT_dosovitskiy2021an} shows that a hybrid approach that generates patch tokens from a CNN model such as ResNet-50 can improve the performance of ViT on the ImageNet1K dataset. Here we experiment with a similar idea by substituting the linear patch embedding in ViT by three convolutional layers as the patch tokenizer. These models are differentiated from others by a suffix  in Table~\ref{table:models}. 

\begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|cccccccccc}
        \toprule
                      Model & Patch  & \multicolumn{2}{c}{Patch size} & \multicolumn{2}{c}{Dimension} & \# of heads &  &  \\
                      & embedding & Small & Large & Small & Large &  \\
        \midrule
        \ours-Ti & Linear & 12 & 16 & 96& 192 & 3 & 4 & 4  \\
        \ours-S & Linear & 12 & 16 & 192& 384 & 6 & 4 & 4  \\
        \ours-B & Linear & 12 & 16 & 384& 768 & 12 & 4 & 4  \\
        \ours-9 & Linear & 12 & 16 & 128& 256 & 4 & 3 & 3  \\
        \ours-15 & Linear & 12 & 16 & 192& 384 & 6 & 5 & 3  \\
        \ours-18 & Linear & 12 & 16 & 224& 448 & 7 & 6 & 3  \\
        \ours-9 & 3 Conv. & 12 & 16 & 128& 256 & 4 & 3 & 3  \\
        \ours-15 & 3 Conv. & 12 & 16 & 192& 384 & 6 & 5 & 3  \\
        \ours-18 & 3 Conv. & 12 & 16 & 224& 448 & 7 & 6 & 3  \\
        
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Model architectures of \ours.} , ,  for all models, and number of heads are same for both branches.
     denotes the number of multi-scale transformer encoders. ,  and  denote the number of transformer encoders of the small and large branches and the cross-attention modules in one multi-scale transformer encoder.  is the expanding ratio of feed-forward network () in the transformer encoder. See Figure~\ref{fig:cross_attention} for details.}
\label{table:models}
\end{table}





%
 \begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|cccc}
        \toprule
             Model   & Top-1 Acc. & FLOPs & Throughput & Params \\ 
                     & (\%) &  (G) & (images/s) & (M) \\
        \midrule
             DeiT-Ti  & 72.2 & 1.3 & 2557 & 5.7 \\
            \ours-Ti & 73.4 (+1.2) & 1.6 & 1668 & 6.9 \\ 
\ours-9 & 73.9 (+0.5) & 1.8 & 1530 & 8.6 \\
             \ours-9 & \textbf{77.1} (+3.2) & 2.0 & 1463 & 8.8 \\






\midrule
            DeiT-S  &  79.8 & 4.6 & 966 & 22.1 \\
            \ours-S &  81.0 (+1.2) & 5.6 & 690 & 26.7 \\
            \ours-15&  81.5 (+0.5) & 5.8 & 640 & 27.4 \\
            \ours-15 & \textbf{82.3} (+0.8) & 6.1 & 626 & 28.2 \\ 
            \midrule


DeiT-B  &  81.8 & 17.6 & 314 & 86.6 \\
            \ours-B &  82.2 (+0.4) & 21.2 & 239 & 104.7\\
\ours-18& 82.5 (+0.3) & 9.0 & 430 & 43.3 \\ 


\ours-18 & \textbf{82.8} (+0.3) & \textbf{9.5} & 418 & 44.3 \\ 
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Comparisons with DeiT baseline on ImageNet1K.} The numbers in the bracket show the improvement from each change. See Table~\ref{table:models} for model details.}
    \label{table:baseline}
\end{table}

%
 \subsection{Main Results}
\myparagraphfirst{Comparisons with DeiT.}
DeiT~\cite{DeiT_touvron2020} is a better trained version of ViT, we thus compare our approach with three baseline models introduced in DeiT, i.e., DeiT-Ti,DeiT-S and DeiT-B. It can be seen from Table~\ref{table:baseline} that \ours improves DeiT-Ti, DeiT-S and DeiT-B by 1.2\%, 1.2\% and 0.4\% points respectively when they are used as the primary branch of \ours. This clearly demonstrates that our proposed cross-attention is effective in learning multi-scale transformer features for image recognition.
By making a few architectural changes (see Table~\ref{table:models}), \ours further raises the accuracy of the baselines by another 0.3-0.5\% point, with only a small increase in FLOPs and model parameters. Surprisingly, the convolution-based embedding provides a significant performance boost to \ours-9 (+3.2\%) and \ours-15 (+0.8\%). As the number of transformer encoders increases, the effectiveness of convolution layers seems to become weaker, but \ours-18 still gains another 0.3\% improvement over \ours-18. We would like to point out that the work of T2T~\cite{tokenstotoken_yuan2021} concurrently proposes a different approach based on token-to-token transformation to address the limitation of linear patch embedding in vision transformer.

Despite the design of \ours is intended for accuracy, the efficiency is also considered. E.g., 
\ours-9 and \ours-15 incur 30-50\% more FLOPs and parameters than the baselines. However, their accuracy is considerably improved by 2.5-5\%. On the other hand, \ours-18 reduces the FLOPs and parameters almost by half compared to DeiT-B while still being 1.0\% more accurate. 






\begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|c|c|c}
        \toprule
             Model   & Top-1 Acc. (\%) & FLOPs (G) & Params (M)  \\ 
        \midrule
            Peceiver~\cite{perceiver_jaegle2021} (arXiv, 2021-03) & 76.4 &  & 43.9 \\
            DeiT-S~\cite{DeiT_touvron2020} (arXiv, 2020-12) & 79.8 & 4.6& 22.1 \\
CentroidViT-S~\cite{centroidvit_wu2021} (arXiv, 2021-02) & 80.9&4.7&22.3 \\
            PVT-S~\cite{PVT_wang2021} (arXiv, 2021-02) &79.8& 3.8&24.5 \\
            PVT-M~\cite{PVT_wang2021} (arXiv, 2021-02) &81.2&6.7&44.2 \\
T2T-ViT-14~\cite{tokenstotoken_yuan2021} (arXiv, 2021-01) & 80.7 & 6.1 & 21.5 \\
            TNT-S~\cite{TNT_han2021transformer} (arXiv, 2021-02) & 81.3& 5.2& 23.8 \\
            \ours-15 (Ours)& 81.5 & 5.8& 27.4 \\
            \ours-15 (Ours) & \textbf{82.3} & 6.1 & 28.2 \\ 
            \midrule
            ViT-B@384~\cite{ViT_dosovitskiy2021an} (ICLR, 2021) & 77.9 & 17.6& 86.6 \\
DeiT-B~\cite{DeiT_touvron2020} (arXiv, 2020-12)& 81.8& 17.6& 86.6 \\
            PVT-L~\cite{PVT_wang2021} (arXiv, 2021-02) &81.7&9.8&61.4 \\
T2T-ViT-19~\cite{tokenstotoken_yuan2021} (arXiv, 2021-01) & 81.4 & 9.8  & 39.0 \\
            T2T-ViT-24~\cite{tokenstotoken_yuan2021} (arXiv, 2021-01) & 82.2 & 15.0  & 64.1 \\
            TNT-B~\cite{TNT_han2021transformer} (arXiv, 2021-02) & \textbf{82.8} & 14.1& 65.6 \\
            \ours-18 (Ours)& 82.5& 9.0 & 43.3 \\ 




            \ours-18 (Ours)& \textbf{82.8} & 9.5 & 44.3 \\ 
\bottomrule
        \multicolumn{4}{l}{\footnotesize : We recompute the flops by using our tools.}
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Comparisons with recent transformer-based models on ImageNet1K.} All models are trained using only ImageNet1K dataset. Numbers are referenced from their recent version as of the submission date.}
    \label{table:sota}
\end{table}
%
 
\vspace{1mm}
\myparagraph{Comparisons with SOTA Transformers.}
We further compare our proposed approach with some very recent concurrent works on vision transformers. They all improve the original ViT~\cite{ViT_dosovitskiy2021an} with respect to efficiency, accuracy or both. 
As shown in Table~\ref{table:sota}, \ours-15 outperforms the small models of all the other approaches with comparable FLOPs and parameters. 
Interestingly when compared with ViT-B, \ours-18 significantly outperforms it by 4.9\% (77.9\% vs 82.8\%) in accuracy while requiring 50\% less FLOPs and parameters. 
Furthermore, \ours-18 performs as well as TNT-B and better than the others, but also has fewer FLOPs and parameters. Our approach is consistently better than T2T-ViT~\cite{tokenstotoken_yuan2021} and PVT~\cite{PVT_wang2021} in terms of accuracy and FLOPs, showing the efficacy of multi-scale features in vision transformers.  







\begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|c|c|c|c}
        \toprule
             Model   & Top-1 Acc. & FLOPs & Throughput & Params \\ 
                     & (\%) &  (G) & (images/s) & (M) \\
        \midrule
        
ResNet-101~\cite{ResNet_He_2016_CVPR} & 76.7 & 7.80 & 678 & 44.6 \\
ResNet-152~\cite{ResNet_He_2016_CVPR} & 77.0 & 11.5 & 445 & 60.2 \\
\midrule
ResNeXt-101-324d~\cite{ResNeXt_Xie_2017_CVPR} & 78.8 & 8.0 & 477 & 44.2 \\
ResNeXt-101-644d~\cite{ResNeXt_Xie_2017_CVPR} & 79.6 & 15.5 & 289 & 83.5 \\
\midrule
SEResNet-101~\cite{SENet_Hu_2018} & 77.6 & 7.8 & 564 & 49.3 \\
SEResNet-152~\cite{SENet_Hu_2018} & 78.4 & 11.5 & 392 & 66.8 \\
SENet-154~\cite{SENet_Hu_2018} & 81.3 & 20.7 & 201 & 115.1\\
\midrule
ECA-Net101~\cite{ECA_wang2020} & 78.7 & 7.4 & 591 & 42.5 \\
ECA-Net152~\cite{ECA_wang2020} & 78.9 & 10.9 & 428 & 59.1 \\
\midrule
RegNetY-8GF~\cite{RegNet_Radosavovic_2020_CVPR} & 79.9 & 8.0 & 557 & 39.2 \\ RegNetY-12GF~\cite{RegNet_Radosavovic_2020_CVPR} & 80.3 & 12.1 & 439 & 51.8 \\ RegNetY-16GF~\cite{RegNet_Radosavovic_2020_CVPR} & 80.4 & 15.9 & 336 & 83.6 \\
RegNetY-32GF~\cite{RegNet_Radosavovic_2020_CVPR} & 81.0 & 32.3 & 208 & 145.0  \\

\midrule
EfficienetNet-B4@380~\cite{efficientnet_pmlr_tan_19}& 82.9& 4.2 & 356 & 19 \\
EfficienetNet-B5@456~\cite{efficientnet_pmlr_tan_19}& 83.7& 9.9 & 169 & 30 \\
EfficienetNet-B6@528~\cite{efficientnet_pmlr_tan_19}& 84.0& 19.0 & 100 & 43 \\
EfficienetNet-B7@600~\cite{efficientnet_pmlr_tan_19}& 84.3& 37.0 & 55 & 66 \\


\midrule
            \ours-15& 81.5 & 5.8 & 640 & 27.4 \\
            \ours-15 & 82.3 & 6.1 & 626 & 28.2 \\ 
            \ours-15@384 & 83.5 & 21.4 & 158 & 28.5 \\ 
\ours-18& 82.5& 9.03 & 430 & 43.3 \\ 
            \ours-18 & 82.8 & 9.5 & 418 & 44.3 \\ 
\ours-18@384& 83.9 & 32.4 & 112 & 44.6 \\ 
            \ours-18@480& 84.1 & 56.6 & 57 & 44.9 \\
\bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Comparisons with CNN models on ImageNet1K.} Models are evaluated under 224224 if not specified. 
    The inference throughput is measured under a batch size of 64 on a Nvidia Tesla V100 GPU with cudnn 8.0. We report the averaged speed over 100 iterations.}
    \label{table:compare_cnn}
\end{table}





 
\myparagraph{Comparisons with CNN-based Models.}
CNN-based models are dominant in computer vision applications. In this experiment, we compare our proposed approach with some of the best CNN models including both hand-crafted (e.g., ResNet~\cite{ResNet_He_2016_CVPR}) and search based ones (e.g., EfficientNet~\cite{efficientnet_pmlr_tan_19}).
In addition to accuracy, FLOPs and parameters, run-time speed is measured for all the models and shown as inference throughput (images/second) in Table~\ref{table:compare_cnn}.
We follow prior work~\cite{DeiT_touvron2020} to report accuracy from the original papers.
First, when compared to the ResNet family, including ResNet~\cite{ResNet_He_2016_CVPR}, ResNeXt~\cite{ResNeXt_Xie_2017_CVPR}, SENet~\cite{SENet_Hu_2018}, ECA-ResNet~\cite{ECA_wang2020} and RegNet~\cite{RegNet_Radosavovic_2020_CVPR}, \ours-15 outperforms all of them in accuracy while being smaller and running more efficiently (except ResNet-101, which is slightly faster).
In addition, our best models such as \ours-15 and \ours-18, when evaluated at higher image resolution, are encouragingly competitive against EfficientNet~\cite{efficientnet_pmlr_tan_19} with regard to accuracy, throughput and parameters. We expect neural architecture search (NAS)~\cite{Nasnet_Zoph_2018_CVPR} to close the performance gap between our approach and EfficientNet. 



\vspace{1mm}
\myparagraph{Transfer Learning.}
Despite our model achieves better accuracy on ImageNet1K compared to the baselines (Table~\ref{table:baseline}), it is crucial to check generalization of the models by evaluating transfer performance on tasks with fewer samples.
We validate this by performing transfer learning on 5 image classification tasks, including CIFAR10~\cite{cifar_krizhevsky2009learning}, CIFAR100~\cite{cifar_krizhevsky2009learning}, Pet~\cite{pet_parkhi12a}, CropDisease~\cite{cropdisease_mohanty2016}, and ChestXRay8~\cite{chestxray8_wang2017chestx}. While the first four datasets contains natural images, ChestXRay8 consists of medical images.
We finetune the whole pretrained models with 1,000 epochs, batch size 768, learning rate 0.01, SGD optimizer, weight decay 0.0001, and using the same data augmentation in training on ImageNet1K.
Table~\ref{table:transfer} shows the results. While being better in ImageNet1K, our model is on par with DeiT models on all the downstream classification tasks. This result assures that our models still have good generalization ability rather than only fit to ImageNet1K.

\begin{table}
\centering
\begin{adjustbox}{max width=\linewidth}
\begin{tabular}{l|ccccc}
\toprule
Model &  CIFAR10 &  CIFAR100 &   Pet &  CropDiseases &  ChestXRay8 \\
\midrule
DeiT-S~\cite{DeiT_touvron2020}   &    99.15 &     90.89 & 94.93 &         99.96 &       55.39 \\
DeiT-B~\cite{DeiT_touvron2020}    &    99.10 & 90.80  & 94.39 &         99.96 &       55.77 \\  \ours-15 &    99.00 &     90.77 & 94.55 &         99.97 &       55.89 \\
\ours-18  &    99.11 &     91.36 & 95.07 &         99.97 &       55.94 \\
\bottomrule
\multicolumn{6}{l}{\footnotesize : numbers reported in the original paper.}
\end{tabular}
\end{adjustbox}
\caption{\textbf{Transfer learning performance.} Our \ours models are very competitive with the recent DeiT~\cite{DeiT_touvron2020} models on all the downstream classification tasks.}
\label{table:transfer}
\end{table}




%
 \subsection{Ablation Studies}
\label{subsec:ablations}
In this section, we first compare the different fusion approaches (Section~\ref{subsec:ms_fusion}), and then analyze the effects of different parameters of our architecture design, including the patch sizes, the channel width and depth of the small branch and number of cross-attention modules. At the end, we also validate that the proposed can cooperate with other concurrent works for better accuracy.



\myparagraph{Comparison of Different Fusion Schemes.} Table~\ref{table:ablation_fusion} shows the performance of different fusions schemes, including (I) no fusion, (II) all-attention, (III) class token fusion, (IV) pairwise fusion, and (V) the proposed cross-attention fusion. Among all the compared strategies, the proposed cross-attention fusion achieves the best accuracy with minor increase in FLOPs and parameters. Surprisingly, despite the use of additional self-attention to combine information between two branches, all-attention fails to achieve better performance compared to the simple class token fusion. While the primary L-branch dominates in accuracy by diminishing the effect of complementary S-branch in other fusion strategies, both of the branches in our proposed cross-attention fusion scheme achieve certain accuracy and their ensemble becomes the best, suggesting that these two branches learn different features for different images.  



\begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|c|c|c||c|c}
        \toprule
               & Top-1 & FLOPs & Params & \multicolumn{2}{c}{Single Branch Acc. (\%) } \\ 
        Fusion & Acc. (\%)  & (G) & (M) & L-Branch & S-Branch \\
        \midrule
            None & 80.2 & 5.3 & 23.7 & 80.2 & 0.1 \\
            All-Attention & 80.0 &  7.6 & 27.7 & 79.9 & 0.5 \\
            Class Token & 80.3 & 5.4 & 24.2 & 80.6 & 7.6 \\
            Pairwise & 80.3 & 5.5 & 24.2 & 80.3 & 7.3 \\ 
            Cross-Attention & 81.0 & 5.6 & 26.7 & 68.1 & 47.2 \\
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Ablation study with different fusions on ImageNet1K.} All models are based on \ours-S. Single branch Acc. is computed using \clstoken from one branch only.}
    \label{table:ablation_fusion}
\end{table}


%
 
\myparagraph{Effect of Patch Sizes.} 
We perform experiments to understand the effect of patch sizes in our \ours by testing two pairs of patch sizes such as (8, 16) and (12, 16), and observe that the one with (12, 16) achieves better accuracy with fewer FLOPs as shown in Table~\ref{table:ablation} (A). 
Intuitively, (8, 16) should get better results as patch size of 8 provides more fine-grained features; however, it is not good as (12, 16) because of the large difference in granularity between the two branches, which makes it difficult for smooth learning of the features. For the pair (8, 16), the number of patch tokens are 4 difference while the ratio of patch tokens are only 2 for the model with (12, 16).

\myparagraph{Channel Width and Depth in S-branch.} Despite our cross-attention is designed to be light-weight, we check the performance by using a more complex S-branch, as shown in Table~\ref{table:ablation} (B and C). Both models increase FLOPs and parameters without any improvement in accuracy, which we think is due to the fact that L-branch has the main role to extract features while S-branch only provides additional information; thus, a light-weight branch is enough.

\myparagraph{Depth of Cross-Attention and Number of Multi-Scale Transformer Encoders.} To increase frequency of fusion across two branches, we can either stack more cross-attention modules () or stack more multi-scale transformer encoders () (by reducing  to keep the same total depth of a model). Results are shown in Table~\ref{table:ablation} (D and E). With \ours-S as baseline, too frequent fusion of branches does not provide any performance improvement but introduces more FLOPs and parameters. This is because patch token from the other branch is untouched, and the advantages from stacking more than one cross-attention is small as cross-attention is a linear operation without any nonlinearity function. Likewise, using more multi-scale transformer encoders also does not help in performance which is the similar case to increase the capacity of S-branch.

\myparagraph{Importance of CLS Tokens.} We experiment with one model based on \ours-S without CLS tokens, where the model averages the patch tokens of one branch as the CLS token for cross attention with the other branch.
This model achieved 80.0\% accuracy which is is 1\% worse than \ours-S (81.0\%) on ImageNet1K, showing effectiveness of CLS token in summarizing information of current branch for passing to another one through cross-attention. 

\myparagraph{Cooperation with Concurrent Works.} Our proposed cross-attention is also capable of cooperating with other concurrent ViT variants. We consider T2T-ViT~\cite{tokenstotoken_yuan2021} as a case study and use the T2T module to replace linear projection of patch embedding in both branches on \ours-18. \ours-18+T2T achieves an top-1 accuracy of 83.0\% on ImageNet1K, additional 0.5\% improvement over \ours-18. This shows that our proposed cross-attention is also capable of learning multi-scale features for other ViT variants. 



\begin{table}[t]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|cccccccc|c|c|c}
        \toprule
        Model        & \multicolumn{2}{c}{Patch size} & \multicolumn{2}{c}{Dimension} & & & & & Top-1 & FLOPs & Params \\ 
                & Small     & Large               &   Small       &   Large &  &  &  &  & Acc. (\%)  & (G) & (M) \\
        \midrule
        \ours-S &    12 & 16 & 192& 384 & 3 & 1 & 4 & 1 & 81.0 & 5.6 & 26.7\\
        \midrule
        A &    \boldblue{8}  & 16 & 192 & 384 & 3 & 1 & 4 & 1 & 80.8 & 6.7 & 26.7\\
B &    12 & 16 & \boldblue{384} & 384 & 3 & 1 & 4 & 1 & 80.1 & 7.7 & 31.4 \\
        C &    12 & 16 & 192& 384 & 3 & \boldblue{2} & 4 & 1 & 80.7 & 6.3 & 28.0 \\
        D &    12 & 16 & 192& 384 & 3 & 1 & 4 & \boldblue{2} & 81.0 & 5.6 & 28.9 \\
        E &    12 & 16 & 192& 384 & \boldblue{6} & 1 & \boldblue{2} & 1 & 80.9 & 6.6 & 31.1\\
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Ablation study with different architecture parameters on ImageNet1K.} The \boldblue{blue} color indicates changes from \ours-S.}
    \label{table:ablation}
\end{table} 














%
 \section{Conclusion}
\label{sec:conclusion}
In this paper, we present \ours, a dual-branch vision transformer for learning multi-scale features, to improve the recognition accuracy for image classification. To effectively combine image patch tokens of different scales, we further develop a fusion method based on cross-attention to exchange information between two branches efficiently in linear time.
With extensive experiments, we demonstrate that our proposed model performs better than or on par with several concurrent works on vision transformer, in addition to efficient CNN models.
While our current work scratches the surface on multi-scale vision transformers for image classification, we anticipate that in future there will be more works in developing efficient multi-scale transformers for other vision applications, including object detection, semantic segmentation, and video action recognition.


 

{\small
\bibliographystyle{ieee_fullname}
\bibliography{egbib}
}

\clearpage

\appendix
\myparagraphfirst{Summary} This supplementary material contains the following additional comparisons and hyperparameter details.
We first provide more comparisons between the proposed \ours and DeiT (see Table~\ref{table:more_baselines}) and then list the training hyperparameters used in main results, ablation studies and transfer learning, in Table~\ref{table:training_params}. 


\section{More Comparisons and Analysis}



To further check the advantages of the proposed \ours, we trained the models whose architecture are identical to the L-branch (primary) of our models. E.g., DeiT-9 is the baseline for \ours-9. As shown in Table~\ref{table:more_baselines},
the proposed cross-attention fusion consistently improves the baseline vision transformers regardless of their primary branches and patch embeddings, suggesting that the proposed multi-scale fusion is effective for different vision transformers. 



\begin{table}[!b]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{l|c|c|c}
        \toprule
             Model   & Top-1 Acc. (\%) & FLOPs (G) & Params (M)  \\ 
        \midrule
DeiT-9 & 72.9 & 1.4 & 6.4\\
            \ours-9 & 73.9 & 1.8 & 8.6 \\
            DeiT-9 & 75.6 &  1.5 & 6.6\\
             \ours-9 & \textbf{77.1} & 2.0 & 8.8 \\
             


             


\midrule
DeiT-15 & 80.8 & 4.9 & 22.9 \\
            \ours-15&  81.5 & 5.8& 27.4 \\
            DeiT-15 & 81.7 & 5.1 & 23.5\\
            \ours-15 & \textbf{82.3} & 6.1 & 28.2 \\ 
            \midrule
DeiT-18 & 81.4 & 7.8 & 37.1\\
            \ours-18& 82.5 & 9.0 & 43.3 \\ 


DeiT-18 & 81.2 & 8.1 & 37.9 \\
            \ours-18 & \textbf{82.8} & 9.5 & 44.3 \\ 
        \bottomrule
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Comparisons with various baselines on ImageNet1K.} See Table~1 of the main paper for model details.  denotes the models using three convolutional layers for patch embedding instead of linear projection.}
    \label{table:more_baselines}
\end{table}

 


\begin{table}[!bt]
    \centering
    \begin{adjustbox}{max width=\linewidth}
    \begin{tabular}{c|cc}
        \toprule
            & Main Results & Transfer \\
        \midrule
        Batch size & 4,096 & 768 \\
        Epochs & 300 & 1,000 \\
        Optimizer & AdamW & SGD \\
        Weight Decay & 0.05 & 1e-4 \\
        Linear-rate Scheduler & \multirow{2}{*}{Cosine (0.004)} & \multirow{2}{*}{Cosine (0.01)} \\
        (Initial LR) \\
        \midrule
        Warmup Epochs & 30 & 5 \\
        Warmup linear-rate & \multicolumn{2}{c}{\multirow{2}{*}{Linear (1e-6)}} \\
        Scheduler (Initial LR) \\
        \midrule
        Data Aug. & \multicolumn{2}{c}{RandAugment (m=9, n=2)} \\
        \midrule
        Mixup () & \multicolumn{2}{c}{0.8} \\
        CutMix () & \multicolumn{2}{c}{1.0} \\
        Random Erasing & 0.25 & 0.0 \\
        \midrule
        Instance & \multicolumn{2}{c}{\multirow{2}{*}{3}} \\
        Repetition \\
        \midrule
        Drop-path & 0.1 & 0.0 \\
        Label Smoothing & \multicolumn{2}{c}{0.1} \\
        \bottomrule
        \multicolumn{3}{l}{\footnotesize : only used for \ours-18.}
    \end{tabular}
    \end{adjustbox}
\caption{\textbf{Details of training settings.}}
    \label{table:training_params}
\end{table}
 


\begin{figure*}[h]
    \centering
    \includegraphics[width=\linewidth]{./Figures/visualization}
    \caption{\textbf{Feature visualization of \ours-S.} Features of patch tokens of both branches from the last multi-scale transformer encoder are shown. (36 random channels are selected.)
    }
    \label{fig:feat} 
\end{figure*}



Figure~\ref{fig:feat} visualizes the features of both branches from the last multi-scale transformer encoder of \ours. 
The proposed cross-attention learns different features in both branches, where the small branch generates more low-level features because there are only three transformer encoders while the features of the large branch are more abstract.  Both branches complement each other and hence the ensemble results are better.

 

\end{document}
