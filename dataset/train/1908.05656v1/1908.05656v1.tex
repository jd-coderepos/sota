\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}




\usepackage[preprint]{neurips_2019}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage{placeins}
\usepackage{booktabs}
\usepackage{pgfpict2e}
\usepackage{enumitem}
\usepackage{epstopdf}
\usepackage{booktabs}
\usepackage{color,colortbl}
\usepackage{multirow}


\definecolor{Gray}{gray}{0.9}

\newcommand{\LM}[1]{{\textbf{\color{cyan} (Laurens: #1)}}}
\newcommand{\AB}[1]{{\textbf{\color{magenta} (Anton: #1)}}}
\newcommand{\JJ}[1]{{\textbf{\color{blue} (Justin: #1)}}}
\newcommand{\RG}[1]{{\textbf{\color{green} (Ross: #1)}}}
\newcommand{\todo}[1]{{\textbf{\color{red} TODO: #1}}}

\newcommand{\app}{\raise.17ex\hbox{$\scriptstyle\sim$}}

\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1pt}}
\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\footnotesize}

\definecolor{demphcolor}{RGB}{100,100,100}
\newcommand{\demph}[1]{\textcolor{demphcolor}{#1}}

\title{PHYRE: A New Benchmark for Physical Reasoning}



\author{Anton Bakhtin \quad\quad
  Laurens van der Maaten \quad\quad
  Justin Johnson \\
  \bf{Laura Gustafson} \quad\quad
  \bf{Ross Girshick} \\\
  Facebook AI Research \\
  \texttt{\{yolo,lvdmaaten,jcjohns,lgustafson,rbg\}@fb.com} \\
}

\begin{document}


\maketitle

\vspace{-1em}
\begin{abstract}
Understanding and reasoning about physics is an important ability of intelligent agents. We develop the PHYRE benchmark for physical reasoning that contains a set of simple classical mechanics puzzles in a 2D physical environment. The benchmark is designed to encourage the development of learning algorithms that are sample-efficient and generalize well across puzzles. We test several modern learning algorithms on PHYRE and find that these algorithms fall short in solving the puzzles efficiently. We expect that PHYRE will encourage the development of novel sample-efficient agents that learn efficient but useful models of physics. For code and to play PHYRE for yourself, please visit \url{https://player.phyre.ai}.
\end{abstract}



\section{Introduction}
\label{sec:introduction}

Understanding and reasoning about physics is a hallmark of intelligence~\cite{davis2006}.
Humans can make sense of novel physical situations by reasoning about abstract concepts like gravity, mass, inertia, and friction.
For this reason, testing the ability to solve novel physics puzzles has been used to measure the reasoning abilities of human children~\cite{cheke2012children,visalberghi1996acting} as well as non-human animals such as capuchin monkeys~\cite{visalberghi1994lack,visalberghi1989tool}, chimpanzees~\cite{povinelli2000folk}, crows~\cite{jelbert2014using,taylor2008new}, finches~\cite{teschke2011physical}, and rooks~\cite{bird2009rooks}. A key aspect of physical intelligence is \emph{generalization}: after learning to solve a physics puzzle, an intelligent agent should be able to generalize that knowledge and quickly solve related tasks. Robust generalization may set humans apart from other species---prior research showed that four species of non-human primates can learn to solve novel physics puzzles, but struggle to generalize to related tasks~\cite{martin2008tubes}.

We want to develop artificial systems that can reason and generalize about physics as well as people. However, we hypothesize that in the realm of physical reasoning, present-day machine learning methods will struggle to quickly solve new puzzles.  We anticipate that more effective methods may involve fundamental improvements to sample-efficient learning and the ability to learn computationally efficient but useful models of physics.

Towards this goal, we have developed the PHYRE (PHYsical REasoning) benchmark. PHYRE provides a set of physics puzzles in a simulated 2D world. Each puzzle has a goal state (\emph{e.g.}, \emph{``make the green ball touch the blue wall''}) and an initial state in which the goal is not satisfied; see Figure~\ref{fig:phyre_examples}. A puzzle can be solved by placing one or more new bodies in the environment such that when the physical simulation is run the goal is satisfied. An agent playing this game must solve previously unseen puzzles in as few attempts as possible. PHYRE was designed to satisfy three main goals:

\begin{itemize}[leftmargin=*]
\setlength\itemsep{0em}
  \item \textbf{Focus on physical reasoning:} Tasks are as simple as possible but still require nontrivial physical reasoning. Scenes are built only from balls and rectangular bars. Dynamics are deterministic, with only collision, gravity, and friction. Goals are symbolic, so natural language is not required.
  \item \textbf{Focus on generalization:} After training on one set of tasks, we should expect an effective agent to solve new, previously unseen puzzles. The benchmark is structured such that puzzles are split into training tasks and evaluation tasks, and involves two different degrees of generalization.  
  \item \textbf{Focus on sample-efficiency:} Our evaluation rewards solving tasks with as few attempts as possible. Methods that master a task only after thousands of attempts will not perform well.
\end{itemize}

Figure~\ref{fig:phyre_examples} shows three examples of PHYRE tasks. Each task comprises static and dynamic objects in a 2D environment and a goal description. Upon looking at these examples, you, the reader, will likely form an intuitive hypothesis for how to solve each problem. If your first attempt were to fail, you would likely be able to use your observations of what happened to refine your attempt into a successful solution. PHYRE encourages the development of learning agents with similar abilities.

\begin{figure}[t]
\centering
  \includegraphics[width=\linewidth]{figs/phyre_examples}
  \begin{minipage}{0.245\linewidth}
    \centering
    \scriptsize
    Make the green ball\\touch the blue ball
  \end{minipage}
  \begin{minipage}{0.245\linewidth}
    \centering
    \scriptsize
    Make the green ball\\touch the blue bar
  \end{minipage}
  \begin{minipage}{0.245\linewidth}
    \centering
    \scriptsize
    Make the green ball\\touch the blue ball
  \end{minipage}
  \begin{minipage}{0.245\linewidth}
    \centering
    \scriptsize
    Make the green ball\\touch the blue ball
  \end{minipage}
\caption{Three examples of PHYRE tasks (left) and one example solution (right). Black objects are static; objects with any other color are dynamic and subject to gravity. The tasks describe a terminal goal state that can be achieved by placing additional object(s) in the world and running the simulator. The task in the left-most pane requires placement of two balls to be solved, whereas the others can be solved with one ball. The right-most pane illustrates a solution (red ball) and the solution dynamics.}
\label{fig:phyre_examples}
\end{figure}
 

\section{Related Work}
\label{sec:related_work}

PHYRE is related to prior work on intuitive physics, visual reasoning, and learning in computer games and simulated (robotics) environments. It was developed concurrently with the Tools game~\cite{allen2019tools}.

\noindent\textbf{Intuitive physics.} Foundational work in cognitive psychology suggests that people reason about the physical world using simplified intuitive theories~\cite{mccloskey1983naive,mccloskey1980curvilinear,mccloskey1983intuitive}. Early computational instantiations of this framework used probabilistic models over physical simulations~\cite{battaglia2013simulation,zhang2016evaluation}, while more recent methods use feedforward neural networks trained to make pixelwise~\cite{finn2016unsupervised,lerer2016blocks,mirza2017generalizable,xue2016visual} or qualitative~\cite{groth2018shapestacks,li2016fall,li2017stability,mirza2017generalizable,zhang2016evaluation} predictions about the future, sometimes in conjuction with simulation~\cite{janner2019,wu2015galileo,wu2017learning}. Many methods are evaluated on the constrained task of predicting whether a 3D stack of blocks will topple; some recent studies instead ask models to determine whether videos of more complex scenes are physically plausible~\cite{piloto2018probing,riochet2018intphys}. In contrast, PHYRE provides a suite of goal-driven tasks to test intuitive physical understanding: rather than evaluating intermediate tasks like future prediction or stability modeling, PHYRE requires agents to intervene in the scene to achieve a desired end goal.

\noindent\textbf{Visual reasoning.} Work on visual reasoning dates to SHRDLU~\cite{winograd1971} which probed scene understanding using natural language; more recent benchmarks require systems to answer natural-language questions about images~\cite{antol2015vqa,johnson2017clevr}. Recent methods use neural networks to extract sub-symbolic image representations, which are used in subsequent reasoning modules~\cite{hu2017learning,hudson2018compositional,johnson2017inferring,mao2019neurosymbolic,perez2018film,santoro2017relational}. Like PHYRE, these tasks require reasoning about the interactions of multiple objects in a scene; however unlike PHYRE they assume a static world, and do not require reasoning about world dynamics.

\noindent\textbf{Learning in computer games.} Computer games often involve complex 2D and 3D environments and require agents to possess some level of physical understanding~\cite{mnih2015atari,smith2006billiards}. For instance, Atari games such as Pong involve precise positioning of a paddle based on observed ball dynamics~\cite{mnih2015atari}. The main difference between prior work in computer games and our work is that PHYRE requires the agent to learn a single model to solve a wide range of different tasks rather than a specialized model for each task. Moreover, in contrast to most work in computer games, PHYRE requires the agent to learn in a sample-efficient manner, penalizing agents that require many samples to learn.

\noindent\textbf{Learning in simulated (robotics) environments.} A range of prior work studies learning in simulated (robotics) environments for self-driving cars~\cite{dosovitskiy2017carla}, humanoid robotics~\cite{tudorov2012mujoco}, or navigation tasks~\cite{savva19habitat,wu2018building}. In contrast to PHYRE, these prior studies focus on agents operating in realistic non-deterministic 3D environments in which the world is not fully observed, which hampers systematic study of reasoning capabilities of the agent. By contrast, PHYRE takes inspiration from CLEVR~\cite{johnson2017clevr} and limits the complexity of the environment, facilitating more systematic analysis of reasoning abilities.
 

\section{PHYRE Physical Reasoning Benchmark}
\label{sec:phyre}

The PHYRE environment is a two-dimensional world that simulates simple deterministic Newtonian physics. There is a constant downward gravitational force and a small amount of friction. All \emph{bodies} are non-deformable and are either \emph{static} or \emph{dynamic}, distinguished by color. Static bodies remain at a fixed position and are not influenced by gravity or collision, while dynamic bodies move in response to these forces. All bodies come from a small \emph{vocabulary}\footnote{The current body vocabulary contains balls, bars, standing sticks, and jars.}, varying in scale, location, and orientation.

A PHYRE \emph{task} consists of an \emph{initial world state} and a \emph{goal}. The initial world state is a pre-defined configuration of bodies. The goal is a (subject, relation, object) triplet identifying a \emph{relationship} between two bodies that the agent needs to achieve when the simulation terminates. At present all tasks use a single relation, \texttt{touching} for at least 3 seconds, which we found sufficient for developing a diverse set of tasks. The environment can be extended in the future to include additional relationships.

The agent aims to achieve the goal by taking a single \emph{action}, placing one or more new dynamic bodies into the world. Bodies placed by the action may not extend beyond the world boundaries or intersect other bodies; such actions are rejected by the simulator as \emph{invalid}. After the action is taken, the simulator runs until the goal is reached or until a time limit elapses, whichever happens first. The agent cannot perform additional actions while the simulator runs. Once the simulation is complete, the agent receives a binary \emph{reward} indicating whether the goal was achieved, and gains access to observations of the intermediate world states produced by the simulator. If the goal was not achieved, the world resets to its initial state and the agent tries again, possibly informed by its prior attempts.

The full world state, comprising exact positions and orientations of bodies as well as their masses and velocities, is not revealed to agents since human observers cannot directly perceive such values from their environments.
Instead, the agent receives coarser initial and intermediate world states as \emph{observation images} which rasterize the world to a 256$\times$256 grid. Each grid cell takes one of seven values specifying whether that location is a (1) dynamic goal object, (2) static goal subject, (3) dynamic goal subject, (4) static confounding body, (5) dynamic confounding body, (6) body placed by the agent, or (7) background. With only one relation, the colors in the initial observation encode the goal, eliminating the need for natural-language goal specification or grounding. Figure~\ref{fig:phyre_examples} shows three PHYRE tasks with goals written in natural language solely for the convenience of the reader.

Without any restrictions on the action space, for example on the body types, their properties, and the number of bodies that may be placed, the action space is large and complex. We therefore define two restricted action \emph{tiers} for the current benchmark, which we describe next. After research progresses on these tiers, more complex ones may be added to the benchmark.

\subsection{Benchmark Tiers}
\label{sec:benchmark_tiers}
This work studies two benchmark tiers of increasing difficulty. A \emph{tier} comprises a combination of: (1) a predefined set of all actions the agent is allowed perform and (2) a set of tasks that can be solved by at least one action from this action set. The two tiers we developed for this study are:
\begin{itemize}[leftmargin=*]
\setlength\itemsep{0em}
\item \textbf{PHYRE-B.} Action set containing all valid locations and radii for a single ball (3D; continuous).
\item \textbf{PHYRE-2B.} Action set containing all valid pairs of two balls (6D; continuous).
\end{itemize}
The two tiers each contain 25 task \emph{template}s. A task template defines a set of related tasks that are generated by varying task template parameters (such as positions of initial world bodies). All tasks in the same template share a common goal, but have different initial world states. Each template defines 100 such tasks. Task templates are used to measure an agent's generalization ability in two settings. In the \textbf{within-template} setting, an agent trains on a subset of tasks in the template and is evaluated on the remaining tasks within that template. To measure \textbf{cross-template} generalization, test tasks are selected exclusively from templates that were not used for training. Our criteria for task design, additional analysis, and visualizations of tasks are provided in the supplement.

\subsection{Learning Setting}
\label{sec:learning_setting}
Because the agent can only perform a single action to solve a PHYRE task, PHYRE is similar to a \emph{contextual bandit} setting~\cite{langford2008bandits,li2010contextual}. PHYRE differs from traditional contextual bandit settings in two main ways: (1) it has an offline training phase that precedes the online learning testing phase and (2) the agent receives privileged information~\cite{vapnik2009privileged} in addition to the binary reward signal, \emph{viz.}, it has access to observations of intermediate world states produced by the simulator on previous attempts.

In the \textbf{training phase}, the agent has access to the training tasks and unlimited access to the simulator. The agent does not have access to task solutions, but can use the simulator to train models that can solve tasks. Such models may include forward-prediction or action-prediction models.

In the \textbf{testing phase}, the agent receives test tasks that it needs to solve in as few \emph{attempts} (queries to the simulator) as possible. After each attempt, the agent receives a binary reward and observations of intermediate world states. The agent can use this information to refine its action for the next attempt. Some actions may be invalid, \emph{i.e.}, correspond to an object that overlaps with other objects. In such cases, we neither give the agent any reward nor count this attempt toward the query budget. The agent receives access to all test tasks at once, allowing it to choose the order in which it solves tasks.

\noindent\textbf{Performance measure.}
We judge an agent's performance by how efficiently it solves tasks in the testing phase. We characterize efficiency in terms of the number of actions that were attempted to solve a given task; fewer attempts corresponds to greater efficiency. We formalize this intuition by recording the cumulative percentage of test tasks that were solved (the \emph{success percentage}) as a function of the number of attempts taken per task. To compare the performance of agents on PHYRE, we plot this success-percentage curve. We also compute a performance measure, called \textbf{AUCCESS}, that aggregates the success percentages in the curve via a weighted average. To place more emphasis on solving tasks with fewer attempts, we consider the range of attempts $k\!\in\!\{1, \ldots, 100\}$ and use weights $w_k \!=\! {\log(k + 1) - \log(k)}$, yielding $\textrm{AUCCESS}\!=\!\sum_k w_k \cdot s_k / \sum_k w_k$, where $s_k$ is the success percentage at $k$ attempts. The relative weight of the first 10 attempts in the AUCCESS measure is $\app$0.5: agents that need more than 10 attempts cannot get an AUCCESS score of more than 50\%. This encourages the development of sample-efficient agents. AUCCESS is equivalent to the area under the success-percentage curve formed by replacing the discrete samples with a piecewise constant function and placing the number of attempts on a log scale.

\begin{figure*}[!t]\centering
\subfloat[\label{fig:phyre_difficulty_analysis}Percentage of tasks solved by a \emph{random} agent ($y$-axis) as a function of the number of attempts ($x$-axis; log scale) for both PHYRE tiers.]{\includegraphics[width=0.45\linewidth]{figs/plot_attempts_to_solve.pdf}}
\hspace{6mm}
\subfloat[\label{fig:phyre_tpl_difficulty_analysis}Probability ($y$-axis; log scale) that a \emph{random} attempt solves each of the 25 task templates ($x$-axis) in a tier for both PHYRE tiers.]{\includegraphics[width=0.45\linewidth]{figs/template_complexity_progression.pdf}}\\[.25em]
\caption{PHYRE complexity analysis. Values are averaged over 10 runs over all tasks in the tier; error bars indicate one standard deviation. Two-ball tasks are much harder to solve by chance than single ball tasks. Each tier contains a spectrum of task difficulty with respect to random guessing.}
\vspace{-3mm}
\end{figure*}


\subsection{Analysis}
\label{sec:phyre_analysis}
To assess the difficulty of the tasks in both PHYRE tiers, we measured what percentage of PHYRE tasks can be solved by an agent that randomly samples actions from the action space. Figure~\ref{fig:phyre_difficulty_analysis} shows the percentage of tasks ($y$-axis) that this random agent solves in at most $k$ attempts ($x$-axis), averaged over 10 runs on all PHYRE tasks. The figure reveals that tasks vary greatly in difficulty level: a few tasks can be solved by a random agent in just a few attempts, whereas other tasks require thousands of attempts to be solved. The figure also shows that tasks in the PHYRE-B tier are, on average, harder than those in PHYRE-2B because the action space in that tier has more degrees of freedom.

We designed the PHYRE tasks such that, on average, it takes a random agent no more than 10,000 attempts to solve task in the PHYRE-B tier and no more than 100,000 attempts to solve a task in the PHYRE-2B tier. Figure~\ref{fig:phyre_tpl_difficulty_analysis} illustrates this by displaying the average probability that a random attempt solves a task for each of the 25 task templates in both PHYRE tiers. In line with the previous analysis, the figure also shows that tasks in PHYRE-2B are substantially harder than those in PHYRE-B.
 

\section{Experiments}
\label{sec:experiments}
We conduct experiments to obtain baseline results for within-template and cross-template generalization on the PHYRE benchmark. Experiments are performed separately on each tier. Code reproducing the results of our experiments is available from \url{https://phyre.ai}.

\subsection{Baseline Agents}
We experiment with five baseline agents that rank actions given an observation of the initial state (recall that the observation encodes the goal): (1) a random agent, (2) a non-parametric agent, (3) a deep Q-network~\cite{mnih2015atari}, and (4-5) counterparts to (2) and (3) that update the agent online during testing.

\noindent\textbf{Random agent (RAND).} This agent does not perform any training and instead samples actions uniformly at random from the 3D or 6D (depending on the tier) action space at test time.

\noindent\textbf{Non-parametric agent (MEM).} At training time, this agent generates a set of $R$ random actions and uses the simulator to check if each of these actions can solve each of the training tasks. For each action $a$, the agent computes $p_a$: the fraction of training tasks that the action solves. The agent then sorts the $R$ actions by $p_a$ (highest to lowest), and tries them in this order at test time. This agent is non-parametric because it uses a list of ``memorized'' actions at test time.

In the \emph{cross-template setting}, the test tasks come from previously unseen task templates and this simple agent cannot relate them to tasks seen during training. It therefore uses the same action ranking for all tasks and ignores the observation of the initial state. In the \emph{within-template setting}, each test task comes from a task template that was seen during training. In this case, we give the agent access to the task template id for each test task. The agent maintains a per-task-template ranking of the $R$ actions. The same set of actions is shared across all templates; only the ranking changes. The set of actions attempted on each task may vary because invalid actions are ignored; see Section~\ref{sec:learning_setting}.

\noindent\textbf{Non-parametric agent with online learning (MEM-O).} This agent has the same training phase as the non-parametric agent, but continues to learn online at test time. Specifically, after finishing each test task (either successfully or unsuccessfully), the agent updates $p_a$ based on the reward received for each action $a$ in the subset of the actions it attempted. The updated ranking is used when the next task is attempted. Such online updates are beneficial, in particular, in the cross-template setting because they allow the agent to learn something about the tasks in the previously unseen templates. We use cross-validation to tune the relative weight of the  update on each train-val fold (see Section~\ref{sec:exp_setup}).

\noindent\textbf{Deep Q-network (DQN).} As before, the DQN agent collects a set of observation-action-reward triplets by randomly sampling actions and running them through the simulator.
The agent trains a deep network on the resulting data to predict the reward for an observation-action pair.
Following~\cite{bellemare2017distributional}, we train the network by minimizing the cross-entropy between the soft prediction and the observed reward.
During training, we sample batches with an equal number of positive and negative triplets.

Our network comprises: (1) an \emph{action encoder} that transforms the 3D or 6D (depending on the tier) action representation using a multi-layer perceptron with a single hidden layer; (2) an \emph{observation encoder} that transforms the observation image into a hidden representation using a convolutional network (CNN); and (3) a \emph{fusion module} that combines the action and observation representations and makes a prediction. Our action encoder is a MLP with a single hidden layer with 512 units and ReLU activations. Our observation encoder is a ResNet-18~\cite{he2016deep}. For the fusion module, we follow~\cite{perez2018film} and use the action encoder to predict a bias and gain for each channel in the CNN. The output of the action encoder thus contains twice as many values as there are channels in the CNN at the fusion point. To expedite action ranking, we fuse both models before the last residual block of the CNN. We tried other fusion points but did not observe performance differences (see supplemental material).

The observation of the initial state is a 256$\times$256 image with one of 7 colors at each pixel, which encodes properties of each body and the goal. We map this observation into a 7-channel image for input to the CNN; each colored pixel in the image yields a 7D one-hot vector. Following common practice, the network is trained end-to-end using stochastic gradient descent with the Adam optimizer~\cite{kingma2014adam}. We anneal the learning rate to 0 using a half cosine schedule without restarts~\cite{loshchilov2016sgdr}.

\noindent\textbf{Deep Q-network with online learning (DQN-O).} Akin to MEM-O, this agent uses rewards from test tasks to perform online updates. After finishing a test task, the agent performs a number of gradient descent updates using examples obtained from that task. The updated model is then used for the next test task. The number of updates and corresponding learning rate are set via cross-validation.

\noindent\textbf{Contextual bandits.}
While PHYRE is a contextual-bandit setting, we found that contextual bandits (CBs) do not work well on our complex observation and action space.
Most CBs model the expected reward given the context and action using linear models~\cite{chapelle2011empirical,chu2011contextual,li2010contextual}, Gaussian processes~\cite{srinivas2009gaussian}, or deep neural networks~\cite{riquelme2018deep}.
Linear models do not yield useful context representations (which are observation images).
Gaussian processes require a reasonable kernel function on the observation image space, which is difficult to define.
Methods based on deep neural network seem more suitable. We tried to use the implementation from~\cite{riquelme2018deep}\footnote{\scriptsize{\url{https://github.com/tensorflow/models/tree/master/research/deep_contextual_bandits}}}, but were unable to train the model once we replaced the shallow MLP used in~\cite{riquelme2018deep} by a CNN that is better suited for image encoding.
In addition, CBs generally assume a fixed (usually small) number of arms without a similarity metric between the arms, which is problematic for PHYRE tasks: when reasonably discretized, the number of arms in PHYRE-B is $\app 10^6$.
Moreover, without considering similarity between actions, agents try various non-working arms in the same region of the action space without diversifying them (see Section~\ref{ref:ablation}).

\noindent\textbf{Policy learners.}  We faced similar issues with policy learners such as PPO~\cite{schulman2017ppo} and A2C~\cite{mnih2016a2c}.
While we were able to factorize the action space over each dimension and use continuous action spaces, we were unable to train models that outperform our random baseline due to poor training stability.



\subsection{Experimental Setup}\label{sec:exp_setup}
We measure success percentage and AUCCESS on PHYRE using the learning setting of~\ref{sec:learning_setting}.
To make results reproducible and allow fair comparisons between agents across studies, PHYRE provides:
\begin{itemize}[leftmargin=*]
\setlength\itemsep{0em}
\item A fully deterministic environment: agents always produce the same result on a task.
\item A process that deterministically splits the tasks into 10 \emph{folds} containing a training, validation, and test set. As a result, agents are always compared on exactly the same task splits. Task splits are available for both tiers and both generalization settings (within-template and cross-template).
\end{itemize}
To avoid overfitting on test tasks, hyperparameter tuning is only to be performed based on the validation set: \emph{we discourage tuning of hyperparameters based on test task performance.} For results on the test set, we use these tuned hyperparameter and train agents on the union of the training and validation sets. To compare agents, we use the non-parametric Wilcoxon signed-rank test for median difference~\cite{wilcoxon1945individual} with one-sided null hypotheses and $p\!=\!0.01$.
We use this test as it does not have a normality assumption, is efficient with small sample sizes, and works with relative values on each fold instead of absolute values.
To facilitate comparisons with our baselines, we provide our AUCCESS scores on all 10 folds in the supplementary material.

At test time, all agents (except the random agent) rank the same set of 10,000 actions on each task and propose the highest-scoring actions for that task as solution attempts. The MEM(-O) agents were trained on the same 10,000 actions. The DQN(-O) agents were trained on 100,000 actions per task.\footnote{To simplify follow-up research, we will release the simulation results of these 100,000 actions per task.} All agents are permitted to make up to 100 attempts per task. This fact subtly implies that when computing the success percentage at $k\!<\!100$ attempts, online agents will have learned from up to 100 (not $k$) attempts per task; this pragmatic choice makes the benchmark computationally tractable as otherwise online agents would need to be re-run for every value of $k\!\in\!\{1,\ldots,100\}$.

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figs/finals.pdf}
\vspace{-5mm}
\caption{Percentage of solved tasks (success percentage) as a function of the number of attempts per task of five agents on PHYRE-\{B, 2B\} in the within-template and cross-template settings. Success percentages are averaged over all test tasks and 10 folds. Shaded regions show one standard deviation.}
\label{fig:success_curves}
\vspace{-5mm}
\end{figure}

\newcommand{\colw}{30}
\begin{table*}[!h]\centering
\subfloat[\label{tab:final_auccess}Area under the success-percentage curve (AUCCESS) of five agents. Higher is better.]{\tablestyle{4pt}{1.2}\begin{tabular}{@{}lx{\colw}x{\colw}x{\colw}x{\colw}@{}}
    & \multicolumn{2}{c}{\bf PHYRE-B} & \multicolumn{2}{c}{\bf PHYRE-2B} \\
    & \bf Cross& \bf Within & \bf Cross & \bf Within \\
    \midrule
    {\bf RAND} & 13.0{\tiny{{\demph{{$\pm$5.0}}}}} & 13.7{\tiny{{\demph{{$\pm$0.5}}}}} & 2.6{\tiny{{\demph{{$\pm$1.5}}}}} & 3.6{\tiny{{\demph{{$\pm$0.6}}}}} \\
{\bf MEM} & 18.5{\tiny{{\demph{{$\pm$5.1}}}}} & 2.4{\tiny{{\demph{{$\pm$0.3}}}}} & 3.7{\tiny{{\demph{{$\pm$2.3}}}}} & 3.2{\tiny{{\demph{{$\pm$0.2}}}}} \\
{\bf MEM-O} & 22.8{\tiny{{\demph{{$\pm$5.0}}}}} & - & 4.9{\tiny{{\demph{{$\pm$3.1}}}}} & - \\
{\bf DQN} & 36.8{\tiny{{\demph{{$\pm$9.7}}}}} & 77.6{\tiny{{\demph{{$\pm$1.1}}}}}* & 23.2{\tiny{{\demph{{$\pm$9.1}}}}} & 67.8{\tiny{{\demph{{$\pm$1.5}}}}}* \\
{\bf DQN-O} & 56.2{\tiny{{\demph{{$\pm$10.5}}}}}* & - & 39.6{\tiny{{\demph{{$\pm$11.1}}}}}* & - \\
 \end{tabular}}
\hspace{6mm}
\subfloat[\label{tab:final_solved}Success percentage at $k\!=\!10$ attempts of five agents. Higher is better.]{\tablestyle{4pt}{1.2}\begin{tabular}{@{}lx{\colw}x{\colw}x{\colw}x{\colw}@{}}
    & \multicolumn{2}{c}{\bf PHYRE-B} & \multicolumn{2}{c}{\bf PHYRE-2B} \\
    & \bf Cross & \bf Within & \bf Cross & \bf Within \\
    \midrule
    {\bf RAND} & 6.8{\tiny{{\demph{{$\pm$5.0}}}}} & 7.7{\tiny{{\demph{{$\pm$0.8}}}}} & 2.2{\tiny{{\demph{{$\pm$1.8}}}}} & 3.2{\tiny{{\demph{{$\pm$0.9}}}}} \\
{\bf MEM} & 15.2{\tiny{{\demph{{$\pm$5.9}}}}} & 2.7{\tiny{{\demph{{$\pm$0.5}}}}} & 1.9{\tiny{{\demph{{$\pm$1.6}}}}} & 3.4{\tiny{{\demph{{$\pm$0.3}}}}} \\
{\bf MEM-O} & 20.1{\tiny{{\demph{{$\pm$5.6}}}}} & - & 3.8{\tiny{{\demph{{$\pm$3.2}}}}} & - \\
{\bf DQN} & 34.5{\tiny{{\demph{{$\pm$10.2}}}}} & 81.4{\tiny{{\demph{{$\pm$1.9}}}}} & 22.4{\tiny{{\demph{{$\pm$10.0}}}}} & 74.9{\tiny{{\demph{{$\pm$1.7}}}}} \\
{\bf DQN-O} & 58.2{\tiny{{\demph{{$\pm$10.9}}}}} & - & 41.6{\tiny{{\demph{{$\pm$11.7}}}}} & - \\
 \end{tabular}}
\caption{Comparison of the five agents on PHYRE-\{B, 2B\}. Mean and standard deviation on the 10 folds are reported. MEM-O and DQN-O perform best with no update in the within-template setting, making them equivalent to MEM and DQN in this case; thus, we omit their results. *Indicates an agent's AUCCESS is better than all others per the Wilcoxon one-sided test with $p \!=\! 0.01$.}
\vspace{-3mm}
\end{table*}


\subsection{Main Results}\label{sec:main_results}
Figure~\ref{fig:success_curves} presents success-percentage curves for all five agents on both PHYRE tiers (-B and -2B) in both generalization settings (within-template and cross-template): the curves show the percentage of tasks solved as a function of the number of solution attempts per task, and are computed by averaging over all 10 folds in PHYRE. Table~\ref{tab:final_auccess} presents the corresponding mean AUCCESS (and its standard deviation). The results are in line with the trends observed in Section~\ref{sec:phyre_analysis}: the within-template setting is much easier than the cross-template setting for all (non-random) agents. As forecasted, the two tiers also have different difficulty characteristics. In the cross-template setting, the best agent, DQN-O, is able to reach a reasonably high AUCCESS of 56.2\% on PHYRE-B, but is at just 39.6\% on PHYRE-2B. This small change in the action space substantially decreases agent success. Notably, agents that perform online learning ($\mathbf{\star}$\textbf{-O}) substantially outperform their offline counterparts.

In Table~\ref{tab:final_solved}, we present the percentage of tasks that were solved within 10 attempts by each agent. This low-attempt regime is emphasized by AUCCESS and a goal of the PHYRE benchmark is to encourage research that improves results in this regime. The results are in line with prior observations and illustrate that the PHYRE-2B cross-template setting presents a significant challenge for all agents.

\subsection{Analysis}
\label{ref:ablation}
Here, we analyze the effect of: (1) the number of actions that are ranked by agents at test time and (2) the ``aggressiveness'' of agent updates on the performance of online agents. In the supplement, we also ablate the deep Q-network (DQN) design.
For these experiments, agents are trained and evaluated on the train and validation splits, respectively, using the first three (out of 10) folds.

\begin{figure}[t]
\centering
\includegraphics[width=.99\linewidth]{figs/dqn_quality_per_ranking_size.pdf}
\vspace{-2mm}
\caption{AUCCESS as a function of the number of actions being ranked by the agent for the RANDOM, MEM, and DQN agents and for an agent that is OPTIMAL in terms of scoring attempts.}
\label{fig:dqn_rerank_size}
\end{figure}

\noindent\textbf{Number of actions ranked.} Figure~\ref{fig:dqn_rerank_size} shows the AUCCESS of the RAND, MEM, and DQN agents as a function of the number of actions that are ranked by the agents at test time. We also present an OPTIMAL ranking agent that performs oracle ranking of the action set. The performance of the OPTIMAL agent suggests that ranking is a reasonable strategy: it solves all tasks in PHYRE-B and 95\% of tasks in PHYRE-2B by ranking fewer than 100,000 attempts. For non-oracle agents, DQN is a much better ranker than MEM. As expected, AUCCESS increases as more actions are ranked, but eventually plateaus and sometimes decreases beyond a certain number of attempts. This is due to a lack of diversity in the rankings produced by the agents, which do not have a model of similarity between actions and may suggest multiple similar attempts when sampling of actions is fine-grained.

\begin{figure}[t]
\centering
\includegraphics[width=.99\linewidth]{figs/online_sweep_combined.pdf}
\vspace{-2mm}
\caption{AUCCESS of MEM-O and DQN-O agents as the ``aggressiveness'' of the online update is varied during the testing phase. The left-most point in each plot is an offline version of the agent.}
\label{fig:online_sweep}
\end{figure}

\noindent\textbf{Effect of online updates.} Online agents use examples obtained during both the training and testing stages. Figure~\ref{fig:online_sweep} analyzes the effect of re-weighting both types of examples on the performance of online agents (on three folds). The results show that the AUCCESS of MEM-O is fairly independent of the weight used. The AUCCESS of the DQN-O agent does vary as a function of how many updates were performed at test time: online updates even impede DQN-O in the within-template setting.
 

\section{Discussion and Future Work}
\label{sec:discussion}
PHYRE aims to enable the development of physical reasoning algorithms with strong generalization properties mirroring those of humans~\cite{martin2008tubes}. Yet the baseline methods studied in this work are far from this goal, demonstrating limited generalization abilities. We foresee several areas for advancement:
\begin{itemize}[leftmargin=*]
\setlength\itemsep{0em}
\item Agents should use intermediate observations from the simulator following an (unsuccessful) attempt to refine their next attempt. Our current failure to do so makes the agents sample-inefficient, as these observations contain rich information on the specific task that the agent is solving that should be used effectively for efficient problem-solving. Doing so requires \emph{counterfactual reasoning}: agents need to reason about what would happen upon a particular change to a previous attempt.
\item Agents should use a forward-prediction model that mimics the simulator by a learnable function~\cite{henaff2017prediction}. Such a model can be integrated into a DQN by running attempts through it for a number of time steps, and using the resulting state predictions as additional inputs into the Q-network.
\item Agents should explicitly diversify attempts when solving a task.
\item Agents should use an active strategy at test time, \emph{e.g.}, by starting with solving simple tasks. 
\item While each task is different from the others, they share the same underlying causal model (physics). Methods aimed at invariant causal prediction (ICP)~\cite{heinze2018invariant,peters2014causal} may be well-suited for PHYRE.
\end{itemize}
Based on these observations, we expect to witness rapid progress on the PHYRE benchmark. To this point, we highlight that PHYRE is an extensible platform upon which more challenging puzzle tiers may be built. The two tiers provided in this initial benchmark are designed to be approachable, yet challenging. Future tiers may involve substantially larger and more complex action spaces. 

We also foresee approaches that implement a simulator ``internal'' to the agent and then query it to brute-force a solution before submitting any attempts to the real simulator. Based on initial experiments, we expect that training a neural network to exactly mimic the simulator will be difficult. However, one might instead use hand-coded rules specific to PHYRE---in the extreme, one could simply call the real simulator inside the agent. We view such approaches as violating the spirit of the benchmark.  We discourage this line of attack as well as in-between solutions that combine function approximation with extensive hand-coded inductive biases that are specific to PHYRE.
 
\section*{Acknowledgements}
We thank Mayank Rana for his help with early versions of PHYRE, and Audrey Durand, Joelle Pineau, Arthur Szlam, Alessandro Lazaric, Devi Parikh, Dhruv Batra, and Tim Rockt{\"a}schel for helpful discussions.

\bibliographystyle{abbrvnat}
\bibliography{references}

\newpage
\appendix


\section{Ablation Study of Deep Q-Network (DQN)}

\label{sec:dqn_ablation}
Figure~\ref{fig:dqn_variants} shows the effect on AUCCESS of six modifications to our DQN agent. The modifications encompass changes to the architecture of the action encoder (\emph{Act1024} and \emph{Act1024$\times$2}), the fusion mechanism (\emph{FuseGlobal}, \emph{FuseFirst}, and \emph{FuseAll}), and the balancing of training batches (\emph{NoBalancing});
see the figure caption for full details. We make four main observations:
\begin{itemize}[leftmargin=*]
\setlength\itemsep{0em}
\item Class-balancing training batches is critical to the DQN agent's performance, particularly on the PHYRE-2B tier where only 0.3\% of randomly chosen actions yield a positive example.
\item Early fusion of action information into the ResNet-18 observation encoder does not help. Early fusion is also inefficient for action ranking: it prohibits caching of the observation encoder's output.
\item Our default fusion method uses channel-wise bias and gain modulation immediately before the ResNet-18 \texttt{conv5} stage; applying this fusion the final globally pooled features, instead, substantially deteriorates AUCCESS.
\item Larger action encoders can improve performance, but the gains are not consistent across settings.
\end{itemize}
\begin{figure}[!h]
\centering
\includegraphics[width=0.88\linewidth]{figs/dqn_variants.pdf}
  \caption{Mean AUCCESS on PHYRE-\{B, 2B\} of six DQN variants of the \emph{Baseline} in the main text. Error bars show one standard deviation. \emph{FuseFirst}, \emph{FuseAll}, and \emph{FuseGlobal} DQN agents perform fusion of observation and action features in alternative locations via channel-wise bias and gain modulation (akin to~\cite{perez2018film}): \emph{Baseline} fuses with the input to the ResNet-18 \texttt{conv5} stage; \emph{FuseFirst} fuses with the input to the \texttt{conv2} stage; \emph{FuseAll} fuses with the inputs to each stage from \texttt{conv2} to \texttt{conv5}; and \emph{FuseGlobal} fuses with the globally max-pooled output of the \texttt{conv5} stage. \emph{Act1024} and \emph{Act1024$\times$2} DQN agents use \emph{Baseline} fusion but larger action encoder networks with one or two hidden layers of 1024 units, respectively. The \emph{NoBalancing} agents trains the \emph{Baseline} DQN without balancing the positive and negative examples in the batches. We refer the reader to our code release on \url{https://phyre.ai} for full details.}
\label{fig:dqn_variants}
\end{figure}


\section{PHYRE Tasks}

As discussed in the main paper, the current PHYRE benchmark provides two task \emph{tiers}:
PHYRE-B tasks can be solved by placing a single ball in the initial world, whereas PHYRE-2B tasks require placement of two balls in the initial scene. Each tier provides 25 \emph{task templates},
and each task template contains 100 \emph{tasks} that are similar in design but that have a different initial configuration of bodies in the world. Figure~\ref{fig:1B-tasks} shows an example task from each of the 25 task templates in
the PHYRE-B tier, and Figure~\ref{fig:2B-tasks} shows an example task for each of
the 25 task templates in the PHYRE-2B tier.

\noindent\textbf{Stable solutions.} When designing the PHYRE tasks, we made sure that each task has a \emph{stable solution}. We define a stable solution to be an action that: (1) solves the task and (2) still solves the task if the action is slightly perturbed. The perturbations we consider are translations by 0.5 pixels along each axis (8 shifts in total).

\noindent\textbf{Task solvability.} Because the current benchmark contains $(25+25) \times 100 = 5,000$ tasks, it is cumbersome to manually find stable solutions for each task. Moreover, it is not possible to do brute-force search over all possible actions because the action space is continuous.
Therefore, we used the following stochastic approach to evaluate whether or not a task is solvable.
Let $a$ denote an action and $\tau$ a task. We define the random variable $\texttt{stably\_solves}(a, \tau)$ to be $1$ if action $a$ is a stable solution for task $\tau$ and $0$ otherwise. The random variable $\texttt{valid}(a, \tau)$ is $1$ iff action $a$ is a valid action for task $\tau$. We define the \emph{solvability level} of task $\tau$ to be: $s(\tau) = P(\texttt{stably\_solves}(a, \tau) = 1 | \texttt{valid}(a, \tau) = 1)$. To determine whether task $\tau$ is solvable, we would ideally seek to reject the hypothesis $s(\tau) = 0$.

Exact testing of this hypothesis is, however, infeasible, and so we resort to a proxy that uses a small constant $p_0$, randomly selected actions, and a binomial statistical test to reject at least one of the hypotheses: $s(\tau) \leq p_0$ or $s(\tau) \geq 2p_0$. We sample random actions until we can reject one of the two hypotheses. If the $s(\tau) \leq p_0$ hypothesis is rejected, we define the task to be \emph{solvable}. Alternatively, we define the task \emph{unsolvable} if the $s(\tau) \geq 2p_0$ hypothesis is rejected. In the unlikely event that both hypotheses are rejected we categorize the task as solvable.

It is possible to show that this algorithm requires no more than $\frac{1}{32p_0}$ action samples to reject at least one of the hypotheses with $p$-value $0.05$. In practice, the value of $p_0$ was chosen to match our intuitive sense of task solvability: for PHYRE-B, we set $p_0=10^{-5}$; for PHYRE-2B, we set $p_0=10^{-6}$.

\noindent\textbf{Tier requirements.} We used the definition of task solvability to check the correctness of the implementation of a task template. We also used task solvability to guide the selection of tasks within a template, \emph{e.g.}, the task creator may impose the constraint that a template only contains tasks with two-ball solutions and no single-ball solutions and enforce this constraint automatically.

We designed the task templates in both tiers to meet the following criteria: (1) all tasks in a tier to be solvable according to the definition of task solvability described above using samples from the action space corresponding to that tier and (2) less than 50\% of the tasks in a PHYRE-2B task template can be solvable using a single ball. Hence, the task templates in PHYRE-2B are strictly harder to solve than those in PHYRE-B.


\begin{figure}
  \setlength{\fboxsep}{0pt}
  \setlength{\fboxrule}{2pt}
  \centering
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00004.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00005.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00006.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00007.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00008.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00009.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00010.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00011.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00012.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00013.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00014.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00015.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00016.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00017.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00018.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00019.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00020.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00021.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00022.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00023.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/ball/00024.png}}
  \caption{
    The 25 task templates in the PHYRE-B tier. In each task the goal is to make
    the (dynamic) green body touch the (static) purple body or the (dynamic)
    blue body; black bodies are static and gray bodies are dynamic. Each of the
    PHYRE-B task templates gives rise to 100 tasks, each of which can be solved by
    adding a single dynamic ball to the scene.
  }
  \label{fig:1B-tasks}
\end{figure}



\begin{figure}
  \setlength{\fboxsep}{0pt}
  \setlength{\fboxrule}{2pt}
  \centering
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00100.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00101.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00102.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00103.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00104.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00105.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00106.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00107.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00108.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00109.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00110.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00111.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00112.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00113.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00114.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00115.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00116.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00117.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00118.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00119.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00120.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00121.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00122.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00123.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/v3/two_balls/00124.png}}
  \caption{
    The 25 task templates in the PHYRE-2B tier. In each task the goal is to make
    the (dynamic) green body touch the (static) purple body or the (dynamic) blue
    body; black bodies are static and gray bodies are dynamic. Each of the PHYRE-2B
    task templates gives rise to 100 related tasks, all of which can be solved by
    adding two dynamic balls to the scene.
  }
  \label{fig:2B-tasks}
\end{figure}



\begin{figure}
  \setlength{\fboxsep}{0pt}
  \setlength{\fboxrule}{2pt}
  \centering
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/115_000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/115_001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/115_002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/115_003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/115_004.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/159_000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/159_001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/159_002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/159_003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/159_004.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/173_000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/173_001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/173_002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/173_003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/173_004.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/126_000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/126_001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/126_002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/126_003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/126_004.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/264_000.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/264_001.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/264_002.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/264_003.png}}
  \fbox{\includegraphics[width=0.185\textwidth]{figs/tasks/recolor-v2/instances/264_004.png}}
  \caption{
    Each row shows five example tasks from the same task template. The size,
    initial position, and orientation of bodies vary within a template, so each
    task requires its own solution; however all tasks within a template share
    similar physical intuition and high-level strategy.
  }
  \label{fig:templates}
\end{figure}


\noindent\textbf{Solution diversity.} The task templates are designed such that solving a task instance within a template should not be trivial for an agent that knows how to solve other tasks in the template. For example, a task template should not have a single ``master solution'' that solves (nearly) all tasks in the template. At the same time, it is nearly impossible to prevent that multiple tasks in the same template share solutions because these tasks share the same design (see Figure~\ref{fig:templates}).

To measure the \emph{solution diversity} of a task template, we count the number of tasks within the template that each action can solve. Since the action space is continuous we cannot check every action. Instead, we randomly sample $10^6$ actions to estimate solution diversity. We plot the results, for each task template, as histograms in Figure~\ref{fig:1B-diversity} and~\ref{fig:2B-diversity}. Each histogram shows the number of actions ($y$-axis) that can each solve a particular number of tasks ($x$-axis) within the template. We are interested to see if one or more actions are able to solve a large fraction of the tasks within a template, which will appear as bars (of any height) on the right side of the $x$-axis. The figures show that in general tasks in the PHYRE-2B tier require more diverse solutions to be solved than those in the PHYRE-B tier.

\begin{figure}
\includegraphics[width=\linewidth]{figs/solution_diversity_ball.pdf}
  \caption{
   Analysis of the \emph{solution diversity} of the task templates in the PHYRE-B tier. Histograms show the number of actions ($y$-axis) that solve a certain number of tasks in the template ($x$-axis).
    }
  \label{fig:1B-diversity}
\end{figure}



\begin{figure}
\includegraphics[width=\linewidth]{figs/solution_diversity_two_balls.pdf}
 \caption{
   Analysis of the \emph{solution diversity} of the task templates in the PHYRE-2B tier. Histograms show the number of actions ($y$-axis) that solve a certain number of tasks in the template ($x$-axis).
  }
  \label{fig:2B-diversity}
\end{figure}



\FloatBarrier

\newpage
\section{Comparing Agents}
To determine if one agent outperforms another agent, we use the one-sided Wilcoxon test as implemented in the
\texttt{scipy.stats} Python package.\footnote{Specifically, we call \texttt{scipy.stats.wilcoxon(A, B, zero\_method=`wilcox', correction=False, alternative=`greater')} to test if the AUCCESS vector \texttt{A} outperforms AUCCESS vector \texttt{B}, where \texttt{A} and \texttt{B} are component-wise paired with one component for each fold.} To enable future work to compare with our baselines, we provide AUCCESS scores for all folds and evaluation settings in Table~\ref{tbl:auccess_all_seeds}.

\begin{table*}[!h]\centering
  \tablestyle{4pt}{1.2}\begin{tabular}{llrrrrrrrrrr}
\toprule
           & Fold &       0 &       1 &       2 &       3 &       4 &       5 &       6 &       7 &       8 &       9 \\
Setting & Agent &         &         &         &         &         &         &         &         &         &         \\
\midrule
2B (cross) & RAND &  0.0517 &  0.0212 &  0.0099 &  0.0442 &  0.0038 &  0.0356 &  0.0178 &  0.0177 &  0.0264 &  0.0275 \\
           & MEM &  0.0728 &  0.0289 &  0.0135 &  0.0783 &  0.0090 &  0.0463 &  0.0186 &  0.0387 &  0.0376 &  0.0274 \\
           & MEM-O &  0.0967 &  0.0371 &  0.0164 &  0.0933 &  0.0094 &  0.0815 &  0.0242 &  0.0451 &  0.0535 &  0.0345 \\
           & DQN &  0.3818 &  0.1944 &  0.1072 &  0.3051 &  0.0732 &  0.2703 &  0.2388 &  0.2216 &  0.2528 &  0.2730 \\
           & DQN-O &  0.5149 &  0.2682 &  0.2596 &  0.5298 &  0.2809 &  0.5313 &  0.4828 &  0.3330 &  0.3581 &  0.3987 \\
2B (within) & RAND &  0.0271 &  0.0367 &  0.0428 &  0.0301 &  0.0394 &  0.0452 &  0.0336 &  0.0287 &  0.0380 &  0.0335 \\
           & MEM &  0.0325 &  0.0336 &  0.0315 &  0.0371 &  0.0304 &  0.0314 &  0.0282 &  0.0320 &  0.0330 &  0.0347 \\
           & MEM-O &  0.0325 &  0.0336 &  0.0315 &  0.0371 &  0.0304 &  0.0314 &  0.0282 &  0.0320 &  0.0330 &  0.0347 \\
           & DQN &  0.6447 &  0.6829 &  0.6747 &  0.6763 &  0.6999 &  0.6700 &  0.6879 &  0.6704 &  0.6877 &  0.6824 \\
           & DQN-O &  0.6447 &  0.6829 &  0.6747 &  0.6763 &  0.6999 &  0.6700 &  0.6879 &  0.6704 &  0.6877 &  0.6824 \\
B (cross) & RAND &  0.1178 &  0.1242 &  0.1818 &  0.1242 &  0.0381 &  0.2250 &  0.1173 &  0.1329 &  0.0894 &  0.1460 \\
           & MEM &  0.2059 &  0.1656 &  0.2004 &  0.2263 &  0.1159 &  0.2488 &  0.1416 &  0.2467 &  0.1055 &  0.1881 \\
           & MEM-O &  0.2578 &  0.2551 &  0.2443 &  0.2552 &  0.2327 &  0.2508 &  0.1469 &  0.2801 &  0.1281 &  0.2273 \\
           & DQN &  0.4369 &  0.3096 &  0.4305 &  0.4391 &  0.2277 &  0.4440 &  0.3453 &  0.3920 &  0.1898 &  0.4646 \\
           & DQN-O &  0.6859 &  0.4867 &  0.6671 &  0.5995 &  0.4916 &  0.6560 &  0.5100 &  0.6573 &  0.3733 &  0.4884 \\
B (within) & RAND &  0.1344 &  0.1401 &  0.1379 &  0.1380 &  0.1275 &  0.1334 &  0.1395 &  0.1430 &  0.1336 &  0.1433 \\
           & MEM &  0.0198 &  0.0258 &  0.0230 &  0.0269 &  0.0223 &  0.0286 &  0.0237 &  0.0214 &  0.0223 &  0.0288 \\
           & MEM-O &  0.0198 &  0.0258 &  0.0230 &  0.0269 &  0.0223 &  0.0286 &  0.0237 &  0.0214 &  0.0223 &  0.0288 \\
           & DQN &  0.7682 &  0.7972 &  0.7822 &  0.7586 &  0.7703 &  0.7842 &  0.7801 &  0.7734 &  0.7804 &  0.7687 \\
           & DQN-O &  0.7682 &  0.7972 &  0.7822 &  0.7586 &  0.7703 &  0.7842 &  0.7801 &  0.7734 &  0.7804 &  0.7687 \\
\bottomrule
\end{tabular}
   \caption{\label{tbl:auccess_all_seeds}AUCCESS scores (on a 0.0 to 1.0 scale) of our five agents in both generalization settings, for each of our 10 folds.}
\end{table*}
 
\end{document}
