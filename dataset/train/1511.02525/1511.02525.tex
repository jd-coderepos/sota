\documentclass[11pt,a4paper]{article}
\pdfoutput=1

\usepackage{amsfonts,amsmath,amsthm,color,enumitem,graphicx,url}
\usepackage[hmargin=30mm,vmargin=30mm]{geometry}
\usepackage[numbers,sort&compress]{natbib}
\usepackage{microtype}
\usepackage{hyperref}




\newcommand{\floor}[1]{\lfloor{#1}\rfloor}
\newcommand{\ceil}[1]{\lceil{#1}\rceil}
\newcommand{\myd}[2]{\lvert #1 #2 \rvert}
\newcommand{\s}[1]{{\lvert #1 \rvert}}
\newcommand{\mylen}[1]{{\lVert #1 \rVert}}
\newcommand{\eps}{\varepsilon}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\diam}{diam}
\DeclareMathOperator{\interior}{int}

\newcommand{\myB}{\mathcal{B}} \newcommand{\myC}{\mathcal{C}} \newcommand{\myD}{\mathcal{D}} \newcommand{\myP}{\mathcal{P}} \newcommand{\myS}{\mathcal{S}}
\newcommand{\myT}{\mathcal{T}}
\newcommand{\myU}{\mathcal{U}}
\newcommand{\myV}{\mathcal{V}}

\newcommand{\myF}{\mathcal{F}}
\newcommand{\myG}{\mathcal{G}}
\newcommand{\myH}{\mathcal{H}}
\newcommand{\myR}{\mathcal{R}}

\newcommand{\myI}{\mathcal{I}}

\newcommand{\myA}{\mathcal{A}}

\newcommand{\MSTN}{\mathrm{MSFN}}
\newcommand{\MStTN}{\mathrm{MStFN}}
\newcommand{\optstab}{\mathrm{Stab}}
\newcommand{\optrel}{R^{*}}
\newcommand{\intW}{\interior(W\mspace{-1mu})}
\newcommand{\blue}{\text{blue}}
\newcommand{\red}{\text{red}}

\newcommand{\rhubt}{137/30}
\newcommand{\rstabt}{137/60}
\newcommand{\rhub}{\frac{137}{30}}
\newcommand{\rstab}{\frac{137}{60}}



\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=black,
    urlcolor=[rgb]{0,0.1,0.5},
    pdftitle={Improved approximation algorithms for relay placement},
    pdfauthor={Alon Efrat, S\'andor P. Fekete, Joseph S. B. Mitchell, Valentin Polishchuk, Jukka Suomela},
}



\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newenvironment{myabstract}
               {\list{}{\listparindent 1.5em\itemindent    \listparindent
                        \leftmargin    0cm
                        \rightmargin   0cm
                        \parsep        0pt}\item\relax}
               {\endlist}

\newenvironment{mycover}
               {\list{}{\listparindent 0pt
                        \itemindent    \listparindent
                        \leftmargin    0cm
                        \rightmargin   0cm
                        \parsep        0pt}\raggedright
                \item\relax}
               {\endlist}

\renewcommand*{\thefootnote}{\fnsymbol{footnote}}

\newcommand{\myauthor}[1]{#1\par\smallskip}
\newcommand{\myaff}[1]{{\small #1\par}\bigskip}



\setenumerate{label=(\arabic*)}
\newcommand{\mytitlebreak}{\texorpdfstring{\\}{ }}



\begin{document}

\mbox{}
\begin{mycover}
{\huge \bfseries Improved Approximation Algorithms \\ for Relay Placement \par}

\bigskip
\bigskip
\myauthor{ALON EFRAT}
\myaff{Department of Computer Science, University of Arizona}

\myauthor{S\'ANDOR P.\ FEKETE}
\myaff{Department of Computer Science, Braunschweig University of Technology}

\myauthor{JOSEPH S.\ B.\ MITCHELL}
\myaff{Department of Applied Mathematics and Statistics, Stony Brook University}

\myauthor{VALENTIN POLISHCHUK}
\myaff{Communications and Transport Systems, Link\"oping University
    \par\smallskip
    Helsinki Institute for Information Technology HIIT\\
    Department of Computer Science, University of Helsinki}

\myauthor{JUKKA SUOMELA}
\myaff{Helsinki Institute for Information Technology HIIT, \\
    Department of Computer Science, Aalto University}
\end{mycover}

\bigskip
\begin{myabstract}
\noindent\textbf{Abstract.}
In the relay placement problem the input is a set of sensors and a number , the communication range of a relay.  In the \emph{one-tier} version of the problem the objective is to place a minimum number of relays so that between every pair of sensors there is a path \emph{through sensors and/or relays} such that the consecutive vertices of the path are within distance  if both vertices are relays and within distance~1 otherwise.  The \emph{two-tier} version adds the restrictions that the path must go \emph{through relays, and not through sensors}.  We present a -approximation algorithm for the one-tier version and a PTAS for the two-tier version.  We also show that the one-tier version admits no PTAS, assuming PNP.
\end{myabstract}
\thispagestyle{empty}
\setcounter{page}{0}
\newpage



\section{Introduction}

A sensor network consists of a large number of low-cost autonomous devices, called \emph{sensors}. Communication between the sensors is performed by wireless radio with very limited range, e.g., via the Bluetooth protocol. To make the network connected, a number of additional devices, called \emph{relays}, must be judiciously placed within the sensor field.  Relays are typically more advanced and more expensive than sensors, and, in particular, have a larger communication range.  For instance, in addition to a Bluetooth chip, each relay may be equipped with a WLAN transceiver, enabling communication between distant relays.  The problem we study in this paper is that of placing a \emph{minimum number} of relays to ensure the connectivity of a sensor network.

Two models of communication have been considered in the literature \cite{bredin10deploying,chen00approximations,chen01approximations,cheng08relay,liu06optimal,lloyd07relay,srinivas06mobile,zhang07fault-tolerant}.  In both models, a sensor and a relay can communicate if the distance between them is at most~1, and two relays can communicate if the distance between them is at most~, where  is a given number.  The models differ in whether direct communication between sensors is allowed.  In the \emph{one-tier} model two sensors can communicate if the distance between them is at most~1.  In the \emph{two-tier} model the sensors do not communicate at all, no matter how close they are.  In other words, in the two-tier model the sensors may only link to relays, but not to other sensors.

Formally, the input to the relay placement problem is a set of  sensors, identified with their locations in the plane, and a number , the communication range of a relay (by scaling, without loss of generality, the communication range of a sensor is~).  The objective in the \emph{one-tier} relay placement is to place a minimum number of relays so that between every pair of sensors there exists a path, \emph{through sensors and/or relays}, such that the consecutive vertices of the path are within distance  if both vertices are relays, and within distance~1 otherwise.  The objective in the \emph{two-tier} relay placement is to place a minimum number of relays so that between every pair of sensors there exists a path \emph{through relays} such that the consecutive vertices of the path are within distance  if both vertices are relays, and within distance~1 if one of the vertices is a sensor and the other is a relay (going directly from a sensor to a sensor is forbidden).

\subsection{Previous Work}

One-tier relay placement in the special case of  \cite{bredin10deploying,cheng08relay} is equivalent to finding a Steiner tree with minimum number of Steiner nodes and bounded edge length -- the problem that was studied under the names STP-MSPBEL \cite{lin99steiner}, SMT-MSPBEL \cite{lloyd07relay,zhang07fault-tolerant}, MSPT \cite{mandoiu00note}, and STP-MSP \cite{chen00approximations,chen01approximations,cheng08relay,liu06optimal,srinivas06mobile}.
\citet{lin99steiner} proved that the problem is NP-hard and gave a 5-approximation algorithm.  Chen et al.\ \cite{chen00approximations,chen01approximations} showed that the algorithm of Lin and Xue is actually a 4-approximation algorithm, and gave a 3-approximation algorithm; \citet{cheng08relay} gave a 3-approximation algorithm with an improved running time, and a randomised 2.5-approximation algorithm.  Chen et al.\ \cite{chen00approximations,chen01approximations} presented a polynomial-time approximation scheme (PTAS) for minimising the \emph{total} number of vertices in the tree (i.e., with the objective function being the number of the original points plus the number of Steiner vertices) for a restricted version of the problem, in which in the minimum spanning tree of the set the length of the longest edge is at most constant times the length of the shortest edge.

For the general case of \emph{arbitrary} , the current best approximation ratio for one-tier relay placement is due to \citet{lloyd07relay}, who presented a simple 7-approximation algorithm, based on ``Steinerising'' the minimum spanning tree of the sensors.  In this paper we give an algorithm with an improved approximation ratio of 3.11.

Two-tiered relay placement (under the assumptions that the sensors are uniformly distributed in a given region and that ) was considered by \citet{hao04fault-tolerant} and \citet{tang06relay} who suggested constant-factor approximation algorithms for several versions of the problem.  \citet[Thm.~4.1]{lloyd07relay} and \citet[Thm.~1]{srinivas06mobile} developed a general framework whereby given an -approximate solution to Disk Cover (finding minimum number of unit disks to cover a given set of points) and a -approximate solution to STP-MSPBEL (see above), one may find an approximate solution for the two-tier relay placement.  In more details, the algorithm in \citet{lloyd07relay} works for arbitrary  and has an approximation factor of ; the algorithm in \citet{srinivas06mobile} works for  and guarantees an -approximate solution.  Combined with the best known approximation factors for the Disk Cover \cite{hochbaum85approximation} and STP-MSPBEL \cite{chen00approximations,chen01approximations,cheng08relay}, these lead to  and  approximations for the relay placement respectively.  In this paper we present a PTAS for the two-tiered relay placement; the PTAS works directly for the relay placement, without combining solutions to other problems.

A different line of research \cite{misra08constrained,carmi07covering} concentrated on a ``discrete'' version of relay placement, in which the goal is to pick a minimum subset of relays from a \emph{given} set of possible relay locations.  In this paper we allow the relays to reside anywhere in the plane.

\subsection{Contributions}

We present new results on approximability of relay placement:
\begin{itemize}[itemsep=0.5ex]
    \item In Section~\ref{sec_apx1tier} we give a simple -time 6.73-approximation algorithm for the one-tier version.
    \item In Section~\ref{sec_apx1tierim} we present a polynomial-time 3.11-approximation algorithm for the one-tier version.
    \item In Section~\ref{sec_inapx1tier} we show that there is no PTAS for one-tier relay placement (assuming that  is part of the input, and PNP).
    \item In Section~\ref{sec_ptas} we give a PTAS for two-tier relay placement.
\end{itemize}
Note that the \emph{number} of relays in a solution may be exponential in the size of the input (number of bits).  Our algorithms produce a succinct representation of the solution.  The representation is given by a set of points and a set of line segments; the relays are placed on each point and equally-spaced along each segment.



\section{Blobs, Clouds, Stabs, Hubs, and Forests}\label{sec_prelim}

In this section we introduce the notions, central to the description of our algorithms for one-tier relay placement.  We also provide lower bounds.

\subsection{Blobs and Clouds}

We write  for the Euclidean distance between  and~. Let  be a given set of sensors (points in the plane).  We form a unit disk graph  and a disk graph  where

see Figure~\ref{fig:clouds}a.

\begin{figure}[t]
    \centering
    \scalebox{0.9}{\begin{picture}(0,0)\includegraphics{clouds2.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6278,5284)(-1184,-5918)
\put(2476,-1186){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4141,-1411){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-1169,-781){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(-1169,-4381){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(-1169,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\end{picture} }
    \caption{(a)~Dots are sensors in , solid lines are edges in  and , and dashed lines are edges in  only. There are 5 blobs in  (one of them highlighted) and 2 clouds . The wide grey line is the only edge in , which happens to be equal to  here. (b)~Stabs. (c)~Hubs.}\label{fig:clouds}
\end{figure}

A \emph{blob} is defined to be the union of the unit disks centered at the sensors that belong to the same connected component of . We use  to refer to a blob, and  for the set of all blobs.

Analogously, a \emph{cloud}  is the union of the unit disks centered at the sensors that belong to the connected component of the graph . The sensors in a blob can communicate with each other without relays, while the ones in a cloud might not, even though their disks may overlap. Each cloud  consists of one or more blobs ; we use  to denote the blobs that form the cloud~.

\subsection{Stabs and Hubs}

A \emph{stab} is a relay with an infinite communication range (). A \emph{hub} is a relay without the ability to communicate with the other relays (thus hubs can enable communication within one cloud, but are of no use in communicating between clouds). As we shall see, a solution to stab or hub placement can be used as the first step towards a solution for relay placement.

If we are placing stabs, it is necessary and sufficient to have a stab in each blob to ensure communication between all sensors (to avoid trivialities we assume there is more than one blob). Thus, stab placement is a special case of the set cover problem: the universe is the blobs, and the subsets are sets of blobs that have a point in common.  We use  to denote the minimum set of stabs that stab each blob in . In the example in Figure~\ref{fig:clouds}b small rectangles show an optimal solution to the stab placement problem; 3 stabs are enough.

If we are placing hubs, it is necessary (assuming more than one blob in the cloud), but not sufficient, to have a hub in each blob to ensure communication between sensors within one cloud.  In fact, hub placement can be interpreted as a special case of the \emph{connected} set cover problem \cite{cerdeira05requiring,shuai06connected}.  In the example in Figure~\ref{fig:clouds}c small rectangles show an optimal solution to the hub placement problem for the cloud ; in this particular case, 2 stabs within the cloud  were sufficient to ``pierce'' each blob in  (see Figure~\ref{fig:clouds}b), however, an additional hub (marked red in Figure~\ref{fig:clouds}c) is required to ``stitch'' the blobs together (i.e., to establish communication between the blobs). The next lemma shows that, in general, the number of additional hubs needed  is less than the number of stabs:

\begin{lemma}\label{lem_stab2hub}
    Given a feasible solution\/  to stab placement on\/ , we can obtain in polynomial time a feasible solution to hub placement on\/  with\/  hubs.
\end{lemma}

\begin{proof}
    Let  be the graph, whose nodes are the sensors in the cloud  and the stabs in , and whose edges connect two devices if either they are within distance~1 from each other or if both devices are stabs (i.e., there is an edge between \emph{every} pair of the stabs).  Switch off communication between the stabs, thus turning them into hubs.  Suppose that this breaks  into  connected components. There must be a stab in each connected component. Thus, .

    If , by the definition of a cloud, there must exist a point where a unit disk covers at least two sensors from two different connected components of . Placing a hub at the point decreases the number of the connected components by at least~1. Thus, after putting at most  additional hubs, all connected components will merge into one.
\end{proof}

\subsection{Steiner Forests and Spanning Forests with Neighbourhoods}

Let  be a collection of planar subsets; call them \emph{neighbourhoods}. (In Section~\ref{sec_apx1tier} the neighbourhoods will be the clouds, in Section~\ref{sec_apx1tierim} they will be ``clusters'' of clouds.)  For a plane graph , let  be the graph whose vertices are the neighbourhoods and two neighbourhoods  are adjacent whenever  has a vertex in , a vertex in , and a path between the vertices.

The \emph{Minimum Steiner Forest with Neighbourhoods} on , denoted , is a \emph{minimum-length} plane graph  such that  is connected. The  is a generalisation of the Steiner tree of a set of points. Note that  is slightly different from Steiner tree with neighbourhoods (see, e.g., \citet{yang07minimum}) in that we are only counting the part of the graph \emph{outside}  towards its length (since it is not necessary to connect neighbourhoods beyond their boundaries).

Consider a complete weighted graph whose vertices are the neighbourhoods in  and whose edge weights are the distances between them.  A minimum spanning tree in the graph is called the \emph{Minimum Spanning Forest with Neighbourhoods} on , denoted .  A natural embedding of the edges of the forest is by the straight-line segments that connect the corresponding neighbourhoods; we will identify  with the embedding.  (As with , we count the length of  only \emph{outside}~.)

We denote by  and  the total length of the edges of the forests.  It is known that

for a \emph{point} set , where  is the \emph{Steiner ratio} \cite{du90approach}. The following lemma generalises this to neighbourhoods.
\begin{lemma}\label{lem_StRatio}
    For any\/ , .
\end{lemma}
\begin{proof}
    If  is erased,  falls off into a forest, each tree of which is a minimum Steiner tree on its leaves; its length is within the Steiner ratio of minimum spanning tree length.
\end{proof}

\subsection{Lower Bounds on the Number of Relays}\label{ssec:lower-bounds}

Let  be an optimal set of relays.  Let  be the communication graph on the relays  alone, i.e., without sensors taken into account; two relays are connected by an edge in  if and only if they are within distance  from each other. Suppose that  is embedded in the plane with vertices at relays and line segments joining communicating relays.  The embedding spans all clouds, for otherwise the sensors in a cloud would not be connected to the others. Thus, in  there exists a forest , whose embedding also spans all clouds. Let  denote the total length of the edges in . By definition of , we have .

Let , , and  be the number of edges, vertices, and trees of .  Since each edge of  has length at most , we have . Since , since there must be a relay in every blob and every cloud, and since the clouds are disjoint, it follows that




\section{A 6.73-Approximation Algorithm for\mytitlebreak One-Tier Relay Placement}\label{sec_apx1tier}

In this section we give a simple 6.73-approximation algorithm for relay placement.  We first find an approximately optimal stab placement. Then we turn a stab placement into a hub placement within each cloud. Then a spanning tree on the clouds is found and ``Steinerised''.

Finding an optimal stab placement is a special case of the set cover problem. The maximum number of blobs pierced by a single stab is~ (since this is the maximum number of unit disks that can have non-empty intersection while avoiding each other's centers). Thus, in this case the greedy heuristic for the set cover has an approximation ratio of  \cite[Theorem~35.4]{cormen01introduction}.

Based on this approximation, a feasible hub placement  within one cloud  can be obtained by applying Lemma~\ref{lem_stab2hub}; for this set of hubs it holds that

We can now interpret hubs  as relays; if the hubs make the cloud  connected, surely it holds for relays.

Let  denote all relays placed this way. Since the blobs  for different  do not intersect, , so


Next, we find  and place another set of relays, , along its edges.  Specifically, for each edge  of the forest, we place  relays at the endpoints of , and   relays every  units starting from one of the endpoints. This ensures that all clouds communicate with each other; thus  is a feasible solution. Since the number of edges in  is ,

We obtain

from \eqref{eq_lower_bound_MStTN}--\eqref{eq_R2} and Lemma~\ref{lem_StRatio}.

\subsection{Running Time}

To implement the above algorithm in  time, we construct the blobs (this can be done in  time since the blobs are the union of disks centered on the sensors), assign each blob a unique colour, and initialise a Union-Find data structure for the colours. Next, we build the arrangement of the blobs, and sweep the arrangement  times, once for each ; upon encountering a -coloured cell of the arrangement, we place the stab anywhere in the cell, merge the corresponding  colours, and continue. Finally, to place the hubs we do one additional sweep.

As for the last step -- building  -- it is easy to see that just as the ``usual'' minimum spanning tree of a set of points,  uses only the edges of the relative neighbourhood graph of the sensors (refer, e.g., to \citet[p.~217]{berg08computational} for the definition of the graph).
Indeed, let  be an edge of ; let  and  be the sensors that are within distance  of  and , respectively. If there existed a sensor  closer than  to both  and , the edge  could have been swapped for a shorter edge (Figure~\ref{fig:nlogn}).
\begin{figure}[ht]
\centering
\scalebox{1.1}{\begin{picture}(0,0)\includegraphics{nlogn}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2266,780)(2918,-586)
\put(3736, 51){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3106,-263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4906,-263){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4591,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4633,-226){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4014,-97){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\caption{Edge  could be swapped for a shorter edge.}\label{fig:nlogn}
\end{figure}

It remains to show how to build and sweep the arrangement of blobs in  time.
Since the blobs are unions of unit disks, their total complexity is linear (see, e.g., \citet[Theorem~13.9]{berg08computational}). Moreover, the arrangement of the blobs also has only linear complexity (see Lemma~\ref{lem:arr} below); this follows from the fact that every point can belong to only a constant number of blobs (at most ). Thus, we can use sweep to build the arrangement in  time, and also, of course, sweep the arrangement within the same time bound.

\begin{lemma}\label{lem:arr}
The arrangement of the blobs has linear complexity.
\end{lemma}
\begin{proof}
The vertices of the arrangement are of two types -- the vertices of the blobs themselves and the vertices of the intersection of two blobs (we assume that no three blobs intersect in a single point). The total number of the vertices of the first type is linear, so we focus on the vertices of the second type.

Let  be a tile in the infinite unit-square tiling of the plane. There is not more than a constant number  of blobs that intersect  (since there is not more than a constant number of points that can be placed within distance  from  so that the distance between any two of the points is larger than~). Let  be the number of disks from blob  that intersect . Every vertex of the arrangement inside  is on the boundary of the union of some two blobs. Because the union of blobs has linear complexity, the number of vertices that are due to intersection of blobs  and  is . Since there is at most  blobs for which , we have

where  is the total number of disks intersecting . Clearly, each unit disk intersects only a constant number of the unit-square tiles, and only a linear number of tiles is intersected by the blobs. Thus, summing over all tiles, we obtain that the total complexity of the arrangement is .
\end{proof}




\section{A 3.11-Approximation Algorithm for\mytitlebreak One-Tier Relay Placement}\label{sec_apx1tierim}

In this section we first take care of clouds whose blobs can be stabbed with few relays, and then find an approximation to the hub placement by greedily placing the hubs themselves, without placing the stabs first, for the rest of the clouds. Together with a refined analysis, this gives a polynomial-time -approximation algorithm.  We focus on nontrivial instances with more than one blob.

\subsection{Overview}

The basic steps of our algorithm are as follows:
\begin{enumerate}[noitemsep]
\item Compute optimal stabbings for the clouds that can be stabbed with few relays.
\item Connect the blobs in each of these clouds, using Lemma~\ref{lem_stab2hub}.
\item Greedily connect all blobs in each of the remaining clouds (``stitching'').
\item Greedily connect clouds into clusters, using 2 additional relays per cloud.
\item Connect the clusters by a spanning forest.
\end{enumerate}

Our algorithm constructs a set  of ``red'' relays (for connecting blobs in a cloud, i.e., relays added in steps~1--3), a set  of ``green'' relays (two per cloud, added in steps~4--5) and a set  of ``yellow'' relays (outside of sensor range, added in step~5). Refer to Figures~\ref{fig:red} and~\ref{fig:greenyellow}. In the analysis, we compare an optimal solution  to our approximate one by subdividing the former into a set  of ``dark'' relays that are within reach of sensors, and into a set  of ``light'' relays that are outside of sensor range. We compare  with , and  with , showing in both cases that the ratio is less than~.
\begin{figure}\centering
\begin{picture}(0,0)\includegraphics{red}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5198,5308)(-1139,-5783)
\end{picture} \caption{Red relays placed by our algorithm (the sensors are the solid circles); the numbers indicate the order in which the relays are placed within each cloud. (a)~Stab the clouds that can be stabbed by placing few relays; the clouds are then stitched by placing the hubs as in Lemma~\ref{lem_stab2hub}. (b)~Greedily stitch the other clouds.}\label{fig:red}
\end{figure}

\begin{figure}\centering
\includegraphics[page=1]{figs.pdf}
\caption{(a)~Green relays connect clouds into clusters -- on average, we use at most 2 green relays per cloud. (b)~Green (inside clouds) and yellow (outside clouds) relays interconnect the cloud clusters by a spanning tree.}\label{fig:greenyellow}
\end{figure}

\subsection{Clouds with Few Stabs}

For any constant , it is straightforward to check in polynomial time whether all blobs in a cloud  can be stabbed with  stabs. (For any subset of  cells of the arrangement of unit disks centered on the sensors in , we can consider placing the relays in the cells and check whether this stabs all blobs.)  Using Lemma~\ref{lem_stab2hub}, we can connect all blobs in such a cloud with at most  red relays. We denote by  the set of clouds where the minimum number of stabs is , and by  the set of clouds that need at least  stabs.

\subsection{Stitching a Cloud from \texorpdfstring{}{Ck+}}

We focus on one cloud . For a point  in the plane, let

be the set of blobs that contain the point; obviously  for any . For any subset of blobs , define  to be the set of blobs \emph{not from } containing , and define  to be the set of sensors that form the blobs in~.

Within , we place a set of red relays , as follows:
\begin{enumerate}
    \item Choose arbitrary .
    \item Initialise , .
    \item While :
        \\label{eq_J+1}
        \sum_{B\in \myB_C} \!\! w(B) \,=\, \s{A_r^C}+1.
    
        {\sum_{B \in \myU(z)} \!\!\! w(B)} \,\le\, 1 .
    
        {\sum_{B \in \myV(z)} \!\!\! w(B)} \,\le\, \frac{1}{\s{\myV(z)}} + \frac{1}{\s{\myV(z)} - 1} + \dotsb + \frac{1}{1} .
    
        \myS(\myT_j, z) \setminus \myS(\myT_{j+1}, z)
        \,=\, \myB(z)\cap \myS_j
        \,=\, \myV(z) \cap \myS_j .
    
        \sum_{B \in \myV(z)} w(B)
        \,\le\, \frac{a_1}{a_1+a_2+\dotsb+a_n} + \frac{a_2}{a_2+a_3+\dotsb+a_n} + \dotsb + \frac{a_n}{a_n} ,
    \label{eq_Wz<}
        W(z) \,= {\sum_{B\in \myU(z)} \!\!\! w(B) \,+\, \sum_{B\in \myV(z)} \!\!\! w(B)}
        \,\le\, 1 + \frac14 + \frac13 + \frac12 + \frac11
        \,=\, \frac{37}{12}.
    
            \frac{37}{12} \s{\optrel_d \cap C}
            \,\ge\! \sum_{z \in \optrel_d \cap C} \!\! W(z)
            \,\ge\! \sum_{B\in \myB_C} \!\! w(B) \,=\, \s{A_r^C} + 1. \qedhere
    
    \s{\optrel_d} \ge k\s{\myC^{k+}}+\sum_{i=1}^{k-1}i \s{\myC^i}

    \s{A_r}+\s{A_g}
    &\,\le \sum_{C \in \myC^{k+}} \left( \frac{37}{12} \s{\optrel_d \cap C} - 1 \right) +
\sum_{i=1}^{k-1} (2i-1)\s{\myC^{i}} + 2 \s{\myC} - 2 \\
    &\,\le\, \frac{37}{12} \biggl( \s{\optrel_d} - \sum_{i=1}^{k-1} i\s{\myC^{i}} \biggr) + \s{\myC^{k+}} + \sum_{i=1}^{k-1} (2i+1)\s{\myC^{i}} - 2 \\
    &\,\le\, \frac{37}{12} \s{\optrel_d} + \s{\myC^{k+}}
    \,<\, \left( 3.084 +\frac{1}{k} \right) \s{\optrel_d}.

        \left(\frac{4}{\sqrt{3}} + \frac{4}{5}\right) \s{\optrel_w} < 3.11 \s{\optrel_w}
    \label{eq_yellow_bw}
        b \le w.
    \label{eq_yellow_95wbg}
    \frac95 w
    \,\ge\, \frac15 (6 w_2 + w_1) + \frac45 (w_2 + w_1)
    \,=\, (w_2 + w_1) + w_2
    \,=\, b + g.

        \begin{split}
        \frac{2}{\sqrt{3}} (b+w) + g
        &\,=\, \left(\frac{2}{\sqrt{3}} - 1\right) (b+w) + b+g + w \\
        &\,\le\, \left(\frac{2}{\sqrt{3}} - 1\right) 2 w + \frac{9}{5} w + w
        \,=\, \left(\frac{4}{\sqrt{3}} + \frac45 \right)w
        \,<\, 3.11 w .
        \end{split}
    
    \alpha \,=\, 1 + \frac{C-B}{B + \Delta A + 1}

    \alpha - 1 \,<\, \frac{C-B-2\eps}{B +\eps + \Delta A+1/n}

    \begin{split}
    c - b
    &\,\ge\, (C-\eps)n + 2\s{E} + 1 - \alpha \bigl((B+\eps)n + 2\s{E} + 1\bigr) \\
    &\,\ge\, \bigl(C - B - 2 \eps - (\alpha-1)(B+ \eps + \Delta A + 1/n)\bigr) n
    \,>\, 0,
    \end{split}

    \s{S} \,\le\, O(ns) + (1+1/m) \s{\optrel} r .

    \s{R} \,\le\, O(n + ns/r) + \s{S}/r \,\le\, O(ns/r) + (1+1/m) \s{\optrel}.

    ns/r \,=\, D/(mr) \,\le\, (1/m) \s{\optrel},

and we conclude that  is within factor  of .

\subsection{Dense Instances}

In Section~\ref{sec_lem_rounding} we prove the following lemma showing
that we can focus on a polynomial-size set  of candidate relay
positions.

\begin{lemma}\label{lem_rounding}
For any fixed positive integer  and a given dense instance of the
two-tier relay placement problem, we can construct in polynomial time
a (polynomial-size) set of points  such that there exists a
feasible, -approximate solution  with .
\end{lemma}


Lemma~\ref{lem_rounding} implies that, in our quest for a PTAS for our
two-tier relay placement problem, it suffices for us to consider sets
of relays on the grid~.

Our PTAS method is based on the -guillotine framework of
\citet{mitchell99guillotine}.  We review a few definitions.  Let  be
a connected set of line segments with endpoints in . A {\em window}
 is an axis-aligned rectangle whose defining coordinates are - and
-coordinates of the grid points .  A {\em cut} is a horizontal
or vertical line , through a point of , that intersects
, the interior of window . The intersection, , of a cut  with  consists of a
discrete (possibly empty) set of crossing points where an edge from
 crosses~. Let the crossing points be denoted by
, in order along~.  We define the {\em
  -span}, , of  (with respect to ) to be
the empty set if , and to be the (possibly
zero-length) line segment  otherwise.

A cut  is {\em -perfect with respect to } if
.  The edge set  is {\em -guillotine
  with respect to window } if either
\begin{enumerate}
    \item , or
    \item there exists an -perfect cut, , with respect to
      , such that  is -guillotine with respect to windows
       and , where ,  are the closed
      halfplanes defined by~.
\end{enumerate}
We say that  is {\em -guillotine} if  is -guillotine with
respect to the axis-aligned bounding box of~.

\begin{figure}\centering
\includegraphics[page=2]{figs.pdf}
\caption{Optimal solution  and tree . (a)~Red and blue disks. (b)~Red and blue squares.}\label{fig:redblue}
\end{figure}

Let  denote an optimal solution to the two-tier relay placement
problem restricted to points of the grid .  Associated with 
is a tree  whose internal nodes are the set  and whose
leaves are the  input points (sensors) , with every edge of
 between two relays having length at most  and every edge of
 between a relay and a leaf (sensor) having length at most~1; see Figure~\ref{fig:redblue}.
Some edges of  are blue (those of length at most  between two
relays), and some edges are red (those of length at most 1 between a
red relay and a sensor).  Relays that are incident on red edges are
{\em red} and all other relays are {\em blue}.  We place {\em red
  disks} of radius 1 centered at each red relay and place {\em blue
  disks} of radius  centered at {\em every} relay (blue or red).
Each red disk (resp., blue disk) has an associated bounding box, which
we call a {\em red square} (resp., {\em blue square}).  We observe
that each blue relay has constant degree in  (in fact, at most 5,
based on the degree bound of Euclidean minimum spanning trees in the
plane), and no point in the plane lies in more than a constant number
of blue squares (for the same basic reasons as the degree bound --
otherwise, the set of relays could be reduced, while maintaining
communication connectivity).  Further, we observe that the union of
the edges bounding all blue squares is connected (since the blue edges
of  form a subtree of , and any two relays joined by a blue
edge must have their corresponding blue squares intersecting).

The -guillotine method is typically applied to a set of {\em edges}
of some network.  We now define a related concept, that of a set of
relays being ``-guillotine''.  Let  be a set of
relays that is feasible for , meaning that there is an associated
tree  with leaves at , blue edges of lengths at most  and red
edges of lengths at most 1.  Let  be the set of (axis-parallel)
edges bounding the blue squares associated with , and let  be
the set of (axis-parallel) edges bounding the red squares associated
with .  Consider a window  (on the grid induced by the points
) and a horizontal/vertical cut  intersecting .

The intersection, , of a cut  with
 consists of a discrete (possibly empty) set of
crossing points where an edge from  crosses~.
Without loss of generality, consider a vertical cut ,
and let  denote its intersection with the window~.
We now define the {\em blue -span},
, of  (with respect to ), as follows.
As we walk along  from  towards , we enter various blue squares;
let  be the th entry point, if it exists; if we enter fewer than 
blue squares, then we define the blue -span to be empty.
(Note that the point  may lie within more than one blue square;
however, we can always assume that no point lies within more than a constant number of blue squares.)
Similarly, as we walk along  from  towards , we enter various blue squares;
let  be the th entry point, if it exists; if we enter fewer than 
blue squares, then we define the blue -span to be empty.
Then, if  is closer to  than , and the length of  is at least  (implying that
 fully crosses at least one blue square, entering and exiting it), we define the blue -span,
, of  (with respect to ), to be the segment , a subsegment of ; otherwise,
we define the blue -span to be empty. See Figure~\ref{fig:bluespan} for an illustration.
Note that, if nonempty, by definition the blue -span has length at least , the side length of a blue square;
further, if the blue -span is empty, then  intersects  blue squares.
We similarly
define the {\em red -span}, , of  (with
respect to ) based on the entry points along  of red squares.
Note that, if nonempty, by definition the red -span has length at least 1;
further, if the red -span is empty, then  intersects  red squares.

\begin{figure}\centering
\includegraphics[page=3]{figs.pdf}
\caption{A horizontal cut  (dashed line) and the blue -span  for  (thick line).}\label{fig:bluespan}
\end{figure}

We say that a nonempty blue
-span  is {\em relay-dense}
if  includes relays at
all points of  that are corners of ()-by-() grid cells intersected
by  ; the corresponding relays are called a {\em relay-dense bridge}; see Figure~\ref{fig:densebridge}.  ( includes the points  of the regular square grid of spacing
 that covers the bounding rectangle of ; see
Section~\ref{sec_lem_rounding}.)
Similarly, we say that a nonempty red -span is {\em relay-dense} if
 includes relays
at all points of  that are corners of (1/2)-by-(1/2) grid cells that contain points of 
(which implies that it includes at least one (red) relay within each disk of radius 1,
centered at , that is intersected by );
the corresponding red relays are called a {\em (red) relay-dense bridge}.
( includes the points  at the corners of the cells of the regular square grid of spacing 1/2 that contain points ;
see Section~\ref{sec_lem_rounding}.)

\begin{figure}\centering
\includegraphics[page=4]{figs.pdf}
\caption{(a)~Regular square grid  of spacing . (b)~A relay-dense -span .}\label{fig:densebridge}
\end{figure}

A cut  is {\em -perfect with respect to } if
the nonempty -spans (red and blue) along  are relay-dense.
The set  of relays is {\em -guillotine
  with respect to window } if either
\begin{enumerate}
    \item there are no blue squares of  interior to , or
    \item there exists an -perfect cut, , with respect to
      , such that  is -guillotine with respect to windows
       and , where ,  are the closed
      halfplanes defined by~.
\end{enumerate}
We say that  is {\em -guillotine} if  is -guillotine with
respect to the axis-aligned bounding box of~.

\begin{lemma}\label{lem_guillotine_relays}
Let  be a fixed positive integer, and let  be a given dense
instance of the two-tier relay placement problem.  Then, for any set
 of relays that is feasible for the instance, there exists an
-guillotine set  of relays, also feasible for the instance, with
.
\end{lemma}

\begin{proof}
We argue that we can add a small number, at most ,
of relays to  to make it -guillotine, if it is not already.

First, consider the set of blue and red squares associated with ;
these are the bounding boxes of the disks of radius  centered at
all relays and disks of radius 1 centered at red relays.  Let 
and  be the (axis-parallel) edges bounding the blue and red
squares, respectively.

By the standard -guillotine arguments \cite{mitchell99guillotine},
we know that  can be augmented by ``blue'' bridges (-spans) of
length totalling , so that the resulting set of
edges is -guillotine (in the usual sense).  A similar statement
holds for the set  of red edges, which can be augmented by
``red'' bridges to make the set -guillotine if it is not already
-guillotine.  In fact, by a slight modification of the usual
argument, we can claim that we can augment  by a set of
red and blue bridges so that the resulting set is collectively
-guillotine, with a common recursive partitioning by cuts: For each
cut  in the recursive decomposition, we can choose 
(horizontal or vertical, in an appropriate position) so that the red
-span (with respect to ) and the blue -span (with respect
to ) can each be charged off to the red and blue lengths of the
input, charging the input with a factor of .  In more detail,
we define the cost of a vertical cut at position  to be
, where  is the length of the -span at
position  of the red edges , and  is the length of the
-span at position  of the blue edges .  The union of
-spans over all  defines a ``red region'' and a ``blue region''
with respect to vertical cuts, and the integral,  gives the weighted sum of the areas of these
regions, weighting the length of the blue -span by  (this is
to reflect the fact that the blue squares are  times as large as
the red squares, and our goal is to count the cardinality of squares).
Similarly, we can define red and blue regions with respect to {\em
  horizontal cuts}, and functions,  and , that define
the cost of such cuts.

The (weighted) areas of the red/blue regions with respect to
horizontal cuts are given by the integrals  and
; equivalently they are given by the integrals,
 and , of the lengths
 and  of the vertical sections of the regions.  These
lengths ( and ) represent the ``chargeable length'' of
vertical cuts at position .  Then, assuming that the weighted sum
of the areas of the red and blue regions with respect to horizontal
cuts is greater than that with respect to vertical cuts, we get that
there must be a vertical cut at some position  where
.  A vertical
cut through  can then have its red -span charged to 
of the length of edges bounding red squares (i.e.,  times the
number of red squares) and its blue -span charged to 
times the length of edges bounding blue squares (i.e.,  times
the number of blue squares/relays).

Next, consider each blue bridge (-span) that the above argument
shows we can afford to add (charging  times the number of
relays), to make  -guillotine (as a network).  We can convert
any such blue bridge of length  into 
relays on or near the corresponding cut , in order to make the
cut relay-dense (i.e., to include relays at all points of  that
are corners of ()-by-() grid cells intersected by the blue
bridge).
Similarly, each red bridge (-span), of length , that is added in order to make
 -guillotine (as a network) can be converted into 
red relays that stab all disks of radius 1, centered at points of , that are
intersected by the red bridge.
Similarly, we say that a nonempty red -span is {\em relay-dense} if
 includes at least one (red) relay from the set  within each disk of radius 1,
centered at , that is intersected by .
The purpose of relay-dense bridges of red relays is to ensure that
sensors within distance 1 of the boundary of  are covered by the unit disks
of the red relay-dense bridge, if they are not covered by
the unit disks associated with the  unbridged red relays.  This allows for ``separation''
between subproblems in the dynamic program.

Finally, we conclude that the total number of relays added is 
times .  If we let the lengths of blue bridges be
 and let the lengths of red bridges be
, then we know, from the charging scheme for making
 and  -guillotine, that  is at most  times the total
perimeters of all blue squares plus  times the total
perimeters of all red squares.  This implies that  is at most  times
the number of relays of .  By construction, we know that if
 is nonzero, then , and that
if  is nonzero, then .  Thus,
the total number of relays added,  is at most  times the number
of relays of .
\end{proof}


Applying Lemma~\ref{lem_guillotine_relays} and Lemma~\ref{lem_rounding} yields the following

\begin{corollary}
Let  be a fixed positive integer, and let  be a given dense instance of
the two-tier relay placement problem.
Then, there exists an -guillotine
set  of relays with .
\end{corollary}

We now describe the algorithm that yields the claimed PTAS for
computing  approximately.  The algorithm is based on a dynamic
program to compute a minimum-cardinality -guillotine set, , of
relays that obeys certain connectivity and coverage constraints.  A
subproblem is specified by a window  (with coordinates from the
grid ), together with a constant (depending on ) amount of boundary information:
\begin{enumerate}
\item A set of  (unbridged) blue relays (from ) whose
  blue squares intersect the boundary of , and a set of  red
  relays (from ) whose red squares intersect the boundary of~.
\item The blue -spans, which determine the set of relays
  forming the relay-dense bridge; in order to describe the relay-dense
  bridge, we have only to specify the endpoints of the blue -span,
  as this gives a succinct encoding of the relays that form the
  relay-dense bridge.  There are up to 4 blue -spans, one per side
  of .
\item The red -spans, which determine the set of red relays
  forming the relay-dense bridge; in order to describe the relay-dense
  bridge, we have only to specify the endpoints of the red -span,
  as this gives a succinct encoding of the relays that form the
  relay-dense bridge.
\item Connectivity requirements among the relays specified along
  the boundary.  Specifically, there are  entities specified
  along the boundary of :  unbridged relays per side of
  , and up to two -spans per side of , which encode the
  relay-dense bridges.  The connectivity requirements are specified as
  a collection of (disjoint) subsets of these  entities, with
  the understanding that each such subset of entities must be
  connected within  by edges of the communication graph that
  connects two relays if and only if they are at distance at most 
  from each other.
\end{enumerate}
We require that the solution to a subproblem gives a set of red relays
whose unit disks cover all sensors interior to  that are not
covered by the relays specified along the boundary (either the 
unbridged red relays or the relay-dense bridges of red relays),
together with a set of blue relays within the subproblem that enable
connectivity.  The dynamic program optimizes over all choices of cuts
 (horizontal or vertical) of , and all choices of boundary
information along the cut  that are compatible with the boundary
information for .  Since, for fixed , there are a polynomial
number of different subproblems, and a polynomial number of choices of
cuts and boundary information within the dynamic programming
recursion, we have completed the proof of the main result, Theorem~\ref{thm:ptas}.

\subsection{Proof of Lemma~\ref{lem_rounding}}\label{sec_lem_rounding}

\paragraph{\boldmath Construction of .}


Let  be the regular square grid of spacing  that
covers the bounding rectangle of ; the points of  are
the corners of ()-by-() squares that form a regular grid.
By construction, the grid  has  points.

Consider now the regular square grid of spacing  that covers the
bounding rectangle of~.  Let  be the subset of these
grid points that are within distance 1 of one of the  input points~.
Then,  are the corners of ()-by-() squares
of a regular grid, and there are only  such corner points.

We construct an \emph{iterated circle arrangement}  recursively as follows. As the base case, let . Then, for each , the arrangement  is constructed as follows: For each point , add  to , as well as the \emph{special points} located  unit below  and  units below . Then draw circles of radii  centered at each point of . Finally, add the vertices (crossing points) of this arrangement to~.

Finally, let . The size of  is polynomial in , for a constant .

\paragraph{\boldmath Construction of .}

Consider an optimal solution  and the minimum-length communication tree  associated with it; let  be the blue subtree of . Since  is an MST of , the maximum degree of any relay in  is . Hence there is a set  of  blue edges whose removal breaks  into subtrees, each having at most  relays.

We construct a new solution  that conforms to  as follows; see Figure~\ref{fig:snapdense} for an illustration. First, for each edge , we add a new relay  at a point of  that is within distance  from  and ; then we replace the edge  by two edges,  and . The new blue edge  becomes part of the same subtree as , and the edge  becomes part of the same subtree as .

\begin{figure}
    \centering
    \scalebox{1.0}{\begin{picture}(0,0)\includegraphics{snapdense}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5627,1712)(-225,-917)
\put(1126,-601){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(271,389){\makebox(0,0)[rb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}:}}}}}
\put(2791,389){\makebox(0,0)[rb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}:}}}}}
\put(3781,254){\makebox(0,0)[rb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1531,-151){\makebox(0,0)[rb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(811, 29){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3286, 29){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4006,-151){\makebox(0,0)[rb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1081,209){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
    \caption{Construction of  for dense instances. Each edge in the set  is replaced by a path of length . The grey area shows one of the subtrees. The leaf nodes of the subtree are now pinned at points of , and there are at most  internal nodes. Figure~\ref{fig:pinsubtree} shows how we can ``pin'' the internal nodes of the subtree to points of .}\label{fig:snapdense}
\end{figure}

So far we have added  new relays, and we have partitioned the communication tree into edge-disjoint subtrees. The leaf nodes of the subtrees are sensors or newly added relays; both of them are located at points of . There are at most  internal nodes in each subtree. To prove Lemma~\ref{lem_rounding}, it is sufficient to show that we can move the internal relays so that they are located at points of , and while doing so we do not break any sensor--relay or relay--relay connections.

We say that a relay is \emph{pinned} if it is located at a point of . We show how to pin all relays in  iterations. In the beginning, we have partitioned the communication tree into edge-disjoint subtrees where the leaf nodes are pinned at  and there are at most  internal nodes in each subtree. In what follows, we will show that we can move the internal nodes and refine the partition so that after iteration , we have partitioned the communication tree into edge-disjoint subtrees where the leaf nodes are pinned at  and there are at most  internal nodes in each subtree. Hence after  iterations, we have pinned all nodes at .

Observe that it is sufficient to show that if  is a subtree where leaf nodes are pinned at , then we can move the internal nodes so that at least one node  becomes pinned at . Then we can partition the subtree  into smaller, edge-disjoint subtrees that share the leaf node . Each of the new subtrees has all leaf nodes pinned at  and they also have fewer internal nodes than .

Consider a subtree . Start translating (in any direction) the internal nodes of , while keeping the leaf nodes in place. This translation will cause some edge  linking a leaf node  to an internal node  to reach its maximum length ( for blue edges or  for red edges). At this moment, the point  lies on a circle  of radius  or  centered at~; see Figure~\ref{fig:pinsubtree} for an illustration.

\begin{figure}[b!]
    \centering
    \scalebox{1.0}{\begin{picture}(0,0)\includegraphics{pinsubtree}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4479,4741)(-239,-3669)
\put(1306,704){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1306,-1546){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1126,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2566,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1306,-61){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-224,839){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(-224,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(766,-1771){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(766,479){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(676,-511){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}special point}}}}}
\end{picture} }
    \caption{Pinning a subtree. Black dots are sensors and white boxes are relays. The leaf nodes are pinned at points of . Straight lines denote ``taut'' edges, i.e., red edges of length  or blue edges of length ; other edges are shown with winding lines. (a)~We have translated the internal nodes until the edge between a leaf node  and an internal node  becomes taut. Then we try to slide  along circle  towards the special point. If we succeed, we have pinned  at the special point, which is in . (b)~In this case we cannot slide  to the special point. However, from the subtree of taut edges, we can find a node  that is now located at a point of  -- in this case at the intersection of a circle of radius  centered at a sensor, and a circle of radius  centered at a pinned relay.}\label{fig:pinsubtree}
\end{figure}

Now slide the point  along circle  until some other constraint becomes binding. We now do not consider  to be a rigid structure; rather, we allow the internal nodes to move arbitrarily, subject to the upper bound constraints on each edge. The edges serve as ``cables'', which readily shorten, but cannot extend beyond their maximum length.

If we can slide  along  to the special point located below , then we have pinned  at a point of . Otherwise some edges of  reach their upper bound of length while we slide  along ; i.e., one or more cables becomes taut. At this moment, some subset of the edges of  are taut (at their length upper bound); this subset of edges forms a tree, . There are two cases:
\begin{enumerate}[label=(\roman*)]
    \item  is a path. Then  is a path linking  to a leaf node  of . Further,  is a \emph{straight} path of edges, each at its upper length bound; in fact, all edges of  will be of length , the upper bound for relay--relay edges, except, possibly, the edge incident on  (if  is a sensor). Thus, in this position,  lies at the intersection of circle  with a circle centered at a point of  of radius  or , for some integer~. As we had , we will have now .
    \item  is not a path. Then,  has some node,  (possibly equal to ) that is connected to leaves of  by two (or more) straight paths, each of length  or , for some integer ; see Figure~\ref{fig:pinsubtree}b. This implies that  lies at a point of .
\end{enumerate}

In both cases we have moved the internal nodes of  so that one of them becomes pinned at ; moreover, none of the communication links are broken, leaf nodes are held in place, and no new relays are added.


\end{document}
