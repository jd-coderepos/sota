\documentclass[paper]{ieice}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage[fleqn]{amsmath}




\usepackage{bm}
\usepackage{theorem}
\usepackage{listings}
\usepackage{color}
\usepackage{url}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{bussproofs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{intmacros}
\usepackage{wrapfig}

\usepackage{article}

\newcommand{\Todo}[1]{}
\newcommand{\Tocheck}[1]{\textcolor{blue}{#1}}

\newcommand{\Until}{\mathsf{U}}
\newcommand{\Always}{\mathsf{G}}
\newcommand{\Eventually}{\mathsf{F}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}


\newenvironment{proof}[1][Proof.]{\begin{trivlist}
\item[\hskip \labelsep {\itshape #1}]}{\end{trivlist}}

\newcommand{\PropEx}{q}
\newcommand{\PropEq}{\mathit{eq}}

\setcounter{page}{1}

\def\ClassFile{\texttt{ieice.cls}}
\newcommand{\PS}{{\scshape Post\-Script}}
\newcommand{\AmSLaTeX}{\lower.4ex\hbox{}-\LaTeX}
\def\BibTeX{{\rmfamily B\kern-.05em
 \textsc{i\kern-.025em b}\kern-.08em
  T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\hyphenation{man-u-script}
\makeatletter
\def\tmpcite#1{\@ifundefined{b@#1}{\textbf{?}}{\csname b@#1\endcsname}}\makeatother




\field{A}
\vol{99}
\no{2}
\title[Monitoring Temporal Properties using Interval Analysis]
      {Monitoring Temporal Properties using Interval Analysis}
\titlenote{The preliminary version of this paper was presented at the 8th International Workshop on Numerical Software Verification (NSV'15).} 
\authorlist{\authorentry{Daisuke ISHII}{m}{labelA}
 \authorentry{Naoki YONEZAKI}{m}{labelA}
 \authorentry{Alexandre GOLDSZTEJN}{n}{labelB}
}
\affiliate[labelA]{The authors are with Tokyo Institute of Technology.}
\affiliate[labelB]{The author is with CNRS/IRCCyN.} 

\received{2015}{8}{11}
\revised{2015}{10}{5}

\begin{document}
\maketitle

\begin{summary}
Verification of temporal logic properties plays a crucial role in proving the desired behaviors of continuous systems. 
In this paper, we propose an interval method that verifies the properties described by a bounded signal temporal logic.
We relax the problem so that if the verification process cannot succeed at the prescribed precision, it outputs an inconclusive result. The problem is solved by an efficient and rigorous monitoring algorithm.
This algorithm performs a forward simulation of a continuous-time dynamical system, detects a set of time intervals in which the atomic propositions hold, and validates the property by propagating the time intervals.
In each step, the continuous state at a certain time is enclosed by an interval vector that is proven to contain a unique solution.
We experimentally demonstrate the utility of the proposed method in formal analysis of nonlinear and complex continuous systems.
\end{summary}
\begin{keywords}
  continuous-time dynamical systems, interval analysis, linear temporal logic, falsification method
\end{keywords}

\section{Introduction}\label{intro}

Reasoning with the temporal logic properties in continuous systems is a challenging and important task that combines computer science, numerical analysis, and control theory.
Various methods for the verification of continuous and hybrid systems with bounded temporal properties have been developed, e.g., 
\cite{Plaku2009,Nghiem2010,David2012,Zuliani2013}, 
enabling the falsification of various properties (e.g., safety, stability, and robustness) of large and complex systems. However, the state-of-the-art tools are based on numerical simulations whose numerical errors frequently yield qualitatively wrong results, which become problematic even in statistical evaluations.

Computing rigorously approximated reachable sets is a fundamental process in formal methods for continuous systems.
Techniques based on interval analysis (Section~\ref{s:interval}) have proven practical in the reachability analysis of nonlinear and complex continuous systems~\cite{Eggers2008,Collins2008,Ramdani2011,Ishii2011,Chen2012,Gao2013:SMODE}. 
In these frameworks, the computation is \emph{-complete} \cite{Gao2012}: assuming that function values may be perturbed within a predefined , 
many generically undecidable problems become decidable.
However, -complete verification of generic properties other than reachability is a challenging topic.

The contribution of this paper is to propose an interval method that verifies (bounded portions of) the signal temporal logic (STL) properties (Section~\ref{s:stl}) of a class of continuous-time dynamical systems (Section~\ref{s:cs}; extension to hybrid systems is straightforward).
Our method reliably computes three values: , , and . The method outputs  or  when the soundness is guaranteed by interval analysis;
otherwise, when the verification fails after reaching a prescribed precision threshold, it outputs .
Our method is based on validated interval analysis, and therefore it is reliable compared to the existing simulation-based monitoring tools, e.g., \cite{Maler2003,Fainekos2006a,Donze2010,Donze2010a}.
We show that simulation with numerical errors may compute an incorrect signal for a chaotic system.
In contrast with the existing tools that monitor a single behavior of a system,
our method monitors a set of possible behaviors using an interval-based technique;
therefore, the method can check the validity of the system.
In this sense, our approach can be viewed as an integration of reachability analysis and simulation-based monitoring methods.
The relaxation allowing  results enables us to generate an efficient monitor for STL properties that can be regarded as a variant of -complete procedures.
We demonstrate efficient and reliable monitors for several continuous systems including a chaotic system.

In Section~\ref{s:method}, we present an algorithm for monitoring STL properties based on the forward simulation that encloses a signal with a set of \emph{boxes} (i.e., interval vectors). 
For each atomic proposition involved in a property  to be verified, the algorithm obtains an inner and outer approximation of the time intervals in which the proposition holds. The interval Newton operator is used for the purposes of accelerating the search of instants where the satisfaction of propositions changes, and certifying the uniqueness of these event within their enclosures, eventually certifying the sequence of consistent/inconsistent time intervals over time for each proposition.
Next, it modifies the set of time intervals according to the syntax of the property ; finally, it checks that  holds at the initial time.
Using our implementation, we show that several benchmarks are verified efficiently, yet non-robust instances with respect to numerical errors are rejected (Section~\ref{s:ex}).
The implementation reliably analyzes a set of signals and provides a foundation for verification and parameter synthesis of complex systems.


\section{Related Work} \label{s:related}

Many previous studies have applied interval methods to reachability analyses of continuous and hybrid systems~\cite{Eggers2008,Collins2008,Ramdani2011,Ishii2011,Chen2012,Gao2013:SMODE}.
These methods output an over-approximation of reachable states as a set of boxes. 
Interval analysis often proves the unique existence of a solution within a resulting interval, and
it is also applicable to interval-based reachability analysis~\cite{Ishii2011,Goubault2014}.
Our method utilizes the proof in the verification of more generic temporal properties.



Reasoning of real-time temporal logic has been a research topic of interest~\cite{Alur1996,Shultz1997}. 
Numerical method for \emph{falsification} of a temporal property is straightforward~\cite{Maler2003}.
The algorithm simulates a signal of a bounded length and checks the satisfiability of the negation of the property described by a bounded temporal logic.
This paper presents an interval extension of this falsification method.

To falsify realistic nonlinear models efficiently, researchers have proposed a tree-search method~\cite{Plaku2009}, a Monte-Carlo optimization method~\cite{Nghiem2010}, and statistical model checking methods~\cite{David2012,Zuliani2013}.
Despite their successes, these methods are compromised by numerical error. To improve the reliability and practicality of the falsification, integration with our interval method will be a promising future direction.
An integrated statistical and interval method was also proposed in \cite{Wang2014} for reachability analysis.

To facilitate simulation-based verification of temporal properties, the \emph{robustness} concept has been proposed~\cite{Fainekos2006a,Donze2010,Nghiem2010}.
In these works, the degree of robustness defines the distance between a signal and a region over which a proposition holds.
If the absolute value of the degree is small, it is likely to be unreliable because of numerical errors.
Our method rigorously ensures robustness by verifying that every intersection between a signal and each boundary in the state space is enclosed with an interval.

There exist several methods for model checking of temporal logic properties~\cite{Podelski2006,Cimatti2014}.
\cite{Podelski2006} proposed a method specialized in stability properties, which is described as a specific form of temporal logic formula.
\cite{Cimatti2014} proposed a method that translates a verification problem into a reachability problem with the -Liveness scheme,
which is incomplete in general settings.
Our method can be viewed as a bounded model checking method that validates a bounded temporal property when the property is satisfied by all signals emerging from the interval parameter value.





\section{Interval Analysis}
\label{s:interval}

This section introduces selected topics and techniques based on interval analysis~\cite{Moore1966,Neumaier1990}.



A (bounded) \textit{interval}  is a connected set of real numbers .
 denotes the set of intervals. 
 denotes the subset .
For an interval ,
 and  denote the lower and upper bounds, respectively; and
 denotes the interior .
 denotes a point interval .
The hypermetric between two intervals  and ,
 is given by .
For a set ,  denotes the interval .
All these definitions are naturally extended to interval vectors;
an -dimensional \textit{box} (or interval vector)  is a tuple of  intervals
, and
 denotes the set of -dimensional boxes.
For  and ,
we use the notation , which is interpreted as .

In actual implementations, the interval bounds should be machine-representable floating-point numbers, and other real values are rounded in the appropriate directions.



Given a function ,
 is called an \emph{interval extension} of  if and only if it satisfies the containment condition
.
This definition is generalizable to function vectors .
Given two intervals , we can compute interval extensions of the four operators  as  (assuming  for division).

For arbitrary intervals , the \emph{extended division} 

can be implemented as follows (see Section~4.3 of \cite{Neumaier1990}):

In the second and third cases, when  (resp. ), we set  and  as  and  (resp.  and  as  and ).



Given a differentiable function  and a domain interval ,
a root  of  such that  is included in the result of the \emph{interval Newton operator}

where , and  and  are interval extensions of  and the derivative of , respectively. 
The first expression is always valid while the second expression is valid only when  does not contain 0.
Iterative applications of the operator will converge.
Let  be the result of applying the operator to . If , a unique root exists in .


\section{Continuous-Time Dynamical Systems}
\label{s:cs}

We consider dynamical systems whose behaviors are described by ordinary differential equations (ODEs).

\begin{definition}
A \emph{continuous-time dynamical system} is a tuple 

consisting of the following components:
\begin{itemize}
\item A vector of real-valued \emph{parameters} .
\item A vector of real-valued \emph{variables} .
\item A \emph{domain}  for the valuation of the parameters and variables.
\item An \emph{initial domain} .
\item A \emph{vector fields}  (assuming Lipschitz continuity).
\end{itemize}
\end{definition}
In this work, we specify domains  and  as boxes.
The behaviors of a system  are formalized as \emph{signals}.
\begin{definition}
	Given a time interval  and a parameter value ,
	a \emph{signal} of a continuous-time dynamical system  is a function  such that
    
\end{definition}
 denotes the set of signals of  of length .

\begin{example} \label{ex:rotation}
	An anticlockwise rotation of a 2D particle can be modeled as a continuous-time dynamical system:
	
A signal of this example is illustrated in Figure~\ref{f:rotation}.
The signal moves on the circle of radius 1 when ; the system is stable when  and is unstable when .
\end{example}

\begin{figure}[th]
\centering
\vspace{-1em}
\includegraphics[width=\linewidth]{figures/rotation.pdf}
\caption{A signal of the rotation system}
\label{f:rotation}
\end{figure}

\begin{example} \label{ex:lorenz}
	A well-known chaotic dynamical system is the Lorenz equation:
	
A signal of this system is illustrated in the upper part of Figure~\ref{f:lorenz}.
\end{example}

\begin{figure}[th]
\centering
\includegraphics[width=\linewidth]{figures/lorenz.pdf}
\includegraphics[width=\linewidth]{figures/lorenz-breach.pdf}
\caption{Signals of the Lorenz system simulated by validated (upper) and non-validated (lower) numerical methods}
\label{f:lorenz}
\end{figure}


\subsection{ODE Integration using Interval Analysis}
\label{s:ode}

Using tools based on interval Taylor methods, such as CAPD\footnote{\url{http://capd.ii.uj.edu.pl/}} and VNODE~\cite{Nedialkov2006}, we can obtain an interval extension  of signals in .
Given , these tools perform stepwise integration of the flow function  from the initial time  to time , and output the value .
At each step, interval Taylor methods verify the \emph{unique existence} of a solution in a box enclosure using the Picard-Lindel\"{o}f operator and Banach's fixpoint theorem.
Accordingly, when an interval enclosure  is computed by an interval Taylor method, the following property holds:

where  is interpreted as ``uniquely exists.''

In principle, if  is Lipschitz continuous and we can assume arbitrary precision, we obtain an arbitrarily narrow interval enclosure  for .
However, because interval Taylor methods are implemented using machine-representable real numbers, they may fail to compute an enclosure when verifying the unique existence property, even at the smallest step size.

\begin{example} \label{ex:lorenz:sig}
	Signals of the Lorenz system in Example~\ref{ex:lorenz} (when ), computed with an interval method (CAPD) and a non-validated numerical method, are illustrated in Figure~\ref{f:lorenz}.
	Non-validated numerical methods may compute a wrong signal for a chaotic system as shown in this figure. 
On the other hand, validated simulation of this system over a long period is difficult with double-precition floating-point numbers;
	the width of the interval enclosure computed by CAPD blows up after  time units and the simulation fails.
\end{example}

\begin{figure*}[t]
\includegraphics[width=.9\linewidth]{figures/example.pdf}
\caption{Monitoring process on the rotation system}
\label{f:rotation:proc}
\end{figure*}


\section{Signal Temporal Logic}
\label{s:stl}

We consider a fragment~\cite{Maler2003} of the real-time metric temporal logic~\cite{Alur1996} whose temporal modalities are bounded by an interval , where the bounds  are in .
Following \cite{Maler2003}, we refer to this logic as the \emph{signal temporal logic} (STL).

\begin{definition}
We consider constraints in the real domain as atomic propositions.
The syntax of the STL formulae is defined by the grammar

where  belongs to a set of \emph{atomic propositions} ,  is the ``until'' operator bounded by a non-empty positive time interval , 
 is a vector of variables, and .
We use the standard abbreviations, e.g., ,  (``eventually''), and  (``always'').
\end{definition}


\subsection{Semantics}

The necessary length  of the signals for checking an STL formula  is inductively defined by the structure of the formula:

The map  associates each proposition  to a set .

When we check the satisfiability of  at time , we should have a signal of length  (this value of  is used in evaluating all subformulae of ).
Let  and  be an STL property.
Then, we have a satisfaction relation defined as follows:

At a given time ,  intuitively means that  holds within the time interval  and that  always hold until then.
We also have the following validation relation:



\subsection{Method for Monitoring STL Formulae}
\label{s:stl:monitoring}

Our interval method is based on the monitoring method proposed in \cite{Maler2003}, which decides whether a signal satisfies an STL property based on the numerical simulation of signals of bounded lengths.
This section explains this basic method.
First, we introduce the notion of consistent time intervals in the STL evaluation.
\begin{definition} \label{th:consistent}
	Let  be a signal of length  and  be an STL formula.
	We say that a left-closed and right-open interval  is \emph{consistent} with  iff .\footnote{The original definition~\cite{Maler2003} involves left-closed right-open time intervals  so that they do not overlap and they can cover . However, , with , is not true in the left-closed right-open interval . In this paper, we only enforce the predicate to be true in the interior of time intervals  to regard  consistent. This has no impact on the soundness nor efficiency of the proposed method, since such bounds will be approximated by enclosing intervals in Definition~\ref{d:acti}.}
\end{definition}

Next, whether a signal satisfies property  is checked as follows:
\begin{enumerate}
	\item For each atomic proposition  in , monitor the signal of length  and identify a non-overlapping set of consistent time intervals .
\item Following the parse tree of  in a bottom-up fashion, obtain a set of consistent time intervals of . For each construct of STL, obtain the set that is consistent with the sub-formula as follows:

where .
\item Check whether  contains time 0.
	If yes,  is satisfied; otherwise, it is not satisfied.
\end{enumerate}

\begin{example} \label{ex:stl}
	We consider the property 
	
	for the model in Example~\ref{ex:rotation}, which describes that, within the initial  time units, the signal  increases beyond  within every  time units.
	Verification with the monitoring method (extended to an interval method) is illustrated in Figure~\ref{f:rotation:proc}, when the parameter is set as .
\end{example}


\section{Interval-Based Monitoring Method}
\label{s:method}

In this section, we propose a reliable method for monitoring STL properties on continuous-time dynamical systems. This method is an interval extension of the monitoring method described in Section~\ref{s:stl:monitoring}.

Given a system  and an STL property , the proposed  algorithm (Algorithm~\ref{a:main}) outputs the following results:
 (implying that ),
 (implying that ), or
 (meaning that the computation is inconclusive).
The algorithm implements the method described in Section~\ref{s:stl:monitoring}.
The sub-procedures  (Section~\ref{s:method:map}) for monitoring atomic propositions, and  and  (Section~\ref{s:method:propag}) for evaluating an STL formula are rendered rigorous and sound by interval analysis;
namely, the precision of every numerical computation is guaranteed, and the correctness of the monitoring method is assured by verifying the unique existence of a solution within its resulting interval.
Any errors introduced by the sub-procedures are captured by the catch clause at Line~5.

\begin{algorithm}[thb]
\caption{\label{a:main}  algorithm}

\begin{algorithmic}[1]
  \REQUIRE , 
  \ENSURE , , or 

  \STATE \textbf{try}
  \STATE \quad 
  \hfill\COMMENT{Step~1; Section~\ref{s:method:map}}
  \STATE \quad 
  \hfill\COMMENT{Step~2; Section~\ref{s:method:propag}}
  \STATE \quad \textbf{return} {}
  \hfill\COMMENT{Step~3}
  \STATE \textbf{catch error return}  \textbf{end try}
\end{algorithmic}
\end{algorithm}

Despite its efficient computational cost (Section~\ref{s:complexity}), the proposed method has some limitations.
First, the method is incomplete; it allows inconclusive computations and outputs  when the interval computation is too imprecise to separate several solutions within an interval.
In practice, the  output is valuable, because a numerically non-robust signal is rejected as an error in the verification process.
Second, although the algorithm validates system properties in principle, its success is guaranteed only over sufficiently small domains  and , particularly when evaluating nonlinear systems.
Third, the method is a bounded model-checking method, in the sense that the domain  and the lengths of the signals are both bounded.

Our method is targeted at (i) a more generic framework, in which the possible initial and parameter values can be exhaustively enumerated, and (ii) statistical methods that treat the parameters as random variables and evaluate probabilistic STL properties.


\subsection{Approximation of Consistent Time Intervals}
\label{s:method:approx}

In this section, we introduce an interval approximation for the consistent time intervals (Definition~\ref{th:consistent}).
The basic idea is to enclose each bound of the consistent time intervals within a closed interval.
\begin{definition} \label{d:acti}
	Given a consistent time interval  that is consistent with an STL property , we define an \emph{(interval) approximation} as a pair  such that , , and .
\end{definition}
Given an approximation  and a continuous signal , we have .

We now approximate a set of consistent time intervals  as a set (or sequence) of approximations.
Instead of the set of pairs ,
we represent a set of approximations with the set , where the tags  and  represent whether an element corresponds to a lower or an upper bound.
A set of approximations is interpreted as both \emph{outer} and \emph{inner approximations};
that is, each consistent time interval  is enclosed by the outer approximation , and the inner approximation  is contained in  .
\begin{definition} \label{d:approxs}
	Consider a set  where , , and .
	The second element of each pair is a \emph{polarity value} that represents whether the pair is an enclosure of a lower or upper bound of a consistent time interval.
We say that  is \emph{canonical} iff
	\begin{itemize}
		\item the elements can be sorted, i.e.,\\ ,
		\item , 
		\item , and
		\item .
	\end{itemize}
We say that  is an \emph{(interval) approximation} of 
iff
	\begin{itemize}
	\item  is canonical,
	\item , 
	\item , 
	\item , and
	\item .
	\end{itemize}
\end{definition}
Given a set of consistent time intervals, its canonical approximation is a disjoint sequence of lower and upper bound enclosures; the sequence starts with a lower bound enclosure and ends with either a lower or an upper bound enclosure.
For  such that ,  may contain only its lower-bound enclosure.
 and  are the approximations of  and , respectively.

\begin{example} \label{ex:approx}
	Let  be  such that
	the variable  represents the signal .
	Consider a property
.
 is , and 
	the set of consistent time intervals within  is
	, 
	, and
	, respectively.
	Then, their approximations are
	
\end{example}


\subsection{Monitoring Atomic Propositions}
\label{s:method:map}

This section describes the  procedure (Algorithm~\ref{a:map}) that,
given a system  and an STL property , computes a set  containing an approximated set  of consistent time intervals for each .

\begin{algorithm}[t]
\caption{ algorithm}
\label{a:map}
\begin{algorithmic}[1]
  \REQUIRE , 
  \ENSURE 
\STATE 
  \FOR{}\STATE 
  \STATE \textbf{if}  \textbf{then}  \textbf{else} 
  \STATE ; \quad 
  \LOOP
  \STATE 
  \STATE \textbf{if}  \textbf{then} \textbf{break} \textbf{end if}
  \STATE 
  ; \quad
  ; \quad 
  \ENDLOOP
  \STATE 
  \ENDFOR

  \vspace{.5em}
  \RETURN 
\end{algorithmic}
\end{algorithm}

The outer loop enumerates each atomic proposition  of the form . Lines~3--4 compute the initial polarity by evaluating the proposition at time 0; the set  is initialized accordingly.
Note that  represents a solving process for the signals in  (see Section~\ref{s:ode}), which can be regarded as a function .
The inner loop searches for bounds at which  changes sign.
Line~7 invokes the  procedure (Algorithm~\ref{a:searchzero}), which searches for the \emph{earliest} bound at which  switches consistency within the time interval , and outputs a sharp enclosure of the bound (or  if there is no solution).
This result is stored in the set , and  is stored in .


\begin{example}
	For  in Example~\ref{ex:approx},  computes
	 as .
\end{example}



The evaluation of atomic propositions  switches between  and  at the root of .
The intersection between a signal  and a boundary condition  is searched by Algorithm~\ref{a:searchzero}.
As inputs, this algorithm accepts an interval extension of the signal , a vector field , the function , and a time interval  to be searched.
The algorithm computes the time interval  that encloses the earliest root, i.e., 
 verifies that  encloses a unique bound, i.e.,

Alternatively, if no bound exists in ,  verifies the following:


\begin{algorithm}[t]
\caption{\label{a:searchzero}  algorithm}

\begin{algorithmic}[1]
  \REQUIRE , 
     , 
, 
	 
	 \ENSURE  \PARAM , \STATE  \REPEATC{Lower bound reduction}
    \STATE 
\STATE 
	\STATE 
\UNTIL{}
  \STATE \textbf{if}  \textbf{then return}  \textbf{end if}
\vspace{.5em}
  \STATE ; \quad 
  \LOOPC{Unique solution existence verification}
	\STATE 
    \STATE \textbf{if}  \textbf{then error end if}
    \STATE 
	\STATE \textbf{if} 
	  \textbf{then} ; \textbf{break end if}
\STATE ; \quad 
	\STATE 
	\STATE \textbf{if}  \textbf{then error end if}
  \ENDLOOP
\vspace{.5em}
\RETURN 
\end{algorithmic}
\end{algorithm}

\begin{theorem}[Soundness]
	If  returns an interval , properties \eqref{e:zero:earliest} and \eqref{e:zero:unique} hold.
	If it returns , property \eqref{e:zero:unsat} holds.
\end{theorem}

To justify the soundness os , we describe some details of Algorithm~\ref{a:searchzero}. 
Lines~2--6 repeatedly filter the time interval  using the interval Newton operator.
Line~4 (and Line~10) invokes the  procedure, which is given a function  and computes an interval enclosure of the derivative  over  using the chain rule

Next, at Line~5, the interval Newton operator is applied.
To handle the numerator interval  containing zero, we implement the interval Newton by the extended division described in Section~\ref{s:interval}.
Because we expand the interval Newton on the lower bound  and the extended division encloses the values in the  domain, the resulting  is filtered its inconsistent portion without losing the solutions or being expanded.
If the interval Newton returns ,  also returns  to signal the unsatisfiability (Line~7).

Because  may contain several solutions, 
Line~8 of the algorithm resets  to the lower bound as a starting value for computing the enclosure of the earliest solution.
Then,  checks that the time interval contains a unique solution.
To this end, it applies the interval Newton with the inclusion test to prove the unique existence of a solution within the contracted interval  (Lines~9--17).
The interval Newton verification is repeated with an inflation process of the time interval (see \cite{Goldztejn2010:RC} for a detailed implementation).
If Line~18 is reached with no error, the time interval  is a sharp enclosure of the first zero of . 


When  is implemented with machine-representable real numbers or when there is a tangency between the signal and the boundary condition, an error may result.
Line~11 of  outputs an error if the derivative on an (inflated) time interval contains zero.
At Line~16, we limit the number of iterations by specifying a threshold  for the inflation ratio between two consecutive contraction amounts as in \cite{Goldztejn2010:RC}.




\subsection{Evaluation of STL Properties}
\label{s:method:propag}

We now describe the procedures for evaluating STL formulae at Lines~3 and 4 of Algorithm~\ref{a:main}.
Propagation of a set of monitored time intervals that are consistent with the atomic propositions is implemented as a rigorous and sound but incomplete procedure.

To evaluate the approximated sets, we extend the evaluation procedure on sets of consistent time intervals described in Section~\ref{s:stl:monitoring}.
Algorithm~\ref{a:propagate} implements Step~2 of the procedure, which propagates the STL formulae over a set of time intervals.

\begin{algorithm}[t]
\caption{ algorithm}
\label{a:propagate}

\begin{algorithmic}[1]
  \REQUIRE , 
  \ENSURE 

  \STATE \textbf{switch} 
  \STATE \textbf{case}  : 
  \STATE \qquad \textbf{return} {}
  \STATE \textbf{case}  : 
  \STATE \qquad \textbf{return} 
  \STATE \textbf{case}  : 
  \STATE \qquad 
  \STATE \qquad 
  \STATE \qquad \textbf{return} {}
  \STATE \textbf{case}  : 
  \STATE \qquad 
  \STATE \qquad 
\STATE \qquad \textbf{return} 
  \STATE \textbf{end switch}
\end{algorithmic}
\end{algorithm}

We now handle the approximated sets by extending the operations \eqref{e:op:neg}--\eqref{e:op:until} on sets of time intervals.
The procedures for the operations , , , and  are described in Figure~\ref{f:operations} in the appendix.
Note that, some operations cause ambiguities when handling non-canonical approximated time intervals.
Such a situation is exemplified below.
To avoid these ambiguities, our implementation results in an error once a resulting set becomes non-canonical.\footnote{
To output  only due to the insufficient precision of numerical computation,
the procedure should branch the process and proceed evaluation for both cases;
implementation of such a procedure remains as a future work.}

\begin{example}
Consider the same timer system as in Example~\ref{ex:approx}, i.e. ,
and the property 
, where .
The subformula  is consistent at every time except at , therefore, the set of consistent time intervals is .
Assume  is approximated with a non-canonical set .\footnote{The bound enclosures are usually very accurate, but kept large on this example to emphasize their impact.}
To verify , the procedures  and  should be applied.
However, as illustrated in Figure~\ref{f:overlap}, we cannot decide whether the overlapping boundary intervals should be removed and expanded, or separated, and  results in an error.\footnote{The property  is verified in the same way. The set  is consistent with the atomic proposition . The verification will result in an error when  computes an enclosure of  at time 1.} This ambiguous situation is avoided by using only canonical approximations. Note that, in some cases, this local ambiguity does not impact the global consistency. In the case of this example, if , both scenarios lead to , and forking the resolution process would be able to resolve the local ambiguity.

\begin{figure}[ht]
	\vspace{-1em}
\centering
\includegraphics[width=.8\linewidth]{figures/overlap1.pdf}
\caption{Ambiguity caused by overlapping bounds}
\label{f:overlap}
\end{figure}
\end{example}

The following claims state that the procedures are closed in the canonical approximated sets, and the  procedure is sound.

\begin{lemma} \label{th:canonical}
	Let  and  be canonical approximated sets.
	If  results from , , , or , and if no  occurs in these procedures, then  is canonical.
\end{lemma}
\begin{proof}
	See Appendix~\ref{s:canonical:proof}.
\end{proof}

\begin{theorem}[Soundness] \label{th:soundness}
	Consider an STL formula  and a set  of approximated sets of time intervals that are consistent with atomic propositions.
	If ,
	then  is an approximation of .
\end{theorem}
\begin{proof}
	See Appendix~\ref{s:soundness:proof}.
\end{proof}

Finally, we obtain  and conclude that  is  if  is the smallest interval in  and ,  if  or , or  if .
The computation is performed by  (see Algorithm~\ref{a:inittime} in the appendix).


\subsection{Computational Cost}
\label{s:complexity}

The time complexity of  is bounded by the product of the size (i.e., the number of operators) of the considered STL formula  and the cost of the procedures , , and  in Figure~\ref{f:operations}.
The complexity of the procedures on approximated sets is polynomial in the number of intersections of the signal and the atomic proposition bounds (see Appendix~\ref{s:complexity:op}). The number of iterations in  is bounded by the product of the size of  and the maximum number of bounds detected for an atomic proposition, i.e., .

The number of bounds detected depends on the oscillations of the ODE solution and the predicate bound. Although it can be very high in theory, it is usually quite small. In the generic case of non tangent intersection between the ODE solution and the predicate bound, the  procedure has a quadratic convergence and therefore a very low computational cost. The main computational cost of the method is therefore the validated simulation of the ODE. This cost is difficult to foresee: It highly depends on the ODE and the solver. For example, validated solvers are currently quite inefficient in solving stiff ODEs, and require to iterate many steps leading to a high computational cost. The complexity of  is bounded by the product of the size (i.e., the number of operators) of the considered STL formula  and the cost of the procedures in Figure~\ref{f:operations}.


\begin{table*}[t]
	\centering
\caption{\label{t:ex:rotation} Experimental results (rotation)} 
\begin{tabular}{l|c|c|c|r|r|r|r} \hline \hline
		 & \!\#\! &  &  &
		\!\#\! & \!\#\! & \!\#\! & time \\
		\hline
		\multirow{5}{*}{
		\hspace{-1.5em}
		\begin{tabular}{l}
		
		\end{tabular}}
		&   & \multirow{3}{*}{100} 
			  &  0               &  507 & 493 &   0+0 & 0.51s \\
		&   & &   &  483 & 508 &   9+0 & 0.52s \\
		& 1 & &   &    0 & 462 & 538+0 & -- \\
		\cline{3-8}
		&   & \multirow{2}{*}{10} 
			  &  0               &  490 & 510 &   0+0 & 0.03s \\
		&   & &   &  270 & 470 & 260+0 & 0.02s \\
		\hline
		\multirow{5}{*}{
		\hspace{-1.5em}
		\begin{tabular}{l}
		\\
		
		\end{tabular}}
		&   & \multirow{3}{*}{100} 
			  &  0               &  485 & 515 &   0+0 & 1.1s \\
		&   & &   &  353 & 505 &  26+116 & 1.03s \\
		& 2 & &   &    0 & 463 & 537+0 & -- \\
		\cline{3-8}
		&   & \multirow{2}{*}{10} 
			  &  0               &  514 & 486 &   0+0 & 0.05s \\
		&   & &   &   86 & 493 & 421+0 & 0.06s \\
		\hline
		\multirow{5}{*}{
		\hspace{-1.5em}
		\begin{tabular}{l}
		\\
		\\
		\\
		
		\end{tabular}}
		&   & \multirow{3}{*}{100} 
			  & 0               &  482 & 518 &   0+0 & 1.7s \\
		&   & &  &  346 & 498 & 18+138 & 1.6s \\
		& 3 & &  &    0 & 0   & 1000+0 & -- \\
		\cline{3-8}
		&   & \multirow{2}{*}{10} 
			  & 0               &  516 & 484 &   0+0 & 0.08s \\
		&   & &  &   84 &   0 & 916+0 & 0.09s \\
		\hline
		\multirow{5}{*}{
		\hspace{-1.5em}
		\begin{tabular}{l}
		\\
		\\
		\\
		\\
		
		\end{tabular}}
		&   & \multirow{3}{*}{100} 
			  & 0               &  490 & 510 &   0+0 & 2.7s \\
		&   & &  &  352 & 477 &  74+97 & 2.7s \\
		& 5 & &  &    0 &   0 & 1000+0 & -- \.1em]
		\hline
	\end{tabular}
\end{table*}

\section{Experiments}
\label{s:ex}

We have implemented the proposed method and experimented on two examples to confirm the effectiveness of the method.
Experiments were run on a 3.4GHz Intel Xeon processor with 16GB of RAM.

\subsection{Implementation}
\label{s:impl}

Algorithms~\ref{a:main}--\ref{a:inittime} were implemented in OCaml and C/C++.
ODEs were solved by procedures in the CAPD library.
The configurable parameters , , and  correspond to the smallest integration step size that CAPD can take, the threshold used in Figure~\ref{a:searchzero}, and the threshold used in , respectively.
In the experiments, these parameters were set as , , and .


\subsection{Verification of the Rotation System}



We verified the system in Example~\ref{ex:rotation} on four STL formulae.
The specifications and results of this experiment are summarized in  Table~\ref{t:ex:rotation}.
The first column lists the STL formulae in which the bound  of each  operator is parameterized and set to either  or .
The column ``\#'' represents the number of atomic propositions in each .
In each verification, the parameter value  was first randomly selected from  and then modified to , where  was any of , , or .
The column ``'' indicates the interval used in each verification.

The considered STL properties are assumed to hold if  and not to hold if .
Each STL property was verified for 1000 times.
The columns ``\#'', ``\#'', and ``\#'' list the numbers of runs resulting in each output; the ``\#'' outputs are separated with `' according to whether it was caused by an error in the  algorithm or an error in the  and  algorithms.
The column ``time'' lists the average CPU time taken for a  verification.

From the results, we can observe that the rates of inconclusive runs were related to the simulation lengths, the uncertainties in the parameter values, and the size of the formula .
 results were generated by the interval Newton process in  and the undecidable situations in  and . In this experiment, verification failures increased as the value of  approached 0 and the signal and boundary condition became close to tangent.
When the parameter values were exact and , all the verifications succeeded even under near-singular conditions because the considered signals were always enclosed with tight intervals.
As coarser intervals were appended to the parameter values and the simulation lengths became longer, the number of  results increased; meanwhile, the number of  results decreased more rapidly than the number of  results because a  verification required detecting a number of bounds for each atomic proposition. Any detection failure resulted in .

The bottleneck of the verification process is the  algorithm that integrates ODEs and searches for boundary intervals. The number of calls to  depends on the size of  and the number of bounds as described in Section~\ref{s:complexity}.
Therefore, the runtime increased linearly in either the number of atomic propositions or the simulation length that should be proportional to the number of bounds.
The cost of evaluation of the STL formulae seemed relatively small and not affecting the overall timings.


\subsection{Verification of the Lorenz System}

We verified the system in Example~\ref{ex:lorenz} on the following STL formula:

In each verification, the parameters were set to exact values randomly selected from the domain.
The signal  oscillates on either the positive or the negative side. According to the formula, when  descends below ,  moves into the disk  after some duration in the interval  and remains in the disk for at least 1 time unit.

The experimental results are summarized in Table~\ref{t:ex:lorenz}.
As in Table~\ref{t:ex:rotation}, the columns (from left to right) represent the number of atomic propositions, the numbers of , , and  verification results in 1000 runs, and the average CPU time for a  verification.

\begin{table}[ht]
\begin{center}
	\caption{\label{t:ex:lorenz} Experimental results (Lorenz)} 
    \begin{tabular}{c|r|r|r|r} \hline\hline
		\# & \# & \# & \# & time \\
		\hline
		2 & 566 & 413 & 21 & 9.2s \\
		\hline
	\end{tabular}
\end{center}
\end{table}

This experiment demonstrated that the proposed method can handle a chaotic system with a nonlinear atomic proposition. In such systems, non-validated numerical methods frequently output wrong results because of rounding errors, as shown in the next section.
As explained in Example~\ref{ex:lorenz}, CAPD integration generated a coarse enclosure of the signal (around  time units), which introduced errors in the integration process  or the interval Newton process.
These errors would account for the 21  results in Table~\ref{t:ex:lorenz}.


\subsection{Comparison with Breach Toolbox}

For comparative purposes, we ran the above problems on the Breach Toolbox~\cite{Donze2010a} (built from commit ed1178c in the Mercurial repository), a tool for STL verification based on numerical computation with rounding errors.
Breach can check the satisfiability and the \emph{robustness}, which is quantified by a positive or negative real value based on the distance between a considered signal and the bound in the state space where the satisfaction of the STL property switches.

For the rotation system, when the parameter value  approached 0 (specifically, at ), Breach returned , whereas our implementation returned .
This incorrect verification was implied by the low robustness value.
In this example, the robustness was low for all parameter values because the initial part of the signal was close to the bounds of the atomic propositions.

For the Lorenz system, the numerical integration process of Breach yielded incorrect signals, as explained in Example~\ref{ex:lorenz:sig}; therefore, the verification results were unreliable. 
For example, when , Breach reported an  verification of property~\eqref{e:lorenz}, whereas our method returned certified .

Breach ran more quickly than our implementation: it required less than 0.01s for both problems.


\section{Conclusions}

We have presented a sound STL validation method for checking that all initialized signals satisfy the properties of a system.
The proposed method detects a witness signal and verifies its unique existence using an interval-based ODE integration and an interval Newton method.
The experimental results demonstrate the potential for the method as a practical tool.


In future work, we will improve our method and implementation to handle hybrid systems and large and uncertain initial values.
Examples in a realistic setting should be demonstrated with the implementation.

\section*{Acknowledgments}

This work was partially funded by JSPS (KAKENHI 25880008 and 15K15968).


\bibliographystyle{ieicetr}
\bibliography{mitl}


\appendix*
\section{Omitted Procedures and Proofs}

Procedures of the operations on approximated sets are specified in Figure~\ref{f:operations}.
, , , and  implement the operations in Step~2 of Section~\ref{s:stl:monitoring} as procedures that modify the set of boundary intervals.
 consists of sub-procedures  and ;  computes the intersections and back-shifting pairwise ( enumerates approximations of time intervals in );  applies the back-shifting.
The results of the procedures may become non-canonical, so  is applied at last to make them canonical.



 is implemented in Algorithm~\ref{a:inittime}.
An input  is either , , or an approximated set;
in the last case, the algorithm picks an earliest approximation with , and checks whether it contains 0 or not.

\begin{figure*}[t]

\caption{\label{f:operations} Procedures for approximated sets of consistent time intervals}
\end{figure*}

\begin{algorithm}[thb]
\caption{\label{a:inittime}  algorithm}

\begin{algorithmic}[1]
  \REQUIRE 
  \ENSURE , , or 

  \IF{}
	\RETURN{}
  \ELSIF{}
	\RETURN{}
\ELSE
    \STATE 
    \IF{}
	  \RETURN{}
    \ELSIF{}
	  \RETURN{}
    \ELSEC{}
	  \RETURN{}
    \ENDIF
  \ENDIF
\end{algorithmic}
\end{algorithm}


\subsection{Proof of Lemma~\ref{th:consistent}}
\label{s:canonical:proof}

We check that each condition of a canonical approximation (Definition~\ref{d:approxs}) is assured by , the last sub-process in each procedure:
\begin{itemize}
\item During the propagation process, polarity alternation might be inhibited by , , or , which locates a boundary interval inside another consistent time interval.
These \emph{embedded} bounds are removed by .
An embodiment can be determined by checking the difference between the numbers of lower and upper bounds in the past since the smallest elements in  and  are always the lower-bound enclosures.
\item The upper bound of each time interval  in  becomes non-negative because elements with non-positive upper bounds are filtered out by .
\item No two elements of  overlap because an overlapping pair with opposite polarity results in an error (the second branch of ) and an overlap with the same polarity is joined ();
thus, the elements in  can be sorted.
\item  assures that the polarity value of the smallest element is .
\Qed
\end{itemize}


\subsection{Proof of Theorem~\ref{th:soundness}}
\label{s:soundness:proof}

We perform a structural induction based on the STL formulae.

For the base case ,  exists in .

For the inductive step, consider STL formulae  and , and assume as the inductive hypothesis that we have canonical approximated sets  and  of  and , respectively.
We show that  computes the approximated set properly for each formula constructed from  and .

When , the polarity of each bound of  is switched by  to obtain an approximated set for the complementary time intervals, which is sound regarding the operation~\eqref{e:op:neg} in Step~2 of Section~\ref{s:stl:monitoring}.
Then,  is applied to canonicalize the result;
it will append or remove the smallest bound.
Let  be the smallest element in a result of polarity inversion.
We confirm that  is sound in a case analysis:
\begin{itemize}
\item if  is non-empty and , the computation results in an error (the first branch of );
\item if , the element remains and the element  is appended by ;
\item if , the element is removed by .
\end{itemize}


When ,  and  are modified by , which joins the elements of both approximated sets; a result might be a non-canonical set when two approximated time intervals from  and  overlap.
Then,  is applied to unify two overlapping approximations so that the result becomes a sound approximated set with respect to the operation~\eqref{e:op:lor}.
When two approximated time intervals  and  overlap, the boundary interval (e.g., ) either (i) overlaps with another boundary interval, (ii) is included in the inner approximation , or (iii) is excluded from the outer approximation . \Todo{Need a figure?}
We confirm the soundness of  in another case analysis:
\begin{itemize}
\item in case (i), the bound is removed by the second branch of  and by ;
\item in case (ii), the bound is removed by ; 
\item in case (iii), the bound remains since it should be the bound of the joined time interval.
\end{itemize}

When ,  and  are modified by , which applies ,  and , those implement the operation~\eqref{e:op:until}.
The soundness of  with respect to the set intersection is evident because this procedure simply implements the set operation .
 exhaustively applies  to each pair of boundary enclosures in  and .
 translates the lower and upper bounds, according to the operation~\eqref{e:op:until}; this procedure is sound because an interval enclosure is assumed for each bound of the consistent time intervals.
, then, resolves the overlaps and closes the lowest bound as in the case of .
\Qed


\subsection{Computational Complexity of the Operations on Approximated Sets}
\label{s:complexity:op}

Let  be the number of elements in ;
if the bounds appear uniformly in a simulation,  is proportional to ;
in other words,  is bounded by  where  is the precision of the floating-point numbers.
The complexity of  is bounded by  since the complexities of , , , and  are , , , and , respectively.
Without the  process, the complexities of  and  are  and , respectively; together with , their complexities are .
The complexity of  is  (let  be the larger cardinality for  or ) since the complexities of  and  are  and , respectively.



\newpage

\profile{Daisuke Ishii}{recieved B.Eng, M.Eng, and Ph.D. degrees in computer science from Waseda University, Tokyo, Japan in 2001, 2003, and 2010, respectively.
He was a research fellow at INRIA/LINA in France, from 2010 to 2011, and a research fellow of the JSPS at National Institute of Informatics from 2011 to 2013.
He is currently an Assistant Professor at Tokyo Institute of Technology.
His research interests include interval analysis and formal methods for hybrid systems.

Tokyo Institute of Technology, Department of Computer Science,
2-12-1-W8-67, Ookayama, Meguro-ku, Tokyo, 152-8550 Japan.
}
\label{profile}



\profile{Naoki Yonezaki}{Naoki Yonezaki currently is Visiting Professor of Open University of Japan and Emeritus Professor of Tokyo Institute of Technology.
He has been Professor of Tokyo Institute of Technology since 1991. He was also  Professor of Japan Advanced Institute of Science and Technology from1991 till 1995. His research interests include verification of software specification, verification of security and formal approach to system biology.
He is a member of IEICE, IPSJ, JSSST, JSAI, ACM and EATCS. He awarded to a fellowship from JSSST in 2008.

Open University of Japan,
2-11 Wakaba, Mihama-ku, Chiba 261- 8586 Japan.
}

\profile{Alexandre Goldsztejn}{After receiving his Ph.D. from the University of Nice in 2005, he has spent one year as a postdoctoral fellow in USA, in the University of Central Arkansas and in the University of California Irvine. He was then granted a tenured research associate position at CNRS, where he continued his researches on numerical constraint programming, with emphasis on quantified constraints and positive dimensional manifolds, global optimization and dynamical systems.

IRCCyN -- Ecole Centrale de Nantes,
1, rue de la No\"{e}, BP 92101, 44321 Nantes Cedex~3, France.
}

\end{document}
