\documentclass{article}

\usepackage{amsmath}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{latexsym}
\usepackage{fullpage}

\newtheorem{defi}{Definition}
\newtheorem{lemm}{Lemma}
\newtheorem{coro}[lemm]{Corollary}
\newtheorem{theo}[lemm]{Theorem}
\newenvironment{proof}{\par\noindent{\bf Proof}}{\hspace{\stretch{1}}}

\newcommand{\prefix}{\sqsubseteq}

\newcommand{\naturals}{\mathbf{N}}

\newcommand{\qi}[0]{q_{\mathrm{I}}}
\newcommand{\sigmao}[0]{\Sigma_{\mathrm{o}}}
\newcommand{\Sigmao}[0]{\sigmao}
\newcommand{\path}[0]{\mathit{\rho}}
\newcommand{\trans}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\lang}[0]{\mathcal{L}}
\newcommand{\langf}[1]{\lang_{#1}}
\newcommand{\obs}[0]{\mathrm{obs}}
\newcommand{\nonfaulty}[1]{\not{#1}}
\newcommand{\dmin}[1]{\mathit{dmin}_{#1}}
\newcommand{\dmax}[1]{\mathit{dmax}_{#1}}
\newcommand{\distances}{\mathit{distances}_F}
\newcommand{\belief}{\mathcal{B}}
\newcommand{\optimal}[1]{{#1}^\star}
\newcommand{\optipred}{\optimal{P}}

\newcommand{\set}[1]{\{#1\}}

\newcommand{\queue}[0]{\mathcal{Q}}
\newcommand{\nbsucc}[0]{\mathrm{nsucc}}

\begin{document}
\title{Interval Predictability \mbox{in Discrete Event Systems}}
\author{Alban Grastien\thanks{A.~Grastien is with NICTA, Australia, 
and the Australian National University.}
}

\maketitle

\begin{abstract}
  In this paper we study the problem of predictability 
  in partially observable discrete event systems, 
  i.e., the question whether an observer 
  can predict the occurrence of a fault.  
  We extend the definition of predictability 
  to consider the time interval where the fault will occur: 
  the -predictability does not only specify 
  that the fault will be predicted before it occurs, 
  but also that the predictor will be able 
  to predict that its occurrence will occur 
  in  to  observations from now.  
  We also provide a quadratic algorithm 
  that decides predictability of the system.  

  {\bf Keywords: Predictability, Discrete Event Systems}
\end{abstract}

\section{Motivation}
A fault is predictable 
if its unavoidable occurrence can always be determined in advance.  
Being able to predict the fault 
allows the supervisor to step in 
and take preventive actions, 
such as reconfiguring the system, 
replacing damaged components, or shutting the system down.  

Predictability has been greatly studied in the last decade 
(some references are provided in the related work section).  
To be maximally effective, 
the prediction should satisfy two criteria: 
it should be made well in advance, 
so that the operator has enough time 
to decide for and perform corrective actions; 
it should be reasonably precise, 
so that the repair is not performed too early 
if that is unnecessary.  
The first contribution of this paper is the formalisation 
of these two objectives: 
we define the notion of -predictability, 
a generalisation of the existing notion of predictability 
that states that faults can always be predicted 
at least  timesteps in advance 
and, when this prediction is made, 
the fault will not occur in more than  timesteps.  

We study this definition of predictability and 
we propose an algorithm that computes all pairs  
for which predictability holds.  
We show that this algorithm runs in quadratic time.  
This is an improvement over the existing predictability algorithms 
that run in .  

This paper is organised as follows.  
Next section presents preliminary definitions.  
Our definition of predictability is presented in Section~\ref{sec::defi}, 
together with a discussion of its benefits.  
Our algorithm is given in Section~\ref{sec::solution}.  
Existing approaches are discussed in Section~\ref{sec::related}.  

\section{Preliminaries}
\label{sec::prelim}
\subsection{Discrete Event Systems}

This work is applicable to finite discrete event systems (DES) 
\cite{cassandras-lafortune::99}.  
The system is modeled as a DES and is assumed fixed for this paper.  
A (finite) DES is a model for dynamic systems 
where the state space is discrete (and finite) 
and is modeled as a finite state machine.  


A (partially observable) \emph{finite state machine} (FSM) 
is a tuple  
where  is a finite set of states, 
 is a finite set of events, 
 is a finite set of transitions, 
 is the initial state, 
and 
 is a finite set of observable events.  

To simplify notations, it is assumed that the FSM is deterministic, 
i.e., there is only one initial state 
and there are no two transitions originating from the same state 
and labeled with the same event: 

This assumption is not restrictive 
as any non-deterministic FSM can be turned into a deterministic FSM 
that is equivalent from a predictive/monitoring perspective, 
by adding a number of states and transitions 
smaller than the original number of transitions 
and without affecting the overall complexity of the algorithm.  
Furthermore the algorithms presented later apply 
to non-deterministic FSM as well.  
The assumption of determinism is however convenient 
because there a one-to-one mapping between a path and a trace 
(defined below).  

A \emph{path}  is a double sequence 
of states and events  
such that .  
The label , called the \emph{trace}, of the path 
is the sequence of events .  
That there exists a path labeled by  from  to  
is denoted ; 
the state  reached from  through  is denoted  
and the fact that it exists is written .  

The definition of a path is extended to infinite paths 
 such that for all , 
 is a path.  
It is assumed that the system is live, 
i.e., that for any state , there exists an outgoing transition: 
.  
Infinite traces are denoted  and finite ones .  
The \emph{prefix} relation is denoted  
where  may be finite or infinite.  
We extend the notation  to infinite traces, 
with the meaning .  

The system starts in state  
and takes an infinite path.  
The language  
is defined as the set of infinite words over  
that label an infinite path on the FSM starting from the initial state.  

Given a finite word , 
the \emph{observation} of  is the traditional projection 
of  on the set of observable events: 

where  is the empty sequence.  
As usual it is assumed that any infinite trace 
generates infinitely many observations.  

\subsection{Faults}

The system can be subject to faults, 
i.e., types of behaviour that we wish to prevent.  
Faults can be defined as a single event 
or as a subtle pattern of events \cite{jeron-etal::dx::06}.  
These two definitions are however very similar: 
the important notion here 
is that it can also be modeled as the property 
of the current (possibly augmented) state of the system 
(normal state vs. faulty state).  
A set  of states will represent the faulty states: 
a path is faulty if it reaches a faulty state 
().  
The faulty aspect of a trace  
will therefore be represented by .  
Notice that, by definition, any transition from a faulty state 
leads to a faulty state: 

It is assumed that the initial state is not faulty.  
The set of infinite faulty traces is represented 
by language , 
which is formally defined as the set of traces 
whose path from  is faulty.  

\section{-Predictability}
\label{sec::defi}
\subsection{Predictability}

Fault prediction is the problem of deciding 
whether an operator should be warned that a fault is bound to occur.  
We want to give guarantees about the prediction of the fault.  
This guarantee is expressed by a tuple  
where  (resp. ) is a lower bound (resp. upper bound) 
of the fault occurrence.  

In the following a \emph{time interval} is a pair of elements  
from  
(the natural numbers including zero and infinity) 
so that .  
We define the operator  
so that  
where  if  
and  otherwise.  
A time interval  can be interpreted 
as the set of numbers between  and .  
Under this interpretation 
the relation  
is equivalent to ; 
and .\footnote{Notice that  may contain elements 
that are neither in  nor in .}

A predictor is a machine  that, given a sequence  of observations, 
returns a time interval , 
meaning that any trace that matches this sequence 
will not become faulty before  more observations are collected 
(if , the fault may already have occurred) 
but will definitely be faulty before  more observations are 
(or returns  if the fault is not predicted---it may never occur).  
In the coming definition, 
notice that, while this is not explicitely stated, 
if  and  are two different traces 
that generate the same observations () 
then the predictor should obviously give the same prediction: 
.  
Hence the predictor has to be conservative 
so as to satisfy the two constraints given in the definition 
for all relevant traces.  
In other words, there are two types of uncertainty: 
uncertainty about what happened until now 
(we only know that the behaviour generated the sequence  
but the actual behaviour is unknown); 
uncertainty about what will happen from now.  

\begin{defi}\label{defi::predictor}
  A \emph{predictor} is a machine  
  that takes a sequence of observations 
  and that returns a time interval 
  with the following property: 
   
  such that , 
  let , then 
  \begin{itemize}
  \item 
     and 
  \item 
    .  
  \end{itemize}
\end{defi}

An -predictor has the added requirement 
that, before a fault occurs, 
a prediction should be made about the fault occurrence 
that is tighter than, or as tight as, .  

\begin{defi}\label{defi::ijpredictor}
  A predictor  is an \emph{-predictor
  for a given trace } if 
  

  A predictor is an \emph{-predictor} 
  if it is an -predictor for every trace .  
\end{defi}

-predictability is then the property 
that an -predictor exists.  
We also define \emph{-predictability}, 
the property that the fault occurrence can be predicted 
at least  observations before it occurs; 
and \emph{predictability}, 
the property that the fault can be predicted before it occurs.  

\begin{defi}\label{defi::predictability}
  A system is \emph{-predictable} 
  if there exists an -predictor for it.  
  It is \emph{-predictable} if it is -predictable 
  for some .  
  It is \emph{predictable} if it is -predictable 
  for some .  
\end{defi}

Notice that the condition  (i.e., ) 
is necessary because forbidding the upper bound of  
to be  forces the predictor 
to predict the fault before its occurrence 
(i.e., the predictor asserts that the fault will definitely occur).  
Similarly we forbid  because we want the fault to be predicted 
in a state where it has not occurred yet.  

\begin{figure}[ht]
  \begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state,initial,initial text=] (A) at (0,2) {};
  \node[state] (B) at (2,2) {};
  \node[state] (C) at (0,0) {};
  \node[state] (D) at (2,0) {};
  \node[state] (E) at (4,2) {};
  \node[state] (F) at (4,0) {};
  \node[state,fill=gray] (G) at (6,0) {};

  \path
    (A) edge [bend left] node {} (B) 
    (B) edge [bend left] node {} (A)
    (C) edge [bend left] node {} (D) 
    (D) edge [bend left] node {} (C)
    (A) edge node {} (C)
    (B) edge node {} (E)
    (D) edge node {} (F)
    (E) edge node {} (F)
    (F) edge node {} (G)
    (G) edge [loop] node {} (G)
  ;
\end{tikzpicture}
  \end{center}
  \caption{Example of a system;  is the only unobservable event.}
  \label{fig::simple}
\end{figure}

\begin{table}[ht]
  \begin{center}
    \begin{tabular}{c | c}
      Observation pattern & Prediction\\
      \hline
      No  & \\
      Last observed event is  & \\
      Second last observed event is  & \\
      Contains  followed by two or more observed events & 
    \end{tabular}
  \end{center}
  \caption{A -predictor for the system of Figure~\ref{fig::simple}.}
  \label{tab::predictor}
\end{table}

These definitions are illustrated 
with the example of Figure~\ref{fig::simple}.  
The faulty states are represented with grey filling.  
Table~\ref{tab::predictor} presents one predictor.  
For instance the first pattern of the predictor specifies 
that if the sequence of observations does not contain the event  
then the prediction is , 
i.e., there will be at least two observations 
before the fault occurs, and it may never occur.  
The second pattern specifies 
that if the last event of the sequence of observations is  
then the prediction is , meaning that a faulty state 
will be reached after one or two more observations are received.  
Similarly for the third pattern: the prediction is , 
i.e., it may already have occurred or it will 
when the next observation has been received.  
Finally the last pattern indicates a situation 
where the fault definitely occurred.  

We illustrate that the machine in Table~\ref{tab::predictor} 
(denoted  here)
indeed presents a predictor on a few selected examples.  
We first assume a trace  
with prediction .  
Consider its continuation ; 
then the length difference between  and  is , 
which is less than ; 
therefore  has to satisfy , 
which it does.  
Consider instead ; 
the length difference is this time , 
which means that none of the constraints 
in Definition~\ref{defi::predictor} applies.  
Predictor  is not claimed to be ``optimal'' 
(where the precise definition of optimality is presented later); 
nevertheless one might claim 
that a prediction of  is not very precise 
given that any continuation of  requires three observable events 
to reach a faulty state ( is the shortest).  
Notice however that  does not know that the system trace is : 
it only knows the sequence of observations generated by , 
i.e., , which is identical to the sequence 
generated by ; 
this trace  can reach a faulty state in just two observable steps 
(), which forces the lower bound of  to be at most .  

Assume now  with prediction .  
Consider the non-faulty trace ; 
the length difference is , 
which means that none of the constraints 
in Definition~\ref{defi::predictor} applies.  
Consider instead the faulty trace ; 
the length difference is , 
which is greater or equals to the upper bound of the prediction; 
therefore  has to satisfy , 
which it does.  

As we can see any faulty trace has to include , 
which means that the flow of observations generated by a faulty trace 
will eventually be associated with the prediction .  
Therefore the system is -predictable.  
We can however show that the system is not -predictable.  
Indeed consider the infinite faulty trace  
where the exponent  indicates an infinite repetition of .  
For  to be -predictable, 
we need to exhibit one of its prefix  
such that one can predict  
(here  should exactly equal ).  
Assume that such a prefix and such a predictor exist.  
Following Definition~\ref{defi::predictor}, 
consider a continuation  of  
that generates one more observation; 
because , 
 should not lead to a faulty state.  
Therefore  has to belong to the set 
.  
Similarly however, if  is chosen such that its observable length 
is exactly two more than that of , 
then  has to lead to a faulty state.  
Therefore  and .  
Consider however the trace  
and its continuation .  
Clearly .  
According to Definition~\ref{defi::predictor} 
since  
 should not lead to a faulty state.  
It does however, which shows that no prefix  of  
satisfies  for some predictor .  

\subsection{Discussion}

Predictors can be used to stop or rectify the system 
before it produces a faulty behaviour.  
Being able to predict a fault well in advance 
helps getting prepared for intervention; 
this is represented by the  parameter (which should be maximised).  
Being able to predict the time when the fault is likely to happen 
prevents hasty corrections; 
this is represented by the difference  
(which should be minimised).  
There is an implicit assumption here 
that the number of observations is indicative of time: 
for instance the system generates one observation per minute.  
This is particularly relevant to hybrid systems modeled as DES 
\cite{vento-etal::tsmc::15}.  

Ideally the system should be -predictable with a large  value 
and a small  value.  

We illustrate the definition of predictability by considering the example 
of the potentially critical subsystem of an aircraft.  
This example is, of course, very limited.  
For such a system it is important to predict faults well in advance 
in order to take preventive measures 
(e.g., modify the flight path in order to stay near to an aerodrome).  
On the other hand it is also important to provide a precise prediction 
as emergency landings are expansive.  

In order to provide an early prediction 
we might want the system to be at least -predictable.  
At that stage however, we do not need a precise prediction: 
a -predictability is still acceptable.  
For the second requirement however, 
we want to be able to predict the fault quite accurately, 
for instance -predictability
which suggests that the fault will occur in the next four hours 
and that an unscheduled landing is now necessary.  
So, interestingly, this example requires 
two different predictability properties.  

\section{Solving Interval Predictability Problems}
\label{sec::solution}
This section shows how to verify the predictive level 
of a given system.  

\subsection{Predictive levels}

We first show that, 
while the definition of predictability involves two parameters, 
the dimension of predictability is actually much smaller.  

\begin{lemm}\label{lemm::pred->pred}
  A system that is -predictable 
  is also 
  \begin{enumerate}
  \item 
    -predictable (if ) 
    and
  \item 
    -predictable (if ). 
  \end{enumerate}
\end{lemm}

\begin{proof}
  That -predictability entails -predictability 
  is trivial from Definition~\ref{defi::ijpredictor}: 
  an -predictor is also an -predictor 
  since the constraint on the prediction is strictly weaker.  

  Assume that the system is -predictable with , 
  i.e., there exists an -predictor .  
  Then define  such that 
  \begin{itemize}
  \item  and 
  \item .  
  \end{itemize}  
  It is easy to show that  is a predictor 
  (if the prediction  was correct, 
  then the prediction  is correct).  
  Furthermore it is easy to prove that  is an -predictor: 
  if  for some prefix  of , 
  then for the prefix , 
   
  (or  if ).  
\end{proof}

Lemma~\ref{lemm::pred->pred} shows that some levels of predictability 
are strictly weaker than others.  
There are however levels of predictability 
that are mutually incomparable.  
Consider the examples of Figure~\ref{fig::1123}.  
Clearly the system of Figure~\ref{fig::1123}a is -predictable 
because a fault is always preceded by two s 
and the occurrence of the first  implies 
that the fault will be reached after the next observation; 
on the other hand it is not -predictable 
because when the fault becomes unavoidable 
(i.e., it will occur after less than  observations) 
then the fault can (and, actually, will) occur after less than  observations.  
The system of Figure~\ref{fig::1123}b is -predictable 
because the fault is always preceded by  or  
and because observing a first  implies that the fault is unavoidable; 
on the other hand, it is not -predictable 
because, after observing , it is not possible to decide 
whether the fault will occur immediately or after two observations.  

\begin{figure*}[ht]
  \begin{minipage}{0.35\linewidth}
    \begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state,initial,initial text=] (A) at (0,0) {};
  \node[state] (B) at (2,0) {};
  \node[state,fill=gray] (C) at (4,0) {};

  \path 
    (A) edge        node {} (B)
    (B) edge        node {} (C)
    (A) edge [loop] node {} ()
    (C) edge [loop] node {} ()
  ;
\end{tikzpicture}
    \end{center}
  \end{minipage}\hfill
  \begin{minipage}{0.55\linewidth}
    \begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state,initial,initial text=] (A) at (0,0) {};
  \node[state] (B) at (2,0) {};
  \node[state] (C) at (4,0) {};
  \node[state] (D) at (6,1) {};
  \node[state,fill=gray] (E) at (6,-1) {};

  \path 
    (A) edge        node {} (B)
    (B) edge        node {} (C)
    (C) edge        node {} (E)
    (C) edge        node {} (D)
    (D) edge        node {} (E)
    (A) edge [loop] node {} ()
    (E) edge [in=-15,out=15,loop] node {} ()
  ;
\end{tikzpicture}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.4\linewidth}
    a. Example of a -predictable set of faults 
    which is not -predictable.
  \end{minipage}\hfill
  \begin{minipage}{0.5\linewidth}
    b. Example of a -predictable (and -predictable) 
    set of faults 
    which is not -predictable.
  \end{minipage}
  \caption{Illustrating that some predictive levels are not comparable.}
    \label{fig::1123}
\end{figure*}

\subsection{Characterisation of Predictability}

In order to determine whether a system is predictable 
we define notions of distance between a system state and a fault.  

\begin{defi}
  The \emph{minimal distance} between  and the set  of states 
  denoted , is the minimum number of observations 
  before reaching  from  
  
  and  if there is no such .  
  The \emph{maximal distance} between  and a set of states , 
  denoted , is the maximum number of observations 
  before reaching  from  
  
   if there is no bound to , 
  and  if  (i.e., there is no such ).  
\end{defi}

Notice that these distances are bounded by the number  of states 
when they are different from .  
Indeed, if  
the corresponding trace includes a cycle, 
and a smaller trace therefore exists (by cutting the cycle).  
Similarly if  
the corresponding trace includes a cycle, 
and a longer trace exists (where the cycle can be taken once more).  


The minimal and maximal distances give us 
a first estimate of the time interval before fault.  
To simplify notations we write  
to denote the time interval .  

\begin{lemm}\label{lemm::singlestateprediction}
  For all trace  and all prefix , 
  if  is a predictor then
  
\end{lemm}

\begin{proof}
  Let  be the time interval 
  of the state  
  and let  be the prediction of .  

  By definition of the minimal distance~, 
  there exists a trace  
  such that , 
  , 
  and .  
  Therefore  would contradict the first condition 
  in the definition of a predictor (Def.~\ref{defi::predictor}).  

  Furthermore if , 
  then by definition of the maximal distance~, 
  there exists a trace  
  such that , 
  , 
  and .  
  Therefore  would contradict the second condition 
  in the definition of a predictor (Def.~\ref{defi::predictor}).  

  If  then  and  implies .  
\end{proof}

This result can be generalised to the collection of states 
that an observer can assume the system to be in 
(the \emph{belief state}).  
Formally the belief state  is the set of states 
that the system can be in if the sequence  of observations 
has been observed: 


\begin{coro}\label{coro::predictorsupset}
  For all predictor , 
  for all sequence  of observations 
  
\end{coro}

\begin{proof}
  If  is an element of the belief state 
  then, by definition of the belief state, 
  there exists a trace  such that  
  and .  
  From Lemma~\ref{lemm::singlestateprediction}, 
  , 
  which also applies to the union of these elements.  
\end{proof}

Actually it is possible to characterise 
the ``optimal'' predictor in terms of distances.  
Let  and  be two predictors.  
We say that  is stronger than , denoted , 
iff  for all .\footnote{We assume that  and  
are undefined if  cannot be generated by the system 
().}
We denote  the \emph{optimal predictor}: 
.  
It should be clear that the optimal predictor is well-defined and unique.  

\begin{lemm}\label{lemm::defopti}
  The optimal predictor  
  is exactly the predictor that satisfies  
  for all sequence  of observations.  
\end{lemm}

\begin{proof}
  Let  
  and .  
  From Corollary~\ref{coro::predictorsupset} 
  we already know that .  
  We only need to prove that  
  is a correct prediction.  

  Following Definition~\ref{defi::predictor} 
  let  be an infinite trace 
  and let  be two finite traces 
  such that  and .  
  Let us call  the state reached by  
  and  the state reached by : 
  .  
  By definition of the belief state, .  
  To prove that  is a correct prediction 
  we need to prove that the two conditions 
  of Definition~\ref{defi::predictor} are satisfied.  

  Assume that ; 
  we shall prove that the premise of the second condition 
  in Definition~\ref{defi::predictor} is not satisfied.  
  By definition of the maximal distance of : 
  .  
  Since we know , it clearly holds 
  that .  

  Assume instead that ; 
  we shall prove this time 
  that the premise of the first condition is not satisfied.  
  By definition of the minimal distance of : 
  .  
  Since we know , it clearly holds 
  that .  
\end{proof}

As it turns out  equals the union of exactly two intervals.  

\begin{lemm}\label{lemm::twostates}
  For all sequence  of observations 
  such that , 
  there exists a pair of states  
  such that .  
\end{lemm}

\begin{proof}
  From Lemma~\ref{lemm::defopti} 
   is the union of a finite collection of intervals.  
  Because this set is finite, there is an interval, say , 
  whose lower bound is minimal; 
  similarly there is an interval, say , 
  whose upper bound is maximal.  
  Therefore .  
\end{proof}

The optimal predictor exhibits some very interesting properties.  

\begin{lemm}\label{lemm::onemoreobs}
  For all sequence  of observations, 
  
\end{lemm}

\begin{proof}
  Let  be two finite traces 
  such that .  
  Then by definition 
   
  (unless ).  
  Similarly 
   
  (unless ).  
  
  Therefore .  

  For each state , 
  there exists a state in  
  such that two such traces  
  lead respectivement to  and  
  (but notice that for some , there may be no such ).  
  Therefore .  
\end{proof}


The optimal predictor can be used to decide predictability.  
Indeed from Definition~\ref{defi::ijpredictor} 
any suboptimal predictor enjoys only a (non-necessarily strict) subset 
of -predictability qualities of the optimal predictor.  
This is expressed in the following corollary 
where non-predictability is proved 
if  is a strict subset () 
of some prediction .  

\begin{coro}\label{coro::predictfromoptimal}
  If  
  the system is not -predictable 
  iff there exists a sequence  of observations 
  such that .  
\end{coro}

\begin{proof}
  We assume .  

  
  Assume that there is no sequence  of observations 
  such that .  
  Consider a faulty trace .  
  We shall show that  is -predictable.  

  Let  be a faulty prefix: 
  .  
  Then by Definition~\ref{defi::predictor} of a predictor, 
   where .  
  Notice also that  where .  
  From Lemma~\ref{lemm::onemoreobs} 
  we know that adding one observation to a sequence 
  can reduce the lower bound of the interval returned by  
  only by .  
  Therefore, since the lower bound is greater than or equal to  
  for  and down to  for , 
  there is a prefix  of  
  such that  and .  
  But since , 
   and the faulty trace  
  is -predictable (Def.~\ref{defi::ijpredictor}).  


  
  Let  be the sequence of observations 
  such that  
  and let  be this interval .  
  Notice that  since  is not empty.  

  Assume .  
  From Lemma~\ref{lemm::twostates} 
  and from the definition of the time intervals 
  there exists  
  and  
  such that 
  \begin{itemize}
  \item 
    , 
  \item 
    , 
  \item 
    , 
  \item 
    , 
  \item 
    , 
  \item 
    .  
  \end{itemize}
  We shall prove by contradiction that  is not -predictable.  
  
  Assume that  is -predictable.  
  Then there exists a prefix  of  
  such that .  
  Because of the first condition of Definition~\ref{defi::predictor}, 
  this prefix must be such that , 
  and therefore .  
  We know that , 
  therefore  and .  

  Because  and  generate the same sequence of observations, 
  there exists a prefix  of  (and therefore of ) 
  that generates the same sequence of observations as .  
  Furthermore, we know that ; 
  that is: .  
  According to the second condition of Definition~\ref{defi::predictor}, 
  , 
  which contradicts the last item of the six items 
  presented at the beginning of this proof.  

  The proof under the assumption that  is very similar.  
  We choose  such that .  
  This proves that the system is not -predictable.  
  Since we know that a bound bigger than  is equivalent 
  to that of , we show 
  that the system is not -predictable.  
\end{proof}

Notice that if , 
then the system is not -predictable for any  
(even ).  

Combining Corollary~\ref{coro::predictfromoptimal} 
and Lemma~\ref{lemm::twostates}, 
we obtain the following theorem.  

\begin{theo}\label{theo::computingpredictability}
  The system is -predictable 
  iff  and 
  for all sequence  of observations, 
  for all pair of states , 
  
\end{theo}

We write  the relation 
indicating that the two states  and  
appear together in a belief state.  
Notice that  is not an equivalence relation 
(it is not transitive).  

\subsection{Algorithms}


We now turn to implementation of Theorem~\ref{theo::computingpredictability}.  
The algorithm includes four steps: 
\begin{enumerate}
\item 
  Compute the minimal distance for each state; 
\item 
  Compute the maximal distance for each state; 
\item 
  Compute the twin plant which represents the  relation; 
\item 
  Compute the -predictability.  
\end{enumerate}
All parts of the verification process will be presented here 
to ensure the paper is self-contained.  

Algorithm~\ref{algo::dmin} computes the minimal distance of each state.  
In this algorithm and the following one, 
 if  is observable and  otherwise.  
It assumes that all states have infinite distance 
until it is has been proved that a shorter distance exists.  
It then sets all faulty states' minimal distance to  
and updates the minimal distances of all states 
until convergence is reached.  
To make sure that the states are explored in the optimal order 
we use a priority queue  
that orders its elements by smaller value ; 
however since  only contains elements 
with two types of distances 
(the current distance and this distance plus one), 
the queue can be implemented with two buckets.  
The complexity of the algorithm is therefore linear 
in the number  of transitions.  

\begin{algorithm}[ht]
  \begin{algorithmic}
  \STATE 
    {\bf Input}: an FSM , 
    a set of states 
  \STATE 
    Create a table 
  \FORALL{}
    \STATE 
  \ENDFOR
  \STATE 
    
  \FORALL{}
    \STATE 
    \STATE 
  \ENDFOR
  \WHILE{} 
    \STATE 
    \FORALL{}
      \IF{}
        \STATE 
        \STATE 
      \ENDIF
    \ENDFOR
  \ENDWHILE
  \STATE {\bf return}  
  \end{algorithmic}
  \caption{Computing the minimal distance.}
  \label{algo::dmin}
\end{algorithm}

\paragraph{}
Algorithm~\ref{algo::dmax} computes the maximal distance of each state.  
It starts by computing the list of states () 
that can stay outside of  forever 
(those states have infinite maximal distance).  
It then initialises every state with a maximal distance of  
and updates the distance whenever it finds a bigger value.  
This update will eventually terminate 
(after at most  iterations).  
The first part of the algorithm requires to iterate twice
over all transitions; 
the second part requires to iterate at most  times 
over at most all transitions.  
Therefore the complexity of Algorithm~\ref{algo::dmax} 
is at most .  

\begin{algorithm}[p]
\begin{algorithmic}
\STATE 
  {\bf Input}: an FSM , 
  a set of states 
\STATE 
  Let 
\STATE 
  Create map 
\STATE
  
\FORALL{}
  \STATE  
  \IF{}
    \STATE 
  \ENDIF
\ENDFOR
\WHILE{}
  \STATE 
    Let 
  \FORALL{}
    \STATE 
    \IF{}
      \STATE 
    \ENDIF
  \ENDFOR 
\ENDWHILE
\STATE 
  Create a table 
\FORALL{}
  \IF{} 
    \STATE 
  \ELSE
    \STATE 
  \ENDIF
\ENDFOR
\STATE 
  
\WHILE{}
  \STATE 
  \FORALL{}
    \FORALL{}
      \IF{}
        \STATE 
        \STATE  
      \ENDIF
    \ENDFOR
  \ENDFOR
\ENDWHILE
\STATE {\bf return}  
\end{algorithmic}
  \caption{Computing the maximal distance.}
  \label{algo::dmax}
\end{algorithm}

\paragraph{}
The twin plant \cite{jiang-etal::tac::01} is a construction 
that determines precisely the  relation.  
Notice that, strictly speaking, it is not necessary 
to build it as a finite state machine: 
for predictability only the  relation matters; 
not the transitions between the states of the twin plant.  

  Given an FSM , 
  the \emph{twin plant} is the finite state machine 
   
  where 
  \begin{itemize}
  \item 
    , 
  \item 
    , 
  \item 
    

    
  \item 
    .  
  \end{itemize}

It is well-known that the state  of  
is reachable from  iff  
(Lemma~10, \cite{genc-lafortune::automatica::09} 
where the twin plant is called \emph{verifier}).  
The twin plant can therefore be used to verify the -predictability.  

The procedure for computing the -predictability 
is given in Algorithm~\ref{algo::pred}.  
It generates an array  such that for all , 
the system is -predictable and non--predictable.  
The algorithm first initialises  to .  
It then iterates over all the states of the twin plant 
and updates the table .  
According to Theorem~\ref{theo::computingpredictability} 
the result of Algorithm~\ref{algo::pred} 
is the list of -predictabilities that the system enjoys.  

\begin{algorithm}
  \begin{algorithmic}[1]
    \STATE {\bf input} an FSM , 
    the list of minimal and maximal distances  and , 
    the twin plant 
    \STATE Create an array of integers 
    \FORALL{}
        \STATE 
    \ENDFOR
    \FORALL{}
    \STATE 
    \STATE 
      \STATE \label{line::ss->notpred}
    \ENDFOR
    \STATE {\bf return} 
  \end{algorithmic}
  \caption{Algorithm to compute -predictability}
  \label{algo::pred}
\end{algorithm}

We claim that the algorithm presented here is quadratic 
in the number of states and transitions of the system.  
It is easy to see that computing the distances 
is at most quadratic for both types of distances, 
and that the resulting structure has linear size 
with constant time access.  
The size of the twin plant is quadratic 
in the size of the original system 
(it includes at most  states 
and  transitions)---and that is assuming a non-deterministic model. 
Finally the fourth step 
requires iterating over the quadratic number of states in the twin plant.  

Our definitions of predictability and -predictability 
match those of J\'eron et al. \cite{jeron-etal::wc::08} 
and the proposed algorithm can therefore be used 
to verify these properties.  
It is also possible to simplify it 
by focussing on the  parameter.  

As a last result, consider a \emph{fully observable system}, 
i.e., a system in which .  
Then, at any time, the state of the system can be deduced 
from the sequence of observations; 
but notice that how the system will evolve 
remains unknown.  
Then the relation  is equivalent to identity: 
 iff .  
Consequently, after the distances of each state have been computed, 
the predictability can be computed in linear time.  

\subsection{Building the Optimal Predictor}

Lemma~\ref{lemm::defopti} gives us a procedure 
for computing the optimal predictor.  
Similarly to diagnosis and its diagnoser \cite{sampath-etal::tac::95} 
it is possible to compute a deterministic FSM 
that represents how the belief state evolves 
as more observations are gathered.  

Formally the \emph{optimal predictor} is a finite state machine 
 
where 
\begin{itemize}
\item 
  , 
\item 
  , 
\item 
   
  is defined below, 
  and 
\item 
  . 
\end{itemize}

For every state  of the optimal predictor
and every event , 
there is exactly one state  
such that  
is a transition of the optimal predictor.  
The state  is defined 
as the set of states of the system 
that can be reached from a state of  
through a path that generates only one observation: 


Given a sequence  of observations 
the predictor follows the single path labeled by  
on the predictor and reaches the state  
(i.e., the state  
such that ).  
The prediction is then .\footnote{If the model is correct, 
then the state  should never be reached 
and the union is therefore well-defined.}
Adding a single observation  to , 
the new prediction can be easily computed 
by getting the state  that satisfies 
.  
Assuming the optimal FSM 
and the interval associated with each state of the predictor 
are precomputed, 
the optimal prediction of a sequence of observations 
is linear in the size of this sequence 
and the incremental optimal prediction is constant time.  
Notice however that, as is the case with the diagnoser 
\cite{rintanen::ijcai::07}, 
the optimal predictor is exponentially large 
in the number of states of the system.  

\section{Related Work}
\label{sec::related}
Predictability as presented in this paper 
was introduced by Genc and Lafortune 
\cite{genc-lafortune::safeprocess::06}.  
Their approach was however only Boolean: 
they addressed the question 
``can the fault be predicted before it occurs?''  
They presented an exponential space algorithm 
using a structure similar to our optimal predictor.  
They also announced the existence of a polytime algorithm, 
similar to the twin plant used for diagnosability 
and formally presented in an extension of their work 
\cite{genc-lafortune::automatica::09}.  

Together with J\'eron and Marchand, 
they proposed an additional improvement to lower the complexity 
down to quadratic \cite{jeron-etal::wc::08}.  
We claim here that their algorithm is not quite quadratic 
(we discuss this question at the end of this section).  
Their approach is very similar to the approach presented 
in the previous section: 
They construct a twin plant and verify predictability 
by checking whether there exists a pair  
such that  and .  

Brand\'an Briones and Madalinski presented 
the notions of -predictability and -predictability 
\cite{brandanbriones-madalinski::sccc::11}.  
-predictability is similar to our definition of -predictability 
meaning that the fault is predicted at least  observations 
before the fault occurs.  
-predictability is the equivalent 
of our property of -predictability, 
meaning that it is possible to predict the fault occurrence 
before it occurs but when at most  observations 
are still possible before the fault 
(in other words, the fault prediction is not too early).  

\begin{figure}[ht]
  \begin{minipage}{0.47\linewidth}
  \begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state] (A) at (0,0) {};

  \node[state] (B1) at (2,2) {};
  \node (Bm) at (2,0) {};
  \node[state] (Bn) at (2,-2) {};

  \node[state] (C) at (4,0) {};

  \node[state] (D1) at (6,2) {};
  \node (Dm) at (6,0) {};
  \node[state] (Dn) at (6,-2) {};

  \path
    (A) edge node[above] {} (B1)
    (A) edge node[below] {} (Bn)
    (B1) edge node[above] {} (C)
    (Bn) edge node[below] {} (C)
    (C) edge node[above] {} (D1)
    (C) edge node[below] {} (Dn)
    (D1) edge[in=-15,out=15,loop] node {} (D1)
    (Dn) edge[in=-15,out=15,loop] node {} (Dn)
  ;
\end{tikzpicture}
  \end{center}
  \end{minipage}\begin{minipage}{0.06\linewidth}
  \ 
  \end{minipage}\begin{minipage}{0.47\linewidth}
  \begin{center}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]

  \node[state] (A) at (0,0) {};

  \node[state] (B1) at (2,2) {};
  \node (Bm) at (2,0) {};
  \node[state] (Bn) at (2,-2) {};

  \node[state] (D1) at (6,2) {};
  \node (Dm) at (6,0) {};
  \node[state] (Dn) at (6,-2) {};

  \path
    (A) edge node[above] {} (B1)
    (A) edge node[below] {} (Bn)
    (B1) edge node[above] {} (D1)
    (B1) edge node[below] {} (Dn)
    (Bn) edge node[above] {} (D1)
    (Bn) edge node[below] {} (Dn)
    (D1) edge[in=-15,out=15,loop] node {} (D1)
    (Dn) edge[in=-15,out=15,loop] node {} (Dn)
  ;

\end{tikzpicture}
  \end{center}
  \end{minipage}

  \begin{minipage}{0.47\linewidth}
  \begin{center}
    {a. System.}
  \end{center}
  \end{minipage}\begin{minipage}{0.06\linewidth}
  \ 
  \end{minipage}\begin{minipage}{0.47\linewidth}
  \begin{center}
    {b. -reduction of the system.}
  \end{center}
  \end{minipage}
  \caption{DES (a) and its -reduction (b).}
  \label{fig::quadra}
\end{figure}

\paragraph{}
While this is a minor issue, 
we provide an example and a comprehensive discussion 
that illustrate the complexity error from J\'eron et al. 
\cite{jeron-etal::wc::08}.  
Consider the example of Figure~\ref{fig::quadra}a.  
This DES includes  states and  transitions.  
The single observable event is  
and the single unobservable event is  
(this example does not feature any faulty event).  
The twin plant then consists in  states and  transitions 
(details in Table~\ref{tab::tpsize}).  
The -reduction, presented on Figure~\ref{fig::quadra}b, 
contains one state fewer than the original DES 
but  transitions.  
As a consequence, the number of states in the twin plant 
reduces down to  
but the number of transitions shoots up to   
(details in Table~\ref{tab::tpsize2}).  

\begin{table}[t!]
  \begin{minipage}{.5\linewidth}
    \begin{center}
      \begin{tabular}{c | c}
        Type of states & Number of states\\ 
        \hline 
         & \\
         & \\
         & \\
         & \\
        \hline
        Total: & 
      \end{tabular}
    \end{center}
  \end{minipage}\begin{minipage}{.5\linewidth}
    \begin{center}
      \begin{tabular}{c | c}
        Type of transitions & Number of transition\\ 
        \hline 
         & \\
         & \\
         & \\
         
        & \\
        \hline
        Total: & 
      \end{tabular}
    \end{center}
  \end{minipage}
  \caption{Size of the twin plant for the DES in Figure~\ref{fig::quadra}a.}
  \label{tab::tpsize}
\end{table}

\begin{table}[t!]
  \begin{minipage}{.5\linewidth}
    \begin{center}
      \begin{tabular}{c | c}
        Type of states & Number of states\\ 
        \hline 
         & \\
         & \\
         & \\
        \hline
        Total: & 
      \end{tabular}
    \end{center}
  \end{minipage}\begin{minipage}{.5\linewidth}
    \begin{center}
      \begin{tabular}{c | c}
        Type of transitions & Number of transition\\ 
        \hline 
         & \\
         
        & \\
         
        & \\
        \hline
        Total: & 
      \end{tabular}
    \end{center}
  \end{minipage}
  \caption{Size of the twin plant for the -reduced 
  DES in Figure~\ref{fig::quadra}b.}
  \label{tab::tpsize2}
\end{table}

\section{Conclusion}
We presented a notion of -predictability, 
an extension of predictability that specifies 
that there exists a time interval 
during which the fault occurrence is bound to happen in the system.  
This notion is very useful 
because it allows one to express different type of predictability, 
namely whether a fault can be predicted well in advance, 
whether the time of failure can be precisely predicted, 
or both.  

There are several obvious extensions to these works, 
mainly regarding the expressive power of the modelling framework.  
We want to extend this work to timed systems 
\cite{cassez-grastien::formats::13}, 
to probabilistic systems \cite{nouioua-etal::dx::14}, 
or to hybrid systems \cite{bayoudh-etal::ecai::08}.  
Other works include the extension of the current work 
to decentralised predictors \cite{takai-kumar::tac::12}, 
the study of optimal observability for predictability 
akin to that of diagnosability \cite{brandanbriones-etal::dx::08}
or in combinaison with opacity constraints
\cite{chedor-etal::jdeds::14}.  

\section*{Acknowledgments}
NICTA is funded by the Australian Government 
through the Department of Communications 
and the Australian Research Council 
through the ICT Centre of Excellence Program. 

\bibliographystyle{alpha}
\bibliography{bib}

\end{document}
