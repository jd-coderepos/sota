\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts,amssymb}
\usepackage{eucal}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{color} 
\newcommand{\pare}[1]{(#1)}
\newcommand{\bra}[1]{\{#1\}}
\newcommand{\brac}[1]{[#1]}
\newcommand{\bigpare}[1]{\bigl(#1\bigr)}
\newcommand{\biggpare}[1]{\biggl(#1\biggr)}
\newcommand{\Bigpare}[1]{\Bigl(#1\Bigr)}
\newcommand{\Biggpare}[1]{\Biggl(#1\Biggr)}
\newcommand{\bigbra}[1]{\bigl\{#1\bigr\}}
\newcommand{\Bigbra}[1]{\Bigl\{#1\Bigr\}}
\newcommand{\biggbra}[1]{\biggl\{#1\biggr\}}
\newcommand{\Biggbra}[1]{\bigl\{#1\Biggr\}}
\newcommand{\bigbrac}[1]{\bigl[#1\bigr]}
\newcommand{\Bigbrac}[1]{\Bigl[#1\Bigr]}
\newcommand{\biggbrac}[1]{\biggl[#1\biggr]}
\newcommand{\Biggbrac}[1]{\Biggl[#1\Biggr]}
\newcommand{\normalset}[2]{\{#1\mid#2\}}
\newcommand{\bigset}[2]{\bigl\{#1\bigm|#2\bigr\}}
\newcommand{\Bigset}[2]{\Bigl\{#1\Bigm|#2\Bigr\}}
\newcommand{\biggset}[2]{\biggl\{#1\biggm|#2\biggr\}}
\newcommand{\Biggset}[2]{\bigl\{#1\Biggm|#2\Biggr\}}
\newcommand{\norm}[1]{\| #1 \|}
\newcommand{\bignorm}[1]{\bigl\| #1 \bigr\|}
\newcommand{\Bignorm}[1]{\Bigl\| #1 \Bigr\|}
\newcommand{\biggnorm}[1]{\biggl\| #1 \biggr\|}
\newcommand{\Biggnorm}[1]{\Biggl\| #1 \Biggr\|}
\newcommand{\abs}[1]{| #1 |}
\newcommand{\bigabs}[1]{\bigl| #1 \bigr|}
\newcommand{\Bigabs}[1]{\Bigl| #1 \Bigr|}
\newcommand{\biggabs}[1]{\biggl| #1 \biggr|}
\newcommand{\Biggabs}[1]{\Biggl| #1 \Biggr|}
\newcommand{\jap}[1]{\langle #1 \rangle}
\newcommand{\bigjap}[1]{\bigl\langle #1 \bigr\rangle}
\newcommand{\Bigjap}[1]{\Bigl\langle #1 \Bigr\rangle}
\newcommand{\biggjap}[1]{\biggl\langle #1 \biggr\rangle}
\newcommand{\Biggjap}[1]{\Biggl\langle #1 \Biggr\rangle}

\newcommand{\simgt}{\lower.5ex\hbox{}}
\newcommand{\simlt}{\lower.5ex\hbox{}}


\def\a{\alpha}
\def\b{\beta}
\def\c{\gamma}
\def\d{\delta}
\def\e{\varepsilon}
\def\f{\varphi}
\def\g{\psi}
\def\h{\hbar}
\def\i{\mbox{\raisebox{.5ex}{}}}
\def\k{\kappa}
\def\l{\lambda}
\def\m{\mu}
\def\n{\nu}
\def\o{\omega}
\def\s{\sigma}
\def\t{\tau}
\def\x{\xi}
\def\y{\eta}
\def\z{\zeta}
\def\th{\theta}
\newcommand{\F}{\Phi}
\newcommand{\G}{\Psi}
\renewcommand{\L}{\Lambda}
\renewcommand{\O}{\Omega}
\newcommand{\Th}{\Theta}
\newcommand{\OPS}{O\!P\!S}

\def\re{\mathbb{R}}
\def\co{\mathbb{C}}
\def\ze{\mathbb{Z}}
\def\na{\mathbb{N}}
\def\ex{\mathbb{E}}
\def\pa{\partial}
\def\ids{{\mathcal N}}
\def\pe{\mathbb{P}}

\newcommand{\dom}{\mathcal{D}}
\newcommand{\qdom}{\mathcal{Q}}
\newcommand{\supp}{\text{{\rm supp}\;}}
\newcommand{\trace}{\text{{\rm Tr}} }
\newcommand{\dist}{\text{\rm dist}}
\newcommand{\dto}{\downarrow}
\newcommand{\bounded}{\mathcal{L}}
\newcommand{\arccosh}{\text{\rm Arccosh}}
\newcommand{\ord}{\text{\rm ord}}
\newcommand{\Var}{\text{\rm Var}}
\newcommand{\Res}{\text{\rm Res}}

\newcommand{\Ran}{\text{\rm Ran\;}}

\newcommand{\Mod}{\text{\rm mod }}
\newcommand{\lcm}{\text{\rm lcm}}
\newcommand{\QR}{\text{\rm QR}}
\newcommand{\BYTEMIX}{\text{\rm BYTE\_MIX}}


\def\qed{\hfill }


\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}

\newtheorem{defn}[thm]{Definition}
\newtheorem{ass}{Assumption}
\renewcommand{\theass}{\Alph{ass}}
\newtheorem{example}{Example}

\newtheorem{rem}{Remark}




\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
\title{Crashing Modulus Attack on Modular Squaring for Rabin Cryptosystem}


\author{Masahiro~Kaminaga, Hideki~Yoshikawa,Arimitsu Shikoda,and~Toshinori~Suzuki\thanks{M. Kaminaga, H. Yoshikawa, and T. Suzuki are with the Department 
of Electrical Engineering and Information Technology, and A. Shikoda is with the Department 
of Electrical Engineering, Tohoku Gakuin University, 
13-1, Chuo-1, Tagajo, 985-8537, Japan e-mail: (kaminaga@mail.tohoku-gakuin.ac.jp).}\thanks{Manuscript received xxxx xx, xxxx; revised xxxx xx, xxxx.}}




\markboth{IEEE Transactions on Information Forensics and Security,~Vol.~xx, No.~x, xx~20xx}{Kaminaga \MakeLowercase{\textit{et al.}}: Crashing Modulus Attack on Modular Squaring}




\maketitle

\begin{abstract} The Rabin cryptosystem has been proposed protect the unique ID (UID) in
radio-frequency identification tags. 
The Rabin cryptosystem is a type of lightweight public key system that
is theoretetically quite secure; however it is vulnerable 
to several side-channel attacks. 
In this paper, a crashing modulus attack is presented as a new fault attack on
 modular squaring during Rabin encryption.
This attack requires only one fault in the public key if its perturbed public key can be factored. 
Our simulation results indicate that the attack is more than 50\% successful with several faults in practical time.
A complicated situation arises when reconstrucing the message, including the UID, from ciphertext, i.e., 
the message and the perturbed public key are not relatively prime. 
We present a complete and mathematically rigorous 
message reconstruction algorithm for such a case.
Moreover, we propose an exact formula to obtain a number of candidate messages.
We show that the number is not generally equal to a power of two.
\end{abstract}










\section{Introduction}\label{intro}
It is quite important that 
the modular squaring map  from  to itself, 
where , is the reduced residue system mod .
The algorithmic complexity of 
the modular quadratic equation  for quadratic residue  is equivalent to factoring . 
Thus,  has one-wayness if factoring  is sufficiently difficult.

There are various applications of the modular squaring map with  for large distinct primes  and .
For example, Blum et al.~\cite{BBS} constructed a unpredictable pseudorandom sequence to take the parity of  for 
 with a secret initial value . 
This is known as the Blum-Blum-Shub pseudorandom number generator, and it is theoretically quite important. 
Another important example is the Rabin cryptosystem developed by Michael C. Rabin~\cite{Rabin}.
The Rabin cryptosystem is a public key cryptosystem with public key  and secret keys  and . 
In this system, message  is encrypted as  and decrypted as 
four possible roots of  using  and  and the 
Chinese remainder theorem~(CRT)~(see Section \ref{Rabin}). 

The security of the Rabin cryptosystem, similar to that of RSA, 
is related to the practical difficulty of factoring .
The Rabin cryptosystem has a theoretical advantage in that there exists an exact proof of 
its security equivalent to factoring , which is not currently known to be true for RSA.  
Being theoretically important, the Rabin cryptosystem is also useful 
for passive radio frequency identification~(RFID). 
The use of passive RFID tags to prevent counterfeiting by embedding them in a product is an emerging application. 
RFID systems comprises tags and interrogators.
RFID tags are low-cost wireless devices that associate a unique ID~(UID) with the product.
These tags are powered passively by the interrogator.
Implementation of a public key cryptosystem on RFID tags is challenging, 
because the hardware limited.  Therefore, ``lightweight" cryptosystems are required for RFID tags.
RSA is a well-known and effective public key cryptosystem; however, 
it is not suitable for RFID tags.
RSA encryption requires many modular multiplications, relatively long processing time, 
and a relatively large data-path area. 
In addition, RSA consumes a significant amount of energy. 
There are two major lightweight public key cryptosystems suitable for RFID tags, i.e., 
the elliptic curve cryptosystem~(ECC) and the Rabin cryptosystem. 

ECC can be applied to small devices and has shorter processing time than RSA. 
Moreover, ECC is suitable for various RFID applications. 
Many academic papers on ECC for RFID tags have been published.
For example, F\"urbass-Wolkerstorfer~\cite{Furbass}, Lee-Sakiyama-Batina-Verbauwhede~\cite{Lee}, 
Hutter-Feldhofer-Plos~\cite{Hutter1}, Hutter-Feldhofer-Wolkerstorfer~\cite{Hutter2}, 
Hutter-Joye-Sierra~\cite{Hutter3}, Pessl-Hutter~\cite{Hutter4}, and Kern-Feldhofer~\cite{Kern} 
have reported remarkable results on ECC implementation for RFID tag chip. 


The Rabin cryptosystem requires only one modular squaring, which 
is advantageous for use with RFID tags. 
Indeed, Oren-Feldhofer~\cite{Oren-Feldhofer}, \cite{Oren-Feldhofer2}, Arbit et al.~\cite{Implement} 
successfully applied Rabin encryption variant to RFID tags. The variant, known as 
WIPR~(Weizmann-IAIK[Institute for Applied Information Processing and Communications] Public Key for RFID) 
was developed by Naccache~\cite{Naccache} and Shamir~\cite{Shamir}, \cite{Shamir2}. 
WIPR is smaller, faster, and requires less power than ECC implementations. 
Giesecke \& Devrient GmbH~\cite{RAMON} proposed 
proposed the Rabin-Montgomery Cryptosystem~(RAMON), 
a public key protocol for RFID tags based on the Rabin cryptosystem. 
RAMON uses Montgomery reduction~\cite{Mont} to avoid trial division. 
Therefore, it is very likely that the Rabin cryptosystem 
will be implemented on  various types of RFID tag chips. 

Since the publication of Boneh, DeMillo, and Lipton's landmark paper~\cite{Bellcore}, 
differential fault analysis(DFA) has been an active area in cryptography. 
DFA is a technique to extract secret information from a cryptographic device by provoking a computational fault. 
DFA is a real threat for cryptographic devices, such as smartcard~\cite{Bar}; therefore, 
a vast number of research papers about DFA have been published. 
The monograph edited by Joye-Tunstall~\cite{Joye-Tunstall-Book} is a good guide to this field. 

However, conventional fault attack research for public key cryptosystems 
has focused on DFA for smartcards, particularly signature schemes using RSA and ECC. 
Little attention has been paid to Rabin cryptosystem implemented on an RFID tag chip. 
We propose a powerful fault attack by one-byte perturbation of public key 
 based on the assumption that an attacker can induce faults as 
 the device moves one byte of  from non-volatile memory to a register.
Under this assumption, the attacker can create a new faulted public key , 
where  are mutually distinct primes and  are positive integers. 

We provide a mathematical analysis and 
demonstrate the effectiveness of the proposed fault attack through simulation.
Although there have been some related studies~\cite{Seifert}, \cite{Muir}, they 
are not directly applicable to our target.
An attack against RSA, first developed by Seifert~\cite{Seifert} and
extended to the general case by Muir et al.~\cite{Muir}, can obtain a new secret
exponent , where  is a public exponent and 
 is Euler's totient function. 
This approach is not applicable to Rabin cryptosystems; 
therefore, a secret message  including UID must be reconstructed directly.
Conversely, it is known that an attacker can obtain modular quadratic 
equation  by solving each  and
computing  using CRT only if  holds.
However, generally, 
some prime factors of  are small. 
As a result, cases in which  occur frequently. We also present a complete mathematical method to reconstruct the message in such cases. 
\medskip
The remainder of this paper is organized as follows. 
Section II presents a brief description of quadratic residues, 
the Rabin cryptosystem, and basic facts about the target implementation of a Rabin cryptosystem 
in an RFID tag.
Section III presents the general principle and procedure of our attack, 
as well as a complete and mathematically rigorous message reconstruction algorithm.
We show an exact formula to obtain the number of candidate message in Section IV. 
Simulated attack results are presented in Section V, and conclusions are presented in Section VI. 
\section{Preliminaries}
\subsection{Quadratic Residues}
Let  be an odd prime. 
An integer  is called a quadratic residue mod  if 
there exists  such that . 
We denote the set of all quadratic residues mod  by .
We can use 
Euler's criterion to claim that  
to determine  or not.
In other words,  holds if , or 
 holds if .
Using Euler's criterion, square roots of  mod  can be represented as 

if . 
Note that  is a positive integer under the condition 
and .
If , i.e., , 
then we require the Tonelli-Shanks algorithm to find the square roots. 
The Tonelli-Shanks algorithm runs in polynomial time 
assuming that the generalized Riemann hypothesis is true. 
We can find the roots mod  of  as follows. 
First, we find all square roots mod . 
Then using the Hensel lift(see e.g., section 13.3.2 of Shoup's book~\cite{Shoup}), we 
lift each of these square roots to obtain all of the roots , 
and then lift these to obtain all square roots 
mod , and so on.
Quadratic residue can be generalized for the mod of 
an odd composite number . 
A quadratic residue mod  is an integer  such that there exists an  
that satisfies . 
Using the CRT, it can be demonstrated that  is a quadratic residue mod  
if and only if it is a quadratic residue mod of each , and one obtain every root mod  
from all roots mod 's. 



\subsection{Rabin Cryptosystem}\label{Rabin}
The Rabin cryptosystem~\cite{Rabin} is a public key system based on the factorization 
difficulty of  where  and  are large and distinct balanced primes. 
The length  of  must be greater than or equal to 1,024 to be safe.
 is its public key, and  and  are its secret keys. 
To reduce decryption complexity, choose  and  that satisfy 
 should be chosen. 
According to the Dirichlet's theorem on arithmetic progressions
(see e.g., Theorem 5.52 of Shoup's book~\cite{Shoup}), 
infinitely many prime numbers  that satisfy  exist. 
Let  be the reduced residue system mod .
Generally, the plaintext  is generated from a shorter message, including 
the UID, in our case. 
In the Rabin cryptosystem, to encrypt , the sender computes its square mod :
 

To decrypt the ciphertext , the receiver computes its square roots  
of  mod  using  and  as follows.
First, compute 
 and 

using an efficient exponentiation algorithm.
Second, using the CRT, 
the four roots are computed as follows:

Finally, 
the receiver recognizes the valid plaintext based on its format, such as redundancy and structure.

The Rabin cryptosystem has two significant advantages with respect to 
alternative public key schemes. 
First, it is provably difficult to factor . 
Second, it imposes a small computational burden, 
has relatively 
lightweight implementation, and requires only a single squaring and modular reduction 
for encryption.

lightweight implementation, and requires


\subsection{WIPR Scheme}
The most time consuming process of Rabin encryption is trial division by  
because it is a RAM-intensive process. 
There are two well-known ways to avoid trial division. 
One is using Montgomery reduction~\cite{Mont}, 
and the other is using the WIPR scheme.
When we use Montgomery reduction, we 
compute  rather than , 
where  is -bits long; therefore, it is simply a data format problem. 
Conversely, the WIPR scheme includes an essentially different process.
Thus, we describe only the WIPR scheme.

To reduce the trial division process, Naccache~\cite{Naccache} and Shamir~\cite{Shamir}, \cite{Shamir2} 
proposed a variant by replacing the modular multiplication by adding a large random multiple of , 
where the size of the random number  is at least 80 bits longer than the size of :

Obviously, , and  is fully randomized.
The decryption process is identical to Rabin's original process.
This randomized variant of Rabin's scheme is easier to implement because it has only multiplications 
without modular reduction. 
It is lighter than the original Rabin scheme; however, it 
requires a register that is approximately twice as long 
for the ciphertext.

The WIPR scheme replaces  with the output of a light stream cipher, 
which was developed by Oren-Feldhofer~\cite{Oren-Feldhofer}. 
This stream cipher is implemented by creating a Feistel network. 
Arbit et al.~\cite{Implement} reported that 
their successful implementation had a data-path area of 
4,184 gate equivalents, an encryption time of 180 ms and an average power consumption of 11 W.  

We describe the WIPR challenge-response protocol as follows.
\begin{enumerate}
\item Challenge: The interrogator sends the challenge(random bit string)  
of length  to the tag.
\item Response: 
The RFID tag generates two random bit strings  and , where 
, and .
The tag generates a message as follows:

where  denotes concatenation operator, and transmits the following ciphertext:

and {\BYTEMIX} is a simple byte-interleaving 
operation~(see Oren-Feldhofer~\cite{Oren-Feldhofer2} for details).
\item Verify: The interrogator decrypts  using the secret key  and 
finds the correct message, including the UID, in four square roots.
\end{enumerate}
Here,  and  are security parameters~(originally set to ).

Note that using the Rabin function  to encrypt a message  
that satisfies  requires 
some kind of random padding. 
Some padding schemes with short random padding are vulnerable to attacks based on 
Coppersmith's Theorem for a univariate polynomial~\cite{Coppersmith} and 
Franklin-Reiter's related message attack~\cite{FR1}, \cite{FR2}.

\subsection{RAMON}
Another way to avoid trial division is using 
Montgomery reduction~\cite{Mont}.
When we use Montgomery reduction, we 
compute  rather than , 
where  is -bits long.
Montgomery reduction computes  that satisfies the following Diophantine equation:

Clearly, . 

RAMON was proposed by Giesecke \& Devrient GmbH~\cite{RAMON}.
RFID tag sends the following ciphertext:

where .
In 1024 bit  case, the message  is formatted as follows:
(128 bytes) = challenge(10 bytes)  tag random number(10 bytes)
  TLV-coded signed Tag UID(n bytes)  variable length filling(x bytes)  
checksum(2 bytes)  The last byte must be left free; i.e., set to zero~(1 byte).

Note that ; therefore, 
the interrogator transforms  into normal ciphertext as follows:

Then, the interrogator computes four roots of  mod  using the secret key  
and finds the correct  based on its format.


\section{Proposed Attack}

\subsection{Principle}
In the following, we consider only the WIPR protocol for convenience. 
The fundamental idea of our attack method uses perturbed public key  of .
In this case, the ciphertext changes as follows:

Generally, the attacker cannot factor the coprime  in realistic time.
Conversely, a perturbation  of  can be factored at high probability. 
If the attacker has factored  successfully, such as 
, 
then the modular quadratic equation 
 derived from (\ref{perturbed_eq}) splits into  smaller 
equations: 

Equation (\ref{perturbed_eq_splitted}) can be solved using the 
Tonelli-Shanks algorithm and the Hensel lift. 
CRT leads us to all roots of (\ref{perturbed_eq}) 
from the roots  of (\ref{perturbed_eq_splitted}), i.e., 
we obtain:

where . 
The attacker obtains the correct roots  by modifying the above  as  for 
the smallest  such that . 
The perturbed modular quadratic equation (\ref{perturbed_eq}) typically has  roots, and 
these roots contain the correct message including the UID.
The number of roots exceeds  in some cases depending 
on the values of  for . 
We discuss these problems in Sections \ref{roots} and \ref{NUM}.

\subsection{Fault Models}
The WIPR protocol requires two online multiplications to compute . 
Optimal implementation of WIPR with 1,024 bit  was shown by 
Arbit et al.~\cite{Implement}.
This multiplication process is performed on a multiply-accumulate register by convolution. 
Assuming a word size of one byte, a single multiply-accumulate register 
perform this multiplication in approximately  steps. 
The public key  moves from non-volatile memory to the register byte by byte. 
We assume that the attacker can inject a one-byte fault into this data moving process.
In this paper, we consider two fault models. 
\subsubsection{Crash a byte of }
The first fault model that we choose to perform our attack 
with is derived from those used by Berzati et al.~\cite{Berzati2}, \cite{Berzati3} 
to successfully attack standard RSA.

Here let  be a set of integers in the interval . 
We assume that the attacker can inject a transient fault that public key  modifies by byte, that is,
the injected fault affects only one byte of the public key by modifying it randomly as follows:

where  is bitwise exclusive OR and ,  
for  which 
is required to preserve the parity of . 
We assume the attacker knows the position , 
but the correct value of the faulty public key  is unknown by the attacker.
The attacker must factor 255~() candidates of . 
Our attack also works for a fault that affects several bytes of . 
However, the attacker's task grows in proportion to 
the number of candidates  of perturbed .

This is a natural assumption for both WIPR and RAMON. 
In the WIPR case, the attack target is the time at 
which the -th byte  of  moves from non-volatile memory to 
the register for multiplication before multiplying  and . 
In the RAMON case, the fault is injected while  moves from 
non-volatile memory, such as EEPROM, 
to a register at the trensfer time of the -th byte 
prior to Montgomery squaring .

\subsubsection{Instruction skip}
The second fault model is based on the instruction skip technique. 
Instruction skip is equivalent to replacing an instruction with a no operation 
in assembly language.
Several researchers have investigated DFA using an instruction skip, or a bypass operation 
\cite{RoundReduction}, \cite{park}, \cite{yoshikawa1}. 
Instruction skip does not affect the registers, internal memory, and calculation process.
Successful instruction skip attacks have been reported for 
PIC16F877~\cite{RoundReduction}, ATmega 128~\cite{park}, 
and ATmega 168~\cite{yoshikawa1} microcontrollers. 
Choukri-Tunstall~\cite{RoundReduction} and Park et al.~\cite{park} showed that 
an entire Advanced Encryption Standard secret key could be 
reconstructed by skipping a branch instruction used to 
check the number of rounds. 
Kaminaga et al.~\cite{KYS2015IEEE} showed that it is possible to 
reconstruct an entire secret exponent with  
faulted signatures in a short time for a 1536-bit RSA implementation with the 
-ary method using instruction skipping technique in precomputation phase.


Our attack target is a conditional branch operation for moving 
the last byte of  at the counter .
If the conditional branch operation is 
skipped, the attacker obtains the faulted public key  as follows:

where each .
Clearly,  is one byte shorter than the original , and preserves its parity.

\subsection{Target Byte Location}
Some Rabin cryptosystems for RFID tags adopt special types of modulus  for restricted hardware resources.
WIPR for RFID proposed by Oren-Feldhofer~\cite{Oren-Feldhofer2} uses 
modulus  with a predefined upper half to reduce ROM cost by half.
RAMON uses modulus  to satisfy the condition , which means 
that approximately one-half of the least significant bits of ~(except for the last one) are zeroes 
to reduce multiplications~\cite{RAMON}.
Half of the processes in which modulus data is transferring from EEPROM to a register are reduced in 
such cases.
Therefore, the attacker must set the location of the target byte to the lower half bytes of  
for implementation of 
Oren-Feldhofer's proposal~\cite{Oren-Feldhofer2}, and the attack must set the 
location of the byte to upper half bytes of  for RAMON~\cite{RAMON}.


\subsection{Attack Procedure}\label{AP}
The attacker's goal is to reconstruct the secret message , including the UID.
The following steps provide an example of our attack process. 
\begin{description}
\item[Step 1.] ~Create a perturbed public key  
by injecting a fault to a byte of the public key .
\item[Step 2.] ~Factorize 255 candidates  of . 
When factoring consumes too much amount of time, perturb another byte of  and attempt this process again.
\item[Step 3.] ~Solve modular quadratic equation .
\item[Step 4.] ~Find the correct message  based on data format in all roots of .
\end{description}
Step 2 is the most time concuming process in computation for the attacker. 
Most of  have relatively small factors; thus, these 
can be factored in a short time.
However, some cases require more time to factor . Then, the attacker 
shifts the position of the target byte and attempt the factoring process again. 
Step 3 is a technical process, and we must consider the degenerate case, 
.
Mathematicians have paid little attention to the degenerate case; however, 
such case arises in our attack. 

\subsection{Reconstruction of Roots}\label{roots}
Our attack method comes down to finding all roots of the following 
modular quadratic equation with a square number :

where  is an odd prime and  is a positive integer. 
The oddness of  obeys the fact that our attack targets a byte of  that is not the lowest byte.

We use assumption (A), i.e.,  is squared , throughout this paper. 
Assumption (A) is very natural because  is derived from 
our target equation . 

We denote  by . 
The algorithm for finding the roots of (\ref{QE}) depends on whether . 
We distinguish the ``degenerate" case  
from the ``non-degenerate" case .

\subsubsection{Non-degenerate Case}

Here, let  for some .
For , finding the roots of (\ref{QE}) 
is not difficult~(see e.g., Section 2.8.2 of Shoup's book~\cite{Shoup_book}). 
\begin{thm}(Theorem 2.25~\cite{Shoup_book})\label{justtwo}
If , then the modular quadratic equation (\ref{QE}) 
is equivalent to . 
In particular, (\ref{QE}) has only two roots.
\end{thm}
\begin{proof}
Here, we show the proof for Theorem~\ref{justtwo}. 
Since , there exists the inverse  mod . 
Therefore, (\ref{QE}) is equivalent to .
Let  be , and we obtain

Thus, there exists non-negative integers  such that 
 or . 
Then,  divides  if both  and  are positive, 
which leads to a contradiction because  is an odd prime, therefore, 
 or .
\end{proof}

\begin{thm}
For  and , all the roots of (\ref{QE}) are given by:

where  is Euler's totient function.
\end{thm}
\begin{proof}
It is easy to verify (\ref{easyroot}) directly. 
From Theorem~\ref{justtwo}, the number of roots of (\ref{QE}) is two. 
Note that  follows from 
.
By using Euler's totient theorem  and squaring , we obtain:

Using (\ref{sqrt_Eu}), we obtain
.
This means that  is a square root mod  of , 
therefore, all square roots mod  of  are given by .
\end{proof}

For , we first solve the following equation:


We require the Tonneli-Shanks algorithm to solve (\ref{diffcase}). 
The Tonneli-Shanks algorithm can be described as follows.

{\small
\begin{enumerate}
\item Determine  such that  where  is odd.
\item Find a non-quadratic residue  mod .
\item Compute .
\item Find  such that .
\item Compute .
\item Output  as a solution.
\end{enumerate}
}
It is easy to check if  is a square root mod  of . 
Indeed, using Fermat's little theorem, we obtain 
.

After solving (\ref{diffcase}), the roots can be lifted to mod  using the following.

\begin{thm}(Hensel's lifting lemma) 
Let  and  satisfy 
 and .
Then, there is unique  such that  
and . 
Furthermore, this x is unique in mod , and can be represented explicitly as:

where

The division by  denotes ordinary integer division, 
and the inversion  is computed in .
\end{thm}

\subsubsection{Degenerate Case}
Here we consider the degenerate case, i.e., .

\begin{thm}\label{zerothm}
All roots of the modular quadratic equation  are given by
 for . 
In particular, the number of its roots is .
\end{thm}
\begin{proof} It is clear that  for  satisfies 
. 
Thus, we only have to show that other forms of the roots do not exist. 
Let  with . Since ,  is a multiple number of , 
therefore, . 
Then  if and only if  holds.
\end{proof}

\begin{thm}\label{nonzerothm}
All roots of 
 for , 
which is squared, and  are given by 

where  is a root of . 
In particular, the number of its roots is .
\end{thm}
\begin{proof}
Note that  must be even under assumption (A).
Let  such that , and substitute  into the quadratic equation; thus, we obtain:

Suppose that ,  holds, 
which means that  is a multiple of  and is contradictory. 
Conversely, suppose that ,  holds, 
which means that  is a multiple of  and is contradictory. 
Therefore,  holds, and we obtain:

From Theorem \ref{justtwo}, (\ref{yeq}) has only two roots in modulo . 
Therefore, the root  of  can be represented as: 

for some . 
(\ref{genrep}) satisfies . Then, we have 
. 
We learn . Since  is odd and  is invertible, 
 is a multiple of . Then,  for some .
Substituting  into (\ref{genrep}), we reach 
 for . 
Since only two  satisfy (\ref{yeq}), the number of  is .
\end{proof}

\begin{rem}
The degenerate case occurs frequently when  has a small prime factor.
Therefore, in many cases, we can easily find the desired roots by 
brute force without using Hensel's lifting lemma.
\end{rem}

\section{Number of Candidates of Message}\label{NUM}
We really need for the perturbed public key  is to be easily factorable. 
After factoring, the problem breaks down to find the roots of the modular 
quadratic equation. 
Complexity of finding square roots mod  depends on prime factor decomposition of . 
Complicated cases arise when  is not square-free. 
Here we denote the function the number of distinct prime factor of  by , 
and the number of roots of  by . 
CRT equality (\ref{CRT}) says that  is a multiplicative function. 
Combining Theorem \ref{justtwo}, \ref{zerothm}, and \ref{nonzerothm}, each  can be represented explicitly 
as follows.

\begin{thm}\label{th:numberofroots}

for , and where 

\end{thm}
It is well known that the following asymptotic estimate for 
, which is the number of square-free numbers below .

\begin{thm}(Theorem 333, Hardy-Write~\cite{Hardy-Wright}, p.355) \label{HWasym}

\end{thm}

This estimate tells us that the probability that a number should be square-free 
is approximated as  for large .
Note that  is even because  is squared, and  if and only if .
Theorem \ref{th:numberofroots} implies the following upper bound for square-free :

The equality holds in (\ref{bound}) if and only if . 
Therefore, Theorem \ref{th:numberofroots} and \ref{HWasym} mean that 
the probability that the inequality (\ref{bound}) holds 
is greater than or equal to  asymptotically.
The asymptotic behavior of  is described by Theorem~\ref{EK}.

\begin{thm}(Erd\"os and Kac\cite{ErdosKac}) \label{EK}
The function  is normally distributed in the 
sense that, for any fixed , one has:

as , 
where we denote the cardinality of a set  as .
\end{thm}

Theorem \ref{EK} tells us the distribution of  obeys 
normal distribution with mean  and variance .
We use the rough estimate  for 1,024-bit . 
However, convergence is slow because 
the term  increases very slowly as  becomes large.

Since both WIPR and RAMON uses at east an 80 bit challenge, 
the probability that a candidate correct message  has the same data format 
accidentally is less than or equal to .
According to the above mathematical observations, 
it is quite rare that plural candidates of  will appear.



\section{Time of attack process}\label{SIM}
\subsection{Evaluation method}
In the attack procedure discused in Section \ref{AP}, 
the most time-consuming process is the 
factorization of  at Step 2. 
When this process takes too much time, another fault injection 
is required (Step 1). The other steps are straightforward. 


 Therefore, in this section, the number of repeated fault injections and the time for factorization are 
evaluated by computer simulation. For simplicity, we explain only 
the case `crash of a byte of '. 
The simulation procedure is as follows where  is the average calculation time in Steps (3) and (4).

\begin{description}
\item[Step (0):] ~~~Generate a 1,024 bit ~(128 bytes). Let . 
\item[Step (1a):] ~~~Decide fault position .   in uniform distribution. 
\item[Step (1b):] ~~~Decide fault pattern .  in uniform distribution.
As a notation, 

and .
Attackers know , but do not know .
\item[Step (2):] ~~Let . 
Reset timer , which accumulates the processing time of Steps (2a) through (4).
Reset counter , which counts successful factorization.
\item[Step (2a):] ~~~~~Make  and attempt to factorize it within 1 min. 
If factorization is successful, proceed to Steps 3 and 4 in Section III-D. Let .
If factorization does not finish, proceed to Step (4).
\item[Step (3):] ~~~If , go to Step (5).
\item[Step (4):] ~~~.
When , go back to Step (2a); otherwise, proceed to Step (6).
\item[Step (5):] ~~~The attack is successful. Time consumed is . 
The simulation ends.
\item[Step (6):] ~~~The attack is in fail. Consuming time is . Simulation ends.
\end{description}

\subsection{Results}
Using a desktop PC with a Core i7-2600 CPU at 3.4 GHz with 12 GB RAM, 
the simulation runs on Mathematica 9 for Windows 7 Pro 64 bit. 
A simulated one attack begins 
at Step (0). If this attack ends at Step (5), the attack can find the correct message, i.e., the 
attack is successful. Otherwise, it ends at Step (6), which means the attack has failed. 
As a result, 28 cases were successful among 195 simulated attacks, which is an 14.4\% success rate. 
According to this result, attack with  fault injections has a success rate of . 
The success rate is 54\% for . Figure~\ref{fig:A} shows the distribution of time consumed  per single attack. 
 For successful attacks, 
the mean  is 115.4 min, the median is 136.8 min, and the standard deviation is 78.1 min. For 
failed attacks, the mean, median, and standard deviation of  
are 226.4 min, 226.6 min, and 4 min, respectively.  can be 255 
min at most. However, when factorization finishes within 1 min,  will be less than 255 min. 
Moreover, the attack is complete when the correct message is found; 
thus,  becomes much less than 255 min. if the factorized fault pattern  is 
the true fault pattern, .
 The distribution of the number of successful factorizations,  is shown in Fig.\ref{fig:B}. 
Here,  is 30.91 
on average for failed attack cases. For successful attacks, 
the factorization will break at 
Step (3); therefore, it does not reach the final fault pattern  with high probability. 
Thus, the successful factorization rate is estimated as \%.
Note that, in this simulation, the time limit for the factorization process is 
1 min at Step (2a), which is just an example. The time limit for factorization would be optimized 
by considering total attack time and/or the cost of fault injections. 
This issue will be the focus of future study.


\begin{figure}[htbp]
 \begin{center}
  \includegraphics[width=80mm]{distT.eps}
 \end{center}
 \caption{Distribution of }
 \label{fig:A}
\end{figure}

\begin{figure}[htbp]
 \begin{center}
  \includegraphics[width=80mm]{distc.eps}
 \end{center}
 \caption{Distribution of }
 \label{fig:B}
\end{figure}

\section{Conclusion}
In this paper, we have proposed a powerful fault attack technique against a Rabin cryptosystem implemented in 
a passive RFID tag chip. 
Our attack uses one byte perturbation  of public key . 
One difficulty with our attack is how to reconstruct the message , including the UID, when .
We have provideed a complete algorithm to reconstruct  for such cases. 
This attack requires only one fault in the public key if its perturbed public key can be factored.
The most time consuming process of our attack is the factorization of . 
Empirically, the successful factorization rate is estimated as 12.2\% of , 
even if factorization is limited within 1 min using a desktop PC. 
When this process takes too much time, another fault injection is preferable. 


\section*{acknowledgements}
This work was supported by the Japan Society for the Promotion of Science KAKENHI Grant Number 25330157.


\begin{thebibliography}{}
\bibitem{BBS}L. Blum, M. Blum, and M. Shub, 
``A Simple Unpredictable Pseudo-Random Number Generator", SIAM Journal on Computing, vol. 15, pp. 364-383(1986).
\bibitem{Rabin}M. Rabin, Digitalized Signatures and Public-Key Functions as Intractable
as Factorization, tech. report, MIT, 1979. 
\bibitem{Furbass}F\"urbass and Wolkerstorfer, ``ECC Processor with Low Die Size for RFID Applications," 
IEEE International Symposium on Circuits and Systems, 2007, pp. 1835-1838(2007). 
\bibitem{Lee} Y. K. Lee, K. Sakiyama, L. Batina, and I. Verbauwhede, 
``Elliptic-Curve-Based Security Processor for RFID," IEEE Transactions on Computers, 57(11), pp. 1514-1527(2008).
\bibitem{Hutter1} M. Hutter, M. Feldhofer, and T. Plos, ``An ECDSA Processor for RFID Authentication," 
In S. B. O. Yalcin, editor, RFIDsec 2010, 6th Workshop, Istanbul, Turkey,
June 7-9, volume 6370 of LNCS, Springer, pp. 189-202(2010).
\bibitem{Hutter2} M. Hutter, M. Feldhofer, and J. Wolkerstorfer. ``A Cryptographic Processor for Low Resource
Devices: Canning ECDSA and AES like Sardines," In C. A. Ardagna and
J. Zhou, editors, Information Security Theory and Practices - WISTP, Heraklion,
Crete, Greece, June 1-3, volume 6633 of LNCS, Springer, pp. 144-159(2011).
\bibitem{Hutter3} M. Hutter, M. Joye, and Y. Sierra. Memory-Constrained Implementations of Elliptic
Curve Cryptography in Co-Z Coordinate Representation. In A. Nitaj and
D. Pointcheval, editors, AFRICACRYPT 2011, Dakar, Senegal, July 5-7, volume
6737 of LNCS, Springer, pp. 170-187(2011).
\bibitem{Hutter4}P. Pessl and M. Hutter, ``Curved Tags - A Low-Resource ECDSA Implementation tailored for RFID," 
Radio Frequency Identification: Security and Privacy Issues
Lecture Notes in Computer Science Volume 8651, pp. 156-172(2014).
\bibitem{Kern} T. Kern and M. Feldhofer, ``Low-Resource ECDSA Implementation for Passive RFID Tags," 
In ICECS, December 12-15, Athens, Greece, pp. 1236-1239(2010).
\bibitem{Oren-Feldhofer}Y. Oren and M. Feldhofer, ``WIPR--Public-Key Identification on
Two Grains of Sand," Proc. Workshop on RFID Security 2008, pp. 15-27(2008).
\bibitem{Oren-Feldhofer2} Y. Oren and M. Feldhofer, ``A Low-Resource Public-Key Identification
Scheme for RFID Tags and Sensor Nodes," Proc. 2nd International Conf.
Wireless Network Security (WiSec 09), ACM, pp. 59-68(2009).
\bibitem{Implement}
A. Arbit, Y. Livne, Y. Oren, A. Wool, ``Implementing public-key cryptography on passive RFID tags is practical," 
International Journal of Information Security, February 2015, Volume 14, Issue 1, pp 85-99(2015)
\bibitem{Naccache}
D. Naccache, Method, Sender Apparatus and Receiver Apparatus for
Modulo Operation, European Patent Application 91402958.2, filed
27 Oct. 1992.
\bibitem{Shamir}
A. Shamir, ``Memory Efficient Variants of Public-Key Schemes for
Smart Card Applications," Proc. Advances in Cryptology (EUROCRYPT'94), LNCS 950, pp. 445-449(1995).
\bibitem{Shamir2}
A. Shamir, ``SQUASH - a new MAC with provable security properties for highly
constrained devices such as RFID tags" In Fast Software Encryption,  Springer,  pp. 144-157(2008).
\bibitem{RAMON}W. Hinz, K. Finkenzeller, M. Seysen, 
``Secure UHF Tags with Strong Cryptography - 
Development of ISO/IEC 18000-63 Compatible Secure RFID Tags 
and Presentation of First Results," SENSORNETS, pp. 5-13(2013)
\bibitem{Mont} P. Montgomery, 
``Modular Multiplication Without Trial Division," Math. Computation, vol. 44, pp. 519--521(1985).
\bibitem{Bellcore} D. Boneh, R.A. DeMillo, and R.J. Lipton, ``On the importance
of eliminating errors in cryptographic computations," J. Cryptol. vol.14, no.2,
pp. 101-119, Springer-Verlag, Berlin, 2001. Earlier version published in EUROCRYPT' 97.

\bibitem{Bar} H. Bar-Ei, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan, 
``The sorcerer's apprentice guide to fault attacks," In Proc. of the IEEE 94(2), pp. 370-382(2006).


\bibitem{Joye-Tunstall-Book} M. Joye, and M. Tunstall eds., 
{\it Fault Analysis in Cryptography}, Springer, 2012.


\bibitem{Seifert} J. Seifert, 
``On authenticated computing and RSA-based authentication." In Proc. of the 12th
ACM Conference on Computer and Communications Security (CCS 2005), pp. 122-127(2005).
\bibitem{Muir} J. A. Muir, ``Seifert's RSA fault attack: Simplified analysis and generalizations, "
In ICICS'06 Proc. of the 8th International Conference on Information and Communications Security, 
pp.420-434(2006).
\bibitem{Shoup} V. Shoup, 
{\it A Computational Introduction to Number Theory and Algebra - Second ed.}, 
Cambridge University Press, 2009.
\bibitem{Coppersmith}
D. Coppersmith, Small solutions to polynomial
equations, and low exponent RSA with vulnerabilities,
Journal of Cryptology 10, pp.233-260(1997).
\bibitem{FR1}
M. Franklin and M. Reiter, A Linear Protocol Failure for RSA with exponent three, in
CRYPTO'95 Rump Session, Aug. 1995.
\bibitem{FR2}
D. Coppersmith, M. Franklin, J. Patarin, and
M. Reiter, Low-exponent RSA with related
messages, in EUROCRYPT'98, vol. 1403 of
LNCS, pp. 58-71(1998).
\bibitem{Berzati2} A. Berzati, and L. Goubin, 
Perturbing RSA Public Keys: an Improved Attack. In 
E. Oswald, P. Rohatgi (eds.): Cryptographic Hardware and
Embedded Systems (CHES 2008), Lecture Notes in Computer Science vol. 5154, Springer, 
pp. 380-395(2008).
\bibitem{Berzati3} A. Berzati, C. Canovas-Dumas, and L. Goubin, 
Fault Attacks on RSA Public Keys: Left-To-Right Implementations are also Vulnerable. In 
M. Fischlin (ed.): CT-RSA 2009, Lecture Notes in Computer Science vol. 5473, Springer, 
pp. 414-428(2009).
\bibitem{RoundReduction} H. Choukri and M. Tunstall,
``Round reduction using faults," In Proc. of FDTC 2005, pp.13-24(2005).
\bibitem{park} J. Park, S. Moon, D. Choi, Y. Kang, and J. Ha,~
``Differential fault analysis for round-reduced AES by fault injection,"~
ETRI J. vol. 33, no.3, pp.434-441(2011).
\bibitem{yoshikawa1} H. Yoshikawa, M. Kaminaga, and A. Shikoda,~
``Round addition using faults for generalized Feistel network,"~
{\em IEICE Trans. Inf. \& Syst.}, vol.E96-D, no.1, pp.146-150(2013).
\bibitem{KYS2015IEEE} M. Kaminaga, H. Yoshikawa, and T. Suzuki, 
Double Counting in -ary RSA Precomputation Reveals the Secret Exponent, 
IEEE Trans. on Inform. Forensics \& Sec., pp.1394-1401(2015).
\bibitem{Shoup_book}
V. Shoup, A Computational Introduction to Number Theory and Algebra(2nd ed.), Cambridge University Press, 2009.

\bibitem{Hardy-Wright} G. H. Hardy and E. M. Wright(revised by D. R. Heath-Brown and J. H. Silverman), 
{\it An Introduction to The Theory of Numbers(Sixth Edition)}, Oxford University Press, 2008.

\bibitem{ErdosKac} P. Erd\"os and M. Kac, 
The Gaussian law of errors in the theory of additive number theoretic functions, 
American Journal of Mathematics 62, pp. 738-742(1940) .
\end{thebibliography}





\end{document}
