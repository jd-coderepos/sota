\documentclass[oribibl, 11pt]{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{color}
\usepackage{hyperref}

\usepackage{fancyhdr}
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}

\fancyhf{} 
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\cfoot{\thepage}

\setcounter{secnumdepth}{3}

\fancyhf{}
\renewcommand{\headrulewidth}{0pt} \renewcommand{\footrulewidth}{0pt} 

\fancyfoot[C]{\thepage}

\newcommand{\removed}[1]{}

\newcommand{\rem}{\mathbf}

\newcommand{\cm}{\mathcal{M}}
\newcommand{\cn}{\mathcal{N}}
\newcommand{\co}{\mathcal{O}}
\newcommand{\ce}{\mathcal{E}}
\newcommand{\ch}{\mathcal{H}}
\newcommand{\cs}{\mathcal{S}}
\newcommand{\cu}{\mathcal{U}}
\newcommand{\cp}{\mathcal{P}}
\newcommand{\ca}{\mathcal{A}}
\newcommand{\cb}{\mathcal{B}}
\newcommand{\cc}{\mathcal{C}}
\newcommand{\cd}{\mathcal{D}}
\newcommand{\cg}{\mathcal{G}}
\newcommand{\cx}{\mathcal{X}}
\newcommand{\cl}{\mathcal{L}}
\newcommand{\cj}{\mathcal{J}}
\newcommand{\calt}{\mathcal{T}}
\newcommand{\calr}{\mathcal{R}}

\newcommand{\ra}{\rightarrow}
\newcommand{\rsa}{\rightsquigarrow}
\newcommand{\la}{\longrightarrow}
\newcommand{\lra}{\Leftrightarrow}
\newcommand{\coleq}{\mathrel{\mathop:}=}
\newcommand{\bs}{\backslash}
\newcommand{\past}{\mathrm{past}}
\newcommand{\psum}{\mathrm{psum}}
\newcommand{\future}{\mathrm{future}}
\newcommand{\fsum}{\mathrm{fsum}}

\newcommand{\dprime}{\prime\prime}
\newcommand{\tprime}{\prime\prime\prime}

\newcommand{\gfs}{\cg_{star}}
\newcommand{\gfc}{\cg_{com}}
\newcommand{\gfu}{\cg_{unr}}
\newcommand{\srarrow}{\stackrel{*}\rightarrow}
\newcommand{\lan}{\langle}
\newcommand{\ran}{\rangle}

\DeclareMathOperator{\lcm}{\textup{lcm}}

\renewcommand{\P}{\textup{P}}
\newcommand{\E}{\textup{E}}
\newcommand{\Var}{\textup{Var}}

\newcommand{\tsf}{\textsf}
\newcommand{\ap}{\text{\emph{all paths}}}
\newcommand{\shp}{\text{\emph{shortest paths}}}
\newcommand{\reach}{reach}
\newcommand{\ALG}{\text{ALG}}
\newcommand{\OPT}{\text{OPT}}

\definecolor{DarkRed}{RGB}{182,11,1}

\sloppy

\newtheorem{observation}{Observation}

\title{An Introduction to Temporal Graphs: An Algorithmic Perspective\thanks{Supported in part by the project ``Foundations of Dynamic Distributed Computing Systems'' (\textsf{FOCUS}) which is implemented under the ``ARISTEIA'' Action of the  Operational Programme ``Education and Lifelong Learning'' and is co-funded by the European Union (European Social Fund) and Greek National Resources.}}

\author{Othon Michail}
\institute{Computer Technology Institute \& Press ``Diophantus'' (CTI),\\N. Kazantzaki Str., Patras University Campus,\\ Rio, P.O. Box 1382, 26504,\\Patras, Greece\\
Email:\email{ michailo@cti.gr}\\ Phone: +30 2610 960300}

\begin{document}

\maketitle

\begin{abstract}
A \emph{temporal graph} is, informally speaking, a graph that changes with time.  When time is discrete and only the relationships between the participating entities may change and not the entities themselves, a temporal graph may be viewed as a sequence  of static graphs over the same (static) set of nodes . Though static graphs have been extensively studied, for their temporal generalization we are still far from having a concrete set of structural and algorithmic principles. Recent research shows that many graph properties and problems become radically different and usually substantially more difficult when an extra time dimension in added to them. Moreover, there is already a rich and rapidly growing set of modern systems and applications that can be naturally modeled and studied via temporal graphs. This, further motivates the need for the development of a temporal extension of graph theory. We survey here recent results on temporal graphs and temporal graph problems that have appeared in the Computer Science community.
\end{abstract}

\section{Introduction}
\label{sec:intro}

The conception and development of graph theory is probably one of the most important achievements of mathematics and combinatorics of the last few centuries. Its applications are inexhaustible and ubiquitous. Almost every scientific domain, from mathematics and computer science to chemistry and biology, is a natural source of problems of outstanding importance that can be naturally modeled and studied by graphs. The 1736 paper of Euler on the Seven Bridges of K{\" o}nigsberg problem is regarded as the first formal treatment of a graph-theoretic problem. Till then, graph theory has found applications in electrical networks, theoretical chemistry, social network analysis, computer networks (like the Internet) and distributed systems, to name a few, and has also revealed some of the most outstanding problems of modern mathematics like the four color theorem and the traveling salesman problem.

Graphs simply represent a set of objects and a set of pairwise relations between them. It is very common, and shows up in many applications, the pairwise relations to come with some additional information. For example, in a graph representing a set of cities and the available roads from each city to the others, the additional information of an edge  could be the average time it takes to drive from city  to city . In a graph representing bonding between atoms in a molecule, edges could also have an additional bond order or bond strength information. Such applications can be modeled by weighted or, more generally, by labeled graphs, in which edges (and in some cases also nodes) are assigned values from some domain, like the set of natural numbers. An example of a classical, very rich, and well-studied area of labeled graphs is the area of graph coloring \cite{MR02}.

\emph{Temporal graphs} (also known as \emph{dynamic}, \emph{evolving} \cite{Fe04}, or \emph{time-varying} \cite{FMS09,CFQS12} graphs) can be informally described as \emph{graphs that change with time}. In terms of modeling, they can be thought of as a special case of labeled graphs, where labels capture some measure of time. Inversely, it is also true that any property of a graph labeled from a discrete set of labels corresponds to some temporal property if interpreted appropriately. For example, a proper edge-coloring, i.e. a coloring of the edges in which no two adjacent edges share a common color, corresponds to a temporal graph in which no two adjacent edges share a common time-label, i.e. no two adjacent edges ever appear at the same time. Still, the time notion and the rich domain of modern applications motivating its incorporation to graphs, gives rise to a brand new set of challenging, important, and practical problems that could not have been observed from the more abstract perspective of labeled graphs.

Though the formal treatment of temporal graphs is still in its infancy, there is already a huge identified set of applications and research domains that motivate it and that could benefit from the development of a concrete set of results, tools, and techniques for temporal graphs. A great variety of both modern and traditional networks such as information and communication networks, social networks, transportation networks, and several physical systems can be naturally modeled as temporal graphs. In fact, this is true for almost any network with a dynamic topology. Most modern communication networks, such as mobile ad-hoc, sensor, peer-to-peer, opportunistic, and delay-tolerant networks, are inherently dynamic. In social networks, the topology usually represents the social connections between a group of individuals and it changes as the social relationships between the individuals are updated, or as individuals leave or enter the group. In a transportation network, there is usually some fixed network of routes and a set of transportation units moving over these routes and dynamicity refers to the change of the positions of the transportation units in the network as time passes. Physical systems of interest may include several systems of interacting particles or molecules reacting in a well-mixed solution. Temporal relationships and temporal ordering of events are also present in the study of epidemics, where a group of individuals (or computing entities) come into contact with each other and we want to study the spread of an infectious disease (or a computer virus) in the population.

A very rich motivating domain is that of distributed computing systems that are inherently dynamic. The growing interest in such systems has been mainly driven by the advent of low-cost wireless communication devices and the development of efficient wireless communication protocols. Apart from the huge amount of work that has been devoted to applications, there is also a steadily growing concrete set of foundational work. A notable set of works has studied (distributed) computation in \emph{worst-case} dynamic networks in which the topology may change arbitrarily from round to round subject to some constraints that allow for bounded end-to-end communication~\cite{OW05,KLO10,MCS14,MCS13b,DPRS13,APRU12}. Population protocols \cite{AADFP06} and variants \cite{MCS11-2,MS14b} are collections of finite-state agents that move passively, according to the dynamicity of the environment, and interact in pairs when they come close to each other. The goal is typically for the population to compute (i.e. agree on) something useful or construct a desired network or structure in such an adversarial setting. Another interesting direction assumes that the dynamicity of the network is a result of randomness (this is also the case sometimes in population protocols). Here the interest is on determining ``good'' properties of the dynamic network that hold with high probability (abbreviated w.h.p. and meaning with probability at least  for some constant ), such as small (temporal) diameter, and on designing protocols for distributed tasks \cite{CFTE08,AKL08}. In all the above subjects, there is always some sort of underlying temporal graph either assumed or implied. For introductory texts on the above lines of research in dynamic distributed networks the reader is referred to \cite{CFQS12,MCS11,Sc02,KO11}.

Though static graphs \footnote{In this article, we use ``static'' to refer to classical graphs. This is plausible as the opposite of ``dynamic'' that is also commonly used for temporal graphs. In any case, the terminology is still very far from being standard.} have been extensively studied, for their temporal generalization we are still far from having a concrete set of structural and algorithmic principles. Additionally, it is not yet clear how is the complexity of combinatorial optimization problems affected by introducing to them a notion of time. In an early but serious attempt to answer this question, Orlin \cite{Or81} observed that many dynamic languages derived from -complete languages can be shown to be -complete. Among the other few things that we do know, is that the max-flow min-cut theorem holds with unit capacities for time-respecting paths \cite{Be96}. Additionally, Kempe \emph{et al.} \cite{KKK00} proved that, in temporal graphs, the classical formulation of Menger's theorem is violated and the computation of the number of node-disjoint - paths becomes -complete. A reformulation of Menger's theorem which is valid for all temporal graphs was recently achieved in \cite{MMCS13}. These results are discussed in Section \ref{sec:menger}. Recently, building on the distributed online dynamic network model of \cite{KLO10}, Dutta \emph{et al.} \cite{DPRS13}, among other things, presented \emph{offline centralized algorithms} for the -\emph{token dissemination} problem. In -token dissemination, there are  distinct pieces of information (tokens) that are initially present in some distributed processes and the problem is to disseminate all the  tokens to all the processes in the dynamic network, under the constraint that one token can go through an edge per round. These results, motivated by distributed computing systems, are presented in Section \ref{sec:dissemination}.

Another important problem is that of \emph{designing} an efficient temporal graph given some requirements that the graph should meet. This problem was recently studied in \cite{MMCS13}, where the authors introduced several interesting cost minimization parameters for optimal temporal network design. One of the parameters is the \emph{temporality} of a graph , in which the goal is to create a temporal version of  minimizing the maximum number of labels of an edge, and the other is the \emph{temporal cost} of , in which the goal is to minimize the total number of labels used. Optimization of these parameters is performed subject to some \emph{connectivity constraint}. They proved several upper and lower bounds for the temporality of some very basic graph families such as rings, directed acyclic graphs, and trees, as well as a trade-off between the temporality and the maximum label of rings. Furthermore, they gave a \emph{generic method} for computing a lower bound of the temporality of an arbitrary graph with respect to (abbreviated w.r.t.) the constraint of preserving a time-respecting analogue of every simple path of . Finally, they proved that computing the temporal cost w.r.t. the constraint of preserving at least one time-respecting path from  to  whenever  is reachable from  in , is -hard. Most of these results are discussed in Section \ref{sec:design}.

Other recent papers have focused on understanding the complexity and providing algorithms for temporal versions of classical graph problems. For example, the authors of \cite{MS14} considered temporal analogues of \emph{traveling salesman problems} (TSP) in temporal graphs, and in the way also introduced and studied temporal versions of other fundamental problems like {\sc Maximum Matching}, {\sc Path Packing}, {\sc Max-TSP}, and {\sc Minimum Cycle Cover}. One such version of TSP is the problem of exploring the nodes of a temporal graph as soon as possible. In contrast to the positive results known for the static case strong inapproximability results can be proved for the dynamic case \cite{MS14,EHK15}. Still, there is room for positive results for interesting special cases \cite{EHK15}. Another such problem is the {\sc Temporal Traveling Salesman Problem with Costs One and Two} (abbreviated TTSP(1,2)), a temporal analogue of TSP(1,2), in which the temporal graph is a complete weighted graph with edge-costs from  and the cost of an edge may vary from instance to instance \cite{MS14}. The goal is to find a minimum cost temporal TSP tour. Several \emph{polynomial-time approximation algorithms} have been proved for TTSP(1,2) \cite{MS14}. The best approximation is  for the generic TTSP(1,2) and  for its interesting special case in which the lifetime of the temporal graph is restricted to . These and related results are presented in Section \ref{sec:matching}.

Additionally, there are works that have considered \emph{random temporal graphs}, in which the labels are chosen according to some probability distribution. We give a brief introduction to such models in Section \ref{sec:random}. Moreover, Section \ref{sec:model} provides all necessary preliminaries and definitions and also a first discussion on temporal paths and Section \ref{sec:linear} discusses a temporal graph model in which the availability times of the edges are provided by a set of linear functions.

As is always the case, not all interesting results and material could fit in a single document. We list here some of them. Holme and Saram{\" a}ki \cite{HS12} give an extensive overview of the literature related to temporal networks from a diverge range of scientific domains. Harary and Gupta \cite{HG97} discuss applications of temporal graphs and highlight the great importance of a systematic treatment of the subject. Kostakos \cite{Ko09} uses temporal graphs to represent real datasets, shows how to derive various node metrics like average temporal proximity, average geodesic proximity and temporal availability, and also gives a static representation of a temporal graph (similar to the \emph{static expansion} that we discuss in Section \ref{sec:model}). Avin \emph{et al.} \cite{AKL08} studied the cover time of a simple random walk on Markovian dynamic graphs and proved that, in great contrast to being always polynomial in static graphs, it is exponential in some dynamic graphs. Clementi \emph{et al.} \cite{CFTE08} studied the flooding time (also known as information dissemination; see a similar problem discussed in Section \ref{sec:dissemination}) in the following type of edge-markovian dynamic graphs: if an edge exists at time  then, at time , it disappears with probability , and if instead the edge does not exist at time , then it appears at time  with probability . There are also several papers that have focused on temporal graphs in which every instance of the graph is drawn independently at random according to some distribution \cite{CPMS07,HHL88,Pi87,KK02} (the last three did it in the context of dynamic gossip-based mechanisms), e.g. according to . A model related to random temporal graphs, is the \emph{random phone-call model}, in which each node, at each step, can communicate with a random neighbour \cite{DGH87,KSSV00}. Other authors \cite{XFJ03,FT98} have assumed that an edge may be available for a whole time-interval  or several such intervals and not just for discrete moments. Aaron \emph{et al.} \cite{AKM14} studied the {\sc Dynamic Map Visitation} problem, in which a team of agents must visit a collection of critical locations as quickly as possible in a dynamic environment. Kontogiannis \emph{et al.} \cite{KMP15}, among other things, presented oracles for providing time-dependent min-cost route plans and conducted their experimental evaluation on a data set of the city of Berlin. 

\section{Modeling and Basic Properties}
\label{sec:model}

When time is assumed to be discrete, a temporal graph (or digraph) is just a static graph (or digraph)  with every edge  labeled with zero or more natural numbers. The labels of an edge may be viewed as the times at which the the edge is \emph{available}. For example, an edge with no labels is never available while, on the other hand, an edge with labels all the even natural numbers is available every even time. Labels could correspond to seconds, days, years, or could even correspond to some artificial discrete measure of time under consideration. 

There are several ways of modeling formally discrete temporal graphs. One is to consider an underlying static graph  together with a labeling  of  assigning to every edge of  a (possibly empty) set of natural numbers, called \emph{labels}. Then the temporal graph of  with respect to  is denoted by . This notation is particularly useful when one wants to explicitly refer to and study properties of the labels of the temporal graph. For example, the multiset of all labels of  can be denoted by , their cardinality is defined as , and the maximum and minimum label assigned to the whole temporal graph as  and , respectively. Moreover, we define the \emph{age} (or \emph{lifetime}) of a temporal graph  as  (or simply  when clear from context). Note that in case  then we have .

Another, often convenient, notation of a temporal graph  is as an ordered pair of disjoint sets  such that  in case of a graph and with  replaced by  in case of a digraph. The set  is called the set of \emph{time-edges}.  can also be used to refer to the structure of the temporal graph at a particular time. In particular,  is the (possibly empty) set of all edges that appear in the temporal graph at time . In turn,  can be used to define a snapshot of the temporal graph  at time , which is usually called the -\emph{th instance of }, and is the static graph . So, it becomes evident that a temporal graph may also be viewed as a \emph{sequence of static graphs} .

Finally, it is typically very useful to expand in time the whole temporal graph and obtain an equivalent static graph without losing any information. The reason for doing this is mainly because static graphs are much better understood and there is a rich set of well established tools and techniques for them. So, a common approach to solve a problem concerning temporal graphs is to first express the given temporal graph as a static graph and then try to apply or adjust one of the existing tools that works on static graphs. Formally, the \emph{static expansion} of a temporal graph  is a DAG  defined as follows. If  then  and  and  or . In words, for every discrete moment we create a copy of  representing the instance of the nodes at that time (called \emph{time-nodes}). We may imagine the moments as levels or rows from top to bottom, every level containing a copy of . Then we add outgoing edges from time-nodes of one level only to time-nodes of the level below it. In particular, we connect a time-node  to its own subsequent copy  and to every time-node  s.t.  is an edge of the temporal graph at time . Observe that the above construction includes all possible vertical edges from a node to its own subsequent instance. These edges express the fact that nodes are usually not oblivious and can preserve their on history in time (modeled like propagating information to themselves). Nevertheless, depending on the application, these edges may some times be omitted. 

\subsection{Journeys}
\label{subsec:journeys}

As is the case in static graphs, the notion of a \emph{path} is one of the most central notions of a temporal graph, however it has to be redefined to take time into account. A \emph{temporal} (or \emph{time-respecting}) \emph{walk}  of a temporal graph  is an alternating sequence of nodes and times  where , for all , and , for all . We call  the \emph{duration} (or \emph{temporal length}) of the walk ,  its \emph{departure time} and  its \emph{arrival time}. A \emph{journey} (or \emph{temporal/time-respecting path})  is a temporal walk with pairwise distinct nodes. In words, a journey of  is a path of the underlying static graph of  that uses strictly increasing edge-labels. A - journey  is called \emph{foremost from time } if it departs after time  and its arrival time is minimized. The \emph{temporal distance} from a node  at time  to a node  is defined as the duration of a foremost - journey from time . We say that a temporal graph  has \emph{temporal (or dynamic) diameter} , if  is the minimum integer for which it holds that the temporal distance from every time-node  to every node  is at most .

A nice property of foremost journeys is that they can be computed efficiently. In particular there is an algorithm that, given a source node  and a time , computes for all  a foremost - journey from time  \cite{MMCS13,MMS15}. The running time of the algorithm is , where  here and throughout this article denotes the number of nodes of the temporal graph. It is worth mentioning that this algorithm takes as input the whole temporal graph . Such algorithms are known as \emph{offline} algorithms in contrast to \emph{online} algorithms to which the temporal graph is revealed on the fly. The algorithm is essentially a temporal translation of the breadth-first search (BFS) algorithm (see e.g. \cite{CLRS01} page 531) with path length replaced by path arrival time. For every time , the algorithm picks one after the other all nodes that have been already reached (initially only the source node ) and inspects all edges that are incident to that node at time . If a time-edge  leads to a node  that has not yet been reached, then  is picked as an edge of a foremost journey from the source to . This greedy algorithm is correct for the same reason that the BFS algorithm is correct. An immediate way to see this is by considering the static expansion of the temporal graph. The algorithm begins from the upper copy (i.e. at level 0) of the source in the static expansion and essentially executes the following slight variation of BFS: at step , given the set  of already reached nodes at level , the algorithm first follows all vertical edges leaving  in order to reach in one step the -th copy of each node in , and then inspects all diagonal edges leaving  to discover new reachabilities. The algorithm outputs as a foremost journey to a node , the directed path of time-edges by which it first reached the column of  (vertical edges are interpreted as waiting on the corresponding node). The above algorithm computes a shortest path to each column of the static expansion. Correctness follows from the fact that shortest paths to columns are equivalent to foremost journeys to the nodes corresponding to the columns.

\section{Connectivity and Menger's Theorem}
\label{sec:menger}

Assume that we are given a static graph  and a source node  and a sink node  of . \footnote{The sink is usually denoted by  in the literature. We use  instead as we reserve  to refer to time moments.} Two paths from  to  are called node-disjoint if they have only the nodes  and  in common. \emph{Menger's theorem} \cite{Me27}, which is the analogue of the max-flow min-cut theorem for undirected graphs, is one of the most basic theorems in the theory of graph connectivity. It states that \emph{the maximum number of node-disjoint - paths is equal to the minimum number of nodes that must be removed in order to separate  from } (see also \cite{Bo98} page 75). 

It was first observed in \cite{Be96} and then further studied in \cite{KKK00} that this fundamental theorem of static graphs, is violated in temporal graphs if we keep its original formulation and only require it to hold for journeys instead of paths. In fact, the violation holds even for a very special case of temporal graphs, those in which every edge has at most one label, which are known as \emph{single-labeled temporal graphs} (as opposed to the more general \emph{multi-labeled} temporal graphs that we have discussed so far). Even in such temporal graphs, the maximum number of node-disjoint journeys from  to  can be strictly less than the minimum number of nodes whose deletion leaves no - journey. For a simple example, observe in Figure \ref{fig:ber} that there are no two node-disjoint journeys from  to  but after deleting any one node (other than  or ) there still remains a - journey. To see this, notice that every journey has to visit at least two of the inner-nodes . If  is one of them, then a vertical obstacle is introduced which cannot be avoided by any other journey. If  is not, then the only disjoint path remaining is  which is not a journey. On the other hand, any set of two inner vertices has a - journey going through them implying that any - separator must have size at least 2. As shown in \cite{KKK00}, this construction can be generalized to a single-labeled graph with  inner nodes in which: (i) every - journey visits at least  of these nodes, ensuring again that there are no two node-disjoint - journeys and (ii) there is a journey through any set of  inner nodes, ensuring that every - separator must have size at least .

\begin{figure}[!hbtp]
   \centering{
        \includegraphics[width=0.65\textwidth]{berman.pdf}
        }
   \caption{A counterexample of Menger's theorem for temporal graphs (adopted from \cite{KKK00}). Each edge has a single time-label indicating its availability time.} \label{fig:ber}
\end{figure} 

On the positive side, the violation does not hold if we replace node-disjointness by edge-disjointness and node removals by edge removals. In particular, it was proved in \cite{Be96} that for single-labeled temporal graphs,  the maximum number of edge-disjoint journeys from  to  is equal to the minimum number of edges whose deletion leaves no - journey, that is, that the max-flow min-cut theorem of static graphs holds with unit capacities for journeys in single-labeled temporal graphs. The construction (which we adopt from \cite{KKK00}) is simply an \emph{ad-hoc} static expansion for the special case of single-labeled temporal graphs. Let  be the underlying graph of an undirected single-labeled temporal graph. We construct a labeled directed graph  as follows. for every  we add in  two new nodes  and  and the directed edges , , , , . Then we relax all labels required so that there is sufficient ``room'' (w.r.t. time) to introduce (by labeling the new edges) both a  journey and a  journey. The goal is to be able to both move by a journey from  to  and from  to  in . An easy way to do this is the following: if  is the label of , then we can label  by , where , and similarly for . Then we construct a static directed graph  as follows: For every  let  be its incoming edges and  its outgoing edges. We want to preserve only the time-respecting  traversals. To this end, for each one of the  edges we introduce a node  and the edge  and for each one of the  edges we introduce a node  and the edge  and we delete node . Finally, we introduce the edge  iff  is time-respecting. This reduction preserves edge-disjointness and sizes of edge separators and if we add a super-source and a super-sink to  the max-flow min-cut theorem for static directed graphs yields the aforementioned result. Another interesting thing is that reachability in  under journeys corresponds to (path) reachability in  so that we can use BFS on  to answer questions about foremost journeys in , as we did with the static expansion in Section \ref{subsec:journeys}.

Fortunately, the above important negative result concerning Menger's theorem has a turnaround. In particular, it was proved in \cite{MMCS13} that if one reformulates Menger's theorem in a way that takes time into account then a very natural temporal analogue of Menger's theorem is obtained, which is valid for all (multi-labeled) temporal networks. The idea is to replace in the original formulation node-disjointness by \emph{node departure time disjointness} (or \emph{out-disjointness}) and node removals by \emph{node departure times removals}. When we say that we remove \emph{node departure time}  we mean that we remove \emph{all edges leaving  at time }, i.e. we remove label  from all  edges (for all ). So, when we ask ``how many node departure times are needed to separate two nodes  and ?'' we mean how many node departure times must be selected so that after the removal of all the corresponding time-edges the resulting temporal graph has no - journey (note that this is a different question from how many time-edges must be removed and, in fact, the latter question does not result in a Menger's analogue). Two journeys are called \emph{out-disjoint} if they never leave from the same node at the same time (see Figure \ref{fig:menger-example} for an example).

\begin{figure}[!hbtp]
   \centering{
        \includegraphics[width=0.8\textwidth]{menger-example.pdf}
        }
   \caption{An example of a temporal graph. The dashed curves highlight the directions of three out-disjoint journeys from  to . The labels used by each of these journeys are indicated by the labels that are enclosed in boxes.} \label{fig:menger-example}
\end{figure}

\begin{theorem} [Menger's Temporal Analogue \cite{MMCS13}] \label{the:dmeng}
Take any temporal graph , where , with two distinguished nodes  and . The maximum number of out-disjoint journeys from  to  is equal to the minimum number of node departure times needed to separate  from .  
\end{theorem}

The idea is to take the static expansion  of  and, for each time-node  with at least two outgoing edges to nodes different than , add a new node  and the edges  and  . Then define an \emph{edge capacity function } as follows: edges  take capacity  and all other edges take capacity . The theorem follows by observing that the maximum - flow is equal to the minimum of the capacity of a - cut, the maximum number of out-disjoint journeys from  to  is equal to the maximum - flow, and the minimum number of node departure times needed to separate  from  is equal to the minimum of the capacity of a - cut. See also Figure \ref{fig:menger-example-expansion} for an illustration.

\begin{figure}[!hbtp]
   \centering{
        \subfigure[]{
        \includegraphics[width=0.362\textwidth]{menger-example2.pdf}
        \label{fig:shape1}}
	\hspace{1cm}
        \subfigure[]{
        \includegraphics[width=0.48\textwidth]{menger-example3.pdf}
        \label{fig:shape2}}
	\hspace{1cm}
        \subfigure[]{
        \includegraphics[width=0.362\textwidth]{menger-example4.pdf}
        \label{fig:shape3}}
	\hspace{1cm}
        \subfigure[]{
        \includegraphics[width=0.48\textwidth]{menger-example5.pdf}
        \label{fig:shape4}}        
        }
   \caption{(a) The static expansion of a temporal graph. Here, only two edges leave from the same node at the same time:  and . (b) Adding a new node  and three new edges. This we ensures that a node departure time can be removed by removing a single diagonal edge: removing edge  removes all possible departures from . This ensures that separation of  and  by node-departure times is equivalent to separation by a usual static cut. (c) Adding capacities to the edges. Vertical edges take capacity  and diagonal edges take capacity 1. (d) The maximum number of out-disjoint journeys from  to  is equal to the maximum flow from  to  and both are equal to 3.} \label{fig:menger-example-expansion}
\end{figure}

\section{Dissemination and Gathering of Information}
\label{sec:dissemination}

A natural application domain of temporal graphs is that of \emph{gossiping} and in general of \emph{information dissemination}, mainly by a distributed set of entities (e.g. a group of people or a set of distributed processes). Two early such examples were the \emph{telephone problem} \cite{BS72} and the \emph{minimum broadcast time problem} \cite{Ra94}. In both, the goal is to transmit some information to every participant of the system, while minimizing some measure of communication or time. A more modern setting, but in the same spirit, comes from the very young area of distributed computing in highly dynamic networks \cite{OW05,KLO10,KO11,CFQS12,MCS14,MCS13b}. 

There are  nodes. In this context, nodes represent distributed processes. Note, however, that most of the results that we will discuss, concern centralized algorithms (and in case of lower bounds, these immediately hold for distributed algorithms as well). The nodes communicate with other nodes in discrete rounds by interchanging messages. In every round, an adversary scheduler selects a set of edges between the nodes and every node may communicate with its current neighbors, as selected by the adversary, usually by \emph{broadcasting} a single message to be delivered to all its neighbors. So, the dynamic topology behaves as a discrete temporal graph where the -th instance of the graph is the topology selected by the adversary in round . The main difference, compared to the setting of the previous sections, is that now (in all results that we will discuss in this section, apart from the last one) the topology is revealed to the algorithms in an online and totally unpredictable way. An interesting special case of temporal graphs consists of those temporal graphs that have \emph{connected instances}. A temporal graph  is called \emph{continuously connected} (also known as \emph{1-interval connected}) if  is connected for all times  \cite{OW05,KLO10}. Such temporal graphs have some very useful properties concerning information propagation in a distributed setting, like, for example, that if all nodes broadcast in every round all information that they have heard so far, then in every round at least one more node learns something new, which implies that a piece of information can in principle be disseminated in at most  rounds. Naturally, the problem of information dissemination becomes much more interesting and challenging if we do not allow nodes to transmit an unlimited amount of information in every round, that is, if we restrict the size of the messages that they can transmit.

An interesting problem of token dissemination in such a setting, called the -\emph{token dissemination problem}, was introduced and first studied in \cite{KLO10}. In this problem there is a domain of \emph{tokens} , each node is assigned a subset of the tokens, and a total of  distinct tokens is assigned to the nodes. The goal is for an algorithm (centralized or distributed) to organize the communication between the nodes in such a way that, under any dynamic topology (from those described above), each node eventually terminates and outputs (i.e. has learned) all  tokens. In particular, the focus here is on \emph{token-forwarding algorithms}. Such an algorithm is quite restricted in that, in every round  and for every node , it only picks a single token from those already known by  (or the empty token ) and this token will be delivered to all the current neighbors of  by a single broadcast transmission. Token-forwarding algorithms are simple, easy to implement, typically incur low overhead, and have been extensively studied in static networks \cite{Le92,Pe00}. We will present now a lower bound from \cite{KLO10} on the number of rounds for token dissemination, that holds even for centralized token forwarding algorithms. Such centralized algorithms are allowed to see and remember the whole state and history of the entire network, but they have to make their selection of tokens to be forwarded without knowing what topology will be scheduled by the adversary in the current round. So, first the algorithm selects and then the adversary reveals the topology, taking into account the algorithm's selection. For simplicity, it may be assumed that each of the  tokens is assigned initially to exactly one (distinct) node.  

\begin{theorem} [\cite{KLO10}] \label{the:klo10-lower-bound}
Any deterministic centralized algorithm for -token dissemination in continuously connected temporal graphs requires at least  rounds to complete in the worst case.
\end{theorem}

The idea behind the proof is to define a potential function that charges by  the -th token learned by each node. So, for example, the first token learned by a node comes at a cheap price of  while the last token learned costs . The initial total potential is , because  nodes have obtained their first token each, and the final potential (i.e. when all nodes have learned all  tokens) is . Then it suffices to present an adversarial schedule, i.e. a continuously connected temporal graph, that forces any algorithm to achieve in every round at most a bounded increase in potential. The topology of a round can be summarized as follows. First we select all edges that contribute no cost, called \emph{free edges}. An edge  is free if the token transmitted by  is already known by  and vice versa. The free edges partition the nodes into  components . We pick a representative  from each component . It remains to construct a connected graph over the s. An observation is that each  transmits a distinct token , otherwise at least two of them should have been connected by a free edge (because two nodes interchanging the same token cannot learn anything new). The idea is to further partition the representatives into a small set of nodes that know many tokens each and a large set of nodes that know few tokens each. We can call the nodes that know many tokens the \emph{expensive} ones, because according to the above potential function a new token at a node that already knows a lot of tokens comes at a high price, and similarly we call those nodes that know few tokens the \emph{cheap} ones. In particular, a node is expensive if it is missing at most  tokens and cheap otherwise. Roughly, a cheap node learns a new token at the low cost of at most , because the cost of a token is inversely proportional to the number of missing tokens before the token's arrival. First we connect the cheap nodes by an arbitrary line. As there are at most  such nodes and each one of them obtains at most two new tokens (because it has at most two neighbors on the line and each node transmits a single token), the total cost of this component is at most , that is, bounded as desired. It remains to connect the expensive nodes. It can be shown that there is a way to match each expensive node to a distinct cheap node (i.e. by constructing a matching between the expensive and the cheap nodes), so that no expensive node learns a new token. So, the only additional cost is that of the new tokens that cheap nodes obtain from expensive nodes. This additional cost is roughly at most , so the total cost have been shown to be bounded by a small constant as required. It is worth mentioning that \cite{KLO10}, apart from the above lower bound, also proposed a simple distributed algorithm for -token dissemination that needs  rounds in the worst case to deliver all tokens.

The above lower bound can be further improved by exploiting the probabilistic method \cite{DPRS13}. In particular it can be shown that any randomized token-forwarding algorithm (centralized or distributed) for -token dissemination needs  rounds. This lower bound is within a logarithmic factor of the  upper bound of \cite{KLO10}. The construction is trivial (as is typical in probabilistic results, the interesting machinery is in the analysis). Now \emph{all} the representatives of the connected components formed by the free edges are connected arbitrarily by a line. The idea is to first prove the bound w.h.p. over an initial token distribution, in which each of the nodes receives each of the  tokens independently with probability . It can be shown in this case that, w.h.p. over the initial assignment of tokens, in every round there are at most  new token deliveries and an overall of  new token deliveries must occur for the protocol to complete. Finally, it can be shown via the probabilistic method, that, in fact, any initial token distribution can be reduced to the above distribution for which the bound holds. The above lower bounding technique, based on the probabilistic method, was applied in \cite{HK12} to several variations of -token dissemination. For example, if the nodes are allowed to transmit  tokens instead of only one token in every round, then it can be proved that any randomized token-forwarding algorithm requires  rounds.

In \cite{DPRS13}, also offline token forwarding algorithms were designed, that is, algorithms provided the whole dynamic topology in advance. One of the problems that they studied, was that of delivering all tokens to a given sink node  as fast as possible, called the \emph{gathering problem}. We now present a lemma from \cite{DPRS13} concerning this problem, mainly because its proof constitutes a nice application of the temporal analogue of Menger's theorem presented in Section \ref{sec:menger} (the simplified proof via Menger's temporal analogue is from \cite{MMCS13}).

\begin{lemma} [DPRS13]
Let there be  tokens at given source nodes and let  be an arbitrary node. Then, if the temporal graph  is continuously connected, all the tokens can be delivered to , using local broadcasts, in  rounds.
\end{lemma}

Let  be the set of source nodes, let  be the number of tokens of source node  and let the age of the temporal graph be . It suffices to prove that there are at least  out-disjoint journeys from  to any given , such that  of these journeys leave from each source node . Then, all tokens can be forwarded in parallel, each on one of these journeys, without conflicting with each other in an outgoing transmission and, as the age is , they all arrive at  in  rounds. To show the existence of  out-disjoint journeys, we create a \emph{supersource} node  and connect it to the source node with token  (assuming an arbitrary ordering of the tokens from  to ) by an edge labeled . Then we shift the rest of the temporal graph in time, by increasing all other edge labels by . The new temporal graph  has asymptotically the same age as the original and all properties have been preserved. Now, it suffices to show that there are at least  out-disjoint journeys from  to , because the  edges of  respect the 's. Due to Menger's temporal analogue, it is equivalent to show that at least  departure times must be removed to separate  from . Indeed, any removal of fewer than  departure times must leave at least  rounds during which all departure times are available (because, due to shifting by , the age of  is ). Due to the fact that the original temporal graph is connected in every round,  rounds guarantee the existence of a journey from  to . 

\section{Design Problems}
\label{sec:design}

So far, we have mainly presented problems in which a temporal graph is provided somehow (either in an offline or an online way) and the goal is to solve a problem on that graph. Another possibility is when one wants to \emph{design} a desired temporal graph. In most cases, such a temporal graph cannot be arbitrary, but it has to satisfy some properties prescribed by the underlying application. This design problem was introduced and studied in \cite{MMCS13} (and its full version \cite{MMS15}). An abstract definition of the problem is that we are given an underlying (di)graph  and we are asked to assign labels to the edges of  so that the resulting temporal graph  minimizes some parameter while satisfying some connectivity property. The parameters studied in \cite{MMCS13} were the maximum number of labels of an edge, called the \emph{temporality}, and the total number of labels, called the \emph{temporal cost}. The connectivity properties of \cite{MMCS13} had to do with the preservation of a subset of the paths of  in time-respecting versions. For example, we might want to preserve all reachabilities between nodes defined by , in the sense that for every pair of nodes  such that there is a path from  to  in  there must be a temporal path from  to  in . Another such property is to guarantee in  time-respecting versions of all possible paths of . All these can be thought of as trying to \emph{preserve} a connectivity property of a static graph in the temporal dimension while trying to minimize some cost measure of the resulting temporal graph. 

The provided graph  represents some given static specifications, for example the available roads between a set of cities or the available routes of buses in the city center. In scheduling problems it is very common to have such a static specification and to want to organize a temporal schedule on it, for example to specify the precise time at which a bus should pass from a particular bus stop while guaranteeing that every possible pair of stops are connected by a route. Furthermore, it is very common that any such solution should at the same time take into account some notion of cost. Minimizing cost parameters may be crucial as, in most real networks, making a connection available and maintaining its availability does not come for free. For example, in wireless sensor networks the cost of making edges available is directly related to the power consumption of keeping nodes awake, of broadcasting, of listening the wireless channel, and of resolving the resulting communication collisions. The same holds for transportation networks where the goal is to achieve good connectivity properties with as few transportation units as possible.

For an example, imagine that we are given a directed ring  and we want to assign labels to its edges so that the resulting temporal graph has a journey for every simple path of the ring and at the same time minimizes the maximum number of labels of an edge. In more technical terms, we want to determine or bound the \emph{temporality} of the ring subject to the \emph{all paths} property. It is worth mentioning that the temporality (and the temporal cost) is defined as the \emph{minimum} possible achievable value that satisfies the property, as, for example, is also the case for the chromatic number of a graph, which is defined as the minimum number of colors that can properly color a graph. Looking at Figure~\ref{fig:ring}, it is immediate to observe that an increasing sequence of labels on the edges of path  implies a decreasing pair of labels on edges  and . On the other hand, path  uses first  and then  thus it requires an increasing pair of labels on these edges. It follows that in order to preserve both  and  we have to use a second label on at least one of these two edges, thus the temporality is at least 2. Next, consider the labeling that assigns to each edge  the labels , where  and . It is not hard to see that this labeling preserves all simple paths of the ring. Since the maximum number of labels that it assigns to an edge is 2, we conclude that the temporality is also at most 2. Taking both bounds into account, we may conclude that the temporality of preserving all simple paths of a directed ring is 2. Moreover, it holds that the temporality of graph  is lower bounded by the maximum temporality of its subgraphs, because if a labeling preserves all paths of  then it has to preserve all paths of any subgraph of , paying every time the temporality of the subgraph. So, for example, if the input graph  contains a directed ring then the temporality of  must be at least  (and could be higher depending on the structure of the rest of the graph).   

\begin{figure}[!hbtp]
\centering{
\includegraphics[width=0.4\textwidth]{ring.pdf}
}
\caption{Path  forces a second label to appear on either  or .} \label{fig:ring}
\end{figure}

Rings have very small temporality w.r.t. the all paths property, however there is a large family of graphs with even smaller. This is the family of directed acyclic graphs (DAGs). DAGs have the very convenient property that they can be topologically sorted. In fact, DAGs are the only digraphs that satisfy this property. A \emph{topological sort} of a digraph  is a linear ordering of its nodes such that if  contains an edge  then  appears before  in the ordering. So, we can order the nodes from left to right and have all edges pointing to the right.  Now, we can assign to the nodes the indices  in ascending order from left to right and then assign to each edge the label of its tail, as shown in Figure \ref{fig:dag}. In this way, every edge obtains exactly one label and every path of  has been converted to a journey, because every path moves from left to right thus always moves to greater node indices. As these indices are also the labels of the corresponding edges, the path has strictly increasing labels which makes it a journey. This, together with the fact that the temporality is at least 1 in all graphs with non-empty edge sets, shows that the temporality of any DAG w.r.t. the all paths property is .

\begin{figure}[!hbtp]
   \centering{
        \includegraphics[width=0.8\textwidth]{dag.pdf}
        }
   \caption{A topological sort of a DAG. Edges are labeled by the indices of their tails (which are strictly increasing from left to right) and this labeling converts every possible path of the dag to a journey. For example,  is a journey because its labels  are strictly increasing.} \label{fig:dag}
\end{figure}

In both of the above examples, all paths could be preserved by using very few labels per edge. One may immediately wonder whether converting all paths to journeys can always be achieved with few labels per edge, e.g. a constant number of labels. However, a more careful look at the previous examples may provide a first indication that this is not the case. In particular, the ring example suggests that cycles can cause an increase of temporality, compared to graphs without cycles, like DAGs. Of course, a single ring only provides a very elementary exposition of this phenomenon, however as proved in \cite{MMCS13}, this core observation can be extended to give a quite general method for lower bounding the temporality. The idea is to identify a subset of the edges of  such that, for every possible permutation of these edges,  has a path following the direction of the permutation. Such subsets of edges, with many interleaved cycles, are called \emph{edge-kernels} (see Figure \ref{fig:edge-kernel} for an example) and it can be proved that the preservation of all paths of an edge-kernel on  edges yields a temporality of at least . To see this, consider an edge-kernel  and order increasingly the labels of each edge. Now take an edge with maximum first label, move from it to an edge of maximum second label between the remaining edges, then move from this to an edge of maximum third label between the remaining edges, and so on. All these moves can be performed because  is an edge-kernel, thus there is a path no matter which permutation of the edges we choose. As in step  we are on the edge  with maximum -th label, we cannot use the 1st, 2nd, , -th labels of the next edge to continue the journey because none of these can be greater than the -th label of . So, we must necessarily use the -th label of the next edge, which by induction shows that in order to go through the -th edge in this particular permutation we need to use a th label on that edge.

\begin{figure}[!hbtp]
\centering{
\includegraphics[width=0.9\textwidth]{edge-kernel.pdf}
}
\caption{The graph consists of the solid and dashed edges. The long curves highlight some of the paths that the graph defines. Edges , , and  constitute an edge-kernel of the graph, because for every possible permutation of these edges the graph has a directed path (one of those highlighted in the figure) that traverses the edges in the order defined by the permutation. As a result, at least 3 labels must be assigned on an edge in order to preserve a temporal analogue of every possible path.} \label{fig:edge-kernel}
\end{figure}

Also, as stated above, the temporality of a graph w.r.t to the all paths property is always lower bounded by the temporality of any of its subgraphs. As a consequence, we can obtain a lower bound on the temporality of a graph or of a whole graph family by identifying a large edge-kernel in it. For a simple application of this method, it is possible to show that in order to preserve all paths of a complete digraph, at least  labels are required on some edge. This is done by showing that complete digraphs have an edge-kernel of size . Moreover, it is possible to construct a planar graph containing an edge-kernel of size , which yields that there exist planar graphs with temporality at least . It is worth noting that the absence of a large edge-kernel does not necessarily imply small temporality. In fact, it is an interesting open problem whether there are other structural properties of the underlying graph that could cause a growth of the temporality.

The above show that preserving all paths in time can be very costly in several cases. On the other hand, preserving  only the reachabilities can always be achieved inexpensively. In particular, it can be proved that for every strongly connected digraph , we can preserve a journey from  to  for every  for which there exists a path from  to  in , by using at most two labels per edge \cite{MMCS13}. Recall the crucial difference: now it suffices to preserve \emph{a single path} from all possible paths that go from  to . The result is proved by picking any node  and considering an in-tree rooted at . We then label the edges of each level , counting from the leaves, with label , so that all paths of the tree become time-respecting (this also follows from the fact that the tree is a DAG so, as we discussed previously, all of its paths can be preserved with a single label per edge). Next we consider an out-tree rooted at  and we label that tree inversely, i.e. from the root to the leaves, and beginning with the label . The first tree has a journey from every node to  arriving by time  and the second tree has a journey from  to every other node beginning at time . This shows that there is a journey from every node to every other node. Moreover, this was achieved by using at most two labels per edge because every edge of the in-tree has a single label and every edge of the out-tree has a single label and an edge is in the worst case used by both trees, in which case it is assigned two labels. Furthermore, it can be proved that the temporality w.r.t. reachabilities of any digraph  is upper bounded by the maximum temporality of its strongly connected components. But we just saw that each component needs at most two labels, thus it follows that two labels per edge are sufficient for preserving all reachabilities of \emph{any} digraph . 

Finally, we should mention an interesting relation between the temporality and the age of a temporal graph. In particular, restricting the maximum label that the labeling is allowed to use makes the temporality grow. For an intuition why this happens, consider the case in which there are many maximum length shortest paths between different pairs of nodes that all must be necessarily be preserved in order to preserve the reachabilities. Now if it happens that all of them pass through the same edge  but use  at many different times, then  must necessarily have many different labels, one for each of these paths. A simple example to further appreciate this is given in Figure \ref{fig:diam}. In that figure, each - path is a unique shortest path between  and  and has additionally length equal to the diameter (i.e. it is also a maximum one), so we must necessarily preserve all 5 - paths. Note now that each - path passes through  via its -th edge. Each of these paths can only be preserved without violating  by assigning the labels , however note that then edge  must necessarily have all labels . To see this, notice simply that if any label  is missing from  then there is some maximum shortest path that goes through  at step . As  is missing it cannot arrive sooner than time  which violates the preservation of the diameter. Additionally, the following trade-off for the particular case of a ring can be proved \cite{MMCS13}: If  is a directed ring and the age is , then the temporality of preserving all paths is , when , and , when . 

\begin{figure}[!hbtp]
\centering{
\includegraphics[width=0.8\textwidth]{diameter.pdf}
}
\caption{In this example, restricting the maximum label to be at most equal to the diameter  forces the temporality to be at least .} \label{fig:diam}
\end{figure}

\section{Temporal Versions of Other Standard Graph Problems: Complexity and Solutions}
\label{sec:matching}

Though it is not yet clear how is the complexity of combinatorial optimization problems affected by introducing to them a notion of time, still there is evidence that complexity increases significantly and that totally novel solutions have to be developed in several cases. In an early but serious attempt to answer the above question, Orlin \cite{Or81} observed that many dynamic languages derived from -complete languages can be shown to be -complete. This increase in complexity has been also reported in \cite{BF03,XFJ03}. For example, \cite{BF03} studied the computation of multicast trees minimizing the overall transmission time and to this end proved that it is -complete to compute strongly connected components in temporal graphs. Important evidence to this direction comes also from the rich literature on labeled graphs, a more general model than temporal graphs, with different motivation, and usually interested in different problems than those resulting when the labels are explicitly regarded as time moments. Several papers in this direction have considered labeled versions of polynomial-time solvable problems, in which the goal is to minimize/maximize the number of labels used by a solution. For example, the first labeled problem introduced in the literature was the {\sc Labeled Minimum Spanning Tree} problem, which has several applications in communication network design. This problem is -hard and many complexity and approximability results have been proposed (see e.g. \cite{BL97,KW98}). On the other hand, the {\sc Labeled Maximum Spanning Tree} problem has been shown polynomial in \cite{BL97}. In \cite{BLWZ05}, the authors proved that the {\sc Labeled Minimum Path} problem is -hard and provided some exact and approximation algorithms. In \cite{Mo05}, it was proved that the {\sc Labeled Perfect Matching} problem in bipartite graphs is -complete (see also \cite{TIR78} for a related problem). 

A primary example of this phenomenon, of significant increase in complexity when extending a combinatorial optimization problem in time, is the fundamental {\sc Maximum Matching} problem. In its static version, we are given a graph  and we must compute a maximum cardinality set of edges such that no two of them share an endpoint. {\sc Maximum Matching} can be solved in polynomial time by the famous Edmonds' algorithm \cite{Ed65} (the time is  by the algorithm of \cite{MV80}). Now consider the following temporal version of the problem, called {\sc Temporal Matching} in \cite{MS14}. In this problem, we are given a temporal graph  and we are asked to decide whether there is a maximum matching  of the underlying static graph of  that can be made temporal by selecting a single label  for every edge . For a single-labeled matching to be temporal it suffices to guarantee that no two of its edges have the same label. {\sc Temporal Matching} was proved in \cite{MS14} to be -complete. Then the problem of computing a maximum cardinality temporal matching is immediately -hard, because if we could compute such a maximum temporal matching in polynomial time, we could then compare its cardinality to the cardinality of a maximum static matching and decide {\sc Temporal Matching} in polynomial time. -completeness of {\sc Temporal Matching} can be proved by the sequence of polynomial-time reductions: {\sc Balanced 3SAT}  {\sc Balanced Union Labeled Matching}  {\sc Temporal Matching}. In {\sc Balanced 3SAT}, which is known to be -complete, every variable  appears  times negated and  times non-negated and in {\sc Balanced Union Labeled Matching} we are given a bipartite graph , labels , and a labeling , every node  has precisely two neighbors , and additionally both edges of  have the same number of labels, and we must decide whether there is a maximum matching  of  s.t.  \cite{MS14}.

Another interesting problem is the {\sc Temporal Exploration} problem \cite{MS14}. In this problem, we are given a temporal graph and the goal is to visit all nodes of the temporal graph by a temporal walk, that possibly revisits nodes, minimizing the arrival time. The version of this problem for static graphs is well-known as {\sc Graphic TSP}. Though, in the static case, the decision version of the problem, asking whether a given graph is explorable, can be solved in linear time, in the temporal case it becomes -complete. Additionally, in the static case, there is a -approximation for undirected graphs \cite{GSS11} and a  for directed \cite{AGMGS10}. 

In contrast to these, it was proved in \cite{MS14} that there exists some constant  such that {\sc Temporal Exploration} cannot be approximated within  unless , by presenting a gap introducing reduction from {\sc Hampath}. Additionally, it was proved that even the special case in which every instance of the temporal graph is connected, cannot be approximated within , for every constant , unless . The reduction is from {\sc Hampath} (input graph , source ). The constructed temporal graph  consists of three strongly connected static graphs , , and  persisting for the intervals , , and , respectively (it will be helpful at this point to look at Figure \ref{fig:oneint}). We can restrict attention to instances of {\sc Hampath} of order at least , without affecting its -completeness. We also set  (in fact, we can set  equal to any polynomial-time computable function of ). If  is hamiltonian, then for the arrival time, , of an optimum exploration it holds that  while if  is not hamiltonian, then     , which can be shown to introduce the desired  gap. This negative result has been recently improved by Erlebach \emph{et al.} \cite{EHK15} to  for any . In the same work, an explicit construction of continuously connected temporal graphs that require  steps to be explored was also given. 

\begin{figure}[!hbtp]
   \centering{
        \subfigure[]{
        \includegraphics[width=0.8\textwidth]{ac-texp-hard-appr1.pdf}
        \label{fig:oneint1}}
	\hspace{1cm}
        \subfigure[]{
        \includegraphics[width=0.8\textwidth]{ac-texp-hard-appr2.pdf}
        \label{fig:oneint2}}
	\hspace{1cm}
        \subfigure[]{
        \includegraphics[width=0.8\textwidth]{ac-texp-hard-appr3.pdf}
        \label{fig:oneint3}}
        }
   \caption{The temporal graph constructed by the reduction. (a)  (b)  (c) } \label{fig:oneint}
\end{figure}

On the positive side, it is not hard to show that in continuously connected temporal graphs, {\sc Temporal Exploration} can be approximated within the temporal diameter of the temporal graph \cite{MS14}. In \cite{EHK15}, the authors additionally studied the {\sc Temporal Exploration} problem in other interesting restricted families of temporal graphs, like temporal graphs in which the underlying graph has treewidth  (a work explicitly concerned with the treewidth of temporal graphs and its relation to the treewidth of static graphs is \cite{MM13}), is a  grid, a cycle, a cycle with a chord, or a bounded-degree planar graph, for which they provided upper bounds on exploration time. See also \cite{FMS09} for another study of the exploration problem in temporal graphs with periodic edge-availabilities, from a distributed computing perspective.

Another demanding problem that becomes even more challenging in its temporal version is the famous {\sc Traveling Salesman Problem}, in which a graph with non-negative costs on its edge is provided and the goal is to find a tour visiting every node exactly once (called a \emph{TSP tour}), of minimum total cost. In one version of the problem, introduced in \cite{MS14}, the digraph remains static and complete throughout its lifetime but now each edge is assigned a cost that may change from instance to instance. So, the dynamicity has now been transferred from the topology to the costs of the edges. The goal is to find (by an offline centralized algorithm) a \emph{temporal TSP tour} of minimum total cost, where the cost of a tour is the sum of the costs of the time-edges that it traverses. The authors of \cite{MS14} introduced and studied the special case of this problem in which the costs are chosen from the set . In particular, there is a cost function  assigning a cost to every time-edge of the temporal graph (see Figure \ref{fig:tsp-example} for an illustration). This is called the {\sc Temporal Traveling Salesman Problem with Costs One and Two} and abbreviated TTSP(1,2). Now observe that the famous (static) ATSP(1,2) problem is a special case of TTSP(1,2) when the lifetime of the temporal graph  is restricted to  and  for all edges  and times . This immediately implies that TTSP(1,2) is also -hard \cite{PY93} and cannot be approximated within any factor less than  \cite{KS13} and the same holds for the interesting special case of TTSP(1,2) with lifetime restricted to , that we will also discuss.

In the static case, one easily obtains a -factor approximation for ATSP(1,2) by computing a perfect matching maximizing the number of ones and then patching the edges together arbitrarily. This works well, because such a minimum cost perfect matching can be computed in polynomial time in the static case by Edmonds' algorithm \cite{Ed65} and its cost is at most half the cost of an optimum TSP tour, as the latter consists of two perfect matchings. The  factor follows because the remaining  edges that are added during the patching process cost at most , which, in turn, is another lower bound to the cost of the optimum TSP tour. This was one of the first algorithms known for ATSP(1,2). Other approaches have improved the factor to the best currently known  \cite{Bl04}. Unfortunately, as we already discussed in the beginning of this section, even the apparently simple task of computing a matching maximizing the number of ones is not that easy in temporal graphs. A simple modification of those arguments yields that the problem remains -hard if we require consecutive labels (in an increasing ordering) of the matching to have a time difference of at least two. Such time-gaps are necessary for constructing a time-respecting patching of the edges of the matching. In particular, if two consecutive edges of the matching had a smaller time difference, then the patching-edge would share time with at least one of them and the resulting tour would not have strictly increasing labels.

\begin{figure}[!hbtp]
\centering{
\includegraphics[width=0.75\textwidth]{tsp-example.pdf}
}
\caption{An instance of TTSP(1,2) consisting of a complete temporal graph , where , and a cost function  which is presented by the corresponding costs on the edges. For simplicity,  is an undirected temporal graph. Observe that the cost of an edge may change many times, e.g. the cost of  changes 5 times while of  changes only once. Here, the lifetime of the temporal graph is 6 and it is greater than . The gray arcs and the nodes filled gray (meaning that the tour does not make a move and remains on the same node for that step) represent the TTSP tour  that has cost  and therefore it is an optimum TTSP tour.} \label{fig:tsp-example}
\end{figure}

Our inability to compute a temporal matching in polynomial time, still does not exclude the possibility to find good approximations for it and then hope to be able to use them for obtaining good approximations for TTSP(1,2). Two main approaches were followed in \cite{MS14}. One was to reduce the problem to {\sc Maximum Independent Set} ({\sc MIS}) in -claw free graphs and the other was to reduce it to {\sc -Set Packing}, for some  and  to be determined. The first approach gives a -approximation () for the generic TTSP(1,2) and a -approximation () for the special case of TTSP(1,2) in which the lifetime is restricted to  (the latter is obtained by approximating a temporal path packing instead of a matching). The second approach improves these to  for the general case and to  when the lifetime is . In all the above cases,  is a small constant (not necessarily the same in all cases) adopted from the factors of the approximation algorithms for independent set and set packing.

We summarize now how the first of these approximations works. Consider the static expansion  of  and an edge . There are three types of conflicts, each defining a set of edges that cannot be taken together with  in a temporal matching (with only unit time differences): (i) Edges of the same row as , because these violate the unit time difference constraint (ii) edges of the same column as , because these share a node with , thus violate the condition of constructing a matching, and (iii) edges of the same column as , for the same reason as (ii). Next consider the graph of edge conflicts , where  iff  and  satisfy some of the above constraints (observe that the node set of  is equal to the edge set of the static expansion ). Observe that temporal matchings of  are now equivalent to independent sets of . Moreover,  is -claw free meaning that there is no 4-independent set in the neighborhood of any node. To see that it is -claw free, take any  and any set  of four neighbors of  in . There are only 3 constraints thus at least two of the neighbors, say  and , must be connected to  by the same constraint. But then  and  must also satisfy the same constraint with each other thus they are also connected by an edge in . Now, from \cite{Ha95}, there is a factor of  for {\sc MIS} in -claw free graphs, which implies a -approximation algorithm for temporal matchings. Simple modifications of the above arguments yield a -approximation algorithm for temporal matchings with time-differences at least two. Additionally, it can be proved that a -factor approximation for the latter problem implies a -factor approximation for TTSP(1,2). All these together, yield a -approximation algorithm for TTSP \cite{MS14}. 

An immediate question, which is currently open, is whether there is a -factor approximation algorithm either for the general TTSP(1,2) or for its special case with lifetime restricted to  (the reader may have observed that in the temporal case we have not yet achieved even the simplest factor of the static case).

\section{Linear Availabilities}
\label{sec:linear}

An interesting family of temporal graphs consists of those temporal graphs whose availability times are provided by some succinct representation. This could for example be a function, which we discuss here, or a probability distribution, which we discuss in the next section.

Such an example of a temporal graph in which a set of functions describes the availability times of the edges is the following (for other studies on periodically varying temporal graphs the reader is encouraged to consult \cite{Or81,FMS09,CFQS12} and references therein). The underlying graph is a complete static graph . Each  has an associated linear function of the form , where . For example, if an edge  has , then it is available at times . Clearly, the temporal graph that we obtain in this manner is  where  for some . If we are additionally provided with a lifetime  of the temporal graph then we just restrict  to .

The above provides an immediate way for obtaining the th instance for any . For every , the th instance contains edge  iff  is integer. It is important to note that, in the above family of temporal graphs, algorithmic solutions that depend at least linearly on the lifetime  are not acceptable. The reason is that the lifetime  is provided in binary so a linear dependence on  grows exponentially in the binary representation of . Foremost journeys in such graphs can be easily computed by a variation of the algorithm discussed in Section \ref{subsec:journeys}.

Now consider the following problem. We are given two edges  and  with corresponding functions  and  and we are asked to determine whether there is some instance having both edges, that is, to determine whether there exist  and  s.t.   . So, in fact, we are seeking for a  s.t.  (where `' reads as ``divides'') and we have reduced our problem to the problem of determining whether  for some . Now imagine a right oriented ring of  nodes numbered . Consider a process beginning from node  and making clockwise jumps of length  in each round (where a round corresponds to an increment of  by 1). We have that the process falls at some point on node  iff  for some . Viewed in this way, our problem is equivalent to checking whether  is solvable for the unknown . This, in turn, may easily take the form  (given that ) for  and  (equalities to 0 correspond to trivial cases of our original problem). Clearly, we have reduced our problem to the problem of detecting whether a modular linear equation admits a solution which is well-known to be solvable in polynomial time. In particular, a modular linear equation  has a solution iff  (see e.g. \cite{CLRS01}, Corollary 31.21, page 869). Additionally, by solving the equation we can find all solutions modulo  in  arithmetic operations (see e.g. \cite{CLRS01}, page 871).

Note that in the case where  then the answer to the problem is always ``yes'' as  trivially holds for  and  (provided that  does not exceed the lifetime of the network if a lifetime is specified). In particular, if we are asked to determine the foremost instance containing both edges then this reduces to the computation of  (where  is the least common multiple) which in turn reduces to the computation of  by the equation . 

Now let us slightly simplify our model in order to obtain a solution to a more generic version of the above problem. We restrict the edge functions  so that , e.g. . Then clearly, each such function corresponds to the whole equivalence subclass of  modulo  containing , that is, . So, for example,  corresponds to  in contrast to  that was allowed before and would just give the subset  of the actual class. Consider now the following problem: ``We are given a subset  of the edge set  and we want to determine whether there is some instance of the temporal graph containing all edges in ''. For simplicity, number the edges in  from 1 to . Formally, we want to determine the existence of some time  s.t., for all , there exists  s.t. , or equivalently, . Clearly, we have arrived at a set of simultaneous linear congruences and we can now apply the following known results.

\begin{theorem} [see e.g. \cite{BS96}, Theorem 5.5.5, pg 106] \label{the:bs1}
The system of congruences , , has a solution iff  for all . If the solution exists, it is unique modulo .
\end{theorem}

\begin{corollary} [see e.g. \cite{BS96}, Corollary 5.5.6, pg 106]
Let  be integers, each , and define , and . Given the system  of congruences , , we can determine if  has a solution, using  bit operations, and if so, we can find the unique solution modulo , using  bit operations.
\end{corollary}

We may now return to the original formulation of our model in which  does not necessarily satisfy . First keep in mind that  is the minimum time for every edge from  to appear at least once (in fact, at that time, the last edge of  appears). So we cannot hope to have them all in one instance sooner than this. Now notice that  is equivalent to  for ; for example,  is equivalent to  for . In this manner, we obtain an equivalent setting in which again  for all  but additionally for every  we have a constraint on  of the form . We may now ignore the constraints and apply Theorem \ref{the:bs1} to determine whether there is a solution to the new set of congruences as there is a solution that satisfies the constraints iff there is one if we ignore the constraints (the reason being that the constraints together form a finite lower bound while there is an infinite number of solutions). If there is a solution it will be a unique solution modulo  corresponding to an infinite number of solutions if expanded. From these solutions we just have to keep those that are not less than  (in case we want to find the actual solutions to the system). 

\section{Random Temporal Graphs}
\label{sec:random}

Another model of temporal graphs with succinct representation, is the model of random temporal graphs. Consider the case in which each edge (of an underlying clique) just picks independently and uniformly at random \emph{a single time-label} from . So it gets label  with probability .

We first calculate the probability that given a specific path  of length  a journey appears on this path. We begin with the directed case. First, let us obtain a weak but elegant upper bound. Partition  into  and . Clearly,  as any journey assignment cannot have two consecutive selections s.t. the first one is from  and the second from . So, it suffices to calculate . Notice that the assignments in which no  occurs are of the form  for , e.g.  and there are  of them. In contrast, all possible assignments are  corresponding to all possible ways to choose  times with repetition from . So,  (as all assignments are equiprobable, with probability ) and we conclude that , which, interestingly, is independent of ; e.g. for  we get a probability of at most  for a journey of length  to appear.

For any specific assignment of labels  of this path, where  (), the probability that this specific assignment occurs is simply . So, all possible assignments are equiprobable and we get
  
where  follows from the fact that any strictly increasing assignment is just a unique selection of  labels from the  available and any such selection corresponds to a unique strictly increasing assignment. So, for example, for  and  we get a probability of  which is a little smaller than  as expected, due to the fact that there is an equal number of strictly increasing and strictly decreasing assignments but we also loose all remaining assignments which in this case are only the ties (that is, those for which ).

Now it is easy to compute the expected number of journeys of length . Let  be the set of all directed paths of length  and let  be an indicator random variable which is 1 if a journey appears on a specific  and 0 otherwise. Let also  be a random variable giving the number of journeys of length . Clearly, a journey appears on a specific path of length . Now, if we set , we get . A simpler, but weaker, formula can be obtained by requiring . In this case, we get . So, for example, a long journey of size  that uses all available labels is expected to appear provided that  (to see this, simply set ).

We will now try to obtain bounds on the probability that a journey of length  appears on a random temporal graph. Let us begin from a simple case, namely the one in which , that is, we want to calculate the probability that a journey of length 4 appears. Let the r.v.  be the number of journeys of length 4 and let  be an indicator for path , where  is the set of all paths of length 4. Denote  by  First note that  and clearly goes to  for every . However, we cannot yet conclude that  is also large. To show this we shall apply the second moment method. We will make use of Chebyshev's inequality  and of the following well-known theorem:

\begin{theorem} \label{the:secmom}
Suppose , where  is an indicator for event . Then,

where  denotes that  depends on . Moreover, if  for all , then

\end{theorem}

So, in our case, we need to estimate . If we show that  for all  then we will have that . If we additionally manage to show that , then  which tells us that . Putting this back to Chebyshev's inequality we get that  as needed. 

So, let us try to bound  appropriately. Clearly,  cannot be a journey if it visits some edges of  in inverse order (than the one they have on ). Intuitively, the two paths must have the same orientation. We distinguish cases based on the number of edges shared by the two paths. First of all, note that if  and  have precisely  edges in common then  which becomes  in our case. The reason is that the  edges of  that are not shared with  must at least obtain an increasing labeling. If we also had taken into account that that labeling should be consistent to the labels of the shared edges then this would decrease the probability. So we just use an upper bound which is sufficient for our purposes. 

\emph{Case 1: 1 shared edge.} If a single edge is shared then there are  different paths  achieving this as there are  ways to choose the shared edge,  to choose the missing nodes (nodes of  not shared with ),  ways to order those nodes, and, in this particular example, 4 ways to arrange the nodes w.r.t. the shared edge. In particular, we can put all nodes before the shared edge, all nodes after, 2 nodes before and 1 node after, or 1 node before and 2 nodes after. We conclude that the probability that .

\emph{Case 2: 2 shared edges.} In this case, we can have all possible  2-sharings. Let us denote by  the edges of . For the sharings , , and  we get in total  paths. For ,  we get . For  we get  in case we connect the 2 edges by an intermediate node (i.e. go from the head of  to some  not in  and then form  to the tail of ) and  in case we connect  directly to  and use an external node either before or after, so in total  paths. Putting these all together we get .

\emph{Case 3: 3 shared edges.} Here there are just 2 choices for the 3 shared edges, namely  and , the reason being that if the edges are not consecutive then a fourth edge must be necessarily shared and the 2 paths would coincide. As there are  ways to choose the missing node and 2 ways to arrange that node we get  and consequently .

So, we have  and  which applied to Theorem \ref{the:secmom} gives  and this in turn applied to Chebyshev's inequality gives the desired . We conclude that:

\begin{theorem}
For all , almost all random temporal graphs contain a journey of length 4.
\end{theorem}

Now let us turn back to our initial  formula of  (which holds for all ). This gives , which, for all  and all , goes to  as  grows. We will now try to generalize the ideas developed in the  case to show that for any not too large  almost all random temporal graphs contain a journey of length . Take again a path  of length  and another path  of length  that shares  edges with . We will count rather crudely but in a sufficient way for our purposes. As again the shared edges can be uniquely oriented in the order they appear on , there are at most  ways to choose the shared edges (at most because some selections force more than  sharings to occur). Counting the tail of the first edge and the head of every edge, these  edges occupy at least  nodes, so at most  nodes are missing from  and thus there are at most  ways to choose those nodes. Moreover there are at most  ways to permute them on . Finally, we have to place those nodes relative to the  shared edges. In the worst case, the  edges define  slots that can be occupied by the nodes in  ways. In total, we have  different paths and the corresponding probability is 

So we have that

The first equality follows from the Chu-Vandermonde identity  by setting  and  as needed in our case.

Thus, we have  and for  we have . At the same time we have  (for large ), thus  as needed. So we have  and we again get that . Captured in a theorem:

\begin{theorem}
For all  and all , almost all random temporal graphs contain a journey of length .
\end{theorem}
However, there seems to be some room for improvements if one counts more carefully.

Now take any two nodes  and  in . We want to estimate the arrival time of a foremost journey from  to . Let  be the random variable of the arrival time of the foremost - journey. Let us focus on . Denote by  the label chosen by edge . Given a specific node  we have that . Thus,   We have:


So, even if  we have that  (for some constant ) as  goes to infinity, so we have a constant probability of arriving by time 2 at . Clearly, for smaller values of  (smaller w.r.t. ) we get even better chances of arriving early. For another example, let  and . As  is almost equal to  we get that it is almost equal to 1 in this particular case. For even greater , e.g. , we still go very close to 1.

The following proposition gives a bound on the temporal diameter of undirected random temporal graphs, by exploiting well known results of the Erd\" os-Renyi () model (cf. \cite{Bol01}).

\begin{proposition}
Almost no temporal graph has temporal diameter less than .
\end{proposition}

To see this, observe that if  then . Consider now the temporal subgraph consisting only of the first  labels . By the connectivity threshold of the static  model this subgraph is almost surely disconnected implying that almost surely the temporal diameter is greater than .

So, for example, if  almost no temporal graph has temporal diameter . Note, however, that the above argument is not sufficient to show that a.e. temporal graph has temporal diameter at least . Though it shows that in a.e. graph the subgraph consisting of the labels , for  is connected, it does not tell us whether that connectivity also implies temporal connectivity (that is, the existence of journeys).

We should also mention that \cite{AGMS14} studied the temporal diameter of the directed random temporal graph model for the case of , and proved that it is  w. and in expectation. In fact, they showed that information dissemination is very fast w.h.p. even in this hostile network with regard to availability. Moreover, they showed that the temporal diameter of the clique is crucially affected by the clique's lifetime, , e.g., when  is asymptotically larger than the number of vertices, , then the temporal diameter must be . They also defined the \emph{Price of Randomness} metric in order to capture the cost to pay per link and guarantee temporal reachability of all node-pairs by local random available times w.h.p..

The idea of \cite{AGMS14} to establish that the temporal diameter is  is as follows. Given an instance of such a random temporal clique, the authors pick any source node  and any sink node  and present an algorithm trying to construct a journey from  arriving at  at most by time . The algorithm expands two fronts, one beginning from  and moving forward (in fact, an out-tree rooted at ) and one from  moving backward (an in-tree rooted at ). Beginning from , all neighbors that can be reached in one step in the interval , are visited. Next the front moves on to all neighbors of the previous front that can be reached in one step in the interval . The process continues in the same way, every time replacing the current front by all its neighbors that can be reached in the next  steps. A similar backward process is executed from . These processes are executed for  steps resulting in the final front of  and the final front of . Note that the front of  begins from the interval  and every time subtracts a . Finally, the algorithm tries to find an edge from the final front of  to the final front of  with the appropriate label in order to connect the journey from  to the journey to  in a time-respecting way and obtain the desired - journey of duration  (determined by the interval of the first front of , and in particular by ). Via probabilistic analysis it can be proved that, with probability at least , the final front of  consists of  nodes and that the same holds for the front of . Moreover, it can be proved that again with probability at least  the desired edge for the final front of  to the final front of  exists, and thus we can conclude that there is a probability of at least  of getting from  to  by a journey arriving at most by time . Finally, it suffices to observe that the probability that there exists a pair of nodes  for which the algorithm fails is less than , thus with probability at least  the temporal diameter is , as required.

\newcommand{\etalchar}[1]{}
\begin{thebibliography}{CMM{\etalchar{+}}08}

\bibitem[AAD{\etalchar{+}}06]{AADFP06}
D.~Angluin, J.~Aspnes, Z.~Diamadi, M.~J. Fischer, and R.~Peralta.
\newblock Computation in networks of passively mobile finite-state sensors.
\newblock {\em Distributed Computing}, pages 235--253, March 2006.

\bibitem[AGM{\etalchar{+}}10]{AGMGS10}
A.~Asadpour, M.~X. Goemans, A.~Madry, S.~O. Gharan, and A.~Saberi.
\newblock An {}-approximation algorithm for the
  asymmetric traveling salesman problem.
\newblock In {\em Proceedings of the Twenty-First Annual ACM-SIAM Symposium on
  Discrete Algorithms (SODA)}, pages 379--389, Philadelphia, PA, USA, 2010.
  Society for Industrial and Applied Mathematics.

\bibitem[AGMS14]{AGMS14}
E.~C. Akrida, L.~Gasieniec, G.~B. Mertzios, and P.~G. Spirakis.
\newblock Ephemeral networks with random availability of links: Diameter and
  connectivity.
\newblock In {\em Proceedings of the 26th ACM symposium on Parallelism in
  algorithms and architectures (SPAA)}, pages 267--276. ACM, 2014.

\bibitem[AKL08]{AKL08}
C.~Avin, M.~Kouck\'{y}, and Z.~Lotker.
\newblock How to explore a fast-changing world (cover time of a simple random
  walk on evolving graphs).
\newblock In {\em Proceedings of the 35th international colloquium on Automata,
  Languages and Programming (ICALP), Part I}, pages 121--132. Springer-Verlag,
  2008.

\bibitem[AKM14]{AKM14}
E.~Aaron, D.~Krizanc, and E.~Meyerson.
\newblock {DMVP}: foremost waypoint coverage of time-varying graphs.
\newblock In {\em Graph-Theoretic Concepts in Computer Science}, pages 29--41.
  Springer, 2014.

\bibitem[APRU12]{APRU12}
J.~Augustine, G.~Pandurangan, P.~Robinson, and E.~Upfal.
\newblock Towards robust and efficient computation in dynamic peer-to-peer
  networks.
\newblock In {\em Proceedings of the Twenty-Third Annual ACM-SIAM Symposium on
  Discrete Algorithms (SODA)}, pages 551--569. SIAM, 2012.

\bibitem[Ber96]{Be96}
K.~A. Berman.
\newblock Vulnerability of scheduled networks and a generalization of
  {M}enger's theorem.
\newblock {\em Networks}, 28[3]:125--134, 1996.

\bibitem[BF03]{BF03}
S.~Bhadra and A.~Ferreira.
\newblock Complexity of connected components in evolving graphs and the
  computation of multicast trees in dynamic networks.
\newblock In S.~Pierre, M.~Barbeau, and E.~Kranakis, editors, {\em Ad-Hoc,
  Mobile, and Wireless Networks}, volume 2865 of {\em Lecture Notes in Computer
  Science}, pages 259--270. Springer Berlin Heidelberg, 2003.

\bibitem[BL97]{BL97}
H.~Broersma and X.~Li.
\newblock Spanning trees with many or few colors in edge-colored graphs.
\newblock {\em Discussiones Mathematicae Graph Theory}, 17[2]:259--269, 1997.

\bibitem[Bl{\"a}04]{Bl04}
M.~Bl{\"a}ser.
\newblock A 3/4-approximation algorithm for maximum atsp with weights zero and
  one.
\newblock In {\em Approximation, Randomization, and Combinatorial Optimization.
  Algorithms and Techniques}, pages 61--71. Springer, 2004.

\bibitem[BLWZ05]{BLWZ05}
H.~Broersma, X.~Li, G.~Woeginger, and S.~Zhang.
\newblock Paths and cycles in colored graphs.
\newblock {\em Australasian Journal on Combinatorics}, 31:299--311, 2005.

\bibitem[Bol98]{Bo98}
B.~Bollob{\'a}s.
\newblock {\em Modern Graph Theory}.
\newblock Graduate Texts in Mathematics. Springer; Corrected edition (July 1,
  1998), 1998.

\bibitem[Bol01]{Bol01}
B.~Bollob{\'a}s.
\newblock {\em Random graphs}.
\newblock Cambridge Studies in Advanced Mathematics. Cambridge University
  Press; 2nd edition, 2001.

\bibitem[BS72]{BS72}
B.~Baker and R.~Shostak.
\newblock Gossips and telephones.
\newblock {\em Discrete Mathematics}, 2[3]:191--193, 1972.

\bibitem[BS96]{BS96}
E.~Bach and J.~Shallit.
\newblock {\em Algorithmic number theory, volume 1: efficient algorithms},
  volume~1.
\newblock MIT press, 1996.

\bibitem[CFQS12]{CFQS12}
A.~Casteigts, P.~Flocchini, W.~Quattrociocchi, and N.~Santoro.
\newblock Time-varying graphs and dynamic networks.
\newblock {\em International Journal of Parallel, Emergent and Distributed
  Systems}, 27[5]:387--408, 2012.

\bibitem[CLRS01]{CLRS01}
T.~H. Cormen, C.~E. Leiserson, R.~L. Rivest, and C.~Stein.
\newblock {\em Introduction to Algorithms, Second Edition}.
\newblock The MIT Press and McGraw-Hill Book Company, 2001.

\bibitem[CMM{\etalchar{+}}08]{CFTE08}
A.~E. Clementi, C.~Macci, A.~Monti, F.~Pasquale, and R.~Silvestri.
\newblock Flooding time in edge-markovian dynamic graphs.
\newblock In {\em Proc. of the 27th ACM Symp. on Principles of distributed
  computing (PODC)}, pages 213--222, 2008.

\bibitem[CPMS07]{CPMS07}
A.~E. Clementi, F.~Pasquale, A.~Monti, and R.~Silvestri.
\newblock Communication in dynamic radio networks.
\newblock In {\em Proceedings of the twenty-sixth annual ACM symposium on
  Principles of distributed computing (PODC)}, pages 205--214. ACM, 2007.

\bibitem[DGH{\etalchar{+}}87]{DGH87}
A.~Demers, D.~Greene, C.~Hauser, W.~Irish, J.~Larson, S.~Shenker, H.~Sturgis,
  D.~Swinehart, and D.~Terry.
\newblock Epidemic algorithms for replicated database maintenance.
\newblock In {\em Proceedings of the sixth annual ACM Symposium on Principles
  of distributed computing (PODC)}, pages 1--12. ACM, 1987.

\bibitem[DPR{\etalchar{+}}13]{DPRS13}
C.~Dutta, G.~Pandurangan, R.~Rajaraman, Z.~Sun, and E.~Viola.
\newblock On the complexity of information spreading in dynamic networks.
\newblock In {\em Proceedings of the Twenty-Fourth Annual ACM-SIAM Symposium on
  Discrete Algorithms (SODA)}, pages 717--736. SIAM, 2013.

\bibitem[Edm65]{Ed65}
J.~Edmonds.
\newblock Paths, trees, and flowers.
\newblock {\em Canadian Journal of mathematics}, 17[3]:449--467, 1965.

\bibitem[EHK15]{EHK15}
T.~Erlebach, M.~Hoffmann, and F.~Kammer.
\newblock On temporal graph exploration.
\newblock 2015.
\newblock Yet unpublished work.

\bibitem[Fer04]{Fe04}
A.~Ferreira.
\newblock Building a reference combinatorial model for manets.
\newblock {\em Network, IEEE}, 18[5]:24--29, 2004.

\bibitem[FMS09]{FMS09}
P.~Flocchini, B.~Mans, and N.~Santoro.
\newblock Exploration of periodically varying graphs.
\newblock In Y.~Dong, D.-Z. Du, and O.~Ibarra, editors, {\em Algorithms and
  Computation}, volume 5878 of {\em Lecture Notes in Computer Science}, pages
  534--543. Springer Berlin Heidelberg, 2009.

\bibitem[FT98]{FT98}
L.~Fleischer and {\'E}.~Tardos.
\newblock Efficient continuous-time dynamic network flow algorithms.
\newblock {\em Operations Research Letters}, 23[3]:71--80, 1998.

\bibitem[GSS11]{GSS11}
S.~O. Gharan, A.~Saberi, and M.~Singh.
\newblock A randomized rounding approach to the traveling salesman problem.
\newblock In {\em Proceedings of the IEEE 52nd Annual Symposium on Foundations
  of Computer Science (FOCS)}, pages 550--559, Washington, DC, USA, 2011. IEEE
  Computer Society.

\bibitem[Hal95]{Ha95}
M.~M. Halld{\'o}rsson.
\newblock Approximating discrete collections via local improvements.
\newblock In {\em Proceedings of the sixth annual ACM-SIAM symposium on
  Discrete algorithms}, pages 160--169. Society for Industrial and Applied
  Mathematics, 1995.

\bibitem[HG97]{HG97}
F.~Harary and G.~Gupta.
\newblock Dynamic graph models.
\newblock {\em Mathematical and Computer Modelling}, 25[7]:79--87, 1997.

\bibitem[HHL88]{HHL88}
S.~M. Hedetniemi, S.~T. Hedetniemi, and A.~L. Liestman.
\newblock A survey of gossiping and broadcasting in communication networks.
\newblock {\em Networks}, 18[4]:319--349, 1988.

\bibitem[HK12]{HK12}
B.~Haeupler and F.~Kuhn.
\newblock Lower bounds on information dissemination in dynamic networks.
\newblock In {\em Proceedings of the 26th International Symposium on
  Distributed Computing (DISC)}, volume 7611 of {\em Lecture Notes in Computer
  Science}, pages 166--180. Springer Berlin Heidelberg, 2012.

\bibitem[HS12]{HS12}
P.~Holme and J.~Saram{\"a}ki.
\newblock Temporal networks.
\newblock {\em Physics reports}, 519[3]:97--125, 2012.

\bibitem[KK02]{KK02}
D.~Kempe and J.~Kleinberg.
\newblock Protocols and impossibility results for gossip-based communication
  mechanisms.
\newblock In {\em Proceedings of the IEEE 43rd Annual Symposium on Foundations
  of Computer Science (FOCS)}, pages 471--480. IEEE, 2002.

\bibitem[KKK00]{KKK00}
D.~Kempe, J.~Kleinberg, and A.~Kumar.
\newblock Connectivity and inference problems for temporal networks.
\newblock In {\em Proceedings of the 32nd annual ACM symposium on Theory of
  computing (STOC)}, pages 504--513, 2000.

\bibitem[KLO10]{KLO10}
F.~Kuhn, N.~Lynch, and R.~Oshman.
\newblock Distributed computation in dynamic networks.
\newblock In {\em Proceedings of the 42nd ACM symposium on Theory of computing
  (STOC)}, pages 513--522, New York, NY, USA, 2010. ACM.

\bibitem[KMP{\etalchar{+}}15]{KMP15}
S.~Kontogiannis, G.~Michalopoulos, G.~Papastavrou, A.~Paraskevopoulos,
  D.~Wagner, and C.~Zaroliagis.
\newblock Analysis and experimental evaluation of time-dependent distance
  oracles.
\newblock In {\em Proceedings of the Seventeenth Workshop on Algorithm
  Engineering and Experiments (ALENEX)}, pages 147--158, 2015.

\bibitem[KO11]{KO11}
F.~Kuhn and R.~Oshman.
\newblock Dynamic networks: models and algorithms.
\newblock {\em SIGACT News}, 42:82--96, March 2011.
\newblock Distributed Computing Column, Editor: Idit Keidar.

\bibitem[Kos09]{Ko09}
V.~Kostakos.
\newblock Temporal graphs.
\newblock {\em Physica A: Statistical Mechanics and its Applications},
  388[6]:1007--1023, 2009.

\bibitem[KS13]{KS13}
M.~Karpinski and R.~Schmied.
\newblock On improved inapproximability results for the shortest superstring
  and related problems.
\newblock {\em Proc. 19th CATS}, pages 27--36, 2013.

\bibitem[KSSV00]{KSSV00}
R.~Karp, C.~Schindelhauer, S.~Shenker, and B.~Vocking.
\newblock Randomized rumor spreading.
\newblock In {\em Proceedings of the IEEE 41st Annual Symposium on Foundations
  of Computer Science (FOCS)}, pages 565--574. IEEE, 2000.

\bibitem[KW98]{KW98}
S.~O. Krumke and H.-C. Wirth.
\newblock On the minimum label spanning tree problem.
\newblock {\em Information Processing Letters}, 66[2]:81--85, 1998.

\bibitem[Lei92]{Le92}
F.~T. Leighton.
\newblock {\em Introduction to parallel algorithms and architectures}, volume
  188.
\newblock Morgan Kaufmann San Francisco, 1992.

\bibitem[MCS11a]{MCS11-2}
O.~Michail, I.~Chatzigiannakis, and P.~G. Spirakis.
\newblock Mediated population protocols.
\newblock {\em Theoretical Computer Science}, 412[22]:2434--2450, May 2011.

\bibitem[MCS11b]{MCS11}
O.~Michail, I.~Chatzigiannakis, and P.~G. Spirakis.
\newblock {\em New Models for Population Protocols}.
\newblock N. A. Lynch (Ed), Synthesis Lectures on Distributed Computing Theory.
  Morgan \& Claypool, 2011.

\bibitem[MCS13]{MCS13b}
O.~Michail, I.~Chatzigiannakis, and P.~G. Spirakis.
\newblock Naming and counting in anonymous unknown dynamic networks.
\newblock In {\em 15th International Symposium on Stabilization, Safety, and
  Security of Distributed Systems (SSS)}, pages 281--295. Springer, 2013.

\bibitem[MCS14]{MCS14}
O.~Michail, I.~Chatzigiannakis, and P.~G. Spirakis.
\newblock Causality, influence, and computation in possibly disconnected
  synchronous dynamic networks.
\newblock {\em Journal of Parallel and Distributed Computing},
  74[1]:2016--2026, 2014.

\bibitem[Men27]{Me27}
K.~Menger.
\newblock Zur allgemeinen kurventheorie.
\newblock {\em Fundamenta Mathematicae}, 10[1]:96--115, 1927.

\bibitem[MM13]{MM13}
B.~Mans and L.~Mathieson.
\newblock On the treewidth of dynamic graphs.
\newblock In D.-Z. Du and G.~Zhang, editors, {\em Computing and Combinatorics},
  volume 7936 of {\em Lecture Notes in Computer Science}, pages 349--360.
  Springer Berlin Heidelberg, 2013.

\bibitem[MMCS13]{MMCS13}
G.~B. Mertzios, O.~Michail, I.~Chatzigiannakis, and P.~G. Spirakis.
\newblock Temporal network optimization subject to connectivity constraints.
\newblock In {\em 40th International Colloquium on Automata, Languages and
  Programming (ICALP)}, volume 7966 of {\em Lecture Notes in Computer Science},
  pages 657--668. Springer Berlin Heidelberg, 2013.

\bibitem[MMS15]{MMS15}
G.~B. Mertzios, O.~Michail, and P.~G. Spirakis.
\newblock Temporal network optimization subject to connectivity constraints.
\newblock {\em CoRR}, abs/1502.04382, 2015.
\newblock Full version of [MMCS13].

\bibitem[Mon05]{Mo05}
J.~Monnot.
\newblock The labeled perfect matching in bipartite graphs.
\newblock {\em Information Processing Letters}, 96[3]:81--88, 2005.

\bibitem[MR02]{MR02}
M.~Molloy and B.~Reed.
\newblock {\em Graph colouring and the probabilistic method}, volume~23.
\newblock Springer, 2002.

\bibitem[MS14a]{MS14b}
O.~Michail and P.~G. Spirakis.
\newblock Simple and efficient local codes for distributed stable network
  construction.
\newblock In {\em Proceedings of the 33rd ACM Symposium on Principles of
  Distributed Computing (PODC)}, PODC '14, pages 76--85. ACM, 2014.

\bibitem[MS14b]{MS14}
O.~Michail and P.~G. Spirakis.
\newblock Traveling salesman problems in temporal graphs.
\newblock In {\em 39th International Symposium on Mathematical Foundations of
  Computer Science (MFCS)}, pages 553--564. Springer, 2014.

\bibitem[MV80]{MV80}
S.~Micali and V.~V. Vazirani.
\newblock An  algorithm for finding maximum
  matching in general graphs.
\newblock In {\em Proceedings of the IEEE 21st Annual Symposium on Foundations
  of Computer Science (FOCS)}, pages 17--27. IEEE, 1980.

\bibitem[Orl81]{Or81}
J.~B. Orlin.
\newblock The complexity of dynamic languages and dynamic optimization
  problems.
\newblock In {\em Proceedings of the 13th annual ACM symposium on Theory of
  computing (STOC)}, pages 218--227. ACM, 1981.

\bibitem[OW05]{OW05}
R.~O'Dell and R.~Wattenhofer.
\newblock Information dissemination in highly dynamic graphs.
\newblock In {\em Proceedings of the 2005 joint workshop on Foundations of
  mobile computing (DIALM-POMC)}, pages 104--110, 2005.

\bibitem[Pel00]{Pe00}
D.~Peleg.
\newblock Distributed computing: A locality-sensitive approach.
\newblock {\em SIAM Monographs on discrete mathematics and applications}, 5,
  2000.

\bibitem[Pit87]{Pi87}
B.~Pittel.
\newblock On spreading a rumor.
\newblock {\em SIAM Journal on Applied Mathematics}, 47[1]:213--223, 1987.

\bibitem[PY93]{PY93}
C.~H. Papadimitriou and M.~Yannakakis.
\newblock The traveling salesman problem with distances one and two.
\newblock {\em Mathematics of Operations Research}, 18[1]:1--11, 1993.

\bibitem[Rav94]{Ra94}
R.~Ravi.
\newblock Rapid rumor ramification: Approximating the minimum broadcast time.
\newblock In {\em Proceedings of the IEEE 35th Annual Symposium on Foundations
  of Computer Science (FOCS)}, pages 202--213. IEEE, 1994.

\bibitem[Sch02]{Sc02}
C.~Scheideler.
\newblock Models and techniques for communication in dynamic networks.
\newblock In {\em Proceedings of the 19th Annual Symposium on Theoretical
  Aspects of Computer Science (STACS)}, pages 27--49, 2002.

\bibitem[TIR78]{TIR78}
S.~L. Tanimoto, A.~Itai, and M.~Rodeh.
\newblock Some matching problems for bipartite graphs.
\newblock {\em Journal of the ACM (JACM)}, 25[4]:517--525, 1978.

\bibitem[XFJ03]{XFJ03}
B.~Xuan, A.~Ferreira, and A.~Jarry.
\newblock Computing shortest, fastest, and foremost journeys in dynamic
  networks.
\newblock {\em International Journal of Foundations of Computer Science},
  14[02]:267--285, 2003.

\end{thebibliography}

\end{document}
