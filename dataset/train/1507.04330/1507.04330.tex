In this section we describe a template for maintaining a maximal independent set (MIS). Initially, we are given a graph  along with an MIS that satisfies certain properties, and after a topology change occurs in the graph, applying the template results in an MIS that satisfies the same properties. That is, the template describes what we do after a single topology change, and if one considers a long-lived process of topology changes, then this would correspond to having initially an empty graph and maintaining an MIS as it evolves. We emphasize that the template describes a process that is not in any particular model of computation, and later in Section~\ref{sec:dist_impl} we show how to implement it efficiently in our dynamic distributed setting. This also means that there are only four topology changes we need to consider: edge-insertion, edge-deletion, node-insertion and node-deletion. For example, the notions of abrupt and graceful node deletions are defined with respect to the dynamic distributed setting because they affect communication, and therefore the implementation of the template will have to address this distinction, but the template itself is only concerned with a single type of node deletion, not in any particular computation model.


Throughout, we assume a uniformly random permutation  on the nodes . We define two \emph{states} in which each node can be:   for an MIS node, and  for a non-MIS node. We abuse notations and also denote by  and  the sets of all MIS and non-MIS nodes, respectively. Our goal is to maintain the following \emph{\MIS invariant}: A node  is in  if and only if all of its neighbors  which are ordered before it according to , i.e., for which , are not in . It is easy to verify that whenever the \MIS invariant is satisfied, it holds that the set  is a maximal independent set in .
Furthermore, it is easy to verify that this invariant simulates the greedy sequential algorithm, as defined in the introduction.

When any of the four topology changes occurs, there is at most a single node for which the MIS invariant no longer holds. We denote this node by , where  and  are the graphs before and after the topology change. For an edge insertion or deletion,  is the endpoint with the larger order according to . For a node insertion or deletion,  is the  node. \footnote{For a node deletion, we slightly abuse the definition of  in order to facilitate the presentation, and consider it to be the deleted node. This means that here we consider an intermediate stage of having  still belong to the graph w.r.t. the \MIS invariant of all the other nodes, but for  the \MIS invariant no longer holds. This is in order to unify the four cases, otherwise we would have to consider all of the neighbors of a deleted node as nodes for which the \MIS invariant no longer holds after the topology change.}
In case the topology change is an edge change, we will need also to take into consideration its other endpoint. We denote it by , and notice that by our notation, it must be the case that . In order to unify our proofs for all of the four possible topology changes, we talk about a node  also for node changes. In this case we define  to be  itself, and we have that . Therefore, for any topology change, it holds that .

To describe our template, consider the case where a new edge is inserted and it connects two nodes , where both nodes are in . As a result,  must now be deleted from the MIS and hence we need to change its state. Notice that as a result of the change in the state of , additional nodes may need their state to be changed, causing multiple state changes in the graph.
An important observation is that it is possible that during this process of propagating local corrections of the \MIS invariant, we change the state of a node more than once. As a simple example, consider the case in which  has two neighbors,  and , for which , and that  and  are connected by a path , with . Now, when we change the state of  to , both  and  need to be changed to , for the \MIS invariant to hold. This implies that  needs to be changed to  and  needs to be changed to . In this case, since , the node  needs to be changed back to state .


The above observation leads us to define a set of \emph{influenced} nodes, denoted by , containing  in the scenario where we need to change its state, and all other nodes whose state we must  subsequently change as a result of the state change of .
To formally define the set  we introduce some notations. The notations rely on the graph structure of  unless the change is a node deletion in which case the rely on .
For each node , we define , the set of neighbors of  that are ordered before it according to .
These are the nodes that can potentially \emph{influence} the state of  according to the \MIS invariant. The definition of  is recursive, according to the ordering induced by .
If immediately after the topology change, in the new graph  with the order  it holds that the \MIS invariant still holds for , then we define . (This is motivated by the fact that no node is influenced by this change.) Otherwise, we denote , and inductively define


The set  is then defined as . Notice that a node  can be in more than one set , as is the case for  in the example above, which is in both  and . The impact of a node  being in more than one  is that in order to maintain the \MIS invariant, we need to make sure that we update the state of  after we update that of , for any  such that . Instead of updating the state of  twice, we can simply wait and update it only after the state of every such  is updated. For this, we denote by  the maximal index  for which  is in .

\begin{algorithm}
Initially,  satisfies the \MIS invariant.\\
On topology change at node  do:\\
1. Update state of  if required for \MIS to hold\\
2. For , until , do:\\
3. \quad For every  such that :\\
4. \quad\quad Update state of \\
5. \quad 
\caption{A Template for Dynamic Correlation Clustering.}
\label{alg:template}
\end{algorithm}


We formally describe our template in Algorithm~\ref{alg:template}.
By construction, the updated states after executing Algorithm~\ref{alg:template} satisfy the \MIS invariant.
In addition, the crucial property that is satisfied by the above template is that in expectation, the size of the set  is . The remainder of this section is devoted to proving the following, which is our main technical result.

\begin{thm}
\label{thm:ES-const}
For every two graphs  and  that differ only by a single edge or a single node, it holds that  
. 
\end{thm}


\paragraph{Outline of the proof:} In order to prove that , 
instead of analyzing the set  directly, we analyze the set ,  which is defined via recursion similarly to  with three modifications: (1) It is always the case that  (2) The graph according to which  is defined is  in the case of a node deletion or an edge insertion, and  otherwise. (3) The permutation according to  is defined as , that is identical to  other than its value for  that is forced to be the minimal among all other  values. Notice that  does not depend on  and in particular, having knowledge about its elements does not give any information as to whether  or vice versa. 






In Lemma~\ref{lem:SandS'}, we prove that if  then , and otherwise  (in fact, it would be enough that ). Then, in Lemma~\ref{lem:one-over-P}, we prove that for any set , given the event that , the probability, over the random choice of , that  is . This leads to the required result of Theorem~\ref{thm:ES-const}.
Lemma~\ref{lem:one-over-P} would be trivial if there was no correlation between  and . However, the trap we must avoid here is that  is defined according to , and therefore when analyzing its size we cannot treat  as a \emph{uniformly} random permutation. To see why, suppose we know that inside  we have nodes with large order in . Then the probability that the order of  in  is smaller than all nodes in , is much larger than , and can in fact be as large as . In other words,  gives some information over . Nevertheless, we show that this information is either about the order between nodes outside of , or about the order between nodes within . Both types of restrictions on  do not affect the probability that  is the minimal of .



We now formally prove our result as outlined above. Throughout we use the notation  or . This applies only to nodes  for which we are guaranteed that their states remain the same despite the topology change.
\begin{lem}
\label{lem:SandS'}
If  then . Otherwise, .
\end{lem}
\begin{proof}
First, assume that . We show that the \MIS invariant still holds after the topology change, and so .
Consider the node , for which . Notice that , because . We claim that . Assume, towards a contradiction, that . This implies that  has a neighbor  such that . For this node  we must have  due to the minimality of . It follows, according to the construction of  that  cannot be an element of , leading to a contradiction.

We have that  and due to the minimality of , it must be that , which implies that  is a neighbor of . But then, when considering ,  has a neighbor other than  which is ordered before it according to  which is in . In the case of an edge insertion or deletion, this means that  remains in  despite the topology change meaning that . In the case of a node deletion,  was not in  prior to the change hence . In the case of a node insertion,  does not enter  hence again, .

Next, assume that . We show that either  or .
If there is no need to change the state of  as a result of the topological change then , and so  and the claim holds. It remains to analyze the case where . 
If  then  hence according to its definition . If  then  must have a neighbor  with  meaning that . We have that  and similarly  for all . We conclude that  as required.
\end{proof}

The following lemma shows that the probability of having  is , which immediately lead to Theorem~\ref{thm:ES-const} as the only other alternative is . \begin{lem}
\label{lem:one-over-P}
For any set of nodes , it holds that 
\end{lem}


To prove this lemma we focus on . Notice that the events we considered in the previous lemma depend only on the ordering 
implied by  and hold for any configuration of states for the nodes that satisfy the \MIS invariant. Roughly speaking, the lemma 
will follow from the fact the the event  does not give any information about the order implied by  between nodes in  
and nodes in . To this end, for every permutation  on , we define  as the set corresponding to  under the ordering induced by . 
We denote by  the set of all permutations  for which it holds that . We first need to establish the 
following about permutations in : If  and  are two permutations on  such that  
and , then  if and only if .



\begin{claim}
\label{claim:u-in-barS}
Let  be a set of nodes, and let  and  be two permutations such that  and . Assume . We have that  and every  has the same state according to  and .
\end{claim}

\begin{proof}
Let . We prove that  and that its state under  is the same as it is under  by induction on the order of nodes in  according to  (which is equal to their order according to ).



For the base case, assume that  has the minimal order in .
We claim that  cannot have a neighbor in .
Assume, towards a contradiction, that  has a neighbor . Since  then it is possible that after the a  will be in . Since two nodes in  cannot be neighbors and , then  must be in  according to . In this case there is a node  that is in  according to . But this cannot occur due to the minimality of  in . Therefore,  has no neighbors in  as required.

We have that all of the neighbors of  are in  and that  is the minimal among its neighbors according to . Since  we have that  has the minimal order among its neighbors according to . This translates into  having a state of  under  and in particular,  is not an element of , thus proving our base case.


For the induction step, consider a node , and assume the claim holds for every . We consider two cases, depending on whether  has a neighbor in  or not.

Case 1:   does not have any neighbor in .
If , then there is a node  that is in  according to . By the induction hypothesis,  and  also according to . Since , we have that  is in  according to  too.
Otherwise, if , then every  (which is also ) is in  according to .
Any node  is also in , since it is not in  and . The induction hypothesis on  gives that it is also in  (otherwise it would be in  in contradiction to the assumption of case 1), and its state according to  is . Hence,  must be in  as well, and in state  according to .


Case 2: Assume that  has a neighbor . Since  then it is possible that after the algorithm  will be in . Since two nodes in  cannot be neighbors and , then  must be in  according to . In this case there is a node  that is in  according to . By the induction hypothesis,  and  also according to . Since , we have that  is in  and in  according to  too.
\end{proof}


\begin{claim}
\label{claim:sigma-pi}
Let  be a set of nodes, and let  and  be two permutations such that  and . Assume . We have that .
\end{claim}
\begin{proof}
We prove that every node  is also in  by induction on the order of nodes in  according to  (which is equal to their order according to ), with the modification forcing  to be the first among the nodes of .
The base case is for , which is clearly in both sets  and .
Consider a node  and assume that the claim holds for every node in  which is ordered before  according to .
Since  and  there must be some  since  and  we have according to our induction hypothesis that , meaning that  is non-empty.

Consider now an arbitrary . If  then since  and  we have according to our induction hypothesis that . If  then it must be the case that  according to , otherwise  cannot be in . We thus have according to Claim~\ref{claim:u-in-barS} that (1)  and (2)  according to . It follows that all neighbors of  in  are either in  or in  according to , hence since  it must be the case that .
\end{proof}





Claims~\ref{claim:u-in-barS} and~\ref{claim:sigma-pi} combined imply that if  and  then  if and only if . We are now ready for the proof of Lemma~\ref{lem:one-over-P}.
\begin{proof}
\emph{(of Lemma~\ref{lem:one-over-P})~}
Given two permutations  and  on  and , respectively, we define  as 




First, we observe that for two pairs of permutations  and  as above, it holds that . This is because given the condition for , applying the permutation  to nodes in  and applying the permutation  to nodes in  has no affect on whether the event  holds.
Next, since , we have that for any pair of permutations  on  and , respectively:
\vspace{-0.1in}


Finally, Claims~\ref{claim:u-in-barS} and~\ref{claim:sigma-pi} imply that for every set  there is a set of  pairs of permutations  on  and , respectively, such that . We conclude that for a given set :
\vspace{-0.2in}

\vspace{-0.25in}

To complete the proof, we argue that knowing that  can only decrease the probability that  for all . Formally,

To bound the above expression, we separate our discussion into three possible cases. In the first  and . The value of the expression is clearly 0 in this case. In the second we have  and according to Equation~\eqref{eq:vs_min} we have that the quantity is bounded by . The last case is the one where . Here, because  and  we have that the events of  being the minimal in  and  being the smaller than each of the elements of  are independent for uniform . This is due to the first event being dependent of the inner order inside  and the second being independent of the same inside order.
Hence,

\vspace{-0.2in}

\end{proof}
\vspace{-0.1in}

Lemma~\ref{lem:SandS'} and Lemma~\ref{lem:one-over-P} immediately lead to Theorem~\ref{thm:ES-const}. Also, as an immediate corollary of Theorem~\ref{thm:ES-const} we get

\begin{corollary}
A direct distributed implementation of Algorithm~\ref{alg:template} has, in expectation, both a single adjustment and round, in both the synchronous and asynchronous models.
\end{corollary}
