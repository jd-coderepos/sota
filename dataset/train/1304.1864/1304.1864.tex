\documentclass[final]{siamltex}

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{array}
\usepackage{ifthen}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{aicescover}




\newcommand\comm[1]{{\bf COMMENT: #1 :COMMENT}}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Rn}{\R^{n}}
\newcommand{\Rnn}{\R^{n \times n}}

\newcommand\norm[1]{\lVert#1\rVert}
\newcommand\order[1]{\mathcal{O}(#1)}
\newcommand\abs[1]{\lvert#1\rvert}

\newcommand{\binaryx}{{\it binary\_\hspace*{1pt}x}}
\newcommand{\binaryy}{{\it binary\_\hspace*{0pt}y}}

\sloppy
\hyphenation{eigen-val-ue eigen-val-ues eigen-prob-lem eigenprob-lems}


\begin{document}


\title{Improved Accuracy and Parallelism for MRRR-based Eigensolvers -- A Mixed Precision Approach\thanks{Financial support  
from the Deutsche Forschungsgemeinschaft (German Research Association)
through grant GSC 111 is gratefully acknowledged. Enrique S. Quintana-Ort\'{\i} was supported by project TIN2011-23283 and FEDER.}} 

\author{
  M.~Petschow\thanks{Aachen Institute for advanced study in Computational 
Engineering Science, RWTH Aachen University, Germany. Electronic address:
{\tt \{petschow,pauldj\}@aices.rwth-aachen.de}}
  \and E.~S. Quintana-Ort\'{i}\thanks{Depto. de Ingenier\'{\i}a y Ciencia de
    Computadores, Universidad Jaume I, 12071 Castell\'on, Spain. Electronic
    address: {\tt quintana@icc.uji.es}}
  \and P.~Bientinesi\footnotemark[2]
}





\aicescoverpage

\maketitle

\begin{abstract}
The real symmetric tridiagonal eigenproblem is of outstanding 
importance in numerical computations; it arises frequently as 
part of eigensolvers for standard and generalized 
dense Hermitian eigenproblems that are based on a
reduction to tridiagonal form.
For its solution, the algorithm of {\it Multiple Relatively
  Robust Representations} (MRRR) is among the fastest methods. 
Although fast, the solvers based on MRRR do not
deliver the same accuracy as competing methods like Divide \& Conquer or the
QR algorithm.   
In this paper, we demonstrate that the use of mixed precisions leads to
improved accuracy of MRRR-based eigensolvers {\it with limited or no
  performance penalty}. As a result, we obtain eigensolvers that are not
only equally or more accurate than the best available methods, but also --
under most circumstances -- faster and more scalable than the competition.
\end{abstract}

\begin{keywords} 
  symmetric eigenproblems, tridiagonal matrices, high-performance, MRRR
\end{keywords}

\begin{AMS}
65F15, 65Y05, 68W10
\end{AMS}

\pagestyle{myheadings}
\thispagestyle{plain}
\markboth{M.~Petschow, E.~S. Quintana-Ort\'{\i}, and
  P.~Bientinesi}{Improved accuracy for MRRR-based eigensolvers} 


\section{Introduction}
\label{sec:intro}

In~\cite{Li02design}, the authors
describe how in libraries the use of ``higher internal
precision and mixed input/output types and precisions permits
[...] to implement some algorithms that are simpler, more accurate, and
sometimes faster.'' In particular, the internal use of higher precision
provides the 
library developer with extra precision and a wider range of values, which may
benefit the accuracy and robustness of numerical routines. 
In sharp contrast to software that uses
arbitrary precision to obtain any desired accuracy, the use of higher precision should not
lower performance  significantly if at all. In this paper, we employ
mixed precisions to improve not only the accuracy, but also the robustness and
scalability of eigensolvers based on the algorithm of {\it Multiple Relatively
  Robust Representations} (MRRR or MR for
short)~\cite{DesignMRRR,Bientinesi:2005:PMR3,Vomel:2010:ScaLAPACKsMRRR,mr3smp,EleMRRR,Willems:Diss}.  

Direct methods for standard and generalized Hermitian eigenproblems often rely on a
reduction to real symmetric tridiagonal form~\cite{Bai:2000:TSA:357352}. Once the
problem is transformed, the {\it real symmetric tridiagonal eigenproblem} (STEP)
is the following: Given a tridiagonal matrix  (with , where  denotes the transpose of ), find quantities  and nonzero  such that the equation

holds. Without loss of generality, we assume  hereafter,
where  denotes the 2-norm. For such a 
solution,  is called an \textit{eigenvalue} (of ) and  an associated
\textit{eigenvector}; an eigenvalue together with an associated
eigenvector are said to form an \textit{eigenpair}, .
The Spectral Theorem~\cite{Parlett:1998:SEP} ensures the existence of
 eigenpairs , , such that the
eigenvectors form a complete orthonormal set; that is, for all ,   

Since all eigenvalues are
real, they can be ordered:

where  is the -th smallest eigenvalue of . In
this paper, whenever the underlying matrix is not clear, we write
 explicitly. The set of all eigenvalues of  is denoted
 and the spectral diameter is defined as . 
For a given 
index set ,  

denotes the invariant subspace associated with . As with the
eigenvalues, whenever the underlying matrix is not understood from context, we
write  explicitly.

In many applications, only a subset of eigenpairs are of interest and need
to be computed. 
For the computed eigenpairs,
,  and , the accuracy of the
results can be quantified by 
the {\it largest residual norm} and the {\it orthogonality}, 
respectively defined as 


A number of excellent algorithms for the STEP have been discovered. Among them,
Bisection and Inverse Iteration (BI)~\cite{Dhillon98currentinverse,Ipsen:1997:Invit},
the QR algorithm (QR)~\cite{qr61a,qr61b},  
Divide \& Conquer (DC)~\cite{dc81,dc94,dc95}, and the focus of this study,
MRRR~\cite{Dhillon:Diss,Dhillon:2004:Ortvecs,Dhillon:2004:MRRR,Fernando97,Parlett2000121,Willems:Diss}.  
These methods differ in various aspects: the number of floating point operations (flops)
they perform, the flop-rate at 
which the operations are executed, the amount of memory required, the
possibility of computing subsets 
of eigenpairs at reduced cost, the attainable accuracy, the simplicity and
robustness of the code, and the suitability for parallel computations.
Thus, the ``best'' algorithm is influenced by factors such as the problem
(e.g., dimension, subset, spectral distribution), the 
architecture (e.g., cache sizes, parallelism), external
libraries (e.g., Basic Linear Algebra Subprograms), and the specific
implementation of the algorithm (e.g., thresholds, optimizations). 

Demmel et al.~\cite{perf09} provide a detailed study of the performance and
accuracy of LAPACK's~\cite{laug} 
implementations of these four methods on various
architectures. They conclude that
()~DC and QR are the most accurate
algorithms; ()~DC requires  additional memory and therefore
much more than all 
the other algorithms;\footnote{Here and in the following, we use the notation
   informally as ``of the order of  in magnitude.'' The notion
is used to hide moderate constants that are of no particular interest to our
discussion.} ()~DC and MRRR are {\em much faster} than QR and BI;
despite the fact that MRRR uses the fewest flops, DC is faster on certain classes of
matrices. If the full eigendecomposition is desired, DC is generally the method of
choice, but whether DC or MRRR is faster depends on the spectral distribution
of the input matrix; and ()~if only a subset of eigenpairs is desired, 
MRRR is the method of choice. 
The study is limited to {\it sequential} executions and does not take
into account the degree of parallelism the algorithms provide. However, various
studies~\cite{Bientinesi:2005:PMR3,Vomel:2010:ScaLAPACKsMRRR,EleMRRR,Tisseur:1999:PDC,mr3smp} of the performance and 
accuracy of parallel implementations come to similar conclusions.

To summarize, if all eigenpairs are computed, depending on the spectral
distribution of the input matrix, either DC or MRRR is the fastest method. If only
a subset of eigenpairs is desired, MRRR is the method of
choice. Unfortunately, MRRR delivers generally the least accurate results.   
These observations carry over to direct methods for the dense
eigenproblem based on a reduction to tridiagonal form. 
It is natural to ask whether the accuracy of the MRRR-based routines can be
improved to levels of other methods like QR or DC. 
Unfortunately, a general analysis of any MRRR implementation shows that, even if all 
requirements of the algorithm are fulfilled, one needs to expect
orthogonality of  -- with unit roundoff 
~\cite{Willems:framework}. Methods like QR and DC, however,
attain superior results with orthogonality of . In this paper, we present a practical solution that improves the
accuracy of MRRR. As a result, it becomes equally or more accurate than QR and DC.

Our solution resorts to the use of higher precision arithmetic. The motivation is
twofold: () MRRR is frequently the fastest algorithm and it might be
possible to trade (some of) its performance to obtain higher accuracy; ()
often MRRR is used in the context of direct methods for Hermitian
eigenproblems. While the tridiagonal stage is responsible for much of 
the ``loss'' of orthogonality in the final result, it has a lower complexity
than the reduction to
tridiagonal form. Thus, {\it even if it is necessary to spend more time in the
tridiagonal stage to improve accuracy, for sufficiently large matrices, the
overall run time will not be affected 
significantly}. As MRRR does not make use of
any level-3 Basic Linear Algebra Subprograms (BLAS)~\cite{blas90}, we do not
require in our mixed precision approach any optimized BLAS library for 
high precision, which might not be available. 

For any MRRR solver, we present how the use of mixed
precisions leads to more accurate results at very little or even no extra
costs in terms of performance. 
As a consequence, {\it MRRR is not only one 
of the fastest methods, but also becomes as accurate or even more accurate than the
competition}. Moreover, for direct methods based on a reduction to
tridiagonal form and MRRR, the tridiagonal eigensolver is responsible for
the inferior orthogonality compared with other methods. These solvers
benefit directly 
from our approach. 

\subsection{Related work and outline}
\label{sec:relatedwork}

The term {\it mixed precision algorithm} is sometimes synonymously
used for the following procedure: First solve the problem using a fast
low-precision arithmetic, and then refine the result to high accuracy using
a high-precision arithmetic.
This {\it mixed precision iterative refinement} approach
exploits the fact 
that  
there might exist a low-precision arithmetic faster
than that of the input/output data format. The larger the performance gap
between the two arithmetic, the more beneficial the
approach. Iterative refinement (with and without using mixed precisions) has
been most extensively studied for the 
solution of linear systems of equations~\cite{HIGHAM01101997},
but other 
operations such as the solution of Lyapunov equations   
also benefit from it~\cite{Benner:2011:MAS:2010586.2010622}.
 
We use of the term {\it mixed precision} in its more general form; that is,
using two or more different precisions for solving a problem. In particular,
we use a
higher precision in the more sensitive parts of an 
algorithm to obtain accuracy, which otherwise could not be achieved. This
approach is especially effective if the sensitive 
portion of the algorithm and/or the performance gap
between the two arithmetic is small. Similarly to the mixed
precision ideas for iterative refinement, the approach is quite
general and we believe it can benefit computations in numerous areas. 

The rest of the paper is organized as follows: In
Section~\ref{sec:mrrralgorithm}, we present the MRRR algorithm and its
accuracy limitations. The section mainly serves as a vehicle to introduce the
factors that influence accuracy, which are summarized in
Theorem~\ref{resthm}. The derivation of
the error bounds, which can be found in~\cite{Willems:framework}, is not important
for the understanding of our discussion. In
Section~\ref{sec:mixedgeneral}, we detail our mixed 
precision approach in a general setting. Besides presenting a way to improve
accuracy, we investigate the effects on memory
usage, robustness, and scalability.
In Section~\ref{sec:implementation}, we comment on an actual implementation
of our approach and 
elaborate on a number of practical issues. Finally, we present experimental
results of our mixed precision solvers in Section~\ref{sec:experiments}. 


\section{The MRRR algorithm}
\label{sec:mrrralgorithm}

In this section, we present the MRRR algorithm to the detail necessary for the
later discussion. 
Our exposition is largely based
on~\cite{Willems:framework,Willems:twisted,Dhillon:2004:MRRR} and a
high-level description of the method given in Algorithm~\ref{alg:mrrr}. We
comment more thoroughly on various parts of the computation in the following.  
The goal is to present
Theorem~\ref{resthm} -- i.e., the factors that influence the accuracy of any
implementation of MRRR.

\paragraph{Preprocessing} Algorithm~\ref{alg:mrrr} assumes that the necessary
preprocessing is already performed; this includes the {\it scaling} of the entries, and
the so called {\it splitting} of the input matrix into principal submatrices
if off-diagonal entries are sufficiently small in
magnitude~\cite{Parlett:1998:SEP}. 
In this section, without any loss is generality, we assume that
the input matrix is (numerically) {\it irreducible}, i.e., 
no off-diagonal entry is ``small enough'' in magnitude that warrants setting it
to zero. The exact criterion is specified later.
\begin{algorithm}[ht]
 \small
    {\bf Input:} Irreducible symmetric tridiagonal ; index set . \\
    {\bf Output:} Eigenpairs  with
    .
    
    \vspace{1mm}

  \algsetup{indent=2em}
  \begin{algorithmic}[1]
    \STATE Select shift  and compute . \label{line:mrrr:root} 
    \STATE Perturb  by a ``random'' relative amount bounded by a
    small multiple of . \label{line:mrrr:perturb}
    \STATE Compute  with 
    to relative accuracy sufficient for classification. 
    \label{line:mrrr:initialeigvals} 
    \STATE Form a work queue  and enqueue task
    . \label{line:mrrr:enddlarre}
    \WHILE{ not empty} 
    \STATE Dequeue a task . \label{line:mrrr:dequeue}
    \STATE Partition   according 
    to the separation of the eigenvalues. \label{line:mrrr:initialpartitioning}
    \FOR{ {\bf to} }
    \IF{} \label{line:mrrr:ifstatement} 
    \STATE // {\it process well-separated eigenvalue associated with
      singleton } //
    \STATE Perform Rayleigh quotient iteration (guarded by bisection) to
    obtain eigenpair  with sufficiently
    small residual norm, . \label{line:mrrr:rqi}
    \STATE Return  and
     . \label{line:mrrr:returneigenpair} 
    \ELSE
    \STATE // {\it process cluster associated with } //
    \STATE Select shift  and compute . \label{line:mrrr:shifting}  
    \STATE Refine  with  to
    sufficient relative 
    accuracy. \label{line:mrrr:refine} 
    \STATE Enqueue . \label{line:mrrr:partition} 
    \ENDIF
    \ENDFOR
    \ENDWHILE \label{line:mrrr:end}
  \end{algorithmic}
  \caption{\ MRRR}
  \label{alg:mrrr}
\end{algorithm}

\paragraph{Choice of representations}
In order for Algorithm~\ref{alg:mrrr} 
to work, the representation of tridiagonals (i.e.,  and
) by their diagonal and off-diagonal entries must be abandoned
and alternative representations must be used. Any  (or less) scalars
together with a mapping that define the entries of a symmetric tridiagonal
is called a {\it representation}~\cite{Willems:framework}. We distinguish 
between the data of the representation, which are floating point numbers,
and the underlying tridiagonal, which is generally not exactly representable
 in the same finite precision format. There are multiple candidates
-- existence assumed -- for providing representations of tridiagonals:

\begin{enumerate}
\item {\it Lower bidiagonal factorizations} of the form , and {\it
    upper bidiagonal factorizations} of the form , where  and  are diagonal,  
   and  are respectively unit lower bidiagonal and
  unit upper bidiagonal. 
\item A generalization of the above are the so called {\it twisted
    factorizations} or {\it
    BABE-factorizations}~\cite{Fernando97}, , where 
   denotes the {\it twist index}. The  leading principle
  submatrix of  is unit lower bidiagonal (determined by the non-trivial
  entries ), and the 
  trailing principle submatrix of  is unit upper bidiagonal (determined by the non-trivial
  entries ); the matrix  
is diagonal. 
Although 
it was known that these factorizations can additionally serve as
representations of the intermediate
matrices~\cite{Dhillon:Diss,Dhillon:2004:Ortvecs},
their benefits were only demonstrated 
recently~\cite{Willems:Diss,Willems:twisted}. 
Due to their additional degree of freedom in choosing , the twisted
factorizations
are superior to lower or upper bidiagonal factorizations. 
Besides representing intermediate tridiagonals, twisted factorizations are
essential in computing accurate eigenvectors~\cite{Fernando97,Dhillon:2004:Ortvecs}.
\item {\it Blocked
    factorizations} are further generalizations of bidiagonal and twisted factorizations. The
  quantities , , and  
   are block diagonal, with blocks of size  or . The other factors -- , , and  -- are
  partitioned conformally, with one or the  identity as diagonals. These types of
  factorizations contain the unblocked bidiagonal and twisted factorizations
  as special cases. With their great flexibility, the blocked factorizations
  have been used very successfully within the MRRR
  algorithm~\cite{Willems:Diss,Willems:blocked}. 
\end{enumerate}
All these factorizations are determined by  scalars, the data. 
For instance, for lower bidiagonal factorizations, the  floating
point numbers  determine a
tridiagonal; such representation by the non-trivial entries of the
factorization is called an -representation. 
Similarly, the floating point numbers
 represent a tridiagonal -- with ,
,
being 's off-diagonal elements; such representation, including 's
off-diagonal elements, is called an -representation. Besides the - and
the -representation, the -representation is introduced
in~\cite{Willems:twisted} for bidiagonal and twisted factorizations. For
blocked factorizations, a variant of the -representation is commonly
used~\cite{Willems:blocked}. 
Other quantities that are computed using the
(primary) data are called {\it secondary} or {\it derived} data. For
instance, 's off-diagonal 
elements are secondary for an -representation while
being primary for an -representation. While the details are not relevant
for our discussion, it is important to note that there are different
variants to represent tridiagonals -- each one with slightly different properties.
Subsequently, we do not distinguish between the representation of a
tridiagonal and the tridiagonal itself; that is, it is always implied that
tridiagonals are represented in one of the above forms.

\paragraph{The representation tree}
The unfolding of Algorithm~\ref{alg:mrrr} is best described as a tree of
representations~\cite{Dhillon:Diss,Dhillon:2004:MRRR,Willems:framework}. Each task
 or just  (Line~\ref{line:mrrr:dequeue} of
Algorithm~\ref{alg:mrrr}) is connected to a
node in the tree; that is, all nodes consist of a representation and an
index set.  is associated with the root node (hence the name).
All other tasks are connected to ordinary nodes. Each node has a
depth associated with it: the number of edges on the unique path to it from
the root. The maximum depth for all nodes is denoted . The edges
connecting internal nodes are associated with the spectrum shifts  that are
performed in Line~\ref{line:mrrr:shifting} of Algorithm~\ref{alg:mrrr}. 

\paragraph{Factors influencing MRRR's accuracy} The analysis
in~\cite{Willems:framework} 
-- a streamlined version of the proofs
in~\cite{Dhillon:2004:MRRR,Dhillon:2004:Ortvecs} --  shows that, if suitable
representations are found, the 
computed eigenpairs enjoy a small residual norm and are mutually
(numerically) orthogonal. 

\begin{theorem}[Accuracy] 
Let  be computed (exactly)\footnote{The
  assumption can be removed; we simply stated the theorem as it can be found
in~\cite{Willems:Diss,Willems:framework}.} by applying the
spectrum shifts to eigenvalue  obtained by the Rayleigh quotient
iteration in Line~\ref{line:mrrr:rqi} of Algorithm~\ref{alg:mrrr}.  
Provided all the requirements, which are discussed below, are satisfied, it holds

with . 
Furthermore, we have for any computed eigenvectors  and , , 

where .
\label{resthm}
\end{theorem}
A proof of the theorem can be found
in~\cite{Willems:Diss,Willems:framework}. 
Provided the representation of
 is computed in a backward stable manner, a small residual norm with
respect to  implies a small residual, 
, with respect to the input matrix . 

The rest of this section serves to convey the meaning of all the
parameters involved in the theorem. In Section~\ref{sec:mixedgeneral}, we
furthermore discuss their effects on performance, robustness,
and parallel scalability.  

\paragraph{Shifting the spectrum ()}
The spectrum shifts of Line~\ref{line:mrrr:shifting} leave the eigenvectors 
unchanged in exact arithmetic; this invariance is lost in finite precision. An essential
ingredient of MRRR is the use of special forms of Rutishauser's {\it
  Quotienten-Differenzen} (qd) algorithm to perform the shifts. 
Given a representation for , we require that the representation
for  is computed in an {\it element-wise mixed relative 
stable} way, i.e.,  holds
exactly for small element-wise relative perturbations of the data for
 and . For all shifts performed in the algorithm, these
perturbations must be bounded by   
 and , respectively. Algorithms that implement the spectrum
shifts for different forms of representations are presented
in~\cite{Dhillon:2004:Ortvecs,Willems:twisted,Willems:blocked}. 

\paragraph{Requirements on the representations ()}
In order to ensure that the computed eigenpairs enjoy small residual norms
with respect to the input matrix and that the eigenvectors are
numerically orthogonal, the representations in
Line~\ref{line:mrrr:shifting}, , need to be chosen
with care. By selecting appropriate shifts , representations that are
{\it relatively robust} and exhibit {\it conditional element growth} are
selected. Before we define the meaning of these two concepts, we give a
brief definition of a {\it relative gap}. 

\begin{definition}[Relative gap] Let  be an irreducible
  symmetric tridiagonal matrix with eigenvalues  and let
   be an index set.  
  The relative gap connected to  is defined as
  
  where quantities  are  if .
\label{def:relgapindexset}
\end{definition}

\begin{definition}[Relative robustness] 
Let  (given by any representation),  and  be as
in the previous definition. Furthermore, let  be
the invariant subspace associated with . We say 
  that the representation of  is relatively robust for 
  if for all element-wise relative perturbation in the data bounded by
   and for all , we have 
  
where  and  denote the
eigenvalues and the corresponding invariant subspaces of the perturbed matrices,
respectively; 
denotes the largest principle angle; 
and  is moderate constant, say about 10.\footnote{According to
  \cite{Willems:Diss,Willems:framework}, the requirement on the eigenvalues
  can be removed entirely: for , by
  Theorem~\ref{thm:gapthm} stated below, the second condition implies 
  the first up to a small constant provided .  Similarly, if  is not a
  singleton, the second term implies that  for all . 
}
\label{def:RRR}
\end{definition}

\begin{definition}[Conditional element growth] 
A representation for a real symmetric tridiagonal, , exhibits conditional
element growth with respect to the index set ,
if for any element-wise relative perturbation in the data
bounded by  (leading to a perturbed tridiagonal ) and each , it holds

where  are the computed eigenvectors, and  is a moderate
constant, say about 10. 
\end{definition}

In Line~\ref{line:mrrr:shifting} of Algorithm~\ref{alg:mrrr}, we need to
ensure that  as well as  are relatively robust for
 and that  features conditional element growth
for . 
In this paper, we are not concerned how to ensure that the involved representations satisfy
the requirements; this is the topic
of~\cite{perturbLDL,Parlett2000121,Dhillon:2004:Ortvecs,Willems:framework}.\footnote{In
  particular, it is {\it not} necessary to compute the eigenvectors in order
  to give bounds on the conditional element growth.} 
We 
remark however that there exist the danger that no suitable representation
that passes the test for the requirements can be found. In this case,
it is common to select a promising representation, which might not fulfill the
requirements. As a consequence, the accuracy of Theorem~\ref{resthm} is not
guaranteed anymore.    

\paragraph{Classification of the eigenvalues ()} 

While the above requirements on the representations pose a restriction on the
choice of shifts  and  in
Lines~\ref{line:mrrr:root} and \ref{line:mrrr:shifting}, the main goal is to
chose shifts such that, in the next iteration, the partitioning , splits the index set into at least two subsets so that progress
in the algorithm is guaranteed. 
The partitioning is done according to the 
separation of the eigenvalues and must ensure two requirements: For a given
tolerance , say , ()  , and ()
whenever  is a singleton, . The latter relative gap is thereby defined as 
 

For all , let  denote the midpoint point
of a computed interval of uncertainty
 containing eigenvalue
. To achieve the desired partitioning of , let  and define 

as a measure of the relative gap. If , then  and
 belong to different subsets of the partition. Additionally, this criterion
based on the relative separation can be amended by a criterion based on the
absolute separation of the eigenvalues~\cite{VoemelRefinedTree2007tr}. After
partitioning, each index set 
 with  is associated with a {\it cluster}
of eigenvalues, . Similarly, each
singleton  is associated with a {\it
  well-separated} eigenvalue .

In order to reliably classify the
eigenvalues, they should be approximated in
Lines~\ref{line:mrrr:initialeigvals} and \ref{line:mrrr:refine} to relative
accuracy of about : that is, at least 

The above criterion can be relaxed for
eigenvalues with a large gap to the rest of the
spectrum~\cite{DesignMRRR}. Commonly, the 
eigenvalues are computed by some form of 
bisection~\cite{Parlett:1998:SEP}. In 
particular, in Line~\ref{line:mrrr:refine}, we already have good
approximations to the eigenvalues, which can be refined by bisection to the
desired accuracy. 

The parameter  is so important that it influences almost all parts
of the algorithm. Since the error bounds in Theorem~\ref{resthm} are
proportional to , the value indicates how much accuracy we are willing to lose in the
computation. For many applications, this limits the choice to values larger than about
. However, we cannot use values much larger than
 as otherwise it becomes impossible to make progress by breaking
clusters. 

As a side note: the condition , together with the mixed
relatively stable computation of the spectrum shifts, implies that the
associated invariant subspaces are not 
perturbed too much due to rounding
errors, i.e., . After shifting, we can
therefore hope to compute an orthonormal 
basis for such a subspace, which is {\it automatically} numerically
orthogonal to the subspace spanned by the other eigenvectors. This is the
main idea behind the MRRR algorithm.


\paragraph{Rayleigh quotient iteration ()}

Finally, in Line~\ref{line:mrrr:rqi} of Algorithm~\ref{alg:mrrr}, eigenpairs of well-separated
eigenvalues are computed via the Rayleigh quotient iteration (RQI).  
Given an approximation  and a representation  that
is relatively robust for , a key ingredient of MRRR is the ability to
compute an accurate eigenvector approximation  such that ; see~\cite{Dhillon:2004:Ortvecs} for a
proof. This is certainly achieved by driving the local residual 
norm below a specified threshold

where  is . 
In this case, the so called Gap Theorem gives the desired bound on the error
angle . 
\begin{theorem}[Gap Theorem]
Given a symmetric matrix  and an approximation , , 
to the eigenpair , with  closer to  than to any other eigenvalue,
let  
be the residual ; then

The residual norm is minimized if  is the Rayleigh quotient
of , . In 
this case, 

\label{thm:gapthm}
\end{theorem}
A proof of the theorem can be found for instance in~\cite{Parlett:1998:SEP,Willems:Diss}. 

In general, a residual norm such as in~\eqref{localresbound} cannot be guaranteed; it is only
possible to show that it holds for a small element-wise relative
perturbation of the data of  bounded by  and the computed
eigenvector  bounded by  -- with  and
. For our purposes, this
detail is not important. 
Nonetheless, Theorem~\ref{resthm} takes
this fact into account. Note that even in rare cases where \eqref{localresbound} is not
fulfilled, the small error angle together with \eqref{eq:gapthmeq2} imply
.

In the RQI, the -th iteration consists of four steps: () For all , compute the twisted factorizations ; () determine , where  is the -th element of  (see
above); () solve the linear system , which is equivalent to the system ; () use the 
Rayleigh quotient correction term to update the eigenvalue
. The residual norm is
approximated by  and the process is stopped if
\eqref{localresbound} is satisfied. 
In order to always converge, the stopping criterion is amended and the
iteration stopped when  is not improved anymore, i.e.,
~\cite{NLA:NLA493}.  
An alternative approach to RQI is to refine the eigenvalue approximation to full
precision (i.e., ), and then perform only a single step of RQI. This approach is used 
whenever RQI fails to converge to the correct eigenvalue~\cite{DesignMRRR}.



\section{Mixed precision MRRR}
\label{sec:mixedgeneral}

The exact values of the parameters in Theorem~\ref{resthm} differ
slightly for various implementations of the algorithm and need not to be
known exactly in the following analysis. The bounds on the residual norm and
orthogonality are {\it theoretical}. It is useful to translate what the bounds mean in practice: 
with reasonable parameters, realistic {\it practical} bounds on the residual
norm and on the orthogonality are  and , respectively. 
In order to obtain accuracy similar to that of the best available methods,
we need to trade the 
dependence on  by a dependence on . Furthermore, it is
necessary to reduce the orthogonality by about three orders of
magnitude.

\subsection{A solver using mixed precisions}

The technique is simple, yet powerful: Inside the algorithm, 
we use a precision higher than of the input/output in order to improve accuracy. 
A similar idea was already mentioned in~\cite{Dhillon:Diss},
in relation to a preliminary version of the MRRR algorithm,
but was never pursued further.
With many implementation and algorithmic advances since then (e.g.,
\cite{NLA:NLA493,Dhillon05gluedmatrices,Bientinesi:2005:PMR3,Willems:twisted,Willems:blocked}),  
it is appropriate to  
investigate the approach in detail.
To this end, we build a tridiagonal eigensolver that 
differentiates between two precisions: ()~the  
input/output precision, say \binaryx, and ()~the working precision,
\binaryy, with . If , we have the original 
situation of a solver based on one precision; in this case, the following analysis
is easily adapted to situations in which we are satisfied with {\em less} accuracy
than achievable by MRRR in -bit arithmetic. Since we are interested in accuracy that
cannot be accomplished in -bit arithmetic, we
restrict ourselves to the case . Provided the unit roundoff of the -bit format is
sufficiently smaller than the unit roundoff of the -bit format, say four
or five orders of magnitude, we show how to obtain, for practical matrix sizes, improved
accuracy to the desired level. 

Although any -bit and -bit floating point format might be chosen, in
practice, only those shown in
Table~\ref{tab:precisions} are used in high-performance libraries. 
For example, for a {\it binary32} input/output format (single precision), we
might use a {\it binary64} working format (double precision). Similarly, for
a {\it binary64} input/output format, we might use a {\it binary80} or {\it binary128} working
format (extended or quadruple precision). For these three configurations, we use the terms
{\it single/double}, {\it double/extended}, and {\it
  double/quadruple}. Practical issues for their implementation are  
discussed in Section~\ref{sec:implementation}. In this section, however, we
concentrate on the generic case of \binaryx/\binaryy. In general, when we
refer to \binaryx, we mean both the -bit data type and its unit roundoff . 
\begin{table}[htb]
  \begin{center}
\begin{tabular}[thb]{l@{\quad}l@{\quad}l@{\quad}l@{\quad}l@{\quad}}
\toprule
{\bf Name} & {\bf IEEE-754} & {\bf Precision} & {\bf Support}  \\
\midrule
single    & binary32   &  &  Hardware       \\ 
double    & binary64   &  &  Hardware       \\ 
extended  & binary80   &  &  Hardware       \\ 
quadruple & binary128  &  & Software       \\ 
\bottomrule\noalign{\smallskip}
\end{tabular}
  \end{center}
  \caption{The various floating point formats used and their support on common
    hardware. The -terms denote the unit roundoff error (for 
    rounding to nearest). We use the letters , ,  and
     synonymously with 32, 64, 80, and 128. For instance,
    .}
  \label{tab:precisions}
\end{table}

In principle, we could perform the entire computation in -bit arithmetic
and, at the end, cast the results to form the -bit output; for 
all practical purposes, we would obtain improved results as
desired. This naive approach, however, is not satisfactory for two reasons:
()~since the eigenvectors need to be
stored explicitly in the
\binaryy\ format, the memory requirement is increased; and more importantly,
() if the -bit floating point 
arithmetic is much slower than the -bit one, the
performance suffers severely. While the first issue is addressed rather
easily (as discussed Section~\ref{sec:memcost}), the latter requires more
care. The key insight is that it is unnecessary to compute eigenpairs with
residual norms and orthogonality bounded by ; instead,
these bounds are relaxed to  (for
example, think of , , and ). While in a conventional
implementation the choice of parameters is very restricted, as we show below, we gain enormous freedom in their choice. In
particular, while meeting our new accuracy goals, we are able to select values such
that the amount of necessary computation is reduced, the 
robustness is increased, and parallelism is improved. As our following analysis
shows, we can emphasize the importance of any of those features. 

\subsection{Adjusting the algorithm} Consider the input/output being in a
-bit format and the entire computation being performed in
-bit arithmetic. Starting from this configuration, we expose the new
freedom in the choice of several parameters and justify other changes made to the algorithm.
For example, we identify parts that can be executed in -bit
arithmetic, which might be considerably faster. 

Assuming  (again, think of  and ), we simplify
Theorem~\ref{resthm} by canceling terms that are insignificant  
even with adjusted parameters (i.e., terms that are comparable to
 in magnitude\footnote{In particular, we require that .}). In our argumentation, we hide all constants,
which anyway correspond to the bounds attainable for a solver purely based
on \binaryy.  For any reasonable implementation of the algorithm, we have the following:
, ,
, . 
Thus, the orthogonality of the final result is given by 

Similarly, for the bound on the residual norm, we get 

with 
 and .

We now provide a list of changes that can be done to the algorithm. 
We discuss their effects on performance, parallelism, and memory
requirement.  

\paragraph{Preprocessing}
We assume scaling and splitting is done as in a solver purely based on -bit
floating point arithmetic. In particular, off-diagonal
element  of the input, , is set to zero whenever
  
where  and  refer to the {\it unreduced} input.\footnote{We can
  relax the condition further and use
  .} 
We remark that this
criterion is less strict than setting elements to zero whenever . Splitting the input matrix into submatrices is
beneficial for both performance and accuracy as these are mainly determined
by the largest submatrix.
In the rest of this
section, we assume that the preprocessing has been done and each subproblem
is treated independently by invoking Algorithm~\ref{alg:mrrr}. In particular, whenever
we refer to matrix , it is assumed to be irreducible; whenever we
reference the matrix size  in the context of parameter settings, it refers
to the size of the processed block. 

\paragraph{Choice of representations} For different forms
of representing tridiagonals (e.g., bidiagonal, twisted, or blocked factorizations) and their
data (e.g., -, -, or -representation), different algorithms
implement the shift operation: . All these
algorithms are stable in the sense that the relation holds 
exactly if the data for  and  are perturbed element-wise by a
relative amount bounded by . The implied constants
for the perturbation bounds vary slightly. As , instead of concentrating on accuracy issues, we make our
choice based on robustness and {\it performance}. A discussion of performance
issues related to different forms of the representations can be found
in~\cite{Willems:twisted,Willems:Diss}. Based on this discussion, it appears
that twisted factorizations with -representation seem to be a reasonable
choice. As the off-diagonal entries of all the matrices stay the same, they
only need to be stored once and are reused during the entire
computation. 

\paragraph{Random perturbations} In Line~\ref{line:mrrr:perturb} of
Algorithm~\ref{alg:mrrr}, to break up tight clusters, the data of 
, , is perturbed element-wise by small
random relative amounts:\footnote{True randomness is not necessary; any
  (fixed) sequence of pseudo-random numbers can be used.} 
 with  for all . In practice, a value like  is used. Although our data is in \binaryy, we are quite
aggressive and adopt  or a small multiple
of it. Thus, for , about half of the digits in each entry of the representation are chosen
randomly; therefore, with high probability, eigenvalues do not agree to
many more than  digits.
This has two major effects: () together with the changes in
 (see below), in practice, the probability to encounter  
becomes very low, and () it becomes easier to find suitable shifts such that the
resulting representation satisfies the requirements of relative robustness
and conditional element growth. The positive impact of small 
 on the accuracy is apparent from \eqref{simpleorthobound}
and \eqref{simpleresbound}. Furthermore, as 
discussed below, due to limiting , the computation can be
reorganized for efficiency. Although it might look innocent, the more
aggressive random perturbations lead to much improved robustness: A detailed
discussion can be found in~\cite{Dhillon05gluedmatrices}.\footnote{For a quantitative
  assessment of robustness, see~\cite{mydiss}.} 

\paragraph{Classification of the eigenvalues} Due to the importance of the
-parameter, adjusting it to our requirements is key to the success
of our approach. The parameter influences nearly all stages of the
algorithm; most importantly, the classification of eigenvalues into
well-separated and clustered. As already discussed, the choice of {\it
  gaptol} is restricted by the loss of orthogonality that we are willing to
accept; in practice, the value is often
chosen to be ~\cite{Dhillon:2004:MRRR}.\footnote{For instance,
  LAPACK's {\tt DSTEMR} uses , while {\tt SSTEMR} uses .} As we merely require 
orthogonality of , we accept
more than three orders of magnitude loss of orthogonality. Both terms in
\eqref{simpleorthobound} (and the in practice observed orthogonality)
are proportional to . This means that the value of {\it gaptol} can be chosen as small as . As a consequence, we might select any
 value satisfying

 where the  terms are derived from practice and might be altered slightly.
 Note that  potentially becomes as small
 as  in the single/double case and  in the
 double/quadruple one. If we restrict the analysis to matrices with size , we can
 choose a constant  as small as  and  
 respectively for the single/double and double/quadruple cases. 
 
 With any choice of  complying \eqref{eq:gaptolinterval}, accuracy
 to the desired level is guaranteed, and there is room to choose the specific
 value of , as well as other parameters, to optimize performance or
 parallelism. In particular, by generally reducing the clustering of the
 eigenvalues, the smallest possible value of  provides the greatest parallelism.
 To quantify this statement, for any matrix, we
 define {\it clustering}  formally as the size of the
 largest cluster divided by the matrix size. There are two main advantages
 in decreasing : () the work is reduced as processing the
 largest cluster introduces  
 flops extra work, and () the potential parallelism is increased. A conservative
 estimate of the parallelism of a problem is provided by . For instance,  implies that the problem is {\it embarrassingly parallel}. The
 estimate of parallelism assumes that clusters are processed sequentially,
 while in reality the bulk of the work (the refinement of the eigenvalues and
 the final computation of eigenpairs) can be
 parallelized. Nonetheless, matrices with high clustering still pose
 difficulties to MRRR as they introduce load-balancing issues and
 communication, which considerably reduce the parallel
 scalability~\cite{Vomel:2010:ScaLAPACKsMRRR,VoemelRefinedTree2007tr,mydiss}. 
 Therefore, even if we did not have the desire to guarantee improved accuracy of
 the method, we could use the mixed precision approach to significantly
 enhance parallelism. In this case, the -dependence on the lower
 bound for the value of  would be removed and the bound could be
 loosened by another three orders of magnitude; that is, we could choose a value of
  and  for the single/double and double/quadruple case,
 respectively.\footnote{If we select values  and , we improve the bounds by three orders of magnitude.} Consequently, {\it almost
 all} computations become embarrassingly parallel. 

 As an example, Table~\ref{tab:clustering}
 shows the clustering for double precision Hermite 
 type\footnote{See~\cite{Marques:2008} for information on test matrices.} test matrices of
 various sizes with four distinct classification criteria:\footnote{Criterion I is used in LAPACK~\cite{DesignMRRR} and in results of {\tt
    mr3smp} in~\cite{mr3smp}, which usually uses II. Criterion II is used in
  ScaLAPACK~\cite{Vomel:2010:ScaLAPACKsMRRR} and
  Elemental~\cite{EleMRRR}. In massively parallel computing environments,
  criteria III and IV can (and should) additionally complemented with the
  splitting based on absolute gaps; see also~\cite{mixedtr}.} 
(I) , (II) , combined with splitting based on
the absolute gap as proposed in~\cite{VoemelRefinedTree2007tr} to enhance
parallelism, (III) , and (IV) .
\begin{table}[htb]
\begin{center}
\small
\begin{tabular}{c@{\quad\quad\quad}cccc}
\toprule
Criterion &   \multicolumn{4}{c}{Matrix size} \\
               & 2{,}500 & 5{,}000 & 10{,}000 & 20{,}000 \\
\midrule
I  &  0.70  &         0.86   &  0.93  & 0.97 \\
II &  0.57   &        0.73   &  0.73  & 0.73 \\
III &  4.00e-4  &   2.00e-4   &  1.00e-4  & 5.00e-5  \\
IV &  4.00e-4  &   2.00e-4   &  1.00e-4  & 5.00e-5 \\
\bottomrule\noalign{\smallskip}
\end{tabular} 
\end{center}
\caption{The -parameter effect on clustering .  
}
\label{tab:clustering}
\end{table}
For the latter two criteria, the computations are embarrassingly parallel.
As with this example, experience shows that, thanks to a reduced value of
 as in criteria III or IV, many problems 
become embarrassingly parallel {\em and} guarantee improved accuracy. 
In case , , which not only benefits accuracy by
\eqref{simpleorthobound} and \eqref{simpleresbound}, but also has a 
more dramatic effect: {\it the danger of 
not finding representations that satisfy the requirements is entirely
removed.} This follows from the fact that a satisfactory root representation is 
always found (e.g., by making  definite) and no other
representation needs to be computed. 
Even in cases with , the
number of times Line~\ref{line:mrrr:shifting} of Algorithm~\ref{alg:mrrr}
needs to be executed is often considerably reduced. 

On the downside, selecting a smaller  can result in more work in the
initial approximation\footnote{For instance, if bisection is used to obtain
  initial approximations to the eigenvalues.} and later refinements -- in
both cases, eigenvalues must be approximated to relative accuracy of about , see
\eqref{eq:relaccgaptol}; hence, optimal performance is often not achieved
for the smallest possible value of . 
Moreover, as we discuss below, if one is willing to limit
the choice of , the computation and refinement of eigenvalues can be
done (almost) entirely in -bit arithmetic.\footnote{For the refinement of extreme
  eigenvalues prior to selecting shifts, we still need to resort to
  -bit arithmetic.} If -bit arithmetic is slow, it might be best to
take advantage of the faster -bit arithmetic. And, as we see below as
well, if not the smallest possible value is chosen for , the
requirements the intermediate 
representations must fulfill are relaxed, thereby increasing the robustness
of the method.  

Another corollary of adjusting  is slightly hidden: in
Line~\ref{line:mrrr:shifting} of Algorithm~\ref{alg:mrrr}, we gain more freedom
in selecting  such
that, at the next iteration, the index set 
 splits into two or more subsets. For instance, when choosing
 close to one end of the cluster, we are able to ``back off'' further
away than usual from the end of the cluster in cases where, in a previous
attempt, we did not find a representation satisfying the requirements~\cite{DesignMRRR}. 

We cannot overemphasize the positive effects an adjusted {\em gaptol} has on
robustness and parallel scalability. In particular, in a massively parallel
computing environment, the smallest value for  significantly
improves the parallel scalability. And since many problems become embarrassingly
parallel, the danger of failing to find suitable representations is entirely
removed. 


\paragraph{Arithmetic used to approximate eigenvalues} 
In Lines~\ref{line:mrrr:initialeigvals} and \ref{line:mrrr:refine} of
Algorithm~\ref{alg:mrrr}, eigenvalues are respectively computed and refined
to a specified relative accuracy. 
In both cases, we are given a
representation, which we call  henceforth, and an index set
 that indicates the eigenvalues that need to be approximated. 
When the -bit arithmetic is much slower than the -bit one (say a
factor 10 or more), the use of the latter is preferred: 
One creates a temporary copy of  in \binaryx\ -- called  henceforth
-- that is used for the eigenvalue computation in -bit arithmetic. The creation of 
corresponds to an element-wise relative perturbation of  bounded by
. By the relative robustness of the representation, 

For instance, bisection can be used to compute eigenvalue approximations
 to high relative accuracy, after which  is discarded. As
casting the result back to \binaryy\ causes no additional error, it is  and

where  is a moderate constant given by the bisection method. To first order, by the
triangle inequality, it holds

Provided , by \eqref{eq:relaccgaptol}, -bit arithmetic can be used to approximate the
eigenvalues. Thus, an additional constraint on both the size  and
 arises:
Given a , we must limit the matrix size up to which we do the
computation purely in -bit arithmetic. Similarly, for a given matrix size, we need to adjust
the lower bound on  in \eqref{eq:gaptolinterval}. As an example, if
say , , , and , it is required that that . 
When resorting to -bit arithmetic or if  is chosen too small, one might
respectively verify or refine the result of the -bit eigenvalue computation using
-bit arithmetic without significant costs.\footnote{If the first
  requirement in Definition~\ref{def:RRR} is 
  removed, we can still make use of -bit arithmetic although
  \eqref{eq:accuracyeigvalinxarithmetic} might
  not always be satisfied anymore.} 

\paragraph{Requirements on the representations}
As long as , by \eqref{simpleresbound},
the residual with respect the  is mainly influenced by the local
residual. In our mixed precision approach, without loss of accuracy, it
is possible to allow for  

where we assumed 10 was the original value of . As a result, the
requirement on the conditional element growth is considerably relaxed. 
For instance, in the single/double and double/quadruple cases,
assuming , bounds on  of about  and  are
sufficient, respectively. 
If  is
not chosen as small as possible, the bound on  is loosened in a
similar fashion:

As an example, in the double/quadruple case, assuming  and
 set to ,  would be sufficient to ensure
accuracy. 

\paragraph{Rayleigh quotient iteration}
Our willingness to lose orthogonality up to a certain level, which is
noticeable in the lower bound on , 
is also reflected in \eqref{localresbound}. 
As , we stop the RQI when

where  is . In practice, we take  (or
even ). As a consequence, the iteration is stopped
earlier on, thereby reducing the overall work. 

As a side note: In the rare cases where RQI fails to converge (or as a general alternative to
RQI), we commonly resort to bisection to approximate the eigenvalue
 and then use only one step of RQI (with or without
applying the correction term). In the worst case, we require the eigenvalue to be
approximated to high relative accuracy, ~\cite{Dhillon:2004:Ortvecs}. With mixed precision, we 
relax the condition to , which is less
restrictive if  is not chosen as small as
possible.\footnote{The implied constants being the same and given by the
  requirement of a regular solver based on -bit arithmetic. In a similar way, we
  could say that the Rayleigh quotient correction does not
  improve the eigenvalue essentially anymore 
  if , instead of . We never employed it as such a
  change will hardly have any effect on the computation time.} If
, the restriction on the accuracy of the
approximated eigenvalue is lifted even further~\cite{Willems:Diss}. 

\paragraph{The representation tree} 
Thanks to the random
perturbation of the root representation and a properly adjusted
-parameter, we rarely expect to see large values for . For all
practical purposes, in the case of , we may assume . As a result,
the computation can be rearranged, as discussed
in~\cite{Willems:framework} and summarized in the following: To bound the memory
consumption, a breath-first strategy such as in Algorithm~\ref{alg:mrrr} is used; see for
instance in~\cite{DesignMRRR,mr3smp}. This means that, at
any level of the representation tree, all singletons are processed before the
clusters. A depth-first strategy would instead process entire clusters,
with the
only disadvantage that meanwhile up to  representations need to 
be kept in memory. If  is limited as in our case, the depth-first
strategy can be used without disadvantage. In fact, a depth-first strategy
brings two advantages: () 
copying representations to and from the eigenvector matrix is avoided entirely (see
Section~\ref{sec:memcost} on the benefit for the mixed precision approach) and () if no
suitable representation is found, there is the possibility of
backtracking, that is, we process the cluster again by choosing different
shifts at a higher level of the representation tree. For these reasons, in the mixed
precision approach, a depth-first strategy is preferred. 

\subsection{Memory cost}
\label{sec:memcost}

We stress that in our approach, both input and output are in \binaryx\
format; only {\it internally} (i.e., hidden to a user) -bit
arithmetic is used.
The memory management of an actual implementation of MRRR is affected by the
fact that matrix , which on output contains
the desired eigenvectors, 
is commonly used as intermediate work space. Since  is in \binaryx\ format, whenever , the work space is not sufficient anymore for its customary use: For
each index set  with , a
representation, , is stored in the corresponding columns of
~\cite{DesignMRRR,mr3smp}. 
As these representations consist of  \binaryy\ numbers, this approach
is generally not applicable. However, if we restrict to , we can store the 2 
\binaryy\ numbers whenever a cluster of size four and more is encountered. Thus, the computation
must be reorganized so that at least clusters containing less than four
eigenvalues are processed without storing any data in  temporarily. In
fact, using a depth-first strategy, we remove the need to use  as
temporary storage entirely. 
Immediately after computing an eigenvector
in \binaryy, it is converted to \binaryx, written into , and
discarded. While our approach slightly increases the memory usage, we
do not require much more memory: with  denoting the number of computational
threads, our mixed precision solver still needs only 
\binaryx\ floating point numbers extra work space.  


\section{Practical aspects}
\label{sec:implementation}

We have implemented the mixed precision approach for three cases:
{\it single/double}, {\it double/extended}, and {\it double/quadruple}. The
first solver accepts single precision input and produces single precision
output, but internally uses (hidden to the user) double precision. The
other two are for double precision input/output. The performance of the
solvers, compared with the traditional implementation, depends entirely on
the difference in speed between the two involved arithmetic. 
If the higher precision arithmetic is not much slower (say less
than a factor four), the approach is expected to always work well, even for
sequential executions and relatively small matrices. If the higher
precision arithmetic is considerably slower, the mixed precision approach
might still perform well for large 
matrices. Due to increased parallelism, our approach is also
expected to perform generally well on highly parallel systems. 
Our target application is the computation of a subset of eigenpairs of
large-scale dense Hermitian matrices. For such a scenario, we 
tolerate a slowdown of the tridiagonal eigensolver due to mixed precisions
without affecting performance significantly as the reduction to tridiagonal
form is the performance bottleneck~\cite{EleMRRR,mixedtr}.

\subsection{Implementations}
In Section~\ref{sec:experiments}, we present experimental results of our
implementations. All mixed precision implementations are based on a 
multi-threaded variant of MRRR, {\tt mr3smp}, presented
in~\cite{mr3smp,para2010}, which is built on top of LAPACK's routine {\tt
  DSTEMR} (version 3.2). All codes use
-representations of lower bidiagonal 
factorizations. Bisection is used
for the initial eigenvalue computation if a small 
subset of  eigenpairs is requested or if the
number of executing threads exceeds ~\cite{DesignMRRR,mr3smp}. If
all eigenpairs are requested and the number of threads is less than 12, the fast
sequential {\it dqds algorithm}~\cite{AccurateSVDandQDtrans,dqds99} is used
instead of bisection. As a consequence, speedups compared with the sequential
execution appear less than perfect even for an embarrassingly parallel
computation. 

We did not relax the requirements on the representations
according to \eqref{eq:newkelgbound} and \eqref{eq:newkrrbound}; we only
benefit from the possibility of 
doing so indirectly: If no suitable 
representation is found, the best candidate is chosen, which might still
fulfill the relaxed requirements.  

In the following, we provide
additional comments to all of the mixed precision solvers individually. 
As parameters can take a wide range of values (in particular, , but also  and
) and several design decisions can be made, optimizing a code for performance
is non-trivial as it generally depends on both the specific input and the architecture. 
While we cannot expect to create an ``optimal''
design for all input matrices and architectures, we make design
decisions in a way that in general yields good performance. 
For instance, on
a highly parallel machine one would select a small value for  to
increase parallelism. For testing purposes, we disabled the
classification criterion based on the absolute gaps of the eigenvalues
proposed in~\cite{VoemelRefinedTree2007tr}, which might reduce clustering even
further (it has no consequences for our test cases shown in the next section). 

\paragraph{Single/double} With widespread language and hardware support for
  double precision, the mixed precision approach is most easily implemented
  for the {\it single/double} case. In our test implementation, we fixed
   to . When bisection is used, the initial eigenvalue
  approximation is done to a relative accuracy of . As
  on most machines the double precision arithmetic is not more than a factor two
  slower than the single precision one, we carry out {\it all} computations in
  the former. Data conversion is only necessary when reading the input and
  writing the output. As a result, compared with a double precision solver
  using a depth-first strategy,
  merely a number of convergence criteria and thresholds must be
  adjusted, and the RQI must be performed using a temporary vector that is,
  after convergence, written into the output eigenvector matrix. The mixed precision code
  closely resembles a conventional double precision implementation of MRRR.
\paragraph{Double/extended} Many current architectures have hardware
  support for a 80-bit extended floating point format (see
  Table~\ref{tab:precisions}). As the unit roundoff  is only
  about three orders of magnitude smaller than , we can 
  improve the accuracy of MRRR by this amount. For matrices of moderate size, this means
  that the accuracy becomes comparable to that of the best methods. The main
  advantage of the extended format is that, compared with double precision, its
  arithmetic comes without any or only a small loss in speed. However, we
  cannot make any further adjustments in the algorithm, which 
  positively effect its robustness and parallelism. 
  We do not include results for the {\it double/extended}
case in the next section; however, we tested the approach and experimental
results can be found in~\cite{mydiss,mixedtr}.  
\paragraph{Double/quadruple} As quadruple precision arithmetic is not
  widely supported by today's processors or languages, we had to resort to
  software-simulated arithmetic, which is rather slow. For this reason, we
  used double precision for the initial approximation and for the refinement
  of the eigenvalues. The necessary intermediate data conversions make the
  mixed precision approach slightly more complicated to implement than
  the {\it single/double} one. 
  We used the value  for  in our tests. Further details
  can be found in~\cite{mixedtr}.  

\subsection{Portability} The biggest problem of the mixed precision approach
is a potential lack of support for the involved data types. As single and
double precisions are supported by 
virtually all machines, languages, and compilers, the mixed precision
approach can be incorporated to any linear algebra library for single
precision input/output. However, for double precision input/output, we
need to resort to either 
extended or quadruple precision.  
Not all architectures, languages, and compiler support these formats. For
instance, the 80-bit floating point format is not supported by all
processors. Futhermore, while the FORTRAN {\tt REAL*10} data
type is a non-standard feature of the language and is not supported by all
compilers, a C/C++ code can use the standardized {\tt long double} data type
(introduced in ISO C99) that achieves the 
desired result on most architectures that support 80-bit arithmetic. 
For the use of quadruple precision, there are presently two major drawbacks:
() it is usually not supported in hardware, which means that one has to resort to
a rather slow software-simulated arithmetic, and () the support from compilers  
and languages is rather limited. 
While FORTRAN has a {\tt REAL*16}
data type, the quadruple precision data type in C/C++ is compiler-dependent:
  for instance, there exist the {\tt \rule{8pt}{0.5pt}float128} and {\tt
  \rule{4pt}{0.5pt}Quad} data types for the GNU and Intel
compilers, respectively. An external library implementing the
software arithmetic might be used for portability. In all cases, the
performance of quadruple arithmetic depends on its specific 
implementation. It is however likely that the hardware/software support for
quadruple precision will be improved in the near future.  




\section{Experimental Results}
\label{sec:experiments}

All tests, in this section, were run on a multi-processors system comprising four
eight-core {\it Intel Xeon X7550 Beckton} processors, with a nominal clock
speed of 2.0 GHz. 
Subsequently, we refer to this
machine as {\sc Beckton}. We used LAPACK version
3.4.2 and linked the library with the vendor-tuned MKL BLAS version
12.1. In addition to the results for LAPACK's routines and our mixed
precision solvers, we also include results for {\tt
mr3smp}~\cite{mr3smp}. All routines were compiled with
Intel's compiler version 12.1 and optimization level {\tt -O3} enabled.
Although we present only results for computing {\it all}
eigenpairs (LAPACK's DC does not allow the computation of subsets), we
mention that {\it MRRR's strength and main application lies in the
  computation of subsets of 
eigenpairs}. 

For our tests, we used matrices of size ranging from  to
 (in steps of ) of six different types: uniform eigenvalue distribution,
geometric eigenvalue distribution, 1--2--1, Clement, Wilkinson, and Hermite. The
dimension of the Wilkinson type matrices is , as they are
only defined for odd sizes. Details on these matrix types can be found
in~\cite{Marques:2008}. 
To help the exposition of the results, in the accuracy plots, the matrices
are sorted by type first and then by size; vice versa, in the plots relative
to timings, the matrices are sorted by size first and then by type.  

Figure~\ref{fig:accartifial32coresingle} shows
timings and accuracy for single precision inputs. 
\begin{figure}[bth]
   \centering   
   \subfigure[Execution time: sequential.]{
     \includegraphics[width=.47\textwidth]{figures/fig1a.eps}
   \label{fig:accartifial32coresinglea}
   } \subfigure[Execution time: multi-threaded.]{
     \includegraphics[width=.47\textwidth]{figures/fig1b.eps}
   \label{fig:accartifial32coresingleb}
   }

   \subfigure[Largest residual norm.]{
     \includegraphics[width=.47\textwidth]{figures/fig1c.eps}
   \label{fig:accartifial32coresinglec}
   } \subfigure[Orthogonality.]{
     \includegraphics[width=.47\textwidth]{figures/fig1d.eps}
   \label{fig:accartifial32coresingled}
   }

   \caption{
     Time and accuracy on {\sc Beckton}. Timings are presented in a
     logarithmic scale. The largest residual norm and the orthogonality are
     measured as in~\eqref{def:defresortho}. The dotted black line
     corresponds to unit round-off . As there exist no parallel MRRR for
     single precision, we show timings for our mixed precision approach and
     {\tt SSTEDC} only. 
   }
   \label{fig:accartifial32coresingle}
\end{figure}
As a reference, we include
results for LAPACK's {\tt SSTEMR} (MRRR) and {\tt SSTEDC} (Divide \& Conquer). 
As shown in Fig.~\ref{fig:accartifial32coresinglea}, even in a sequential execution, our mixed precision approach is up to an
order of magnitude {\it faster} than LAPACK's {\tt SSTEMR}. For one type of
matrices, {\tt SSTEDC} 
is considerably faster than for all 
the others. These are the Wilkinson matrices, which represent a class of
matrices that allow for heavy deflation within the Divide \& Conquer
approach. For all other matrices, which do 
not allow such extensive deflation, our solver is {\it faster} than {\tt
  SSTEDC}. As seen in Fig.~\ref{fig:accartifial32coresingleb}, in a
parallel execution, the performance gap for the Wilkinson matrices almost
entirely vanishes, while for the other matrices our solver remains up to an order of magnitude
faster than {\tt SSTEDC}.  
As depicted in Figs.~\ref{fig:accartifial32coresinglec}--\subref{fig:accartifial32coresingled},
our routine is not only as accurate as
desired but it is the most accurate one. For single precision input/output
arguments, we obtain a solver that is more accurate {\it and} faster than the
original single precision solver. In addition,
the solver is more scalable, and more robust. In 38 out of the 48 test cases,
{\tt SSTEMR} accepted representations that did {\em not} pass the test for
relative robustness, thereby jeopardizing the accuracy of the
result. In contrast, using mixed precisions, our solver was able to find
suitable representations in all cases.

We now turn our attention to double precision inputs/outputs, for which timings and
accuracy are presented in Fig.~\ref{fig:accartifial32core}. 
We included the results for the multi-threaded solver {\tt mr3smp}, which 
in the sequential case is just a wrapper to {\tt DSTEMR}. In general,  {\tt
  mr3smp} obtains accuracy equivalent to 
LAPACK's {\tt DSTEMR}.  
\begin{figure}[tbh]
   \centering   
   \subfigure[Execution time: sequential.]{
     \includegraphics[width=.47\textwidth]{figures/fig2a.eps}
     \label{fig:accartifial32corea}
   } \subfigure[Execution time: multi-threaded.]{
     \includegraphics[width=.47\textwidth]{figures/fig2b.eps}
     \label{fig:accartifial32coreb}
   }

   \subfigure[Largest residual norm.]{
     \includegraphics[width=.47\textwidth]{figures/fig2c.eps}
     \label{fig:accartifial32corec}
   } \subfigure[Orthogonality.]{
     \includegraphics[width=.47\textwidth]{figures/fig2d.eps}
     \label{fig:accartifial32cored}
   }
   \caption{
     Time and accuracy on {\sc Beckton}. Timings are presented in a
     logarithmic scale. The largest residual and the orthogonality are
     measured as in~\eqref{def:defresortho}. The dotted black line
     corresponds to unit round-off  and the accuracy of {\tt mr3smp} is
     equivalent to the one obtained by LAPACK's {\tt DSTEMR}.   
   }
   \label{fig:accartifial32core}
\end{figure}

Figure~\ref{fig:accartifial32corea} shows the timings for 
sequential executions. Our mixed precision solver is slower than {\tt DSTEMR}, which is not
a surprise, as we make use of {\it software-simulated} quadruple precision
arithmetic. What might be a surprise is that, even with the use of such slow
arithmetic, for large matrices, our solver is usually as fast as {\tt
  DSTEDC}. As in the single precision case, only for matrices that allow
for substantial deflation, {\tt
  DSTEDC} is considerably faster. As Fig.~\ref{fig:accartifial32coreb}
shows, for a parallel execution, the performance difference reduces and is
expected to eventually vanish as it does already for the a regular MRRR
implementation~\cite{EleMRRR}. For matrices that do not allow for extensive
deflation, our solver is about a factor two faster than {\tt DSTEDC}. 

 While {\tt DSTEMR} accepted in 29 out of the 48 test cases representations
 that did not pass the test for relative robustness, our mixed precision
 solver found suitable representations in all cases. In fact, 
for all but the Wilkinson type matrices, we have  and as a
consequence: {\it no danger of failing} to find suitable representations and
{\it embarrassingly parallel} computation. 
Even for Wilkinson type matrices,  was limited to one
and clustering  was limited to . 
For {\tt DSTEMR},  was as high as 21 and clustering  was
about  on average, which should 
be compared with the value of about  for the mixed precision solver.
Therefore, we
believe that our approach is especially well-suited for highly parallel
systems. In particular, solvers for distributed-memory systems should greatly
benefit from better load-balancing and reduced communication. 

For single precision inputs [Figs.~\ref{fig:accartifial32coresinglea}--\subref{fig:accartifial32coresingleb}]
or in a parallel stetting [Fig.~\ref{fig:accartifial32coreb}], our tridiagonal
eigensolver is highly competitive in terms of execution time --
often faster -- compared with Divide \& Conquer and the
conventional MRRR. As a consequence, when used in context of dense Hermitian
eigenproblems, the accuracy improvement of the tridiagonal stage carry over to the
overall accuracy {\it without any penalty in terms of performance}. Such a
behavior is illustrated by
Fig.~\ref{fig:accartifial32coredense}, where we present timings and orthogonality
for dense, real symmetric input matrices. 
\begin{figure}[tbh]
   \centering   
   \subfigure[Execution time: multi-threaded.]{
     \includegraphics[width=.47\textwidth]{figures/fig3a.eps}
     \label{fig:accartifial32coredensea}
   } \subfigure[Orthogonality.]{
     \includegraphics[width=.47\textwidth]{figures/fig3b.eps}
     \label{fig:accartifial32coredenseb}
   }
   \caption{
     Time and orthogonality for computing all eigenpairs of dense, real
     symmetric matrices. Timings are presented in a
     logarithmic scale and are dominated by the reduction to tridiagonal
     form.    
   }
   \label{fig:accartifial32coredense}
\end{figure}
The inputs were generated by applying random orthogonal similarity
transformations to the tridiagonal matrices of the previous experiments:
, with random orthogonal matrix . 
For small matrices in a sequential execution, our approach
introduces extra overhead -- see Fig.~\ref{fig:accartifial32corea}. Since 
the tridiagonal solver only requires  operations to compute 
eigenpairs, while the reduction to tridiagonal form requires
 operations, for sufficiently large matrices the overhead is
completely negligible. {\em Such a statement would even more apply if the matrices were
complex-valued and/or only a subset of eigenpairs were computed, since the
reduction to tridiagonal form would carry even more
weight relative to the tridiagonal stage.} 
In a parallel execution, the mixed precision approach is competitive even
for relatively small matrices [Fig.~\ref{fig:accartifial32coredensea}]; at
the same time, the approach significantly 
improves orthogonality [Fig.~\ref{fig:accartifial32coredenseb}]. Further
experiments, including  
subset computations and complex-valued inputs, can be found in~\cite{mydiss,mixedtr}.  


\section{Conclusions}

We presented a mixed precision variant of the MRRR algorithm, which addresses a
number potential weaknesses of MRRR such as () inferior
accuracy compared with the Divide \& Conquer method or the QR algorithm;
() the danger of not finding suitable representations; and () for distributed-memory
architectures, load-balancing and
communication problems for matrices with large clustering of the
eigenvalues. Our approach provides a
new perspective: Given input/output arguments in a \binaryx\ floating
point format, we use a higher precision \binaryy\ arithmetic to
obtain the desired accuracy. As our analysis shows, the use of higher
precision provides us with freedom in setting important parameters of the
algorithm. In particular, we select these parameters to reduce the operation count,
increase robustness, and improve parallelism; at the same time, we meet
more stringent accuracy goals. Due to these changes, our mixed precision
approach is not only as accurate as the Divide \& Conquer method or the QR algorithm but -- under many
circumstances --  is also faster than  
these methods or even faster than a conventional implementation of MRRR. 

This work was mainly motivated by the results of MRRR-based eigensolvers for
dense Hermitian problems~\cite{EleMRRR}. In the context of dense
eigenproblems, the tridiagonal stage is often completely negligible
in terms of execution time: to compute  eigenpairs of a tridiagonal matrix, it
only requires  operations; the reduction to
tridiagonal form requires  operations and is the performance
bottleneck. In terms of accuracy, the 
tridiagonal stage is responsible for most of the loss of orthogonality. The
natural question was whether it is possible to improve the accuracy to the
level of the best methods without sacrificing too much performance. As
our results show, this is indeed possible. In fact, our mixed precision
solvers are even more accurate than the ones based on Divide \& Conquer and
QR, and remain as fast, or faster, than the classical MRRR. 
Finally, an important feature of the mixed precision approach is a
considerably increased robustness 
and parallel scalability. 



\footnotesize
\bibliographystyle{abbrv}
\bibliography{mixed}


\end{document}
