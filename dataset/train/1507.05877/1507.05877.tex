\documentclass[english]{tlp}

\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{aopmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{multirow}

\newtheorem{example}{Example}       \newtheorem{definition}{Definition} 


\newcommand{\tts}{\tt \small}
\renewcommand{\b}{\hspace{-.4mm}}
\newcommand{\wrt}{w.r.t.\ }
\newcommand{\If}{\leftarrow}
\newcommand{\Imp}{\rightarrow}
\newcommand{\Iff}{\leftrightarrow}
\newcommand{\IF}{\Leftarrow}
\newcommand{\IMP}{\Rightarrow}
\newcommand{\IFF}{\Leftrightarrow}
\newcommand{\diff}{\!\neq\!}
\newcommand{\gr}{\!>\!}
\newcommand{\greq}{\!\geq\!}
\newcommand{\less}{\!<\!}
\newcommand{\lesseq}{\!\leq\!}
\newcommand{\mgu}{\textit{mgu}}
\newcommand{\vars}{\textit{vars}}
\newcommand{\true}{\textit{true}}
\newcommand{\false}{\textit{false}}
\newcommand{\hd}{\textit{hd}}
\newcommand{\bd}{\textit{bd}}

\newcommand{\down}{\rule{0mm}{3.5mm}}
\newcommand{\band}{\rule{0mm}{3mm}}

\newcommand{\bbL}{\{\hspace{-3pt}\{}
\newcommand{\bbR}{\}\hspace{-3pt}\}}

\newcommand{\aaL}{\langle{\hspace*{-2.5pt}}\langle}
\newcommand{\aaR}{\rangle{\hspace*{-2.5pt}}\rangle}

\newcommand{\andw}
{\,{\scriptstyle{\wedge}}\hspace{-5.2pt}{\scriptstyle{\wedge}}\,} 
\newcommand{\orv}
{\,{\scriptstyle{\vee}}\hspace{-5.2pt}{\scriptstyle{\vee}}\,} 
\newcommand{\eop}{\hfill}
\usepackage{color}
\newcommand{\comment}[1]{\noindent{\color{red}#1}}

\newcommand{\exm}

\title{Proving Correctness of Imperative Programs by Linearizing Constrained Horn Clauses}


\author[E. De~Angelis, F. Fioravanti, A. Pettorossi, M. Proietti]
{EMANUELE DE ANGELIS, FABIO FIORAVANTI\\
DEC, University `G. d'Annunzio', Pescara, Italy\\
\email{\{emanuele.deangelis,fabio.fioravanti\}@unich.it}
\and
ALBERTO PETTOROSSI\\
DICII, Universit\`a di Roma Tor Vergata, Roma, Italy\\
\email{pettorossi@disp.uniroma2.it}
\and
MAURIZIO PROIETTI\\
CNR-IASI, Roma, Italy\\
\email{maurizio.proietti@iasi.cnr.it} 
}

\begin{document}

\pagestyle{plain}


\maketitle

\begin{abstract}
We present a method for verifying the correctness of 
imperative programs which is based on the automated transformation 
of their specifications.
Given a program \textit{prog}, we consider a partial correctness 
specification of the form
,
where the assertions  and~ are predicates
defined by a set~\textit{Spec} of possibly recursive 
Horn clauses with linear arithmetic ({\it LA})
constraints in their premise (also called {\it constrained Horn clauses}).
The verification method consists in
constructing  a set \textit{PC} of constrained Horn clauses
whose satisfiability implies that  is valid.
We highlight some limitations of state-of-the-art constrained Horn clause solving
methods, here called {\it{LA-solving methods}}, 
which prove the satisfiability of the clauses  by looking for linear arithmetic interpretations of the 
predicates. 
In particular, we prove that there exist some specifications 
that cannot be 
proved valid by any of those {\it LA}-solving methods. 
These specifications require the proof
of satisfiability of a set \textit{PC} of constrained Horn clauses that contain
{\it nonlinear clauses} (that is, clauses with more than one atom in their premise).
Then, we present a transformation, called {\it linearization}, that 
converts \textit{PC} into
a set of {\it linear} clauses (that is, clauses with at most one 
atom in their premise).
We show that several specifications 
that could not be proved valid by  {\it LA}-solving  methods,
can be proved valid after linearization.
We also present a strategy for performing linearization in an automatic way and
we report on some experimental results obtained by using a preliminary implementation
of our method.

\medskip

\noindent
{\em To appear in Theory and Practice of Logic Programming (TPLP), Proceedings of ICLP 2015.}

\end{abstract}


\begin{keywords}
Program verification,
Partial  correctness specifications,
Horn clauses,
Constraint Logic Programming,
Program transformation.\vspace{-2mm}
\end{keywords}


\section{Introduction}
\label{sec:intro}

One of the most established methodologies for specifying
and proving the correctness of imperative programs is based on the 
Floyd-Hoare axiomatic approach
(see~\cite{Hoa69}, and also~\cite{Ap&09} for a recent presentation dealing with 
both sequential and concurrent programs). 
By following this approach, the {\it partial correctness} of a program 
\textit{prog} is formalized by a triple
, also called {\it partial 
correctness specification}, 
where the {\it precondition}  and the
{\it postcondition}  are assertions in
first order logic, meaning that
if the input values of \textit{prog} satisfy 
and program execution terminates, then the output values satisfy~.

It is well-known that the problem of checking
partial correctness of programs with respect to given 
preconditions and postconditions
is undecidable. 
In particular, the undecidability of partial correctness is due to the fact
that in order to prove in Hoare logic the validity of a 
triple , 
one has to look for suitable auxiliary assertions, 
the so-called {\it invariants}, in an infinite space of formulas, and also
to cope with the undecidability of logical consequence.

Thus, the best way of addressing the problem of the automatic verification of
programs is to design {\it incomplete} methods, that is, methods
based on restrictions of first order logic, which work well in the practical cases of interest.
To achieve this goal, some methods proposed in the literature
in recent years use 
{\it linear arithmetic constraints} as the assertion language and {\it constrained 
Horn clauses} as the formalism to express and reason about program 
correctness~\cite{Bj&12,De&14c,Gr&12,Ja&12,Pe&98,PoR07,Ru&13}.

Constrained Horn clauses are clauses with {\it at most one} atom in their conclusion and a conjunction of atoms
and constraints over a given domain in their premise. In this paper 
we will only consider constrained Horn clauses with linear arithmetic constraints.
The use of  this formalism has the advantage that logical consequence 
for linear arithmetic constraints is decidable and, moreover, 
reasoning within constrained Horn clauses is supported by very effective
automated tools, such as {\it Satisfiability Modulo Theories} (SMT)
solvers~\cite{DeB08,MaS13,Ru&13} and
{\it constraint logic programming} (CLP) inference systems~\cite{JaM94}.
However, current approaches to correctness proofs based on constrained Horn clauses 
have the disadvantage that they only consider specifications whose preconditions and  
postconditions are linear arithmetic constraints.

In this paper we overcome this limitation and propose an approach 
to proving general specifications of the form 
, where  
and~ are predicates defined by a set of possibly recursive constrained Horn clauses 
(not simply linear arithmetic constraints), 
and {\it prog} is a program written in a C-like imperative language.

First, we indicate how to construct 
a set \textit{PC}  of constrained Horn clauses (\textit{PC} stands for 
partial correctness), 
starting from: (i)~the assertions  and , 
(ii)~the program~\textit{prog}, and (iii)~the 
definition of the operational semantics of the language in which
 \textit{prog} is written, 
such that, if  is satisfiable, then the partial correctness 
specification  is valid.

Then, we formally show that there are sets \textit{PC} of constrained Horn clauses
encoding partial correctness specifications, whose satisfiability cannot  be
proved by current methods,
here collectively called {\it \mbox{{\textit {LA}}-solving} methods}
({\it LA} stands for linear arithmetic).
This limitation is due to the fact that 
\mbox{{\textit {LA}}-solving} methods try to prove satisfiability
by interpreting the predicates as linear arithmetic constraints.

For these problematic specifications, the set~\textit{PC} of constrained Horn clauses contains
{\it nonlinear} clauses, that is, clauses with more than one atom in their premise.

Next, we present a transformation, which we 
call {\it linearization}, that 
converts the set \textit{PC} into
a set of {\it linear} clauses, that is, clauses with at most one 
atom in their premise.
We show that linearization preserves satisfiability and also 
increases the power of {\textit {LA}}-solving, in the sense that
several specifications that could not be proved valid by {\textit {LA}}-solving methods,
can be proved valid after linearization.
Thus, linearization followed by {\textit {LA}}-solving is 
strictly more powerful than {\textit {LA}}-solving alone.

The paper is organized as follows. In Section~\ref{sec:encoding}
we show how a class of partial correctness specifications can be translated into
constrained Horn clauses.
In Section~\ref{sec:Limitations} we prove that {\textit {LA}}-solving methods
are inherently incomplete for proving the satisfiability of constrained Horn clauses.
In Section~\ref{sec:transform} we present a strategy for automatically performing 
the linearization transformation,
we prove that it preserves {\textit {LA}}-solvability, and (in some cases) it is able to
transform constrained Horn clauses that are not {\textit {LA}}-solvable into
constrained Horn clauses that are {\textit {LA}}-solvable. 
Finally, in Section~\ref{sec:experiments}
we report on some preliminary experimental results obtained by using
a proof-of-concept implementation of the method.

\section{Translating Partial Correctness into Constrained Horn Clauses}
\label{sec:encoding}


We consider a C-like imperative programming language with integer 
variables, assignments, conditionals, while loops, and goto's.
An imperative  program is a sequence of labeled commands (or commands, for short), 
and in each program there is a unique
 command that, when executed, causes program termination.

The semantics of our language is defined by a {\it transition relation},  denoted 
, between {\it configurations}. Each configuration is a pair
 of a labeled command~ and an 
{\it environment}~.
An {environment}~ is a function 
that maps every integer variable identifier  to its value  
in the integers~.
The definition of the relation  is similar to that of the
`{small step}' operational semantics presented in~\cite{Rey98},
and is omitted.
Given\,a\,program \textit{prog},\,we\,denote\,by 
 its\,first\,labeled command.

We assume that all program executions are {\it deterministic} in the sense that,
for every environment~,
there exists a unique, maximal (possibly infinite) 
sequence of configurations, called {\it computation sequence}, 
of the form: 
\mbox{} .
We also assume that every {\it finite} computation sequence ends in the configuration
, for some environment .
We say that  a program \textit{prog}  {\it terminates} for~ iff 
the computation sequence
starting from the initial configuration  
is finite.

\newpage

\subsection{Specifying Program Correctness}
\label{subsec:Spec}


First we need the following notions about constraints, 
constraint logic programming, and constrained Horn clauses. 
For related notions with which the reader is not
 familiar, he may refer to~\cite{JaM94,Llo87}.

A \textit{constraint}
is a linear arithmetic equality (=) or inequality ()
over the integers~, or a conjunction
or a disjunction of constraints. For example, 
 is a constraint.
We feel free to say
`linear arithmetic constraint', instead of `constraint'.
We denote by~ the set of all constraints.
An {\it atom} is an atomic formula of the form ,
where  is a predicate symbol not in  and 
 are terms.
Let {\it Atom} be the set of all atoms.
A~{\it definite clause} is an implication of the form  
, where in the conclusion (or {\it head\/})  is an atom, 
and in the
premise (or {\it body\/})  is a constraint, and~ is a (possibly empty)
conjunction of atoms.
A~{\it constrained goal} (or simply, a {\it goal}\/) is  an implication of the form  
.
A~{\it constrained Horn clause} (CHC) (or simply, a {\it clause}) 
is either a definite 
clause or a constrained goal. 
A {\it constraint logic program} (or simply, a CLP {\it program})  
is a set of definite clauses.
A~clause {\it over the integers} is a clause that has no function 
symbols except for integer constants, addition, and
multiplication by integer constants.

The semantics of a constraint  
is defined in terms of the usual interpretation, denoted by ,
over the integers . We write  to denote
that  is true in~.
Given a set  of constrained Horn clauses, an
{\it LA-interpretation} is an interpretation for the language of
 that agrees with {\it LA}
on the language of the constraints.
An {\it LA-model} of  
is an {\it LA-interpretation} that makes all clauses of  true.
A set of constrained Horn clauses is {\it satisfiable} if it has an {\it LA-model}.
A CLP program  is always satisfiable and has a 
{\it least -model}, denoted . 
We have that a set  of constrained Horn clauses is {\it satisfiable} iff 
, where~ is a CLP program,  is a set  of goals, and
.
Given a first order formula , we denote by 
its {\it existential closure} and by  its 
{\it universal closure}.


Throughout the paper we will consider partial correctness 
specifications which are particular triples of the form
\mbox{ {\textit{prog}} } defined as follows.
\vspace{-1mm}

\begin{definition}[{{Functional Horn Specification}}]\label{def:spec} 
{\rm 
A partial correctness triple
\mbox{ {\textit{prog}} } is said to be a {\it functional Horn specification} if the following 
assumptions hold, where the predicates  and  are 
assumed to be defined by a CLP program \textit{Spec\/}:

\noindent\hangindent=4mm
(1)  is the formula: 
,
where  are the variables occurring in \textit{prog}, and
  are variables (distinct from the~'s), called
{\it parameters} (informally,   determines the 
initial values of the 's); 

\noindent\hangindent=4mm
(2)   is the atom , 
where  is a variable in  (informally, 
 is the variable whose final value is the result of 
the computation of~\textit{prog});

\noindent\hangindent=4mm
(3) \textit{f}\/ is a relation which is  {\it total on pre\/} and {\it functional}, in the sense that 
the following two properties hold (informally,  is the function
computed by \textit{prog}):

(3.1)\,.
. \nopagebreak

(3.2)\,. .~\eop
}\vspace*{-1mm}
\end{definition}

\noindent
We say that a functional Horn 
specification \mbox{ {\textit{prog}} } 
is {\it valid\/}, or \textit{prog} is 
partially correct with respect to  and , iff
for all environments
 and ,

\noindent 
{\it if}  holds (in words,   satisfies \textit{pre}) 
and  
\mbox{} holds (in words, 
\textit{prog} terminates for ) holds, 
{\it then}  holds (in words,  satisfies the postcondition).

The relation 
computed by \textit{prog} according to the operational semantics of 
the imperative language, is defined by the CLP 
program~\textit{OpSem} made out of: (i)~the following clause~
(where, as usual, variables are denoted by upper-case letters):

\noindent
.~~~ 

\noindent
where:

\noindent\hangindent=5mm
(i.1)~
represents the initial configuration , where the variables
 are bound to the values , respectively,
and  holds,

\noindent\hangindent=5mm
(i.2)~ represents the transitive closure
 of the transition relation , 
which in turn is represented by a predicate  
that encodes the operational semantics, that is, the
{\it interpreter} of our imperative language,
by relating a source configuration  to a target configuration ,

\noindent\hangindent=5mm
(i.3)~ represents the final configuration 
, where the variable  is bound to the value ,

\noindent
and (ii)~the clauses for the predicates 
 and 
. The 
clauses for the predicate  are defined 
as indicated in~\cite{De&14c},
and are omitted for reasons of space.


\vspace{-1mm}
\begin{example}[Fibonacci Numbers]\label{ex:fib}
\begin{rm}
Let us consider the following program \textit{fibonacci}, that returns as value of
{\tt u} 
the {\tt n}-th Fibonacci number, for any {\tt n} , having 
initialized {\tt u} 
to {\tt 1} and {\tt v} to {\tt 0}.
\vspace{.5mm}

\noindent
{\textit{fibonacci}}

\vspace{.5mm}
\noindent
The following is a functional Horn specification of the partial correctness of the program \textit{fibonacci}:

\hspace{10mm}{\rm{\{}}{\tt n=N,\,N>=0,\,u=1,\,v=0,\,t=0}{\rm{\}}} ~~~~{\textit{fibonacci}}~~~~
{\rm{\{}}{\tt fib(N,u)}{\rm{\}}}\hfill \nopagebreak

\noindent
where {\tt N} is a parameter and 
{\tt fib} is defined by the following CLP program:

\vspace{.5mm}
\noindent

\noindent


\vspace{.5mm}
\noindent

\noindent
For reasons of conciseness, in the above specification  we have 
slightly deviated from Definition~\ref{def:spec}. In particular, 
we did not introduce the predicate symbol {\it pre}, and 
in the precondition and postcondition 
we did not introduce the parameters which have constant values.

The relation {\tt r\_fibonacci} computed by the program \textit{fibonacci} 
according to the operational semantics,
is defined by the following CLP program:


\noindent
\textit{OpSem}_{\textit{\small fibonacci}}

\smallskip
\noindent
where: (i)~{\tt firstCmd(LC)} holds for the command
with label {\tt 0} of the  program \textit{fibo\-nacci};
(ii)~{\tt env((x,X),E)}  holds iff in the environment {\tt E} the variable 
{\tt x} is bound to the value of {\tt X};
(iii)~in the initial configuration {\tt C0} the environment {\tt E}
binds the variables {\tt n}, {\tt u}, {\tt v}, {\tt t} 
to the values
{\tt N} ({\tt >=0}), {\tt 1}, {\tt 0}, and {\tt 0}, respectively; and
(iv)~{\tt haltCmd(LC)} holds for the labeled command {\tt h:\,halt}.\eop
\end{rm}
\end{example}


\subsection{Encoding Specifications into Constrained Horn Clauses}
\label{subsec:PC}

In this section we present the encoding of the 
validity problem of functional Horn specifications into the satisfiability 
problem of CHC's.
 
For reasons of simplicity we assume that in \textit{Spec} 
no predicate depends on  (possibly, except for  itself),
that is,  \textit{Spec} can be partitioned into two sets of clauses,
call them 
and , where 
is the set of clauses with head predicate~ and~ does not occur in \textit{Aux}. 

\vspace{-2mm}



\begin{theorem}[{Partial Correctness}]\label{thm:pc}
Let  be the set of goals derived from 
 as follows\ \ 
for each clause  of the form 
,

\noindent
\hangindent=5.5mm
~every occurrence of  in  
(and, in particular, in~) is replaced by , 
thereby deriving a clause~ of the form\/: 
, 

\noindent
\hangindent=5.5mm
 clause  is replaced by the goal : 
, where  is a new variable, and



\noindent
\hangindent=0mm
  goal  is replaced by the following two goals:



~~.~ 

~~.~ 





\hangindent=0mm
\noindent
Let  be the set 
 of CHC's.
We have that: if  is satisfiable,
then \mbox{} 
is valid.\eop
\end{theorem}

\vspace{-1mm}
\noindent
The proof of this theorem and of the other facts presented in this
paper can be found in the online appendix.
In our Fibonacci example  (see Example~\ref{ex:fib})
 the set   of clauses 
is the entire set  
and . 
According to Points~(1)--(3) of Theorem~\ref{thm:pc},
from  we derive the following six 
goals: 

{\small
\smallskip
\noindent
{\tt{G1. false :- F>1, r\_fibonacci(0,F).}}\nopagebreak
\hspace{10mm}

\noindent
{\tt{G2. false :- F<1, r\_fibonacci(0,F).}}\nopagebreak

\noindent
{\tt{G3. false :- F>1, r\_fibonacci(1,F).}}\nopagebreak
\hspace{10mm}

\noindent
{\tt{G4. false :- F<1, r\_fibonacci(1,F).}}

\noindent
{\tt{G5. false :- N1>=0, N2=N1+1, N3=N2+1, F3>F1+F2,}}\nopagebreak 

\hspace{18mm}{\tt{r\_fibonacci(N1,F1), r\_fibonacci(N2,F2), r\_fibonacci(N3,F3).}}
         
\noindent  
{\tt{G6. false :- N1>=0, N2=N1+1, N3=N2+1, F3<F1+F2,}}\nopagebreak

\hspace{18mm}{\tt{r\_fibonacci(N1,F1), r\_fibonacci(N2,F2), r\_fibonacci(N3,F3).}}  

} 

\noindent
Thus, in order to prove 
the validity of the specification~ above, 
since ,
it is enough to show that the set
 of CHC's  
is satisfiable.

\section{A Limitation of {\textit{LA}}-solving Methods}
\label{sec:Limitations}

Now we show that there are sets of CHC's that encode
partial correctness specifications whose 
satisfiability cannot be proved by {\textit {LA}}-solving methods.

A {\it symbolic interpretation} is a function  such that, for every  and substitution , 
.
Given a set  of CHC's, a symbolic interpretation  is an 
-{\it solution}
of  iff, for every clause  in , 
we have that
.

We say that a set  of CHC's is {\textit {LA-solvable}} 
if there exists an {\textit {LA}}-solution of~.
Clearly, if a  set of CHC's is {\textit {LA}}-solvable, then it is satisfiable.
The converse does not hold as we now show.

\vspace{-1mm}
\begin{theorem}\label{thm:limitation}
	There are sets of 
	constrained Horn clauses which are satisfiable and not \mbox{{\textit {LA}}-solvable}.\end{theorem}

\vspace{-2mm}
\noindent
{\it Proof.}
Let  be the
set of clauses that encode the validity of the Fibonacci 
specification~.
 is satisfiable, because
 holds iff  is the
-th Fibonacci number, and hence the bodies of 
 are false.
(This fact will also be proved by the automatic method presented in 
Section~\ref{sec:transform}.)

Now we prove, by contradiction, that 
 is not {\textit {LA}}-solvable.
Suppose that there exists an {\textit {LA}}-solution  
of .
Let  be a constraint .
To keep our proof simple, we assume that  is defined by a 
conjunction of linear arithmetic inequalities (that is,  
is a convex constraint), 
but our argument can easily be generalized to any constraint in~.
By the definition of {\textit {LA}}-solution, we have that:



{\small{
\noindent
 {{}} 
		
\noindent
 {{}} }}
	
\noindent
Property~ follows from the fact that, in particular, an 
\textit{LA}-solution satisfies goal~{\tt G5}.
Property~ follows from the fact that an \textit{LA}-solution 
satisfies all clauses of 
 and
 defines the 
{\it least\/}  relation that satisfies 
those clauses.

From Property  and from the fact that  
holds iff  is the
-th Fibonacci number (and hence {\tt F} is an exponential 
function of {\tt N}), 
it follows that {\tt c(N,F)} is a conjunction of the form 
,
where, for , with ,  is
either 
(A)~, for some integer , or 
(B)~. 
(No constraints of the form 
are possible, as shown in Figure~\ref{fig:fib-constraint}.)

\begin{figure}[!ht]
\vspace{-2mm}
\centering
\includegraphics[50mm,209mm][160mm,252mm]{DFPP_ICLP-15_Figure1.ps}
\caption{The relation {\tt r\_fibonacci(N,F)} and the convex constraint 
{\tt c(N,F)}.\label{fig:fib-constraint}
}
\vspace{-2mm}
\end{figure}

\noindent
By replacing {\tt c(N1,F1)}, {\tt c(N2,F2)}, and {\tt c(N3,F3)}
by the corresponding conjunctions of atomic constraints of the forms (A) and (B), and eliminating the occurrences of
{\tt F1}, {\tt F2}, {\tt N2}, and {\tt N3}, from  we get:

{\small{
\noindent
 
}}

\noindent
where, for ,  is a linear polynomial in the variable  {\tt N1}.
Then, the constraint  is satisfiable
and Property~ is false. Thus, 
the assumption 
that   is {\textit {LA}}-solvable is false,
and we get the thesis.
\hfill\eop

\section{Increasing the Power of LA-Solving Methods by Linearization}
\label{sec:transform}



A weakness of the {\it LA}-solving methods
is that they look for -solutions constructed from single atoms, 
and by doing so they may fail to discover that a goal is satisfiable 
because a conjunction of atoms in its premise is unsatisfiable,
in spite of the fact that {each of its conjoint atoms is} satisfiable.
For instance, in our Fibonacci example  the premise of 
goal~{\tt G5} contains three atoms with predicate {\tts r\_fibonacci} and our proof
of Section \ref{sec:Limitations} shows that, even if the premise of~{\tt G5}
is unsatisfiable, there is no constraint which is an -solution of the 
clauses defining
{\tts r\_fibonacci} that, when substituted for each {\tts r\_fibonacci} atom, 
makes that premise false.
Thus, the notion of -solution
shows some weakness when dealing with 
{\it nonlinear} clauses, that is, clauses whose premise 
contains more than one atom (besides constraints).

In this section we present an automatic transformation of
constrained Horn clauses that has the objective of increasing the power of
 -solving methods. 
 
The core of the transformation, called {\it linearization}, 
takes a set of possibly 
nonlinear constrained Horn clauses and transforms it
 into a set of {\it linear} clauses,
that is, clauses whose premise contains at most one atom (besides constraints).
After performing linearization, the {\it LA}-solving methods are able
to exploit the interactions among several atoms,
instead of dealing with each atom individually.
In particular, an -solution of the linearized set of clauses
will map a {\it conjunction} of atoms
to a constraint.
We will show that {\rm linearization} preserves the existence of 
 -solutions and,
in some cases (including our Fibonacci example), transforms a set of clauses 
which is not -solvable into a set of clauses that is 
-solvable.


Our transformation technique is made out of the following two steps:\\
(1)~RI:~{\it Removal of the interpreter}, and
(2)~LIN:~{\it Linearization}.\\ 
These steps
 are performed by using the 
transformation rules for CLP programs presented in \cite{EtG96}, that is:
 {\it unfolding} (which consists in applying a resolution step
and a constraint satisfiability test), {\it definition} (which 
introduces a new predicate defined in terms of old predicates), 
and {\it folding} (which redefines old predicates
in terms of new predicates introduced by the definition rule).

\subsection{{\bf{RI:}} Removal of the Interpreter}
\label{subsec:removal}


This step is a variant of the  {removal of the interpreter}
transformation presented in~\cite{De&14c}.
In this step a specialized definition for   is derived
by transforming the CLP program \textit{OpSem}, thereby getting a new
CLP program  where there are
no occurrences of the predicates {\it initCf}, {\it finalCf},
{\it reach}, and~{\it tr}, which as already mentioned 
encodes the interpreter of the imperative language in 
which {\it prog} is written.
(See online appendix for more details.)

By a simple extension of the results presented in~\cite{De&14c},
it can be shown that the RI transformation always terminates, 
preserves satisfiability, and transforms \textit{OpSem} into a set of
linear clauses over the integers.
It can also be shown that the removal of the interpreter preserves 
\mbox{-solvability.} 
	Thus, we have the following result.


\vspace{-.5mm}
\begin{theorem}
Let \textit{OpSem} be a CLP program constructed starting from any given 
imperative program \textit{prog}.\label{thm:RI}
Then the RI transformation terminates and derives a CLP program  such that:

\noindent
(1)  is a set of linear clauses over the integers;

\noindent
(2)  is satisfiable iff 
 is satisfiable;

\noindent
(3)  is 
-solvable iff  is {\textit{LA}}-solvable.
\end{theorem}

\noindent
In the Fibonacci example, the input of the
RI transformation is . 
The output of the
RI transformation consists of the following three clauses:

{\small{
\noindent
{\tt{E1.~r\_fibonacci(N,F):- N>=0,\,U=1,\,V=0,\,T=0,\,r(N,U,V,T,N1,F,V1,T1).}}\rule{0mm}{3.5mm}

\noindent
{\tt{E2.~r(N,U,V,T,N,U,V,T):- N=<0.}}


\noindent
{\tt{E3.~r(N,U,V,T,N2,U2,V2,T2):- N>=1,\,N1=N-1,\,U1=U+V,\,V1=U,\,T1=U,}}

\hspace{46mm}{\tt{r(N1,U1,V1,T1,N2,U2,V2,T2).}}

}} \noindent
where {\tts r} is a new predicate symbol introduced by the
RI transformation.

As stated by Theorem~\ref{thm:RI},  is a set of
clauses over the integers. Since the clauses of the specification {\it Spec} define
computable functions from  to , without loss of generality we may assume that also
the clauses in  are over the integers \cite{SeS82}.
From now on we will only deal with clauses over the integers, and
we will feel free to omit the qualification `over the integers'.


\subsection{{\bf{LIN:}} Linearization}
\label{subsec:linearization}


The {\rm linearization} transformation takes as input the set 

of constrained Horn clauses and derives a new, equisatisfiable set \textit{TransfCls} of 
{\it linear} constrained Horn clauses. 

In order to perform linearization, we assume that
\textit{Aux} is a set of linear clauses.
This assumption,
which is not restrictive because any computable function on the integers can be
encoded by linear clauses \cite{SeS82}, simplifies the 
proof of termination of the transformation.

The {\rm linearization} transformation is described in Figure~\ref{fig:Lin}.
Its input is constructed  by partitioning

into a set {\it LCls} of linear clauses and a set {\it NLGls} of nonlinear goals.
{\it LCls} consists of \textit{Aux},  
(which, by Theorem~\ref{thm:RI}, is a set of linear clauses),
and the subset of linear goals in . 
{\it NLGls} consists of the set of nonlinear goals in .


When applying linearization we use the following transformation rule.

\smallskip
\noindent
{\it Unfolding  Rule.} Let  be a set of constrained Horn clauses.
Given a clause  
of the form , 
let us consider the set
 
made out of the (renamed apart) clauses of~ 
such that, for  
 is unifiable with~ via the most general 
unifier~ and  is satisfiable. 
By unfolding~ with respect to~ using~, we derive the set 
 of clauses.

\begin{figure}[ht]
\vspace{-3mm}

\noindent\hrulefill
\begin{flushleft}\vspace{-2mm}
\noindent {\it Input\/}: (i)~A set \textit{LCls} of linear clauses, 
and (ii)~a set \textit{Gls} of nonlinear goals.\\ 
\noindent  {\it Output\/}: A set \textit{TransfCls} of linear clauses.

\vspace*{-2mm}
\rule{30mm}{0.1mm}

\noindent \textsc{Initialization}:~~~
;
~ ~;
~ ~;


\smallskip

\noindent \textit{while}~ there is a clause~ in \textit{NLCls}
~\textit{do}


\smallskip
\hspace*{3mm}\begin{minipage}{124mm} 

\hangindent=3mm
\noindent \textsc{Unfolding}: From clause  derive a set  of clauses by
unfolding  with respect to every atom occurring
in its body using \textit{LCls}; \\
Rewrite each clause in  to a clause of the form 
 , such that, for ,  is of the form
;

\smallskip
\hangindent=3mm
\noindent {\textsc{Definition}\,\&\,\textsc{Folding}:} 

\noindent
\hspace*{3mm};

\hangindent=3mm
\noindent
\hspace*{3mm}\makebox[4mm][l]{\it for} every clause  of the form   \ {\it do}

\hangindent=11.5mm
\noindent
\hspace*{8mm}{\it if} in \textit{Defs} there is no
clause of the form  ,
where 

\noindent
\hangindent=18mm
\hspace*{8mm}{\it then} add  to \textit{Defs} and to \textit{NLCls}; 

\noindent
\hspace*{8mm}\0pt]
\cline{1-9} \0pt]

2.& {\it fast\_multiplication\_\rule{0mm}{0mm}} & 0.02 
& {\it TO} & 3.71 
& 0.01 
& 1.07 & 1.97 & 7.59\0pt]

4.& {\it fibonacci \rule{0mm}{0mm}} & 0.01 
& {\it TO} & {\it TO} 
& 0.01 
& 2.00 & 47.74 & 6.97\0pt]

6.& {\it greatest\_common\_divisor\rule{0mm}{0mm}} & 0.01 
& {\it TO} & {\it TO} 
& 0.01 
& 0.89 & 1.78 & 0.04\0pt]

8.  &{\it -function\rule{0mm}{0mm}} & 0.01 
& 1.27  & {\it TO} 
& 0.06 
& ~117.97 & 14.24 & {\it TO} \0pt]

10. & {\it remainder\rule{0mm}{0mm}} & 0.01 
& {\it TO}  & {\it TO} 
& 0.01 
& 0.87 & 1.70 & 3.16\0pt] 

12. & {\it lucas\rule{0mm}{0mm}} & 0.01 
& {\it TO} & {\it TO} 
& 0.01 
& 2.04  & 8.39 & 9.46\0pt] 

14. & {\it perrin\rule{0mm}{0mm}} & 0.01 
& {\it TO} & {\it TO} 
& 0.02 
& 2.23 & {\it TO} & 11.89\0pt]

16. & {\it digits \rule{0mm}{0mm}} & 0.01
& {\it TO} & {\it TO} 
& 0.01 
& 4.52 & 3.10 & 6.54 \0pt]

18. & {\it digits-opt \rule{0mm}{0mm}} & 0.08
& {\it TO} & {\it TO} 
& 0.10 
& {\it TO} & {\it TO} & 15.80\0pt]

\cline{1-9} 
\end{tabular}\vspace{0mm}

\caption{Columns\/ {\rm RI} and {\rm LIN} show the times in seconds
 taken for removal of the interpreter and linearization. 
The two columns under \mbox{{\it LA}-{\rm solving-1}} show the times taken by {\rm Z3} and {\rm \hspace{.5mm}Eldarica} for solving the problems after {\rm RI} alone.
The three columns under \mbox{{\it LA}-{\rm solving-2}} show the times taken 
by \mbox{\rm VeriMAP} together with {\rm Z3}, {\rm MathSAT}, {\rm \hspace{.5mm}and Eldarica},  after {\rm RI} and {\rm LIN}.
The timeout TO occurs after  seconds.
\label{tab:expres}}
\end{table}



\section{Conclusions and Related Work}
\label{sec:conclusions}


We have presented a method for proving partial correctness specifications
of programs, given as Hoare triples of the form ,
where the assertions~ and~ are predicates
defined by a set of {\it possibly recursive}, definite CLP clauses.
Our verification method is based on: 
{\it{ Step}} (1) a translation of a given
specification into a set of constrained 
Horn clauses (that is, a CLP program together with one or more goals), 
{\it{Step}} (2)  an unfold/fold transformation strategy, 
called {\rm linearization}, which
derives {\it linear} clauses (that is, clauses with at most 
one atom in their body), and
{\it{Step}} (3) an {\it LA}-solver that attempts to prove the 
satisfiability of constrained Horn clauses
by interpreting predicates as linear arithmetic constraints.


We have formally proved that the method {which uses} {\rm linearization} 
is strictly more
powerful than the method that applies Step\,(3) immediately after Step\,(1).
We have also developed a proof-of-concept implementation of our method 
by using the VeriMAP verification system~\cite{De&14b} together with 
various state-of-the-art solvers
(namely, Z3~\cite{DeB08}, MathSAT~\cite{MaS13}, and Eldarica~\cite{Ru&13}), and we 
have shown that our method works on several verification problems.
Although these problems refer to
quite simple specifications, some of them cannot be solved by {using the above mentioned solvers alone.}


The use of transformation-based methods in the field of program verification 
has recently gained  popularity  (see, 
for instance,~\cite{Al&07,De&14c,Fi&13a,KaG15a,LeM99,LiN08,Pe&98}). 
However, fully automated methods based on various notions
of {\it partial deduction} and {\it CLP program specialization} cannot
achieve the same effect as {\rm linearization}. Indeed, 
{\rm linearization} requires the introduction of new predicates corresponding
to {\it conjunctions} of old {predicates}, whereas {partial deduction} and {program specialization}
can only introduce new predicates that correspond to instances of old 
{predicates}.
In order to derive linear clauses, one could apply {\it conjunctive partial deduction}
\cite{De&99}, which essentially is equivalent to unfold/fold transformation. However, 
to the best of our knowledge, this 
application of conjunctive partial deduction to the field of program verification
has not been investigated {so far}.


The use of linear arithmetic constraints for program verification
has been first proposed in the field of 
{\it abstract interpretation}~\cite{CoC77}, where
these constraints are used for approximating the set of states that
are reachable during program execution~\cite{CoH78}.
In the field of logic programming, abstract interpretation methods work similarly to 
{\it LA}-solving for constrained Horn clauses, 
because they both 
look for interpretations of predicates as linear arithmetic 
constraints that satisfy {the} program clauses 
(see, for instance,~\cite{BeK96}).
Thus, abstract interpretation methods suffer from the 
same theoretical limitations we 
have pointed out in this paper for {\it LA}-solving methods.

One approach that has been followed for overcoming the limitations
related to the use of linear arithmetic constraints is to
devise methods for generating polynomial invariants and proving
specifications with polynomial arithmetic constraints~\cite{RoK07a,RoK07b}. 
This approach also requires the development
of solvers for polynomial constraints, which is a very complex task on its own,
as in general the satisfiability of these constraints on the integers 
is undecidable~\cite{Mat70}.
In contrast, the approach presented in this paper  has the objective of transforming
problems which would require the proof of nonlinear 
arithmetic assertions into problems
which can be solved by using linear arithmetic constraints.
We have shown some examples (such as the  {\it fibonacci} program)
where we are able to prove specifications whose post-condition
is an exponential function.

An interesting issue for future research is 
to identify general criteria to answer the following question:
Given a class  of constraints and a class 
of constrained Horn clauses, does the satisfiability
of a finite set of clauses in  
imply its \mbox{-solvability?}
Theorem \ref{thm:limitation} provides a negative answer to this question when
 is the class of {\it LA} constraints and
 is the class of all constrained Horn clauses.



\section{Acknowledgments}

We thank the participants in the Workshop VPT~'15 on
{\it Verification and Program Transformation}, held in London on April 2015, 
for their comments on a preliminary version of this paper.
This work has been partially supported by the National Group of 
Computing Science (GNCS-INDAM).



\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Albert, G\'{o}mez-Zamalloa, Hubert, and
  Puebla}{Albert et~al\mbox{.}}{2007}]{Al&07}
{\sc Albert, E.}, {\sc G\'{o}mez-Zamalloa, M.}, {\sc Hubert, L.}, {\sc and}
  {\sc Puebla, G.} 2007.
\newblock Verification of {J}ava {B}ytecode {U}sing {A}nalysis and
  {T}ransformation of {L}ogic {P}rograms.
\newblock In {\em Practical {A}spects of {D}eclarative {L}anguages},
  {M.~Hanus}, Ed. Lecture Notes in Computer Science~4354. Springer, 124--139.

\bibitem[\protect\citeauthoryear{Apt, {de Boer}, and Olderog}{Apt
  et~al\mbox{.}}{2009}]{Ap&09}
{\sc Apt, K.~R.}, {\sc {de Boer}, F.~S.}, {\sc and} {\sc Olderog, E.-R.} 2009.
\newblock {\em Verification of Sequential and Concurrent Programs\/}, {T}hird
  ed.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Benoy and King}{Benoy and King}{1997}]{BeK96}
{\sc Benoy, F.} {\sc and} {\sc King, A.} 1997.
\newblock Inferring argument size relationships with {CLP(R)}.
\newblock In {\em Proceedings of the 6th International Workshop on Logic
  Program Synthesis and Transformation, LOPSTR~'96, Stockholm, Sweden, August
  28-30, 1996}, {J.~P. Gallagher}, Ed. Lecture Notes in Computer Science~1207.
  Springer, 204--223.

\bibitem[\protect\citeauthoryear{Bj{\o}rner, McMillan, and
  Rybalchenko}{Bj{\o}rner et~al\mbox{.}}{2012}]{Bj&12}
{\sc Bj{\o}rner, N.}, {\sc McMillan, K.}, {\sc and} {\sc Rybalchenko, A.} 2012.
\newblock Program verification as satisfiability modulo theories.
\newblock In {\em Proceedings of the 10th International Workshop on
  Satisfiability Modulo Theories,~SMT-COMP~'12}. 3--11.

\bibitem[\protect\citeauthoryear{Cimatti, Griggio, Schaafsma, and
  Sebastiani}{Cimatti et~al\mbox{.}}{2013}]{MaS13}
{\sc Cimatti, A.}, {\sc Griggio, A.}, {\sc Schaafsma, B.}, {\sc and} {\sc
  Sebastiani, R.} 2013.
\newblock {The MathSAT5 SMT Solver}.
\newblock In {\em Proceedings of TACAS}, {N.~Piterman} {and} {S.~Smolka}, Eds.
  Lecture Notes in Computer Science~7795. Springer.

\bibitem[\protect\citeauthoryear{Cousot and Cousot}{Cousot and
  Cousot}{1977}]{CoC77}
{\sc Cousot, P.} {\sc and} {\sc Cousot, R.} 1977.
\newblock Abstract interpretation: {A} unified lattice model for static
  analysis of pro\-grams by construction of approximation of fixpoints.
\newblock In {\em Proceedings of the 4th {ACM-SIGPLAN} Symposium on Principles
  of Pro\-gramming Languages,~POPL~'77}. {ACM}, 238--252.

\bibitem[\protect\citeauthoryear{Cousot and Halbwachs}{Cousot and
  Halbwachs}{1978}]{CoH78}
{\sc Cousot, P.} {\sc and} {\sc Halbwachs, N.} 1978.
\newblock Automatic discovery of linear restraints among variables of a
  program.
\newblock In {\em Proceedings of the Fifth ACM Symposium on Principles of
  Programming Languages,~POPL~'78}. {ACM}, 84--96.

\bibitem[\protect\citeauthoryear{{De~Angelis}, Fioravanti, Pettorossi, and
  Proietti}{{De~Angelis} et~al\mbox{.}}{2014a}]{De&14c}
{\sc {De~Angelis}, E.}, {\sc Fioravanti, F.}, {\sc Pettorossi, A.}, {\sc and}
  {\sc Proietti, M.} 2014a.
\newblock Program verification via iterated specialization.
\newblock {\em Science of Computer Programming\/}~{\em 95, Part 2}, 149--175.
\newblock Selected and extended papers from Partial Evaluation and Program
  Manipulation 2013.

\bibitem[\protect\citeauthoryear{{De~Angelis}, Fioravanti, Pettorossi, and
  Proietti}{{De~Angelis} et~al\mbox{.}}{2014b}]{De&14b}
{\sc {De~Angelis}, E.}, {\sc Fioravanti, F.}, {\sc Pettorossi, A.}, {\sc and}
  {\sc Proietti, M.} 2014b.
\newblock {V}eri{MAP}: {A} {T}ool for {V}erifying {P}rograms through
  {T}ransformations.
\newblock In {\em Proceedings of the 20th International Conference on Tools and
  Algorithms for the Construction and Analysis of Systems, TACAS~'14}. Lecture
  Notes in Computer Science~8413. Springer, 568--574.
\newblock Available at: {\rm http://www.map.uniroma2.it/VeriMAP}.

\bibitem[\protect\citeauthoryear{de~Moura and Bj{\o}rner}{de~Moura and
  Bj{\o}rner}{2008}]{DeB08}
{\sc de~Moura, L.~M.} {\sc and} {\sc Bj{\o}rner, N.} 2008.
\newblock Z3: {A}n efficient {SMT} solver.
\newblock In {\em Proceedings of the 14th International Conference on Tools and
  Algorithms for the Construction and Analysis of Systems, {TACAS}~'08}.
  Lecture Notes in Computer Science~4963. Springer, 337--340.

\bibitem[\protect\citeauthoryear{{De Schreye}, Gl{\"u}ck, J{\o}rgensen,
  Leuschel, Martens, and S{\o}rensen}{{De Schreye} et~al\mbox{.}}{1999}]{De&99}
{\sc {De Schreye}, D.}, {\sc Gl{\"u}ck, R.}, {\sc J{\o}rgensen, J.}, {\sc
  Leuschel, M.}, {\sc Martens, B.}, {\sc and} {\sc S{\o}rensen, M.~H.} 1999.
\newblock {C}onjunctive {P}artial {D}eduction: {F}oundations, {C}ontrol,
  {A}lgorithms, and {E}xperiments.
\newblock {\em Journal of {L}ogic {P}rogramming\/}~{\em 41,\/}~2--3, 231--277.

\bibitem[\protect\citeauthoryear{Etalle and Gabbrielli}{Etalle and
  Gabbrielli}{1996}]{EtG96}
{\sc Etalle, S.} {\sc and} {\sc Gabbrielli, M.} 1996.
\newblock Trans\-form\-ations of {CLP} modules.
\newblock {\em Theoretical Computer Science\/}~{\em 166}, 101--146.

\bibitem[\protect\citeauthoryear{Felsing, Dennis and Grebing, Sarah and Klebanov, Vladimir and R\"{u}mmer, Philipp and Ulbrich, Mattias}{Felsing et~al\mbox{.}}{2014}]{Fe&14}
{\sc Felsing, D.}, {\sc Grebing, S.}, {\sc Klebanov, V.}, {\sc R\"{u}mmer, P.}, {\sc and}
  {\sc Ulbrich, M.} 2014.
\newblock {A}utomating {R}egression {V}erification.
\newblock In {\em Proceedings of the 29th {ACM/IEEE} {I}nternational {C}onference on  {A}utomated {S}oftware {E}ngineering,~ASE~'14}. {ACM}, 349--360.

\bibitem[\protect\citeauthoryear{Fioravanti, Pettorossi, Proietti, and
  Senni}{Fioravanti et~al\mbox{.}}{2013}]{Fi&13a}
{\sc Fioravanti, F.}, {\sc Pettorossi, A.}, {\sc Proietti, M.}, {\sc and} {\sc
  Senni, V.} 2013.
\newblock Generalization strategies for the verification of infinite state
  systems.
\newblock {\em Theory and Practice of Logic Programming. Special Issue on the
  25th {A}nnual GULP {C}onference\/}~{\em 13,\/}~2, 175--199.

\bibitem[\protect\citeauthoryear{Grebenshchikov, Lopes, Popeea, and
  Rybalchenko}{Grebenshchikov et~al\mbox{.}}{2012}]{Gr&12}
{\sc Grebenshchikov, S.}, {\sc Lopes, N.~P.}, {\sc Popeea, C.}, {\sc and} {\sc
  Rybalchenko, A.} 2012.
\newblock Synthesizing software verifiers from proof rules.
\newblock In {\em Proceedings of the ACM SIGPLAN Conference on Programming
  Language Design and Implementation, PLDI~'12}. 405--416.

\bibitem[\protect\citeauthoryear{Hoare}{Hoare}{1969}]{Hoa69}
{\sc Hoare, C.} 1969.
\newblock An {A}xiomatic {B}asis for {C}omputer {P}rogramming.
\newblock {\em CACM\/}~{\em 12,\/}~10 (October), 576--580, 583.

\bibitem[\protect\citeauthoryear{Jaffar and Maher}{Jaffar and
  Maher}{1994}]{JaM94}
{\sc Jaffar, J.} {\sc and} {\sc Maher, M.} 1994.
\newblock Constraint logic programming: {A} survey.
\newblock {\em Journal of Logic Programming\/}~{\em 19/20}, 503--581.

\bibitem[\protect\citeauthoryear{Jaffar, Murali, Navas, and Santosa}{Jaffar
  et~al\mbox{.}}{2012}]{Ja&12}
{\sc Jaffar, J.}, {\sc Murali, V.}, {\sc Navas, J.~A.}, {\sc and} {\sc Santosa,
  A.~E.} 2012.
\newblock {TRACER}: {A} {S}ymbolic {E}xecution {T}ool for {V}erification.
\newblock In {\em {P}roceedings 24th {I}nternational {C}onference on {C}omputer
  {A}ided {V}erification, CAV~'12}. Lecture Notes in Computer Science~7358.
  Springer, 758--766.
\newblock \rm {http://paella.d1.comp.nus.edu.sg/tracer/}.

\bibitem[\protect\citeauthoryear{Kafle and Gallagher}{Kafle and
  Gallagher}{2015}]{KaG15a}
{\sc Kafle, B.} {\sc and} {\sc Gallagher, J.~P.} 2015.
\newblock Constraint {S}pecialisation in {H}orn {C}lause {V}erification.
\newblock In {\em Proceedings of the 2015 Workshop on Partial Evaluation and
  Program Manipulation, PEPM~'15, Mumbai, India, January 15--17, 2015}. {ACM},
  85--90.

\bibitem[\protect\citeauthoryear{Lloyd}{Lloyd}{1987}]{Llo87}
{\sc Lloyd, J.~W.} 1987.
\newblock {\em Foundations of Logic Pro\-gramming}.
\newblock Springer, Berlin. 
\newblock 2nd Edition.

\bibitem[\protect\citeauthoryear{Leuschel and Massart}{Leuschel and
  Massart}{2000}]{LeM99}
{\sc Leuschel, M.} {\sc and} {\sc Massart, T.} 2000.
\newblock Infinite state model checking by abstract interpretation and program
  specialization.
\newblock In {\em Proceedings of the 9th International Workshop on Logic-based
  Program Synthesis and Transformation (LOPSTR~'99), Venezia, Italy},
  {A.~Bossi}, Ed. Lecture Notes in Computer Science~1817. Springer, 63--82.

\bibitem[\protect\citeauthoryear{Lisitsa and Nemytykh}{Lisitsa and
  Nemytykh}{2008}]{LiN08}
{\sc Lisitsa, A.} {\sc and} {\sc Nemytykh, A.~P.} 2008.
\newblock Reachability analysis in verification via supercompilation.
\newblock {\em Int. J. Found. Comput. Sci.\/}~{\em 19,\/}~4, 953--969.

\bibitem[\protect\citeauthoryear{Matijasevic}{Matijasevic}{1970}]{Mat70}
{\sc Matijasevic, Y.~V.} 1970.
\newblock Enumerable sets are diophantine.
\newblock {\em Doklady Akademii Nauk SSSR (in Russian)\/}~{\em 191}, 279--282.

\bibitem[\protect\citeauthoryear{Peralta, Gallagher, and Saglam}{Peralta
  et~al\mbox{.}}{1998}]{Pe&98}
{\sc Peralta, J.~C.}, {\sc Gallagher, J.~P.}, {\sc and} {\sc Saglam, H.} 1998.
\newblock Analysis of {I}mperative {P}rograms through {A}nalysis of
  {C}onstraint {L}ogic {P}rograms.
\newblock In {\em Proceedings of the 5th {I}nternational {S}ymposium on
  {S}tatic {A}nalysis, {SAS}~'98}, {G.~{L}evi}, Ed. Lecture Notes in Computer
  Science~1503. Springer, 246--261.

\bibitem[\protect\citeauthoryear{Podelski and Rybalchenko}{Podelski and
  Rybalchenko}{2007}]{PoR07}
{\sc Podelski, A.} {\sc and} {\sc Rybalchenko, A.} 2007.
\newblock {ARMC}: {T}he {L}ogical {C}hoice for {S}oftware {M}odel {C}hecking
  with {A}bstraction {R}efinement.
\newblock In {\em Practical Aspects of Declarative Languages, {PADL}~'07},
  {M.~Hanus}, Ed. Lecture Notes in Computer Science~4354. Springer, 245--259.

\bibitem[\protect\citeauthoryear{Reynolds}{Reynolds}{1998}]{Rey98}
{\sc Reynolds, C.~J.} 1998.
\newblock {\em Theories of {P}rogramming {L}anguages}.
\newblock Cambridge University Press.

\bibitem[\protect\citeauthoryear{Rodr{\'{\i}}guez{-}Carbonell and
  Kapur}{Rodr{\'{\i}}guez{-}Carbonell and Kapur}{2007a}]{RoK07a}
{\sc Rodr{\'{\i}}guez{-}Carbonell, E.} {\sc and} {\sc Kapur, D.} 2007a.
\newblock Automatic generation of polynomial invariants of bounded degree using
  abstract interpretation.
\newblock {\em Sci. Comput. Program.\/}~{\em 64,\/}~1, 54--75.

\bibitem[\protect\citeauthoryear{Rodr{\'{\i}}guez{-}Carbonell and
  Kapur}{Rodr{\'{\i}}guez{-}Carbonell and Kapur}{2007b}]{RoK07b}
{\sc Rodr{\'{\i}}guez{-}Carbonell, E.} {\sc and} {\sc Kapur, D.} 2007b.
\newblock Generating all polynomial invariants in simple loops.
\newblock {\em J. Symb. Comput.\/}~{\em 42,\/}~4, 443--476.

\bibitem[\protect\citeauthoryear{R{\"u}mmer, Hojjat, and Kuncak}{R{\"u}mmer
  et~al\mbox{.}}{2013}]{Ru&13}
{\sc R{\"u}mmer, P.}, {\sc Hojjat, H.}, {\sc and} {\sc Kuncak, V.} 2013.
\newblock Disjunctive interpolants for {H}orn-clause verification.
\newblock In {\em Proceedings of the 25th International Conference on Computer
  Aided Verification, {CAV}~'13, Saint Petersburg, Russia, July 13--19, 2013},
  {N.~Sharygina} {and} {H.~Veith}, Eds. Lecture Notes in Computer Science~8044.
  Springer, 347--363.

\bibitem[\protect\citeauthoryear{Sebelik and Step{\'{a}}nek}{Sebelik and Step{\'{a}}nek}{1982}]{SeS82}
{\sc Sebelik, J.} {\sc and} {\sc Step{\'{a}}nek, P.} 1982.
\newblock Horn clause programs for recursive functions.
\newblock In {\em Logic Programming},
  {K. L.~Clark} {and} {S.-A.~T{\"a}rnlund}, Eds. 
  Academic Press, 325--340.



\end{thebibliography}

\newpage

\section*{Appendix}


For the proof of Theorem \ref{thm:pc} we need the following lemma.

\medskip
\noindent
{\it Lemma~1}. (i) The relation  defined by \textit{OpSem} is a functional relation, that is, 
..

\noindent
(ii) A program
 terminates for an environment  such that
\mbox{},, 
and  holds, iff

. .

\medskip

\noindent
{\it Proof.} 
Since the program \textit{prog}  is deterministic, 
the predicate  defined by \textit{OpSem} is 
a functional relation (which might not be total on \textit{pre}, as 
\textit{prog} might not terminate).
Moreover, a program \textit{prog}, with variables ,
terminates for an environment  such that:
(i)~  ,
and (ii)~  satisfies~\textit{pre},
iff  .\, holds in 
. \hfill\eop

\medskip

\noindent
{\it Proof of Theorem \ref{thm:pc} Partial Correctness.}

\noindent
Let  be  a predicate that
represents the {\it domain} of the functional relation .
We assume that    is defined by
a set \textit{Dom} of clauses, using predicate symbols not in , such that 

 \hfill 

\hspace{20mm} 

\noindent
Let us denote by  the set of clauses obtained from 
\textit{Spec} by replacing each clause  
by the clause .
Then,  for all integers ,

\smallskip

 \ implies \   \hfill (2)

\smallskip

\noindent
Moreover,  let us denote by  the set of clauses obtained from  by replacing all occurrences of  by .
We show that  .

\noindent
Let   be any clause in . If  belongs to  , then .
Otherwise,  is of the form  and, by construction,  in 
there are two goals

\smallskip
: ,
and 

:  

\smallskip
\noindent
such that  is satisfiable.
Then, 

\smallskip


\smallskip
\noindent
Since , we also have that

\smallskip


\smallskip
\noindent
From the functionality of  it follows that 

\smallskip
 

\hfill


\smallskip
\noindent
 and hence, by using (1), 

\smallskip


\smallskip
\noindent
Thus, we have that 

\smallskip


\smallskip
\noindent
that is, clause
 is true in .
We can conclude that  is a model of
, and since  is the {\it least} model of , we have that

\smallskip
 \hfill (3)

\smallskip
\noindent
Next we show that,  for all integers ,

\smallskip

  
\ \ iff  \ \
 \hfill (4)

\smallskip\noindent
{\it Only If Part of} (4).
Suppose  that
. Then, by 
construction,

\smallskip



\smallskip

\noindent
and hence, by (3),

\smallskip

 

\smallskip

\noindent
Since  does not depend on predicates in ,

\smallskip




\medskip

\noindent
{\it If Part of} (4). 
Suppose that
.

\noindent
Then, by definition of  ,

\smallskip
 \hfill (5)

\noindent
and 

  \hfill (6)

\smallskip
\noindent
Thus, by (6) and {Condition~(3.1)}
of Definition \ref{def:spec}, there exists  such that 

\smallskip
 \hfill (7)

\smallskip
\noindent
By (5) and (7),

\smallskip
 \hfill (8)

\smallskip
\noindent
By the {\it Only If Part} of (4), 

\smallskip
 

\smallskip
\noindent
and
by the functionality of , . Hence, by (8),

\smallskip


\medskip
\noindent
Let us now prove partial correctness.
If   and 
\textit{prog} terminates, that is, ,  
then for some integer~, .
Thus, by (4),  
and hence, by (2), .
Suppose that  the postcondition  is . Then,
by {Condition~(3.2)} of Definition~\ref{def:spec}, .

Thus, \mbox{ {\textit{prog}} }.
\hfill 



\bigskip

\noindent
{\it Removal of the Interpreter}


\noindent
Here we report the variant of the transformation presented in \cite{De&14c} that
we use in this paper to perform the removal of the interpreter. 
In this transformation we use the function  
defined as the set of clauses derived by unfolding a clause~ with respect to an atom~
using the set~ of clauses (see the unfolding rule in Section \ref{subsec:linearization}).

The predicate {\it reach} is defined as follows:





\noindent
where, as mentioned in Section \ref{sec:encoding}, {\it tr} is a (nonrecursive) predicate representing 
one transition step according to the operational semantics of the imperative language.

In order to perform the \textsc{Unfolding} step,
we assume that the atoms occurring in bodies of clauses 
are annotated as either {\em unfoldable} 
or {\em not unfoldable}. 
This annotation 
ensures that any sequence of clauses constructed by unfolding
w.r.t.~unfoldable atoms is finite. 
In particular, the atoms with predicate \textit{initCf\/}, \textit{finalCf\/},
and {\it tr\/} are unfoldable. The atoms of the form 
 are unfoldable if 
is not associated with a while or goto command. 
Other annotations based on a different analysis of program  can be used.




\noindent\hrulefill
	
	\noindent \emph{Input\/}: Program~.\\ 
	\noindent \emph{Output\/}: Program  such that,
for all integers ,
	 
	 iff 
.\\	
\noindent\rule{30mm}{0.1mm}
	
	\noindent \textsc{Initialization}:

\noindent\hspace{.6mm}
; ~~;

\noindent\hspace{.6mm}
;
	


	\noindent \textit{while}~in \textit{InCls} there is a clause~
	which is not a constrained fact
	\textit{do}
	
	\smallskip
	
	\hspace*{3mm}\begin{minipage}{118mm}
		
		\smallskip
		\noindent \textsc{Unfolding}:
		


		\noindent , 
		where \textit{A} is the leftmost atom in the body of~;
		
		
		\noindent \textit{while}
		\hangindent=8mm in  there is a clause 
		whose body contains an occurrence of an unfoldable atom \textit{A}
		\textit{do} 
		\\
		


		\noindent \textit{end-while};
		
		
		\smallskip
		
		\noindent {\textsc{Definition} \& \textsc{Folding}:}
		
		\noindent
		\makebox[8mm][l]{\textit{while}}\ in  there is a clause
		  of the form: 
		~~
		
		\noindent  
		\textit{do}
		
		\smallskip
		
		\hspace*{3mm}\begin{minipage}{115mm}
			
			\noindent
			\makebox[4mm][l]{\textit{if}}in  there is no clause of the form:
			~~ 
			
			\hspace*{4mm}where {\it V} is the set of variables occurring in 
			
			
\noindent
			\textit{then}~~add the clause : 
			to \textit{Defs} and \textit{InCls};
						
			
		\end{minipage}
		
		\smallskip
		\noindent
		\textit{end-while};
		
		\smallskip
		
		\noindent ; ~~
		;
		
	\end{minipage}
	
	\smallskip
	
	\noindent \textit{end-while};
	
	\vspace*{-1.5mm}
	\noindent\hrulefill\nopagebreak
\vspace{-2mm}
\begin{center} RI: Removal of the Interpreter. \end{center}
\nopagebreak

\noindent
Let us now prove Theorem \ref{thm:RI} stating the relevant properties of the RI transformation.

\medskip
\noindent
{\it The RI transformation terminates.} 
The termination of the \textsc{Unfolding} step is guaranteed by the 
{\it unfoldable} annotations. Indeed, (i) the repeated unfolding of the
unfoldable atoms with predicates \textit{initCf\/}, \textit{finalCf\/}, and {\it tr}, 
always terminates because those atoms have no recursive clauses,
(ii) by the definition of the semantics of the imperative program, 
the repeated unfolding of an atom of the form
 eventually derives
a new  atom where
  is either a final configuration or
a configuration associated with a while or goto command, and in both cases
unfolding terminates.
The termination of the \textsc{Definition} \& \textsc{Folding} step
follows from the fact that {\it SpC} is a finite set of clauses. 

The outer while loop terminates because a finite set of new predicate definitions
of the form 
can be introduced.
Indeed, each configuration {\it cf} is represented as a term 
{\tt cf(LC,E))}, where {\tt LC} is a labeled command and 
{\tt E} is an environment (see Example \ref{ex:fib}). 
An environment is represented as a list of  pairs where 
 is a variable identifier and  is its value, that is, a logical
variable whose value may be subject to a given constraint.
Considering that: (i) the labeled commands and the variable identifiers
occurring in an imperative 
program are finitely many, and
(ii) predicate definitions of the form
 
abstract away from the constraints that hold on the logical
variables occurring in  and ,
we can conclude that there are only finitely many such clauses (modulo variable renaming).
 

\medskip	
\noindent
{\it Point}~1: {\it  is a set of linear clauses over the integers.}
By construction, every clause in  is of the 
form , where
(i)  is either  or , for some new predicate
 and tuple of variables , and
(ii)  is either absent or of the form , for some new predicate
 and tuple of variables .
Thus, every clause is a linear clause over the integers.
	
\medskip	
\noindent
{\it Point}~2: {\it  is satisfiable iff 
	 is satisfiable.}
From the correctness of the unfolding, definition, and folding rules with respect
to the least model semantics of CLP programs \cite{EtG96}, it follows that,
for all integers ,

 iff 
	 \hfill  ~~~
	
\noindent
 is satisfiable iff 
for every ground instance  of a goal in , .
Since the only predicate of \textit{OpSem} on which  may depend is , by ,
we have that  iff 
.
Finally,  
for every ground instance  of a goal in , iff
 is satisfiable.




\medskip	
\noindent
{\it Point}~3: {\it  is 
	-solvable iff  is {\textit{LA}}-solvable.}

Suppose that  is 
-solvable, and let  be an {\it LA}-solution of 
. 
Now we construct an {\it LA}-solution  of .
To this purpose it is enough to define a symbolic interpretation for
the new predicates introduced by RI.

For any predicate {\it newp} introduced by RI via a clause of the form:

\smallskip



\smallskip

\noindent
we define a symbolic interpretation as follows:

\smallskip



\smallskip

\noindent
Moreover,  is identical to  for the atoms with
predicate occurring in \textit{OpSem}.

Now we have to prove that  is indeed an
{\it LA}-solution of . This proof is similar to
the proof of Theorem \ref{thm:LAsolv} (actually, simpler, because RI
introduces new predicates defined by single atoms, while LIN introduces
new predicates defined by conjunctions of atoms), and is omitted.

Vice versa, if  is an {\it LA}-solution
of ,
we construct an {\it LA}-solution  of 
 
by defining

.
\hfill \eop





\bigskip

\noindent
{\it Proof of Theorem \ref{thm:term-corr}} 

\noindent
Let {\it LCls} be a set of linear clauses and \textit{Gls} be a set of nonlinear goals. 
We split the proof of Theorem \ref{thm:term-corr} in three parts:

\noindent
{\it Termination}: The \textrm{linearization} transformation LIN terminates for the input set of clauses ;

\noindent
{\it Linearity}: The output  of LIN is a set of linear clauses;

\noindent
{\it Equisatisfiability}:  is satisfiable iff
	\textit{TransfCls} is satisfiable.

\smallskip

\noindent
({\it Termination}) 
Each \textsc{Unfolding} and \textsc{Definition}\,\&\,\textsc{Folding} step terminates.
Thus, in order to prove the termination of LIN it is enough to show
that the while loop is executed a finite number of times, that is,
a finite number of clauses are added to {\it NLCls}.
We will establish this finiteness property by showing that there exists
an integer  such that every clause added to {\it NLCls} is of the form:

 \hfill  ~~~

\noindent
where: (i) , (ii) for ,  is of the form
, and (iii)~.

Indeed, let  be the maximal number of atoms occurring in the body
of a goal in {\it Gls}, to which {\it NLCls} 
is initialized.
Now let us consider a clause  in {\it NLCls} and assume that
in the body of  there are at most  atoms.
The clauses in the set \textit{LCls} used for unfolding  are linear, and hence
in the body of each clause belonging to the set  obtained after the \textsc{Unfolding}
step, there are at most  atoms.
Thus, each clause in 
is of the form , with .
Since the body of every new clause introduced by the subsequent
\textsc{Definition}\,\&\,\textsc{Folding} step is obtained 
by dropping the constraint from the body of a clause in ,
we have that every clause added to {\it NLCls} is of the form 
 ,
with .
Thus, LIN terminates.

\smallskip
\noindent
({\it Linearity}) \textit{TransfCls} is initialized to the set
\textit{LCls} of linear clauses. Moreover, each clause added to \textit{TransfCls}
is of the form , and hence
is linear.

\smallskip
\noindent
({\it Equisatisfiability}) 
In order to prove that LIN ensures equisatisfiability, let us 
adapt to our context the basic notions about the unfold/fold 
transformation rules for CLP programs presented in~\cite{EtG96}.

Besides the unfolding rule of Section \ref{subsec:linearization}, 
we also introduce the following {\it definition} and {\it folding} rules.

\smallskip

\noindent
{\it Definition Rule.}  By definition we 
introduce a clause of the form \mbox{}, 
where \textit{newp} is a new predicate symbol and
 is a tuple of variables occurring in~\textit{G}.

\smallskip

\noindent
{\it Folding Rule.} 
Given a clause :  and 
a clause :  introduced by the definition rule.
Suppose that, .
Then by folding~ using  we derive .

\smallskip

From a set {\it Cls} of clauses
we can derive a new set  of clauses either by
adding a new clause to {\it Cls} using the definition rule or by: 
(i)~selecting a clause~ in {\it Cls},
(ii)~deriving a new set \textit{TransfC} of clauses using
one or more transformation rules among unfolding and folding, and
(iii)~replacing  by \textit{TransfC} in~{\it Cls}.
We can apply a new sequence of transformation rules
starting from \textit{TransfCls} and iterate this process at will.

The following theorem is an immediate consequence of the correctness results 
for the unfold/fold transformation rules of CLP programs~\cite{EtG96}. 

\begin{theorem}[{\textit Correctness of the Transformation Rules}]
\label{thm:corr_rules}
Let the set  be derived from {\it Cls} by a sequence
of applications of the unfolding, definition and folding transformation rules. 
Suppose that every clause introduced by the definition
rule is unfolded at least once in this sequence.
Then, {\it Cls} is satisfiable \mbox{iff}
{\it TransfCls} is satisfiable.
\end{theorem}

Now, equisatisfiability easily follows from 
Theorem \ref{thm:corr_rules}. Indeed, the \textsc{Unfolding} and
\textsc{Definition \& Folding} steps of LIN
are applications of the unfolding, definition, and folding rules
(strictly speaking, the rewriting performed after unfolding is not included 
among the transformation rules, but obviously preserves all {\it LA}-models). 
Moreover, every clause introduced during the \textsc{Definition \& Folding} step
is added to {\it NCls} and unfolded in a subsequent step of the transformation.
Thus, the hypotheses of Theorem \ref{thm:corr_rules} are fulfilled, and hence
we have that  is satisfiable iff
\textit{TransfCls} is satisfiable. \hfill 


\bigskip

\noindent
{\it Linearized clauses for Fibonacci.} 

\noindent
The set of {\it linear} constrained Horn clauses obtained after applying LIN
is made out of clauses {\tts E1}, {\tts E2}, 
{\tts E3}, and {\tts C3}, together with the following clauses:
\vspace{1.5mm}

\smallskip
{\small{\tts{

\noindent
new1(N1,U,V,U,N2,U,N3,U):-\,N1=<0,\,N2=<0,\,N3=<0.

\noindent
new1(N1,U,V,U,N2,U,N3,F3):-\,N1=<0,\,N2=<0,\,N4=N3-1,\,W=U+V,\,N3>=1,new2(N4,W,U,F3).

\noindent             
new1(N1,U,V,U,N2,F2,N3,U):-\,N1=<0,\,N4=N2-1,\,W=U+V,\,N2>=1,\,N3=<0,new2(N4,W,U,F2).
 
\noindent            
new1(N1,U,V,U,N2,F2,N3,F3):-\,N1=<0,\,N4=N2-1,\,N2>=1,\,N5=N3-1,\,N3>=1,\par\hspace{12mm}  
             new3(N4,W,U,F2,N5,F3).

\noindent             
new1(N1,U,V,F1,N2,U,N3,U):-\,N4=N1-1,\,W=U+V,\,N1>=1,\,N2=<0,\,N3=<0,new2(N4,W,U,F1).
 
\noindent            
new1(N1,U,V,F1,N2,U,N3,F3):-\,N4=N1-1,\,N1>=1,\,N2=<0,\,N5=N3-1,\,W=U+V,\,N3>=1,\nopagebreak\par\hspace{12mm}  
             new3(N4,W,U,F1,N5,F3).

\noindent             
new1(N1,U,V,F1,N2,F2,N3,U):-\,N4=N1-1,\,N1>=1,\,N5=N2-1,\,W=U+V,\,N2>=1,\,N3=<0,\nopagebreak\par\hspace{12mm}   
             new3(N4,W,U,F1,N5,F2).

\noindent             
new1(N1,U,V,F1,N2,F2,N3,F3):-\,N4=N1-1,\,N1>=1,\,N5=N2-1,\,N2>=1,\,N6=N3-1,\,W=U+V,
\nopagebreak\par\hspace{12mm} N3>=1,\,new1(N4,W,U,F1,N5,F2,N6,F3).
 
\noindent            
new2(N,U,V,U):-\,N=<0.

\noindent
new2(N,U,V,F):-\,N2=N-1,\,W=U+V,\,N>=1,\,new2(N2,W,U,F).

\noindent
new3(N1,U,V,U,N2,U):-\,N1=<0,\,N2=<0.

\noindent
new3(N1,U,V,U,N2,F2):-\,N1=<0,\,N3=N2-1,\,W=U+V,\,N2>=1,\,new2(N3,W,U,F2).

\noindent
new3(N1,U,V,F1,N2,F2):-\,N3=N1-1,\,N1>=1,\,N4=N2-1,\,W=U+V,\,N2>=1,\par\hspace{12mm} 
             new3(N3,W,U,F1,N4,F2).
             
\noindent
new3(N1,U,V,F1,N2,U):-\,N3=N1-1,\,W=U+V,\,N1>=1,\,N2=<0,\,new2(N3,W,U,F1).


}}} \normalsize

\medskip

\noindent
{\it Proof of Theorem \ref{thm:LAsolv} Monotonicity with respect to {\it LA}-Solvability.}

\noindent
Suppose that the set  of constrained Horn clauses
is {\it LA}-solvable, and let  be obtained by applying
LIN to . 
Let  be an {\it LA}-solution of . We now construct an {\it LA}-solution of .
For any predicate {\it newp} introduced by LIN via a clause of the form:



\noindent
we define a symbolic interpretation  as follows:



\noindent
Now, we are left with the task of proving that  is indeed an
{\it LA}-solution of .
The clauses in  are either of the form



\noindent
or of the form



\noindent
where \textit{newp} and \textit{newq} are
 predicates  introduced by LIN. We will only consider the more difficult case where
the conclusion is not \textit{false}.

The clause 
has been derived (see the {\rm linearization} transformation LIN in Figure \ref{fig:Lin})
in the following two steps.

\noindent
(Step i) Unfolding  
w.r.t. all atoms in its body using  clauses in \textit{LCls}:



\noindent
where some of the 's can be the \textit{true} and , thereby deriving



\noindent
(Without loss of generality we assume that the atoms in the body
of the clauses are equal to, instead of {\it unifiable} with,
the heads of the clauses in \textit{LCls}. )

\noindent
(Step ii) Folding 
using a clause of the form:



\noindent
Thus, for  we have the following symbolic interpretation:



\medskip
\noindent
To prove that  is an {\it LA}-solution of , we have to show that



\noindent
Assume that



\noindent
Then, by definition of ,



\noindent
Since  is an {\it LA}-solution of \textit{LCls}, we have that:



\noindent
and hence



\noindent
Thus, by definition of ,

 \hfill \eop

\end{document}