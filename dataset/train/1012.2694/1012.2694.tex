\documentclass[a4paper,12pt]{article}
\usepackage{color,amsmath,amssymb,path,amsthm,caption,url,changepage,algorithmic,eqnarray,wasysym,textcomp,enumerate,setspace,graphicx,mathtools}

\usepackage[margin=1in]{geometry}

\def\A{{\cal A}}
\def\B{{\cal B}}
\def\C{{\cal C}}
\def\D{{\cal D}}
\def\S{{\cal S}}


\def\bd{{\partial}}
\def\Vor{{\rm Vor}}
\def\invcos{{\rm invcos}}
\def\reals{\mathbb{R}}

\def\etal{\textsl{et~al.}}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}


\def\marrow{{\marginpar[\hfill]{}}}

\def\micha#1{{\sc Micha says: }{\marrow\sf #1}}
\def\rinat#1{{\sc Rinat says: }{\marrow\sf #1}}

\begin{document}

\begin{titlepage}

\title{The 2-Center Problem in Three Dimensions{\large{\thanks{Work on this paper by Pankaj Agarwal and Micha Sharir has been
supported by Grant 2006/194 from the U.S.-Israeli Binational Science
Foundation. Work by Pankaj Agarwal is also supported by NSF under
grants
 CNS-05-40347, CCF-06 -35000, IIS-07-13498,
                and CCF-09-40671, by ARO grants
                W911NF-07-1-0376 and W911NF-08-1-0452, by an
                NIH grant 1P50-GM-08183-01, and by a DOE grant
                OEG-P200A070505
Work by Micha Sharir has also been supported
by NSF Grants CCF-05-14079 and CCF-08-30272,
by Grants 155/05 and 338/09 from the Israel Science Fund,
and by the Hermann Minkowski--MINERVA Center for Geometry at Tel Aviv
University. A preliminary version of this paper appeared in {\it Proc. 26th Sympos. on Computational Geometry} 2010, pp. 87--96.
  }}}}





\author{
  Pankaj K. Agarwal\thanks{Department of Computer Science, Box 90129, Duke University,
      Durham, NC 27708-0129, USA; {\tt pankaj@cs.duke.edu}}
       \and
       Rinat Ben Avraham\thanks{School of Computer Science, Tel Aviv University, Tel Aviv 69978,
          Israel; {\tt rinatba@gmail.com}}
       \and
       Micha Sharir\thanks{School of Computer Science, Tel Aviv University, Tel~Aviv 69978,
          Israel; and Courant Institute of Mathematical Sciences, New York
          University, New York, NY~~10012,~USA; {\tt michas@post.tau.ac.il }}
 }
\date{}
\maketitle

\begin{abstract}
Let  be a set of  points in .  The \emph{2-center
problem} for  is to find two congruent balls of minimum radius
whose union covers . We present two randomized algorithms for
computing a 2-center of . The first  algorithm runs in
 expected time, and the second algorithm runs in
 expected time, where  is the
radius of the 2-center balls of  and  is the radius of the
smallest enclosing ball of . The second algorithm is faster than
the first one as long as  is not too close to , which is
equivalent to the condition that the centers of the two covering
balls be not too close to each other.
\end{abstract}

\end{titlepage}

\section{Introduction}
\label{sec:introduction}

\subsection{Background}
\label{subsec:background} Let  be a set of
 points in . The \emph{2-center problem} for  is to
find two congruent balls of minimum radius whose union covers .
This is a special case of the general -center problem in
, which calls for covering a set  of  points in
 by  congruent balls of minimum radius. If  is
part of the input, the problem is known to be NP-complete~\cite{MK}
even for , so the complexity of algorithms for solving the
-center problem, for any fixed , is expected to increase more
than polynomially in . Agarwal and Procopiuc showed that the
-center problem in  can be solved in 
time~\cite{AP}, improving upon a naive -solution. At the
other extreme end, the 1-center problem (also known as the
\emph{smallest enclosing ball} problem) is known to be an LP-Type
problem, and can thus be solved in  randomized expected time
in any fixed dimension, and also in deterministic linear time
~\cite{CM, NML, NMLT}. Faster approximate solutions to the general
-center problem have also been proposed~\cite{AP, BHI, BE}.

If  is not fixed, the 2-center problem in  is
NP-Complete~\cite{MK2}. The 2-center problem in  has a
relatively rich history, mostly in the past two decades. Hershberger
and Suri~\cite{HS} showed that the decision problem of determining
whether  can be covered by two disks of a given radius  can be
solved in  time. This has led to several
nearly-quadratic algorithms~\cite{ASP, DE, JK} that solve the
optimization problem, the best of which, due to Jaromczyk and
Kowaluk~\cite{JK}, runs in  deterministic time.
Sharir~\cite{MS} considerably improved these bounds and obtained a
deterministic algorithm with  running time. His
algorithm combines several geometric techniques, including
parametric searching, searching in monotone matrices, and dynamic
maintenance of planar configurations. Chan~\cite{TC} (following an
improvement by Eppstein~\cite{DEF}) improved the running time to
.

The only earlier work on the 2-center problem in  we are aware of is by Agarwal~\etal~\cite{AES},
which presents an algorithm with  running time, for any . It uses
a rather complicated data structure for dynamically maintaining upper and lower envelopes of bivariate functions.

\subsection{Our results}
\label{subsec:results} We present two randomized algorithms for the
2-center problem in . We first present an algorithm whose
expected running time is . It is conceptually a
natural generalization of the earlier algorithms for the planar
2-center problem~\cite{ASP, DE, JK}; its implementation however is
considerably more involved. The second algorithm runs in  expected time, where  is the common
radius of the 2-center balls and  is the radius of the smallest
enclosing ball of .  This is based on some of the ideas in
Sharir's planar algorithm~\cite{MS}, but requires several new
techniques. As in the previous algorithms, we first present
algorithms for the decision problem: given , determine
whether  can be covered by two balls of radius . We then
combine it with an adaptation of Chan's randomized optimization
technique~\cite{TCG} to obtain a solution for the optimization
problem. In both cases, the asymptotic expected running time of the
optimization algorithm is the same as that of the decision procedure
(which itself is deterministic).

The paper is organized as follows. Section~\ref{sec:sketches}
briefly sketches our two solutions. Section~\ref{sec:cubic_alg}
presents the near-cubic algorithm, and
Section~\ref{sec:improved_alg} presents the improved algorithm. A
key ingredient of both algorithms is a dynamic procedure for testing
whether the intersection of a collection of balls in 
is nonempty. We present the somewhat technical details of this
procedure in Section~\ref{sec:spherical_polytopes}, and conclude in
Section~\ref{sec:discussion} with a few open problems.

\section{Sketches of the Solutions}
\label{sec:sketches}

\subsection{The near-cubic algorithm}
\label{subsec:n^3_sketch} To solve the decision problem, in the less
efficient but conceptually simpler manner, we use a standard
point-plane duality, and replace each point  by a dual
plane , and each plane  by a dual point , such that the
above-below relations between points and planes are preserved. We
note that if  can be covered by two balls  (not
necessarily congruent), then there exists a plane  (containing
the circle , if they intersect at all, or
separating  and  otherwise) separating  into two
subsets , such that  and . We therefore construct the arrangement  of the set  of dual planes. It has  cells, and each cell
 has the property that, for any point , its primal
plane  separates  into two subsets of points,  and
, which are the same for every , and depend
only on . We thus perform a traversal of , which proceeds
from each visited cell to a neighbor cell. When we visit a cell
, we check whether the subsets  and  can
be covered by two balls of radius , respectively. To do so, we
maintain dynamically the intersection of the sets , , where  is
the ball of radius  centered at , and observe that (a) any
point in the first (resp., second) intersection can serve as the
center of a ball of radius  which contains  (resp.,
), and (b) no ball of radius  can cover 
(resp., ) if the corresponding intersection is empty.
Moreover, when we cross from a cell  to a neighbor cell
,  changes by the insertion or deletion of a single
point, and  undergoes the opposite change, so each of the
sets of balls ,  changes by the deletion or insertion of a single ball.
As we know the sequence of updates in advance, maintaining
dynamically the intersection of either of these sets of balls can be
done in an offline manner. Still, the actual implementation is
fairly complicated. It is performed using a variant of the
multi-dimensional parametric searching technique of
Matou\v{s}ek~\cite{JM} (see also~\cite{TCA, CMS, NPT}). The same
procedure is also used by the second improved algorithm. For the
sake of readability, we describe this procedure towards the end of
the paper, in Section~\ref{sec:spherical_polytopes}.


The main algorithm uses a segment tree to represent the sets
 (and another segment tree for the sets ).
Roughly, viewing the traversal of  as a sequence  of
cells, each ball  has a \emph{life-span} (in ),
which is a union of contiguous maximal subsequences of cells ,
in which , and a complementary life-span in
. We store these (connected portions of the) life-spans as
segments in the segment tree. Each leaf of the tree represents a
cell  of , and the balls stored at the nodes on the path
to the leaf from the root are exactly those whose centers belong to
the set  (or ). By precomputing the intersection
of the balls stored at each node of the tree, we can express each of
the intersections  and
, for each cell , as
the intersection of a logarithmic number of precomputed
intersections (see also~\cite{DE}). We show that such an
intersection can be tested for emptiness in  time. This
in turn allows us to execute the decision procedure with a total
cost of . We then return to the original
optimization problem and apply a variant of Chan's randomization
technique~\cite{TCG} to solve the optimization problem by a small
number of calls to the decision problem, obtaining an overall
algorithm with  \emph{expected} running
time.\footnote{\small The earlier algorithm in~\cite{AES} follows
the same general approach, but uses an even more complicated, and
slightly less efficient machinery for dynamic emptiness testing of
the intersection of congruent balls.}

\subsection{The improved solution}
\label{subsec:n^2_sketch} The above algorithm runs in nearly cubic
time because it has to traverse the entire arrangement , whose
complexity is . In Section~\ref{sec:improved_alg} we improve
this bound by traversing only portions of , adapting some of the
ideas in Sharir's improved solution for the planar
problem~\cite{MS}. Specifically, Sharir's algorithm solves the
decision problem (for a given radius ) in three steps, treating
separately three subcases, in which the centers  of the
two covering balls are, respectively, far apart (),
at medium distance apart () and near each
other (). We base our solution on the techniques
used in the first two cases, which, for simplicity, we merge into a
single case (as done in~\cite{DEF} for the planar case), and extend
it so that we only need to assume that , for
any fixed . In more detail, letting  denote the
disk of radius  centered at a point , Sharir's algorithm
guesses a constant number of lines , one of which separates the
centers  of the respective solution disks , so
that the set  of the points to the left of  is contained in
. We then compute the intersection , and intersect each , for  (the subset of points to the right of ), with
. It is easily seen that  has linear
complexity and that each circle , for ,
intersects it at two points (at most). This produces  critical
points (vertices and intersection points) on  and
 arcs in between. As argued in~\cite{MS}, it suffices to
search these points and arcs for possible locations of the center of
 (and dynamically test whether the balls centered at the
uncovered points have nonempty intersection).

Generalizing this approach to , we need to guess a separating plane , to retrieve the subset  of points to the left of , to compute  (which, fortunately, still has only linear complexity), to intersect , for each , with , and to form the arrangement of the resulting intersection curves. Each cell of this arrangement is a candidate for the location of the center of the left covering ball , and for each placement in ,  contains the same fixed subset of  (which depends only on ).

However, the complexity of the resulting arrangement  on
 might potentially be cubic. We therefore compute only
a portion  of , which suffices for our purposes, and prove
that its complexity is only . This is the main geometric
insight in the improved algorithm, and is highlighted in
Lemma~\ref{lemma:quadratic_K_P_L}. We show that if there is a
solution then  guesses suffice to find a separating
plane. This implies that the running time of the improved decision
procedure is . Thus, it is nearly
quadratic for any fixed value of . We show that one can take
, where  is the radius of the smallest
enclosing ball of .

To solve the optimization problem, we conduct a search on the
optimal radius , using our decision procedure, starting from
small values of  and going up, halving the gap between  and
 at each step\footnote{\small We have to act in this manner to
make sure that we do not call the decision procedure with values of
 which are too close to , thereby losing control over the
running time.}, until the first time we reach a value .
Then we use a variant of Chan's technique~\cite{TCG}, combined with
our decision procedure, to find the exact value of . The way
the search is conducted guarantees that its cost does not exceed the
bound , for the separation parameter
 for . Hence, we obtain a randomized
algorithm that solves the 2-center problem for any positive
separation of  and , and runs in  expected time.



\section{A Nearly Cubic Algorithm}
\label{sec:cubic_alg}

\subsection{The decision procedure}
\label{subsec:decision_procedure} In this section we give details of
the implementation of our less efficient solution, some of which are
also applicable for the improved solution. Recall from the
description in Section~\ref{sec:sketches} that the decision
procedure, on a given radius , constructs two segment trees , on the life-spans of the balls , for  (with
respect to the tour of the dual plane arrangement ). Each leaf
is a cell  of , and the balls, whose centers belong to
 (resp., ), are those stored at nodes on the
path from the root to  in  (resp., ).

For each node  of , let  denote the intersection of all
the balls (of radius ) stored at . We refer to each  as a
\emph{spherical polytope}; see~\cite{BCT, BLNP, BN} for (unrelated)
studies of spherical polytopes. We compute each  in  deterministic time, using the algorithm by
Br\"{o}nnimann et al.~\cite{BCM} (see also~\cite{CS, ER} for
alternative algorithms). Since the arrangement  consists of
 cells, standard properties of segment trees imply that the
two trees require  storage and 
preproccessing time.

Clearly, the intersection  (resp., ) of
the balls whose centers belong to  (resp., ) is
the intersection of all the spherical polytopes , over the
nodes  on the path from the root to  in  (resp.,
).

\paragraph{Intersection of spherical polytopes.}
Let  be the set of 
spherical polytopes stored at the nodes of a path from the root to a
leaf of  or of , where, as above, a spherical polytope is
the intersection of a finite set of balls, all having the common
radius . Each  is the intersection of some  balls, and
. Our current goal is to determine, in
polylogarithmic time, whether the intersection  of the spherical
polytopes in  is nonempty. If this is the case for at least one
path of  and for the same path in  then , and
otherwise . Moreover, if there exist a pair of such paths
for which both intersections have nonempty interior, then 
(because we can then slightly shrink the balls and still get a
nonempty intersection). If no such pair of paths have this property,
but there exist pairs with nonempty intersections (with at least one
of them being degenerate) then .

The algorithm for testing emptiness of  is technical and fairly
involved. For the sake of readability, we delegate its description
to Section~\ref{sec:spherical_polytopes}. It uses a variant of
multidimensional parametric searching which somewhat resembles
similar techniques used in ~\cite{TCA, CMS, JM, NPT}. It is
essentially independent of the rest of the algorithm (with some
exceptions, noted later). We summarize it in the following
proposition.

\begin{proposition}
\label{prop:intersection_test} Let  be a collection of spherical
polytopes, each defined as the intersection of at most  balls of
a fixed radius . Let  denote the sum, over the polytopes of
, of the number of balls defining each polytope. After a
preprocessing stage, which takes  time and uses 
storage, we can test whether any  polytopes of 
have a nonempty intersection in  time, and also
determine whether the intersection has nonempty interior.
\end{proposition}

Hence, we check, for each cell , whether each of 
and  are nonempty and non-degenerate. To this end, we
go over each path of , and over the same path of , and
check, using the procedure described in
Proposition~\ref{prop:intersection_test}, whether the spherical
polytopes along the tested paths (of  and of ) have a
nonempty intersection (and whether these intersections have nonempty
interiors). We stop when a solution for which both  and
 are nonempty and non-degenerate is obtained, and
report that . Otherwise, we continue to test all cells
. If at least one degenerate solution is found (i.e., a
solution where both  are nonempty, and at
least one of them has nonempty interior), we report that ,
and otherwise .

By proposition~\ref{prop:intersection_test}, the cost of this
procedure is . This subsumes the cost of all the
other steps, such as constructing the arrangement  and the
segment trees . We therefore get a decision procedure
which runs in  (deterministic) time.

\subsection{Solving the optimization problem}
\label{subsec:optimization_problem}
We now combine our decision procedure with the randomized
optimization technique of Chan~\cite{TCG}, to obtain an algorithm
for the optimization problem, which runs in 
\emph{expected} time. Our application of Chan's technique, described
next, is somewhat non-standard, because each recursive step has also
to handle global data, which it inherits from its ancestors.

Chan's technique, in its ``purely recursive'' form, takes an optimization problem that has to compute an optimum value  on an input set . The technique replaces  by several subsets , such that , and  for each  (here  and  are constants). It then processes the subproblems  in a \emph{random} order, and computes  by comparing each  to the minimum  collected so far, and by replacing  by  if the latter is smaller.\footnote{\small So the value of  keeps shrinking.} Comparisons are performed by the decision procedure, and updates of  are computed recursively. The crux of this technique is that the expected number of recursive calls (in a single recursive step) is only , and this (combined with some additional enhancements, which we omit here) suffices to make the expected cost of the whole procedure asymptotically the same as the cost of the decision procedure, for \emph{any} values of  and . Technically, if the cost  of the decision procedure is
, where  is some fixed positive constant, the expected running time is  provided that

However, even when (\ref{equation:lnr}) does not hold ``as
is'', Chan's technique enforces it by compressing  levels of the
recursion into a single level, for  sufficiently large, so its expected cost is still . See~\cite{TCG} for details.


To apply Chan's technique to our decision procedure,
we pass to the dual space, where each point  is mapped to a
plane , as done in the decision procedure. We obtain the set  of dual planes, and we consider its arrangement
, where each cell  in  represents an
equivalence class of planes in the original space, which separate 
into the same two subsets of points .

To decompose the optimization problem into subproblems, as required
by Chan's technique, we construct a -\emph{cutting} of
the dual space. We recall that, given a collection  of 
hyperplanes in  and a parameter , a -\emph{cutting} of  of size  is a
partition of space into  (possibly unbounded) openly disjoint
-dimensional simplices , such that the
interior of each simplex  is intersected by at most
 of the hyperplanes of . See~\cite{JMC} for more
details.  We use the following well known result~\cite{BC, CF}:

\begin{lemma}
\label{lemma:cutting}
Given a set  of  hyperplanes in , a
-cutting of  of size  can be constructed
in time , for any .
\end{lemma}

Returning to our setup, we construct a -cutting for
, for a specific constant value of , that we will
fix later, and obtain  simplices, such that the
interior of each of them is intersected by at most 
planes of . Each simplex  corresponds to one
subproblem and contains some (possibly only portions of) cells
 of the arrangement . We recall that each
cell  represents an equivalence class of planes which
separate  into two subsets of points  and
. Hence,  represents a collection of such
equivalence classes. All these subproblems have in common the sets
, , consisting,
respectively, of all the planes that pass fully above  and
those that pass fully below . (These sets are dual to
respective subsets  of , where
 is contained in all the sets , for
the cells , that meet , and symmetrically for
.) Note that most of the dual planes belong to
; the ``undecided''
planes are those that cross the interior of , and their
number is at most . We denote the set of these planes as
 (and the set of their primal points as
).


To apply Chan's technique, we construct two segment trees on the
arrangement of , as described in Section~\ref{subsec:decision_procedure}. Consider one of these segment trees, ,
that maintains the set of balls . Each cell  in  is represented by a
leaf of . Each ball is represented as a collection of disjoint
life-spans, with respect to a fixed tour of the cells of ,
which are stored as segments in , as described earlier.
In addition, we compute the intersection of the balls centered
at the points of , in  time, and store it at
the root of . Note that, as we go down the recursion, we keep
adding planes to , that is, points to , and the
actual set  of points dual to the planes above the
current  is the union of logarithmically many subsets, each
obtained at one of the ancestor levels of the recursion, including the current step.
However, we cannot inherit the precomputed intersections of the balls
in these subsets of  from the previous levels, since, as we go down the
recursion, Chan's technique keeps `shrinking' the radius of the balls. Hence, each
time we have to solve a decision subproblem, we compute the
intersection of the balls centered at the points of 
(collected over all the higher levels of the recursion)
from scratch. (See below for details on the additional cost incurred
by this step.) We build a second segment tree 
that maintains the balls of , in a fully analogous manner. The running time so far (of the decision procedure)
is , where  is the
number of planes in  and  is the size of the
initial input set .

To solve the decision procedure for a given subproblem associated
with a simplex , we test, by going over all the
root-to-leaf paths in  and , whether there exists a cell
 (overlapping ), for which the intersections of the
spherical polytopes on the two respective paths in  and 
are nonempty (and, if nonempty, whether they both have nonempty
interiors). The overall cost of this step, iterating over the
 cells of  and applying the
procedure from Section~\ref{subsec:decision_procedure} for
intersecting spherical polytopes, is .

When the recursion bottoms out, we have two subsets
, and  of  points, and a
constant number of points in . Hence, we try the
constant number of possible separations of  into an
ordered pair of subsets  and , and, for each of these separations, we compute the two
smallest enclosing balls of the sets  and
 in linear time. If both  and  can be covered by balls of
radius , for at least one of the possible separations of
 into two subsets, then we have found a solution for
the 2-center problem. (Discriminating between  or 
is done as in Section~\ref{subsec:decision_procedure}.)

We now apply Chan's technique to this decision procedure. Note that
this application is not standard because the recursive subproblems are
not ``pure'', as they also involve the ``global'' parameter . We
therefore need to exercise some care in the analysis of the expected
performance of the technique.

Specifically, denote by  an upper bound on the expected
running time of the algorithm, for preprocessing
a recursive subproblem involving  points, where the initial input
consists of  points. Then  satisfies the following recurrence.


where  is an appropriate absolute constant (so that 
bounds the number of cells of the cutting), and  is chosen
to be a sufficiently large constant so that (\ref{equation:lnr})
holds (with , and ).
It is fairly routine (and we omit the details) to show that the
recurrence (\ref{eqn:T(m,n)}) yields the overall bound  on the expected cost of the initial problem; i.e., . We thus obtain the following intermediate result.

\begin{theorem}
Let  be a set of  points in . A 2-center for 
can be computed in  randomized expected time.
\end{theorem}

\section{An Improved Algorithm}
\label{sec:improved_alg}

\subsection{An improved decision procedure }
\label{subsec:improved_decision_procedure}


\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{beta_a_s.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2347,1261)(3642,-392)
\put(5974,-17){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5931,450){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5772,710){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3718,-275){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4005, -9){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4319,311){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3657,574){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5306,311){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5072,545){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf The points  prevent  from getting smaller.} \label{figure:beta}
\end{center}
\end{figure}

Consider the decision problem, where we are given a radius  and a parameter , and
have to determine whether  can be covered by two balls of radius
, such that the distance between their centers  is at
least . (Details about supplying a good lower bound for  will be given in Section~\ref{sec:separated_centers_optimization}.)
By this we mean that there is no placement of two balls of radius , which cover , such that the distance between their centers is smaller than ; see Figure~\ref{figure:beta}.

This assumption is easily seen to imply the following property: Let
 denote the intersection circle of  and 
(assuming that ). Then any hemisphere
 of , such that (a) the plane  through 
delimiting  is disjoint from , and (b)  and
 lie on different sides of , must contain a point 
of , for otherwise we could have brought  and  closer
together by moving  in the normal direction of , into the
halfspace containing  (and ). See
Figure~\ref{figure:case2_assumption}.

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{case2_assumption_s.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2046,1849)(9147,-624)
\put(9747,1054){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10680,325){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9412, 74){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(11178,-37){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9314,618){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10293,-365){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9162,-254){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9665,205){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf The plane  passes through  and is
disjoint from . The hemisphere  delimited by ,
which lies on the side of  not containing , must
contain a point  of .} \label{figure:case2_assumption}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{new_case2_a_s.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2180,1859)(2895,-118)
\put(4529,944){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2910,325){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4115,207){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4073,1308){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5060,558){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3438,816){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf  is the leftmost point of the intersection
circle .} \label{figure:new_case2_1}
\end{center}
\end{figure}

\smallskip
\noindent{\bf Guessing orientations and separating planes.} We
choose a set  of canonical orientations, so that the maximum
angular deviation of any direction  from its closest direction in
 is an appropriate multiple  of . The connection
between  and  is given by the following reasoning.
Fix a direction  so that the angle between the orientation
of  and  is at most . Rotate the coordinate
frame so that  becomes the -axis. As above, let 
denote the intersection circle of  and 
(assuming that the balls intersect). Let  be the leftmost point
of  (in the -direction); see
Figure~\ref{figure:new_case2_1}. If  and  are disjoint
(which only happens when ) we define  to be the
leftmost point of . To determine the value of , we note
that (in complete analogy with Sharir's algorithm in the
plane~\cite{MS}) our procedure will try to find a -parallel
plane, which separates  from . For this, we want to ensure
that , say, to leave enough room for
guessing such a separating plane. Let  denote the angle
 (see Figure~\ref{figure:new_case2_2}). Using
the triangle inequality on angles, the angle between
 and the -axis is at most , so . Hence,
to ensure the above separation, we need to choose , such
that . Since , we have . Hence, it suffices to choose
, such that

With this constraint on , the size of  is
.

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{choosing_alpha_s2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2288,2090)(8909,-214)
\put(9994,-145){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9861,1002){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9889,-145){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8924,530){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(11050,660){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10506,1120){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9762,1232){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10026,1041){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10146,326){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9472,1002){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10080,1429){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf .}
\label{figure:new_case2_2}
\end{center}
\end{figure}

We draw  -parallel planes, with horizontal
separation of , starting at the leftmost point of 
(with respect to the guessed orientation). One of these planes will
separate  from . Thus, the total number of guesses that we
make (an orientation in  and a separating plane) is
. The following description pertains to a correct
guess, in which the properties that we require are satisfied. (If
all guesses fail, the decision procedure has a negative answer.)

\smallskip
\noindent{\bf Reducing to a 2-dimensional search.}
By the property noted above, the left hemisphere  of , delimited by
the -parallel plane  through ,
must pass through at least one point  of  (see Figure~\ref{figure:new_case2_left}).

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{leftsemiball_s2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2106,2010)(7061,-104)
\put(7076,307){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8659,918){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8288,162){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8002,1747){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7137,724){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9123,468){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7244,1238){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8210,1274){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7597,863){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7874,1747){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf The separating plane  and its parallel
copy  through . The hemisphere  of
 to the left of  must contain a point  of
.} \label{figure:new_case2_left}
\end{center}
\end{figure}


Let  denote the subset
of points of  lying to the left of . Then 
must be fully
contained in  and contain .
We compute the intersection 
in  time~\cite{BCM}. If  is empty, then  cannot be covered
by a ball of radius  and we determine that the currently assumed
configuration does not yield a positive solution for the decision problem.
Otherwise, since , 
must lie in
. Moreover, since  lies on the \emph{left} portion
of ,  must
lie on the \emph{right} portion of the boundary of . Finally, since  lies to the
left of , only the portion  of the right part of  to the left of  has to be considered.
If  is disjoint from  then  is just the right
portion of . Otherwise,  has a ``hole'', bounded by , which is a convex piecewise-circular curve, being the boundary of the intersection of the disks , for .

We partition  into \emph{quadratically many} cells, such
that if we place the center  of the left solution ball  in
a cell , then, no matter where we place it within ,
 will cover the same subset of points from . To construct
this partition, we intersect, for each , the sphere  with  and obtain a curve
 on ; this curve bounds the portion of the
unique face of  within . Hence,
within , it is a closed connected curve (it may be
disconnected within , though). Let  denote the
arrangement formed on  by the curves , for , and by the arcs of . Apriori,  might have
cubic complexity, if many of the  pairs of curves , for , traverse a linear number of common
faces of , and intersect each other on many of these
faces, in an overall linear number of points. Equivalently, the
``danger'' is that the intersection circle  of a
corresponding pair of spheres , for , could intersect a linear number of faces of 
(and each of these intersections is also an intersection point of
 and ). See Figure~\ref{figure:new_case2_cubic}.

\begin{figure}[htbp]
\begin{center}

\begin{picture}(0,0)\includegraphics{new_case2_cubic.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1919,1932)(5845,-3354)
\end{picture} 
\caption{\small \sf In a general setup (different than ours), an intersection circle of two balls (the dotted circle) may
intersect a linear number of faces of .}
\label{figure:new_case2_cubic}
\end{center}
\end{figure}

\smallskip
\noindent{\bf Complexity of .} Fortunately, in the assumed
configuration, this cubic behavior is impossible ---  can
meet only a constant number of faces of . Consequently,
the overall complexity of  is only quadratic. This crucial claim
follows from the observation that, for  to intersect many
faces of , it must have many short arcs, each delimited by
two points on  and lying outside . The main
geometric insight, which rules out this possibility, and leads to
our improved algorithm, is given in the following lemma.

\begin{lemma}
\label{lemma:quadratic_K_P_L}
Let  be a -parallel plane, which separates  from .
Let  be the subset of points of  to the left of , and let .
Let  denote the intersection circle of , for some pair of points , and let . If the arc  is smaller than a semicircle of , then at least one of its endpoints must lie to the right of .
\end{lemma}

\begin{proof}The situation and its analysis are depicted in Figure~\ref{figure:lemma_setup}. To slightly simplify the analysis, and without loss of generality, assume that . Let  be the plane passing through ,  and . Let 
denote the midpoint of , and let  denote the center of the
circumscribing circle  of . Denote the distance 
by , and the radius of  by  (so ).
Note that  and  lie in  and that .
Observe that  is the center of the intersection circle  of
 and . See Figure~\ref{figure:lemma_setup}(a).

\begin{figure}[htbp]
\begin{center}
\begin{tabular*}{0.8\textwidth}{c c c}
            \hspace{-35pt} {\input{h_setup_s2.pstex_t} } &  & {\begin{picture}(0,0)\includegraphics{C_ab_s2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1419,2431)(5132,-3533)
\put(6299,-2458){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6536,-2290){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6106,-1242){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6227,-1840){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6233,-3086){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6116,-3021){\rotatebox{90.0}{\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}}
\put(5624,-2317){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5399,-2925){\rotatebox{35.0}{\makebox(0,0)[lb]{\smash{{\SetFigFont{9}{10.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}}
\put(5283,-1951){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}  } \\
    \small (a) & \hspace{15pt} & \small (b) \\
    \hspace{45pt} & {\begin{picture}(0,0)\includegraphics{abq_s2.pstex}\end{picture}\setlength{\unitlength}{1657sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(5499,3520)(1923,-2601)
\put(6176,287){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3131,543){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2502,-1484){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4984,-618){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3167,-2471){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2580,-897){\makebox(0,0)[rb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4431,-601){\makebox(0,0)[lb]{\smash{{\SetFigFont{11}{13.2}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}  } & \hspace{45pt}\\
     \hspace{-35pt} & \small (c) &
\end{tabular*}

       \vspace{20pt}
\caption{\small \sf The setup in Lemma~\ref{lemma:quadratic_K_P_L}:
           (a) the setup within the plane ; (b) the setup within
    ; (c)  lies on the bisector of  in
           the direction that gets away from .}

\label{figure:lemma_setup}
\end{center}
\end{figure}

The intersection points  of  and  are the
intersection points of the three spheres
, , and .
They lie on the line  passing through  and orthogonal
to , at equal distances  from . See Figure~\ref{figure:lemma_setup}(b).
(If  then  and  do not exist, in which case  does not intersect ; in what follows we assume
that .)
Hence, within ,  is a chord of length .
In the assumed setup,  and 
delimit a short arc  of , which lies outside ,
so points on the arc are (equally) closer to  and  than to
.


Hence, the projection of the arc  onto  is a small
interval , which lies on the bisector of  in the
direction that gets away from ; that is, it lies on the Voronoi
edge of  in the diagram  within . See Figure~\ref{figure:lemma_setup}(c).
Moreover,  also lies on the bisector, but it has to lie on the
other side of , or else the smaller arc  would have to lie
inside . That is,  has to be closer to  than to 
and . Since  separates  and  from , it also separates
  from . Moreover, the preceding arguments are easily seen to imply that  crosses  (as in Figure~\ref{figure:lemma_setup}(a)), which implies that  also separates  and , so
 has to lie to the right of . Since  and  lie on
two sides of  on the line , at least one of them has to lie on
the same side of  as  (i.e., to the right of
). This completes the proof.
\end{proof}

Let  and consider those arcs of  which lie outside  but their endpoints lie on . Clearly, all these arcs are pairwise disjoint. At most one such arc can be larger than a semicircle. Let  be an arc of this kind which is smaller than a semicircle, and let  be such that one endpoint of  lies on . Then  is contained in  and therefore is also smaller than a semicircle. By Lemma~\ref{lemma:quadratic_K_P_L}, exactly one endpoint of  lies to the right of  (the other endpoint lies on ).
Note that  cannot have more than two such short arcs lying outside , since, due to the convexity of , only two arcs of  can have their two endpoints lying on opposite sides of . Hence the number of arcs of  under consideration is at most 3, implying that  and  intersect at most three times, and thus the complexity of  is , as asserted.

\smallskip
\noindent{\bf Constructing and searching .} The next step of the
algorithm is to compute . We have already constructed
, in  time, and, in additional linear
time, we can compute its portion  to the left of 
(we omit the straightforward details). We compute the intersection
curve  of  and , for each ,
in  time, by computing the intersection , and obtaining the curve which bounds the portion of the
unique face of  within . If
necessary, we also split  into portions, such that each
portion is contained in a different face of . The total
cost of computing all curves , and
spreading them along the faces of , is .
Then, for each face  of , we consider the portions of
all the arcs , for , within , and compute
their arrangement (which is the portion of  which lies in ).
To this end, we use standard line-sweeping~\cite{book}, to report
all the intersections of  curves in the plane in  time, where  is the complexity of the resulting
arrangement on . Hence, the total cost of computing the portion
of  on all the faces of  is , since the complexity of  is
.

We next perform a traversal of the cells of  in a manner similar to the one used in Section~\ref{sec:cubic_alg}, via a tour, which proceeds from each visited cell to an adjacent one. For each cell  that we visit, we place
the center  of  in , and maintain dynamically the subset
 of points of  not covered by . (Here, unlike the algorithm of Section~\ref{sec:cubic_alg}, the complementary set   is automatically covered by  and there is no need to test it.) As before,
when we move
from one cell  to an adjacent cell ,  gains
one point or loses one point. This implies that this tour generates only  connected life-spans of the points of , where a life-span of a point  is a maximal connected interval of the tour, in which  belongs to . We can thus use a segment tree  to store these life-spans, as before. Each
leaf  of  represents a cell  of , and the balls not containing  are those with life-spans that are stored at the nodes on the path from the root to . Since  has a quadratic number of
cells,  has a total
of  leaves. Arguing exactly as in Section~\ref{subsec:decision_procedure}, we can compute  in overall  time, and the total storage used by  is .

As in Section~\ref{subsec:decision_procedure}, we next test, for
each leaf  of , whether the spherical polytopes along the
path from the root to  have non-empty intersection. We do this
using the parametric search technique described in
Proposition~\ref{prop:intersection_test}, which takes 
time for each path, for a total of . More
precisely, as above, we also need to distinguish between 
and . We therefore stop only when both the intersection
along the path and the cell of  corresponding to  are
non-degenerate, and then report that . Otherwise, we
continue running the above procedure over all paths of , and
repeat it for each of the  combinations of an
orientation  and a separating plane . If we find at
least one (degenerate\footnote{Note that  is non-degenerate if  is a 2-face or an edge. If
 is a vertex we test for degeneracy as in the procedure in
Section~\ref{subsec:decision_procedure}. Determining whether
 is degenerate is also
performed using that procedure.}) solution, we report that , and otherwise conclude that . Hence, the cost of handling Case~2, and thus also the overall
cost of the decision procedure, is .

\subsection{Solving the optimization problem}
\label{sec:separated_centers_optimization}

We now combine the decision procedure  described in Section~\ref{subsec:improved_decision_procedure} with the randomized optimization
technique of Chan~\cite{TCG} (as briefly described in Section~\ref{subsec:optimization_problem}),
to obtain a solution for the optimization problem.

The decision procedure , on a specified radius , relies on an apriori knowledge of a lower bound  for the separation ratio
. To supply such a , let  denote the radius of the smallest
enclosing ball of , and observe that if there exist two balls  of radius  covering  then the smallest ball  enclosing  must be at least as large as the smallest enclosing ball of , so its radius must be at least . Since this radius is
 (see Figure~\ref{figure:new_case2_SEB}), we have
 or .
It follows that the running time of the decision procedure  is


\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{B_s2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1856,2037)(12710,-942)
\put(14230,217){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12968,217){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(14027,-878){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(13951,-313){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(13085,-351){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(13273,-50){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(13876,-87){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(13583,243){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf The smallest enclosing ball  of .} \label{figure:new_case2_SEB}
\end{center}
\end{figure}

Chan's technique starts with a very big  (for all practical
purposes we can start with ) and shrinks it as it iterates
over the subproblems. Therefore, running Chan's technique in a
straightforward manner, starting with , will make it
potentially very inefficient, because the initial executions of
, when  is still close to , may be too expensive due
to the large constant of proportionality (not to mention the run at
 itself, which the algorithm cannot handle at all). We need to
fine-tune Chan's technique, to ensure that we do not consider values
of  which are too close to . To do so, we consider the
interval  which contains , and run an ``exponential
search'' through it, calling  with the values , for , in order, until the
first time we reach a value . Note that  and , so our lower
bound estimates for the separation ratio  at  and at
 differ by at most a factor of , so the cost of running
 at  is asymptotically the same as at . Moreover,
since the (constants of proportionality in the) running time bounds
on the executions of  at  form a geometric
sequence, the overall cost of the exponential search is also
asymptotically the same as the cost of running  at . We
then run Chan's technique, with  as the initial minimum radius
obtained so far. Hence, from now on, each call to  made by
Chan's technique will cost asymptotically no more than the cost of
calling  with  (which is asymptotically the same as
calling  with ).

\paragraph{Combining Chan's technique with the decision procedure .}
To apply Chan's technique with our decision procedure, we use the
same cutting-based decomposition as in
Section~\ref{subsec:optimization_problem}. That is, we replace each
point  by its dual plane , and construct a
-cutting of , for some sufficiently large
constant parameter . We then apply Chan's technique to
the resulting subproblems (where each subproblem corresponds to a
simplex  of the cutting), using the improved decision
procedure  on each of them, and recursing into some of them,
as required by the technique. As in Section~\ref{sec:cubic_alg}, the
recursion and the application of the decision procedure are not
``pure'', because they need to consider also those planes that miss
the current simplex. (Note that in the problem decomposition we use,
for simplicity, the full 3-dimensional arrangement , of
cubic size. This, however, does not affect the asymptotic running
time, because we have only a constant number of subproblems, and
Chan's technique recurses into only an expected logarithmic number
of them.) Given a radius , we compute the lower bound  for the separation ratio
, where  are the centers of the two
covering balls, as above. Consider the application of  to a
subproblem represented by a simplex  of the cutting. The
presence of ``global'' points (those dual to planes passing above or
below ) forces us, as in
Section~\ref{subsec:optimization_problem}, to modify the ``pure''
version of  described above. We use the same notations as in
Section~\ref{sec:cubic_alg}.

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{h_lambda_s2.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1904,2148)(4839,-982)
\put(5805,-907){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4854,-302){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4883,725){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6728,-86){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6217,281){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6049,-909){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5833,686){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5479, 47){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} 
\caption{\small \sf  does not contain any point of
.} \label{figure:h_lambda}
\end{center}
\end{figure}

We again rotate the coordinate axes, in 
ways (in the same manner as in the ``pure'' decision procedure), and
draw  -parallel planes, such that, at the correct
orientation, one of these planes, , separates  from
 (if there is a solution for ). As in the pure case, we may
assume that the -span of  is at most ; a larger span is
handled earlier. We assume, without loss of generality, that
, and that . Recall also that the points in the left halfspace 
bounded by  are all contained in . Moreover, the plane
 containing the intersection circle  is dual to a point
, which has to separate  from
. Hence, all the points of  have
to lie on the other side of , and in , which is easily
seen to imply that none of them can lie in . See
Figure~\ref{figure:h_lambda}. We thus verify that , aborting otherwise the guess of
. (Note that, in contrast, points of  can
also lie to the right of .)

We now have a subset  of  points
to the left of , which are assumed, together with the
points of , to be contained in . Note however
that, for Lemma~\ref{lemma:quadratic_K_P_L} to hold, we have to
define  only in terms of the points to the left of
. Therefore, we compute the surface  and search on
it for a placement of the center  of . However, since the
remaining points of  are also assumed to belong to
, we need to consider only the portion of  inside
.
Let  denote this portion. It is easy to compute
 in  time. It is easily checked that 
must lie on  (if there is a solution for the current
situation). So far, the cost of the decision procedure also depends
(cheaply --- see below) on the initial input size , but the
saving in this setup comes from the fact that it suffices to
intersect the  spheres , for , with  to obtain the
map , since only the points of  are
``undecided''. (The points of  are always placed in
 as already discussed.)

Note that  need not to be connected, so it may seem
impossible to visit all the cells of  in a single connected tour.
Nevertheless, we will be able to do it, in a manner detailed below.
We thus build a segment tree  to maintain the subset 
of points of  not covered by . We build and query  as
is done in Section~\ref{subsec:decision_procedure}, except for the
following modifications. First, note that the points of
 are assumed to be contained in . Thus, the
points of , that in the decision procedure were
considered in building , do not need to be considered as part of
 now, rather it is enough to build the spherical polytope
 and place it at the
root of . Second, we claim that  is of complexity .
To see this, let  denote the set of curves . Each pair of curves of
 can intersect each other in only a constant number of points,
as proved in Section~\ref{subsec:improved_decision_procedure}.
Hence, the complexity of the arrangement of the  curves in
, formed on , is . However, 
itself is of complexity , and each edge of  may
intersect the curves of  at  points. Hence, the
complexity of the map  is , but the number of its
vertices that lie in the interior of the faces of  is only
.

To overcome the possible disconnectedness of , we
proceed as follows. We consider the (connected) network of the
 edges of , and intersect each of these edges with
the  balls , for . We construct a
tour of this network, which visits  arcs along the edges of
, and append to this ``master tour'' separate tours of
each face of . We get in this way a single grand tour of
the cells of  (which also traverses some superfluous arcs of
), of length , which has the
incremental property that we need: Moving from any cell or arc of
the tour to a neighbor cell or arc incurs an insertion or a deletion
of a single point into/from .


\paragraph{Running time.}
For each cell of  we run the procedure described in
Proposition~\ref{prop:intersection_test} for determining whether the
intersection of the corresponding spherical polytopes is nonempty
(and whether it has nonempty interior). Therefore, solving each
subproblem requires  time. The  time
required to build , and the  time required to
construct the intersection of the balls in , are all subsumed in that cost. Repeating this for
each of the  guesses of an orientation and a
separating plane, results in 
rnning time. When the recursion bottoms out, we handle it the same
way as in Section~\ref{subsec:optimization_problem}.

Arguing similarly to the less efficient solution, we obtain the
following recurrence for the maximum expected cost  of
solving a recursive subproblem involving  ``local'' points, where
 is the number of initial input points in .


where  is an appropriate absolute constant (as in
Section~\ref{subsec:optimization_problem}),  is the
parameter of the cutting, chosen to be a sufficiently large constant
(to satisfy (\ref{equation:lnr}), as above, with ), and
, where  is the value of  at
which the initial exponential search is terminated.

It can be shown rather easily (and we omit the details, as we did in
the preceding section), that the recurrence~(\ref{eqn:T(m,n)_2})
yields the overall bound  on
the expected cost of the initial problem; i.e.,
 We thus finally obtain
our main result:
\begin{theorem}
Let  be a set of  points in . A 2-center for 
can be computed in  randomized
expected time, where  is the radius of the balls of the
2-center for  and  is the radius of the smallest enclosing
ball of .
\end{theorem}

\section{Efficient Emptiness Detection of Intersection of Spherical
Polytopes} \label{sec:spherical_polytopes} In this section we
describe an efficient procedure for testing emptiness (and
non-degeneracy) of the intersection of spherical polytopes, as
prescribed in Proposition~\ref{prop:intersection_test}. Let  be
a collection of spherical polytopes, each defined as the
intersection of at most  balls of a fixed radius . Fix a
spherical polytope . To simplify the forthcoming analysis,
we assume that the centers of the balls involved in the polytopes of
 are in general position, meaning that no five of them are
co-spherical, and that there exists at most one quadruple of centers
lying on a common sphere of radius . As is well known, each ball
 participating in the intersection  contributes at most one
(connected) face to  (see~\cite{ER}). The vertices and edges
of  are the intersections of two or three bounding spheres,
respectively (at most one vertex might be incident to four spheres).
Hence  is a planar (or, rather, spherical) map with at most
 faces, which implies that the complexity of  is
.

We preprocess  into a point-location structure. We first
partition  into its upper portion  and lower
portion . We project vertically each of  and
 onto the -plane and obtain two respective planar maps
 and  (see Figure~\ref{figure:projection}). For each face
 of each map we store the ball  that created it; that is,
 is the projection of the (unique) face of  that lies
on . The -projection  of  is equal to both
projections of , , and is bounded by a convex
curve  that is the concatenation of the -projections of
certain edges of  and of portions of horizontal equators of some
of its balls.

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{projection_log8.pstex}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(13067,3529)(1020,-3194)
\put(9450,-3071){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(10249,-2149){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12477,-1659){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1773, 32){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4199,-1900){\makebox(0,0)[lb]{\smash{{\SetFigFont{10}{12.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf Projecting  vertically onto the
-plane (left), and the point location structure for the
resulting map  (right).} \label{figure:projection}
\end{center}
\end{figure}

We apply the standard point-location algorithm of Sarnak and
Tarjan~\cite{ST} to each of the maps . That is, we divide
each planar map into slabs by parallel lines (to the -axis)
through each of the endpoints (and locally -extremal points) of
the arcs obtained by projecting the edges of , including the
new equatorial arcs. Using the persistent search structure
of~\cite{ST}, the total storage is linear in  and the
preprocessing cost is , where  is the number
of balls forming . To locate a point  in  (or in
), we first find the slab in the -structure that contains
, and then find the two curves between which  lies in the
-structure.\footnote{\small All these standard details are
presented to make more precise the infrastructure used by the
higher-dimensional routines  and .}

To determine whether , we locate the face 
(resp., ) of the map  (resp., ) that contains
, as just described. Each of these faces can be a 2-face, an edge
or a vertex. We therefore retrieve a set  (resp., ) of
the one, two, or three or four balls associated (respectively) with
the 2-face, edge or vertex containing . (We omit here the easy
construction of witness balls when the faces  and 
are not associated with any ball, that is, .)

Let  denote the set . We observe that  if and only if the -vertical line  through 
intersects . Moreover, we have, by construction, . Hence  if and only if
. Clearly,
if we put , then the preprocessing stage
takes a total of  time and requires  storage.

Next, let  be  spherical polytopes of
, for which we want to determine whether  is nonempty (and, if so, whether it has nonempty interior). We
solve this problem by employing a technique similar to the
multi-dimensional parametric searching technique of
Matou\v{s}ek~\cite{JM} (see also~\cite{AES, TCA, CMS, NPT}). We
solve in succession the following three subproblems, ,
where  is a point in the -plane, , where  is a
-parallel line in the -plane, and , over the entire
-plane. In the latter problem we wish to to determine whether
the -projection  of  is nonempty. During the execution
of the algorithm for solving , we call recursively the
algorithm for solving , for certain -parallel lines , and we wish to determine whether  meets
. If so, then  is solved directly (with a positive
answer). Otherwise, we wish to determine which side of , within
, can meet  (since  is convex, there can
exist at most one such side). The recursion bottoms out at certain
points , on which we run  to determine whether
 contains . If so, then  is solved directly (with
a positive answer). Otherwise, we determine which side of ,
within , can meet , and continue the search accordingly.

Our solutions to the subproblems , , are based
on generic simulations of the standard point-location machinery of
Sarnak and Tarjan~\cite{ST} mentioned above. In each of the
subproblems, if we find a point in , for the respective
point, line, or the entire -plane , we know that  and stop right away. If , we want
to ``prove'' it, by returning a small set of \emph{witness balls}
, where, for each ,  is one of the balls
that participates in some spherical polytope  (so ), so that their intersection  satisfies  (where, as above, 
is the -projection of ). If  then  too and we stop. Otherwise (when  is a line or a
point),  determines the side of  (within  if
 is a line, or within the containing line  if  is a point)
that might meet ; the opposite side is asserted at this point
to be disjoint from . We use this information to perform binary
search (or, more precisely, parametric search) to locate 
within the flat, from which we have recursed into .  The
execution of the algorithm for solving  will therefore either
find a point in  or determine that , because it
has collected a small (as we will show, polylogarithmic) number of
witness balls, whose intersection, which has to contain , is
found to be empty.

\paragraph{Solving  for a point .}
\label{subsec:Pi_0}
Here we have a point  and we wish to determine
whether . To do so, we locate  in each of the maps
 (the -projection of ) and  (the
-projection of ), for each . If 
lies outside the projection of at least one polytope  then , and we return the witness balls that prove that . Otherwise, as explained above, each point location
returns a set  of  witness balls for . We compute
the  line segments , for each
, where  is, as above, the -vertical
line through . We then have , so it suffices to compute this intersection
(in  time) and test whether it is nonempty. If  is
nonempty, then we have found a point  in . Otherwise, we
return the set  of up
to  balls as witness balls for the higher-dimensional step
(involving the -parallel line containing ).

The time complexity for solving  is , since
it takes  time to compute, for each of the 
spherical polytopes , the intersection .

\paragraph{\bf Solving  for a line .}
\label{subsec:Pi_1}
Here we have a -parallel line  and we
wish to determine whether  meets . We first locate  in
each of the planar maps  and  of each , and find
the slabs  and , which contain  (in some
cases  is the common bounding line of two adjacent slabs
 and  of  or of , so we retrieve
both slabs). We then run a binary search through the -structure
of each of the obtained slabs to find a point in , if
one exist. In each step of the search, within some fixed slab
, we consider an arc  of the -structure, and
determine whether  meets  above or below  (within
), assuming . To this end,
we find the intersection point , and run the
algorithm for solving  (see Figure~\ref{figure:pi_1}).
If , then we have found a point  in , and we
immediately stop. Otherwise, we have a set  of up to  balls returned by the algorithm for solving . We test
whether the -projection  of  intersects
. If , then (due to the convexity of
) we know which side of  (within ) meets ,
and we return  as a set of witness balls for the
higher-dimensional (planar) step. Otherwise (again due to the
convexity of ), we know which side of , within , meets
, and we continue the search through the -structure of
 on this side. We continue the search in this manner, until,
for each , we obtain an interval  of  between two
consecutive arcs of the -structure of , which meets 
(assuming ). Let  denote the
collection of all these intervals. Clearly, . We find the lowest endpoint  among the top
endpoints of the intervals in  and the highest endpoint 
among the bottom endpoints of the intervals in , and test
whether  is above . If so, we consider the set  of
up to  witness balls returned by the algorithms for
solving  and . If the -projection
 of  intersects , then  meets  and
we stop immediately, for we have found that  is nonempty.
Otherwise, we know which side of  (within ) can
meet , and we return  as a set of witness balls for the
higher (planar) recursive level. If  is not above , then
 and we return  as a set of witness
balls for the higher (planar) recursive level as well.\footnote{With
some care, the number of witness balls can be significantly reduced.
We do not go into this improvement, because handling the witness
balls is an inexpensive step, whose cost is subsumed by the cost of
the other steps of the algorithm.}

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{pi_1_log8.pstex}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2120,4802)(598,-3758)
\put(1547,-3626){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1478,669){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(797,-1214){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1764,-1192){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf The line  on which we run . The
point  on which we run  is the intersection point
of  with some arc .} \label{figure:pi_1}
\end{center}
\end{figure}

A naive implementation of the above procedure takes 
time, since for each of the  spherical polytopes  we
run a binary search through the -structure of at most two slabs
of each of the maps  and , and in each of the binary
search steps, we run the algorithm for solving  for some
point . The other substeps take less time. However, we can
improve the running time by implementing it in a parallel manner and
simulating the parallel version sequentially with a smaller number
of calls to .

We only parallelize the binary searches through the -structure of
each  and , since the other substeps take less time.
To this end, we use  processors, one for each of the
planar maps  and , and we run in parallel the binary
search through the -structure of each planar map using  parallel steps. In each parallel step we need to ``compare''
 arcs with  (one arc for each of the planar maps
, ). We therefore intersect each such arc with  and
obtain a set  of  intersection points. We then run a
binary search through the points of  (to locate ) using
. This determines the outcome of the comparisons of each of
the arcs with , and the parallel execution can proceed to the
next step. Applying this approach to each of the 
parallel steps results in an -time
algorithm for solving . However, we can slightly improve
this bound further using a simple variant of Cole's
technique~\cite{RC}. More precisely, in each parallel step we have a
collection  of  weighted points, one for each map,
which we need to compare with . We select the (weighted) median
point  of  and run . This determines the
outcomes of the comparisons between  and each of the points in
 which lie to the opposite side of  to the side containing
. Points in  which lie in the same side of  as ,
in level  of the parallel implementation, are given weight
 and we try to resolve their comparison to  in the
next step. An easy calculation (simpler than the one used by Cole)
shows that this method adds only  steps to the  parallel steps of the searches, and now in each parallel step we
perform only one call to  (see~\cite{RC} for more details).
Therefore, the total running time of  is .

\paragraph{\bf Solving .}
\label{subsec:Pi_2}
We next consider the main problem , where we want to
determine whether  (i.e., whether ). We use parametric searching, in which we run the point
location algorithm that we used for solving , in the
following generic manner.

In the first stage of the generic point location, we run a binary
search through the slabs of each of the planar maps  and
, for . In each step of the search through any
of the maps, we take a line  delimiting two consecutive slabs
of the map, and run the algorithm for solving , thereby
deciding on which side of  to continue the search. At the end
of this stage, unless we have already found a point in  or
determined that  is empty, we obtain a single slab in each map
that contains .  Let  denote the intersection of these
slabs, which must therefore contain  (unless  is empty). The
cost of this part of the procedure is .

In the next stage of the generic point location, we consider each
map  or  (for simplicity we refer to it just as )
separately, and run a binary search through the -structure of its
slab  that contains . In each step of the search we
consider an arc  of the -structure, and determine which
side of  (within the slab ), can meet , assuming
that ; if  we will detect it and stop right away. Before describing
in detail how to resolve each comparison with an arc , we
note that this results in  comparisons of arcs 
to  for each of the  planar maps  and
. However, we can reduce the number of comparisons to  in total, by simulating (sequentially) a parallel implementation
of this step, as follows. There are  parallel steps, and
in each step we execute a single step of the binary search in each
of the maps . In each parallel step we need to compare
 to a set  of  arcs, one of each of the planar
maps . Consider the portion  of the
arrangement  of the arcs in  which lies in . Let
 denote the set of  -parallel lines which pass
through the vertices of . We run a binary search through the
lines of , using calls to the algorithm for  to guide
the search, to locate  amid these lines, in a total of
 running time. This step (if it did not
find a line crossing ) may trim  to a narrower slab
 in which  must lie if . Put , and observe that the arcs
of  are pairwise disjoint and form a sorted sequence in the
-direction. We then perform a binary search through the arcs in
, using  comparisons to . Each comparison
is carried out in  time, in a manner detailed below.
Once the binary search is terminated, we can determine the outcomes
of the comparisons between  and each of the arcs in  and
proceed to the next parallel step. Applying this approach to each of
the  parallel steps results in an -algorithm for solving . We again use an appropriate
variant of Cole's technique to improve the running time by a  factor, in a manner similar to the one described in the
solution of .

To carry out a comparison between an arc  and ,
we act under the assumption that ,
and try to locate a point of  in each of the other
maps. Suppose, to simplify the description, that we managed to
locate the entire  in a single face of each of the other
maps , . This yields a set  of  balls, so
that a point  lies in  if and only if it lies in
the -projection  of . We then test whether
 intersects . If so, we have found a point in  and
stop right away. Suppose then that .
If  then  must be empty, because we
already know that . If , then we know on which side of  to continue the
binary search in (the portion within  of) .

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{pi_2_log8.pstex}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2739,5750)(5544,-3906)
\put(6294,911){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6891,-3770){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6693,-84){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5995, 44){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7494,-24){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7285,1469){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\small \sf Comparing  with . The
outcome of  determines (a) the side of  in which
the search in  should continue, and (b) the portion of
 which can still meet . The subslab  is drawn
shaded.} \label{figure:pi_2}
\end{center}
\end{figure}




In general, though,  might split between several cells of a
map , where  denotes, as above, one of the maps  or
. This forces us to narrow the search to a subarc of
, in the following manner. We run a binary search through
the -structure of the corresponding slab  of , which
contains , and repeat it for each of the maps . In each
step of the search, we need to compare  (or, more precisely,
some point in ) with some arc  of ,
which we do as follows. If  lies, within , completely
on one side of , we continue the binary search in 
on that side of . If  intersects , we pick
an intersection point  of  and , pass a
-parallel line  through , and run
the non-generic version of the algorithm to solve . (See
Figure~\ref{figure:pi_2}.) As before, if  we detect this and stop. Otherwise, we know which of the
two portions of , delimited by , can intersect . We
repeat this step for each of the at most four intersection points of
 and  (observing that these are elliptic arcs), and
obtain a connected portion  of , delimited by two
consecutive intersection points, whose relative interior lies
completely above or below , so that , if
nonempty, lies in . This allows us to resolve the generic
comparison with , and continue the binary search through
. (On the fly, each comparison with a line  narrows
 still further.)

To make this procedure more efficient, we perform the binary
searches through the slabs  in parallel, as follows. As
before, we run in parallel the binary searches through each of the
slabs  using  parallel steps. In each parallel
step we need to compare a set  of  arcs to ,
one arc  from each planar map . We intersect each of
the arcs in  with  and obtain a set  of 
intersection points. Let  denote the set of the 
-parallel lines which pass through the points of . We run a
binary search through the lines of , using calls to the
algorithm for  to guide the search, in a total of  running time. We obtain a connected portion 
of , delimited by two consecutive intersection points of
, whose relative interior lies completely above or below each
, so that , if nonempty, lies in
. This allows us to resolve each comparison between 
and an arc , assuming that , and we continue the binary search through each  in
the same manner.

We again use a variant of Cole's technique~\cite{RC} to slightly
improve this bound further. In each parallel step we have a
collection  of  weighted points, each of which is an
intersection point of  with some arc  from one of
the planar maps , and we need to compare each of the points of
 with . Let  denote the set of these active arcs.

Note that each arc  participating in this step
contributes (at most) four points to , for a total of at most
 points. We perform three steps of a (weighted) binary search on
the points of , where each step takes the weighted median 
of an appropriate portion of , and calls , where 
is the vertical line through . These -steps resolve the
comparisons with  of all but  of the points of , that is,
at most  points of  are still unresolved.

In other words, after the three calls
to the algorithm for solving  (in the first parallel
step of the execution), we can determine the outcomes of the
comparisons of at least half of the arcs in  with . We can
then proceed in this manner and apply Cole's technique (as before),
by using only a constant number of calls to  in each of the
 parallel steps of searching in all the maps.
This reduces a  factor from the bound of the
running time, so it is only  time.

When these searches terminate, we end up with a 2-face in each
, in which  lies (if nonempty), and we reach
the scenario described in a preceding paragraph. As explained there,
we can now either determine that , or that , or else we know which side of , within 
(or, rather, within ) can contain , and we continue the
binary search through  on that side.

When the binary search through  terminates, we have a 2-face
 of , where  must lie, and we retrieve the ball
 corresponding to . We repeat this step to each of the
maps  and  of each of the  spherical polytopes
, and obtain a set  of  balls. In addition, the
searches through the maps  and  may have trimmed
 to a narrower strip , and have produced a set 
of witness balls, so that the -projection of their intersection
lies inside .  may consist of a total of  witness balls, as is easy to verify. In addition, the
second-level searches produce an additional collection ,
consisting of balls corresponding to faces of the maps  and
, in which the second-level searches have ended; their
overall number is . Put . Hence  if and only if .

As already noted, the overall running time of the emptiness
detection is .

So far, we have only determined whether  is empty or not.
However, to enable the decision procedure to discriminate between
the cases  and  we need to refine the algorithm,
so that it can also determine whether  has nonempty interior (we
refer to an intersection  with this property as
\emph{non-degenerate}).  To do so, we make the following
modifications to the algorithm described above. Each step in the
emptiness testing procedure which detects that 
obtains a specific point  that belongs to . Moreover, 
belongs to the intersection  of polylogarithmically many
witness balls, and does not lie on the boundary of any other ball.
This is because each of the procedures , or 
locates the -projection  of  (which, for  and
 is a generic, unknown point in ) in each of the maps
, and the collection of the witness
balls gathered during the various steps of the searches contains all
the balls that participate in the corresponding spherical polytopes
 on whose boundary  can lie. Thus, when we terminate with a
point , we find, among the polylogarithmically many witness
balls, the at most four balls whose boundaries contain  (recall
our general position assumption), and test whether their
intersection is the singleton . It is easily checked that
this is equivalent to the condition that  is degenerate.

This completes the description of the algorithm, and concludes the
proof of Proposition~\ref{prop:intersection_test}.


\section{Discussion and Open Problems.}
\label{sec:discussion} In this paper we presented two algorithms for
computing the 2-center of a set of points in . The first
algorithm takes near-cubic time, and the second one takes
near-quadratic time provided that the two centers are not too close
to each other. Note that our second algorithm may be slightly
revised, so that it receives, in addition to , a parameter
 as input, and returns a solution for the 2-center
problem for , if . To this end,
we run the exponential search until we reach a value of  with
. If along the search we have found a
value of  such that , we stop the search and run
Chan's technique with the constraint that , as above.
Otherwise, we have  and we may return the
smallest enclosing ball of  as an -approximate solution
for the 2-center problem. This way, we ensure that the running time
of our algorithm is .

An obvious open problem is to design an algorithm for the 2-center
problem that runs in near-quadratic time on all point sets in
.  Another interesting question is whether the 2-center
problem in  is \emph{{\sc 3sum}-hard} (see~\cite{GO}
for details), which would suggest that a near-quadratic algorithm is
(almost) the best possible for this problem.


\begin{thebibliography}{}

\bibitem{AES}
P.~K.~Agarwal, A.~Efrat and M.~Sharir,
Vertical decomposition of shallow levels in 3-dimensional arrangements and its applications,
{\it SIAM J. Comput.} 29 (2000), 912--953.

\bibitem{AP}
P.~K.~Agarwal and C.~M.~Procopiuc,
Exact and approximation algorithms for clustering,
{\it Algorithmica} 33 (2002), 201--226.

\bibitem{ASP}
P.~K.~Agarwal and M.~Sharir,
Planar geometric location problems,
{\it Algorithmica} 11 (1994), 185--195.

\bibitem{BHI}
M.~B\u{a}doiu, S.~Har-Peled and P.~Indyk,
Approximate clustering via core-sets,
{\it Proc. 34th ACM Sympos. Theory Comput.} (2002), 250--257.

\bibitem{BE}
M.~Bern and D.~Eppstein,
Approximation algorithms for geometric problems,
In D.~S. Hochbaum, editor, {\it Approximation algorithms for NP-Hard problems,} PWS Publishing Company, 1997.

\bibitem{BCT}
K.~Bezdek and R.~Connelly,
The Kneser-Poulsen conjecture for spherical polytopes,
{\it Discrete Comput. Geom.} 32 (2004), 101--106.

\bibitem{BLNP}
K.~Bezdek, Z.~Langi, M.~Nasz\'{o}di and P.~Papez,
Ball polyhedra,
{\it Discrete Comput. Geom.} 38 (2007), 201--230.

\bibitem{BN}
K.~Bezdek and M.~Nasz\'{o}di,
Rigidity of ball-polyhedra in euclidean 3-space,
{\it European J. Combin.} 27 (2006), 255--268.

\bibitem{BCM}
H.~Br\"{o}nnimann, B.~Chazelle and J.~Matou\v{s}ek,
Product range spaces, sensitive sampling, and derandomization,
{\it SIAM J. Comput.} 28 (1999), 1552--1575.

\bibitem{TCA}
T.~M.~Chan,
An optimal randomized algorithm for maximum Tukey depth,
{\it Proc. 15th ACM-SIAM Sympos. Discrete Algorithms} (2004), 430--436.

\bibitem{TCG}
T.~M.~Chan,
Geometric applications of a randomized optimization technique,
{\it Discrete Comput. Geom.} 22 (1999), 547--567.

\bibitem{TC}
T.~M.~Chan,
More planar two-center algorithms,
{\it Comput. Geom. Theory Appl.} 13 (1999), 189--198.

\bibitem{BC}
B.~Chazelle,
Cutting hyperplanes for divide-and-conquer,
{\it Discrete Comput. Geom.} 9 (1993), 145--158.

\bibitem{CF}
B.~Chazelle, and J.~Friedman,
A deterministic view of random sampling and its use in geometry,
{\it Combinatorica} 10 (1990), 229--249.

\bibitem{CM}
B.~Chazelle and J.~Matou\v{s}ek,
On linear-time deterministic algorithms for optimization problems
in fixed dimension,
{\it J. Algorithms} 21 (1996), 579--597.

\bibitem{CS}
K.~L.~Clarkson and P.~W.~Shor,
Applications of random sampling in computational geometry,
II, {\it Discrete Comput. Geom.} 4 (1989), 387--421.

\bibitem{CMS}
E.~Cohen and N.~Megiddo
Strongly polynomial-time and NC algorithms for detecting cycles in dynamic graphs,
{\it J. ACM} 40 (1993), 791--830.

\bibitem{RC}
R.~Cole, Slowing down sorting networks to obtain faster sorting
algorithms, {\it J. ACM} 34 (1987), 200--208.

\bibitem{book}
M.~de Berg, M.~van Kreveld, M.~Overmars and O.~Schwarzkopf,
{\it Computational Geometry: Algorithms and Applications},
Springer-Verlag, 1997.

\bibitem{DE}
D.~Eppstein,
Dynamic three-dimensional linear programming,
{\it ORSA J. Computing} 4 (1992), 360--368.

\bibitem{DEF}
D.~Eppstein,
Faster construction of planar two-centers,
{\it Proc. 8th ACM-SIAM Sympos. Discrete Algorithms} (1997), 131--138.

\bibitem{GO}
A.~Gajentaan and M.~H.~Overmars,
On a class of  problems in computational geometry,
{\it Comput. Geom. Theory Appl.} 5(3) (1995), 165--185.

\bibitem{HS}
J.~Hershberger and S.~Suri,
Finding tailored partitions,
{\it J. Algorithms} 12 (1991), 431--463.

\bibitem{JK}
J.~Jaromczyk and M.~Kowaluk,
An efficient algorithm for the euclidean two-center problem,
{\it Proc. 10th ACM Sympos. Comput. Geom.} (1994), 303--311.

\bibitem{JMC}
J.~Matou\v{s}ek,
Cutting hyperplane arrangements,
{\it Discrete Comput. Geom.} 6 (1991), 385--406.

\bibitem{JM}
J.~Matou\v{s}ek,
Linear optimization queries,
{\it J. Algorithms} 14 (3) (1993), 432--448.

\bibitem{NML}
N.~Megiddo,
Linear programming in linear time when the dimension is fixed,
{\it J. ACM} 31 (1984), 114--127.

\bibitem{NMLT}
N.~Megiddo,
Linear time algorithms for linear programming in 
and related problems,
{\it SIAM J. Comput.} 12 (1983), 759--776.

\bibitem{MK}
N.~Megiddo and K.~Supowit,
On the complexity of some common geometric location problems,
{\it SIAM J. Comput.} 13 (1984), 1182--1196.

\bibitem{MK2}
N.~Megiddo, On the complexity of some geometric problems in unbounded dimension,
{\it J. Symbolic Comput.} 10 (1990), 327--334.

\bibitem{NPT}
C.~H.~Norton, S.~A.~Plotkin and E.~Tardos,
Using separation algorithms in fixed dimension,
{\it J. Algorithms} 13 (1992), 79--98.

\bibitem{ER}
E.~A.~Ramos,
Intersection of unit-balls and diameter of a point set in ,
{\it Comput. Geom. Theory Appl.} 8 (1997), 57--65.

\bibitem{ST}
N.~Sarnak and R.~E.~Tarjan,
Planar point location using persistent search trees,
{\it Comm. ACM} 29 (7) (1986), 669--679.

\bibitem{MS}
M.~Sharir,
A near linear algorithm for the planar 2-center problem,
{\it Discrete Comput. Geom.} 18 (1997), 125--134.

\end{thebibliography}

\end{document}
