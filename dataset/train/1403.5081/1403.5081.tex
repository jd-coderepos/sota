\pdfoutput=1

\documentclass[draft]{ifacconf}


\usepackage[utf8]{inputenc}
 \usepackage[english]{babel}
 \usepackage[babel]{csquotes}



\usepackage{etex}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{array}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{longtable}
\usepackage{nicefrac}
\usepackage{xspace}
\usepackage{paralist}
\usepackage{listings}
\usepackage{bashful}
\usepackage{xifthen}
 \usepackage{url}
 \usepackage{mathpartir}
 \usepackage{versions}
 \usepackage{pdflscape}
 \usepackage{scrtime}
 \usepackage{intcalc}

\usepackage{amsmath}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{proof}{Proof}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{notation}{Notation}


\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{trees,decorations,arrows,automata,shadows,positioning,plotmarks,backgrounds,shapes}
\usetikzlibrary{calc,matrix,fit,petri,decorations.pathmorphing,patterns}
\usetikzlibrary{decorations.pathreplacing}

\tikzstyle{block} = [draw, fill=black!10, rectangle, 
    minimum height=2em, minimum width=3em]
\tikzstyle{blockbig} = [draw, fill=black!10, rectangle, 
    minimum height=2cm, minimum width=2.4cm]
\tikzstyle{sum} = [draw, fill=black!10, circle, node distance=1cm]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
\tikzstyle{sinput} = [coordinate]



\renewcommand{\textbullet}{\ensuremath{\bullet}\xspace}

\newcommand{\rot}[1]{\textcolor{red}{#1}}
\newcommand{\gruen}[1]{\textcolor{green}{#1}}
\newcommand{\schwarz}[1]{\textcolor{black}{#1}}
\newcommand{\darkred}[1]{{\color{red!70!black}#1}}
\newcommand{\dr}{red!70!black}
\newcommand{\drl}{red!70!black!30}
\newcommand{\drarrow}{{\color{red!60!black}}}
\newcommand{\drbullet}{{\color{red!60!black}}}


\let\theoremOrig\endtheorem
\def\endtheorem{\hspace*{0pt}\hfill\rule{1ex}{1ex}\theoremOrig\vspace*{-1ex}}
\let\exampleOrig\endexample
\def\endexample{\hspace*{0pt}\hfill\exampleOrig\vspace*{-1ex}}
\let\lemmaOrig\endlemma
\def\endlemma{\hspace*{0pt}\hfill\rule{1ex}{1ex}\lemmaOrig\vspace*{-1ex}}
\let\remarkOrig\endremark
\def\endremark{\hspace*{0pt}\hfill\remarkOrig\vspace*{-1ex}}
\let\proofOrig\endproof
\def\endproof{\hspace*{0pt}\hfill\proofOrig\vspace*{-1ex}}
\let\definitionOrig\enddefinition
\def\enddefinition{\hspace*{0pt}\hfill\definitionOrig\vspace*{-1ex}}
\let\propositionOrig\endproposition
\def\endproposition{\hspace*{0pt}\hfill\rule{1ex}{1ex}\propositionOrig\vspace*{-1ex}}
\let\notationOrig\endnotation
\def\endnotation{\hspace*{0pt}\hfill\notationOrig\vspace*{-1ex}}
\let\corollaryOrig\endcorollary
\def\endcorollary{\hspace*{0pt}\hfill\rule{1ex}{1ex}\corollaryOrig\vspace*{-1ex}}



 \usepackage{macros}

\newcommand{\STEP}[1]{\ensuremath{G_{#1}}\xspace}

\usepackage{stmaryrd,pifont}
\newcommand{\ENDOFOUTPUT}{\ensuremath{\diamond}\xspace}

\usepackage{framed}
\makeatletter
\begingroup \makeatletter
  \g@addto@macro\framed{\let\marginnoteleftadjust\FrameSep
    \let\marginnoterightadjust\FrameSep
  }
\endgroup
\newenvironment{fshaded}{\def\FrameCommand{\fcolorbox{framecolor}{shadecolor}}\MakeFramed {\FrameRestore}}{\endMakeFramed}

\makeatletter
\newrobustcmd{\Sven}[1]{\definecolor{shadecolor}{rgb}{.8,.8,1}\definecolor{framecolor}{rgb}{0,0,1}\begin{fshaded}\textsl{Kommentar Sven: #1}\end{fshaded}}
\newrobustcmd{\Anne}[1]{\definecolor{shadecolor}{rgb}{1,.8,.8}\definecolor{framecolor}{rgb}{1,0,0}\begin{fshaded}\textsl{Kommentar Anne: #1}\end{fshaded}}
\makeatother


\newrobustcmd{\SINGLEx}[1]{\ensuremath{\underbar{\ensuremath{#1}}}}
\newrobustcmd{\SINGLE}[1]{\let\LISTSEP\relax\List[]{#1}{}{}}

\newrobustcmd{\myFigure}[2]{
\begin{figure}[t]
\footnotesize
\input{figures/#1}
\caption{\normalfont\footnotesize\label{#1}#2}
\end{figure}}
\newrobustcmd{\myFigureWide}[2]{
\begin{figure*}[t]
\footnotesize
\input{figures/#1}
\caption{\normalfont\footnotesize\label{#1}#2}
\end{figure*}}

\newrobustcmd{\myTable}[3]{
\begin{table}[t]
\footnotesize
\input{figures/#1}
\vspace*{2ex}
\caption{\normalfont\footnotesize\label{#2}#3}
\vspace*{-2ex}
\end{table}}
\newrobustcmd{\myTableWide}[3]{
\begin{table*}[t]
\footnotesize
\input{figures/#1}
\caption{\normalfont\footnotesize\label{#2}#3}
\vspace*{-.5cm}
\end{table*}}

\newcommand{\EG}{e.g.,\xspace}
\newcommand{\IE}{i.e.,\xspace}
\newcommand{\WRT}{w.r.t.\xspace}

\newenvironment{MultCases}{\begin{cases}}{\end{cases}}
\newcommand{\XCase}[2]{#1&,~#2\\}
\newcommand{\YCase}[2]{#1&,~#2}

\newenvironment{MultCasesC}{\begin{cases}}{\end{cases}}
\newcommand{\XCaseC}[2]{\hspace{2em}\text{if}~#2\\#1\\}
\newcommand{\YCaseC}[2]{\hspace{2em}\text{if}~#2\\#1}

\newenvironment{propConjA}{\left(\begin{array}{@{\wedge}l@{}}}{\end{array}\right)}
\newenvironment{propImpA}{\left(\def\propImpAtest{1}\begin{array}{@{\if\propImpAtest1\gdef\propImpAtest{0}\phantom{\rightarrow}\else\rightarrow\fi}l@{}}}{\end{array}\right)}
\newenvironment{propDisjA}{\left(\begin{array}{@{\vee}l@{}}}{\end{array}\right)}
\newenvironment{unionA}{\left(\def\unionAtest{1}\begin{array}{@{\if\unionAtest1\gdef\unionAtest{0}\phantom{\cup}\else\cup\fi}l@{}}}{\end{array}\right)}

\makeatletter
\newlength{\SFS@HEIGHT}
\newlength{\SFS@WIDTH}

\newcommand{\SplitX}[2]{
\settoheight{\SFS@HEIGHT}{}
\settowidth{\SFS@WIDTH}{}
\mbox{\begin{tikzpicture}[baseline=(current bounding box.center)]
\node[] (E) at (0,0) {};
\node[inner sep=0pt] (F) at () {};
\node[] (E) at (0,0) {\phantom{}};
\draw[fill] () circle (.2ex);
\draw[->] () -- () -- () -- () -- ();
\end{tikzpicture}}}

\newcommand{\libFAUDES}{\textrm{libFAUDES}\xspace}

\newcommand{\AllQSplit}[2]{\SplitX{\forall\;#1\;.}{#2}}
\newcommand{\SetCompSplit}[2]{\left\{\SplitX{#1\mid}{#2}\right\}}
\newcommand{\ExQSplit}[2]{\SplitX{\exists\;#1\;.}{#2}}
\newcommand{\nExQSplit}[2]{\SplitX{\neg\exists\;#1\;.}{#2}}
\newcommand{\THESplit}[2]{\SplitX{\iota\;#1\;.}{#2}}
\newcommand{\LetSplit}[2]{\SplitX{\text{let  in}}{#2}}
\newcommand{\propImpSplit}[2]{\SplitX{#1\;\rightarrow\;}{#2}}
\newcommand{\propAequSplit}[2]{\SplitX{#1\;\leftrightarrow\;}{#2}}
\newcommand{\propEquSplit}[2]{\SplitX{#1\;=\;}{#2}}
\newcommand{\DERIVESplit}[3]{\SplitX{#2\;\DERIVE{#1}\;}{#3}}
\newcommand{\FunAnonymSplit}[2]{\SplitX{\lambda #1\;.\;}{#2}}


\makeatother
\newcommand{\REDS}[1]{\begingroup\color{red}\Set{#1}\endgroup}
\newcommand{\YES}{\begingroup\color{green}\checkmark\endgroup}
\newcommand{\NO}{\begingroup\color{red}\texttimes\endgroup}
\newcommand{\NOI}{x}\newcommand{\UL}{x}\newcommand{\UniquenessQ}[2]{\ensuremath{\nu\;#1\;.\;#2}}

\newcommand{\THUSj}[2][\Rightarrow]{\stackrel{#2}{}\;#1}
\newcommand{\THUSLj}[2][\Leftarrow]{\stackrel{#2}{}\;#1}
\newcommand{\THUSRj}[2][\rightarrow]{\stackrel{#2}{}\;#1}
\newcommand{\THUSLRj}[2][\leftrightarrow]{\stackrel{#2}{}\;#1}
\newcommand{\THUSEj}[2][=]{\stackrel{#2}{}\;#1}
\newcommand{\THUSSimj}[2][\dot{\preceq}^{R}]{\stackrel{#2}{}\;#1}
\newcommand{\SUBEQj}[2][\subseteq]{\stackrel{#2}{}\;#1}
\newcommand{\NSUBEQj}[2][\nsubseteq]{\stackrel{#2}{}\;#1}
\newcommand{\EQj}[2][=]{\stackrel{#2}{}\;#1}
\newcommand{\NEQj}[2][\neq]{\stackrel{#2}{}\;#1}
\newcommand{\inTHUSj}[2][\Rightarrow]{\stackrel{#2}{#1}}
\newcommand{\inSUBEQj}[2][\subseteq]{\stackrel{#2}{#1}}
\newcommand{\inEQj}[2][=]{\stackrel{#2}{#1}}
\newcommand{\inNEQj}[2][\neq]{\stackrel{#2}{#1}}
\newcommand{\inNSUBEQj}[2][\nsubseteq]{\stackrel{#2}{#1}}
\newcommand{\trivial}{\text{trivial}\xspace}
\newcommand{\trivialN}[1]{\text{trivial}\xspace}
\newcommand{\PRED}[2][]{\psi_{#1}(#2)}

\newcommand{\FINCOUNTState}[1]{\ensuremath{\#_Q(\ifthenelse{\isempty{#1}}{\cdot}{#1})}}

\newcommand{\UNDEF}{\bot}
\newcommand{\drop}[2]{\mathrm{drop}(#1,#2)}
\newcommand{\length}[1]{|#1|}
\newcommand{\delbot}[1]{\mathrm{del\ENDOFOUTPUT}(#1)}
\newcommand{\SUP}[2]{\sup\SetComp{#1}{#2}}
\newcommand{\RIGHTQUOT}[2]{#1/^{\mathsf{r}}#2}
\newcommand{\LEFTQUOT}[2]{#1/^{\mathsf{l}}#2}
\newcommand{\POSTC}[1]{\overrightarrow{#1}}
\newcommand{\ParComp}[2]{#1{\mid}#2}
\newcommand{\DES}{\ensuremath{\mathsf{DES}}\xspace}
\newcommand{\DESname}{D}
\newcommand{\DESum}{S}
\newcommand{\DESm}{S_{\operatorname{m}}}

\newcommand{\PlantName}{P}
\newcommand{\PlantRhs}{(\SigmaC,\SigmaUC,\PlantUM,\PlantM)}
\newcommand{\PlantUM}{L_{\operatorname{um}}}
\newcommand{\PlantM}{L_{\operatorname{m}}}
\newcommand{\ContName}{C}
\newcommand{\ContRhs}{(\SigmaC,\SigmaUC,\ContUM,\ContM)}
\newcommand{\ContUM}{{L_{\operatorname{c}}}_{\operatorname{um}}}
\newcommand{\ContM}{{L_{\operatorname{c}}}_{\operatorname{m}}}
\newcommand{\ContXName}{C'}
\newcommand{\ContXRhs}{(\SigmaC,\SigmaUC,\ContXUM,\ContXM)}
\newcommand{\ContXUM}{{L'_{\operatorname{c}}}_{\operatorname{um}}}
\newcommand{\ContXM}{{L'_{\operatorname{c}}}_{\operatorname{m}}}
\newcommand{\ContOName}{O}
\newcommand{\ContORhs}{(\SigmaC,\SigmaUC,\ContOUM,\ContOM)}
\newcommand{\ContOUM}{{L_{\operatorname{o}}}_{\operatorname{um}}}
\newcommand{\ContOM}{{L_{\operatorname{o}}}_{\operatorname{m}}}
\newcommand{\ClName}{\PlantName{\times}\ContName}
\newcommand{\ClRhs}{(\SigmaC,\SigmaUC,\ClUM,\ClM)}
\newcommand{\ClUM}{{L_{\operatorname{cl}}}_{\operatorname{um}}}
\newcommand{\ClM}{{L_{\operatorname{cl}}}_{\operatorname{m}}}
\newcommand{\SpecName}{S}
\newcommand{\SpecRhs}{(\SigmaC,\SigmaUC,\SpecUM,\SpecM)}
\newcommand{\SpecUM}{{L_{\operatorname{spec}}}_{\operatorname{um}}}
\newcommand{\SpecM}{{L_{\operatorname{spec}}}_{\operatorname{m}}}
\newcommand{\SpecXName}{S'}
\newcommand{\SpecXRhs}{(\SigmaC,\SigmaUC,\SpecXUM,\SpecXM)}
\newcommand{\SpecXUM}{{L_{\operatorname{spec}}'}_{\operatorname{um}}}
\newcommand{\SpecXM}{{L_{\operatorname{spec}}'}_{\operatorname{m}}}
\newcommand{\ClMayUM}{K_{\operatorname{um}}}
\newcommand{\ClMayM}{K_{\operatorname{m}}}
\newcommand{\ContCandUM}{\hat{K}_{\operatorname{um}}}
\newcommand{\ContCandM}{\hat{K}_{\operatorname{m}}}
\newcommand{\RestrictMContResUM}{\hat{K}_{\operatorname{um}}^\uparrow}
\newcommand{\RestrictMContResM}{\hat{K}_{\operatorname{m}}^\uparrow}
\newcommand{\RestrictUMContResUM}{\hat{K}_{\operatorname{um}}^\downarrow}
\newcommand{\RestrictUMContResM}{\hat{K}_{\operatorname{m}}^\downarrow}
\newcommand{\CONTROLLABLEsetdeff}[3]{\INTERSECT{\BR{#1\sconc #3}}{#2}\subseteq #1}
\newcommand{\CONTROLLABLEset}[3]{\ON{ContS}(#1,#2,#3)}
\newcommand{\inputCONTROLLABLEset}[4]{\ON{ContS}(#1,#2,#3,#4)}

\newcommand{\GFP}[1]{\mathrm{gfp}\left(#1\right)}
\newcommand{\FunAnonym}[2]{\lambda#1.#2}

\newcommand{\ALGORITHMAname}{\ensuremath{\mathfrak{A}}\xspace}
\newcommand{\ALGORITHMBname}{\ensuremath{\mathfrak{B}}\xspace}
\newcommand{\ALGORITHMCname}{\ensuremath{\mathfrak{C}}\xspace}
\newcommand{\ALGORITHMDname}{\ensuremath{\mathfrak{D}}\xspace}
\newcommand{\ALGORITHMAIname}{\ensuremath{\mathfrak{A}^1}\xspace}
\newcommand{\ALGORITHMBIname}{\ensuremath{\mathfrak{B}^1}\xspace}
\newcommand{\ALGORITHMCIname}{\ensuremath{\mathfrak{C}^1}\xspace}
\newcommand{\ALGORITHMDIname}{\ensuremath{\mathfrak{D}^1}\xspace}

\newcommand{\ThreeArgCommand}[4][f]{\ensuremath{#1\ifthenelse{\equal{#2#3#4}{}}{}{(\ifthenelse{\equal{#2}{}}{\cdot}{#2},\ifthenelse{\equal{#3}{}}{\cdot}{#3},\ifthenelse{\equal{#4}{}}{\cdot}{#4})}}\xspace}
\newcommand{\ALGORITHMA}[3]{\ThreeArgCommand[\ALGORITHMAname]{#1}{#2}{#3}}
\newcommand{\ALGORITHMB}[3]{\ThreeArgCommand[\ALGORITHMBname]{#1}{#2}{#3}}
\newcommand{\GENALGORITHMname}[1][]{\alpha\ifthenelse{\equal{#1}{}}{}{^{#1}}}
\newcommand{\GENALGORITHM}[2][]{\GENALGORITHMname[#1]{(#2)}}
\newcommand{\ALGORITHM}[2]{#1(#2)}
\newcommand{\STATES}[1]{\ensuremath{\mathsf{States}(#1)}\xspace}

\newcommand{\EnsureNonBlocking}[1]{\ensuremath{\mathsf{DoNonBlock}(#1)}\xspace}
\newcommand{\EnsureNonBlockingN}[2]{\ensuremath{\mathsf{DoNonBlock}_{\mathsf{#1}}(#2)}\xspace}
\newcommand{\EnsureControllabilityName}{\ensuremath{\mathsf{DoCont}}\xspace}
\newcommand{\EnsureControllability}[1]{\ensuremath{\EnsureControllabilityName(#1)}\xspace}
\newcommand{\EnsureStrongControllability}[2]{\ensuremath{\mathsf{DoCont}^{\mathsf{s}}_{\mathsf{#1}}(#2)}\xspace}
\newcommand{\EnsureWeakControllability}[2]{\ensuremath{\mathsf{DoCont}^{\mathsf{w}}_{\mathsf{#1}}(#2)}\xspace}
\newcommand{\EnsureControllabilityW}[1]{\ensuremath{\mathsf{DoCont^W}(#1)}\xspace}
\newcommand{\EnsureControllabilityWM}[1]{\ensuremath{\mathsf{DoCont_m^W}(#1)}\xspace}
\newcommand{\EnsureControllabilityWUM}[1]{\ensuremath{\mathsf{DoCont_{um}^W}(#1)}\xspace}
\newcommand{\ERASURE}[1]{\mathsf{ERASURE}(#1)}
\newcommand{\COMP}[4]{\mathsf{Comp}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}
\newcommand{\COMPStrong}[2]{\ensuremath{\mathsf{CompS}_{#1}(#2)}\xspace}
\newcommand{\COMPWeak}[2]{\ensuremath{\mathsf{CompW}_{#1}(#2)}\xspace}
\newcommand{\COMPW}[4]{\mathsf{Comp^W}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}
\newcommand{\COMPUM}[4]{\mathsf{CompUM}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}
\newcommand{\COMPUMW}[4]{\mathsf{CompUM^W}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}

\newcommand{\NONBLOCKINGSETS}[2]{\ensuremath{\ON{NonBlockS}(#1,#2)}}
\newcommand{\RestrictUMContResUMsupcond}[1]{\propConj{#1\subseteq\ContCandUM}{\propConj{\CONTROLLABLEset{#1}{}{}}{\propConj{#1=\PC{#1}}{#1\subseteq\PC{\INTERSECT{\ContCandM}{#1}}}}}}
\newcommand{\RestrictMContResMsupcond}[1]{\propConj{#1\subseteq\ContCandM}{\CONTROLLABLEset{\PC{A}}{}{}}}

\newcommand{\SUPcontained}[1]{\ON{SupC}(#1)}

\newcommand{\SSol}[2]{\mathsf{SSol}(#1,#2)}
\newcommand{\MSol}[2]{\mathsf{MSol}(#1,#2)}
\newcommand{\SMSol}[2]{\mathsf{SMSol}(#1,#2)}
\newcommand{\UMSol}[2]{\mathsf{UMSol}(#1,#2)}
\newcommand{\MMSol}[2]{\mathsf{MMSol}(#1,#2)}
\newcommand{\SIUMSol}[2]{\mathsf{SIUMSol}(#1,#2)}
\newcommand{\SIMMSol}[2]{\mathsf{SIMMSol}(#1,#2)}
\newcommand{\SIUMpred}[1]{\Phi_{\mathsf{sium}}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\UMpred}[1]{\Phi_{\mathsf{um}}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\MMpred}[1]{\Phi_{\mathsf{mm}}\ifthenelse{\isempty{#1}}{}{(#1)}}


\newcommand{\GoodSubSet}[3]{\ensuremath{\mathsf{GoodSubSet}(#1,#2,#3)}}
\newcommand{\BadSubSet}[4]{\ensuremath{\mathsf{BadSubSet}(#1,#2,#3,#4)}}


\newcommand{\PROJ}[2]{\pi_{#2}(#1)}
\newcommand{\ITEMS}[1]{\ON{Items}(#1)}
\newcommand{\ITEMMARKER}{\Yright}
\newcommand{\ITEM}[4]{[#1\fun #2\ITEMMARKER#3,#4]}
\newcommand{\EDGE}[5]{(#1,#2,#3,#4,#5)}
\newcommand{\PROD}[2]{(#1,#2)}
\newcommand{\ATS}{\ensuremath{\mathrm{ATS}}\xspace}
\newcommand{\NATPREFIX}[2]{#1:#2}
\newcommand{\PC}[1]{\overline{#1}}
\newcommand{\PREFIX}[2]{#1 \sqsubseteq #2}
\newcommand{\SUFFIX}[2]{#1 \sqsupseteq #2}
\newcommand{\nPREFIX}[2]{#1 \centernot{\sqsubseteq} #2}
\newcommand{\CSTR}[1]{#1^{*\omega}}
\newcommand{\Parser}{\ensuremath{\mathrm{Parser}}\xspace}
\newcommand{\TFP}{\ensuremath{\mathsf{TFP}}\xspace}
\newcommand{\LMP}{\ensuremath{\mathsf{LMP}}\xspace}
\newcommand{\Grammar}{\ensuremath{\mathsf{Grammar}}\xspace}
\newcommand{\CFG}{\ensuremath{\mathrm{CFG}}\xspace}
\newcommand{\LR}[1][1]{\ensuremath{\mathrm{LR}(#1)}\xspace}
\newcommand{\DERIVE}[2][]{\ensuremath{\mathrel{\vdash}\ifthenelse{\isempty{#2}}{}{_{#2}}\ifthenelse{\isempty{#1}}{}{^{\ON{#1}}}}\xspace}
\newcommand{\DERIVEst}[2][]{\ensuremath{\mathrel{\vdash^*}\ifthenelse{\isempty{#2}}{}{_{#2}}\ifthenelse{\isempty{#1}}{}{^{\ON{#1}}}}\xspace}
\newcommand{\nDERIVE}[2][]{\ensuremath{\mathrel{\nvdash}\ifthenelse{\isempty{#2}}{}{_{#2}}\ifthenelse{\isempty{#1}}{}{^{\ON{#1}}}}\xspace}
\newcommand{\DERIVATIONS}[3][]{\mathcal{D}\ifthenelse{\isempty{#1}}{}{^{\ON{#1}}}\ifthenelse{\isempty{#2}}{}{_{#2}}\ifthenelse{\isempty{#3}}{}{(#3)}\xspace}
\newcommand{\fRES}[3]{#1_{\mid #2,#3}}
\newcommand{\SENTENTIAL}[3]{\ensuremath{\mathcal{S}\ifthenelse{\isempty{#1}}{}{^{#1}}\ifthenelse{\isempty{#2}}{}{_{#2}}(#3)}\xspace}
\renewcommand{\LANG}[1]{\ensuremath{\ifthenelse{\isempty{#1}}{\mathrm{L_{m}}}{\mathrm{L_{m}}(#1)}}\xspace}
\newcommand{\ULANG}[1]{\ensuremath{\ifthenelse{\isempty{#1}}{\mathrm{L_{um}}}{\mathrm{L_{um}}(#1)}}\xspace}
\newcommand{\LANGc}[1]{\ensuremath{\ifthenelse{\isempty{#1}}{\mathrm{L^c_{m}}}{\mathrm{L^c_{m}}(#1)}}\xspace}
\newcommand{\SCP}{\ensuremath{\mathrm{SCP}}\xspace}
\newcommand{\OSCP}{\ensuremath{\mathrm{OSCP}}\xspace}
\newcommand{\SDPDA}{\ensuremath{\mathrm{SDPDA}}\xspace}
\newcommand{\NFA}{\ensuremath{\mathrm{NFA}}\xspace}
\newcommand{\DFA}{\ensuremath{\mathrm{DFA}}\xspace}
\newcommand{\EPDA}{\ensuremath{\mathrm{EPDA}}\xspace}
\newcommand{\PDA}{\ensuremath{\mathrm{PDA}}\xspace}
\newcommand{\DPDA}{\ensuremath{\mathrm{DPDA}}\xspace}
\newcommand{\VPTA}{\ensuremath{\mathrm{VPTA}}\xspace}
\newcommand{\DPDAs}{\ensuremath{\mathrm{DPDA}s}\xspace}
\newcommand{\EDPDA}{\ensuremath{\mathrm{EDPDA}}\xspace}
\newcommand{\EDPDAs}{\ensuremath{\mathrm{EDPDA}s}\xspace}
\newcommand{\DCFL}[1][]{\ensuremath{\mathrm{DCFL}\ifthenelse{\isempty{#1}}{}{(#1)}}\xspace}
\newcommand{\CFL}[1][]{\ensuremath{\mathrm{CFL}\ifthenelse{\isempty{#1}}{}{(#1)}}\xspace}
\newcommand{\REG}[1][]{\ensuremath{\mathrm{REG}\ifthenelse{\isempty{#1}}{}{(#1)}}\xspace}
\newcommand{\LLF}{\ensuremath{\mathrm{LLF}}\xspace}
\newcommand{\PTNET}{\ensuremath{\mathrm{PTNET}}\xspace}

\newcommand{\REALIZABLE}[2]{\ensuremath{\mathrm{Realizable}(#1,#2)}\xspace}
\newcommand{\REALIZES}[2]{\ensuremath{\mathrm{Realizes}(#1,#2)}\xspace}

\newcommand{\BISIMd}[2][XXXXXXX]{\dot{\sim}_{#1}^{#2}}
\newcommand{\SIMd}[2][XXXXXXX]{\dot{\preceq}_{#1}^{#2}}
\newcommand{\autfont}[1]{#1}
\newcommand{\w}{\alpha}
\newcommand{\Aut}[1][]{\autfont{M}^{#1}}
\newcommand{\AutRhs}[1][]{(Q^{#1},\Sigma^{#1},\Gamma^{#1},\delta^{#1},p_0^{#1},\Box^{#1},F^{#1})}
\newcommand{\Gra}[1][]{\autfont{G}^{#1}}
\newcommand{\GraNon}{N}
\newcommand{\GraSig}{\Sigma}
\newcommand{\GraPro}{P}
\newcommand{\GraIni}{S}
\newcommand{\GraRhs}[1][]{(\GraNon^{#1},\GraSig^{#1},\GraPro^{#1},\GraIni^{#1})}
\newcommand{\Par}[1][]{\autfont{P}^{#1}}
\newcommand{\ParRhs}[1][]{(N^{#1},\Sigma^{#1},R^{#1},S^{#1})}
\newcommand{\PlantAutName}{\autfont{\PlantName}}
\newcommand{\PlantAutRhs}{(Q_\PlantAutName,\Sigma,\Set{\Box},\delta_\PlantAutName,q_{\PlantAutName 0},\Box,F_\PlantAutName)\in\DFA}
\newcommand{\SpecAutName}{\autfont{\SpecName}}
\newcommand{\SpecAutRhs}[1][\DPDA]{(Q_\SpecAutName,\Sigma,\Gamma,\delta_\SpecAutName,q_{\SpecAutName 0},\Box,F_\SpecAutName)\in#1}
\newcommand{\ContOAutName}{\autfont{\ContOName}}
\newcommand{\ContOAutRhs}{(Q,\Sigma,\Gamma,\delta,q_0,\Box,F)\in\DPDA}
\newcommand{\ContAutName}{\autfont{\ContName}}
\newcommand{\Cc}{\ensuremath{_C}}
\newcommand{\ContOCAutName}{\autfont{\ContOName}\Cc}
\newcommand{\ContOCAutRhs}{(Q\Cc,\Sigma,\Gamma,\delta\Cc,q_0,\Box,F\Cc)\in\DPDA}

\newcommand{\NONBLOCKINGEDPDA}[1]{\ON{IsNB}(#1)}
\newcommand{\BLOCK}[1]{\mathcal{B}(#1)\xspace}
\newcommand{\CONTROLLABLE}[3]{\ON{Cont}(#1,#2,#3)}
\newcommand{\inputCONTROLLABLE}[5]{\ON{Cont}(#1,#2,#3,#4,#5)}
\newcommand{\CONTROLLABLEaut}[3]{\ON{ContA}(#1,#2,#3)}
\newcommand{\inputCONTROLLABLEaut}[4]{\ON{ContA}(#1,#2,#3,#4)}

\newcommand{\PCdef}{\twoheadleftarrow}
\newcommand{\PCif}[1]{\ON{if}(#1)}
\newcommand{\PCelif}[1]{\ON{elif}(#1)}
\newcommand{\PCwhile}[1]{\ON{while}(#1)}
\newcommand{\PCfor}[1]{\ON{for}(#1)}
\newcommand{\PCreturn}[1]{\ON{return}(#1)}
\newcommand{\PCmatch}[2]{\ON{match}(#1 \leftrightarrows #2)}
\newcommand{\PCcontinue}{\ON{continue}}
\newcommand{\PCbreak}{\ON{break}}
\newcommand{\PCsigma}[1]{#1.\mathrm{\Sigma}}
\newcommand{\PCnonterms}[1]{#1.\mathrm{N}}
\newcommand{\PCemptyG}{\ON{emptyG()}}
\newcommand{\PClhs}[1]{#1.\ON{lhs}}
\newcommand{\PCrhs}[1]{#1.\ON{rhs}}
\newcommand{\PCproductions}[1]{#1.\mathrm{P}}
\newcommand{\PCemptyParser}{\ON{emptyParser()}}
\newcommand{\PCitemRhsII}[1]{#1.\mathrm{rhs2}}
\newcommand{\PCitemRhsI}[1]{#1.\mathrm{rhs1}}
\newcommand{\PCitemLhs}[1]{#1.\mathrm{lhs}}
\newcommand{\PCitemLa}[1]{#1.\mathrm{la}}
\newcommand{\PCrules}[1]{#1.\mathrm{R}}
\newcommand{\PCoutput}[1]{#1.\mathrm{O}}
\newcommand{\PCemptyEPDA}{\ON{emptyEPDA()}}
\newcommand{\PCgamma}[1]{#1.\mathrm{\Gamma}}
\newcommand{\PCstates}[1]{#1.\mathrm{Q}}
\newcommand{\PCedges}[1]{#1.\delta}
\newcommand{\PCfinal}[1]{#1.\mathrm{F}}
\newcommand{\PCinitial}[1]{#1.\mathrm{q_0}}
\newcommand{\PCstackBottom}[1]{#1.\ON{\Box}}
\newcommand{\PCred}{\global\edef\PCredIF{1}}
\newcommand{\PCredOff}{\global\edef\PCredIF{X}}\PCredOff
\newcommand{\PCfredPrint}[1]{\ifthenelse{\equal{\PCredIF}{X}}{\begingroup\color{red!50!black}\ON{#1}\endgroup}{\begingroup\color{red}\ON{#1}\endgroup}\PCredOff}
\newcommand{\PCfCC}[3][\SigmaUC]{\PCfredPrint{CC}\ifthenelse{\isempty{#2#3}}{}{(#2,#3,#1)}}
\newcommand{\PCfCCL}[3][\SigmaUC]{\PCfredPrint{CCL}\ifthenelse{\isempty{#2#3}}{}{(#2,#3,#1)}}
\newcommand{\PCfCCS}[3][\SigmaUC]{\PCfredPrint{CCS}\ifthenelse{\isempty{#2#3}}{}{(#2,#3,#1)}}
\newcommand{\PCfAC}[1]{\PCfredPrint{AC}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfTE}[2]{\PCfredPrint{TE}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}\xspace}
\newcommand{\PCfTS}[2]{\PCfredPrint{TS}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfTRANSIENT}[1]{\PCfredPrint{TRANSIENT}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfRNCE}[3]{\PCfredPrint{RNCE}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfSPLIT}[1]{\PCfredPrint{SPLIT}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfRULS}[1]{\PCfredPrint{RULS}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfCONT}[1]{\PCfredPrint{CONT}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfNONBLOCK}[1]{\PCfredPrint{NONBLOCK}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfdesc}[3]{\PCfredPrint{desc}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfdescone}[3]{\PCfredPrint{desc1}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfdesconeone}[3]{\PCfredPrint{desc11}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfDollarAugmented}[3]{\PCfredPrint{\DIM}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfderive}[3]{\PCfredPrint{derive}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCffirst}[2]{\PCfredPrint{first}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstLeqi}[3]{\PCfredPrint{firstleq1}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCffirstR}[2]{\PCfredPrint{firstR}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstReduced}[2]{\PCfredPrint{firstRed}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstA}[2]{\PCfredPrint{firstA}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstL}[2]{\PCfredPrint{firstL}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstOne}[2]{\PCfredPrint{first1}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstAll}[2]{\PCfredPrint{firstAll}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCffirstDomStrings}[1]{\PCfredPrint{fDS}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfpassesX}[2]{\PCfredPrint{passesX}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfBASIS}[2]{\PCfredPrint{BASIS}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfLRPRules}[4]{\PCfredPrint{LRPRules}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}
\newcommand{\PCfLRP}[5]{\PCfredPrint{LRP}\ifthenelse{\isempty{#1#2#3#4#5}}{}{(#1,#2,#3,#4,#5)}}
\newcommand{\PCfREPiip}[1]{\PCfredPrint{REP2+}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfREPz}[1]{\PCfredPrint{REP0}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfRPP}[1]{\PCfredPrint{RPP}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfNDA}[1]{\PCfredPrint{NDA}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfLRM}[2]{\PCfredPrint{LRM}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfLRMonce}[3]{\PCfredPrint{LRM1}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfEPDAGoto}[3]{\PCfredPrint{EPDAGoto}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfEPDAGotoSeq}[3]{\PCfredPrint{EPDAGotoSeq}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfValidEmpty}[2]{\PCfredPrint{ValidEmpty}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfLRMloop}[5]{\PCfredPrint{LRMloop}\ifthenelse{\isempty{#1#2#3#4#5}}{}{(#1,#2,#3,#4,#5)}}
\newcommand{\PCfGPtoPP}[2]{\PCfredPrint{GP2PP}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfdescInitial}[1]{\PCfredPrint{descInitial}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfSPtoLR}[1]{\PCfredPrint{SP2LR}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCftimes}[2]{\PCfredPrint{\times}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfGOTO}[4]{\PCfredPrint{GOTO}\ifthenelse{\isempty{#1#2#3#4}}{}{(#1,#2,#3,#4)}}
\newcommand{\PCfRtoE}[2]{\PCfredPrint{R2E}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfRtoQ}[2]{\PCfredPrint{R2Q}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfRENAMEQ}[2]{\PCfredPrint{RenQ}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfRENAMEG}[2]{\PCfredPrint{RenG}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfFILTER}[2]{\PCfredPrint{filter}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfFILTERfirst}[2]{\PCfredPrint{filter1}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfPostCl}[1]{\PCfredPrint{PostCl}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfREPLACE}[3]{\PCfredPrint{replace}\ifthenelse{\isempty{#1#2#3}}{}{(#1,#2,#3)}}
\newcommand{\PCfRUP}[1]{\PCfredPrint{RUP}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfRNPP}[1]{\PCfredPrint{RNPP}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfRNPPL}[2]{\PCfredPrint{RNPPL}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfRNPPone}[2]{\PCfredPrint{RNPP1}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\PCfRUS}[1]{\PCfredPrint{RUS}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\PCfFreshState}[2]{\PCfredPrint{FreshState}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}\xspace}
\newcommand{\PCfRNPS}[1]{\PCfredPrint{RNPS}\ifthenelse{\isempty{#1}}{}{(#1)}}


\newcommand{\SigmaC}{\Sigma_{\mathsf{c}}}
\newcommand{\SigmaUC}{\Sigma_{\mathsf{uc}}}
\newcommand{\EARS}[2]{\ensuremath{\ON{Ears}(#1,#2)}}
\newcommand{\HEADS}[1]{\ensuremath{\ON{Heads}(#1)}}
\newcommand{\ANN}[2]{\ensuremath{\TupleAngle{\mathsf{#1},#2}}}
\newcommand{\EAR}[2]{\ANN{ear}{#1,#2}}
\newcommand{\HEAD}[1]{\ANN{head}{#1}}
\newcommand{\QST}{\ensuremath{Q_{\Gamma,\SpT}}}
\newcommand{\FB}{\ensuremath{F_{B}}}
\newcommand{\projState}[2][]{\pi_{#1}(#2)}
\newcommand{\PI}{\ensuremath{PI}}
\newcommand{\ContOAutNamePI}{\autfont{\ContOName}_{\PI}}
\newcommand{\ContOAutRhsPI}{\Tuple{Q_{\PI},\Sigma,\Gamma,\delta_{\PI},q_{\PI,0},\Box,F_{\PI}}}
\newcommand{\NoAcTr}[1]{\ON{NoAcTr}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\NoAcSt}[1]{\ON{NoAcSt}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\ACCESSIBLEPART}[1]{\ON{Ac}(#1)}
\newcommand{\Acx}{\ensuremath{Ac_{\times}}}
\newcommand{\AcAutName}{\autfont{\ContOName_{\Acx}}}
\newcommand{\AcAutRhs}{\Tuple{Q',\Sigma,\Gamma,\delta',q'_{0},\Box,F'}}
\newcommand{\SPLITSTATES}[1]{\ON{Split}(#1)}
\newcommand{\SpA}{\ensuremath{Sp}}
\newcommand{\SplitAutNameA}{\autfont{\ContOName}_{\SpA}}
\newcommand{\SplitAutRhsA}{\Tuple{Q_{\SpA},\Sigma,\Gamma,\delta_{\SpA},\HEAD{q_{0}},\Box,F_{\SpA}}}

\newcommand{\TestUSELESS}[2]{\ensuremath{\ON{TestUL(#1,#2)}}}
\newcommand{\USELESSSTATES}[1]{\ON{ULS}(#1)}
\newcommand{\REMOVEUSELESSSTATES}[1]{\ON{RULS}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\Sp}{\ensuremath{SpT}}
\newcommand{\SplitAutName}{\autfont{\ContOName}_{\Sp}}
\newcommand{\SplitAutRhs}{\Tuple{Q_{\Sp},\Sigma,\Gamma,\delta_{\Sp},\HEAD{q_{0}},\Box,F_{\Sp}}}
\newcommand{\SpT}{\ensuremath{SpT}}
\newcommand{\SplitAutNameT}{\autfont{\ContOName}_{\SpT}}
\newcommand{\SplitAutRhsT}{\Tuple{Q_{\SpT},\Sigma,\Gamma,\delta_{\SpT},\HEAD{q_{0}},\Box,F_{\SpT}}}
\newcommand{\NONCONTSTATES}[2]{\ON{NCS}(#1,#2)}
\newcommand{\NONCONTEARS}[3]{\ON{NCE}(#1,#2,#3)}
\newcommand{\SpR}{\ensuremath{SpTR}}
\newcommand{\RncsAutName}{\autfont{\ContOName}_{\SpR}}
\newcommand{\RncsAutRhs}{\Tuple{Q_{\SpR},\Sigma,\Gamma,\delta_{\SpR},q_{0},\Box,F_{\SpR}}}
\newcommand{\recRncsAutName}[1]{\autfont{\ContOName}_{\SpR}(#1)}
\newcommand{\kSpRc}{\ensuremath{k_{\SpR}}}
\newcommand{\RCP}[1]{\ON{RemoveContProblems}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\Wuc}[1]{\ensuremath{\mathcal{S}_{uc}(#1)}}
\newcommand{\WMuc}[1]{\ensuremath{\mathcal{S}_{m}(#1)}}
\newcommand{\WUMuc}[1]{\ensuremath{\mathcal{S}_{um}(#1)}}
\newcommand{\NONBLOCK}[1]{\ON{EnsureNonBlocking}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\Nb}{\ensuremath{NB}}
\newcommand{\NbAutName}{\autfont{\ContOName_{\Nb}}}
\newcommand{\NbAutRhs}{\Tuple{Q_{\Nb},\Sigma,\Gamma,\delta_{\Nb},q_{0},\Box,F_{\Nb}}}
\newcommand{\CC}[2]{\ON{CC}\ifthenelse{\isempty{#1#2}}{}{(#1,#2)}}
\newcommand{\CCLD}[2]{\ON{CCLD}(#1,#2)}
\newcommand{\CCLBF}[2]{\ON{CCLBF}(#1,#2)}
\newcommand{\CCL}[2]{\ON{CCL}(#1,#2)}




\newlength{\XInnerSep}
\setlength{\XInnerSep}{2ex}
\newcommand{\emBox}[2]{
\begin{pgfonlayer}{background}\node [line width=\XInnerSep,join=round,fill=black!10,fit=#2] (#1) {};\end{pgfonlayer}
\node (lab#1) at (#1.north west) {};
} 
\usetikzlibrary{calc, intersections,positioning}
\usepackage{graphicx,adjustbox}
\usepackage{scrtime}
\usepackage{natbib}
\newcommand{\TOBEREMOVED}[2][1]{{\ifthenelse{\equal{#1}{1}}{\color{blue!80!white}#2}{\color{blue!50!white}#2}}}
\newcommand{\Derivations}[1]{\mathcal{D}(#1)\xspace}
\newcommand{\InitialDerivations}[1]{\mathcal{D}_\mathrm{I}(#1)\xspace}
\newcommand{\AccLang}[1]{\ON{L_{m}}(#1)\xspace}
\newcommand{\AccLangX}{\ON{L_{m}}\xspace}
\newcommand{\AnyLang}[1]{\ON{L_{um}}(#1)\xspace}
\newcommand{\AnyLangX}{\ON{L_{um}}\xspace}
\newcommand{\IFTHENELSE}[3]{\ON{if }#1\ON{ then }#2\ON{ else }#3\xspace}
\newcommand{\myparagraph}[1]{\par\emph{#1:}}

\newcommand{\AnConf}[2]{\mathrm{\maltese}(#1,#2)\xspace}
\newcommand{\CAConf}[1]{\mathcal{C}_{\mathrm{A}}(#1)\xspace}
\newcommand{\CConf}[1]{\mathcal{C}(#1)\xspace}

\newcommand{\AccConf}[1]{\mathcal{C}_{\ON{fin}}(#1)}
\newcommand{\ReachConf}[1]{\mathcal{C}_{\ON{reach}}(#1)}


\newcommand{\OUTm}[1]{o_{\var{m}}\ifthenelse{\isempty{#1}}{}{(#1)}}
\newcommand{\OUTum}[1]{o_{\var{um}}\ifthenelse{\isempty{#1}}{}{(#1)}}

\newcommand{\ATSrhsX}{E,C,S,\pi_S,R,c_0,A,O,\OUTm{},\OUTum{}}
\newcommand{\ATSrhs}{(\ATSrhsX)}
\newcommand{\BlockFree}[1]{\ON{BlockFree}(#1)\xspace}
\newcommand{\kPrefix}[1]{{1}{:}#1\xspace}
\newcommand{\kPREFIX}[2][k]{{#1}{:}#2\xspace}

\newcommand{\RULE}[4]{#1 {\mid} #2 {\fun} #3 {\mid} #4}

\newcommand{\OBF}{operational blockfree\xspace}
\newcommand{\LBF}{\textrm{LBF}\xspace}
\newrobustcmd{\FIGREF}[1]{Figure~\ref{#1}}
\newrobustcmd{\THMREF}[1]{Theorem~\ref{#1}}
\newrobustcmd{\DEFREF}[1]{Definition~\ref{#1}}
\newrobustcmd{\TABREF}[1]{Table~\ref{#1}}
\newrobustcmd{\SECREF}[1]{Section~\ref{#1}}
\newrobustcmd{\EQNREF}[3]{Equation\ifthenelse{\isempty{#2#3}}{}{s}~\eqref{#1}\ifthenelse{\isempty{#2#3}}{}{#2\eqref{#3}}}

\newcommand{\instantiate}[1]{{\fboxsep1pt\fbox{}}}



\newcommand{\CHANGE}[1]{{\color{red}#1}}
\newcommand{\WAS}[1]{{\color{blue}#1}}
\newcommand{\COM}[1]{{\color{red}\textit{#1}}}

\begin{document}
\def\abstractname{{\bfseries {Abstract: }}}
\def\figurename{\bfseries\footnotesize Figure}
\def\tablename{\bfseries\footnotesize Table}
\begin{frontmatter}
\title{Enforcing Operational Properties\\including Blockfreeness for\\Deterministic Pushdown Automata}

\author{S. Schneider and U. Nestmann}

\address{Technische Universit√§t Berlin}
\begin{abstract}
We present an algorithm which modifies a deterministic pushdown automaton (\DPDA) such that
\begin{inparaenum}[(i)]\item the marked language is preserved, \item lifelocks are removed, \item deadlocks are removed, \item all states and edges are accessible, and \item \OBF{}ness is established (i.e., coaccessibility in the sense that every initial derivation can be continued to a marking configuration). \end{inparaenum}
This problem can be trivially solved for deterministic finite automata (\DFA) but is not solvable for standard petri net classes.
The algorithm is required for an operational extension of the supervisory control problem (\SCP) to the situation where the specification in modeled by a \DPDA.
\end{abstract}

\begin{keyword}
Deterministic Pushdown Automata, DPDA, Blockingness, Deadlocks, Lifelocks, Accessibility, Coaccessibility, Supervisory Control
\end{keyword}


\end{frontmatter}

We are introducing an algorithm to transform a \DPDA such that its observable operational behavior is restricted to its desired fragment.
The algorithm decomposes the problem into three steps: transformation of the \DPDA into a Context Free Grammar (\CFG) while preserving the operational behavior, restricting the \CFG to enforce operational blockfreeness, and the transformation of the resulting \CFG via \Parser{}s to \DPDA while preserving and establishing the relevant criteria on the operational behavior.
The algorithm presented here is an essential part for the effective solution of the supervisory control problem for \DFA plants and \DPDA specifications which is reduced (in the companion paper by \citet*{SchneiderSchmuck2014}) to the effective implementability of ensuring blockfreeness (solved in this paper) and ensuring controllability (solved in the companion paper by \citet*{SchmuckSchneider2014}).

In \SECREF{sect:ATS} we define abstract transition systems (\ATS) as a basis for the systems involved in the algorithm and give a formal problem statement to be solved for \DPDA.
In \SECREF{sect:CTS} we define the concrete transition systems appearing in the algorithm as instantiations of \ATS.
In \SECREF{sect:ALG} we present the extensive algorithm due to space restrictions mostly informally using a running example before we discuss the formal verification and possible improvements of the approach.
The formal constructions of the algorithm are contained in~\cite{SchneiderSchmuck_TechRep_2013}.
We summarize our results in \SECREF{sect:SUM} and outline our next steps in \SECREF{sect:FUTURE}.

\section{Abstract Transition Systems}\label{sect:ATS}
The concrete systems used in this paper (including \DPDA, \CFG, and \Parser{}s) are instantiations of the subsequently defined class of Abstract Transition Systems (\ATS).
Thus, they will inherit the uniform definitions of derivations, languages, and the problem to be solved from the \ATS definitions.

\newrobustcmd{\RED}[1]{{\color{red}#1}}
\newrobustcmd{\VISIBLE}[1]{#1}
\newrobustcmd{\OPTSIGMAELEM}{\VISIBLE{\sigma}}
\newrobustcmd{\STACKELEM}{\VISIBLE{\gamma}}
\newrobustcmd{\SIGMAELEM}{\VISIBLE{\alpha}}
\newrobustcmd{\STACKSTR}{\VISIBLE{s}}
\newrobustcmd{\SIGMASTR}{\VISIBLE{w}}
\newrobustcmd{\FIXEDSTR}{\VISIBLE{f}}
\newrobustcmd{\STATEELEM}{\VISIBLE{p}}
\newrobustcmd{\STATESTR}{\VISIBLE{\tilde{p}}}
\newrobustcmd{\NONTERMELEMA}{\VISIBLE{A}}
\newrobustcmd{\NONTERMELEMB}{\VISIBLE{B}}
\newrobustcmd{\CFGMIXSTR}{\VISIBLE{v}}
\newrobustcmd{\CFGMIXELEM}{\VISIBLE{\kappa}}

Throughout the paper we use the following notations.
\begin{notation}
Let  be an alphabet and let  be a set. Then
\begin{inparaenum}[(i)]
\item  denotes the set of all finite words over ,
\item ,
\item  denotes the set of all finite and infinite words over ,
\item  is the (sometimes omitted) concatenation operation on words (and languages), 
\item  is the prefix relation, \item  is the prefix-closure of , \item  is the suffix relation, and \item  denotes the k-Prefix of  defined by , and
\item  denotes  where  represents undefinedness.
\end{inparaenum}
\end{notation}

\begin{definition}[Abstract Transition System]\label{def:ATS}\leavevmode\\
 \IFFtext
\begin{inparaenum}[(i)]
\item  is a set of step-edges,
\item  is a set of configurations,
\item  is a set of states,
\item  maps each configuration to at most one state,
\item  is a binary step-relation on ,
\item  is the initial configuration,
\item  is the marking subset of ,
\item  is the set of outputs, and
\item  and  define the unmarked and marked outputs for configurations.
\end{inparaenum}
\end{definition}
For these \ATS we define their derivations, generated languages, and subsequently the properties to be enforced.
\begin{definition}[Semantics of \ATS]\begin{inparaenum}[(i)]
\item the set of derivations  contains all elements from  starting in a configuration of the form  where all adjacent  satisfy ,
\item the set of initial derivations  contains all elements of  starting with ,
\item the reachable configurations  are defined by ,
\item the marked language  is defined by , and
\item the unmarked language  is defined by .
\end{inparaenum}\\
The concatenation of derivations  is given by .
\end{definition}
\begin{definition}[Properties of \ATS]\label{ATS:props}
\begin{inparaenum}[(i)]
\item  has a deadlock \IFFtext for some finite  of length  which is not marking (i.e., for all ,  implies ) there is no  such that ,
\item  has a lifelock \IFF for some infinite  there is an  such that the unmarked language of  is constant after  (i.e., for all , ),
\item  is accessible \IFF for each  there is  such that  and
for each  there is  such that , and
\item  is \OBF \IFF for any finite  of length  ending in  there is a continuation  such that  is a marking derivation and  and  match at the gluing point  (i.e., ).
\end{inparaenum}
\end{definition}

By definition, for \OBF \ATS the absence of deadlocks is guaranteed.
Finally, we present the problem of enforcing the desired properties on an \ATS, which will be solved for \DPDA by the algorithm presented in \SECREF{sect:ALG}.

\begin{definition}[Problem Statement for \ATS]\label{def:ATS:problem}
Let .
How to find  such that 
\begin{inparaenum}[(i)]
\item ,
\item  is accessible,
\item  has no deadlocks,
\item  has no lifelocks, and
\item  is \OBF?
\end{inparaenum}
\end{definition}
In the \DFA-setting: lifelocks can not occur and the other aspects of the problem are solved by simple and efficient graph-traversal algorithms pruning out states which are either not reachable from the initial state or from which no marking state can be reached\footnote{The trivial handling of an \ATS with empty marked language obtained at some point of the calculation is kept implicit in this paper (in this case, no solution exists and the calculation can be aborted).}.

\section{Concrete Transition Systems}\label{sect:CTS}
Every deterministic context free language can be properly represented by at least three different types of finite models: a deterministic \EPDA, a context free grammar (\CFG) satisfying the \LR determinism property, and a deterministic \Parser.
These three types occur at intermediate steps of our algorithm which solves the problem stated in \DEFREF{def:ATS:problem}.
Therefore, the following subsections contain their definitions as instantiations of the \ATS.
In each of the three cases we proceed in three steps:
\begin{inparaenum}
\item definition of \EPDA, \CFG, and \Parser as tuples,
\item instantiation of the \ATS-scheme by defining each of the ten components, and
\item characterization of the determinism conditions.
\end{inparaenum}

\begin{remark}
We provide the slightly nonstandard branching semantics\footnote{The branching interpretation is already the standard for \CFG.} for \EPDA and \Parser{}s which utilize a history variable in the configurations to greatly simplify the definition of the operational-blockfreeness from \DEFREF{ATS:props}.
Furthermore, this branching semantics corresponds to the intuition that the finite state realizations are generators rather than acceptors of languages, as it is customary in the context of supervisory control theory.

\end{remark}
\newrobustcmd{\ENDOFSTACK}{\ensuremath{\Box}\xspace}
\subsection{\EPDA and \DPDA}
We introduce \EPDA, which are \NFA enriched with a variable on which the stack-operations top, pop, and, push can be executed.
\begin{definition}[Extended Pushdown Automata (\EPDA)]\label{def:PDA}\leavevmode\\
 \IFF
\begin{inparaenum}[(i)]
\item the states , the output alphabet , the stack alphabet , and the set of edges  are finite (, , , , ,  range over , , , , , , respectively),
\item ,
\item the end-of-stack marker  is contained in ,
\item the marking states  and the initial state  are contained in , and
\item  is never removed from the stack (i.e.,  and  imply ).
\end{inparaenum}
\end{definition}
We proceed with the \ATS instantiation for \EPDA.
\begin{definition}[\EPDA---\ATS Instantiation]\label{def:PDAsemantics}\leavevmode\\
An \EPDA  instantiates the \ATS scheme  via:
\begin{inparaenum}[(i)]
\item \instantiate{E}~
\item \instantiate{C}~ where  consists of a state , a history variable  (storing the symbols generated), and the stack-variable 
\item \instantiate{S}~
\item \instantiate{\pi_S(\STATEELEM,\SIGMASTR,\STACKSTR)}~
\item \instantiate{R}~ defined by 
\item \instantiate{c_0} 
\item \instantiate{A}~
\item \instantiate{O}~
\item \instantiate{\OUTm{\STATEELEM,\SIGMASTR,\STACKSTR},\OUTum{\STATEELEM,\SIGMASTR,\STACKSTR}}~
\end{inparaenum}
\end{definition}

\newcommand{\Yes}{\checkmark}

The well known sub-classes of \EPDA having one or more of the properties below are defined in \TABREF{tab:subclasses}.
\begin{definition}[Sub-classes of \EPDA]
\myTable{fig__subclasses}{tab:subclasses}{Subclasses of \EPDA.}
An \EPDA is 1-pop\-ping \IFFtext every edge pops precisely one element from  from the stack.
An \EPDA is deterministic \IFFtext for every reachable configuration all two distinct steps append distinct elements of  to the history variable\footnote{Thus, -steps may not be enabled simultaneously with other steps.}.
An \EPDA is -step-free \IFFtext no edge is of the form .
An \EPDA is stack-free \IFFtext every edge is of the form .
\end{definition}

\subsection{\CFG and \LR}
A \CFG (e.g., defined by \cite{DBLP:journals/iandc/GinsburgG66b}) is a term-replacement system replacing a nonterminal with a word over output symbols\footnote{The output symbols of a \CFG are usually called terminals.} and nonterminals.
\begin{definition}[Context-Free Grammars (\CFG)]\label{def:cfg}\leavevmode\\
 \IFF
\begin{inparaenum}[(i)]
\item the nonterminals  (ranging over ), the output alphabet , and the productions  are finite
\item , and
\item the initial nonterminal  is contained in .
\end{inparaenum}
 and  range over  and , respectively.
Productions  are written .
\end{definition}
\begin{definition}[\CFG---\ATS Instantiation]\label{def:CFGsemantics}\leavevmode\\
A   instantiates the \ATS scheme  via:
\begin{inparaenum}[(i)]
\item \instantiate{E}~
\item \instantiate{C}~ 
\item \instantiate{S}~
\item \instantiate{\pi_S}~take the first nonterminal (if present) of the configuration
\item \instantiate{R}~ given by 
\item \instantiate{c_0}~
\item \instantiate{A}~
\item \instantiate{O}~
\item \instantiate{\OUTm{\CFGMIXSTR}}~
\item \instantiate{\OUTum{\CFGMIXSTR}}~
\end{inparaenum}
\end{definition}
The \LR-condition below, which corresponds to the determinism property of \EPDA, depends on the restriction of the step-relation to the replacement of the right-most nonterminal which will be denoted by the index .
\begin{definition}[\LR-Condition]
According to \cite{sippu-2} (page 52)\footnote{The here relevant section 6.6 of the monograph \cite{sippu-2} is based primarily on the work of \cite{DBLP:journals/iandc/Knuth65} which was later extended by \cite{Aho:1972:TPT:578789}.}, \LR is the set of all \CFG for which (assuming )\\
\begin{inparaenum}[(i)]
\item ,\\
\item ,\\
\item , and\\
\item , imply\\
\item , , and .
\end{inparaenum}
\end{definition}
Intuitively, if a parser for a \CFG has generated the shorter prefix  it must be able to decide by fixing the next symbol ( and , respectively) whether  is to be applied backwards or whether for  another symbol of  should be generated or for  the production  is to applied backwards\footnote{E.g., .}.


\subsection{\Parser}
Intuitively, a \Parser is an \EPDA with mild modifications\footnote{An equivalent linear/scheduled definition of \Parser is given by \cite{sippu-2}.}:
\begin{inparaenum}
\item the parser may fix the next output-symbol (without generating it) and
\item the parser may terminate the generation of symbols (by fixing the end-of-output marker ).
\end{inparaenum}
\begin{definition}[\Parser]\label{def:parser}
 \IFF\\
\begin{inparaenum}[(i)]
\item the stack alphabet , the output alphabet , the marking stack-tops , and the rules  are finite,
(, , , , range over , , , , respectively)
\item ,
\item the initial stack symbol  and the marking stack-tops  are contained in ,
\item the end-of-output marker  is contained in ,
\item the parser may not modify the output (i.e.,  implies  (i.e.,  ends with )), and
\item the end-of-output marker  may not be generated (i.e.,  and  imply ).
\end{inparaenum}
Rules  are written .
\end{definition}
Intuitively, a rule  is changing the state from  to , pops  from the stack, pushes  to the stack, fixes the output , and generates  to the output.
\begin{definition}[\Parser---\ATS Instantiation]\label{def:ParserSemantics}\leavevmode\\
A \Parser  in\-stan\-ti\-ates the \ATS scheme
  via:
\begin{inparaenum}[(i)]
\item \instantiate{E}~
\item \instantiate{C}~ where  contains the stack fragment , the current state , a history variable , and the \emph{fixed} part  which the parser fixed without generating it.
\item \instantiate{S}~
\item \instantiate{\pi_S(\STACKSTR\sconc \STATEELEM,\SIGMASTR,\FIXEDSTR)}~
\item \instantiate{R}~ given by  where
  \begin{inparaenum}[(a)]
  \item ,
  \item ,\!\footnote{Here  removes a potential  from the end of  and  drops the first  symbols from .} and finally
  \item .
  \end{inparaenum}
\item \instantiate{c_0}~
\item \instantiate{A}~
\item \instantiate{O}~
\item \instantiate{\OUTm{\STACKSTR\sconc \STATEELEM,\SIGMASTR,\FIXEDSTR}}~
\item \instantiate{\OUTum{\STACKSTR\sconc \STATEELEM,\SIGMASTR,\FIXEDSTR}}~.
\end{inparaenum}
\end{definition}
A \Parser is deterministic \IFF for all reachable configuration all two distinct steps
\begin{inparaenum}[(i)]
\item append distinct symbols to the history variable, or
\item one step adds a symbol to the history variable and the other step completes the output-generation by fixing the end-of-output marker \footnote{A parser may (depending on the other rules) be deterministic if  and  are successors of the same reachable configuration .}.
\end{inparaenum}

\section{Approach}\label{sect:ALG}
\newcommand{\EdgeLabel}[3]{{#1}\kern-1pt{,}\kern-1pt{#2}\kern-1pt{,}\kern-1pt{#3}}
\newcommand{\EdgeSep}{;}

\myFigure{fig__example__M_0_and_M_I}{\DPDA \STEP{0} and  generating .}
\emph{Motivation:} For example, the \DPDA \STEP{0} in \FIGREF{fig__example__M_0_and_M_I} exhibits
\begin{inparaenum}[]
\item a lifelock generating the output  reaching  arbitrarily often,
\item a lifelock (and blocking situations) generating the output  reaching  arbitrarily often,
\item a non accessible state  (along with the edge leading to it), but
\item no deadlock.
\end{inparaenum}
Observe that the cause ( does not properly distinguish between an even or odd number of generated s) is structurally separated from the lifelock at .
Thus, the intuitive solution  (see \FIGREF{fig__example__M_0_and_M_I}) is obtained by splitting the state  and by removing junk.
Any formal construction must 
\begin{inparaenum}[]
\item detect the states with a deadlock, a lifelock, or a blocking situation,
\item determine the cause of that problem, and
\item make a decision on how to fix the problem.
\end{inparaenum}

\myFigure{fig__overview}{Visualization of the algorithm.}

\emph{Solution:} In \FIGREF{fig__overview} we have depicted our approach in the subsequently explained 12 steps.
The basic idea is to
\begin{inparaenum}[]
\item (Steps 1--3) transform the \DPDA \STEP{0} into a \CFG \STEP{3},
\item (Step 4) obtain an \LR grammar \STEP{4} by restricting \STEP{3} to establish operational blockfreeness and absence of lifelocks,
\item (Steps 5--11) transform the \LR grammar into a \DPDA \STEP{11} preserving the desired properties, and finally
\item (Step 12) remove all inaccessible states and edges.
\end{inparaenum}

Steps~1--4 and~7--12 preserve the marked language.
Steps~1--3 and~7--12 preserve the unmarked language while step~4 restricts the unmarked language to the prefix closure of the marked language.
Steps~5 and~6 are not meant to preserve the (un)marked language as they are only intermediate results of the translation in Step~7.

\myparagraph{Approximating Accessibility}\label{mypar:ApproximatingAccessibility}
Throughout the following presentation we omit states and edges which are obviously inaccessible: such states and edges are detected by overapproximating the possible -length prefixes of stacks in reachable configurations.
The -overapproximation  is the least function satisfying the following rules:
\begin{inparaenum}[(i)]
\item initial configuration: ,
\item closure under steps: if  and  then  and , and
\item transitivity: if  and  then .\footnote{
Without using the transitivity rule we obtain the - and -overapproximations  and  of \STEP{0} (where we omit empty sets):




}
\end{inparaenum}


For example, in  the state  is obviously inaccessible because the set of all -length prefixes of stacks of reachable configurations with state  is empty. However, we would obtain  to be a -length prefix of a reachable configuration with state ; i.e., by increasing the parameter for the length of the calculated prefixes a better result may be obtained. For \DFA and  the standard \DFA-accessibility-operation is obtained.
For arbitrary \DPDA step~12 alone enforces accessibility.

\newcommand{\OPNAME}[1]{\ensuremath{f_{\mathrm{#1}}}\xspace}
\newcommand{\FUNtoSDPDA}{\OPNAME{2SDPDA}}
\newcommand{\FUNfreshSymbol}{\OPNAME{fresh}}
\newcommand{\FUNRNoOp}{\OPNAME{NoNoOp}}
\newcommand{\FUNSPP}{\OPNAME{SPP}}
\newcommand{\FUNRMP}{\OPNAME{RMP}}
\newcommand{\FUNSR}{\OPNAME{SR}}
\newcommand{\epdagamma}{\mathrm{epda\underbar{ }gamma}}
\newcommand{\mathlet}{\mathrm{let}~}
\newcommand{\mathin}{~\mathrm{in}~}

Applying this approximation implicitly in the running example, we now describe the steps of the algorithm solving the problem stated in \DEFREF{def:ATS:problem}.

\myparagraph{Step 1}
We transform the \DPDA into a simple \DPDA (called \SDPDA subsequently) such that every edge is of one of three forms: a generating edge , a pop edge , or a push edge .
The operation consists of four steps:
\begin{inparaenum}[(i)]
\item split every edge of the form  into  and ,
\item split every neutral edge of the form  into  and  for a unique fresh stack symbol ,
\item split every rule of the form  with  into 
 and
 for every , and
\item split every rule of the form  into  steps which push a single symbol of  in each step.
\end{inparaenum}
Note that the fresh states to be used in each of the four steps contain the edge for which they have been constructed (i.e.,  in the first step is ).
The operation has been adapted from \cite{DBLP:journals/iandc/Knuth65} by 
\begin{inparaenum}
\item correcting the handling of neutral edges involving the \ENDOFSTACK symbol (for example, the self loop at  in  would have been handled incorrectly), and by
\item logging the involved edges in the fresh states as explained before.
\end{inparaenum}
\myFigure{fig__example__SDPDA_NDA_LR1_no_rename}{The simple \DPDA \STEP{1}, the simple \DPDA \STEP{2} not exhibiting double marking, and the \LR-grammar \STEP{4}.}
For the \DPDA \STEP{0} from \FIGREF{fig__example__M_0_and_M_I} the \SDPDA \STEP{1} in \FIGREF{fig__example__SDPDA_NDA_LR1_no_rename} results (up to renaming of the states).


\myparagraph{Step 2}
We transform the \SDPDA \STEP{1} into an \SDPDA \STEP{2} such that once the \SDPDA \STEP{2} has generated an output, it has to generate another symbol before entering a marking state again.
For the example automaton \STEP{1} this means that the lifelock at  is problematic.
We are reusing the construction from \cite{DBLP:journals/iandc/Knuth65}:
Every state is duplicated (the duplicated states are neither initial nor marking).
Then, the edges are defined such that the automaton \STEP{2} operates on the original states until it reaches a marking state.
Once this happens, the automaton either remains in the original states by using a generating edge or it switches to the duplicated states.
The automaton remains in the duplicated states until switching to the original states using any generating edge.
For the \SDPDA \STEP{1} from \FIGREF{fig__example__SDPDA_NDA_LR1_no_rename} the \SDPDA \STEP{2} in the same figure results.
Note, the lifelock in  has been removed by the cost of another lifelock in  generating the same output .

\myparagraph{Step 3 \& Step 4} 
We transform the \SDPDA \STEP{2} in step~3 into the \CFG \STEP{3} using a construction from \cite{DBLP:journals/iandc/Knuth65}.
We restrict the \CFG \STEP{3} in step~4 to the \LR grammar \STEP{4} (see \FIGREF{fig__example__SDPDA_NDA_LR1_no_rename}) by removing all productions from \STEP{3} which do not appear in any marking derivation of \STEP{3}.
That is, the accessible and coaccessible part is constructed using a fixed-point algorithm in each case.
For the accessible part: the \emph{accessible} nonterminals are the least set of nonterminals  such that the initial nonterminal is contained in  and for any production : if , then the nonterminals of  are contained in .
For the coaccessible part: the \emph{coaccessible} nonterminals are the least set of nonterminals  such that for any production : if the nonterminals of  are contained in  then .
The equivalence of \STEP{2} and \STEP{4} w.r.t. the marked language can best be understood by comparing the derivations in \FIGREF{fig__example__derivation_SDPDA_LR1G}.
The following three properties explain the correctness of the construction:
\begin{inparaenum}[(i)]
\item The nonterminals of the form  (for example ) guarantee a marking derivation of the \SDPDA starting in  not modifying the stack starting with .
\item The nonterminals of the form  (for example ) guarantee a derivation of the \SDPDA starting in  not modifying the stack starting with  and reaching a configuration in which the  is removed and the state  is reached.
\item For any configuration  there are  such that 
 is reachable by \STEP{2} \IFF  is reachable by \STEP{4}.
\end{inparaenum}

\emph{Once step~4 has been completed, for the given \DPDA a marked language equivalent \CFG has been constructed which is lifelockfree, accessible, and operational blockfree (and by that deadlockfree).}

\myFigure{fig__example__derivation_SDPDA_LR1G}{Corresponding initial derivations of the \SDPDA \STEP{2} and the \LR grammar \STEP{4}.}

\myparagraph{Step 5 \& Step 6 \& Step 7}
In these steps we are following, with some modifications, the constructions in \cite{sippu-2}.

In step~5 we are constructing the \ENDOFOUTPUT-augmented version \STEP{5} of \STEP{4}: A new initial nonterminal  and the production  are added where  is the old nonterminal.
This modification allows for a simpler construction procedure of the \LR-machine and the \LR-parser in steps~6 and~7.

\myFigureWide{fig__example__LRmachine}{The \LR-machine \STEP{6}. Edges generating terminals (relevant for shift-rules) and items with marker  at the beginning of the right hand side (relevant for reduce rules) are printed in red.}
In step~6 we are constructing the \LR-machine \STEP{6} (depicted in \FIGREF{fig__example__LRmachine}) for the \LR-grammar \STEP{5}.
The output alphabet of the \DFA \STEP{6} is the union of the output alphabet and the nonterminals of \STEP{5}.
The steps of the parser (between two states  of \STEP{6}) will depend on the elements of : these elements are called items which are formally four-tuples containing a production with a marker splitting the right hand side of the production and a lookahead symbol.
The \DFA \STEP{6} has two kinds of edges:
the edges labeled with an output symbol  represent the action where the parser generates ,
the edges labeled with nonterminals are required for the actions where the parser concludes (based on its stack and the lookahead of the items) that it has generated a word derivable by a nonterminal.

Every edge  in \STEP{6} satisfies that  is the least set satisfying the following conditions:  contains all items of  where the marker  has been shifted over .
Furthermore, if an item of the form  is obtained, then the so-called \enquote{first}-symbols  are determined\footnote{While in \cite{sippu-2} no effective algorithm is presented for this operation we have been able to verify such a construction.} for which there is a  satisfying  with  and for all such (possibly empty)  and all productions of the form , the item  is contained in \footnote{The state with no items has been removed from the visualization in \FIGREF{fig__example__LRmachine}.}.

For example (in \FIGREF{fig__example__LRmachine}), the -successor of state  is state :  is the result of the shifting of the  over the  in the item ; 
 because  and  is (trivially) derivable to ;
 because  and  is derivable to .

\myFigure{fig__example__Parser0}{The rules of the \LR-parser \STEP{7} with initial state  and marking set .}
In step~7 we are constructing the \LR-parser \STEP{7} (depicted in \FIGREF{fig__example__Parser0}) for \STEP{5} and \STEP{6}. The parser consists of shift rules (generating a symbol and changing the stack and state) and reduce rules (which only modify the stack and state). The shift rules are obtained from the \LR-machine by selecting the edges in \STEP{6} which are labeled with an output symbol: an edge  would result in the shift rule  (e.g., the edge  results in the rule ).
The reduce rules are constructed for every item of the form  (i.e., the marker  is at the beginning of the right hand side): let  (by construction  is also a word over the stack alphabet of ) be the sequence of states visited by generating  starting in  in \STEP{6} and let  be the state reached by generating  in  in \STEP{6}.
Then the reduce rule  is added to 
the parser (e.g., the item  results in the rule ).

\begin{remark}
According to \cite{sippu-2}, the parser \STEP{7} is a \emph{correct prefix parser}. However, that is a too weak assertion: their definition of the unmarked language considers a symbol the parser has fixed but not generated not to be part of the generated unmarked word. Since the mode of operation we are interested (control of (embedded) discrete event systems), we had to find new proofs to verify that our stronger condition is also satisfied by the generated parser \STEP{7}.
\end{remark}

\myFigure{fig__example__Parser1}{The rules of the \LR-parser \STEP{8} with initial state  and marking set  (the nonterminals  are no longer reachable)}
\myparagraph{Step 8}
Since \DPDA are not capable of terminating the generation by fixing an end-of-output marker, we are modifying the parser \STEP{7} by removing all rules involving the end-of-output marker  and by changing the set of marking states such that \STEP{8} (depicted in \FIGREF{fig__example__Parser1}) marks in  \IFF some edge  has been removed. While it is not mentioned in \cite{sippu-2}, we discovered that this drastic removal of rules preserves the (un)marked language because the parser reaches a configuration in which such an edge is enabled if and only if the stack can be entirely reduced by subsequently executed reduce rules. This optimization also speeds up the parsing process using the presented construction in any other context (e.g., parsing of programming languages for which it has originally been designed).

\myFigure{fig__example__Parser2}{The rules of the \LR-parser \STEP{9} with initial state  and marking set .}
\myparagraph{Step 9}
Since \DPDA are not capable of fixing output symbols without generating them, we add the fixed output component of a configuration into the state of the configuration.
For every shift rule of the form  the rules  and  are used.
For every reduce rule of the form  the rules  and  are used.
The resulting parser \STEP{9} is depicted in \FIGREF{fig__example__Parser2}.

\emph{It is then possible to verify, that all reachable configurations of the resulting parser \STEP{9} have an empty fixed output component.
We call the parser \STEP{9} essentially \EDPDA because it uses none of the extra capabilities of the parser formalism.}

\myparagraph{Step 10}
The essentially \EDPDA parser \STEP{9} can be translated into the \EDPDA \STEP{10} (depicted in \FIGREF{fig__example__EDPDA}) by using for every rule of the form  the edge . Marking and initial states of \STEP{10} are taken from \STEP{9}.

\myparagraph{Step 11}
Since \DPDA are not capable of popping strictly \emph{more} than one symbol from the stack, we split such edges into multiple edges to obtain the \DPDA \STEP{11}. To preserve determinism, the splitting of edges with the same source entails the merging of partially identical edges until the recursive split identifies their distinctness. For example, the edges  and  share a common prefix  on the popping component.

Since \DPDA are not capable of popping strictly \emph{less} than one symbol from the stack, we modify the automaton by replacing any edge  with  for any  of the stack alphabet of \STEP{10}. For soundness, recall that the stack-bottom-marker can never be removed from the stack.

\myparagraph{Step 12}
Finally, accessibility of states and edges can be enforced by reusing the presented steps~1--4.
For a \DPDA we are executing steps~1--4.
From the productions obtained by step~4 we can determine by executing the steps~1--3 backwards (which are by our construction injective in the sense that for each constructed production/edge  a unique edge  can be determined for which  has been constructed).
Using this backwards computation, we are able to determine the accessible edges of a \DPDA.
The accessible states are the sources and edges of any of the accessible edges.
The inaccessible states and edges are then removed to obtain the \DPDA \STEP{12} from \FIGREF{fig__example__DPDA}.

We are not aware of comparable constructions ensuring accessibility of \DPDA, however, using the decidability of emptiness from \cite{HopcroftUllman} it is possible to test a single (and by that every) edge for accessibility; this approach has been used in~\cite{Griffin2006}.
Our approach is superior as we are executing a single test on all edges simultaneously.

\myFigure{fig__example__EDPDA}{The resulting \EDPDA \STEP{10} where obviously unreachable states have been removed.}
\myFigure{fig__example__DPDA}{The resulting \DPDA \STEP{12}.}

\myparagraph{Verification}
The soundness of the presented algorithm (w.r.t. the problem Definition~\ref{def:ATS:problem}) has been verified in the interactive theorem prover Isabelle/HOL~\citep{IsabelleHOL2011} apart from the following steps for which only pen-and-paper proofs exist yet and which are to be completed in Isabelle/HOL in the near future: 
\begin{inparaenum}[(i)]
\item the \CFG obtained in step~4 is an \LR grammar (satisfied according to \cite{DBLP:journals/iandc/Knuth65}),
\item the \Parser obtained in step~7 is deterministic if \STEP{5} is an \LR grammar (satisfied according to \cite{sippu-2}),
\item step~11, and
\item step~12.
\end{inparaenum}
From these tasks however, only the first appears to be complicated.

\myparagraph{Testing}
The presented algorithm has been implemented in Java for rapid prototyping and in C++ as a plugin to the \cite{libFAUDES} tool.
The implementations have been used successfully for many examples including the running example of this paper.

\myparagraph{Optimizations}
The algorithm can be optimized in different ways.
\begin{inparaenum}[(i)]
\item The runtime of the algorithm depends primarily on the steps~3 and~4 because \STEP{3} would have an enormous amount of productions. We can greatly restrict the set of productions to be generated by exploiting the structure of the input \DPDA using the reachability overapproximation presented on page~\pageref{mypar:ApproximatingAccessibility}.
\item Furthermore, steps~3 and~4 can be merged such that only productions are generated which are coaccessible.
This alternative trades runtime for space-requirements (the size of \STEP{4} is usually not much greater than \STEP{1} but the runtime is increased by the length of the longest derivation necessary in \STEP{2} to reach all states).
\item Another optimization merges adjacent edges in \EDPDA which are intermediate results. This optimization decreases the runtime of the subsequently executed operations.
\end{inparaenum}
The formal definition and verification in Isabelle/HOL of such intermediate operations is left for future work.

\section{Conclusion}\label{sect:SUM}
The algorithm presented in this paper optimizes the behavior of a \DPDA whilst preserving its marked language by first translating the \DPDA into another model (\LR grammars) in which the desired properties can be enforced using simple constructions and by translating the obtained solution back into \DPDA while preserving the desired properties.

The algorithm guarantees accessibility (every state and every edge is required for some marking derivation), lifelockfreeness (there is no initial derivation executing infinitely many steps without generating an output symbol), deadlockfreeness (non-extendable initial derivations are ending in marking states), and finally the operational blockfreeness (every initial derivation can be extended into a marking derivation).

The operational blockfreeness is sufficient to conclude that the unmarked language is the prefix closure of the marked language of the resulting \DPDA.

The algorithm does not minimize the size of the automaton, in fact, the size of the resulting \DPDA is usually increased and is growing according to \cite{DBLP:conf/focs/GellerHSU75} in some cases exponentially.

The algorithm presented here is a crucial part of the presented solution of the supervisory control problem for \DFA plants and \DPDA specifications which is reduced (in the companion paper by \citet*{SchneiderSchmuck2014}) to the effective implementability of ensuring blockfreeness (solved in this paper) and ensuring controllability (solved in the companion paper by \citet*{SchmuckSchneider2014}).

\section{Future Work}\label{sect:FUTURE}
\myparagraph{Petri nets}
Since the problem of establishing blockfreeness is unsolvable for standard Petri net classes~\citep{GiuaCesare1994,GiuaCesare1995}, we intend to determine Petri net classes  that can be translated (preserving the marked language) into a \DPDA  such that the \DPDA generated by our algorithm  can be translated back into a Petri net from  to solve the problem for such a Petri net class.

\myparagraph{Visibly Pushdown Tree Automata (\VPTA)}
\VPTA introduced by \cite{DBLP:conf/frocos/ChabinR07} are the greatest known subclass of \DPDA which are closed under intersection.
For the context of the Supervisory Control Theory we intend to determine an algorithm which solves the problem from \DEFREF{def:ATS:problem} for \VPTA because
\begin{inparaenum}[(i)]
\item plant and controller can then be generated by \VPTA, while this decreases the expressiveness for the controller language it also increases the expressiveness for the plant language, and
\item the closed loop is again a \VPTA, which allows for the iterative restriction of a plant language by horizontal composition of controllers.
\end{inparaenum}
The algorithm presented here may be reusable: the output of the algorithm, when executed on a \VPTA, may be (convertible) into a \VPTA.
Therefore, when using \VPTA for plants, specifications, and controllers, the supervisory controller synthesis can be extended to yet another domain.

\myparagraph{Nondeterminism}
For the context of the Supervisory Control Theory there is no reason to restrict oneself to deterministic controllers. However, for these systems the desired property of operational blockfreeness is not guaranteed for language blockfree controllers. Therefore, when extending the domain of the algorithm to \PDA the proofs will become more complex as the preservation of marked and unmarked language is no longer sufficient for the preservation of the operational blockfreeness as discussed in \cite{SchneiderSchmuck2014}.

\begin{thebibliography}{15}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi:\discretionary{}{}{}#1}\else
  \providecommand{\doi}{doi:\discretionary{}{}{}\begingroup
  \urlstyle{rm}\Url}\fi

\bibitem[{Aho and Ullman(1972)}]{Aho:1972:TPT:578789}
Aho, A.V. and Ullman, J.D. (1972).
\newblock \emph{The theory of parsing, translation, and compiling}.
\newblock Prentice-Hall, Inc., Upper Saddle River, NJ, USA.

\bibitem[{Chabin and R{\'e}ty(2007)}]{DBLP:conf/frocos/ChabinR07}
Chabin, J. and R{\'e}ty, P. (2007).
\newblock Visibly pushdown languages and term rewriting.
\newblock In B.~Konev and F.~Wolter (eds.), \emph{FroCoS}, volume 4720 of
  \emph{Lecture Notes in Computer Science}, 252--266. Springer.

\bibitem[{Geller et~al.(1975)Geller, III, Szymanski, and
  Ullman}]{DBLP:conf/focs/GellerHSU75}
Geller, M.M., III, H.B.H., Szymanski, T.G., and Ullman, J.D. (1975).
\newblock Economy of descriptions by parsers, dpda's, and pda's.
\newblock In \emph{FOCS}, 122--127. IEEE Computer Society.

\bibitem[{Ginsburg and Greibach(1966)}]{DBLP:journals/iandc/GinsburgG66b}
Ginsburg, S. and Greibach, S.A. (1966).
\newblock Deterministic context free languages.
\newblock \emph{Information and Control}, 9(6), 620--648.

\bibitem[{Giua and DiCesare(1994)}]{GiuaCesare1994}
Giua, A. and DiCesare, F. (1994).
\newblock Blocking and controllability of petri nets in supervisory control.
\newblock \emph{IEEE Transactions on Automatic Control}, 39(4), 818--823.
\newblock \doi{10.1109/9.286260}.

\bibitem[{Giua and DiCesare(1995)}]{GiuaCesare1995}
Giua, A. and DiCesare, F. (1995).
\newblock Decidability and closure properties of weak petri net languages in
  supervisory control.
\newblock \emph{IEEE Transactions on Automatic Control}, 40(5), 906--910.
\newblock \doi{10.1109/9.384227}.

\bibitem[{Griffin(2006)}]{Griffin2006}
Griffin, C. (2006).
\newblock A note on deciding controllability in pushdown systems.
\newblock \emph{IEEE Transactions on Automatic Control}, 51(2), 334 -- 337.

\bibitem[{Hopcroft and Ullman(1979)}]{HopcroftUllman}
Hopcroft, J.E. and Ullman, J.D. (1979).
\newblock \emph{Introduction to Automata Theory, languages and computation}.
\newblock Addison-Wesley Publishing company.

\bibitem[{Knuth(1965)}]{DBLP:journals/iandc/Knuth65}
Knuth, D.E. (1965).
\newblock On the translation of languages from left to rigth.
\newblock \emph{Information and Control}, 8(6), 607--639.

\bibitem[{libFAUDES(2006-2013)}]{libFAUDES}
libFAUDES (2006-2013).
\newblock Software library for discrete event systems.
\newblock \urlprefix\url{http://www.rt.eei.uni-erlangen.de/FGdes/faudes}.

\bibitem[{Paulson et~al.(2011)Paulson, Nipkow, and Wenzel}]{IsabelleHOL2011}
Paulson, L., Nipkow, T., and Wenzel, M. (2011).
\newblock Isabelle/{HOL}.
\newblock \urlprefix\url{http://isabelle.in.tum.de}.

\bibitem[{Schmuck et~al.(2014)Schmuck, Schneider, Raisch, and
  Nestmann}]{SchmuckSchneider2014}
Schmuck, A.-K., Schneider, S., Raisch, J., and Nestmann, U. (2014).
\newblock Extending supervisory controller synthesis to deterministic pushdown
  automata---enforcing controllability least restrictively.
\newblock \emph{WODES'14}.

\bibitem[{Schneider and Schmuck(2013)}]{SchneiderSchmuck_TechRep_2013}
Schneider, S. and Schmuck, A.-K. (2013).
\newblock Supervisory controller synthesis for deterministic pushdown automata
  specifications.
\newblock Technical report, Technical University of Berlin, \urlprefix\url{http://www.tu-berlin.de/?25631}.

\bibitem[{Schneider et~al.(2014)Schneider, Schmuck, Raisch, and
  Nestmann}]{SchneiderSchmuck2014}
Schneider, S., Schmuck, A.-K., Raisch, J., and Nestmann, U. (2014).
\newblock Reducing an operational supervisory control problem by decomposition
  for deterministic pushdown automata.
\newblock \emph{WODES'14}.

\bibitem[{Sippu and Soisalon-Soininen(1990)}]{sippu-2}
Sippu, S. and Soisalon-Soininen, E. (1990).
\newblock \emph{Parsing Theory}, volume II: {LR}() and {LL}() Parsing of
  \emph{EATCS Monographs on Theoretical Computer Science}.
\newblock Springer-Verlag.

\end{thebibliography}
 
\end{document}
