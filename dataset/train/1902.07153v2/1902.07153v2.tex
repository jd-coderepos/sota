

\documentclass{article}
\usepackage[inline]{enumitem}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{subfigure}
\usepackage{booktabs} \usepackage{extarrows}

\usepackage{amsmath}   
\usepackage{amssymb}
\usepackage{wasysym}
\usepackage{multirow}
\usepackage[dvipsnames]{xcolor}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{tikz}
\usepackage{enumerate}
\usetikzlibrary{calc}
\usetikzlibrary{arrows.meta}
\usepackage{footmisc}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}





\newcommand{\amauri}[1]{}
\newcommand{\felix}[1]{}
\newcommand{\kilian}[1]{}
\newcommand{\chris}[1]{}
\newcommand{\tao}[1]{}
\newcommand{\tianyi}[1]{}


\newcommand{\Method}{Simple Graph Convolution}
\newcommand{\method}{SGC}

\definecolor{color_sn}{HTML}{79a6f6}
\definecolor{color_cheby}{HTML}{a8c0f3}
\definecolor{color_gcn}{HTML}{c8daf4}
\definecolor{color_sgr}{HTML}{e1ebf7}
\definecolor{color_perceptron}{HTML}{ffd6d6}
\definecolor{color_mlp}{HTML}{ffbfbf}
\definecolor{color_filter}{HTML}{fff9db}
\definecolor{color_cnn}{HTML}{fff3ba}

\definecolor{myred}{HTML}{e53935}
\definecolor{myblue}{HTML}{0277bd}

\definecolor{modelblue}{HTML}{1034A6}







%
 

\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\relu}{\mathrm{ReLU}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \graphicspath{{figures/}}



\usepackage[accepted]{icml2019}

\icmltitlerunning{Simplifying Graph Convolutional Networks}



\begin{document}

\twocolumn[
\icmltitle{Simplifying Graph Convolutional Networks}





\icmlsetsymbol{equal}{*}


\begin{icmlauthorlist}
\icmlauthor{Felix Wu}{equal,cornell}
\icmlauthor{Tianyi Zhang}{equal,cornell}
\icmlauthor{Amauri Holanda de Souza Jr.}{equal,cornell,ifce}
\icmlauthor{Christopher Fifty}{cornell}
\icmlauthor{Tao Yu}{cornell}
\icmlauthor{Kilian Q. Weinberger}{cornell}
\end{icmlauthorlist}

\icmlaffiliation{cornell}{Cornell University}
\icmlaffiliation{ifce}{Federal Institute of Ceara (Brazil)}

\icmlcorrespondingauthor{Felix Wu}{fw245@cornell.edu}
\icmlcorrespondingauthor{Tianyi Zhang}{tz58@cornell.edu}


\icmlkeywords{Machine Learning, ICML}
\vskip 0.3in
]





\printAffiliationsAndNotice{\icmlEqualContribution} 

\begin{abstract}
Graph Convolutional Networks (GCNs) and their variants have experienced significant attention and have become the de facto methods for learning graph representations. 
GCNs derive inspiration primarily from recent deep learning approaches, and as a result, may inherit unnecessary complexity and redundant computation. 
In this paper, we reduce this excess complexity through successively removing nonlinearities and collapsing weight matrices between consecutive layers. 
We theoretically analyze the resulting linear model and show that it corresponds to a fixed low-pass filter followed by a linear classifier. 
Notably, our experimental evaluation demonstrates that these simplifications do not negatively impact accuracy in many downstream applications.
Moreover, the resulting model scales to larger datasets, is naturally interpretable, and yields up to two orders of magnitude speedup over FastGCN. 


 \end{abstract}


\section{Introduction}
Graph Convolutional Networks (GCNs) \cite{gcn} are an efficient variant of Convolutional Neural Networks (CNNs) on graphs. 
GCNs stack layers of learned first-order spectral filters followed by a nonlinear activation function to learn graph representations.
Recently, GCNs and subsequent variants have achieved state-of-the-art results in various application areas, including but not limited to citation networks \cite{gcn}, social networks \cite{FastGCN}, applied chemistry \cite{liao2018lanczosnet}, natural language processing \cite{textGCN, han2012geolocation, relation-extraction}, and computer vision \cite{wang2018zero, ADGPM}.  

Historically, the development of machine learning algorithms has followed a clear trend from initial simplicity to need-driven complexity. For instance, limitations of the linear Perceptron \cite{rosenblatt1958perceptron} motivated the development of the more complex but also more expressive neural network (or multi-layer Perceptrons, MLPs)~\cite{rosenblatt1961principles}. Similarly, simple pre-defined linear image filters~\cite{sobel19683x3,harris1988combined} eventually gave rise to nonlinear CNNs with learned convolutional kernels ~\cite{waibel1989phoneme,lecun1989backpropagation}. 
As additional algorithmic complexity tends to complicate theoretical analysis and obfuscates understanding, it is typically only introduced  for applications where simpler methods are insufficient.  Arguably, most classifiers in real world applications are still linear (typically logistic regression), which are straight-forward to optimize and easy to interpret. 



\begin{figure*}[h!]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/gcn5.pdf}
    \caption{Schematic layout of a GCN v.s. a SGC. \textit{Top row:} The GCN  transforms the feature vectors repeatedly throughout  layers and then applies a linear classifier on the final representation. \textit{Bottom row:}  the \method{} reduces the entire procedure to a simple feature propagation step followed by standard logistic regression. }
    \label{fig:method}
\end{figure*}

However, possibly because GCNs were proposed after the recent ``renaissance" of neural networks, they tend to be a rare exception to this trend. GCNs are built upon multi-layer neural networks, and were never an extension of a simpler (insufficient) linear counterpart. 

In this paper, we observe that GCNs inherit considerable  complexity from their deep learning lineage, which can be burdensome and unnecessary for less demanding applications. Motivated by the glaring historic omission of a simpler predecessor, we aim to derive the simplest linear model that ``could have'' preceded the GCN, had a more ``traditional'' path been taken. We reduce the excess complexity of GCNs by repeatedly removing the nonlinearities between GCN layers and collapsing the resulting function into a single linear transformation. We empirically show that the final linear model exhibits comparable or even superior performance to GCNs on a variety of tasks while being computationally more efficient and fitting significantly fewer parameters. We refer to this simplified linear model as \Method{} (\method{}). 

In contrast to its nonlinear counterparts, the  \method{} is intuitively interpretable and 
we provide a theoretical analysis from the graph convolution perspective. 
Notably, feature extraction in \method{} corresponds to a single fixed filter applied to each feature dimension. 
\citet{gcn} empirically observe that the ``renormalization trick", i.e. adding self-loops to the graph, improves accuracy, and we demonstrate that this method effectively shrinks the graph spectral domain, resulting in a low-pass-type filter when applied to \method{}. 
Crucially, this filtering operation gives rise to locally smooth features across the graph~\cite{Bruna13}.

Through an empirical assessment on node classification benchmark datasets for citation and social networks, we show that the \method{} achieves comparable performance to GCN and other state-of-the-art graph neural networks. However, it is significantly faster, and even outperforms  FastGCN~\citep{FastGCN} by  up to two orders of magnitude on the largest dataset (Reddit) in our evaluation. 
Finally, we demonstrate that \method{} extrapolates its effectiveness to a wide-range of downstream tasks. In particular, \method{} rivals, if not surpasses, GCN-based approaches on text classification, user geolocation, relation extraction, and zero-shot image classification tasks. 
The code is available on Github\footnote{\url{https://github.com/Tiiiger/SGC}}.

 
\section{\Method{}}
We follow \citet{gcn} to introduce GCNs (and subsequently \method{}) in the context of node classification. Here, GCNs take a graph with some labeled nodes as input and generate label predictions for all graph nodes. Let us formally define such a graph as , where  represents the vertex set consisting of nodes , and 
 is a symmetric (typically sparse) adjacency matrix
where  denotes the edge weight between nodes  and . A missing edge is represented through .
 We define the degree matrix  as a diagonal matrix where each entry on the diagonal is equal to the row-sum of the adjacency matrix . 


Each node  in the graph has a corresponding -dimensional feature vector . The entire feature matrix  stacks  feature vectors on top of one another, . 
Each node belongs to one out of  classes and can be labeled with a -dimensional one-hot vector .
We only know the labels of a subset of the nodes and want to predict the unknown labels.

\subsection{Graph Convolutional Networks}
Similar to CNNs or MLPs, GCNs  learn a new feature representation for the feature  of each node over multiple layers, which is subsequently used as input into a linear classifier.  For the -th graph convolution layer, we denote the input node representations of all nodes by the matrix   and the output node representations . Naturally, the initial node representations are just the original input features: 

which serve as input to the first GCN layer. 

A -layer GCN is identical to applying a -layer MLP to the feature vector  of each node in the graph, except that the hidden representation of each node is averaged with its neighbors at the beginning of each layer. In each graph convolution layer, node representations are updated in three stages: feature propagation, linear transformation, and a pointwise nonlinear activation (see \autoref{fig:method}). For the sake of clarity, we describe each step in detail. 


\paragraph{Feature propagation} is what distinguishes a GCN from an MLP. 
At the beginning of each layer the features  of each node  are averaged with  the feature vectors  in its local neighborhood, 

More compactly, we can express this update over the entire graph as a simple matrix operation.  Let  denote the ``normalized'' adjacency matrix with added self-loops, 

where  and  is the degree matrix of . The simultaneous update in~\autoref{eq:update} for all nodes becomes a simple sparse matrix multiplication

Intuitively, this step smoothes the hidden representations locally along the edges of the graph and ultimately encourages similar predictions among locally connected nodes.


\paragraph{Feature transformation and nonlinear transition.} 
After the local smoothing, a GCN layer is identical to a standard MLP.  Each layer is associated with a learned weight matrix , and the smoothed hidden feature representations are transformed linearly. 
Finally, a nonlinear activation function such as  is applied pointwise before outputting feature representation . In summary, the representation updating rule of the -th layer is: 

The pointwise nonlinear transformation of the -th layer is followed by the feature propagation of the -th layer.
\paragraph{Classifier.} For node classification, and similar to a standard MLP, the last layer of a GCN predicts the labels using a \textit{softmax} classifier. Denote the class predictions for  nodes as  where 
 denotes the probability of node  belongs to class .
The class prediction  of a -layer GCN can be written as:

where  acts as a normalizer across all classes. 

\subsection{Simple Graph Convolution}
In a traditional MLP, deeper layers increase the expressivity because it allows the creation of feature hierarchies, e.g. features in the second layer build on top of the features of the first layer. In GCNs, the layers have a second important function: in each layer the hidden representations are averaged among neighbors that are one hop away. This implies that after  layers a node obtains feature information from all nodes that are hops away in the graph. This effect is similar to convolutional neural networks, where depth increases the receptive field of internal features~\cite{hariharan2015hypercolumns}.  Although convolutional networks can benefit substantially from increased depth~\cite{huang2016deep}, typically MLPs obtain little benefit beyond 3 or 4 layers. 

\paragraph{Linearization.}
We hypothesize that the nonlinearity between GCN layers is not critical - but that the majority of the benefit arises from the local averaging. We therefore remove the nonlinear transition functions between each layer and only keep the final softmax (in order to obtain probabilistic outputs). 
The resulting model is linear, but still has the same increased ``receptive field'' of a -layer GCN,

To simplify notation we can collapse the repeated multiplication with the normalized adjacency matrix  into a single matrix by raising  to the -th power, . Further, we can reparameterize our weights into a single matrix  .  The resulting classifier becomes

which we refer to as \Method{} (\method{}). 

\paragraph{Logistic regression.} \autoref{eq:SGC} gives rise to a  natural and intuitive interpretation of \method{}: by distinguishing between feature extraction and classifier, \method{} consists of a fixed (i.e., parameter-free) feature extraction/smoothing component  followed by a linear logistic regression classifier . Since the computation of  requires no weight it is essentially equivalent to a feature pre-processing step and the entire training of the model reduces to straight-forward multi-class logistic regression on the pre-processed features .


\paragraph{Optimization details.} The training of logistic regression is a well studied convex optimization problem and can be performed with any efficient second order method or stochastic gradient descent~\cite{bottou2010large}. Provided the graph connectivity pattern  is sufficiently sparse, SGD naturally scales to very large graph sizes and the training of \method{} is  drastically faster than that of GCNs.   

 
\section{Spectral Analysis}
\label{sec:analysis}
We now study \method{} from a graph convolution perspective. We demonstrate that \method{} corresponds to a fixed filter on the graph spectral domain. 
In addition, we show that adding self-loops to the original graph, i.e. the renormalization trick \citep{gcn}, effectively shrinks the underlying graph spectrum.
On this scaled domain, \method{} acts as a low-pass filter that produces smooth features over the graph. As a result, nearby nodes tend to share similar representations and consequently predictions.


\subsection{Preliminaries on Graph Convolutions}
Analogous to the Euclidean domain, graph Fourier analysis relies on the spectral decomposition of graph Laplacians. The graph Laplacian  (as well as its normalized version ) is a symmetric positive semidefinite matrix with eigendecomposition , where  comprises orthonormal eigenvectors and  is a diagonal matrix of eigenvalues. The eigendecomposition of the Laplacian allows us to define the Fourier transform equivalent on the graph domain, where eigenvectors denote Fourier modes and eigenvalues denote frequencies of the graph. In this regard, let  be a signal defined on the vertices of the graph. We define the graph Fourier transform of  as , with inverse operation given by .
Thus, the graph convolution operation between signal  and filter  is

where  denotes a diagonal matrix in which the diagonal corresponds to spectral filter coefficients. 

Graph convolutions can be approximated by -th order polynomials of Laplacians

where  denotes coefficients. In this case, filter coefficients correspond to polynomials of the Laplacian eigenvalues, i.e.,  or equivalently . 


Graph Convolutional Networks (GCNs) \cite{gcn} employ an affine approximation () of \autoref{eq:polynomial approximation} with coefficients  and  from which we attain the basic GCN convolution operation


In their final design, \citet{gcn} replace the matrix  by a normalized version  where  and consequently , dubbed the \textit{renormalization trick}. Finally, by generalizing the convolution to work with multiple filters in a -channel input and layering the model with nonlinear activation functions between each layer, we have the GCN propagation rule as defined in \autoref{eq:gcn_propagation}.

\begin{figure*}[tb] 
\centering
\includegraphics[width=.8\linewidth]{figures/s_filters_new2.pdf}
\caption{Feature ({\color{myred}red}) and filters ({\color{myblue}blue}) spectral coefficients for different propagation matrices on Cora dataset (rd feature).}
\label{fig:s_filters}
\end{figure*}

\subsection{\method{} and Low-Pass Filtering}
The initial first-order Chebyshev filter derived in GCNs corresponds to the propagation matrix  (see \autoref{eq:first-order-cheby}). Since the normalized Laplacian is , then . Therefore, feature propagation with  implies filter coefficients , where  denotes the eigenvalues of . \autoref{fig:s_filters} illustrates the filtering operation related to  for a varying number of propagation steps . As one may observe, high powers of  lead to exploding filter coefficients and undesirably over-amplify signals at frequencies .


To tackle potential numerical issues associated with the first-order Chebyshev filter, \citet{gcn} propose the \textit{renormalization trick}. Basically, it consists of replacing  by the normalized adjacency matrix after adding self-loops for all nodes. We call the resulting propagation matrix the augmented normalized adjacency matrix , where  and . Correspondingly, we define the augmented normalized Laplacian . Thus, we can describe the spectral filters associated with  as a polynomial of the eigenvalues of the underlying Laplacian, i.e.,  , where  are eigenvalues of .


We now analyze the spectrum of  and show that adding self-loops to graphs shrinks the spectrum (eigenvalues) of the corresponding normalized Laplacian.

\begin{theorem}\label{thm:Lapla_eig_shrink} Let  be the adjacency matrix of an undirected, weighted, simple graph  without isolated nodes and with corresponding degree matrix . Let , such that , be the augmented adjacency matrix with corresponding degree matrix . Also, let  and  denote the smallest and largest eigenvalues of ; similarly, let  and  be the smallest and largest eigenvalues of . We have that

\end{theorem}
\autoref{thm:Lapla_eig_shrink} shows that the largest eigenvalue of the normalized graph Laplacian becomes smaller after adding self-loops  (see supplementary materials for the proof).

\autoref{fig:s_filters} depicts the filtering operations associated with the normalized adjacency  and its augmented variant  on the Cora dataset~\citep{sen2008collective}. Feature propagation with  corresponds to filters  in the spectral range ; therefore odd powers of  yield negative filter coefficients at frequencies . By adding self-loops (), the largest eigenvalue shrinks from  to approximately  and then eliminates the effect of negative coefficients. Moreover, this scaled spectrum allows the filter defined by taking powers  of  to act as a low-pass-type filters. In supplementary material, we empirically evaluate different choices for the propagation matrix. 

\section{Related Works}


\begin{figure*}[tb!] 
\centering
\includegraphics[width=0.8\textwidth]{acc_run_time_v2.pdf}
\caption{Performance over training time on Pubmed and Reddit. \method{} is the fastest while achieving competitive performance. 
We are not able to benchmark the training time of GaAN and DGI on Reddit because the implementations are not released. 
}
\label{fig:run_time}
\end{figure*}
\subsection{Graph Neural Networks}
\citet{Bruna13} first propose a spectral graph-based extension of convolutional networks to graphs. 
In a follow-up work, ChebyNets \cite{Defferrard16} define graph convolutions using Chebyshev polynomials to remove the computationally expensive Laplacian eigendecomposition. GCNs \cite{gcn} further simplify graph convolutions by stacking layers of first-order Chebyshev polynomial filters with a redefined propagation matrix . 
\citet{FastGCN} propose an efficient variant of GCN based on importance sampling, and \citet{Hamilton17} propose a framework based on sampling and aggregation. 
\citet{dcnn}, \citet{n-gcn}, and \citet{liao2018lanczosnet} exploit multi-scale information by raising  to higher order.
\citet{xu2018how} study the expressiveness of graph neural networks in terms of their ability to distinguish any two graphs and introduce Graph Isomorphism Network, which is proved to be as powerful as the Weisfeiler-Lehman test for graph isomorphism. 
\citet{Klicpera19} separate the non-linear transformation from propagation by using a neural network followed by a personalized random walk.
There are many other graph neural models~\cite{Monet, EP17, Li18}; we refer to \citet{gnn_review, battaglia2018relational, wu2019comprehensive} for a more comprehensive review. 



Previous publications have pointed out that simpler, sometimes linear models can be effective for node/graph classification tasks. \citet{agnn} empirically show that a linear version of GCN can perform competitively and propose an attention-based GCN variant. \citet{cai2018simple} propose an effective linear baseline for graph classification using node degree statistics. \citet{Buchnik18} show that models which use linear feature/label propagation steps can benefit from self-training strategies. 
\citet{Li2019LabelES} propose a generalized version of label propagation and provide a similar spectral analysis of the renormalization trick.





Graph Attentional Models learn to assign different edge weights at each layer based on node features and have achieved state-of-the-art results on several graph learning tasks \citep{gat, agnn, zhang2018gaan, ADGPM}.
However, the attention mechanism usually adds significant overhead to computation and memory usage. 
We refer the readers to \citet{attention-survey} for further comparison.

\subsection{Other Works on Graphs} 
Graph methodologies can roughly be categorized into two approaches: graph embedding methods and graph laplacian regularization methods. 
Graph embedding methods \citep{Weston2008, Perozzi14, Yang16, infomax} represent nodes as high-dimensional feature vectors. 
Among them, DeepWalk~\citep{Perozzi14} and Deep Graph Infomax (DGI)~\citep{infomax} use unsupervised strategies to learn graph embeddings.
DeepWalk relies on truncated random walk and uses a skip-gram model to generate embeddings, whereas DGI trains a graph convolutional encoder through maximizing mutual information. 
Graph Laplacian regularization \citep{Zhu03, Zhou04,Belkin04b,Belkin2006} introduce a regularization term based on graph structure which forces nodes to have similar labels to their neighbors.
Label Propagation~\citep{Zhu03} makes predictions by spreading label information from labeled nodes to their neighbors until convergence.  
\section{Experiments and Discussion}
\label{sec:experiment}

We first evaluate \method{} on citation networks and social networks and then extend our empirical analysis to a wide range of downstream tasks.
\subsection{Citation Networks \& Social Networks} \label{sec:citation-networks}
We evaluate the semi-supervised node classification performance of \method{} on the Cora, Citeseer, and Pubmed citation network datasets (\autoref{table:citation-base}) \cite{sen2008collective}. 
We supplement our citation network analysis by using \method{} to inductively predict community structure on Reddit (\autoref{table:reddit}), which consists of a much larger graph. Dataset statistics are summarized in \autoref{table:citation-dataset}.

\paragraph{Datasets and experimental setup.}
\begin{table}[tb!]
\small
\centering
\caption{Dataset statistics of the citation networks and Reddit.}
\label{table:citation-dataset}
\begin{tabular}{l|cccccc}
\toprule
Dataset & \# Nodes & \# Edges & Train/Dev/Test Nodes \\
\midrule
Cora &  &  & \\
Citeseer &  &  & \\
Pubmed &  &  & \\
\midrule
Reddit & K & M & K/K/K\\
\bottomrule
\end{tabular}
\end{table}
\begin{table}[htb!]
\centering
        \small
        \caption{Test accuracy (\%) averaged over 10 runs on citation networks. We remove the outliers (accuracy ) when calculating their statistics due to high variance.}
        \label{table:citation-base}
        \begin{tabular}{l|c|c|c}
        \toprule
         & Cora & Citeseer & Pubmed \\ 
        \midrule
        \multicolumn{4}{l}{\textbf{Numbers from literature:}} \\
GCN  &  &  &   \\
        GAT  &  &  &  \\
        GLN  &  &  &  \\
        AGNN &  &  &  \\
        LNet &  &   &  \\
        AdaLNet &  &   &  \\
        DeepWalk &  &  & \\
        DGI &  &  &  \\
         \midrule
        \multicolumn{4}{l}{\textbf{Our experiments:}} \\
GCN &  &  &  \\
GAT &  &  &   \\
        FastGCN &  &  &  \\
        GIN &  &   &  \\
        LNet &  &   &  \\
        AdaLNet &  &  &  \\
        DGI &  &  & \\
        {\color{modelblue} \method{}} &  &  &  \\
         \bottomrule
        \end{tabular}
\end{table}
\begin{table}[htb!]
        \centering
        \small
        \caption{Test Micro F1 Score (\%) averaged over 10 runs on Reddit. Performances of models are cited from their original papers. \textbf{OOM:} Out of memory.}
        \label{table:reddit}
        \begin{tabular}{l|l|l}
        \toprule
        Setting & Model & Test F1 \\
         \midrule
        \multirow{5}{*}{\shortstack[c]{Supervised}}
        & GaAN  &  \\
        & SAGE-mean & \\
        & SAGE-LSTM & \\
        & SAGE-GCN & \\
        & FastGCN & \\
        & GCN & \textbf{OOM} \\
        \midrule
        \multirow{3}{*}{\shortstack[c]{Unsupervised}} 
        & SAGE-mean &  \\
        & SAGE-LSTM & \\
        & SAGE-GCN  & \\
        & DGI & \\
        \midrule
        \multirow{2}{*}{\shortstack[c]{No Learning}} 
        & Random-Init DGI &  \\
        & {\color{modelblue} \method{}} &  \\
        \bottomrule
        \end{tabular}
\end{table}
On the citation networks, we train \method{} for 100 epochs using Adam~\citep{adam} with learning rate 0.2. In addition, we use weight decay and tune this hyperparameter on each dataset using hyperopt~\citep{hyperopt} for 60 iterations on the public split validation set. 
Experiments on citation networks are conducted \emph{transductively}. 
On the Reddit dataset, we train \method{} with L-BFGS \cite{lbfgs} using no regularization, and remarkably, training converges in 2 steps. 
We evaluate \method{} \emph{inductively} by following \citet{FastGCN}: we train \method{} on a subgraph comprising only training nodes and test with the original graph.
On all datasets, we tune the number of epochs based on both convergence behavior and validation accuracy.


\paragraph{Baselines.} For citation networks, we compare against GCN~\citep{gcn}
GAT~\citep{gat}
FastGCN~\citep{FastGCN}
LNet, AdaLNet~\citep{liao2018lanczosnet} 
and DGI~\citep{infomax} using the publicly released implementations.
Since GIN is not initially evaluated on citation networks, we implement GIN following ~\citet{xu2018how} and use hyperopt to tune weight decay and learning rate for 60 iterations. 
Moreover, we tune the hidden dimension by hand.

For Reddit, we compare \method{} to the reported performance of GaAN~\cite{zhang2018gaan}, supervised and unsupervised variants of GraphSAGE~\cite{Hamilton17}, FastGCN, and DGI. \autoref{table:reddit} also highlights the setting of the feature extraction step for each method. 
We note that \method{} involves no learning because the feature extraction step, , has no parameter. Both unsupervised and no-learning approaches train logistic regression models with labels afterward.


\paragraph{Performance.}
Based on results in \autoref{table:citation-base} and \autoref{table:reddit}, we conclude that \method{} is very competitive. 
Table~\ref{table:citation-base} shows the performance of \method{} can match the performance of GCN and state-of-the-art graph networks on citation networks.
In particular on Citeseer, \method{} is about 1\% better than GCN, and we reason this performance boost is caused by \method{} having fewer parameters and therefore suffering less from overfitting.
Remarkably, GIN performs slight worse because of overfitting. Also, both LNet and AdaLNet are unstable on citation networks.
On Reddit, \autoref{table:reddit} shows that \method{} outperforms the previous sampling-based GCN variants, SAGE-GCN and FastGCN by more than 1\%. 

Notably, \citet{infomax} report that the performance of a randomly initialized DGI encoder nearly matches that of a trained encoder; however, both models underperform \method{} on Reddit.   
This result may suggest that the extra weights and nonlinearities in the DGI encoder are superfluous, if not outright detrimental. 

\paragraph{Efficiency.} 
In \autoref{fig:run_time}, we plot the performance of the state-of-the-arts graph networks over their training time relative to that of \method{} on the Pubmed and Reddit datasets. In particular, we precompute  and the training time of \method{} takes into account this precomputation time.
We measure the training time on a NVIDIA GTX 1080 Ti GPU and present the benchmark details in supplementary materials.

On large graphs (e.g. Reddit), GCN cannot be trained due to excessive memory requirements. 
Previous approaches tackle this limitation by either sampling to reduce neighborhood size~\cite{FastGCN, Hamilton17} or limiting their model sizes~\cite{infomax}.
By applying a fixed filter and precomputing , \method{} minimizes memory usage and only learns a single weight matrix during training. Since  is typically sparse and  is usually small, we can exploit fast sparse-dense matrix multiplication to compute .
\autoref{fig:run_time} shows that \method{} can be trained up to two orders of magnitude faster than fast sampling-based methods while having little or no drop in performance.

\subsection{Downstream Tasks}
We extend our empirical evaluation to 5 downstream applications --- text classification, semi-supervised user geolocation, relation extraction, zero-shot image classification, and graph classification --- to study the applicability of \method{}. 
We describe experimental setup in supplementary materials.

\begin{table}[tb!]
\centering
\small
\caption{Test Accuracy (\%) on text classification datasets. The numbers are averaged over 10 runs.}
\begin{tabular}{l|l|cc}
\toprule
Dataset & Model & Test Acc.  & Time (seconds)  \\
\midrule
\multirow{2}{*}{20NG} & GCN &  &  \\ & {\color{modelblue} \method{}} &  &  \\
\midrule
\multirow{2}{*}{R8} & GCN &  &  \\ & {\color{modelblue} \method{}} &  &  \\
\midrule
\multirow{2}{*}{R52} & GCN &  &  \\ & {\color{modelblue} \method{}} &  &  \\
\midrule
\multirow{2}{*}{Ohsumed} & GCN &  &  \\ & {\color{modelblue} \method{}} &  &  \\
\midrule
\multirow{2}{*}{MR} & GCN &  &  \\ & {\color{modelblue} \method{}} &  &  \\
\bottomrule
\end{tabular}
\label{table:text-base-time}
\end{table}


\paragraph{Text classification} assigns labels to documents. 
\citet{textGCN} use a 2-layer GCN to achieve state-of-the-art results by creating a corpus-level graph which treats both documents and words as nodes in a graph. 
Word-word edge weights are pointwise mutual information (PMI) and word-document edge weights are normalized TF-IDF scores. 
\autoref{table:text-base-time} shows that an SGC () rivals their model on 5 benchmark datasets, while being up to  faster.
\begin{table}[t!]
\centering
\small
\caption{Test accuracy (\%) within 161 miles on semi-supervised user geolocation. The numbers are averaged over 5 runs.}
\resizebox{\linewidth}{!}{\begin{tabular}{l|l|rrrr}
\toprule
Dataset & Model & Acc.@161 & Time  \\
\midrule
\multirow{2}{*}{GEOTEXT} & GCN+H &  & s\\
& {\color{modelblue} \method{}} &  & s\\
\midrule
\multirow{2}{*}{TWITTER-US} & GCN+H &  & h m \\
& {\color{modelblue} \method{}} &  & h m  \\
\midrule
\multirow{2}{*}{TWITTER-WORLD} & GCN+H &  & d h m \\
& {\color{modelblue} \method{}} &  & h m \\
\bottomrule
\end{tabular}
}
\label{table:geo_result}
\end{table}

\paragraph{Semi-supervised user geolocation} locates the ``home'' position of users on social media given users' posts, connections among users, and a small number of labelled users. \citet{Rahimi18} apply GCNs with highway connections on this task and achieve close to state-of-the-art results.
\autoref{table:geo_result} shows that \method{} outperforms GCN with highway connections on GEOTEXT \citep{eisenstein2010latent}, TWITTER-US \citep{roller2012supervised}, and TWITTER-WORLD \citep{han2012geolocation} under \citet{Rahimi18}'s framework, while saving  hours on TWITTER-WORLD.

\begin{table}[t!]
\centering
\caption{Test Accuracy (\%) on Relation Extraction. The numbers are averaged over 10 runs.}
\label{table:relation-base}
\begin{tabular}{l|c}
\toprule
TACRED & Test Accuracy  \\
\midrule
C-GCN \citep{relation-extraction} &  \\
C-GCN & \\
{\color{modelblue} C-\method{}} & \\
 \bottomrule
\end{tabular}
\end{table}

\paragraph{Relation extraction} involves predicting the relation between subject and object in a sentence.
\citet{relation-extraction} propose C-GCN which uses an LSTM~\citep{LSTM} followed by a GCN and an MLP.
We replace GCN with SGC () and call the resulting model C-SGC. \autoref{table:relation-base} shows that C-SGC sets new state-of-the-art on TACRED~\citep{TACRED}.

\begin{table}[t!]
\centering
\small
\caption{Top-1 accuracy (\%) averaged over 10 runs in the 2-hop and 3-hop setting of the zero-shot image task on ImageNet. ADGPM~\citep{ADGPM} and EXEM 1-nns~\citep{EXEM} use more powerful visual features.}
\label{table:zero_shot}
\resizebox{\linewidth}{!}{\begin{tabular}{l|l|l|l}
\toprule
Model & \# Param.  & 2-hop Acc.  & 3-hop Acc. \\
 \midrule
\multicolumn{4}{l}{\textbf{Unseen categories only:}} \\
EXEM 1-nns & - &  &  \\ 
ADGPM & - &  &  \\
GCNZ  & - &   &  \\
GCNZ (ours) &  &   &  \\
{\color{modelblue} MLP-\method{}Z (ours)}  &  &   &  \\
\midrule
\multicolumn{4}{l}{\textbf{Unseen categories \& seen categories:}} \\
ADGPM & - &  &  \\
GCNZ  & - &  &  \\
GCNZ (ours) &  &  &  \\
{\color{modelblue} MLP-\method{}Z (ours)} &  &   &  \\
 \bottomrule
\end{tabular}
}
\end{table}

\paragraph{Zero-shot image classification} consists of learning an image classifier without access to any images or labels from the test categories. 
GCNZ~\citep{wang2018zero} uses a GCN to map the category names --- based on their relations in WordNet~\citep{miller1995wordnet} --- to image feature domain, and find the most similar category to a query image feature vector.
\autoref{table:zero_shot} shows that replacing GCN with an MLP followed by \method{} can improve performance while reducing the number of parameters by .
We find that an MLP feature extractor is necessary in order to map the pretrained GloVe vectors to the space of visual features extracted by a ResNet-50.
Again, this downstream application demonstrates that learned graph convolution filters are superfluous; similar to \citet{EXEM}'s observation that GCNs may not be necessary. 


\paragraph{Graph classification} requires models to use graph structure to categorize graphs.
\citet{xu2018how} theoretically show that GCNs are not sufficient to distinguish certain graph structures and show that their GIN is more expressive and achieves state-of-the-art results on various graph classification datasets. We replace the GCN in DCGCN~\citep{zhang2018end} with an \method{} and get  and  on NCI1 and COLLAB datasets~\citep{yanardag2015deep} respectively, which is on par with an GCN counterpart, but far behind GIN. Similarly, on QM8 quantum chemistry dataset~\citep{ramakrishnan2015electronic}, more advanced AdaLNet and LNet~\citep{liao2018lanczosnet} get  MAE on QM8, outperforming \method{}'s  MAE by a large margin.
 
\section{Conclusion}
In order to better understand and explain the mechanisms of GCNs, we explore the simplest possible formulation of a graph convolutional model, \method{}. The algorithm is almost trivial, a graph based pre-processing step  followed by standard multi-class logistic regression. However, the performance of \method{} rivals --- if not surpasses --- the performance of GCNs and state-of-the-art graph neural network models across a wide range of graph learning tasks.
Moreover by precomputing the fixed feature extractor , training time is reduced to a record low.
For example on the Reddit dataset, \method{} can be trained up to two orders of magnitude faster than sampling-based GCN variants. 

In addition to our empirical analysis, we analyze \method{} from a convolution perspective and manifest this method as a low-pass-type filter on the spectral domain. Low-pass-type filters capture low-frequency signals, which corresponds with smoothing features across a graph in this setting. 
Our analysis also provides insight into the empirical boost of the ``renormalization trick" and demonstrates how shrinking the spectral domain leads to a low-pass-type filter which underpins \method{}. 

Ultimately, the strong performance of \method{} sheds light onto GCNs. It is likely that the expressive power of GCNs originates primarily from the repeated graph propagation (which \method{} preserves) rather than the nonlinear feature extraction (which it doesn't.) 

Given its empirical performance, efficiency, and interpretability, we argue that the \method{} should be highly beneficial to the community in at least three ways:
(1) as a first model to try, especially for node classification tasks; 
(2) as a simple baseline for comparison with future graph learning models; 
(3) as a starting point for future research in graph learning --- returning to the historic machine learning practice to develop complex from simple models. 

 

\section*{Acknowledgement}
This research is supported in part by grants from the National
Science Foundation (III-1618134, III-1526012, IIS1149882,
IIS-1724282, and TRIPODS-1740822), the Office
of Naval Research DOD (N00014-17-1-2175), 
Bill and Melinda Gates Foundation, and 
Facebook Research. We are thankful for
generous support by SAP America Inc. 
Amauri Holanda de Souza Jr. thanks CNPq (Brazilian Council for Scientific and Technological Development) for the financial support.
We appreciate the discussion with Xiang Fu, Shengyuan Hu, Shangdi Yu, Wei-Lun Chao and Geoff Pleiss as well as the figure design support from Boyi Li.





\bibliography{references}
\bibliographystyle{icml2019}


\clearpage

\twocolumn[   

\icmltitle{Simplifying Graph Convolutional Networks \\ (Supplementary Material)}

]

\appendix

\section{The spectrum of }

The normalized Laplacian defined on graphs with self-loops, , consists of an instance of generalized graph Laplacians and hold the interpretation as a difference operator, i.e. for any signal  it satisfies 


Here, we prove several properties regarding its spectrum.

\begin{lemma}
(Non-negativity of ) The augmented normalized Laplacian matrix is symmetric positive semi-definite.
\end{lemma}
\begin{proof}

The quadratic form associated with  is



\end{proof}

\begin{lemma}
\label{lem:0_eig}
 is an eigenvalue of both  and .
\end{lemma}
\begin{proof}
First, note that  is an eigenvector of  associated with eigenvalue , i.e., .

Also, we have that . Denote , then


Therefore,  is an eigenvector of  associated with eigenvalue , which is then the smallest eigenvalue from the non-negativity of . Likewise, 0 can be proved to be the smallest eigenvalues of .
\end{proof}

\begin{lemma}
\label{lem:adj_eig}
Let  denote eigenvalues of  and  be the eigenvalues of . Then,

\end{lemma}

\begin{proof}

We have shown that 0 is an eigenvalue of . Since , then  is an eigenvalue of . More specifically, . In addition, by combining the fact that  with , we conclude that .

By choosing  such that  and , we have that  and . Hence, we use the Rayleigh quotient to provide a lower bound to :


One may employ similar steps to prove the second inequality in \autoref{eq:bounds_norm_adj}.

\end{proof}

\begin{proof} [Proof of Theorem 1] 
Note that . Using the results in Lemma \autoref{lem:adj_eig}, we show that the largest eigenvalue  of  is



\end{proof}

\section{Experiment Details}
\label{sec:exp-details}
\paragraph{Node Classification.}
We empirically find that on Reddit dataset for \method{}, it is crucial to normalize the features into zero mean and univariate. 

\paragraph{Training Time Benchmarking.} We hereby describe the experiment setup of Figure 3.
\citet{FastGCN} benchmark the training time of FastGCN on CPU, and as a result, it is difficult to compare numerical values across reports.
Moreover, we found the performance of FastGCN improved with a smaller early stopping window (10 epochs); therefore, we could decrease the model's training time.
We provide the data underpinning Figure 3 in \autoref{table:citation-time} and \autoref{table:reddit-time}.
\begin{table}[htb!]
\centering
        \small
        \caption{Training time (seconds) of graph neural networks on Citation Networks. Numbers are averaged over 10 runs.}
        \label{table:citation-time}
        \begin{tabular}{l|c|c|c}
        \toprule
        Models & Cora & Citeseer & Pubmed \\ 
        \midrule
GCN &  &  &  \\
GAT &  &  &   \\
        FastGCN &  &  &  \\
        GIN &  &   &  \\
        LNet &  &   &  \\
        AdaLNet &  &  &  \\
        DGI &  &  & \\
        {\color{modelblue} \method{}} &  &  &  \\
         \bottomrule
        \end{tabular}
\end{table}
\begin{table}[htb!]
        \centering
        \small
        \caption{Training time (seconds) on Reddit dataset.}
        \label{table:reddit-time}
        \begin{tabular}{l|l}
        \toprule
        Model & Time(s)  \\
         \midrule
        SAGE-mean & \\
        SAGE-LSTM & \\
        SAGE-GCN & \\
        FastGCN & \\
        {\color{modelblue} \method{}} &  \\
        \bottomrule
        \end{tabular}
\end{table}
\begin{figure*}[htb] 
\centering
\includegraphics[width=0.9\textwidth]{figures/propagation.pdf}
\caption{Validation accuracy with \method{} using different propagation matrices.}
\label{fig:propagation-ablation}
\end{figure*}
\paragraph{Text Classification.} 
\citet{textGCN} use one-hot features for the word and document nodes. In training SGC, we normalize the features to be between 0 and 1 \textbf{after propagation} and train with L-BFGS for 3 steps. We tune the only hyperparameter, weight decay, using hyperopt\cite{hyperopt} for 60 iterations. Note that we cannot apply this feature normalization for TextGCN because the propagation cannot be precomputed. 
\paragraph{Semi-supervised User Geolocation.}
We replace the 4-layer, highway-connection GCN with a 3rd degree propagation matrix () SGC and use the same set of hyperparameters as \citet{Rahimi18}. All experiments on the GEOTEXT dataset are conducted on a single Nvidia GTX-1080Ti GPU while the ones on the TWITTER-NA and TWITTER-WORLD datasets are excuded with 10 cores of the Intel(R) Xeon(R) Silver 4114 CPU (2.20GHz). Instead of collapsing all linear transformations, we keep two of them which we find performing slightly better possibly due to . Despite of this subtle variation, the model is still linear.
\paragraph{Relation Extraction.}
We replace the 2-layer GCN with a 2nd degree propagation matrix () SGC and remove the intermediate dropout. We keep other hyperparameters unchanged, including learning rate and regularization. Similar to \citet{relation-extraction}, we report the best validation accuracy with early stopping.
\paragraph{Zero-shot Image Classification.}
We replace the 6-layer GCN (hidden size: 2048, 2048, 1024, 1024, 512, 2048) baseline with an 6-layer MLP (hidden size: 512, 512, 512, 1024, 1024, 2048) followed by a SGC with . Following \cite{wang2018zero}, we only apply dropout to the output of SGC. Due to the slow evaluation of this task, we do not tune the dropout rate or other hyperparameters. Rather, we follow the GCNZ code and use learning rate of 0.001, weight decay of 0.0005, and dropout rate of 0.5. We also train the models with ADAM~\cite{adam} for 300 epochs.

\section{Additional Experiments}
\paragraph{Random Splits for Citation Networks.}
Possibly due to their limited size, the citation networks are known to be unstable. 
Accordingly, we conduct an additional 10 experiments on random splits of the training set while maintaining the same validation and test sets. 
\begin{table}[th!]
\small
\centering
\caption{Test accuracy (\%) on citation networks (random splits). We remove the outliers (accuracy ) when calculating their statistics due to high variance.}
\label{table:citation-random}
\begin{tabular}{l|c|c|c}
\toprule
 & Cora & Citeseer & Pubmed \\ 
\midrule
\multicolumn{4}{l}{\textbf{Ours:}} \\
GCN &   &  & \\
GIN  &  &  &  \\
LNet &  &  &  \\
AdaLNet &  &  &  \\
GAT  &  &   &  \\
{\color{modelblue} \method{}} &  &  & \\
 \bottomrule
\end{tabular}
\end{table}
\paragraph{Propagation choice.}
We conduct an ablation study with different choices of propagation matrix, namely:
\begin{itemize}
\item[] Normalized Adjacency: 
\item[] Random Walk Adjacency 
\item[] Aug. Normalized Adjacency  \item[] Aug. Random Walk  
\item[] First-Order Cheby 
\end{itemize}

We investigate the effect of propagation steps  on validation set accuracy. 
We use hyperopt to tune L2-regularization and leave all other hyperparameters unchanged. \autoref{fig:propagation-ablation} depicts the validation results achieved by varying the degree of different propagation matrices.

We see that augmented propagation matrices (i.e. those with self-loops) attain higher accuracy and more stable performance across various propagation depths. Specifically, the accuracy of  tends to deteriorate as the power  increases, and this results suggests using large filter coefficients on low frequencies degrades \method{} performance on semi-supervised tasks.

Another pattern is that odd powers of  cause a significant performance drop for the normalized adjacency and random walk propagation matrices. This demonstrates how odd powers of the un-augmented propagation matrix use negative filter coefficients on high frequency information. Adding self-loops to the propagation matrix shrinks the spectrum such that the largest eigenvalues decrease from  to  on the citation network datasets. By effectively shrinking the spectrum, the effect of negative filter coefficients on high frequencies is minimized, and as a result, using odd-powers of  does not degrade the performance of augmented propagation matrices. For non-augmented propagation matrices --- where the largest eigenvalue is approximately 2 --- negative coefficients significantly distort the signal, which leads to decreased accuracy. Therefore, adding self-loops constructs a better domain in which fixed filters can operate. 

\begin{table}[h]
    \centering
    \begin{tabular}{c|cc}
    \toprule
    \# Training Samples & \method{} & GCN \\
    \midrule
    1 & 33.16 & 32.94 \\
    5 & 63.74 & 60.68 \\
    10 & 72.04 & 71.46 \\
    20 & 80.30 & 80.16 \\
    40 & 85.56 & 85.38 \\
    80 & 90.08 & 90.44 \\
    \bottomrule
    \end{tabular}
    \caption{Validation Accuracy (\%) when \method{} and GCN are trained with different amounts of data on Cora. The validation accuracy is averaged over 10 random training splits such that each class has the same number of training examples.} 
    \label{tab:data_ablation}
\end{table}

\paragraph{Data amount.}
We also investigated the effect of training dataset size on accuracy. 
As demonstrated in Table~\ref{tab:data_ablation}, \method{} continues to perform similarly to GCN as the training dataset size is reduced, and even outperforms GCN when there are fewer than  training samples. We reason this study demonstrates \method{} has at least the same modeling capacity as GCN.
 



\end{document}
