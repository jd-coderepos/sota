\documentclass[copyright]{eptcs}
\usepackage{times}
\usepackage{proof}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{color}
\usepackage{amsmath}
\usepackage{listings}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}




\newcommand{\fixme}[1]{\textcolor{red}{[FIXME: #1]}\message{FIXME: #1}}

\newcommand{\To}{\Rightarrow}
\newcommand{\next}[0]{\textit{next}}
\newcommand{\nf}[0]{\textit{nf}}
\newcommand{\elt}[0]{\texttt{next}}
\newcommand{\length}[0]{\texttt{length}}
\newcommand{\SN}[0]{\textit{SN}}
\newcommand{\vc}[0]{\texttt{vec}}
\newcommand{\nat}[0]{\texttt{nat}}
\newcommand{\Tvec}[0]{\texttt{T}^\vc}
\newcommand{\nil}[0]{\texttt{nil}}
\newcommand{\cons}[0]{\texttt{cons}}
\newcommand{\refl}[0]{\texttt{refl}}
\newcommand{\join}[0]{\texttt{join}}
\newcommand{\cast}[0]{\texttt{cast}}
\newcommand{\subst}[0]{\texttt{subst}}
\newcommand{\Con}[0]{\textit{Con}}
\newcommand{\pred}[0]{\textit{pred}}
\newcommand{\hole}[0]{\cdot}
\newcommand{\Ctx}[0]{{\cal C}}
\newcommand{\incon}[0]{\textit{incon}}
\newcommand{\leadstov}[0]{\leadsto_v}
\newcommand{\rewritesto}[0]{\longmapsto}
\newcommand{\unfold}[0]{\triangledown}
\newcommand{\ifzero}[0]{\texttt{ifZero}}
\newcommand{\impapp}[0]{\raisebox{-0.2ex}{}}

\newcommand{\interp}[1]{[\negthinspace[#1]\negthinspace]}
\newcommand{\drop}[1]{| #1 |}


\newcommand{\VS}[1]{\textcolor{blue}{[VS: {#1}]}}
\newcommand{\AS}[1]{\textcolor{red}{[AS: {#1}]}}

\begin{document}

\pagestyle{empty}


\newif \ifTR \TRfalse

\title{Equality, Quasi-Implicit Products, and Large Eliminations}
\author{Vilhelm Sj\"oberg
\institute{Computer and Information Science\\
University of Pennsylvania}
\email{vilhelm@cis.upenn.edu}
\and
Aaron Stump 
\institute{Computer Science\\
The University of Iowa}
\email{astump@acm.org}}

\date{}

\def\authorrunning{Sj\"oberg and Stump}
\def\titlerunning{Equality and Implicit Products}

\maketitle
\thispagestyle{empty}

\begin{abstract}
This paper presents a type theory with a form of equality reflection:
provable equalities can be used to coerce the type of a term.
Coercions and other annotations, including implicit arguments, are
dropped during reduction of terms.  We develop the metatheory for an
undecidable version of the system with unannotated terms.  We then
devise a decidable system with annotated terms, justified in terms of
the unannotated system.  Finally, we show how the approach can be
extended to account for large eliminations, using what we call
quasi-implicit products.
\end{abstract}

\section{Introduction}
\label{sec:intro}

The main goal of this paper, as of several recent works, is to
facilitate external reasoning about dependently typed
programs~\cite{mishra-linger+08,barras+08}.  This is hampered if one
must reason about specificational data occurring in terms.
Specificational data are data which have no effect on the result of
the computation, and are present in program text solely for
verification purposes.  In traditional formal methods, specification
data are also sometimes called ghost data.  For example, consider the
familiar example of vectors  indexed by
both the type  of the elements and the length  of the vector.
An example dependently typed program is the 
function (we work here with monomorphic functions, but will elide type
subscripts), operating on vectors holding data of type .  We can
define \textit{append} so that it has the following type, assuming a
standard definition of  on unary natural numbers
:

\noindent We might wish to prove that \textit{append} is associative.
In type theories such as \textsc{Coq}'s Calculus of Inductive
Constructions, we would do this by showing that the following type is
inhabited:

\noindent Notice how the lengths of the vectors are cluttering even
the statement of this theorem.  Tools like \textsc{Coq} allow such
arguments to be elided, when they can be uniquely reconstructed.  So
the theorem to prove can be written in the much more palatable form:

\noindent This is much more readable.  But as others have noted, while
the indices have been elided, they are not truly erased.  This means
that the proof of associativity of \textit{append} must make use of
associativity also of \textit{plus}, in order for the lengths of the
two vectors (on the two sides of the equation) to be equal.  Indeed,
even stating this equation may require some care, since the types of
the two sides are not definitionally equal: one has
 where the other has
.  This is where
techniques like heterogeneous equality come into
play~\cite{mcbride99}.

One solution to this problem is via intersection types, also called in
this setting \emph{implicit products}, as in the Implicit Calculus of
Constructions~\cite{miquel01}.  An implicit product  is the type for functions whose arguments are erased
during conversion (cf.~\cite{mishra-linger+08,barras+08}).  Such a
type can also be viewed as an infinite intersection type, since its
typing rule will assert 
whenever .  This rule formalizes
(approximately) the idea that  is in the type  whenever it is in each instance of that type (i.e., each
type  for ).  Thus, membership in the
-type follows from membership in the instances of the body of
the -type, making the -type an intersection of those
instances.  Note that this is an infinitary intersection, and thus
different from the classical finitary intersection type
of~\cite{CoppoDezani78}.  We note in passing that the current work includes
first-class datatypes, while the other works just cited all rely on
encodings of inductive data as lambda terms.

We seek to take the previous approaches further, and erase not just
arguments to functions typed with implicit products, but all
annotations.  This is not the case in the Implicit Calculus of
Constructions, for example, or its algorithmic development
~\cite{barras+08}, where typing annotations other than
implicit arguments are not erased from terms.  When testing
-equivalence of terms, we will work with unannotated versions
of those terms, where all type- and proof-annotations have been
dropped.  For associativity of \textit{append}, the proof does not
require associativity of \textit{plus}.  From the point of view of
external reasoning, \textit{append} on vectors will be
indistinguishable from \textit{append} on lists (without statically
tracked length).  

\textbf{The  Type Theory.} This paper studies versions of a
type theory we call .  This system is like G\"odel's System T,
with vectors and explicit equality proofs.  We first study an
undecidable version of  with equality reflection, where terms
are completely unannotated (Section~\ref{sec:core}).  We establish
standard meta-theoretic results for this unannotated system
(Section~\ref{sec:metatheory}).  We then devise a decidable annotated
version of the language, which we also call  (the context will
determine whether the annotated or unannotated language is intended).
The soundness of annotated  is justified by erasure to the
unannotated system (Section~\ref{sec:tvec}).  We consider the
associativity of \textit{append} in annotated , as an example
(Section~\ref{sec:eg}).  This approach of studying unannotated versus
annotated versions of the type theory should be contrasted with the
approach taken in NuPRL, based on Martin-L\"of's extensional type
theory~\cite{C86,ml84}.  There, one constructs typing derivations, as
separate artifacts, for unannotated terms.  Here, we unite the typing
derivation and the unannotated term in a single artifact, namely the
annotated term.

\textbf{Large eliminations.} Type-level computation poses challenges
for our approach.  Because coercions by equality proofs are erased
from terms, if we naively extended the system with large eliminations
(types defined by pattern matching on terms) we would be able
to assign types to diverging or stuck terms. We propose a solution
based on what we call \emph{quasi-implicit products}.  These
effectively serve to mark the introduction and elimination of the
intersection type, and prohibit call-by-value reduction within an
introduction.  This saves Normalization and Progress, which would
otherwise fail.  We develop the meta-theory of an extension of the
unannotated system with large eliminations and call-by-value
reduction, including normalization (Section~\ref{sec:tveclarge}).

The basic idea of basing provable equality on the operational
semantics of unannotated terms has been implemented previously in the
\textsc{Guru} dependently programming language, publicly available at
\url{http://www.guru-lang.org}~\cite{guru09}.  The current paper
improves upon the work on \textsc{Guru}, by developing and analyzing a
formal theory embodying that idea (lacking in~\cite{guru09}).

\section{Unannotated }
\label{sec:core}

The definition of unannotated  uses  unannotated terms  (we
sometimes also write ):

\noindent Here,  is for -bound variables and  is for
successor (not the  combinator).   is the recursor over
natural numbers, and  is the recursor over vectors.  We have
constructors  and  for vectors.  The term construct
 is the introduction form for equality proofs.  We will not
need an elimination form, since our system includes a form of equality
reflection.  For readability, we sometimes use meta-variable  for
terms  intended as lengths of vectors.  Types  are defined
by:

\noindent The first -type is as usual, while the second is an
intersection type abstracting a specificational .  This  need
not be -abstracted in the corresponding term, nor supplied as
an argument when that term is applied, similarly to Miquel's implicit
products~\cite{miquel01}. 

The reduction relation is the compatible closure under arbitrary
contexts of the rules in Figure~\ref{fig:red}.
Figure~\ref{fig:typing} gives type assignment rules for , using
a standard definition of typing contexts .  We define
 to mean that if
, then
. We use  to mean that  and  are joinable with respect to our
reduction relation (i.e., there exists  such that
 and ).

Perhaps surprisingly we do not track well-formedness of types, and
indeed the \texttt{join} and \texttt{conv} rules can introduce
untypable terms into types. However, they preserve the invariant
that terms deemed equal are joinable, and that turns out to
be enough to ensure type safety.

Type assignment is not syntax-directed, due to the \texttt{(conv)},
\texttt{(spec-abs)}, and \texttt{(spec-app)} rules, and not obviously
decidable.  This will not pose a problem here as we study the
meta-theoretic properties of the system.  Section~\ref{sec:tvec}
defines a system of annotated terms which is obviously decidable, and
justifies it by translation to unannotated .  We work up to
syntactic identity modulo safe renaming of bound variables, which we
denote .

\begin{figure}

\caption{Reduction semantics for unannotated  terms}
\label{fig:red}
\end{figure}

\begin{figure}

\caption{Type assignment system for unannotated }
\label{fig:typing}
\end{figure}

\section{Metatheory of Unannotated }
\label{sec:metatheory}

 enjoys standard properties: Type Preservation, Progress (for
closed terms), and Strong Normalization.  These are all easily
obtained, the last by dependency-erasing translation to another type
theory (as done originally for LF in~\cite{HHP93}).  Here, we consider
a more semantically informative approach to Strong Normalization.
Omitted proofs may be found in a companion report on the second
author's web page (see \url{http://www.cs.uiowa.edu/~astump/papers/ITRS10-long.pdf}).

\begin{theorem}[Type Preservation]
\label{thm:tppres}
If  and , then .
\end{theorem}

\begin{theorem}[Progress]
\label{thm:progress}
If  and , then either  is a value or  . Here a \emph{value} is a term of the form

\end{theorem}

\subsection{Semantics of equality}

For our Strong Normalization proof, a central issue is providing an
interpretation for equality types in the presence of free variables.
We would like to interpret equations like 
(where the numerals abbreviate terms formed with  and  as usual,
and \textit{plus} has a standard recursive definition), as simply
.  But when the two terms contain
free variables -- e.g., in  -- or when the context is inconsistent, the
semantics should make the equation true, even though its sides are not
joinable.  So our semantics for equality types is joinability under
all \emph{ground instances} of the context .  The notation for
this is .  The definition must be given as part of
the definition of the interpretation of types, because we want to
stipulate that the substitutions  replace each variable  by
a ground term in the interpretation of .  When
 is empty, we will write  as .  We
use a similar convention for other notations subscripted by a context
below.

\subsection{The interpretation of types}

The interpretation of types is given in Figure~\ref{fig:interp}.  In
that figure, we write  and  for meta-level
implication and equivalence, respectively, and give 
lowest precedence among all infix symbols, and  next lowest
precedence.  We stipulate up front (not in the clauses in the figure)
that  requires  (where  is the
set of strongly normalizing terms) and .  The
definition in Figure~\ref{fig:interp} proceeds by well-founded
recursion on the triple , in the natural
lexicographic ordering.  Here,  is the cardinality of
, and if , then we make use of a
(finite) natural number  bounding the number of symbols in the
normal form of .  We need to assume confluence of reduction
elsewhere in this proof, so it does not weaken the result to assume
here that each term has at most one normal form.  While we believe
confluence for this language should be easily established by standard
methods, that proof remains to future work.  The quantity  is
the depth of , defined as follows:

\noindent Note that  for all , , and
.  Also, in the clause for -types, since the right hand
side of the clause conjoins the condition ,  is
defined, and we have .  The figure gives an
inductive definition for when .  We
call such a  a \emph{closable substitution}.

\begin{figure}

\caption{The interpretation  of strongly normalizing terms with }
\label{fig:interp}
\end{figure}

In general, the inductive definition of closable substitution
 allows the range of the
substitution to contain open terms.  When  is empty, 
is a \emph{closing} substitution.  The definition of 
for types uses the definition of closable substitutions in a
well-founded way.  We appeal only to  (with an empty
context ) in the definitions of  and
.  Where the definition of
 appeals back to the interpretation of types,
it does so only when this  was non-empty, and with an empty
context given for the interpretation of the type.  So  has
indeed decreased from one appeal to the interpretation of types to the
next.

\begin{comment}
The notion of closable substitution depends on the equally important
concept of a \emph{closable} term , with notation
.  Intuitively, a term  in the
interpretation of a type  in context  is closable iff
being in the interpretation is preserved for all nontrivial closing
substitutions.

Finally, the clause for -types is complicated by two issues.
First, -types are parameterized by a type, and so we must ensure
that subdata are reducible at the appropriate types.  Second,
-types are indexed (by the length of the list), and so we must
specify that the length is equal to  in the first case; and equal
to some  that can serve as the length of the sublist (), in
the second.  These equalities are stated using .
\end{comment}

\subsection{Critical properties}
\label{sec:critprop}

A term is defined to be \emph{neutral} iff it is of the form 
or  (with ), or if it is a
variable.  We prove three critical properties of reducibility at type
, by mutual induction on .  Here we
write .

\ 

\noindent \textbf{R-Pres}. If , then .

\noindent \textbf{R-Prog}. If  is neutral and , then
 implies .

\noindent \textbf{R-Join}. Suppose ;
 for some ; and
. Then .


\subsection{Soundness of typing with respect to the interpretation}

Our typing rules are sound with respect to our interpretation of types
(Figure~\ref{fig:interp}).  As usual, we must strengthen the statement
of soundness for the induction to go through.  We need a quasi-order
 on contexts, defined by:
.

\begin{theorem}[Soundness for Interpretations]
\label{thm:soundness}
Suppose .  Then for any 
with  and , we
have .  
\end{theorem}

\noindent Critically, we quantify over possibly open substitutions
, whose ranges consist of closable terms.  

\begin{corollary}[Strong Normalization]
\label{cor:sn}
If , then .
\end{corollary}

\begin{corollary}
\label{cor:eqdec}
If  and , then  is decidable.
\end{corollary}

\begin{corollary}[Equational Soundness]
\label{cor:eqsnd}
If , then .
\end{corollary}

\begin{corollary}[Logical Soundness]
There is a type  such that  does not hold for any .
\end{corollary}

\noindent \textbf{Proof.} By Equational Soundness, we do not have  for any .

\section{Annotated }
\label{sec:tvec}

We now define a system of annotated terms , and a decidable type
computation system deriving judgments ,
justified by dropping annotations via  (defined in
Figure~\ref{fig:drop}).  The annotated terms  are the following.
Annotations include types , possibly with designated free
variables, as in  (bound by the dot notation).

\noindent Three new constructs correspond to the typing rules
, , and  of
Figure~\ref{fig:typing}: ,  and
.  Figure~\ref{fig:tpcomp} gives
syntax-directed type-computation rules, which constitute a
deterministic algorithm for computing a type  as output from a
context  and annotated term  as inputs.  Several rules use
the  function, since types  (as defined in
Section~\ref{sec:core} above) may mention only unannotated terms.

\begin{comment}
We define 
independently of typing.  This simplifies the presentation, and means
that we need not worry whether a term is typable or not before we drop
its annotations.  We record the fact that the type-computation rules
constitute an algorithm as a theorem:
\end{comment}

\begin{theorem}[Algorithmic Typing]
Given  and , we can, in an effective way, either find
 such that , or else report that there
is no such .
\end{theorem}

\noindent This follows in a standard way from inspection of the rules,
using Corollary~\ref{cor:eqdec} for the -rule.

\begin{theorem}[Soundness for Type Assignment]
If  then .
\end{theorem}

\begin{comment}
We omit the corresponding notion of completeness,
since the unrestricted nature of the type assignment rule for
\texttt{(join)} (of Figure~\ref{fig:typing}) makes it impossible to
have a complete corresponding rule in the annotated system.
\end{comment}

\begin{figure}

\caption{Translation from annotated terms to unannotated terms}
\label{fig:drop}
\end{figure}

\begin{figure}

\caption{Type-computation system for annotated  (selected rules)}
\label{fig:tpcomp}
\end{figure}

\subsection{Example}
\label{sec:eg}

Now let us see versions of the examples mentioned in
Section~\ref{sec:intro}, available in the \texttt{guru-lang/lib/vec.g}
library file for \textsc{Guru} (see \url{www.guru-lang.org}).  The
desired types for vector append (``\textit{append}'') and for
associativity of vector append are:

\noindent We consider now annotated inhabitants of these types.  The
first is the following:
{\small
}
\noindent The two cases in the  term return a type-cast version
of what would standardly be returned in an unannotated version of
\textit{append}.  The proofs  and  used in those casts show
respectively that  and
. They
are simple join-proofs:

\noindent Now for \textit{append\_assoc}, we can use the following annotated term:
{\small
}
\noindent The omitted proof  is an easy equational proof of the following type:


\section{ with Large Eliminations}
\label{sec:tveclarge}

\begin{figure}


\caption{Types, terms, values, and typing rules for  with large eliminations.}
\label{fig:tveclarge}
\end{figure}

Next we study an extended version of  with large eliminations,
i.e. types defined by pattern matching on terms.  This extended
language no longer is normalizing under general -reduction
, but we will prove that well-typed closed terms normalize
under call-by-value evaluation . In particular, the language is
type safe and logically consistent.

The additions to the language and type system are shown in
figure~\ref{fig:tveclarge}. 

The type language is extended with the simplest possible form of large elimination,
a type-level conditional \ifzero which is introduced and
eliminated by the \texttt{fold} and \texttt{unfold} rules.  While type
conversion and type folding/unfolding are completely implicit, we
replace the \texttt{spec-abs/app} rules with new rules
\texttt{spec-abs'/app'} which require the place where we introduce or
eliminate the -type to be marked by new \emph{quasi-implicit}
forms  and . These forms do not mention the
quantified variable or the term it is instantiated with, so we retain
the advantages of specificational reasoning. The point of these forms
is their evaluation behavior: , and
 counts as a value so CBV evaluation will never reduce
inside it. Besides this, the CBV operational semantics is standard, so
we omit it here.

In the language with large eliminations we no longer have
normalization or type safety for arbitrary open terms. This is because
the richer type system lets us make use of absurd equalities: whenever we
have  and , we can
show  for any  by going via the
intermediate type . In particular, this
means we  can show judgments like

This is also the reason we introduce the quasi-implicit
products. Using our old rule \texttt{spec-abs} we would be able to
show , despite  being a
stuck term in our operational semantics.

Because of this \emph{quod libet} property it is no longer convenient
to prove Progress and Preservation before Normalization. While the
proof of Preservation is not hard, Progress as we have seen depends on
the logical consistency of the language, which is exactly what we hope
to establish through Normalization. To cut this circle we design an
interpretation of types (figure \ref{fig:large_interp}) that lets us
prove type safety, Canonical Forms and Normalization in a single
induction.

\subsection{Semantics of Equality}
We need to pick an interpretation for equality types. Since we
are only interested in closed terms, this can be less elaborate than
in section~\ref{sec:metatheory}. Perhaps surprisingly, even though we
are interested in CBV-evaluation of programs, we can still interpret
equality as joinability  under unrestricted -reduction. 
In the interpretation we use  for the
program being evaluated, but  whenever we talk about terms
occurring in types (namely in , , and R-types). The
\texttt{join} typing rule is specified in terms of , so
when doing symbolic evaluation of programs at type checking time the 
type checker can use unrestricted reduction, which gives a powerful
type system than can prove many equalities.

\subsection{Normalization to Canonical Form}

\begin{figure}

\caption{Type interpretation  and context interpretation  for  with large eliminations}
\label{fig:large_interp}
\end{figure}

We define the interpretation  as in
figure~\ref{fig:large_interp} by recursion on the depth of the
type . As we only deal with closed terms, the definition
can be simpler than the one in section \ref{sec:metatheory}.
The proof then proceeds much like the proof for open
terms:

\noindent \textbf{R-Canon}. If , then  for some . Furthermore, if the top-level constructor of 
is , , , , or , then  is the
corresponding introduction form.

\noindent \textbf{R-Pres}. If  and , then .

\noindent \textbf{R-Prog}. If , and , then .

\noindent \textbf{R-Join}. If , then  
implies .


\begin{theorem}
\label{thm:fundamental_tveclarge}
If  and ,
then .
\end{theorem}

\begin{corollary}[Type Safety]
\label{cor:sn}
If , then .
\end{corollary}

\begin{corollary}[Logical Soundness]
 does not hold for any .
\end{corollary}


\section{Conclusion and Future Work}

The  type theory includes intersection types and a form of
equality reflection, justified by translation to an undecidable
unannotated system.  The division into annotated and unannotated
systems enables us to reason about terms without annotations, while
retaining decidable type checking.  We have seen how this approach
extends to a language including large eliminations, by introducing a
novel kind of \emph{quasi-implicit} products. The quasi-implicit
products allow convenient reasoning about specificational data, while
permitting a simple proof of normalization of closed terms.  Possible
future work includes formalizing the metatheory, and extending to a
polymorphic type theory.  Adding an extensional form of equality while
retaining decidability would also be of interest, as
in~\cite{altenkirch+07}.

\textbf{Acknowledgments:} Thanks to members of the \textsc{Trellys}
team, especially Stephanie Weirich and Tim Sheard, for discussions on
this and related systems.  This work was partially supported by the
the U.S. National Science Foundation under grants 0910510 and 0910786.

\bibliographystyle{eptcs}
\bibliography{biblio}

\ifTR
\appendix

\section{Proof of Type Preservation (Theorem~\ref{thm:tppres})}

\textbf{More about contexts.}  In more detail, we consider a contexts
 to be a function from a finite set of variables to types,
together with a total ordering on its domain, and write
 for the function that behaves just like ,
except that it returns  for , and places  after the
variables in .  When
 with all the variables in
 greater than those of  in the ordering, we write
 (implying also that the domains of  and
 are disjoint).

The proof of Type Preservation is by induction on the structure of the
assumed typing derivation.  We list all cases.  Unless we introduce
meta-variable  for another purpose, in each case we will assume the
term in question reduces to .  In cases where the term in question
is a normal form, this will lead to a contradiction.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This case cannot arise, since  is a normal form and so
cannot reduce.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This case cannot arise, since  is a normal form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent (Recall that by convention in this proof, our second
assumption is .)  By the induction hypothesis, we have
.  We may then reapply this rule to
conclude .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have .  Reduction cannot increase the set of free variables, so
.  We may then reapply this rule to obtain
.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have .  We may then reapply this rule to obtain
.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have .  We may then reapply this rule to obtain .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Suppose the reduction is from , so we have
.  Then we apply the induction hypothesis to
the first premise to obtain , and
then reapply this rule to obtain .
Suppose now that the reduction is from , so we have
.  Then we apply the induction hypothesis to
the second premise to obtain .  Reapplying this
rule then gives us .  We must now
apply the \texttt{conv} rule (of Figure~\ref{fig:typing}), using as
the first premise the judgment , which
is derivable since  (because ).  This gives
us the desired result: .

Finally, suppose the reduction is because we have  for some  and , and the application itself is being
-reduced.  In this case, we need a lemma in order to limit the
cases arising from inversion on the derivation of .  We now need this lemma (proof in
Section~\ref{sec:simplinv}):

\begin{lemma}[Simplifying Inversion]
\label{lem:simplinv}
Suppose  is derivable, where  is an
introduction form (i.e., of the form , , , ,
, or ), and  has the corresponding
form of type (e.g., a -type for a -abstraction).  Then
 is also derivable by a derivation starting with
the corresponding introduction rule for the form of , using the
same context , and followed by a sequence of \texttt{(conv)}
inferences.
\end{lemma}

\noindent Using Simplifying Inversion on the derivation , we may assume this derivation starts
like this:

\noindent The derivation then uses a sequence  of \texttt{(conv)}
inferences to end in .  Let
 be the sequence which is just the same except that for every
first premise  of a \texttt{(conv)}-inference
in , we have a \texttt{(conv)} inference with first premise
, easily derived from .  We now wish to show that the result of substituting our  for
 in  has the expected type .  For this, we must
first apply the sequence  to .  This
gives us .  Now we apply Substitution (proved
in Section~\ref{sec:subst} below):

\begin{lemma}[Substitution]
\label{lem:subst}
If  and ,
then .
\end{lemma}

\noindent This gives us .  We may
apply  now to obtain . 

\ 

\noindent \textbf{Case:}

\



\

\noindent This case cannot arise since  is a normal form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This case cannot arise since  is a normal form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have ,
and we may then reapply this rule to obtain .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent If the reduction arises from  or 
or , then we apply the induction hypothesis to the
corresponding premise and then reapply this typing rule.  If the
reduction arises because  and the -term is itself
being reduced to , then we have  from
the second premise to the rule, and the fact that . Suppose the reduction arises because  and the
-term is itself being reduced to
.  Applying Simplifying Inversion
(Lemma~\ref{lem:simplinv}), we obtain .  
So we may apply the  typing rule
to obtain .  Applying the
application typing rule twice gives us then
. This is the
desired typing, since .


\ 

\noindent \textbf{Case:}

\



\ 

\noindent The reduction must arise from  or , so we apply the induction hypothesis to the corresponding premise,
and then reapply this typing rule.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent If the reduction arises from  or 
or , then we apply the induction hypothesis to the
corresponding premise and then reapply this typing rule.  If the
reduction arises because  and the -term is
itself being reduced to , then we have  from the second premise to the rule, and the fact
that .  By Simplifying Inversion
(Lemma~\ref{lem:simplinv}), we know there is a derivation of
 which starts with
 and then has a
sequence  of \texttt{(conv)}-inferences.  We may use this same
series  to change  to  in ,
yielding the desired conclusion.  Finally, suppose the reduction
arises because  for some  and ,
and the -term itself is reduced to
.  By Simplifying Inversion again,
we have a derivation of  starting from a
-introduction deriving  from premises  and ; and then
using a sequence  of \texttt{(conv)} inferences.

We may apply the sequence  of \texttt{(conv)} inferences to the
typing for  to obtain , for some  where
.  With this, we can reapply the typing rule for
 to get
.  Using this
and the typing for  we derived just previously, we can obtain
.
Since  and , the type
is equivalent to the desired one.

\subsection{Proof of Simplifying Inversion (Lemma~\ref{lem:simplinv})}
\label{sec:simplinv}

For the proof of this lemma, we begin by simplifying the derivation
 of  by applying two transformations
to the maximal path ending with the conclusion , which is
assigning a type to  (rather than a strict subterm of ). First,
we remove all inferences of the following form:

\noindent We may replace this with the result of applying the
Substitution Lemma proved in the next section, in the special case
where .  By inspection of the proof of
Substitution, we see that while inferences of the form we are eliminating
can be created, they must be created in a part of  typing
a strict subterm of .  This is because  is an introduction form.

The second transformation simplifies this inference:

\noindent Observing that the substitutions in question commute,
we reduce this to the following, where  is easily
constructed to show  from :


\noindent For each of these transformations, the following measure is
strictly decreased in the lexicographic ordering (combining two copies
of the natural number ordering): the pair of the sum of the distances
of occurrences of a \texttt{(conv)} inference on the maximal path
typing ; and the number of inferences of the form removed by the
first transformation in that same path.  Note that the \texttt{(conv)}
inference introduced by the second transformation in the topmost
rightmost position show above is not on the maximal path typing 
(it is typing ).  Strict decrease of the stated measure implies
that the transformations terminate.  They also preserve the form of
the derived judgment.

We can now prove the lemma by induction on the simplified derivation
.  It cannot end in a use of \texttt{(spec-abs)}, since
then  would be a -type (and by assumption it is of the
form corresonding to the introduction form which  is assumed to
have).  It also cannot be a \texttt{(spec-app)} inference, for the
following reason.  Consider the maximal consecutive sequence  of
\texttt{(spec-app)} inferences ending at the conclusion of
, and typing .  These inferences cannot start with the
conclusion of either a \texttt{(conv)} or a \texttt{(spec-abs)}
inference, since such patterns of inference have been eliminated by
the above transformations.  But these are the only possibilities, since
 is an introduction form.  Therefore, the derivation 
ends in a sequence of \texttt{(conv)} inferences, starting from a use
of the introduction rule for .  Since \texttt{(conv)} does not change
the context, this introduction inference for  uses the same context,
as required by the statement of the lemma.

\subsection{Proof of Substitution (Lemma~\ref{lem:subst})}
\label{sec:subst}

The proof is written using different variable names than the statement
of the lemma, in order to not clash with the variable names in the
typing rules. We prove:

If  and ,
then .

The proof is by induction on the depth of . The cases are:

\ 

\noindent \textbf{Case:}

\



There are three cases: , , or . If , then by  we know , so  and the conclusion follows by Var. If  the conclusion follows directly by Var. In the case , we use the second assumption together with a weakening lemma:

\begin{lemma}[Weakening]
\label{lem:weak}
If , , and , then .
\end{lemma}
\begin{proof}
Induction on . The only interesting cases are for Abs and Spec-Abs. There we have  by assumption; by regularity, we get , so then  and the conclusion follows by IH.
\end{proof}

\begin{lemma}[Free variables of typable terms]
\label{lem:vars}
If , then .
\end{lemma}
\noindent The proof is a straightforward induction on the typing
derivation.

We also need to note that by Lemma~\ref{lem:vars} , and the substitution preserves well-scoping of contexts:

\begin{lemma}
If  and , then .
\end{lemma}
\begin{proof}
For each variable  in , if the entire context looks like   we know that  and , so  is still well-scoped.
\end{proof}

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Immediate by the fact that substitution preserves joinability.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent First, rename  in  so that .

By IH we get  and . Now by \texttt{(conv)} we conclude  as required.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent First, rename  in the derivation of  so that . This can be done without changing the depth.

By IH we get . The conclusion follows by Spec-Abs.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Pick  and . 

By IH we get  and . Then by Spec-App,   as required.

\noindent \textbf{Case:}

\



\ 

\noindent Similar to Spec-abs.

\

\noindent \textbf{Case:}

\



\ 

\noindent Similar to Spec-App.

\

\noindent \textbf{Case:}

\



\

\noindent Immediate.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Immediate.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Immediate by IH.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent First rename  in  so that .

IH gives  and  Then by Rnat, 

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Immediate by IH.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Similar to Rnat case.



\section{Proof of Progress (Theorem~\ref{thm:progress})}
\label{sec:progress}

The proof is by induction on . 


\ 

\noindent \textbf{Case:}

\



\ 

\noindent Impossible by .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  is a value, as required.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Directly by the IH for .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent The condition  ensures that , so we can apply the IH for .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Directly by the IH for .

\noindent \textbf{Case:}

\



\ 

\noindent  is a value as required.


\noindent \textbf{Case:}

\



\ 

\noindent By the IH for , we know  either steps or is a value. If  steps, the entire expression  steps also, by -congruence. If  is a value, by Lemma~\ref{lem:canonical} , so  steps by .

\noindent \textbf{Case:}

\



\

\noindent  is a value as required.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  is a value as required.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the IH for , we know  either steps or is a value; accordingly  steps or is a value.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the IH for  and Lemma~\ref{lem:canonical}, we know that either  steps or  or . Then  steps by congruence or one of the two reduction rules, respectively.


\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the IH,  and  either step or are values; accordingly  steps by congruence or is a value.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the IH for  and Lemma~\ref{lem:canonical}, we know that either  steps or  or . Then  steps by congruence or by one of the two reduction rules, respectively.


\subsection{Proof of Canonical Forms (Lemma~\ref{lem:canonical})}
\label{sec:canonical}

Write  for .
\begin{lemma}[Canonical Forms]
\label{lem:canonical}
If , then
\begin{itemize}
\item if , then  or .
\item if , then  or .
\item if , then 
\item if , then .
\end{itemize}
\end{lemma}

\noindent \textbf{Proof:}

Induction on the typing judgment. The cases are 
\begin{itemize}
\item \textbf{var} Impossible by .
\item \textbf{conv}
\



\ 

The types  and  have the same top-level structure, so the IH applies.

\item \textbf{spec-abs}
\



\ 

The condition  ensures that . Also, the type  still has the required form. So the IH applies.

\item \textbf{spec-app}
\



\ 

If the type  has the required form, then  has required form also, so the IH applies.

\item \textbf{join,abs,zero,nil,succ,cons} The value in the conclusion has the required form.
\item \textbf{app, Rnat, Rvec} The term in the conclusion is not a value.

\end{itemize}

\section{Proof of Critical Properties (Section~\ref{sec:critprop})}

\subsection{More basic notation}

We will define a term context to be a term  with a designated free
variable , which may be instantiated in a capture-avoiding way by a
term  using the notation .  

Also, if  is a set of terms, then we will allow ourselves to write
a term which has  inserted for the hole of some context .  For
example, we may write  (here ).  The meaning of this notation is the set of terms
.  So in the example: .  

Finally, if , we define  to be some bound on the
lengths of the reduction sequences from .

\subsection{Preliminary observation}

We will not explicitly prove strong normalization or typability in the
cases for \textbf{R-Join} below.  This is because \textbf{R-Join}
assumes  for some , so we will always
be able to show  from  using \texttt{(conv)}.  Similarly, we will always have
, since it follows from .

\subsection{Critical properties for }

\textbf{R-Pres} holds using Type Preservation
(Theorem~\ref{thm:tppres}), and the fact that .  For \textbf{R-Prog}, we have , and  by assumption (of
\textbf{R-Prog}). We have \textbf{R-Join} because all instances
 have the same (trivial) interpretation.

\subsection{Critical properties for }

\subsubsection{Proof of \textbf{R-Pres}}

Suppose , and
.  We have  from , and  by Type Preservation.  To prove the second conjunct for
 at -type -- namely,  -- assume .  From this and the
assumption that , we have .  So we can
use the corresponding conjunct for  to conclude ,
as required.  Similar reasoning applies for the third conjunct.

\subsubsection{Proof of \textbf{R-Prog}}

Suppose ,
with  neutral and .  We have  for the
same reason as for the  case above.  It suffices now to show the
two conjuncts of the clause of  for -types, for
.  For the first, assume .  Now since  is
neutral, we cannot have .  So consider arbitrary
.  From  and , we obtain
 by confluence.  We may then apply the corresponding
second conjunct for  to obtain the desired result for this
conjunct.  The second conjunct follows by similar reasoning.

\subsubsection{Proof of \textbf{R-Join}}

Suppose that , and consider arbitrary
.  We must show
.  It suffices
to prove the two conjuncts for  at the type involving
, assuming them for the type involving .  For the first
conjunct, assume .  We must show that for an
arbitrary , we have .  From the second conjunct for the -type,
we have .  Instantiate our first
assumption about  and , to obtain .  Now we use the fact that joinability is closed under
substitution of joinable terms (proof omitted), to obtain the desired
result.  Note that joinability is not closed under substitution of
joinable terms for more specialized reduction strategies, such as
call-by-value or call-by-name.

For the second conjunct, assume .  From
the corresponding second conjunct for the -type, we obtain the
following for some :
\begin{itemize}
\item 
\item 
\item  
\end{itemize}
\noindent We use \textbf{R-Join} on the first formula to derive the
similar statement involving . The measure
 decreases, because the depth of the type
decreases (and  is unchanged).  Now let  be a variable
not in  and not free in , , or .
Then the second formula is equivalent to
, and
by \textbf{R-Join} (where the measure decreases because the depth of
the type is the same, but the quantity given by  has
decreased), we have
, which
is equivalent to the required
.
Instantiating the third formula with an arbitrary
, we have .  We appeal as above to the closure of joinability under
substitution of joinable terms, to obtain .

\subsection{Critical properties for }

\subsubsection{Proof of \textbf{R-Pres}}

Assume , and consider an
arbitrary .  By definition of
, we have .  We
also have


\noindent By \textbf{R-Pres} at type  (where we have
, and so can apply the induction
hypothesis), we obtain
.  By (\ref{eq7}),
this implies .  We
conclude this for all .  Then by the
definition of , we obtain the desired
, using also Type
Preservation and the fact that  (since ).

\subsubsection{Proof of \textbf{R-Prog}}

Suppose  is neutral with .  By
assumption, we have


\noindent It suffices, by the definition of , to show
that  and for all ,
. We have  from
, so we focus on the latter property.  Consider
arbitrary .  Since  is neutral,
 cannot be a -redex.  Since
, we have  by \textbf{R-SN} at
type  (where , so the induction
hypothesis may be applied).  So we may reason by inner induction on
the number  to prove that for all
, we have
.  By \textbf{R-Prog} at type
 (where , so the
induction hypothesis may be applied), it suffices to prove
, since the term in
question is neutral and since we have .  The possibilities for reduction are summarized
by:


\noindent We have  from
(\ref{eq8}), by the definition of .  For reducibility
of the second set, consider arbitrary .  By our inner
induction hypothesis, which we may apply because
 by \textbf{R-Pres} at type  (with
smaller depth), we have .  Now
we may apply \textbf{R-Join} at type  (with smaller depth),
using the obvious fact that  implies the facts  and  (required by
\textbf{R-Join}).  This yields
, as required by our inner
induction.

\subsubsection{Proof of \textbf{R-Join}}

Suppose that , and consider arbitrary
.  We must show
.  It suffices to show
 for an arbitrary
.  We now wish to use
\textbf{R-Join} at type  (with smaller depth), with the
symmetric equality .  Symmetry of  is
direct from its definition.

Using \textbf{R-Join} in this way with , we obtain
.  We must further obtain
.  So consider arbitrary
.  From closability of  at the type
involving , we have .
We must show .  If
 is empty, this formula is equivalent to
, which we already have.  So suppose
 is not empty.  Then the formula is equivalent to , since
.  Notice that from our assumption that
, we obtain .  We may
now use \textbf{R-Join}, where the length of the context has
decreased, to conclude  from .

Since we have obtained , we now get
 by the assumption above
of reducibility of .  Applying Lemma~\ref{lem:vars} to the fact
that  (which we have from
), and using the assumption that
, we obtain .
Since  is locally scoped, we may also assume that
 and . This tells
us that  and also
.  Using the first of these, we
may conclude  from the
similar fact we had just above.  Using the second of these
commutations of substitutions, and also \textbf{R-Join} at type
 (of smaller depth), we can conclude
, as required.

\subsection{Critical properties for }

The proofs here are simpler versions (particularly for
\textbf{R-Prog}) of those for the previous case.

\subsubsection{Proof of \textbf{R-Pres}}

Assume , and consider an
arbitrary .  By \textbf{R-Pres} at type
 (with smaller depth), we obtain
.  We conclude this for all
.  Then by the definition of
, we get the required , using also Type Preservation and the fact
 (from ).

\subsubsection{Proof of \textbf{R-Prog}}

Suppose  is neutral with .  By assumption, we have


\noindent It suffices, by the definition of , to show
that  and for all ,
. We have  from
, so we focus on the latter property.  Consider
arbitrary .  By the definition of
 at -type and our above assumption, we have
.  So by \textbf{R-Prog} at
type  (with smaller depth), we have
, as required.

\subsubsection{Proof of \textbf{R-Join}}

Suppose that , and consider arbitrary
.  We must show
.  It suffices to
show  for an arbitrary
.  By \textbf{R-Join} at type
 (with smaller depth), and using the symmetric version of our
assumption as above, we have .  We
further obtain  as in the case
for \textbf{R-Prog} for -types.  So we get
 by the assumption of
reducibility of .  By similar reasoning as above, we may permute
the substitutions in question.  So we may apply \textbf{R-Join} at
type  (of smaller depth) to conclude
, as required.

\subsection{Critical properties for }

\subsubsection{Proof of \textbf{R-Pres}}

Consider arbitrary  with .  We
have  from , and  by Type
Preservation.  Now suppose .  Then we have
 and obtain  from
.  

\subsubsection{Proof of \textbf{R-Prog}}

We have  from  as in other cases above.
Suppose that .  Since  is neutral, we cannot
have .  So we must have .  Then we get
 by confluence, and we can use the assumption that
 to obtain  as
required.

\subsubsection{Proof of \textbf{R-Join}}

Assume , and assume .  Then we
have  from .  Consider arbitrary
.  Instantiating our two assumptions of
joinability under all ground instances with this , we obtain:
\begin{itemize}
\item 
\item 
\end{itemize}
\noindent The desired result (namely, ) now follows from 
closure of joinability under substitution of joinable terms.

\section{Proof of Soundness (Theorem~\ref{thm:soundness})}

\subsection{The Closability Lemma}

We have carefully crafted our notions of closable terms and closable
substitutions to allow the following two lemmas to be proved.  The
first expresses the basic desired property of closable substitutions,
and the second shows that under the conditions of the Soundness
Theorem, the term  is closable which Soundness tells us is
in the interpretation of  with context .

\begin{lemma}[Composing Substitutions]
\label{lem:csubst}
Suppose  and
.  Then
.
\end{lemma}

\noindent The proof is by induction on the
structure of the derivation of
.  The base case
holds trivially, noting that .  For
the step case, we have

\noindent Now we obtain
, by the
definition of closability of .  This implies
, since the
definitions of  and  coincide when
the context is empty.  By the induction hypothesis we have
.  So we may
reapply the rule to obtain the desired
.

\begin{lemma}[Closability]
\label{lem:close} Suppose the following main assumption is true: for any 
and , we have .  In this case, for any such
 and , we also have .
\end{lemma}

\noindent Assume an arbitrary .  We must
show .  By Composing
Substitutions (Lemma~\ref{lem:csubst}), we have
.  So we may instantiate the
main assumption with  to obtain the the required
formula.

\subsection{The Proof}

The proof of the Soundness Theorem is by induction on the structure of
the assumed typing derivation.  We consider all cases, and implicitly
start each by assuming an arbitrary .
We often will use this  to instantiate universal formulas
obtained by application of our induction hypothesis, without
explicitly noting that we are instantiating the induction hypothesis.
If  is a substitution, we will write  for the
substitution that extends  by mapping  to .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent We prove  by
inner induction on the structure of
.  The base case cannot arise,
since we have  defined.  For the step case, we have:

\noindent If , then we have  from the first premise.  We just need to show
.  But this follows from
the fact that  (by ).
If , then by the inner induction hypothesis we have
.  We must show that
this implies the desired .  We certainly have , and .  So it suffices to show that
.  But  cannot
contain , so this holds.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent If , we certainly also have , since joinability is closed under substitution.
This gives us .  Again by
closure of joinability under substitution, we have , since for any , we
certainly have .  We
obviously have , so we conclude
.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent The required conclusion follows by \textbf{R-Join} from
, which we have
from the induction hypothesis for the second premise.  To enable this
use of \textbf{R-Join}, we need  and .  The former we
obtain from ,
which we have by the induction hypothesis for the first premise.  The
latter we obtain as follows.  Consider an arbitrary
.  From this and the fact that
, we have
 by Composing Substitutions
(Lemma~\ref{lem:csubst}).  

Since , we can use it to
instantiate the induction hypothesis for the first premise.  This
gives us , which implies .  So consider the
unique normal form  of , which exists by
confluence and \textbf{R-SN}.  We have  by repeated application of \textbf{R-Pres}.
This implies .  By
Progress, this  must be a value.  We may now apply Canonical Forms
(Lemma~\ref{lem:canonical}), to conclude that .  Now
by the definition of , we have ,
as required.  We assumed an arbitrary , so
we may conclude that  holds for all such .  This is sufficient for .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent From the
induction hypothesis, we infer the following, for any
, for any
:


\noindent Our first need is to prove .  For this, we
instantiate (\ref{eqlama}) with ;
; and .  Note that it is at
precisely this point that we critically need open substitutions in the
statement of Soundness.  To show that this instantiation is legal, we
must, of course, prove that .
For this, we need two things.  First, we need to know that
.  This follows
because  by
\textbf{R-Prog} (since ); and further, for any
, we derive from that same
fact the formula , which we
require for closability of .  Now we use the following lemma (proof
in Section~\ref{sec:weaksubst} below) to finish our proof of the
intermediate fact :

\begin{lemma}[Weakening Substitutions]
\label{lem:weaksubst}
If  and
, then
.
\end{lemma}

\noindent Using this intermediate fact
, we may indeed
instantiate (\ref{eqlam}) above with ,  and  for
, as mentioned.  This gives us . By \textbf{R-SN}, we then obtain .  From this, we obtain
 and , which we need to show .

To complete this case, it suffices to consider arbitrary
, and show .  Instantiating (\ref{eqlama})
with , we obtain .  This is equivalent to the
goal, thanks to the following facts about the substitutions in
question.  Since , we have .  Also, we have  by the
following lemma.  So we get the desired .

\begin{lemma}[Basic Property of Substitutions]
\label{lem:substvars}

\end{lemma}
\noindent The proof is by induction on the structure of the assumed
derivation.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This follows immediately from induction hypothesis, and the
definition of  for -types (here, the type
), using the fact that various
substitutions involved commute, as in cases above.  We critically use
Closability (Lemma~\ref{lem:close}), to get  from .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent We begin just as for the \texttt{(spec-abs)} case.  From the
induction hypothesis, we infer the following, for any
, for any
:

\noindent By the same reasoning as for the \texttt{(spec-abs)} case,
we obtain  and .

Now by the definition of , it suffices to prove that
for all , we have .  We
prove that (\ref{eqlam}) implies this, by inner induction on
, which is defined by \textbf{R-SN} (for
 and ).  By \textbf{R-Prog}, it suffices to prove
, since the term in question
(i.e., ) is neutral and appropriately
typable since  is.  In more detail, since we have , we obtain
.  Then we apply the
typing rule for -abstractions to obtain , and we conclude the typing
proof with the application rule on this fact and .

Now the possibilities for reduction of the term in question are
summarized by:


\noindent We have  by the inner
induction hypothesis, using \textbf{R-Pres} to conclude .  For the set , we use the inner induction hypothesis to
conclude that for all , we have .  Applying the
induction hypothesis here requires the fact that
, which follows by \textbf{R-Pres}.
Now we may apply \textbf{R-Join} with  and
 (which follow from ), to
obtain .  This implies , as
required.

Finally, we wish to conclude  by instantiating (\ref{eqlam}) above with
; ; and . We
have the required , of course.
But we also need the fact that .  This holds because  (by
Lemma~\ref{lem:substvars}, as in an earlier case).  So we conclude the
desired .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have  and .  By Closability
(Lemma~\ref{lem:close}), we then get .  Then using the definition of
 at -type, we directly obtain .  Since
 (by Lemma~\ref{lem:substvars}), we get
from this the desired conclusion, namely .

\ 

\noindent \textbf{Case:}

\



\

\noindent Since  is a normal form, we have  and
, which suffices for this case.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Since  is a normal form, we have , and of
course, . For the
second conjunct of the definition of  at -type,
we have . For the third conjunct, assume
 for some  and .  This is easily
shown to be impossible, since reduction cannot possibly turn 
into a -term.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have , which is equivalent to the conjunction of
 and .  This implies
 and , which
suffices.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have
\begin{itemize}
\item 
\item 
\item 
\end{itemize}

\noindent We will prove that for any , and
assuming the second two of these facts, we have . The proof is
by inner induction on the measure .  Our measure is defined, since all the terms
involved are reducible and hence strongly normalizing by
\textbf{R-SN}.  By \textbf{R-Prog}, it suffices to prove
, since the term in question is
neutral and appropriately typable.  The possibilities for reduction are
summarized by:


\noindent The first three cases are for when the reduction is due to
reduction in a subterm.  The second two are for when the term in
question is itself a redex.  For the first two cases, we use the inner
induction hypothesis and \textbf{R-Pres}.  For the third, we do the
same, except also apply \textbf{R-Join} with  for
.  This ensures that we have  (the
critical point being that we have  in the type, and not some
).  The fourth case follows by our assumption that
 (note that in this case that
the type in question is equivalent to the desired ).  For
the fifth case, we have  by the inner induction
hypothesis, using the fact that  and  implies
; and this then implies  by
definition of .  Note that we obtain  from , by applying Simplifying
Inversion (Lemma~\ref{lem:simplinv} above).  By the definition of
 at -type and our hypothesis that  is
reducible at the appropriate -type, we have that the given term
is in the set , which is equal to the
desired .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have  and .  By \textbf{R-SN}, these facts imply
 and , respectively, and hence
.  We also have .
We must show the conjuncts of the definition of  at
-type to conclude .  The second
conjunct is vacuously true, since we cannot have
. The third conjunct follows directly
from our assumptions.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This case is similar to that for  above, although it
is for this case that we have the various clauses of the definition of
 at -type.  By the induction hypothesis, we have
\begin{itemize}
\item 
\item 
\item 
\end{itemize}

\noindent It is sufficient to prove that for any , for any
, and assuming the
second two of these facts, we have . The proof is by inner
induction on the measure .
As above, this measure is defined, by \textbf{R-SN}.  By
\textbf{R-Prog}, it suffices to prove , since
the term in question is neutral and appropriately typable.  The
possibilities for reduction are summarized by:


\noindent The first three cases are for when the reduction is due to
reduction in a subterm.  The second two are for when the term in
question is itself a redex.  For the first two cases, we use the inner
induction hypothesis and \textbf{R-Pres}.  For the third, we also
apply \textbf{R-Join} as in the  case above, to ensure that we
have .  The fourth
case follows by our assumption that .  By the definition of
 at -type, we have ; so we can
apply \textbf{R-Join} and the fact that  to obtain
, as required.

We now consider the fifth case. First, since 
and , the
definition of  at -type gives us the following
facts for some :
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
\noindent We next apply the inner induction hypothesis to obtain
; this is legal,
since the measure has decreased (in particular, ).  With
this obtained, we use the definition of  at -type
and our hypothesis that  is reducible at the appropriate
-type.  So we obtain the fact that the given term is in the set
.  We can then
use \textbf{R-Join} with the fourth assumed formula above, and the
fact that , to get that the term is in the
desired .

\subsection{Proof of Weakening Substitutions (Lemma~\ref{lem:weaksubst})}
\label{sec:weaksubst}

\noindent The proof is by induction on the structure of the assumed
derivation of .  The base case is
trivial.  For the step case, we have:

\noindent The induction hypothesis gives us
.  We just need
, and we can
reapply the rule to get the desired result.  For this, we use the
following lemma:

\begin{lemma}[Weakening for Closable Terms]
\label{lem:weakclose}
Suppose .  Then
 implies
.
\end{lemma}

\noindent Now we apply the following lemma to complete the proof,
noting that the variable  of interest here is not in the free
variables of  or , and so the assumption implies the required
universal formula:

\begin{lemma}[Weakening-Strengthening for Interpretations]
\label{lem:weakstr}
Suppose .  Then we have
 iff for all
, we have .
\end{lemma}

\noindent The proof makes frequent use of the following lemma, which
we prove briefly first:

\begin{lemma}[Weakening-Strengthening for Ground Joinability]
\label{lem:weakstrj}
Suppose .  Then we have
 iff for all
, we have .
\end{lemma}

\noindent First, suppose , and consider
arbitrary  and
.  Then we have
 by Composing
Substitutions (Lemma~\ref{lem:csubst}).  We can then use  to get , as required.  

Second, suppose that for all , we have
, and show .  Assume arbitrary .  Then for
some  and , we have
.  Instantiating our assumption with this
 and then , we obtain the desired conclusion.

We now turn to the main proof for Weakening-Strengthening, which is by
induction on .  In all cases, the typing
statement in question follows by either Weakening
(Lemma~\ref{lem:weak}) or Substitution (Lemma~\ref{lem:subst}), so we
omit consideration of typing below.  Strong normalization of the
substitution instances follows from the definition of closability (and
the assumption that  is a closable term in context ).



\

\noindent \textbf{Case:} .

\

\noindent This case is trivial.

\ 

\noindent \textbf{Case:} .

\

\noindent These cases follow easily by Weakening-Strengthening for Ground
Joinability (Lemma~\ref{lem:weakstrj}) and the induction hypothesis.

\ 

\noindent \textbf{Case:} .

\

\noindent First, assume , and
show  for an arbitrary
.  It suffices to consider arbitrary
, and show
.  Since
, we certainly have
 for all
.  So we may apply the induction
hypothesis to conclude .
Now we may use our assumption of reducibility of  in context
 to conclude
.  To obtain
 from this,
assume an arbitrary partition
, and arbitrary
.  We must show .  If  is
empty, this statement is equivalent to the fact
, which we already
have.  So suppose  ends in .  Then
.  Also, , so
our current goal formula is equivalent to .  Instantiating
our assumption of closability of  with
, we obtain .  This is then sufficient for the
desired conclusion, since we easily obtain  from our assumption of
closability of  in context .  Having obtained 
closable, we may now apply the induction hypothesis again, to obtain
, noting again
that .  Closability of  and  again
imply closability of this final term.

Now assume that for all , we have
; and show
.  It suffices to consider
arbitrary , and show
.  By the induction
hypothesis, we have  for any
.  Consider arbitrary such .  We have
 by
reducibility of  in context .  Closability of  and
 in context  again imply closability of this
term. This is true for any , so we may apply the induction
hypothesis again to conclude
, and again obtain
closability as above, for the required conclusion.

\

\noindent \textbf{Case:} .

\

\noindent This case is very similar to the previous one, so we omit it.

\ 

\noindent \textbf{Case:} .

\

\noindent This follows by Weakening-Strengthening for Ground
Joinability (Lemma~\ref{lem:weakstrj}).

\section{Proof of Corollaries of Theorem~\ref{thm:soundness}}

\subsection{Proof of Strong Normalization (Corollary~\ref{cor:sn})}

By Soundness for Interpretations,
we have  for all  and
 with  and
.  We instantiate this by taking
 for  and the identity substitution  on
 for .  We have
, since for all
, we have 
by \textbf{R-Prog} and the fact that if ,
then by that assumption, we get , which is needed for closability of .  This
instantiation yields , which implies
 by \textbf{R-SN}.


\subsection{Proof of Equational Soundness (Theorem~\ref{cor:eqsnd})}

By Type Preservation, Progress, and
Canonical Forms, we obtain .  By Inversion, the only
possible derivations are \texttt{(conv)} inferences starting with a
-introduction.  This implies , because
joinability is closed under substitution of joinable terms.  An easy
corollary is:

\section{Proofs for section \ref{sec:tveclarge} (Large Eliminations)}


\subsection{Proof of Critical Properties}

\

\noindent \textbf{R-Canon}. If , then  for some . Furthermore,
if  is a value type (i.e. , , , , or ), then  is the corresponding introduction form.

\begin{proof} Immediate from the definition of .
\end{proof}

\noindent \textbf{R-Pres}. If  and , then .

\begin{proof}Induction on the depth of .

The clauses of the form  are all proven in the same way: for instance if  and , then  by determinacy of . This takes care of all cases except  and .

For , we also need to show . Let . By assumption we know . But , so by the IH at the type  (which is of lower depth)  as required.

The case  is similar to the above case: we need to show  and use that .
\end{proof}

\noindent \textbf{R-Prog}. If , and , then .

\begin{proof}
Induction on the depth of .

The clauses of the form  are all proven in the same way: for instance if  and , then . This takes care of all cases except  and .

For , we also need to show . Let . By assumption . But , so by IH at the type  (which is of lower depth),  as required.

The case  is similar to the above case: we need to show  and use .

\end{proof}

\noindent \textbf{R-Join}. If , then  
implies .

\begin{proof}
Induction on the  depth of . 
\begin{itemize}
\item . Trivially true since .
\item .  By assumption , so either  and
  , or  and
   with  and
  .

In the first case, note that joinability implies .
In the second case, joinability gives ,
and the IH gives  and .

\item . The first conjunct is the same for both  and .
For the second conjunct, let . By IH ,
so . Since  was a bound variable we can choose it such
that ,
so . By IH applied to  (which is of lower depth),
 as required.

\item . Similar to the previous case.

\item . We need to show that  implies , which is true.

\item . Note that  implies , and then by the IH.
\end{itemize}
\end{proof}

\subsection{Proof of Theorem \ref{thm:fundamental_tveclarge} (Fundamental Lemma for Large Eliminations version of )}

\ 

\noindent \textbf{Case:}

\



\ 

\noindent Immediate by .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  is a value of the right form. We get , since joinability is closed under substitution.
We get  by IH and \textbf{R-Canon}.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the IH from the second premise we have .  By the IH from the first
premise we have , so .  So by \textbf{R-Join}, .

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  is a value of the right form. We must show
.


Consider some . By \textbf{R-Prog}, it
suffices to show , since .  Let . Then
, so by IH we have , that is 

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This follows immediately from induction hypothesis, and the
definition of  for -types.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  is a value of the right form.  We must show
.


Consider some . We must show . By \textbf{R-Prog} it suffices to show that it steps to a term in .

By \textbf{R-Canon},  for some . We proceed by the number
of steps  takes to normalize. In the base case  is already a
value. Then  where .
, so by IH . 

In the step case,  for some , so . By \textbf{R-Pres}, , so the inner IH applies and . But , so , so , so \textbf{R-Join} applies and  as required.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent This follows immediately from induction hypothesis, and the
definition of  for -types.

\ 

\noindent \textbf{Case:}

\



\

\noindent is a value of the right form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have , so by \textbf{R-Canon}  . Then , which is a value of the
right form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent By the induction hypothesis, we have
\begin{itemize}
\item 
\item 
\item 
\end{itemize}

\noindent We will prove that for any , and
assuming the second two of these facts, we have . The proof is
by inner induction on the measure .  Our measure is defined, since all the terms
involved are normalizing by \textbf{R-Canon}.

By \textbf{R-Prog}, it suffices to prove that  steps to a term in .  The
terms , , and  are all in  , 
so by \textbf{R-Canon} each of them either steps or is a value. By
considering the cases, one of the following must be the case:


\noindent The first three cases are for when the reduction is due to
reduction in a subterm.  The second two are for when the term in
question is itself a redex.  For the first two cases, we use the inner
induction hypothesis and \textbf{R-Pres}.  For the third, we do the
same, except also apply \textbf{R-Join} with .  This
ensures that we have  (the critical point being that we have 
in the type, and not ) The fourth case follows by our assumption
that  (note that in this case
that the type in question is equivalent to the desired ).
For the fifth case, we have  by the inner induction
hypothesis. Since  is a number we trivially have .  By the definition of  at -type
and our hypothesis that  is reducible at the appropriate
-type, we have that the given term is in the set , which is equal to the desired
.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent  and  are values of the right form.

\ 

\noindent \textbf{Case:}

\



\ 

\noindent We prove the second disjunct of . 
By IH and \textbf{R-Canon}, we know   and 
reduce to some values  and . Then  as required. Similarly
from the IH we know , so  as required.

\

\noindent \textbf{Case:}

\



\ 

\noindent This case is similar to that for  above. By the induction hypothesis, we have
\begin{itemize}
\item 
\item 
\item 
\end{itemize}

\noindent It is sufficient to prove that for any , for any
, and assuming the
second two of these facts, we have . The proof is by inner
induction on the measure .
As above, this measure is defined, by \textbf{R-Canon}. 

By \textbf{R-Prog}, it suffices to prove that  steps to a term in .  The
terms , , and  are all in  , 
so by \textbf{R-Canon} each of them either steps or is a value. By
considering the cases, one of the following must be the case:



\noindent The first three cases are for when the reduction is due to
reduction in a subterm.  The second two are for when the term in
question is itself a redex.  For the first two cases, we use the inner
induction hypothesis and \textbf{R-Pres}.  For the third, we also
apply \textbf{R-Join} as in the  case above, to ensure that we
have .  The fourth
case follows by our assumption that .  By the definition of
 at -type, we must have ; so we can
apply \textbf{R-Join} and the fact that  to obtain
, as required.

For the fifth case, we know by assumption that .  By the definition of
 that means that , , and .

Then we have  by the inner induction
hypothesis. By the definition of  at -type and
our hypothesis that  is reducible at the appropriate
-type, we have that the given term is in the set . By using \textbf{R-Join} on
, this implies the desired .


\ 

\noindent \textbf{Case:}

\



\ 

\noindent By IH we have , so by \textbf{R-Canon},  for some . Therefore 
, so we need to show , which we get by IH.

\

\noindent \textbf{Case:}

\



\ 

\noindent Similar to the previous case.


\noindent \textbf{Case:}

\



\ 

\noindent Similar to \texttt{unfoldS} case.

\

\noindent \textbf{Case:}

\



\ 

\noindent Similar to \texttt{foldS} case.

\

\fi 

\end{document}
