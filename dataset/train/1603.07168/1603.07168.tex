\documentclass[11pt]{llncs}

\usepackage{fullpage}
\usepackage{graphicx, color}
\usepackage{latexsym,amsfonts,enumerate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{tikz} \usetikzlibrary{arrows,decorations.markings,patterns,calc, positioning, backgrounds} 

\newtheorem{new-claim}{Claim}
\newcommand{\vote}{\mathsf{vote}}
\newcommand{\capac}{\mathsf{cap}}
\newcommand{\Nbr}{\mathsf{nbr}}
\def\labelitemi{--}

\begin{document}
\pagestyle{plain}
\title{Popular matchings with two-sided preferences and one-sided ties\thanks{A preliminary version of this paper has appeared at ICALP~2015.}}
\author{\'{A}gnes Cseh\inst{1}\thanks{Work done while visiting TIFR, supported by the Deutsche Telekom Stiftung.}
\and Chien-Chung Huang\inst{2}\and Telikepalli Kavitha\inst{3}}
\institute{Reykjavik University, Iceland. \email{cseh@ru.is} \and Chalmers University, Sweden. \email{huangch@chalmers.se} \and Tata Institute of Fundamental Research, India. \email{kavitha@tcs.tifr.res.in}}
\maketitle


\begin{abstract}
We are given a bipartite graph  where each vertex has a preference list
ranking its neighbors: in particular, every  ranks its neighbors in a strict order 
of preference, whereas the preference lists of  may contain ties. A matching  is 
\emph{popular} if there is no matching  such that the number of vertices that prefer  
to  exceeds the number of vertices that prefer  to~. We show that the problem of deciding whether 
 admits a popular matching or not is -hard. This is the case even when every 
 either has a strict preference list or puts all its neighbors into a single tie. 
In contrast, we show that the problem becomes polynomially solvable in the case when each 
 puts all its neighbors into a single tie. That is, all neighbors of  are tied 
in 's list and  desires to be matched to any of them. Our main result is an  algorithm 
(where ) for the popular matching problem in this model. Note that this model 
is quite different from the model where vertices in  have no preferences and do {\em not} 
care whether they are matched or not.
\end{abstract}

\section{Introduction}
\label{sec:intro}
We are given a bipartite graph  where the vertices in  are called 
applicants and the vertices in  are called posts, and each vertex has a preference list 
ranking its neighbors in an order of preference. Here we assume that vertices in  have 
strict preferences while vertices in  are allowed to have ties in their preference lists. 
Thus each applicant ranks all posts that she finds interesting in a strict order of preference,
while each post need not come up with a total order on all interested applicants -- here 
applicants may get grouped together in terms of their suitability, thus equally competent 
applicants are tied together at the same rank. 

Our goal is to compute a {\em popular} matching in~. The definition of popularity uses the 
notion of each vertex casting a ``vote'' for one matching versus another. A vertex  
{\em prefers} matching  to matching  if either  is unmatched in  and matched in 
 or  is matched in both matchings and  ('s partner in ) is ranked better 
than  in 's preference list. In an election between matchings  and , each 
vertex  votes for the matching that it prefers or it abstains from voting if  and  
are equally preferable to~. Let  be the number of vertices that vote for  in 
an election between  and~.

\begin{definition}
A matching  is \emph{popular} if  for every matching~.
\end{definition}

If , then we say  is {\em more popular} than  and denote it by 
; else~. Observe that popular matchings need not always exist. 
Consider an instance where  and  and for , 
each  has the same preference list which is  followed by  followed by  
while each  ranks  the same, i.e.\  are tied together in 's 
preference list (see bottom left instance in Fig.~\ref{fig:AppA}). It is easy to see that for any matching  
here, there is another matching  such that , thus this instance admits no 
popular matching.

The popular matching problem is to determine if a given instance  admits a 
popular matching or not, and if so, to compute one. This problem has been studied in the 
following two models.
\begin{itemize}
\item {\em 1-sided model:} here it is only vertices in  that have preferences and cast 
votes; vertices in  are objects with no preferences or votes.
\item {\em 2-sided model:} vertices on both sides have preferences and cast votes.
\end{itemize}

Popular matchings need not always exist in the 1-sided model and the problem of whether a 
given instance admits one or not can be solved efficiently using the characterization and 
algorithm from~\cite{AIKM05}. In the 2-sided model when all preference lists are strict, it 
can be shown that any stable matching is popular; thus a popular matching can be 
found in linear time using the Gale-Shapley algorithm. However when ties are allowed in 
preference lists on both sides, Bir\'o, Irving, and Manlove~\cite{BIM09} showed that the 
popular matching problem is -complete. In this paper we focus on the following 
variant:
\begin{enumerate} []
\item it is only vertices in  that have preference lists ranking their neighbors, 
however vertices on {\em both} sides cast votes.
\end{enumerate}

That is, vertices in  have no preference lists ranking their neighbors -- however each 
 desires to be matched to any of its neighbors. Thus in an election between two 
matchings,  abstains from voting if it is matched in both or unmatched in both, else it 
votes for the matching where it is matched. An intuitive understanding of such an instance 
is that  is a set of applicants and  is a set of tasks -- while each applicant has a 
preference list over the tasks that she is interested in, each task just cares to be assigned 
to anyone who is interested in performing it. 

For instance, each task is a building that seeks to have some guard assigned to it and it has no 
preferences over the identity of the guard. Another application is in the {\em many-to-one} 
popular matching problem  where each  also has a capacity  associated with 
it. Here we seek a popular matching that can match every  to up to -many 
neighbors and we need to devise natural and succinct rules to decide when  prefers one subset 
over another. A possible model is to say that  just cares to have enough partners in the 
matching and it does not care about the identities of these partners. That is, we say  
prefers  to  if , where  is the number of 
partners of  in~. 

In this paper we deal with the one-to-one setting of the above problem, i.e.\ 
for all . We will see in 
Section~\ref{sec:prelims} that this problem is significantly different 
from the popular matching problem in the 1-sided model where vertices in  do not cast votes.  
We show the following results here, complementing our polynomial time algorithm in 
Theorem~\ref{thm:popular} with our hardness result in Theorem~\ref{thm:nphard}.

\begin{theorem}
\label{thm:popular}
Let  be a bipartite graph where each  has a strict preference list 
while each  puts all its neighbors into a single tie. The popular 
matching problem in  can be solved in  time, where .
\end{theorem}

\begin{theorem}
\label{thm:nphard}
Let  be a bipartite graph where each  has a strict preference list 
while each  either has a strict preference list or puts all its neighbors into a single 
tie. The popular matching problem in  is -complete. 
\end{theorem}
 
Theorem~\ref{thm:nphard} follows from a simple reduction from the \textsc{(2,2)-e3-sat} problem. The \textsc{(2,2)-e3-sat} problem takes as its input a Boolean formula  in CNF, where each clause contains three literals and every variable appears exactly twice in unnegated form and exactly twice in negated form in the clauses. The problem is to determine if  
is satisfiable or not. This problem is -complete~\cite{BKS03} and our reduction shows that the following
version of the 2-sided popular matching problem in  with 1-sided ties is -complete: 
\begin{itemize}
\item every vertex in  has a strict preference list of length 2 or 4;
\item every vertex in  has either a strict preference list of length~2 or a single tie of length~2 or 3 as a preference list.
\end{itemize}
Note that our -hardness reduction needs  to have  vertices with 
strict preference lists and  vertices with single ties as their preference lists.

Our algorithm that proves Theorem~\ref{thm:popular} performs a partition of the set  into three sets: 
the first set  is a subset of top posts and, roughly speaking, the second set  consists of 
{\em mid-level} posts, while the third set  consists of {\em unwanted} posts 
(see Fig.~\ref{fig:next}). Applicants get divided into two sets: the set of those with one or 
more neighbors in the set  (call this set ) and the rest (this set is 
).  

Our algorithm performs the partition of  into , and  over several iterations. 
Initially , where  is the set of top posts, , and .
In each iteration, certain top posts get {\em demoted} from  to  and certain non-top 
posts get demoted from  to~. With new posts entering , we also have applicants
moving from  to . Using the partition  of 
, we will build a graph  where each applicant keeps at most two edges: either 
to its most preferred post in  and also in  or to its most preferred post in  and 
also in~. Some dummy posts may be included in~.

We prove that  admits a popular matching if and only if  admits an -complete matching,
i.e.\ one that matches all vertices in~. We show that corresponding 
to any popular matching in , there is a partition  of  into 
{\em top posts}, {\em mid-level posts}, and {\em unwanted posts} such that  
and , where  is the partition computed by our algorithm.
This allows us to show that if  does not admit an -complete matching, then  has no 
popular matching. In fact, not every popular matching in  becomes an -complete matching 
in  (Section~\ref{sec:algo} has such an example). However it will be the case that if  
admits popular matchings, then at least one of them becomes an -complete matching in~.



\medskip

\noindent{\bf Background.\ \ } Popular matchings have been well-studied in the 1-sided model 
\cite{AIKM05,KN08,Mah06,MS06,MI09,Mes06} where only vertices of  have preferences and cast votes. 
Abraham et al.~\cite{AIKM05} gave efficient algorithms to determine if a given instance admits a 
popular matching or not -- their algorithm also works when preference lists of vertices in  admit ties. 
The notions of {\em least unpopular} matchings~\cite{McC06} and popular {\em mixed} matchings~\cite{KMN09} 
were also proposed to deal with instances that had no popular matchings.

G\"ardenfors~\cite{Gar75}, who introduced the notion of popular matchings, considered
this problem in the domain of 2-sided preference lists. In any instance  
with 2-sided strict preference lists, a stable matching is actually a minimum size popular matching
and efficient algorithms for computing a maximum size popular matching were given in~\cite{HK11,Kav12}. 

\medskip

\noindent{\bf Organization of the paper.} Section~\ref{sec:prelims} has preliminaries.
Section~\ref{sec:algo} contains our algorithm and its proof of correctness. Section~\ref{sec:hardness}
shows our -hardness result. We conclude with some open problems.

\section{Preliminaries}
\label{sec:prelims}

For any , let  denote 's most desired, first choice post. Let  be the set of these top posts. We will refer to posts in  as -posts and to those in 
 as non--posts. For any , let  be the rank of 's most 
preferred non--post in 's preference list; when all of 's neighbors are in , we 
set . The following theorem characterizes popular matchings in the 
1-sided voting model. 
\begin{theorem}[from \cite{AIKM05}]
\label{thm1}
Let  be an instance of the 1-sided popular matching problem, where each 
 has a strict preference list.
Let  be any matching in~.  is popular if and only if the following two properties are 
satisfied:
\begin{enumerate} [(i)]
\item  matches every  to some applicant  such that ;
\item  matches each applicant  to either  or its neighbor of rank~.
\end{enumerate}
\end{theorem}

Thus the only applicants that may be left unmatched in a popular matching here are those 
 that satisfy .

Let us consider the following example where  and : 
both  and  have the same preference list which is  ( followed by 
) while 's preference list is  (see the top left figure in 
Fig.~\ref{fig:AppA}). Assume first that only applicants cast votes.
The only posts that any of  can be matched to in a popular matching here 
are  and~.  As there are three applicants and only two possible partners 
in a popular matching, there is no popular matching here. However in our 2-sided voting model, 
where posts also care about being matched and all neighbors are in a single tie, 
we have a popular matching . Note that  is ranked third 
in 's preference list, which is worse than , however such edges are permitted 
in popular matchings in our 2-sided model.

Consider the following example (see the middle figure in Fig.~\ref{fig:AppA}):  
and ; both  and  have the same preference list which is  
while 's preference list is  and 's preference list is . There 
is again no popular matching here in the 1-sided model, however in our 2-sided voting model, we have 
a popular matching . Note that  and here it is 
matched to  and ; also  is matched to its second ranked post: this 
is neither its top post nor its  -th ranked post ( here).

Thus popular matchings in our 2-sided voting model are quite different from the 
characterization given in Theorem~\ref{thm1} for popular matchings in the 1-sided model. Our 
algorithm (presented in Section~\ref{sec:algo}) uses the following decomposition.

\paragraph{Dulmage-Mendelsohn decomposition~\cite{dulmage}.} Let  be a maximum matching in 
a bipartite graph . Using , we can partition  into three 
disjoint sets: a vertex  is \emph {even} (similarly, \emph {odd}) if there is an even 
(resp., odd) length alternating path with respect to  from an unmatched vertex to~.
Similarly, a vertex  is \emph {unreachable} if there is no alternating path from an 
unmatched vertex to~. Denote by , , and  the sets of 
even, odd, and unreachable vertices, respectively. The following properties (proved 
in~\cite{GGL95}) will be used in our algorithm and analysis.
\begin{itemize}
\item , , and  are pairwise disjoint. Let  be any
maximum matching in  and let , , and  be the sets 
of even, odd, and unreachable vertices with respect to , respectively. Then , , and .
\item Every maximum matching  matches all vertices in  and 
has size . In , every vertex in  is matched 
with some vertex in , and every vertex in  is matched with another 
vertex in~. 
\item The graph  has no edge in .
\end{itemize}

\section{Finding popular matchings in a 2-sided voting model}
\label{sec:algo}
The input is  where each applicant  has a strict preference list 
while each post  has a single tie as its preference list. Our algorithm below builds 
a graph  using a partition  of  that is 
constructed in an iterative manner.
Initialize , , and . 

For any , recall that  is the rank of 's most preferred non--post.
For any , let  (similarly, ) denote the set of neighbors in 
 (resp., in ) of the vertices in~. Note that our algorithm will maintain
 by ensuring that . 


\begin{enumerate}[(I)]
\item While  do
\begin{enumerate}[1.]
\setcounter{enumii}{-1}
\item  is the empty graph on .
\item For each  do: 

-- if  then add the edge  to~.

\item For every  that is isolated in~ do: 

-- delete  from  and add  to~.

\item For each  do: 

-- let  be 's most preferred post in the set ; if the rank of  in 's preference 
list is  (i.e.\  or better), then add  to~.

\item Consider the graph  constructed in steps~1-3.  Compute a maximum matching in~. 
{\em [This is to identify ``even'' posts in~.]}
\begin{itemize}
\item If there exist even posts in~ then delete all even posts from  and add them 
to~.
\item Else quit the While-loop.
\end{itemize}
\end{enumerate}

\smallskip

\item Every  adds the edge  to  where  is 's most preferred post 
in the set~. 

\smallskip

\item Add all posts in  to , where 
 is the {\em dummy} last resort post of applicant~. For every applicant  such that 
, add the edge  to~. 
\end{enumerate}

Note that
introducing dummy posts does not interfere with the voting for popular matchings because 
dummy posts do not vote -- they are only present in the 
``helper'' graph  constructed above and not in the popular matching instance~. For any
applicant , being matched to  is equivalent to  being left unmatched. Thus any 
matching  in  can be projected to a matching in , by deleting all  
edges from  and for convenience, we will refer to the resulting matching also as .


The condition for exiting the While-loop ensures that all posts in , and hence 
all in , are odd/unreachable in the subgraph of  with the set of posts 
restricted to {\em real} posts in  (i.e.\ the non-dummy ones). So starting 
with a maximum matching in this subgraph and augmenting it after adding the edges on 
posts in  in phase~(II) and the edges on dummy posts in phase~(III), we get a maximum matching 
in  that matches all real posts in~. After the construction of , our 
algorithm for the popular matching problem in  is given below.
\begin{itemize}
\item If  admits an -complete matching, then return one that matches all real posts 
in~; else output `` has no popular matching''.
\end{itemize}


In the rest of this section, we prove the following theorem.

\begin{theorem} 
\label{thm:correctness}
 admits a popular matching if and only if  admits an -complete matching, i.e.\ one 
that matches all vertices in~.
\end{theorem}


\subsubsection{Some examples.}

We present some examples here and describe how our algorithm builds the graph  on these examples. 
Let  denote the sets 
 at the end of the -th iteration of our algorithm and let  denote
the graph  in step~4 of the -th iteration of our algorithm.



\tikzstyle{vertex} = [circle, draw=black, fill=black, inner sep=0pt,  minimum size=5pt]
\tikzstyle{edgelabel} = [circle, fill=white, inner sep=0pt,  minimum size=15pt]
\begin{center}
\begin{figure}[h!]
\centering
	\pgfmathsetmacro{\d}{2}
	\pgfmathsetmacro{\b}{3.6}
\begin{minipage}{0.28\textwidth}
\centering
\begin{tikzpicture}[scale=0.9, transform shape]

	\node[vertex, label=below:] (a1) at (0,0) {};
	\node[vertex, label=below:] (a2) at () {};
	\node[vertex, label=below:] (a3) at () {};
	\node[vertex, label=below:] (b1) at (\b,0) {};
	\node[vertex, label=below:] (b2) at () {};
	\node[vertex, label=below:] (b3) at () {};

	\draw [very thick, red, dotted] (a1) -- node[edgelabel, near start] {1} (b1);
	\draw [] (a1) -- node[edgelabel, near start] {2} (b2);
	\draw [] (a2) -- node[edgelabel, near start] {1} (b1);
	\draw [very thick, red, dotted] (a2) -- node[edgelabel, near start] {2} (b2);
	\draw [] (a3) -- node[edgelabel, near start] {1} (b1);
	\draw [] (a3) -- node[edgelabel, near start] {2} (b2);
	\draw [very thick, red, dotted] (a3) -- node[edgelabel, near start] {3} (b3);

	\node[vertex, label=below:] (A1) at () {};
	\node[vertex, label=below:] (A2) at () {};
	\node[vertex, label=below:] (A3) at () {};
	\node[vertex, label=below:] (B1) at (\b,-6) {};
	\node[vertex, label=below:] (B2) at () {};
	\node[vertex, label=below:] (B3) at () {};

	\draw [] (A1) -- node[edgelabel, near start] {1} (B1);
	\draw [] (A1) -- node[edgelabel, near start] {2} (B2);
	\draw [] (A1) -- node[edgelabel, near start] {3} (B3);
	\draw [] (A2) -- node[edgelabel, near start] {1} (B1);
	\draw [] (A2) -- node[edgelabel, near start] {2} (B2);
	\draw [] (A2) -- node[edgelabel, near start] {3} (B3);
	\draw [] (A3) -- node[edgelabel, near start] {1} (B1);
	\draw [] (A3) -- node[edgelabel, near start] {2} (B2);
	\draw [] (A3) -- node[edgelabel, near start] {3} (B3);

\end{tikzpicture}
\end{minipage}\hspace{0.7cm}\begin{minipage}{0.28\textwidth}
\centering
\begin{tikzpicture}[scale=0.9, transform shape]

	\node[vertex, label=below:] (a1) at (0,0) {};
	\node[vertex, label=below:] (a2) at () {};
	\node[vertex, label=below:] (a3) at () {};
	\node[vertex, label=below:] (a0) at () {};
	\node[vertex, label=below:] (b1) at (\b,0) {};
	\node[vertex, label=below:] (b2) at () {};
	\node[vertex, label=below:] (b0) at () {};
	\node[vertex, label=below:] (b3) at () {};

	\draw [very thick, red, dotted] (a1) -- node[edgelabel, near start] {1} (b1);
	\draw [] (a1) -- node[edgelabel, near start] {2} (b2);
	\draw [] (a2) -- node[edgelabel, near start] {1} (b1);
	\draw [very thick, red, dotted] (a2) -- node[edgelabel, near start] {2} (b2);
	\draw [] (a3) -- node[edgelabel, near start] {1} (b1);
	\draw [] (a3) -- node[edgelabel, near start] {3} (b2);
	\draw [very thick, red, dotted] (a3) -- node[edgelabel, near start] {2} (b0);
	\draw [] (a0) -- node[edgelabel, near start] {1} (b0);
	\draw [very thick, red, dotted] (a0) -- node[edgelabel, near start] {2} (b3);
	
\end{tikzpicture}
\end{minipage}
\hspace{0.7cm}\begin{minipage}{0.28\textwidth}
\begin{tikzpicture}[scale=0.9, transform shape]

	\node[vertex, label=below:] (a1) at (0,0) {};
	\node[vertex, label=below:] (a2) at () {};
	\node[vertex, label=below:] (a3) at () {};
	\node[vertex, label=below:] (x1) at () {};
	\node[vertex, label=below:] (x2) at () {};
	\node[vertex, label=below:] (b1) at (\b,0) {};
	\node[vertex, label=below:] (b2) at () {};
	\node[vertex, label=below:] (b3) at () {};
	\node[vertex, label=below:] (y1) at () {};
	\node[vertex, label=below:] (y2) at () {};
	\node[vertex, label=below:] (y3) at () {};
	
	\draw [very thick, red, dotted] (a1) -- node[edgelabel, near start] {1} (b1);
	\draw [very thick, green, dashed] (a1) -- node[edgelabel, near start] {2} (b2);
	\draw [very thick, green, dashed] (a2) -- node[edgelabel, near start] {1} (b1);
	\draw [very thick, red, dotted] (a2) -- node[edgelabel, near start] {3} (b2);
	\draw [] (a2) -- node[edgelabel, very near start] {2} (y1);
	\draw [] (a3) -- node[edgelabel, very near start] {1} (b1);
	\draw [] (a3) -- node[edgelabel, near start] {2} (b2);
	\draw [very thick, green, dashed] () -- ();
	\draw [very thick, red, dotted] (a3) -- node[edgelabel, near start] {3} (b3);
	\draw [very thick, green, dashed] (x1) -- node[edgelabel, near start] {1} (y1);
	\draw [very thick, red, dotted] (x1) -- node[edgelabel, near start] {2} (y2);
	\draw [] (x1) -- node[edgelabel, near start] {3} (y3);
	\draw [very thick, red, dotted] (x2) -- node[edgelabel, near start] {1} (y1);
	\draw [very thick, green, dashed] (x2) -- node[edgelabel, near start] {2} (y2);
\end{tikzpicture}
\end{minipage}

\caption{We have 4 examples here: except for the graph in bottom left, all the other graphs admit popular matchings and these are highlighted. In the graph on the extreme right, both the red  dotted and green dashed matchings are popular, however the matching  in their union is {\em not} popular.}
\label{fig:AppA}
\end{figure}
\end{center}

In the first example (top left of Fig.~\ref{fig:AppA}), we have  and  
and the preferences of applicants are denoted on the edges.  By our initialization, we have , 
, and . In step~4 of our first iteration, we identify  as an even post in~. 
So  and . In the second iteration,  and so it has no edge to  in~. 
This is the last iteration of our algorithm. Our final graph  has the edge set 
.

While the above example admits a popular matching,
consider the graph in the bottom left of Fig.~\ref{fig:AppA}. The first iteration of our algorithm is exactly the same
on this graph as it was with the earlier graph. We have , , and .
However in the second iteration, all the applicants  become elements of  and  becomes an isolated vertex
in step~2, so  becomes an element of~. In step~4 of the second iteration,  is identified as an even post in  
as it is isolated in~.  So  and . No demotions happen in the third iteration, 
which is the last iteration of our algorithm. Our final graph  has the edge set . Observe that  has no 
-complete matching.

\smallskip

In the third example (middle of Fig.~\ref{fig:AppA}), we have  and  
and the preferences of applicants are again denoted on the edges. In step~4 of the first iteration of this algorithm, the post 
is identified as an even vertex in  and it becomes an element of~. So  and  becomes isolated in step~2 
of the second iteration. So  becomes an element of   and this is the last iteration of our algorithm. 
Our final graph  has the edge set . 
This graph admits an -complete matching .

\smallskip

The fourth example here (the rightmost graph in Fig.~\ref{fig:AppA}) is that of a  graph  with several popular matchings. 
It is not the case that  contains all these matchings.  At the end of our entire algorithm, we have , ,
and . The graph  does not contain the edges  and  since  and  belong to~. 
The subgraph  admits an -complete matching  and this is a popular matching in~.
However  does not contain , , which is another popular matching in~.
In fact, any subgraph that contains both  and  would also contain the following -complete matching
, which is {\em not} popular.



\subsection{Proof of Theorem~\ref{thm:correctness}: the sufficient part} 
\label{sec:suff}

We first show that if  admits an -complete matching, then 
 admits a popular matching. We have already observed that if  admits an -complete matching, then  has an -complete matching  that matches all real posts in~.

A useful observation is that . This is because in step~4 of the 
While-loop in our algorithm, all -posts in  are odd/unreachable in  as they are the 
only neighbors in  of applicants who regard them as -posts.

We now assign edge labels in  to all edges in~:
for an edge  in , if  prefers  to , 
then we label this edge , else we label this~. The label of  is basically 's 
vote for  vs~. Fig.~\ref{fig:next} is helpful here.

\begin{figure}[h]
\centerline{\resizebox{0.65\textwidth}{!}{\begin{picture}(0,0)\includegraphics{revised-fig1.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(11824,10551)(1059,-9814)
\put(6796,-736){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6931,-4336){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6886,-7801){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1081,-4741){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1171,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12421,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8326,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8236,-7801){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8056,-3931){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12376,-3931){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(12421,-7711){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}% }}
\caption{The set  gets partitioned into , and~.  We have . In the figure on the right, the horizontal edges  belong to~. Only the edges of  can be labeled~.}
\label{fig:next}
\end{figure}



For any , let  be the set of applicants matched in  
to posts in~. The following lemma is important. 

\begin{lemma}
\label{lem:edge-signs}
Every edge of  in  is labeled~; similarly, every edge in  
is labeled~. Any edge labeled~ has to be either in  or in 
.
\end{lemma}
\begin{proof}
Every edge of  that is present in  is a top ranked edge. Since 
 belongs to , the edges of  from  are top ranked edges. Thus it is 
clear that every edge of  in  is labeled~. Regarding , 
every edge of  that is present in the graph  is an edge  where the 
rank of  in 's preference list is  (i.e.\  or better); on the other hand, 
every edge of  that is present in the graph  is an edge  
where the rank of  in 's preference list is  (because ). 
Since  belongs to , the edges of  from  are ranked better than the edges 
of~. Thus every edge of  in  is labeled~.

We now show that any edge labeled~ has to be in either   or
 (see Fig.~\ref{fig:next}). Consider any edge  
such that  and , where . It follows from the 
construction of the graph  that a vertex in  can be adjacent in  to only its most 
preferred post in~. Thus any edge  where  and  is 
ranked~. We have already seen that all edges in  and in  are 
labeled~. There are no edges in  since . 
Thus any edge labeled~ has to be in either   or . \qed
\end{proof}



Let  be any matching in~. The symmetric difference of  and  is denoted by 
: this consists of alternating paths and alternating cycles -- note that
edges here alternate between  and~. 
Recall that last resort posts are not used in~ (which is a matching in ) 
whereas last resort posts may be present in~ (which is a matching in ). 

\begin{lemma}
\label{lem:1-3}
Consider . The following three properties hold:
\begin{enumerate}[(i)]
\item\label{le2i} in any alternating cycle in  , the number of edges that are 
labeled~ is at least the number of edges that are labeled~.
\item\label{le2ii} in any alternating path in , the number of edges that are 
labeled~ is at most {\em two plus} the number of edges that are labeled~; in case one 
of the endpoints of this path is a last resort post, then the number of edges labeled~ is 
at most {\em one plus} the number of edges labeled~.
\item\label{le2iii} in any even length alternating path in , the number of edges 
that are labeled~ is at least the number of edges that are labeled~;
in case one of the endpoints of this path is a last resort post, then
the number of edges labeled~ is at least  {\em one plus} the number of edges labeled~.
\end{enumerate}
\end{lemma}
\begin{proof}
\noindent{\em Property~(\ref{le2i}).} Let  be an alternating cycle. Let  be 
-------, 
where  for . If  contains no vertex of , then there cannot
be two consecutive non-matching edges labeled~ in~. That is, if  is 
labeled~, then  and there is no  edge incident on , thus the non-matching edge incident on  
in  has to be labeled~. Hence the number of edges that are labeled~ is at least the number of edges 
that are labeled~.

Suppose  contains a vertex of~: let  be such a vertex. There can be two consecutive non-matching edges labeled~ now: let ---- be such an alternating path within , where both  and  are labeled~. Then , , and . In the first place, there is no  edge incident on  and the crucial part is that there is {\em no} edge in  between a vertex in  and a vertex in~. Thus once we reach a vertex , we have to see an edge labeled   and so as to reach a vertex in , we need to see at least {\em two} consecutive non-matching edges labeled~. Thus it again follows that the number of edges that are labeled~ is at least the number of edges that are labeled~.

\medskip

\noindent{\em Property~(\ref{le2ii}).} Let  be an alternating path. Let  be
--------, where  for 
. The same argument that was used in the proof of property~(\ref{le2i}) shows us that 
there can be at most two consecutive non-matching edges labeled~ in  and once we 
traverse such an alternating path ---- in  (where  
has to be in ), we are at a vertex~. Thereafter we have to see at least two more 
non-matching edges 
labeled~ than those labeled~ to again reach a vertex in~. Thus it follows that the 
difference between the number of edges that are labeled~ and the number of edges that are 
labeled~ is at most two.
 
In fact, for the difference between the number of edges that are labeled~ and the number of 
edges that are labeled~ to be exactly two, it has to be the case that  is in~. For, in 
case  is in , then it is easy to see that the difference between the number of 
non-matching edges that are labeled~ and the number of non-matching edges that are labeled 
 is at most one. Note that all last resort posts belong to~. Thus when  is a last 
resort post, then the number of edges labeled~ in  is at most {\em one plus} the 
number of edges labeled~.

\medskip

\noindent{\em Property~(\ref{le2iii}).} Let ------- be an 
even length alternating path where  for . The post  is unmatched in  
and  is unmatched in~. Recall that  is -complete, thus any even length alternating path with 
respect to  has to have vertices in  as its endpoints (since one of them is left unmatched in~). 
Since  is a post that is matched in  but not in , it follows that  (as all non-dummy 
posts in  are matched in~).

Now the argument is similar to the proof of property~(\ref{le2ii}). In order to maximize the difference between 
the number of edges labeled~ and those labeled~, we assumed that the starting vertex . For the 
final vertex  to be in , it follows that the number of edges that are labeled~ is at least the number 
of edges that are labeled~. In particular, when  is a last resort post, then the starting vertex is in  
and so the number of edges that are labeled~ is at least {\em one plus} the number of edges that are labeled~. \qed
\end{proof}

Lemma~\ref{new-cor} uses the above lemma to show the popularity of~. This completes the proof that if  admits an 
-complete matching then  admits a popular matching.

\begin{lemma}
\label{new-cor}
For any matching  in , we have .
\end{lemma}
\begin{proof}
Recall that  is -complete (where some of the posts used in  
can be last resort posts). For any  and any neighbor  of  such that , let  
be the label of the edge , which is 's vote for  vs~. Consider . We will now investigate each component of  -- being a cycle, an odd path or an even path -- and show  for each of them.
\begin{itemize}
\item For any alternating cycle , among the vertices of , the difference between those who prefer 
 and those who prefer  is equal to . It follows from property~(\ref{le2i}) 
that this sum is at most 0.

\item Consider any odd length alternating path : its endpoints are an applicant  and a post  that are 
unmatched in~. Assume  is a non-dummy post. Then among the vertices of  that are matched in , the difference between 
those who prefer  and those who prefer  is equal to . It follows from 
property~(\ref{le2ii}) that this sum is at most~2. The two vertices  and  prefer  to  as they are matched in  and 
unmatched in , since  is unmatched in~. Thus summed over all vertices of , the difference between those who prefer  and those who prefer  is 
again at most 0.

Now suppose  is a dummy post. Then it follows from property~(\ref{le2ii}) that among the vertices of  that are matched in 
, the difference between those who prefer  and those who prefer  is at most 1. The vertex  prefers  to~. Thus 
summed over all real vertices of , the difference between those who prefer  and those who prefer  is again at most 0.

\item Consider any even length alternating path : its endpoints are a post  that is unmatched in  
and a post  that is unmatched in~. Assume  is a non-dummy post. Then summed over all vertices of  
(this includes  who prefers  and  who prefers ), the difference between those who prefer  and those who prefer  
is at least 0 (by property~(\ref{le2iii})). 

Now suppose  is a dummy post.  Then summed over all real vertices of  that are matched in , the difference between those 
who prefer  and those who prefer  is at least 1 (by property~(\ref{le2iii})). Thus summed over all real vertices of  
(this includes  who prefers ), the difference between those who prefer  and those who prefer  is at least 0.
\end{itemize}
All vertices whose partners in  and in  are different belong to some alternating path or cycle in~. Hence 
the difference between the number of vertices that prefer  and those that prefer  is non-negative. In other words, 
. \qed
\end{proof}



\subsection{Proof of Theorem~\ref{thm:correctness}: the necessary part}
We now show the other side of Theorem~\ref{thm:correctness}. That is, if  admits a popular 
matching, then  admits an -complete matching. Let  be a popular matching in~. 
Lemma~\ref{lem:pop-mat} will be useful to us.
\begin{lemma}
\label{lem:pop-mat}
If  and , then  has rank better than  in 's preference list.
\end{lemma}
\begin{proof}
Suppose , where , and  has rank worse than  in 's preference list. Note that the rank of  cannot be exactly  since there is another 
post  that has rank  in 's preference list. We know that  prefers post 
 to~. If post  is unmatched, then consider  where ----, where  is an applicant such that  (there exists such an applicant since ). The matching  is more popular than~. 

So suppose the post  is matched and let . If , then consider the alternating cycle 
----; the matching  makes  and  swap their partners and both applicants prefer
 to  while nobody prefers  to~. Thus  is more popular than~.
If , then consider the alternating path  that promotes  to its top post  and then  to a more 
preferred post  and finally,  to its top post~.
The vertices  and  become unmatched in  and so they prefer  
to   while the three vertices , and   prefer  to~. 
Every other vertex is indifferent between  and~.
So  is more popular than~. Thus we have contradicted the popularity of  in all the cases. \qed
\end{proof}


Analogous to Section~\ref{sec:suff}, we label the edges of  by  or~: the label of an edge  in 
 is the vote of  for  vs~. In case  is not matched in , 
then  for any neighbor  of~. Due to the popularity of , 
the following two properties hold on these edge labels (otherwise ).

\begin{enumerate} 
\item[] There is no alternating path  such that the edge labels in 
 are , i.e.\
no three consecutive non-matching edges are labeled~. 
\item[]  There is no alternating path  where the edge labels in 
 are , , i.e.\
no five consecutive non-matching edge labels add up to~4.
\end{enumerate}

Based on the matching  and the edge labels on , we partition  into 
. 
\begin{itemize}
\item Roughly speaking,  consists of unwanted posts, so
all posts that are unmatched in  belong to . Similarly, posts like  with a
length-5 alternating path ----- incident on them,
with both the non-matching edges labeled~ (see Fig.~\ref{fig:partition}) are in .
\item Top posts are split across  and : property~ indicates
that applicants matched to posts in  should not be adjacent to posts in ,
hence those top posts whose partners have neighbors in  are in~ and
the top posts whose partners have {\em no} neighbors in  are in~.
\end{itemize}

\begin{figure}[h]
\centerline{\resizebox{0.38\textwidth}{!}{\begin{picture}(0,0)\includegraphics{L-partition.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(6483,5212)(-14,-6893)
\put(5806,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5806,-4471){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5851,-6721){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(  1,-6766){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put( 46,-4516){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(  1,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{A length-5 alternating path -----, where both  and  are labeled~.}
\label{fig:partition}
\end{figure}


More formally, we define the partition  below.
\begin{enumerate}\setcounter{enumi}{-1}
\item Initialize  and  is unmatched in~.
We now add more posts to the sets  as described below.

\item 
For each length-5 alternating path ----- where 
 and both  and  are marked~, 
add  to~, for .

\item Now consider those  that are matched in  but  is not a part of any 
length-5 alternating path where both the non-matching edges are labeled~. We repeat the 
following two steps till there are no more posts to be added to either  or~
via these rules: 
\begin{itemize}
\item suppose  has no  edge incident on it: if , then add 
 to~. 
\item if  has a  edge to a vertex in , then add  to~. 
\end{itemize}
\item For each  such that  has no  edge incident on it: 
\begin{itemize}
\item if , then add  to~. 
\end{itemize}
\item For each  not yet in  and  has a  edge to a vertex in : 
\begin{itemize}
\item add  to~. 
\end{itemize}
\end{enumerate}


\begin{lemma}
\label{lemma-F} 
Recall that  is the set of top posts. The above partition  satisfies the following properties:
\begin{enumerate}[1.]
\item ;
\item .
\end{enumerate}
\end{lemma}
\begin{proof}
Suppose  belongs to~. The post  has to be matched 
in~. Let  and we also know from the construction of the set  that 
there is an edge  with  that is labeled~. If the vertex  is 
unmatched in , then by promoting  to  and  to , 
and leaving  unmatched, we obtain a matching that is more popular than~.

Hence let us assume that  is matched in~. Consider the alternating path 
---- with respect to~: this has two consecutive non-matching 
edges that are labeled~. Thus it follows from our construction of  that 
, , and . 
This contradicts our assumption that . This finishes the proof of (1).

\smallskip

We first state the following claim, which will be used in the proof of (2). We will assume Claim~\ref{lem:alt-path}
and finish the proof of (2) and then prove this claim.
\begin{new-claim}
\label{lem:alt-path}
If  and , then there is an alternating path  with respect to  
with  as an endpoint such that either  is even and  the edge labels on  
are  or  is odd and the edge labels on  are 
 where the last edge is incident on an unmatched post.
\end{new-claim}


We now use Claim~\ref{lem:alt-path} to show that .
Posts get added to  in steps~1 and~3 of the partition scheme. 
Let  be a post that got added to  in step~1 -- then there is an alternating path 
---- where both  and  are labeled~. 
We know from property~ that ; if , then there is 
an alternating path  as described in Claim~\ref{lem:alt-path}. If the posts  and 
 do not appear in , then 
consider the alternating path  which consists of  followed by~. It is easy 
to see that  is more popular than : a contradiction to the popularity of~. 

In case  appears in , then we have an alternating cycle , which is  
truncated till the vertex  followed by --. This cycle has a stretch of 
alternating  and  labeled non-matching edges along with two consecutive non-matching 
edges labeled~: these are the edge  and the edge incident on  in  from a vertex 
in~. Thus  is more popular than : a contradiction again. If  
appears in  , then we can again construct an alternating cycle  
(using the  subpath of  followed by the alternating path ).
The matching  is more popular than  since  
has more  labeled non-matching edges than  labeled non-matching edges. This again
contradicts the popularity of~.


Regarding posts added to  in step~3, we add any post  to  only after checking that 
. This completes the proof that . \qed
\end{proof}


\paragraph{Proof of Claim~\ref{lem:alt-path}.}
Posts are added to  in steps 1, 2 and~3. We now study each of these cases. The set  was initialized to the set of posts left unmatched in~. So at the end of step~0, it is the case that every  has an odd alternating path, which is in fact an edge  labeled~, whose one endpoint is  and the
other endpoint is an unmatched post~.

Let  be a post that got added to  in step~1. Then there is an alternating path 
----- such that  for , and both  and 
 are marked~. Thus every neighbor  with  has an even 
length alternating path ------ where the edge labels on  
are . Note that  -- otherwise  is an alternating cycle and
 is more popular than~.

Thus the claim that every  with  has a desired alternating path  is true at
the end of step~1. Let  be a post that got added to  in step~2 and
let us assume that till the point  gets added to , the claim holds.
Since  was added to  in step~2, this was due to a  edge between  
and a post  whose partner  regards  as a top post. 
The post  because its partner . 
This means there is a desired alternating path  incident on~.
Neither  nor  lies on  since all the posts in  that belong to 
 were added to  prior to  joining  and  joining~. 
Consider any neighbor  of  that is in  because  and . 
The desired alternating path  is ---- followed by~. \qed


\medskip

We will use the partition  of  
to build the following subgraph  of~. For each , 
include the following edges in~:  
\begin{itemize}
\item[(i)] if , then add the edge  to~.
\item[(ii)] if  has a neighbor of rank  in , then add the edge  to , 
where  is 's most preferred neighbor in~.
\item[(iii)] if , then add the edge  to , where  is 's most 
preferred neighbor in~.
\end{itemize}



\begin{lemma}
\label{lem:main}
Every edge of the matching  belongs to the graph~.
\end{lemma}
\begin{proof}
The set  has been partitioned into . We will now show that for each post  that is matched in , the edge  belongs to~. We distinguish three cases: ,  and .

\smallskip

\noindent{\em -- Case~1.} The post . Hence there is no  edge incident on 
, in other words, .
Lemma~\ref{lemma-F}.2 tells us that ; 
hence  has no neighbor in  and by rule~(i) above, 
the edge  belongs to the edge set of~.


\smallskip

\noindent{\em -- Case~2.} Next we consider the case when .
It is easy to see that  has to be 's most preferred post in , where 
. 
Otherwise there would have been an edge  labeled~ with , 
where  is 's most preferred post in~. Then either  or
 (from how we construct the sets ), a contradiction.
We now have to show that the rank of  in 's preference list is , 
otherwise the edge  does not belong to~.

Suppose . Since the edge , which is a popular matching, it follows 
from Lemma~\ref{lem:pop-mat} that  is ranked better than  in 's preference 
list; thus the edge  belongs to~. So the case left is when . 
If  is not 's most preferred post outside , then there is the length-5 alternating 
path -----, 
where  is the most preferred post of  outside  and .
The alternating path  has two consecutive non-matching edges  and 
 that are labeled~. This contradicts the presence of  in  as such 
a post would have to be in~.
Thus if , then  has to be 's most preferred post outside , i.e.\
 has rank  in 's preference list.

\smallskip

\noindent{\em -- Case 3.} We finally consider the case when the post . 
We need to show that  is the most preferred post of  in~. 
Suppose not. 
Let  be 's most preferred post in~. Since  while  (by Lemma~\ref{lemma-F}.1), we know that there is an 
edge labeled~ incident on . Let this edge be~ and let  
be~. So there is a length-5 alternating path ----- 
where both the non-matching edges  and  are labeled~. This contradicts 
the presence of  in  as such a post would have to be in~.
Thus  is 's most preferred post in~. \qed
\end{proof}

The following lemma shows the relationship between the partition  and the partition  constructed by our algorithm that builds the graph~.
\begin{lemma}
\label{lem:L1andX}
The set  and the set .\end{lemma}
\begin{proof}
In our algorithm that constructs the graph  and the partition , the 
set  is initialized to  and the set  is initialized to~. As our algorithm 
progresses, in each iteration of the While-loop, some -posts get demoted from  to  and similarly, 
some non--posts get demoted from  to  till there is an iteration (say, iteration ) where all 
posts in  are odd/unreachable in  -- this is the last iteration of the While-loop. 

For any ,  let  (similarly, ) be the set of posts that got 
demoted from  to  (resp.,  to ) in the -th iteration of the While-loop in our algorithm. We have .


Note that  since  is initialized to , so
in the first iteration of our algorithm, {\em every} -post  has a neighbor  such that . 
Thus no post is demoted from  to  in the first iteration. 

The graph  is the subgraph of  where each  has at most two neighbors: 
its top post and when , its neighbor of rank~. 
Let  be the set of posts in  that are odd/unreachable in the graph~. 
The set  is the set of even non--posts in~,
i.e.\ . 

We will use the following claims and finish the proof of this lemma
(the proofs of Claims~\ref{lemma-T}-\ref{lem:Z1} are given after the proof of Lemma~\ref{lem:L1andX}).


\begin{new-claim}
\label{lemma-T}
The set .
\end{new-claim}

\begin{new-claim}
\label{lem:F1}
For any , if  then .
\end{new-claim}


\begin{new-claim}
\label{lem:Z1}
For any , if  then . 
\end{new-claim}

Claim~\ref{lemma-T} tells us that . We now use Claims~\ref{lem:F1} and \ref{lem:Z1} 
alternately to conclude that for
every , we have  and .

\smallskip

Thus the set  is a subset of  and the set  
is a subset of~. Since , it follows that . \qed
\end{proof}


\paragraph{Proof of Claim~\ref{lemma-T}.}
Any post in  that is left unmatched in  has to belong to~. Similarly, any  that is
matched to an applicant  that ranks  worse than  has to belong to~: this is 
because there is a length-5 alternating path ----- where  is a post of rank  
in 's preference list, , and . The path  has
two consecutive non-matching edges that are labeled~, so .

Now consider any  that is matched in  to an applicant  such that the rank of 
 is~. So  is a neighbor of  in~.
Since  is even in , all the neighbors of  in  are odd and thus they have to be of
degree {\em exactly} 2 in  (recall that  all applicants have degree at most 2 in ).
Thus the neighbors of these applicants are again even. Let   be the connected component containing  
in~. It is easy to see that in , all posts are even, all applicants are odd, and the
number of posts is more than the number of applicants. (In fact,  is a tree with  as the root and  
the number of posts in  is {\em one} plus the number of applicants in~.)

If , then 's other neighbor in , which is , has to be in  since
there is a  edge from  to~. This means  is matched to an applicant  that ranks
it as a top post, so the applicant  is a neighbor of  in~. There has to be another
neighbor of  in , call this~. The important observation is that  cannot be in  as that would
violate Lemma~\ref{lemma-F}.2 since . So  and this means  is matched to an
applicant  that ranks it , in other words,  is a neighbor of  in~. So  has to be in  
and we continue in this manner marking all -posts in  as elements of  and all non--posts in  as elements 
of~. 

This means all posts in  are matched to their neighbors in , however this is not possible as there are more posts 
than applicants in~.  This contradicts our assumption that , in other words,  has to be in~. Thus 
. \qed




\paragraph{Proof of Claim~\ref{lem:F1}.}
The set  is the set of posts that got 
demoted from  to  in the -th iteration of the While-loop: this means each post  
in  had no applicant outside  that regarded  as an -post. 
In other words, every applicant  such that  belongs to . 
Since , each such applicant  is present in~. 

\smallskip

Let . For , let : 
if , then  (because ); 
else there is an edge  that is labeled~ incident on  and hence  
cannot be in~. Thus , i.e.\  (by 
Lemma~\ref{lemma-F}.1). \qed




\paragraph{Proof of Claim~\ref{lem:Z1}.}
Let us assume that we have proved Claim~\ref{lem:Z1} for all smaller values of~. That is, for , we have
shown that if  then the set . This is indeed the case for 
since we know  (by Claim~\ref{lemma-T}).
Using Claim~\ref{lem:F1} and Claim~\ref{lem:Z1} (for ) alternately now, it follows that 
 for . Thus . We will now show that  is a subset of~.

\smallskip


Let  denote the graph  in step~4 in the -th iteration of the While-loop in our 
algorithm. This is the graph where we determine the even posts that will get demoted from 
 to~. In step~4 of the -th iteration of the While-loop, the set  
(call this set ),  (call this set ), and let  be the set of posts 
outside~. The edge set of  is as follows: 
\begin{itemize}
\item for each : if the rank of 's most preferred post  in  is , then the 
edge  belongs to 
\item for : the edge~ is also present in~.
\end{itemize}

Let us refer to posts in  
as {\em -posts}: recall that these are odd/unreachable non--posts in the graph~.
We will now show that all -posts in  are odd/unreachable in ;
so every -post that is even in  has to be in , in other words, . 
Let  be the subgraph of  with the set of posts restricted to  
(see Fig.~\ref{fig:last-claim}).
Consider the subgraph  of  obtained by deleting edges missing in  from~.

We now show that  contains all edges in  incident on -posts in~. 
This is because any edge  incident on an -post  in  is present 
in  also. Since the edge  belongs to , the post  has to be ranked  
in 's preference list and there is no -post in  of rank better than  in 's 
list. If the edge  does not exist in , then it means there is some -post in 
 that  prefers to~. All -posts in  are in  and we are given 
that . Since we know there is no -post in  that  
prefers to , it follows that  has to be 's most preferred post in  and so the 
edge  belongs to~. Thus , whose edge set is the intersection of the edge sets 
of  and , contains all edges in  incident on -posts in~. 

\begin{figure}[h]
\centerline{\resizebox{0.27\textwidth}{!}{\begin{picture}(0,0)\includegraphics{claim6-fig.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4341,5421)(3793,-6844)
\put(5626,-2446){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5311,-4201){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5356,-6046){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{The set of posts in  can be viewed as . 
All -posts in  are in .}
\label{fig:last-claim}
\end{figure}




Every post in  is odd/unreachable in  since the matching  restricted 
to the edge set of  is -complete. We have shown that  contains all 
edges in  incident on -posts in : thus all -posts in  
are odd/unreachable in~. It is easy to see that all {\em top-ranked} edges in 
 incident on -posts in  are also present in : each such post has 
a degree~1 neighbor in , thus all -posts in  are also odd/unreachable 
in~.

We now claim that all posts in  are also odd/unreachable in~. We first show that 
all edges incident on  in  are present in~. This is because each edge  
in  such that  is incident on an applicant  such 
that  and we know the graph  has  edges for all 
 since 
.


In , each vertex  either has a degree~1 neighbor (in which case our claim is 
true) or it has a degree~2 neighbor  whose other neighbor is in , i.e.
it is not in . This is because  cannot have 2 neighbors in  in the graph 
 and we know  since all -posts missing in  (these are posts in 
) are absent from  also. Since all posts in  
are odd/unreachable in~, it follows that all posts in  are also odd/unreachable 
in~.

\smallskip

Let us now compare the graph  with the graph~. The graph  has additional 
vertices: these are the ones in  and the new edges in  (new relative to )
 belong to the following two classes: (i)~
and (ii)~. This is because every edge incident on 
 in  (these are all top-ranked edges) is present in  as well. 

Consider any new edge  in  of type~(i), 
i.e.\ . Since  belongs to , it must be 
the case that 's most preferred neighbor in  is~. So the post  is
ranked  in 's list and  has no neighbor of rank better than  in~. 
Recall that  has no edge in  . So the only edge that can be incident 
on  in the graph  is an edge to  in . 

Consider any connected component  in  that contains an -post in : every post 
here belongs to either  or , in other words, there is no post in 
 here. This is because there is no applicant  in  with neighbors in 
 and   as this means  has two neighbors in , which  is 
forbidden in~. 
Similarly, there is no applicant  in  with neighbors in  and 
 as this means  has two neighbors in , which  is forbidden in~. 
Thus  has no post from .

So the new edges in  of type~(i) do not touch components in  that contain -posts 
in~. All the new edges incident upon these components have their endpoints in 
. These posts  are already odd/unreachable in~. So these posts 
remain  odd/unreachable in~. Hence every -post in  is odd/unreachable in~. \qed




\subsubsection*{The augmented graph .}
The matching  need not be -complete. However it would help us to assume that  is 
-complete, so we augment  by adding  edges for every  that
is unmatched in~. Recall that  is the dummy last resort post of~.
However the augmented matching  need not belong to the graph  any longer -- hence
we augment  also by adding some dummy vertices and some edges as described below. 

The augmentation of  is analogous to phase~(III) of our algorithm -- we augment  as
follows: let , where ;
if , then add  to~. Thus when compared to , 
the augmented  has some new vertices (all these are dummy last resort posts) and 
some new edges -- each new edge is of the form  where  is 's only
neighbor in .
These new edges are enough to show the following lemma.

\begin{lemma}
\label{lem:augmented}
The augmented matching  belongs to the augmented graph~.
\end{lemma}
\begin{proof}
Before the augmentations of  and , the matching  belonged to the graph~ (by Lemma~\ref{lem:main}). We now need to 
show that if  is left unmatched in  (before augmentation), then  and all of 's neighbors belong to~.

Suppose  is left unmatched in  and . 
Since , there is a post  such that the post  has rank  in 
's preference list. Consider the alternating path ----, where 
 and . The matching  matches  to  and promotes
 to its top post  and leaves  unmatched.
Thus  is more popular than , a contradiction.

So let us assume  and  was left unmatched in~. Suppose  has some neighbor  outside~. 
The post  has to be in  because , i.e.\  has no neighbors outside~. 
Since  (by Lemma~\ref{lemma-F}.1), it follows that . Let ; if 
, then we again have an alternating path ----, 
where  such that  is more popular than~.
This contradicts the popularity of~.

So suppose   and  because . We know from 
Claim~\ref{lem:alt-path} that there is a desired alternating path , where
either the last two non-matching edges are labeled~ or the last post in  
is unmatched. 
Consider the alternating path  which is the path -- followed by the path~. 
It is easy to see that  is more popular than , 
a contradiction to the popularity of~. \qed
\end{proof}

Since the augmented  is an -complete matching, it follows from Lemma~\ref{lem:augmented} 
that the augmented graph  admits an -complete matching. 
Theorem~\ref{last-lemma} uses Lemma~\ref{lem:L1andX} to show that if the augmented graph  
admits an -complete matching, then so does the graph  constructed by our algorithm. 

\begin{theorem}
\label{last-lemma}
If  does not admit an -complete matching, then the augmented graph  cannot admit an 
-complete matching.
\end{theorem}
\begin{proof}
We will use  to refer to the {\em augmented} graph  in this proof.
The rules for adding edges in  and in  are exactly the same -- the only difference is 
in the partition  on which  is based vs the partition 
 on which  is based. If , then the graphs  and  are exactly the same. 

\begin{figure}[h]
\centerline{\resizebox{0.65\textwidth}{!}{\begin{picture}(0,0)\includegraphics{fig3.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(9786,8144)(58,-8183)
\put(5896,-736){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5266,-3886){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7966,-3526){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2026,-1456){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5761,-7216){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(451,-3841){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9316,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(271,-7441){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5311,-2311){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1216,-7306){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(946,-4606){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5176,-5641){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{The part of  inside the box will be called~. 
The graph  has no edge between any applicant in  and any post in~.}
\label{fig:last-thm}
\end{figure}

Fig.~\ref{fig:last-thm} denotes how the partition  can be
modified to the partition . We know from  Lemma~\ref{lem:L1andX} 
that  and .
Consider the subgraph  of  induced on the vertex set 
 and . 
This is the part bounded by the box in Fig.~\ref{fig:last-thm}. 
In our analysis, we can essentially separate  into  and the part outside  
due to the following claim that says  has no edges between  and~.

\begin{new-claim}
\label{claim1}
 has no edge  where  and . 
\end{new-claim}
\begin{proof}
Any applicant  has to belong to either  or to 
 (see Fig.~\ref{fig:last-thm}). 
There is obviously no edge in  between a vertex in  and any vertex in~. So suppose . For , if the edge 
is in , then  has to be 's most preferred post in~. We will now show that 
, equivalently . 
Thus  has no edge  where  and .

Since , the graph  contains an edge between  and some 
. Recall that an element of  is a real post in~. 
By the rules of including edges in , it follows that the rank of  in 's preference 
list is . The entire set  cannot contain any post of rank better than  for any 
 since any post of rank better than  in 's list belongs to  while 
 (by Lemma~\ref{lemma-F}.1). So  has rank  in 's list.
Thus 's most preferred neighbor in  belongs to . \qed
\end{proof}




Let  be the subgraph of  obtained by deleting from  the edges that are absent 
in~. Thus  is a subgraph of both  and~. The following claim (whose proof is given 
after the proof of Theorem~\ref{last-lemma}) will be useful to us.

\begin{new-claim}
\label{claim2}
All posts in  are odd/unreachable in~.
Moreover, every edge  in  that is missing in  satisfies 
.
\end{new-claim}

Consider the graph  whose edge set is the intersection of the edge sets of 
and~. Equivalently,  can be constructed by adding to the edge set of ,
the edges incident on  that are present 
in both  and  (see Fig.~\ref{fig:last-thm}).
This is due to the fact that  has no edge in .  


We claim that all posts in  are odd/unreachable in~. This is because Claim~\ref{claim2} tells us that each post in this set is 
odd/unreachable in  and due to the absence of  edges in , the graph 
 has no {\em new} edge (new when compared to ) incident on the set  of 
applicants in~. Hence all posts in  remain 
odd/unreachable in~.

Claim~\ref{claim2} also tells us that all edges in  that are missing in  are incident 
on posts in . We know that all these posts are 
odd/unreachable in , hence  has no {\em new} edge (new when compared to ) on 
posts that are {\em even} in~. Thus the size of a maximum matching in  equals the 
size of a maximum matching in~. This is at most the size of a maximum matching in , 
since  is a subgraph of~. 
Hence if  has no -complete matching, then neither does~. \qed
\end{proof}

\paragraph{Proof of Claim~\ref{claim2}.}
We will now show that all posts in  are odd/unreachable in~.
Let  be an applicant with degree~2 in the graph , let  and  be the two 
neighbors of , where  is the more preferred neighbor of~. We claim either 
(i)~ and  or
(ii)~ and .
This is because of the following.

\begin{itemize}
\item There is no applicant in  with edges to both a post in  and post in 
. If there was such an applicant , then  would have two
neighbors in the set~, which is forbidden in~. Recall that
any edge in  is an edge in  as well. 
\item There is no applicant in  with edges to both a post in  and a post in 
. If there was such an applicant , then  would have two
neighbors in the set~, which is forbidden in~. Recall that
any edge in  is an edge in  as well. 
\item There is no applicant in  with edges to both a post in  and a post in 
. If there was such an applicant , then  would have two
neighbors in the set~, which is forbidden in~.
\item There is no applicant  in  with edges to both a post in  and a post in 
. This is because  cannot contain such a pair of edges as it is only applicants 
in  that are adjacent to posts in~.
\end{itemize}

Thus in the graph , vertices in   and those in 
 belong to different connected components. 
Note that all dummy posts belong to . So none of these posts belongs to any
connected component in  that contains vertices in  .
Consider the subgraph  of ,  obtained by restricting the set of posts in  to 
{\em real} posts in . All real posts in  are odd/unreachable in~.  
Since  consists of real posts, all these posts are 
odd/unreachable in .

\smallskip

We now claim that all posts in  remain odd/unreachable in~. 
In the first place, every edge  in  incident on any vertex  
is present in  as well. This is because   and if  is the 
most preferred post in  for applicant , then the rank of  in 's preference 
list is  and thus  is also 's most preferred post in , so the edge 
 belongs to the graph~. Similarly every edge  in  incident on 
any post  is present in  as well -- this is  because  
and  has to be  for the edge  to exist in~. Thus  is also 
's most preferred post in~. Hence all edges in  incident on posts in 
 are present in~.

Let  be any post in . The connected component in  that 
contains  can be obtained by taking the connected component containing  in  and 
deleting all vertices in  from this component. Since no edge incident on 
 has been deleted here and because  is odd/unreachable in the starting component, it 
follows that  is odd/unreachable in~.

\smallskip

We will now show the second part of Claim~\ref{claim2}: every edge  in  that is 
missing in  satisfies .
We partitioned the set  of posts into five sets (refer to Fig.~\ref{fig:last-thm}). These are 
, , , , and~. We will now show that every 
edge in  that is incident on  is present in  also.
\begin{itemize}
\item Any edge  in  where  is such that  and .
Since  (by Lemma~\ref{lem:L1andX}), this means . Thus  also contains the edge~.
\item Any edge  in  where  is such that  is 's most preferred post in  and
the rank of  in 's preference list is . Note that  
(by Lemma~\ref{lemma-F}.1). Thus the rank of 's most preferred post in  is  and hence no post in 
 can be preferred to~. So the post  is, in fact, 's most preferred post in~. Thus the edge  
belongs to  as well. 
\item Any edge  in  where  is such that  is 's most preferred post in~.
Since , this means  is 's most preferred post in~. Thus  also contains the edge~. 
\end{itemize}
Thus every edge  in  that is missing in  satisfies 
. \qed

\medskip

Theorem~\ref{last-lemma}, along with Lemma~\ref{lem:augmented}, finishes the proof of the 
necessary part of Theorem~\ref{thm:correctness} and this completes 
the proof of correctness of our algorithm. We now analyze its running time.

Observe that we can maintain the most preferred posts in , and  for all 
applicants over all iterations in  time, where  is the number of edges in . 
To begin with, the most preferred non--post for all applicants can be determined in  time. Thereafter, whenever a post  moves from  to  (similarly, from  to ), we charge  a cost of the degree of  to pay for checking if any of its neighbors now has  as its most preferred post in  (resp.,~). 

Let  be the number of vertices in~. The number of iterations is  and 
the most expensive step in each iteration is finding a maximum matching in a subgraph where 
each vertex in  has degree at most~2. It is easy to see that this step can
be performed in  time. Thus the running time of our algorithm is~.
Hence we can conclude Theorem~\ref{thm:popular} stated in Section~\ref{sec:intro}.

\smallskip

There are instances on  vertices and  edges where our algorithm takes  time. 
Consider the example given in Fig.~\ref{fig:tight}: here there are  applicants and  posts and the
number of edges is~.
For each , we have  and  is the most preferred non--post for both  and~.
For , we have  and 's most preferred non--post is~.

\begin{figure}[h]
\centerline{\resizebox{0.6\textwidth}{!}{\begin{picture}(0,0)\includegraphics{tight-example.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(9916,3621)(886,-4954)
\put(2521,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3421,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4636,-3841){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6166,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7966,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6706,-3346){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1756,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5401,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1081,-3481){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4366,-2671){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6031,-2671){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8596,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7291,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7651,-3886){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8731,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(991,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2341,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7021,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5401,-4831){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(901,-1681){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4276,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2656,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{25}{30.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }}
\caption{The preferences of applicants are indicated on the edges. Our algorithm runs for  iterations here.}
\label{fig:tight}
\end{figure}


In the starting graph , there is exactly one post that is even in : this is  and 
so  moves from  to~. In the second iteration,  has no applicant in  that regards it
as a top post  and this causes the demotion of  from  to~. 
Now the post  is the most preferred post in  for  and this makes
 even in  and causes  to move from  to~. 

This makes both  and  belong to  and hence  gets isolated in  and so  moves from  to~. Now  becomes the most preferred post in  for  and this causes  to move from  to  and so on. 
Thus our algorithm runs for  iterations. This instance admits popular matchings, for instance, 
 is a popular matching here.



\section{Our -hardness result}
\label{sec:hardness}
Given a matching  in , it was shown in~\cite{BIM09} that  can be tested for popularity in 
 time (even in the presence of ties), where . We now show the -hardness 
of the 2-sided popular matching problem in  with 1-sided ties using the \textsc{(2,2)-e3-sat} problem.  

Recall that the \textsc{(2,2)-e3-sat} problem takes as its input a Boolean formula  in CNF, where each clause contains 
three literals and every variable appears exactly twice in unnegated form and exactly twice in negated form in the clauses. The problem 
is to determine if  is satisfiable or not and this problem is -complete~\cite{BKS03}.

\paragraph{Constructing a popular matching instance  from~.}
Let  have  clauses and  variables. The instance  constructed consists of  variable gadgets,  clause gadgets, and some interconnecting edges between these, see Fig.~\ref{fi:pop_np}. A \emph{variable gadget} representing variable , for , is a 4-cycle on vertices 
, and~, where  and . 
A \emph{clause gadget} representing clause , for , is a subdivision graph of a claw. Its 
edges are divided into three classes:  is at the center, the neighbors of  are , and 
finally, each of  is adjacent to its respective copy in~, where 
.


A vertex in  represents an appearance of a variable. For instance,  is the first literal of the third clause. Each of 
the vertices in  is connected to a vertex in the variable gadget via an \emph{interconnecting edge}. Vertex  is 
connected to the gadget standing for variable  if the -th literal of the th clause is either  or~. If it is ,
then the interconnecting edge ends at , else at~. The preferences of this instance can be seen in 
Fig.~\ref{fi:pop_np}. The constructed graph trivially satisfies both conditions claimed in Section~\ref{sec:intro}, i.e.\ 
every vertex in  has a strict preference list of length 2 or 4 and every vertex in  has either a strict preference list of length~2 
or a single tie of length~2 or 3 as a preference list.
\tikzstyle{vertex} = [circle, draw=black, fill=black, inner sep=0pt,  minimum size=5pt]
\tikzstyle{edgelabel} = [circle, fill=white, inner sep=0pt,  minimum size=15pt]
\begin{center}
\begin{figure}[h!]
\centering
	\pgfmathsetmacro{\d}{3}
	\pgfmathsetmacro{\b}{5}
	\pgfmathsetmacro{\k}{10}
	\pgfmathsetmacro{\c}{2}
\begin{minipage}{0.45\textwidth}
\centering
\begin{tikzpicture}[scale=0.85, transform shape]

	\node[vertex, label=below:] (c1) at () {};
	\node[vertex, label=below:] (x11) at () {};
	\node[vertex, label=below:] (x12) at () {};
	\node[vertex, label=below:] (x13) at () {};
	\node[vertex, label=below:] (y11) at () {};
	\node[vertex, label=below:] (y12) at () {};
	\node[vertex, label=below:] (y13) at () {};
	
	\draw [] (c1) -- node[edgelabel, near start] {1} node[edgelabel, near end] {1} (x11);
	\draw [] (c1) -- node[edgelabel, near start] {1} node[edgelabel, near end] {1} (x12);
	\draw [] (c1) -- node[edgelabel, near start] {1} node[edgelabel, near end] {1} (x13);
	
	\draw [] (x11) -- node[edgelabel, near start] {2} node[edgelabel, near end] {1} (y11);
	\draw [] (x12) -- node[edgelabel, near start] {2} node[edgelabel, near end] {1} (y12);
	\draw [] (x13) -- node[edgelabel, near start] {2} node[edgelabel, near end] {1} (y13);
	
	\draw [dotted] (y11) -- node[edgelabel] {2} ();
	\draw [dotted] (y12) -- node[edgelabel] {2} ();
	\draw [dotted] (y13) -- node[edgelabel] {2} ();

\end{tikzpicture}

\end{minipage}\hspace{1.22cm}\begin{minipage}{0.45\textwidth}
\centering
	\begin{tikzpicture}[scale=0.9, transform shape]
	\node[vertex, label=below:] (A1) at (0, 0) {};
	\node[vertex, label=below:] (B1) at (\d+1, 0) {};
	\node[vertex, label=below:] (A2) at (0, -\d-1) {};
	\node[vertex, label=below:] (B2) at (\d+1, -\d-1) {};
	
	\draw [] (A1) -- node[edgelabel, near start] {1} node[edgelabel, near end] {1} (B1);
	\draw [] (A1) -- node[edgelabel, near start] {4} node[edgelabel, near end] {1} (B2);
	\draw [] (A2) -- node[edgelabel, near start] {1} node[edgelabel, near end] {1} (B1);
	\draw [] (A2) -- node[edgelabel, near start] {4} node[edgelabel, near end] {1} (B2);
	
	\draw [dotted] (A1) -- node[edgelabel] {2} ();
	\draw [dotted] (A1) -- node[edgelabel] {3} ();
	\draw [dotted] (A2) -- node[edgelabel] {2} ();
	\draw [dotted] (A2) -- node[edgelabel] {3} ();
	
	\end{tikzpicture}
\end{minipage}

\vspace{1.5cm}

\begin{tikzpicture}[scale=0.9, transform shape]
	
	\node[vertex] (A1) at (0, 0) {};
	\node[vertex] (B1) at (\d, 0) {};
	\node[vertex] (A2) at (0, -\d) {};
	\node[vertex] (B2) at (\d, -\d) {};
	
	\draw [ultra thick, red] (A1) -- (B1);
	\draw [] (A1) -- node [near start, fill=white]{(-1,0)} (B2) ;
	\draw [] (A2) -- node [near start, fill=white]{(+1,0)} (B1);
	\draw [ultra thick, red] (A2) -- (B2);
	\draw [dotted] (A1) -- ();
	\draw [dotted] (A2) -- ();
	
	\iffalse
	\node[vertex] (a1) at () {};
	\node[vertex] (b1) at () {};
	\node[vertex] (a2) at () {};
	\node[vertex] (b2) at () {};
	
	\draw [] (a1) -- (b1);
	\draw [] (a1) -- (b2);
	\draw [] (a2) -- (b1);
	\draw [] (a2) -- (b2);
	\fi
	


	\node[vertex] (c2) at () {};
	\node[vertex] (x21) at () {};
	\node[vertex] (x22) at () {};
	\node[vertex] (x23) at () {};
	\node[vertex] (y21) at () {};
	\node[vertex] (y22) at () {};
	\node[vertex] (y23) at () {};
	
	\draw [] (c2) -- node [above, fill=white]{(+1,0)} (x21);
	\draw [ultra thick, red] (c2) -- (x22);
	\draw [] (c2) -- node [below, fill=white]{(+1,0)} (x23);
	
	\draw [ultra thick, red] (x21) -- (y21);
	\draw []  (x22) -- node [above, fill=white]{(-1,+1)} (y22);
	\draw [ultra thick, red] (x23) -- (y23);
	
	\draw [dotted] (y21) -- ();
	\draw [dotted] (y22) -- node [above, fill=white]{(+1,-1)}(A1);
	\draw [dotted] (y23) --();
	
	\node[vertex] (c1) at () {};
	\node[vertex] (x11) at () {};
	\node[vertex] (x12) at () {};
	\node[vertex] (x13) at () {};
	\node[vertex] (y11) at () {};
	\node[vertex] (y12) at () {};
	\node[vertex] (y13) at () {};
	
	\draw [ultra thick, red] (c1) -- (x11);
	\draw [] (c1) -- node [below=3pt, near end, fill=white]{(+1,0)} (x12);
	\draw [] (c1) -- node [below, fill=white]{(+1,0)} (x13);
	
	\draw [] (x11) --  node [above, fill=white]{(-1,+1)} (y11);
	\draw [ultra thick, red] (x12) -- (y12);
	\draw [ultra thick, red] (x13) -- (y13);
	
	\draw [dotted] (y11) -- ();
	\draw [dotted] (y12) -- ();
	\draw [dotted] (y13) --  node [above, fill=white]{(-1,+1)} (A2);
\end{tikzpicture}

\caption{A clause gadget, a variable gadget, and the structure of the entire construction with a variable that appears at the second place in the first clause in unnegated form and at the third place in the second clause in negated form. The thick red matching corresponds to a true variable.}
\label{fi:pop_np}
\end{figure}
\end{center}

\vspace*{-1cm}
	
\paragraph{Constructing a truth assignment in , given a popular matching  in~.}
The graph  is as described above. Claim~\ref{clm1:appb} states that any popular matching  in  has a certain structure.
\begin{new-claim}
\label{clm1:appb}
Any popular matching  in  has to obey the following properties.
\begin{itemize}
	\item  avoids all interconnecting edges.
	\item  is one of the two perfect matchings on any variable gadget; i.e.\ for each , the edges of , restricted to the gadget 
corresponding to variable , are either (i)~ and , or (ii)~ and .
	\item  leaves exactly one vertex per clause  unmatched and this unmatched vertex  is adjacent to an  that is 
matched to~.
\end{itemize}
\end{new-claim}

\begin{proof}
Label each edge  in  by the pair , where  is 's vote for  versus  and 
 is 's vote for  versus~. Our first observation is that every , for , and every 
, for , must be matched in~. That is because these vertices are the top choices for each of their neighbors, 
hence if one of them is left unmatched, then there would be an edge labeled  incident to an unmatched vertex. This contradicts the 
popularity of~.
 
Assume without loss of generality that .  Also, the edges  and
 must be in , because they are the top-ranked edges of  and , respectively. We now claim
that  as well. 

Suppose . Since  is a maximal matching,  
for some~. Based on the above described structure of the clause gadgets, the edges , and 
 are in , where the subscripts are taken modulo~3. 
Consider the following augmenting path  wrt~: 

We have , which contradicts the
popularity of~. Thus . 

An analogous argument proves that if  for some , then  has to be in~. 
The last observation we make is that if  is unmatched in , then its interconnecting edge leads to an   
that is matched to~. Otherwise  would be labeled  with one vertex unmatched, a contradiction 
again to the popularity of~. This finishes the proof of Claim~\ref{clm1:appb}. \qed
\end{proof}

We assign  to all variables  such that  and 
 to all variables  such that .

So the truth value of every variable is uniquely defined and all we need to show is that every clause has a true literal. Assume that in clause , all three 
literals are false. The clause gadget has an unmatched vertex  that is adjacent to an~. If the literal is false, 
then  prefers  to  and this becomes an edge labeled  with an unmatched end vertex -- this 
contradicts the popularity of~. Hence in every clause, there is at least one true literal and so this is a satisfying assignment.








\paragraph{Constructing a popular matching in , given a truth assignment in~.}
Here we first construct a matching  in the graph  as described below and then show that it is popular. Initially .
For each , where , if  in the assignment, then add  and  to , 
else add  and  to~. 
For each , where , in the gadget corresponding to clause , any true literal is chosen (say, the -th literal) and 
, representing its appearance, is left unmatched. Moreover,  and  (where
the subscripts are taken modulo 3) are added to~. No interconnecting edge appears in~. This finishes the description of~.

\begin{new-claim}
\label{clm2:appb}
The matching  is popular in~.
\end{new-claim}
\begin{proof}
Suppose  is not popular. Then there is another matching  that is more popular than~. This can only happen if  contains 
a component  such that the number of vertices in  that prefer  to  is more than those that prefer  to~.
To achieve this, the matching  should contain at least one edge labeled either  or , where we use edge labels 
as described in the proof of Claim~\ref{clm1:appb}. We now analyze the cases based on the occurrences of such ``positive'' edges.

Since we started with a truth assignment, no interconnecting edge can be labeled . In fact, it is easy to check that no edge here can 
be labeled . We now check for the occurrences of edges labeled . These can occur at two places: the edge  
for any  and the edge  for any . 

\noindent {\em Case~1.} Suppose  is labeled~. This happens if  is  in the truth assignment.
We start the augmenting path  at~. Augmenting along the 4-cycle is not sufficient to break popularity, therefore,  must 
be matched along one of its interconnecting edges, say . 
\begin{itemize}
\item If  is unmatched, consider the path ----. There are two vertices ( and ) 
that prefer  to  and two vertices ( and ) that prefer  to~.
\item If  is matched, then extend the path  till the unmatched vertex of the th variable gadget (call this ). The path
 is described below:

So 4 vertices, i.e.\ , , , and , prefer
 to  while 3 vertices, i.e.\ , , and , prefer  to~.
\end{itemize}



\noindent {\em Case~2.}
Now suppose  is labeled . Let us assume that this edge is  and suppose~. 
Consider the alternating path ----. In the matching , the vertices  and
 are better-off while  and  are worse-off, i.e.\ they prefer  to  . In order to collect one
more vertex that prefers , let us extend this alternating path  to include  , the interconnecting edge 
of~. The vertex  still prefers  to  since  was paired in  to its top-ranked neighbor.

Without loss of generality, let us assume that this interconnecting edge is . 
We have two cases here: either  or , . 
\begin{itemize}
\item In the first case, the path  gets extended to --. So  prefers  to , however
 is left unmatched in , so  prefers  to .
\item In the second case, the path  gets extended to ----. So  prefers  
to , however both  and  prefer  to .
\end{itemize}
We have analyzed all the cases where edges can labeled  and we showed that there is no alternating cycle or path  containing an edge
labeled  such that . Thus  is popular. \qed
\end{proof}
This finishes the proof of Theorem~\ref{thm:nphard} stated in Section~\ref{sec:intro}.

\subsubsection{Conclusions and open problems.} We gave an  algorithm for the popular 
matching problem in  where vertices in  have strict preference lists while 
each vertex in  puts all its neighbors into a single tie and .
Our algorithm needs the preference lists of vertices in  to be strict and 
the complexity of the popular matching problem when ties are allowed in the preference lists of 
vertices in  is currently unknown.  

When each  either has a single tie of length at most~3 or a strict preference list (and each  has a strict preference list), we showed that the popular matching problem becomes -hard. The complexity of the same problem with ties of length at most~2 instead of~3 is open. 
Another open problem is to extend our algorithm to solve the popular matching problem in the many-to-one 
setting where each post  has a capacity 
and post  prefers  to  if . 

\bibliographystyle{plain}
\begin{thebibliography}{10}


\bibitem{AIKM05}
D.J. Abraham, R.W. Irving, T.~Kavitha, and K.~Mehlhorn.
\newblock Popular matchings.
\newblock SIAM Journal on Computing, Vol.~37, No.~4, pages~1030--1045, 2007.

\bibitem{BKS03}
P.~Berman, M.~Karpinski, and Alexander~D. Scott.
\newblock Approximation hardness of short symmetric instances of {MAX-3SAT}.
\newblock Electronic Colloquium on Computational Complexity Report, number 49,
  2003.

\bibitem{BIM09}
P.~Bir\'o, R.W. Irving, and D.F. Manlove.
\newblock Popular matchings in the {M}arriage and {R}oommates problems.
\newblock In {\em Proceedings of the 7th CIAC}: pages 97--108, 2010.

\bibitem{dulmage}
A. Dulmage and N. Mendelsohn. 
Coverings of bipartite graphs. 
In {\em Canadian Journal of Mathematics}, 10: pages 517-534, 1958. 

\bibitem{Gar75}
P.~G\"{a}rdenfors.
\newblock Match making: assignments based on bilateral preferences.
\newblock {\em Behavioural Science}, 20: pages 166--173, 1975.

\bibitem{GGL95}
R.L. Graham, M.~Gr\"{o}tschel, and L.~Lovasz, editors.
\newblock {\em The Handbook of Combinatorics}, chapter 3, Matchings and
  Extensions, by W. R. Pulleyblank, pages 179--232.
\newblock North Holland, 1995.

\bibitem{HK11}
C.-C. Huang and T.~Kavitha.
\newblock Popular matchings in the stable marriage problem.
\newblock In {\em Proceedings of the 38th ICALP}: pages 666--677, 2011.

\bibitem{Kav12}
T. Kavitha.
\newblock Popularity vs Maximum cardinality in the stable marriage setting.
\newblock  In {\em Proceedings of the 23rd SODA}: pages~123-134, 2012.

\bibitem{KMN09}
T.~Kavitha, J.~Mestre, and M.~Nasre.
\newblock Popular mixed matchings.
\newblock In {\em Proceedings of the 36th ICALP}: pages 574--584, 2009.

\bibitem{KN08}
T.~Kavitha and M.~Nasre.
\newblock {\em Note: Optimal popular matchings.}
\newblock Discrete Applied Mathematics, 157(14): pages 3181--3186, 2009.

\bibitem{Mah06}
M.~Mahdian.
\newblock Random popular matchings.
\newblock In {\em Proceedings of the 7th EC}: pages 238--242, 2006.

\bibitem{MS06}
D.F. Manlove and C.T.S. Sng.
\newblock Popular matchings in the {C}apacitated {H}ouse {A}llocation problem.
\newblock In {\em Proceedings of the 14th ESA}: pages 492--503, 2006.

\bibitem{McC06}
R.M. McCutchen.
\newblock The least-unpopularity-factor and least-unpopularity-margin criteria for matching problems with one-sided preferences.
\newblock In {\em Proceedings of the 8th LATIN:} pages 593-604, 2008.

\bibitem{MI09}
E.~McDermid and R.W. Irving.
\newblock Popular matchings: Structure and algorithms.
\newblock In {\em Proceedings of the 15th COCOON}: pages 506--515,  2009.

\bibitem{Mes06}
J.~Mestre.
\newblock Weighted popular matchings.
\newblock In {\em Proceedings of the 33rd ICALP}: pages 715--726, 2006.
\end{thebibliography}
\end{document}
