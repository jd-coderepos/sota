\documentclass{article}



\usepackage[final,nonatbib]{neurips_2019}


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{algorithmicx,algpseudocode,algorithm}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs} \usepackage{enumitem} 
\usepackage{bm}
\usepackage{nicefrac}
\usepackage{placeins}
\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage{wrapfig,tikz}
\usepackage{amsmath,longtable,fancyhdr,booktabs,multirow,graphicx,float}
\usepackage{adjustbox, bigstrut, tabularx, multirow, makecell, diagbox}
\usepackage{amssymb,xcolor,amsthm}
\usepackage{color}
\usepackage{colortbl}
\usepackage{theoremref}
\usepackage{subcaption}

\bibliographystyle{abbrv}

\newcommand{\abs}[1]{\lvert#1\rvert}
\newcommand{\T}{\intercal}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}

\newcommand{\ud}{\mathrm{d}}
\newcommand{\up}{\mathrm}
\def\dbar{\mathrm{\mathchar'26\mkern-12mu d}}
\newcommand{\wave}{\sim}
\newcommand{\mcal}{\mathcal}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newtheorem{problem}{Problem}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{observation}{Observation}
\newtheorem{proposition}{Proposition}
\newtheorem{assumption}{Assumption}
\newtheorem{assumptions}{Assumptions}
\newtheorem{definition}{Definition}
\newtheorem{innercustomthm}{Theorem}
\newenvironment{customthm}[1]
{\renewcommand\theinnercustomthm{#1}\innercustomthm}
{\endinnercustomthm}
\newtheorem{innercustomlem}{Lemma}
\newenvironment{customlem}[1]
{\renewcommand\theinnercustomlem{#1}\innercustomlem}
{\endinnercustomlem}
\newtheorem{innercustomhyp}{Hypothesis}
\newenvironment{customhyp}[1]
{\renewcommand\theinnercustomhyp{#1}\innercustomhyp}
{\endinnercustomhyp}
\newtheorem{innercustomprop}{Proposition}
\newenvironment{customprop}[1]
{\renewcommand\theinnercustomprop{#1}\innercustomprop}
{\endinnercustomprop}
\newtheorem{innercustomass}{Assumption}
\newenvironment{customass}[1]
{\renewcommand\theinnercustomass{#1}\innercustomass}
{\endinnercustomass}

\newcommand{\be}{}

\definecolor{Gray}{gray}{0.85}
\definecolor{LightCyan}{rgb}{0.88,1,1}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}

\DeclareMathOperator*{\argsup}{arg\,sup}
\DeclareMathOperator*{\arginf}{arg\,inf}

\makeatletter
\usepackage{xspace}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}

\newcommand{\eqnref}[1]{Eq\onedot~\eqref{#1}}
\newcommand{\figref}[1]{Fig\onedot~\ref{#1}}
\newcommand{\algoref}[1]{Algorithm~\ref{#1}}
\newcommand{\equref}[1]{Eq\onedot~\eqref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\tabref}[1]{Tab\onedot~\ref{#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\prgref}[1]{Program~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}
\newcommand{\clmref}[1]{Claim~\ref{#1}}
\newcommand{\corref}[1]{Corollary~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\propref}[1]{Proposition~\ref{#1}}
\newcommand{\ptyref}[1]{Property~\ref{#1}}
\newcommand{\assref}[1]{Assumption~\ref{#1}}
\newcommand{\bfx}{\mathbf{x}}
\newcommand{\bfA}{\mathbf{A}}
\newcommand{\bfB}{\mathbf{B}}
\newcommand{\bfW}{\mathbf{W}}
\newcommand{\bfV}{\mathbf{V}}
\newcommand{\bfM}{\mathbf{M}}
\newcommand{\bfb}{\mathbf{b}}
\newcommand{\bfv}{\mathbf{v}}
\newcommand{\bfz}{\mathbf{z}}
\newcommand{\bfI}{\mathbf{I}}
\newcommand{\bft}{\mathbf{t}}
\newcommand{\bfzero}{\mathbf{0}}
\newcommand{\frakm}{\mathfrak{L}}
\newcommand{\bfe}{{\bs{\epsilon}}}
\newcommand{\bftheta}{{\boldsymbol{\theta}}}
\newcommand{\bfalpha}{{\boldsymbol{\alpha}}}
\newcommand{\bfphi}{{\boldsymbol{\phi}}}
\newcommand{\bfy}{\mathbf{y}}
\newcommand{\bfs}{\mathbf{s}}
\newcommand{\bfh}{\mathbf{h}}
\def\eg{\emph{e.g}\onedot}
\def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot}
\def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{cf}\onedot}
\def\Cf{\emph{Cf}\onedot}
\def\etc{\emph{etc}\onedot}
\def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot}
\def\dof{d.o.f\onedot}
\def\aka{a.k.a\onedot}
\def\iid{i.i.d\onedot}
\def\etal{\emph{et al}\onedot}

\newcommand{\chenlin}[1]{{\color{cyan} [CM: {#1}]}}
\newcommand{\y}[1]{{\color{orange} [YS: {#1}]}}
\newcommand{\s}[1]{{\color{magenta} [SE: {#1}]}}

\usepackage[textsize=tiny]{todonotes}


\title{MintNet: Building Invertible Neural Networks with Masked Convolutions}


\author{Yang Song\thanks{Equal contribution.} \\
  Stanford University \\
  \texttt{yangsong@cs.stanford.edu} \\
  \And
  Chenlin Meng\footnotemark[1] \\
  Stanford University \\
  \texttt{chenlin@cs.stanford.edu} \\
  \And
  Stefano Ermon \\
  Stanford University \\
  \texttt{ermon@cs.stanford.edu} \\
}

\begin{document}
\maketitle
\begin{abstract}
We propose a new way of constructing invertible neural networks by combining simple building blocks with a novel set of composition rules. This leads to a rich set of invertible architectures, including those similar to ResNets. Inversion is achieved with a locally convergent iterative procedure that is parallelizable and very fast in practice. 
Additionally, the determinant of the Jacobian can be computed analytically and efficiently, enabling their generative use as flow models. 
To demonstrate their flexibility, we show that our invertible neural networks are competitive with ResNets on MNIST and CIFAR-10 classification. 
When trained as generative models, our invertible networks achieve competitive likelihoods on MNIST, CIFAR-10 and ImageNet 3232, with bits per dimension of 0.98, 3.32 and 4.06 respectively.
\end{abstract} \section{Introduction}
Invertible neural networks
have many applications in machine learning. 
They have been employed to investigate representations of deep classifiers~\cite{jacobsen2018irevnet}, understand the cause of adversarial examples~\cite{jacobsen2018excessive}, learn transition operators for MCMC~\cite{song2017nice,levy2018generalizing}, create generative models that are directly trainable by maximum likelihood~\cite{nvp,dinh2016density,maf,glow,FFJORD,i-resnet}, and perform approximate inference~\cite{rezende15variational,kingma2016iaf}.

Many applications of invertible neural networks require that both inverting the network and computing the Jacobian determinant be efficient.
While typical neural networks are not invertible, achieving these properties often imposes restrictive constraints
to the architecture. 
For example, planar flows~\cite{rezende15variational} and Sylvester flow~\cite{berg2018sylvester} constrain the number of hidden units to be smaller than the input dimension. NICE~\cite{dinh2016density} and Real NVP~\cite{nvp} rely on dimension partitioning heuristics and specific architectures such as coupling layers, which could make training more difficult~\cite{i-resnet}. Methods like FFJORD~\cite{FFJORD}, i-ResNets~\cite{i-resnet} have fewer architectural constraints. However, their Jacobian determinants have to be approximated, which is problematic if repeatedly performed at training time as in flow models.


In this paper, we propose a new method of constructing invertible neural networks which are flexible, efficient to invert, and whose Jacobian can be computed \emph{exactly} and efficiently.
We use triangular matrices as our basic module. Then, we provide a set of composition rules to recursively build more complex non-linear modules from the basic module, and show that the composed modules are invertible as long as their Jacobians are non-singular. As in previous work~\cite{nvp,maf},
the Jacobians of our modules are triangular, allowing efficient determinant computation. The inverse of these modules can be obtained by an efficiently parallelizable fixed-point iteration method, making the cost of inversion comparable to that of an i-ResNet~\cite{i-resnet} block. 


Using our composition rules and masked convolutions as the basic triangular building block, we construct a rich set of invertible modules to form a deep invertible neural network. The architecture of our proposed invertible network closely follows that of ResNet~\cite{he2016deep}---the state-of-the-art architecture of discriminative learning. We call our model \textbf{M}asked \textbf{In}ver\textbf{t}ible \textbf{Net}work (MintNet). To demonstrate the capacity of MintNets, we first test them on image classification. We found that a MintNet classifier achieves 99.6\% accuracy on MNIST, matching the performance of a ResNet with a similar architecture. On CIFAR-10, it achieves 91.2\% accuracy, comparable to the 92.6\% accuracy of ResNet. When using MintNets as generative models, they achieve the new state-of-the-art results of bits per dimension (bpd) on uniformly dequantized images. Specifically, MintNet achieves bpd values of 0.98, 3.32, and 4.06 on MNIST, CIFAR-10 and ImageNet 3232, while former best published results are 0.99 (FFJORD~\cite{FFJORD}), 3.35 (Glow~\cite{glow}) and 4.09 (Glow) respectively.
Moreover, MintNet uses fewer parameters and less computational resources. Our MNIST model uses 30\% fewer parameters than FFJORD~\cite{FFJORD}. For CIFAR-10 and ImageNet 3232, MintNet uses 60\% and 74\% fewer parameters than the corresponding Glow~\cite{glow} models.
When training on dataset such as CIFAR-10, MintNet required 2 GPUs for approximately 5 days, while FFJORD~\cite{FFJORD} used 6 GPUs for approximately 5 days, and Glow~\cite{glow} used 8 GPUs for approximately 7 days. 

 \section{Background}
Consider a neural network  that maps a data point  to a latent representation . When for every  there exists a unique  such that , we call  an invertible neural network. There are several basic properties of invertible networks. First, when  is continuous, a necessary condition for  to be invertible is . Second, if  and  are both invertible,  will also be invertible. In this work, we mainly consider applications of invertible neural networks to classification and generative modeling.

\subsection{Classification with invertible neural networks}

Neural networks for classification are usually not invertible
because the number of classes  is usually different from the input dimension . Therefore, when discussing invertible neural networks for classification, we separate the classifier into two parts : feature extraction  and classification , where  is usually the softmax function. We say the classifier is invertible when  is invertible.
Invertible classifiers are arguably more interpretable, because a prediction can be traced down by inverting latent representations~\cite{jacobsen2018irevnet, jacobsen2018excessive}. 



\subsection{Generative modeling with invertible neural networks}
An invertible network  can be used to warp a complex probability density  to a simple base distribution  (\eg, a multivariate standard Gaussian)~\cite{dinh2016density,nvp}.
Under the condition that both  and  are differentiable, the densities of  and  are related by the following change of variable formula

where  denotes the Jacobian of  and we require  to be non-singular so that  is well-defined. Using this formula,  can be easily computed if the Jacobian determinant  is cheaply computable and  is known.

Therefore, an invertible neural network  implicitly defines a normalized density model , which can be directly trained by maximum likelihood. The invertibility of  is critical to fast sample generation. Specifically, in order to generate a sample  from , we can first draw , and warp it back through the inverse of  to obtain . 


Note that multiple invertible models  can be stacked together to form a deeper invertible model , without much impact on the inverse and determinant computation. This is because we can sequentially invert each component, \ie, , and the total Jacobian determinant equals the product of each individual Jacobian determinant, \ie, .
 \section{Building invertible modules compositionally}\label{sec:composition}
In this section, we discuss how simple blocks like masked convolutions can be composed to build invertible modules that allow efficient, parallelizable inversion and determinant computation. To this end, we first introduce the basic building block of our models. Then, we propose a set of composition rules to recursively build up complex non-linear modules with triangular Jacobians. Next, we prove that these composed modules are invertible as long as their Jacobians are non-singular. Finally, we discuss how these modules can be inverted efficiently using numerical methods.

\subsection{The basic module}\label{sec:basic}
We start from considering linear transformations , with , and . For a general , computing its Jacobian determinant requires  operations. We therefore choose  to be a triangular matrix. In this case, the Jacobian determinant  is the product of all diagonal entries of , and the computational complexity is reduced to . The linear function  with  being triangular is our \emph{basic module}. 





\begin{figure}
    \centering
    \includegraphics[width=0.9 \textwidth]{diagrams/plot.png}
    \caption{Illustration of a masked convolution with 3 filters and kernel size . Solid checkerboard cubes inside each filter represent unmasked weights, while the transparent blue blocks represent the weights that have been masked out. The receptive field of each filter on the input feature maps is indicated by regions shaded with the pattern (the colored square) below the corresponding filter.}
    \label{fig:masked_conv}
\end{figure}

\paragraph{Masked convolutions.} Convolution is a special type of linear transformation that is very effective for image data. The triangular structure of the basic module can be achieved using \emph{masked} convolutions (\eg, causal convolutions in PixelCNN~\cite{oord2016pixel}). We provide the formula of our masks in Appendix~\ref{app:masked_conv} and  an illustration of a  masked convolution with  filters in \figref{fig:masked_conv}. Intuitively, the causal structure of the filters (ordering of the pixels) enforces a triangular structure.


\subsection{The calculus of building invertible modules}\label{sec:calculus}
Complex non-linear invertible functions can be constructed from our basic modules in two steps. First, we follow several composition rules so that the composed module has a triangular Jacobian. Next, we impose appropriate constraints so that the module is invertible. To simplify the discussion, we only consider modules with lower triangular Jacobians here, and we note that it is straightforward to extend the analysis to modules with upper triangular Jacobians. 

The following proposition summarizes several rules to compositionally build new modules with triangular Jacobians using existing ones.
\begin{proposition}\label{prop:calculus}
Define  as the set of all continuously differentiable functions whose Jacobian is lower triangular. Then  contains the basic module in \secref{sec:basic}, and is closed under the following composition rules.
\begin{itemize}
    \item \textbf{Rule of addition}. , where . \item \textbf{Rule of composition}. . A special case is , where  is a continuously differentiable non-linear activation function that is applied element-wise.\end{itemize}
\end{proposition}
The proof of this proposition is straightforward and deferred to Appendix \ref{app:proof}. By repetitively applying the rules in \propref{prop:calculus}, our basic linear module can be composed to construct 
complex non-linear modules having continuous and triangular Jacobians. Note that besides our linear basic modules, other functions with triangular and continuous Jacobians can also be made more expressive using the composition rules. For example, the layers of dimension partitioning models (\eg, NICE~\cite{dinh2016density}, Real NVP~\cite{nvp}, Glow~\cite{glow}) and autoregressive flows (\eg, MAF~\cite{maf}) all have continuous and triangular Jacobians and therefore belong to . Note that the rule of addition in \propref{prop:calculus} preserves triangular Jacobians but not invertibility. Therefore, we need additional constraints if we want the composed functions to be invertible.

\begin{figure}
    \centering
    \includegraphics[width=0.9 \textwidth]{diagrams/venn.png}
    \caption{Venn Diagram relationships between invertible functions (), the function sets of  and , functions that meet the conditions of \thmref{thm:invert} (), functions whose Jacobian is triangular and Jacobian diagonals are strictly positive (), functions whose Jacobian is triangular and Jacobian diagonals are all 1s ().}
    \label{fig:venn}
\end{figure}


Next, we state the condition for  to be invertible, and denote the invertible subset of  as . \begin{theorem}\label{thm:invert}
If  and  is non-singular for all  in the domain, then  is invertible.
\end{theorem}

\begin{proof}
A proof can be found in Appendix~\ref{app:proof}.
\end{proof}

The non-singularity of  constraint in \thmref{thm:invert} is natural in the context of generative modeling. This is because in order for \eqnref{eqn:flow} to make sense,  has to be well-defined, which requires  to be non-singular.

In many cases, \thmref{thm:invert} can be easily used to check and enforce the invertibility of . For example, the layers of autoregressive flow models and dimension partitioning models can all be viewed as elements of  because they are continuously differentiable and have triangular Jacobians. Since the diagonal entries of their Jacobians are always strictly positive and hence non-singular, we can immediately conclude that they are invertible with \thmref{thm:invert}, thus generalizing their model-specific proofs of invertibility. 

In \figref{fig:venn}, we provide a Venn Diagram to illustrate the set of functions that satisfy the condition of \thmref{thm:invert}. As depicted by the orange set labeled by , \thmref{thm:invert} captures a subset of  where the Jacobians of functions are non-singular so that the change of variable formula is usable. Note the condition in Theorem 1 is sufficient but not necessary.
For example,  is invertible, but  is singular. Many previous invertible models with special architectures, such as NICE, Real NVP, and MAF, can be viewed as elements belonging to subsets of . 








\subsection{Efficient inversion of the invertible modules}
In this section, we show that when the conditions in \thmref{thm:invert} hold, not only do we know that  is invertible (), but also we have a fixed-point iteration method to invert  with strong theoretical guarantees and good performance in practice.

\begin{algorithm}
	\caption{Fixed-point iteration method for computing .}
	\label{alg:solver}
	\begin{algorithmic}[1]
	    \Require{} \Comment{ is the number of iterations;  is the step size.}
	    \State{Initialize }
        \For{ to }
            \State{Compute }
            \State{Compute }
            \State{}
        \EndFor
        \item[]
        \Return{}
	\end{algorithmic}
\end{algorithm}

The pseudo-code of our proposed inversion algorithm is described in \algoref{alg:solver}. Theoretically, we can prove that this method is locally convergent---as long as the initial value is close to the true value, the method is guaranteed to find the correct inverse. We formally summarize this result in \thmref{thm:converge}.
\begin{theorem}\label{thm:converge}
The iterative method of \algoref{alg:solver} is locally convergent whenever .
\end{theorem}
\begin{proof}We provide a more rigorous proof in Appendix~\ref{app:proof}.
\end{proof}



In practice, the method is also easily parallelizable on GPUs, making the cost of inverting  similar to that of an i-ResNet~\cite{i-resnet} layer. Within each iteration, the computation is mostly matrix operations that can be vectorized and run efficiently in parallel. Therefore, the time cost will be roughly proportional to the number of iterations, \ie, . As will be shown in our experiments, \algoref{alg:solver} converges fast and usually the error quickly becomes negligible when . This is in stark contrast to existing methods of inverting autoregressive flow models such as MAF~\cite{maf}, where  univariate equations need to be solved sequentially, requiring at least  iterations. There are also other approaches for inverting . For example, the bisection method is guaranteed to converge globally, but its computational cost is , and is usually much more expensive than \algoref{alg:solver}. Note that as discussed earlier, autoregressive flow models can also be viewed as special cases of our framework. Therefore, \algoref{alg:solver} is also applicable to inverting autoregressive flow models and could potentially result in large improvements of sampling speed.


\section{Masked Invertible Networks}\label{sec:invnet}
We show that techniques developed in \secref{sec:composition} can be used to build our Masked Invertible Network (MintNet). First, we discuss how we compose several masked convolutions to form the Masked Invertible Layer (Mint layer). Next, we stack multiple Mint layers to form a deep neural network, \ie, the MintNet. Finally, we compare MintNets with several existing invertible architectures.

\subsection{Building the Masked Invertible Layer}\label{sec:layer}
We construct an invertible module in  that serves as the basic layer of our MintNet. This invertible module, named Mint layer, is defined as

where  denotes the elementwise multiplication, , , and  are all lower triangular matrices with additional constraints to be specified later, and . Additionally, Mint layers use a monotonic activation function , so that . Common choices of  include ELU~\cite{clevert2015fast}, tanh and sigmoid. Note that every individual weight matrix has the same size, and the 3 groups of weights ,  and  can be implemented with 3 masked convolutions (see Appendix~\ref{app:masked_conv}). We design the form of  so that it resembles a ResNet / i-ResNet block that also has 3 convolutions with  filters, with  being the number of channels of . When using \algoref{alg:solver} to invert Mint layers, we initialize .

From \propref{prop:calculus} in \secref{sec:calculus}, we can easily conclude that . Now, we consider additional constraints on the weights so that , \ie, it is invertible. Note that the analytic form of its Jacobian is

with , , and . Therefore, once we impose the following constraint

we have , which satisfies the condition of \thmref{thm:invert} and as a consequence we know . In practice, the constraint \eqnref{eqn:constraint} can be easily implemented. For all , we impose no constraint on  and , but replace  with . 
Note that  has the same signs as  and therefore . Moreover,  is almost everywhere differentiable \wrt , which allows gradients to backprop through.



\subsection{Constructing the Masked Invertible Network}
In this section, we introduce design choices that help stack multiple Mint layers together to form an expressive invertible neural network, namely the MintNet. The full MintNet is constructed by stacking the following paired Mint layers and squeezing layers.
\paragraph{Paired Mint layers.} As discussed above, our Mint layer  always has a triangular Jacobian. To maximize the expressive power of our invertible neural network, it is undesirable to constrain the Jacobian of the network to be triangular since this limits capacity and will cause blind spots in the receptive field of masked convolutions. We thus always pair two Mint layers together---one with a lower triangular Jacobian and the other with an upper triangular Jacobian, so that the Jacobian of the paired layers is not triangular, and blind spots can be eliminated.


\paragraph{Squeezing layers.} Subsampling is important for enlarging the receptive field of convolutions. However, common subsampling operations such as pooling and strided convolutions are usually not invertible. Following \cite{nvp} and \cite{i-resnet}, we use a ``squeezing'' operation to reshape the feature maps  so that they have smaller resolution but more channels. After a squeezing operation, the height and width will decrease by a factor of 
, but the number of channels will increase by a factor of .  This procedure is invertible and the Jacobian is an identity matrix. Throughout the paper, we use .

\subsection{Comparison to other approaches}\label{sec:connection}
In what follows we compare MintNets to several existing methods for developing invertible architectures. We will focus on architectures with a tractable Jacobian determinant. However, we note that there are models (\cf, \cite{gomez2017reversible,mackay2018reversible,revnet}) that allow fast inverse computation but do not have tractable Jacobian determinants. Following~\cite{i-resnet}, we also provide some comparison in \tabref{tab:compare} (see Appendix~\ref{app:tables}).

\subsubsection{Models based on identities of determinants} Some identities can be used to speed up the computation of determinants if the Jacobians have special structures. For example, in Sylvester flow~\cite{berg2018sylvester}, the invertible transformation has the form , where  is a nonlinear activation function, , ,  and . By Sylvester's determinant identity,  can be computed in , which is much less than  if . However, the requirement that  is small becomes a bottleneck of the architecture and limits its expressive power. Similarly, Planar flow~\cite{rezende15variational} uses the matrix determinant lemma, but has an even narrower bottleneck. 

The form of  bears some resemblance to Sylvester flow. However, we improve the capacity of Sylvester flow in two ways. First, we add one extra non-linear convolutional layer. Second, we avoid the bottleneck that limits the maximum dimension of latent representations in Sylvester flow.

\subsubsection{Models based on dimension partitioning} NICE~\cite{dinh2016density}, Real NVP~\cite{nvp}, and Glow~\cite{glow} all depend on an affine coupling layer. Given ,  is first partitioned into two parts . The coupling layer is an invertible transformation, defined as , where  and  are two arbitrary functions. However, the partitioning of  relies on heuristics, and the performance is sensitive to this choice (\cf, \cite{glow,i-resnet}). In addition, the Jacobian of  is a triangular matrix with diagonal . In contrast, the Jacobian of MintNets has more flexible diagonals---without being partially restricted to 's.

\subsubsection{Models based on autoregressive transformations} By leveraging autoregressive transformations, the Jacobian can be made triangular. For example, MAF~\cite{maf} defines the invertible tranformation as , where  and . Note that  can be obtained by sequentially solving  based on previous solutions . Therefore, a na\"{i}ve approach requires  computations for inverting autoregressive models. Moreover, the architecture of  is only an affine combination of autoregressive functions with . In contrast, MintNets are inverted with faster fixed-point iteration methods, and the architecture of MintNets is arguably more flexible.

\subsubsection{Free-form invertible models} Some work proposes invertible transformations whose Jacobians are not limited by special structures. For example, FFJORD~\cite{FFJORD} uses a continuous version of change of variables formula~\cite{chen2018neural} where the determinant is replaced by trace. Unlike MintNets, FFJORD needs an ODE solver to compute its value and inverse, and uses a stochastic estimator to approximate the trace. Another work is i-ResNet~\cite{i-resnet} which constrains the Lipschitz-ness of ResNet layers to make it invertible. Both i-ResNet and MintNet use ResNet blocks with 3 convolutions. The inverse of i-ResNet can be obtained efficiently by a parallelizable fixed-point iteration method, which has comparable computational cost as our \algoref{alg:solver}. However, unlike MintNets whose Jacobian determinants are exact, the log-determinant of Jacobian of an i-ResNet must be approximated by truncating a power series and estimating each term with stochastic estimators. 

\subsubsection{Other models using masked convolutions}
Emerging convolutions~\cite{hoogeboom2019emerging} and MaCow~\cite{ma2019macow} improve the Glow architecture by replacing  convolutions in the original Glow model with masked convolutions similar to those employed in MintNets. Emerging convolutions and MaCow are both inverted using forward/back substitutions designed for inverting triangular matrices, which requires the same number of iterations as the input dimension. In stark contrast, MintNets use a fixed-point iteration method (\algoref{alg:solver}) for inversion, which is similar to i-ResNet and requires substantially fewer iterations than the input dimension. For example, our method of inversion takes 120 iterations to converge on CIFAR-10, while inverting emerging convolutions will need 3072 iterations. In other words, our inversion can be 25 times faster on powerful GPUs. Additionally, the architecture of MintNet is very different. The architectures of \cite{hoogeboom2019emerging} and \cite{ma2019macow} are both built upon Glow. In contrast, MintNet is a ResNet architecture where normal convolutions are replaced by causal convolutions.


 \section{Experiments}\label{sec:exp}
In this section, we evaluate our MintNet architectures on both image classification and density estimation. We focus on three common image datasets, namely MNIST, CIFAR-10 and ImageNet 3232. We also empirically verify that \algoref{alg:solver} can provide accurate solutions within a small number of iterations. We provide more details about settings and model architectures in Appendix~\ref{app:network}.

\subsection{Classification}
To check the capacity of MintNet and understand the trade-off of invertibility, we test its classification performance on MNIST and CIFAR-10, and compare it to a ResNet with a similar architecture. 




On MNIST, MintNet achieves a test accuracy of 99.6\%, which is the same as that of the ResNet. On CIFAR-10, MintNet reaches 91.2\% test accuracy while ResNet reaches 92.6\%. 
Both MintNet and ResNet achieve 100\% training accuracy on MNIST and CIFAR-10 datasets. This indicates that MintNet has enough capacity to fit all data labels on the training dataset, and the invertible representations learned by MintNet are comparable to representations learned by non-invertible networks in terms of generalizability. Note that the small degradation in classification accuracy is also observed in other invertible networks. For example, depending on the Lipschitz constant, the gap between test accuracies of i-ResNet and ResNet can be as large as 1.92\% on CIFAR-10.  

\subsection{Density estimation and verification of invertibility}\label{sec:exp:invert}



In this section, we demonstrate the superior performance of MintNet on density estimation by training it as a flow generative model. In addition, we empirically verify that \algoref{alg:solver} can accurately produce the inverse using a small number of iterations. We show that samples can be efficiently generated from MintNet by inverting each Mint layer with \algoref{alg:solver}.
\paragraph{Density estimation.}
In \tabref{tab:bpd_table}, we report bits per dimension (bpd) on MNIST, CIFAR-10, and ImageNet 3232 datasets. It is notable that MintNet sets the new records of bpd on all three datasets. Moreover, when compared to previous best models, our MNIST model uses 30\% fewer parameters than FFJORD, and our CIFAR-10 and ImageNet 3232 models respectively use 60\% and 74\% fewer parameters than Glow. When trained on datasets such as CIFAR-10, MintNet requires 2 GPUs for approximately five days, while FFJORD is trained on 6 GPUs for five days, and Glow on 8 GPUs for seven days. 
Note that all values in \tabref{tab:bpd_table} are with respect to the continuous distribution of uniformly dequantized images, and results of models that view images as discrete distributions are not directly comparable (\eg, PixelCNN~\cite{oord2016pixel}, IAF-VAE~\cite{kingma2016iaf}, and Flow++~\cite{ho2019flow}). To show that MintNet learns semantically meaningful representations of images, we also perform latent space interpolation similar to the interpolation experiments in Real NVP (see Appendix~\ref{app:interpolation}).


\begin{table}
 \caption{MNIST, CIFAR-10, ImageNet 3232 bits per dimension (bpd) results. Smaller values are better. Result not directly comparable because ZCA preprocssing was used.} \label{tab:bpd_table}
\begin{center}
    \begin{tabular}{p{5cm} c c c}
        \toprule
        Method & MNIST & CIFAR-10 & ImageNet 3232\\
        \midrule
        NICE~\cite{dinh2016density} &4.36 &4.48 & -\\
        MAF~\cite{maf} &1.89 &4.31 & -\\
        Real NVP~\cite{nvp} &1.06 &3.49 & 4.28\\
        Glow~\cite{glow} &1.05 &3.35 & 4.09\\
        FFJORD~\cite{FFJORD} &0.99 &3.40 & -\\
        i-ResNet~\cite{i-resnet} &1.06 &3.45 & - \\
        \midrule
        MintNet (ours) &\textbf{0.98} &\textbf{3.32} & \textbf{4.06}\\
        \bottomrule
    \end{tabular} 
\end{center}
\end{table}


\paragraph{Verification of invertibility.} We first examine the performance of \algoref{alg:solver} by measuring the reconstruction error of MintNets. We compute the inverse of MintNet by sequentially inverting each Mint layer with \algoref{alg:solver}. We used grid search to select the step size  in \algoref{alg:solver} and chose  respectively for MNIST, CIFAR-10 and ImageNet 3232. An interesting fact is for MNIST,  actually works better than other values of  within , even though it does not have the theoretical gurantee of local convergence. As \figref{fig:newton} shows, the normalized  reconstruction error converges within  iterations for all datasets considered. Additionally, \figref{fig:recon} demonstrates that the reconstructed images look visually indistinguishable to true images. 

\paragraph{Samples.} Using \algoref{alg:solver}, we can generate samples efficiently by computing the inverse of MintNets. We use the same step sizes as in the reconstruction error analysis, and run \algoref{alg:solver} for 120 iterations for all three datasets. We provide uncurated samples in \figref{fig:samples}, and more samples can be found in Appendix~\ref{app:samples}. In addition, we compare our sampling time to that of the other models (see \tabref{tab:sample_time} in Appendix~\ref{app:tables}). Our sampling method has comparable speed as i-ResNet. It is approximately 5 times faster than autoregressive sampling on MNIST, and is roughly 25 times faster on CIFAR-10 and ImageNet 3232.
\begin{figure}\centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/samples_mnist8.png}
        \caption{MNIST}
        \label{fig:mnist}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/samples_cifar8.png}
        \caption{CIFAR-10}
        \label{fig:cifar10}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{diagrams/samples_imagenet8.png}
        \caption{ImageNet-3232}
        \label{fig:imagenet32}
    \end{subfigure}
    \caption{Uncurated samples on MNIST, CIFAR-10, and ImageNet 3232 datasets.}
    \label{fig:samples}
\end{figure}
\begin{figure}\centering
    \begin{subfigure}[b]{0.5\textwidth}
        \includegraphics[width=\textwidth]{diagrams/newton_analysis.png}
        \caption{Reconstruction error analysis.}
        \label{fig:newton}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{diagrams/invert_groundtruth.png}
        \caption{Reconstructed images.}
        \label{fig:recon}
    \end{subfigure}
    \caption{Accuracy analysis of \algoref{alg:solver} on MNIST, CIFAR-10, and ImageNet 3232 datasets. Each curve in (a) represents the mean value of normalized reconstruction errors for 128 images. The 2nd, 4th and 6th rows in (b) are reconstructions, while other rows are original images.}
    \label{fig:invert}
\end{figure}

 \section{Conclusion}
We propose a new method to compositionally construct invertible modules that are flexible, efficient to invert, and with a tractable Jacobian. Starting from linear transformations with triangular matrices, we apply a set of composition rules to recursively build new modules that are non-linear and more expressive~(\propref{prop:calculus}). We then show that the composed modules are invertible as long as their Jacobians are non-singular (\thmref{thm:invert}), and propose an efficiently parallelizable numerical method (\algoref{alg:solver}) with theoretical guarantees (\thmref{thm:converge}) to compute the inverse. The Jacobians of our modules are all triangular, which allows efficient and exact determinant computation.

As an application of this idea, we use masked convolutions as our basic module. Using our composition rules, we compose multiple masked convolutions together to form a module named Mint layer, following the architecture of a ResNet block. To enforce its invertibility, we constrain the masked convolutions to satisfy the condition of \thmref{thm:invert}. We show that multiple Mint layers can be stacked together to form a deep invertible network which we call MintNet. The architecture can be efficiently inverted using a fixed point iteration algorithm (\algoref{alg:solver}). Experimentally, we show that MintNet performs well on MNIST and CIFAR-10 classification. Moreover, when trained as a generative model, MintNet achieves new state-of-the-art performance on MNIST, CIFAR-10 and ImageNet 3232.

\subsection*{Acknowledgements}
This research was supported by Intel Corporation, Amazon AWS, TRI, NSF (\#1651565, \#1522054, \#1733686), ONR  (N00014-19-1-2145), AFOSR (FA9550-
19-1-0024).





 \bibliography{flow}
\newpage
\appendix
\section{Proofs}\label{app:proof}
\paragraph{Notations.} Let  denote the Jacobian of  evaluated at . We use  to denote the -th component of the vector-valued function , and  to denote the -th entry of . We further use  to denote the -th component of the input vector , and  to denote the partial derivative of  \wrt , evaluated at .

\begin{customprop}{\ref{prop:calculus}}
Define  as the set of all continuously differentiable functions whose Jacobian is lower triangular. Then  contains the basic module in \secref{sec:basic}, and is closed under the following composition rules.
\begin{itemize}
   \item \textbf{Rule of addition}. , where . \item \textbf{Rule of composition}. . A special case is , where  is a continuously differentiable non-linear activation function that is applied element-wisely.
\end{itemize}
\end{customprop}
\begin{proof}
    Since the basic modules have the form , where  is a lower triangular matrix, we immediately know that  is continuously differentiable and  is lower triangular, therefore . Next, we prove the closeness properties of  one by one.
    \begin{itemize}
        \item \textbf{Rule of addition}.  is continuously differentiable, and  is lower triangular. This is because , and both  and  are continuous and lower triangular.
        
        \item \textbf{Rule of composition}.  is continuously differentiable and has a lower triangular Jacobian. This is because , and both  and  are continuous and lower triangular. As a special case, we choose , where  is a continuously differentiable univariate function. Since the Jacobian of  is diagonal and continuous, we have . Therefore  holds true for all .
    \end{itemize}
\end{proof}

The following two lemmas will be very helpful for proving \thmref{thm:invert}.
\begin{lemma}
\label{condition1}
 is lower triangular for all  implies  is a function of , and does not depend on .
\end{lemma}
\begin{proof}
Due to the fact that  is lower triangular, we have  for any . When  are fixed, we have


This implies that  does not depend on  for any . In other words,  is only a function of .
\end{proof}
\begin{lemma}
\label{condition2}
 implies that for any , either (i)  or (ii) . That is,  is monotonic \wrt  when  are fixed.
\end{lemma}
\begin{proof}
Clearly  is equivalent to . This means for any ,  and it shares the same sign with , a constant that is either strictly positive or strictly negative. This further implies that when  are fixed,  is either strictly positive or strictly negative for all , and  is therefore monotonic \wrt .
\end{proof}
\begin{customthm}{\ref{thm:invert}}
If  and  is non-singular for all  in the domain, then  is invertible.
\end{customthm}

\begin{proof}
Assume without loss of generality that  is lower triangular. We first prove that  by contradiction. Assuming , then  such that . Because  is always triangular and non-singular, we immediately conclude that . Assume without loss of generality that  and . Then, by the intermediate value theorem, we know that  such that , which contradicts that fact that  is always non-singular.

Next, we prove that for all  in the range of , there exists a unique  such that . To obtain , we only need to solve , which is an equation of variable , as concluded from \lemref{condition1}. Since \lemref{condition2} implies that  is monotonic \wrt , we know that  has a unique inverse  whenever  is in the range of . Now assume we have already obtained , where . In this case, \lemref{condition1} asserts that  is an equation of variable . Again \lemref{condition2} implies that  is a monotonic function of  given , which implies further that  has a unique solution  whenever  is in the range of . By induction, we can solve for  by repetitively employing this procedure, which concludes that  exists, and can be determined uniquely. 




\end{proof}

\iffalse
We provide a toy example for Theorem \ref{thm:invert}.
\begin{example}\label{exp:thm1}
Let 
Clearly,  satisfies . More specifically, if we want to solve , what we do is that we first solve , which gives us . Then, let's plug in  to the second and third equation, which gives us  and . Let's now solve the second equation , which implies . Plugging in  to the third equation, we got , which implies . In this case, we are able to find the inverse of  at . 
\end{example}
\fi

\begin{customthm}{\ref{thm:converge}}
The iterative method of \algoref{alg:solver} is locally convergent whenever .
\end{customthm}
\begin{proof}
    Let  be any value in the range of  and , where  denotes a diagonal matrix whose diagonal entries are the reciprocals of those of . The iterative method of \algoref{alg:solver} can be written as . Because of \thmref{thm:invert}, there exists a unique  such that , in which case . Applying the product rule, we have
    
    where  denotes the Jacobian of  evaluated at . Since  is triangular,  will also be triangular. Therefore, the only eigenvalue of  is , due to the fact that the only solution to the equation system  is . Since , the spectral radius of  satisfies . Then the Ostrowski Theorem (\cf, Theorem 10.1.3. in \cite{ortega1970iterative}) shows that the sequence  obtained by  converges locally to  as .
\end{proof}

\section{Masked convolutions}\label{app:masked_conv}
Convolution is a special type of linear transformation that proves to be very effective for image data. The basic invertible module can be implemented using masked convolutions (\eg, causal convolutions in PixelCNN~\cite{oord2016pixel}). Consider a 2D convolutional layer with  input feature maps,  filters, a kernel size of  and a zero-padding of . We assume  is an odd integer and  so that the input and output of the convolutional layer have the same shape. Let  be the weight tensor of this layer. We define a mask  that satisfies

The masked convolution then uses  as the weight tensor. In \figref{fig:masked_conv}, we provide an illustration on a  masked convolution with  filters.

In MintNet,  is efficiently implemented with 3 masked convolutional layers. The weights and masks are denoted as ,  and , which separately correspond to  in \eqnref{eqn:block}. Let  be the number of input feature maps, and suppose the kernel size is . The shapes of ,  and  are respectively ,  and . The masks of them are simple concatenations of copies of the mask in \eqnref{eqn:mask}. For instance,  consists of  copies of \eqnref{eqn:mask}, and  consists of  copies. Using masked convolutions,  can be concisely written as

where  are biases, and  denotes the operation of discrete 2D convolution.





\section{Interpolation of hidden representations}
\label{app:interpolation}
\begin{figure}[!t]
\centering
\includegraphics[width=0.3\textwidth]{diagrams/interpolation_mnist.png}
\includegraphics[width=0.3\textwidth]{diagrams/interpolation_cifar10.png}
\includegraphics[width=0.3\textwidth]{diagrams/interpolation_imagenet.png}
\caption{MintNet interpolation of hidden representation. \textbf{Left:} MintNet MNIST latent space interpolation. \textbf{Middle:} MintNet CIFAR-10 latent space interpolation. \textbf{Right:} MintNet ImageNet 3232 latent space interpolation.}
\label{fig:interpolation}
\end{figure}
Given four images  in the dataset, let , where , be the corresponding features in the feature domain. Similar to \cite{nvp}, in the feature domain, we define

where -axis corresponds to , -axis corresponds to , and both  and  range over . We then transform  back to the image domain by taking . Interpolation results are shown in \figref{fig:interpolation}.

\section{Experiment setup and network architecture}
\label{app:network}
\paragraph{Hyperparameter tuning and computation infrastructure.} We use the standard train/test split of MNIST, CelebA and CIFAR-10. We tune our models by observing its training bpd. For density estimation on CIFAR-10 and ImageNet 3232, the models were run on two Titan XP GPUs. In other cases the model was run on one Titan XP GPU.

\paragraph{Classification setup.} Following \cite{i-resnet}, we pad the images to 16 channels with zeros. This corresponds to the first convolution in ResNet which increases the number of channels to 16. Both ResNet and our MintNet are trained with AMSGrad~\cite{reddi2018on} for 200 epochs with the cosine learning rate schedule~\cite{loshchilov2016sgdr} and an initial learning rate of 0.001. Both networks use a batch size of 128.

\paragraph{Classification architecture.} The ResNet contains 38 pre-activation residual blocks~\cite{he2016identity}, and each block has three  convolutions. The architecture is divided into 3 stages, with 16, 64 and 256 filters respectively. Our MintNet uses 19 grouped invertible layers, which include a total of 38 residual invertible layers, each having three  convolutions. Batch normalization is applied before each invertible layer. Note that batch normalization does not affect the invertibility of our network, because during test time it uses fixed running average and standard deviation and is an invertible operation. We use 2 squeezing blocks at the same position where ResNet applies subsampling, and matches the number of filters used in ResNet. To produce the logits for classification, both MintNet and ResNet first apply global average pooling and then use a fully connected layer (see \tabref{tab:classification}).

\paragraph{Density estimation setup.}
We mostly follow the settings in \cite{maf}. All training images are dequantized and transformed using the logit transformation. Networks are trained using AMSGrad~\cite{amsgrad}. On MNIST, we decay the learning rate by a factor of 10 at the 250th and 350th epoch, and train for 400 epochs. On CIFAR-10, we train with cosine learning rate decay for a total of 200 epochs. On ImageNet 3232, we train with cosine learning rate decay for a total of 350k steps. All initial learning rates are 0.001. 

\paragraph{Density estimation architecture.}
For density estimation on MNIST, we use 20 paired Mint layers with 45 filters each. For both CIFAR-10 and ImageNet 3232, we use 21 paired Mint layers, each of which has 255 filters. For all the three datasets, two squeezing operations are used and are distributed evenly across the network  (see \tabref{tab:mnist_density} and \tabref{tab:cifar_imagenet_density}). 

\paragraph{Tuning the step size for sampling.}
We perform grid search to find hyperparamter  for \algoref{alg:solver} using a minibatch of 128 images. More specifically, we start from  to 5 with a step size 0.5 for MNIST, CIFAR-10, and ImageNet 3232, and compute the normalized  reconstruction error with respect to the number of iterations. The normalized  error is defined as , where  and  are two image vectors corresponding to the original and reconstructed images. We find that the algorithm converges most quickly when  is in intervals ,  and  for MNIST, CIFAR-10 and ImageNet 3232 respectively. Then we perform a second round grid search on the corresponding interval with a step size 0.05. In this case, we are able to find the best , that is  for the corresponding datasets.

\paragraph{Verification of invertibility.}
To verify the invertibility of MintNet, we study the normalized  reconstruction error for MNIST, CIFAR-10 and ImageNet 3232. The  reconstruction error is computed for 128 images on all three datasets. We plot the exponential of the mean log reconstruction errors in \figref{fig:invert}. The shaded area corresponds to the exponential of the standard deviation of log reconstruction errors.


\begin{table}
	\small
	\centering
	\caption{MintNet image classification network architecture.}
	\begin{tabular}{l|c|c}
		\hline\bigstrut
		\bf Name & \bf Configuration & \bf Replicate Block \\
		\hline\bigstrut
		\multirow{12}{*}{\shortstack{Paired Mint Block1\\ with Batch Normalization}}
		& batch normalization\\
		&  lower triangular masked convolution, 1 filter
		& \multirow{10}{*}{}\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter \\
		& batch normalization\\
		&  upper triangular masked convolution, filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{12}{*}{\shortstack{Paired Mint Block2\\ with Batch Normalization}} 
		& batch normalization\\
		&  lower triangular masked convolution, 1 filter
		& \multirow{10}{*}{}\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter \\
		& batch normalization\\
		&  upper triangular masked convolution, filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{12}{*}{\shortstack{Paired Mint Block3\\ with Batch Normalization}} 
		& batch normalization\\
		&  lower triangular masked convolution, 1 filter
		& \multirow{10}{*}{}\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter\\
		& leaky relu activation& \\
		&  lower triangular masked convolution,  filter \\
		& batch normalization\\
		&  upper triangular masked convolution, filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		& leaky relu activation& \\
		&  upper triangular masked convolution,  filter \\
		\hline\bigstrut
		\multirow{3}{*}{Output Layer}
		& average pooling
		& \multirow{3}{*}{---}\\
		& fully connected layer\\
		& softmax layer\\
		\hline
	\end{tabular}
\label{tab:classification}
\end{table}



\begin{table}
	\small
	\centering
	\caption{MintNet MNIST density estimation network architecture.}
	\begin{tabular}{l|c|c}
		\hline\bigstrut
		\bf Name & \bf Configuration & \bf Replicate Block \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block1} 
		&  lower triangular masked convolution, 45 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block2} 
			&  lower triangular masked convolution, 45 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block3} 
		&  lower triangular masked convolution, 45 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline
	\end{tabular}
\label{tab:mnist_density}
\end{table}



\begin{table}
	\small
	\centering
	\caption{MintNet CIFAR-10 and Imagenet 3232 density estimation network architecture.}
	\begin{tabular}{l|c|c}
		\hline\bigstrut
		\bf Name & \bf Configuration & \bf Replicate Block \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block1} 
		&  lower triangular masked convolution, 85 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block2} 
			&  lower triangular masked convolution, 85 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline\bigstrut
		Squeezing Layer & 
		 squeezing layer & {---} \\
		\hline\bigstrut
		\multirow{10}{*}{Paired Mint Block3} 
		&  lower triangular masked convolution, 85 filters
		& \multirow{10}{*}{}\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters\\
		& elu activation& \\
		&  lower triangular masked convolution,  filters \\
		&  upper triangular masked convolution, filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		& elu activation& \\
		&  upper triangular masked convolution,  filters \\
		\hline
	\end{tabular}
\label{tab:cifar_imagenet_density}
\end{table}


\clearpage
\section{Additional tables}
\label{app:tables}
\vspace*{\fill}
\FloatBarrier
\begin{table}[H]
 \caption{Comparison to some common invertible models.} \label{tab:compare}
\begin{center}
		\begin{adjustbox}{max width=\textwidth}
    \begin{tabular}{c | c c c c c c | c}
				\Xhline{2\arrayrulewidth}\bigstrut
        Property & NICE & Real-NVP & Glow & MaCow & FFJORD & i-ResNet & MintNet\\
				\Xhline{1\arrayrulewidth}\bigstrut
        Analytic Forward & \cmark & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark\\
        Analytic Inverse & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark\\
        Non-volume Preserving & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
        Exact Likelihood & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark\\
	    \Xhline{2\arrayrulewidth}
    \end{tabular} 
    \end{adjustbox}
\end{center}
\end{table}

\begin{table}[H]
 \caption{Sampling time for 64 samples for MintNet, i-ResNet and autoregressive method on the same model architectures. The time is evaluated on a NVIDIA TITAN Xp.} \label{tab:sample_time}
\begin{center}
    \begin{tabular}{p{5cm} c c c}
        \toprule
        Method & MNIST & CIFAR-10 & ImageNet 3232\\
        \midrule
        i-ResNet~\cite{i-resnet} (100 iterations) 
&11.56s &99.41s &92.53s\\ 
        Autoregressive (1 iteration) &63.61s &2889.64s &2860.21s\\
        \midrule
        MintNet (120 iterations) (ours) 
&12.81s  &117.83s  &120.78s\\
        \bottomrule
    \end{tabular} 
\end{center}
\end{table}
\FloatBarrier
\vfill
\clearpage
\section{More Samples}
\label{app:samples}
In this section, we provide more uncurated MintNet samples on MNIST, CIFAR-10 and ImageNet 3232.
\vspace*{\fill}
\FloatBarrier
\begin{figure}[H]
\centering
\includegraphics[width=0.70\textwidth]{diagrams/samples_mnist20.png}
\caption{MintNet MNIST samples.}
\label{fig:samples_mnist}
\end{figure}
\FloatBarrier
\vfill
\vspace*{\fill}
\FloatBarrier
\begin{figure}
\centering
\includegraphics[width=0.70\textwidth]{diagrams/samples_cifar20.png}
\caption{MintNet CIFAR-10 samples.}
\label{fig:samples_cifar10}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{diagrams/samples_imagenet20.png}
\caption{MintNet ImageNet 3232 samples.}
\label{fig:samples_imagenet32}
\end{figure}
\FloatBarrier
\vfill \end{document}
