\documentclass[UKenglish]{llncs}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\IfFileExists{pdfsync.sty}{\usepackage{pdfsync}}{}







\newtheorem{define}{Definition}



\newenvironment{idproof}{{\bf Sketch of the proof}~:}{\hfill  }
\newenvironment{code}{{\bf Du code}~:}{\hfill \textit{} }
\def\E{\mathop{\mathbb{E}}\nolimits}
\def\ETf{\mathop{\mathbb{E}(T)}\nolimits}
\def\ENp{\mathop{\mathbb{E}(N_p)}\nolimits}
\def\Var{\mathop{\text{Var}}\nolimits}
\newcommand\motnouv[1]{{\emph{#1}}}
\newcommand\refOriginal{\textcolor{red}{ref}}


\newcommand\A{\mathcal{A}}
\newcommand\B{\mathfrak{B}}
\newcommand\C{\mathfrak{C}}

\newcommand\SSS{\mathcal{S}}
\newcommand\f{\mathfrak{F}}
\newcommand\ttt{\mathfrak{t}}
\newcommand\RL{\mathfrak{R}}

\newcommand\III{\mathcal{ND}}
\newcommand\D{\mathcal{D}}
\newcommand\F{\mathcal{F}}
\newcommand\T{\mathcal{T}}





\newcommand\N{\mathbb{N}}
\newcommand\Z{\mathbb{Z}}
\newcommand\Q{\mathbb{Q}}
\newcommand\Qp{\mathbb{Q}_{\ge 0}}
\newcommand\Qg{\mathbb{Q}_{> 0}}
\newcommand\eps{\epsilon}
\newcommand\id{identifier}
\newcommand\ids{identifiers}
\newcommand\idd{identifiers}
\newcommand\Part{\mathscr{P}}
\newcommand\Pred{\mathcal{P}}
\newcommand{\fBB}{\mathfrak{BB}_{RTFM}}



\newcommand{\grad}{\mbox{\text{grad}}}
\newcommand\vx{{x}}
\newcommand\ve{{e}}
\newcommand\vy{{y}}
\newcommand\vz{{z}}
\newcommand\II{{R}}
\newcommand\I{{I}}
\newcommand\vectorl[1]{{\mathbf#1}}
\newcommand\R{\mathbb{R}}
\newcommand\TODO[1]{\textcolor{red}{#1}}
\pagestyle{plain}


\begin{document}

\title{Homonym Population Protocols}
\titlerunning{Homonym Population Protocols}







\newcommand\at{}


\author{Olivier Bournez\and Johanne Cohen \and Mika\"el Rabie}
\institute{O. Bournez \at LIX, Ecole Polytechnique,  91128 Palaiseau Cedex, France
\email{bournez@lix.polytechnique.fr}
\and
J. Cohen \at
Universit\'{e} de Paris-Sud,
LRI, B\^{a}timent 425,\\
F-91405 Orsay Cedex, France\\\email{Johanne.Cohen@lri.fr}
\and M. Rabie \at LIX, Ecole Polytechnique,  91128 Palaiseau Cedex,
France
and Université Paris-Dauphine, 116 avenue du Président Wilson 93100 Montreuil Sous Bois France
\email{mikael.rabie@lix.polytechnique.fr}
}


\date{Received: \today/ Accepted: date}



\maketitle

\begin{abstract}
The population protocol model was introduced by Angluin \emph{et  al.}
as a model of passively mobile anonymous finite-state agents. This model  computes a
  predicate on the multiset of their inputs via interactions by
  pairs. The original population protocol  model has been proved to compute only semi-linear
  predicates and has been recently extended in various ways. 
  
 
In the community protocol model by Guerraoui and Ruppert, agents have unique identifiers but
  may only store a finite number of the identifiers they already heard
  about.  The  community protocol model    provides the power of a
  Turing machine with a  space.
   We consider variations on the two above models and we obtain a whole
  landscape that covers and  extends  already known results.

Namely, by  considering the case of homonyms, that is to say the case when several agents may share the same
identifier, we provide a hierarchy that goes from the case of no
  identifier   (population protocol    model)
  to the case of unique identifiers  (community protocol
  model). We obtain in particular 
  that any Turing Machine on space
  
  can be simulated with at least 
  identifiers, a result filling a gap left open in all previous studies.


   

Our results also extend and revisit in particular the hierarchy
  provided by Chatzigiannakis \emph{et al.} on population protocols
  carrying Turing Machines on limited space, solving the problem of
  the gap left by this work between per-agent space  (proved to be
  equivalent to population protocols) and  (proved to be
  equivalent to Turing machines).
       


\end{abstract}



\section{Introduction}



Angluin \emph{et al.}  \cite{AspnesADFP2004} proposed a  
distributed computation model called {\em population protocols}. It is a minimal model that aims at modeling large
sensor networks with resource-limited anonymous mobile agents. The
mobility of the agents is assumed to be unpredictable (but has to respect some
fair scheduler) and pairs of agents can
exchange state information when they are close
together.  

The population protocol model is also considered as a computational model, in
particular computing predicates: Given some input configuration, the
agents have to decide whether it satisfies the predicate.
The population of agents has to eventually stabilize to a
configuration in which every agent is in an accepting state or a
rejecting one. This should not depend on the size of the population,
i.e for any
size of input configuration. 

The seminal work of Angluin \emph{et
al.} \cite{angluin2007cpp,AspnesADFP2004} proved that predicates
computed by population protocols are precisely first-order formula in Presburger arithmetic
(equivalent to a semilinear set).  Subsets definable
in this way are rather restricted, as multiplication for example is not
expressible in Presburger
arithmetic. 
Several variants
of the original model have been 
studied in order to strengthen the population protocol model with
additional realistic and implementable assumptions, in order to improve the
computational power. This includes natural restrictions like modifying the assumptions between
agent's interactions (one-way communications \cite{angluin2007cpp},
particular interaction graphs \cite{AngluinACFJP2005}).  This also
includes the 
Probabilistic Population Protocol model that makes a random scheduling
assumption for interactions~\cite{AspnesADFP2004}.  Also fault tolerance have been taken account  for population protocols
\cite{Delporte-GalletFGR06}, including the self-stabilizing
solutions \cite{OPODIS}.  We refer to
\cite{PopProtocolsEATCS,ChatzigiannakisMS10} for a 
survey.



Among many variants of population protocols, the \emph{passively mobile
(logarithmic space) machine model} introduced by Chatzigiannakis \emph{et
  al.}  \cite{chatzigiannakis2011passively} generalizes  the population protocol model where finite state
agents are replaced by agents that correspond to arbitrary Turing
machines with  space per-agent, where  is the number
of agents.  An exact characterization
\cite{chatzigiannakis2011passively} of computable predicates is given: this model can compute all symmetric predicates in 
as long as .  Chatzigiannakis \emph{et al.}
establish that  the
model with a space in agent in   is equivalent to population protocols, i.e. to the case
. 


In parallel, \emph{community protocols} introduced by Guerraoui and
Ruppert~\cite{guerraoui2009names} are closer to the original
population protocol model, assuming \textit{a priori} agents with
individual very restricted computational capabilities.  In this model,
each agent has a unique
identifier and  can only store  other agent
identifiers, and only identifiers from agents that it met.  Guerraoui
and Ruppert~\cite{guerraoui2009names} using results about the
so-called storage modification machines \cite{schonhage1980storage},   proved
that such protocols 
simulate  Turing machines:  predicates computed by this
model with  agents are precisely the predicates in .


This work aims at obtaining a whole landscape that covers and extends
already known results about \emph{community protocol} models and
population protocols carrying Turing Machines on limited space.
  
First,   
we drop the hypothesis of unique identifiers. That is to say,  agents may have homonyms. We obtain a hierarchy that goes from the case of no
  identifier (i.e. population protocol
  model) to the case of unique identifiers (i.e. community protocol
  model). In what follows,  denotes the number of distinct available
  identifiers on a population with  agents.  Notice that the idea
  of having less identifiers than agents, that is to say of having ``homonyms'',  has already been considered
  in other contexts or with not closely related problematics 
  \cite{Delporte-Gallet:2011,Delporte-Gallet:2012,ArevaloAIJR12,Guiseppe2013}. 


Second, our results also extend the \emph{passively mobile
machine model}. In particular,
Chatzigiannakis \emph{et
  al.}  \cite{chatzigiannakis2011passively}  solved the cases
 (equivalent to population protocols) and
 (equivalent to Turing machines).
We provide a characterization for the case :
the model is equivalent to
   (see Table \ref{tab:Chatzigiannakis}).






To sum up, Tables~\ref{tab:Guerraoui}
and~\ref{tab:Chatzigiannakis} summarize  our results. 
 (respectively:  ) is the set of
-symmetric\footnote{These classes are defined in Section~\ref{sec:def}.} (resp. also stable under
the permutation of the input multisets) 
languages recognized by non deterministic Turing
machines on space . 
   \begin{table}
\vspace{-0.3cm}
\begin{center}
\begin{tabular}{c|c}
 identifiers   &  Computational power\\\hline
 & Semilinear Sets \\
& \cite{angluin2007cpp,AspnesADFP2004} \\  \hline
 &
 \\
with &   Theorem \ref{th:main} \\ 
\hline
&   \\
with & Theorem \ref{th:sqrt} \\
\hline 
 &  \\
& \cite{guerraoui2009names} \\\end{tabular}
\end{center}
\caption{Homonym population
protocols with  agents and  distinct identifiers.}
\label{tab:Guerraoui}

    \end{table}




\begin{table}
\vspace{-1.5cm}
\begin{center}
\begin{tabular}{c|c}
Space per agent  & Computational power \\\hline
   & Semilinear Sets  \\
                      &  \cite{angluin2007cpp,AspnesADFP2004}  \\  \hline
    &  Semilinear Sets  \\
                                             &
              \cite{chatzigiannakis2011passively} \\ \hline
       &    \\
                                     &  Theorem \ref{th:grec}\\ \hline
) &  \\
   &    \cite{chatzigiannakis2011passively} \\
\end{tabular}
\end{center}
      \caption{Passively mobile
machine model~\cite{chatzigiannakis2011passively}
with  agents and space  per agent.}
\label{tab:Chatzigiannakis}

 \end{table}


 

The document is organized as follows. Section~\ref{sec:2} introduces the formal definitions of the different
models and main known results. 
Section~3 introduces the definition of a new class of Turing Machines that will
help for the characterization of our models.
Section~\ref{sec:3p} is devoted to the case where there is
a polylogarithmic number of different identifiers in the population.
Section~\ref{resthirera} deals with the case where the population's number of identifiers is constant,
 and . 
Section~\ref{sec:4demi} treats the case  in the
passively mobile machine model~\cite{chatzigiannakis2011passively} (see Table 2).
Finally Section~\ref{sec:5} is  a summary of our results with some open questions. 
























\section{Models}
 \label{sec:2}

Population protocols have been mostly considered up to now as computing predicates:
one considers protocols such that starting from some initial
configuration, any fair sequence of pairwise interactions must
eventually lead to a state where all agents agree and either accept
or reject. A protocol computes a predicate if it accepts the inputs
verified by this predicate (and refuses the others).
Algorithms are assumed to be uniform: the protocol description must be 
independent of the number  of the agents.

The models we consider are variations of the {\em community
  protocol} model~\cite{guerraoui2009names}. This latter model is in
turn   considered as an extension of the population protocols.
In all these models, a collection of
agents is considered. Each agent has a
finite number of possible states and an input value, that
determines  its initial state. Evolution of states of agents is the
product of pairwise interactions between agents: when two agents meet,
they exchange information about their states and simultaneously update
their own state according to a joint transition function, which
corresponds to the algorithm of the protocol. The precise
sequence of agents involved under the pairwise interactions is 
under the control of any fair scheduler.
The considered
notion of fairness for population protocols states that every 
configuration that can be reached infinitely often is eventually
reached.






In order to avoid multiplication of names, we will write community protocols for the
 model introduced by Guerraoui and Ruppert \cite{guerraoui2009names}, and homonym population protocols
for our version. 
The main difference between the two is the following: 
Let  be the infinite set containing the possible
identifiers. 
We assume that the possible identifier set  is not 
arbitrary: we assume that . 
We also assume these  identifiers are not necessarily
unique: several agents may have the same  identifier.
In a population of size , we suppose that there are  distinct identifiers. 



More formally, a  community  protocol / homonym population protocol
algorithm is then specified by:
\begin{enumerate}
\item an infinite set  of the possible identifiers.
In the Homonym case, .
\item a function  mapping the size of the population to the number of \idd{}  appearing in this population. In the community
protocol case,  is identity. 
\item a finite set  of possible internal states;
\item an integer  representing the number of  {identifier}s that can be
  remembered by an agent;
\item some input alphabet  and some output alphabet ;
\item an input map  and an output map ;
\item a transition function   , with
  .
\end{enumerate}

\begin{remark}
For sake of clarity,   is a function, but this could be a relation as in the community protocol definition
\cite{guerraoui2009names}, without changing our results. 
\end{remark}

\begin{remark} Unlike in the population protocol model, each agent's
  state is given by its  identifier and    identifiers stored.  
If any of the  slots is not currently storing an identifier, it
contains the \emph{null}  identifier .  In other words,
 is the set
of possible agent states.  
\end{remark}

The transition function   indicates the
result (state shift) of a pairwise interaction: when agents in respective state
 and  meet, they move to respectively state  and
 whenever .

As in the community model \cite{guerraoui2009names},  agents store only  identifiers
they have learned from other agents (otherwise, they could be used as
an external way of storing arbitrary information and this could be used as
a space for computation in a non interesting and trivial way): 
if , and  appears in
   then  must appear in  or in .

The identifiers of agents
are chosen by some adversary, and not under the control of the
program. 

We add two hypothesis to the community model \cite{guerraoui2009names}:
agents need to know when an identifier is equal to  and when
two identifiers are consecutive (i.e. ).
More formally, this is equivalent to say that 
whenever , let   
be the distinct  identifiers that appear in any of
  the four states .
Let  be identifiers such that   and .
If  is the state obtained from  by replacing all
  occurrences of each identifier  by , then we require that
  . 


 We also suppose that
every identifiers in  are present in the population. As we want to be
minimal,  those are the only hypothesis we make on identifiers in the following
sections. 






\begin{remark} \ 

\vspace{-0.3cm}
\begin{itemize}
\item This weakening of the community protocols does not change the computational
power in the case where all agents have distinct identifiers.
\item 
Our purpose is to establish results with minimal hypothesis. Our
results work  when identifiers are consecutive integers, say
.  
This may be thought as a restriction. This is why we weaken to the
above hypothesis, which seems to be the minimal hypothesis to make our
proofs and constructions correct. 

We conjecture that without the possibility to know if an identifier is
the successor of another one, the model is far too weak. Without this
assumption, our first protocol (in  Proposition~) does not work.
\item
Notice that 
knowing whether an identifier is equal to  is not essential, but eases
the explanation of our counting protocol of Proposition~.
\end{itemize}
\end{remark}


  From now on, an agent in state  with initial identifier  and
   the list storing the  identifiers is denoted
  by  or .  If the list  is not
  relevant for the rule, we sometimes write  where  is the agent's identifier.


A \emph{configuration}  of the algorithm then consists of a finite vector of
elements from :  it is a set of  agent's states.
An \emph{input of size } is given by  non empty multisets 
over alphabet .
An initial configuration for  agents is a vector in 
of the form 
where  is the th element of . In other words, every agent 
starts in a basic state encoding , its associated
identifier  and
no other identifier stored in its  slots (since it met no other agent). 



 If  and  are two
configurations, then we say that  ( is reachable from 
in a unique step) if   is obtained by executing only one step of the transition function. In other words,  there are  such that
 and  for all  different
from  and . An execution is a sequence of configurations  such that  is an initial configuration, and  for all . An execution is fair if for each
configuration  that appears infinitely often and for each 
such that ,  appears infinitely often.
 
























\begin{example}[Leader Election]
  We want to design a protocol that performs a leader election, with the additional
  hypothesis that when the election has finished, all agents know the
  identifier of the leader.

  We adapt here a classical example of Population Protocol (Recall that in the  Population Protocol, this
  is not possible to store the identifier of the leader and hence this
  is not possible to compute the leader's identifier; Here this is
  possible as identifiers can be stored):
    Each agent with identifier  starts with state ,
  considering that the leader is an agent with identifier . We want to design a protocol such that
  eventually at some time (i.e in a finite number of steps), there
  will be a unique agent in state , where  is the
  identifier of this unique agent, and all the other agents in state
   (where  is its identifier).

 A protocol performing such a leader election is the following: 
, , , 
 (only the identifier of the current leader is stored), 
, , 
, 
, 
and    such that the rules are: 
\begin{center}
\begin{tabular}{ l @{\hspace{0,2cm}} l @{} l
    @{\hspace{0,2cm}} l @{\hspace{1cm}} l }
   &  &  &   & \\
   &  &  &   & \\
 &  &  &  & \\
 &   &    &  & \\
 &  &  &  & \\
\end{tabular}
\end{center}

By the fairness assumption, this protocol will
reach a configuration where there is exactly
one agent in state  for some identifier .
Then, by fairness again, this protocol will reach the
final configuration such that only agent is in state  and all the other agents are in state  with .


\end{example}




A configuration has an \motnouv{Interpretation}  if, for each agent in the
population, its state  is such that . If there are two agents in state
 and  such that , then we say that the
configuration has \motnouv{no Interpretation}.
A protocol is said to \motnouv{compute the output}  from an input   if,
for each fair sequence  starting from an
initial condition  representing , there exists 
such that, for each ,  has the interpretation .
The protocol is said to compute function  if
it computes  for all inputs .
A predicate is a function  whose range is 
. As usual, a predicate can also
be considered as a decision problem, and a decision problem is said to
be decided if its characteristic function is computed. 






Observe that  population protocols 
\cite{angluin2007cpp,AspnesADFP2004} are the special case  of the
protocols considered here where  and .
The following is known for the population protocol model~\cite{angluin2007cpp,AspnesADFP2004}: 

\begin{theorem}[Population Protocols \cite{angluin2007cpp}]
Any predicate over  that is first order definable in
Presburger's arithmetic can be computed by a population protocol.
Conversely, 
any predicate computed by a population protocol is a subset of
 first order definable in
Presburger's arithmetic.
\end{theorem}










For the community protocols, Guerraoui and Ruppert~\cite{guerraoui2009names} 
established     that computable predicates
are exactly those of , i.e. those of  the class
  of languages recognized in non-deterministic space .


Notice that their
convention \cite{guerraoui2009names}  of input   requires that the input be distributed on agents ordered by
identifiers. 







\begin{theorem}[Community Protocols
\cite{guerraoui2009names}] \label{th:eux}
Community protocols can compute  any predicate in . 
Conversely, any predicate computed by such a 
community protocol is in the class .
\end{theorem}

Notice that Guerraoui and Ruppert \cite{guerraoui2009names}
established that this holds even with Byzantine agents, under some
rather strong conditions.  We now determine what can be computed when
the number of identifiers  is smaller than . This will be
done by first considering some basic protocols.




\section{Definitions}
\label{sec:3}







































Our  main aim  is to determine exactly what can be computed
with homonym population protocols. We first need to introduce
Turing Machines that has inputs analog to homonym protocols. To perform it
we  will define the notion of \emph{-symmetry} language,
and   the  class .




A multiset of elements from some set  is also  seen as a
word over alphabet : list the elements of the multiset in any
order, and consider the list as a word. Of course, any permutation of
this word corresponds to the same multiset. 

We focus on languages made of  multisets over alphabet
. From the above remark, this is seen as words over alphabet
, and hence as -Symmetric languages in the
following sense: 


\begin{define}\label{defmnspace}
 Let  be a function. 
A Language  over alphabet  is  \motnouv{-Symmetric} if  and only if:
\begin{itemize}
\item \#;
\item Words of  are all of the form \#\#\#, with  and
, ;
\item If, ,  is a permutation of , and if \#\#\#, 
then \\ \#\#\#;

\end{itemize}
\end{define}

The complexity class associated to   -symmetric languages is :


\begin{define}[]
Let  be a function 
. The set of -symmetric languages recognized by Non Deterministic
Turing Machines on  space  is the class   \motnouv{}
 or  \motnouv{} when  is unambiguous.
\end{define}


\begin{remark}  since each multiset
must then contain exactly one element.
       as accepting a multiset
is exactly being stable under input permutation.
\end{remark}

Now, we will define a collection of languages called \emph{Included Language} in . 

\begin{define}
Let  be a positive integer and let  be a finite
sequence of multisets of elements from .
 is a  \motnouv{included language}, if and only if, for all , .
\end{define}

This corresponds to finite sequences of non-empty multisets where each
multiset is included in the previous one. Using the above
representation trick (representing a multiset by a word up to
permutation) this can also be considered as a -Symmetric
language.


\begin{proposition}
Any included language  is in  where .
\end{proposition}
\begin{proof}
Let  be a positive integer and let  be an included language.
 denotes the number of  in a multiset . 

To check whether   is equivalent to check, whether 
for each . 
This can be performed on a space . 
In other words,  the language is accepted if and only if there do not exist  and  such that
.\hfill \qed

\end{proof}








 
\begin{proposition} Let  be a positive integer and let  be an included language
and let .


  can be decided by a homonym population protocol of  agents having  distinct identifiers.
\end{proposition}
\begin{proof}


The high-level description of the protocol is  described in order to check whether  for every .  Thus,   implies that each
agent in  manages to "delete" an agent with the same input in
.


In our protocol, each agent with an identifier  looks for
an agent of identifier  with the same input to "delete" it. 
More formally, consider:

\begin{itemize}
\item .
\item .
\item .
\item  .
\item , , ,
.
\item  is such that the non trivial rules are:
\end{itemize}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}}  l l}
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & \\
\end{tabular}
\end{center}

The state of each agent is composed of four elements:
\begin{enumerate}
\item The first element corresponds to its input symbol.
\item The second is equal to  if the agent with  identifier has not yet "deleted" an
agent with the same input and with  identifier. It is equal to 
if the deletion has already been performed.
\item The third element is equal to  if it has not been deleted yet by an agent
with the successor identifier. It is  as soon as the deletion has been performed.
\item The fourth element corresponds to the output. State  means that
the agent needs to perform a deletion. The agent knows that the input has to be 
as long as it has not deleted an agent with the previous identifier. State  means
the agent believes that at least one deletion needs to be performed.
State  means that the agent made its deletion and since did not meet agent needing
to perform a deletion. State  means that the agent believes that no deletions need to be done.
\end{enumerate}

Rule  handles that agents with identifier  does not need to do a deletion.
Rule 2 handles a deletion.

If we project on the fourth element, the stable configuration are
 and .

Rule 3 spreads the output  to each agent. It can only come
from an agent still waiting for a deletion. If a deletion needs to be done
and cannot be, the output  will be spread by fairness.

Rule 4 spreads the output  from  to  agents.
If there are no longer deletions to do, there is at least one  in the population,
being from the agent that has performed the last deletion.
It will spread the output  by fairness. \hfill \qed
\end{proof}







 




\section{A Polylogarithmic Number of Identifiers}\label{sec:3p}

In this section, the case where the population  contains   distinct
identifiers is considered. First, a protocol is designed in order to compute   the size of the population. 
When the population reaches a stable configuration (i.e. agents will no longer be able
to fin another one that will change its state), the size 
will be encoded in binary  on  agents. We will then show how to 
"read the input" and how to simulate a tape of length . To perform that,
we will explain a process that ensures that the protocol will at some point
do exactly what is expected.

\subsection{Organization As a Chain}

The first step is to organize  agents in a chain: 
We design a protocol that creates a chain containing all the existing identifiers such that an agent with identifier  is a successor of an agent with identifier .  This protocol consists of the execution of several leader Election protocols.
  The classical Leader Election protocol for population protocols distinguishes
one agent from all the others, usually by having all agents but one in state ,
the leader being in state   by using the simple rule  
. Here, instead of having a unique agent different from all the
others, it distinguishes one agent for each distinct identifier, by 
the simple trick that two agents truly interact only if
they have the same identifier.
Here is the protocol:
\begin{itemize}
\item .
\item .
\item , ,  and .
\item  has only one difference from the usual Leader Election:
the first rule is split according to the identifiers.
\end{itemize}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}}  l l}
 &  &  &  & \\
 &  &  &  & with \\
\end{tabular}
\end{center}

At some point, there will be exactly one  agent for each .
We will denote the leader with identifier  by . Moreover, 
we focus on the leader with identifier  denoted by   and called the .

For the remaining of this section, the \motnouv{Chain} will refer to these particular agents.
We will often see these agents as a tape of  symbols in 
sorted according to the identifiers.



\subsection{The Size of the Population}

In many classical population protocols, integers are encoded in unary.
Here, we will compute the size of the population on  agents in binary.
The size of the population will be encoded in binary on a chain
(it will be possible as  in this part), using the
concept of chain of previous section. 




\begin{proposition}\label{compte}
When the population has  distinct identifiers,
there exists an homonym population protocol that computes the size 
of the population: 
At some point,  all agents are in a particular state  except    agents having distinct identifiers.
If we align these agents from the highest identifier
to the lowest one,  then they encode the size of the population  written  in binary.
\end{proposition}



\begin{proof}
  In a high-level description, the protocol initializes all agents to a particular
  state . This protocol will implicitly include the chain construction
(instead of being in state , potential leaders will have their state
in ).
This protocol  counts the number of agents in state . An agent in state
   (respectively 0, or 2) with identifier  represents 
  (respectively 0, or ) agents counted. Interactions between
  agents are then built to update those counts. 

More formally, we have  . The rules  are the following:
\begin{center}
\begin{tabular}{ l @{\hspace{0,2cm}} l @{} l
    @{\hspace{0,2cm}} l @{\hspace{1cm}} l @{\hspace{2cm}}  l @{\hspace{0,2cm}} l
    @{\hspace{0,2cm}}l @{\hspace{0,2cm}} l @{\hspace{0,2cm}} l @{\hspace{1cm}} l }
 &  &  &  &   &  &  &  & &  & \\
 &  &  &  &  &  &  & & &  & \\
 &  &  &  &  &  &  & & &  &  \\
 &  &  &  &  &       &            &  &            &            & \\
 &  &   &  & &       &            &   &          &            &\\
\end{tabular}
\end{center}

This protocol is split into 3 steps. (i) At the beginning, all agents are in state .  A state  is
  transformed  into a state , by adding  to an agent of
  identifier  corresponding to the  first rules of the left column. (ii) The remaining rules of the left column correspond to summing together the counted agents, carrying on to the next identifier the .
 (iii) Rules of the right column are here
to perform in parallel the chain protocol.


Let  be the function over the states defined as follows for any :
, , , .  We
can notice that the sum of  values over all the agents remains constant over the
rules. Thus the sum always equals the number of agents in the
population.

By fairness, all the agents in state  will disappear, the chain will finish, and the agent in state  will disappear.
Hence, the protocol writes the size of the population on the chain in binary. \hfill \qed
\end{proof}

\begin{remark}
The  previous counting protocol also works with .
Indeed, if for some  we have ,
then, using a base  instead of a base 2 allows that  can
be written on  digits.
\end{remark}

\begin{remark}   The  previous counting protocol  works if the population can detect that  an identifier is equal to . 
This protocol can be adapted to a population 
with identifiers in . For this, agents store an identifier 
corresponding to the minimal one they met (called here ). An agent with identifier  and state 
stores . When it meets an identifier equals to ,
it looks for a leader with identifier  to give it its stored integer.
\end{remark}


Once 
a chain is constructed, as above, it can be used to store numbers or
words. Thus it can be used as the tape of a Turing Machine. We will
often implicitly use this trick within the rest of the paper.  




\subsection{Resetting a Computation}

The computation of the size  (encoded as above) is crucial for the following protocols.  
We call \emph{leader}  an agent not in state  with identifier 0
from the previous protocol (or the chain protocol).


We will now provide a  \emph{Reset  protocol}. This protocol has the goal to reach a configuration
such that (i) the Counting protocol is finished, (ii) all agents except the leader are in state , and (iii)
the leader {\it knows} when this configuration is reached (i.e. the leader is
on a state  making him the belief the reset is done. The last time 
the protocol turn the leader's state into , the reset will be done).


This protocol will then permit to launch the computation of some other protocols
with the guarantee that, by fairness, at some point, all agents were counted, and hence covered.


\begin{define}
A \motnouv{Reset Protocol} is a homonym protocol that guarantees to reach a configuration
where:
\begin{itemize}
\item The size of the population has been computed. In particular, the population has
a unique leader at this point.
\item There exists a mapping function  such
  that leader's state is mapped to  and 
all other agents' states are mapped to . 
\end{itemize}

\end{define}
This configuration will be the beginning of the next computation step. All
agents will be ready, at this point, to start a next computation.
\begin{proposition}\label{prop:reset}
There exists a  Reset  Protocol.
\end{proposition}

\begin{proof}
 The high-level description  of the protocol relies on  starting back the reset protocol each time the leader sees that
  the counting protocol (of the previous proposition) has not finished yet. 


The leader turns agents in state . The chain lets the leader count the number of agents it turns into state .
If it has turned the same number of agents that the number computed by the
Counting protocol, then it turns its state into .
The protocol handles two counters in parallel. The first counter corresponds to the size of the population and the second counter
counts the number of agents that have been reset. We can notice that the leaders for each identifier will be the same on the first and second element,
and hence the chains will be the same for the two counters.



This mechanism is not as simple as it could look: the protocol uses the fairness
to be sure that at some point, it will have turned the right number of agents into state .\\

More formally, the set of states is  where  is the set
of states of the counting protocol (and  its interaction function). The first element of the triplet
is for the counting protocol, the second for the counting of agents turned into
state , and the third part is for the reset itself. At the beginning, all agents are in state . 
The second counting protocol will work a bit differently for the carry over.
The leader performs it by itself, walking through the chain, contrarily to the process
described in Proposition~\ref{compte}.

This protocol uses two identifiers slots. The first will be attached to the first counter:
the leader stores the greater identifier it heard about (each time it updates it,
we consider it has updated its state). The second is attached to the second counter.


Sometimes, rules will be of the form:
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}} l l }
 &  &  & . 
\end{tabular}
\end{center}
We will implicitly assume that .
If we write  (resp ) instead of  (resp ), then
it implies that  (resp ).
We will note  if the identifier  attached to  is relevant
(same for ).

We will describe  according to the steps of the process of resetting:
\begin{enumerate}
\item First, the leader needs to know when the counting protocol evolved.
For this, as soon as an interaction occurred, agents not being a leader go into state 
to warn the leader to restart the reset. The leader  then goes
into state  on its third element. (We can notice that in ,
there is a non trivial interaction with a leader if and only if the leader is the second element.
We can also notice that an agent with identifier  in state  is a leader.)
\end{enumerate}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}} l l }
 &  &  &  & with  or \\
 &  &  &  & with \\
\end{tabular}
\end{center}


\begin{enumerate}
\item[2.] In  state , the leader knows that the counting protocol is not finished yet. 
It turns all agents into state . At some point (when the leader is the second
element of an interaction), it stops and goes to state .

The idea is that by fairness, if we repeat again and again this process,
at some point, the leader will manage to have all other agents turned into state .
\end{enumerate}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}} l l }
 &  &  &  & with \\
 &  &  &  & with \\
\end{tabular}
\end{center}

\begin{enumerate}
\item[3.] In state , the leader clears the second chain
  corresponding to the swith econd counter of the reset agents.
This way, after the last change from the counting protocol,
we are sure that the chain will be cleared and will effectively
count all the agents.
The identifier attached to the first state gives to the leader the highest
identifier it saw. This way, it knows the last element's identifier in the chain.

The leader just keeps its own bit at , as it needs to
count itself. After that, the leader goes to state .
\end{enumerate}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}} l l }
 &  &  &
                                                                      
                                                                             &
                                                                               with -1 \\  and \\
 &  &  &  & with \\
\end{tabular}
\end{center}


\begin{enumerate}
\item[4] In state , the leader looks only for  agents. When it finds one
it turns it into a  and adds  to the second counter (by going to state ).
If it meets another state, it goes back to state , in order to try to
turn again all agents into  and to reset the counter.
\end{enumerate}
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}} l l }
 &  &  &  &\\
 &  &  &  & with \\
\end{tabular}
\end{center}


\begin{enumerate}
\item[5] In state , the leader increases the second counter by .
If it has a carry, it goes in state  as long at it is needed.
When the incrementation is over it goes back to state  until it
reaches the end of the chain or find a difference.
If it finds a difference, and if it still has to propagate the carry, then it goes in state .


Here, we see why the agents need another slot of identifier: the leader needs to
remember what was the last bit he saw
(to identify easily the next one to find). The identifier on the first state
allows to know until which identifier
it has to compare the two counters.


If it reaches the last bit of the chain and the two counters are equal,
then the leader believes the reseting is over and goes to state  (until
the counting protocol on the first element gets an update, if it happens).
If the counter is not yet equal, then it looks for another  to turn into a .
\end{enumerate}
\begin{center}
{\small
\begin{tabular}{ r @{\hspace{0,1cm}} l @{} r @{\hspace{0,1cm}} l l }
 &  &  &  &\\
 &  &  &  &\\
 &  &  &  &\\
 &  &  &  &\\
 &  &
                                              
                                                       &
                                                         
                                                                         &  \begin{minipage}{2.5cm}
                                                                           with
                                                                           
                                                                           and
                                                                           -1
                                                                           \end{minipage}\\
 & 1- &  & 1- & with \\
 &  &  &  & with \\
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & with -1\\ 
 &  &  &  & \\
 &  &  &  & \\ 
 &  &  &  &\\
\end{tabular}
}
\end{center}

To prove that this protocol will succeed, we know by fairness that the
counting protocol will finish at some point. There will be several agents in state .
By fairness, the leader will have seen all of them at some point.

Let consider a configuration appearing infinitely often.
We will show that the reset point can be reached from it
(and then will be reached by fairness).
\begin{itemize}
\item If the leader has its third state equal to , then we have it met all the agents to turn them
into . Then, we go into state  in a
population where all other agents are in state .
\item If the leader is in state , it can only do an interaction one
after another: clearing the chain by following the leaders one identifier
after another.
We then
reach , keeping the number of  in the population.
\item If the leader is in state ,
we have two cases:
\begin{itemize}
\item All agents are in state . It can be the case only if the leader's last
operation was becoming a  from a ,
hence the second counter is equal to . Then, if the leader repeats
the actions (turn an agent from  to  + increment the counter),
at some point the two counters will match, and the leader will reach the state .
\item At least one agent is not in state . We have the leader interacts with
it to go in state .
\end{itemize}
\item If the leader is in state , we can finish Step 5. The
leader will then be in state  or .
\item If the leader is in state , then the two counters must be equal.
Hence, the leader turned exactly the right number of agents from state  to ,
the reset is performed.
\end{itemize}
The population will reach at some point the desired configuration. \hfill \qed
 \end{proof}

To run the computations of the following protocols, we first reach the end
of this protocol. More precisely, the leader will start the next steps after
having reached the state . If at some point the leader replaces
the  with a  using the reset protocol, then it knows it has to restart
the next steps. While the leader will turn into  all the other agents,
it will also reset the computations elements from the next steps.

The last time the leader will turn into  and  will know that all
agents are ready to start the next steps. It also knows that the size of the population
is encoded correctly on the chain.



This protocol ensures that the leader has access to all the input
at some point. With population protocols, the leader will never be able to know
if it has turned every agent into some state , because it has not the
ability to know the size of the population.



\subsection{Access to the Input} 

We now
introduce a protocol that computes the number of agents
that had the input  and were given the identifier .

This is a sub-protocol that can be used by the
main protocol at any moment. Hence, the information cannot be definitively kept 
and has to be precisely given  at the requested moment.
We cannot accept any error as it could not be detected on time to correct the computation.



\begin{proposition}\label{prop:sid}
If we have  identifiers and 
if the reset protocol has finished,
for all input  and for all ,
there exists a protocol that writes on the chain the number of agents initialized
as .  
\end{proposition}

\begin{proof}
We assume that the population is already reseted to state  using a Reset Protocol.

We do not give here the formal description of protocol, only a description of its process:
\begin{enumerate}
\item[0.] The agents will have a state corresponding to a -tuples:
  \begin{itemize}
  \item the first element of the -tuple is assumed to implement the
    counting protocol of previous subsection. We assume that the reset
    protocol has finished, so the counting protocol on this
first element is over.
\item the second element of the -tuple will be used to count the agents
  with input .
\item the third element of the -tuple will be used to implement another counting protocol, similar to the one of previous section. This will be used to recount the population to check that
    every agent has met the leader since the beginning of this process
    (by checking that the value encoded by first elements is equal to
    the value encoded by third elements).
\item the last fourth element of the -tuple is
    here to determine whether the agent has already been  counted by the leader
    yet (for the counters corresponding to the second and third
    element of the 4-tuple).  It  is in
     and is equal to  if and only if the leader already
    counted it.
  \end{itemize}


\item The leader looks for an agent it has not recounted again (i.e. with its 4th state equals to ).
When it meets one, it switches this agent's internal state from  to , and it looks if its input was  or not. If it is, then it increments the second and the third counter,
otherwise it only increments  the third.
\item The leader then looks if the first and the third counter are equal. If not, it goes back to 
step , if yes the computation is over.
\end{enumerate}

Since the counting protocol is over (if not, the population will be reseted again and again
until the counting is over), the size is known. With that, we are sure to have counted each agent
started in state , as the leader must have seen each agent in this protocol before
finishing it.\hfill \qed

\end{proof}

\begin{remark}
  In other words, if at some moment, the population needs to know
the number of agents which started in the state , then this is
possible.
\end{remark}

\subsection{Turing Machine Simulation}\label{sec:def}

With all these ingredients we will now be able to access to the input
easily. We will also use the chain to simulate a tape of a
Turing Machine. 


The result obtained in this section  is a weaker bound than the one we will obtain latter. The principle of this proof helps to understand the stronger result.

\begin{proposition}
Any language in  can be recognized by an homonym population
protocol with  identifiers.
\end{proposition}

\begin{proof}
  The main key of this proof is to use the chain 
  as a tape for a Turing Machine. To simulate the tape of
  the Turing Machine, we store the position where the head of the
  Turing machine is by memorizing on which multiset the head is (via
  the corresponding identifier) and its relative position inside this
  multiset: the previous protocol will be used to find out the number of
  agents with some input symbol in the current multiset, in order to
  update all these information and simulate the evolution
  of the Turing Machine  step by step.

More precisely, let . There exists some  such that  uses at most  bits
for each input of size .
 To an input \#\#\#, we associate the input configuration
with, for each  and for each ,  agents in state  with the identifier ,
  being the number of  in .

The idea is to use the chain as the tape of the Turing Machine. We
give  bits to each agent,  so that
the protocol  has a tape of the correct length (the chain is of size ).
We just need to simulate the reading of the input (the writing
will be intuitively be performed by the leader keeping track of the identifier
of the agent where the machine's head is).
The protocol starts by counting the population and resetting agents after that.

We assume that symbols on  are ordered. Since the language recognized by  is -symmetric, we can reorganize the input by permuting the 's
such that the input symbols are ordered (i.e.  and 
).

Here are the steps that perform the simulation of reading the tape: 
\begin{enumerate}
\item[0.] The chain contains two counters. The leader also stores an identifier  and a state .
The first counter stores the total of  computed at some point by the protocol of
Proposition~ \ref{prop:sid}. The second counter  is the position the reading head.
The simulated head is on the th  of .
\item At the beginning of the protocol, the population counts the number of agents with input 
and identifier , where  is the minimal
element of .  is initialized to .
\item When the machine needs to go to the right on the reading tape, 
  is incremented. If  equals , then
the protocol looks for the next state  in the order of , and count the number of . If this
value is , then it takes the next one. If  was the last one, then the reading tape will consider to be on a \#.

If the reading head was on a \#, then it looks for the successor identifier of , and counts the number of .
If  was maximal, then the machine knows it has reached the end of the input tape.

\item The left movement process is similar to this one.
\end{enumerate}

This protocol can simulate the writing on a tape and the reading of the input.\\

To simulate the non deterministic
part, each time the leader needs to make a non deterministic choice
between two possibilities, it looks for an agent. If the first
agent the leader meets has its identifier equal to , then the leader makes
the first choice, otherwise it makes the second one.
When the computation is over, if it rejects, it reset the simulation
and starts a new one.

By fairness, if there is a path of non deterministic choices for the machine,
the protocol will at some point use it and accept the input, as would do .
If not, as all the agents will stay in a rejecting state, the protocol will reject
the input.

This protocol simulates .\hfill \qed

\end{proof}

\begin{corollary}
Let  such that . 

Any language in   can be recognized by an homonym population protocol with  identifiers.
\end{corollary}
\begin{proof}
We use the same protocol (which is possible as the size of the population can be computed).
Since the chain of identifiers has a length of , we have access to a tape of size .\hfill \qed

\end{proof}

\subsection{Polylogarithmic Space}

We prove now the exact characterization of what can be computed
by our model: functions computable by Turing Machines on
polylogarithmic space. To prove it, we first prove several propositions.
The combination of the three following results permit to conclude the main theorem.




















\begin{proposition}\label{prop:truc}
Let  such that .
Let  be a positive integer.

Any language in  can be recognized by a protocol
with  identifiers.
\end{proposition}

\begin{proof}
The idea here is that, by combining several identifiers together, we get much more identifiers available, increasing
the chain and space of computation: Indeed, if we combine  {\id}s together
in a -tuple, then we get  possible identifiers. The basic idea is to
count in base : the leader finds  agents and
distribute to each of them a unique new identifier (encoding as a -tuple of
original identifiers). 

To do so, first the population performs the computation of the size of
the population. This also builds a chain of
all the identifiers. Then, the leader creates a counter of  identifiers, initialized at  (seen as the number
 written in base ). It looks for an agent in state 
(i.e.  corresponds to the state of a agent which has not been given
a -tuple identifier yet) and transmits its new identifier: that is the
current -tuple stored in the leader. The leader then increments his
counter by . As soon as it has finished (by giving  or  identifiers, depending on what happens first),
the protocol can then work on a tape of space .

Since , there exists some  such that .\hfill \qed

 \end{proof}

\begin{proposition}
Let  such that there exists some real  such that we have .

Any language in  can be
recognized by an homonym population protocol with  identifiers.
\end{proposition}
\begin{proof} 
We only need to treat the counting protocol when  (the case  is treated in Proposition~\ref{prop:truc},
the case  is a direct corollary of this proposition).

In previous constructions, to count the population, we needed at least
 identifiers. The idea is to use -tuples to encode
identifiers, when the number of identifiers is too low. 

By taking   we have ,
and a counting protocol can be implemented after distributing these
new identifiers (using a process similar to previous proposition). 

More precisely, in the counting protocol, when agents realize that  might be reached and they need more identifiers, they use the tuple,
storing the maximal \id\ . If at some point, they realize that a higher \id\  exists,
they just do an appropriate update of the numbers stored in the chain.\hfill \qed

  \end{proof}



















\begin{proposition}\label{th:olivier}
Consider a predicate computed by a protocol with 
identifiers. Assume that  for some .   

The predicate is in  for some positive integer . 
\end{proposition}
\begin{proof}
We need to prove that there exists a Turing Machine that can compute, for any given input ,
the output of protocol .

From definitions, given some input ,  outputs the output  on
input  if and only if  there exists a finite sequence , starting from an
initial condition  representing , that reaches at some finite time
  some configuration  with interpretation , and so that any
configuration reachable from  has also interpretation . 

This latter property can be expressed as a property on the graph of
configurations of the protocol, i.e. on the graph whose nodes are
configurations of  agents, and whose edges corresponds to unique step
reachability:  one must check the existence of a path
from  to some  with interpretation  so that there is no
path from  to some other  with interpretation different from
. 

Such a problem can be solved in  where 
denotes the number of nodes of this graph of configurations. 
Indeed, guessing a path from  to
some  can easily be done in  by guessing
intermediate nodes (corresponding to configurations) between  and . There remains to
see that testing if there is no
path from  to some other  with interpretation different from
 can also be done in  to conclude.

But observe that testing if there is a path from  to some other
 with interpretation different from  is clearly in  by guessing . From Immerman-Szelepcsnyi's Theorem
\cite{immerman1988nondeterministic,Szelepcsenyi} we know that one has 
. Hence, testing if there is no path
from  to some other  with interpretation different from
 is indeed also in .

It remains now to evaluate : 
For a given identifier , an agent encodes basically some basic state , and  identifiers . There are at most  agents
in  a given state .
Hence  
In other words, the algorithm above in  is
hence basically in . As a
consequence, this
is 
included in 
for some . \hfill \qed

\end{proof}

\begin{theorem}\label{th:main}
Let   such that for some , we have .
The set of functions computable by homonym population protocols with 
identifiers corresponds exactly to .

\end{theorem}

\section{The Rest of the Hierarchy}\label{resthirera}

\subsection{Population with  Identifiers}

One can go from   (with ) to a space of
computation equivalent to the case where :  We just need to use a -tuple of identifiers,
as in Proposition~\ref{prop:truc}.





\begin{theorem}\label{th:sqrt}
Let  such that there exists some  such that .
The set of functions computable by homonym population protocols with 
identifiers corresponds exactly to .
\end{theorem}





\begin{remark}
This result does not need the two restrictions of knowing if an identifier is equal to  or if
two identifiers are consecutive. The result holds when the set of possible identifiers
 is chosen arbitrarily and when the
restrictions over the rules are those in \cite{guerraoui2009names}.
\end{remark}

\subsection{Population with  Identifiers}

This time, we consider we have really few identifiers.
To write the size of the population in binary, we need to differentiate
 agents. With  identifiers, it is no longer possible.
Because of that, the counting protocol and the reset protocol can no longer
be used to simulate Turing Machines.

In this section, we consider two cases:  and
a constant number of identifiers.
We have a characterization when
this number is constant: it leads to population protocols. In the general case,
the population is more powerful, but we do not have any exact characterization.



\begin{theorem}\label{hppconst}
Let  such that for some , we have, for all , .

The set of functions computable by homonym population protocols with 
identifiers corresponds to the semilinear sets over .
\end{theorem}
\begin{proof}
Each agent tries to put in its internal state the value of its identifier 
by using the following algorithm:
\begin{itemize}
\item If the identifier is , then the agent puts .
\item If an agent knowing its identifier  meets an agent with identifier , then
the second knows its identifier by incrementing .
\end{itemize}
From this,  it is possible to compute semilinear predicates.
Indeed, agents know now their initial state and can run the corresponding population protocol.\\

The proof that only semilinear sets can be computed is quite simple: we see a community protocol
as a population protocol where the identifiers are directly included in the states.
More precisely, , and .\hfill \qed

\end{proof}

\begin{proposition}\label{contrex1}
There exists some non semilinear predicates over 
and some function  such that there exists
a homonym population protocols with  identifiers that computes this predicate.
\end{proposition}
\begin{proof}
For example, it is possible to compute the predicate asking if the
 agents with an even identifier are in majority.

To compute this it suffices to determine for each agent if its identifier
is even or odd. The way to compute it is as follows:
\begin{itemize}
\item If the identifier is , then the agent remembers its identifier is odd.
\item If an agent knowing its parity meets an agent with an identifier
that is the directly next one, then
the second knows its parity by switching the other's one.
\end{itemize}
We then run the protocol .\hfill \qed

\end{proof}

\begin{remark}\label{contrex2}
Another counter-example is that we can compute the following predicate
 
where  is the number of agents with input  and identifier .
This predicate corresponds to a threshold predicate when we take into consideration
whether the identifier of the agent is in the first or second half of the present ones.

This protocol computes the threshold predicate with first value  for each agent
with non  identifier and input , and  for the agents with identifier  and
input .

To compute the medium identifier, we have .
For an agent ,  means agent's own identifier,  is the medium candidate and,
 represents  or . At the beginning, if the identifier is , then we have ,
otherwise, we get . The state  means "I need to increment  if 
is present". The state  means "I need to increment both  and  if
 is present". The state  means "I need to increment   if
 is present". Hence, each time we increment twice , we increment once .

The rules are:
\begin{center}
\begin{tabular}{ r @{\hspace{0,2cm}} l @{} r @{\hspace{0,2cm}}  l l}
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & \\
 &  &  &  & \\
\end{tabular}
\end{center}

As soon as an agent in input  realizes its identifier is smaller or equal to its ,
it adds  to its state if possible (otherwise, it waits an occasion to add it
to another agent).

By fairness, all agents will determine at some point if their identifier is greater
or smaller to half the highest one, and then the leader will be able to compute the
right output.
\end{remark}





































\section{Passively Mobile Machines}
\label{sec:4demi}


We now show how previous constructions
 improve the results about the passively mobile protocol model  \cite{chatzigiannakis2011passively}.
This section treats the case where  in the
passively mobile protocol model. Table \ref{tab:Chatzigiannakis} gives a summary of this hierarchy.
 corresponds to the class of languages recognized
by Passively Mobile Agents using space .











\begin{theorem}\label{th:grec}
.\end{theorem}
\begin{proof}
\textbf{1.} .

The idea of this proof is quite simple: Let .
We can notice that  
(as the space of computation is the same and symmetric is equivalent
to be a single multiset).
From Theorem \ref{th:main}, there is a population protocol computing M. We will simulate it.
With space , we can simulate
a population protocol with  identifiers.

Indeed, we adapt a bit the counting protocol.
 At the beginning, each agent has identifier  in order to create  identifiers.
When two agents with the same \id\ meet, if each one contains the integer , then
the first switch its integer to  and, the other increases its own \id.

We then just need to simulate the behavior of each agent as if they have started 
with their created \id. It requires a space of size  plus some constant,
which is enough.

\textbf{2.} :
The proof is similar to the one of Theorem \ref{th:olivier}:
It is a question of accessibility in the  graph of the configurations.
We need to compute the number of possible configurations denoted by .

For each agent, there are  possible states and 4 tapes of length
 for some . Hence, there are 
possible states for each agent.

Now 

For each possible state, there are at most  agents sharing it.

Hence, .


The accessibility can be computed by a machine in space complexity
, which means a space  for some .\hfill \qed

 \end{proof}

With a similar proof, we can get the following result that gives a good clue for the gap
between  and :

\begin{corollary}
Let  such that  and .



\end{corollary}

\section{Summary} \label{sec:5}

From the model given  by Guerraoui and Ruppert \cite{guerraoui2009names}, we introduced a hierarchy according
to the number of distinct identifiers in the population:
\begin{itemize}
\item  The existence of identifiers is useless with a constant number of the identifiers.
\item Homonym population protocols with  identifiers
  can exactly  recognize any language in .
\item Homonym population protocols with  identifiers
  have same power that homonym population protocols
  with  identifiers.
\end{itemize}

It remains an open and natural question: is the knowledge of consecutive values of two identifiers
 crucial or not?  Our guess is that this knowledge  is essential to compute  
the size of the population. Protocols without this assumption have not been found yet.

Chatzigiannakis \emph{et al.}  \cite{chatzigiannakis2011passively} started a hierarchy over protocols
depending on how much space of computation each agent has.
The paper left an open question on the gap between  and .
We provided an answer, by proving that with  space,
exactly  is computed. However, it remains the gap between  and , where we 
currently just have the following bounds: 

.








\begin{thebibliography}{10}

\bibitem{angluin2007cpp}
D.~Angluin, J.~Aspnes, D.~Eisenstat, and E.~Ruppert.
\newblock {The computational power of population protocols}.
\newblock {\em Distributed Computing}, 20(4):279--304, 2007.

\bibitem{AngluinACFJP2005}
D.~Angluin, J.~Aspnes, M.~Chan, M.~J. Fischer, H.~Jiang, and
  R.~Peralta.
\newblock Stably computable properties of network graphs.
\newblock In {\em Distributed Computing in Sensor Systems: DCOSS 2005}, volume 3560 of {\em Lecture Notes in Computer Science},
  pages 63--74. Springer-Verlag, 2005.

\bibitem{AspnesADFP2004}
D.~Angluin, J.~Aspnes, Z.~ Diamadi, M.~J. Fischer, and R.~Peralta.
\newblock Computation in networks of passively mobile finite-state sensors.
\newblock In {\em Twenty-Third ACM Symposium on Principles of Distributed
  Computing}, pages 290--299. ACM Press,  2004.

\bibitem{OPODIS}
D.~Angluin, J.~Aspnes, M.~J. Fischer, and H.~Jiang.
\newblock Self-stabilizing population protocols.
\newblock In {\em Principles of Distributed Systems, 9th International
  Conference, OPODIS}, volume  3974 of {\em Lecture Notes in Computer Science}, pages 103--117.
  Springer, 2005.

\bibitem{ArevaloAIJR12}
S. Ar{\'{e}}valo, A.~Fern{\'{a}}ndez Anta, D. Imbs, E.
  Jim{\'{e}}nez, and M. Raynal.
\newblock Failure detectors in homonymous distributed systems (with an
  application to consensus).
\newblock In {\em 2012 {IEEE} 32nd International Conference on Distributed
  Computing Systems (ICDCS)}, pages 275--284, 2012.

\bibitem{PopProtocolsEATCS}
J.~Aspnes and E.~Ruppert.
\newblock An introduction to population protocols.
\newblock In {\em Bulletin of the EATCS}, volume~93, pages 106--125, 2007.

\bibitem{chatzigiannakis2011passively}
I.~Chatzigiannakis, O.~Michail, S.~Nikolaou, A.~Pavlogiannis, and P.~G.
  Spirakis.
\newblock Passively mobile communicating machines that use restricted space.
\newblock {\em Theoretical Computer Science}, 2011.

\bibitem{ChatzigiannakisMS10}
I.~Chatzigiannakis, O.~Michail, and P.~G. Spirakis.
\newblock Algorithmic verification of population protocols.
\newblock In {\em 12th Symp. on Stabilization, Safety, and Security of
  Distributed Systems (SSS)}, pages 221--235, 2010.

\bibitem{Delporte-Gallet:2011}
C.~Delporte-Gallet, H.~Fauconnier, R.~Guerraoui, A.~Kermarrec, E.~Ruppert, and H.~Tran-The.
\newblock Byzantine agreement with homonyms.
\newblock In {\em 30th Annual ACM SIGACT-SIGOPS Symposium on
  Principles of Distributed Computing}, PODC '11, pages 21--30,  2011.

\bibitem{Delporte-GalletFGR06}
C.~Delporte-Gallet, H.~Fauconnier, R.~Guerraoui, and E.~Ruppert.
\newblock When birds die: Making population protocols fault-tolerant.
\newblock In {\em Distributed Computing in Sensor Systems, Second {IEEE}
  International Conference, {DCOSS} 2006}, volume 4026 of {\em Lecture Notes in Computer
  Science}, pages 51--66. Springer, 2006.

\bibitem{Delporte-Gallet:2012}
C.~Delporte-Gallet, H.~Fauconnier, and H.~Tran-The.
\newblock Homonyms with forgeable identifiers.
\newblock In {\em   19th International Conference on
  Structural Information and Communication Complexity}, SIROCCO'12, pages
  171--182, Springer-Verlag, 2012. 

\bibitem{Guiseppe2013}
G.A. Di~Luna, R.~Baldoni, S.~Bonomi, and I.~Chatzigiannakis.
\newblock Counting the number of homonyms in dynamic networks.
\newblock In {\em Stabilization, Safety,
  and Security of Distributed Systems}, volume 8255 of {\em Lecture Notes in
  Computer Science}, pages 311--325. Springer, 2013.

\bibitem{guerraoui2009names}
R.~Guerraoui and E.~Ruppert.
\newblock Names trump malice: Tiny mobile agents can tolerate byzantine
  failures.
\newblock In {\em Automata, Languages and Programming}, pages 484--495, 2009.

\bibitem{immerman1988nondeterministic}
N.~Immerman.
\newblock {Nondeterministic space is closed under complementation}.
\newblock In {\em Structure in Complexity Theory Conference,  Third Annual}, pages 112--115. IEEE, 1988.

\bibitem{schonhage1980storage}
A.~Sch{\"o}nhage.
\newblock Storage modification machines.
\newblock {\em SIAM Journal on Computing}, 9(3):490--508, 1980.

\bibitem{Szelepcsenyi}
R.~Szelepcs{\'e}nyi.
\newblock The method of forced enumeration for nondeterministic automata.
\newblock {\em Acta Inf.}, 26(3):279--284, November 1988.

\end{thebibliography}
 
\end{document}
