
\documentclass{article} 

\usepackage[dvipsnames]{xcolor}
\usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         





\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false,citecolor=RoyalBlue]{hyperref}



\usepackage{float}
\usepackage{adjustbox}
\usepackage{subcaption}
\usepackage{array}
\usepackage{tabularx}
\usepackage{arydshln}
\usepackage{booktabs}
\usepackage{pifont}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{lipsum}
\usepackage[ruled]{algorithm2e}


\newcommand{\algo}{VICReg}
\newcommand{\expander}{expander }
\newcommand{\expandernospace}{expander}
\newcommand{\Expander}{Expander}
\newcommand\todo[1]{\textcolor{RubineRed}{#1}}

\newcommand{\cmark}{\ding{51}}\newcommand{\bigcell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}



 \iclrfinalcopy


\title{VICReg: Variance-Invariance-Covariance
Re-gularization for Self-Supervised Learning}



\author{
    Adrien Bardes$^{1,2}$ \And Jean Ponce$^{2,4}$ \And Yann LeCun$^{1,3,4}$ \AND
    \begin{tabular}{l}
        $^1$\normalfont Facebook AI Research\\
        $^2$\normalfont Inria, École normale supérieure, CNRS, PSL Research University \\
        $^3$\normalfont Courant Institute, New York University\\
        $^4$\normalfont Center for Data Science, New York University\\
    \end{tabular}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\maketitle

\begin{abstract}
Recent self-supervised methods for image representation learning maximize the agreement between embedding vectors produced by encoders fed with different views of the same image. The main challenge is to prevent a {\em collapse} in which the encoders produce constant or non-informative vectors. We introduce \algo \ (Variance-Invariance-Covariance Regularization), a method that explicitly avoids the collapse problem with two regularizations terms applied to both embeddings separately: (1) a term that maintains the variance of each embedding dimension above a threshold, (2) a term that decorrelates each pair of variables. Unlike most other approaches to the same problem, \algo \ does {\em not} require techniques such as: weight sharing between the branches, batch normalization, feature-wise normalization, output quantization, stop gradient, memory banks, etc., and achieves results on par with the state of the art on several downstream tasks. In addition, we show that our variance regularization term stabilizes the training of other methods and leads to performance improvements.
\end{abstract}

\newcommand\blfootnote[1]{\begingroup
  \renewcommand\thefootnote{}\footnotetext{#1}\endgroup
}


\section{Introduction}

Self-supervised representation learning has made significant progress over the last years, almost reaching the performance of supervised baselines on many downstream tasks \cite{bachman2019mutual, misra2020pirl, he2020moco, tian2020makes, caron2020swav, grill2020byol, chen2020simsiam, gidaris2021obow, zbontar2021barlow}. Several recent approaches rely on a {\em joint embedding architecture} in which two networks are trained to produce similar embeddings for different views of the same image. A popular instance is the Siamese network architecture \cite{bromley1994siamese}, where the two networks share the same weights. The main challenge with joint embedding architectures is to prevent a {\em collapse} in which the two branches ignore the inputs and produce identical and constant output vectors. There are two main approaches to preventing collapse: contrastive methods and information maximization methods. Contrastive \cite{bromley1994siamese, chopra2005,he2020moco, hjelm2019mutual, chen2020simclr} methods tend to be costly, require large batch sizes or memory banks, and use a loss that explicitly pushes the embeddings of dissimilar images away from each other. They often require a mining procedure to search for offending dissimilar samples from a memory bank~\cite{he2020moco} or from the current batch \cite{chen2020simclr}. Quantization-based approaches \cite{caron2020swav, caron2018clustering} force the embeddings of different samples to belong to different clusters on the unit sphere. Collapse is prevented by ensuring that the assignment of samples to clusters is as uniform as possible. A similarity term encourages the cluster assignment score vectors from the two branches to be similar. More recently, a few methods have appeared that do not rely on contrastive samples or vector quantization, yet produce high-quality representations, for example BYOL~\cite{grill2020byol} and SimSiam~\cite{chen2020simsiam}. They exploit several tricks: batch-wise or feature-wise normalization, a "momentum encoder" in which the parameter vector of one branch is a low-pass-filtered version of the parameter vector of the other branch~\cite{grill2020byol, richemond2020byolworks}, or a stop-gradient operation in one of the branches~\cite{chen2020simsiam}. The dynamics of learning in these methods, and how they avoid collapse, is not fully understood, although theoretical and empirical studies point to the crucial importance of batch-wise or feature-wise normalization~\cite{richemond2020byolworks,tian2021understanding}. Finally, an alternative class of collapse prevention methods relies on maximizing the information content of the embedding~\cite{zbontar2021barlow, ermolov2021whitening}. These methods prevent {\em informational collapse} by decorrelating every pair of variables of the embedding vectors. This indirectly maximizes the information content of the embedding vectors. The Barlow Twins method drives the normalized cross-correlation matrix of the two embeddings towards the identity~\cite{zbontar2021barlow}, while the Whitening-MSE method whitens and spreads out the embedding vectors on the unit sphere \cite{ermolov2021whitening}.




\section{VICReg: intuition}

\begin{figure}[t]
\centering
\captionsetup[subfigure]{labelformat=empty}
\subfloat[] {\includegraphics[trim=0cm 0.2cm 0cm 0cm, clip, width=157mm]{figures/vicreg_archi.pdf}}
\vspace{-5mm}
\caption{\textbf{\algo: joint embedding architecture with variance, invariance and covariance regularization.} Given a batch of images $I$, two batches of different views $X$ and $X^{\prime}$ are produced and are then encoded into representations $Y$ and $Y^{\prime}$. The representations are fed to an expander producing the embeddings $Z$ and $Z^{\prime}$. The distance between two embeddings from the same image is minimized, the variance of each embedding variable over a batch is maintained above a threshold, and the covariance between pairs of embedding variables over a batch are attracted to zero, decorrelating the variables from each other. 
Although the two branches do not require identical architectures nor share weights, in most of our experiments, they are Siamese with shared weights: the encoders are ResNet-50 backbones with output dimension 2048. The expanders have 3 fully-connected layers of size 8192.}
\label{fig:varcov_archi}
\end{figure}

We introduce \algo \ (Variance-Invariance-Covariance Regularization), a self-supervised method for training joint embedding architectures based on the principle of preserving the information content of the embeddings. 
The basic idea is to use a loss function with three terms:
\begin{itemize}
    \item {\bf Invariance}: the mean square distance between the embedding vectors.
    \item {\bf Variance}: a hinge loss to maintain the standard deviation (over a batch) of each variable of the embedding above a given threshold. This term forces the embedding vectors of samples within a batch to be different.
    \item {\bf Covariance}: a term that attracts the covariances (over a batch) between every pair of (centered) embedding variables towards zero. This term decorrelates the variables of each embedding and prevents an {\em informational collapse} in which the variables would vary together or be highly correlated.
\end{itemize}
Variance and Covariance terms are applied to both branches of the architecture separately, thereby preserving the information content of each embedding at a certain level and preventing informational collapse independently for the two branches.
The main contribution of this paper is the Variance preservation term, which explicitly prevents a collapse due to a shrinkage of the embedding vectors towards zero.
The Covariance criterion is borrowed from the Barlow Twins method and prevents informational collapse due to redundancy between the embedding variables~\cite{zbontar2021barlow}. \algo \ is more generally applicable than most of the aforementioned methods because of fewer constraints on the architecture. In particular, \algo :
\begin{itemize}
    \item does not require that the weights of the two branches be shared, not that the architectures be identical, nor that the inputs be of the same nature;
    \item does not require a memory bank, nor contrastive samples, nor a large batch size;
    \item does not require batch-wise nor feature-wise normalization; and
    \item does not require vector quantization nor a predictor module.
\end{itemize}

Other methods require asymmetric stop gradient operations, as in SimSiam~\cite{chen2020simsiam}, weight sharing between the two branches as in classical Siamese nets, or weight sharing through exponential moving average dampening with stop gradient in one branch, as in BYOL and MoCo~\cite{he2020moco, grill2020byol,chen2020mocov2}, large batches of contrastive samples, as in SimCLR~\cite{chen2020simclr}, or batch-wise and/or feature-wise normalization~\cite{caron2020swav, grill2020byol, chen2020simsiam, zbontar2021barlow, ermolov2021whitening}. One of the most interesting feature of \algo \ is the fact that the two branches are not required to share the same parameters, architecture, or input modality. This opens the door to the use of non-contrastive self-supervised joint-embedding for multi-modal signals, such as video and audio. We demonstrate the effectiveness of the proposed approach by evaluating the representations learned with \algo \ on several downstream image recognition tasks including linear head and semi-supervised evaluation protocols for image classification on ImageNet~\cite{deng2009imagenet}, and other classification, detection, instance segmentation, and retrieval tasks. Furthermore, we show that incorporating variance preservation into other self-supervised joint-embedding methods yields better training stability and performance improvement on downstream tasks. More generally, we show that \algo \ is an explicit and effective, yet simple method for preventing collapse in self-supervised joint-embedding learning.

  
\section{Related work}

\noindent \textbf{Contrastive learning.} In contrastive SSL methods applied to joint embedding architectures, the output embeddings for a sample and its distorted version are brought close to each other, while other samples and their distortions are pushed away. The method is most often applied to Siamese architectures in which the two branches have identical architectures and share weights~\cite{misra2020pirl, he2020moco, bromley1994siamese, hjelm2019mutual, chen2020simclr, chen2020mocov2, hadsell2006contrastive, ye2019spreading, wu2018discrimination, oord2018coding, chen2020simclrv2}. Many authors use the InfoNCE loss~\cite{oord2018coding} in which the repulsive force is larger for contrastive samples that are closer to the reference. While these methods yield good performance, they require large amounts of contrastive pairs in order to work well. These contrastive pairs can be sampled from a memory bank as in MoCo~\cite{he2020moco}, or given by the current batch of data as in SimCLR~\cite{chen2020simclr}, with a significant memory footprint. This downside of contrastive methods motivates a search for alternatives.

\vspace{2mm}
\textbf{Clustering methods.} Instead of viewing each sample as its own class, clustering-based methods group them into clusters based on some similarity measure~\cite{caron2020swav, caron2018clustering, bautista2016cliquecnn, yang2016joint, xie2016clustering, huang2019neighbourhood, zhuang2019local, caron2019noncurated, asano2020labelling, yan2020clusterfit}. DeepCluster~\cite{caron2018clustering} uses $k$-means assignments of representations from previous iterations as pseudo-labels for the new representations, which requires an expensive clustering phase done asynchronously, and makes the method hard to scale up. SwAV~\cite{caron2020swav} mitigates this issue by learning the clusters online while maintaining a balanced partition of the assignments through the Sinkhorn-Knopp transform~\cite{cuturi2013sinkhorn}. These clustering approaches can be viewed as contrastive learning at the level of clusters which still requires a lot of negative comparisons to work well. 

\vspace{2mm}
\noindent \textbf{Distillation methods.} Recent proposals such as BYOL, SimSiam, OBoW and variants~\cite{grill2020byol, chen2020simsiam, gidaris2021obow, richemond2020byolworks, gidaris2020bags} have shown that collapse can be avoided by using architectural tricks inspired by knowledge distillation \cite{hinton2015distillation}. These methods train a student network to predict the representations of a teacher network, for which the weights are a running average of the student network's weights~\cite{grill2020byol}, or are shared with the student network, but no gradient is back-propagated through the teacher~\cite{chen2020simsiam}. These methods are effective, but there is no clear understanding of why and how they avoid collapse. Alternatively, the images can be represented as bags of word over a dictionary of visual features, which effectively prevents collapse. In OBoW~\cite{gidaris2020bags} and~\cite{gidaris2021obow} the dictionary is obtained by off-line or on-line clustering. By contrast, our method explicitly prevents collapse in the two branches independently, which removes the requirement for shared weights and identical architecture, opening the door to the application of joint-embedding SSL to multi-modal signals.

\vspace{2mm}
\noindent \textbf{Information maximization methods.} A principle to prevent collapse is to maximize the information content of the embeddings. Two such methods were recently proposed: W-MSE~\cite{ermolov2021whitening} and Barlow Twins~\cite{zbontar2021barlow}.
In W-MSE, an extra module transforms the embeddings into the eigenspace of their covariance matrix (whitening or Karhunen-Loève transform), and forces the vectors thereby obtained to be uniformly distributed on the unit sphere.
In Barlow Twins, a loss term attempts to make the normalized cross-correlation matrix of the embedding vectors from the two branches to be close to the identity. 
Both methods attempt to produce embedding variables that are decorrelated from each other, thus preventing an {\em informational collapse} in which the variables carry redundant information. Because all variables are normalized over a batch, there is no incentive for them to shrink nor expand. This seems to sufficient to prevent collapse.
Our method borrows the decorrelation mechanism of Barlow Twins. But it includes an explicit variance-preservation term for each variable of the two embeddings and thus does not require any normalization.
    
\section{VICReg: detailed description} \label{sec:method}

\algo \ follows recent trends in self-supervised learning~\cite{caron2020swav, grill2020byol, chen2020simsiam, zbontar2021barlow, chen2020simclr} and is based on a {\em joint embedding architecture}. Contrary to many previous approaches, our architecture may be completely symmetric or completely asymmetric with no shared structure or parameters between the two branches. In most of our experiments, we use a Siamese net architecture in which the two branches are identical and share weights. Each branch consists of an {\em encoder} $f_{\theta}$ that outputs the representations (used for downstream tasks), followed by an {\em expander} $h_{\phi}$ that maps the representations into an embedding space where the loss function will be computed. The role of the \expander is twofold: (1) eliminate the information by which the two representations differ, (2) expand the dimension in a non-linear fashion so that decorrelating the embedding variables will reduce the dependencies (not just the correlations) between the variables of the representation vector. The loss function uses a term $s$ that learns invariance to data transformations and is regularized with a variance term $v$ that prevents norm collapse and a covariance term $c$ that prevents informational collapse by decorrelating the different dimensions of the vectors. After pretraining, the \expander is discarded and the representations of the encoder are used for downstream tasks.

\subsection{Method} \label{sec:method_details}

Given an image $i$ sampled from a dataset $\mathcal{D}$, two transformations $t$ and $t^{\prime}$ are sampled from a distribution $\mathcal{T}$ to produce two different views $x = t(i)$ and $x^{\prime} = t^{\prime}(i)$ of $i$. These transformations are random crops of the image, followed by color distortions. The distribution $\mathcal{T}$ is described in Appendix~\ref{app:sec_impl_details}. The views $x$ and $x^{\prime}$ are first encoded by $f_{\theta}$ into their {\em representations} $y = f_{\theta}(x)$ and $y^{\prime} = f_{\theta}(x^{\prime})$, which are then mapped by the expander $h_{\phi}$ onto the {\em embeddings} $z = h_{\phi}(y)$ and $z^{\prime} = h_{\phi}(y^{\prime})$. The loss is computed at the embedding level on $z$ and $z^{\prime}$.

We describe here the variance, invariance and covariance terms that compose our loss function. The images are processed in batches, and we denote $Z = [z_1, \dots, z_n]$ and $Z^{\prime} = [z_1^{\prime}, \dots, z_n^{\prime}]$ the two batches composed of $n$ vectors of dimension $d$, of embeddings coming out of the two branches of the siamese architecture. We denote by $z^{j}$ the vector composed of each value at dimension $j$ in all vectors in $Z$. We define the variance regularization term $v$ as a hinge function on the standard deviation of the embeddings along the batch dimension:
\begin{equation} \label{eq:var_loss}
    v(Z) = \frac{1}{d} \sum_{j=1}^{d} \max(0, \gamma - S(z^{j}, \epsilon)),
\end{equation}
where $S$ is the regularized standard deviation defined by:
\begin{equation}
    S(x, \epsilon) = \sqrt{\mathrm{Var}(x) + \epsilon},
\end{equation}
$\gamma$ is a constant target value for the standard deviation, fixed to $1$ in our experiments, $\epsilon$ is a small scalar preventing numerical instabilities. This criterion encourages the variance inside the current batch to be equal to $\gamma$ along each dimension, preventing collapse with all the inputs mapped on the same vector. Using the standard deviation and not directly the variance is crucial. Indeed, if we take $S(x) = \mathrm{Var}(x)$ in the hinge function, the gradient of $S$ with respect to $x$ becomes close to 0 when $x$ is close to $\bar{x}$. In this case, the gradient of $v$ also becomes close to 0 and the embeddings collapse. We define the covariance matrix of $Z$ as:
\begin{equation} \label{eq:covariance}
    C(Z) = \frac{1}{n - 1} \sum_{i=1}^{n} (z_{i} - \bar{z})(z_{i} - \bar{z})^{T}, \ \ \ \textrm{where} \ \ \ \bar{z} = \frac{1}{n} \sum_{i=1}^{n} z_{i}.
\end{equation}
Inspired by Barlow Twins \cite{zbontar2021barlow}, we can then define the covariance regularization term $c$ as the sum of the squared off-diagonal coefficients of $C(Z)$, with a factor $1/d$ that scales the criterion as a function of the dimension:
\begin{equation} \label{eq:cov_loss}
    c(Z) = \frac{1}{d} \sum_{i \ne j} [C(Z)]_{i,j}^2.
\end{equation}
This term encourages the off-diagonal coefficients of $C(Z)$ to be close to $0$, decorrelating the different dimensions of the embeddings and preventing them from encoding similar information. Decorrelation at the embedding level ultimately has a decorrelation effect at the representation level, which is a non trivial phenomenon that we study in Appendix~\ref{app:additional_results}. We finally define the invariance criterion $s$ between $Z$ and $Z^{\prime}$ as the mean-squared euclidean distance between each pair of vectors, without any normalization:
\begin{equation} \label{eq:invariance}
    s(Z, Z^{\prime}) = \frac{1}{n} \sum_i \|z_i - z^{\prime}_i\|_2^2.
\end{equation}
The overall loss function is a weighted average of the invariance, variance and covariance terms:
\begin{equation} \label{eq:loss}
    \ell(Z, Z^{\prime}) = \ \lambda s(Z, Z^{\prime}) + \mu [ v(Z) + v(Z^{\prime}) ] + \nu [ c(Z) + c(Z^{\prime}) ],
\end{equation}
where $\lambda$, $\mu$ and $\nu$ are hyper-parameters controlling the importance of each term in the loss. In our experiments, we set $\nu = 1$ and perform a grid search on the values of $\lambda$ and $\mu$ with the base condition $\lambda = \mu > 1$. The overall objective function taken on all images over an unlabelled dataset $\mathcal{D}$ is given by:
\begin{equation} \label{eq:final_loss}
    \mathcal{L} = \sum_{I \in \mathcal{D}} \sum_{t, t^{\prime} \sim \mathcal{T}} \ell(Z^{I}, Z^{\prime I}),
\end{equation}
where $Z^{I}$ and $Z^{\prime I}$ are the batches of embeddings corresponding to the batch of images $I$ transformed by $t$ and $t^{\prime}$. The objective is minimized for several epochs, over the encoder parameters $\theta$ and \expander parameters $\phi$. We illustrate the architecture and loss function of \algo \ in Figure~\ref{fig:varcov_archi}.\\
\setlength\intextsep{0pt}
\subsection{Implementation details} \label{sec:impl_details}














Implementation details for pretraining with \algo \ on the 1000-classes ImagetNet dataset without labels are as follows. Coefficients $\lambda$ and $\mu$ are $25$ and $\nu$ is 1 in Eq.~(\ref{eq:loss}), and $\epsilon$ is $0.0001$ in Eq.~(\ref{eq:var_loss}). We give more details on how we choose the coefficients of the loss function in Appendix~\ref{app:loss_coeffs}. The encoder network $f_{\theta}$ is a standard ResNet-50 backbone~\cite{he2016resnet} with 2048 output units. The expander $h_{\phi}$ is composed of two fully-connected layers with batch normalization (BN)~\cite{ioffe2015bn} and ReLU, and a third linear layer. The sizes of all 3 layers were set to 8192. As with Barlow Twins, performance improves when the size of the expander layers is larger than the dimension of the representation. The impact of the expander dimension on performance is studied in Appendix~\ref{app:additional_results}. The training protocol follows those of BYOL and Barlow Twins: LARS optimizer~\cite{you2017lars, goyal2017lars} run for 1000 epochs with a weight decay of $10^{-6}$ and a learning rate $lr = batch\_size / 256 \times base\_lr$, where $batch\_size$ is set to $2048$ by default and $base\_lr$ is a base learning rate set to $0.2$. The learning rate follows a cosine decay schedule \cite{loshchilov2017sgdr}, starting from $0$ with $10$ warmup epochs and with final value of $0.002$.

\section{Results}
In this section, we evaluate the representations obtained after self-supervised pretraining of a ResNet-50~\cite{he2016resnet} backbone with \algo \ during 1000 epochs, on the training set of ImageNet, using the training protocol described in section~\ref{sec:method}. We also pretrain on pairs of image and text data and evaluate on retrieval tasks on the MS-COCO dataset.
\begin{table}[t]
\setlength{\tabcolsep}{7pt}
\centering
    \caption{\textbf{Evaluation on ImageNet.} Evaluation of the representations obtained with a ResNet-50 backbone pretrained with \algo \ on: (1) linear classification on top of the frozen representations from ImageNet; (2) semi-supervised classification on top of the fine-tuned representations from 1\% and 10\% of ImageNet samples. We report Top-1 and Top-5 accuracies (in \%). Top-3 best self-supervised methods are \underline{underlined}.}
    \label{tab:imagenet_evaluation}
    \vspace{-0.5em}
    \begin{tabular}{ @{} l cc c cccc @{} }
      \toprule
 & \multicolumn{2}{c}{Linear}  &~~~~& \multicolumn{4}{c}{Semi-supervised} \\
 \cmidrule{2-3}\cmidrule{5-8}
 Method                     & Top-1 & Top-5 && \multicolumn{2}{c}{Top-1} & \multicolumn{2}{c}{Top-5} \\
	                                            &        &        && 1\% & 10\% & 1\% & 10\% \\      
      \midrule
	    Supervised                              & 76.5 & -      && 25.4 & 56.4 & 48.4 & 80.4 \\
      \midrule
	    MoCo~\cite{he2020moco}                  & 60.6 & -      && -      & -      & -      & - \\
	    PIRL~\cite{misra2020pirl}               & 63.6 & -      && -      & -      & 57.2 & 83.8 \\
	    CPC v2 \cite{henaff2019data}            & 63.8 & -      && -      & -      & -      & - \\
	    CMC \cite{tian2019cmc}                  & 66.2 & -      && -      & -      & -      & - \\
	    SimCLR~\cite{chen2020simclr}            & 69.3 & 89.0   && 48.3 & 65.6 & 75.5 & 87.8 \\
	    MoCo v2~\cite{chen2020mocov2}           & 71.1 & -      && -      & -      & -      & - \\
	    SimSiam~\cite{chen2020simsiam}          & 71.3 & -      && -      & -      & -      & - \\
	    SwAV~\cite{caron2020swav}               & 71.8 & -      && - & - & - & - \\
	    InfoMin Aug~\cite{tian2020makes}        & 73.0 & \underline{91.1}   && -      & -      & -      & - \\
	    OBoW \cite{gidaris2021obow}             & \underline{73.8} & -         && -    & -    & \underline{82.9} & \underline{90.7} \\
	    BYOL~\cite{grill2020byol}               & \underline{74.3} & \underline{91.6}   && 53.2 & 68.8 & 78.4 & 89.0 \\
	    SwAV (w/ multi-crop)~\cite{caron2020swav}               & \underline{75.3} & -      && \underline{53.9} & \underline{70.2} & 78.5 & \underline{89.9} \\
	    Barlow Twins~\cite{zbontar2021barlow}   & 73.2 & 91.0 && \underline{55.0} & \underline{69.7} & \underline{79.2} & 89.3 \\
\algo \ (ours)                          & 73.2 & \underline{91.1} && \underline{54.8} & \underline{69.5} & \underline{79.4} & \underline{89.5} \\
      \bottomrule
    \end{tabular}
\end{table}

\subsection{Evaluation on ImageNet} \label{sec:eval_imagenet}

Following the ImageNet \cite{deng2009imagenet} linear evaluation protocol, we train a linear classifier on top of the frozen representations of the ResNet-50 backbone pretrained with \algo. We also evaluate the performance of the backbone when fine-tuned with a linear classifier on a subset of ImageNet's training set using 1\% or 10\% of the labels, using the split of \cite{chen2020simclr}. We give implementation details about the optimization procedure for these tasks in Appendix~\ref{app:sec_impl_details}. We have applied the training procedure described in section~\ref{sec:method} with three different random initialization. The numbers reported in Table~\ref{tab:imagenet_evaluation} for \algo \ are the mean scores, and we have observed that the difference between worse and best run is lower than 0.1\% accuracy for linear classification, which shows that \algo \ is a very stable algorithm. Lack of time has prevented us from doing the same for the semi-supervised classification experiments, and the experiments of section~\ref{sec:eval_transfer} and \ref{sec:ablations}, but we expect similar conclusion to hold. We compare in Table~\ref{tab:imagenet_evaluation} our results on both tasks against other methods on the validation set of ImageNet. The performance of \algo \ is on par with the state of the art without using the negative pairs of SimCLR, the clusters of SwAV, the bag-of-words representations of OBoW, or any asymmetric networks architectural tricks such as the momentum encoder of BYOL and the stop-gradient operation of SimSiam. The performance is comparable to that of Barlow Twins, which shows that \algo's more explicit way of constraining the variance and comparing views has the same power than maximizing cross-correlations between pairs of twin dimensions. The main advantage of \algo \ is the modularity of its objective function and the applicability to multi-modal setups.

\subsection{Transfer to other downstream tasks} \label{sec:eval_transfer}
Following the setup from \cite{misra2020pirl}, we train a linear classifier on top of the frozen representations learnt by our pretrained ResNet-50 backbone on a variety of different datasets: the Places205~\cite{zhou2014places} scene classification dataset, the VOC07~\cite{everingham2010voc} multi-label image classification dataset and the iNaturalist2018~\cite{vanhorni2018naturalist} fine-grained image classification dataset. We then evaluate the quality of the representations by transferring to other vision tasks including VOC07+12~\cite{everingham2010voc} object detection using Faster R-CNN~\cite{ren2015fasterrcnn} with a R50-C4 backbone, and COCO~\cite{lin2014coco} instance segmentation using Mask-R-CNN~\cite{he2017maskrcnn} with a R50-FPN backbone.  We report the performance in Table~\ref{tab:transfer_learning}, \algo \ performs on par with most concurrent methods, and better than Barlow Twins, across all classification tasks, but is slightly behind the top-3 on detection tasks. 

\begin{table}[t]
\centering
    \caption{\textbf{Transfer learning on downstream tasks.} Evaluation of the representations from a ResNet-50 backbone pretrained with \algo \ on: (1) linear classification tasks on top of frozen representations, we report Top-1 accuracy (in \%) for Places205 \cite{zhou2014places} and iNat18~\cite{vanhorni2018naturalist}, and mAP for VOC07~\cite{everingham2010voc}; (2) object detection with fine-tunning, we report AP$_{50}$ for VOC07+12 using Faster R-CNN with C4 backbone~\cite{ren2015fasterrcnn}; (3) object detection and instance segmentation, we report AP for COCO~\cite{lin2014coco} using Mask R-CNN with FPN backbone~\cite{he2017maskrcnn}. We use ${\dagger}$ to denote the experiments run by us. Top-3 best self-supervised methods are \underline{underlined}.}
    \label{tab:transfer_learning}
    \vspace{-0.5em}
  \setlength{\tabcolsep}{2.0pt}
    \begin{tabular}{ @{} l ccc c ccc @{} }
      \toprule
       & \multicolumn{3}{c}{Linear Classification} &~~~~& \multicolumn{3}{c}{Object Detection}\\
\cmidrule{2-4}\cmidrule{6-8}
	   Method  & Places205 & VOC07 & iNat18 && VOC07+12 & COCO det & COCO seg \\
      \midrule
	    Supervised                          & 53.2  & 87.5 & 46.7 && 81.3 & 39.0 & 35.4 \\
      \midrule
	    MoCo~\cite{he2020moco}              & 46.9 & 79.8 & 31.5 && - & - & - \\
	    PIRL~\cite{misra2020pirl}           & 49.8 & 81.1 & 34.1 && - & - & - \\
	    SimCLR~\cite{chen2020simclr}        & 52.5 & 85.5 & 37.2 && - & - & -\\
	    MoCo v2~\cite{chen2020mocov2}       & 51.8 & 86.4 & 38.6 && 82.5 & 39.8 & 36.1 \\
	    SimSiam~\cite{chen2020simsiam}      & -      & -      & -      && 82.4 & - & - \\
	    BYOL~\cite{grill2020byol}           & 54.0 & \underline{86.6} & \underline{47.6} && - & \hspace{0.41em}\underline{40.4}$^{\dagger}$ & \hspace{0.41em}\underline{37.0}$^{\dagger}$ \\
	    SwAV (m-c)~\cite{caron2020swav}           & \underline{56.7} & \underline{88.9} & \underline{48.6} && \underline{82.6} & \underline{41.6} & \underline{37.8} \\
	    OBoW \cite{gidaris2021obow}         & \underline{56.8} & \underline{89.3} & -    && \underline{82.9} & - & - \\
	    Barlow Twins~\cite{grill2020byol}   & 54.1 & 86.2 & 46.5 && \underline{82.6} & \hspace{0.41em}\underline{40.0}$^{\dagger}$ & \hspace{0.41em}\underline{36.7}$^{\dagger}$ \\
\algo \ (ours)                      & \underline{54.3} & \underline{86.6} & \underline{47.0} && 82.4 & 39.4 & 36.4 \\
      \bottomrule
    \end{tabular}
\end{table}

\subsection{Multi-modal pretraining on MS-COCO}

One fundamental difference of VICReg compared to Barlow Twins is the way the branches are regularized. In VICReg, both branches are regularized independently, as the covariance term is applied on each branch separately, which works better in the scenarios where the branches are completely different, have different types of architecture and process different types of data. Indeed, the statistics of the output of the two branches can be very different, and the amount of regularization required for each may vary a lot. In Barlow Twins, the regularization is applied on the cross-correlation matrix, which favors the scenarios where the branches produce outputs with similar statistics. We demonstrate the capabilities of VICReg in a multi-modal experiment where we pretrain on pairs of images and corresponding captions on the MS-COCO dataset. We regularize each branch with a different coefficient, which is not possible with Barlow Twins, and we show that VICReg outperforms Barlow Twins on image and text retrieval downstream tasks. Table~\ref{tab:retrieval} reports the performance of VICReg against the contrastive loss proposed by VSE++ \cite{faghri2018vse}, and against Barlow Twins, in the identical setting proposed in \cite{faghri2018vse}. VICReg outperforms the two by a significant margin.

\begin{table}[t]
\caption{\textbf{Evaluation on MS-COCO 5K retrieval tasks.} Comparison of VICReg with the contrastive loss of VSE++ \cite{faghri2018vse}, and with Barlow Twins, pretrain on the training set of MS-COCO. In all settings, the encoder for text is a word embedding followed by a GRU layer, the encoder for images is a ResNet-152.}
\label{tab:retrieval}
\vspace{-1.5em}
\setlength{\tabcolsep}{10.5pt}
\vskip 0.15in
\begin{center}
\begin{tabular}{lcccccc}
\toprule
Method & \multicolumn{3}{c}{Image-to-text} &  \multicolumn{3}{c}{Text-to-Image} \\
                & R@1 & R@5 & R@10 & R@1 & R@5 & R@10 \\
\midrule
Contrastive (VSE++) &	30.3	& 59.4 &72.4	&41.3&	71.1&	81.2 \\
Barlow Twins	&31.4	&60,4	&75.1&	42.9	&74.0&	83.5 \\
VICReg	&33.6&	62.7&	77.9	&45.2&	76.1&	84.2 \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-2mm}
\end{table}


\section{Analysis} \label{sec:ablations}
In this section we study how the different components of our method contribute to its performance, as well as how they interact with components from other self-supervised methods. We also evaluate different scenarios where the branches have different weights and architecture. All reported results are obtained on the linear evaluation protocol, using a ResNet-50 backbone if not mentioned otherwise, and 100 epochs of pretraining, which gives results consistent with those obtained with 1000 epochs of pretraining. The optimization setting used for each experiment is described in Appendix~\ref{app:sec_impl_details}.

\vspace{2mm}
\textbf{Asymmetric networks.} \label{sec:ablation_asymetric} We study the impact of different components used in asymmetric architectures and the effects of adding variance and covariance regularization, in terms of performance and training stability. Starting from a simple symmetric architecture with an encoder and an \expander without batch normalization, which correspond to \algo \ without batch normalization in the \expandernospace, we progressively add batch normalization in the inner layers of the \expandernospace, a predictor, a stop-gradient operation and a momentum encoder. We use the training protocol and architecture of SimSiam \cite{chen2020simsiam} when a stop-gradient is used and the training protocol and architecture of BYOL \cite{grill2020byol} when a momentum encoder is used. The predictor as used in SimSiam and BYOL is a learnable module $g_{\psi}$ that predicts the embedding of a view given the embedding of the other view of the same image. If $z$ and $z^{\prime}$ are the embeddings of two views of an image, then $p = g_{\psi}(z)$ and $p^{\prime} = g_{\psi}(z^{\prime})$ are the predictions of each view. The invariance loss function of Eq.~(\ref{eq:invariance}) is now computed between a batch of embeddings $Z = [z_1, \dots, z_n]$ and the corresponding batch of predictions $P = [p_1^{\prime}, \dots, p_n^{\prime}]$, then symmetrized:
\begin{equation}
    s(Z, Z^{\prime}, P, P^{\prime}) = \frac{1}{2n} \sum_i D(z_i - p^{\prime}_i) + \frac{1}{2n} \sum_i D(z^{\prime}_i - p_i),
\end{equation}
where $D$ is a distance function that depends on the method used. BYOL uses the mean square error between $l_2$-normalized vectors, SimSiam uses the negative cosine similarity loss and \algo \ uses the mean square error without $l_2$-normalization. The variance and covariance terms are regularizing the output $Z$ and $Z^{\prime}$ of the \expandernospace, which we empirically found to work better than regularizing the output of the predictor. We compare different settings in Table~\ref{tab:ablation}, based on the default data augmentation, optimization and architecture settings of the original BYOL, SimSiam and \algo \ methods. In all settings, the absence of BN indicates that BN is also removed in the predictor when one is used.

\begin{table}[t]
\caption{\textbf{Effect of incorporating variance and covariance regularization in different methods.} Top-1 ImageNet accuracy with the linear evaluation protocol after 100 pretraining epochs. For all methods, pretraining follows the architecture, the optimization and the data augmentation protocol of the original method using our reimplementation. ME: Momentum Encoder. SG: stop-gradient. PR: predictor. BN: Batch normalization layers after input and inner linear layers in the \expandernospace. No Reg: No additional regularization. Var Reg: Variance regularization. Var/Cov Reg: Variance and Covariance regularization. Unmodified original setups are marked by a ${\dagger}$.}
\label{tab:ablation}
\vspace{-1.5em}
\setlength{\tabcolsep}{10.5pt}
\vskip 0.15in
\begin{center}
\begin{tabular}{lcccc|ccc}
\toprule
Method & ME & SG & PR & BN & No Reg & Var Reg & Var/Cov Reg \\
\midrule
BYOL            & \cmark & \cmark & \cmark & \cmark & \hspace{0.14em} 69.3$^{\dagger}$ & 70.2 & 69.5 \\
SimSiam         &        & \cmark & \cmark & \cmark & \hspace{0.14em} 67.9$^{\dagger}$ & 68.1 & 67.6 \\
SimSiam         &        & \cmark & \cmark &        & 35.1      & 67.3 & 67.1 \\
SimSiam         &        & \cmark &        &        & collapse  & 56.8 & 66.1 \\
\algo           &        &        & \cmark &        & collapse  & 56.2 & 67.3 \\
\algo           &        &        & \cmark & \cmark & collapse  & 57.1 & 68.7 \\
\algo           &        &        &        & \cmark & collapse  & 57.5 & \hspace{0.14em} 68.6$^{\dagger}$ \\
\algo           &        &        &        &        & collapse  & 56.5 & 67.4 \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-2mm}
\end{table}


We analyse first the impact of variance regularization (VR) in the different settings. When using VR, adding a predictor (PR) to \algo \ does not lead to a significant change of the performance, which indicates that PR is redundant with VR. In comparison, without VR, the representations collapse, and both stop-gradient (SG) and PR are necessary. Batch normalization in the inner layers of the \expander (BN) in \algo \ leads to a 1.0\% increase in the performance, which is not a big improvement considering that SG and PR without BN is performing very poorly at 35.1\%. 

Finally, incorporating VR with SG or ME further improves the performance by small margins of respectively 0.2\% and 0.9\%, which might be explained by the fact that these architectural tricks that prevent collapse are not perfectly maintaining the variance of the representations, i.e. very slow collapse is happening with these methods. We explain this intuition by studying the evolution of the standard deviation of the representations during pretraining for BYOL and SimSiam in Appendix~\ref{app:additional_results}. We then analyse the impact of adding additional covariance regularization (CR) in the different settings, along with variance regularization. We found that optimization with SG and CR is hard, even if our analysis of the average correlation coefficient of the representations during pretraining in Appendix~\ref{app:additional_results} shows that both fulfill the same objective. 

\newcommand{\xmark}{\ding{55}}\begin{table}[t]
\caption{\textbf{Impact of sharing weights or not between branches.} Top-1 accuracy on linear classification with 100 pretraining epochs. The encoder and \expander of both branches can share the same architecture and share their weights (SW), share the same architecture with different weights (DW), or have different architectures (DA). The encoders can be ResNet-50, ResNet-101 or ViT-S.}
\centering
\vspace{-2mm}
\label{tab:non-shared}
\begin{tabular}{lcccc}
\toprule
 & SW R50 & DW R50  & DA R50/R101 & DA R50/ViT-S \\
\midrule
BYOL          & 69.3  & \xmark & \xmark & \xmark \\
SimCLR        & 64.4  & 63.1 & 63.9 & 63.5 \\
Barlow Twins  & 68.7  & 64.2 & 65.3 & 63.9 \\
\algo         & 68.6  & 66.5 & 68.1 & 66.2\\
\bottomrule
\end{tabular}
\end{table}

The performance of BYOL and SimSiam slightly drops compared to VR only, except when PR is removed, where SG becomes useless. BN is still useful and improves the performance by 1.3\%. Finally with CR, PR does not harm the performance and even improves it by a very small margin. \algo+PR with 1000 epochs of pretraining exactly matches the score of \algo \ (73.2\% on linear classification).




\textbf{Weight sharing.} \label{sec:non-shared} 
Contrary to most self-supervised learning approaches based on Siamese architectures, \algo \ has several unique properties: (1) weights do not need to be shared between the branches, each branch's weights are updated independently of the other branch's weights; (2) the branches are regularized independently, the variance and covariance terms are computed on each branch individually; (3) no predictor is necessary unlike with methods where one branch predicts outputs of the other branch. We compare the robustness of VICReg against other methods in different scenarios where the weights of the branches can be shared (SW), not shared (DW), and where the encoders can have different  architectures (DA). Among other self-supervised methods, SimCLR and Barlow Twins are the only ones that can handle these scenarios. The asymmetric methods that are based on a discrepancy between the branches requires either the architecture or the weights to be shared between the branches. The performance drops by 2.1\% with VICReg and 4.5\% with Barlow Twins, between the shared weights scenario (SW) and the different weight scenario (DW). The difference between VICReg and Barlow Twins is also significant in scenarios with different architectures, in particular VICReg performs better than Barlow Twins by 2.8\% with ResNet-50/ResNet-101 and better by 2.3\% with ResNet-50/ViT-S \cite{dosovitskiy2021vit}. This shows that VICReg is more robust than Barlow Twins in these kind of scenarios. The performance of SimCLR remains stable across scenarios, but is significantly worse than the performance of VICReg. Importantly, {\bf the ability of \algo \ to function with different parameters, architectures, and input modalities for the branches widens the applicability to joint-embedding SSL to many applications, including multi-modal signals.}





\section{Conclusion} \label{sec:conclusion}
We introduced \algo, a simple approach to self-supervised learning based on a triple objective: learning invariance to different views with a invariance term, avoiding collapse of the representations with a variance preservation term, and maximizing the information content of the representation with a covariance regularization term. \algo \ achieves results on par with the state of the art on many downstream tasks, but is not subject to the same limitations as most other methods, particularly because it does not require the embedding branches to be identical or even similar.









\newpage

\textbf{Acknowledgement.} Jean Ponce was supported in part by the French government under management of Agence Nationale de la Recherche as part of the ”Investissements d’avenir” program,
reference ANR-19-P3IA-0001 (PRAIRIE 3IA Institute), the Louis Vuitton/ENS Chair in Artificial
Intelligence and the Inria/NYU collaboration. Adrien Bardes was supported in part by a FAIR/Prairie
CIFRE PhD Fellowship. The authors wish to thank Jure Zbontar for the BYOL implementation,
Stéphane Deny for useful comments on the paper, and Li Jing, Yubei Chen, Mikael Henaff, Pascal
Vincent and Geoffrey Zweig for useful discussions. We thank Quentin Duval and the VISSL team for
help obtaining the results of table 2.

\bibliographystyle{iclr2022_conference}
\bibliography{iclr2022_conference}


\newpage

\renewcommand{\thesubsection}{\Alph{subsection}}
\newcommand\tab[1][5mm]{\hspace*{#1}}

\subsection{Algorithm}


\begin{algorithm}[H]
  \caption{\algo \ pytorch pseudocode.}
  \label{alg:method}
    \definecolor{codeblue}{rgb}{0.25,0.5,0.5}
    \definecolor{codekw}{rgb}{0.85, 0.18, 0.50}
    \newcommand{\algofontsize}{11.0pt}
    \lstset{
      backgroundcolor=\color{white},
      basicstyle=\fontsize{\algofontsize}{\algofontsize}\ttfamily\selectfont,
      columns=fullflexible,
      breaklines=true,
      captionpos=b,
      commentstyle=\fontsize{\algofontsize}{\algofontsize}\color{codeblue},
      keywordstyle=\fontsize{\algofontsize}{\algofontsize}\color{black},
    }
\begin{lstlisting}[language=python]
# f: encoder network, lambda, mu, nu: coefficients of the invariance, variance and covariance losses, N: batch size, D: dimension of the representations
# mse_loss: Mean square error loss function, off_diagonal: off-diagonal elements of a matrix, relu: ReLU activation function

for x in loader: # load a batch with N samples
    # two randomly augmented versions of x
    x_a, x_b = augment(x)
    
    # compute representations
    z_a = f(x_a) # N x D
    z_b = f(x_b) # N x D
    
    # invariance loss
    sim_loss = mse_loss(z_a, z_b)
    
    # variance loss
    std_z_a = torch.sqrt(z_a.var(dim=0) + 1e-04)
    std_z_b = torch.sqrt(z_b.var(dim=0) + 1e-04)
    std_loss = torch.mean(relu(1 - std_z_a)) + torch.mean(relu(1 - std_z_b))
    
    # covariance loss
    z_a = z_a - z_a.mean(dim=0)
    z_b = z_b - z_b.mean(dim=0)
    cov_z_a = (z_a.T @ z_a) / (N - 1)
    cov_z_b = (z_b.T @ z_b) / (N - 1)
    cov_loss = off_diagonal(cov_z_a).pow_(2).sum() / D 
                    + off_diagonal(cov_z_b).pow_(2).sum() / D

    # loss
    loss = lambda * sim_loss + mu * std_loss + nu * cov_loss

    # optimization step
    loss.backward()
    optimizer.step()
\end{lstlisting}
\end{algorithm}

\newpage

\subsection{Relation to other self-supervised methods}

We compare here \algo \ with other methods in terms of methodology, and we discuss the mechanisms used by these methods to avoid collapse and to learn representations, and how they relate to \algo. We synthesize and illustrate the differences between these methods in Figure~\ref{fig:vicreg_comp}. 

\vspace{2mm}
\textbf{Relation to Barlow Twins} \cite{zbontar2021barlow}. \algo \ uses the same decorrelation mechanism as Barlow Twins, which consists in penalizing the off-diagonal terms of a covariance matrix computed on the embeddings. However, Barlow Twins uses the cross-correlation matrix where each entry in the matrix is a cross-correlation between two vectors $z^{i}$ and $z^{\prime j}$, from the two branches of the siamese architecture. Instead of using cross-correlations, we simply use the covariance matrix of each branch individually, and the variance term of \algo \ allows us to get rid of standardization. Indeed, Barlow Twins forces the correlations between pairs of vectors $z^{i}$ and $z^{\prime i}$ from the same dimension $i$ to be 1. Without normalization, this target value of 1 becomes arbitrary and the vectors take values in a wider range. Moreover, there is an undesirable phenomenon happening in Barlow Twins, the embeddings before standardization can shrink and become constant to numerical precision, which could cause numerical instabilities. In practice, this is solved by adding a constant scalar in the denominator of standardization of the embeddings. Without normalization, \algo \ naturally avoids this edge case.

\vspace{2mm}
\textbf{Relation to W-MSE} \cite{ermolov2021whitening}. The whitening operation of W-MSE consists in computing the inverse covariance matrix of the embeddings and use its square root as a whitening operator on the embeddings. Using this operator has two downsides. First, matrix inversion is a very costly and potentially unstable operation. \algo \ does not need to inverse the covariance matrix. Second, as mentioned in \cite{ermolov2021whitening} the whitening operator is constructed over several consecutive iteration batches and therefore might have a high variance, which biases the estimation of the mean-squared error. This issue is overcome in practice by a batch slicing strategy, where the whitening operator is computed over randomly constructed sub-batches. \algo \ does not apply any operator on the embeddings, but instead regularizes the variance and covariance of the embeddings using an additional constraint.

\vspace{2mm}
\textbf{Relation to BYOL and SimSiam} \cite{grill2020byol, chen2020simsiam}. The core components that avoid collapse in BYOL and SimSiam are the average moving weights and the stop-gradient operation on one side of their asymmetric architecture, which play the role of the repulsive term used in other methods. Our experiments in Appendix~\ref{app:combination} show that in addition to preventing collapse, these components also have a decorrelation effect. In addition, we have conducted the following experiment: We compute the correlation matrix of the final representations obtained with SimSiam, BYOL, \algo \ and \algo \ without covariance regularization. We measure the average correlation coefficient and observe that this coefficient is much smaller for SimSiam, BYOL and \algo, compared to \algo \ without covariance regularization. We observe in Figure~\ref{fig:byol_simsiam_cor} that even without covariance regularization, SimSiam and BYOL naturally minimize the average correlation coefficient of the representations. \algo \ replaces the moving average weights and the stop-gradient operation, which are architectural trick that require some dependency between the branches, by an explicit constraint on the variance and the covariance of both embeddings separately, which achieves the same goal of decorrelating the representations and avoiding collapse, while being clearer, more interpretable, and working with independent branches.

\vspace{2mm}
\textbf{Relation to SimCLR, SwAV and OBoW} \cite{caron2020swav, chen2020simclr, gidaris2021obow}. Contrastive and clustering based self-supervised algorithms rely on direct comparisons between elements of negative pairs. In the case of SimCLR, the negative pairs involve embeddings mined from the current batch, and large batch sizes are required. Despite the fact that SwAV computes clusters using elements in the current batch, it does not seem to have the same dependency on batch size. However, it still requires a lot of prototype vectors for negative comparisons between embeddings and codes. \algo \ eliminates the negative comparisons and replace them by an explicit constraint on the variance of the embeddings, which efficiently plays the role of a negative term between the vectors. SwAV can also be interpreted as a distillation method, where a teacher network produces quantized vectors, used as target for a student network. Ensuring an equal partition of the quantized vectors in different bins or clusters effectively prevents collapse. OBOW can also be interpreted under the same framework. The embeddings are bag-of-words over a vocabulary of visual features, and collapse is avoided by the underlying quantization operation.




\newpage

\begin{figure}[t]
\centering
\hspace{2mm}
{\includegraphics[trim=0cm 0.0cm 0cm 0cm, clip, width=127mm]{figures/comp1.pdf}}
\vspace{-10mm}
\end{figure}

\begin{figure}[t]
\centering
\captionsetup[subfigure]{labelformat=empty}
\subfloat[] {\includegraphics[trim=0cm 0.0cm 0cm 0cm, clip, width=130mm]{figures/comp2.pdf}}
\vspace{-4mm}
\caption{\textbf{Conceptual comparison between different self-supervised methods.} The inputs $X$ and $X^{\prime}$ are fed to an encoder $f$ with weights $\theta$. The representations $Y$ and $Y^{\prime}$ are further processed by a network $h$ with weights $\psi$. $h$ can be a projector (narrowing trapeze) that reduces the dimensionality of the representations, or an expander (widening trapeze) that increases their dimensionality. A criterion is finally applied on the embeddings $Z$ and $Z^{\prime}$. \algo \ (a) works when both branches have encoders $f$ and $f^{\prime}$ with different architectures and sets of weights $\theta$ and $\theta^{\prime}$. Each branch's variance and covariance are regularized by regularizers $v$ and $c$, and the distance between both branches is minimized with a mean-squared error loss $s$. Barlow Twins (b) uses a loss $c$ to decorrelate pairs of different dimensions in the batch-wise normalized (B-Norm) embeddings, and learns invariance with a loss $i$ that makes similar dimensions highly correlated. W-MSE (c) uses a batch slicing operation that shuffles batches into small sub-batches, and apply PCA as a whitening operation on the feature-wise normalized (F-Norm) embeddings of each sub-batch. BYOL (d) has an asymmetric architecture where the weights $\theta_{m}$ of one encoder are an exponential moving average (ema) of the other encoder's weights $\theta$. A predictor $g$ with weights $\psi$ is used in the branch with learnable weights. SimSiam (e) uses a predictor on one branch and a stop-gradient operation (sg) on the other one. SimCLR (f) uses the InfoNCE contrastive loss where all the feature-wise normalized embeddings are compared between them inside a batch. Samples from distorted versions of the same input are brought close to each other, while other samples are pushed away. SwAV (g) quantizes the feature-wise normalized embeddings of a branch and use it as target for the other one. OBoW (h) uses bag-of-words (BoW) representations and a cross-entropy loss to compare the BoW generated by a teacher network from the feature maps $Y^{F}$ of the encoder, to the BoW predicted by a student network. Green blocks: parametric functions; yellow boxes: non-parametric functions; blue boxes: objective functions.}
\label{fig:vicreg_comp}
\end{figure}

\clearpage



















\subsection{Additional implementation details} \label{app:sec_impl_details}

\subsubsection{Data augmentation} \label{app:data_aug}

We follow the image augmentation protocol first introduced in SimCLR \cite{chen2020simclr} and now commonly used by similar approaches based on siamese networks \cite{caron2020swav, grill2020byol, chen2020simsiam, zbontar2021barlow}. Two random crops from the input image are sampled and resized to $224 \times 224$, followed by random horizontal flip, color jittering of brightness, contrast, saturation and hue, Gaussian blur and random grayscale. Each crop is normalized in each color channel using the ImageNet mean and standard deviation pixel values.
In more details, the exact set of augmentations is based on BYOL~\cite{grill2020byol} data augmentation pipeline but is symmetrised. The following operations are performed sequentially to produce each view:
\begin{itemize}
    \item Random cropping with an area uniformly sampled with size ratio between 0.08 to 1.0, followed by resizing to size 224 $\times$ 224. \texttt{RandomResizedCrop(224, scale=(0.08, 0.1))} in PyTorch.
    \item Random horizontal flip with probability 0.5.
    \item Color jittering of brightness, contrast, saturation and hue, with probability 0.8. \texttt{ColorJitter(0.4, 0.4, 0.2, 0.1)} in PyTorch.
    \item Grayscale with probability 0.2.
    \item Gaussian blur with probability 0.5 and kernel size 23.
    \item Solarization with probability 0.1.
    \item color normalization with mean (0.485, 0.456, 0.406) and standard deviation (0.229, 0.224, 0.225).
\end{itemize}

\subsubsection{ImageNet evaluation} \label{app:eval_imnet}

\textbf{Linear evaluation.} We follow standard procedure and train a linear classifier on top of the frozen representations of a ResNet-50 pretrained with \algo. We use the SGD optimizer with a learning rate of $0.02$, a weight decay of $10^{-6}$, a batch size of 256, and train for 100 epochs. The learning rate follows a cosine decay. The training data augmentation pipeline is composed of random cropping and resize of ratio 0.2 to 1.0 with size 224 $\times$ 224, and random horizontal flips. During evaluation the validation images are simply center cropped and resized to 224 $\times$ 224.

\textbf{Semi-supervised evaluation.} We train a linear classifier and fine-tune the representations using 1 and 10\% of the labels. We use the SGD optimizer with no weight decay and a batch size of 256, and train for 20 epochs. We perform a grid search on the values of the encoder and linear head learning rates. In the 10\% of labels case, we use a learning rate of 0.01 for the encoder and 0.1 for the linear head. In the 1\% of labels case we use 0.03 for the encoder and 0.08 for the linear head. The two learning rates follow a cosine decay schedule. The training data and validation augmentation pipelines are identical to the linear evaluation data augmentation pipelines.

\subsubsection{Transfer learning} \label{app:transfer_other}

We use the VISSL library \cite{goyal2021vissl} for linear classification tasks and the detectron2 library \cite{wu2019detectron2} for object detection and segmentation tasks.

\textbf{Linear classification.} We follow standard protocols \cite{misra2020pirl, caron2020swav, zbontar2021barlow} and train linear models on top of the frozen representations. For VOC07 \cite{everingham2010voc}, we train a linear SVM with LIBLINEAR \cite{fan2008liblinear}. The images are center cropped and resized to 224 $\times$ 224, and the C values are computed with cross-validation. For Places205 \cite{zhou2014places} we use SGD with a learning rate of 0.003, a weight decay of 0.0001, a momentum of 0.9 and a batch size of 256, for 28 epochs. The learning rate is divided by 10 at epochs 4, 8 and 12. For Inaturalist2018 \cite{vanhorni2018naturalist}, we use SGD with a learning rate of 0.005, a weight decay of 0.0001, a momentum of 0.9 and a batch size of 256, for 84 epochs. The learning rate is divided by 10 at epochs 24, 48 and 72.

\textbf{Object detection and instance segmentation.} Following the setup of \cite{he2020moco, zbontar2021barlow}, we use the \texttt{trainval} split of VOC07+12 with 16K images for training and a Faster R-CNN C-4 backbone for 24K iterations with a batch size of 16. The backbone is initialized with our pretrained ResNet-50 backbone. We use a learning rate of 0.1, divided by 10 at iteration 18K and 22K, a linear warmup with slope of 0.333 for 1000 iterations, and a region proposal network loss weight of 0.2. For COCO we use Mask R-CNN FPN backbone for 90K iterations with a batch size of 16, a learning rate of 0.04, divided by 10 at iteration 60K and 80K and with 50 warmup iterations.

\subsubsection{Analysis} \label{app:ablation}

We give here implementation details on the results of Table~\ref{tab:ablation} with BYOL and SimSiam, as well as the default setup for \algo \ with 100 epochs of pretraining, used in all our ablations included in Appendix~\ref{app:additional_results}. For both BYOL and SimSiam experiments, the variance criterion has coefficient $\mu=1$ and the covariance criterion has coefficient $\nu=0.01$, the data augmentation pipeline and the architectures of the expander and predictor exactly follow the pipeline and architectures described in their paper. The linear evaluation setup of each methods follows closely the setup described in the original papers.

\textbf{BYOL setup.} We use our own BYOL implementation in PyTorch, which outperforms the original implementation for 100 epochs of pretraining (69.3\% accuracy on the linear evaluation protocol against 66.5\% for the original implementation) and matches its performance for 1000 epochs of pretraining. We use the LARS optimizer \cite{you2017lars}, with a learning rate of $base\_lr * batch\_size / 256$ where $base\_lr$ = 0.45, and $batch\_size$ = 4096, a weight decay of $10^{-6}$, an eta value of 0.001 and a momentum of 0.9, for 100 epoch of pretraining with 10 epochs of warmup. The learning rate follows a cosine decay schedule. The initial value of the exponential moving average factor is 0.99 and follows a cosine decay schedule. 

\textbf{SimSiam setup.} We use our own implementation of SimSiam, which reproduces exactly the performance reported in the paper \cite{chen2020simsiam}. We use SGD with a learning rate of $base\_lr * batch\_size / 256$ where $base\_lr$ = 0.05, $batch\_size$ = 2048, with a weight decay of 0.0001 and a momentum of 0.9 for 100 epochs of pretraining and 10 epochs of warmup. The learning rate of the encoder and the expander follow a cosine decay schedule while the learning rate of the predictor is kept fixed.

\textbf{\algo \ setup.} The setting of \algo's experiments is identical to the setting described in section~\ref{sec:impl_details}, except that the number of pretraining epochs is 100 and the base learning rate is 0.3. The base learning rates used for the batch size study are 0.8, 0.5 and 0.4 for batch size 128, 256 and 512 respectively, and 0.3 for all other batch sizes. When a predictor is used, it has a similar architecture as the expander described in section~\ref{sec:impl_details}, but with 2 layers instead of 3, which gives better results in practice.

\subsection{Additional results} \label{app:additional_results}

\subsubsection{Other ResNet architectures}

Table~\ref{tab:large_arch} reports the performance of \algo \ on linear classification with large ResNet architectures. We focus on the wider family of ResNet \cite{zagoruyko2016resnetwide} and aggregated ResNet \cite{xie2017resnext}, and we consider two ways of widening a standard ResNet. First, we follow standard practice in recent self-supervised learning work \cite{caron2020swav, grill2020byol, chen2020simclr} and multiple by 2 or 4 the number of filters in every convolutional layer, which also has the effect of multiplying the dimensionality of the representations. Second, as originally proposed in \cite{zagoruyko2016resnetwide}, we only multiply the number of filters in the bottleneck layers, which does not increases the dimensionality of the representations. We call this architecture Narrow ResNet (with prefix N- in Table~\ref{tab:large_arch}). The main observation we make is the dependency of \algo \ on the dimensionality of the representation. Using the narrow architecture, the performance of \algo, jumps from 73.2\% top-1 accuracy on linear classification with a ResNet-50, to 74.7\% with Narrow ResNet-50 (x2), which is a 1.5\% improvement and 76.0\% with Narrow ResNet-50 (x4), which is a 2.8\% improvement. We observe a similar trend going from ResNet-50 to ResNet-50 (x2), which is a 2.3\% improvement but the performance completely saturates with ResNet-50 (x4), which is a 0.1\% improvement over ResNet-50 (x2). Table~\ref{tab:large_arch_semi} reports the performance of \algo \ on semi-supervised classification with large ResNet architectures. \algo \ combined with a ResNet-50 (x2) \ outperforms the current state-of-the-art methods BYOL and SimCLR, using this encoder architecture. Our largest model ResNet-200 (x2) performs lower than BYOL when 1\% of the labels are used but is on par with 10\% of the labels. These results demonstrate the capabilities of \algo \ to scale up when large architectures are used.


\subsubsection{Pretraining and evaluation on ESC-50 audio classification}

We demonstrate the ability of VICReg to function in a setting where the branches have different architectures by pretraining on the ESC-50 audio dataset \cite{piczak2015dataset}, which is an environmental sound classification dataset with 50 classes. We jointly embedded a raw audio time-series representation on one branch, with its corresponding time-frequency representation on the other branch. We use the standard split of ESC-50 \cite{piczak2015dataset}, composed of 1600 training audio samples and 400 validation sample. The raw audio encoder is a 1-dimensional ResNet-18 with output dimension 384. The time-frequency image representation is the mel spectrogram with 1 channel of the raw audio, that we normalize between 0 and 1, and that is processed be a ResNet-18 with output dimension of 512. We use the AdamW optimizer with learning rate 0.0005 for 100 epochs of pretraining.

Table~\ref{tab:audio_results} reports the performance of a linear classifier trained one the frozen representations obtained with VICReg and Barlow Twins to a simple supervised baseline where we train a ResNet-18 on the time-frequency representation in a supervised way. VICReg performs better by 5.7\% than our supervised baseline, and better by 3.0\% than Barlow Twins. We give more details in Appendix~\ref{app:audio}. Current best approaches that report around 95\% accuracy on this task uses tricks such as heavy data augmentation or pretraining on larger audio and video datasets. With this experiment, our purpose is not to push the state of the art on ESC-50, but merely to demonstrate the applicability of VICReg to settings with multiple architectures and input modalities.

\begin{table}[t]
\caption{\textbf{Evaluation on ESC-50.} Evaluation of the representations obtained with a ResNet-18 backbone pretrained with \algo \ on ESC-50 \cite{piczak2015dataset} by processing jointly a raw audio time-series and its corresponding time-frequency representation. The supervised baseline corresponds to a ResNet-18 trained on the time-frequency representation in a supervised way. We report Top-1 accuracy on the validation set (in \%).}
\centering
\vspace{-2mm}
\label{tab:audio_results}
\begin{tabular}{lc}
\toprule
Method & Top-1 \\
\midrule
Supervised baseline  & 72.7 \\
Barlow Twins  & 75.4 \\
\algo         & 78.4 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{K-nearest-neighbors}

Following recent protocols \cite{caron2020swav, wu2018discrimination, zhuang2019local}, we evaluate the learnt representations using K-nearest-neighbors classifiers built on the training set of ImageNet and evaluated on the validation set of ImageNet. We report the results with K=20 and K=200 in Table~\ref{tab:results_knn}. \algo \ performs slightly lower than other methods in the 20-NN case but remains competitive in the 200-NN case. These results with K-NN classifiers demonstrate the potential applicability of \algo \ to downstream tasks based on nearest neighbors search, such as content retrieval in images or videos.

\subsubsection{Loss function coefficients.} \label{app:loss_coeffs}
Table~\ref{tab:impact_varcov} reports the performance for various values of the loss term coefficients in Eq.~(\ref{eq:loss}). Without variance regularization the representations immediately collapse to a single vector and the covariance term, which has no repulsive effect preventing collapse, has no impact. The invariance term is absolutely necessary and without it the network can not learn any good representations. By simply using the invariance term and variance regularization, which is a very simple baseline, \algo \ still reaches an accuracy of 57.5$\%$. These results show that variance and covariance regularizations have complementary effects, and that both are required.

On ImageNet, we choose the final coefficients the following way. First, we have empirically found that using very different values for $\lambda$ and $\mu$, or taking $\lambda=\mu$ with $\nu > \mu$ leads to unstable training. On the other hand taking $\lambda=\mu$ and picking $\nu<\mu$ leads to stable convergence, with the exact value picked for $mu$ having very limited influence on the final linear classification accuracy. We have found that setting $lambda=mu= 25$ and $nu=1$ works best (by a small margin) for Imagenet but we have also obtained excellent results on MNIST and Cifar-10 and 100 using these exact same values. We could easily have tuned these parameters by cross-validation on the validation sets of these two smaller datasets.

\def \hfillx {\hspace*{-\textwidth} \hfill}
\begin{table}[t]
\small
\begin{minipage}[c]{0.49\textwidth}
\centering
    \captionof{table}{\textbf{Impact of variance-covariance regularization.} Inv: a invariance loss is used, $\lambda > 0$, Var: variance regularization, $\mu > 0$, Cov: covariance regularization, $\nu > 0$, in Eq.~(\ref{eq:loss}).}
    \vspace{-1.5mm}
\label{tab:impact_varcov}
    \setlength\tabcolsep{3.5pt}
    \small
    \vspace{0.1mm}
    \begin{tabular}{lccccc}
    \toprule
    Method & $\lambda$ & $\mu$ & $\nu$ & Top-1  \\
    \midrule
    Inv                         & 1     & 0     & 0     & collapse \\
    Inv + Cov                   & 25    & 0     & 1     & collapse \\
    Inv + Cov                   & 0     & 25    & 1     & collapse \\
    Inv + Var                   & 1     & 1     & 0     & 57.5 \\
    \midrule
    Inv + Var + Cov (\algo)     & 1     & 1	    & 1	    & collapse \\
                                & 1	    & 10	& 1	    & collapse \\
                                & 10	& 1	    & 1	    & collapse \\
                                & 5	    & 5	    & 1	    & 68.1 \\
                                & 10	& 10	& 1	    & 68.2 \\
                                & 25    & 25    & 1     & 68.6 \\
                                & 50	& 50	& 1	    & 68.3 \\
    \bottomrule
    \end{tabular}
\end{minipage}
\hfillx
\begin{minipage}[c]{0.49\textwidth}
\centering
    \captionof{table}{\textbf{Impact of normalization.} Std: variables are centered and divided by their standard deviation over the batch. This is applied or not to the embedding and the expander hidden layers. $l_2$: the embedding vectors are $l_2$-normalized.}
    \vspace{-1.5mm}
    \label{tab:impact_norm}
    \small
    \begin{tabular}{llc}
    \toprule
    Representation & Embedding & Top-1  \\
    \midrule
Std  & None  & 68.6 \\
    Std  & Std & 68.4 \\
    None & Std  & 67.4 \\
    Std & None & 67.2 \\
    None  & $l_2$ & 65.1 \\
    \bottomrule
    \end{tabular}
\end{minipage}
\end{table}


\subsubsection{Normalizations} 
\algo \ is the first self-supervised method for joint-embedding architectures we are aware of that does not require normalization. Contrary to SimSiam, W-MSE, SwAV and BYOL, and others, the embedding vectors are not projected on the unit sphere. Contrary to Barlow Twins, they are not standardized (equivalent to batch normalization without the adaptive parameters). Table~\ref{tab:impact_norm} shows that the best settings do not involve any normalization of the embeddings, whether it is batch-wise or feature-wise (as in  $l_2$ normalization). Whenever the embeddings are standardized (lines 3 and 5 in the table) the covariance matrix of Eq.~(\ref{eq:covariance}) becomes the normalized auto-correlation matrix with coefficients between -1 and 1. This hurts the accuracy by 0.2$\%$. We observe that when unconstrained, the coefficients in the covariance matrix take values in a wider range, which seems to facilitate the training process. Standardization is still an important component that helps stabilize the training when used in the hidden layers of the \expandernospace, and the performance drops by 1.2\% when it is removed. Projecting the embeddings on the unit sphere implicitly constrains their standard deviation along the batch dimension to be $1/\sqrt{d}$, where $d$ is the dimension of the vectors. We change the invariance term of Eq.~(\ref{eq:invariance}) to be the mean square error between $l_2$-normalized vectors, and the target $\gamma$ in the variance term of Eq.~(\ref{eq:var_loss}) is set to $1/\sqrt{d}$ instead of $1$, forcing the standard deviation to get closer to $1/\sqrt{d}$, and the vectors to be spread out on the unit sphere. This puts a lot more constraints on the network and the performance drops by 3.5\%.

\clearpage

\begin{table}[t]
\caption{\textbf{Linear classification with large architectures.} Top-1 accuracy comparison between different methods using various encoder architectures. For all \algo \ results, the output dimensionality of the expander is 8192. N-R stands for Narrow ResNet, where only the bottleneck convolutional layers are widen.}
\label{tab:large_arch}
\vspace{-6mm}
\vskip 0.15in
\begin{center}
\begin{tabular}{llrrcc}
\toprule
Method & Arch. & Param. & Repr. & Top-1 & Top-5 \\
\midrule
SimCLR \cite{chen2020simclr}    & R50 (x2)   &   93M     &   4096    &   74.2    &   92.0    \\
  & R50 (x4)   &   375M    &   8192    &   76.5    &   93.2    \\
\midrule
SwAV \cite{caron2020swav}& R50 (x2)    &   93M     &   4096    &   77.3    &   -    \\
 & R50 (x4)    &   375M    &   8192    &   77.9    &   -    \\
 & R50 (x5)    &   586M    &   10240   &   78.5    &   -    \\
\midrule
BYOL \cite{grill2020byol}& R50 (x2)    &   93M     &   4096    &   77.4    &   93.6    \\
 & R50 (x4)    &   375M    &   8192    &   78.6    &   94.2    \\
 & R200 (x2)   &   250M    &   4096    &   79.6    &   94.8    \\
\midrule
\algo \ (ours) & N-R50 (x2)    &   66M     &   2048    &   74.7    &   91.9    \\
 & N-R50 (x4)    &   221M    &   2048    &   76.0    &   92.4  \\
 & R50 (x2)    &   93M     &   4096    &   75.5    &   92.1    \\
 & R50 (x4)    &   375M    &   8192    &   75.6    &   92.2    \\
 & RNXT101-32-16 &   191M    &   2048    &   76.1    &   92.3  \\
 & R200 (x2)   &   250M    &   4096    &   77.3    &   93.3    \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\begin{table}[t]
\caption{\textbf{Semi-supervised classification with large architectures.} Top-1 accuracy comparison between different methods using various encoder architectures. For all \algo \ results, the output dimensionality of the expander is 8192.}
\label{tab:large_arch_semi}
\vspace{-6mm}
\vskip 0.15in
\begin{center}
\begin{tabular}{llrrcccc}
\toprule
Method  & Arch. & Param.    & Repr. & \multicolumn{2}{c}{Top-1} & \multicolumn{2}{c}{Top-5} \\
        &       &           &       & 1\% & 10\% & 1\% &  10 \% \\
\midrule
SimCLR \cite{chen2020simclr}    & R50 (x2)   &   93M     &   4096    &   58.5    &   71.7  & 83.0  & 91.2  \\
  & R50 (x4)   &   375M    &   8192    &   63.0    &   74.4 &  85.8  & 92.6 \\
\midrule
BYOL \cite{grill2020byol}& R50 (x2)    &   93M     &   4096    &   62.2    &   73.5 & 84.1 & 91.7    \\
 & R50 (x4)    &   375M    &   8192    &   69.1    &   75.7 & 87.9 & 92.5    \\
 & R200 (x2)   &   250M    &   4096    &   71.2    &   77.7 & 89.5 & 93.7    \\
\midrule
\algo \ (ours) & R50 (x2)    &   93M     &   4096    &   62.6    &   73.9  &   84.5    &   91.8  \\
& R200 (x2)   &   250M    &   4096    &   68.8    &   77.3  &   88.2    &   93.6  \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\begin{table}[t]
\caption{\textbf{K-NN classifiers on ImageNet.} Top-1 accuracy with 20 and 200 nearest neighbors.}
\vspace{-6mm}
\label{tab:results_knn}
\vskip 0.15in
\begin{center}
\begin{tabular}{lcc}
\toprule
Method & 20-NN & 200-NN \\
\midrule
NPID \cite{wu2018discrimination}        &  -        & 46.5    \\
LA \cite{zhuang2019local}               &  -        & 49.4    \\
PCL \cite{li2021pcl}                    &  54.5     & -         \\
BYOL \cite{grill2020byol}               &  66.7     & 64.9  \\
SwAV \cite{caron2020swav}               &  65.7     & 62.7    \\
Barlow Twins \cite{zbontar2021barlow}   &  64.8     & 62.9  \\
\algo \                                 &  64.5     & 62.8  \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\clearpage

\subsubsection{Expander network architecture} \label{app:expander_archi}
\algo \ borrows the decorrelation mechanism of Barlow Twins \cite{zbontar2021barlow} and we observe that it therefore has the same dependency on the dimensionality of the expander network. Table~\ref{tab:ablation_expander} reports the impact of the width and depth of the expander network. The dimensionality corresponds the number of hidden and output units in the expander network during pretraining. As the dimensionality increases, the performance dramatically increases from 55.9\% top-1 accuracy on linear evaluation with a dimensionality of 256, to 68.8\% with dimensionality 16384. The performance tends to saturate as the difference between dimensionality 8192 and 16384 is only of 0.2\%.

\subsubsection{Batch size} \label{sec:batch_size} Contrastive methods suffer from the need of a lot of negative examples which can translate into the need for very large batch sizes \cite{chen2020simclr}. Table~\ref{tab:ablation_bs} reports the performance on linear classification when the size of the batch varies between 128 and 4096. For each value of batch size, we perform a grid search on the base learning rate described in Appendix~\ref{app:ablation}. We observe a $0.7\%$ and $1.2\%$ drop in accuracy with small batch size of 256 and 128 which is comparable with the robustness to batch size of Barlow Twins \cite{zbontar2021barlow} and SimSiam \cite{chen2020simsiam}, and a $0.8\%$ drop with a batch size of 4096, which is reasonable and allows our method to be very easily parallelized on multiple GPUs.

\begin{table}[t]
\caption{\textbf{Impact of expander dimensionality.} Top-1 accuracy on the linear evaluation protocol with 100 pretraining epochs.}
\label{tab:ablation_expander}
\vspace{-6mm}
\setlength{\tabcolsep}{10.5pt}
\vskip 0.15in
\begin{center}
\begin{tabular}{lccccccc}
\toprule
Dimensionality      & 256      & 512      & 1024      & 2048     & 4096  &  8192  &  16834 \\
\midrule
Top-1           & 55.9 & 59.2 & 62.4 & 65.1 & 67.3 & 68.6 & 68.8 \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-2mm}
\end{table}

\begin{table}[t]
\caption{\textbf{Impact of batch size.} Top-1 accuracy on the linear evaluation protocol with 100 pretraining epochs.}
\label{tab:ablation_bs}
\vspace{-6mm}
\setlength{\tabcolsep}{10.5pt}
\vskip 0.15in
\begin{center}
\begin{tabular}{lccccccc}
\toprule
Batch size      & 128      & 256      & 512      & 1024     & 2048     & 4096 \\
\midrule
Top-1           & 67.3 & 67.9 & 68.2 & 68.3 & 68.6 & 67.8 \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-2mm}
\end{table}


\subsubsection{Combination with BYOL and SimSiam} \label{app:combination}

BYOL \cite{grill2020byol} and SimSiam \cite{chen2020simsiam} rely on a effective but difficult to interpret mechanism for preventing collapse, which may lead to instabilities during the training. We incorporate our variance regularization loss into BYOL and SimSiam and show that it helps stabilize the training and offers a small performance improvement. For both methods, the results are obtained using our own implementation and the exact same data augmentation and optimization settings as in their original paper. The variance and covariance regularization losses are incorporated with a factor of $\mu=1$ for variance and $\nu=0.01$ for covariance. We report in Figure~\ref{fig:byol_simsiam_accuracy} the improvement obtained over these methods on the linear evaluation protocol for different number of pre-training epochs. For BYOL the improvement is of 0.9\% with 100 epochs and becomes less significant as the number of pre-training epochs increases with a 0.2\% improvement with 1000 epochs. This indicates that variance regularization makes BYOL converge faster. In SimSiam the improvement is not as significant. We plot in Figure~\ref{fig:std} the evolution of the standard deviation computed along each dimension and averaged across the dimensions of the representation and the embeddings, during BYOL and SimSiam pretraining. For both methods, the standard deviation computed on the embeddings perfectly matches $1/\sqrt{d}$ where $d$ is the dimension of the embeddings, which indicates that the embeddings are perfectly spread-out across the unit sphere. This translates in an increased standard deviation at the representation level, which seems to be correlated to the performance improvement. We finally study in Figure~\ref{fig:byol_simsiam_cor} the evolution of the average correlation coefficient, during pretraining of BYOL and SimSiam, with and without variance and covariance regularization. The average correlation coefficient is computed by averaging the off-diagonal coefficients of the correlation matrix of the representations:
\begin{equation}
    \frac{1}{2d(d-1)} \sum_{i \ne j} C(Y)_{i,j}^2 + C(Y^{\prime})_{i,j}^2,
\end{equation}
where $Y$ and $Y^{\prime}$ are the standardized representations and $C$ is defined in Eq.~(\ref{eq:covariance}). In BYOL this coefficient is much lower using covariance regularization, which translate in a small improvement of the performance, according to Table~\ref{tab:ablation}. We do not observe the same improvement in SimSiam, both in terms of correlation coefficient, and in terms of performance on linear classification. The average correlation coefficient is correlated with the performance, which motivates the fact that decorrelation and redundancy reduction are core mechanisms for learning self-supervised representations.

\begin{figure}
\hspace{-4em}
    \centering
    \begin{minipage}{0.38\textwidth}
        \centering
        \includegraphics[trim=0.4cm 0cm 1.0cm 0cm, clip, width=1.3\textwidth]{plots/byol_var.pdf}
\end{minipage}\hspace{5em}
    \begin{minipage}{0.42\textwidth}
        \centering
        \includegraphics[trim=0.1cm 0cm 0cm 0cm, clip, width=1.3\textwidth]{plots/simsiam_var.pdf}
    \end{minipage}
    \caption{\textbf{Incorporating variance regularization in BYOL and SimSiam.} Top-1 accuracy on the linear evaluation protocol for different number of pretraining epochs. For both methods pre-training follows the optimization and data augmentation protocol of their original paper but is based on our implementation. \textit{Var} indicates variance regularization}
    \label{fig:byol_simsiam_accuracy}
\end{figure}


\subsection{Running time} \label{app:running_time}

We report in Table~\ref{tab:running_time}, the running time of \algo \ in comparison with other methods. All methods are run by us on 32 Tesla V100 GPUs. Each method offers a different trade-off between running time, memory and performance. SwAV is a very fast algorithm which use less memory and run faster than the other methods but with a lower performance, multi-crop helps the performance at the cost of additional compute and memory usage. BYOL has the highest memory requirement, which is due to the need of storing the target network weights. Finally, Barlow Twins and \algo \ offer an interesting trade-off, consuming less memory than BYOL and SwAV with multi-crop, and running faster than SwAV with multi-crop, but with a slightly worse performance. The difference of 1h running time between Barlow Twins and \algo \ is probably due to implementation details not related to the method.

\vspace{6mm}

\begin{table}[h]
\caption{\textbf{Running time and peak memory.} Comparison between different methods, the training is distributed on 32 Tesla V100 GPUs, the running time is measured over 100 epochs and the peak memory is measured on a single GPU. We report top-1 accuracy (\%) on linear classification on top of the frozen representations.}
\vspace{-6mm}
\label{tab:running_time}
\vskip 0.15in
\begin{center}
\begin{tabular}{lccc}
\toprule
Method & time / 100 epochs & peak memory / GPU & Top-1 accuracy (\%) \\
\midrule
SwAV                        &   9h      &   9.5G    & 71.8 \\
SwAV (w/ multi-crop)        &   13h     &   12.9G   & 75.3 \\
BYOL                        &   10h     &   14.6G   & 74.3 \\
Barlow Twins                &   12h     &   11.3G   & 73.2 \\
\algo                       &   11h     &   11.3G   & 73.2 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\newpage
\setcounter{figure}{2}

\begin{figure}[b]
\centering
\hspace{-4em}
\begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics[width=1.3\textwidth]{plots/byol_stde.pdf}
\end{subfigure}\hspace{5em}
\begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics[width=1.3\textwidth]{plots/byol_stdh.pdf}
\end{subfigure}
\end{figure}
\begin{figure}[b]
\vspace{-3em}
\centering
\hspace{-4em}
\begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics[width=1.3\textwidth]{plots/simsiam_stde.pdf}
\end{subfigure}\hspace{5em}
\begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics[width=1.3\textwidth]{plots/simsiam_stdh.pdf}
\end{subfigure}
\caption{\textbf{Standard deviation of the features during BYOL and SimSiam pretraining.} Evolution of the average standard deviation of each dimension of the features with and without variance regularization (Var). left: the standard deviation is measured on the representations, right: the standard deviation is measured on the embeddings.}
\label{fig:std}
\end{figure}

\begin{figure}
    \hspace{-4em}
    \centering
    \begin{minipage}{0.4\textwidth}
        \centering
        \includegraphics[trim=0.0cm 0cm 0cm 0cm, clip, width=1.3\textwidth]{plots/byol_core.pdf} \end{minipage}\hspace{5em}
    \begin{minipage}{0.4\textwidth}
        \centering
        \includegraphics[trim=0cm 0cm 0cm 0cm, clip, width=1.3\textwidth]{plots/simsiam_core.pdf} \end{minipage}
    \caption{\textbf{Average correlation coefficient of the features during BYOL and SimSiam pretraining.} Evolution of the average correlation coefficient measured by averaging the off-diagonal terms of the correlation matrix of the representations with BYOL, BYOL with variance-covariance regularization (BYOL VarCov), SimSiam, and SimSiam with variance-covariance regularization (SimSiam VarCov).}
    \label{fig:byol_simsiam_cor}
\end{figure}

 
\end{document}