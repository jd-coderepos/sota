\documentclass{eptcs}


\usepackage[T1]{fontenc}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{paralist}
\usepackage{mathpartir} 
\usepackage{proof}

\newcommand{\Comment}[2]{\noindent ---#1: \marginpar{}\small #2}
\newcommand{\commentCK}[1]{\Comment{CK}{#1}}
\newcommand{\commentRB}[1]{\Comment{RB}{#1}}
\newcommand{\commentPEM}[1]{\Comment{PEM}{#1}}


\newcommand{\ih}{induction hypothesis\xspace}

\newcommand{\tom}{\textsf{Tom}\xspace}
\newcommand{\Java}{\textsf{Java}\xspace}
\newcommand{\java}{\Java}

\newcommand{\FF}{\ensuremath{\Sigma}\xspace}
\newcommand{\TT}{\ensuremath{\mathcal{T}}\xspace}
\newcommand{\XX}{\ensuremath{\mathcal{X}}\xspace}
\newcommand{\VV}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\FA}{\ensuremath{\FF_\A}\xspace}
\newcommand{\TFA}{\ensuremath{\T(\FA)}\xspace}
\newcommand{\TF}{\ensuremath{\TT(\FF)}\xspace}
\newcommand{\TFAX}{\ensuremath{\TT(\FA,\XX)}\xspace}
\newcommand{\FV}{\ensuremath{\FF_v}\xspace}
\def\ca#1{\ensuremath{\mathcal{#1}}}
\newcommand{\caP}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\caE}{\ensuremath{\mathcal{E}}\xspace}
\newcommand{\caQ}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\caD}{\ensuremath{\mathcal{D}}\xspace}
\newcommand{\caR}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\caO}{\ensuremath{\mathcal{O}}\xspace}
\newcommand{\caS}{\ensuremath{\mathcal{S}}\xspace}
\newcommand{\caH}{\ensuremath{\mathcal{H}}\xspace}
\newcommand{\caF}{\ensuremath{\mathcal{F}}\xspace}
\newcommand{\caX}{\ensuremath{\mathcal{X}}\xspace}
\newcommand{\TFV}{\ensuremath{\TT(\FV)}\xspace}
\newcommand{\TFX}{\ensuremath{\TT(\caF,\XX)}\xspace}
\newcommand{\TFVX}{\ensuremath{\TT(\caF \cup \caF_v,\XX)}\xspace}
\newcommand{\FS}{\ensuremath{\FF_\mathcal{S}}\xspace}
\newcommand{\XS}{\ensuremath{\XX_\mathcal{S}}\xspace}
\newcommand{\XTY}{\ensuremath{\XX_{\tau}}\xspace}
\newcommand{\caC}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\CC}{\ensuremath{C}\xspace}
\newcommand{\VC}{\ensuremath{\VV(\CC)}\xspace}
\newcommand{\Sorts}{\ensuremath{\mathcal{S}}\xspace}
\newcommand{\xx}{\ensuremath{x^*}\xspace}
\newcommand{\TYSV}{\ensuremath{\TT_{ype}(\FV \cup \{?\},\Sorts,\VV)}\xspace}
\newcommand{\TYDV}{\ensuremath{\TT_{ype}(\caD \cup \{wt\},\VV)}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\BB}{\ensuremath{\mathbb{B}}\xspace}
\newcommand{\arit}{\textrm{ar}\xspace}
\newcommand{\arity}[1]{\textrm{ar}(#1)}
\newcommand{\termi}[2]{\ensuremath{{#1}_{#2}}}
\newcommand{\match}{\mathrel{\mbox{}}}
\newcommand{\nmatch}{\mathrel{\mbox{}}}
\newcommand{\tommatch}{\texttt{\%match}\xspace}
\newcommand{\applysubs}[2]{#1(#2)}

\newcommand{\TVar}{{\small \textsc{T-Var}}}
\newcommand{\TSVar}{{\small \textsc{T-SVar}}}
\newcommand{\TFun}{{\small \textsc{T-Fun}}}
\newcommand{\TEmpty}{{\small \textsc{T-Empty}}}
\newcommand{\TElem}{{\small \textsc{T-Elem}}}
\newcommand{\TMerge}{{\small \textsc{T-Merge}}}
\newcommand{\Sub}{{\small \textsc{Sub}}}
\newcommand{\Gen}{{\small \textsc{Gen}}}
\newcommand{\TMatch}{{\small \textsc{T-Match}}}
\newcommand{\TConj}{{\small \textsc{T-Conj}}}
\newcommand{\TDisj}{{\small \textsc{T-Disj}}}
\newcommand{\TRule}{{\small \textsc{T-Rule}}}

\newcommand{\CTVar}{{\small \textsc{CT-Var}}}
\newcommand{\CTSVar}{{\small \textsc{CT-SVar}}}
\newcommand{\CTFun}{{\small \textsc{CT-Fun}}}
\newcommand{\CTEmpty}{{\small \textsc{CT-Empty}}}
\newcommand{\CTElem}{{\small \textsc{CT-Elem}}}
\newcommand{\CTStar}{{\small \textsc{CT-Star}}}
\newcommand{\CTMerge}{{\small \textsc{CT-Merge}}}
\newcommand{\CTMatch}{{\small \textsc{CT-Match}}}
\newcommand{\CTConj}{{\small \textsc{CT-Conj}}}
\newcommand{\CTDisj}{{\small \textsc{CT-Disj}}}
\newcommand{\CTRule}{{\small \textsc{CT-Rule}}}


\newcommand{\sub}{\mathrel{\mbox{{\footnotesize }}}}
\newcommand{\transsub}{\mathrel{\mbox{}}}
\newcommand{\wt}[0]{{\ensuremath{wt}}}
\newcommand{\ctvdash}{\ensuremath{\vdash_{ct}}}

\newcommand{\del}[1]{
        \ensuremath{
        \mathrel{\mbox{
        \footnotesize }
        #1\mbox{\footnotesize ~}}}}
\newcommand{\sortof}[2]{\texttt{sortOf}\ensuremath{(#1,#2)}}
\newcommand{\sigof}[2]{\texttt{sigOf}\ensuremath{(#1,#2)}}
\newcommand{\sig}[2]{\ensuremath{{#1}\rightarrow{#2}}}
\newcommand{\vsig}[2]{\ensuremath{{#1}^*\rightarrow{#2}}}

\newcommand{\ie}{\textit{i.e.}}
\newcommand{\wrt}{\textit{wrt.}}
\newcommand{\etc}{\textit{etc.}}

\def\vs{\vspace{-1.5mm}}

 


\newtheorem{thm}{Theorem}[section]
\newtheorem{defn}[thm]{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{exmp}[thm]{Example} 
\newtheorem{conj}[thm]{Conjecture}

\title{A Type System for \tom}
\author{Claude Kirchner
\institute{INRIA \\
Centre de Recherche \\INRIA Bordeaux - Sud-Ouest \\
  351, cours de la Lib\'eration, \\
  33405 Talence Cedex France}
\email{Claude.Kirchner@inria.fr}
\and
Pierre-Etienne Moreau
\quad\quad 
Cl\'audia Tavares\thanks{This work was partially supported by The Capes
Foundation, Ministry of Education of Brazil. Cx. postal 365, Bras\'ilia DF
70359-970, Brazil.}
\institute{INRIA \& LORIA\\
615 rue du Jardin Botanique, CS 20101\\
54603 Villers-l\`es-Nancy Cedex France}
\email{Pierre-Etienne.Moreau@loria.fr
\quad\quad
Claudia.Tavares@loria.fr}
}

\def\titlerunning{A Type System for \tom}
\def\authorrunning{Claude Kirchner,  Pierre-Etienne Moreau,  Cl\'audia Tavares}
\begin{document}
\maketitle

\begin{abstract}
  Extending a given language with new dedicated features is a general and quite used
  approach to make the programming language more adapted to problems. Being closer to the
  application, this leads to less programming flaws and easier maintenance.  But of course
  one would still like to perform program analysis on these kinds of extended languages,
  in particular type checking and inference. In this case
  one has to make the typing of the extended features compatible with the ones in the starting language. \\
The \tom programming language is a typical example of such a situation as it consists of
  an extension of \java that adds pattern matching, more particularly associative pattern
  matching, and reduction strategies. \\
This paper presents a type system with subtyping for
  \tom, that is compatible with \java's type
  system, and that performs both type checking and type inference.
  We propose an algorithm that checks if all patterns of a \tom program are well-typed. In
  addition, we propose an algorithm based on equality and subtyping constraints that
  infers types of variables occurring in a pattern. Both algorithms are exemplified and
  the proposed type system is showed to be sound and complete.

\end{abstract}

\sloppy



\section{Introduction of the problem: static typing in \tom}
\label{sec:tom}

We consider here the {\tom} language, which is an extension of {\java} that provides rule
based constructs. In particular, any {\java} program is a {\tom} program. We
call this kind of extension {\em formal
islands}~\cite{balland:06,balland:09} where the {\em ocean} consists of {\java} code
and the {\em island} of algebraic patterns. For simplicity, we consider here only two
new {\tom} constructs: a \verb|\verb|`| (backquote) construct.

The semantics of \verb|programming languages, but in an imperative context. A \texttt{\%match} is parameterized
by a list of subjects (\ie\ expressions evaluated to ground terms) and contains a list of
rules. The left-hand side of the rules are patterns built upon constructors and fresh
variables, without any linearity restriction. The right-hand side is {\em not} a
term, but a {\java} statement that is executed when the pattern matches the
subject. However, thanks to the backquote construct (\texttt{`}) a term can be easily built and returned.
In a similar way to the standard \texttt{switch/case} construct, patterns are evaluated from top to
bottom. In contrast to the functional {\em match}, several actions ({\ie} right-hand
sides) may be fired for a given subject as long as no \texttt{return} or \texttt{break} instruction is
executed. To implement a simple reduction step for each rule, it suffices to encode the
left-hand side with a pattern and consider the {\java} statement that returns the right-hand
side.

For example, given the sort \texttt{Nat} and the function symbols \texttt{suc} and
\texttt{zero}, addition and comparison of Peano integers may be encoded as follows: \vs

In this combination of an ocean language (in our case \java) and island features (in our
case abstract data types and matching), it is still an open question to perform type
checking and type inference.

Since we want to allow for type inclusion at the pattern level, the first purpose of this
paper is to present an extension of the signature definition mechanism allowing for
subtypes. In this context we define \textit{\java-like} types and signatures.
Therefore the set of types is the union of \java types and
abstract data types (i.e. \tom types) where multiple inheritance and
overloading are forbidden. For example, given the sorts \texttt{Int},
\texttt{Int}, \texttt{Int} and \texttt{Zero}, the type system accepts the
declaration 

but refuses the declaration 
.
Moreover, a function symbol \texttt{suc} cannot be overloaded on
both sorts \texttt{Int} and \texttt{Int}. In order to handle those
issues, we propose an algorithm based on unification of equality
constraints \cite{milner:78} and simplification of subtype constraints
\cite{dominic:01,aiken:92,pottier:01}. It infers the types of the variables that occur
in a pattern (\texttt{x} and \texttt{y} in the previous example). Moreover, we
also propose an algorithm
that checks that the patterns occurring in a {\tom} program are correctly typed.

Of course typing systems for algebraic terms and for rewriting has a long history.  It
includes the seminal works done on OBJ, order-sorted algebras~\cite{obj3-88,OBJ2-POPL}
and Maude~\cite{Maude2007}; the works done on feature
algebras~\cite{AitKaciPodelskiSmolkaTCS94} or on membership
constraints~\cite{HintermeierKK-jsc98,DBLP:journals/jsc/Comon98}; and the works on typing
rewriting in higher-order settings like~\cite{BakelF97} or ~\cite{barthe03a}.  Largely
inspired from these works, our contribution here focusses on the appropriate type system
for pattern-matching, possibly modulo associativity, in a \java environment.



\section{Type checking}
\label{sec:checking}

Given a signature~, the (simplified) abstract syntax of a {\tom} program is as follows:

The left-hand side of a rule is a conjunction of matching conditions  consisting of a pair of terms and where  denotes a sort. We introduce the set
 of free symbols. Terms are many-sorted terms composed of variables  and
function symbols . The set of terms is written . In general, an {\em
  action} is a {\java} statement, but for our purpose it is enough to consider an
abstraction consisting of terms 
 whose instantiations are
described by the conditions, and used in the {\java} statement.

\begin{exmp}
The last rule of the \verb+greaterThan+ function given above can be represented by the following  expression:

\end{exmp}

In a first step, we define  as a set of sorts and we consider that a {\em context}~ is composed of a set of pairs
(variable,sort), and (function symbol,rank):
{\small

}
and context access is defined by the function \sortof{\Gamma}{e}  which returns the sort of term  in the context :
\begin{center}
{\small
\begin{tabular}{rcl}
        \sortof{\Gamma}{x} 
        , if  
        & &
        \sortof{\Gamma}{f(e_1,\ldots,e_n)}      
        , if     \\
\end{tabular}}
\end{center}
where  and .

We denote by 
the fact that 
 belongs to .
Similarly,
 means that 
belongs to .
In Fig.~\ref{fig:simplechecking} we give a classical type checking system defined by a set of inference rules.
Starting from a context~ and a rule expression , we say that 
is well-typed if  can be derived by applying the inference rules. 
is a special sort that corresponds to the well-typedness of a  or a
condition .

\begin{figure}[h!]

\caption{Simple type checking system.}
\label{fig:simplechecking}
\end{figure}

\subsection{Subtypes and associative-matching}
\label{subsec:subtypes}

In order to introduce subtypes in \tom, we refine  as the set of sorts, equipped
with a partial order~, called {\em subtyping}. It is a binary relation on 
that satisfies reflexivity, transitivity and antisymmetry. Moreover, since we allow for
some symbols to be associative, we introduce the set  of variadic symbols to
denote them.  Now, the set of terms is written  and terms are many-sorted variadic
terms composed of variables  and function symbols . In the
following, we often write  a variadic operator and call it a {\em list}.

We extend matching over lists to be associative. Therefore a pattern matches a subject
considering equality relation modulo flattening. Lists can be denoted by function symbols
 or by variables  annotated by . Such variables, which we
write , are called {\em star variables}. So we consider in the following many-sorted
variadic terms composed of variables , star variables  (where )
and function symbols . Moreover, we define that function symbols  with variable domain (since they have a variable arity) of sort  and
codomain  are written  while star variables  are also sorted
and written .

Since terms built from syntactic and variadic operators can have the same codomain, we
cannot distinguish one from the other only by theirs sorts. However, this is necessary to
know which typing rule applies. Moreover, an insertion of a term can be treated by two
ways: given terms  where , we have:
\begin{inparaenum}[1)]
\item an insertion of a list  into a list  corresponds to a
concatenation of these both lists resulting in ;
\item an insertion of a list  into a list  results in .
\end{inparaenum}
For that reason, it is important to distinguish the list from the inserted term by its
function symbol in order to define which typing rule concerned for list must be
applied. For this purpose, we introduce a notion of sorts decorated with function symbols,
called {\em types}, to classify terms. The special symbol  is used as decoration when
it is not useful to know what the function symbol is, i.e. when the expected type is known
but not the expected function symbol. This leads to a new set of decorated sorts 
which is equipped with a partial order . It is a binary relation on  where
 is equivalent to .

\textit{As pointed out in the introduction, we assume in all that paper that the
  signatures considered do not have multiple inheritance and that we do not allow function
  symbol overloading.} 

Given these notions, we refine the notion of context  as a set of subtyping
declarations (type,type) and pairs (variable,type), and (function symbol,rank). This is
expressed by the following grammar:

where  corresponds to the reflexive transitive closure of~ and context access is refined by the function \sortof{\Gamma}{e}  which returns the type of term  in the context :

where , , ,  and
.
 
The context has at most one declaration of type or signature per term since overloading is
forbidden. This means that for  and  (where
 and ) if  and  then . We denote
by 
the fact that 
 belongs to .

\subsection{Type checking algorithm}
\label{subsec:checking_algo}

In Fig.~\ref{fig:checking} we give a type checking system to many-sorted variadic terms applying
associative matching. The rules are standard except for the use of
decorated types. The most interesting rules are those 
that apply to lists. They are three: [\TEmpty] checks
if a empty list has the same type declared in ; [\TElem] is similar to
[\TFun] but is applied to lists; and [\TMerge] is applied to a concatenation of
two lists of type  in , resulting in a new list with same type
.
\begin{figure}[h!]
\begin{center}\small
\begin{tabular}{|lll|}
        \hline
&&                                                                                        \\
        \infer[\TVar] 
                {\Gamma(x : s^g) \vdash x : s^g}
                {}
&&
        \infer[\TSVar] 
                {\Gamma(\xx : s^{\ell}) \vdash \xx : s^{\ell}}
                {}                                                                      \\
        where 
&&                                      \\
&&                                                                                        \\
       \infer[\TFun]
                {\Gamma(f : \sig{s_1^?,\ldots,s_n^?}{s^f}) \vdash f(e_1, \ldots, e_n) : s^f}
                {\Gamma \vdash e_1 : s_1^?
                &\quad  
                \ldots
                &\quad
                \Gamma \vdash e_n : s_n^?}  
&&                                      
       \infer[\TEmpty]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) \vdash \ell() : s^{\ell}}
                {} \\
&&                                                                                        \\
       \infer[\TElem]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) \vdash \ell(e_1, \dots, e_n,
e) : s^{\ell}}
                {\Gamma \vdash \ell(e_1, \ldots, e_n) : s^{\ell}
                &\quad  
                \Gamma \vdash e : s_1^?}  
&&
       \infer[\TMerge]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) \vdash \ell(e_1, \dots, e_n, e) : s^{\ell}}
                {\Gamma \vdash \ell(e_1, \ldots, e_n) : s^{\ell}
                &\quad
                \Gamma \vdash e : s^{\ell}} \\
if \sortof{\Gamma}{e}  and 
&&
if \sortof{\Gamma}{e}           \\
&&                                                                                        \\
        \infer[\Sub]
                {\Gamma(s_1^{g_1} \sub_s s^g) \vdash e : s^g}
                {\Gamma \vdash e : s_1^{g_1}}
&&
        \infer[\Gen]
                {\Gamma \vdash e : s^?}
                {\Gamma \vdash e : s^h}                                                 \\
        where 
&&
        if \sortof{\Gamma}{e} , where                        \\
&&                                                                                        \\
       \infer[\TMatch]
                {\Gamma \vdash (e_1 ~\match_{[s^?]}~ e_2) : \wt}
                {\Gamma \vdash e_1 : s^?
                &\quad  
                \Gamma \vdash e_2 : s^?}
&&                                                                                       
       \infer[\TConj]
                {\Gamma \vdash (cond_1 \wedge \ldots \wedge cond_n) : \wt}
                {\Gamma \vdash (cond_1) : \wt
                &\quad
                \ldots
                &\quad
                \Gamma \vdash (cond_n) : \wt}                                           \\
&&                                                                                        \\
\multicolumn{3}{|c|}{
        \infer[\TRule]
                {\Gamma \vdash (cond \longrightarrow (e_1, \ldots, e_n)) : \wt}
                {\Gamma \vdash (cond) : \wt
                &\quad
                \Gamma \vdash e_1 : s_1^{g_1}
                &\quad
                \ldots
                &\quad
                \Gamma \vdash e_n : s_n^{g_n}}}                                  \\
\multicolumn{3}{|c|}{
                if , where  for }      \\
&&                                                                                        \\
\hline
\end{tabular}
\end{center}
\caption{Type checking rules.}
\label{fig:checking}
\end{figure}

The type checking algorithm reads derivations bottom-up. Since the rule [\Sub] can be applied
to any kind of term, we consider a strategy where it is applied iff no other
typing rule can be applied. In practice, [\Sub] will be
combined with [\TVar], [\TFun] and [\TElem] and
the type  which appears in the premise will be defined
according to the result of function \sortof{\Gamma}{e}. The algorithm stops if
it reaches the [\TVar] or [\TSVar] cases, ensuring that the original expression is well-typed, or if
none of the type checking rules can be applied, raising an error.

\begin{exmp}
\label{exmp:checking}
Let . Then the expression  is well-typed
and its deduction tree is given in Fig.~\ref{fig:example-tc}

\begin{figure}
\begin{center}
{\scriptsize
\begin{mathpar}
        \inferrule*[Right={\scriptsize T-Rule},rightskip=51mm]
                {\inferrule*[leftskip=13mm,Right={\scriptsize T-Match}]
                        {\inferrule*[vdots=25mm,Right={\scriptsize
        T-Gen},leftskip=22mm,rightskip=30mm]
                                {\inferrule*[Right={\scriptsize
        T-Merge}]
                                        {\inferrule*[leftskip=19mm,Right={\scriptsize T-Elem}]
                                                {\inferrule*[leftskip=13mm,Right={\scriptsize T-Merge}]
                                                        {\inferrule*[Right={\scriptsize T-Empty}]
                                                                {~}
                                                                {\Gamma \vdash
\ell() : \ZZ^{\ell}}
                                                        \\ \quad \\
                                                        \inferrule*[Right={\scriptsize T-SVar}]
                                                                {~}
                                                                {\Gamma
                        \vdash x^* : \ZZ^{\ell}}
                                                        }
                                                        {\Gamma \vdash \ell(x^*) :
\ZZ^{\ell}}
                                                \\ \quad \\
                                                \inferrule*[Right={\scriptsize T-Var}]
                                                        {~}
                                                        {\Gamma \vdash y : \ZZ^?}
                                                }
                                                {\Gamma \vdash \ell(x^*,y) :
\ZZ^{\ell}}
                                        \\ \quad \\
                                        \inferrule*[Right={\scriptsize T-SVar}]
                                                {~}
                                                {\Gamma \vdash z^* : \ZZ^{\ell}}
                                        }
                                        {\Gamma \vdash \ell(x^*,y,z^*) : \ZZ^{\ell}}
                                }
                                {\Gamma \vdash \ell(x^*,y,z^*) : \ZZ^?}
                        \\
                        \inferrule*[Right={\scriptsize T-Gen}]
                                {\inferrule*[Right={\scriptsize T-Elem}]
                                        {\inferrule*[Right={\scriptsize T-Empty}]
                                                {~}
                                                {\Gamma \vdash \ell() : \ZZ^{\ell}}
                                        \\ \quad \\
                                        \inferrule*[Right={\scriptsize Sub}]
                                                {\inferrule*[Right={\scriptsize Gen}]
                                                        {\inferrule*[Right={\scriptsize T-Fun}]
                                                                {~}
                                                                {\Gamma \vdash one() :
                        \NN^{one}}
                                                        }
                                                        {\Gamma \vdash one() :
                        \NN^?}
                                                }
                                                {\Gamma \vdash one() :
                        \ZZ^?}
                                        }
                                        {\Gamma \vdash \ell(one()) : \ZZ^{\ell}}
                                }
                                {\Gamma \vdash \ell(one()) : \ZZ^?}
                        }
                        {\Gamma \vdash (\ell(x^*,y,z^*) \match_{[\ZZ^?]} \ell(one())) : \wt}
                \\ \quad \\
                \inferrule*[Right={\scriptsize T-Var}]
                        {~}
                        {\Gamma \vdash y : \ZZ^?}
                }
                {\Gamma \vdash (\ell(x^*,y,z^*) \match_{[\ZZ^?]} \ell(one())
\longrightarrow (y)) : \wt}
\end{mathpar}}
\end{center}
\caption{Type checking example.}
\label{fig:example-tc}
\end{figure}
\end{exmp}




\section{Type inference}
\label{sec:inference}

The type system presented in Section~\ref{sec:checking} needs rules to
control its use in order to find the expected deduction tree of an expression. Without these rules it is possible to find more than one
deduction tree for the same expression. For instance, in Example
\ref{exmp:checking}, the rule [\Sub] can be applied to the leaves resulting of application of
rule [\TVar]. The resulting tree will still be a valid deduction tree since the
variables in the leaves will have type  instead of type 
declared in the context and . For that reason, we are interested in defining another type system
able to infer the most general types of terms. We add type variables in the set
of types (defined up to here as a set of decorated sorts) to describe a
possibly infinite set of decorated sorts. The set of types
 is given by a set of decorated sorts , a set of type variables
 and a special sort :

where , ,  and . 

In order to build the subtyping rule into the rules, we use a
{\em constraint set} \CC to store all equality and subtyping constraints. These
constraints limit types that terms can have. The language  is built from
the set of types  and the operators ``'' (equality) and
``'' (extension to  of the partial order defined in Subsection~\ref{subsec:subtypes}):

where , .

A substitution  is said to {\em satisfy} an equation 
if . Moreover,  is said
to {\em satisfy} a subtype relation  if .

Thus,  is a {\em solution} for  if
it satisfies all constraints in . This is written . The set  denotes the set of type
variables in . 

Constraints are calculated according to the application of rules of
 type inference system (see Fig.~\ref{fig:inference}) where we
can read the judgment  as ``the term  has type 
under assumptions  whenever the constraints \CC are
satisfied''. More formally, this judgment states that .

\subsection{Type inference algorithm}
\label{subsec:inference_algo}

In Fig. \ref{fig:inference} we give a type inference system with constraints.
In order to infer the type of a given expression~, the context  is initialized to: 
\begin{inparaenum}[1)]
\item subtype declarations of the form  where  and ;
\item a pair of the form  for each
syntactic operator  occurring in  where  for ;
\item a pair of the form  for each variadic
operator  occurring in  where ;
\item a pair of the form  for each variable  occurring in  where  is a fresh type variable;
\item a pair of the form  for each star variable  occurring
in  where  is a fresh type variable.
\end{inparaenum}
Moreover, each type variable introduced in a sub-derivation is a fresh type variable and
the fresh type variables in different sub-derivations are distinct. As in Section~\ref{subsec:checking_algo}, we explain the rules concerning lists: [\CTEmpty] infers for an empty list  a type variable
 with the constraint ,  given by the rank of
; [\CTElem] treats applications of lists to elements which are neither lists
with the same function symbol nor star variables; [\CTMerge] is applied to
concatenate two lists of same type ; and [\CTStar] is applied to
concatenate a list and a star variable of the same type .

\begin{figure}[h!]
\begin{center}

\begin{tabular}{|c|}
        \hline
                                                                                        \\
                                                                                        \\
        \infer[\CTVar] 
                {\Gamma(x : \tau) \ctvdash  x : \alpha 
                        \bullet \{\alpha =_s \tau\}}
                {~}
                \quad\quad\quad\quad
        \infer[\CTSVar] 
                {\Gamma(\xx : \alpha_1) \ctvdash  \xx : \alpha 
                        \bullet \{\alpha_1 =_s \alpha\}}
                {~}             \\
                                \\
        \infer[\CTFun]
                {\Gamma(f : \sig{s_1^?,\ldots,s_n^?}{s^f}) 
                        \ctvdash f(e_1,\ldots,e_n) : \alpha 
                        \bullet  \{\alpha =_s s^f\} 
                        \bigcup \limits_{i = 1}^n \CC_i 
                        \cup \{\alpha_i \sub_s s_i^?\}}   
                {\Gamma \ctvdash e_1 : \alpha_1 \bullet \CC_1 
                &
                \ldots
                &
                \Gamma \ctvdash e_n : \alpha_n \bullet \CC_n}           \\
                                                                        \\
                                                                        \\
        \infer[\CTEmpty]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) \ctvdash \ell(): \alpha 
                        \bullet  \{\alpha =_s s^{\ell}\}}
                {~}                                                      \\
                                                                         \\
        \infer[\CTElem]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) 
                        \ctvdash \ell(e_1,\ldots,e_n,e) : \alpha 
                        \bullet  \{\alpha =_s s^{\ell}, \alpha_1 \sub_s s_1^?\}
                        \cup \CC_1 \cup \CC_2} 
                {\Gamma \ctvdash \ell(e_1,\ldots,e_n) : \alpha \bullet \CC_1
                &\quad
                \Gamma \ctvdash e : \alpha_1 \bullet \CC_2}             \\
         if  and          \\
                                                                        \\
        \infer[\CTMerge]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) 
                        \ctvdash \ell(e_1,\ldots,e_n, e) : \alpha 
                        \bullet  \{\alpha =_s s^{\ell}\} \cup \CC_1 \cup \CC_2}
                {\Gamma \ctvdash \ell(e_1,\ldots,e_n) : \alpha \bullet \CC_1
                &\quad
                \Gamma \ctvdash e : \alpha \bullet \CC_2}               \\
         if                              \\
                                                                        \\
        \infer[\CTStar]
                {\Gamma(\ell : \vsig{(s_1^?)}{s^{\ell}}) 
                        \ctvdash \ell(e_1,\ldots,e_n, \xx) : \alpha 
                        \bullet  \{\alpha =_s s^{\ell}\} \cup \CC_1 \cup \CC_2}
                {\Gamma \ctvdash \ell(e_1,\ldots,e_n) : \alpha \bullet \CC_1
                &\quad  
                \Gamma \ctvdash \xx : \alpha \bullet \CC_2}             \\
                                                                        \\
        \infer[\CTMatch]
                {\Gamma \ctvdash (e_1 ~\match_{[\tau]}~ e_2) : \wt 
                        \bullet  \{\alpha_1 \sub_s \tau, \alpha_2 =_s \tau\} 
                        \cup \CC_1 \cup \CC_2}
                {\Gamma \ctvdash e_1 : \alpha_1 \bullet \CC_1
                &\quad
                \Gamma \ctvdash e_2 : \alpha_2 \bullet \CC_2}           \\
                                                                        \\
        \infer[\CTConj]
                {\Gamma \ctvdash (cond_1 \wedge \ldots \wedge cond_n) : \wt 
                        \bullet  \bigcup \limits_{i = 1}^n \CC_i}
                {\Gamma \ctvdash (cond_1) : \wt \bullet \CC_1
                &\quad
                \ldots
                &\quad
                \Gamma \ctvdash (cond_n) : \wt \bullet \CC_n}           \\
                                                                        \\
        \infer[\CTRule]
                {\Gamma \ctvdash (cond \longrightarrow (e_1,\ldots,e_n)) : \wt \bullet  \CC_{cond} \bigcup \limits_{i=1}^n C_i }
                {\Gamma \ctvdash (cond) : \wt \bullet \CC_{cond}
                &\quad
                \Gamma \ctvdash e_1 : \tau_1 \bullet \CC_{1}
                &
                \ldots
                &
                \Gamma \ctvdash e_n : \tau_n \bullet \CC_{n}}      \\
                if , for 
                where    \\              
                                                                        \\
        \hline                                  
\end{tabular}
\end{center}
\caption{Type inference rules.}
\label{fig:inference}
\end{figure}

\begin{exmp}
\label{exmp:inference}
Let . Then the expression
 is well-typed
and the deduction tree is given in Fig.~\ref{fig:example-ti}.

\begin{figure}
\begin{center}
{\scriptsize
\begin{mathpar}
        \inferrule*[width=5cm,Right={\scriptsize CT-Star},rightskip=5mm]
                {\inferrule*[width=10cm,vdots=10mm,leftskip=35mm,Right={\scriptsize
CT-Elem},rightskip=70mm]
                        {\inferrule*[width=10cm,leftskip=5mm,Right={\scriptsize CT-Star}]
                                {\inferrule*[Right={\scriptsize CT-Empty}]
                                        {~}
                                        {\Gamma \ctvdash \ell() : \alpha_5 
                                                \bullet \CC_3 = \{\alpha_5 =_s \ZZ^{\ell}\}}
                                \\ \quad \quad \\
                                \inferrule*[Right={\scriptsize CT-SVar}]
                                        {~}
                                        {\Gamma \ctvdash x^* : \alpha_5 
                                                \bullet \CC_4 = \{\alpha_5 =_s \alpha_1\}}}
                                {\Gamma \ctvdash \ell(x^*) : \alpha_5 
                                        \bullet C_2 = \{\alpha_5 =_s \ZZ^{\ell}\}
                                        \cup \CC_3 \cup \CC_4}
                        ~~~~~~~~~~~~~~~~~~~~
                        \inferrule*[Right={\scriptsize CT-Var}]
                                {~}
                                {\Gamma \ctvdash y : \alpha_8 
                                        \bullet \CC_5 = \{\alpha_8 =_s \alpha_2\}}}
                        {\Gamma \ctvdash \ell(x^*,y) : \alpha_5 
                                \bullet C_1 = \{\alpha_5 =_s \ZZ^{\ell}, 
                                \alpha_8 \sub_s \ZZ^?\} \cup C_2 \cup \CC_5}
                ~~~~~~~~~~~~~~~~~
                \inferrule*[Right={\scriptsize CT-SVar}]
                        {~}
                        {\Gamma \ctvdash z^* : \alpha_5 
                                \bullet \CC_6 = \{\alpha_5 =_s \alpha_3\}}}
                {\Gamma \ctvdash \ell(x^*,y,z^*) : \alpha_5 
                        \bullet C_p = \{\alpha_5 =_s \ZZ^{\ell}\} \cup C_1 \cup \CC_6}
\end{mathpar}
\textrm{\textbf{(1)}} \\

\begin{mathpar}
        \inferrule*[width=10cm,Right={\scriptsize CT-Elem}]
                {\inferrule*[Right={\scriptsize CT-Empty}]
                        {~}
                        {\Gamma \ctvdash \ell() : \alpha_6 
                                \bullet \CC_7 =\{\alpha_6 =_s \ZZ^{\ell}\}}
                \\ \quad \quad \\
                \inferrule*[Right={\scriptsize CT-Fun}]
                        {~}
                        {\Gamma \ctvdash one() : \alpha_7 
                                \bullet \CC_8\{\alpha_7 =_s \NN^{one}\}}}
                {\Gamma \ctvdash \ell(one()) : \alpha_6 
                        \bullet C_s = \{\alpha_6 =_s \ZZ^{\ell}, \alpha_7 \sub_s
\ZZ^?\} \cup \CC_7 \cup \CC_8}
\end{mathpar}
\textrm{\textbf{(2)}} \\

\begin{mathpar}
        \inferrule*[width=19cm,Right={\scriptsize CT-Rule}]
                {\inferrule*[Right={\scriptsize CT-Match}]
                        {\textbf{(1)~~~~~~~~} 
                        \\ 
                        ~~~~~~~~~~\textbf{(2)}}
                        {\Gamma \ctvdash (\ell(x^*,y,z^*) 
                                \match_{[\alpha_4]} \ell(one())) : \wt 
                                \bullet \CC_{cond} =\{\alpha_5 \sub_s \alpha_4,
                                                \alpha_6 =_s \alpha_4\}}
		\\ \quad \quad \quad \quad
		\inferrule*[Right={\scriptsize CT-Var}]
			{~}
			{\Gamma \ctvdash y : \alpha_9 
                                        \bullet \CC_{10} = \{\alpha_9 =_s \alpha_2\}}
		}
                {\Gamma \ctvdash (\ell(x^*,y,z^*) 
                        \match_{[\alpha_4]} \ell(one()) \longrightarrow (y)) : \wt 
                        \bullet \CC_r = \{\alpha_2 =_s \alpha_2\} \cup \CC_{cond}
\cup \CC_{10}}
\end{mathpar}
}
\end{center}
\caption{Type inference example.}
\label{fig:example-ti}
\end{figure}
\end{exmp}



\subsection{Constraint resolution}
\label{subsec: resol}

In Fig.~\ref{fig:fail_rules} we propose an algorithm to decide whether a given
constraint set  has a solution, where . 
We denote by  the fact that there exists  such that 
, 
, \ldots,
 and .
If the algorithm stops without failure then  is said to
be in {\em solved form}. 
\begin{figure}[h!]
\begin{center}

\begin{tabular}{|clcl|}
        \hline
                &       &       &       \\
        (1)     & 
                &      
                &  if   \\
        (2)     & 
                &      
                &  if   \\
        (3)     & 
                &      
                &  if    \\
        (4)     &   
                &      
                &  if  \\
        (5)     &   
                &      
                &  if  \\
                &       &       &       \\
        \hline
\end{tabular}
\end{center}
\caption{Rules for detection of errors in a constraint set .}
\label{fig:fail_rules}
\end{figure}

While solving a constraint set  we wish to make sure, after each
application of a constraint resolution rule, that the constraint set at hand is
satisfiable, so as to detect
errors as soon as possible. Therefore we must combine the rules for error detection and constraint
resolution in order to keep  in solved form. The rules for the constraint resolution algorithm are provided in Fig.
\ref{fig:constraint_rules}, where . The
rules (1)-(14) are recursively applied over . More precisely, rules (1)-(3) work as a garbage
collector removing constraints that are no more useful. Rules (4) and (5)
generate . Rules (6) and (7) generate more simplified constraints. Rules (8)-(12)
generate  and simplified constraints by antisymmetric and transitive
subtype closure. Rules (13) and (14) are applied when none of previous rules can be applied
generating a new  from a constraint over a type variable that has no
other constraints. The algorithm stops if: a rule returns , then the algorithm returns 
the solution ; if  reaches a non-solved form, then the algorithm for detection of
errors returns ; or if  reaches a normal form different from the empty set,
then the algorithm returns an error. We say that the algorithm is \textit{failing} if it
returns either \textit{fails} or an error.

\begin{figure}[h]
\begin{center}
\begin{tabular}{|clcl|}
        \hline
                &       &       &                                       \\
        (1)     &                       
                &      
                &                                                 \\
        (2)     &    
                &      
                &                                                 \\
        (3)     &  
                &      
                &  if      \\
                &       &       &                                       \\
        (4)     & 
                &      
                &                            \\
        (5)     &      
                &      
                &                            \\
                &       &       &                                       \\
        (6)    & 
                &      
                & 
                        if \\
        (7a)   & 
                &      
                & 
                        if \\ 
        (7b)   & 
                &      
                & 
                        if \\ 
                &       &       &                                       \\   
        (8)     &    
                &      
                &                      \\
        (9)     & 
                &      
                &              \\
        (10)     & 
                &      
                &              \\
        (11)     & 
                &      
                &              \\
        (12)    & 
                &      
                & 
                        if       \\
                &       &       &                                       \\
   
        (13)    &   
                &      
                &  if                    \\
        (14)    &  
                &      
                &  if                    \\
                &       &       &                                       \\
        \hline
\end{tabular}
\end{center}
\caption{Constraint resolution rules in context .}
\label{fig:constraint_rules}
\end{figure}
\begin{exmp}
\label{exmp:resolution}

Let  and
 from the Example
\ref{exmp:inference}. Let  and . The constraint resolution algorithm
starts by:  
\begin{enumerate}
\item Application of sequence of rules (4), (1) and (5) generating 

and


\item Application of rules (1), (2) and (3) generating  and ;

\item Application of rule (13) generating  and , the algorithm then stops
and returns  providing a substitution for all type variables in
the deduction tree of .
\end{enumerate}
\end{exmp}



\section{Properties}
\label{sec:properties}

Since our type checking system and our type inference system address the same
issue, we must
check two properties. First, we show that every typing judgment that can be
derived from the inference rules also follows from the checking rules (Theorem
\ref{thm:soundness}), in particular the soundness. Then we show that a solution
given by the checking rules
can be extended to a solution proposed by the inference rules (Theorem
\ref{thm:completeness}).

\begin{defn}[Solution]
Let  be a context and  a term. 
\begin{itemize}
\item A {\em solution} for  is a pair  such that , where .
\item Assuming a well-formed sequent , a
{\em solution} for
   is a pair  such that  satisfies  and
  , where  and .
\end{itemize}
\end{defn}

\begin{thm}[Soundness of constraint typing]
\label{thm:soundness}
Suppose that  is a valid sequent. If  is a
solution for , then it is also a solution for
 (i.e.  is well-typed in ).
\end{thm}

\begin{proof}
By induction on the given constraint typing derivation for . We just detail the most noteworthy cases of this
proof.

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :        & 
                                &                        \\
                                
                                &                   
                                &                                   \\
                                
                                & &        \\ 
\end{tabular}
\end{flushleft}

We are given that  is a solution for , that is,  satisfies  and
. Since  satisfies  and ,
 and  are solutions for
 and ,
respectively.
By the \ih, we have  and
. Since , by  we obtain . Since , by
 we obtain . By  we
obtain  , as required.

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :       & 
                                &                        \\
                                
                                &                   
                                &                                   \\
                                
                                & &  \\ 
\end{tabular}
\end{flushleft}

We are given that  is a solution for , that is,  satisfies  and
. Since  satisfies  and ,
 and  are solutions for
 and .
By the \ih, we have  and
. Since , by
 we obtain . By  we
obtain  , as required.

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :       & 
                                &                   \\
                                
                                &                         
                                &                                         \\
                                
                                & &   \\ 
\end{tabular}
\end{flushleft}

We are given that  is a solution for , that
is,  satisfies  and
. Since  satisfies  and ,
 and  are solutions for
 and , respectively.
By the \ih, we have  and
. Since , by  we obtain
. Since , by
 we obtain , as required.
\end{proof}

\begin{defn}[Normal form of typing derivation]
A typing derivation is in {\em normal form} if it does not have successive
applications of rule \textsc{[\Sub]}.
\end{defn}

\begin{thm}[Completeness of constraint typing]
\label{thm:completeness}
Suppose that . Write  for
the set of all type variables mentioned in the last rule used to derive 
and write  for the substitution that is undefined for all the
variables in  and otherwise behaves like . If  is a
solution for  and , then
there is some solution  for
 such that .
\end{thm}
\begin{proof}
By induction on the given constraint typing derivation in normal form, but we
must take care with fresh names of variables. We just detail the most noteworthy cases of this
proof.

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :        & 
                                &                        \\
                                
                                &                   
                                &                                   \\
                                
                                & 
                                &        \\
                                
                                &  & \\
\end{tabular}
\end{flushleft}

From the assumption that  is a solution for  and , we have
. This can be derived from: 
\begin{inparaenum}[1)] 
\item ,
\item  or
\item . 
\end{inparaenum}
In all those cases, we must exhibit a substitution  such that: (a)  agrees with ; (b) ; (c) 
satisfies  and ; and (d)  satisfies . We reason by cases as follows:  

\begin{enumerate}
\item By  we assume that  and we know that
 and . But since we cannot find a
type  such that ,  cannot be derived even from . Thus  is not a relevant case.

\item By  we assume that  and we know that
 and . By the \ih, there are
solutions  for 
and  for , and
. Define . Conditions (a), (b), (c) and (d) are obviously satisfied. Thus, we
see that  is a solution for .

\item By  we assume that  and we know that
. This must be derived from , similar to case (2). 
\end{enumerate}

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :       & 
                                &                        \\
                                
                                &                   
                                &                                   \\
                                
                                & 
                                &  \\
                                
                                &  & \\
\end{tabular}
\end{flushleft}

From the assumption that  is a solution for  and , we have
. This can be derived from:
\begin{inparaenum}[1)] 
\item ,
\item  or
\item . 
\end{inparaenum}
In all those cases, we must exhibit a substitution  such that: (a)  agrees with ; (b) ; (c) 
satisfies  and ; and (d)  satisfies . We reason by cases as follows:  

\begin{enumerate}
\item By  we assume that  and we know that
 and . By the \ih, there are
solutions  for 
and  for , and
. Define . Conditions (a), (b), (c) and (d) are obviously satisfied. Thus, we
see that  is a solution for .

\item By  we assume that  and we know that
 and . But, because of the
application condition of , we cannot find a type  for
 such that ,  cannot be derived from . Likewise, since we cannot find a type
 for  such that ,  cannot be derived even from . Thus  is not a relevant case.

\item By  we assume that  and we know that
. This must be derived from , similar to case (1). 
\end{enumerate}

\begin{flushleft}
\begin{tabular}{lll}
        \textit{Case} :       & 
                                &                   \\
                                
                                &                         
                                &                                         \\
                                
                                & 
                                &  if          \\
                                & &  if      \\ 
\end{tabular}
\end{flushleft}

From the assumption that  is a solution for  and , we have
. This must be
derived from , we know that  and
. By the \ih, there are solutions
 for  and
 for . We must exhibit a substitution  such that: (a)  agrees with ; (b) ; (c) 
satisfies  and ; and (d)  satisfies . Define , where . Moreover, define  if  and  otherwise. Conditions (a), (b), (c) and (d) are obviously satisfied. Thus, we
see that  is a solution for .
\end{proof}

The constraint resolution algorithm always terminates. More formally:
\begin{thm}[Termination of algorithm] ~
\label{thm:termination}
\begin{enumerate}
\item \label{thm_i1} the algorithm halts, either by failing or by returning a
substitution, for all ;
\item \label{thm_i2}if the algorithm returns , then  is a solution for
;
\end{enumerate} 
\end{thm}

We can already sketch a proof of Theorem \ref{thm:termination} following Pierce
\cite{pierce:02}.
\begin{proof}
For part \ref{thm_i1}, define the {\em degree} of a constraint set  to be
the pair , where  is the number of constraints in  and  is the number
of subtyping constraints in . The algorithm terminates immediately (with
success in the case of an empty constraint set or failure for an equation involving two
different decorated sorts) or makes recursive calls to itself with
a constraint set of lexicographically smaller degree.

For part \ref{thm_i2}, by induction on the number of recursive calls in the
computation of the algorithm.
\end{proof}



\section{Conclusion}
\label{sec:conclusion}

In this paper we have presented a type system for the pattern matching
constructs of \tom. The system is composed of type
checking and type inference algorithms with subtyping over sorts. Since \tom
also implements associative pattern matching over variadic operators, we were 
interested in defining both a way to distinguish these from syntactic
operators and checking and inferring their types.

We have obtained the following: our type inference system is sound and complete
w.r.t. checking, showed by Theorems \ref{thm:completeness} and \ref{thm:soundness}. This
is the first step towards an effective implementation, thus leading to a safer
\tom.
However, we still need to investigate type unicity that we believe to hold under our assumptions of non-overloading and non-multiple inheritance.

As we have considered a subset of the \tom language, future work will 
focus on extending the type system to handle the other constructions of the
language such as anti-patterns \cite{KirchnerKM-2007,kopetz:08}. 
As a slightly more prospective research area, we also want parametric polymorphism over types for \tom: our type system will therefore have
to be able to handle that as well.  

\section*{Acknowledgements} We would like to acknowledge the numerous discussions we had
in the Protheo and Pareo teams, especially with Paul Brauner, on these topics during these
last years as well as the constructive and useful comments done by the anonymous
refereees.

\bibliography{typing}
\bibliographystyle{plain}

\end{document}
