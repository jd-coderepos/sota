\documentclass{eptcs-modified}
\usepackage{tikz}

 \providecommand{\event}{} \usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amscd}
\usepackage{graphics}



\title{Computable dyadic subbases and -representations of compact sets}
\author{
Arno Pauly
\institute{Department of Computer Science, Swansea University, Swansea, UK\\
Birmingham University, United Kingdom}
\email{Arno.M.Pauly@gmail.com}
\and
Hideki Tsuiki
\institute{Graduate School of Human and Environmental Studies,\\ Kyoto University, Kyoto, Japan}
\email{tsuiki@i.h.kyoto-u.ac.jp}
}
\def\titlerunning{ representations from dyadic subbases}
\def\authorrunning{A. Pauly \& H. Tsuiki}

\begin{document}
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{question}[theorem]{Open Question}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{example}[theorem]{Example}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\id}{\textnormal{id}}
\def\2{\{0,1\}}
\newcommand{\Cantor}{{\2^\omega}}
\newcommand{\Baire}{{\mathbb{N}^\omega}}
\newcommand{\Lev}{\textnormal{Lev}}
\newcommand{\hide}[1]{}
\newcommand{\mto}{\rightrightarrows}
\newcommand{\uint}{{[0, 1]}}
\newcommand{\bft}{\mathrm{BFT}}
\newcommand{\lbft}{\textnormal{Linear-}\mathrm{BFT}}
\newcommand{\pbft}{\textnormal{Poly-}\mathrm{BFT}}
\newcommand{\sbft}{\textnormal{Smooth-}\mathrm{BFT}}
\newcommand{\ivt}{\mathrm{IVT}}
\newcommand{\cc}{\textrm{CC}}
\newcommand{\lpo}{\textrm{LPO}}
\newcommand{\llpo}{\textrm{LLPO}}
\newcommand{\aou}{AoU}
\newcommand{\Ctwo}{C_{\{0, 1\}}}
\newcommand{\name}[1]{\textsc{#1}}
\newcommand{\C}{\textrm{C}}
\newcommand{\UC}{\textrm{UC}}
\newcommand{\ic}[1]{\textrm{C}_{\sharp #1}}
\newcommand{\xc}[1]{\textrm{XC}_{#1}}
\newcommand{\me}{\name{P}.~}
\newcommand{\etal}{et al.~}
\newcommand{\eval}{\operatorname{eval}}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\Sierp}{Sierpi\'nski }
\newcommand{\isempty}{\operatorname{IsEmpty}}
\newcommand{\spec}{\textrm{Spec}}
\newcommand{\cord}{\textrm{COrd}}
\newcommand{\Cord}{\textrm{\bf COrd}}
\newcommand{\CordM}{\Cord_{\textrm{M}}}
\newcommand{\CordK}{\Cord_{\textrm{K}}}
\newcommand{\CordHL}{\Cord_{\textrm{HL}}}
\newcommand{\leqW}{\leq_{\textrm{W}}}
\newcommand{\leqsW}{\leq_{\textrm{sW}}}
\newcommand{\leW}{<_{\textrm{W}}}
\newcommand{\equivW}{\equiv_{\textrm{W}}}
\newcommand{\geqW}{\geq_{\textrm{W}}}
\newcommand{\pipeW}{|_{\textrm{W}}}
\newcommand{\nleqW}{\nleq_{\textrm{W}}}
\newcommand{\Det}{\textrm{Det}}
\newcommand{\R}{\textrm{R}}
\newcommand{\UR}{\textrm{UR}}
\newcommand{\bo}[2]{{{#1_{{\langle#2\rangle}}}}}
\newcommand{\Q}{\mathbb{Q}}
\def\T{\mathbb{T}}
\def\A{\mathcal{A}}
\def\K{\mathcal{K}}
\def\V{\mathcal{V}}
\def\O{\mathcal{O}}
\def\X{\mathbf{X}}
\def\Y{\mathbf{Y}}
\def\N{\mathbb{N}}
\newcommand{\pruned}{\mathcal{PT}}
\newcommand{\tree}{\mathcal{T}}
\newcommand{\treeL}{\mathcal{T}_\mathcal{L}}
\newcommand{\comp}{\uparrow}
\def\exS{S_{\mathrm{ex}}}
\def\exbarS{\bar{S}_{\mathrm{ex}}}
\newcommand{\cl}{\textrm{cl}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\extr}{\mathrm{ext}}

\newcommand\tboldsymbol[1]{\protect\raisebox{0pt}[0pt][0pt]{}\mbox{\hskip 1pt}}

\newcommand{\bolds}{\tboldsymbol{\Sigma}}
\newcommand{\boldp}{\tboldsymbol{\Pi}}
\newcommand{\boldd}{\tboldsymbol{\Delta}}
\newcommand{\boldg}{\tboldsymbol{\Gamma}}

\newcounter{saveenumi}
\newcommand{\seti}{\setcounter{saveenumi}{\value{enumi}}}
\newcommand{\conti}{\setcounter{enumi}{\value{saveenumi}}}



\maketitle

\begin{abstract}    We explore representing the compact subsets of a given represented space by infinite sequences over Plotkin's . We show that computably compact computable metric spaces admit
representations of their compact subsets
in such a way that compact sets are essentially underspecified points.
We can even ensure that a name of an -element compact set contains  occurrences of .
We undergo this study effectively  and show that
such a -representation is effectively obtained from structures of
computably compact computable metric spaces.
As an application, we prove some statements about the Weihrauch degree of closed choice for finite subsets of computably compact computable metric spaces.

Along the way, we introduce the notion of a computable dyadic subbase, and prove that every computably compact computable metric space admits a proper computable dyadic subbase.
\end{abstract}

\maketitle








\section{Introduction}
In TTE \cite{weihrauchd}, the fundamental computability notion is introduced on either Cantor space  or Baire space , and then lifted to other spaces of interest via representations. It is well-known that the choice of  or  is inconsequential for the resulting theory, and authors typically choose whatever space works better for a specific purpose. In principle, other spaces can be used as the fundament, too, provided that they have a sufficiently substantial computability theory defined on them. Using the space of regular word functions has been advocated by \name{Kawamura} and \name{Cook} with computational complexity as the motivation \cite{kawamura}. If one is primarily interested in Quasi-Polish spaces \cite{debrecht6}, then the Scott domain  makes sense as the foundational space, with a computability notion derived from enumeration reducibility (cf.~\cite{pauly-kihara-arxiv}).

Here we consider  as a fundamental space for computation, the space of infinite sequences over Plotkin's . Plotkin's  is the three point space  with the topology generated by . Thus,  plays the role of \emph{not yet determined}, whereas the values  and , once attained, will remain unchanged. The use of  (together with IM2 machines) as the basis for a theory of computability has been investigated by the second author in a number of papers \cite{tsuiki,tsuiki4,tsuiki3}. An interesting result is that a separable
metric space  admits an injective representation  such that each  has at most  occurrences of  iff the dimension of  is at most .

This approach appears very similar to the domain-representations studied in e.g.~\cite{blanck}. The significant difference is that we allow for multivalued realizers,
and thus never change the resulting notion of computability. For domain-representations, realizers are required to be single-valued, and the resulting categories can thus differ fundamentally from the category of represented spaces and computable functions.

In the present paper we consider -representations of the space  of compact subsets of some space  represented over . We first introduce some notions on representations of non-empty compact subsets.
We are particularly interested in matching representations in the following sense:

\begin{definition}\label{def:match}
Consider a representation  and a -representation . We say that they \emph{match} iff

for every .
Here  denotes the specialization relation on 
(see Section \ref{section-notation} for details on notation).
\end{definition}



A pair of matching representations means that we can obtain names for points inside the compact set by replacing  with  or .
This essentially means that we can consider compact subsets as underspecified points. This seems like a counterpart to the identification of points in admissible spaces as being equivalent to compact singletons \cite{schroder5,pauly-synthetic}.
We consider more: we can obtain names for compact subsets
by replacing some copies of  with  or .

\begin{definition}\label{def:hereditary}
A -representation  is \emph{hereditary} if the restriction of  to  is a
representation of 
for every .
\end{definition}
Here,   is the upper set with respect to the specialization order ,  which for  is   iff .
If  is a hereditary representation and , then .
Therefore, every name of a -point set  contains at least  copies of  because there is a chain of length  in .
We want even more for our applications.
\begin{definition}\label{def:faithful}
A -representation  is \emph{faithful} if it is hereditary and the followings properties hold for the case  is a finite subset:
\begin{itemize}

\item[(1)]  contains  copies of .
\item[(2)] .
\end{itemize}
\end{definition}

Since the restriction of a faithful  -representation  of 
to  is a representation of singleton sets,
it induces a representation  of .
The pair  obviously forms a matching representation.

From a -representation , one can easily form a -representation
 by defining  and
 for .
Therefore, we extend the above notions to those of -representations of  as follows.
\begin{definition}\label{def:match2}
A -representation   is faithful
iff,   and the -representation  of
 defined as  is
faithful.  Similary, we define a hereditary -representation of 
and a -representation of  that
matches with a representation  of .
\end{definition}
If  is a faithful -representation of , then
every name of a -point set contains  copies of .

We provide a faithful -representation for the case  being the Cantor space  in Section \ref{sec:cantor}.
For more general spaces,
we  provide a construction of a faithful -representation
based on the concept of a proper dyadic subbase.
We study computable dyadic subbases
and  show that every computable metric space has a proper computable dyadic subbase by effectivizing a proof of \name{Tsukamoto} \cite{tsukamoto} in Section
\ref{sec:propersubbases}.
Then, in Section \ref{sec:mainresult},
we show that a computably compact computable metric space with a proper computable dyadic subbase has a faithful -representation.




  We represent compact subsets as trees using proper computable dyadic subbases,
and then construct a -representation of trees.
  Tree-based representations of compact sets appeared in \cite{berger}, where they used the Vietoris topology (aka the Hausdorff metric aka the full information representation) on the hyper space.  Our representation is linked to the upper Vietoris topology, which is compatible with -representations.

An initial motivation of this work was the investigation of a construction employed to prove \cite[Proposition 1.9]{paulyleroux}. That result is showing that the Weihrauch degree of finding a point in a closed subset of a computably rich computably compact computable metric space  with cardinality equal to  (or up to ) does not depend on the choice of . The construction in \cite{paulyleroux} crucially depends on knowing . Here, we can prove that the statement remains true without any bound on the finite cardinality. In Section \ref{sec:weihrauch}, we explore the resulting Weihrauch degree and relate it to other known degrees.

\section{Notation and Fundamentals}

\subsection{Notation}\label{section-notation}
For an alphabet , we denote by  respectively  the space of
finite respectively infinite sequences over .
For , let  express that  is a prefix of .
For , we let  denote its length.
For  or , we denote by  its restriction to first  components.  Here, in the case , we assume that .
As a special case,  is the space of finite sequences over .
We consider  mapping  to  as a standard computable map, but point out that the partial inverse of  is not computable
\footnote{Note that in the previous literature on proper dyadic subbases the expression  denotes our
.}.

We call the number of digits (i.e., 0 or 1) in   the level of 
and denote it by .
We denote by  the set of level- sequences.
More generally, for a subset  of ,
we denote by  the set of level- sequences of .
For example,
 all have length 3 and
belong to , respectively.
We write .
For  or , we define  as

for  the index of the -th digit of . For example, .

We write  for  if , and
 for   if
.

 We write . By  we denote that . We extend these notions to  along . Note that  is a partial order on  but is only a quasiorder on , as e.g.~ and . By excluding from  the finite sequence ending in  we obtain canonic representative  of each -equivalence class.   is a partially ordered set.

By  we denote the set  equipped with the representation ,  and .
With the representation we will introduce in Section \ref{section-introtomega},
 is computable, but  is not. In the following, we will suppress both  and  and their combinations in the notation. For example, if we have some function , we might speak of the function  obtained by precomposing with these computable functions without further notice.

\subsection{Background on represented spaces}
We briefly recall some fundamental concepts on represented spaces following \cite{pauly-synthetic}, to which the reader shall also be referred for a more extensive treatment. A \emph{represented space} is a pair  of a set  and a partial surjection . A (multivalued) function between represented spaces is a (multivalued) function between the underlying sets. For  and , we call  a realizer of  (notation ), iff  for all , i.e.~if the following diagram commutes:
 
A map between represented spaces is called computable (continuous), iff it has a computable (continuous) realizer. A priori, the notion of a continuous map between represented spaces and a continuous map between topological spaces are distinct. However, for the admissible spaces (as defined by \name{Schr\"oder} \cite{schroder,schroder5}) the notions coincide. This in particular includes the computable metric spaces.

We say that representations ,  of the same set  are equivalent, if  and  are both computable. In this case, we also say that  is a representation of , or that  admits the representation .

Cantor space itself is considered a represented space, with  serving as the representation. Other specific relevant represented spaces are  represented by  and Sierpi\'nski space  with underlying set  and representation  defined by  and  for .

Courtesy of the UTM-theorem (in the form proven in \cite{weihrauchk}), there is a natural representation of the space  of continuous functions between two given represented spaces , . Then representation is rendering all the expected operations computable, in particular composition and evaluation. We immediately obtain a representation of any  in form of . We can also derive the space  of open subsets of  by identifying a set  with its characteristic function  mapping  to  and  to . The open subsets are the final topology along the representation, and again, the expected operations are computable.

The represented space  of closed subsets is defined
by considering the characteristic function of its complement. In other words, we define  in such a way that  and  became computable.
We further introduce the space  of compact subsets by representing  via .
Dually, we define the represented space  of
overt subsets by representing  via . Note that the elements of  individually are closed sets, but neither  nor  is computable for non-empty .

A represented space  is called computably compact if  is computable,
and computably overt if  is computable.
It is called computably Hausdorff, iff  is computable. A space is computably compact and computably Hausdorff iff both  and  are well-defined and computable. As we will be working with (computable) compact Hausdorff spaces, we can freely alternate between treating sets represented as closed or as compact sets in the following.

\subsection{Computably compact computably Hausdorff countably-based spaces}
The proofs of our main results will make explicit use of the space  being computably compact and being computably Hausdorff. Moreover, since we are using dyadic subbases, the space has to be countably-based. It is a classical result in topology that countably based compact Hausdorff spaces are metrizable. This is shown in two steps: First, it is shown that compact Hausdorff spaces are regular, then Urysohn's metrization theorem tells us that countably-based regular Hausdorff spaces are metrizable.

In an effective context, Schr\"oder's effective metrization theorem \cite{grubba3,schroder8} shows that countably-based computably-regular computably Hausdorff spaces are computably metrizable. However, the standard proof that compact Hausdorff implies regular does not effectivize:

The argument proceeds as follows: We have a point  and a (non-empty) closed set  with . For every  there exist disjoint open  with  and , since  is Hausdorff. Now  is an open cover of . By compactness, it has a subcover indexed by a finite set . Now  and  are disjoint open sets with  and , establishing that  is regular. The problem is that to effectively use the open cover , we would need to know  as an overt set, not as a closed set.

Whether there is a different proof that establishes the full effective version of this result has been raised as \cite[Question 9]{oberwolfach-computability}. However, we only need it in the countably-based case. Here, we have effectively open representations available, meaning that  is well-defined and computable.

\begin{theorem}\label{theorem:coregular}
Let  admit an effectively open representation, be computably Hausdorff and computably compact. Then  is computably regular.
\begin{proof}
We are given  and  with , and we need to compute  with ,  and . We use computable compactness of  to obtain . Since  is computably Hausdorff, there exists a computable function  such that  is . We can extend  to a total computable function, as  is precomplete.

We exhaustively search for finite prefixes  such that the realizer of  writes a  somewhere when reading in a prefix  of our given name for  as first input, and  as prefix of the second input. Since  is effectively open, we can then compute  and . The construction guarantees that ,  and , where  is the set of all prefixes we discover.

Since , computable compactness lets us find a finite  with . Now  and  are computable from the given data, and satisfy our criteria.
\end{proof}
\end{theorem}

\begin{corollary}
Let  admit an effectively open representation, be computably Hausdorff and computably compact. Then  is computably metrizable.
\end{corollary}

Many results of this paper
(e.g., Theorem \ref{theo:dyadicexists}, \ref{theo:hereditary}, \ref{theo:minimalfaithful}) are about computably compact computably metrizable spaces (CCCMS). This corollary shows that they also hold for computably Hausdorff computably compact spaces with effectively open representations.


\subsection{Introducing -represented spaces}
\label{section-introtomega}
We can consider  as a represented space (over ) via the representation  defined by ,  iff  is even and  iff  is odd. From this representation we derive a representation  of  in the usual way.
Thus we have a notion of computability of (multivalued) functions on  available. We could alternatively define computability on  directly via IM2 machines, but will not do so here for sake of simplicity.

For an alternative equivalent approach, note that there is an embedding from  to  that maps
  0 and 1 to  and  , respectively. Therefore
   embeds into  which has a natural enumeration-based representation.  Thus, we have a representation  of
 by restricting the standard representation of . The representations  and  are equivalent.

A -representation  of some set  is just a partial surjection , and a -represented space is a set equipped with a -representation of it. As , we can consider every (ordinary) representation as a special case of a -representation. Conversely, every -representation  induces an ordinary representation .

Let ,  be -represented spaces. We call a multivalued function  a -realizer of  iff  for all . Unlike the situation for ordinary representations, we also need multivalued realizers here. The reason is that not every computable multivalued function  has a computable choice function\footnote{For example, consider  defined by  iff  and  iff .}. Again, we call a (multivalued) function between -represented spaces computable (continuous), iff it has a computable (continuous) -realizer. The following is then straight-forward:

\begin{proposition}
\begin{enumerate}
\item Let  and  be represented spaces. A multivalued function  is computable (continuous) as a function between represented spaces iff it is computable (continuous) as a function between -represented spaces.
\item Let  and  be -represented spaces, and  and  the induced represented spaces. Then  is computable (continuous) iff  is.
\end{enumerate}
\end{proposition}

 We thus see that the category of represented spaces and  computable (continuous) (multi-valued) functions is equivalent to the category of -represented space and computable (continuous) (multi-valued) functions. We can identify a -represented space with  the induced represented space.




\section{-representations of pruned trees}
\label{sec:cantor}
We recall that a (binary) tree is a set  such that  implies . The elements of a tree are called vertices. By using some standard bijection , we can then represent a tree  by its characteristic function . We shall denote the represented space of binary trees by .

Some  is called an infinite path trough a tree  if . The set of infinite paths through  is denoted by . It is well-known that the closed subsets of  arise as  for some tree in a uniform way. In other words  is computable and has a computable multivalued inverse.

A tree is pruned, if  implies . By induction, in a pruned tree every vertex is the prefix of some infinite path through it. Moreover, for any tree  there is a unique pruned tree  such that  -- however,  is not computable from , with the Kleene tree being the canonic counterexample.

\begin{definition}
\label{def:pruned}
We define the -represented space  by letting the underlying set be the pruned binary trees, and the  representation  be defined as follows:

\end{definition}

This means that we use the first symbol in a -name for a tree to indicate whether the tree is empty or not, with  representing non-emptyness. If the tree is non-empty, then clearly . Then for any vertex  of the tree, the value of  indicates whether the left child, the right child or both are part of the tree. This represents precisely the pruned trees, as there the fourth case of \emph{neither} does not apply.

\begin{theorem}
\label{theo:prunedtrees}
The map  is computable and has a computable multivalued inverse.
\begin{proof}
We compute the pruned tree  from , we read through  layer by layer (i.e.~consider all  with  at the same time).
 While doing so, we construct a -name  of . We can assume that initially, , and then change entries in  to  or  as required.

If at any stage of the computation we find that  and there is some  such that for all  with  we learn that , then we set . If  and there is some  such that for all  with  we learn that , then we set . If we ever find some  such that  for all  with , then we set . Using compactness, it is straight-forward to verify that this yields a valid -name for . Note that moreover, every entry in the resulting name  which is not specified by the definition of  will be either  or , but never .

Now let us consider how to compute the multivalued inverse of . We start with some -name 
of a -name 
of some pruned tree . For  and , let . Let . Note that given , ,  we can compute  and .

We define a tree  by setting  iff . This is a tree by monotonicity of the condition (which is in part derived from the monotonicity of  and  in ). As  is available, the condition is decidable, and thus the tree is known as an element of . It is straight-forward to verify that .
\end{proof}
\end{theorem}

Let  be the restriction of  so that
 if .  That is,
all non-specified entries are 0 or 1 in a name of a pruned tree.
One can see from the proof that  is a map to this restricted represented space.

\begin{corollary}
\label{corr:nicefunctionscantor}
There is a surjection  and a multivalued
map  such that
\begin{enumerate}
\item  and  are computable.
\item .
\item  is hereditary.
\item The restriction of  to the domain of  is faithful. In particular, if  is a finite set, then
the cardinality of  is equal to the number of  in .
\end{enumerate}
\begin{proof}
We obtain  as , and then  as its multivalued inverse
computed through the realizer of .
That  is hereditary directly follows from its construction.
Property  follows from the observation that   is a map to
the domain of .
\end{proof}
\end{corollary}

We define  as the faithful -representation
obtained by restricting   to the domain of .


\section{Proper computable dyadic subbases}
\label{sec:propersubbases}

In order to obtain a result akin to  Corollary \ref{corr:nicefunctionscantor} for a larger class of spaces, we will utilize the notion of a proper dyadic subbase.  It was introduced in \cite{tsuiki},
and further studied in \cite{tsuiki2,tsuiki4,TsukamotoTsuiki:2016,tsukamotophd}.
The original motivation was to generalize the role of the binary and signed binary representations of real number: A proper dyadic subbase induces both (1) a ``tiling'' coding generalizing the binary expansion and (2) ``covering'' coding (which forms an admissible representation) generalizing the signed binary expansion.

The definition of a (not necessarily proper) dyadic subbase was changed in \cite{TsukamotoTsuiki:2016} compared to the previous literature.  Here, we adopt the definition from \cite{TsukamotoTsuiki:2016} and introduce the notion of a computable dyadic subbase of a represented space.

\subsection{Computable dyadic subbases}

\begin{definition}\rm\label{def:dyadicsubbase}
A \emph{dyadic subbase} over a set  is
a map  such that  for every  and if  for , then .
\end{definition}

We write  for  and .
For a dyadic subbase  and , define

We say that  is a dyadic subbase of a topological space  if  is a subbase of , or equivalently,
 is a base of .

A dyadic subbase  defines an injection
 from  to  as follows.

Any dyadic subbase  over a set  thus induces a -representation . We shall denote the resulting (-)represented space by .
On the other hand, any injective -representation  induces a dyadic subbase 
  defined as . Therefore, a dyadic subbase can be identified with an injective -representation.

\newcommand{\I}{{\mathbb I}}
\begin{example}\label{ex:gray} Let  be the interval .  Let  be the tent function
.
We define  the dyadic subbase  recursively as , ,
.  We have

We have
,  ,
, and .
 contains  if  is a dyadic rational (numbers of the form , and the sequence after a  is always .
One can easily see that  is a dyadic subbase of  with the Euclidean topology.

\end{example}




\begin{definition}\label{def:dyadicsubbase3}
We say that  is a (computable) dyadic subbase of a represented space  if
 is computably isomorphic to .
\end{definition}

The adjective \emph{computable} is redundant, but in order to avoid confusion between a dyadic subbase of a topological space and of a represented space, we add this adjective to the latter case.
Recall that a represented space  is an admissible represented space if
the map  has a computable partial inverse.
This definition also applies to -represented spaces.
The following proposition says that only admissible represented spaces have computable dyadic subbases.


\begin{proposition}
   is an admissible represented space.
\end{proposition}
\begin{proof}
  With the representation ,
 is a name of  if  is an enumeration of .
That is, it is the standard representation with respect to the subbase
, which is admissible.
\end{proof}


We can characterize a computable dyadic subbase as follows.
Recall that  and
 can be seen as the space of enumerations of sets of finite words over . Therefore,  is a base of .


\begin{proposition} \label{prop:computablepds}
Suppose that  is an admissible represented space.
A dyadic subbase 
is a computable dyadic subbase of  iff  is computable and has a computable multi-valued inverse .

\begin{proof}
Suppose that the right hand side of the statement holds. Then in particular,  is computable. As  is by definition computable, and the promise that , we find that  mapping  to  iff  is computable. This lets us compute .

To show that  is computable, too, recall that for admissible  the map  has a computable partial inverse. Thus, it suffices to show that  is computable.
Since  is computable, it suffices to show the
computability of the map  mapping  to  iff . As  is computably overt (which makes existential quantification computable), this in turn follows from the computability of .

The reverse implication is obvious from how  inherits its topology as a subspace of .
\end{proof}
\end{proposition}


For a dyadic subbase  and , define


We have

These equations show that  and  are order-theoretic notion in .


\begin{proposition}
\label{prop:dyadicsubbase}
Let  be a computable dyadic subbase of . Then  and  are computable.
\begin{proof}
This follows immediately from the definition of  and  together with the observation that finite intersection , countable intersection  and complement  are computable (eg \cite{pauly-synthetic}).
\end{proof}
\end{proposition}

\begin{corollary}
\label{corr:compactsemicharac}
Let  be a computable dyadic subbase of computably compact . Then  is recursively enumerable.
\end{corollary}


\begin{proposition}
\label{prop:overtcharac}
Let  be a computable dyadic subbase of . Then  is computably overt iff  is recursively enumerable.
\begin{proof}
By definition,  is computably overt iff  is computable. By composing this with computable , we conclude that  is recursively enumerable.

For the converse direction, note that from  we can compute  with , and that  iff .
\end{proof}
\end{proposition}


\subsection{Proper dyadic subbases}

\begin{definition}
We say that a dyadic subbase  is {\em proper} if
 for every .
\end{definition}

If  is a proper dyadic subbase,
 and   are regular open sets which are exteriors of each other.  That is,  is the common boundary between them and
.
Therefore, if  is a proper dyadic subbase then
a sequence 
not only contains information
 on
the basic open sets  belongs to, but also information

on the basic open sets to whose closure  belongs.

\begin{proposition}
\label{prop:propercharac}
Let  be a dyadic subbase.   The followings are equivalent:
\begin{itemize}
\item[(1)]  is a proper dyadic subbase.  That is,  for every .
\item[(2)]  for every .
\item[(3)] 
for every .
\item[(4)] 
for every .
\end{itemize}
\begin{proof} The equivalence of (1) and (2) is given in Lemma 9 of \cite{tsuiki2}.
The equivalence of (1) and (3) is given in Proposition 2.7 of \cite{tsuiki3}.
The equivalence of (1) and (4) is similar.
\end{proof}
\end{proposition}

\begin{corollary}\label{cor:proper}
  If  for every , then  is a proper dyadic subbase.
\end{corollary}

\begin{example}
  The Gray subbase is proper by Corollary \ref{cor:proper}.
\end{example}

\begin{proposition}\label{prop:pi02}
If  is a computable dyadic subbase of a computably compact and computably overt space , then  being proper is a -property.
\end{proposition}
\begin{proof}
  From
  Corollary \ref{corr:compactsemicharac}, Proposition \ref{prop:overtcharac},
  and Proposition \ref{prop:propercharac}.
\end{proof}

\begin{proposition}\label{prop:decidable}
If  is a proper computable dyadic subbase of a computably compact computably overt space , then
it is decidable whether  for .
\end{proposition}
\begin{proof}
These observations follow from Proposition \ref{prop:propercharac} in combination with Corollary \ref{corr:compactsemicharac} and Proposition \ref{prop:overtcharac}.
\end{proof}


\begin{corollary}
\label{corr:dyadicsubbase}
Let  be a proper computable dyadic subbase of computably overt . Then  is computable.
\begin{proof}
As  is computable, we obtain  from Proposition \ref{prop:dyadicsubbase}. By definition of a proper dyadic subbase,  for , and  is computable for computably overt  (eg \cite{pauly-synthetic}). We thus obtain .
\end{proof}
\end{corollary}

\begin{definition}
\label{def:excase}
For a dyadic subbase  of a space ,
 and ,
we define 
and  as follows.

Note that
.
For , we define  and  .  We have

\end{definition}


The sets  may fail be to be either open or closed, but are guaranteed to be . While each  is a closed set, even for a computable dyadic subbase this does not yield an effective statement in general: The sets ,  will be available as elements of , whereas  is available as an element of 
but not as an element of  in general because finite intersection is not a continuous operation on . However, if  is proper, then  and  -- i.e.~all component sets of  are available as elements of , and this space is effectively closed under intersection. We thus find:

\begin{observation}
\label{obs:effectivelyproper}
Let  be a proper computable dyadic subbase of . Then  is computable.
\end{observation}

We can use this to characterize compactness similar to the characterization of overtness in Proposition \ref{prop:overtcharac} (and extending Corollary \ref{corr:compactsemicharac}):

\begin{proposition}
\label{prop:compactcharac}
Let  be compact and admit a proper computable dyadic subbase .
Then  is computably compact iff  is recursively enumerable.
\begin{proof}
The forward-implication follows from Observation \ref{obs:effectivelyproper} and the basic characterization of computable compactness (see \cite{pauly-synthetic}). For the other direction, we need to show that we can semidecide  given . By Proposition \ref{prop:computablepds}, we can assume  to be given as  for some enumerated set . Since we assume  to be compact, if , then already  for some finite .

Now from any  we can compute  such that . Thus, by semideciding whether  for all , we can semidecide whether  .
\end{proof}
\end{proposition}

\subsection{Existence of proper computable dyadic subbases}
\label{sec:existenceproper}

In \cite[Section 3.1]{tsukamoto}, \name{Tsukamoto} had shown that any separable metric space admits a proper dyadic subbase.
In this subsection, we effectivize the proof to show that every computably compact computable metric space admits a proper computable dyadic subbase.

We recall the definition of a computable metric space:

\begin{definition}
A computable metric space  is a separable metric space  with metric  and a dense sequence  such that  is a computable double sequence of real numbers.\\

A computable metric space is turned into a represented space via the Cauchy representation  defined by  iff . A computable Polish space is a represented space induced by a complete computable metric space.
\end{definition}

We point out that since a computable metric space has by definition a computable dense sequence, it is always computably overt. In particular,  is computable for any computable metric space .

Next, we gather some results and definitions which we will require for the existence proof.

\begin{theorem}(Computable Baire category theorem \cite{brattka7})
Let  be a computable Polish space.
There exists a computable operation  such that,  for any sequence  of closed nowhere dense subsets of  and a non-empty open subset ,
.
\end{theorem}

\begin{definition}
   is a local maximum of a continuous function  if  is the maximum value of  for some open subset .  Local maximum and local minimum values are called local extrema.
We denote by  the set of local extrema of .
\end{definition}

For a function  and a real number ,  let
 and
. Note that  is a computable function. While  and  are clearly always disjoint, in general they do not have to be exteriors of each other. However, we can establish:


\begin{lemma}\label{lemma0}
If , then  and   are exteriors of each other.
\end{lemma}

\begin{proof}
  Suppose that  is not a local extremum of  and .
  Then, for any ,  and
  .
\end{proof}

Let  and  denote the open and respectively closed ball of  center  and radius . For , ,  and , let  be the maximum value of  in  and  be the supremum value of  in . Let .

\begin{lemma}
\label{lem:mmd}
The following functions are computable:
\begin{enumerate}
\item ,
\item ,
\item .
\end{enumerate}
\begin{proof}
\begin{enumerate}
\item From ,  we can compute . The intersection of a compact and a closed set is computable as a compact set. The maximum of a real-valued continuous function on a compact set is approximable from above, i.e.~computable as a point in .
\item The map  is computable. We can thus compute . Taking the closure does not impact the supremum of a continuous function. The supremum of a real-valued continuous function on an overt set is approximable from below, i.e.~computable as a point in .
\item By combining  and , and noting that  and  are computable.
\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma}
\label{lem:extrfcharac}
.
\begin{proof}
Since , we find that . Thus,  is either empty, or the singleton  where . In either case, we see that . The same argument works for  by exchanging minima and maxima.

Conversely, let . By moving to  if necessary, we can assume  to be a local maximum. This means there is some open  such that . Pick some  with . Since we are working in a separable metric space, there are  with . We then find that , hence .
\end{proof}
\end{lemma}


\begin{lemma}\label{lemma1}
  Let  be a computable metric space.
There exists a computable operation  which returns a real in
 to input  if  is nonempty.
\end{lemma}

\begin{proof}
By Lemma \ref{lem:mmd} (3) and Lemma \ref{lem:extrfcharac}, we can compute each  as the union of a sequence of nowhere-dense closed sets. The computable Baire category theorem then lets us find a point avoiding their union.
\end{proof}

\begin{theorem}
\label{theo:dyadicexists}
Every CCCMS (computably compact computable metric space)  admits a proper computable dyadic subbase.
\end{theorem}
\begin{proof}
Let  be a computable sequence of  open rational intervals which forms a base of .   Let  be a standard bijection. Let .
Then, for any choice of , we obtain a dyadic subbase of  by . If  is computable, then  is even a computable dyadic subbase.

By Proposition \ref{prop:propercharac}, for  to be proper, we need that
 for every . We will choose  inductively to ensure this.


For a sequence  of length  and ,
we define  and 
as   and
. Since  is computably compact, we also obtain .

First, we choose  avoiding the local extrema of , i.e.~ via Lemma \ref{lemma1}.

Suppose that we have defined  to  so that
 for every .
Let  and .  We have .
We choose  via Lemma \ref{lemma1}, i.e.~avoiding any local extrema of  on any .

We prove  for every .  We show it for the case .
we need to show

First, we have

because  for open sets .
Since  is not a local extremum of  on , by Lemma \ref{lemma0},


With the dyadic subbase  thus defined,  and

are computable open sets of  and therefore  is computable.
On the other hand,  for a base  for  and , take an  such that  and
define . Then,
.  Therefore, the multi-valued inverse of  is computable.
Thus, by Proposition \ref{prop:computablepds},
 is a computable dyadic subbase of .
\end{proof}

The proof of Theorem \ref{theo:dyadicexists} is fully uniform. We could have constructed the represented spaces of all compact separable metric spaces, similar to what is suggested in \cite{rettinger2}. Then we would have stated that we can compute a proper dyadic subbase from a given compact separable metric space.

Given that the original proof from \cite[Section 3.1]{tsukamoto} does not require compactness, of course the question arises why we require it for Theorem \ref{theo:dyadicexists}. Computable compactness of  is used to obtain the , not just in , which is needed to invoke Lemma \ref{lemma1}. We will see in the following example that without compactness, there is no computable way to avoid local extrema. There might still be a way to salvage the construction by exploiting that we do not need to avoid local extrema of arbitrary functions, but of distances.

\begin{example}
There exists a computable function  such that for every computable real  there exists some  with .
\begin{proof}
We can describe a computable function  by computably labelling the full countably branching tree  with closed rational intervals  such that  and . We label the root and all first-generation children by . Inside the subtree below the -th first generation child, we try to compute the -th computable real number  (which might be undefined).

Once we have found the label  to some vertex, we compute the labels for the successors as follows: To obtain , we continue the computation of  for  more steps. If this yields an approximation  of  of precision , and  is non-empty, then we set . Otherwise, we set .

This ensures that if  is an upper bound for the computation time of , then . Otherwise, .
\end{proof}
\end{example}

\begin{corollary}
The map  defined by  is not computable.
\end{corollary}

\section{Main result}
\label{sec:mainresult}
In this section, we show that for every computably compact computable metric space (CCCMS)  there is a faithful -representation of .

\subsection{The poset }

Our construction utilizes
a sub-poset  of , which was studied in \cite{tsuiki4}.


We say that  is an \emph{immediate successor} of 
(denoted by )
if  and  has one more digit than .
We say that a subset  of   is \emph{tree-like} if
.
For a tree-like set  and ,
we write  for the set of immediate successors of  in .
A tree-like set  is called \emph{finitely branching} if
 is finite for each .

For a tree-like subset ,
we call an infinite sequence  in  an \emph{infinite path} in .
Every infinite path   has a limit ,
which is an element of .
We define  as the set of limits of infinite paths in  (i.e.~ generalizes the notion of body of a tree).





The following proposition gives a sufficient condition for  to become a singleton.
\begin{proposition}[Proposition 2.5 of \cite{tsuiki4}]\label{prop:rho}
  Suppose that  is a proper dyadic subbase of a Hausdorff space .
\begin{itemize}
\item[(1)]  If , then  and  for some  and .

  \item[(2)] If  and , then .

\item[(3)] If  and , then .
Therefore,  another -representation   of  is derived from .
The domain of  is  and  if and only if ,
or equivalently, .
\end{itemize}
\begin{proof}
\begin{enumerate}
\item Since  is Hausdorff and  is proper, there is  such that
 and .  Therefore,   and
 by equations (\ref{eq:s}) and (\ref{eq:cs}).
Thus, .  Therefore,
 for some .

\item  It holds for dyadic subbases in general.
First, we have .  For  holds.


\item  From (1), we have .
We have  from .
On the other hand,  because .
\end{enumerate}
\end{proof}
\end{proposition}





\begin{definition}
Let  be a dyadic subbase of a space .
 We define the poset  as
 
\end{definition}

Every element of  does not end with  and thus belongs to .  Therefore,  is a poset.
It is a tree-like set by construction.  Since
 for some ,
we can derive

from   Equation (\ref{eq:barcs}).
As is shown in Proposition 4.4 of \cite{tsuiki4},
 is consistently complete (i.e., every pair of consistent elements have
their least upper bound) and  forms a Scott sub-domain of .


\begin{figure}
\begin{center}
\begin{tikzpicture}{align=bottom}
\draw (0,0) node (e) {};
\draw (-4,1) node (0) {};
\draw (0,1) node (b1) {};
\draw (4,1) node (1) {};

\draw (e) --(b1);
\draw (e) --(1);
\draw (e) --(0);

\draw (-2,2) node (01) {};
\draw (0,2) node (b10) {};
\draw (2,2) node (11) {};
\draw (4,2) node (1b1) {};


\draw (0) --(01);
\draw (b1) --(01);
\draw (b1) --(b10);
\draw (b1) --(11);
\draw (1) --(11);
\draw (1) --(1b1);


\draw (1,3) node (110) {};\draw (2,3) node (11b1) {};
\draw (3,3) node (111) {};
\draw (4,3) node (1b10) {};\draw (5,3) node (101) {};

\draw (11) --(11b1);
\draw (11) --(111);
\draw (1b1) --(111);


\draw (1.5,4) node (a) {};\draw (2,4) node (b) {};
\draw (2.5,4) node (c) {};
\draw (3,4) node (d) {};\draw (3.5,4) node (e) {};

\draw (11b1) --(2.5,3.5);
\draw (111) --(2.5,3.5);
\draw (111) --(3,3.5);


\draw (2.5,5) node (b1) {};
\draw (2.75,5) node (c1) {};
\draw (3,5) node (d1) {};



\draw (2.5,3.5) --(2.5,4);
\draw (2.5,3.5) --(2.75,4);
\draw (3,3.5) --(2.75,4);

\draw (2.5,4) --(2.625,4.5);
\draw (2.75,4) --(2.625,4.5);
\draw (2.75,4) --(2.75,4.5);

\draw (2.65,4.75) node {...};

\draw (-1,3) node (010) {};
\draw (0,3) node (b100) {};
\draw (1,3) node (110) {};

\draw (01) --(010);
\draw (b10) --(010);
\draw (b10) --(b100);
\draw (b10) --(110);
\draw (11) --(110);

\draw (010) --(-0.5,3.5);
\draw (b100) --(0   ,3.5);
\draw (b100) --(-0.5 ,3.5);
\draw (b100) --(0.5  ,3.5);
\draw (110) --(0.5,3.5);

\draw (-0.5,3.5) --(-0.25,4);
\draw (0,3.5) --(-0.25,4);
\draw (0,3.5) --(0,4);
\draw (0,3.5) --(0.25,4);
\draw (0.5,3.5) --(0.25   ,4);

\draw (-0.25,4) --(-0.125,4.5);
\draw (0,4) --(-0.125,4.5);
\draw (0,4) --(0,4.5);
\draw (0,4) --(0.125,4.5);
\draw (0.25,4) --(0.125   ,4.5);

\draw (0,4.75) node {...};
\draw (-3, 5)-- (3, 5);
\draw (0, 5.2) node (Lb){};
\draw (-0.5, 6) node (L0){};
\draw (0.5, 6) node (L1){};
\draw (Lb)--(L0);
\draw (Lb)--(L1);
\draw (2.65, 5.2) node (L11){};


\end{tikzpicture}
\caption{Some part of . \label{fig:G}}
\end{center}
\end{figure}
\begin{example}
  For the Gray subbase  in Example \ref{ex:gray}, Figure \ref{fig:G} shows
 a tree-like subset of 
that contains
all the paths with the limits , , , and
.
Note that .
\end{example}



\begin{proposition}\label{prop:compact}
Suppose that  is a proper dyadic subbase of a compact Hausdorff space .
\begin{enumerate}
\item[(1)]  is a base of .

\item[(2)]  for .

\item[(3)]  is finitely branching.

 \item[(4)]
 and therefore
the domain of  is .  Moreover,
the map
 from  to  is continuous.
Therefore,  is a retract of .
It also means that
 is homeomorphic to the set of minimal elements of .
\end{enumerate}

\begin{proof}
\begin{enumerate}
\item[(1)] If  for , then  satisfies  and .

\item[(2)] Suppose that  .  Let .  If , then there is an element 
such that .  If , then  satisfies   and .

\item[(3)] It is proved in Proposition 5.10 of \cite{tsuiki4} for a large class of spaces that contain
compact Hausdorff spaces.

\item[(4)]  It is Proposition 3.4 and Theorem 6.4 of \cite{tsuiki4}.
\end{enumerate}
\end{proof}
\end{proposition}


We explore the relationship between the two -representations
   and .
As a part of Proposition \ref{prop:compact}(4),
we have seen .
Actually,   is the limit of the path
 and  for every .
Thus, the inclusion map 
is the realizer of .   The following proposition says that
if  is a proper computable dyadic subbase of a CCCMS ,
then
 is also computable and therefore
the two representations are computably isomorphic.

\begin{proposition}\label{prop:computable-retract}
  Suppose that  is a proper computable dyadic subbase of a CCCMS .
  Then, the retraction  from  to  is  computable and therefore
 is computable.
Thus,   is also a -representation of the represented space .

\end{proposition}
\begin{proof}
Suppose that  is given.
  Proposition \ref{prop:rho} says that there is a unique  such that 
  and we want to compute the sequence    from .
  Since ,
   is obtained by replacing some digits in  with .
  Therefore,
  
  In order to obtain , we need to detect all  such that .

  Since  is regular and  is proper,  if , then
there is  such that
  .
  We also have .
  Therefore,   if and only if  for some .
  It is semi-decidable, because  is in ,  is an open set, and
   is computably compact.
\end{proof}


\subsection{Preparation for the main theorem}

Suppose that   is a proper dyadic subbase of a space .
For a finite-branching tree-like subset  of , we define
 as follows
 is a closed set and we consider that  for a tree 
in Section \ref{sec:cantor} is a special case that  and  is the trivial proper dyadic subbase.

  \begin{proposition}\label{prop:bracket}
If   is a dyadic subbase of  and  is a finite-branching tree-like subset of , then
  .
\end{proposition}
  \begin{proof}
   Let .  We have .
  We choose such  for each  and consider the increasing sequence .
    Let  be its limit.
    Since ,
    we have .
    On the other hand, every  is a limit of an infinite path  in ,
    and  for each .
\end{proof}

  \begin{proposition}\label{prop:tree-like}
   Let  be a finitely branching tree-like subset of .
   There is a strictly increasing function 
and a partial surjective monotonic map  such that
(1)  is a tree,  (2)  maps
 to , and
(3) if  in , then
there exists a unique  such that .
Such a  maps a tree in  to a tree-like subset of 
and injectively maps an infinite path in  to an infinite path in ,
 \end{proposition}
 \begin{proof}
 For each level , let  be the maximum of  for .
    We define  inductively as  and
    .
For each ,  we fix an isomorphism  from a subset of
 to .
For example,  we order 
according to the lexicographic ordering of , and use the
binary notation in .
Then, we define
 for  inductively as
 for  and , when it is defined.  We extend  to a partial map defined on a lower-closed subset of 
by defining  if .
\end{proof}

If we apply this proposition to the case  is a compact Hausdorff space and
,  each tree 
is mapped by  to a tree-like subset of , and thus
\textsf{}specifies a closed subset  of . This correspondence is surjective
because, given a closed subset ,   is a tree in 
such that
.
Note that  is determined by  by Proposition \ref{prop:bracket}.
Since  surjectively maps an infinite path in  to an infinite path in ,
 is determined by , and is again determined by .
In this way, a closed subset of  is determined by a pruned tree.
On the other hand, each infinite path in  is mapped to an infinite path in
 and therefore  specifies
 a point of  by Proposition  \ref{prop:compact}(4).
Combining these with the -representation of pruned trees in Section \ref{sec:cantor},
we {\bf almost} have matching representations of  and .

The obstacle is that the function  in Proposition \ref{prop:tree-like} is not computable in general. This is because the cardinality of
 is not computable, and therefore
the above representation of  is not computably isomorphic to the represented space  .
To solve this, we consider a computable sub-poset 
such that .



\begin{lemma}\label{lemma:H}
Let  be a proper computable dyadic subbase of a CCCMS .
There is a computable monotonic function  such that
the set  defined as

satisfies .
 is decidable as a subspace of .
\label{lem:H}

\begin{proof}
We inductively define .
Let  and .
Suppose that  is defined.
For each element , we perform the following procedure.

By dove-tailing, search for some  such that  is empty.
Recall that we identify  with  for the purpose of defining  for .
Since  is finite, let  be the maximal length
of elements in .  Then,
we have  for .
Therefore, we can find a suitable candidate for 
by Proposition \ref{prop:compactcharac}.
We set  to be  and
.

We show  by induction on .
We have .
Let  and .
Since ,  by induction hypothesis.
Therefore,  and  for .
We have  because ,
and .
Therefore,  and thus .
Therefore,  for .

 is decidable because,
for a -sequence ,  if and only if .

\end{proof}
\end{lemma}

In the following, we fix such a function
 and define  as in Lemma \ref{lemma:H}.
We identify  with , and
we consider that .
Each element of   contains  digits and  copies of .  Therefore, .
In addition,  every   has the same number of successors
.
Since  is finitely branching and tree-like,
by applying Proposition \ref{prop:tree-like}, we have a strictly increasing function 
and a partial surjective map  such that
 is mapped to .
In this case,  is the function .
 maps a tree in  to a tree-like subset of  ,
and injectively maps an infinite path in  to an infinite path in .
By using some bijection , we can represent a tree-like subset of  by its characteristic function, and we shall denote the represented space of tree-like subsets of  by .
Thus,  induces a computable partial map from  to , which we also denote by .



\begin{example}

  For the case of the Gray subbase  in Example \ref{ex:gray},  satisfies Lemma \ref{lemma:H}
and  satisfies Proposition \ref{prop:tree-like}.
Therefore,
 and  for every  .
 contains  in addition to the three elements of
.
 injectively maps  to , and
maps  elements of  to  elements of .
\end{example}

\begin{lemma}\label{lemma:lub}
\begin{enumerate}
\item    is a partially ordered set.

\item    is consistently complete.  That is, every pair  of consistent elements have
  their least upper bound  in .  We have .

\item   for every .
  More generally,
 for every  and .

\item  Every subset  of  has a greatest lower bound .
\end{enumerate}
\begin{proof}
\begin{enumerate}
\item  For ,  if   and ,
then  and  have the same level  and therefore
have the same length .

\item In , if , then their least upper bound  exists.   Therefore, for ,
   if , then
   .
   Thus, least upper bound  of  is obtained by adding some
    at the end of .

\item For ,
 because  for each .

holds if  by Proposition \ref{prop:compact} (3).
It holds for the case  because
 is empty for  such that  and .

\item From (2), every bounded subset of  has a least upper bound.
   Therefore, the set of lower bounds of , which is bounded by an element of , has a least upper bound, which is a greatest lower bound of .
 \end{enumerate}
\end{proof}
\end{lemma}

Note that Lemma \ref{lemma:lub} (2) does not imply that
 if ,
because
 can be empty for  though  is not empty for .

\subsection{Main theorem}

Now we obtain results corresponding to Corollary \ref{corr:nicefunctionscantor}  for CCCMS.


Let  be a CCCMS.
By Theorem \ref{theo:dyadicexists},  admits a proper computable dyadic subbase .  Let , , 
and  be as defined in the previous subsection for  and .
We define a subset  as



\begin{lemma}\label{lem:rhobracket}
  If , then  .
\end{lemma}
\begin{proof}
  By Proposition \ref{prop:bracket},
  \ref{prop:compact}(4). and \ref{prop:rho}(3).
\end{proof}



\begin{proposition}\label{prop:nicefunctionsgeneral}
Let  be a CCCMS.
There is a surjection  and a multivalued map  such that
\begin{enumerate}
\item  and  are computable.
\item .
\item For each , .
\end{enumerate}

\begin{proof}
For a finite subset  and , we simply say that  is a covering of  if
 is a covering of .

For , we define .
As  is effectively closed under finite unions and countable intersections,
and since  is recognizable, this does define a computable function.

For , we define  as follows.
We inductively define a computable strictly monotonic function  and
a sequence  of subsets  such that
 and that
 is a covering of .
Then, we define a tree-like subset  such that
 by defining for ,
. Finally, we set .



We start with  and .
We search for (in a dove-tailing way) finite coverings  of .
There are infinitely many such coverings, and
as  is computably compact, we will find each such covering eventually.

If we do find a new covering  at stage , then we consider
  Here,   exists because of Lemma \ref{lemma:lub} (2).
Because ,
.  That is,   is
a covering of , which is a refinement of both coverings  and .


We then choose  so that  and set

Note that  is decidable  by Proposition \ref{prop:decidable}.
Because of Lemma \ref{lemma:lub} (3), for ,
we have .
Therefore,
we have .
Thus,  is also
a covering of , which is a refinement of both coverings  and .

This procedure ensures that

is equal to the intersection of all finite basic open coverings of , which is equal to  in a compact Hausdorff space.  Therefore, we have .




Finally, we show that .
Let  be an infinite sequence such that
 and let  be its limit.
We first show that .
We have  by the definition of .  Therefore, if , then  for some .   It contradicts the construction because .   Suppose that  and .
Since  is computably regular by Theorem \ref{theorem:coregular} and computably compact,
there is a finite covering  that does not contain an element  such that .
If such a covering is found at stage ,  then,  no element of  contains both  and .
It contradicts to .  Thus, we have
 and suppose that .  We show .
Suppose that   for  and . Then,
since  is computably regular and computably compact, there is a finite covering  of  such that  for every .
We can assume that  for every , because
 means  and  we can remove such elements from  to have a covering of
.
Then,  is a covering of  and therefore is also a covering of .
Suppose that such a covering is found at stage .  Then, for every element  of ,
 implies .  Since , we have  and
we have  because .
Since it holds for every  such that , we have .
\end{proof}
\end{proposition}

\begin{theorem}
\label{theo:hereditary}Let  be a CCCMS.
There is a hereditary representation of .
\begin{proof}
  First, we define a computable function  from  to , which is a right inverse of .
  For  , we define .
We have  and
therefore it induces a tree  such that .  We define .
We have .

With the maps  and 
we defined in Proposition \ref{prop:nicefunctionsgeneral},
we define  as
.
Note that
 if  as we observed
after Proposition \ref{prop:tree-like}.  Therefore,
the value of  is determined not depending on which value of 
is used.  Let  be its multi-valued inverse
computed by the realizer of .
We have .
We define the representation  by restricting
the domain of  to the -names of .
Note that since  is a map to 
by Proposition \ref{prop:nicefunctionsgeneral}(3),
 is a map to the domain of , and therefore .








We show that  is hereditary. That is, if
 and  is a non-empty compact subset of ,
then .
Let  satisfy ,
, and  is a -name of  .
As the hereditarity of  shows,
if , then there exists  such that
.
Since  is monotonic in addition, we only need to show that
there exists a tree-like subset  such that  and .
We define .
 is a tree-like subset of  and therefore .
We need to show that .
By Lemma \ref{lem:rhobracket}, we show
.
If , then  satisfies  and we have  for every .
Suppose that  is the limit of a path  in . Since  for each ,
we have  and thus  by Proposition \ref{prop:rho}(3) and
Lemma \ref{lem:rhobracket}.
\end{proof}
\end{theorem}

We finally modify  to form a faithful representation  of .
For this purpose,
we modify  in the proof of Theorem \ref{theo:hereditary}
and construct 
so that, for a tree-like set  such that  is a singleton,
 is an infinite path  such that .

\begin{example}
  As the right half of Figure \ref{fig:G} shows,  contains a tree-like set  such that
 (and therefore )  and  for every .
 As the left half of Figure \ref{fig:G} shows,  contains a tree-like set  such that
 (and therefore )  and  for every .
 and  are binary trees which contain infinite number of paths
though  and  are singletons.
The new function  we will define chooses one infinite path from these tree-like sets, and converts them to infinite paths in .
\end{example}

\begin{lemma}\label{lem:sqcapsingle}
  Let  be a proper computable dyadic subbase of a CCCMS  and
  let  be a tree-like set such that  is a singleton.
  For each   there is  such that .

  \begin{proof}
    Let , ,  and .
    For each ,  is a tree-like subset of .  If  is infinite, then  there is an infinite path in  because  is finite-branching.
    Therefore, there is  such that  and it contradicts the fact that all the elements of
 are greater than or equal to  .
    Therefore,  is a finite set and there exists  such that  for every element of .   Let  be the maximal of .
    Then, for every  , .  Therefore, .
  \end{proof}
\end{lemma}

This lemma shows that the sequence  can be extended to an infinite path whose limit  satisfies .


\begin{theorem}\label{theo:minimalfaithful}
  Let  be a CCCMS. There is a faithful -representation of .
\begin{proof}
  In this proof, we  define another computable right inverse  of  such that if  then  is a tree with  infinite paths.





(i) Definition of .

Suppose that  is given.  We construct  by
inductively defining  for .
 satisfies the following condition.
 Let  be the
division of  into equivalence classes with respect to the transitive closure of ,
and  be their greatest lower bounds.  The condition is that
 is divided into    such that (1) ,
(2)  the greatest lower bound (i.e., longest common prefix)  of  satisfies
,   and (3) .



First, set .  Suppose that  is defined and it satisfies the above condition.  Let  be the division of
 into equivalence classes with respect to the transitive closure of , and
   be their greatest lower bounds.  Since ,  and
   impliy , for each , there is an equivalence class  of 
  such that every element of  is greater than an element of .
Let  be the greatest lower
  bound of . By induction hypothesis, for the greatest lower bound  of , we have .  On the other hand, we have  because  is a lower bound
  of .  Therefore, we can choose 
such that  by Proposition \ref{prop:tree-like}.
Now, we select such a  for each , and
define .  Then, we define
.

We show that  .  For , since  and ,
there exists  such that  and  again by Proposition \ref{prop:tree-like}.
Since , we have  by condition (3) of .  Next, we show that
.    Set .
Suppose that .
Since  is a prefix of  and  is a prefix of ,  is a prefix of .
Therefore,  is a prefix of  and thus we have .
Thus,  induces a
  tree  such that , and we define .
One can see from this construction that
   is a computable map.
We have   because .

(ii) If , then  is a tree with  infinite paths.

We first study the case that  is a singleton.
By Lemma \ref{lem:sqcapsingle}, for each , there is  such that the level of  is greater or equal to .
Among the equivalence classes of 
with respect to the transitive closure of , only one of them, which we call , contains an element less than .  It means that
only elements in  can be extended to infinite paths.

From the definition of ,  there is  such that .
Note that  is the only element in  that can be extended to an infinite path in 
beause  by condition (3) of .
Therefore,  is extended to the only infinite path in .


If  contains  points, then there exists  such that for each ,
 is divided into  equivalence classes  with respect to the transitive closure of .  Therefore,  has  infinite paths with a similar argument.


(iii) Definition of .

We define the multi-valued map  through  the realizer of .  Set


Suppose that .  Then, for ,   is a tree with  paths by (ii).  Therefore,  has  copies of  and .   Therefore, .
Suppose that  is infinite. Since , we have .
Thus,  is a computable map to .
Now, we define the representation  as the restriction of  to .

(iv)  is faithful.

First, we show that
condition (1) and (2) of  Definition \ref{def:faithful} are satisfied
if  is a -point set.
(1) is satisfied since  is restricted to  .
(2) is satisfied because all the infinite paths of a tree-like set  are in , and
that  is a faithful map.
In order to show that  is hereditary, compared with the proof that
 is hereditary in Theorem \ref{theo:hereditary},
we only need to see that if  is an infinite set and  is a -point set, then there is  such that .
It is done by selecting, for each element of ,  one infinite path from .
\end{proof}
\end{theorem}


\section{Applications to finite closed choice}
\label{sec:weihrauch}
As mentioned in the introduction, an initial goal of our explorations was to better understand and to generalize a construction from \cite{paulyleroux}. The construction was used to show that the difficulty of selecting a point from a closed subset of cardinality equal to (at most)  from a computably rich computably compact computable metric space  does not depend on the choice of . The original construction crucially depended on knowledge of , and thus did not extend to the task of selecting a point from a finite closed set. Based on Theorem \ref{theo:minimalfaithful}, we can fill this gap.

These considerations belong to the investigation of closed choice principles in the Weihrauch lattice. Closed choice principles are used to calibrate non-computable tasks where (provided with a suitable certificate) incorrect solutions can be effectively rejected, and some guarantees on the set of solutions are given. In our context, these guarantees are that the solutions belong to compact metric spaces, and that each instance has only finitely many correct solutions (plus certificates). For an survey of Weihrauch reducibility, and the definition of all terms left undefined here, we refer to \cite{pauly-handbook}. The important role of close choice principles was noted in \cite{paulybrattka}.

\begin{definition}
For a represented space , closed choice  is defined via  iff . By  and  we denote the restriction of  to sets of cardinality up to  and equal to  respectively. By  we denote the restriction of  to finite sets.
\end{definition}

\begin{definition}
\label{def:concretize}
Let  be defined via  iff . Let  be the restriction of  to .
\end{definition}

\begin{corollary}
Let  be a computably rich CCCMS. Then

\begin{proof}
\begin{description}
\item[] By using a faithful representation for  from Theorem \ref{theo:minimalfaithful}, we can apply  to the input for  and obtain a singleton subset. By admissibility of , we can then extract the point from the singleton.
\item[] Given  we can compute . The claim follows from the definition of  in Definition \ref{def:concretize}.
\item[] As  is computably rich, by definition it contains a copy of  as a computable closed subspace.
\end{description}
\end{proof}
\end{corollary}

By  (all-or-unique choice) we denote the restriction of  to . The degree  was studied first in \cite{paulyincomputabilitynashequilibria}, where it was found to relate to the complexity of finding Nash equilibria in bimatrix games. Further results on  are available in \cite[Section 16 \& 17]{hoelzl} and \cite{pauly-kihara2-mfcs}.

\begin{proposition}
.
\begin{proof}
Note that  is a cylinder, so if , then already . Assume this would hold. Consider the input  to . This will be mapped to some finite set . The outer reduction witness  can be lifted to compact sets. Let  be the inner reduction witness. From  we can compute , in particular . Since , at some finite time some non-empty open ball  is removed from . But at that moment, we can still alter the name for  to a name for  for some , and the reduction cannot adapt. Thus,  cannot hold.
\end{proof}
\end{proposition}

By  we denote the restriction of  to connected sets. Clearly, for a connected space  we find that . The degrees  are equivalent to Brouwer's fixed point theorem for  as shown in \cite{paulybrattka3}.

\begin{corollary}
.
\end{corollary}

\subsection{Generalized register machines}
Building on Tavana and Weihrauch's \cite{tavana}, Neumann and Pauly \cite{paulyneumann} introduced the operator  on Weihrauch degrees. Roughly spoken,  is the universal problem for register machines using computable operations and tests, together with  as primitive operations. Thus, we can view a Weihrauch reduction to  as a uniformly computably procedure that solves the problem by making finitely many oracle calls to . This notion was studied as generalized Weihrauch reducibility by Hirschfeldt and Jockusch \cite{hirschfeldt,hirschfeldt2}.

\begin{proposition}
\label{prop:cinftydiamond}
.
\begin{proof}
Given some input  to , we make an oracle guess . Then we simulate the generalized register machine . Each time  calls its oracle , we split the oracle into two parts  and use  as putative output of  , and  as new oracle. Once  terminates, we check that the current oracle is equal to . In addition, we check that all outputs of  were guessed correctly.

We need to argue that there are finitely many valid guesses. As each oracle use has only finitely many correct answers, and since every computation of  is finite, the potential computation paths of  form a finitely branching tree without infinite paths, hence a finite tree. Once all oracle calls are taken care of, only  remains as the unique correct guess.
\end{proof}
\end{proposition}

\begin{proposition}
\label{prop:cleqdiamond}

and

\begin{proof}
In each case, the second equivalence was already shown in \cite{paulyleroux}, and the reduction from the right-most degree to the left-most is trivial. We thus only need to show that  and .

Similar to the argument in Proposition \ref{prop:cinftydiamond}, consider the computation tree of a generalized register machine  making oracle calls to  (respectively ). We know that the branching factor of the computation tree at the oracle calls is exactly two (respectively at most two). By Weak K\"onig's Lemma, the depth of the computation tree is bounded, and we can in fact effectively compute some upper bound  on its depth. We then use  as first component of the input to  (respectively  as input to ).

In the former case, we can simply feed the same set of guesses constructed in the proof of Proposition \ref{prop:cinftydiamond} to , as the upper bound is guaranteed to be correct, and that is all that is required. In the latter case, we keep refining the computation tree. Each time we learn that one of the up to  many oracle calls in the computation tree is not actually happening, we duplicate all remaining points in the input set. This ensures that in the end, we produce a set of the correct cardinality.
\end{proof}
\end{proposition}

\begin{corollary}

\begin{proof}
The first reduction is trivial. That it is strict follows from  shown in \cite{paulyleroux} and Proposition \ref{prop:cleqdiamond}. The second reduction follows from Proposition \ref{prop:cinftydiamond}. We can see that it is strict by first observing that  would imply . As  is a fractal, that in turn implies  for some . But that is a contradiction to  established in \cite{paulyleroux}.
\end{proof}
\end{corollary}
\subsection{A digression on and comparison with }
\begin{definition}
Let  be defined via  iff , and , where , , etc, and  is the least witness of .
\end{definition}

Let  denote the restriction of  to .  was introduced and studied in \cite{paulyneumann}, and then generalized to  in \cite{hoelzl2}.

\begin{proposition}
.
\begin{proof}
: \quad Given a -instance , we compute   instances  by letting  be the result of replacing each digit less than  in  by , and each digit greater-or-equal to  by . If  are the outputs of , we compute a suitable output  of  by reading through all  in lock-step. By construction,  will switch from  to  prior to  (if they switch at all). In , we write s as long as none switches, then s after  switched until  switches, and so on.

: \quad Given  -instances  we compute a -instance . Since adding a digit of value  to  has no impact, we do so often enough to ensure an infinite sequence. We add the -th digit  to  as soon as we find that -many of the  have an -th digit .

Let . Each  in  indicates that all  have one more , so we compute the sorted versions of the  by first copying the s of  to each . If  then changes from  to , this indicates that amongst the  exactly one has no further s. We can wait until we find another  in -many, and then continue the other  by . Then as long as we read  in , each remaining  is extending by . Once  switches to , we know than again exactly one  has no further s, and we identify the correct one by ing for s in the others. (If  jumps directly from  to , the two steps are just merged into one). We continue like this for the other potential switches in .
\end{proof}
\end{proposition}

\begin{corollary}
\label{corr:sortvariants}
.
\end{corollary}

\begin{proposition}
.
\begin{proof}
By Corollary \ref{corr:sortvariants}, we can show  for the first reduction. The reduction follows since each  is a restriction of . To show strictness, assume that . As  is easily seen to be a fractal, -irreducibility implies that there is some  with , so in particular, . But this was shown to be false in \cite{paulyneumann}.

Using , we can see  by asking all countably many questions of the form \emph{Are there at least  occurrences of  in the input?} (each of them is equivalent to ), and then computing the solution to  from that in the obvious way. To see that the reduction is strict, note that  outputs only computable points, whereas  has to output the Halting problem for some computable input.
\end{proof}
\end{proposition}

\begin{proposition}
.
\begin{proof}
\begin{description}
\item[] Straightforward.
\item[] For any  the set  containing all  that have exactly  many 's and infinitely many 's is a -set. Being in the domain of  means being contained in a . With  we can, given , find some  such that . Then computing  is straightforward.
\item[] See \cite{paulybrattka5}.
\item[] We can view  as the following task: \emph{Given a sequence  with  such that some  contains infinitely many s, find such an .} From such an input to  we compute some  by listing  in  whenever we find another  in . The promise on the input to  ensures that . Now  is an eventually constant sequence, and we can use  to find the last index at which  changes. With that index, we can find which digit is repeated infinitely often in , and this digit constitutes a valid output to .
    \end{description}
\end{proof}
\end{proposition}

\begin{proposition}
.
\begin{proof}
For each , let  be an effective enumeration of all prefix-independent -tuples of finite words. Given , we will write the -th  to the input to  as soon as we have found for each  some  such that  (this condition is semidecidable). If , then for each  we will eventually reach some -tuple  such that each  contains a point, whereas each -tuple will eventually be enumerated. In particular, we do indeed produce a valid input to .

As , we know that the output  of  is not . Thus, we can compute the maximal  such that  is a prefix of . Then we know that . We write , and attempt to compute the unique , writing any confirmed prefix to the output. Simultaneously we search for the maximal  such that  is a prefix of .

If , then the process will proceed to fully write a correct solution. If , we will find a maximal . Let  be the prefix of the output written so far (we know this to be correct). Then we know that  and . If  is compatible with one of  and , then we attempt to compute the unique extension of  in  respectively , while searching for a maximal  such that  is a prefix of . If the process continues for ever, we correctly write a solution. Otherwise, some maximal  must exist. If  is compatible with neither of  and , then , and we know that a maximal  exist, which we search for straight-away.

We continue this process. At the latest once we have found the maximal , we will attempting to compute the unique point in a singleton, and thus the computation will succeed.

That the reduction is strict follows from ,  and .
\end{proof}
\end{proposition}

\section*{Acknowledgements}
We are grateful to Matthew de Brecht for helpful discussions.

 \begin{minipage}{0.1\textwidth}\includegraphics[width=\textwidth]{eu-flag-png}\end{minipage} \begin{minipage}{0.9\textwidth} This project has received funding from the European Union's Horizon 2020 research and innovation programme under the Marie Sklodowska-Curie grant agreement No 731143, \emph{Computing with Infinite Data}.\end{minipage}

 This work also benefited from the Marie Curie International Research Staff Exchange Scheme \emph{Computable
Analysis} (PIRSES-GA-2011- 294962).
 The second author was partially supported by the JSPS Core-to-Core Program (A.
Advanced research Networks) and JSPS KAKENHI Grant Number 15K00015.





\bibliographystyle{eptcs}
\bibliography{../spieltheorie}



\end{document}
