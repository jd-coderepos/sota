

\documentclass[10pt]{article}

\usepackage{a4wide}


\usepackage{amsmath}
\usepackage{amsthm}


\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pstricks}



\newcommand{\probtitle}[1]{\textsc{#1}}


\newcommand{\qedfill}[0]{ }

\newtheorem{remark}{Remark}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}


\begin{document}

\newcommand\thetitle{The firefighter problem with more than one firefighter on trees}

\title{\textbf{\thetitle}}
\author{Cristina Bazgan \and Morgan Chopin \and Bernard Ries\\
 {\small Universit\'{e} Paris-Dauphine, LAMSADE,}\\
  {\small Place du Marchal de Lattre de Tassigny, 75775 Paris Cedex 16, France.}\\
  {\small \{bazgan, chopin, ries\}@lamsade.dauphine.fr }\\
 }

\date{ }

\maketitle












\begin{abstract}
In this paper we study the complexity of the firefighter
problem and related problems on trees when more than one firefighter is available at each time
step, and answer several open questions of \cite{finbow2009}.
More precisely, when  firefighters are allowed at each time step, the problem is NP-complete
for trees of maximum degree  and polynomial-time solvable for trees of
maximum degree  when the fire breaks out at a vertex of
degree at most . Moreover we present a polynomial-time algorithm for a subclass of trees, namely -caterpillars.
\end{abstract}






\section{Introduction}

Modeling a spreading process in a network is a widely studied topic and often relies on a graph theoretical approach (see \cite{chen2008,dreyer2009,finbow2009,kempe2003,ng2008,scott2006}). Such processes occur for instance in epidemiology and social sciences. Indeed, the spreading process could be the spread of an infectious disease in a population 
or the spread of opinions through a social network. Different objectives may then be of interest, for instance minimizing the total number of 
infected persons by vaccinating at each time step some particular individuals, or making sure that some specific subset of individuals does not get infected at all, etc...

The spreading process may also represent the spread of a fire. The associated firefighter problem, introduced in \cite{hartnell1995}, 
has been studied intensively in the literature (see for instance \cite{anshelevich2009,cai2008,develin2007,finbow2007,finbow2009,hartnell1995,hartnell2000,IKM11,king2010,macgillivray2003,ng2008}). In this paper, 
we consider some generalizations and variants of this problem which is defined as follows.
Initially, a fire breaks out at some special
vertex  of a graph. At each time step, we have to choose one
vertex which will be protected by a firefighter. Then the fire
spreads to all unprotected neighbors of the vertices on fire. The
process ends when the fire can no longer spread, and then all
vertices that are not on fire are considered as saved. The
objective consists of choosing, at each time step, a vertex which
will be protected by a firefighter such that a maximum number of
vertices in the graph is saved at the end of the process. 

The firefighter problem
was proved to be NP-hard for bipartite graphs
\cite{macgillivray2003}. Much stronger results were proved later
\cite{finbow2007} implying a dichotomy: the firefighter problem is
NP-hard even for trees of maximum degree three and it is solvable
in polynomial-time for graphs with maximum degree three, provided
that the fire breaks out at a vertex of degree at most two.
Moreover, the firefighter problem is NP-hard for cubic graphs
\cite{king2010}. From the approximation point of view, the
firefighter problem is -approximable on trees \cite{cai2008} and
it is not -approximable on general graphs for any 
\cite{anshelevich2009}, if P NP. Moreover for trees where vertices have at most three children, 
the firefighter problem is -approximable \cite{IKM11}. Finally, the firefighter problem is polynomial-time solvable for caterpillars and P-trees \cite{macgillivray2003}.

A problem related to the firefighter
problem, denoted by {\sc -Fire}, was introduced in
\cite{king2010}. It consists of deciding if there is a strategy
of choosing a vertex to be protected at each time step such that  all vertices
of a given set  are saved. {\sc -Fire} was proved to be
NP-complete for trees of maximum degree three in which every leaf is
at the same distance from the vertex where the fire starts and  is the set of leaves.

In this paper, we consider a generalized version of {\sc
-Fire}. We denote by {\sc -Save}, where  is an integer,
the problem which consists of deciding if we can choose at most  vertices
to be protected by firefighters at each time step and save all the vertices
from a given set . Thus, {\sc -Fire} is equivalent to {\sc -Save}.
The optimization version of {\sc -Save} will be denoted by {\sc Max -Save}.
This problem consists of choosing at most  vertices to be protected at each time
step and saving as many vertices as possible from a given set . Hence, {\sc Max -Save}
corresponds to the firefighter problem when  is the set of all vertices of the graph.
{\sc Max -Save} is known to be 2-approximable for trees  when  is the
set of all vertices \cite{hartnell2000}. 

A survey on the firefighter problem and related problems can
be found in \cite{finbow2009}. In this survey, the authors presented a list of
open problems. Here, we will answer three of these open questions (questions 2, 4, and 8).

The first question asks for finding algorithms and complexity results of {\sc -Save}
when . We show that for any fixed , {\sc
-Save} is NP-complete for trees of maximum degree  when  is the set of all leaves. Moreover, we show that for any fixed ,
{\sc Max -Save} is NP-hard for trees of maximum degree  when  is the set of all vertices.
Finally, we show that for any , {\sc -Save} is polynomial-time solvable for trees of
maximum degree  when the fire breaks out at a vertex of degree at most .

The second question asks if there exists a constant  such that the greedy strategy of protecting, at each time step, a vertex of highest degree adjacent to a burning vertex gives a polynomial-time -approximation for the firefighter problem on trees. We give a negative answer to this question.

Finally, the third question asks for finding classes of trees for which the firefighter problem can be solved in
polynomial time. We present a polynomial-time algorithm to solve {\sc Max -Save}, , in -caterpillars a subclass of trees.



Our paper is organized as follows.
Definitions, terminology and preliminaries are given in  Section~\ref{s:prelim}.
In Section~\ref{s:trees} we establish a dichotomy on the complexity of {\sc -Save} and show that the greedy strategy mentioned above gives no approximation guarantee. In Section~\ref{s:caterpillars} we  show that \textsc{Max -Save} is polynomial-time solvable for
-caterpillars. Some variants of the \textsc{Max -Save} problem are considered in Section~\ref{s:variants}. Conclusions are given in Section~\ref{s:concl}.


\section{Preliminaries} \label{s:prelim}


All graphs in this paper are undirected, connected, finite and simple. Let  be a graph. An edge in  between vertices  will be denoted by . The \textit{degree} of a vertex , denoted by , is the number of edges incident to .
We write  for the subgraph obtained by deleting a vertex  and all the edges incident to . Similarly, for , we denote by  the subgraph of  obtained by deleting the set  and all the edges incident to some vertex in .

\medskip

In order to define the firefighter problem, we use an undirected graph
 and notations of \cite{anshelevich2009}. Each
 vertex in the graph can be in exactly one of the following states:
\textit{burned}, \textit{saved} or \textit{vulnerable}. 
A vertex is said to be burned if it is on fire.
We call a vertex saved if it is either protected by a firefighter --- that is the vertex cannot be burned in subsequent time steps --- or if all paths from any burned vertex to it contains at least one protected vertex.
Any vertex which is neither saved nor burned is called vulnerable.
At time step , all vertices are vulnerable, except vertex ,
which is burned. At each time , at most  vertices can be protected by firefighters and any vulnerable vertex  which is adjacent to a burned
vertex  becomes burned at time , unless it is protected at time step . Burned and saved vertices
remain burned and saved, respectively.

\medskip

Given a graph  and a vertex   initially on fire, a \textit{protection strategy} is a set  where  . We say
that a vertex  is protected at time  according to the
protection strategy  if . A protection
strategy is \textit{valid} with respect to a budget , if the
following two conditions are satisfied:

\begin{enumerate}
\item if  then  is not burned at time ;
\item let ; then  for .
\end{enumerate}





Thus at each time , if a vulnerable  vertex  is adjacent to at least one burned vertex and , then  gets burned at time .




\medskip
We define in the following the problems we study.

\medskip
\noindent
 {\sc -Save}

\noindent\textbf{Input}: An undirected graph , a burned vertex , and a subset .

\noindent\textbf{Question}: Is there a valid strategy
 with respect to budget  such that all vertices from  are saved?


\medskip
\noindent 
{\sc Max -Save}

\noindent\textbf{Input}: An undirected graph , a burned vertex , and a subset .

\noindent\textbf{Output}: A valid strategy   with respect to budget  which maximizes the number of saved vertices that belong to .\\


In the figures of the paper, the burned vertices are represented by  black vertices and the vertices from  are represented by . A protected vertex is represented by .

\medskip

Notice that the NP-hardness of {\sc -Save} implies the NP-hardness of {\sc Max -Save}. Furthermore, if {\sc Max -Save} is solvable in polynomial-time then so is {\sc -Save}.





\section{Trees} \label{s:trees}


It has been shown in \cite{finbow2007} that {\sc -Save} is NP-complete for trees of maximum degree three using a reduction from not-all-equal 3SAT. Furthermore, {\sc -Save} is polynomial-time solvable for graphs of maximum degree three if the fire breaks out at a vertex of maximum degree two. In this section we generalize these results for any fixed .

First of all, we need to define some notions. Let  be a tree and let  be the vertex which is initially burned. From now on,  will be considered as the root of . We define the \textit{level}  of  to be the set of vertices that are at distance exactly  from . The \textit{height} of  is the length of a longest path from  to a leaf. An \textit{ancestor} (resp. \textit{descendant}) of a vertex  in  is any vertex on the path from  to  (resp. from  to a leaf). A \textit{child} of a vertex  in  is an adjacent descendant of . The tree  is said \textit{complete} if every non-leaf vertex has exactly the same number of children.

\begin{remark}
\label{rem:relstrat}
Without loss of generality, we may assume that strategies do not protect a vertex that has a protected ancestor in a tree.
\end{remark}

\begin{remark}
\label{rem:sleave}
For \textsc{-Save} on trees, we may assume without loss of generality that  is the set of leaves. Otherwise for each non-leaf vertex , since we have to save , we can remove the subtree rooted at  such that  becomes a leaf.
\end{remark}

We denote by  a complete tree of height  and root  such that every non-leaf vertex has exactly  children and every leaf is at the same distance from the root (see Figure \ref{fig:gadget1}).


\begin{figure}[!h]

\begin{center}
\begin{picture}(0,0)\includegraphics{gadget1.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1276,884)(2333,-1914)
\put(2926,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{}}}}}
\end{picture} \end{center}

\caption{.}
\label{fig:gadget1}

\end{figure}


For such a tree we obtain the following property.

\begin{lemma}
\label{lem:gadget}
Let  be the number of available firefighters at each time step. Consider a complete tree  . If the fire breaks out at , then at least one leaf will not be saved.
\end{lemma}

\begin{proof}
Since each non-leaf vertex has exactly  children, it follows that at each time step there will be at least one new burning vertex. Thus at the end of the process, at least one leaf will be burned.\qedfill
\end{proof}

\noindent
We also give the following preliminary results.

\begin{lemma}
\label{lem:adj}
Among the strategies that save all the leaves (resp. a maximum number of a given subset of vertices) of a tree, there exists one such that each protected vertex is adjacent to a burning vertex.
\end{lemma}

\begin{proof}
This is a straightforward adaptation of observation 4.1 in \cite{macgillivray2003}.\qedfill
\end{proof}



\begin{lemma}
\label{lem:room}
Let  be a tree and let  be a strategy that saves all the leaves of  using at most  firefighters at each time step. Suppose there exists levels  and  containing  and  firefighters, respectively. Then there exists a strategy  saving all the leaves of  and such that levels  and  contain  and  firefighters, respectively.
\end{lemma}

\begin{proof}
Let  be a protected vertex by strategy  at a level , and let  be the ancestor of  at level . It follows from Remark \ref{rem:relstrat} that we may assume that  is not protected. We transform strategy  into a strategy  as follows (see Figure \ref{fig:umbrella}): protect  at time step  and do not protect  at time step , that is . Since  is an ancestor of , it follows that using strategy , we save a subset of vertices that contains the vertices saved by using . Since level  contains at most  firefighters it follows that  is a valid strategy that saves all the leaves of  and levels  and  contain respectively  and  firefighters.
\begin{figure}[!h]

\begin{center}
\begin{picture}(0,0)\includegraphics{umbrella.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3132,1341)(-596,-2641)
\put(-44,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(586,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(1891,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2521,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(586,-2221){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(2521,-2221){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(-359,-1771){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-179,-2131){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}

\caption{Moving up a firefighter leads to a strategy that saves at least the same set of leaves.}
\label{fig:umbrella}

\end{figure}
\qedfill
\end{proof}



\noindent
We now give the main result of this section.

\begin{theorem}
\label{th:npc}
For any fixed , \textsc{-Save} is NP-complete for
trees of maximum degree .
\end{theorem}

\begin{proof}
Clearly, \textsc{-Save} belongs to NP. In order to prove its NP-hardness,
we use a polynomial-time reduction from \textsc{-Save}
for trees of maximum degree  to \textsc{-Save} for
trees of maximum degree , for any . Since \textsc{-Save} is NP-hard for  (see \cite{king2010}), it follows that \textsc{-Save} is NP-complete for any fixed .

Let  be an instance of \textsc{-Save} consisting of a tree
 of maximum degree  rooted at some vertex  and a subset  which corresponds
to the set of leaves. Let  be the height of . We construct an instance  of
\textsc{-Save} consisting of a tree  of maximum degree  rooted at some vertex  and a subset  which corresponds to the leaves of  as follows (see Figure \ref{fig:ssavereduc1}): add a vertex ; add two paths , , make  adjacent to  and make  adjacent to ; add vertices  and make them adjacent to ; for every vertex , , add vertices  and make them adjacent to ; for  add a path  and make  adjacent to . This clearly gives us a tree  of maximum degree  rooted at vertex  and the set of leaves  is given by .





\medskip
We prove now that there exists a strategy  for  that
saves all the vertices in  if and only if there exists a
strategy  for  that saves all the vertices in
.

\medskip
Suppose there exists a strategy  for  that saves all the
vertices in . In order to save all vertices in , we will
apply strategy  defined as follows: at time step
, we have to protect the vertices ; at each
time step , we have to protect the vertices ; thus after time step , vertex  is burning as well as vertices  ; at each time step , we protect the vertices in  according to  and we use the additional firefighter to protect the leaf . This clearly gives us a valid strategy 
saving all the vertices in .




\medskip
Suppose now that there exists a strategy  for  that
saves all the vertices in . At time step , this strategy necessarily consists in protecting vertices . Furthermore, at each time step , we have to protect the vertices . It follows from Lemma~\ref{lem:adj} that we may assume that 
is a strategy which, at each time step, protects vertices adjacent to burning vertices.
Thus  protects, at each time step , at most  vertices at level  in 
for .
Let  be the number of firefighters in the subtree  of  at level  used by  and let .
If , then for any ,  and thus the strategy , restricted to the tree , is a valid strategy for  that saves
all the leaves of . So we may assume now that .


Let  be the  smallest value in .
Consider the case . Suppose that for any ,
. From the definition of , it follows that we cannot
have , thus  for any . By
construction, this means that, at each time step , the
additional firefighter protects the vertex , .
At time step , since , the vertex
 is not protected and burns which is a contradiction. Thus
there exists a level  such that .
It follows from Lemma~\ref{lem:room} that there exists a strategy saving the leaves of 
such that  and . Applying this argument
iteratively for , we obtain a strategy  that saves all the
vertices in  and such that for any level , . Thus, the strategy  restricted to the tree
 is a valid strategy that saves all the leaves of .
\end{proof}


\begin{figure}[!h]

\begin{center}
\begin{picture}(0,0)\includegraphics{ssavereduc3.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3855,2583)(1066,-2218)
\put(3241,-61){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4906,-331){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(4906,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(4906,-1321){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(4906,-2041){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(1396,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1846,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2296,-1816){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-106){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-376){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4906,-61){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(1081,-196){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1486,-196){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2431,254){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1351,-1276){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1801,-1276){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3511,-331){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-916){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4906,-871){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(4321,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3286,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4096,-2176){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2971,-1456){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2904,-241){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3184,-511){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3985,-1233){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3619,-1051){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3736,-1996){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}
\caption{The construction of .}
\label{fig:ssavereduc1}

\end{figure}










Theorem \ref{th:npc} implies that \textsc{Max -Save} is NP-hard for trees of maximum degree  when  is the set of leaves.
Notice that Theorem \ref{th:npc} does not imply that \textsc{Max -Save} is NP-hard when  is the set of all vertices. However, the following theorem shows
that this is indeed the case.



 \begin{proposition}
 For any fixed , \textsc{Max -Save} is NP-hard for
 trees of maximum degree  when  is the set of all vertices.
 \end{proposition}

\begin{proof}
 We construct a polynomial-time reduction from \textsc{-Save} to \textsc{Max -Save} where .  
 Let  be an instance of \textsc{-Save} consisting of a tree
  of maximum degree  with , a burned vertex , and a subset  which corresponds
 to the set of leaves. We construct an instance  of
 \textsc{Max -Save} consisting of a tree , a set , and a positive integer  as follows (see Figure \ref{fig:maxsavereduc}). For every leaf  of , add  copies , \ldots,  of the tree  such that the root  of  is adjacent to , for . Let  denote the cardinality of each of those trees. Notice that each tree  has  vertices. Set . We will prove that there exists a strategy for  that saves all the vertices in  if and only if there exists a strategy for  that saves at least  vertices in .

 Suppose there exists a strategy  for  that saves all the vertices in . Since  is the set of all
 leaves in , it follows that the strategy  applied to  saves all the vertices of the trees . Notice that we have  such trees. Thus  saves at least  vertices in .

Conversely, suppose that no strategy  for  can save all the vertices in . Thus, at least one leaf of  is burned at the end. This necessarily implies that for any strategy  for  there is at least one vertex, say , of  which is burned. It follows from the construction of , that in this case there are at least  vertices which will be burned for strategy . Thus  saves at most  vertices.
\end{proof}

 \begin{figure}[!h]
 \begin{center}
 \begin{picture}(0,0)\includegraphics{maxsavereduc.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1734,1536)(2419,-1363)
\put(3196,-736){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3061,-1321){\makebox(0,0)[lb]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3331,-1321){\makebox(0,0)[lb]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2791,-1321){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3331, 74){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,-466){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}  \end{center}
 \vspace*{-0.5cm}
 \caption{Construction of  from the tree  for the case .}
 \label{fig:maxsavereduc}
 \end{figure}


The following proposition shows that the sharp separation between the NP-hardness and polynomiality of \textsc{-Save} on trees pointed out in \cite{king2010} is preserved for any fixed .

\begin{proposition}
\label{prop:polytree}
Let  be any fixed integer and  a tree of maximum degree . If the fire breaks out at a vertex
of degree at most  then all the leaves of  can be saved if and only if  is not complete. Thus \textsc{-Save} is polynomial-time solvable for trees of maximum degree  if the fire breaks out at a vertex of degree at most .
\end{proposition}

\begin{proof}
Notice that in this case we protect the vertices such that there is at most one new burning vertex  at each time step. Moreover, the fire stops when the vertex  has degree at most .

Suppose that  is not complete. Then there exists a non-leaf vertex  of degree at most . From the previous remark we can direct the fire from  to  and stop it. Hence all the leaves of  are saved.

Suppose that  is complete. Then at each time step, there is at least one new burning vertex. Thus there will be
a leave which will burn at the end of the process.

Clearly, verifying whether a tree is complete can be done in polynomial-time.\qedfill
\end{proof}

\begin{remark}
Notice that Proposition \ref{prop:polytree} also holds for \textsc{Max -Save}. Given a subset  of vertices, we direct the fire to a vertex of degree at most  such that the number of burned vertices in  is minimum.
\end{remark}

In \cite{finbow2009}, the authors asked whether there exists a constant  such that the degree greedy algorithm that consists, at each time step, to protect a highest degree vertex adjacent to a burning vertex, gives a polynomial-time -approximation for \textsc{Max -Save} for trees. The following proposition answers this question in the case when  firefighters are available at each time step for any .

\begin{proposition}
For any , there exists no function  such that the degree greedy algorithm is an -approximation algorithm for \textsc{Max -Save} for trees where  is the set of all vertices. 
\end{proposition}

\begin{proof}
Consider a tree  where  is a positive integer. Add a vertex  adjacent to  and a vertex  adjacent to ; for , add a path of length  with endpoints  and  such that  is adjacent to ; finally, for , add  vertices adjacent to  (see Figure \ref{fig:greedegree}).

Notice that the degree greedy algorithm protects vertices in the following order: . Thus it saves  vertices. However, it is not difficult to see that the optimal solution protects vertices  in the following order: . Thus, in an optimal solution we save  vertices. Since  when , the result follows.
\end{proof}

\begin{figure}[!h]
\begin{center}
\begin{picture}(0,0)\includegraphics{greedegree.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3488,1952)(1568,-1464)
\put(3241,389){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5041,119){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(5041,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(5041,-151){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(5041,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}level }}}}}
\put(1846, 29){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476,-151){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1846,-1141){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2476, 29){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3061, 29){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,164){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}
\caption{Instance where the degree greedy algorithm gives no approximation guarantee for the case . Since here , we did not represent vertices in  by squares.}
\label{fig:greedegree}
\end{figure}













\section{-caterpillars}\label{s:caterpillars}
 
In this section, we will present a subclass of trees for which \probtitle{Max -Save} is polynomial-time solvable for .

A \textit{caterpillar} is a tree  such that the vertices of  with degree at least  induce a path. In other words, a caterpillar  consists of a path  such that all edges have at least one endpoint in . A \textit{-caterpillar}, , is a caterpillar in which any pending edge , with ,  (\textit{i.e.,} any edge with exactly one endpoint in ) may be replaced by a path of length at most  (see Figure \ref{fig:caterstar}). This path is then called a \textit{leg} of the -caterpillar at vertex . Thus a caterpillar is a -caterpillar.

A \textit{star} is a tree consisting of one vertex, called the \textit{center} of the star, adjacent to all the others. Thus a star on  vertices is isomorphic to the complete bipartite graph . A \textit{-star}, , is a tree obtained from a star in which any edge may be replaced by a path of length at most  (see Figure \ref{fig:caterstar}). Thus a star is a -star.
Notice that a -star is a special case of a -caterpillar

\begin{figure}[!h]
\begin{center}
\begin{minipage}{.90\linewidth}
   \begin{minipage}{.46\linewidth}
   \begin{center}
      \begin{picture}(0,0)\includegraphics{star.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(781,871)(5168,-3804)
\end{picture}    \end{center}
   \end{minipage}
   \begin{minipage}{.46\linewidth}
   \begin{center}
      \begin{picture}(0,0)\includegraphics{cater.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(1546,646)(5168,-3624)
\end{picture}    \end{center}
   \end{minipage}
\end{minipage}
\end{center}

\caption{A -star (left) and a -caterpillar (right).}
\label{fig:caterstar}

\end{figure}

In \cite{macgillivray2003}, the authors showed that the degree greedy algorithm gives an optimal solution for \probtitle{Max -Save} on caterpillars when . However, this result does not hold
for -caterpillars, see for instance Figure \ref{fig:caternopt}.

\begin{figure}[!h]
\begin{center}
\begin{picture}(0,0)\includegraphics{carternopt.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(3935,1056)(3008,-568)
\put(5941,389){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3691,389){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}

\caption{A -caterpillar for which the degree greedy algorithm (left) does not give the optimal solution (right). Since here , we did not represent vertices in  by squares.}
\label{fig:caternopt}

\end{figure}

In this section,
we give a polynomial-time algorithm for \probtitle{Max -Save} for -caterpillars for any  and . In order to prove our main result of this section we first need to show the following.

\begin{theorem}
\label{th:maxbssave_kstar}
For any , , \probtitle{Max -Save} is polynomial-time solvable for -stars.
\end{theorem}

\begin{proof}
We construct a polynomial-time reduction from \probtitle{Max -Save} to the \probtitle{Min Cost Flow} problem which is known to be polynomial-time solvable (see for instance \cite{orlin}).
Let  be a -star. First assume that  is the center of . Let . Let  ,   be the maximal paths of  starting at vertex , with  and , for , if it exists. Let . For each vertex  in these paths, we define . Notice that we may assume that every path  contains at least one vertex of  (otherwise we may delete ).

We construct an auxiliary digraph  (see Figure \ref{fig:mincostflow}), where   and . In this digraph , we associate with each arc , a cost . All other arcs have cost zero. Furthermore we associate with each arc  a capacity , with each arc  a capacity  and with each arc  a capacity . Finally we associate a supply of value  with vertex  and a demand of value  with vertex  (all other vertices have a supply and a demand equal to zero). Thus we obtain an instance of \probtitle{Min Cost Flow} (we want to satisfy the supply and demand of each vertex with a minimum total cost and such that the capacity constraints are respected) and clearly  can be obtained from  in polynomial-time.\\

\begin{figure}[!h]
\begin{center}
\begin{picture}(0,0)\includegraphics{mincostflow.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4437,1490)(3004,-3444)
\put(3061,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3061,-2806){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3061,-3076){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3871,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-2806){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3691,-2806){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3691,-3076){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3421,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3736,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3106,-3391){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4051,-3121){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3376,-2311){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5221,-2716){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5986,-2266){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5626,-2041){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6526,-2041){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5626,-2671){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5626,-3301){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6526,-3301){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6526,-2671){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5896,-2716){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5806,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5806,-3121){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5761,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5761,-2401){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5986,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(5941,-3346){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}-}}}}}
\put(4906,-2716){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7426,-2716){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5221,-2311){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5221,-3256){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6886,-3301){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6886,-2311){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6886,-2716){\makebox(0,0)[lb]{\smash{{\SetFigFont{7}{8.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}

\caption{The auxiliary digraph .}
\label{fig:mincostflow}

\end{figure}

We show now that solving \probtitle{Max -Save} in  is equivalent to solving \probtitle{Min Cost Flow} in . Consider a feasible solution of \probtitle{Max -Save} in  of value . We may assume without loss of generality (see Remark \ref{rem:relstrat}) that at most one vertex is protected in each path , , and (see Lemma \ref{lem:adj}) that at most  vertices are protected in each set ,  (notice that some of these vertices , may not exist in ). Let . Thus . Consider now some vertex . Then in , we will use one flow unit on the path ---. Repeating this procedure for every vertex in , we obtain a flow in  of value  and of cost . Since at most  vertices are protected in each set , it follows that at most  units of flow use the arc , for . Furthermore, since exactly one vertex is protected in each path , it follows that exactly one flow unit uses the arc  for . Hence, we obtain a feasible solution of \probtitle{Min Cost Flow} in .

Conversely, consider now a feasible solution of \probtitle{Min Cost Flow} in  of value . Let  be the set of arcs  used by a flow unit, , . Thus . For each flow unit on a path ---, we choose vertex  in  to be protected, for , . Since the capacity of an arc  is , at most  vertices in  will be chosen to be protected, . Let us denote by  the set of vertices in  chosen to be protected. Furthermore, since the capacity of an arc  is one, exactly one vertex in each path  will be chosen to be protected, . Thus, if we protect at each time step  the vertices in , we obtain a feasible solution of \probtitle{Max -Save} in  of value .\\

Finally, we have to consider the case when  is not the center of . The case when  has degree one is trivial. Thus we may assume now that . If , we are done. Thus we may assume now that . If both neighbors of  are in , then the optimal solution is clearly . If both neighbors of  are not in , then the optimal solution is clearly . Hence the only case remaining is when exactly one neighbor of  is in . Let  be the neighbors of  such that . If  is not the center of , the optimal solution is clearly . Thus we may assume now that  is the center of . Let  denote the set of vertices of the unique maximal path starting at vertex  and containg . In that case we have to compare the value of two solutions: (i)  which is the value of the solution obtained by protecting first  and then, during the second time step, we protect the neighbor of  which is not  (if it exists); (ii) the value of the solution obtained by protecting first  and then applying our algorithm described above to the graph  (\textit{i.e.,} by reducing our problem to a \probtitle{Min Cost Flow} problem).\qedfill
\end{proof}

\begin{remark}
\label{kstar_general}
Notice that the polynomial reduction from \probtitle{Max -Save} to \probtitle{Min Cost Flow} described in the proof of Theorem \ref{th:maxbssave_kstar} is still valid if the number of vertices that can be protected at each time step is not constant (for instance if we are allowed to protect at most  vertices during the first time step,  vertices during the second time step, etc...). In that case we just need to adapt the capacity of the arcs  accordingly.

Furthermore the polynomial reduction remains valid in the case where some of the vertices in a set  are not allowed to be protected during time step . In this case we simply do not put an arc from  to the corresponding vertices  in .
\end{remark}

Consider now a -caterpillar . Let  be the path in the caterpillar from which  has been obtained, which is induced by vertices of degree at least two. We will call  the \textit{spine} of the -caterpillar.

We are now ready to prove the main result of this section.

\begin{theorem}
\label{th:maxbssave_kcater}
For any , , \probtitle{Max -Save} is polynomial-time solvable for -caterpillars.
\end{theorem}

\begin{proof}
Let  be a -caterpillar and let  be the spine of . First assume that  is a vertex of , say , . Let  and . It follows from Remark \ref{rem:relstrat} that we may assume that at most one vertex is protected in  and at most one vertex is protected in . Consider a strategy in which we decide to protect exactly two vertices of , say vertex , for  and vertex , for . We may assume that  is protected during time step  and vertex  is protected during time step  (see Lemma \ref{lem:adj}). Notice that the vertices  will not be protected in this strategy. Construct a -star  as follows (see Figure \ref{fig:catertostar}):

\begin{itemize}
\item[(a)] delete all vertices  as well as the legs at these vertices (all these vertices are saved in our strategy);
\item[(b)] delete all vertices  as well as the legs at these vertices (all these vertices are saved in our strategy);
\item[(c)] delete all edges of ;
\item[(d)] for every , let  be the neighbors of  not belonging to ; delete  and replace it by  vertices  such that  is adjacent to  for ;
\item[(e)] join every vertex , for  and , to  by a path  of length ;
\item[(f)] join every vertex , for  and , to  by a path  of length ;
\end{itemize}

\begin{figure}[!h]
\begin{center}

\begin{picture}(0,0)\includegraphics{catertostar.pstex}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4569,1359)(2329,-3538)
\put(2926,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3286,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3646,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4006,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2746,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3781,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3331,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3466,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3061,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4096,-2851){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5311,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5581,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5851,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6661,-2941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5851,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6121,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6391,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6661,-2761){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5311,-3211){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5581,-3211){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6121,-2266){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2566,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4366,-2581){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \end{center}

\caption{The construction of  with , , and .}
\label{fig:catertostar}

\end{figure}

From the above construction it follows that  is a -star with center . Now in order to solve our initial problem, we need to solve  \probtitle{Max -Save} in  with the following additional constraints: for every  and every  we are not allowed to protect the vertices of . Indeed, since we decided to protect  and , the vertices  will not be saved. Notice that these vertices are represented by the vertices of paths  in . Moreover, if  then at time steps  and  only  firefighters are available (since we protect  and  at these time steps); if  then only  firefighters are available at time step . It follows from Theorem \ref{th:maxbssave_kstar} and Remark \ref{kstar_general} that this problem can be solved in polynomial-time.

Since the number of choices of a pair of vertices  to be protected on  is , we can determine in polynomial-time the best strategy to adopt if we want to protect exactly two vertices on . Notice that a similar procedure to the one described above can be used if we decide to protect exactly one vertex on  respectively if we decide not to protect any vertex of . Clearly the number of choices of exactly one vertex , , to be protected on  is . Thus we conclude that if  we can determine an optimal strategy in polynomial-time.\\

It remains the case when . Similar to the proof of Theorem \ref{th:maxbssave_kstar}, we will distinguish several cases. The case when  has degree one is trivial. Thus we may assume now that . If , we are done. Thus we may assume now that . If both neighbors of  are in , then the optimal solution is clearly . If both neighbors of  are not in , then the optimal solution is clearly . Hence the only case remaining is when exactly one neighbor of  is in . Let  be the neighbors of  such that . If , the optimal solution is clearly . Thus we may assume now that . In this case we have to compare the value of two solutions: (i)  which is the value of the solution obtained by protecting first  and then, during the second time step, we protect the neighbor of  which is not  (if it exists); (ii) the value of the solution obtained by protecting first  and then applying our algorithm described above to the graph , where  is the set of vertices of the unique maximal path starting at  and containing .
\qedfill
\end{proof}


\section{Variants of {\sc Max -Save}} \label{s:variants}

In this section, we give some results for a weighted version of {\sc Max -Save} as well as for its complementary version. 

\subsection{Weighted version}

We would like to mention that our positive results (Proposition~\ref{prop:polytree}, Theorem~\ref{th:maxbssave_kstar}, and Theorem~\ref{th:maxbssave_kcater}) may be generalized to a weighted version of \probtitle{Max -Save}.

Suppose that we are given a weight  for each vertex . These weights may for instance reflect the importance of the vertices: if , vertex  is considered as more important than vertex .
Then we may define the following problem:

\medskip

\noindent 
{\sc Max Weighted -Save}

\noindent\textbf{Input}: An undirected graph , a burned vertex , a subset , and a weight function .

\noindent\textbf{Output}: A valid strategy   with respect to budget  which maximizes the total weight of the saved vertices that belong to .\\

\medskip

In the proof of Proposition~\ref{prop:polytree}, if we direct the fire to a vertex of degree at most  such that the total weight of the burned vertices in  is minimum then we get the following result.

\begin{proposition}
For any , \probtitle{Max Weighted -Save} is polynomial-time solvable for trees of maximum degree  if the fire breaks out at a vertex of degree at most .
\end{proposition}

Now by replacing the costs  in the proof of Theorem~\ref{th:maxbssave_kstar} by  and adapting the case when  is not the center of  according to the weights, it is not difficult to see that we obtain the following.

\begin{theorem}
For any , , \probtitle{Max Weighted -Save} is polynomial-time solvable for -stars.
\end{theorem}

Using this result and adapting the case when  according to the weights, it is straightforward that we obtain the following result.

\begin{theorem}
For any , , \probtitle{Max Weighted -Save} is polynomial-time solvable for -caterpillars.
\end{theorem}

Although the results above are more general than the results in Sections \ref{s:trees} and \ref{s:caterpillars}, we decided to present in detail the results concerning \probtitle{Max -Save} in this paper, since this corresponds to the version which has been widely studied in the literature.

\subsection{Min version}

Let us consider now the minimum version of the {\sc Max -Save} problem which is defined as follows. 

\medskip

\noindent 
{\sc Min -Save}

\noindent\textbf{Input}: An undirected graph , a burned vertex , a subset .

\noindent\textbf{Output}: A valid strategy  with respect to budget  which minimizes the number of burned vertices that belong to .\\

In contrast to {\sc Max -Save} which is constant approximable on trees, the following theorem shows a strong inapproximability result for {\sc Min -Save} even when restricted to trees.


\begin{theorem}
For any  and any , \probtitle{Min -Save} is not -approximable 
even for trees on  vertices when  is the set of all vertices, unless .
\end{theorem}

\begin{proof}
We construct a polynomial-time reduction from \probtitle{-Save} to \probtitle{Min -Save}.
Let  be an instance of \textsc{-Save} consisting of a tree
 with , a burned vertex , and a subset  which corresponds
to the set of leaves. We construct an instance  of
\textsc{Min -Save} consisting of a tree  with , a burned vertex , and  as follows. For every leaf  of , add  vertices adjacent to  where . Notice that .

If there exists a strategy that saves all the vertices in  then at most  vertices are burned in . Conversely, if there is no strategy that saves all the vertices in  then at least  vertices are burned in . 

Suppose that there exists a polynomial-time -approximation algorithm  for \probtitle{Min -Save}. Thus, if  is a \textit{yes}-instance, the algorithm gives a solution of value .
If  is a \textit{no}-instance, the solution value is . Hence, the approximation algorithm  can distinguish in polynomial time between \textit{yes}-instances and \textit{no}-instances for \probtitle{-Save} implying that .
\end{proof}

\section{Conclusion}\label{s:concl}

In this paper, we studied some generalizations and variants of the firefighter problem when more than one firefighter is available at each time step and we answered three open questions of \cite{finbow2009}.
Several interesting questions remain open. The complexity of \probtitle{-Save} and \probtitle{Max -Save} in the following cases are not known: when the number of firefighters at each time step depends on the number of vertices; when every leaf is at the same level. The complexity of \probtitle{Max -Save} for trees of maximum degree  is not establish.
Finally, the problem is 2-approximable for trees when  is the set of vertices. Establishing non approximability results or better approximability results is another open problem.
  





\bibliographystyle{abbrv}
\bibliography{biblio}


\end{document}
