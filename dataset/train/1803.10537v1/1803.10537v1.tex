\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{layout}
\usepackage[nolist]{acronym} 

\usepackage{subfigure,times,multirow}
\usepackage{array}
\usepackage[dvipsnames]{xcolor}
\usepackage[ruled]{algorithm2e}
\usepackage{multirow}
\usepackage{cite}
\usepackage{kotex}
\usepackage[normalem]{ulem} \usepackage[keeplastbox]{flushend}
\usepackage[verbose=silent]{microtype}

\def\etal{\emph{et al}.}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}

\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}\newcommand{\checkboxyes}{\rlap{}{\large\hspace{1pt}\xmark}}


\newif\ifdraft\drafttrue
\ifdraft
\newcommand\modedraft[1]{#1}
\newcommand\todo[1]{{ \color{red}[#1 - \textbf{TODO}]}}
\newcommand\jw[1]{{ \color{blue}[#1 - \textbf{Jongwon}]}}
\newcommand\sd[1]{{ \color{magenta}[#1 - \textbf{Sangdoo}]}}
\newcommand\kw[1]{{ \color{cyan}[#1 - \textbf{kyuewang}]}}
\newcommand\hj[1]{{ \color{ForestGreen}[#1 - \textbf{Hyung Jin}]}}
\newcommand\tf[1]{{ \color{orange}[#1 - \textbf{Tobi}]}}
\newcommand\jy[1]{{ \color{magenta}[#1 - \textbf{Jin Young}]}}
\newcommand\yd[1]{{ \color{cyan}[#1 - \textbf{Yiannis}]}}
\newcommand\ahmed[1]{{ \color{cyan}[#1 - \textbf{Ahmed}]}}
\else
\newcommand\todo[1]{#1}
\newcommand\jw[1]{#1}
\newcommand\kw[1]{#1}
\newcommand\sd[1]{#1}
\newcommand\hj[1]{#1}
\newcommand\tf[1]{#1}
\newcommand\jy[1]{#1}
\newcommand\yd[1]{#1}
\newcommand\ahmed[1]{#1}
\fi



\usepackage{hyperref}

\cvprfinalcopy 
\def\cvprPaperID{892} \def\httilde{\mbox{\tt\raisebox{-.5ex}{\symbol{126}}}}

\ifcvprfinal\pagestyle{empty}\fi

\hyphenation{MATLAB}



\begin{document}

\begin{acronym}[TRACA] \acro{TRACA}{TRAcker based on Context-aware deep feature compression with multiple Auto-encoders}
\end{acronym}


\title{Context-aware Deep Feature Compression for High-speed Visual Tracking}
\vspace{-3cm}
\author{Jongwon Choi \quad Hyung Jin Chang \quad Tobias Fischer \quad Sangdoo Yun \\ Kyuewang Lee \quad Jiyeoup Jeong \quad Yiannis Demiris \quad Jin Young Choi\\
{\small \hspace{1cm}ASRI, ECE., Seoul National University}
{\small \hspace{1cm}Personal Robotics Lab., EEE., Imperial College London}\\
{\small \hspace{-1.5cm}School of Computer Science, University of Birmingham}
{\small \hspace{1.5cm}Clova AI Research, NAVER Corp.}\\
{\tt\scriptsize jwchoi.pil@gmail.com, \{hj.chang,t.fischer,y.demiris\}@imperial.ac.uk, \{yunsd101,kyuewang,jy.jeong,jychoi\}@snu.ac.kr}
}

\maketitle
\thispagestyle{empty}

\AddToShipoutPicture*{\AtTextUpperLeft{\put(0,30){
           \begin{minipage}{\textwidth}
              \footnotesize
              Preprint version; final version available at \url{http://ieeexplore.ieee.org}\\
              IEEE Conference on Computer Vision and Pattern Recognition (CVPR) (2018)\\
              Published by: IEEE
           \end{minipage}}}}

\begin{abstract}
We propose a new context-aware correlation filter based tracking framework to achieve both high computational speed and state-of-the-art performance among real-time trackers.
The major contribution to the high computational speed lies in the proposed deep feature compression that is achieved by a context-aware scheme utilizing multiple expert auto-encoders; a context in our framework refers to the coarse category of the tracking target according to appearance patterns. 
In the pre-training phase, one expert auto-encoder is trained per category.
In the tracking phase, the best expert auto-encoder is selected for a given target, and only this auto-encoder is used.
To achieve high tracking performance with the compressed feature map, we introduce extrinsic denoising processes and a new orthogonality loss term for pre-training and fine-tuning of the expert auto-encoders.
We validate the proposed context-aware framework through a number of experiments, where our method achieves a comparable performance to state-of-the-art trackers which cannot run in real-time, while running at a significantly fast speed of over 100 fps.
\end{abstract} \section{Introduction}
The performance of visual trackers has vastly improved with the advances of deep learning research.
Recently, two different groups for deep learning based tracking have emerged.
The first group consists of online trackers which rely on continuous fine-tuning of the network to learn the changing appearance of the target~\cite{ref:FCNT,ref:MDNet,ref:SINT,ref:STCT,ref:yun}.
While these trackers result in high accuracy and robustness, their computational speed is insufficient to fulfil the real-time requirement of online tracking.
The second group is composed of correlation filter based trackers utilising raw deep convolutional features~\cite{ref:HDT,ref:CF2,ref:DeepSRDCF,ref:COT,ref:ECO}.
However, these features are designed to represent general objects contained in large datasets such as ImageNet~\cite{ref:ImageNet} and therefore are of high dimensionality. 
As the computational time for the correlation filters increases with the feature dimensionality, trackers within the second group do not satisfy the real-time requirement of online tracking either.


\begin{figure}[t]
    \includegraphics[width=1.0\linewidth]{intro6}
    \caption{ \textbf{Comparison of computational efficiency.} This plot compares the performance and computational speed of the proposed tracker (TRACA) with previous state-of-the-art trackers using the CVPR2013 dataset~\cite{ref:Benchmark}. TRACA shows comparable performance with the best performing non real-time trackers, while running at a fast speed of over 100 fps.
    }
    \label{fig:introduction}
    \vspace{-0.4cm}
\end{figure}



In this work, we propose a correlation filter based tracker using context-aware compression of raw deep features, which reduces computational time, thus increasing speed.
This is motivated by the observation that a lower dimensional feature map can sufficiently represent the single target object which is in contrast to the classification and detection tasks using large datasets that cover numerous object categories.
Compression of high dimensional features into a low dimensional feature map is performed using autoencoders~\cite{ref:dAE, ref:ae1, ref:ae2, ref:ae3}.
More specifically, we employ multiple auto-encoders whereby each auto-encoder specialises in a specific category of objects; these are referred to as \textit{expert auto-encoders}.
We introduce an unsupervised approach to find the categories by clustering the training samples according to contextual information, and subsequently train one expert auto-encoder per cluster.
During visual tracking, an appropriate expert auto-encoder is selected by a context-aware network given a specific target. 
The compressed feature map is then obtained after fine-tuning the selected expert auto-encoder by a novel loss function considering the orthogonality of the correlation filters.
The compressed feature map contains reduced redundancy and sparsity, which increases accuracy and computational efficiency of the tracking framework.
To track the target, correlation filters are applied to the compressed feature map.
We validate the proposed framework through a number of self-comparisons and show that it outperforms other trackers using raw deep features while being notably faster at a speed of over 100 fps (see Fig.~\ref{fig:introduction}).


 \begin{figure*}[t]
\centering
    \includegraphics[width=0.82\linewidth]{overall_figure_v2_0}
    \vspace{-0.1cm}
    \caption{ {\bf{Proposed algorithm scheme.}} The expert auto-encoder is selected by the context-aware network and fine-tuned once by the ROI patch at the initial frame (). For the following frames, we first extract the ROI patch () centred at the previous target position. Then, a raw deep convolutional feature () is obtained through VGG-Net, and is compressed by the fine-tuned expert auto-encoder. The compressed feature () is used as the feature map for the correlation filter, and the target's position is determined by the peak position of the filter response. After each frame, the correlation filter is updated online by the newly found target's compressed feature.}
    \label{fig:framework}
\vspace{-0.4cm}
\end{figure*}


\section{Related Works}

\textbf{Online deep learning based trackers:}
Recent trackers based on online deep learning~\cite{ref:FCNT, ref:MDNet,ref:SINT,ref:STCT,ref:yun} have outperformed previous low-level feature-based trackers. Wang~\etal~\cite{ref:FCNT} proposed a framework simultaneously utilising shallow and deep convolutional features to consider detailed and contextual information of the target respectively.
Nam and Han~\cite{ref:MDNet} introduced a novel training method which
avoids overfitting by appending a classification layer to a convolutional neural network that is updated online. Tao~\etal~\cite{ref:SINT} utilised a Siamese network to estimate the similarities between the target's previous appearance and the current candidate patches.
Yun~\etal~\cite{ref:yun} suggested a new tracking method using an action decision network
which can be trained by a reinforcement learning method with weakly labelled datasets.
However, trackers based on online deep learning require frequent fine-tuning of the networks, which is slow and prohibits real-time tracking.
David~\etal~\cite{ref:goturn} and Bertinetto~\etal~\cite{ref:SiamFC} proposed pre-trained networks to quickly track the target without online fine-tuning, but the performance of these trackers is lower than that of the state-of-the-art trackers.


\textbf{Correlation filter based trackers:}
The correlation filter based approach for visual tracking has become increasingly popular due to its rapid computation speed~\cite{ref:KCF, ref:MOSSE, ref:DSST, ref:LongCT, ref:MUSTer, ref:SCT, ref:ACFN}.
Henriques~\etal~\cite{ref:KCF} improved the tracking performance by extending the correlation filter to multi-channel inputs and kernel-based training.
Danelljan~\etal~\cite{ref:DSST} developed a new correlation filter that can detect scale changes of the target. Ma~\etal~\cite{ref:LongCT} and Hong~\etal~\cite{ref:MUSTer} integrated correlation filters with an additional long-term memory system.
Choi~\etal~\cite{ref:ACFN} proposed a tracker with an attentional mechanism exploiting previous target appearance and dynamics.

Correlation filter based trackers showed state-of-the-art performance when deep convolutional features were utilised~\cite{ref:HDT,ref:DeepSRDCF,ref:COT,ref:ECO}.
Danelljan~\etal~\cite{ref:DeepSRDCF} extended the regularised correlation filter~\cite{ref:SRDCF} to use deep convolutional features.
Danelljan~\etal~\cite{ref:COT} also proposed a novel correlation filter to find the target position in the continuous domain to incorporate features of various resolutions.
Ma~\etal~\cite{ref:HDT} estimated the target position by fusing the response maps obtained from convolutional features of various resolutions.
However, even though each correlation filter works fast, raw deep convolutional features have too many channels to be handled in real-time.
A first step towards decreasing the feature space was made by Danelljan~\etal~\cite{ref:ECO} by considering the linear combination of raw deep features, however the method still cannot run in real-time, and the deep feature redundancy was not fully suppressed.






\textbf{Multiple-context deep learning frameworks:}
Our proposed tracking framework benefits from the observation that the performance of deep networks can be improved using contextual information to train multiple specialised deep networks. Indeed, there are several works utilizing such a scheme.
Li~\etal~\cite{ref:context_cascadeface} proposed a cascaded framework detecting faces through multiple neural networks trained by samples divided according to the degree of their detection difficulty.
Vu~\etal~\cite{ref:context_head} integrated the head detection results from two neural networks, one specialising in local information and the other one in global information.
Neural networks specialising in local and global information have also been utilised in the saliency map estimation task~\cite{ref:context_saliency, ref:context_saliency2}.
In crowd density estimation, many works~\cite{ref:crowd1, ref:crowd2, ref:crowd3} have increased their performance by using multiple deep networks with different receptive fields to cover various scales of crowds.



















 \section{Methodology}
The proposed \ac{TRACA} consists of multiple expert auto-encoders, a context-aware network, and correlation filters as shown in Fig.~\ref{fig:framework}. The expert auto-encoders robustly compress raw deep convolutional features from VGG-Net~\cite{ref:vggm}.
Each of them is trained according to a different context, and thus performs context-dependent compression (see Sec.~\ref{sec:expertae}).
We propose a context-aware network to select the expert auto-encoder best suited for the specific tracking target, and only this auto-encoder is running during online tracking (see Sec.~\ref{sec:contextnet}).
After initially adapting the selected expert auto-encoder for the tracking target, its compressed feature map is utilised as an input of correlation filters which track the target online. 
We introduce the general concept of correlation filters in Sec.~\ref{sec:correlationfilter} and then detail the tracking processes including the initial adaptation and the online tracking in Sec.~\ref{Sec:tracking}.











 \subsection{Expert Auto-encoders} \label{sec:expertae}

\textbf{Architecture:}
Auto-encoders have shown to be suitable for unsupervised feature learning~\cite{ref:ae_hinton2006,ref:ae_hinton2006_2,ref:dAE}.
They offer a way to learn a compact representation of the input while retaining the most important information to recover the input given the compact representation.
In this paper, we propose to use a set of  expert auto-encoders of the same structure, each covering a different context. 
The inputs to be compressed are raw deep convolutional feature maps obtained from one of the convolution layers in VGG-Net~\cite{ref:vggm}.

To achieve a high compression ratio, we stack  encoding layers which are followed by  decoding layers in the auto-encoder.
The -th encoding layer  is a convolutional layer working as , thus reducing the channel dimension  of the input to latent channel dimension  while preserving the resolution of the feature map.
The output of  is provided as input to  such that the channel dimension  decreases as the feature maps pass through the encoding layers.
More specifically, in our proposed framework one encoding layer reduces the channel dimension in half, \ie  for .
By denoting the (-th decoding layer by  in the adverse way of ,  expands the input channel dimension  into  to restore the original dimension  of  at the last layer of the decoder, where . 
Then, the auto-encoder  can be expressed as  for a raw convolutional feature map
, and the compressed feature map in the auto-encoder is defined as .
All convolution layers are followed by the ReLU activation function, and the size of their convolution filters is set to .


\textbf{Pre-training:}
The pre-training phase for the expert auto-encoders is split into three parts, each serving a distinct purpose. 
First, we train the base auto-encoder  using all training samples to find context-independent initial compressed feature maps. 
Then, we perform contextual clustering on the initial compressed feature maps of  to find  context-dependent clusters. Finally, these clusters are used to train the expert auto-encoders initialised by the base auto-encoder with one of the sample clusters. 

The purpose of the base auto-encoder is twofold: Using the context-independent compressed feature maps to cluster the training samples and finding good initial weight parameters from which the expert auto-encoders can be fine-tuned.
The base auto-encoder is trained by 
raw convolutional feature maps  with a batch size .
The  is obtained as the output from a convolutional layer involved in VGG-Net~\cite{ref:vggm} fed by randomly selected training images  from a large image database such as ImageNet~\cite{ref:ImageNet}.

To make the base auto-encoder more robust to appearance changes and occlusions, we use two denoising criteria which help to capture distinct structures in the input distribution (illustrated in Fig.~\ref{fig:denoising}). 
The first denoising criterion is a {\it channel corrupting process} where a fixed number of feature channels is randomly chosen and the values for these channels is set to  (while the other channels remain unchanged), which is similar to the destruction process of denoising auto-encoders~\cite{ref:dAE}.
Thus all information for these channels is removed and the auto-encoder is trained to recover this information. 
The second criterion is an {\it exchange process}, where some spatial feature vectors of the convolutional feature are randomly interchanged.
Since the receptive fields of the feature vectors cover different regions within an image, exchanging the feature vectors is similar to interchanging regions within the input image. Thus, interchanging feature vectors that cover the background region and target region respectively leads to a similar effect as the background occluding the target. Therefore, the auto-encoders are trained to be robust against occlusions.
We denote  as the mini-batch after performing the two denoising processes.
Then, the base auto-encoder  can be trained by minimising the distance between the input feature map  and its output  with the noisy sample . 


However, when we only consider the distance between the input and the final output of the base auto-encoder, we frequently observed an overfitting problem and unstable training convergence. To solve these problems, we design a novel loss based on a multi-stage distance which consists of the distances between the input and the outputs obtained by the partial auto-encoders. The partial auto-encoders  contain only a portion of the encoding and decoding layers of their original auto-encoder , while the input and output sizes match that of the original auto-encoder, \ie\ , ,  when . Thus, the loss based on the multi-stage distance can be described as:
\small

\normalsize
where  is the -th partial auto-encoder of , and recall that  denotes the mini batch size.



\begin{figure}[t]
    \subfigure[Channel corrupting process]{\includegraphics[width=4.0cm]{destruction2}}
    \hfill
    \subfigure[Feature vector exchange process]{\includegraphics[width=4.0cm]{exchange}}
    \caption{\textbf{Extrinsic denoising criteria.} To increase robustness of the compressed feature map in the pre-training, two extrinsic denoising criteria are applied to the raw deep feature map which is the input of the auto-encoder. (a) In the channel corrupting process, some randomly selected channels are set to zero. (b) In the exchange process, randomly chosen feature vectors are interchanged.}
    \label{fig:denoising}
    \vspace{-0.4cm}
\end{figure}

Then, we cluster the training samples  according to their respective feature maps compressed by the base auto-encoder, where  denotes the total number of training samples.
To avoid overfitting of the expert auto-encoders due to a too small cluster size, we introduce a two-step clustering algorithm which avoids small clusters.

In the first step, we find  samples which are chosen randomly from the feature maps compressed by the base auto-encoder (note that this is twice the amount of desired clusters). 
We repeat the random selection 1000 times and find the samples which have the largest Euclidean distance amongst them as initial centroids.
Then, all training samples are clustered by -means clustering with  using the compressed feature maps. 
In the second step, among the resulting  centroids, we remove the  centroids of the clusters with the smallest number of included samples. 
Then,  centroids remain, and we cluster the training samples again using these centroids, which results in  clusters including enough samples to avoid the overfitting problem.
We denote the cluster index for  as .

The -th expert auto-encoder  is then found by fine-tuning the base auto-encoder using the training samples with contextual cluster index .
The training process (including the denoising criteria) differs from the base auto-encoder only in the training samples.
 \subsection{Context-aware Network} \label{sec:contextnet}

\textbf{Architecture:}
The context-aware network selects the expert auto-encoder which is most contextually suitable for a given tracking target.
We adopt a pre-trained VGG-M model~\cite{ref:vggm} for the context-aware network since it contains a large amount of semantic information from pre-training on ImageNet~\cite{ref:ImageNet}. 
Given a  RGB input image, our context-aware network consists of three convolutional layers \{\textit{conv1}, \textit{conv2}, \textit{conv3}\} followed by three fully connected layers \{\textit{fc4}, \textit{fc5}, \textit{fc6}\}, whereby \{\textit{conv1}, \textit{conv2}, \textit{conv3}, \textit{fc4}\} are identical to the corresponding layers in VGG-M. 
The weight parameters of \textit{fc5} and \textit{fc6} are initialised randomly with zero-mean Gaussian distribution. 
\textit{fc5} is followed by a ReLU function and contains 1024 output nodes. 
Finally \textit{fc6} has  output nodes and is combined with a softmax layer to estimate the probability for each of the expert auto-encoders to be suited for the tracking target.


\textbf{Pre-training:}
The context-aware network takes a training sample  as input and outputs the estimated probabilities of that sample belonging to cluster index .
It is being trained by a batch  of image/cluster-index pairs where  is the mini-batch size for the context-aware network.
We fix the weights of \{\textit{conv1}, \textit{conv2}, \textit{conv3}, \textit{fc4}\}, and train the weights for \{\textit{fc5}, \textit{fc6}\} by minimising the multi-class loss function  using stochastic gradient descent, where
\small
\vspace{-2mm}

\normalsize
 denotes the cross-entropy loss, and  is the predicted cluster index of  by the context-aware network .

 \subsection{Correlation Filter} \label{sec:correlationfilter}
Before detailing the tracking process of TRACA, we briefly introduce the functionality of conventional correlation filters using a single-channel feature map.
Based on the property of the circulant matrix in the Fourier domain~\cite{ref:cirMatrix}, correlation filters can be trained quickly which leads to high-performing trackers under low computational load~\cite{ref:KCF}. 
Given the vectorised single-channel training feature map  
and the vectorised target response map  obtained from a 2-D Gaussian window with size  and variance  as in \cite{ref:KCF}, the vectorised correlation filter  can be estimated by:

where  and  represent the Fourier-transformed vector of  and  respectively,  is the conjugated vector of ,  denotes an element-wise multiplication,  stands for an inverse Fourier transform function, and  is a predefined regularisation factor.


For the vectorised single-channel test feature map , the vectorised response map  can be obtained by:
\vspace{-2mm}

Then, after re-building a 2-D response map  from , the target position is found from the maximum peak position of .

 \subsection{Tracking Process}
\label{Sec:tracking}
To track a target in a scene, we rely on a correlation filter based algorithm using the compressed feature map of the expert auto-encoders as selected by the context-aware network. 
We describe the initial adaptation of the selected expert auto-encoder in Sec.~\ref{sec:initialAdap} followed by a presentation of the correlation filter based tracking algorithm in Sec.~\ref{sec:onlintTrack}.


\subsubsection{Initial Adaptation Process} \label{sec:initialAdap}
\hspace{3mm}The initial adaptation process contains the following parts. We first extract a region of interest (ROI) including the target from the initial frame, and the expert auto-encoder suitable for the target is selected by the context-aware network.
Then, the selected expert auto-encoder is fine-tuned using the raw convolutional feature maps of the training samples augmented from the ROI.
When we obtain the compressed feature map from the fine-tuned expert auto-encoder, some of its channels represent background objects rather than the target.
Thus, we introduce an algorithm to find and remove the channels which respond to the background objects.

\textbf{Region of interest extraction: }
The ROI is centred around the target's initial bounding box, and is 2.5 times bigger than the target's size to cover the area nearby. 
We then resize the ROI of width  and height  to  in order to match the expected input size of the VGG-Net.
This results in the resized ROI  for the  domain. 
For grey-scale images, the grey value is replicated three times to obtain .
The best expert auto-encoder for the tracking scene is selected according to the contextual information of the initial target using the context-aware network , and we can denote this auto-encoder as .


\textbf{Initial sample augmentation: }
Even though we use two denoising criteria as described earlier, we found that the compressed feature maps of the expert auto-encoders show a deficiency for targets which become blurry or are flipped. 
Thus, we augment  in several ways before fine-tuning the selected auto-encoder. 
To tackle the blurriness problem, four augmented images are obtained by filtering  with Gaussian filters with variances . Two more augmented images are obtained by flipping  around the vertical and horizontal axes respectively.
Then, the raw convolutional feature maps extracted from the augmented samples can be represented by .


\textbf{Fine-tuning: }
The fine-tuning of the selected auto-encoder differs from the pre-training process for the expert auto-encoders.
As there is a lack of training samples, the optimisation rarely converges when applying the denoising criteria.
Instead, we employ a correlation filter orthogonality loss  which considers the orthogonality of the correlation filters estimated from the compressed feature map of the expert auto-encoder, where  is defined as:
\vspace{-2mm}

\normalsize
where  and  defines a vectorised correlation filter estimated by Eq.(\ref{eq:cf}) using the vectorised -th channel of the compressed feature map  from the selected expert auto-encoder. 
The correlation filter orthogonality loss allows increasing the interaction among the correlation filters as estimated from the different channels of the compressed feature maps. 
The fine-tuning is performed by minimising  using stochastic gradient descent.
The differentiation of  is described in Appendix A of the supplementary material.

\textbf{Background channel removal: } 
The compressed feature map  can be obtained from the fine-tuned expert auto-encoder.
Then, we remove the channels within  which have large responses outside of the target bounding box.
Those channels are found by estimating the channel-wise ratio of foreground and background feature responses.
First, we estimate the channel-wise ratio of the feature responses for channel  as 

where  is the -th channel feature map of  and  is obtained from  by setting the values out of the target bounding box to  while the other values are untouched. Then, after sorting all channels according to  in descending order, only the first  channels of the compressed feature map are utilised as input to the correlation filters. We denote the resulting feature map as , where  is the feature size.



\subsubsection{Online Tracking Sequence} \label{sec:onlintTrack}
\hspace{3mm}\textbf{Correlation filter estimation \& update: }
We first obtain the resized ROI for the current frame  using the same method as in the initial adaptation, \ie\ the resized ROI is centred at the target's centre and its size is 2.5 times the target's size and resized to .
After feeding the resized ROI to the VGG-Net, we obtain the compressed feature map  by inserting the raw deep convolutional feature map of the VGG-Net into the adapted expert auto-encoder.

Then, using Eq.(\ref{eq:cf}), we estimate independent correlation filters  for each feature map , where  denotes the -th channel of .
Following~\cite{ref:KCF}, we suppress background regions by multiplying each  with cosine windows of the same size.
For the first frame, we can estimate the correlation filters  with Eq.(\ref{eq:cf}) given by .
For the following frames (), the correlation filters are updated as follows:

where  is an interpolation factor.


\textbf{Tracking: }
After estimating the correlation filter, we need to find the position  of the target in frame . 
As we assume that  is close to the target position in the previous frame , we extract the tracking ROI from the same position as the ROI for the correlation filter estimation of the previous frame.
Then, we can obtain the compressed feature map  for tracking using the adapted expert auto-encoder. 
Inserting  and  to Eq.(\ref{eq:cfrs}) then provides the channel-wise response map  
(we apply the multiplication of cosine windows in the same manner as for the correlation filter estimation).

We then need to combine  to the integrated response map . 
We use a weighted averaging scheme, where we use the validation score  as weight factor with

and  is a 2-D Gaussian window with size  and variance  centred at the peak point  of . 
Then, the integrated response map is calculated as:
\vspace{-2mm}

Following~\cite{ref:ACFN}, we find the sub-pixel target position  by interpolating the response values near the peak position.
Finally, the target position  is found as:


\textbf{Scale changes: }
To handle scale changes of the target, we extract two additional ROI patches scaled from the previous ROI patch size with scaling factors  and  respectively in the tracking sequence. 
The new target scale is chosen as the scale where the respective maximum value of the response map (from the scaled ROI) is the largest.

\textbf{Full occlusion handling: }
To handle full occlusions, a re-detection algorithm is adopted. 
The overall idea is to introduce a so-called re-detection correlation filter which is not being updated and applied to the position of the target at the time where an occlusion has been detected. 
A full occlusion is assumed when a sudden drop of the maximum response value  is detected as described by  with  and  (note that this is the same  as in Eq.(\ref{eq:update})). If that condition is fulfilled, the correlation filter at time  is used as re-detection correlation filter. 
During the next  frames, the target position as determined by the re-detection correlation filter is being used if the maximum value of the re-detection filter's response map is larger than the maximum value of the response map obtained by the normal correlation filter. 
Furthermore,  are replaced by the ones of the re-detection correlation filter, and the target scale is reset to the scale when the occlusion was detected.

 \section{Experimental Result}

\subsection{Implementation}
The feature response after the second convolution layer () of VGG-M~\cite{ref:vggm} was given to the auto-encoders as raw convolutional feature input.
The number of expert auto-encoders was set to , and their depth to .
The mini-batch size for all auto-encoders was set to .
The learning rate for the base auto-encoder was set to , and for expert auto-encoders to .
The base auto-encoder was trained for  epochs, and the expert auto-encoders were fine-tuned for  epochs.
The proportions for the two extrinsic denoising processes were set to  respectively.
For training the context-aware network, the mini-batch size and the learning rate were set to  and , respectively.
The weight for the orthogonality loss term was set to , and the reduced channel dimension after the background channel removal was .
The parameters for the correlation filter based tracker were set to , , and , and .
The parameters for full occlusion handling,  and , were experimentally determined to  and  using scenes with occlusions.

We used MATLAB and MatConvNet~\cite{ref:matconvnet} to implement the proposed framework. 
The computational environment had an Intel i7-2700K CPU @ 3.50GHz, 16GB RAM, and an NVIDIA GTX1080 GPU. 
The computational speed was 101.3 FPS in the CVPR2013 dataset~\cite{ref:Benchmark}.
We release the source code along with the attached experimental results\footnote{\url{https://sites.google.com/site/jwchoivision/}}.

\begin{figure*}[t]
\centering
\subfigure{\includegraphics[width=5.7cm]{SELF_precision2}}
\hfill
\subfigure{\includegraphics[width=5.7cm]{CVPR2013_precision}}
\hfill
\subfigure{\includegraphics[width=5.7cm]{OOTB100_precision}}
\addtocounter{subfigure}{-3}
\vspace{-0.6cm}
\end{figure*}
\begin{figure*}[t]
\centering
\subfigure[Self-comparison on CVPR2013]{\includegraphics[width=5.7cm]{SELF_success2}}
\hfill
\subfigure[Evaluation plots on CVPR2013]{\includegraphics[width=5.7cm]{CVPR2013_success}}
\hfill
\subfigure[Evaluation plots on TPAMI2015]{\includegraphics[width=5.7cm]{OOTB100_success}}
\caption{{\bf{Evaluation results.}} \ac{TRACA} showed the best performance within the self-comparison, and the state-of-the-art performance amongst real-time trackers in CVPR2013~\cite{ref:Benchmark} and TPAMI2015~\cite{ref:TPAMI2015Benchmark} datasets. The numbers within the legend are the average precisions when the centre error threshold equals 20 pixels (top row), or the area under the curve of the success plot (bottom row).}
    \label{fig:Evaluation}
    \vspace{-4mm}
\end{figure*}

\subsection{Dataset}
\label{subsec:dataset}
The classification image samples included in VOC2012~\cite{ref:voc2012} were used to pre-train the expert auto-encoders and the context-aware network.
To evaluate the proposed framework, we used the CVPR2013~\cite{ref:Benchmark} (51 targets, 50 videos) and TPAMI2015~\cite{ref:TPAMI2015Benchmark} (100 targets, 98 videos) datasets, which contain the ground truth of the target bounding box at every frame.
These datasets have been frequently used~\cite{ref:COT,ref:MDNet,ref:KCF,ref:MUSTer,ref:MEEM,ref:STRUCK,ref:ACFN} as they include a large variety of environments to evaluate the general tracking performance.



\subsection{Evaluation Measure}
As performance measure, we used the average precision curve of one-pass evaluation (OPE) as proposed in~\cite{ref:Benchmark}.
The average precision curve was estimated by averaging the precision curves of all sequences, which was obtained using two sources: location error threshold and overlap threshold.
As representative scores of trackers, the average precisions when the location error threshold equals 20 pixels and the area under the curve of the success plot were used.

\begin{table}
\centering 
\caption{Quantitative results on the CVPR2013 dataset~\cite{ref:Benchmark}}
\small{
\resizebox{0.9\linewidth}{!}{
\begin{tabular} {|c||c|>{\centering}m{1.4cm}|c|c|}
\hline
& Algorithm & Pre. score & Mean FPS & GPU\\
\hline
\multirow{10}{0.4cm}{\rotatebox[origin=c]{90}{Proposed}}
 & \textbf{TRACA} & \textbf{89.8\%} & 101.3 & Y\\
 \cline{2-5}
 & -TRACA & 87.7\% & 101.2 & Y\\
 \cline{2-5}
 & random-TRACA & 84.4\% & 99.5 & Y\\
 \cline{2-5}
 & pretrain-TRACA & 83.2\% & 98.8 & Y\\
 \cline{2-5}
 & no orth.-TRACA & 82.2\% & 101.2 & Y\\
 \cline{2-5}
 & dropout-TRACA & 78.5\% & 97.5 & Y\\
 \cline{2-5}
 & label-TRACA & 76.6\% & 97.2 & Y\\
 \cline{2-5}
 & simple-TRACA & 76.4\% & 94.1 & Y\\
 \cline{2-5}
 & single-TRACA & 76.2\% & 100.9 & Y\\
 \cline{2-5}
 & clean-TRACA & 75.4\% & 92.9 & Y\\
\hline
\multirow{7}{0.4cm}{\rotatebox[origin=c]{90}{Real-time}}
& ACFN~\cite{ref:ACFN} & 86.0\% &  15.0 & Y\\
\cline{2-5}
& LCT~\cite{ref:LongCT} & 84.8\% &  21.6 & N\\
\cline{2-5}
& SCT~\cite{ref:SCT} & 84.5\% &  40.0 & N\\
\cline{2-5}
& MEEM~\cite{ref:MEEM} & 81.4\% & 19.5 & N\\
\cline{2-5}
& SiamFC~\cite{ref:SiamFC} & 80.9\% & 86.0 & Y\\
\cline{2-5}
& KCF~\cite{ref:KCF} & 74.2\% & \textbf{120.5} & N\\
\cline{2-5}
& DSST~\cite{ref:DSST} & 74.0\% & 25.4 & N\\
\hline
\hline
\multirow{6}{0.4cm}{\rotatebox[origin=c]{90}{Non Real-time}}
& ECO~\cite{ref:ECO} & {\bf{93.0\%}} & \textbf{8.0} & Y\\
\cline{2-5}
& ADNet~\cite{ref:yun} & 90.3\% & 2.9 & Y\\
\cline{2-5}
& C-COT~\cite{ref:COT} & 89.9\% & 0.5 & N\\
\cline{2-5}
& MUSTer~\cite{ref:MUSTer} & 86.5\% & 3.9 & N\\
\cline{2-5}
& FCNT~\cite{ref:FCNT} & 85.6\% & 3.0 & Y\\
\cline{2-5}
& D-SRDCF~\cite{ref:DeepSRDCF} & 84.9\% & 0.2 & N\\
\hline
\end{tabular}
}
\label{tabular:quantitative2}
}
\vspace{-3mm}
\end{table}


\subsection{Self-comparison}
To analyse the effectiveness of \ac{TRACA},
we compare TRACA with nine variants:
no orth.-TRACA, pretrain-TRACA, clean-TRACA, dropout-TRACA, random-TRACA, -TRACA, label-TRACA, simple-TRACA, and single-TRACA.
In no orth.-TRACA, the weight factor  for the orthogonality loss term is set to zero.
Pretrain-TRACA skipped the initial adaptation step and directly utilised the pre-trained expert auto-encoder.
Clean-TRACA used the expert auto-encoders which were pre-trained without any extrinsic denoising process.
Dropout-TRACA adopted a dropout scheme instead of the proposed dimension corrupting process, while keeping the feature vector exchange process.
Random-TRACA randomly selected the suitable expert auto-encoder.
-TRACA selected the best suitable expert auto-encoder according to the smallest  generation error estimated from the initial target.
Label-TRACA utilised 20 class labels of the pre-training dataset (VOC2012~\cite{ref:voc2012}) as the contextual clusters.
The expert auto-encoders of simple-TRACA were trained and fine-tuned by minimising the Euclidean distance between their inputs and final outputs, \ie\ without using the multi-stage distance.
Single-TRACA utilised the compressed feature map of the base auto-encoder\footnote{For fair comparison, we train the base auto-encoder for 20 epochs in the case of single-TRACA.}.

The results of the comparison with these nine trackers are shown in Table~\ref{tabular:quantitative2} and Fig.~\ref{fig:Evaluation}~(a).
The results of random-TRACA and -TRACA show decreased performance which reflects the importance of the context-aware network.
In the result of pretrain-TRACA, the performance was reduced by 6.6\% when the expert auto-encoder was not adapted initially.
The initial adaptation ignoring the orthogonality loss term (no orth.-TRACA) further decreased the performance by 1\% compared to pretrain-TRACA.
When the extrinsic denoising processes were not applied, the tracking performance reduced dramatically (14.3\%) according to the result of clean-TRACA.
Similarly, as shown in the result of dropout-TRACA, the proposed dimension corrupting process made the expert auto-encoders more robust than a dropout scheme (11.3\% performance reduction).
When the multi-stage distance was not used, the performance was reduced by 13.4\% as shown in the result of simple-TRACA.
Single-TRACA showed a dramatic reduction in the tracking performance (13.6\%), which demonstrates that the multiple-context scheme was effective to compress the raw deep convolutional feature for a specific target.
Finally, the tracking performance was reduced dramatically in label-TRACA (13.2\%), which shows that clustering in feature space is beneficial when training the expert auto-encoders.

\begin{figure}[t]
\centering
    \includegraphics[width=0.92\linewidth]{qualitativeResult5}
    \caption{ {\bf{Qualitative results.}}  The used sequences are {{Lemming}}, {{Couple}}, {{Jumping}}, {{FaceOcc2}}, {{CarDark}}, and {{Soccer}} from the left-top.}
    \label{fig:Qualitative}    
    \vspace{-4mm}
\end{figure}

\subsection{Comparison with State-of-the-art Trackers}
The results of the state-of-the-art methods, including ECO~\cite{ref:ECO}, ADNet~\cite{ref:yun}, ACFN~\cite{ref:ACFN}, C-COT~\cite{ref:COT}, SiamFC~\cite{ref:SiamFC}, FCNT~\cite{ref:FCNT}, D-SRDCF~\cite{ref:DeepSRDCF}, SCT~\cite{ref:SCT}, LCT~\cite{ref:LongCT}, and DSST~\cite{ref:DSST} were obtained from the authors.
In addition, the results of MUSTer~\cite{ref:MUSTer}, MEEM~\cite{ref:MEEM}, and KCF~\cite{ref:KCF} were estimated using the authors' implementations\footnote{For fair comparison, the computational time was estimated by the same computer as \ac{TRACA} and included the image resizing time.}.

In Table~\ref{tabular:quantitative2}, the precision scores of the algorithms on the CVPR2013 dataset are presented along with the computational speed and whether they make use of a GPU.
\mbox{Fig.~\ref{fig:Evaluation}~(b-c)} compares the performances of the real-time trackers, where \ac{TRACA} demonstrates state-of-the-art performance in both the CVPR2013 and TPAMI2015 datasets while running at over 100 fps.
Some qualitative results are shown in Fig.~\ref{fig:Qualitative}.

\begin{figure}[t]
    \centering
\includegraphics[width=0.97\linewidth]{contextSample}
	\caption{\textbf{Top-5 images for each contextual cluster.} Each column represents one context category and consists of the five samples within Caltech256~\cite{ref:caltech2} that have the highest scores of the context-aware network for this category. The results confirm that the contextual clusters represent the category of appearance patterns.}
	\label{fig:contextClutering}
    \vspace{-5mm}
\end{figure}

\subsection{Further Analysis}
The context in the proposed framework refers to a coarse category of the compressed feature maps encoding the target object appearance.
To illustrate the context in practice, we extracted the five samples with the highest scores within the context-aware network for each contextual category using Caltech256~\cite{ref:caltech2}.
As shown in Fig.~\ref{fig:contextClutering}, the contextual clusters categorise the samples according to appearance patterns.


In Appendix B, we evaluate the impact of the chosen target layer of VGG-Net and the number of contextual clusters on the proposed framework.
In Appendix C, we analyse the correlation matrix among various computer vision datasets, which was obtained by estimating the correlation among the histograms of the results from the context-aware network.






 \vspace{-2mm}
\section{Conclusion}
\vspace{-3mm}
In this paper, a new visual tracking framework based on context-aware deep feature compression using multiple auto-encoders was proposed. 
Our main contribution is to introduce a context-aware scheme which includes expert auto-encoders specialising in one context, and a context-aware network which is able to select the best expert auto-encoder for a specific tracking target.
This leads to a significant speed-up of the correlation filter based tracker utilising deep convolutional features. Our experiments lead to the compelling finding that our framework achieves a high-speed tracking ability of over 100 fps while our framework maintains a competitive performance compared to the state-of-the-art trackers. We expect that embedding our context-aware deep feature compression scheme will be integrated with other trackers utilising raw deep features, which will increase their robustness and computational efficiency.
In addition, the scheme can be utilised as a way to avoid the overfitting problem in other computer vision tasks where only few training samples are available, such as in image -shot learning and image domain adaptation.
As a future work, we will jointly train the expert auto-encoders and the context-aware network to potentially further increase the performance due to the correlation between the contextual clustering and the feature compression. 
\vspace{1mm}
\footnotesize
\noindent\textbf{Acknowledgements:} 
This work was supported by  ICT R\&D program MSIP/IITP [2017-0-00306, Outdoor Surveillance Robots], Next-Generation ICD Program through NRF funded by Ministry of S\&ICT [2017M3C4A7077582], 
and BK21.
\normalsize


{\small
\bibliographystyle{ieee}
\bibliography{refs}
}

\end{document}
