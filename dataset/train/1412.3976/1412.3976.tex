\documentclass{llncs}

\usepackage{amsmath,amssymb}
\usepackage[dvipdf]{graphicx}

\pagestyle{plain}
\thispagestyle{plain}





\newcommand{\onestep}{\leftrightarrow}
\newcommand{\sevstep}{\leftrightsquigarrow}

\newcommand{\MC}[2]{\mathsf{MC}_{#1}(#2)} 
\newcommand{\TAR}[1]{\mathsf{TAR}(#1)}
\newcommand{\TS}{\mathsf{TS}}
\newcommand{\TJ}{\mathsf{TJ}}


\newcommand{\symdiff}[2]{#1 \vartriangle #2}





\newcommand{\ini}{0}
\newcommand{\tar}{r}
\newcommand{\cliq}{C}

\newcommand{\TARrule}{\mathsf{TAR}}

\newcommand{\YES}{\mathsf{yes}}
\newcommand{\NO}{\mathsf{no}}


\newcommand{\TARins}[3]{\mathsf{TAR}(#1,#2,#3)}
\newcommand{\TSins}[2]{\mathsf{TS}(#1,#2)}
\newcommand{\TJins}[2]{\mathsf{TJ}(#1,#2)}

\newcommand{\distTAR}[3]{\mathsf{dist_{TAR}}(#1,#2,#3)}
\newcommand{\distTJ}[2]{\mathsf{dist_{TJ}}(#1,#2)}
\newcommand{\distTS}[2]{\mathsf{dist_{TS}}(#1,#2)}

\newcommand{\distTARG}[4]{\mathsf{dist_{TAR}}(#1,#2,#3,#4)}
\newcommand{\distTJG}[3]{\mathsf{dist_{TJ}}(#1,#2,#3)}
\newcommand{\distTSG}[3]{\mathsf{dist_{TS}}(#1,#2,#3)}

\newcommand{\cgraph}{\mathcal{R}}
\newcommand{\cvertex}{\mathcal{V}}
\newcommand{\cedge}{\mathcal{E}}

\newcommand{\Mset}[1]{\mathcal{M}(#1)}
\newcommand{\Msetv}[2]{\mathcal{M}(#1; #2)}

\newcommand{\subH}{H}
\newcommand{\subHp}{H^\prime}
\newcommand{\intH}{\subH}

\newcommand{\dumo}{d_{\ini}}
\newcommand{\dumt}{d_{\tar}}





\newenvironment{listing}[1]{\begin{list}{*}{\settowidth{\labelwidth}{#1}\setlength{\leftmargin}{\labelwidth}\advance \leftmargin by 12pt
\setlength{\itemsep}{0pt}\setlength{\parsep}{0pt}\setlength{\topsep}{0pt}\setlength{\parskip}{0pt}}}{\end{list}}

\newcounter{one}
\setcounter{one}{1}
\newcommand{\one}{{\rm \roman{one}}}
\newcounter{two}
\setcounter{two}{2}
\newcommand{\two}{{\rm \roman{two}}}
\newcounter{three}
\setcounter{three}{3}
\newcommand{\three}{{\rm \roman{three}}}
\newcounter{four}
\setcounter{four}{4}
\newcommand{\four}{{\rm \roman{four}}}
\newcounter{five}
\setcounter{five}{5}
\newcommand{\five}{{\rm \roman{five}}}











\begin{document}
\title{Reconfiguration of Cliques in a Graph}

\author{
Takehiro Ito\inst{1} \and 
Hirotaka Ono\inst{2} \and
Yota Otachi\inst{3}
}

\institute{
	Graduate School of Information Sciences, 
	Tohoku University, \\
    Aoba-yama 6-6-05, Sendai, 980-8579, Japan.\\
\email{takehiro@ecei.tohoku.ac.jp}
\and	
	Faculty of Economics, 
	Kyushu University, \\
	Hakozaki 6-19-1, Higashi-ku, Fukuoka, 812-8581, 
	Japan.\\
\email{hirotaka@econ.kyushu-u.ac.jp}
\and
    School of Information Science, JAIST, \\
Asahidai 1-1, Nomi, Ishikawa 923-1292, Japan.\\
\email{otachi@jaist.ac.jp}
}

\maketitle

	\begin{abstract}
	We study reconfiguration problems for cliques in a graph, which determine whether there exists a sequence of cliques that transforms a given clique into another one in a step-by-step fashion. 
	As one step of a transformation, we consider three different types of rules, which are defined and studied in reconfiguration problems for independent sets.
	We first prove that all the three rules are equivalent in cliques.
	We then show that the problems are PSPACE-complete for perfect graphs, while we give polynomial-time algorithms for several classes of graphs, such as even-hole-free graphs and cographs.  
	In particular, the shortest variant, which computes the shortest length of a desired sequence, can be solved in polynomial time for chordal graphs, bipartite graphs, planar graphs, and bounded treewidth graphs.
	\end{abstract}
\vspace{-2em}

	\begin{figure}[b]
	\vspace{-1em}
		\centering
		\includegraphics[width=0.8\linewidth]{fig/example.eps}
	\vspace{-1em}
	\caption{A sequence  of cliques in the same graph, where the vertices in cliques are depicted by large (blue) circles (tokens).}
\label{fig:example}
	\end{figure}



\section{Introduction}
Recently, {\em reconfiguration problems} attract attention 
in the field of theoretical computer science. 
The problem arises when we wish to find a step-by-step transformation between 
two feasible solutions of a problem such that 
all intermediate results are also feasible and 
each step abides by a fixed reconfiguration rule 
(i.e., an adjacency relation defined on feasible solutions of the original problem).
This kind of reconfiguration problem has been studied extensively 
for several well-known problems, including 
{\sc satisfiability}~\cite{Kolaitis}, 
{\sc independent set}~\cite{Bon14,HearnDemaine2005,IDHPSUU,KaminskiMM12,Wro14}, 
{\sc vertex cover}~\cite{INZ14,MNR14},
{\sc clique}, {\sc matching}~\cite{IDHPSUU}, 
{\sc vertex-coloring}~\cite{BC09},
and so on.
(See also a recent survey~\cite{van13}.)

	It is well known that independent sets, vertex covers and cliques are related with each other. 
	Indeed, the well-known reductions for NP-completeness proofs are essentially the same for the three problems~\cite{GJ79}.
	Despite reconfiguration problems for independent sets and vertex covers are two of the most well studied problems, we have only a few known results for reconfiguration problems for cliques (as we will explain later). 
	In this paper, we thus investigate the complexity status of reconfiguration problems for cliques systematically, and show that the problems can be solved in polynomial time for a variety of graph classes, in contrast to independent sets and vertex covers.  

\subsection{Our problems and three rules}

	Recall that a {\em clique} of a graph  is a vertex subset of  in which every two vertices are adjacent. 
(Figure~\ref{fig:example} depicts seven different cliques in the same graph.)
	Suppose that we are given two cliques  and  of , and imagine that a token is placed on each vertex in . 
	Then, we are asked to transform  into  by abiding a prescribed reconfiguration rule on cliques.
	In this paper, we define three different reconfiguration rules on cliques, which were originally defined as the reconfiguration rules on independents sets~\cite{KaminskiMM12}, as follows:
\begin{list}{*}{\settowidth{\labelwidth}{}\setlength{\leftmargin}{\labelwidth}\advance \leftmargin by 5pt
	\setlength{\itemsep}{5pt}\setlength{\parsep}{0pt}\setlength{\topsep}{5pt}\setlength{\parskip}{0pt}}
	\item[] {\em Token Addition and Removal} ( rule): 
    We can either add or remove a single token at a time 
    if it results in a clique of size at least a given threshold . 
For example, in the sequence  in \figurename~\ref{fig:example}, every two consecutive cliques follow the  rule for the threshold .
    In order to emphasize the threshold , we sometimes call this rule the  rule. 

	\item[] {\em Token Jumping} ( rule): 
    A single token in a clique  can ``jump'' to any vertex in  if it results in a clique.
    For example, consider the sequence  in \figurename~\ref{fig:example}, then two consecutive cliques  and  follow the  rule for each .

	\item[]{\em Token Sliding} ( rule): 
    We can slide a single token on a vertex  in a clique  to another vertex  in  if  it results in a clique and there is an edge  in .
    For example, consider the sequence  in \figurename~\ref{fig:example}, then two consecutive cliques  and  follow the  rule, because  and  are adjacent.
	\end{list}
	A sequence  of cliques of a graph  is called a {\em reconfiguration sequence} between two cliques  and  under  (or , ) if two consecutive cliques  and  follow the  (resp., , ) rule for all .
	The \emph{length} of a reconfiguration sequence is defined to be the number of cliques in the sequence minus one, that is, the length of   is .

	Given two cliques  and  of a graph  (and an integer  for ), \textsc{clique reconfiguration} under  (or , ) is to determine whether there exists a reconfiguration sequence between  and  under  (resp., , ). 
	For example, consider the cliques  and  in \figurename~\ref{fig:example}; let  for . 
	Then, it is a -instance under the  and  rules as illustrated in \figurename~\ref{fig:example}, but is a -instance under the  rule.

	In this paper, we also study the shortest variant, called \textsc{shortest clique reconfiguration}, under each of the three rules which computes the shortest length of a reconfiguration sequence between two given cliques under the rule.
	We define the shortest length to be infinity for a -instance, and hence this variant is a generalization of \textsc{clique reconfiguration}. 

\subsection{Known and related results}
	
	Ito et al.~\cite{IDHPSUU} introduced \textsc{clique reconfiguration} under , and proved that it is PSPACE-complete in general. 
	They also considered the optimization problem of computing the maximum threshold  such that there is a reconfiguration sequence between two given cliques  and  under . 
	This maximization problem cannot be approximated in polynomial time within any constant factor unless ~\cite{IDHPSUU}.

	\textsc{Independent set reconfiguration} is one of the most well-studied reconfiguration problems, defined for independent sets in a graph. 
	Kami\'nski et al.~\cite{KaminskiMM12} studied the problem under ,  and . 
	It is well known that a clique in a graph  forms an independent set in the complement  of , and vice versa.
	Indeed, some known results for \textsc{independent set reconfiguration} can be converted into ones for \textsc{clique reconfiguration}.
However, as far as we checked, only two results can be obtained for \textsc{clique reconfiguration} by this conversion, because we take the complement of a graph.
(These results will be formally discussed in Section~\ref{subsec:independent-clique}.)

	In this way, only a few results are known for \textsc{clique reconfiguration}. 
	In particular, there is almost no algorithmic result, and hence it is desired to develop efficient algorithms for the problem and its shortest variant. 

\subsection{Our contribution}

	In this paper, we embark on a systematic investigation of the computational status of \textsc{clique reconfiguration} and its shortest variant. 
	Figure~\ref{fig:results} summarizes our results, which can be divided into the following four parts.
\smallskip

\begin{list}{*}{\settowidth{\labelwidth}{(3)}\setlength{\leftmargin}{\labelwidth}\advance \leftmargin by 5pt
	\setlength{\itemsep}{5pt}\setlength{\parsep}{0pt}\setlength{\topsep}{0pt}\setlength{\parskip}{0pt}}
	\item[(1)] \emph{Rule equivalence} (Section~\ref{sec:rules}): We prove that  all rules ,  and  are equivalent in \textsc{clique reconfiguration}.
	Then, any complexity result under one rule can be converted into the same complexity result under the other two rules. 
In addition, based on the rule equivalence, we show that \textsc{clique reconfiguration} under any rule is PSPACE-complete for perfect graphs, and is solvable in linear time for cographs.

	\item[(2)] \emph{Graphs with bounded clique size} (Section~\ref{subsec:boundedclique}): We show that the shortest variant under any of ,  and  can be solved in polynomial time for such graphs, which include bipartite graphs, planar graphs, and bounded treewidth graphs.
	Interestingly, \textsc{independent set reconfiguration} under any rule remains PSPACE-complete even for planar graphs~\cite{BC09,HearnDemaine2005} and bounded treewidth graphs~\cite{Wro14}. 
	Therefore, this result shows a nice difference between the reconfiguration problems for cliques and independent sets. 

	\item[(3)] \emph{Graphs with polynomially many maximal cliques} (Section~\ref{subsec:polymany}): We  show that \textsc{clique reconfiguration} under any of ,  and  can be solved in polynomial time for such graphs, which include even-hole-free graphs, graphs of bounded boxicity, and -subdivision-free graphs.
	
	\item[(4)] \emph{Chordal graphs} (Section~\ref{sec:chordal}): We give a linear-time algorithm to solve the shortest variant under any of ,  and  for chordal graphs.
	Note that the clique size of chordal graphs is not always bounded, and hence this result is independent from Result (2) above. 
\end{list}
	Several proofs move to appendices. 


	\begin{figure}[t]
		\centering
		\includegraphics[width=0.9\linewidth]{fig/results.eps}
	\vspace{-1em}
	\caption{Our results under all rules ,  and . 
Each arrow represents the inclusion relationship between graph classes: 
 represents that  is properly included in ~\cite{BLS99}.
Graph classes for which \textsc{shortest clique reconfiguration} is solvable in polynomial time are indicated by thick (red) boxes, 
while the ones for which \textsc{clique reconfiguration} is solvable in polynomial time are indicated by thin (blue) boxes.}
	\vspace{-1em}
	\label{fig:results}
	\end{figure}




	\section{Preliminaries}
	In this section, we introduce some basic terms and notation. 

\subsection{Graph notation}

	In this paper, we assume without loss of generality that graphs are simple.
	For a graph , we sometimes denote by  and  the vertex set and edge set of , respectively. 
For a graph , the \emph{complement}  of  is the graph such that  and .
	We say that a graph class  (i.e., a set of graphs) is \emph{closed under taking complements} if  holds for every graph . 


	In this paper, we deal with several graph classes systematically, and hence we do not define those graph classes precisely;
we simply give the properties used for proving  our results, with appropriate references. 

\subsection{Definitions for {\sc clique reconfiguration}}

	As explained in Introduction, we consider three (symmetric) adjacency relations on cliques in a graph.
	Let  and  be two cliques of a graph .
	Then,
	\begin{listing}{a}
	\item[] \emph{ under } for a nonnegative integer  if , , and  hold;
	\smallskip

	\item[] \emph{ under } if , , and  hold; and
	\smallskip

	\item[] \emph{ under } if , , , and  hold.
	\smallskip
	\end{listing}
	A sequence  of cliques of  is called a {\em reconfiguration sequence} between two cliques  and  under  (or , ) if  holds under  (resp., , ) for all .
	A reconfiguration sequence under  (or , ) is simply called a \emph{-sequence} (resp., \emph{-sequence}, \emph{-sequence}).
	We write  under  (or , ) if there exists a -sequence (resp., -sequence, -sequence) between  and .
	Note that each clique in any -sequence is of size at least , while all cliques in any -sequence or -sequence have the same size.
	In addition, a reconfiguration sequence under any rule is {\em reversible}, that is,  if and only if .

	Let  be a nonnegative integer, and let  and  be two cliques of a graph .
	Then, we define , as follows:
	
	Given two cliques  and  of a graph  and a nonnegative integer , \textsc{clique reconfiguration} under  is to compute .
	By the definition,  if  or  hold, and hence we may assume without loss of generality that both  and  hold;
we call such an instance simply a -instance, and denote it by .
	
	For two cliques  and  of a graph , we similarly define  and .
	Given two cliques  and  of , we similarly define \textsc{clique reconfiguration} under  and , and denote their instance by .
	Then, we can assume that  holds in a - or a -instance .

	Given a -instance , let  be a -sequence in  between  and . 
	Then, the \emph{length} of  is defined to be the number of cliques in  minus one, that is, the length of  is .
	We denote by  the minimum length of a -sequence in  between  and ;
we let  if there is no -sequence in  between  and . 
	The shortest variant, \textsc{shortest clique reconfiguration}, under  is to compute . 
	Similarly, we define  and  for a - and a -instance , respectively. 
	Then, \textsc{shortest clique reconfiguration} under  or  is defined similarly. 
	We sometimes drop  and simply write ,  and  if it is clear from context.
	
	We note that \textsc{clique reconfiguration} under any rule is a decision problem asking for the existence of a reconfiguration sequence, and its shortest variant asks for simply computing the shortest length of a reconfiguration sequence. 
	Therefore, the problems do not ask for an actual reconfiguration sequence. 
	However, our algorithms proposed in this paper can be easily modified so that they indeed find a reconfiguration sequence.  


\section{Rule Equivalence and Complexity}
\label{sec:rules}

In this section, we first prove that all three rules ,  and  are equivalent in \textsc{clique reconfiguration}.
We then discuss some complexity results that can be obtained from known results for \textsc{independent set reconfiguration}.
	

\subsection{Equivalence of  and  rules} 

 and  rules are equivalent, as in the following sense.
	\begin{theorem} \label{the:TS=TAR}
	 and  rules are equivalent in \textsc{clique reconfiguration}, as follows{\rm :} 
		\begin{listing}{aaa}
		\item[{\rm (}a{\rm )}] for any -instance , a -instance  can be constructed in linear time such that   and {\rm ;} and
		\item[{\rm (}b{\rm )}] for any -instance , a -instance  can be constructed in linear time such that .
		\end{listing}
	\end{theorem}
	By Theorem~\ref{the:TS=TAR}(a), note that the reduction from  to  preserves the shortest length of reconfiguration sequences.
\medskip

	\noindent
	{\em Proof of Theorem~{\rm \ref{the:TS=TAR}(}a{\rm )}.}
	Let  be a -instance with .
	Then, as the corresponding -instance , we let ,  and ;
this -instance can be clearly constructed in linear time.
	We thus prove the following lemma, as a proof of Theorem~\ref{the:TS=TAR}(a).
	\begin{lemma} \label{lem:TS->TAR}
	Let  be a graph, and let  and  be any pair of cliques of  such that .
	Then,  and .
	\end{lemma}

	\noindent
	{\em Proof of Theorem~{\rm \ref{the:TS=TAR}(}b{\rm )}.}
	Let  be a -instance; 
note that  may hold, and both  and  hold.
	Then, as the corresponding -instance , let  and  be arbitrary subsets of size exactly ;
this -instance can be clearly constructed in linear time.
	We thus prove the following lemma, as a proof of Theorem~\ref{the:TS=TAR}(b).
	\begin{lemma} \label{lem:TS=TARb}
	Let  be a -instance, and let  and  be arbitrary subsets of size exactly .
	Then, .
	\end{lemma}

\subsection{Equivalence of  and  rules} 

 and  rules are equivalent, as in the following sense.
	\begin{theorem} \label{the:TJ=TAR}
	 and  rules are equivalent in \textsc{clique reconfiguration}, as follows{\rm :} 
		\begin{listing}{aaa}
		\item[{\rm (}a{\rm )}] for any -instance , a -instance  can be constructed in linear time such that   and {\rm ;} and
		\item[{\rm (}b{\rm )}] for any -instance , a -instance  can be constructed in linear time such that .
		\end{listing}
	\end{theorem}
	By Theorem~\ref{the:TJ=TAR}(a), note that the reduction from  to  preserves the shortest length of reconfiguration sequences.
\medskip

	\noindent
	{\em Proof of Theorem~{\rm \ref{the:TJ=TAR}(}a{\rm )}.}
	Let  be a -instance with .
	Then, as the corresponding -instance , we let ,  and ;
this -instance can be clearly constructed in linear time.
	We thus prove the following lemma, as a proof of Theorem~\ref{the:TJ=TAR}(a).
	\begin{lemma} \label{lem:TJ->TAR}
	Let  be a graph, and let  and  be any pair of cliques of  such that .
	Then,  and .
	\end{lemma}

	\noindent
	{\em Proof of Theorem~{\rm \ref{the:TJ=TAR}(}b{\rm )}.}
	Let  be a -instance; 
 may hold, and both  and  hold.
	We first give the following lemma.
	\begin{lemma}
	Let  be a -instance such that .
	Suppose that there exists an index  such that  and  is a maximal clique in .
	Then, . 
	\end{lemma}
	\begin{proof}
	Since  is maximal, there is no clique in  which can be obtained by adding a vertex to . 
	Furthermore, since , we cannot delete any vertex from  to keep the threshold . 
	Thus, there is no clique  in  such that  under .
	Since , we have . 
	\qed
	\end{proof}

	We thus assume without loss of generality that none of  and  is a maximal clique in  of size ;
note that the maximality of a clique can be determined in linear time. 
	Then, we construct the corresponding -instance , as in the following two cases (\one) and (\two):
	\begin{listing}{aaa}
	\item[(\one)] for each  such that , let  be an arbitrary subset of size exactly ; and
	\item[(\two)] for each  such that , let  be an arbitrary superset of size exactly .
	\end{listing}
	This -instance can be clearly constructed in linear time.
	We thus prove the following lemma, as a proof of Theorem~\ref{the:TJ=TAR}(b).
	\begin{lemma} \label{lem:TJ=TARb}
	Let  be a -instance, and let  be the corresponding -instance constructed above.
	Then, .
	\end{lemma}

\subsection{Results obtained from {\sc independent set reconfiguration}}
\label{subsec:independent-clique}

	We here show two complexity results for \textsc{clique reconfiguration}, which can be obtained from known results for \textsc{independent set reconfiguration}. 

	Consider a vertex subset  of a graph . 
	Then,  forms a clique in  if and only if  forms an independent set in the complement  of .
	Therefore, the following lemma clearly holds.
	\begin{lemma} \label{lem:clique-independent}
	Let  be a graph, and let  be a clique of  for each .
	Then,  is a -sequence of cliques in 
if and only if
 is a -sequence of independent sets in the complement  of .
	\end{lemma}

	By Lemma~\ref{lem:clique-independent} we can convert a complexity result for \textsc{independent set reconfiguration} under  for a graph class  into one for \textsc{clique reconfiguration} under  for  if the graph class  is closed under taking complements. 
	Note that, by Theorems~\ref{the:TS=TAR} and \ref{the:TJ=TAR}, any complexity result under one rule can be converted into the same complexity result under the other two rules. 

	\begin{proposition} \label{pro:perfect}
	\textsc{Clique reconfiguration} is PSPACE-complete for perfect graphs under all rules ,  and .
	\end{proposition}

\begin{proposition} \label{pro:cograph}
	\textsc{Clique reconfiguration} can be solved in linear time for cographs under all rules ,  and .
	\end{proposition}






	\section{Polynomial-Time Algorithms} \label{sec:polytime}
	In this section, we show that \textsc{clique reconfiguration} is solvable in polynomial time for several graph classes. 
	We deal with two types of graph classes, that is, graphs of bounded clique size (in Section~\ref{subsec:boundedclique}) and graphs having polynomially many maximal cliques (in Section~\ref{subsec:polymany}).

	\subsection{Graphs of bounded clique size}
	\label{subsec:boundedclique}
	
	In this subsection, we show that \textsc{shortest clique reconfiguration} can be solved in polynomial time for graphs of bounded clique size; 
as we will explain later, such graphs include bipartite graphs, planar graphs, and graphs of bounded treewidth.
	For a graph , we denote by  the size of a maximum clique in .
	Then, we have the following theorem. 
	\begin{theorem} \label{the:boundedclique}
	Let  be a graph with  vertices such that  for a positive integer . 
	Then, \textsc{shortest clique reconfiguration} under any of ,  and  can be solved in time  for . 
\end{theorem}
	
	It is well known that  for any planar graph , and  for any bipartite graph .
	We thus have the following corollary. 
	\begin{corollary}
	\textsc{Shortest clique reconfiguration} under ,  and  can be solved in polynomial time for planar graphs and bipartite graphs.
	\end{corollary}
	
	By the definition of treewidth~\cite{BodlaenderDDFLP13}, we have  for any graph  whose treewidth can be bounded by a positive integer .
	By Theorem~\ref{the:boundedclique} this observation gives an -time algorithm for \textsc{shortest clique reconfiguration}.
	However, for this case, we can obtain a faster fixed-parameter algorithm, where the parameter is the treewidth , as follows.
	\begin{proposition} \label{pro:treewidth}
	Let  be a graph with  vertices whose treewidth is bounded by a positive integer .
	Then, \textsc{shortest clique reconfiguration} under any of ,  and  can be solved for  in time , where  is some constant.
	\end{proposition}

	Proposition~\ref{pro:treewidth} implies that \textsc{shortest clique reconfiguration} under any of ,  and  can be solved in time  for chordal graphs  when parameterized by the size  of a maximum clique in , where  is the number of vertices in  and  is some constant; because the treewidth of a chordal graph  can be bounded by the size of a maximum clique in  minus one~\cite{RS86}. 
	However, we give a linear-time algorithm to solve the shortest variant under any rule for chordal graphs in Section~\ref{sec:chordal}.


	\subsection{Graphs with polynomially many maximal cliques}
	\label{subsec:polymany}
	
	In this subsection, we consider the class of graphs having polynomially many maximal cliques, which properly contains the class of graphs with bounded clique size (in Section~\ref{subsec:boundedclique}). 
	Note that, even if a graph  has a polynomial number of maximal cliques,  may have a super-polynomial number of cliques. 
\begin{theorem} \label{the:poly-many-maxcliques}
	Let  be a graph with  vertices and  edges, and let  be the set of all maximal cliques in . 
	Then, \textsc{clique reconfiguration} under any of ,  and  can be solved for  in time .
	\end{theorem}

	Before proving Theorem~\ref{the:poly-many-maxcliques}, we give the following corollary.
	\begin{corollary} \label{cor:maximal}
	\textsc{Clique reconfiguration} under ,  and  can be solved in polynomial time for even-hole-free graphs, graphs of bounded boxicity, and -subdivision-free graphs.
	\end{corollary}
	\begin{proof}
	By Theorem~\ref{the:poly-many-maxcliques} it suffices to show that the claimed graphs have polynomially many maximal cliques.
	Polynomial bounds on the number of maximal cliques are shown
for even-hole-free graphs in~\cite{SilvaV07},
for graphs of bounded boxicity in~\cite{Spinrad03},
and for -subdivision-free graphs in~\cite{LeeO14}.
	\qed
	\end{proof}


	In this subsection, we prove Theorem~\ref{the:poly-many-maxcliques}. 
	However, by Theorems~\ref{the:TS=TAR}(a) and \ref{the:TJ=TAR}(a) it suffices to give such an algorithm only for the  rule.

	Let  be any -instance.
	Then, we define the \emph{-intersection maximal-clique graph} of , denoted by , as follows:
		\begin{listing}{aaa}
		\item[(\one)] each node in  corresponds to a clique in ; and 
		\item[(\two)] two nodes in  are joined by an edge if and only if  holds for the corresponding two maximal cliques  and  in .  
		\end{listing}
	Note that any maximal clique in  of size less than  is contained in  as an isolated node.
	We now give the key lemma to prove Theorem~\ref{the:poly-many-maxcliques}.
	\begin{lemma} \label{lem:clique-path}
	Let  be a graph, and let  and  be any pair of cliques in  such that  and .
	Let  and  be arbitrary maximal cliques in .
	Then,  under  if and only if  contains a path between the two nodes corresponding to  and .
	\end{lemma}

	\noindent
	{\bf Proof of Theorem~\ref{the:poly-many-maxcliques}.}

	For any graph  with  vertices and  edges, Tsukiyama et al.~\cite{TsukiyamaIAS77} proved that the set  can be computed in time .
	Thus, we can construct  in time .
	By the breadth-first search on  which starts from an arbitrary maximal clique (node) , we can check in time  whether  has a path to a maximal clique .
	Then, the theorem follows from Lemma~\ref{lem:clique-path}.
	\qed









	\section{Linear-Time Algorithm for Chordal Graphs}
	\label{sec:chordal}
	
	Since any chordal graph is even-hole free, by Corollary~\ref{cor:maximal} \textsc{clique reconfiguration} is solvable in polynomial time for chordal graphs. 
	Furthermore, we have discussed in Section~\ref{subsec:boundedclique} that the shortest variant is fixed-parameter tractable for chordal graphs when parameterized by the size of a maximum clique in a graph. 
	However, we give the following theorem in this section.
	\begin{theorem} \label{the:chordal}
	\textsc{Shortest clique reconfiguration} under any of ,  and  can be solved in linear time for chordal graphs. 
	\end{theorem}

	In this section, we prove Theorem~\ref{the:chordal}. 
	By Theorems~\ref{the:TS=TAR}(a) and \ref{the:TJ=TAR}(a) it suffices to give a linear-time algorithm for a -instance;
recall that the reduction from / to  preserves the shortest length of reconfiguration sequences.

	Our algorithm consists of two phases.
The first is a linear-time reduction from a given -instance  for a chordal graph  to a -instance  for an interval graph  such that . 
	The second is a linear-time algorithm for interval graphs.


\medskip

\noindent
	{\bf Definitions of chordal graphs and interval graphs.}

	A graph is a \emph{chordal graph} if every induced cycle is of length three.
	Recall that  is the set of all maximal cliques in a graph , and we denote by  the set of all maximal cliques in  that contain a vertex . 
A tree  is a  \emph{clique tree} of a graph  if it satisfies the following conditions:
	\begin{listing}{aa}
	\item[-] each node in  corresponds to a maximal clique in ; and 
	\item[-] for each , the subgraph of  induced by  is connected.
	\end{listing}
	It is known that a graph is a chordal graph if and only if it has a clique tree~\cite{Gavril74}.
	A clique tree of a chordal graph can be computed in linear time (see~\cite[\S 15.1]{Spinrad03}).

	A graph is an \emph{interval graph} if it can be represented as the intersection graph of intervals on the real line.
	A \emph{clique path} is a clique tree which is a path.
	It is known that a graph is an interval graph if and only if it has a clique path~\cite{FulkersonG65,GilmoreH64}.







\subsection{Linear-time reduction from chordal graphs to interval graphs}

	In this subsection, we describe the first phase of our algorithm. 

	Let  be any -instance for a chordal graph , and let  be a clique tree of .
	Then, we find an arbitrary pair of maximal cliques  and  in  (i.e., two nodes in ) such that  and .
	Let  be the unique path in  from  to . 
	We define a graph  as the subgraph of  induced by the maximal cliques .
	Note that  is an interval graph, because  forms a clique path. 






	The following lemma implies that the interval graph  has a -sequence  such that , and hence yields that  holds. 
	\begin{lemma} \label{lem:consecutive-cliques}
	Let  be a -instance for a chordal graph , and let  be a clique tree of .
	Suppose that  is a shortest -sequence in  from  to .
Let  be the path in  from  to  for any pair of maximal cliques  and .
	Then, there is a monotonically increasing function  such that  for each .
\end{lemma}

	Although Lemma~\ref{lem:consecutive-cliques} implies that  holds for the interval graph , it seems difficult to find two maximal cliques  and  (and hence construct  from ) in linear time. 
	However, by a small trick, we can construct an interval graph  in linear time such that , as follows.
	\begin{lemma} \label{lem:chordal->interval}
	Given a -instance  for a chordal graph , one can obtain a subgraph  of  in linear time such that  is an interval graph,  and .
	\end{lemma}


\subsection{Linear-time algorithm for interval graphs} \label{subsec:interval}

	In this subsection, we describe the second phase of our algorithm.

Let  be a given interval graph, and we assume that its clique path  has  and . 
	Note that we can assume that , that is,  has at least two maximal cliques;
otherwise we can easily solve the problem in linear time (as in Lemma~\ref{lem:tar-dist-in-a-clique} in Appendix~\ref{app:oneclique}).
	For a vertex  in , let  and ;
the indices  and  are called the \emph{-value} and \emph{-value} of , respectively.
	Note that  if and only if .
	For an interval graph , such a clique path  and the indices  and  for all vertices  can be computed in linear time~\cite{UeharaU07}.

	Let  be a -instance.
	We assume that ,  and ;
otherwise, we can remove the maximal cliques  with  and  in linear time.
	Our algorithm greedily constructs a shortest -sequence from  to , as follows:
	\begin{listing}{aaa}
	\item[(1)] if  and , then remove a vertex with the minimum -value in  from ; 
	\item[(2)] otherwise add a vertex in  if any; 
					if no such vertex exists, add a vertex with the maximum -value in .
	\end{listing}
	We regard the clique obtained by the operations above as ;
if necessary, we shift the indices of  so that  and  hold; and repeat.
	If  and none of the operations above is possible, we can conclude that  is a -instance.
	The correctness proof of this greedy algorithm and the estimation of its running time can be found in Appendix~\ref{app:interval-algo}.

	This completes the proof of Theorem~\ref{the:chordal}. 


	\section{Conclusion}
	In this paper, we have systematically shown that \textsc{clique reconfiguration} and its shortest variant can be solved in polynomial time for several graph classes. 
	As far as we know, this is the first example of a reconfiguration problem such that it is PSPACE-complete in general, but is solvable in polynomial time for such a variety of graph classes.

	\subsection*{Acknowledgments}
	This work is partially supported by MEXT/JSPS KAKENHI 25106504 and 25330003 (T.~Ito), 25104521, 26540005 and 26540005 (H.~Ono), and 24106004 and 25730003 (Y.~Otachi).

\bibliographystyle{abbrv}
\begin{thebibliography}{99}


\bibitem{BodlaenderDDFLP13}
Bodlaender, H.L., Drange, P.G., Dregi, M.S., Fomin, F.V., Lokshtanov, D., Pilipczuk, M.:
An  -approximation algorithm for treewidth.
Proc.\ of FOCS 2013, pp.~499--508 (2013)

\bibitem{BC09}
Bonsma, P., Cereceda, L.: 
Finding paths between graph colourings: PSPACE-completeness and superpolynomial distances. 
Theoretical Computer Science 
410, pp.~5215--5226 (2009)  

\bibitem{Bon14}
Bonsma, P.: 
Independent set reconfiguration in cographs. 
Proc. of WG 2014, LNCS 8747, pp.~105--116 (2014)

\bibitem{BLS99} 
Brandst\"adt, A., Le, V.B., Spinrad, J.P.:
Graph Classes: A Survey, SIAM (1999)

\bibitem{SilvaV07}
da~Silva, M.V.G., Vukovi\'c, K.:
\newblock Triangulated neighborhoods in even-hole-free graphs.
\newblock {\em Discrete Mathematics}, 307:1065--1073, 2007.

\bibitem{FulkersonG65}
Fulkerson, D.R., Gross., O.A.:
Incidence matrices and interval graphs.
Pacific J.~Mathematics 15, pp.~835--855 (1965)

\bibitem{GJ79}
Garey, M.R., Johnson, D.S.:
Computers and Intractability: A Guide to the Theory of {NP}-Completeness.
Freeman, San Francisco (1979)

\bibitem{Gavril74}
Gavril, F.:
The intersection graphs of subtrees in trees are exactly the chordal graphs.
J.~Combinatorial Theory, Series B 16, pp.~47--56 (1974)

\bibitem{GilmoreH64}
Gilmore, P.C., Hoffman, A.J.:
A characterization of comparability graphs and of interval graphs.
Canadian J.~Mathematics 16, pp.~539--548 (1964)

\bibitem{Kolaitis}
Gopalan, P., Kolaitis, P.G., Maneva, E.N., Papadimitriou, C.H.:
The connectivity of Boolean satisfiability: computational and structural dichotomies.
SIAM J.~Computing 38, pp.~2330--2355 (2009)  

\bibitem{HearnDemaine2005}
Hearn, R.A., Demaine, E.D.: 
PSPACE-completeness of sliding-block puzzles and other problems through the nondeterministic constraint logic model of computation. 
Theoretical Computer Science 
343, pp.~72--96 (2005) 


\bibitem{IDHPSUU}
Ito, T., Demaine, E.D., Harvey, N.J.A., Papadimitriou, C.H., Sideri, M., Uehara, R., Uno, Y.: 
On the complexity of reconfiguration problems.
Theoretical Computer Science 
412, pp.~1054--1065 (2011)

\bibitem{INZ14}
Ito, T., Nooka, H., Zhou, X.:
Reconfiguration of vertex covers in a graph.
To appear in Proc. of IWOCA 2014. 

\bibitem{KaminskiMM12}
Kami\'nski, M., Medvedev, P., Milani, M.: 
Complexity of independent set reconfigurability problems.
Theoretical Computer Science 439, pp.~9--15 (2012)

\bibitem{LeeO14}
Lee, C., Oum, S.:
Number of cliques in graphs with forbidden subdivision.
{\tt  arXiv:1407.7707} (2014)

\bibitem{MNR14}
Mouawad, A.E., Nishimura, N., Raman, V.: 
Vertex cover reconfiguration and beyond.
Proc.~of ISAAC~2014, LNCS 8889, pp.~452--463 (2014)

\bibitem{RS86}
Robertson, N., Seymour, P.D.: 
Graph minors. I\hspace{-.1em}I. Algorithmic aspects of tree-width. 
J.~Algorithms 7, pp.~309--322 (1986)

\bibitem{Spinrad03}
Spinrad, J.P.:
Efficient Graph Representations.
American Mathematical Society (2003)

\bibitem{TsukiyamaIAS77}
Tsukiyama, S., Ide, M., Ariyoshi, H., Shirakawa, I.:
A new algorithm for generating all the maximal independent sets.
SIAM J.~Computing 6, pp.~505--517 (1977)

\bibitem{UeharaU07}
Uehara, R., Uno, Y.:
On computing longest paths in small graph classes.
International J.~Foundations of Computer Science 18, pp.~911--930 (2007)

\bibitem{van13}
van den Heuvel, J.:
The complexity of change.
Surveys in Combinatorics 2013, 
London Mathematical Society Lecture Notes Series 409 (2013).

\bibitem{Wro14}
Wrochna, M.:
Reconfiguration in bounded bandwidth and treedepth.
{\tt  arXiv:1405.0847} (2014)

\end{thebibliography}

\newpage
\appendix

	\section{Proofs Omitted from Section~\ref{sec:rules}}
	
	\subsection{Proof of Lemma~\ref{lem:TS->TAR}}

	To prove Lemma~\ref{lem:TS->TAR}, we first give the following lemma.	
	\begin{lemma} \label{lem:ar<=k+1}
	Let  be a graph, and let  and  be any pair of cliques of  such that  and  under .
	Then, there exists a shortest -sequence  from  to  such that  and  for every .
	\end{lemma}
	\begin{proof}
	Let  be a shortest -sequence from  to  which minimizes the sum .
Since each clique in the -sequence  is of size at least , it suffices to show that  holds for every .

	Let  be an index satisfying , and suppose for a contradiction that .
	By the definition of , we have .
	Let  and .
	Note that, since  is shortest, we have  and hence .
	We now replace the clique  by another clique , and obtain the following sequence  of cliques:
	
	Since  and , we have  and hence  under .
	Furthermore, since , we have  under . 
	Therefore,  is a -sequence between  and .

	Note that  is of length , and hence it is a shortest -sequence between  and .
	Since , we have  and hence 
	
	This contradicts the assumption that  is a shortest -sequence from  to  which minimizes the sum .
	\qed
	\end{proof}
\medskip



	\noindent
	{\bf Proof of Lemma~\ref{lem:TS->TAR}.}

We first prove that  if .
	In this case, there exists a -sequence between  and ; 
let  be a shortest one, that is,  and .
	Then, since this is a -sequence, we have  for each , where  and . 
(See \figurename~\ref{fig:TS}(a).)
	Therefore,   forms a clique of size .
	Then, for each , we replace each sub-sequence  with , and obtain the following sequence  of cliques:
	
	Notice that  under  for each , because .
	Therefore, the sequence  above is a -sequence from  to , and hence . 
	Furthermore, by the construction,  is of length .
	Therefore, we have 
	

	\begin{figure}[t]
		\centering
		\includegraphics[width=0.6\linewidth]{fig/TS.eps}
	\vspace{-1em}
	\caption{Illustration for Lemma~\ref{lem:TS->TAR}.}
	\vspace{-1em}
	\label{fig:TS}
	\end{figure}

	We then prove that  if .
	In this case, there exists a -sequence between  and ; 
let  be a shortest one, that is,  and .
	Furthermore, by Lemma~\ref{lem:ar<=k+1} we can assume that  and  for every . 
	Then, observe that  for every , and let .
(See \figurename~\ref{fig:TS}(b).)
	Since this -sequence  is shortest, we have .
	Furthermore, since both  and  belong to the clique , they are adjacent.
	Therefore, for every , we have  under ;
we replace each sub-sequence  with , and obtain .
	In this way,  is a -sequence from  to , and hence . 
	Furthermore, the length of  is , and hence 
	

	By Eqs.~(\ref{eq:TAR<=2TS}) and (\ref{eq:2TS<=TAR}) we have .
	\qed



	
	\subsection{Proof of Lemma~\ref{lem:TS=TARb}}
Since  and , we have  under  by deleting the vertices in  from  one by one. 
	Similarly, we have  under ;
recall that any reconfiguration sequence is reversible.
	Since , by Lemma~\ref{lem:TS->TAR} we have 
	

	We now prove that  if .
	In this case, by Eq.~(\ref{eq:TS=TAR}) we have  and hence  under .
	Thus,  holds under , and hence . 
	
	We finally prove that  if .
	In this case, since , we have  under .
	Therefore,  holds under , and hence . 
	By Eq.~(\ref{eq:TS=TAR}) we then have .
\qed





	\subsection{Proof of Lemma~\ref{lem:TJ->TAR}}
	
	We first give the following lemma, which can be obtained from the same arguments as in Lemma~\ref{lem:ar<=k+1} by just shifting the threshold by one.	
	\begin{lemma} \label{lem:ar<=k}
	Let  be a graph, and let  and  be any pair of cliques of  such that  and  under .
	Then, there exists a shortest -sequence  from  to  such that  and  for every .
	\end{lemma}


	\noindent
	{\bf Proof of Lemma~\ref{lem:TJ->TAR}.}

We first prove that  if .
	In this case, there exists a -sequence between  and ; 
let  be a shortest one, that is,  and .
	For each , let  and . 
	Then, we replace each sub-sequence  with  for each , and obtain the following sequence  of cliques:
	
	Notice that  under  for each , because  and .
	Therefore, the sequence  above is a -sequence from  to , and hence . 
	Furthermore, by the construction,  is of length .
	Therefore, we have 
	
	
	We then prove that  if .
	In this case, there exists a -sequence between  and ; 
let  be a shortest one, that is,  and .
	Furthermore, by Lemma~\ref{lem:ar<=k} we can assume that  and  for every . 
	For every , let  and .
	Since  is shortest, we have .
	Then, for every , we have  under ;
we replace each sub-sequence  with , and obtain .
	In this way,  is a -sequence from  to , and hence . 
	Furthermore, the length of  is , and hence 
	

	By Eqs.~(\ref{eq:TAR<=2TJ}) and (\ref{eq:2TJ<=TAR}) we have .
	\qed


	
	
	
	\subsection{Proof of Lemma~\ref{lem:TJ=TARb}}
Similarly as in the proof of Lemma~\ref{lem:TS=TARb}, in both cases (\one) and (\two), we have  and  under .
	Note that . 
	Then, by Lemma~\ref{lem:TJ->TAR} we have
	
	
	We first prove that  if .
	In this case, by Eq.~(\ref{eq:TJ=TAR}) we have , and hence  under .
	Thus,  holds under , and hence . 
	
	We then prove that  if .
	In this case, since , we have  under .
	Therefore,  holds under , and hence . 
	By Eq.~(\ref{eq:TJ=TAR}) we then have .
\qed




	\subsection{Proof of Proposition~\ref{pro:perfect}}
Kami\'nski et al.~\cite[Theorem~3]{KaminskiMM12} proved that \textsc{independent set reconfiguration} under  is PSPACE-complete for perfect graphs.
	Since the class of perfect graphs is closed under taking complements~\cite{Lovasz72}, by Lemma~\ref{lem:clique-independent} \textsc{clique reconfiguration} under  is PSPACE-complete for perfect graphs.
	Then, Theorems~\ref{the:TS=TAR}(b) and \ref{the:TJ=TAR}(b) imply that \textsc{clique reconfiguration} remains PSPACE-complete for perfect graphs under  and , too.
	\qed




	\subsection{Proof of Proposition~\ref{pro:perfect}}
From the definition, the class of cographs is closed under taking complements, and we note that the complement of a cograph can be computed in linear time~\cite{CorneilPS85}.
	Bonsma~\cite{Bon14} proved that \textsc{independent set reconfiguration} under  is solvable in linear time for cographs, and hence by Lemma~\ref{lem:clique-independent} we can solve \textsc{clique reconfiguration} under  in linear time for cographs. 
	Then, Theorems~\ref{the:TS=TAR}(a) and \ref{the:TJ=TAR}(a) imply that \textsc{clique reconfiguration} can be solved in linear time for cographs under  and , too.
	\qed





	\section{Proofs Omitted from Section~\ref{sec:polytime}}
	
	\subsection{Proof of Theorem~\ref{the:boundedclique}}
By Theorems~\ref{the:TS=TAR}(a) and \ref{the:TJ=TAR}(a) it suffices to give an -time algorithm for a -instance;
	recall that the reduction from / to  preserves the shortest length of reconfiguration sequences.
	Note that, however, the arguments for  below can be applied to the other rules  and , and one can obtain algorithms directly for  and  rules.

	Let  be any -instance such that .
	Then, the number of cliques of size at least  in  can be bounded by .
	We now construct a \textit{reconfiguration graph} , as follows: 
		\begin{listing}{aaa}
		\item[(\one)] each node in  corresponds to a clique of  with size at least ; and 
		\item[(\two)] two nodes in  are joined by an edge if and only if  holds under  for the corresponding two cliques  and .  
		\end{listing}
	This reconfiguration graph  can be constructed in time  as follows:
	we first enumerate all cliques in time  by checking all  vertex subsets of size at most ;
	we then add edges from each clique to its  subsets with one less vertex.
	The graph  has  nodes and  edges. 
	Then, there is a -sequence between  and  if and only if there is a path in  between the two corresponding nodes. 
	Therefore, by the breadth-first search on  which starts from the node corresponding to , we can check if  has a desired path or not in time . 
	Furthermore, if such a path exists, it corresponds to a shortest -sequence between  and . 
	\qed



	\subsection{Proof of Proposition~\ref{pro:treewidth}}
We first compute a tree-decomposition  with width  in  time, where  is some constant,
	by using the algorithm in \cite{BodlaenderDDFLP13}.
	Additionally, we can assume that the number of bags in  is ~\cite{BodlaenderDDFLP13}.
	By the definition of the tree-decomposition, every clique in  is included in at least one bag of .
	Since the width of  is , each bag in  contains at most  vertices of .
	Thus, there are at most  cliques in each bag of , and hence we can conclude that  has  cliques.
	Then, the proposition follows, because we can construct a reconfiguration graph  in time , similarly as in the proof of Theorem~\ref{the:boundedclique}.
	\qed




	\subsection{Proof of Lemma~\ref{lem:clique-path}}
We first prove the if-part.
	Suppose that there is a path  in  from the node  to the node .
	Let , and let  be any clique in  of size  for each ; 
such a clique  exists because . 
	Then,  holds under  because  and hence  forms a clique of  for each .
	We thus have  under . 
	Since both  and  are contained in the same maximal clique , we have  and hence  holds under .
 
	We then prove the only-if-part.
	Suppose that there is a -sequence  such that  and .
	Let  be the subgraph of  induced by all nodes (i.e., maximal cliques in ) that contain at least one clique in .
	Then, it suffices to show that  is connected;
then  has a path from any node  to any node . 
	Suppose for a contradiction that  is not connected. 
	Then, there exists an index  such that the cliques  and  are contained in different maximal cliques  and  which belong to different connected components in . 
	In this case,  must be obtained by adding a vertex  to , that is, ;
otherwise both  and  are contained in the same maximal clique .
	Since  is a -sequence, we have  and hence .
	Then, since  and , we have . 
	Therefore,  and  must be joined by an edge in  and hence in .
	This contradicts the assumption that  and  are contained in different connected components in . 
	We have thus proved that  is connected, and hence there is a path in  from any node  to any node .
	\qed





	\section{Proofs Omitted from Section~\ref{sec:chordal}}
	
	\subsection{Proof of Lemma~\ref{lem:consecutive-cliques}} \label{app:oneclique}
	We first prove the following lemma, which can be applied to any graph. 
	\begin{lemma} \label{lem:tar-dist-in-a-clique}
	For two cliques  and  in a graph , suppose that  also forms a clique in .
	Then,  for every integer .
	Furthermore,  every clique in an arbitrary shortest -sequence from  to  consists only of vertices in .
	\end{lemma}
	\begin{proof}
	We first prove that  holds for every integer , by constructing a -sequence between  and  of length , as follows:
we first add the vertices in  to  one by one, and obtain the clique ; and 
we then delete the vertices in  from  one by one, and obtain the clique .
	Since the minimum size of a clique in this sequence is , this is a -sequence for every integer . 
	Furthermore, the length of this -sequence is .
	Therefore, we have .
	
	We then prove that  holds for every integer .
	Since , there exists at least one -sequence between  and  as explained above. 
	Note that, in an arbitrary -sequence between  and , every vertex in  must be either deleted or added at least once. 
	Therefore, we have .
	
	We have thus proved that  holds for every integer .
	Consider an arbitrary shortest -sequence  from  to . 
	Then, every vertex in  must be either deleted or added by  at least once.
	Therefore, if  deletes or adds a vertex not in , then the length of  is strictly greater than .
	This contradicts the assumption that  is shortest.
	We can thus conclude that every clique in an arbitrary shortest -sequence from  to  consists only of vertices in .
	\qed
	\end{proof}

	Let  be a graph, and let .
	A vertex subset  is called an \emph{-separator} of  if any two vertices  and  do not belong to the same component in , where  denotes the subgraph of  induced by the vertex set .
\medskip

	\noindent
	{\bf Proof of Lemma~\ref{lem:consecutive-cliques}.}

We prove the statement by induction on the length  of the unique path  in  between  and .

	First, consider the case where .
	Then, since  and , both  and  are contained in the same maximal clique .
	Therefore,  forms a clique, and hence by Lemma~\ref{lem:tar-dist-in-a-clique} every shortest -sequence passes through cliques consisting of vertices only in .
	Thus, we set  for all .
\medskip

	Next, consider the case where . 
	We assume that , because otherwise we can set  for all  similarly as for the case .
	Then, by the definition of a clique tree,  forms a -separator of  (see~\cite[Lemma 4.2]{BP93chordal}).

	We now claim that there exists at least one clique  in the shortest -sequence  such that .
	Suppose for a contradiction that  for all .
	Let  be an arbitrary vertex in  for each .
	Since  is a -sequence, either  or  holds for each  and hence  forms a clique.
	Therefore, the vertices  and  in  are either the same or adjacent.
	This implies that the subgraph of  induced by  is connected, and hence it contains a path from  to .
	However, since  and , this contradicts the assumption that  is a -separator.
 
	As the induction hypothesis, assume that the statement is true for the length .
	Let  be an arbitrary clique in  such that . 
	Note that, since  is shortest,  is a shortest -sequence from  to . 
	Then, since , Lemma~\ref{lem:tar-dist-in-a-clique} implies that  passes through cliques consisting of vertices only in , that is,
	
holds for each .
	Let  for each , and let  for each .
	Note that  is a shortest -sequence from  to . 
	Furthermore, ,  and   is a path in  of length .
	Therefore, by the induction hypothesis, there is a monotonically increasing function  such that 
	
for all .
	Now we construct a mapping , as follows:
	
	Since  is a monotonically increasing function,  is too. 
	Furthermore, by Eqs.~(\ref{eq:mono-one}) and (\ref{eq:mono-two}) we have  for all .
	Thus,  satisfies the desired property.
	\qed






	\subsection{Proof of Lemma~\ref{lem:chordal->interval}}
	Before giving our linear-time reduction, we give the following lemma.

	\begin{lemma} \label{lem:never-appear-again}
	Suppose that  is a shortest -sequence in a chordal graph .
	Let  and  be two indices in  such that .
	If there is a vertex  in , then  holds for all .
	\end{lemma}
	\begin{proof}
	Suppose for a contradiction that the statement does not hold.
	We may assume without loss of generality that  for every  by setting  as large as possible and  as small as possible.
	Then, observe that  and .

	Let  be a clique tree of .
	Let  be the path in  from  to  for any pair of maximal cliques  and .
	By Lemma~\ref{lem:consecutive-cliques} there is a monotonically increasing function  such that  for each .
	Then,  for each .
	Recall that, by the definition of a clique tree, the subgraph of  induced by  is connected.
	Since , we can conclude that the vertex  is contained in all maximal cliques .

	Therefore, for each , both  and  hold, and hence  forms a clique which is contained in .
	Furthermore,  under  for each , because  under .
	Recall that  and , and hence we replace the sub-sequence  of length  with the following sequence of length :
	
	However, this contradicts the assumption that  is shortest.
	\qed
\end{proof}
\medskip

\noindent
	{\bf Proof of Lemma~\ref{lem:chordal->interval}.}

We first add two dummy vertices  and  to a given chordal graph .
	We then join  with all vertices in  by adding new edges to ;
similarly, we join  with all vertices in .
	Let  be the resulting graph.
	Then,  is also a chordal graph, because the dummy vertices cannot create any new induced cycle of length more than three.
	Note that each of  and  forms a maximal clique in .
	Furthermore, in the set  of all maximal cliques in , the only maximal cliques  and  contain  and , respectively. 
	
	We now construct a clique tree  of  in linear time~\cite[\S 15.1]{Spinrad03}.
	Then,  contains two nodes  and .
	Therefore, we can find the path  in  in linear time.
	Let  be the subgraph of  induced by the maximal cliques .
	Then,  is an interval graph. 
	Furthermore, since  and , Lemma~\ref{lem:consecutive-cliques} implies that 
	
	Let  be the graph obtained from  by removing the dummy vertices  and .
	Since  is an interval graph,  is also an interval graph.
	In this way,  can be constructed in linear time. 
	
	Now we claim that 
	
and
	
	Then, by Eqs.~(\ref{eq:Hpp=Gp})--(\ref{eq:Hpp=H}) we have , as required.
	Note that .
	Thus, to prove Eqs.~(\ref{eq:Gp=G}) and (\ref{eq:Hpp=H}), it suffices to show that there is a shortest -sequence in  (or in ) from  to  which does not pass through any clique containing  or .   
	
	Let  be a shortest -sequence in  (or in ) from  to .
	Suppose for a contradiction that  holds for some .
(The proof for  is the same.)
	Since , Lemma~\ref{lem:never-appear-again} implies that there exists a pair of indices  and  in  such that  and  holds for all .
	Recall that  is a maximal clique in  (or in ), and that no other maximal clique in  (or in ) contains .
	This implies that  for each .
	Since  and , it follows that  and hence  forms a clique.
	Now, by Lemma~\ref{lem:tar-dist-in-a-clique} every shortest -sequence from  to  passes through cliques consisting of vertices only in .
	Since , this contradicts the assumption that  is shortest.
\qed




	\subsection{Correctness of the algorithm for interval graphs} \label{app:interval-algo}
	
	In this subsection, we prove the correctness of the greedy algorithm in Section~\ref{subsec:interval} and estimate its running time.
	For a vertex  in a graph , let  and let .
	We denote by  the degree of , that is, .
\medskip

	We first prove the correctness of Step~(1) of the algorithm:
if  and , then remove a vertex  with the minimum -value in  from .
The following lemma ensures that this operation preserves the shortest length of reconfiguration sequences.
	\begin{lemma} \label{lem:greedily-removing-a-shortest-interval}
	Suppose that  and .
	Let  be any vertex with the minimum -value in .
	Then, 
	
	\end{lemma}
	\begin{proof}
	First, observe that  since .
	Thus,  holds for every vertex .
	Consider any clique  in  such that  under .
	Then, either (\one)  for some vertex , or (\two)  for some vertex ;
recall that  and . 
	Therefore, it suffices to verify the following two inequalities:
	
for any vertex ; and 
	
for any vertex .
\medskip

	We first prove Eq.~(\ref{eq:delete}). 
	Let  be any vertex in , and let  be a shortest -sequence from  to  .
	By Lemma~\ref{lem:never-appear-again} we have  for all .
	On the other hand, since , there exists an index  such that ;
Lemma~\ref{lem:never-appear-again} implies that  if and only if .
	Then,  forms a clique for each , because  for the vertex .
	For each , we replace the clique  in  with the clique , and obtain the following sequence  of cliques:
	
	Since  is a -sequence, we have .
	Furthermore,  under  for all , since  under .
	Finally, since , we have  and hence  under .
	Therefore,  is a -sequence from  to  , which has the same length  as the shortest -sequence  from  to  .
	We have thus verified Eq.~(\ref{eq:delete}). 
\medskip  

 	We then prove Eq.~(\ref{eq:add}). 
	Let  be any vertex in , and let  be a shortest -sequence from  to  .
	Let  be the index such that  if and only if .
	Since , all cliques  are contained in . 
	Furthermore, since , we have  and hence   forms a clique.
	Then, Lemma~\ref{lem:tar-dist-in-a-clique} implies that .
	Note that, since the sub-sequence  is shortest, we have .
	On the other hand, consider the clique ;
note that, since , we have . 
	Since , the set  forms a clique.
	Then, Lemma~\ref{lem:tar-dist-in-a-clique} implies that .
	We now prove that 
	
	Indeed, we show that , as follows.
	Since ,  and , we have 
	
	Let  be a shortest -sequence from  to .
	Then, by Eq.~(\ref{eq:add-one}) the length of  is at most .
	We replace the sub-sequence  of length  with the -sequence .
	Then,  is a -sequence from  to , whose length is at most .
	We have thus verified Eq.~(\ref{eq:add}). 
\qed
\end{proof}

	We then prove the correctness of Step~(2) of the algorithm:
if no vertex can be deleted from  according to Lemma~\ref{lem:greedily-removing-a-shortest-interval}, then add a vertex  chosen by the following lemma, with preserving the shortest length of reconfiguration sequences.
	\begin{lemma} \label{lem:greedily-taking-a-longest-interval}
	Assume that  or .
	Let  be any vertex in  if exists{\rm ;} 
otherwise, let  be any vertex with the maximum -value in .
	Then,
	
	\end{lemma}
	\begin{proof}
	Note that, if , then no vertex can be deleted from  due to the size constraint .
	On the other hand, if , then by Lemma~\ref{lem:never-appear-again} no shortest -sequence from  to  deletes any vertex  in , because .
	Therefore, in any shortest -sequence  from  to , the clique  must be obtained from  by adding a vertex .
	Furthermore, since ,  and  is a clique, the added vertex  must be in . 
	Thus, to prove the lemma, it suffices to show that
	
for any vertex . 

	Let   be any vertex in , and let  be a shortest -sequence from  to .
	For each , let 
	
	We will prove below that  is a -sequence from  to .
	Then, since  is of length , Eq.~(\ref{eq:two-one}) follows. 
	
	We first claim that  and . 
	Since  and , we have . 
	On the other hand, if  is chosen from , then  and hence .
	Otherwise,  holds, and hence  is not contained in ;
we then have .

	We then prove that  forms a clique of size at least  for each , and prove that  under  for each . 
	Since  is a -sequence, by Eq.~(\ref{eq:two-two}) we have . 
	Therefore, it suffices to show that  forms a clique such that  for each .
	This claim trivially holds for the case where both  and  hold, because  is a -sequence.
	By symmetry, we thus assume that , that is, both  and  hold.
	Then, there are the following three cases to consider;
note that, since both  and  hold and  under , we do not need to consider the case where both  and  hold.
\medskip

\noindent
	{\bf Case (\one)  and .}
	
	In this case, we have . 
	Since  and  under , we have .
	Notice that  and , because  or  has the maximum -value in . 
	Therefore,  holds.
	Then, since  is a clique,  forms a clique.
\medskip

\noindent
	{\bf Case (\two) .} 

	In this case, we have . 
	Recall that both  and  hold. 
	Then, since  and  under , we have .
	Since , we thus have  and hence . 
	Furthermore, since  and  is a clique,  forms a clique.
\medskip

\noindent
	{\bf Case (\three) .} 
	
	In this case, we have . 
	Recall again that both  and  hold. 
	Then, since  and  under , we have .
	Since , we thus have  and hence . 
	Then, .
	Since  holds and  is a clique,  forms a clique.
\medskip

	In this way, we have proved that  is a -sequence from  to , and hence Eq.~(\ref{eq:two-one}) holds as we have mentioned above. 
\qed
\end{proof}




	The correctness of the greedy algorithm in Section~\ref{subsec:interval} follows from Lemmas~\ref{lem:greedily-removing-a-shortest-interval} and \ref{lem:greedily-taking-a-longest-interval}.
	Therefore, to complete the proof of Theorem~\ref{the:chordal}, we now show that the algorithm runs in linear time. 
\medskip

\noindent
	{\bf Estimation of the running time.}

	Lemma~\ref{lem:never-appear-again} implies that each vertex is removed at most once and added at most once in any shortest -sequence.
	Therefore, it suffices to show that each removal and addition of a vertex  can be done in time , because .

	We first estimate the running time for Step~(1) of the algorithm. 
	We first check whether both  and  hold or not. 
	These conditions can be checked in constant time by maintaining  and .
	We then find a vertex  with the minimum -value in ; this can be done in time .
	After the removal of , the clique  may be included by some of ; 
in such a case, we need to shift the indices of  so that  and  hold. 
	To do so, we compute the shift-value , and set  for each  and  for each vertex .
	However, since we just have to compute and store only the shift-value  in the actual process, this post-process can be done also in time .
	Since , we have .
	Therefore, Step~(1) can be executed in time .

	We then estimate the running time for Step~(2) of the algorithm. 
	We find a vertex  which either is in  or has the maximum -value in .
	In either case, such a vertex  can be found in time .
	Since , the addition of  can be done in time .



\begin{thebibliography}{[BPS85]}
\bibitem[BP93]{BP93chordal}
Blair, J.R.S., Peyton, B.:
An introduction to chordal graphs and clique trees.
Graph Theory and Sparse Matrix Computation 56, pp.~1--29 (1993)

\bibitem[CPS85]{CorneilPS85}
Corneil, D.G., Perl, Y., Stewart, L.K.:
A linear recognition algorithm for cographs.
SIAM J.~Computing 14, pp.~926--934 (1985)

\bibitem[L72]{Lovasz72}
Lov{\'{a}}sz, L.:
Normal hypergraphs and the perfect graph conjecture.
Discrete Mathematics 2, pp.~253--267 (1972)
\end{thebibliography}

 
\end{document}
