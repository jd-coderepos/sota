\documentclass[runningheads]{llncs}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{cite}
\usepackage{subfig,wrapfig}
\usepackage{graphicx}
\usepackage{times}
\usepackage[bookmarks=false]{hyperref}
\usepackage[textsize=footwww.google.notesize]{todonotes}

\newcommand{\martin}[1]{\todo[color=yellow!40]{MN: #1}}

\newcommand{\romanp}[1]{\todo[color=green!40]{RP: #1}\xspace}
\newcommand{\benjamin}[1]{\todo[color=blue!40]{BN: #1}}

\newcommand{\ignaz}[1]{\todo[color=gray!40]{IR: #1}}

\newtheorem{assumption}{Assumption}
\newcommand{\comment}[1]{{\color{red} #1}}
\newcommand{\rowsum}[1]{{\overset{\rightarrow}{#1}}}
\newcommand{\columnsum}[1]{{\downarrow\!#1}}

\newcommand{\true}{\ensuremath{\textnormal{TRUE}}}
\newcommand{\false}{\ensuremath{\textnormal{FALSE}}}

\newcommand{\bvec}[1]{\mathbf{#1}}

\newcommand{\psolved}{\ensuremath{r_\textnormal{solved}}}

\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}
\renewcommand{\floatpagefraction}{0.35}



\newcounter{constr} 
\setcounter{constr}{0}
\newcommand{\constr}[1]{\noindent \refstepcounter{constr}\theconstr #1}
 
\newcommand{\rephrase}[3]{\noindent\textbf{#1~#2.}~\emph{#3}}

\title{Using ILP/SAT to determine pathwidth, visibility
representations, and other grid-based graph drawings\thanks{T. Biedl
is supported
by NSERC, M. NÃ¶llenburg is supported by the Concept for the Future of
KIT under grant YIG 10-209.}}
\author{Therese Biedl\inst{1}
\and Thomas Bl\"asius\inst{2}
\and Benjamin Niedermann\inst{2}\and Martin~N\"{o}llenburg\inst{2}\and Roman Prutkin\inst{2}\and Ignaz Rutter\inst{2}}
\authorrunning{Biedl \and Bl\"asius \and Niedermann \and
N\"{o}llenburg \and Prutkin \and Rutter}
\titlerunning{ILP/SAT formulation for grid-based graph
representations}
\institute{David R.~Cheriton School of Computer
Science, University of Waterloo, Canada
\and
Institute of Theoretical Informatics, Karlsruhe Institute of
Technology, Germany
}


\begin{document}

\maketitle
\begin{abstract}
We present a simple and versatile formulation of grid-based graph
representation problems as an integer linear program (ILP) and a
corresponding SAT instance. In a grid-based representation vertices
and edges correspond to axis-parallel boxes on an underlying integer
grid; boxes can be further constrained in their shapes and
interactions by additional problem-specific constraints. We describe a
general -dimensional model for grid representation problems. This
model can be used to solve a variety of  NP-hard graph problems,
including pathwidth, bandwidth, optimum -orientation, 
area-minimal (bar-) visibility representation, boxicity- graphs
and others. We implemented SAT-models for all of the above problems
and evaluated them on the Rome graphs collection. The experiments show
that our model successfully solves NP-hard problems within few minutes
on small to medium-size Rome graphs.
\end{abstract}

\section{Introduction}
Integer linear programming (ILP) and Boolean satisfiability testing
(SAT) are indispensable and widely used tools in solving many hard
combinatorial optimization and decision problems in practical
applications~\cite{bhmw-hs-09,cbd-aip-10}. In graph drawing,
especially for planar graphs, these methods are not frequently
applied. A few notable exceptions
are crossing
minimization~\cite{cmb-aecm-08,bcegjk-bacnp-08,jm-2scmpeha-97,gsm-okpcm-11}, orthogonal graph drawing with vertex and
edge labels~\cite{bdln-odgwvel-05} and metro-map
layout~\cite{nw-dlhqm-11}. Recent work by Chimani et
al.~\cite{cz-upt-13} uses SAT formulations for testing upward
planarity. All these approaches have in common that they exploit
problem-specific properties to derive small and efficiently solvable
models, but they do not generalize to larger classes of problems. 

In this paper we propose a generic ILP model that is flexible enough
to capture a large variety of different grid-based graph layout
problems, both polynomially-solvable and NP-complete. We demonstrate
this broad applicability by adapting the base model to six different
NP-complete example problems: pathwidth, bandwidth, optimum
-orientation, minimum area bar- and bar -visibility representation, and boxicity- testing. 
For minimum-area visibility representations and boxicity this is, to the best of our knowledge, the first implementation of an exact solution
method.
Of course this flexibility comes at the cost of losing some of the
efficiency of more specific approaches. Our goal, however, is not to
achieve maximal performance for a specific problem, but to provide an
easy-to-adapt solution method for a larger class of problems, which
allows quick and simple prototyping for instances that are not too
large. Our ILP models can be easily translated into equivalent SAT
formulations, which exhibit better performance in the implementation
than the ILP models themselves. We illustrate the usefulness of our
approach by an experimental evaluation that applies our generic model
to the above six NP-complete problems using the well-known Rome
graphs~\cite{rome} as a benchmark set. Our evaluation shows that,
depending on the problem, our model can solve small to medium-size
instances (sizes varying from about 25 vertices and edges for bar-
visibility testing up to more than 250 vertices and edges, i.e., all
Rome graphs, for optimum -orientation) to optimality within a few
minutes. 
In Section~\ref{sec:genericmodel} we introduce generic grid-based
graph representations and formulate an ILP model for -dimensional
integer grids. We demonstrate how this model can be adapted to six
concrete one-, two- and -dimensional grid-based graph layout
problems in Sections~\ref{se:problems:1dim} and~\ref{sec:higherdim}.
In Section~\ref{sec:exp} we evaluate our implementations and report
experimental results. The implementation is available from
\url{i11www.iti.kit.edu/gdsat}. 
 

\section{Generic Model for Grid-Based Graph Representations}\label{sec:genericmodel}

In this section we explain how to express -dimensional boxes in a
-dimensional integer grid as constraints of an ILP or a SAT
instance. In the subsequent sections we use these boxes as
basic elements for representing vertices and edges in problem-specific ILP and SAT models.
We need a simple observation that shows that we can restrict ourselves
to boxes in integer grids.

\newcommand{\lemTransformToInteger}{
Any set  of  boxes in  can be transformed into another set  of~ closed boxes on 
the integer grid  
such that two boxes intersect in  if and only if they intersect in .
}
\begin{lemma}
\label{lem:transformToInteger}
\label{lem:gtransformToInteger}
\lemTransformToInteger
\end{lemma}

\begin{proof}
Let  be a set of -dimensional intervals.
Then we prove that there exists a set  of
-dimensional intervals such that:
\begin{itemize}
\item For all ,  for some
  .  Put differently,
   has integral coordinates in the range ,
  and it is closed at both ends.
\item  if and only if .
\end{itemize}


It suffices to show this for 1-dimensional intervals; we can then
transform each dimension of the intervals separately to achieve the
results for arbitrary dimensions.
  
For 1-dimensional intervals, presume that , where we
make no assumption over whether the ends of  are open or closed.
We first create a sorted orientation of the  endpoints of these
intervals.  We sort them by their coordinate, and in case of a tie
take 
first right endpoints where the interval is open, 
then left endpoints where the interval is closed,
then right endpoints where the interval is closed 
and then left endpoints where the interval is open.  
Presume that  describes this order, i.e., for any endpoint 
 gives the index of  in this sorted order.
One easily verifies that  intersects 

if and only if  intersects .  Here it does not even matter
whether we make the new intervals open or closed, since all endpoints
are distinct integers.

Now compact  by not using a new integer whenever we have
an endpoint of an interval.  More precisely, split  into
maximal subsequences such that each subsequence consists of multiple
(possibly none) left endpoints of intervals, followed by one right
endpoint of an interval.
There are 
 such subsequences, since there are  right endpoints.
Enumerate the subsequences in order, and let  be
the number assigned to the subsequence that contains ,
for any endpoint  of an interval.
Now for  
define  to be .  We
claim
that this satisfies the conditions.  Clearly the endpoints of the
intervals
are integers in the range , so we only must 
argue that intersections are unchanged.
This held when going over from  to
.
But going over from  to , we changed the relative
order 
of endpoints only by contracting a number
of left endpoints, followed by one right endpoint.  Since 
 is closed at both ends, this does not change intersections.
\qed
\end{proof}


\subsection{Integer Linear Programming Model}\label{sec:ilpmodel}
We will describe our model in the general case for a -dimensional
integer grid, where . Let  be a bounded -dimensional integer grid,
where  denotes the set of integers .
In a \emph{grid-based graph representation} vertices and/or edges are
represented as -dimensional boxes in . A \emph{grid
box}  in  is a subset  of , where  for
all . In the following we describe a set of ILP
constraints that together create a non-empty box for some object  .
 We denote this ILP as .

We first extend  by a margin of dummy points to .
We use three sets of binary variables:

The variables  indicate whether grid point  belongs to the box representing~ () or not (). Variables  and  indicate whether the box of  may start or end at position  in dimension . We use~ to denote the -th coordinate of grid point  and  to denote the -th -dimensional unit vector. If  we will drop the dimension index of the variables to simplify the notation.
The following constraints model a box in  (see Fig.~\ref{fig:example2d} for an example): 


Constraint~\eqref{eq:margin} creates a margin of zeroes
around~.
Constraint~\eqref{eq:nonempty} ensures that the shape representing~
is non-empty, and constraints~\eqref{eq:oneb} and~\eqref{eq:onee}
provide exactly one start and end position in each dimension.
Finally, due to constraints~\eqref{eq:start} and~\eqref{eq:end} each
grid point inside the specified bounds belongs to~ and all other
points don't.

\begin{figure}[tb]
	\centering
		\includegraphics[scale=1]{fig/model}
	\caption{\small Example of a 2-dimensional  grid
 with a 
	 grid box and the corresponding variable assignments.}
	\label{fig:example2d}
	\vspace{-2ex}
\end{figure}


\newcommand{\lemboxtext}{The ILP  defined by constraints~(\ref{eq:x})--(\ref{eq:end}) correctly models all non-empty grid boxes in .
}

\begin{lemma}\label{lem:correctbox}
\lemboxtext
\end{lemma}

\begin{proof}
  Let  be a non-empty
grid box in . We initially set all variables to the
default value of zero. For every  we set
. Moreover, we set  and
 for all . We claim that this
assignment satisfies all constraints. Constraints
(\ref{eq:x})--(\ref{eq:e}) are obviously satisfied, as well as 
constraints~(\ref{eq:margin}) and~(\ref{eq:nonempty}) since  is
nonempty but does not intersect the margin . For every  we set exactly one
variable  and , namely for  and
; this satisfies constraints~(\ref{eq:oneb})
and~(\ref{eq:onee}). Constraints~(\ref{eq:start}) and~(\ref{eq:end})
are trivially satisfied if   for
two neighboring grid points in dimension . Otherwise, if
 and , then
 must equal , and if  and
, then  must equal .
  Let  be a row of  in the -th
dimension indexed by a grid point~. By  we
denote the -th point  in row . We know that   
for . If
, then all indicator variables for
 are equal to zero and constraints~(\ref{eq:start})
and~(\ref{eq:end}) are satisfied. Otherwise, the indicator variables
for row  contain a consecutive sequence of 's for
points  with . But since
 and  the
constraints~(\ref{eq:start}) and~(\ref{eq:end}) are also satisfied for
 and .

Now consider a valid variable assignment according to
constraints~(\ref{eq:x})--(\ref{eq:end}) and define . By constraints~(\ref{eq:margin})
and~(\ref{eq:nonempty})  contains at least one point. Let  be a dimension of  and let  be any
row in the -th dimension. By constraints~(\ref{eq:oneb})
and~(\ref{eq:onee}) there is exactly one coordinate , where
 and one coordinate , where . Thus by
constraints~(\ref{eq:start}) and~(\ref{eq:end}) 
is either empty or a single interval of consecutive points between
 and . Since this is true for
any , the set  must be a (non-empty) grid box. \qed
\end{proof}


Our example ILP models in Sections~\ref{se:problems:1dim}
and~\ref{sec:higherdim} extend ILP  by additional
constraints controlling additional properties of vertex and edge
boxes. For instance, boxes can be easily constrained to be single
points, to be horizontal or vertical line segments, to intersect if
and only if they are incident or adjacent in , to meet in endpoints
etc.
The definition of an objective function for the ILP depends on the
specific problem at hand and will be discussed in the problem
sections.
\subsection{Translating the ILP model into a SAT
model}\label{sec:satmodel}
In this section we explain shortly how ILP~ can be
translated into an equivalent SAT formulation with better
practical performance. The transformation of 
(including later problem-specific extensions) into a SAT instance,
i.e., a set of Boolean clauses, is straightforward. Let , , be positive integers and ,  be binary variables. Then most of our ILP
constraints belong to one of the following four types:
(i)~, 
(ii)~\mbox{,} 
(iii)~,
(iv)~. 

We translate a type-(i) constraint
into the clause~.
For a type-(ii) constraint we consider each tuple of  pairwise
distinct indices  and
 add the clause~. 
This gives us  clauses of size~.
A \mbox{type-(iii)} constraint is equivalent to~,
providing  clauses of size~.
A type-(iv) constraint 
is described as a type-(ii) and a type-(iii) constraint and thus needs
 clauses of size~
and  clauses of size~. 





\iffalse

Presume that for each vertex , we'd like to assign an interval
whose endpoints are integers in the range 
, .
  We will also assume that these intervals are closed at the 
  smaller end in each dimension, but open at the larger end; other
variants of intervals could easily be accommodated by shifting
indices by  as needed.  We define the following variables
for both the ILP and SAT formulation (we associate~1 with  
and~0 with ):
\begin{itemize}
\item  for every  and 
.
	The intended meaning is that  if and only if the point
	with coordinates 
	 belongs to the interval of~.  
\item  for every  
	and .
	The intended meaning is that the interval of  begins at
	coordinate  if and only if .\footnote{To make notations easier, we will in the following sometimes
use , or other variables that are ``out of bounds''.  Such
variables will then be identical to 0.}
\item  for every  
	and .
	The intended meaning is that the interval of  ends at
	index  if and only if .  
\end{itemize}
For the ease of understanding, we first present integer linear constraints
for the problem and translate them into SAT clauses later. 
\subsubsection{ILP formulation.}
\label{se:1dim:ilp}
We impose the following constraints (here, ``for all '' or ``'' 
means using all indices   where the corresponding variable is defined): 
\begin{itemize}
\item[(\constr{\label{c:ilp:frame}})] 
	 for 
	if  for some .
	The grid points at coordinates
	 
	only serve as a ``frame'' that is needed
	to force the begin and endpoints, but they would never belong
	to an interval.  (Some intervals may end at index , but
	since they are open at the larger endpoint in each dimension, we nevertheless
	have .)
\item[(\constr{\label{c:ilp:singleStartEnd}})] 
	 and 
	 for all .
	This enforces that the interval of every vertex 
	begins and ends exactly once.
\item[(\constr{\label{c:ilp:xStrat}})] 
	 for all  and all .
	This constraint ties the interval-indicators to the begin-indicators:
	if  begins at , then  must also be 1.  We could
	impose a few more constraints here (e.g. we must have 0 to the
	left of the beginning, and 0 at the end, but 1 to the left of
	the end), but these turn out to be not necessary due to other
	constraints.	
\end{itemize}
Finally, we have to make sure that 
exactly in the -dimensional box with bounds defined by~
and~. For clarity, we consider one- 
and two-dimensional cases separately.
\paragraph*{One-dimensional intervals.}
Let~. We add the following constraint
in addition to~(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd})
and~(\ref{c:ilp:xStrat}).
\begin{itemize}
  \item[(\constr{\label{c:1dim:ilp:interval}})] 
	 for all 
	and all .  This constraint means that the
	interval-indicators force the begin- and end-indicators.
	Namely, presume  changes from  to  at index .  
	Then the equation holds only if
	, so this forces the begin-indicator to be true.
	Likewise a switch of  from  to  forces the end-indicator
	to be true.
\end{itemize}
It is easy to see that if constraints
(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd}),
(\ref{c:ilp:xStrat}), (\ref{c:1dim:ilp:interval})
 are satisfied, then the sequence
 contains exactly one interval of 1s,
and it begins at  if and only if  and
ends at  if and only if  
(See Lemma~\ref{lem:1dim:ilp} in the Appendix).
\paragraph*{Two-dimensional intervals.}
Let~, , .
We introduce following additional variables:
\begin{itemize}
\item  for every  and 	
	with .  Hence
	 indicates the topmost row of the interval
	of .  This variable is not really needed since it 
	depends with equality on other variables,
	but serves to make later constraints easier to understand.
\item Likewise we define
	
	 and
	
	to indicate leftmost/bottommost/rightmost row/column of the interval
	of .
\end{itemize}
In addition to~(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd})
and~(\ref{c:ilp:xStrat}),
we impose the following constraints, where as before ``for all ''
or ``'' means ``over the range where the variables are defined'':
\begin{itemize}
\item[(\constr{\label{c:ilp:2dim:xEnd}})] 
	 .
\item[(\constr{\label{c:ilp:2dim:rows}})] 
	 ;~~.
These constraints force all rows before~ 
(such that )
and after~ 
(such that )
to only contain zeroes.
Also, for~ 
(such that  and )
and~,
it is , i.e. the left and right boundary of the rectangle of~
contains only ones.
\item[(\constr{\label{c:ilp:2dim:cols}})] 
	 ;~~.
These constraints force all columns before~ 
and after~ to only contain zeroes.
Also, for~ 
and~,
it is , i.e. the upper and lower boundary of the rectangle of~
contains only ones.
Together with the previous constraint, it is~ outside of the rectangle of~
and  on the boundary.
Since  for exactly one~ etc.,
the interior of the rectangle must be filled with ones.
\end{itemize}
[Correctness proof?]
\subsubsection{SAT formulation.}
\label{se:1dim:sat}



We use straightforward methods to translate 
integer linear constraints into SAT clauses.
Consider~ and binary variables 
, , .
For our formulation constraints 
of type
, 
, 
 (for ),
 are sufficient.
We translate the first one
into the clause~.
For the second type, for each  pairwise distinct,
we add the clause~. 
This gives us  clauses of size~.
The third constraint is equivalent to~,
providing  clauses of size~.
Thus, constraint 
is described by  clauses of size~
and  clauses of size~. 
The fourth constraint is equivalent to .
\fi
\section{One-dimensional Problems}
\label{se:problems:1dim}
In the following, let  be an undirected graph with~ and~. 
One-dimensional grid-based graph representations can be used to model vertices as intersecting intervals (one-dimensional boxes) or as disjoint points that induce a certain vertex order. We present ILP models for three such problems.


\subsection{Pathwidth}

The pathwidth of a graph  is a well-known graph
parameter with many equivalent definitions. We use the definition via the
smallest clique size of an interval supergraph.
More precisely, a graph is an {\em interval graph} if it can be
represented as intersection graph of 1-dimensional intervals.  A
graph  has {\em pathwidth}  if there exists an
interval graph  that contains  as a subgraph and for which all
cliques have size at most .
It is NP-hard to compute the pathwidth of an arbitrary graph and even
hard to approximate it~\cite{BodlaenderGKH91}. There are fixed-parameter algorithms for computing the pathwidth,
e.g.~\cite{BodlaenderK96}, however, we are not aware of any
implementations of these algorithms.  The only available implementations are exponential-time algorithms, 
e.g., in
sage\footnote{www.sagemath.org}. 

\begin{problem}[Pathwidth]\label{pb:pw}
	Given a graph , determine the pathwidth of~, i.e., the smallest integer  so that .
\end{problem}

There is an interesting connection between pathwidth and planar graph
drawings of small height.  Any planar graph that has a planar
drawing of height  has pathwidth at most ~\cite{FLW03}.
Also, pathwidth is a crucial ingredient in
testing in polynomial time whether a graph has a planar drawing of
height ~\cite{DFK+08}.

We create a one-dimensional grid representation of , in which every
vertex is an interval and every edge forces the two vertex intervals
to intersect. The objective is to minimize the maximum number of
intervals that intersect in any given point.
We use the ILP  for a grid , which
already assigns a non-empty interval to each vertex . We add
binary variables for the edges of , a variable 
representing the pathwidth of , and a set of additional
constraints as follows.

Our objective function is to minimize the value of  subject to the above constraints.

It is easy to see that every edge must be represented by some grid
point (constraint~(\ref{eq:pw:oneedge})), and can only use those grid
points, where the two end vertices intersect
(constraint~(\ref{eq:pw:edge})). Hence the intervals of vertices
define some interval graph  that is a supergraph of . 
Constraint (13) enforces that at most  intervals meet in any
point, which by Helly's property means that  has clique-size at
most . So  has pathwidth at most . 
By minimizing  we obtain the desired result. 
In our implementation we translate the ILP into a SAT instance
using the rules given in Section~\ref{sec:satmodel}. 
We test satisfiability
for fixed values of , starting with  and increasing it
incrementally until a solution is found.
\begin{theorem}
There exists an ILP/SAT formulation with  variables
and  constraints /  clauses of
maximum size  that has a solution of value  if and only
if  has pathwidth .
\end{theorem}

\par
With some easy modifications, the above ILP can be used 
for testing whether a graph is a (proper) interval graph. Section~\ref{sec:boxicity} shows that boxicity- graphs, the -dimensional generalization of interval graphs, can also be recognized by our ILP.


\iffalse

In this section, we create an integer program whose objective
function is the pathwidth of a given graph.
Recall that there are many equivalent definitions of pathwidth.
The one that we use is that a graph  has pathwidth  
if there exists a super-graph  of  that is a -colorable
interval graph.  Put differently, we can assign 1-dimensional
intervals to the vertices such that for every edge  of 
the intervals of  and  intersect, and any point belongs to at
most  intervals.  We call this an {\em interval representation}
of a graph of pathwidth .

If we have any interval representation of , then we may by
Lemma~\ref{lem:transformToInteger} presume
that they all have integer endpoints in the range 
and that they are closed at the left end and open at the right end.
Hence an interval representation corresponds to assigning
1-dimensional intervals to vertices as explained above, using .  
Now we only
need to incorporate that for every edge , the intervals
of  and  intersect, and that not too many intervals intersect
in one point.    Both are very easy.  We add the following variables:

\begin{itemize}
\item , with the intended meaning that 
	indicates a point where the 
	intervals corresponding to the endpoints of  intersect.
\item  is a variable that indicates the pathwidth.
\end{itemize}

We add the following constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:pw:1}})]
   for all , 
	i.e., every edge does in fact have
	a point where its endpoints intersect.
\item[(\constr{\label{c:1dim:pw:2}})] 
	 and  for every edge
	 and all~, i.e., the intervals of  and  indeed
	cover the point.
\item[(\constr{\label{c:1dim:pw:3}})]
  for all , i.e., no more than  intervals meet in a point.
\end{itemize}
and the objective of the integer program is then to minimize .

Directly from the definition of these constraints, and since we
know that the restrictions on  indeed define
1-dimensional intervals for , it follows that the resulting
value is the pathwidth of the graph.  Also note that the interval
of each vertex can be read from the solution of the integer
program, so solving it also gives us the path decomposition of
the graph.

\begin{theorem}
There exists an integer program with  variables
and constraints that has a solution of value  if and only
if  has pathwidth .
\end{theorem}

To minimize pathwidth using SAT, we create an SAT instance for each fixed value of~.
We start with~ and increase it incrementally,
until a solution is found.
Note that constraint~(\ref{c:1dim:pw:3}) produces 
clauses of size~.
\begin{theorem}
There exists a SAT instance with  variables
and  clauses
of maximum size~ that is satisfiable if and only
if  has pathwidth .
\label{thm:pw:sat}
\end{theorem}
\par
With some easy modifications, the above integer program can also be used 
for testing whether a graph is a (proper) interval graph; see 
Theorems~\ref{thm:int:ilp},\ref{thm:proper-int:ilp} 
in the appendix.

\fi

\subsection{Bandwidth}\label{sec:bandwidth}
The bandwidth of a graph  with  vertices is another classic graph parameter, which is NP-hard to compute~\cite{ccdg-bpgms-82}; due to the practical importance of the problem there are also a few approaches to find exact solutions to the bandwidth minimization problem.
For example,~\cite{bandwidth-exact} and~\cite{mcp-bbambm-08} use the
branch-and-bound technique combined with various heuristics. We
present a solution that can be easily described using our general
framework. However, regarding the running time, it cannot be expected
to compete with techniques specially tuned for solving the bandwidth
minimization problem.

Let  be a bijection that defines a
linear vertex order. The \emph{bandwidth} of  is defined as ,
i.e., the minimum length of the longest edge in  over all possible
vertex orders.


We describe an ILP that assigns the vertices of  to disjoint grid
points  and requires for an integer  that any pair of adjacent
vertices is at most  grid points apart. If the ILP has a solution,
then we know . We set  and add the
following two constraints:

Constraint~(\ref{eq:bw:onlyone}) guarantees that no grid point is
occupied by more than one vertex, and constraint~(\ref{eq:bw:dist})
requires that any two adjacent vertices are at most  grid points
apart.
We note that the variables  and  and their constraints
are not required in this model since in 
constraints~(\ref{eq:nonempty}) and~(\ref{eq:bw:onlyone}) suffice to
set exactly one variable  for every .
We do not need an objective function but rather test if the feasible
region is non-empty for a given .

\begin{theorem}
There exists an ILP/SAT formulation with  variables
and  constraints /  clauses of maximum size 
that has a solution if and only if
 has bandwidth . 
\end{theorem}





\subsection{Optimum -orientation}

Let  be an undirected graph and let  and  be two vertices of
 with .  An {\em -orientation} of  is an
orientation of the edges such
that  is the unique source and  is the unique sink~\cite{ET76}.  Such an
orientation can exist only if  is biconnected. Computing an
-orientation can be done in linear time~\cite{ET76,b-eo-02}, but
it is NP-complete to find an -orientation that minimizes the
length of the longest path from  to , even for planar
graphs~\cite{SZ10}. It has many
applications in graph drawing~\cite{pt-apsto-10} and beyond.

\begin{problem}[Optimum -orientation]\label{pb:st}
	Given a graph  and two vertices  with , find an orientation of  such that  is the only source,  is the only sink, and the length of the longest directed path from  to  is minimum.
\end{problem}


We now formulate an ILP that computes a \emph{height-
-orientation} of , i.e., an -orientation such that the
longest path has length at most  (if one exists).
We use the ILP  for  to assign
intervals to the vertices and edges of . Vertices are required to
occupy exactly one point, whereas edges must span at least two points.
The additional constraints are as follows:

Similarly to the ILP in Section~\ref{sec:bandwidth}, the variables
 and  and their constraints are not required for the
vertices, since constraints~(\ref{eq:nonempty})
and~(\ref{eq:st:one}) ensure that every vertex interval consists of a
single grid point. Constraint~(\ref{eq:st:edge}) guarantees that each
edge interval contains at least two points.
Constraint~(\ref{eq:st:beginend}) makes sure that every edge must
begin and end at the grid points occupied by its end vertices.
Finally, constraints~(\ref{eq:st:out}) and~(\ref{eq:st:in}) ensure
that every vertex except  has an outgoing edge and every vertex
except  has an incoming edge. Since  and
adjacent vertices cannot occupy the same grid point, we know that if
this ILP has a feasible solution, then the longest directed path from
 to  has length at most . Alternatively, we can set  and
use the objective function  to
minimize the position of the sink  and thus the longest path from
 to .

\begin{theorem}
There exists an ILP with  variables
and constraints that computes an optimum -orientation. 
Alternatively, there exists an ILP/SAT formulation with 
variables and  constraints /  clauses of
maximum size~ that has a solution if and only if a height-
-orientation of~ exists. 
\end{theorem}



\iffalse


We demonstrate this technique for two problems, both of which are NP-hard.
\paragraph{Bandwidth.}
The {\em bandwidth} is a graph parameter  that relates to proper
interval graphs the way pathwidth relates to interval graphs:
A graph has {\em bandwidth}  if it is a subgraph of
a proper interval graph that can be coloured with  colours.
Not surprisingly, the integer programs for testing
pathwidth can be combined with the constraints for a proper interval
graph to yield an integer program that computes the bandwidth of
a graph.  But we now show a much
simpler integer program.   An alternate
characterization says that a graph has bandwidth  if
and only if it has a vertex order  such that any
edge connects two vertices whose indices differ by at most .
We hence add variables  for every  and 
(the variables  and  are not needed)
and add constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:bw:1}})]
 , i.e., each vertex has an index.
\item[(\constr{\label{c:1dim:bw:2}})]
 , i.e., no two vertices can be at
	the same index.  This forces that every vertex has exactly one index.
\item[(\constr{\label{c:1dim:bw:3}})] 
  for all  and
	all ordered pairs  with ,
	i.e., if  is at position , then
	 is not allowed at position  or later.  Since we also
	impose the condition for , this implies that the indices
	of  and  are within distance .
\end{itemize}

\begin{theorem}
There exists an integer program with  variables
and  constraints that has a solution if and only if
 has bandwidth .
\end{theorem}
We note here that computing the bandwidth is NP-hard \cite{???}.
Constraints~(\ref{c:1dim:bw:1}), (\ref{c:1dim:bw:2}), (\ref{c:1dim:bw:3})
can be expressed using SAT clauses in the way described earlier.
\begin{theorem}
There exists a SAT instance with  variables
and  clauses 
of maximum size~ that is satisfiable if and only if
 has bandwidth~.
\label{thm:bw:sat}
\end{theorem} 



\paragraph{Computing -orders with few levels.}
Let  be an undirected graph and let  and  be two vertices of
.  An {\em -order} of  is an orientation of the edges such
that  is the unique source and  is the unique sink.  Such an
order can exist only if  is 2-connected.  It has many
applications in graph drawing and [...] 
We now formulate an integer program that expresses an -order
of a given graph.  To do so, we assign a 1-dimensional interval  to 
every vertex and a 1-dimensional interval to every edge.  We force
vertices to have a single point as an interval, while edges must
contain at least two points.  Using the end-information, we can then
force that every vertex (except  and ) has incoming and outgoing
edges.  Let  be some upper bound that we will fix later.

We hence have the following variables:
\begin{itemize}
\item  for every  and every .
	(We could use, but don't need,  and .)
\item  for every  and every .
\end{itemize}
We have the following constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:st:1}})]
 , i.e., each vertex is represented by one point.
\item[(\constr{\label{c:1dim:st:2}})]
For  we add constraints analogous to~(\ref{c:ilp:frame}),
\ldots,(\ref{c:1dim:ilp:interval})
to ensure that edge~ is represented
	by an interval as indicated by  that begins and ends
	as indicated by  and .
	These constraints ensure that if~ and~,
	then .
\item[(\constr{\label{c:1dim:st:3}})]
 , i.e., each edge has non-trivial length.
\item[(\constr{\label{c:1dim:st:4}})]
  for each  and each edge ,
	i.e., edge  begins at the point of  or .
\item[(\constr{\label{c:1dim:st:5}})]
  for each  and each edge ,
	i.e., edge  ends at the point of  or .  Since  has
	non-trivial length, but each vertex is a point, this implies
	that the two ends of  are the two different vertices.  This
	in turn implies that  and  cannot be at the same point.
\item[(\constr{\label{c:1dim:st:6}})]
  for all  and all .
	Thus every vertex  has an incident edge which begins
	at the point of .  Hence the other end of  comes later,
	which means that  has an outgoing edge.
\item[(\constr{\label{c:1dim:st:7}})]
  for all  and all .
	Similarly this forces that any  has an incoming edge.
\end{itemize}

Thus, any solution to this integer program yields an -order,
and vice versa, any -order yields a solution if we use .
However, it is unlikely that this would be used for computing -orders,
since the linear-time algorithm for doing so \cite{ET76} is very
simple.  But we can use this formulation to impose additional
constraints and hence compute solutions to NP-hard problems.

In particular, it is of interest in some graph drawing applications
to compute -orders that minimize the length of the longest
directed path from  to .  This problem is NP-hard even for
plane graphs \cite{SZ10}.
We claim:
\newcommand{\lemMinStText}{A graph  has an -order where the length of the longest path
is  if and only if the integer program
with constraints (\ref{c:ilp:frame}),
\ldots,(\ref{c:1dim:ilp:interval}),
(\ref{c:1dim:st:1}),
\ldots,(\ref{c:1dim:st:7}),
 applied with 
objective function , has a solution
of value .}
\begin{lemma}
 \lemMinStText
 \label{le:minSt}
\end{lemma}
In the above formulation the integer program computes the length
of the longest path.  If we know (or have a good guess) of the length
 of the longest path, then we can also test whether this indeed
is the length of the longest path by setting ,
thus saving on the number of variables and constraints.

\begin{theorem}
There exists an integer program with  variables
and constraints that computes an -order that minimizes
the length of the longest -path.  Alternatively, using only
 variables and constraints, we can test whether
an -order exists such that the longest -path has length .
\end{theorem}
\begin{theorem}
There exists a SAT instance with  variables
and  clauses of maximum size~
that is satisfiable if an only if
an -order of~ exists such that the longest -path has length .
\end{theorem}


\fi


\section{Higher-Dimensional Problems}\label{sec:higherdim}
In this section we give examples of two-dimensional visibility graph representations and a -dimensional grid-based graph representation problem. Let again  be an undirected graph with  and .

\subsection{Visibility representations}

A visibility representation (also: \emph{bar visibility representation} or \emph{weak visibility representation}) of a graph  maps all vertices to disjoint horizontal line segments, called \emph{bars}, and all edges to disjoint vertical bars, such that for each edge  the bar of  has its endpoints on the bars for  and  and does not intersect any other vertex bar. Visibility representations are an important visualization concept in graph drawing, e.g., it is well known that a graph is planar if and only if it has a visibility representation~\cite{Wis85,TT86}.
An interesting recent extension are bar -visibility representations~\cite{deglst-bkvg-07}, which additionally allow edges to intersect at most  non-incident vertex bars. We use our ILP to compute compact visibility and bar -visibility representations. Minimizing the area of a visibility representation is NP-hard~\cite{le-tardhpg-03} and we are not aware of any implemented exact algorithms to solve the problem for any . 
By Lemma~\ref{lem:transformToInteger} we
know that all bars can be described with integer coordinates of size .

\begin{problem}[Bar -Visibility Representation]\label{pb:barvis}
	Given a graph , an integer grid of size , and an integer , find a bar -visibility representation on the given grid (if one exists).
\end{problem}

\paragraph{Bar visibility representations.}
Our goal is to test whether  has a visibility representation in a grid with  columns and  rows (and thus minimize  or ). We set  and use ILP  to create grid boxes for all edges and vertices in . We add one more set of binary variables for vertex-edge incidences and the following constraints.


Constraints~(\ref{eq:vi:vhor}) and~(\ref{eq:vi:ever}) ensure that 
all vertex boxes are horizontal bars of height 1 
and all edge boxes are vertical bars of width 1. 
Constraint~(\ref{eq:vi:disj}) forces the vertex boxes to be disjoint; 
edge boxes will be implicitly disjoint due to the remaining constraints. 
No edge is allowed to intersect a non-incident vertex 
due to constraint~(\ref{eq:vi:edge}). 
Finally, we need to set the new incidence variables  
for an edge  and an incident vertex  so that  
if and only if  and  share the grid point . 
Constraints~(\ref{eq:vi:inci2}) and~(\ref{eq:vi:inci3}) ensure that 
each incidence in  is realized in at least one grid point, 
but it must be one that is used by the boxes of  and . 
Finally, constraint~(\ref{eq:vi:sten}) requires edge  
to start and end at its two intersection points 
with the incident vertex boxes. 
This constraint is optional, 
but yields a tighter formulation.To transform constraint~(\ref{eq:vi:edge}) into SAT,
we add the clause 
for each , , , and 
apply the general transformation rules otherwise.

Since every graph with a visibility representation is planar (and vice versa) we have . Moreover, our ILP and SAT models can also be used to test planarity of a
given graph by setting  and , which is sufficient due to Tamassia and Tollis~\cite{TT86}. This might not look interesting at first sight since planarity testing can be done in linear time~\cite{planarityTest}. However, we think that this is still useful as one can add other constraints to the ILP model, e.g., 
to create simultaneous planar embeddings, and use it as a subroutine for ILP formulations of applied graph drawing problems
such as metro maps~\cite{nw-dlhqm-11} and cartograms.



\begin{theorem}\label{thm:barvis}
	There exists an ILP/SAT formulation with  variables and
 constraints /  clauses of maximum size  
that solves Problem~\ref{pb:barvis} for . 
\end{theorem}



\iffalse


In a {\em weak visibility representation} of a graph,
vertices are assigned disjoint horizontal bars and
every edge is drawn as a vertical line segment that begins and
ends at the bars of its endpoints and whose interior does not intersect any
other edge segment or vertex bar.
In a {\em strong} visibility representation,
a pair of vertex bars can be connected by a vertical segment
whose interior does not intersect any other segment 
if and only if the corresponding vertices are adjacent.
We only consider weak visibility representations.
It is well-known that every planar graph has a visibility 
representation \cite{Wis85,TT86,RT86}.  
By Lemma~\ref{lem:transformToInteger} we
may assume that all boxes and line segments can be described
with integer coordinates of size  (in fact, a
-grid suffices \cite{TT86}.)

With our above ability to assign intervals to vertices via integer
programs, we can easily test whether a graph has a visibility
representation.  In fact, we can even test whether it has a 
visibility representation in a -grid by restricting
the grid points of the integer program formulation to be within this grid.



The idea is to use boxes for {\em both} vertices
and edges, and to ensure disjointness and intersections as needed
by adding extra constraints.
Thus we have:
\begin{itemize}
\item[(\constr{\label{c:vis:vert}})] For every vertex , we have variables  and
	 for , ,
	and we use constraints~(\ref{c:ilp:frame}),
	(\ref{c:ilp:singleStartEnd}), (\ref{c:ilp:xStrat}),
	(\ref{c:ilp:2dim:xEnd}), (\ref{c:ilp:2dim:rows}), (\ref{c:ilp:2dim:cols})
	 to ensure that these
	indicate a 2-dimensional interval  of  and its corners.
\item[(\constr{\label{c:vis:edges}})] For every edge , we similarly have variables  and
	 and constraints
to ensure that these
	indicate a 2-dimensional interval  of  and its corners.
\item[(\constr{\label{c:vis:eVert}})]
	We enforce that edge  is represented by a vertical segment, not a box,
	by adding the constraint 

	for all grid points .
	Thus, if the top left corner of the box of  is at ,
	then the bottom right corner must be in column . 
	Since (as usual) we consider the intervals to be
	open at the bottom and right, this means that the points
	inside the box form a vertical line segment.
\item[(\constr{\label{c:vis:vHor}})]
	We enforce that vertex  is represented by a horizontal segment, not a box,
	by adding the constraint 

	for all grid points .
	Thus, if the top left corner of the box of  is at ,
	then the bottom right corner must be in row .
	Thus, the points inside the box form a horizontal line segment.
\item[(\constr{\label{c:vis:vDisj}})]
	We enforce that vertices are disjoint by adding
	 for any grid point .
\item[(\constr{\label{c:vis:evNonAdj}})]
 	We enforce that edges do not intersect non-incident vertices
	by adding\\  
	for any grid point  and any edge .		 	
\item[(\constr{\label{c:vis:evAdj}})]
	For every edge  with incident vertex , we define a
	variable , with the intended meaning that
	 if and only if  and  meet at point .
	We enforce that edge  intersects an incident vertex  by adding
	, as well as
	 and ,
	for all , all edges , and both incident vertices .
\item[(\constr{\label{c:vis:eBeginEndAtV}})]
	For every vertex~ and an incident edge ,
	we enforce that  starts or ends inside the bar of~
	by adding .
	If~ and~ intersect at~, then~ begins or ends at~.
	Note that this constraint is optional for testing the existence.
	E.g., if an edge~ ends ``beyond'' the bar of the corresponding incident vertex~,
	we cut off~ at~ in a post-processing step. \comment{RP: keep/remove?}
\end{itemize}
Note that since all vertex bars are horizontal, all edge bars are vertical,
and edge bars only intersect bars of incident vertices,
we do not have to additionally enforce that edges have disjoint interiors.
\par



One easily verifies that we have  variables and
constraints.  We may assume  (otherwise the graph
surely isn't planar and doesn't have a visibility representation)
and hence get:

\begin{lemma}
There exists an integer program with  variables and
constraints that has a solution if and only if   has a
visibility representation in a -grid.
\end{lemma}
\begin{lemma}
There exists a SAT instance with  variables and
 
clauses of maximum size~ that is satisfiable
if and only if   has a
visibility representation in a -grid.
\end{lemma}
We have the following corollary.  First, recall that  is planar
if and only if it has a visibility representation in an -grid.
We hence have:

\begin{corollary}
There exists an integer program with  variables and
constraints that has a solution if and only if   is planar.
\end{corollary}

\fi


\paragraph{Bar -visibility representations.}
It is easy to extend our previous model for  to test bar
-visibility representations for . We drop
constraint~(\ref{eq:vi:edge}), introduce another set of binary
variables to indicate intersections between edges and non-incident
vertices, and add the following constraints.

\vspace{-2ex}

The variable  is supposed to equal 1 if and only if 
intersects a non-incident vertex at position .
Constraint~(\ref{eq:kvi:cross}) enforces that  if
grid point  is occupied by  and a non-incident vertex and
constraint~(\ref{eq:kvi:bark}) makes sure that no more than  such
non-incident bars are crossed by each edge. Finally,
constraint~(\ref{eq:kvi:disj}) guarantees that any two edge bars are
disjoint, except for the case that they are incident to the same
vertex bar and meet at a common endpoint. (Alternatively, we could
enforce disjointness for all edge bars if we required vertex bars of
height~.)

To transform constraint~(\ref{eq:kvi:cross}) into SAT,
we add clause 
for each , , .
For~(\ref{eq:kvi:disj}), we add

for each ordered pair , .
For the rest of the constraints, we apply the general transformation
rules.

\begin{theorem}\label{thm:barkvis}
	There exists an ILP/SAT formulation with  variables and
 constraints /  clauses
of maximum size  that solves Problem~\ref{pb:barvis} for .
\end{theorem}



\iffalse


We can easily extend our approach to compute 
\emph{-bar-visibility representations}\cite{???},
i.e., we now allow each edge to cross at most~ bars of 
non-incident vertices.
We replace constraint~(\ref{c:vis:evNonAdj}) by the following:
\begin{itemize}
  \item[(\constr{\label{c:vis:kbar}})]
  For each edge~ and each point~ we introduce 
  a variable~, with the intended meaning that
   if~ intersects a non-incident edge at~.
  For each~ and each~ we add the constraint
  .
  We enforce the -bar-visibility condition by 
  for each~.
  \item[(\constr{\label{c:vis:eDisj}})]
  Note that we now have to explicitly make sure that edges are disjoint (except perhaps at a common
  endpoint). We add
  
  for any grid point .  
\end{itemize}
\begin{lemma}
There exists an integer program with  variables and
constraints that has a solution if and only if   has a
weak -bar-visibility representation in a -grid.
\end{lemma}
\subsubsection{Rectangle-visibility representations.}
The formulation for bar-visibility can be easily be extended to compute 
\emph{weak rectangle-visibility representations}\cite{???},
i.e, vertices are boxes and edges represent horizontal bars
that intersect no other box or bar in its interior.
We remove the constraint~(\ref{c:vis:vHor})
and modify~(\ref{c:vis:vHor})
into .
Again, we require constraint~(\ref{c:vis:eDisj}).
\par
A planar graph has a planar straight-line drawing of
height  if and only if it has a visibility representation
of height  for which all vertices are horizontal line 
segments (see \cite{Bie-WAOA12} for obtaining the straight-line
drawing from the visibility representation; the other direction
is much easier and left to the reader.)
\comment{TB: Or perhaps I should write it up somewhere.}
Moreover, by Lemma~\ref{lem:transformToInteger} we may
assume that the visibility representation has width at most .
Hence we have:

\begin{corollary}
There exists an integer program with  variables and
constraints that has a solution if and only if   has
a planar straight-line drawing of height .
\end{corollary}

\fi


\subsection{Boxicity- graphs}\label{sec:boxicity}
A graph is said to have {\em boxicity}  if it can be represented
as intersection graph of -dimensional axis-aligned boxes. Testing
whether a graph has boxicity  is NP-hard, even for
~\cite{Kra94}. We are not aware of any implemented algorithms to
determine the boxicity of a graph. By
Lemma~\ref{lem:transformToInteger} we can restrict ourselves to a grid
of side length .

We use ILP  for  to model a
-dimensional box for each vertex of a graph . We add the
following variables and constraints to achieve the correct
intersection properties.

The variables  indicate whether a grid point lies in
the intersection of two boxes and thus represents an edge.
Constraint~(\ref{eq:bx:nonempty}) guarantees that there is a non-empty
intersection for each edge , and by
constraint~(\ref{eq:bx:vtcs}) we make sure that the intersection
indicator for an edge  can only be set to  at position
 if the grid boxes for  and  both occupy point
. Finally, constraint~(\ref{eq:bx:disj}) enforces that no
grid point can be occupied by a pair of non-adjacent vertices.



\begin{theorem}
There exists an ILP with  variables and
 constraints 
as well as a SAT instance with  variables and
 clauses of maximum size 
to test whether a graph  has boxicity .
\end{theorem}


\section{Experiments}\label{sec:exp}
We implemented and tested our formulation for minimizing pathwidth, bandwidth,
length of longest path in an -orientation, and width of
bar-visibility and bar 1-visibility representations, as well as
deciding whether a graph has boxicity~2.
\par

The experiments were performed on a single core of an
AMD Opteron 6172 processor running Linux~3.4.11. The machine is
clocked at 2.1 Ghz, and has 256 GiB RAM. Our
implementation\footnote{available from
\url{http://i11www.iti.kit.edu/gdsat}} is written
in C++ and was compiled with GCC 4.7.1 using optimization
\texttt{-O3}. As test sample we used the \emph{Rome graphs} dataset
\cite{rome} which consists of 11533 graphs with vertex number between
10 and 100.  of the Rome graphs are planar.
Figure~\ref{fig:size-distr} shows
the size distribution of the Rome graphs.

\begin{figure}[tbp]
\centering
  \includegraphics{fig/graphs/graphComplexity}
 \caption{\small Size distribution of Rome graphs.
 Black: all graphs,
 blue: biconnected blocks (),
 orange: planar graphs. We used an -Gaussian filter to
reduce oscillations.  
 }
 \label{fig:size-distr}
\end{figure}


We initially used the \emph{Gurobi} solver \cite{gurobi} to
test the implementation of the ILP formulations, however it turned out
that even for very small graphs () solving a single instance can
take minutes. We therefore focused on the equivalent SAT
formulations gaining a significant speed-up. As SAT solver we used
\emph{MiniSat}~\cite{minisat} in version~2.2.0.  
For each of the five minimization problems we determined obvious lower and upper bounds in~ for the respective graph parameter. Starting with the lower bound we iteratively increased the parameter to the next integer until a solution was found (or a predefined timeout was exceeded). Each iteration consists of constructing the SAT formulation 
and executing the SAT solver. We measured the total time spent in all iterations.
For boxicity~2 we decided to consider square grids and minimize
their side lengths. Thus the same iterative procedure applies to boxicity~2.



Note that for all considered
problems a binary search-like procedure for the parameter value did not prove to be efficient, since the solver usually takes more time with increasing parameter value, which is mainly due to the increasing number of variables and
clauses.
For the one-dimensional problems we used a timeout of 300 seconds, for the two-dimensional problems of 600 seconds. 

We ran the instances sorted by size~ starting with the smallest
graphs. If more than 400 consecutive graphs in this order produced
timeouts, we ended the experiment prematurely and evaluated only the
so far obtained results. Figures~\ref{fig:1d} and~\ref{fig:2d}
summarize our experimental results and show the percentage of Rome
graphs solved within the given time limit, as well as scatter plots
with each solved instance represented as a point depending on its
graph size and the required computation time. 

\begin{figure}[t]
\subfloat[percentage of solved instances]{
 	\includegraphics{fig/diagram123}
 	\label{fig:solved}
 }
 \hfill
 \subfloat[pathwidth]{
 \includegraphics
 {fig/pathwidth/diagram2_nodesAndEdges}
 	\label{fig:pw:time}
 }\\
\subfloat[bandwidth]{
 	\includegraphics{fig/bandwidth/diagram2_nodesAndEdges}
 	\label{fig:bw:time}
 }
 \hfill
 \subfloat[-orientation]{
 	\includegraphics{fig/orderings/diagram2_nodesAndEdges}
 	\label{fig:st:time}
 }
 \caption{\small
  Experimental results for the one-dimensional problems.
  \protect\subref{fig:solved} Percentage of solved instances.
  \protect\subref{fig:pw:time}--\protect\subref{fig:st:time}: 
  Time in seconds for solving an instance (dots)
  and percentage of instances not solved within 300 seconds (red curves), 
  both in relation to~ 
}\label{fig:1d}
	\vspace{-2ex}
\end{figure}

\smallskip\noindent\textit{Pathwidth.}
As Fig.~\ref{fig:solved} shows,
we were able to compute the pathwidth for  of all Rome graphs,
from which  were solved within the first minute
and only  within the last.
Therefore, we expect that a significant increase of the timeout value
would be necessary for a noticeable increase 
of the percentage of solved instances.
We note that almost all small graphs ()
could be solved within the given timeout,
however, for larger graphs, the percentage of solved instances rapidly drops,
as the red curve in Fig.~\ref{fig:pw:time} shows.
Almost no graphs with  were solved.

\smallskip\noindent\textit{Bandwidth.}
We were able to compute the bandwidth for  of all Rome graphs
(see Fig.~\ref{fig:solved}),
from which  were solved within the first minute
and only  within the last.
Similarly to the previous case, the procedure 
terminated successfully within 300 seconds 
for almost all small graphs ( in this case), 
while almost none of the larger graphs () were solved;
see the red curve in Fig.~\ref{fig:bw:time}.

\smallskip\noindent\textit{Optimum -orientation.}
Note that very few of the Rome graphs are biconnected.
Therefore, to test our SAT implementation 
for computing the minimum number of levels in an -orientation,
we subdivided each graph into biconnected blocks 
and removed those with~,
which produced 13606 blocks in total;
see Fig.~\ref{fig:size-distr} for the distribution of block sizes.
Then, for each such block, we randomly selected 
one pair of vertices~, , connected them by an edge if
it did not already exist and ran the iterative procedure.
In this way, for the respective choice of~
we were able to compute the minimum number of levels 
in an -orientation for all biconnected blocks; 
see Fig.~\ref{fig:solved}.
Moreover, no graph took longer than 57 seconds,
for  of the graphs it took less than 10 seconds
and for  less than 3 seconds.
Even for the biggest blocks with ,
the procedure successfully terminated within 15 seconds 
in  of the cases; see Fig.~\ref{fig:st:time}.

\begin{figure}[t]
\subfloat[percentage of solved instances]{
 	\includegraphics{fig/diagramBar}
 	\label{fig:visrep:solved}
 }
 \hfill
 \subfloat[bar visibility]{
\includegraphics{fig/visrep_width/diagram}
 	\label{fig:visrep:time}
 }\\
 \subfloat[bar 1-visibility]{
 	\includegraphics{fig/onebar_width/diagram}
 	\label{fig:1bar:time}
 }
 \hfill
  \subfloat[boxicity 2]{
 	\includegraphics{fig/boxicity/diagram2_nodesAndEdges}
 	\label{fig:box:time}
 }
 \caption{\small Experimental results for the two-dimensional problems.
  \protect\subref{fig:visrep:solved} 
   Percentage of solved instances. The red horizontal line shows the
   percentage of planar graphs over all Rome graphs.
  \protect\subref{fig:visrep:time}--\protect\subref{fig:box:time}:  
   Time in seconds for solving an instance (dots)
   and percentage of instances not solved within 600 seconds (red curves), 
   both in relation to~.
 }\label{fig:2d}
	\vspace{-2ex}
\end{figure} 


\smallskip\noindent\textit{Bar visibility.}
To compute bar-visibility representations of minimum width,
we iteratively tested for each graph all widths~
between~1 and~n. We used the trivial upper bound  for the height.
We were able to compute solutions
for~ of all 3281 planar Rome graphs (see
Fig.~\ref{fig:visrep:solved}),  of which were solved within the
first minute and less than~ within the last.
We were able to solve all small instances with~
and almost none for~; see the red curve in
Fig.~\ref{fig:visrep:time}.
\par


\smallskip\noindent\textit{Bar 1-visibility.} We also ran the width minimization procedure for 
bar 1-visibility representations on all Rome graphs. 
The number of graphs for which the procedure terminated successfully
within the given time is 833 ( of all Rome graphs),
which is close to the corresponding number for bar-visibility; see
Fig.~\ref{fig:visrep:solved}. 
 This is not surprising, since most small Rome graphs are planar;
 see Fig.~\ref{fig:size-distr}. 
For bar 1-visibility, eight graphs were solved 
which were not solved for bar-visibility.
Interestingly, they were all planar.
All but 113 graphs successfully processed in the previous
experiment 
were also successfully processed in this one. 
A possible explanation for those~113 graphs is that the SAT formulation for
 bar 1-visibility requires more clauses.
All small graphs with  were processed successfully.
Interestingly, for none of the processed graphs
the minimum width actually decreased in comparison to their
minimum-width bar-visibility representation.


\smallskip\noindent\textit{Boxicity-2}
For testing boxicity~2,
we started with a~ grid for each graph 
and then increased height and width simultaneously after each iteration.
Within the specified timeout of~600 seconds,
we were able to decide whether a graph has boxicity~2
for  of all Rome graphs (see Fig.~\ref{fig:visrep:time}),
 of which were processed within the first minute and~
within the last.
All of the successfully processed graphs actually had boxicity~2.
Small graphs with  were processed almost completely,
while almost none of the graphs with  finished;
see Fig.~\ref{fig:box:time}. 
\section{Conclusion}
We presented a versatile ILP formulation for determining placement of
grid boxes according to problem-specific constraints. We gave six
examples of how to extend this formulation for solving numerous
NP-hard graph drawing and graph representation problems, such as
bar-visibility representations, computing the pathwidth and the
boxicity, and finding an st-orientation that minimizes the
longest directed path. Our experimental evaluation showed that while solving the original ILP is rather slow, the easily derived SAT formulations perform quite well for smaller graphs. While our approach is not suitable to replace specialized exact or heuristic algorithms that are faster and/or can solve larger instances of these problems, it does provide a simple-to-use tool for solving problems that can be modeled by grid-based graph representations without much implementation effort. This can be useful, e.g., for verifying counterexamples, NP-hardness gadgets, or for computing solutions to certain instances in practice.

We note that many other problems can easily be formulated as ILPs by assigning
grid-boxes to vertices or edges.  Among those are, e.g., testing
whether a planar graph has a straight-line drawing of height ,
testing whether a planar graph has a rectangular dual with
integer coordinates and prescribed integral areas, testing whether a graph is a -interval graph, or whether a  bipartite graph can be represented as a planar bus graph. 
Important open problems are to reduce the complexity of our formulations and the question whether approximation algorithms for graph drawing can be derived from our model via fractional relaxation. 


{\small
  \bibliography{abbrv,ilp-gd}
  \bibliographystyle{abbrv}
}






\end{document}
