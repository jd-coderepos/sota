\documentclass[runningheads]{llncs}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{cite}
\usepackage{subfig,wrapfig}
\usepackage{graphicx}
\usepackage{times}
\usepackage[bookmarks=false]{hyperref}
\usepackage[textsize=footwww.google.notesize]{todonotes}

\newcommand{\martin}[1]{\todo[color=yellow!40]{MN: #1}}

\newcommand{\romanp}[1]{\todo[color=green!40]{RP: #1}\xspace}
\newcommand{\benjamin}[1]{\todo[color=blue!40]{BN: #1}}

\newcommand{\ignaz}[1]{\todo[color=gray!40]{IR: #1}}

\newtheorem{assumption}{Assumption}
\newcommand{\comment}[1]{{\color{red} #1}}
\newcommand{\rowsum}[1]{{\overset{\rightarrow}{#1}}}
\newcommand{\columnsum}[1]{{\downarrow\!#1}}

\newcommand{\true}{\ensuremath{\textnormal{TRUE}}}
\newcommand{\false}{\ensuremath{\textnormal{FALSE}}}

\newcommand{\bvec}[1]{\mathbf{#1}}

\newcommand{\psolved}{\ensuremath{r_\textnormal{solved}}}

\renewcommand{\textfraction}{0.01}
\renewcommand{\topfraction}{0.99}
\renewcommand{\bottomfraction}{0.99}
\renewcommand{\floatpagefraction}{0.35}



\newcounter{constr} 
\setcounter{constr}{0}
\newcommand{\constr}[1]{\noindent \refstepcounter{constr}\theconstr #1}
 
\newcommand{\rephrase}[3]{\noindent\textbf{#1~#2.}~\emph{#3}}

\title{Using ILP/SAT to determine pathwidth, visibility
representations, and other grid-based graph drawings\thanks{T. Biedl
is supported
by NSERC, M. NÃ¶llenburg is supported by the Concept for the Future of
KIT under grant YIG 10-209.}}
\author{Therese Biedl\inst{1}
\and Thomas Bl\"asius\inst{2}
\and Benjamin Niedermann\inst{2}\and Martin~N\"{o}llenburg\inst{2}\and Roman Prutkin\inst{2}\and Ignaz Rutter\inst{2}}
\authorrunning{Biedl \and Bl\"asius \and Niedermann \and
N\"{o}llenburg \and Prutkin \and Rutter}
\titlerunning{ILP/SAT formulation for grid-based graph
representations}
\institute{David R.~Cheriton School of Computer
Science, University of Waterloo, Canada
\and
Institute of Theoretical Informatics, Karlsruhe Institute of
Technology, Germany
}


\begin{document}

\maketitle
\begin{abstract}
We present a simple and versatile formulation of grid-based graph
representation problems as an integer linear program (ILP) and a
corresponding SAT instance. In a grid-based representation vertices
and edges correspond to axis-parallel boxes on an underlying integer
grid; boxes can be further constrained in their shapes and
interactions by additional problem-specific constraints. We describe a
general $d$-dimensional model for grid representation problems. This
model can be used to solve a variety of  NP-hard graph problems,
including pathwidth, bandwidth, optimum $st$-orientation, 
area-minimal (bar-$k$) visibility representation, boxicity-$k$ graphs
and others. We implemented SAT-models for all of the above problems
and evaluated them on the Rome graphs collection. The experiments show
that our model successfully solves NP-hard problems within few minutes
on small to medium-size Rome graphs.
\end{abstract}

\section{Introduction}
Integer linear programming (ILP) and Boolean satisfiability testing
(SAT) are indispensable and widely used tools in solving many hard
combinatorial optimization and decision problems in practical
applications~\cite{bhmw-hs-09,cbd-aip-10}. In graph drawing,
especially for planar graphs, these methods are not frequently
applied. A few notable exceptions
are crossing
minimization~\cite{cmb-aecm-08,bcegjk-bacnp-08,jm-2scmpeha-97,gsm-okpcm-11}, orthogonal graph drawing with vertex and
edge labels~\cite{bdln-odgwvel-05} and metro-map
layout~\cite{nw-dlhqm-11}. Recent work by Chimani et
al.~\cite{cz-upt-13} uses SAT formulations for testing upward
planarity. All these approaches have in common that they exploit
problem-specific properties to derive small and efficiently solvable
models, but they do not generalize to larger classes of problems. 

In this paper we propose a generic ILP model that is flexible enough
to capture a large variety of different grid-based graph layout
problems, both polynomially-solvable and NP-complete. We demonstrate
this broad applicability by adapting the base model to six different
NP-complete example problems: pathwidth, bandwidth, optimum
$st$-orientation, minimum area bar- and bar $k$-visibility representation, and boxicity-$k$ testing. 
For minimum-area visibility representations and boxicity this is, to the best of our knowledge, the first implementation of an exact solution
method.
Of course this flexibility comes at the cost of losing some of the
efficiency of more specific approaches. Our goal, however, is not to
achieve maximal performance for a specific problem, but to provide an
easy-to-adapt solution method for a larger class of problems, which
allows quick and simple prototyping for instances that are not too
large. Our ILP models can be easily translated into equivalent SAT
formulations, which exhibit better performance in the implementation
than the ILP models themselves. We illustrate the usefulness of our
approach by an experimental evaluation that applies our generic model
to the above six NP-complete problems using the well-known Rome
graphs~\cite{rome} as a benchmark set. Our evaluation shows that,
depending on the problem, our model can solve small to medium-size
instances (sizes varying from about 25 vertices and edges for bar-$1$
visibility testing up to more than 250 vertices and edges, i.e., all
Rome graphs, for optimum $st$-orientation) to optimality within a few
minutes. 
In Section~\ref{sec:genericmodel} we introduce generic grid-based
graph representations and formulate an ILP model for $d$-dimensional
integer grids. We demonstrate how this model can be adapted to six
concrete one-, two- and $d$-dimensional grid-based graph layout
problems in Sections~\ref{se:problems:1dim} and~\ref{sec:higherdim}.
In Section~\ref{sec:exp} we evaluate our implementations and report
experimental results. The implementation is available from
\url{i11www.iti.kit.edu/gdsat}. 
 

\section{Generic Model for Grid-Based Graph Representations}\label{sec:genericmodel}

In this section we explain how to express $d$-dimensional boxes in a
$d$-dimensional integer grid as constraints of an ILP or a SAT
instance. In the subsequent sections we use these boxes as
basic elements for representing vertices and edges in problem-specific ILP and SAT models.
We need a simple observation that shows that we can restrict ourselves
to boxes in integer grids.

\newcommand{\lemTransformToInteger}{
Any set $I$ of $n$ boxes in $\mathbb R^d$ can be transformed into another set $I'$ of~$n$ closed boxes on 
the integer grid $\{ 1, \ldots, n\}^d$ 
such that two boxes intersect in $I$ if and only if they intersect in $I'$.
}
\begin{lemma}
\label{lem:transformToInteger}
\label{lem:gtransformToInteger}
\lemTransformToInteger
\end{lemma}

\begin{proof}
Let $I_1,\dots,I_n$ be a set of $d$-dimensional intervals.
Then we prove that there exists a set $I'_1,\dots,I'_n$ of
$d$-dimensional intervals such that:
\begin{itemize}
\item For all $i$, $I'_i= [b_i^1,e_i^1] \times \dots \times
[b_i^d,e_i^d]$ for some
  $b_i^1,e_i^1,\dots,b_i^d,e_i^d\in \{1,\dots,n\}$.  Put differently,
  $I'_i$ has integral coordinates in the range $\{1,\dots,n\}$,
  and it is closed at both ends.
\item $I_i\cap I_j$ if and only if $I'_i\cap I'_j$.
\end{itemize}


It suffices to show this for 1-dimensional intervals; we can then
transform each dimension of the intervals separately to achieve the
results for arbitrary dimensions.
  
For 1-dimensional intervals, presume that $I_i=\{s_i,t_i\}$, where we
make no assumption over whether the ends of $I_i$ are open or closed.
We first create a sorted orientation of the $2n$ endpoints of these
intervals.  We sort them by their coordinate, and in case of a tie
take 
first right endpoints where the interval is open, 
then left endpoints where the interval is closed,
then right endpoints where the interval is closed 
and then left endpoints where the interval is open.  
Presume that $\sigma$ describes this order, i.e., for any endpoint $p$
$\sigma(p)$ gives the index of $p$ in this sorted order.
One easily verifies that $\{\sigma(s_i),\sigma(t_i)\}$ intersects 
$\{\sigma(s_j),\sigma(t_j)\}$
if and only if $I_i$ intersects $I_j$.  Here it does not even matter
whether we make the new intervals open or closed, since all endpoints
are distinct integers.

Now compact $\sigma$ by not using a new integer whenever we have
an endpoint of an interval.  More precisely, split $\sigma$ into
maximal subsequences such that each subsequence consists of multiple
(possibly none) left endpoints of intervals, followed by one right
endpoint of an interval.
There are 
$n$ such subsequences, since there are $n$ right endpoints.
Enumerate the subsequences in order, and let $\sigma'(p)$ be
the number assigned to the subsequence that contains $\sigma(p)$,
for any endpoint $p$ of an interval.
Now for $I_i=\{s_i,t_i\}$ 
define $I'_i$ to be $\left[\sigma'(s_i),\sigma'(t_i)\right]$.  We
claim
that this satisfies the conditions.  Clearly the endpoints of the
intervals
are integers in the range $1,\dots,n$, so we only must 
argue that intersections are unchanged.
This held when going over from $\{s_i,t_i\}$ to
$\{\sigma(s_i),\sigma(t_i)\}$.
But going over from $\sigma$ to $\sigma'$, we changed the relative
order 
of endpoints only by contracting a number
of left endpoints, followed by one right endpoint.  Since 
$I'_i$ is closed at both ends, this does not change intersections.
\qed
\end{proof}


\subsection{Integer Linear Programming Model}\label{sec:ilpmodel}
We will describe our model in the general case for a $d$-dimensional
integer grid, where $d \ge 1$. Let $\mathcal R^d = [1,U_1] \times
\ldots \times [1, U_d]$ be a bounded $d$-dimensional integer grid,
where $[A,B]$ denotes the set of integers $\{A, A+1, \dots, B-1,B\}$.
In a \emph{grid-based graph representation} vertices and/or edges are
represented as $d$-dimensional boxes in $\mathcal{R}^d$. A \emph{grid
box} $R$ in $\mathcal R^d$ is a subset $[s_1,t_1] \times \ldots \times
[s_d, t_d]$ of $\mathcal R^d$, where $1 \le s_k \le t_k \le U_k$ for
all $1 \le k \le d$. In the following we describe a set of ILP
constraints that together create a non-empty box for some object  $v$.
 We denote this ILP as $\mathcal B(d)$.

We first extend $\mathcal R^d$ by a margin of dummy points to $\bar{\mathcal R}^d = [0,U_1+1] \times \ldots \times [0, U_d+1]$.
We use three sets of binary variables:
\begin{align}
  \label{eq:x} x_\bvec{i}(v) &\in \{0,1\} && \forall \bvec{i} \in \bar{\mathcal R}^d\\
  \label{eq:b} b_i^{k}(v) &\in \{0,1\} && \forall 1\le k \le d \text{ and } 1\le i \le U_k\\
  \label{eq:e} e_i^{k}(v) &\in \{0,1\} && \forall 1\le k \le d \text{ and } 1\le i \le U_k
\end{align}
The variables $x_\bvec{i}(v)$ indicate whether grid point $\bvec{i}$ belongs to the box representing~$v$ ($x_\bvec{i}(v)=1$) or not ($x_\bvec{i}(v)=0$). Variables $b_i^{k}(v)$ and $e_i^{k}(v)$ indicate whether the box of $v$ may start or end at position $i$ in dimension $k$. We use~$\bvec{i}[k]$ to denote the $k$-th coordinate of grid point $\bvec{i} \in \mathcal R^d$ and $\bvec{1_k} = (0,\dots,0,1,0,\dots,0)$ to denote the $k$-th $d$-dimensional unit vector. If $d=1$ we will drop the dimension index of the variables to simplify the notation.
The following constraints model a box in $\mathcal R^d$ (see Fig.~\ref{fig:example2d} for an example): \begin{align} 
\label{eq:margin} x_\bvec{i}(v) &= 0 && \forall \bvec{i} \in \bar{\mathcal R}^d \setminus \mathcal R^d\\
\label{eq:nonempty} \sum_{\bvec{i}\in \bar{\mathcal R}^d } x_\bvec{i}(v) & \ge 1 &\\
\label{eq:oneb} \sum_{{i \in [1,U_k]}} b_{i}^k(v) & = 1 &&\forall 1
\le k \le d\\
\label{eq:onee} \sum_{{i \in [1,U_k]}} e_{i}^k(v) & = 1 && \forall 1
\le k \le d
\end{align}
\begin{align}
\label{eq:start} x_\bvec{i-1_k}(v) + b_{\bvec{i}[k]}^k(v) &\ge 
x_\bvec{i}(v) && \forall \bvec{i} \in \mathcal R^d \text{ and } 1 \le
k \le d\\
\label{eq:end} x_\bvec{i}(v) &\le x_\bvec{i+1_k}(v) + e_{\bvec{i}[k]}^k(v) && \forall \bvec{i} \in \mathcal R^d \text{ and } 1 \le k \le d
\end{align}

Constraint~\eqref{eq:margin} creates a margin of zeroes
around~$\mathcal R^d$.
Constraint~\eqref{eq:nonempty} ensures that the shape representing~$v$
is non-empty, and constraints~\eqref{eq:oneb} and~\eqref{eq:onee}
provide exactly one start and end position in each dimension.
Finally, due to constraints~\eqref{eq:start} and~\eqref{eq:end} each
grid point inside the specified bounds belongs to~$v$ and all other
points don't.

\begin{figure}[tb]
	\centering
		\includegraphics[scale=1]{fig/model}
	\caption{\small Example of a 2-dimensional $8\times 13$ grid
$\bar{\mathcal R}^d$ with a 
	$6\times 4$ grid box and the corresponding variable assignments.}
	\label{fig:example2d}
	\vspace{-2ex}
\end{figure}


\newcommand{\lemboxtext}{The ILP $\mathcal B(d)$ defined by constraints~(\ref{eq:x})--(\ref{eq:end}) correctly models all non-empty grid boxes in $\mathcal R^d$.
}

\begin{lemma}\label{lem:correctbox}
\lemboxtext
\end{lemma}

\begin{proof}
  Let $R = [s_1,t_1] \times \ldots \times [s_d, t_d]$ be a non-empty
grid box in $\mathcal R^d$. We initially set all variables to the
default value of zero. For every $\bvec{i} \in R$ we set
$x_\bvec{i}(R) = 1$. Moreover, we set $b_{s_k}^k(R) = 1$ and
$e_{t_k}^k(R) = 1$ for all $1 \le k \le d$. We claim that this
assignment satisfies all constraints. Constraints
(\ref{eq:x})--(\ref{eq:e}) are obviously satisfied, as well as 
constraints~(\ref{eq:margin}) and~(\ref{eq:nonempty}) since $R$ is
nonempty but does not intersect the margin $\bar{\mathcal R}^d
\setminus \mathcal R^d$. For every $1 \le k \le d$ we set exactly one
variable $b_i^k(R) = 1$ and $e_j^k(R)=1$, namely for $i=s_k$ and
$j=t_k$; this satisfies constraints~(\ref{eq:oneb})
and~(\ref{eq:onee}). Constraints~(\ref{eq:start}) and~(\ref{eq:end})
are trivially satisfied if $x_\bvec{i}(R) = x_\bvec{i+1_k}(R)$  for
two neighboring grid points in dimension $k$. Otherwise, if
$x_\bvec{i-1_k}(R) = 0$ and $x_\bvec{i}(R) = 1$, then
$b_{\bvec{i}[k]}^k$ must equal $1$, and if $x_\bvec{i}(R) = 1$ and
$x_\bvec{i+1_k}(R) = 0$, then $e_{\bvec{i}[k]}^k$ must equal $1$.
  Let $W_\bvec{i}^k = \{\bvec{j} \in \bar{\mathcal R^d} \mid \bvec{j}
= \bvec{i} + (\lambda - \bvec{i}[k]) \cdot \bvec{1_k}, \, 0 \le
\lambda \le U_k+1  \}$ be a row of $\mathcal R^d$ in the $k$-th
dimension indexed by a grid point~$\bvec{i}$. By $W_\bvec{i}^k[l]$ we
denote the $l$-th point $\bvec{i} + (l - \bvec{i}[k]) \cdot
\bvec{1_k}$ in row $W_\bvec{i}^k$. We know that   $x_\bvec{j}(R)=0$
for $\bvec{j} \in \{W_\bvec{i}^k[0], W_\bvec{i}^k[U_k+1]\}$. If
$W_\bvec{i}^k \cap R = \emptyset$, then all indicator variables for
$W_\bvec{i}^k$ are equal to zero and constraints~(\ref{eq:start})
and~(\ref{eq:end}) are satisfied. Otherwise, the indicator variables
for row $W_\bvec{i}^k$ contain a consecutive sequence of $1$'s for
points $W_\bvec{i}^k[l] \in R$ with $s_k \le l \le t_k$. But since
$b_{s_k}^k(R) = 1$ and $e_{t_k}^k(R) = 1$ the
constraints~(\ref{eq:start}) and~(\ref{eq:end}) are also satisfied for
$\bvec{j} = W_\bvec{i}^k[s_k]$ and $\bvec{j} = W_\bvec{i}^k[t_k]$.

Now consider a valid variable assignment according to
constraints~(\ref{eq:x})--(\ref{eq:end}) and define $R= \{\bvec{i} \in
\mathcal R^d \mid x_\bvec{i} = 1\}$. By constraints~(\ref{eq:margin})
and~(\ref{eq:nonempty}) $R$ contains at least one point. Let $1\le
k\le d$ be a dimension of $\mathcal R^d$ and let $W_\bvec{i}^k$ be any
row in the $k$-th dimension. By constraints~(\ref{eq:oneb})
and~(\ref{eq:onee}) there is exactly one coordinate $s_k$, where
$b_{s_k}^k=1$ and one coordinate $t_k$, where $e_{t_k}^k=1$. Thus by
constraints~(\ref{eq:start}) and~(\ref{eq:end}) $W_\bvec{i}^k \cap R$
is either empty or a single interval of consecutive points between
$W_\bvec{i}^k[s_k]$ and $W_\bvec{i}^k[t_k]$. Since this is true for
any $k$, the set $R$ must be a (non-empty) grid box. \qed
\end{proof}


Our example ILP models in Sections~\ref{se:problems:1dim}
and~\ref{sec:higherdim} extend ILP $\mathcal B(d)$ by additional
constraints controlling additional properties of vertex and edge
boxes. For instance, boxes can be easily constrained to be single
points, to be horizontal or vertical line segments, to intersect if
and only if they are incident or adjacent in $G$, to meet in endpoints
etc.
The definition of an objective function for the ILP depends on the
specific problem at hand and will be discussed in the problem
sections.
\subsection{Translating the ILP model into a SAT
model}\label{sec:satmodel}
In this section we explain shortly how ILP~$\mathcal B(d)$ can be
translated into an equivalent SAT formulation with better
practical performance. The transformation of $\mathcal B(d)$
(including later problem-specific extensions) into a SAT instance,
i.e., a set of Boolean clauses, is straightforward. Let $k,c \in
\mathbb N \setminus \{ 0 \}$, $k > c$, be positive integers and $y_1,
\ldots, y_k$, $z$ be binary variables. Then most of our ILP
constraints belong to one of the following four types:
(i)~$\sum_{i=1}^k y_i \geq z$, 
(ii)~\mbox{$\sum_{i=1}^k y_i \leq c$,} 
(iii)~$\sum_{i=1}^k y_i \geq c$,
(iv)~$\sum_{i=1}^k y_i = c$. 

We translate a type-(i) constraint
into the clause~$y_1 \vee \ldots \vee y_k \vee \neg z$.
For a type-(ii) constraint we consider each tuple of $c+1$ pairwise
distinct indices $i_1, \ldots, i_{c+1}$ and
 add the clause~$\neg y_{i_1} \vee \ldots \vee \neg y_{i_c} \vee \neg
y_{i_{c+1}}$. 
This gives us $\binom{k}{c+1}$ clauses of size~$c+1$.
A \mbox{type-(iii)} constraint is equivalent to~$\sum_{i=1}^k (1 -
y_i) \leq k-c$,
providing $\binom{k}{k-c+1}$ clauses of size~$k-c+1$.
A type-(iv) constraint 
is described as a type-(ii) and a type-(iii) constraint and thus needs
$\binom{k}{c+1}$ clauses of size~$c+1$
and $\binom{k}{k-c+1}$ clauses of size~$k-c+1$. 





\iffalse

Presume that for each vertex $v$, we'd like to assign an interval
whose endpoints are integers in the range 
$\mathcal R^d = [1,U_1] \times \ldots \times [1, U_d]$, $d \in \{ 1,2\}$.
  We will also assume that these intervals are closed at the 
  smaller end in each dimension, but open at the larger end; other
variants of intervals could easily be accommodated by shifting
indices by $\pm 1$ as needed.  We define the following variables
for both the ILP and SAT formulation (we associate~1 with $\true$ 
and~0 with $\false$):
\begin{itemize}
\item $x_\bvec{i}^v\in \{0,1\}$ for every $v\in V$ and 
$\bvec{i} = (i_1, \ldots, i_d)\in 
 \bar{\mathcal R}^d = [0,U_1] \times \ldots \times [0, U_d]$.
	The intended meaning is that $x_\bvec{i}^v=1$ if and only if the point
	with coordinates $\bvec{i} = (i_1, \ldots, i_d)$
	 belongs to the interval of~$v$.  
\item $b_\bvec{i}^v\in \{0,1\}$ for every $v\in V$ 
	and $\bvec{i}\in \mathcal R^d$.
	The intended meaning is that the interval of $v$ begins at
	coordinate $\bvec{i}$ if and only if $b_\bvec{i}^v=1$.\footnote{To make notations easier, we will in the following sometimes
use $b_{U}^v$, or other variables that are ``out of bounds''.  Such
variables will then be identical to 0.}
\item $e_\bvec{i}^v\in \{0,1\}$ for every $v\in V$ 
	and $\bvec{i}\in [2,U_1] \times \ldots \times [2, U_d]$.
	The intended meaning is that the interval of $v$ ends at
	index $\bvec{i}$ if and only if $e_\bvec{i}^v=1$.  
\end{itemize}
For the ease of understanding, we first present integer linear constraints
for the problem and translate them into SAT clauses later. 
\subsubsection{ILP formulation.}
\label{se:1dim:ilp}
We impose the following constraints (here, ``for all $\bvec{i}$'' or ``$\sum_\bvec{i}$'' 
means using all indices $\bvec{i}$  where the corresponding variable is defined): 
\begin{itemize}
\item[(\constr{\label{c:ilp:frame}})] 
	$x_\bvec{i} = 0$ for $\bvec{i} = ( i_1, \ldots, i_d )$
	if $i_j \in \{ 0, U_j\}$ for some $j \in \{ 1, \ldots, d\}$.
	The grid points at coordinates
	$\bvec{\bar{i}} \in (\times_{i=1}^d [ 0, U_i]) 
	\setminus (\times_{i=1}^d [ 1, U_i -1])$ 
	only serve as a ``frame'' that is needed
	to force the begin and endpoints, but they would never belong
	to an interval.  (Some intervals may end at index $\bvec{\bar{i}}$, but
	since they are open at the larger endpoint in each dimension, we nevertheless
	have $x_\bvec{\bar{i}}^v=0$.)
\item[(\constr{\label{c:ilp:singleStartEnd}})] 
	$\sum_\bvec{i} b_\bvec{i}^v = 1$ and $\sum_\bvec{i} e_\bvec{i}^v=1$
	 for all $v\in V$.
	This enforces that the interval of every vertex 
	begins and ends exactly once.
\item[(\constr{\label{c:ilp:xStrat}})] 
	$b_\bvec{i}^v \leq x_\bvec{i}^v$ for all $v\in V$ and all $\bvec{i}$.
	This constraint ties the interval-indicators to the begin-indicators:
	if $v$ begins at $\bvec{i}$, then $x_\bvec{i}^v$ must also be 1.  We could
	impose a few more constraints here (e.g. we must have 0 to the
	left of the beginning, and 0 at the end, but 1 to the left of
	the end), but these turn out to be not necessary due to other
	constraints.	
\end{itemize}
Finally, we have to make sure that $x_\bvec{i} = 1$
exactly in the $d$-dimensional box with bounds defined by~$b_\bvec{i}$
and~$e_\bvec{i}$. For clarity, we consider one- 
and two-dimensional cases separately.
\paragraph*{One-dimensional intervals.}
Let~$d=1$. We add the following constraint
in addition to~(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd})
and~(\ref{c:ilp:xStrat}).
\begin{itemize}
  \item[(\constr{\label{c:1dim:ilp:interval}})] 
	$x_{i-1}^v + b_i^v = x_i^v + e_{i}^v$ for all $i$
	and all $v\in V$.  This constraint means that the
	interval-indicators force the begin- and end-indicators.
	Namely, presume $x^v$ changes from $0$ to $1$ at index $i$.  
	Then the equation holds only if
	$b_i^v=1$, so this forces the begin-indicator to be true.
	Likewise a switch of $x^v$ from $1$ to $0$ forces the end-indicator
	to be true.
\end{itemize}
It is easy to see that if constraints
(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd}),
(\ref{c:ilp:xStrat}), (\ref{c:1dim:ilp:interval})
 are satisfied, then the sequence
$x_0^v,\dots,x_U^v$ contains exactly one interval of 1s,
and it begins at $i$ if and only if $b_i^v=1$ and
ends at $j-1$ if and only if $e_j^v=1$ 
(See Lemma~\ref{lem:1dim:ilp} in the Appendix).
\paragraph*{Two-dimensional intervals.}
Let~$d=2$, $U_1 = W$, $U_2 = H$.
We introduce following additional variables:
\begin{itemize}
\item $\rowsum{B}{_i^v}\in \{0,1\}$ for every $v\in V$ and $i\in \{1,\dots,H-1\}$	
	with $\rowsum{B}{_i^v} = \sum_j b_{i,j}^v$.  Hence
	$\rowsum{B}{_i^v} = 1$ indicates the topmost row of the interval
	of $v$.  This variable is not really needed since it 
	depends with equality on other variables,
	but serves to make later constraints easier to understand.
\item Likewise we define
	$\columnsum{B}{_j^v} = \sum_i b_{i,j}^v$
	$\rowsum{E}{_i^v} = \sum_j e_{i,j}^v$ and
	$\columnsum{E}{_j^v} = \sum_i e_{i,j}^v$
	to indicate leftmost/bottommost/rightmost row/column of the interval
	of $v$.
\end{itemize}
In addition to~(\ref{c:ilp:frame}), (\ref{c:ilp:singleStartEnd})
and~(\ref{c:ilp:xStrat}),
we impose the following constraints, where as before ``for all $i,j$''
or ``$\sum_{i,j}$'' means ``over the range where the variables are defined'':
\begin{itemize}
\item[(\constr{\label{c:ilp:2dim:xEnd}})] 
	 $e_{i,j}^v\leq x_{i-1,j-1}^v$.
\item[(\constr{\label{c:ilp:2dim:rows}})] 
	 $x_{i-1,j}^v + \rowsum{B}{_i^v} \geq x_{i,j}^v$;~~$x_{i-1,j}^v \leq x_{i,j}^v + \rowsum{E}{_i^v}$.
These constraints force all rows before~$i_1$ 
(such that $\rowsum{B}{_{i_1}^v} = 1$)
and after~$i_2-1$ 
(such that $\rowsum{E}{_{i_2}^v} = 1$)
to only contain zeroes.
Also, for~$j \in \{ j_1, j_2-1\}$ 
(such that $\columnsum{B}_{j_1} = 1$ and $\columnsum{E}_{j_2}=1$)
and~$i = i_1, \ldots, i_2 - 1$,
it is $x_{i,j}^v = 1$, i.e. the left and right boundary of the rectangle of~$v$
contains only ones.
\item[(\constr{\label{c:ilp:2dim:cols}})] 
	 $x_{i,j-1}^v + \columnsum{B}{_j^v} \geq x_{i,j}^v$;~~$x_{i,j-1}^v \leq x_{i,j}^v + \columnsum{E}{_j^v}$.
These constraints force all columns before~$j_1$ 
and after~$j_2-1$ to only contain zeroes.
Also, for~$i \in \{ i_1, i_2-1\}$ 
and~$j = j_1, \ldots, j_2 - 1$,
it is $x_{i,j}^v = 1$, i.e. the upper and lower boundary of the rectangle of~$v$
contains only ones.
Together with the previous constraint, it is~$x_{i,j}^v = 0$ outside of the rectangle of~$v$
and $x_{i,j}^v = 1$ on the boundary.
Since $\rowsum{B}{_{i}^v} = 1$ for exactly one~$i$ etc.,
the interior of the rectangle must be filled with ones.
\end{itemize}
[Correctness proof?]
\subsubsection{SAT formulation.}
\label{se:1dim:sat}



We use straightforward methods to translate 
integer linear constraints into SAT clauses.
Consider~$k,c \in \mathbb N \setminus \{ 0 \}$ and binary variables 
$y_1, \ldots, y_k$, $z$, $w_1, \ldots, w_4$.
For our formulation constraints 
of type
$\sum_{i=1}^k y_i \geq z$, 
$\sum_{i=1}^k y_i \leq c$, 
$\sum_{i=1}^k y_i \geq c$ (for $k > c$),
$w_1 + w_2 = w_3 + w_4$ are sufficient.
We translate the first one
into the clause~$y_1 \vee \ldots \vee y_k \vee \neg z$.
For the second type, for each $i_1, \ldots, i_{c+1}$ pairwise distinct,
we add the clause~$\neg y_{i_1} \vee \ldots \vee \neg y_{i_c} \vee \neg y_{i_{c+1}}$. 
This gives us $\binom{k}{c+1}$ clauses of size~$c+1$.
The third constraint is equivalent to~$\sum_{i=1}^k (1 - y_i) \leq k-c$,
providing $\binom{k}{k-c+1}$ clauses of size~$k-c+1$.
Thus, constraint $\sum_{i=1}^k y_i = c$
is described by $\binom{k}{c+1}$ clauses of size~$c+1$
and $\binom{k}{k-c+1}$ clauses of size~$k-c+1$. 
The fourth constraint is equivalent to $w_1 + w_2 + (1-w_3) + (1 - w_4) = 2$.
\fi
\section{One-dimensional Problems}
\label{se:problems:1dim}
In the following, let $G = (V,E)$ be an undirected graph with~$|V|=n$ and~$|E|=m$. 
One-dimensional grid-based graph representations can be used to model vertices as intersecting intervals (one-dimensional boxes) or as disjoint points that induce a certain vertex order. We present ILP models for three such problems.


\subsection{Pathwidth}

The pathwidth of a graph $G$ is a well-known graph
parameter with many equivalent definitions. We use the definition via the
smallest clique size of an interval supergraph.
More precisely, a graph is an {\em interval graph} if it can be
represented as intersection graph of 1-dimensional intervals.  A
graph $G$ has {\em pathwidth} $pw(G)\leq p$ if there exists an
interval graph $H$ that contains $G$ as a subgraph and for which all
cliques have size at most $p+1$.
It is NP-hard to compute the pathwidth of an arbitrary graph and even
hard to approximate it~\cite{BodlaenderGKH91}. There are fixed-parameter algorithms for computing the pathwidth,
e.g.~\cite{BodlaenderK96}, however, we are not aware of any
implementations of these algorithms.  The only available implementations are exponential-time algorithms, 
e.g., in
sage\footnote{www.sagemath.org}. 

\begin{problem}[Pathwidth]\label{pb:pw}
	Given a graph $G=(V,E)$, determine the pathwidth of~$G$, i.e., the smallest integer $p$ so that $pw(G) \le p$.
\end{problem}

There is an interesting connection between pathwidth and planar graph
drawings of small height.  Any planar graph that has a planar
drawing of height $h$ has pathwidth at most $h$~\cite{FLW03}.
Also, pathwidth is a crucial ingredient in
testing in polynomial time whether a graph has a planar drawing of
height $h$~\cite{DFK+08}.

We create a one-dimensional grid representation of $G$, in which every
vertex is an interval and every edge forces the two vertex intervals
to intersect. The objective is to minimize the maximum number of
intervals that intersect in any given point.
We use the ILP $\mathcal B(1)$ for a grid $\mathcal R = [1,n]$, which
already assigns a non-empty interval to each vertex $v \in V$. We add
binary variables for the edges of $G$, a variable $p \in \mathbb N$
representing the pathwidth of $G$, and a set of additional
constraints as follows.
\begin{align}
  \label{eq:pw:edgevar} x_{i}(e) &\in \{0,1\} &&&& \forall {i} \in {\mathcal R} \text{ and } e \in E\\
\label{eq:pw:oneedge} \sum_{i \in \mathcal R} x_{i}(e) &\ge 1 &&&& \forall e \in E\\
  \label{eq:pw:edge} x_i(uv) &\le x_i(u), & x_i(uv) &\le x_i(v) && \forall uv \in E\\
  \label{eq:pw:pw} \sum_{v \in V} x_i(v) &\le p+1 &&&& \forall i \in \mathcal R 
\end{align}
Our objective function is to minimize the value of $p$ subject to the above constraints.

It is easy to see that every edge must be represented by some grid
point (constraint~(\ref{eq:pw:oneedge})), and can only use those grid
points, where the two end vertices intersect
(constraint~(\ref{eq:pw:edge})). Hence the intervals of vertices
define some interval graph $H$ that is a supergraph of $G$. 
Constraint (13) enforces that at most $p+1$ intervals meet in any
point, which by Helly's property means that $H$ has clique-size at
most $p+1$. So $G$ has pathwidth at most $p$. 
By minimizing $p$ we obtain the desired result. 
In our implementation we translate the ILP into a SAT instance
using the rules given in Section~\ref{sec:satmodel}. 
We test satisfiability
for fixed values of $p$, starting with $p=1$ and increasing it
incrementally until a solution is found.
\begin{theorem}
There exists an ILP/SAT formulation with $O(n(n+m))$ variables
and $O(n(n+m))$ constraints / $O(n^3 + n \binom{n}{p+2})$ clauses of
maximum size $n$ that has a solution of value $\leq p$ if and only
if $G$ has pathwidth $\leq p$.
\end{theorem}

\par
With some easy modifications, the above ILP can be used 
for testing whether a graph is a (proper) interval graph. Section~\ref{sec:boxicity} shows that boxicity-$d$ graphs, the $d$-dimensional generalization of interval graphs, can also be recognized by our ILP.


\iffalse

In this section, we create an integer program whose objective
function is the pathwidth of a given graph.
Recall that there are many equivalent definitions of pathwidth.
The one that we use is that a graph $G$ has pathwidth $\leq p$ 
if there exists a super-graph $H$ of $G$ that is a $(p+1)$-colorable
interval graph.  Put differently, we can assign 1-dimensional
intervals to the vertices such that for every edge $(v,w)$ of $G$
the intervals of $v$ and $w$ intersect, and any point belongs to at
most $p+1$ intervals.  We call this an {\em interval representation}
of a graph of pathwidth $p$.

If we have any interval representation of $G$, then we may by
Lemma~\ref{lem:transformToInteger} presume
that they all have integer endpoints in the range $\{1,\dots,n+1\}$
and that they are closed at the left end and open at the right end.
Hence an interval representation corresponds to assigning
1-dimensional intervals to vertices as explained above, using $U=n+1$.  
Now we only
need to incorporate that for every edge $e=\{v,w\}$, the intervals
of $v$ and $w$ intersect, and that not too many intervals intersect
in one point.    Both are very easy.  We add the following variables:

\begin{itemize}
\item $x_i^e \in \{0,1\}$, with the intended meaning that $x_i^e$
	indicates a point where the 
	intervals corresponding to the endpoints of $e$ intersect.
\item $p\geq 0$ is a variable that indicates the pathwidth.
\end{itemize}

We add the following constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:pw:1}})]
  $\sum_i x_i^e \geq  1$ for all $e\in E$, 
	i.e., every edge does in fact have
	a point where its endpoints intersect.
\item[(\constr{\label{c:1dim:pw:2}})] 
	$x_i^e \leq x_i^v$ and $x_i^e\leq x_i^w$ for every edge
	$e=\{ v,w \}\in E$ and all~$i$, i.e., the intervals of $v$ and $w$ indeed
	cover the point.
\item[(\constr{\label{c:1dim:pw:3}})]
 $\sum_{v\in V} x_i^v \leq p+1$ for all $i$, i.e., no more than $p+1$ intervals meet in a point.
\end{itemize}
and the objective of the integer program is then to minimize $p$.

Directly from the definition of these constraints, and since we
know that the restrictions on $x_i^v,b_i^v,e_i^v$ indeed define
1-dimensional intervals for $v$, it follows that the resulting
value is the pathwidth of the graph.  Also note that the interval
of each vertex can be read from the solution of the integer
program, so solving it also gives us the path decomposition of
the graph.

\begin{theorem}
There exists an integer program with $O(n(n+m))$ variables
and constraints that has a solution of value $\leq p$ if and only
if $G$ has pathwidth $\leq p$.
\end{theorem}

To minimize pathwidth using SAT, we create an SAT instance for each fixed value of~$p$.
We start with~$p=1$ and increase it incrementally,
until a solution is found.
Note that constraint~(\ref{c:1dim:pw:3}) produces $O(n \binom{n}{p+2})$
clauses of size~$p+2$.
\begin{theorem}
There exists a SAT instance with $O(n(n+m))$ variables
and $O(n^3 + n \binom{n}{p+2})$ clauses
of maximum size~$n$ that is satisfiable if and only
if $G$ has pathwidth $\leq p$.
\label{thm:pw:sat}
\end{theorem}
\par
With some easy modifications, the above integer program can also be used 
for testing whether a graph is a (proper) interval graph; see 
Theorems~\ref{thm:int:ilp},\ref{thm:proper-int:ilp} 
in the appendix.

\fi

\subsection{Bandwidth}\label{sec:bandwidth}
The bandwidth of a graph $G$ with $n$ vertices is another classic graph parameter, which is NP-hard to compute~\cite{ccdg-bpgms-82}; due to the practical importance of the problem there are also a few approaches to find exact solutions to the bandwidth minimization problem.
For example,~\cite{bandwidth-exact} and~\cite{mcp-bbambm-08} use the
branch-and-bound technique combined with various heuristics. We
present a solution that can be easily described using our general
framework. However, regarding the running time, it cannot be expected
to compete with techniques specially tuned for solving the bandwidth
minimization problem.

Let $f: V \rightarrow \{1, \dots, n\}$ be a bijection that defines a
linear vertex order. The \emph{bandwidth} of $G$ is defined as $bw(G)
= \min_f \max \{f(v) - f(u) \mid uv \in E \text{ and } f(u) < f(v)\}$,
i.e., the minimum length of the longest edge in $G$ over all possible
vertex orders.


We describe an ILP that assigns the vertices of $G$ to disjoint grid
points  and requires for an integer $k$ that any pair of adjacent
vertices is at most $k$ grid points apart. If the ILP has a solution,
then we know $bw(G) \le k$. We set $\mathcal R = [1, n]$ and add the
following two constraints:
\begin{align}
  \label{eq:bw:onlyone} \sum_{v \in V} x_i(v) &\le 1 && \forall i \in
\mathcal R\\
  \label{eq:bw:dist} x_i(u) &\le \sum_{j=i-k}^{i+k} x_j(v) && \forall
uv \in E\,  \forall i \in \mathcal R
\end{align}
Constraint~(\ref{eq:bw:onlyone}) guarantees that no grid point is
occupied by more than one vertex, and constraint~(\ref{eq:bw:dist})
requires that any two adjacent vertices are at most $k$ grid points
apart.
We note that the variables $b_i(v)$ and $e_i(v)$ and their constraints
are not required in this model since in $\mathcal R = [1,n]$
constraints~(\ref{eq:nonempty}) and~(\ref{eq:bw:onlyone}) suffice to
set exactly one variable $x_i(v)=1$ for every $v \in V$.
We do not need an objective function but rather test if the feasible
region is non-empty for a given $k\ge 1$.

\begin{theorem}
There exists an ILP/SAT formulation with $O(n^2)$ variables
and $O(n \cdot m)$ constraints / $O(n^3)$ clauses of maximum size $n$
that has a solution if and only if
$G$ has bandwidth $\leq k$. 
\end{theorem}





\subsection{Optimum $st$-orientation}

Let $G$ be an undirected graph and let $s$ and $t$ be two vertices of
$G$ with $st \in E$.  An {\em $st$-orientation} of $G$ is an
orientation of the edges such
that $s$ is the unique source and $t$ is the unique sink~\cite{ET76}.  Such an
orientation can exist only if $G$ is biconnected. Computing an
$st$-orientation can be done in linear time~\cite{ET76,b-eo-02}, but
it is NP-complete to find an $st$-orientation that minimizes the
length of the longest path from $s$ to $t$, even for planar
graphs~\cite{SZ10}. It has many
applications in graph drawing~\cite{pt-apsto-10} and beyond.

\begin{problem}[Optimum $st$-orientation]\label{pb:st}
	Given a graph $G=(V,E)$ and two vertices $s,t \in V$ with $st \in E$, find an orientation of $E$ such that $s$ is the only source, $t$ is the only sink, and the length of the longest directed path from $s$ to $t$ is minimum.
\end{problem}


We now formulate an ILP that computes a \emph{height-$k$
$st$-orientation} of $G$, i.e., an $st$-orientation such that the
longest path has length at most $k$ (if one exists).
We use the ILP $\mathcal B(1)$ for $\mathcal R = [1,k]$ to assign
intervals to the vertices and edges of $G$. Vertices are required to
occupy exactly one point, whereas edges must span at least two points.
The additional constraints are as follows:
\begin{align}
  \label{eq:st:one} \sum_{i \in \mathcal R} x_{i}(v) &\le 1 &&&&
\forall v \in V\\
  \label{eq:st:edge} \sum_{i \in \mathcal R} x_i(e) &\ge 2 &&&&
\forall e \in E\\
  \label{eq:st:beginend} b_i(uv) &\le x_i(u) + x_i(v), & e_i(uv)&\le
x_i(u) + x_i(v) && \forall i \in \mathcal R\, \forall uv \in E \\
  \label{eq:st:out} x_i(v) &\le \sum_{vw \in E} b_i(vw) &&&& \forall i
\in \mathcal R \, \forall v \in V\setminus\{t\}\\
  \label{eq:st:in} x_i(v) &\le \sum_{vw \in E} e_i(vw) &&&& \forall i
\in \mathcal R \, \forall v \in V\setminus\{s\}
\end{align}
Similarly to the ILP in Section~\ref{sec:bandwidth}, the variables
$b_i(v)$ and $e_i(v)$ and their constraints are not required for the
vertices, since constraints~(\ref{eq:nonempty})
and~(\ref{eq:st:one}) ensure that every vertex interval consists of a
single grid point. Constraint~(\ref{eq:st:edge}) guarantees that each
edge interval contains at least two points.
Constraint~(\ref{eq:st:beginend}) makes sure that every edge must
begin and end at the grid points occupied by its end vertices.
Finally, constraints~(\ref{eq:st:out}) and~(\ref{eq:st:in}) ensure
that every vertex except $t$ has an outgoing edge and every vertex
except $s$ has an incoming edge. Since $\mathcal R = [1,k]$ and
adjacent vertices cannot occupy the same grid point, we know that if
this ILP has a feasible solution, then the longest directed path from
$s$ to $t$ has length at most $k$. Alternatively, we can set $k=n$ and
use the objective function $\min \sum_{i=1}^n i\cdot x_i(t)$ to
minimize the position of the sink $t$ and thus the longest path from
$s$ to $t$.

\begin{theorem}
There exists an ILP with $O(n(n+m))$ variables
and constraints that computes an optimum $st$-orientation. 
Alternatively, there exists an ILP/SAT formulation with $O(k(n+m))$
variables and $O(k(n+m))$ constraints / $O(k^2(n+m))$ clauses of
maximum size~$n$ that has a solution if and only if a height-$k$
$st$-orientation of~$G$ exists. 
\end{theorem}



\iffalse


We demonstrate this technique for two problems, both of which are NP-hard.
\paragraph{Bandwidth.}
The {\em bandwidth} is a graph parameter  that relates to proper
interval graphs the way pathwidth relates to interval graphs:
A graph has {\em bandwidth} $\leq k$ if it is a subgraph of
a proper interval graph that can be coloured with $k+1$ colours.
Not surprisingly, the integer programs for testing
pathwidth can be combined with the constraints for a proper interval
graph to yield an integer program that computes the bandwidth of
a graph.  But we now show a much
simpler integer program.   An alternate
characterization says that a graph has bandwidth $\leq k$ if
and only if it has a vertex order $v_1,\dots,v_n$ such that any
edge connects two vertices whose indices differ by at most $k$.
We hence add variables $x_i^v$ for every $v\in V$ and $i\in \{1,\dots,n\}$
(the variables $b_i^v$ and $e_i^v$ are not needed)
and add constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:bw:1}})]
 $\sum_{i=1}^n x_i^v \geq 1$, i.e., each vertex has an index.
\item[(\constr{\label{c:1dim:bw:2}})]
 $\sum_{v\in V} x_i^v \leq 1$, i.e., no two vertices can be at
	the same index.  This forces that every vertex has exactly one index.
\item[(\constr{\label{c:1dim:bw:3}})] 
 $x_{i}^v \leq (1-\sum_{j=i+k+1}^n x_{j}^w)$ for all $i$ and
	all ordered pairs $v,w\in V$ with $(v,w)\in E$,
	i.e., if $v$ is at position $i$, then
	$w$ is not allowed at position $i+k+1$ or later.  Since we also
	impose the condition for $(w,v)$, this implies that the indices
	of $v$ and $w$ are within distance $k$.
\end{itemize}

\begin{theorem}
There exists an integer program with $O(n^2)$ variables
and $O(n \cdot m)$ constraints that has a solution if and only if
$G$ has bandwidth $\leq k$.
\end{theorem}
We note here that computing the bandwidth is NP-hard \cite{???}.
Constraints~(\ref{c:1dim:bw:1}), (\ref{c:1dim:bw:2}), (\ref{c:1dim:bw:3})
can be expressed using SAT clauses in the way described earlier.
\begin{theorem}
There exists a SAT instance with $O(n^2)$ variables
and $O(n m \binom{n-k}{2})$ clauses 
of maximum size~$n$ that is satisfiable if and only if
$G$ has bandwidth~$\leq k$.
\label{thm:bw:sat}
\end{theorem} 



\paragraph{Computing $st$-orders with few levels.}
Let $G$ be an undirected graph and let $s$ and $t$ be two vertices of
$G$.  An {\em $st$-order} of $G$ is an orientation of the edges such
that $s$ is the unique source and $t$ is the unique sink.  Such an
order can exist only if $G\cup (s,t)$ is 2-connected.  It has many
applications in graph drawing and [...] 
We now formulate an integer program that expresses an $st$-order
of a given graph.  To do so, we assign a 1-dimensional interval $I_v$ to 
every vertex and a 1-dimensional interval to every edge.  We force
vertices to have a single point as an interval, while edges must
contain at least two points.  Using the end-information, we can then
force that every vertex (except $s$ and $t$) has incoming and outgoing
edges.  Let $U\leq n+1$ be some upper bound that we will fix later.

We hence have the following variables:
\begin{itemize}
\item $x_i^v$ for every $i\in \{1,\dots,U\}$ and every $v\in V$.
	(We could use, but don't need, $b_i^v$ and $e_i^v$.)
\item $x_i^e,b_i^e,e_i^e$ for every $i\in \{1,\dots,U\}$ and every $e\in E$.
\end{itemize}
We have the following constraints:
\begin{itemize}
\item[(\constr{\label{c:1dim:st:1}})]
 $\sum_{i} x_i^v = 1$, i.e., each vertex is represented by one point.
\item[(\constr{\label{c:1dim:st:2}})]
For $x_i^e,b_i^e,e_i^e$ we add constraints analogous to~(\ref{c:ilp:frame}),
\ldots,(\ref{c:1dim:ilp:interval})
to ensure that edge~$e$ is represented
	by an interval as indicated by $x_i^e$ that begins and ends
	as indicated by $b_i^e$ and $e_i^e$.
	These constraints ensure that if~$b_{i_1}^e = 1$ and~$e_{i_2}^e = 1$,
	then $i_1 < i_2$.
\item[(\constr{\label{c:1dim:st:3}})]
 $\sum_i x_i^e \geq 2$, i.e., each edge has non-trivial length.
\item[(\constr{\label{c:1dim:st:4}})]
 $b_i^e\leq x_i^v+x_i^w$ for each $i$ and each edge $e=(v,w)$,
	i.e., edge $e$ begins at the point of $v$ or $w$.
\item[(\constr{\label{c:1dim:st:5}})]
 $e_i^e\leq x_{i-1}^v+x_{i-1}^w$ for each $i$ and each edge $e=(v,w)$,
	i.e., edge $e$ ends at the point of $v$ or $w$.  Since $e$ has
	non-trivial length, but each vertex is a point, this implies
	that the two ends of $e$ are the two different vertices.  This
	in turn implies that $v$ and $w$ cannot be at the same point.
\item[(\constr{\label{c:1dim:st:6}})]
 $x_i^v \leq \sum_{e=\{ v,w\} } b_i^e$ for all $i$ and all $v\neq t$.
	Thus every vertex $v\neq t$ has an incident edge which begins
	at the point of $v$.  Hence the other end of $e$ comes later,
	which means that $v$ has an outgoing edge.
\item[(\constr{\label{c:1dim:st:7}})]
 $x_i^v \leq \sum_{e=\{ v,w\}} e_{i+1}^e$ for all $i$ and all $v\neq s$.
	Similarly this forces that any $v\neq s$ has an incoming edge.
\end{itemize}

Thus, any solution to this integer program yields an $st$-order,
and vice versa, any $st$-order yields a solution if we use $U=n+1$.
However, it is unlikely that this would be used for computing $st$-orders,
since the linear-time algorithm for doing so \cite{ET76} is very
simple.  But we can use this formulation to impose additional
constraints and hence compute solutions to NP-hard problems.

In particular, it is of interest in some graph drawing applications
to compute $st$-orders that minimize the length of the longest
directed path from $s$ to $t$.  This problem is NP-hard even for
plane graphs \cite{SZ10}.
We claim:
\newcommand{\lemMinStText}{A graph $G$ has an $st$-order where the length of the longest path
is $k$ if and only if the integer program
with constraints (\ref{c:ilp:frame}),
\ldots,(\ref{c:1dim:ilp:interval}),
(\ref{c:1dim:st:1}),
\ldots,(\ref{c:1dim:st:7}),
 applied with 
objective function $\min \sum_i (i-1)\cdot x_i^t$, has a solution
of value $\leq k$.}
\begin{lemma}
 \lemMinStText
 \label{le:minSt}
\end{lemma}
In the above formulation the integer program computes the length
of the longest path.  If we know (or have a good guess) of the length
$k$ of the longest path, then we can also test whether this indeed
is the length of the longest path by setting $U=k+2$,
thus saving on the number of variables and constraints.

\begin{theorem}
There exists an integer program with $O(n(n+m))$ variables
and constraints that computes an $st$-order that minimizes
the length of the longest $st$-path.  Alternatively, using only
$O(k(n+m))$ variables and constraints, we can test whether
an $st$-order exists such that the longest $st$-path has length $\leq k$.
\end{theorem}
\begin{theorem}
There exists a SAT instance with $O(k(n+m))$ variables
and $O(k^2(n+m))$ clauses of maximum size~$n$
that is satisfiable if an only if
an $st$-order of~$G$ exists such that the longest $st$-path has length $\leq k$.
\end{theorem}


\fi


\section{Higher-Dimensional Problems}\label{sec:higherdim}
In this section we give examples of two-dimensional visibility graph representations and a $d$-dimensional grid-based graph representation problem. Let again $G=(V,E)$ be an undirected graph with $|V|=n$ and $|E|=m$.

\subsection{Visibility representations}

A visibility representation (also: \emph{bar visibility representation} or \emph{weak visibility representation}) of a graph $G=(V,E)$ maps all vertices to disjoint horizontal line segments, called \emph{bars}, and all edges to disjoint vertical bars, such that for each edge $uv \in E$ the bar of $uv$ has its endpoints on the bars for $u$ and $v$ and does not intersect any other vertex bar. Visibility representations are an important visualization concept in graph drawing, e.g., it is well known that a graph is planar if and only if it has a visibility representation~\cite{Wis85,TT86}.
An interesting recent extension are bar $k$-visibility representations~\cite{deglst-bkvg-07}, which additionally allow edges to intersect at most $k$ non-incident vertex bars. We use our ILP to compute compact visibility and bar $k$-visibility representations. Minimizing the area of a visibility representation is NP-hard~\cite{le-tardhpg-03} and we are not aware of any implemented exact algorithms to solve the problem for any $k\ge 0$. 
By Lemma~\ref{lem:transformToInteger} we
know that all bars can be described with integer coordinates of size $O(m+n)$.

\begin{problem}[Bar $k$-Visibility Representation]\label{pb:barvis}
	Given a graph $G$, an integer grid of size $H\times W$, and an integer $k\ge 0$, find a bar $k$-visibility representation on the given grid (if one exists).
\end{problem}

\paragraph{Bar visibility representations.}
Our goal is to test whether $G$ has a visibility representation in a grid with $H$ columns and $W$ rows (and thus minimize $H$ or $W$). We set $\mathcal R^2 = [1,H]\times[1,W]$ and use ILP $\mathcal B(2)$ to create grid boxes for all edges and vertices in $G$. We add one more set of binary variables for vertex-edge incidences and the following constraints.
\begin{align}
	\label{eq:vi:inci} x_\bvec{i}(e,v) &\in \{0,1\} &&&& \forall \bvec{i} \in \mathcal R^2\, \forall e \in E\, \forall v \in e\\
  \label{eq:vi:vhor} b_i^1(v) &= e_i^1(v) &&&& \forall i \in [1,U_1]\, \forall v \in V\\
  \label{eq:vi:ever} b_i^2(e) &= e_i^2(e) &&&& \forall i \in [1,U_2]\, \forall e \in E\\
  \label{eq:vi:disj} \sum_{v \in V} x_\bvec{i}(v) &\le 1 &&&& \forall \bvec{i} \in \mathcal R^2\\
\label{eq:vi:edge} \sum_{v \in V\setminus e} x_\bvec{i}(v) &\le (1-x_\bvec{i}(e)) &&&& \forall \bvec{i} \in \mathcal R^2\, \forall e \in E
\end{align}
\begin{align}
  \label{eq:vi:inci2} x_\bvec{i}(e,v) &\le x_\bvec{i}(e), & x_\bvec{i}(e,v) &\le x_\bvec{i}(v) && \forall \bvec{i} \in \mathcal R^2\, \forall e \in E\, \forall v \in e\\
  \label{eq:vi:inci3} \sum_{\bvec{i} \in \mathcal R^2} x_\bvec{i}(e,v) &\ge 1 &&&& \forall e \in E\, \forall v \in e\\
  \label{eq:vi:sten} x_\bvec{i}(e,v) &\le b_{\bvec{i}[1]}^1(e) + e_{\bvec{i}[1]}^1(e) &&&& \forall \bvec{i} \in \mathcal R^2\, \forall e \in E\, \forall v \in e
\end{align}
Constraints~(\ref{eq:vi:vhor}) and~(\ref{eq:vi:ever}) ensure that 
all vertex boxes are horizontal bars of height 1 
and all edge boxes are vertical bars of width 1. 
Constraint~(\ref{eq:vi:disj}) forces the vertex boxes to be disjoint; 
edge boxes will be implicitly disjoint due to the remaining constraints. 
No edge is allowed to intersect a non-incident vertex 
due to constraint~(\ref{eq:vi:edge}). 
Finally, we need to set the new incidence variables $x_\bvec{i}(e,v)$ 
for an edge $e$ and an incident vertex $v$ so that $x_\bvec{i}(e,v) = 1$ 
if and only if $e$ and $v$ share the grid point $\bvec{i}$. 
Constraints~(\ref{eq:vi:inci2}) and~(\ref{eq:vi:inci3}) ensure that 
each incidence in $G$ is realized in at least one grid point, 
but it must be one that is used by the boxes of $e$ and $v$. 
Finally, constraint~(\ref{eq:vi:sten}) requires edge $e$ 
to start and end at its two intersection points 
with the incident vertex boxes. 
This constraint is optional, 
but yields a tighter formulation.To transform constraint~(\ref{eq:vi:edge}) into SAT,
we add the clause $\neg x_\bvec{i}(e) \vee \neg x_\bvec{i}(v)$
for each $\bvec{i} \in \mathcal R^2$, $e \in E$, $v \in V \setminus e$, and 
apply the general transformation rules otherwise.

Since every graph with a visibility representation is planar (and vice versa) we have $m \in
O(n)$. Moreover, our ILP and SAT models can also be used to test planarity of a
given graph by setting $H= n$ and $W= 2n-4$, which is sufficient due to Tamassia and Tollis~\cite{TT86}. This might not look interesting at first sight since planarity testing can be done in linear time~\cite{planarityTest}. However, we think that this is still useful as one can add other constraints to the ILP model, e.g., 
to create simultaneous planar embeddings, and use it as a subroutine for ILP formulations of applied graph drawing problems
such as metro maps~\cite{nw-dlhqm-11} and cartograms.



\begin{theorem}\label{thm:barvis}
	There exists an ILP/SAT formulation with $O(HWn)$ variables and
$O(HWn)$ constraints / $O (H W n^2)$ clauses of maximum size $HW$ 
that solves Problem~\ref{pb:barvis} for $k=0$. 
\end{theorem}



\iffalse


In a {\em weak visibility representation} of a graph,
vertices are assigned disjoint horizontal bars and
every edge is drawn as a vertical line segment that begins and
ends at the bars of its endpoints and whose interior does not intersect any
other edge segment or vertex bar.
In a {\em strong} visibility representation,
a pair of vertex bars can be connected by a vertical segment
whose interior does not intersect any other segment 
if and only if the corresponding vertices are adjacent.
We only consider weak visibility representations.
It is well-known that every planar graph has a visibility 
representation \cite{Wis85,TT86,RT86}.  
By Lemma~\ref{lem:transformToInteger} we
may assume that all boxes and line segments can be described
with integer coordinates of size $O(m+n)$ (in fact, a
$(2n-4)\times n$-grid suffices \cite{TT86}.)

With our above ability to assign intervals to vertices via integer
programs, we can easily test whether a graph has a visibility
representation.  In fact, we can even test whether it has a 
visibility representation in a $W\times H$-grid by restricting
the grid points of the integer program formulation to be within this grid.



The idea is to use boxes for {\em both} vertices
and edges, and to ensure disjointness and intersections as needed
by adding extra constraints.
Thus we have:
\begin{itemize}
\item[(\constr{\label{c:vis:vert}})] For every vertex $v$, we have variables $x_{i,j}^v,b_{i,j}^v$ and
	$e_{i,j}^v$ for $i\in \{0,\dots,H\}$, $j\in \{0,\dots,W\}$,
	and we use constraints~(\ref{c:ilp:frame}),
	(\ref{c:ilp:singleStartEnd}), (\ref{c:ilp:xStrat}),
	(\ref{c:ilp:2dim:xEnd}), (\ref{c:ilp:2dim:rows}), (\ref{c:ilp:2dim:cols})
	 to ensure that these
	indicate a 2-dimensional interval $I_v$ of $v$ and its corners.
\item[(\constr{\label{c:vis:edges}})] For every edge $e$, we similarly have variables $x_{i,j}^e,b_{i,j}^e$ and
	$e_{i,j}^e$ and constraints
to ensure that these
	indicate a 2-dimensional interval $I_e$ of $e$ and its corners.
\item[(\constr{\label{c:vis:eVert}})]
	We enforce that edge $e$ is represented by a vertical segment, not a box,
	by adding the constraint 
$b_{i,j}^e \leq \columnsum{E}{_{j+1}^e}$
	for all grid points $(i,j)$.
	Thus, if the top left corner of the box of $e$ is at $(i,j)$,
	then the bottom right corner must be in column $j+1$. 
	Since (as usual) we consider the intervals to be
	open at the bottom and right, this means that the points
	inside the box form a vertical line segment.
\item[(\constr{\label{c:vis:vHor}})]
	We enforce that vertex $v$ is represented by a horizontal segment, not a box,
	by adding the constraint 
$b_{i,j}^v \leq \rowsum{E}{_{i+1}^v}$
	for all grid points $(i,j)$.
	Thus, if the top left corner of the box of $v$ is at $(i,j)$,
	then the bottom right corner must be in row $i+1$.
	Thus, the points inside the box form a horizontal line segment.
\item[(\constr{\label{c:vis:vDisj}})]
	We enforce that vertices are disjoint by adding
	$\sum_{v\in V} x_{i,j}^v \leq 1$ for any grid point $(i,j)$.
\item[(\constr{\label{c:vis:evNonAdj}})]
 	We enforce that edges do not intersect non-incident vertices
	by adding\\ $\sum_{v\in V, v\neq u,w} x_{i,j}^v \leq (1-x_{i,j}^e)$ 
	for any grid point $(i,j)$ and any edge $e=\{ u,w \}$.		 	
\item[(\constr{\label{c:vis:evAdj}})]
	For every edge $e$ with incident vertex $v$, we define a
	variable $x_{i,j}^{e,v}$, with the intended meaning that
	$x_{i,j}=1$ if and only if $I_e$ and $I_v$ meet at point $(i,j)$.
	We enforce that edge $e$ intersects an incident vertex $v$ by adding
	$\sum_{i,j} x_{i,j}^{e,v} \geq 1$, as well as
	$x_{i,j}^{e,v} \leq x_{i,j}^e$ and $x_{i,j}^{e,v} \leq x_{i,j}^v$,
	for all $i,j$, all edges $e\in E$, and both incident vertices $v$.
\item[(\constr{\label{c:vis:eBeginEndAtV}})]
	For every vertex~$v$ and an incident edge $e$,
	we enforce that $e$ starts or ends inside the bar of~$v$
	by adding $x_{i,j}^{e,v} \leq b_{i,j}^e + e_{i+1,j+1}^e$.
	If~$v$ and~$e$ intersect at~$(i,j)$, then~$e$ begins or ends at~$(i,j)$.
	Note that this constraint is optional for testing the existence.
	E.g., if an edge~$e$ ends ``beyond'' the bar of the corresponding incident vertex~$v$,
	we cut off~$e$ at~$v$ in a post-processing step. \comment{RP: keep/remove?}
\end{itemize}
Note that since all vertex bars are horizontal, all edge bars are vertical,
and edge bars only intersect bars of incident vertices,
we do not have to additionally enforce that edges have disjoint interiors.
\par



One easily verifies that we have $O(H\cdot W\cdot (n+m))$ variables and
constraints.  We may assume $m\in O(n)$ (otherwise the graph
surely isn't planar and doesn't have a visibility representation)
and hence get:

\begin{lemma}
There exists an integer program with $O(HWn)$ variables and
constraints that has a solution if and only if $G$  has a
visibility representation in a $W\times H$-grid.
\end{lemma}
\begin{lemma}
There exists a SAT instance with $O(HWn)$ variables and
$O(HW n^2)$ 
clauses of maximum size~$HW$ that is satisfiable
if and only if $G$  has a
visibility representation in a $W\times H$-grid.
\end{lemma}
We have the following corollary.  First, recall that $G$ is planar
if and only if it has a visibility representation in an $O(n)\times O(n)$-grid.
We hence have:

\begin{corollary}
There exists an integer program with $O(n^3)$ variables and
constraints that has a solution if and only if $G$  is planar.
\end{corollary}

\fi


\paragraph{Bar $k$-visibility representations.}
It is easy to extend our previous model for $k=0$ to test bar
$k$-visibility representations for $k\ge 1$. We drop
constraint~(\ref{eq:vi:edge}), introduce another set of binary
variables to indicate intersections between edges and non-incident
vertices, and add the following constraints.
\begin{align}
  \label{eq:kvi:vars} y_\bvec{i}(e) &\in \{0,1\} && \forall \bvec{i}
\in \mathcal R^2\, \forall e \in E\\
  \label{eq:kvi:cross} x_\bvec{i}(e) + \sum_{v \in V\setminus e}
x_\bvec{i}(v) &\le y_\bvec{i}(e)+1 && \forall \bvec{i} \in \mathcal
R^2\, \forall e \in E\\
  \label{eq:kvi:bark} \sum_{\bvec{i} \in \mathcal R^2} y_\bvec{i}(e)
&\le k && \forall e \in E
\end{align}
\vspace{-2ex}
\begin{equation}
    \label{eq:kvi:disj} x_\bvec{i}(e) + x_\bvec{i}(e') - \frac{1}{2}
(b_{\bvec{i}[1]}^1(e) + e_{\bvec{i}[1]}^1(e) + b_{\bvec{i}[1]}^1(e') +
e_{\bvec{i}[1]}^1(e')) \le 1 \, \forall \bvec{i} \in \mathcal R^2\,
\forall (e,e') \in \binom{E}{2}
\end{equation}
The variable $y_\bvec{i}(e)$ is supposed to equal 1 if and only if $e$
intersects a non-incident vertex at position $\bvec{i}$.
Constraint~(\ref{eq:kvi:cross}) enforces that $y_\bvec{i}(e)=1$ if
grid point $\bvec{i}$ is occupied by $e$ and a non-incident vertex and
constraint~(\ref{eq:kvi:bark}) makes sure that no more than $k$ such
non-incident bars are crossed by each edge. Finally,
constraint~(\ref{eq:kvi:disj}) guarantees that any two edge bars are
disjoint, except for the case that they are incident to the same
vertex bar and meet at a common endpoint. (Alternatively, we could
enforce disjointness for all edge bars if we required vertex bars of
height~$2$.)

To transform constraint~(\ref{eq:kvi:cross}) into SAT,
we add clause $\neg x_\bvec{i}(e) \vee \neg x_\bvec{i}(v) \vee
y_\bvec{i}(e)$
for each $\bvec{i} \in \mathcal R^2$, $e \in E$, $v \notin e$.
For~(\ref{eq:kvi:disj}), we add
$\neg x_\bvec{i}(e) \vee \neg x_\bvec{i}(e') \vee b_{\bvec{i}[1]}^1(e)
\vee e_{\bvec{i}[1]}^1(e)$
for each ordered pair $e,e' \in E$, $e \neq e'$.
For the rest of the constraints, we apply the general transformation
rules.

\begin{theorem}\label{thm:barkvis}
	There exists an ILP/SAT formulation with $O(HW(n+m))$ variables and
$O(HW(m^2+n))$ constraints / $O(\binom{HW}{k+1} m + HW m^2)$ clauses
of maximum size $HW$ that solves Problem~\ref{pb:barvis} for $k\ge 1$.
\end{theorem}



\iffalse


We can easily extend our approach to compute 
\emph{$k$-bar-visibility representations}\cite{???},
i.e., we now allow each edge to cross at most~$k$ bars of 
non-incident vertices.
We replace constraint~(\ref{c:vis:evNonAdj}) by the following:
\begin{itemize}
  \item[(\constr{\label{c:vis:kbar}})]
  For each edge~$e$ and each point~$(i,j)$ we introduce 
  a variable~$y_{i,j}^e \in \{ 0,1\}$, with the intended meaning that
  $y_{i,j}^e = 1$ if~$e$ intersects a non-incident edge at~$(i,j)$.
  For each~$e=\{ u,w\}$ and each~$(i,j)$ we add the constraint
  $x_{i,j}^e + \sum_{v \neq u,w} x_{i,j}^v \leq y_{i,j}^e + 1$.
  We enforce the $k$-bar-visibility condition by $\sum_{i,j} y_{i,j}^e \leq k$
  for each~$e$.
  \item[(\constr{\label{c:vis:eDisj}})]
  Note that we now have to explicitly make sure that edges are disjoint (except perhaps at a common
  endpoint). We add
  $\sum_{e\in E} (x_{i,j}^e-\frac{1}{2}b_{i,j}^e-\frac{1}{2}e_{(i+1)(j+1)}^e) \leq 1$
  for any grid point $(i,j)$.  
\end{itemize}
\begin{lemma}
There exists an integer program with $O(HW(n+m))$ variables and
constraints that has a solution if and only if $G$  has a
weak $k$-bar-visibility representation in a $W\times H$-grid.
\end{lemma}
\subsubsection{Rectangle-visibility representations.}
The formulation for bar-visibility can be easily be extended to compute 
\emph{weak rectangle-visibility representations}\cite{???},
i.e, vertices are boxes and edges represent horizontal bars
that intersect no other box or bar in its interior.
We remove the constraint~(\ref{c:vis:vHor})
and modify~(\ref{c:vis:vHor})
into $b_{i,j}^v \leq \rowsum{E}{_{i+1}^v} + \columnsum{E}{_{j+1}^v}$.
Again, we require constraint~(\ref{c:vis:eDisj}).
\par
A planar graph has a planar straight-line drawing of
height $H$ if and only if it has a visibility representation
of height $H$ for which all vertices are horizontal line 
segments (see \cite{Bie-WAOA12} for obtaining the straight-line
drawing from the visibility representation; the other direction
is much easier and left to the reader.)
\comment{TB: Or perhaps I should write it up somewhere.}
Moreover, by Lemma~\ref{lem:transformToInteger} we may
assume that the visibility representation has width at most $2(m+n)\in O(n)$.
Hence we have:

\begin{corollary}
There exists an integer program with $O(Hn^2)$ variables and
constraints that has a solution if and only if $G$  has
a planar straight-line drawing of height $H$.
\end{corollary}

\fi


\subsection{Boxicity-$d$ graphs}\label{sec:boxicity}
A graph is said to have {\em boxicity} $d$ if it can be represented
as intersection graph of $d$-dimensional axis-aligned boxes. Testing
whether a graph has boxicity $d$ is NP-hard, even for
$d=2$~\cite{Kra94}. We are not aware of any implemented algorithms to
determine the boxicity of a graph. By
Lemma~\ref{lem:transformToInteger} we can restrict ourselves to a grid
of side length $n$.

We use ILP $\mathcal B(d)$ for $\mathcal R^d = [1,n]^d$ to model a
$d$-dimensional box for each vertex of a graph $G=(V,E)$. We add the
following variables and constraints to achieve the correct
intersection properties.
\begin{align}
  \label{eq:bx:var} x_\bvec{i}(e) &\in \{0,1\} &&&& \forall \bvec{i}
\in \mathcal R^d\, \forall e \in E\\
  \label{eq:bx:nonempty} \sum_{\bvec{i} \in \mathcal R^d}
x_\bvec{i}(e) &\ge 1 &&&& \forall e \in E\\
  \label{eq:bx:vtcs} x_\bvec{i}(uv) &\le x_\bvec{i}(u), &
x_\bvec{i}(uv) &\le x_\bvec{i}(v) && \forall \bvec{i} \in \mathcal
R^d\, \forall uv \in E\\
  \label{eq:bx:disj} x_\bvec{i}(u) + x_\bvec{i}(v) &\le 1 &&&& \forall
\bvec{i} \in \mathcal R^d\, \forall uv \in \binom{V}{2} \setminus E
\end{align}
The variables $x_\bvec{i}(e)$ indicate whether a grid point lies in
the intersection of two boxes and thus represents an edge.
Constraint~(\ref{eq:bx:nonempty}) guarantees that there is a non-empty
intersection for each edge $e \in E$, and by
constraint~(\ref{eq:bx:vtcs}) we make sure that the intersection
indicator for an edge $uv$ can only be set to $1$ at position
$\bvec{i}$ if the grid boxes for $u$ and $v$ both occupy point
$\bvec{i}$. Finally, constraint~(\ref{eq:bx:disj}) enforces that no
grid point can be occupied by a pair of non-adjacent vertices.



\begin{theorem}
There exists an ILP with $O(n^d (n+m))$ variables and
$O(n^{d+2})$ constraints 
as well as a SAT instance with $O(n^d (n+m))$ variables and
$O(n^{d+2})$ clauses of maximum size $O(n^d)$
to test whether a graph $G$ has boxicity $d$.
\end{theorem}


\section{Experiments}\label{sec:exp}
We implemented and tested our formulation for minimizing pathwidth, bandwidth,
length of longest path in an $st$-orientation, and width of
bar-visibility and bar 1-visibility representations, as well as
deciding whether a graph has boxicity~2.
\par

The experiments were performed on a single core of an
AMD Opteron 6172 processor running Linux~3.4.11. The machine is
clocked at 2.1 Ghz, and has 256 GiB RAM. Our
implementation\footnote{available from
\url{http://i11www.iti.kit.edu/gdsat}} is written
in C++ and was compiled with GCC 4.7.1 using optimization
\texttt{-O3}. As test sample we used the \emph{Rome graphs} dataset
\cite{rome} which consists of 11533 graphs with vertex number between
10 and 100. $18\%$ of the Rome graphs are planar.
Figure~\ref{fig:size-distr} shows
the size distribution of the Rome graphs.

\begin{figure}[tbp]
\centering
  \includegraphics{fig/graphs/graphComplexity}
 \caption{\small Size distribution of Rome graphs.
 Black: all graphs,
 blue: biconnected blocks ($n{\geq}3$),
 orange: planar graphs. We used an $(1,2,3,2,1)$-Gaussian filter to
reduce oscillations.  
 }
 \label{fig:size-distr}
\end{figure}


We initially used the \emph{Gurobi} solver \cite{gurobi} to
test the implementation of the ILP formulations, however it turned out
that even for very small graphs ($n<10$) solving a single instance can
take minutes. We therefore focused on the equivalent SAT
formulations gaining a significant speed-up. As SAT solver we used
\emph{MiniSat}~\cite{minisat} in version~2.2.0.  
For each of the five minimization problems we determined obvious lower and upper bounds in~$O(n)$ for the respective graph parameter. Starting with the lower bound we iteratively increased the parameter to the next integer until a solution was found (or a predefined timeout was exceeded). Each iteration consists of constructing the SAT formulation 
and executing the SAT solver. We measured the total time spent in all iterations.
For boxicity~2 we decided to consider square grids and minimize
their side lengths. Thus the same iterative procedure applies to boxicity~2.



Note that for all considered
problems a binary search-like procedure for the parameter value did not prove to be efficient, since the solver usually takes more time with increasing parameter value, which is mainly due to the increasing number of variables and
clauses.
For the one-dimensional problems we used a timeout of 300 seconds, for the two-dimensional problems of 600 seconds. 

We ran the instances sorted by size~$n+m$ starting with the smallest
graphs. If more than 400 consecutive graphs in this order produced
timeouts, we ended the experiment prematurely and evaluated only the
so far obtained results. Figures~\ref{fig:1d} and~\ref{fig:2d}
summarize our experimental results and show the percentage of Rome
graphs solved within the given time limit, as well as scatter plots
with each solved instance represented as a point depending on its
graph size and the required computation time. 

\begin{figure}[t]
\subfloat[percentage of solved instances]{
 	\includegraphics{fig/diagram123}
 	\label{fig:solved}
 }
 \hfill
 \subfloat[pathwidth]{
 \includegraphics
 {fig/pathwidth/diagram2_nodesAndEdges}
 	\label{fig:pw:time}
 }\\
\subfloat[bandwidth]{
 	\includegraphics{fig/bandwidth/diagram2_nodesAndEdges}
 	\label{fig:bw:time}
 }
 \hfill
 \subfloat[$st$-orientation]{
 	\includegraphics{fig/orderings/diagram2_nodesAndEdges}
 	\label{fig:st:time}
 }
 \caption{\small
  Experimental results for the one-dimensional problems.
  \protect\subref{fig:solved} Percentage of solved instances.
  \protect\subref{fig:pw:time}--\protect\subref{fig:st:time}: 
  Time in seconds for solving an instance (dots)
  and percentage of instances not solved within 300 seconds (red curves), 
  both in relation to~$n+m$ 
}\label{fig:1d}
	\vspace{-2ex}
\end{figure}

\smallskip\noindent\textit{Pathwidth.}
As Fig.~\ref{fig:solved} shows,
we were able to compute the pathwidth for $17.0\%$ of all Rome graphs,
from which $82\%$ were solved within the first minute
and only $3\%$ within the last.
Therefore, we expect that a significant increase of the timeout value
would be necessary for a noticeable increase 
of the percentage of solved instances.
We note that almost all small graphs ($n+m<45$)
could be solved within the given timeout,
however, for larger graphs, the percentage of solved instances rapidly drops,
as the red curve in Fig.~\ref{fig:pw:time} shows.
Almost no graphs with $n+m>70$ were solved.

\smallskip\noindent\textit{Bandwidth.}
We were able to compute the bandwidth for $22.3\%$ of all Rome graphs
(see Fig.~\ref{fig:solved}),
from which $90\%$ were solved within the first minute
and only $1.3\%$ within the last.
Similarly to the previous case, the procedure 
terminated successfully within 300 seconds 
for almost all small graphs ($n+m<55$ in this case), 
while almost none of the larger graphs ($n+m>80$) were solved;
see the red curve in Fig.~\ref{fig:bw:time}.

\smallskip\noindent\textit{Optimum $st$-orientation.}
Note that very few of the Rome graphs are biconnected.
Therefore, to test our SAT implementation 
for computing the minimum number of levels in an $st$-orientation,
we subdivided each graph into biconnected blocks 
and removed those with~$n \leq 2$,
which produced 13606 blocks in total;
see Fig.~\ref{fig:size-distr} for the distribution of block sizes.
Then, for each such block, we randomly selected 
one pair of vertices~$s,t$, $s \neq t$, connected them by an edge if
it did not already exist and ran the iterative procedure.
In this way, for the respective choice of~$s,t$
we were able to compute the minimum number of levels 
in an $st$-orientation for all biconnected blocks; 
see Fig.~\ref{fig:solved}.
Moreover, no graph took longer than 57 seconds,
for $97\%$ of the graphs it took less than 10 seconds
and for $68\%$ less than 3 seconds.
Even for the biggest blocks with $m+n > 200$,
the procedure successfully terminated within 15 seconds 
in $93\%$ of the cases; see Fig.~\ref{fig:st:time}.

\begin{figure}[t]
\subfloat[percentage of solved instances]{
 	\includegraphics{fig/diagramBar}
 	\label{fig:visrep:solved}
 }
 \hfill
 \subfloat[bar visibility]{
\includegraphics{fig/visrep_width/diagram}
 	\label{fig:visrep:time}
 }\\
 \subfloat[bar 1-visibility]{
 	\includegraphics{fig/onebar_width/diagram}
 	\label{fig:1bar:time}
 }
 \hfill
  \subfloat[boxicity 2]{
 	\includegraphics{fig/boxicity/diagram2_nodesAndEdges}
 	\label{fig:box:time}
 }
 \caption{\small Experimental results for the two-dimensional problems.
  \protect\subref{fig:visrep:solved} 
   Percentage of solved instances. The red horizontal line shows the
   percentage of planar graphs over all Rome graphs.
  \protect\subref{fig:visrep:time}--\protect\subref{fig:box:time}:  
   Time in seconds for solving an instance (dots)
   and percentage of instances not solved within 600 seconds (red curves), 
   both in relation to~$n+m$.
 }\label{fig:2d}
	\vspace{-2ex}
\end{figure} 


\smallskip\noindent\textit{Bar visibility.}
To compute bar-visibility representations of minimum width,
we iteratively tested for each graph all widths~$W$
between~1 and~n. We used the trivial upper bound $H=n$ for the height.
We were able to compute solutions
for~$28.5\%$ of all 3281 planar Rome graphs (see
Fig.~\ref{fig:visrep:solved}), $69\%$ of which were solved within the
first minute and less than~$0.1\%$ within the last.
We were able to solve all small instances with~$n+m \leq 23$
and almost none for~$n+m >55$; see the red curve in
Fig.~\ref{fig:visrep:time}.
\par


\smallskip\noindent\textit{Bar 1-visibility.} We also ran the width minimization procedure for 
bar 1-visibility representations on all Rome graphs. 
The number of graphs for which the procedure terminated successfully
within the given time is 833 ($7.2\%$ of all Rome graphs),
which is close to the corresponding number for bar-visibility; see
Fig.~\ref{fig:visrep:solved}. 
 This is not surprising, since most small Rome graphs are planar;
 see Fig.~\ref{fig:size-distr}. 
For bar 1-visibility, eight graphs were solved 
which were not solved for bar-visibility.
Interestingly, they were all planar.
All but 113 graphs successfully processed in the previous
experiment 
were also successfully processed in this one. 
A possible explanation for those~113 graphs is that the SAT formulation for
 bar 1-visibility requires more clauses.
All small graphs with $n+m \leq 23$ were processed successfully.
Interestingly, for none of the processed graphs
the minimum width actually decreased in comparison to their
minimum-width bar-visibility representation.


\smallskip\noindent\textit{Boxicity-2}
For testing boxicity~2,
we started with a~$3\times 3$ grid for each graph 
and then increased height and width simultaneously after each iteration.
Within the specified timeout of~600 seconds,
we were able to decide whether a graph has boxicity~2
for $18.7\%$ of all Rome graphs (see Fig.~\ref{fig:visrep:time}),
$82\%$ of which were processed within the first minute and~$0.3\%$
within the last.
All of the successfully processed graphs actually had boxicity~2.
Small graphs with $n+m \leq 50$ were processed almost completely,
while almost none of the graphs with $n+m> 70$ finished;
see Fig.~\ref{fig:box:time}. 
\section{Conclusion}
We presented a versatile ILP formulation for determining placement of
grid boxes according to problem-specific constraints. We gave six
examples of how to extend this formulation for solving numerous
NP-hard graph drawing and graph representation problems, such as
bar-visibility representations, computing the pathwidth and the
boxicity, and finding an st-orientation that minimizes the
longest directed path. Our experimental evaluation showed that while solving the original ILP is rather slow, the easily derived SAT formulations perform quite well for smaller graphs. While our approach is not suitable to replace specialized exact or heuristic algorithms that are faster and/or can solve larger instances of these problems, it does provide a simple-to-use tool for solving problems that can be modeled by grid-based graph representations without much implementation effort. This can be useful, e.g., for verifying counterexamples, NP-hardness gadgets, or for computing solutions to certain instances in practice.

We note that many other problems can easily be formulated as ILPs by assigning
grid-boxes to vertices or edges.  Among those are, e.g., testing
whether a planar graph has a straight-line drawing of height $h$,
testing whether a planar graph has a rectangular dual with
integer coordinates and prescribed integral areas, testing whether a graph is a $t$-interval graph, or whether a  bipartite graph can be represented as a planar bus graph. 
Important open problems are to reduce the complexity of our formulations and the question whether approximation algorithms for graph drawing can be derived from our model via fractional relaxation. 


{\small
  \bibliography{abbrv,ilp-gd}
  \bibliographystyle{abbrv}
}






\end{document}
