\documentclass{LMCS}

\def\dOi{10(3:24)2014}
\lmcsheading {\dOi}
{1--28}
{}
{}
{Nov.~25, 2013}
{Sep.~18, 2014}
{}

\ACMCCS{[{\bf Theory of computation}]: Formal languages and automata
  theory---Regular languages} 

\subjclass{F.4.3}

\usepackage{amsmath,amssymb,xspace,pdfsync,mathrsfs,graphicx,verbatim}
\usepackage{refcount,hyperref}

\usepackage{tikz}
\usepackage[T1]{fontenc}
\usetikzlibrary{trees,arrows,patterns,shapes,snakes,decorations,fit,shadows,calc}

\usepackage{amsthm}

\usepackage[textwidth=3cm]{todonotes}
\setlength{\marginparwidth}{3cm}
\newcommand{\mynote}[3][]{\todo[caption={\sf #3}, color={\ifnum#2=0 green!20
    \else\ifnum#2=1 orange!30
    \else\ifnum#2=2 yellow!20
    \else\ifnum#2=3 cyan!20
    \else magenta!20\fi\fi\fi\fi}, size=\tiny, #1]{\renewcommand{\baselinestretch}{1}\selectfont\sf#3}\xspace}
\newcommand\mznote[1]{\mynote0{#1}}
\newcommand\mypar[1]{\par\medskip\noindent\textbf{#1}}


\definecolor{my1}{cmyk}{0,.6,0,0}
\definecolor{my2}{cmyk}{.3,.0,.0,.0}

\newcommand{\efgame}{Ehrenfeucht-Fra\"iss\'e\xspace}
\newcommand\nat{\ensuremath{\mathbb{N}}\xspace}
\newcommand\As{\ensuremath{\mathcal{A}}\xspace}
\newcommand\Bs{\ensuremath{\mathcal{B}}\xspace}
\newcommand\Ps{\ensuremath{\mathcal{P}}\xspace}
\newcommand\Cs{\ensuremath{\mathcal{C}}\xspace}

\newcommand{\lt}{\textup{LT}\xspace}
\newcommand{\ltt}{\textup{LTT}\xspace}
\newcommand{\lttm}{\textup{LTT+MOD}\xspace}

\newcommand\kloop{-loop\xspace}
\newcommand\kloops{-loops\xspace}
\newcommand\ktame{-\tame}
\newcommand\kltame{-\tame}
\newcommand\tame{tame\xspace}
\newcommand\ktestable{-locally testable\xspace}
\newcommand\testable[1]{-locally testable\xspace}
\newcommand\kdttestable{-locally threshold testable\xspace}
\newcommand\ttestable[2]{-locally threshold testable\xspace}

\newcommand\image[1]{-image\xspace}
\newcommand\images[1]{-images\xspace}
\newcommand\kimage{\image{k}}
\newcommand\kimages{\images{k}}

\newcommand\profile[1]{-profile\xspace}
\newcommand\profiles[1]{-profiles\xspace}
\newcommand\kprofile{\profile{k}}
\newcommand\kprofiles{\profiles{k}}
\newcommand\type[1]{-type\xspace}
\newcommand\types[1]{-types\xspace}
\newcommand\ktype{\type{k}}
\newcommand\ktypes{\types{k}}

\newcommand\lttmeq[3]{\ensuremath{\equiv_{#1}^{#2,#3}}\xspace}
\newcommand\kdplttmeq{\lttmeq{k}{d}{p}}
\newcommand\ltteq[2]{\ensuremath{\equiv_{#1}^{#2}}\xspace}
\newcommand\kdltteq{\ltteq{k}{d}}
\newcommand\lteq[1]{\ensuremath{\equiv_{#1}}\xspace}
\newcommand\klteq{\lteq{k}}

\newcommand{\ltclos}[2]{\ensuremath{[#1]_{#2}}}
\newcommand{\lttclos}[3]{\ensuremath{[#1]_{#2}^{#3}}}
\newcommand{\lttmclos}[4]{\ensuremath{[#1]_{\lttmeq{#2}{#3}{#4}}}}

\newcommand{\de}{\ensuremath{\Delta_{2}}\xspace}
\newcommand{\dew}{\ensuremath{\Delta_{2}(<)}\xspace}
\newcommand{\dewn}{\ensuremath{\Delta_{2}(<,Succ)}\xspace}
\newcommand{\siw}{\ensuremath{\Sigma_{2}(<)}\xspace}
\newcommand{\siwn}{\ensuremath{\Sigma_{2}(<,Succ)}\xspace}
\newcommand{\piw}{\ensuremath{\Pi_{2}(<)}\xspace}
\newcommand{\piwn}{\ensuremath{\Pi_{2}(<,Succ)}\xspace}

\newcommand{\utl}{\ensuremath{UTL}\xspace}
\newcommand{\efw}{\ensuremath{F + F^{-1}}\xspace}
\newcommand{\efwn}{\ensuremath{F + F^{-1} + X + X^{-1}}\xspace}



\newcommand\fod{\ensuremath{\textup{FO}^2}\xspace}
\newcommand\fodw{\ensuremath{\textup{FO}^2(<)}\xspace}
\newcommand\fodwn{\ensuremath{\textup{FO}^2(<,Succ)}\xspace}

\newcommand{\fo}{\ensuremath{\textup{FO}}\xspace}
\newcommand{\fow}{\ensuremath{\textup{FO}(<)}\xspace}
\newcommand{\fos}{\ensuremath{\textup{FO}(+1)}\xspace}
\newcommand{\fom}{\ensuremath{\textup{FO}_{mod}(+1)}\xspace}

\newcommand\subtree[2]{\ensuremath{#1|_{#2}}\xspace}


\newcommand\Cc{\ensuremath{\mathcal{C}}\xspace}
\newcommand\Dc{\ensuremath{\mathcal{D}}\xspace}

\newcommand\pata[1]{\ensuremath{#1}-pattern\xspace}
\newcommand\patas[1]{\ensuremath{#1}-patterns\xspace}


\newcommand\kpata{\pata{k}}
\newcommand\kpatas{\patas{k}}

\newcommand\patt[2]{\ensuremath{(#1,#2)}-pattern\xspace}
\newcommand\patts[2]{\ensuremath{(#1,#2)}-patterns\xspace}

\newcommand\temp[1]{\ensuremath{#1}-template\xspace}
\newcommand\temps[1]{\ensuremath{#1}-templates\xspace}
\newcommand\ltemp{\temp{l}}
\newcommand\ltemps{\temps{l}}


\newcommand\impl[1]{\ensuremath{#1}-implementation\xspace}
\newcommand\impls[1]{\ensuremath{#1}-implementations\xspace}

\newcommand\kimpl{\impl{k}}
\newcommand\kimpls{\impls{k}}

\newcommand\impv[1]{\ensuremath{#1}-implements\xspace}
\newcommand\kimpv{\impv{k}}

\newcommand\peq[1]{\ensuremath{\sim_{#1}}\xspace}
\newcommand\kpeq{\peq{\kappa}}

\newcommand\fodeq[1]{\ensuremath{\cong_{#1}}\xspace}
\newcommand\kfodeq{\fodeq{\kappa}}

\newcommand\foeq[1]{\ensuremath{\equiv_{#1}}\xspace}
\newcommand\kfoeq{\foeq{\kappa}}


\newcommand\decop[1]{\ensuremath{#1}-decomposition\xspace}
\newcommand\decops[1]{\ensuremath{#1}-decompositions\xspace}
\newcommand\pfsdecomp{\decop{\Ps}}
\newcommand\pfsdecomps{\decops{\Ps}}
\newcommand\kdecop{\decop{k}}
\newcommand\kdecops{\decops{k}}

\newcommand\Sep{\ensuremath{\mathcal{S}}\xspace}
\newcommand\C{\ensuremath{\mathcal{C}}\xspace}
\newcommand\um{\ensuremath{\mathbbold{1}}}
\newcommand\content[1]{\ensuremath{\contentmorphism(#1)}}
\newcommand\contentscc[2]{\ensuremath{\contentmorphism\_\mathsf{scc}(#1,#2)}}
\newcommand\arity[1]{\ensuremath{\textsf{arity}(#1)}}
\newcommand\contentmorphism{\ensuremath{\textsf{alph}}}
\newcommand\scc[2]{\ensuremath{\textsf{scc}(#1,#2)}}

\newcommand\pref[2]{\ensuremath{\textsf{pref}_{#1}(#2)}}
\newcommand\suff[2]{\ensuremath{\textsf{suff}_{#1}(#2)}}
\newcommand\samefac[1]{\ensuremath{\equiv_{#1}}}
\newcommand\eqlt[1]{\ensuremath{\sim_{#1}}}

\newcommand\fra{\ensuremath{\mathfrak{a}}\xspace}
\newcommand\frb{\ensuremath{\mathfrak{b}}\xspace}
\newcommand\frc{\ensuremath{\mathfrak{c}}\xspace}
\newcommand\frd{\ensuremath{\mathfrak{d}}\xspace}
\newcommand\fre{\ensuremath{\mathfrak{e}}\xspace}
\newcommand\frf{\ensuremath{\mathfrak{f}}\xspace}
\newcommand\frg{\ensuremath{\mathfrak{g}}\xspace}
\newcommand\frh{\ensuremath{\mathfrak{h}}\xspace}
\newcommand\fri{\ensuremath{\mathfrak{i}}\xspace}
\newcommand\frj{\ensuremath{\mathfrak{j}}\xspace}
\newcommand\frk{\ensuremath{\mathfrak{k}}\xspace}
\newcommand\frl{\ensuremath{\mathfrak{l}}\xspace}
\newcommand\frm{\ensuremath{\mathfrak{m}}\xspace}
\newcommand\frn{\ensuremath{\mathfrak{n}}\xspace}
\newcommand\fro{\ensuremath{\mathfrak{o}}\xspace}
\newcommand\frp{\ensuremath{\mathfrak{p}}\xspace}
\newcommand\fqq{\ensuremath{\mathfrak{q}}\xspace}
\newcommand\frr{\ensuremath{\mathfrak{r}}\xspace}
\newcommand\frs{\ensuremath{\mathfrak{s}}\xspace}
\newcommand\frt{\ensuremath{\mathfrak{t}}\xspace}
\newcommand\fru{\ensuremath{\mathfrak{u}}\xspace}
\newcommand\frv{\ensuremath{\mathfrak{v}}\xspace}
\newcommand\frw{\ensuremath{\mathfrak{w}}\xspace}
\newcommand\frx{\ensuremath{\mathfrak{x}}\xspace}
\newcommand\fry{\ensuremath{\mathfrak{y}}\xspace}
\newcommand\frz{\ensuremath{\mathfrak{z}}\xspace}

\newcommand*{\swap}[2]{#2#1}

\let\le\leqslant
\let\leq\leqslant
\let\ge\geqslant
\let\geq\geqslant
\theoremstyle{plain}
\newtheorem{theorem}[thm]{Theorem}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem*{claim}{Claim}

\newenvironment{mproof}{\begin{proof}}{\qed\end{proof}}

\newcommand\adjustthmcounter[1]{
  \setcounterref{thm}{#1}
  \addtocounter{thm}{-1}}

\title[On Separation by LT and LTT]{On Separation by Locally Testable
  and Locally Threshold Testable Languages}

\author{Thomas~Place}
\address{LaBRI, Bordeaux University, France}
\email{firstname.lastname@labri.fr}  \thanks{Supported by the Agence Nationale de la Recherche ANR 2010 BLAN 0202 01 FREC}

\author{Lorijn~van Rooijen}


\author{Marc~Zeitoun}
\keywords{Automata, Logics, Monoids, Locally testable, Locally
  Threshold Testable, Separation,
    Context-free Language.}





\begin{document}

\begin{abstract}
  A separator for two languages is a third language containing the
  first one and disjoint from the second one. We investigate the
  following decision problem: given two regular input languages,
  decide whether there exists a locally testable (resp.\ a locally
  threshold testable) separator. In both cases, we design a decision
  procedure based on the occurrence of special patterns in automata
  accepting the input languages.  We prove that the problem is
  computationally harder than deciding membership. The correctness
  proof of the algorithm yields a stronger result, namely a
  description of a possible separator.  Finally, we discuss the same
  problem for context-free input~languages.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:intro}

\makeatletter{}\mypar{Context.} The strong connection between finite state devices
and descriptive formalisms, such as first-order or monadic
second-order logic, has been a guideline in computer science since the
seminal work of
B\"uchi~\cite{Buchi:Weak-Second-Order-Arithmetic-Finite:1960:a},
Elgot~\cite{Elgot:Decision-Problems-Finite-Automata:1961:a} and
Trakhtenbrot~\cite{Trakh61}.
This bridge has continuously
been fruitful, disseminating tools and bringing a number of
applications outside of its original research area. For instance,
compiling logical specifications into various forms of automata has
become one of the most successful methods in automatic program
verification~\cite{DBLP:conf/lics/VardiW86}.

One of the challenging issues when dealing with a logical formalism is to
precisely understand its expressiveness and its limitations. While
solutions to \emph{decide} such logics often use a compilation procedure from
formulas to automata, capturing the expressive power amounts to the
opposite translation: given a language, one wants to know whether one
can reconstruct a formula that describes it. In other words, we want
 to solve an instance of the \emph{membership problem}, which asks whether
an input language belongs to some given class.

For regular languages of finite words, the main tool developed to
capture this expressive power is the syntactic
monoid~\cite{pin:hal-00143946}: this is a finite, computable, algebraic
abstraction of the language, whose properties make it possible to
decide  membership. An emblematic example is the membership problem
for the class of first-order definable languages, solved by
Sch\"utzenberger~\cite{Schutzenberger:finite-monoids-having-only:1965:a}
and McNaughton and Papert~\cite{mcnaughton&papert:1971:counter}, which
has led to the development of algebraic methods for obtaining
decidable characterizations of logical
or combinatorial~properties.

\mypar{The separation problem and its motivations.} We consider here the
\emph{separation problem} as a generalization of the membership problem.
Assume we are given two classes of languages  and \Sep. The
question is, given \emph{two} input languages from , 
 whether we can separate them by a language from~\Sep. Here, we say
that a language \emph{separates}  from  if it contains  and
is disjoint from .  An obvious necessary condition for separability
is that the input languages  be disjoint. A separator language
\emph{witnesses} this condition.

\smallskip
One strong motivation for this problem is to understand the limits of
logics over finite words. Notice that membership reduces to separation
when \C is closed under complement, because checking that a language
belongs to \Sep amounts to testing that it is \Sep-separable from its
complement. Deciding \Sep-separation is also more difficult than
deciding membership in~\Sep, as one cannot rely on algebraic tools
tailored to the membership problem. It may also be computationally
harder, as we shall see in this paper. Thus, solving the separation
problem requires a deeper understanding of \Sep than what is
sufficient to check membership: one not only wants to decide whether
\Sep is powerful enough to \emph{describe} a language, but also to
decide whether it can \emph{discriminate} between two
input~languages. This discriminating power provides more accurate
information than the expressive power.

\mypar{Contributions.}  In general, elements of  cannot always be
separated by an element of~ and there is no minimal separator wrt.\  inclusion. We
are interested in the following~questions:
\begin{enumerate}[label=
L_1 \subseteq L \text{ and } L_2 \cap L = \varnothing.

L(\As,I,F) = \{w\in A^* \mid \exists q_I \in I, \exists q_F \in F,\  (q_I,w,q_F)\in \delta\}.
\lttclos{L}{k}{d}=\{w\in A^*\mid \exists u\in L\text{ such that }u\kdltteq
w\}.\ltclos{L}{k}=\{w\in A^*\mid \exists u\in L\text{ such that }u\klteq
w\}.
\label{eq:newdec}
\begin{array}{lll}
w_1 & = & \tilde u_0\tilde v_1\tilde u_1\tilde v_2 \cdots \tilde v_{n}\tilde u_n, \\
w_2 & = & \tilde x_0\tilde y_1\tilde x_1\tilde y_2 \cdots \tilde y_{m}\tilde x_m.
\end{array}

  \begin{array}{lll}
    w_1 & = & u^{}_0v_1^{\ell(d+1)}u^{}_1v_2^{\ell(d+1)} \cdots
    v_{n}^{\ell(d+1)}u^{}_n, \\
    w_2 & = & x^{}_0y_1^{\ell(d+1)}x^{}_1y_2^{\ell(d+1)} \cdots
    y_{m}^{\ell(d+1)}x^{}_m.
  \end{array}
  
\label{eq:newdec}
\begin{array}{lll}
w_1 & = & \tilde u_0\tilde v_1\tilde u_1\tilde v_2 \cdots \tilde v_{n}\tilde u_n, \\
w_2 & = & \tilde x_0\tilde y_1\tilde x_1\tilde y_2 \cdots \tilde y_{m}\tilde x_m.
\end{array}

  \Ps(\ell)\qquad
  \begin{aligned}
    &\text{If ,  are such that , then for all , if the number of}\-1ex]
    &\text{than , then there exist words  and  such that .}
  \end{aligned}

\begin{array}{lcl}
  L_1 & = & a_1\cdot(a_2a_3a_3)^*(a_4a_5a_5)^* \cdots (a_{2m-2}a_{2m-1}a_{2m-1})^*\cdot(a_{2m}a_{2m}a_{2m})^*,
  \\
  L_2 & = & (a_1a_2a_2)^*(a_3a_4a_4)^* \cdots (a_{2m-1}a_{2m}a_{2m})^*.
\end{array}

  \begin{array}{lcl}
    w_1 = a^{}_1(a_2a_3^2)^2 \cdots (a_{2m-2}^{}a_{2m-1}^2)^{2^{2m-3}} (a_{2m})^{3
      \times 2^{2m-1}} & \in & L_1, \\
    w_2 = (a^{}_1a_2^2)(a^{}_3a_4^2)^4 \cdots (a^{}_{2m-1}a_{2m}^2)^{2^{2m-2}}  & \in & L_2.
  \end{array}

\widetilde{Q} = \{(r,R)\ |\ r \in R \subseteq Q,\ R \text{ is
  synchronizable}, r \in Q\} \cup I_1 \cup F_1\cup I_2 \cup F_2.

  c^{}_1\#c_2^{R}\#c^{}_3\#c_4^R \cdots \#c^{}_{2k-1}\#c_{2k}^R \# \gamma^k
  
  c^{}_1\#c_2^{R}\#c^{}_3\#c_4^R \cdots \#c^{}_{2k-1}\#c_{2k}^R \# \gamma^{2k}
  
  \begin{array}{lcll}
    w & = & c^{}_1\#c_2^{R}\#c^{}_3\#c_4^R \cdots \#c^{}_{2k-1}\#c_{2k}^R\#
    & \text{(if ),} \
  By definition of , we have the following fact:

   \begin{fact} \label{fct:reduc} If  is both a prefix of some word
    in  and some word in , then  are
    the first  configurations of the run of  starting from the
    empty input. Moreover, if  and
    
  is a prefix of a word in , then  is configuration  in
  the run. Symmetrically, if  and
  
  is a prefix of a word in , then  is configuration  in
  the run.
\end{fact}

It remains to prove that this is indeed a reduction, \emph{i.e.}, that
 halts on the empty input if and only if  are \lt-separable, if
and only if  are \ltt-separable.
Assume first that  does not halt on empty input. This means that
the run of  is an infinite sequence of configurations
. By definition of , for all :
.8ex]
  c^{}_1\#c_2^{R}\#c^{}_3\#c_4^R \cdots \#c^{}_{2k-1}\#c_{2k}^R \# \gamma^{2k} &\in L_2.
\end{array}

  \begin{array}{l@{\;}ll}
    u=&c^{}_1 \# c_2^{R} \# c^{}_3 \# c_4^R \cdots \# c^{}_{i-1} \#
    c_{i}^R \#,&\text{or} \
  By definition , where  can be of the form
   with  or is the prefix of  or  for
  some configuration  of .

  Assume first that  with . By
  Fact~\ref{fct:reduc},  are the
  first  configurations of the run of  starting from the empty
  input. Since  halts in  steps, this means that  and
  that each configuration  is of length at most . It
  follows that  is of length at most . Therefore,
   is of length at most , in contradiction with the definition of .

  Assume finally that  is the prefix of  or  for some configuration  of
  . By Fact~\ref{fct:reduc},  is so that
   are the first 
  configurations of the run of  starting from the empty
  input. Since  halts in  steps, this means that 
  and that each configuration is of length at most . It
  follows that  is of length at most  which is
  again a contradiction.
\end{proof}

Let  be the language of words of  of length less than
. Similarly, let  be the set of prefixes of length
 of words in . Finally, set . By definition,  are finite languages, hence  is
clearly \lt (and therefore \ltt). It remains to prove that  is a
separator.

By definition, we have . Let us prove that . We proceed by contradiction: assume that there
exists . If , then the contradiction is
immediate because, by definition of ,  must be in of the form

Now, belonging to  would require twice as many letters  at the end
of the word. On the other hand, if , then, by definition of 
there exists some word of length  that is both a prefix
of a word in  and a prefix of a word in . This contradicts
Lemma~\ref{lem:reduc}.

We deduce that  are \lt-separable, and therefore also
\ltt-separable, which concludes the proof of
Theorem~\ref{thm:lttkdecidcf3}.
\end{proof}



















\section{Conclusion}
\label{sec:conc}
\makeatletter{}We have shown separation theorems for both \lt and \ltt. In both cases,
we provide a decision procedure to test separability,
running in {\sc co-Nexptime} and {\sc 2-Expspace}
respectively. Another contribution is a description of possible
separators, given by bounds defining them.

Several questions remain open in this line of research. A first one is
to obtain tight complexity bounds for both classes. While we have {\sc
  co-Nexptime} and {\sc 2-Expspace} upper bounds for \lt and \ltt
respectively, we have only {\sc co-NP} lower bounds.  The upper bounds
rely on a reduction to the case , \emph{i.e.}, a translation to
the special case when the size of infixes is fixed to . This translation is exponential wrt.\
the size of the input automata. Improving the upper bounds would likely require improving
this reduction.

Another question is to generalize our techniques to other settings, and to
obtain transfer results. First, one can consider other fragments for
separability.  For instance, if separation is decidable for some fragment of
first-order logic, is it still decidable when adding some predicate to the
logic, such as the successor? In the present paper, this is what we do for the
specific case of \ltt, whose corresponding logic, \fos, is obtained by adding the successor to
first-order logic with only equality on positions and alphabetic
predicates. Another natural example is adding modulo predicates, which would
allow to treat \lttm for instance, the generalization of \ltt in which infixes
can now also be counted modulo constants. Generalizing our results to more
complex structures such as trees would also be interesting. However, in the
setting of trees, while decidable characterizations are known for both \lt and
\ltt~\cite{bsltt,pslt}, no delay theorem is known. This makes separation a
challenging problem as our techniques rely on a generalization of this
theorem.








\mypar{Acknowledgement.} We thank the referees for their careful reading and
helpful suggestions.

\bibliographystyle{abbrv}\begin{thebibliography}{10}

\bibitem{Almeida:SomeAlg:99}
J.~Almeida.
\newblock Some algorithmic problems for pseudovarieties.
\newblock {\em Publ. Math. Debrecen}, 54(suppl.):531--552, 1999.
\newblock Automata and formal languages, VIII (Salg{\'o}tarj{\'a}n, 1996).

\bibitem{Beauquier&Pin:Languages-scanners:1991:a}
D.~Beauquier and J.~E. Pin.
\newblock Languages and scanners.
\newblock {\em Theoret. Comput. Sci.}, 84(1):3--21, 1991.

\bibitem{bsltt}
M.~Benedikt and L.~Segoufin.
\newblock {Regular Languages Definable in {FO} and {FOmod}}.
\newblock {\em ACM Transactions of Computational Logic}, 11(1), 2009.

\bibitem{bojLTT}
M.~Boja{\'n}czyk.
\newblock A new algorithm for testing if a regular language is locally
  threshold testable.
\newblock {\em Inf. Process. Lett.}, 104(3):91--94, 2007.

\bibitem{BoroshTreybig:76}
I.~Borosh and L.~B. Treybig.
\newblock Bounds on positive integral solutions of linear {Diophantine}
  equations.
\newblock {\em Proc. Amer. Math. Soc.}, 55(2):299--304, 1976.

\bibitem{Brzozowski&Simon:Characterizations-locally-testable-events:1973:a}
J.~Brzozowski and I.~Simon.
\newblock Characterizations of locally testable events.
\newblock {\em Discrete Mathematics}, 4(3):243--271, 1973.

\bibitem{Buchi:Weak-Second-Order-Arithmetic-Finite:1960:a}
J.~R. B{\"u}chi.
\newblock Weak second-order arithmetic and finite automata.
\newblock {\em Mathematical Logic Quarterly}, 6(1-6):66--92, 1960.

\bibitem{Chen09:learning}
Y.-F. Chen, A.~Farzan, E.~M. Clarke, Y.-K. Tsay, and B.-Y. Wang.
\newblock Learning minimal separating {DFA}'s for compositional verification.
\newblock In {\em {TACAS'09}}, volume 5505 of {\em Lect. Notes Comp. Sci.},
  pages 31--45. Springer, 2009.

\bibitem{Choffrut2007274}
C.~Choffrut, F.~D'Alessandro, and S.~Varricchio.
\newblock On the separability of sparse context-free languages and of bounded
  rational relations.
\newblock {\em Theoret. Comput. Sci.}, 381(1-3):274--279, 2007.

\bibitem{Choffrut200627}
C.~Choffrut and S.~Grigorieff.
\newblock Separability of rational relations in {} by
  recognizable relations is decidable.
\newblock {\em Inf. Process. Lett.}, 99(1):27--32, 2006.

\bibitem{Costa:Free-profinite-locally-idempotent:2001:a}
J.~C. Costa.
\newblock Free profinite locally idempotent and locally commutative semigroups.
\newblock {\em J. Pure Appl. Algebra}, 163(1):19--47, 2001.

\bibitem{Costa&Nogueira:Complete-reducibility-pseudovariety:2009:a}
J.~C. Costa and C.~Nogueira.
\newblock Complete reducibility of the pseudovariety {LSl}.
\newblock {\em Internat. J. Algebra Comput.}, 19(02):247--282, 2009.

\bibitem{martens}
W.~Czerwinski, W.~Martens, and T.~Masopust.
\newblock Efficient separability of regular languages by subsequences and
  suffixes.
\newblock In {\em Proc. of ICALP'13}, volume 7966 of {\em Lect. Notes Comp.
  Sci.}, pages 150--161. Springer, 2013.

\bibitem{Elgot:Decision-Problems-Finite-Automata:1961:a}
C.~C. Elgot.
\newblock Decision problems of finite automata design and related arithmetics.
\newblock {\em Trans. Amer. Math. Soc.}, 98(1):21--51, 1961.

\bibitem{Ginsburg&Spanier:Semigroups-Presburger-Formulas-Languages:1966:a}
S.~Ginsburg and E.~H. Spanier.
\newblock Semigroups, {P}resburger formulas and languages.
\newblock {\em Pacific Journal of Mathematics}, 16(2):285--296, 1966.

\bibitem{Gupta08:autom}
A.~Gupta, K.~McMillan, and Z.~Fu.
\newblock Automated assumption generation for compositional verification.
\newblock {\em Formal Methods in System Design}, 32(3):285--301, 2008.

\bibitem{Henckell:1988}
K.~Henckell.
\newblock Pointlike sets: the finest aperiodic cover of a finite semigroup.
\newblock {\em J. Pure Appl. Algebra}, 55(1-2):85--126, 1988.

\bibitem{Henzinger&Jhala&Majumdar&McMillan:Abstractions-from-proofs:2004:a}
T.~A. Henzinger, R.~Jhala, R.~Majumdar, and K.~L. {McMillan}.
\newblock Abstractions from proofs.
\newblock In {\em Proc. of POPL'04}, pages 232--244. {ACM}, 2004.

\bibitem{Hunt:1982:DGP:322307.322317}
H.~B. Hunt, III.
\newblock Decidability of grammar problems.
\newblock {\em J. ACM}, 29(2):429--447, 1982.

\bibitem{Kim&McNaughton&McCloskey:polynomial-time-algorithm-local:1989:a}
S.~Kim, R.~{McNaughton}, and R.~{McCloskey}.
\newblock A polynomial time algorithm for the local testability problem of
  deterministic finite automata.
\newblock In {\em Algorithms and Data Structures}, number 382 in Lect. Notes
  Comp. Sci., pages 420--436. Springer, 1989.

\bibitem{LEROUX-TURING100}
J.~Leroux.
\newblock Vector addition systems reachability problem (a simpler solution).
\newblock In {\em The Alan Turing Centenary Conference, Turing-100}, volume~10,
  pages 214--228, 2012.

\bibitem{Leucker:2006}
M.~Leucker.
\newblock Learning meets verification.
\newblock In {\em Proc. of FMCO'06}, pages 127--151. Springer, 2007.

\bibitem{DBLP:journals/siamcomp/Mayr84}
E.~W. Mayr.
\newblock An algorithm for the general {P}etri net reachability problem.
\newblock {\em SIAM J. Comput.}, 13(3):441--460, 1984.

\bibitem{McMillan:Applications-Craig-Interpolants-Model:2005:a}
K.~L. {McMillan}.
\newblock Applications of {C}raig interpolants in model checking.
\newblock In {\em Proc. of TACAS'05}, pages 1--12. Springer, 2005.

\bibitem{McNaughton:Algebraic-decision-procedures-local:1974:a}
R.~{McNaughton}.
\newblock Algebraic decision procedures for local testability.
\newblock {\em Math. Systems Theory}, 8(1):60--76, 1974.

\bibitem{mcnaughton&papert:1971:counter}
R.~McNaughton and S.~Papert.
\newblock {\em Counter-free automata}.
\newblock The M.I.T. Press, 1971.

\bibitem{Parikh:Context-Free-Languages:1966:a}
R.~J. Parikh.
\newblock On context-free languages.
\newblock {\em J. {ACM}}, 13(4):570--581, 1966.

\bibitem{Pin:expressive-power-existential-first:1996:a}
J.-E. Pin.
\newblock The expressive power of existential first order sentences of
  {B}{\"u}chi's sequential calculus.
\newblock In {\em Proc. of ICALP'96}, number 1099 in Lect. Notes Comp. Sci.,
  pages 300--311. Springer, 1996.

\bibitem{pin:hal-00143946}
J.~E. Pin.
\newblock Syntactic semigroups.
\newblock In {\em {Handbook of language theory, Vol. I}}, pages 679--746.
  Springer, 1997.

\bibitem{Pin:Expressive-power-existential-first-order:2005:a}
J.~E. Pin.
\newblock Expressive power of existential first-order sentences of
  {{B}}{\"u}chi's sequential calculus.
\newblock {\em Discrete Math.}, 291(1--3):155--174, 2005.

\bibitem{pslt}
T.~Place and L.~Segoufin.
\newblock A decidable characterization of locally testable tree languages.
\newblock {\em Logical Methods in Computer Science}, 7(4), 2011.

\bibitem{PvRZ:mfcs}
T.~Place, L.~{van Rooijen}, and M.~Zeitoun.
\newblock Separating regular languages by piecewise testable and unambiguous
  languages.
\newblock In {\em Proc. of MFCS'13}, number 8087 in Lect. Notes Comp. Sci.,
  pages 729--740. Springer, 2013.

\bibitem{PZ:icalp14}
T.~Place and M.~Zeitoun.
\newblock Going higher in the first-order quantifier alternation hierarchy on
  words.
\newblock In {\em {ICALP'14}}, 2014.

\bibitem{PZ:lics14}
T.~Place and M.~Zeitoun.
\newblock Separating regular languages with first-order logic.
\newblock In {\em {CSL-LICS'14}}, 2014.

\bibitem{ReddyLoveland:1978}
C.~R. Reddy and D.~W. Loveland.
\newblock Presburger arithmetic with bounded quantifier alternation.
\newblock In {\em STOC'78}, pages 320--325. ACM, 1978.

\bibitem{Schutzenberger:finite-monoids-having-only:1965:a}
M.~P. Sch{\"u}tzenberger.
\newblock On finite monoids having only trivial subgroups.
\newblock {\em Information and Control}, 8(2):190--194, 1965.

\bibitem{SeidlSMH04}
H.~Seidl, T.~Schwentick, A.~Muscholl, and P.~Habermehl.
\newblock Counting in trees for free.
\newblock In {\em ICALP'04}, volume 3142 of {\em Lect. Notes Comp. Sci.}, pages
  1136--1149. Springer, 2004.

\bibitem{Steinberg:98}
B.~Steinberg.
\newblock On pointlike sets and joins of pseudovarieties.
\newblock {\em Internat. J. Algebra Comput.}, 8(2):203--231, 1998.

\bibitem{Steinberg:01}
B.~Steinberg.
\newblock A delay theorem for pointlikes.
\newblock {\em Sem. Forum}, 63(3):281--304, 2001.

\bibitem{Straubing:Finite-semigroup-varieties-form:1985:a}
H.~Straubing.
\newblock Finite semigroup varieties of the form {}.
\newblock {\em J. Pure Appl. Algebra}, 36({C}):53--94, 1985.

\bibitem{szygram}
T.~G. Szymanski and J.~H. Williams.
\newblock Noncanonical extensions of bottom-up parsing techniques.
\newblock {\em SIAM J. Comput.}, 5(2):231--250, 1976.

\bibitem{Therien&Weiss:Graph-congruences-wreath-products:1985:a}
D.~Th{\'e}rien and A.~Weiss.
\newblock Graph congruences and wreath products.
\newblock {\em J. Pure Appl. Algebra}, 36:205--215, 1985.

\bibitem{Thomas:Classifying-regular-events-symbolic:1982:a}
W.~Thomas.
\newblock Classifying regular events in symbolic logic.
\newblock {\em J.~Comput. Syst. Sci.}, 25(3):360--376, 1982.

\bibitem{Trahtman:Algorithm-Verify-Local-Threshold:2001:a}
A.~N. Trahtman.
\newblock An algorithm to verify local threshold testability of deterministic
  finite automata.
\newblock In {\em Automata Implementation}, number 2214 in Lect. Notes Comp.
  Sci., pages 164--173. Springer, 2001.

\bibitem{Trakh61}
B.~A. Trakhtenbrot.
\newblock Finite automata and logic of monadic predicates.
\newblock {\em Doklady Akademii Nauk SSSR}, 149:326--329, 1961.
\newblock In Russian.

\bibitem{DBLP:conf/lics/VardiW86}
M.~Y. Vardi and P.~Wolper.
\newblock An automata-theoretic approach to automatic program verification.
\newblock In {\em Proc. of LICS'86}, pages 332--344. IEEE Computer Society,
  1986.

\bibitem{VSS05}
K.~N. Verma, H.~Seidl, and T.~Schwentick.
\newblock On the complexity of equational {H}orn clauses.
\newblock In {\em Proc. of CADE'05}, volume 3632 of {\em Lect. Notes Comp.
  Sci.}, pages 337--352, 2005.

\bibitem{gathen78}
J.~von~zur Gathen and M.~Sieveking.
\newblock A bound on solutions of linear integer equalities and inequalities.
\newblock {\em Proc. Amer. Math. Soc.}, 72:155--158, 1978.

\bibitem{Zalcstein:Locally-testable-languages:1972:a}
Y.~Zalcstein.
\newblock Locally testable languages.
\newblock {\em J.~Comput. Syst. Sci.}, 6(2):151--167, 1972.

\end{thebibliography}





\end{document}
