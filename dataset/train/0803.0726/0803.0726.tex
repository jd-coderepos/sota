\documentclass[11pt,a4paper]{article}
\usepackage{xspace}
\usepackage{vaucanson-g}
\usepackage{amsmath,amssymb,amsthm,amscd,mathrsfs}
\usepackage{clrscode} 

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}{Example}


\def\ldots{\mathinner{\ldotp\ldotp}}       \newcommand{\im}{\operatorname{Im}}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\card}{\operatorname{card}}
\newcommand{\size}{\operatorname{size}}
\newcommand{\Sect}{\operatorname{Sect}}

\def\mark#1{\textbf{#1}}
\def\N{\mathbb{N}} 
\def\Z{\mathbb{Z}}
\def\A{\mathcal{A}}
\def\B{\mathcal{B}} 
\def\C{\mathscr{C}} 
\def\R{{R}}
\def\U{\mathcal{U}} 
\def\V{\mathcal{V}} 
\def\T{{T}}
\def\X{\mathsf{X}}

\DeclareMathOperator{\cluster}{\textit{cluster}}
\DeclareMathOperator{\Root}{\textit{root}}
\DeclareMathOperator{\level}{\textit{level}}
\DeclareMathOperator{\cycle}{\textit{cycle}}
\DeclareMathOperator{\num}{\textit{num}}
\DeclareMathOperator{\height}{\text{height}}
\def\Pgoth{{\mathfrak P}}
\newcommand{\edge}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\ie}{{\itshape i.e.}\xspace }
\newcommand{\eg}{{\itshape e.g.}\xspace }
\newcommand{\etal}{{\itshape et al.}\xspace }
\newcommand{\resp}{{resp.}\xspace }
\ChgStateLineWidth{0.5}
\ChgEdgeLineWidth{0.5}
\FixVCScale{0.4}






\title{A quadratic algorithm for road coloring}
\author{Marie-Pierre B{\'e}al and Dominique Perrin
  \thanks{Universit\'e Paris-Est, Laboratoire d'informatique
    Gaspard-Monge CNRS UMR 8049, 5 boulevard Descartes, 77454
    Marne-la-Vall\'ee, France,
    \{beal,perrin\}@univ-mlv.fr}
    \thanks{This work is supported by
    French National Agency (ANR) through "Programme d'Investissements
    d'Avenir" (Project ACRONYME ANR-10-LABX-58).}  }


\PlainState
\begin{document}
\maketitle


\begin{abstract}
  The Road Coloring Theorem states that every aperiodic directed graph
  with constant out-degree has a synchronized coloring. This theorem
  had been conjectured during many years as the Road Coloring Problem
  before being settled by A. Trahtman. Trahtman's proof leads to an
  algorithm that finds a synchronized labeling with a cubic worst-case
  time complexity.  We show a variant of his construction with a
  worst-case complexity which is quadratic in time and linear in
  space. We also extend the Road Coloring Theorem to the periodic
  case.
\end{abstract}
\section{Introduction}

Imagine a map with roads which are colored in such a way that a fixed
sequence of colors, called a homing sequence, leads the traveler to a
fixed place whatever the starting point is.  Such a coloring of the
roads is called synchronized and finding a synchronized coloring is
called the Road Coloring Problem. In terms of graphs, it consists in
finding a synchronized labeling in a directed graph.

The Road Coloring Theorem states that every aperiodic directed graph
with constant out-degree has a synchronized coloring (a graph is
aperiodic if it is strongly connected and the gcd of the length of the
cycles is equal to 1).  It has been conjectured under the name of the
Road Coloring Problem by Adler, Goodwin, and Weiss
\cite{AdlerGoodwynWeiss77}, and solved for many particular types of
automata (see for instance~\cite{AdlerGoodwynWeiss77},
\cite{OBrien81}, \cite{Carbone01}, \cite{Kari03}, \cite{Friedman90},
\cite{PerrinSchutzenberger92}). Trahtman settled the conjecture
in~\cite{Trahtman09}. In this paper, by Road Coloring Problem we
understand the algorithmic problem of finding a synchronized coloring
on a given graph (and not the existence of a polynomial algorithm
which is solved by the Road Coloring Theorem).


Solving the Road Coloring problem in each particular case is not only
a puzzle but has many applications in various areas like coding or
design of computational systems.  These systems are often modeled by
finite-state automata (\ie graphs with labels).  Due to some noise,
the system may take a wrong transition.  This noise may for instance
result from the physical properties of sensors, from unreliability of
computational hardware, or from insufficient speed of the computer
with respect to the arrival rate of input symbols.  It turns out that
the asymptotic behavior of synchronized automata is better than the
behavior of unsynchronized ones (see~\cite{DelyonMaler94}).
Synchronized automata are thus less sensitive to the effect of noise.

In the domain of coding, automata with outputs (\ie transducers) can
be used either as encoders or as decoders. When they are synchronized,
the behavior of the coder (or of the decoder) is improved in the
presence of noise or errors (see \cite{BerstelPerrinReutenauer2010},
\cite{Jurgensen2008}). For instance, the well-known Huffman
compression scheme leads to a synchronized decoder provided the
lengths of the codewords of the Huffman code are relatively prime.  It
is also a consequence of the Road Coloring Theorem that coding schemes
for constrained channels can have sliding block decoders and
synchronized encoders (see \cite{AdlerCoppersmithHassner83} and
\cite{LindMarcus95}).
 
Trahtman's proof is constructive and leads to an algorithm that finds
a synchronized labeling with a cubic worst-case time
complexity~\cite{Trahtman09,Trahtman2011}. The algorithm consists in
a sequence of flips of edges going out of some state so that the
resulting automaton is synchronized. One first searches a sequence of
flips leading to an automaton which has a so-called stable pair of
states (\ie with good synchronizing properties). One then
computes the quotient of the automaton by the congruence generated by
the stable pairs. The process is then iterated on this smaller
automaton. Trahtman's method for finding the sequence of flips leading
to a stable pair has a worst-case quadratic time complexity, which
makes his algorithm cubic.

In this paper, we design a worst-case linear time algorithm for
finding a sequence of flips until the automaton has a stable pair.
This makes the algorithm for computing a synchronized coloring
quadratic in time and linear in space.  The sequence of flips is
obtained by fixing a color, say red, and by considering the red cycles
formed with red edges, taking into account the positions of the roots
of red trees attached to each cycle. The prize to pay for decreasing
the time complexity is some more complication in the choice of the
flips. We also extend the Road Coloring Theorem to periodic graphs by
showing that Trahtman's algorithms provides a minimal-rank coloring.
Another proof of this result using semigroup tools, obtained
independently, is given in \cite{BudzbanFeinsilver11}. For related
results, see also \cite{Trahtman2010} and \cite{JonoskaKarl1999}.

The complexity of synchronization problems on automata has been
already studied (see \cite{KariVolkov2013} for a survey). It is
well-known that there is an  algorithm to test whether an
-state automaton on a fixed-size alphabet is synchronized. The
complexity of computing a specific synchronizing word is  (see
\cite{Eppstein1990}).  However, the complexity of finding a
synchronizing word of a given length is NP-complete
\cite{Eppstein1990} (see also \cite{OlschewskiUmmels2010},
\cite{Roman2011}). The complexity of problems on automata has also
been studied for random automata (see
\cite{CarayolNicaud2012}). Several results prove that, under
appropriate hypotheses, a random irreducible automaton is synchronized
\cite{FreilingEtAl2003}, \cite{SkvortsovZaks2010}, and
\cite{Nicaud2013}. The average time complexity of these problems does not
seem to be known. In particular, we do not know the average time
complexity of the Road Coloring Problem.


The article is organized as follows. In Section~\ref{section.road}, we
give some definitions to formulate the problem in terms of finite
automata instead of graphs. In Section~\ref{section.algo} we describe
Trahtman's algorithm and our variant is detailed in
Section~\ref{section.algo2}. We give both an informal description of
the algorithm with pictures illustrating the constructions, and a
pseudocode. The time and space complexity of the algorithm are
analyzed in Section~\ref{section.complexity}. The periodic case is
treated in Section~\ref{section.periodic}. A preliminary version of this paper was posted in \cite{BealPerrin2008}.

\section{The Road Coloring Theorem} \label{section.road} 

In order to formulate the \emph{Road Coloring Problem} we introduce
the notation concerning automata.  

Let  be a finite alphabet and let  be a finite set.  We denote
by  the set of words over . 

A (finite) \emph{automaton}  over the alphabet  with 
as set of states is a given by a set  of edges which are triples
 where  are states and  is a symbol from  called
the label of the edge. Note that no initial or final states are
specified.  Let  be the multiset formed of the pairs 
obtained from the set  by the map .  The
multigraph having  as set of vertices and  as set of edges is
called the \emph{underlying graph} of .

A \emph{path} in the automaton is sequence of consecutive edges. The
label of the path  is the word . The state  is its origin and  is its end.
The \emph{length} of the path is . The path is a \emph{cycle} if .

An automaton is \emph{deterministic} if, for each state  and each
letter , there is at most one edge starting at  and labeled with
.  It is \emph{complete deterministic} if, for each state  and
each letter , there is exactly one edge starting at  and
labeled with .  This implies that for each state  and each word
 there is exactly one path starting at  and labeled with .
The end of this unique path is denoted by .

An automaton is \emph{irreducible} if its underlying graph is strongly
connected. The \emph{period} of an automaton is the gcd of length of
its cycles. An automaton is \emph{aperiodic} if it is
irreducible and of period \footnote{Note that this notion, which is
  usual for graphs, is not the notion of aperiodic automata used
  elsewhere and which refers to the period of words labeling the
  cycles (see \eg \cite{Eilenberg76B}).}.

A \emph{synchronizing word} of a complete deterministic automaton
 is a word  such that for every pair of states
, one has .  A synchronizing word is
also called a \emph{reset sequence} \cite{Eppstein1990}, or a
\emph{magic sequence} \cite{BoyleMass2000,BoyleMass2004}, or also a
\emph{homing word} \cite{PomeranzReddy1994}. An automaton which has a
synchronizing word is called \emph{synchronized} (see an example on
the right part of Fig.~\ref{figure.automate1}).

Two automata which have isomorphic underlying graphs are called
\emph{equivalent}. Hence two equivalent automata differ only by the
labeling of their edges. In the sequel, we shall consider only complete
deterministic automata.

\begin{proposition} A synchronized complete deterministic automaton is aperiodic.
\end{proposition}
\begin{proof}
We assume that the automaton has at least one edge.  Let  be
an edge of the automaton.  Let  be a synchronizing word focusing to
a state .  Since the graph is strongly connected, there is a word
 such that from . Thus .  The lengths of the cycles from  to  labeled  and
 differ by .  This implies that the period of automaton is .
\end{proof}

The \emph{Road Coloring Theorem} can be stated as follows.

\begin{theorem}[A. Trahtman~\cite{Trahtman09}] \label{theorem.road}
Any aperiodic complete deterministic automaton is equivalent to a synchronized one.
\end{theorem}

\begin{figure}[htbp]
    \centering
\FixVCScale{0.5}
\VCDraw{\begin{VCPicture}{(0,-1)(12,2)}
\MediumState
\State[1]{(0,2)}{1}
\State[2]{(3,2)}{2}
\State[3]{(0,0)}{3}
\State[4]{(3,0)}{4}
\ChgEdgeLineColor{blue}
\ChgEdgeLineStyle{dashed}
\LoopW{1}{}
\LoopE{2}{}
\LoopW{3}{}
\LoopE{4}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineStyle{solid}
\ChgEdgeLineColor{red}
\ArcL[.5]{1}{2}{}
\ArcL[.5]{2}{4}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{3}{1}{}
\VCPut{(7,0)}{
\MediumState
\State[1]{(0,2)}{1}
\State[2]{(3,2)}{2}
\State[3]{(0,0)}{3}
\State[4]{(3,0)}{4}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\LoopW{3}{}
\ArcL[.5]{1}{2}{}
\ArcL[.5]{2}{4}{}
\ArcL[.5]{4}{3}{}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ChgEdgeLineColor{blue}
\LoopW{1}{}
\LoopE{2}{}
\LoopE{4}{}
\ArcL[.5]{3}{1}{}
}
\end{VCPicture}}
        \caption{Two complete aperiodic deterministic automata
          over the alphabet . A thick red plain edge is an edge labeled by
           while a thin blue dashed edge is an edge labeled by
          . The automaton on the left is not synchronized.  The one
          on the right is synchronized. For instance, the word 
          is a synchronizing word. The two automata are equivalent
          since their underlying graph are isomorphic.}\label{figure.automate1}
\end{figure}

A trivial case for solving the Road Coloring Theorem is the case where
the automaton has a loop edge around some state 
\cite{OBrien81}. Indeed, since the graph of the automaton is strongly
connected, there is a spanning tree rooted at~ (with the edges of
the tree oriented towards the root). Let us label the edges of this
tree and the loop by the letter . This coloring is synchronized by
the word , where  is the number of states.

\section{An algorithm for finding a synchronized coloring} \label{section.algo}

Trahtman's proof of Theorem~\ref{theorem.road} is constructive and
gives an algorithm for finding a labeling (also called a coloring) which
makes the automaton synchronized provided it is aperiodic.

In the sequel  denotes an -state complete deterministic
automaton over an alphabet . We fix a particular letter .
Edges labeled by  are also called \emph{red edges} or
-\emph{edges}. The other ones are called \emph{blue} or
-\emph{edges}.


A pair  of states in an automaton is \emph{synchronizable} if
there is a word  with .  It is well-known
that an automaton is synchronized if all its pairs of states are
synchronizable (see for instance Proposition~3.6.5 in
\cite{BerstelPerrinReutenauer2010}). 

A pair  of states in an automaton is \emph{stable} if and only
if, for any word , the pair  is
synchronizable. This notion was introduced in \cite{CulikEtAl1999}.
In a synchronized automaton, any pair of states is stable.  Note that
if  is a stable pair, then for any word ,  is also a stable pair, hence the terminology. Note also that
if  and  are stable pairs then  is also a stable
pair. It follows that the relation defined on the set of states by  if  is a stable pair is an equivalence relation. As
observed in \cite[Lemma~2]{Kari03}, this relation is a congruence (\ie
 whenever ) called \emph{the
  stable pair congruence}.  More generally, a congruence is
\emph{stable} if any pair of states in the same class is stable. The
congruence \emph{generated} by a stable pair  is the least
congruence such that  and  belong to the same class. It is a
stable congruence. Given a congruence on the states of an automaton,
we denote by  the class of a state .


If  is an automaton, the \emph{quotient} of  by a stable
pair congruence is the automaton  whose states are the classes of
 under the congruence. The edges of  are the triples
 where  is an edge of .  The
automaton  is complete deterministic when  is complete
deterministic. The automaton  is irreducible (\resp aperiodic)
when  is irreducible (\resp aperiodic).

The following Lemma was obtained by Culik \etal \cite{CulikEtAl02}.
We reproduce the proof since it helps understanding Trahtman's algorithm
(see the procedure \textsc{FindSynchronizedColoring} below).

\begin{lemma}[Culik \etal \cite{CulikEtAl02}] \label{lemma.lift} If
  the quotient of an automaton  by a stable pair congruence
  is equivalent to a synchronized automaton, then there is a
  synchronized automaton equivalent to .
\end{lemma}

\begin{proof}
  Let  be the quotient of  by a stable congruence and let
   be a synchronized automaton equivalent to .  We define an
  automaton  equivalent to  as follows. The number of edges
  of  going out of  and ending in states belonging to a same
  class  is equal to the number of edges of  (and thus
  ) going out of  and ending in . We define
   by labeling these edges according to the labeling of
  corresponding edges in . The automaton  is a quotient
  of~.
 


  Let us show that  is synchronized. Let  be a synchronizing
  word of  and  the state ending any path labeled by  in
  . Let  be two states of .  Then  and  belong to the same congruence class. Hence  is a stable pair of . Therefore  is a
  synchronizable pair of . Since all pairs of  are
  synchronizable,  is synchronized.
\end{proof}

Trahtman's algorithm for finding a synchronized coloring of an
aperiodic automaton  consists in finding an equivalent automaton
 of  which has at least one stable pair , then in
recursively finding a synchronized coloring  for the quotient
automaton  by the congruence generated by , and finally in
lifting up this coloring to the initial automaton as follows. If there
is an edge  in  but no edge 
in , then there is an edge  in  with
. Then we flip the labels of the two edges labeled 
and  going out of  in .

The algorithm for finding a synchronized coloring is described in the
following pseudocode.  The procedure \textsc{FindStablePair}, which
finds an equivalent automaton which has a stable pair of states, is
described in the next section. The procedure \textsc{Merge} computes
the quotient of an automaton by the stable congruence generated by a
stable pair of states.  The procedure \textsc{Update} updates some
data needed for the computation as described in
Section~\ref{section.update}.

\begin{small}
\begin{codebox}
\Procname{} 
\li  
\li  \While (size() ) 
\li      \Do \proc{Update()}
\li        \proc{FindStablePair()}
\li       lift the coloring up from  to the automaton  
\li        \proc{Merge}
  \End
\li \Return  
\end{codebox}
\end{small}




The termination of the algorithm is guaranteed by the fact that the
number of states of the quotient automaton of  is strictly less
than the number of states of . The computation of the quotient
automaton (performed by the Procedure \textsc{Merge}) is described in
Section~\ref{section.pseudocode}.


\section{Finding a stable pair} \label{section.algo2}

In this section, we consider an aperiodic complete deterministic
automaton  over the alphabet . We design a linear-time
algorithm for finding an equivalent automaton which has a stable pair.

In order to describe the algorithm, we give some definitions and
notation.

Let  be the subgraph of the graph of  made of the red edges.
The graph  is a disjoint union of connected components called
\emph{clusters}. Since each state has exactly one outgoing edge in
, each cluster contains a unique (red) cycle with trees attached to the
cycle at their roots. If  is the root of such a tree, its
\emph{children} are the states  such that  is not on the a red
cycle and  is an edge. If  belong to the same tree,  is
an \emph{ancestor} of  (or  is a \emph{descendant} of ) in
the tree if there is a red path from  to . Note that in these trees,
the edges are oriented from the child to the parents and the paths from
the descendant to the ancestors.

If  belongs to some red cycle of length greater than , its
\emph{predecessor} is the unique state  belonging to the same cycle
such that  is an edge. In the case the length of the cycle
is , we set that the predecessor is  itself.

For each state  belonging to some cluster, we define the \emph{level} of 
as the distance between  and the root of the tree containing
. If  belongs to the cycle of the cluster, its level is thus null.
The \emph{level of an automaton} is the maximal level of its states.
A \emph{maximal state} is a state of maximal level.  
A \emph{maximal tree} is a tree containing at least one maximal state and rooted at
a state of level . 
 A \emph{maximal root} is the root of a maximal
tree and a \emph{maximal child} of a maximal root  is a child of  having at least one maximal state as descendant.





The algorithm for finding a coloring which has a stable pair relies on
the following key lemma due to Trahtman~\cite{Trahtman09}. It uses the
notion of minimal images in an automaton.  An \emph{image} in an
automaton  is a set of states , where  is
a word and .  A \emph{minimal
  image} in an automaton is an image which does not properly contain
another image. In an irreducible automaton two minimal images have
the same cardinality which is called the \emph{minimal rank} of~.
Also, if  is a minimal image and  is a word, then  is
again a minimal image and the map  is
one-to-one from  onto .

Note that the hypotheses in the statement below depend on the choice
of the letter  defining the red edges.
\begin{lemma}[Trahtman~\cite{Trahtman09}] \label{lemma.sameTree} Let
   be an irreducible complete deterministic automaton with a
  positive level.  If all maximal states in  belong to the same
  tree, then  has a stable pair.
\end{lemma}

\begin{proof}
Since  is irreducible, there is a minimal image  containing a
  maximal state . Let  the level of  (\ie the distance
  between  and the root  of the unique maximal tree). Let us assume
  that there is a state  in  of level .  Then the
  cardinal of  is strictly less than the cardinal of
  , which contradicts the minimality of . Thus all states but
   in  have level strictly less than~.

  Let  be a common multiple of the lengths of all red cycles. Let
   be the red cycle containing . Let  be the predecessor
  of  in  and  the child of  containing  in its
  subtree. Since , we have .  Let  and .  Since the level of all states of
   but  is less than or equal to , the set  is equal
  to , where  is a set of states belonging to the
  red cycles.  Since for any state  in a red cycle, , we get .
 
  Let  be a word such that  is a minimal image. For any
  word , the minimal images  and  have the
  same cardinal equal to the cardinal of .  We claim that the set
   is a minimal image. Indeed, , hence all three
  are equal. But .  This forces  since
  the cardinality of  cannot be less than the cardinality
  of . As a consequence  is
  synchronizable and thus  is a stable pair.
\end{proof}

In the sequel, we call Condition~ the assumption of
Lemma \ref{lemma.sameTree}: \emph{all maximal states belong to the same
  tree}.  



In the subsections below, we describe sequences of flips of edges
that make the resulting equivalent automaton satisfy Condition 
and hence have a stable pair. We consider several cases corresponding
to the geometry of the automaton. 


\subsection{The case of null maximal level}

In this section, we assume that the level of the automaton is . The subgraph  of red edges is a disjoint union of cycles.  

A set of edges going out of a state  is called a \emph{bunch} if
these edges all end in a same state . Note that if a state  has
two incoming bunches from two states , then  is a
stable pair.

If the set of outgoing edges of each state is a bunch, then there is
only one red cycle, and the automaton is not aperiodic unless the
trivial case where the length of this cycle is . We can thus assume
that there is a state  whose set of outgoing edges is not a
bunch. There exists  and  such that  and
 are edges. We flip these two edges. This gives an automaton 
which satisfies Condition~.  Let  be the state which is the
predecessor of  in its red cycle.  It follows from the proof of
Lemma~\ref{lemma.sameTree} that the pair  is a stable pair.

This case is described in the pseudocode \textsc{LevelZeroFlipEdges}
where \textsc{GetPredecessor} returns the predecessor of  on its red cycle.  The function \textsc{LevelZero\-FlipEdges}
returns an automaton equivalent to  together with a stable pair.

\begin{small} 
\begin{codebox}
\Procname{)}
\li    \For each state   on a red cycle      
\li        \Do \If the set of outgoing edges of  is not a bunch
\li                \Then  let  and  be edges with  and 
\li                       \proc{Flip}
\li                        \proc{GetPredecessor}
\li                      \Return , 
               \End
       \End 
\li    \Return \proc{Error}( is not aperiodic)  
\end{codebox}
\end{small}

The procedure \textsc{Flip}
exchanges the labels of two edges . It also performs the corresponding update of data as explained in Section~\ref{section.update}. 

\subsection{The case of non-null maximal level}

In this section, we assume that the level of the automaton is .

\subsubsection{Main treatment}








We describe a sequence of flips of edges such that the automaton
obtained after this sequence of flips has a unique maximal tree. Note
that the levels and other useful data will not be recomputed after
each flip (which would increase the time complexity too much).


Let  be a red cycle containing a maximal tree  rooted at .
We denote by  the maximal roots of  in the
order given by the orientation of the red edges of the cycle.  For  and  we denote by  the set of states
contained in the red simple path from the root  with  to  with  included and  excluded.  For
 we define  as the set of all states of .
Similarly, for   and  we denote by 
the set of states contained in the red simple path from the root 
with  to  with  excluded and 
included.  For  we define  as the set of all states of
.


We denote by  the predecessor of  in . If the length of
 is , . We denote by  the set of maximal children
of  (\ie which are ancestors of some maximal state). Let  be
the cardinality of . For each  in , we choose a maximal
state  in the subtree rooted at  (see Fig.
\ref{figure.tree}). There may be several possible choices for the
state  and we select one of them arbitrarily. We denote by 
the set of these maximal states. This set has cardinality .

The key idea, in order to guarantee the global linear complexity, is
to perform operations for each maximal root , whose time complexity
is linear in the number of nodes belonging to trees attached to the
states contained in .

\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,3)(12,14)}
\MediumState
\VCPut{(2,6)}{
\State[]{(2,0)}{1}\ChgStateFillColor{Apricot}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[75]{(0,0)}{\State[s_2]{(4,0)}{11}\State[]{(6,0)}{12}\ChgStateFillColor{Apricot}\State[p_2]{(8,0)}{18}\RstStateFillColor
}
\VCPut[90]{(0,0)}{\State[]{(5.9,0)}{19}
}
\VCPut[85]{(0,0)}{\ChgStateFillColor{Apricot}\State[]{(7.9,0)}{20}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\State[]{(6,0)}{14}\ChgStateFillColor{Apricot}
    \State[p_1]{(8,0)}{16}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}}
\VCPut[180]{(0,0)}{\State[r_k]{(2,0)}{5}
    \State[]{(4,0)}{21}
    \State[]{(6,0)}{22}
    \ChgStateFillColor{Apricot} \State[]{(8,0)}{23}  \RstStateFillColor  
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6} }
\VCPut[270]{(0,0)}{\State[]{(2,0)}{7}
}
\VCPut[315]{(0,0)}{\State[]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{16}{14}{}
\EdgeL[.5]{18}{12}{}
\EdgeL[.5]{19}{13}{}
\EdgeL[.5]{20}{19}{}
\EdgeL[.5]{23}{22}{}
\EdgeL[.5]{22}{21}{}
\EdgeL[.5]{21}{5}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=60}{6}{16}{}
\VArcR[.5]{arcangle=-60}{11}{18}{}
}
\VCPut{(16,6)}{
\State[]{(2,0)}{1}\ChgStateFillColor{Apricot}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[75]{(0,0)}{\State[s_2]{(4,0)}{11}\State[]{(6,0)}{12}\ChgStateFillColor{Apricot}\State[p_2]{(8,0)}{18}\RstStateFillColor
}
\VCPut[90]{(0,0)}{\State[]{(5.9,0)}{19}
}
\VCPut[85]{(0,0)}{\ChgStateFillColor{Apricot}\State[]{(7.9,0)}{20}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\State[]{(6,0)}{14}\ChgStateFillColor{Apricot}
    \State[p_1]{(8,0)}{16}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}}
\VCPut[180]{(0,0)}{\State[r_k]{(2,0)}{5}
    \State[]{(4,0)}{21}
    \State[]{(6,0)}{22}
    \ChgStateFillColor{Apricot} \State[]{(8,0)}{23}  \RstStateFillColor  
}
\VCPut[225]{(0,0)}{\State[]{(2,0)}{6} }
\VCPut[270]{(0,0)}{\State[]{(2,0)}{7}
}
\VCPut[315]{(0,0)}{\State[]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{16}{14}{}
\EdgeL[.5]{18}{12}{}
\EdgeL[.5]{19}{13}{}
\EdgeL[.5]{20}{19}{}
\EdgeL[.5]{23}{22}{}
\EdgeL[.5]{22}{21}{}
\EdgeL[.5]{21}{5}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=50}{14}{16}{}
\VArcR[.5]{arcangle=-50}{19}{20}{}
}
\end{VCPicture}}
        \caption{On the left part the figure, the dashed (blue) edge
          ending in  has type 1 while the one ending in  has
          type 3. On the right part, the set  of dashed
          (blue) edges cover all maximal states of the subtree rooted
          at the child .  }\label{figure.tree}
\end{figure}


Since the automaton is irreducible, for each  there is at
least one blue edge ending in . Each blue edge  ending in
a state  can be of one of the following type depending
on the position of  in the graph:
\begin{itemize}
\item type 0:  is not in the same cluster as , or  has a
  positive level and  is not an ancestor of  in .
\item type 1:  is in the same cluster as , has a null level, and
   is outside the interval .
\item type 2:  is in the same cluster as , has a null level, and
   is contained in the interval . This includes the
  particular case where  and .
\item type 3:  is an ancestor of  in  and .
\end{itemize}
Note that it is possible that . In this case the edge 
has type 0 since  has a positive level.

A procedure \textsc{FindEdges}, that will be described later in
detail (see Section~\ref{section.auxiliary}), first flips some edges and returns
a value of one of the following forms.
\begin{itemize} 
\item A pair , where  is an edge of type 0.
\item A triple , where  are two edges of type 1 or 2
  ending in distinct states of .
\item A pair , where  is an edge of type 1 or 2.
Moreover, in this case, the procedure modifies the tree  in such a way
that  has a unique maximal child.
\item A pair , where  is an edge of type 3 starting at a
  state which is an ancestor of all maximal nodes of .
\end{itemize}   

For each maximal root , the procedure \textsc{FlipEdges}
returns either an automaton equivalent to  together with a stable
pair, or an automaton equivalent to  together with one edge
.  Its execution depends on the value returned by
\textsc{FindEdges} according to the following four cases
described below. After running \textsc{FlipEdges} on each
maximal root, we obtain either an automaton satisfying Condition~
(\ie which has a stable pair) or an automaton where each maximal root
 has a unique maximal child and such that the potential flip of
 with the red edge starting at  makes the root 
not maximal anymore. In the first case, our goal is achieved. In the
latter case, we flip the blue edge  and the red one
starting at  for all maximal roots  \emph{but one}. We get an
equivalent automaton which has unique maximal tree and thus has a
stable pair by Lemma~\ref{lemma.sameTree}. The combination of all
these transformations is realized by the procedure
\textsc{FindStablePair} given at the end of this section.


The possible values returned by the procedure \textsc{FlipEdges}
are the following.
\begin{itemize}
\item Case 0. The value returned by \textsc{FindEdges} is 
  with  of type 0. The procedure
  \textsc{FlipEdges} returns the automaton obtained by
  flipping the edge  and the red edge going out of
  . This automaton is equivalent to  and satisfies
  Condition~. Indeed, one may easily check that, after the flip,
  all states of maximal level belong to the same tree as .


\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,13)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\ChgStateFillColor{Apricot}\State[p_2]{(6,0)}{12}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p_1]{(6,0)}{14}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}}
\VCPut[180]{(0,0)}{\State[5]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=60}{6}{14}{}
}
\VCPut{(14,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\State[10]{(6,0)}{10}\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\State[p_2]{(6,0)}{12}}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\State[p_1]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}}
\VCPut[180]{(0,0)}{\State[5]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\State[19]{(6,0)}{19}}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}\ChgEdgeLineColor{red}\ChgEdgeLineStyle{solid}\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\VArcR[.5]{arcangle=60}{6}{14}{}
\ChgEdgeLineColor{blue}\ChgEdgeLineWidth{1}\ChgEdgeLineStyle{dashed}\ArcL[.5]{6}{5}{}}
\end{VCPicture}}
        \caption{The picture on the left illustrates Case 1.1.
          The edge  if of type 1. After flipping the
          edge  and the red edge going out of , we
          get the automaton on the right. It satisfies the
          Condition~, \ie it has a unique maximal tree (here
          rooted at ). Maximal states are colored and the (dashed)
          -edges of the automaton are not all
          represented.}\label{figure.cluster1}
\end{figure}
\item Case 1. The value returned by \textsc{FindEdges} is
, with ,  of
type 1 or 2. Recall that  and that .
\begin{itemize}
\item Case 1.1. If  (or ) has type 1, the same
conclusion as in Case 0 holds by flipping the edge  and the red edge
going out of~, as is shown in Fig.~\ref{figure.cluster1}.
\item Case 1.2. In the case both edges  have type 2 and , without loss of generality, we may assume that  in the interval  (see Fig.~\ref{figure.cluster2}).  We
      flip the edge  and the red edge going out of
      .  We denote by  the tree rooted at~ after this
      flip.
\begin{itemize}
\item Case 1.2.1.
If the height of 
    is greater than , the automaton satisfies Condition~ (see
    the right part of~Fig.~\ref{figure.cluster2}). 
\item Case 1.2.2.  Otherwise the height of  is at most 
  (see the left part of~Fig.~\ref{figure.cluster3}).  In that case,
  we also flip the edge  and the red edge going out of
  . The new equivalent automaton satisfies Condition~ (see
  the right part of~Fig.~\ref{figure.cluster3}).  The computation of
  the size of  is detailed in Section~\ref{section.complexity}.
\end{itemize}

\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\ChgStateFillColor{Apricot}
    \State[p_2]{(6,0)}{12}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p_1]{(6,0)}{14}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\State[t_2]{(2,0)}{4}
    \State[20]{(4,0)}{20}}
\VCPut[180]{(0,0)}{\State[5]{(2,0)}{5}
    \State[15]{(4,0)}{15}}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
    \ChgStateFillColor{Apricot}   
     \State[22]{(6,0)}{22}
    \RstStateFillColor
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\VArcR[.5]{arcangle=50}{4}{12}{}
}
\VCPut{(14,6)}{

\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\State[10]{(6,0)}{10}\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\State[p_2]{(6,0)}{12}}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\State[p_1]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[t_2]{(2,0)}{4}
    \State[20]{(4,0)}{20}}
\VCPut[180]{(0,0)}{\State[5]{(2,0)}{5}   
    \ChgStateFillColor{Apricot}   
    \State[15]{(4,0)}{15}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
     \State[22]{(6,0)}{22}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\State[19]{(6,0)}{19}}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ArcL[.5]{5}{4}{}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=50}{4}{12}{}
\ArcL[.5]{6}{5}{}
}
\end{VCPicture}}
        \caption{The picture on the left illustrates Case 1.2.1 of
          the main treatment. There are two edges ,
           of type 2. The height of the tree 
          obtained after flipping the edge  and the red
          edge going out of , is 3, which is greater than the maximal
          level. We get a unique maximal tree rooted at  in the
          same cluster.  The picture on the right illustrates the
          result.}
\label{figure.cluster2}
\end{figure}
\begin{figure}[h]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\ChgStateFillColor{Apricot}
    \State[p_2]{(6,0)}{12}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p_1]{(6,0)}{14}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\State[t_2]{(2,0)}{4}
    \State[20]{(4,0)}{20}}
\VCPut[180]{(0,0)}{\State[5]{(2,0)}{5}
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
    \ChgStateFillColor{Apricot}   
     \State[22]{(6,0)}{22}
    \RstStateFillColor
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\VArcR[.5]{arcangle=50}{4}{12}{}
}
\VCPut{(14,6)}{

\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\State[10]{(6,0)}{10}\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\State[p_2]{(6,0)}{12}}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\State[p_1]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[t_2]{(2,0)}{4}
    \ChgStateFillColor{Apricot}
    \State[20]{(4,0)}{20}\RstStateFillColor 
}
\VCPut[180]{(0,0)}{\ChgStateFillColor{Apricot}  
     \State[5]{(2,0)}{5}  
    \RstStateFillColor 
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
     \State[22]{(6,0)}{22}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\State[19]{(6,0)}{19}}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ArcL[.5]{5}{4}{}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\VArcR[.5]{arcangle=50}{4}{12}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{6}{5}{}
}
\end{VCPicture}}
        \caption{The picture on the left illustrates Case
          1.2.2. The two edges ,  are of
          type 2. The height of the tree  obtained after flipping
          the edge  and the red edge going out of
          , is equal to . In this case, we also flip
          the edge  and the red edge going out of
          . We get a unique maximal tree rooted at  in the
          same cluster.  The picture on the right gives the resulting
          cluster.}
\label{figure.cluster3}
\end{figure}


\item Case 1.3. In this case both edges  have type 2 and .  We denote by  (\resp ) the child of  ancestor
  of  (\resp ).  We denote by  the tree rooted at 
  obtained by the potential flip of  and the red edge
  going out of , keeping only  and the subtree rooted at the
  child . The nodes of the tree  rooted at  are
  represented in salmon in the left part of
  Fig.~\ref{figure.cluster4}.  This step again needs a computation of
  the height of  explained in the complexity issue. Case 1.3
  occurs when ,  and .  In the particular case
  where the length of  is , the tree  is reduced to the node
   (it corresponds to the Case 1.3.2 below).
\begin{itemize}
\item Case 1.3.1. If the height of  is greater than the height of ,
  we flip  and the red edge going out of
  . The equivalent automaton satisfies
  Condition~. 
\item Case 1.3.2. If the height of  is less than the height of
  , we flip  and the red edge going
  out of . We then call again the procedure
  \textsc{FlipEdges} with this new red cycle. This time the
  (new) tree  has the same height as .  Hence this
  call is done at most one time for a given maximal root . 
\item Case 1.3.3. Finally, we consider the case where the heights of  and
 are equal (see the left part of Fig.~\ref{figure.cluster4}).
\begin{itemize}
\item Case 1.3.3.1.
If the set of outgoing edges of  is a bunch and there is a state
 whose set of outgoing edges is also a
bunch, we get a trivial stable pair . 
\item Case 1.3.3.2.  If the set of outgoing edges of  is a bunch
  and, for any state , the set of outgoing edges of  is
  not a bunch (as in the left part of Fig.~\ref{figure.cluster4}), we
  flip  and the red edge going out of . The (new)
  tree  (obtained by the potential flip of  and
  the red edge going out of , keeping only  and the subtree
  rooted at the child ) has the same height as .  We then
  call again the procedure \textsc{FlipEdges} with this new
  red cycle. This time the height of the new tree  is still
  equal to the height of  and the set of outgoing edges of the
  predecessor of  on the cycle is not a bunch. This call is thus
  performed at most one time.
\item Case 1.3.3.3.
If the set of outgoing edges of  is not a bunch, let
 be a -edge going out of  with .
If  does not belong to , we get an equivalent automaton
satisfying Condition~ by flipping  and the red edge
going out of . If  belongs to , we flip 
and the red edge going out of . We also flip  and
the red edge going out of  if  is not a descendant of ,
or  and the red edge going out of , in the opposite
case. Note that  since the height of  is equal to
the non-null height of . We get an equivalent automaton satisfying
Condition~ (see the right part of Fig.~\ref{figure.cluster5}).
\end{itemize}
\end{itemize}
\end{itemize}



\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[r]{(2,0)}{3}
 \RstStateFillColor
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\ChgStateFillColor{Apricot}
    \State[p_2]{(6,0)}{12}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p_1]{(6,0)}{14}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[s_0]{(2,0)}{4}
    \State[20]{(4,0)}{20}\RstStateFillColor 
}
\VCPut[180]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[5]{(2,0)}{5}
 \RstStateFillColor 
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
    \ChgStateFillColor{Apricot}   
     \State[22]{(6,0)}{22}
    \RstStateFillColor
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\VArcR[.5]{arcangle=100,ncurv=1.8}{6}{12}{}
\VArcR[.5]{arcangle=60}{4}{3}{}
\VArcR[.5]{arcangle=60}{13}{21}{}
}
\VCPut{(14,6)}{

\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor 
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[r]{(2,0)}{3}
    \RstStateFillColor 
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_2]{(4,0)}{11}\ChgStateFillColor{Apricot}
    \State[p_2]{(6,0)}{12}\RstStateFillColor 
}
\VCPut[100]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[s_1]{(4,0)}{13}\State[p_1]{(6,0)}{14}\RstStateFillColor 
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}
    \ChgStateFillColor{Apricot}
    \State[20]{(4,0)}{20}\RstStateFillColor 
}
\VCPut[180]{(0,0)}{\ChgStateFillColor{Apricot}  
     \State[5]{(2,0)}{5}  
    \RstStateFillColor 
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
    \ChgStateFillColor{Apricot}
     \State[22]{(6,0)}{22}
    \RstStateFillColor 
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ArcL[.5]{5}{4}{}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\ArcL[.5]{4}{3}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ArcL[.5]{6}{5}{}
\VArcR[.5]{arcangle=100,ncurv=1.8}{6}{12}{}
\VArcR[.5]{arcangle=60}{4}{3}{}
\VArcR[.5]{arcangle=60}{13}{21}{}
}
\end{VCPicture}}
        \caption{ The picture on the left illustrates Case 1.3.3.2 of
          the main treatment. The two edges  and
           are of type 2.  Let  be the tree
          rooted at  obtained by the potential flip of
           and the red edge going out of , keeping
          only  and the subtree rooted at the child . The
          nodes of the tree  rooted at  are represented in
          salmon in the left part of the figure. The state  is a
          bunch. After flipping the edge  and the red
          edge going out of , we get the automaton pictured in
          the right part of the figure.  The tree  is now tree
          rooted at  obtained by the potential flip of
           and the red edge going out of , keeping
          only  and the subtree rooted at the child . Its
          states are colored in salmon. The height of  is 2.}
\label{figure.cluster4}
\end{figure}




\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[r]{(2,0)}{3}
 \RstStateFillColor
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_1]{(4,0)}{11}\ChgStateFillColor{Apricot}
    \State[p_1]{(6,0)}{12}\RstStateFillColor
}
\VCPut[100]{(0,0)}{\State[s_2]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p_2]{(6,0)}{14}\RstStateFillColor  
}
\VCPut[135]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[s_0]{(2,0)}{4}
    \State[20]{(4,0)}{20}\RstStateFillColor 
}
\VCPut[180]{(0,0)}{\ChgStateFillColor{Salmon}
    \State[5]{(2,0)}{5}
 \RstStateFillColor 
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
    \ChgStateFillColor{Apricot}   
     \State[22]{(6,0)}{22}
    \RstStateFillColor
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor 
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{5}{4}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\VArcR[.5]{arcangle=100,ncurv=1.8}{6}{12}{}
\EdgeL[.5]{4}{13}{}
}
\VCPut{(14,6)}{

\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\State[10]{(6,0)}{10}\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[80]{(0,0)}{\State[s_1]{(4,0)}{11}\State[p_1]{(6,0)}{12}}
\VCPut[100]{(0,0)}{\State[s_2]{(4,0)}{13}\State[p_2]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}
    \ChgStateFillColor{Apricot}
    \State[20]{(4,0)}{20}\RstStateFillColor 
}
\VCPut[180]{(0,0)}{\ChgStateFillColor{Apricot}  
     \State[5]{(2,0)}{5}  
    \RstStateFillColor 
}
\VCPut[225]{(0,0)}{\State[t_1]{(2,0)}{6}
    \State[17]{(4,0)}{17}
     \State[22]{(6,0)}{22}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\State[19]{(6,0)}{19}}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{12}{11}{}
\EdgeL[.5]{11}{3}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\EdgeL[.5]{20}{4}{}
\EdgeL[.5]{22}{17}{}
\EdgeL[.5]{21}{3}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{4}{13}{}
\VArcR[.5]{arcangle=100,ncurv=1.8}{6}{12}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ArcL[.5]{6}{5}{}
\VArcR[.5]{arcangle=70,ncurv=0.9}{6}{14}{}
\EdgeL[.5]{4}{3}{}
}
\end{VCPicture}}
        \caption{ The picture on the left illustrates Case 1.3.3.3. The
          two edges  and  are of type 2.
          Let  be the tree rooted at  obtained by the
          potential flip of  and the red edge going out
          of , keeping only  and the subtree rooted at the
          child . The nodes of the tree  rooted at  are
          represented in salmon in the left part of the figure.  The
          state  is not a bunch: it has a -edge
           with . After flipping the edge
           and the red edge going out of , and
          flipping  and the red edge going out of
          , we get a unique maximal tree rooted at  in the
          same cluster (see the right part of the figure). }
\label{figure.cluster5}
\end{figure}

\item Case 2. We now come to the case where the value returned by
  \textsc{FindEdges} is a pair  with  of
  type 1 or 2, and  is modified in such a way that 
  has a unique maximal child, \ie .
\begin{itemize}
\item Case 2.1.  If  has type 1, we flip the edge
   and the red edge going out of~. We get an
  equivalent automaton satisfying Condition~.
\item Case 2.2.  If  has type 2, we denote by 
  the tree rooted at  obtained by the potential flip of
   and the red edge going out of , keeping only
   and the subtree rooted at the child .  Case 2.2 occurs
  when ,  and . In the particular case where the
  length of  is ,  is reduced to the node  which
  corresponds to the Case 2.2.2 below.
\begin{itemize}
\item Case 2.2.1.  If the height of  is greater than the height
  of , we do the flip and the equivalent automaton satisfies
  Condition~.  
\item Case 2.2.2.  If the height of  is less than the height of
  , we do not do the flip, and return the automaton together with
  the edge . Note that a possible future flip of
   and the red edge starting at  makes the root
   not maximal anymore.
\item Case 2.2.3.  
We now come to the case where the height
  of  is equal to the height of .  
\begin{itemize}
\item Case 2.2.3.1.  If the set of outgoing edges of  and 
  are bunches, there is a trivial stable pair .
\item Case 2.2.3.2.
If the set of outgoing edges of  is a bunch and
  the set of outgoing edges of  is not a bunch (see the left
  part of Fig.~\ref{figure.cluster6}), we flip the edge
   and the red edge going out of .  We then call
  the procedure \textsc{FlipEdges} with this new red
  cycle. The root  has now a unique child () ancestor of
  maximal state whose set of outgoing edges is a bunch (see the right
  part of Fig.~\ref{figure.cluster6}).  This call is thus performed
  at most one time.  
\item Case 2.2.3.3.
Finally, if  is a not a bunch, let
   be a -edge with .  If  does not
  belong to  we flip the edge  and the red edge
  going out of .  The equivalent automaton satisfies
  Condition~. It  belongs to  and is not a descendant of
  , we flip the edge  and the red edge going out
  of , and we also flip the edge  and the red edge
  going out of .  The equivalent automaton satisfies
  Condition~.  If  belongs to  and is a descendant of
  , we return the automaton together with the edge
  .
\end{itemize}
\end{itemize}
\end{itemize}




\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[90]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p]{(6,0)}{14}\RstStateFillColor
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}
    \State[20]{(4,0)}{new}}
\VCPut[180]{(0,0)}{\State[t_1]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[6]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{21}{3}{}
\EdgeL[.5]{13}{3}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{new}{4}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=60,ncurv=1.2}{5}{14}{}
\VArcR[.5]{arcangle=60}{4}{3}{}
}
\VCPut{(14,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[60]{(0,0)}{\State[21]{(4,0)}{21}}
\VCPut[90]{(0,0)}{\State[s_0]{(4,0)}{13}\State[p]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[s_1]{(2,0)}{4}
     \ChgStateFillColor{Apricot}
    \State[20]{(4,0)}{new}
      \RstStateFillColor
}
\VCPut[180]{(0,0)}{\State[t_1]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[6]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\ArcL[.5]{6}{5}{}
\EdgeL[.5]{21}{3}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{new}{4}{}
\VArcR[.5]{arcangle=60,ncurv=1.2}{5}{14}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ArcL[.5]{5}{4}{}
\VArcR[.5]{arcangle=60}{4}{3}{}
}
\end{VCPicture}}
        \caption{The
          picture on the left illustrates Case 2.2.3.2 of the main treatment.
          The edge  has type 2.  After flipping the edge
           and the red edge going out of , we get the
          automaton on the right part of the figure. The root  has a new single child
           ancestor of a maximal state, whose set of outgoing
          edges is a bunch. The new tree rooted at  has here the
          same level  as before and \textsc{FlipEdges} is
          called a second and last time.}
\label{figure.cluster6}
\end{figure}
\item Case 3. If the value returned by \textsc{FindEdges} is an
  edge  of type 3 and  is an ancestor of all maximal
  nodes of  the procedure \textsc{FlipEdges} returns this
  edge.
\end{itemize}

After running  on all maximal roots, we
get either an automaton with a stable pair, or an automaton where each
cluster fulfills the following conditions.
\begin{itemize}
\item the root  of each maximal tree has a unique maximal child;
\item for each maximal root , there is an edge  such
  that the potential flip of  and the red edge starting at 
   makes the root  not maximal anymore.
\end{itemize}
If the latter case, we flip the blue edge  and the red
one starting at  for all maximal roots  but one. We get an
equivalent automaton which satisfies Condition~ as is shown in
Fig.~\ref{figure.cluster7}. The pseudocode for this final treatment
is given in procedure \textsc{FindStablePair}.

\begin{small}
\begin{codebox} 
\Procname{)} 
\li  \If the maximal level 
\li  \Then  \Return 
\li   \Else \For each maximal root 
\li        \Do 
\li         \If  is a (stable) pair of states 
\li             \Then \Return , 
\li             \Else ( is a -edge ) set 
             \End
           \End
\li      \For each maximal root  
\li        \Do flip the edge  and the red edge starting at 
           \End
\label{li:FindStablePair-fin}
\li       \proc{GetPredecessor}
\li       the child of  ancestor of 
\label{li:FindStablePair-fin2}
\li     \Return ,  
    \End
\end{codebox}
\end{small}

\begin{figure}[htbp]
    \centering
\VCDraw{\begin{VCPicture}{(0,-1)(12,12)}
\MediumState
\VCPut{(0,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\ChgStateFillColor{Apricot}
\State[10]{(6,0)}{10}\RstStateFillColor
\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[90]{(0,0)}{\State[s_1]{(4,0)}{13}\ChgStateFillColor{Apricot}
    \State[p]{(6,0)}{14}\RstStateFillColor
}
\VCPut[135]{(0,0)}{\State[s_0]{(2,0)}{4}
    \State[20]{(4,0)}{new}}
\VCPut[180]{(0,0)}{\State[t_1]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[6]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\ChgStateFillColor{Apricot}
    \State[19]{(6,0)}{19}\RstStateFillColor
}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ChgEdgeLineStyle{solid}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{7}{6}{}
\ArcL[.5]{8}{7}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{13}{3}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{new}{4}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=40}{4}{14}{}
\ArcL[.5]{2}{9}{}
\VArcR[.5]{arcangle=40}{8}{19}{}
\ArcL[.5]{6}{15}{}
}
\VCPut{(14,6)}{
\State[1]{(2,0)}{1}\State[9]{(4,0)}{9}\State[10]{(6,0)}{10}\VCPut[45]{(0,0)}{\State[8]{(2,0)}{2}
}
\VCPut[90]{(0,0)}{\State[r]{(2,0)}{3}
}
\VCPut[90]{(0,0)}{\State[s_0]{(4,0)}{13}\State[p]{(6,0)}{14}}
\VCPut[135]{(0,0)}{\State[s_1]{(2,0)}{4}
    \State[20]{(4,0)}{new}
}
\VCPut[180]{(0,0)}{\State[t_1]{(2,0)}{5}
    \State[15]{(4,0)}{15}\ChgStateFillColor{Apricot}
    \State[16]{(6,0)}{16}\RstStateFillColor
}
\VCPut[225]{(0,0)}{\State[6]{(2,0)}{6}
    \State[17]{(4,0)}{17}
}
\VCPut[270]{(0,0)}{\State[3]{(2,0)}{7}
    \State[18]{(4,0)}{18}\State[19]{(6,0)}{19}}
\VCPut[315]{(0,0)}{\State[2]{(2,0)}{8}}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{red}
\ArcL[.5]{1}{8}{}
\ArcL[.5]{3}{2}{}
\ArcL[.5]{7}{6}{}
\EdgeL[.5]{10}{9}{}
\EdgeL[.5]{9}{1}{}
\EdgeL[.5]{14}{13}{}
\EdgeL[.5]{16}{15}{}
\EdgeL[.5]{15}{5}{}
\EdgeL[.5]{17}{6}{}
\EdgeL[.5]{19}{18}{}
\EdgeL[.5]{18}{7}{}
\ArcL[.5]{6}{5}{}
\ArcL[.5]{5}{4}{}
\EdgeL[.5]{13}{3}{}
\EdgeL[.5]{new}{4}{}
\ArcL[.5]{5}{4}{}
\VArcR[.5]{arcangle=40}{4}{14}{}
\ArcL[.5]{2}{9}{}
\VArcR[.5]{arcangle=40}{8}{19}{}
\ChgEdgeLineColor{blue}
\ChgEdgeLineWidth{1}
\ChgEdgeLineStyle{dashed}
\ArcL[.5]{6}{15}{}
\ArcL[.5]{2}{1}{}
\ArcL[.5]{4}{3}{}
\ArcL[.5]{8}{7}{}
}
\end{VCPicture}}
        \caption{ The picture on the left illustrates the case where
          \textsc{FlipEdges} has returned a -edge 
          for all maximal roots .  We flip  and the red edge
          starting at the same state for all but one maximal root
          . The new cluster is pictured on the right part of the
          figure. It has a unique maximal tree. By
          Lemma~\ref{lemma.sameTree} the pair  is stable.}
\label{figure.cluster7}
\end{figure}


\pagebreak
\subsubsection{The auxiliary procedure \textsc{FindEdges}} \label{section.auxiliary}

In this section, we describe the procedure \textsc{FindEdges}
which is a preliminary step of the procedure \textsc{FlipEdges}.

Let  be a maximal root,  be the set of maximal children of
. For each  in , we choose a maximal state  in the
subtree rooted at  and we denote by  the set of these maximal
states (see Fig. \ref{figure.tree}). Recall that the procedure
\textsc{FindEdges} flips some edges and returns an equivalent
automaton together with one or two edges of the following forms.
\begin{itemize}
\item One edge  of type 0.
\item Two edges  of type 1 or 2 ending in distinct states of
  .
\item One edge  of type 1 or 2.  Moreover, in this case, the
  procedure modifies the tree  in such a way that  has a unique
  maximal child.
\item One edge  of type 3 starting at a
  state which is an ancestor of all maximal nodes of .
\end{itemize} 

For each maximal child , we denote by  the subtree of 
rooted at . The procedure \textsc{FindEdges} computes a
list  of -edges , where  is a maximal node of
 and  is an ancestor of  in  distinct from . The
starting states  of edges of this list \emph{cover} the maximal
nodes of  in the following sense: for each maximal node  in
, there is a unique edge  such that  is an
ancestor of  (see for instance the right part of Fig.
\ref{figure.tree}). The list  is computed by scanning at most one
time each node of the tree . For each maximal leaf , we
follow the red edges up to  and either find  or an already
scanned node, or find a node with an outgoing -edge ending in
. In the latter case, this edge is added to  and we continue
with another maximal leaf. In the case the list  does not cover
all maximal nodes of , and since the graph of the automaton
is strongly connected, the process finds an edge  where
 is a maximal node of , of type 0, 1 or 2.

If there is a maximal child  such that an edge  of
type 0 is found, then \textsc{FindEdges} returns this
edge. 

Otherwise, if there are two maximal children  such
that two edges ,
 of type 1 or 2 are found, then
\textsc{FindEdges} returns these two edges.  If there is a
maximal child  such an edge  of type 1
or 2 and covering lists  for the other maximal children  are found, then we perform the following flips. For any maximal
child  and any edge , we flip the edge
 and the red edge going out of . We update the data of the
trees attached to the nodes from  to  in the new red cycle
created by the flip. After this transformation the node  has  as
unique maximal child. 
The procedure \textsc{FindEdges} returns the edge  of type 
1 or 2  and  has a unique maximal child.  

Finally, if one obtains covering lists for all maximal children, then,
for all these children  but one, say , we flip each edge
 and the red edge going out of . We also flip all
edges  but one, . We update the
data of the trees attached to the nodes from  to  in the new red
cycle created by each flip.  The procedure \textsc{FindEdges}
returns the edge  of type 3. Its starting state 
is disctinct from  ans is an ancestor of all maximal states of .




\section{The complexity issue} \label{section.complexity}

In this section, we establish the time and space complexity of our
algorithm. We denote by  the size of the alphabet  and by 
the number of states of~.  Since  is complete deterministic,
it has exactly  edges.


\subsection{Data structures and their updating} \label{section.update}

Some data attached to the states is useful to obtain the claimed
complexity.  This data is updated after the computation of each
quotient automaton with the procedure  with a time
complexity which is linear in the size of the quotient automaton.

The edges of the automaton can be stored in tables indexed by the
states and labels. The updating procedure computes the level of each
state, the root of its tree in its cluster.  It also computes a list
of maximal roots and the predecessor of a state on the cycle.  The
function \textsc{GetPredecessor} returns the predecessor of state
 on its red cycle in constant time.

One computes 
\begin{itemize}
\item for each root of a tree , the height of ,
\item for each maximal root, the list of its maximal children,
\item for each maximal child, the list of the maximal nodes belonging
  to the subtree rooted at this child.
\end{itemize}
This data can be moreover updated in time linear in the size of the
tree.

We also maintain an inverse structure of the quotient
automaton. Giving a label  and a state , it gives, for each
letter , an unordered list of states  such that there is an edge
 in the quotient automaton. The procedure
\textsc{Flip} exchanges the labels of the two edges
. It also updates in the inverse structure the
lists of edges coming in  and . Its time complexity is thus
upper bounded by the number of edges going out of  or coming in
.


\subsection{Complexity of the algorithm} 

\begin{proposition} \label{proposition.complexity}
The worst-case complexity of \textsc{FindSynchronizedColoring}
applied to an -state aperiodic automaton is 
in time, and  in space.
\end{proposition}

\begin{proof} 
  The complexity of \textsc{FindSynchronizedColoring} is at most  times the
  complexity of the procedures \textsc{Update} and
  \textsc{FindStablePair}.  Indeed, each call in the procedure
  \textsc{Merge} reduces the number of states of the automaton so that
  it is called at most  times. Since each of its steps without the
  recursive calls takes a time at most , the contribution of
  \textsc{Merge} in \textsc{FindSynchronizedColoring} is at most .  As the
  procedure \textsc{Update} has a time complexity , we just
  have to show that the time complexity of
  \textsc{FindStablePair} is .

  Since \textsc{LevelZeroFlipEdges} contains only one \textsc{Flip}
  call, we show that the calls to \textsc{FlipEdges} for all
  maximal roots  can be performed in time .

  We first examine the complexity of the auxiliary step
  \textsc{FindEdges} for a given maximal root .  This
  procedure requires a scan of the nodes of trees  rooted at the
  maximal children  of  together with their outgoing edges.
  Since the edges contained in the lists  have distinct target
  states in , the flips of edges in  can be performed with a
  time complexity at most , where  is the number of edges
  going out of or coming in a node of the tree  rooted by .
  Indeed, the update of the inverse structure for nodes in  can be
  performed one time for all the flips of edges in .  Note that
  the updating of the data after the flips is at most the size
  of~. Indeed, after a flip of  and  only the
  nodes belonging to trees rooted at nodes along the red path from 
  to  are updated.  As a consequence, the contribution of the
  auxiliary step in \textsc{FindStablePair} is .

  We now come to the complexity induced by the main treatment. We
  denote by  the number of edges coming in or going out of a
  node belonging to the sector , \ie the nodes contained in a
  tree attached to a node of the cycle between  and  (
  included and ), where  is the maximal root preceding  on
  . Let us compute for instance the complexity of the procedure
  \textsc{UniqueChildFlipEdges} (see
  Section~\ref{section.pseudocode}).  It contains at most two flips of
  edges ending in .  The height of the tree  is easily
  computed by scanning all nodes attached to some node of  between
   and  ( and  both excluded). In the case where this
  height is equal to  and the set of outgoing edges of  is
  a bunch, we flip the edge .  We perform the procedure
  \textsc{UpDateSector} for updating the data of the nodes
  contained in the trees whose roots belong to .  Then we call
  a second (and last) time \textsc{FlipEdges}.  Since the time
  complexity of \textsc{UpDateSector} is at most ,
  we get that the time complexity of
  \textsc{UniqueChildFlipEdges} is also
  . Similarly, the time complexity of the procedures
  \textsc{ChildrenFlipEdgesEqual} and
  \textsc{ChildrenFlipEdgesUnEqual} is also .

Hence the overall time spent for computing \textsc{FlipEdges}
for all maximal roots  is .
  The space complexity is . Indeed, only linear
  additional space is needed to perform all operations.
\end{proof}

\section{The case of periodic graphs} \label{section.periodic}

Recall that the period of an automaton is the gcd of the lengths of
its cycles.  If the automaton  is an -state
complete deterministic irreducible automaton which is not aperiodic,
it is not equivalent to a synchronized automaton. Nevertheless, the
previous algorithm can be modified as follows for finding an equivalent
automaton with the minimal possible rank. It has a quadratic-time
complexity.

\begin{small}
\begin{codebox}
\Procname{}
\li  
\li  \While (size() ) 
\li      \Do \proc{Update()}
\li        \proc{FindStablePair()}
\label{li:PeriodicFindColoring-3}
\li       lift the coloring up from  to the automaton  
\li       \If there is a stable pair  
\label{li:PeriodicFindColoring-4}
\li              \Then  \proc{Merge}
\li              \Else \Return 
          \End
     \End
\li \Return  
\end{codebox}
\end{small}
It may happen that \textsc{FindStablePair} returns an automaton 
which has no stable pair (it is made of a cycle where the set of
outgoing edges of any state is a bunch).  Lifting up this coloring
to the initial automaton  leads to a coloring of the initial
automaton whose minimal rank is equal to its period.

This result can be stated as the following theorem, which extends the Road
Coloring Theorem to the case of periodic graphs.


\begin{theorem}
  Any irreducible automaton  is equivalent to a an automaton whose
  minimal rank is the period of .
\end{theorem}
 
\begin{proof}


  Let us assume that  is equivalent to an automaton  which
  has a stable pair . Let  be the quotient of  by the
  congruence generated by . Let  be the period of 
  (equal to the period of ) and  the period of . 
  Let us show that .

It is clear that  divides  (which we denote ). Let
 be the length of a path from  to  in , where 
is equivalent to . Since  is stable, it is
synchronizable. Thus there is a word  such that . Since the automaton  is irreducible, there is a path
labeled by some word  from  to . Hence  and , implying .  Let 
be the class of  and  be the label of a cycle around 
in . Then there is a path in  labeled by  from  to
, where  is equivalent to . Thus . It follows that
 and .

 Suppose that  has rank .  Let us show that  also has
 rank . Let  be a minimal image of  and  be the set of
 classes of the states of  in . Two states of  cannot
 belong to the same class since  would not be minimal otherwise.
 As a consequence  has the same cardinal as . The set  is a
 minimal image of . Indeed, for any word , the set 
 is the set of classes of  which is a minimal image of
 . Hence . As a consequence,  has rank .

  Let us now assume that  has no equivalent automaton which has a
  stable pair. In this case, we know that  is made of one red
  cycle where the set of edges going out of any state is a bunch. The
  rank of this automaton is equal to its period which is the
  length of the cycle. 

  Hence the procedure \textsc{PeriodicFindColoring} returns an
  automaton equivalent to  whose minimal rank is equal to its
  period.
\end{proof}

Since the modification of \textsc{FindSynchronizedColoring} into
\textsc{PeriodicFindColoring} does not change its complexity, we
obtain the following corollary.
\begin{corollary}
Procedure \textsc{PeriodicFindColoring} finds a coloring of minimal rank
for an -state irreducible automaton in time .
\end{corollary}

\section{Pseudocode} \label{section.pseudocode}
This section contains the pseudocode of some main procedures.
\subsection{Procedure \textsc{Merge}}

The computation of the congruence generated by  can be
performed by using usual \textsc{Union/Find} functions computing
respectively the union of two classes and the leader of the class of a
state. After merging two classes whose leaders are  and 
respectively, we need to merge the classes of  and  for any .  
A pseudocode for merging classes is given in Procedure \textsc{Merge} below. 

\begin{small}
\begin{codebox}
\Procname{}
\li  
\li  
\li  \If  
\li        \Then 
\li               \For  
\li                   \Do 
                   \End
     \End
\li \Return 
\end{codebox}
\end{small}



\subsection{Procedure \textsc{FlipEdges}}

We give below a pseudocode of the procedure
\textsc{FlipEdges}.  For each maximal root , it
returns either an automaton equivalent to  together with a stable
pair, or an automaton equivalent to  together with one edge.
It performs some flips depending on the type of the edges returned by
\textsc{FindEdges}. It calls \textsc{UniqueChildFlipEdges}
in the case  has a unique maximal child and  is an edge of type 2
returned by \textsc{FindEdges}.  It calls
\textsc{ChildrenFlipEdgesUnequal} in the case  has at least
two maximal children and \textsc{FindEdges} return a pair of
edges with distinct starting states.  It calls
\textsc{ChildrenFlipEdgesUnequal} in the case  has at least
two maximal children and \textsc{FindEdges} returns a pair of
edges which have the same starting state.

Recall that \textsc{GetPredecessor} returns the predecessor of
state  on its red cycle.
\begin{small}
\begin{codebox}
\Procname{r}
\li     result  
\li    \If ( a unique maximal child ) and (result )
\li          \Then \If (result  or (result  where  has type 1)
\li                     \Then \proc{Flip} \li                           \Return  and the stable pair 
\li                     \Else (result  where  has type 2)
\li                           \Return   
                    \End
        \End
\li     \If  ( at least two maximal children) and (result  \\
         where  have type 1 or 2)
\li          \Then  \If 
\li                     \Then \Return   
\li                     \Else \Return   
                     \End
         \End
\li      \If result  where  is an edge of type 3
\li          \Then \Return 
         \End 
\end{codebox}
\end{small}

\begin{small}
\begin{codebox}
\Procname{r}
\li      let  be the unique child of 
\li      
\li       let  be the tree rooted at  obtained by the potential flip of  and the red edge 
\zi     going out of , keeping only  and the subtree rooted at the child 
\li        \If   
\li             \Then \proc{Flip}   
\li                   \Return  and the stable pair  
                \End
\li         \If  
\li             \Then \Return  and the edge 
                 \End
\li         \If  
\li             \Then \If the set of outgoing edges of  and  are bunches
\li                    \Then \Return  and the stable pair  
                       \End
\li                    \If the set of outgoing edges of  is a bunch 
\zi                            and the set of outgoing edges of  is not a bunch
\li                           \Then   
\li                                   \proc{UpDateSector}  (we still have ) \li                                   \Return 
                        \End
\li                    \If the set of outgoing edges of  is not a bunch 
\li                          \Then let  a -edge going out of  with 
\li                                \If   
\li                                    \Then 
\li                                         \If  the level of  is positive
\li                                              \Then  the root of the tree containing 
\li                                                     
\li                                                      the child of  ancestor of 
\li                                                     \Return  and the stable pair  
\li                                              \Else  the root of the tree containing 
\li                                                     
\li                                                     \Return  and the stable pair  
                                                  \End
\li                                    \Else ( and ) 
\li                                           \Return  and the edge 
                                       \End 
                            \End
           \End
\end{codebox}
\end{small}



\begin{small}
\begin{codebox}
\Procname{r}
\li      set  and 
\li      
\li       let  be the tree rooted at  obtained obtained by the potential flip of 
\zi and the red edge going out of , keeping only  and the subtree rooted at 
\li        \If      
\li             \Then \proc{Flip}   
\li                   \Return  and the stable pair  
                \End
\li         \If  
\li             \Then \proc{Flip} 
\li                   \proc{UpDateSector} 
\li                    \Return  \proc{FlipEdges} 
                 \End
\li        \If  
\li              \Then \If the set of outgoing edges of  is a bunch and there is an 
\zi     integer  such that the set of outgoing edges of  is a bunch
\li                       \Then \Return  and the stable pair  
                          \End
\li                     \If the set of outgoing edges of  is a bunch 
\zi                            and the sets of outgoing edges of  for  are not bunches
\label{li:FlipEdgesChildren-cluster4-debut} 
\li                        \Then   
\li                                        \proc{UpDateSector} (we still have ) \label{li:FlipEdgesChildren-cluster4-fin}
\li                                         \Return 
                           \End
\li                     \If the set of outgoing edges of  is not a bunch 
\li                          \Then let  a -edge going out of  with 
\li                                \If   
\li                                    \Then 
\li                                         \If  the level of  is positive
\li                                              \Then  the root of the tree containing 
\li                                                     
\li                                                      the child of  ancestor of 
\li                                                     \Return  and the stable pair  
\li                                              \Else  the root of the tree containing 
\li                                                     
\li                                                     \Return  and the stable pair  
                                                  \End
\li                                    \Else () 
\li                                         \If  is not a descendant of 
\li                                          \Then  
\li                                                     
\li                                                  the child of  ancestor of 
\li                                                 \Return  and the stable pair  
\li                                           \Else ( is a descendant of )
\li                                                 
\li                                                     
\li                                                 \Return  and the stable pair  
                                              \End
                                       \End 
                            \End
           \End
\end{codebox}
\end{small}

The procedure \textsc{UpDateSector} is called
after a flip of the edge  and the red edge going out of . It
updates the data of the nodes (and their trees attached to) along the
red path going from  to , where  is the unique maximal
child of .

\begin{small}
\begin{codebox}
\Procname{r}
\li  set  and  with 
\li  \If at least one of  (say ) has type 1 and  is the child of  ancestor of 
\li      \Then 
\li            \proc{Flip} \li            \Return  and the stable pair 
\li       \Else \proc{Flip} 
\li             let  be the new tree rooted at 
\li             \If    
\label{li:FlipEdgesChild-calcul}
\li                        \Then \Return the stable pair 
\li                        \Else  )
\li                              \proc{Flip}   
\li                              \Return  and the stable pair 
                 \End
          \End
      \End
\end{codebox}
\end{small}



\noindent \emph{Acknowledgments} The authors would like to thank
Florian Sikora, Avraham Trahtman, and the anonymous referees for 
pointing us some missing configurations in the algorithm.
We also thank the referees for helping us to improve the presentation
of the paper.

\bibliographystyle{abbrv}
\bibliography{road}




\end{document}
