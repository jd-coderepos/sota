
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

\newcommand{\kw}[1]{{\small\textsc{\MakeLowercase{#1}}}}
\newcommand{\mat}[1]{\ensuremath{{\mathbf{\MakeUppercase{{#1}}}}}}
\renewcommand{\vec}[1]{\ensuremath{\mathbf{\MakeLowercase{{#1}}}}}
\newcommand{\set}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\gr}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\prm}[1]{\ensuremath{^{#1}}}
\newcommand{\ly}[1]{\ensuremath{^{(#1)}}}
\newcommand{\grn}[2]{\ensuremath{\gr{#1}\prm{#2}}}
\newcommand{\tuple}[1]{\ensuremath{\langle{#1} \rangle}}
\newcommand{\Reals}{\mathds{R}}
\renewcommand{\Re}{\gr{R}}
\newcommand{\Nat}{\set{N}}
\newcommand{\eye}{\mat{I}}
\newcommand{\ones}{\vec{1}}
\newcommand{\Vs}{\set{V}}
\newcommand{\Ws}{\set{W}}
\newcommand{\Ps}{\set{P}}
\newcommand{\Qs}{\set{Q}}
\newcommand{\Sg}{\gr{S}}
\newcommand{\Ig}{\gr{I}}
\newcommand{\Cg}{\gr{C}}
\newcommand{\Gg}{\gr{G}\xspace}
\renewcommand{\gg}{\gr{g}}
\newcommand{\gi}{\gr{i}}
\newcommand{\gj}{\gr{j}}
\newcommand{\gh}{\gr{h}}
\newcommand{\Hg}{\gr{H}}
\newcommand{\hg}{\gr{h}}
\newcommand{\Kg}{\gr{K}}
\newcommand{\Ng}{\gr{N}}
\newcommand{\Bg}{\gr{B}}
\newcommand{\bg}{\gr{b}}
\newcommand{\kg}{\gr{k}}
\newcommand{\Ug}{\gr{U}}
\newcommand{\ug}{\gr{u}}
\newcommand{\Wm}{\mat{W}}
\newcommand{\Xm}{\mat{X}}
\newcommand{\Ym}{\mat{Y}}
\newcommand{\Am}{\mat{A}}
\newcommand{\Gm}{\mat{G}}
\newcommand{\Vm}{\mat{V}}
\newcommand{\Um}{\mat{U}}
\newcommand{\Pm}{\mat{P}}

\newcommand{\fv}{\vec{f}}
\newcommand{\xv}{\vec{x}}
\newcommand{\yv}{\vec{y}}
\newcommand{\hv}{\vec{h}}
\newcommand{\ov}{\vec{o}}
\newcommand{\bv}{\vec{b}}
\newcommand{\wv}{\vec{w}}
\newcommand{\gv}{\vec{g}}
\newcommand{\W}{\Wm}
\newcommand{\X}{\Xm}
\newcommand{\Y}{\Ym}
\newcommand{\A}{\Am}
\newcommand{\x}{\xv}
\newcommand{\Ns}{\set{N}}
\newcommand{\Ms}{\set{M}}
\newcommand{\As}{\set{N}}
\newcommand{\Bs}{\set{M}}

\def\ct{\mathrm{c}}
\def\Ct{\mathrm{C}}
\def\Lt{\mathrm{L}}
\def\Nt{\mathrm{N}}
\def\Kt{\mathrm{K}}
\def\Xt{\mathrm{X}}
\def\Yt{\mathrm{Y}}

\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sR{{\mathbb{R}}}
\def\sZ{{\mathbb{Z}}}

\def\bpsi{{\boldsymbol{\psi}}}

\newcommand{\eu}{\mathrm{e}\mkern1mu}
\newcommand{\du}{\mathrm{d}\mkern1mu}
\newcommand{\iu}{{i\mkern1mu}}
\newcommand{\ltwo}{\boldsymbol{{\rm L}^{2}}}
 
\usepackage{hyperref}
\usepackage{url}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{graphicx}
\usepackage{sidecap}
\usepackage{caption}
\usepackage{subcaption}

\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\usepackage{xfrac}

\usepackage{csquotes}
\usepackage{enumitem}

\usepackage{booktabs}
\usepackage{floatrow}
\usepackage{float}
\floatstyle{plaintop}
\restylefloat{table}
\usepackage{wrapfig}

\usepackage{MnSymbol}\usepackage{wasysym}\usepackage{multirow}
\usepackage{xspace}
\usepackage[capitalise]{cleveref}
\creflabelformat{equation}{#2#1#3}
\newcommand{\creflastconjunction}{,\nobreakspace}
\newcommand{\crefpairconjunction}{,\nobreakspace}
\def\arrvline{\hfil\kern\arraycolsep\vline\kern-\arraycolsep\hfilneg}

\font\btt=rm-lmtk10
\newcommand{\mlp}{{\btt MLP}}
\newcommand{\mlppsi}{\mlp}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\usepackage{mathtools}
\DeclarePairedDelimiterX{\norm}[1]{\lVert}{\rVert}{#1}



\DeclareMathAlphabet{\mathdutchcal}{U}{dutchcal}{m}{n}
\SetMathAlphabet{\mathdutchcal}{bold}{U}{dutchcal}{b}{n}
\DeclareMathAlphabet{\mathdutchbcal}{U}{dutchcal}{b}{n}

\usepackage{dsfont}

\usepackage{color}
\definecolor{mydarkblue}{rgb}{0,0.08,0.45}
\definecolor{mathematicablue}{rgb}{0.11, 0.25, 0.467}
\hypersetup{colorlinks,citecolor={mydarkblue},urlcolor={mydarkblue}, linkcolor={red}} 

\usepackage[ruled,vlined]{algorithm2e}



\title{\centerline{FlexConv: Continuous Kernel Convolutions} \centerline{with Differentiable Kernel Sizes}}



\author{\centerline{David W. Romero, Robert-Jan Bruintjes\thanks{Equal contribution.} ,} \\ \centerline{\textbf{Erik J. Bekkers, Jakub M. Tomczak, Mark Hoogendoorn, Jan C. van Gemert}}\\
  \hspace{0.5mm}Vrije Universiteit Amsterdam \quad \hspace{0.5mm}Delft University of Technology \quad \hspace{0.5mm}University of Amsterdam\\
  \centerline{The Netherlands}\\
  \centerline{\texttt{d.w.romeroguzman@vu.nl, r.bruintjes@tudelft.nl}}\\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\maketitle

\vspace{-2mm}
\begin{abstract}
   When designing Convolutional Neural Networks (CNNs), one must select the size\break of the convolutional kernels before training.
   Recent works show CNNs benefit from\break different kernel sizes at different layers, but exploring all possible combinations is unfeasible in practice. A more efficient approach is to learn the kernel size during training.
   However, existing works that learn the kernel size have a limited bandwidth.
   These approaches scale kernels by dilation, and thus the detail they can describe is limited.
   In this work, we propose \textit{FlexConv}, a novel convolutional operation with which high bandwidth convolutional kernels of learnable kernel size can be learned at a fixed parameter cost. \textit{FlexNets} model long-term dependencies without the use of pooling, achieve state-of-the-art performance on several sequential datasets, outperform recent works with learned kernel sizes, and are competitive with much deeper ResNets on image benchmark datasets. Additionally, FlexNets can be deployed at higher resolutions than those seen during training. To avoid aliasing, we propose a novel kernel parameterization with which the frequency of the kernels can be analytically controlled.
   Our novel kernel parameterization shows higher descriptive power and faster convergence speed than existing parameterizations. This leads to important improvements in classification accuracy.
\end{abstract}
\vspace{-3mm}
\section{Introduction}
\vspace{-1mm}
The kernel size of a convolutional layer defines the region from which features are computed, and is a crucial choice in their design. Commonly, small kernels (up to 7px) are used almost exclusively and are combined with pooling to model long term dependencies \citep{simonyan2014very, szegedy2015going, he2016deep,  tan2019efficientnet}. Recent works indicate, however, that CNNs benefit from using convolutional kernels (\emph{i}) of varying size at different layers \citep{pintea2021resolution, tomen2021deep}, and (\emph{ii}) at the same resolution of the data \citep{peng2017large,cordonnier2019relationship, romero2021ckconv}. Unfortunately, most CNNs represent convolutional kernels as tensors of discrete weights and their size must be fixed prior to training. This makes exploring different kernel sizes at different layers difficult and time-consuming due to (\textit{i}) the large search space, and (\textit{ii}) the large~number~of~weights~required~to~construct~large~kernels.

A more efficient way to tune different kernel sizes at different layers is to \textit{learn} them during training.\break
Existing methods define a \textit{discrete} weighted set of basis functions, e.g., shifted Delta-Diracs (Fig.~\ref{fig:dilated_kernel}, \citet{dai2017deformable}) or Gaussian functions (Fig.~\ref{fig:parametric_dilation}, \citet{jacobsen2016structured, Shelhamer2019BlurringTL, pintea2021resolution}). During training they learn dilation factors over the basis functions to increase the kernel size, which crucially limits the bandwidth of the resulting kernels.


In this work, we present the \textit{Flexible Size Continuous Kernel Convolution} (FlexConv), a convolutional layer able to learn \textit{high bandwidth} convolutional kernels of varying size during training (Fig.~\ref{fig:flexconv}). Instead of using discrete weights, we provide a \textit{continuous parameterization} of convolutional kernels via a small neural network \citep{romero2021ckconv}. This parameterization allows us to model continuous functions of arbitrary size with a fixed number of parameters. By multiplying the response of the neural network with a Gaussian mask, the size of the kernel can be learned during training (Fig.~\ref{fig:flexconv_kernel}). This~allows~us~to~produce~detailed~kernels~of~small~sizes~(Fig.~\ref{fig:capacity_tradeoff}),~and~tune~kernel~sizes~efficiently.


FlexConvs can be deployed at higher resolutions than those observed during training, simply by using a more densely sampled grid of kernel indices. However, the high bandwidth of the kernel can lead FlexConv to learn kernels that show aliasing at higher resolutions, if the kernel bandwidth exceeds the Nyquist frequency. 
To solve this problem, we propose to parameterize convolutional kernels as \textit{Multiplicative Anisotropic Gabor Networks} (MAGNets). MAGNets are a new class of Multiplicative Filter Networks \citep{fathony2021multiplicative} that allows us to analyze and control the frequency spectrum of the generated kernels. We use this analysis to regularize FlexConv against aliasing. With this regularization, FlexConvs can be directly deployed at higher resolutions with minimal accuracy loss. Furthermore, MAGNets provide higher descriptive power and faster convergence speed than existing continuous kernel parameterizations \citep{schutt2017schnet, finzi2020generalizing, romero2021ckconv}. This leads to important improvements in classification accuracy (Sec.~\ref{sec:experiments}).




Our experiments show that CNNs with FlexConvs, coined \textit{FlexNets}, achieve state-of-the-art across several sequential datasets, match performance of recent works with learnable kernel sizes with less compute, and are competitive with much deeper ResNets \citep{he2016deep} when applied on image benchmark datasets. Thanks to the ability of FlexConvs to generalize across resolutions, FlexNets can be efficiently trained at low-resolution to save compute, e.g.,  CIFAR images, and be deployed on the original data resolution with marginal accuracy loss, e.g.,  CIFAR images.\begin{figure}[t]
    \centering
\includegraphics[width=0.88\textwidth]{images/flexconv-with-indices.png}
    \vspace{-3mm}
    \caption{The Flexible Size Continuous Kernel Convolution (FlexConv). FlexConv defines convolutional kernels as the multiplication of a continuous convolutional kernel \mlppsi, with a Gaussian mask of local support : . By learning the parameters of the mask, the size of the convolutional kernel can be optimized during training. See also Fig.~\ref{fig:app-flexconvexample}.
    \vspace{-2mm}}
    \label{fig:flexconv}
\end{figure}

In summary, our \textbf{contributions} are:
\begin{itemize}[topsep=0pt, leftmargin=*]
    \item We introduce the \textit{Flexible Size Continuous Kernel Convolution} (FlexConv), a convolution operation able to learn \emph{high bandwidth} convolutional kernels of varying size end-to-end. 
    \item Our proposed \textit{Multiplicative Anisotropic Gabor Networks} (MAGNets) allow for analytic control of the properties of the generated kernels. This property allows us to construct analytic alias-free convolutional kernels that generalize to higher resolutions, and to train FlexNets at low resolution and deploy them at higher resolutions. Moreover, MAGNets show higher descriptive power and faster convergence speed than existing kernel parameterizations.
    \item CNN architectures with FlexConvs (FlexNets) obtain state-of-the-art across several sequential datasets, and match recent works with learnable kernel size on CIFAR-10 with less compute.
\end{itemize}
\vspace{-2mm}
\section{Related Work}
\vspace{-2mm}
\textbf{Adaptive kernel sizes.} \citet{loog2017supervised} regularize the scale of convolutional kernels for filter learning. For image classification, adaptive kernel sizes have been proposed via learnable pixel-wise offsets \citep{dai2017deformable}, learnable padding operations \citep{Han_2018_CVPR}, learnable dilated Gaussian functions \citep{Shelhamer2019BlurringTL, Xiong_2020_CVPR, tabernik2020spatially, nguyen2020robust} and scalable Gaussian derivative filters \citep{pintea2021resolution, tomen2021deep, lindeberg2021scale}.
These approaches either dilate discrete kernels (Fig.~\ref{fig:dilated_kernel}), or use discrete weights on dilated basis functions (Fig.~\ref{fig:parametric_dilation}). Using dilation crucially limits the bandwidth of the resulting kernels. In contrast, FlexConvs are able to construct high bandwidth convolutional kernels of varying size with a fixed parameter count. 
Larger kernels are obtained simply by passing more positions to the kernel network (Fig.~\ref{fig:flexconv}). 

\textbf{Continuous kernel convolutions.} Discrete convolutional kernel parameterizations assign an independent weight to each specific position in the kernel. Continuous convolutional kernels, on the other hand, view convolutional kernels as continuous functions parameterized via a small neural network \mlppsi, with  the data dimensionality. This defines a convolutional kernel for which arbitrary input positions can be queried. Continuous kernels have primarily been used to handle irregularly-sampled data \textit{locally}, e.g., molecular data \citep{simonovsky2017dynamic, schutt2017schnet} and point-clouds \citep{thomas2018tensor, wang2018deep, shi2019points}. 

Recently, \citet{romero2021ckconv} introduced the Continuous Kernel Convolution (CKConv) as a tool to model long-term dependencies. CKConv uses a continuous kernel parameterization to construct convolutional kernels as big as the input signal with a constant parameter cost. Contrarily, FlexConvs jointly learn the convolutional kernel as well as its size. This leads to important advantages in terms of~expressivity~(Fig.~\ref{fig:capacity_tradeoff}),~convergence~speed~and~compute~costs~of~the~operation.
\begin{figure}
\vspace{-2mm}
    \centering
     \begin{subfigure}[c]{0.28\textwidth}
         \centering
         \vspace{-4mm}
         \includegraphics[width=\textwidth]{images/flexconv_kernelincrease.png}
         \caption{FlexConv kernels (ours)}
         \label{fig:flexconv_kernel}
     \end{subfigure}
     \hfill
     \begin{subfigure}[c]{0.28\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/dilated_kernelincrease.png}
         \caption{Dilation / deformation\newline \citep{dai2017deformable}}
         \label{fig:dilated_kernel}
     \end{subfigure}
     \hfill
      \begin{subfigure}[c]{0.36\textwidth}
     \centering
     \includegraphics[width=\textwidth]{images/steerable_kernelincrease.png}
     \caption{(Learnable) parametric dilation\newline \citep{pintea2021resolution}}
     \label{fig:parametric_dilation}
     \end{subfigure}
    \vspace{-2.5mm}
    \caption{Existing approaches increase the size of convolutional kernels via (learnable) parametric dilations, e.g., by deformation (b) or by Gaussian blur (c). However, dilation limits the bandwidth of the dilated kernel and with it, the amount of detail it can describe. Contrarily, FlexNets extend their kernels by passing a larger vector of positions to the neural network parameterizing them. As a result, FlexConvs are able to learn \textit{high bandwidth} convolutional kernels of varying size end-to-end (a).
    \vspace{-3.5mm}}
    \label{fig:dilations}
\end{figure}
\begin{figure}
    \centering
     \begin{subfigure}[c]{0.267\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/gt_approx.png}
         \caption{Ground Truth}
         \label{fig:gt_approx}
     \end{subfigure}
     \hspace{3.5mm}
     \begin{subfigure}[c]{0.677\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/approximations.png}
         \caption{Reconstructions at varying degrees of localization}
         \label{fig:ckernel_approx}
     \end{subfigure}
     \vspace{-2mm}
     \caption{\label{fig:capacity_tradeoff} The importance of dynamic sizes in continuous kernel convolutions. Consider a neural network predicting pixel values at each position. If the entire image is considered, the network must use part of its capacity to learn to predict zeros outside of the flower region, which in turn degrades the\break quality of the approximation in the region of interest (b). Importantly, the better the localization of the flower, the higher the approximation fidelity becomes. FlexNets learn the size of their convolutional kernels at each layer during training, and thus \emph{(i)} use the capacity of the kernel efficiently, \emph{(ii)} converge faster to good approximations, and \emph{(iii)} are faster in execution --via dynamic cropping--.
     \vspace{-3mm}}
\end{figure}

\textbf{Implicit neural representations.} Parameterizing a convolutional kernel via a neural network can be seen as learning an implicit neural representation of the underlying convolutional kernel \citep{romero2021ckconv}. Implicit neural representations construct continuous data representations by encoding data in the weights of a neural network \citep{park2019deepsdf, sitzmann2020implicit, fathony2021multiplicative}. 

We replace the SIREN \citep{sitzmann2020implicit} kernel parameterization used in \cite{romero2021ckconv} by our \textit{Multiplicative Anisotropic Gabor Networks}: a new class of Multiplicative Filter Networks \citep{fathony2021multiplicative}. MFNs allow for analytic control of the resulting representations, and allow us to construct analytic alias-free convolutional kernels. The higher expressivity and convergence speed of MAGNets lead to accuracy improvements in CNNs using them as kernel parameterization.\vspace{-2mm}
\section{Method}
\vspace{-2mm}
In this section, we introduce our approach. First, we introduce FlexConv and the Gaussian mask. Next, we introduce our Multiplicative Anisotropic Gabor Networks (MAGNets) and provide a description of our regularization technique used to control the spectral components of the generated kernel.
\vspace{-2mm}
\subsection{Flexible Size Continuous Kernel Convolution (FlexConv)}
\label{sec:flexconv}
\vspace{-2mm}
To learn the kernel size during training, FlexConvs define their convolutional kernels  as the product of the output of a neural network \mlppsi\ with a Gaussian mask of local support. The neural network \mlppsi\ parameterizes the kernel, and the Gaussian mask parameterizes its size (Fig.~\ref{fig:flexconv}).

\textbf{Anisotropic Gaussian mask.} Let  
be a Gaussian function parameterized by a mean-variance tuple . The anisotropic Gaussian mask is defined as:

By learning  and  independently, anisotropic non-centered windows can be learned.


\vspace{-2mm}
\subsection{Multiplicative Anisotropic Gabor Networks (MAGNets)}
\label{sec:magnets}
\vspace{-2mm}
In this section, we formalize our proposed parameterization for the kernel \mlppsi. We start by introducing Multiplicative Filter Networks \citep{fathony2021multiplicative}, and present our MAGNets next.

\textbf{Multiplicative Filter Networks (MFNs).} Recently, \citet{fathony2021multiplicative} proposed to construct implicit neural representations as the linear combination of exponentially many basis functions :
\vspace{-0.5mm}

\vspace{-5.5mm}

where ,  depict the learnable parameters of the bases and the affine transformations, and  depict the number of output and hidden channels, respectively. Depending on the selection of , MFNs obtain approximations comparable to those of SIRENs \citep{sitzmann2020implicit} with faster convergence rate. The most successful instantiation of MNFs are the \textit{Multiplicative Gabor Network} (MGN): MFNs constructed with isotropic Gabor functions as basis  (in Eq.~\ref{eq:mfn}):
\vspace{-1mm}

Note that, by setting , an MFN can parameterize a convolutional kernel with  input and  output channels.
\citet{fathony2021multiplicative} show that MFNs are equivalent to a linear combination of exponentially many basis functions . This allows us to analytically derive properties of MFN representations, and plays a crucial role in the derivation of alias-free MAGNets (Sec.~\ref{sec:crtraining}).

\textbf{Multiplicative Anisotropic Gabor Networks (MAGNets).} Our MAGNet formulation is based on the observation that isotropic Gabor functions, i.e., with equal  for the horizontal and vertical directions, are undesirable as basis for the construction of MFNs. Whenever a frequency is required along a certain direction, an isotropic Gabor function automatically introduces that frequency in both directions. As a result, other bases must counteract this frequency in the direction where the frequency is not required, and thus the capacity of the MFN is not used optimally \citep{daugman1988complete}. 

Following the original formulation of the 2D Gabor functions \citep{daugman1988complete}, we alleviate this limitation by using anisotropic Gabor functions instead:\vspace{-0.5mm}

\vspace{-5.5mm}

The resulting \textit{Multiplicative Anisotropic Gabor Network} (MAGNet) obtains better control upon frequency components introduced to the approximation, and demonstrates important improvements in terms of descriptive power and convergence speed (Sec.~\ref{sec:experiments}).

\textbf{MAGNet initialization.} \citet{fathony2021multiplicative} proposes to initialize MGNs by drawing the size of the Gaussian envelopes, i.e., the  term, from a  distribution at every layer . We observe however that this initialization does not provide much variability on the initial extension of the Gaussian envelopes and in fact, most of them cover a large portion of the space at initialization.
To stimulate diversity, we initialize the  terms by a  distribution at the -th layer. We observe that our proposed initialization consistently leads to better accuracy than the initialization of \cite{fathony2021multiplicative} across all tasks considered. (Sec.~\ref{sec:experiments}).
\vspace{-1mm}
\subsection{Analytic Alias-free MAGNets}
\label{sec:crtraining}
\vspace{-1mm}
FlexConvs can be deployed at higher resolutions than those observed during training, simply by sampling the underlying continuous representation of the kernel more densely, and accounting for the change in sampling rate. Consider a -dimensional input signal  with resolution . FlexConv learns a kernel  that can be inferred at a higher resolution  \citep{romero2021ckconv}:  

Note however, that Eq.~\ref{eq:multires} holds \textit{approximately}. This is due to aliasing artifacts which can appear if the frequencies in the learned kernel surpass the Nyquist criterion of the target resolution. Consequently, an anti-aliased parameterization is vital to construct kernels that generalize well to high resolutions.

\textbf{Towards alias-free implicit neural representations.} We observe that SIRENs as well as unconstrained MFNs and MAGNets exhibit aliasing when deployed on resolutions higher than the training resolution, which hurts performance of the model. An example kernel with~aliasing~is~shown~in~Fig.~\ref{fig:app-cifar10kernelfrequencies}.


To combat aliasing, we would like to control the representation learned by MAGNets. MAGNets --and MFNs in general-- construct implicit neural representations that can be seen as a \textit{linear combination of basis functions}. This property allows us to analytically derive and study the properties of the resulting neural representation. Here, we use this property to derive the maximum frequency of MAGNet-generated kernels, so as to regularize MAGNets against aliasing during training. We analytically derive the maximum frequency of a MAGNet, and penalize it whenever it exceeds the Nyquist frequency of the training resolution. We note that analytic derivations are difficult for other implicit neural representations, e.g., SIRENs, due to stacked layer-wise nonlinearities. 

\textbf{Maximum frequency of MAGNets.}
The maximum frequency component of a MAGNet~is~given~by:

where  corresponds to the number of layers,  to the MAGNet parameters as defined in Eq.~\ref{eq:params_anisotropicgaussian}, and  to the cut-off frequency of the Gaussian envelopes in the Gabor filters. A formal treatment as well as the derivations can be found in Appx.~\ref{sec:magnetanalysis}.


\textbf{Effect of the FlexConv mask.} The Gaussian mask used to localize the response of the MAGNet 
also has an effect on the frequency spectrum. Hence, the maximum frequency of a FlexConv kernel is:

Here,  correspond to the mask parameters (Eq.~\ref{eq:gaussianmask}). Intuitively, multiplication with the mask blurs in the frequency domain, as it is equivalent to~convolution~with~the~Fourier~transform~of~the~mask.

\textbf{Aliasing regularization of FlexConv kernels.} With the analytic derivation of  we penalize the generated kernels to have frequencies smaller or equal to their Nyquist frequency  via:

Here,  depicts the size of the FlexConv kernel before applying the Gaussian mask, and is equal to the size of the input signal. In practice, we implement Eq.~\ref{eq:regularizeflexconv} by regularizing the individual MAGNet layers, as is detailed in Appx.~\ref{sec:magnetreg}. To verify our method, Fig.~\ref{fig:app-cifar10kernelfrequencies} (Appx.~\ref{sec:magnetanalysis}) shows that the frequency components of FlexNet kernels are properly regularized for aliasing.
\vspace{-2mm}
\section{Experiments}\label{sec:experiments}
\vspace{-2mm}
We evaluate FlexConv across classification tasks on sequential and image benchmark datasets, and validate the ability of MAGNets to approximate complex functions. A complete description of the datasets used is given in Appx.~\ref{sec:datasets}. Appx.~\ref{sec:flexnet-optimization} reports the parameters used in all our experiments.\footnote{Our code is publicly available at \url{https://github.com/rjbruin/flexconv}.}
\vspace{-2mm}
\subsection{What kind of functions can MAGNets approximate?}
\label{sec:type1-experiment}
\vspace{-2mm}
\begin{figure}
    \centering
     \begin{subfigure}[c]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/type1-gabor.pdf}
\label{fig:exp-type1-gabor-graph}
     \end{subfigure}
     \hfill
     \begin{subfigure}[c]{0.49\textwidth}
         \centering
         \vspace{-8mm}
\includegraphics[width=\textwidth]{images/type1-allfunctions.pdf}
\label{fig:exp-type1-gabor-kernels}
     \end{subfigure}
     \hfill
    \vspace{-9mm}
    \caption{\textit{Left}: Final MSE after fitting each model to Gabor filters of different frequencies. N-Jets cannot fit high frequencies. \textit{Right}: Kernels learned by each model. SIREN and MAGNet can fit all targets. MAGNet-S: a small MAGNet of size akin to N-Jets, still does well on the~Gabor~and~AlexNet~targets.
    \vspace{-7mm}}
    \label{fig:exp-type1-gabor}
\end{figure}
\textbf{Bandwidth of methods with learnable sizes.} First, we compare the bandwidth of MAGNet against N-Jet \citep{pintea2021resolution} by optimizing each to fit simple targets: (i) Gabor filters of known frequency, (ii) random noise and (iii) an a  AlexNet kernel from the first layer \citep{krizhevsky_imagenet_2012}.\break
Fig.~\ref{fig:exp-type1-gabor} shows that, even with 9 orders of Gaussian derivatives, N-Jets cannot fit high frequency signals in large kernels. Crucially, N-Jet models require many Gaussian derivative orders to model high frequency signals in large kernels: a hyperparameter which proportionally increases their inference time and parameter count. MAGNets, on the other hand, accurately model large high frequency signals. This allows FlexNets to learn large kernels with high frequency components.

\textbf{Expressivity of \mlp\ parameterizations.} Next, we compare the descriptive power and convergence speed of MAGNets, Gabor MFNs, Fourier MFNs and SIRENs for image approximation. To this end, we fit the images in the Kodak dataset \citep{kodak1991} with each of these methods. Our results (Tab.~\ref{tab:kodak-results}) show that MAGNets outperform all other methods, and converge faster to good approximations.\vspace{-2mm}
\subsection{Classification Tasks}
\label{sec:classification}
\vspace{-2mm}
\begin{table}
\centering
\caption{Test accuracy and ablation studies on sMNIST, pMNIST, sCIFAR10 and npCIFAR10.}
\label{tab:smnist}
\vspace{-2.5mm}
\begin{small}
\scalebox{0.75}{
\begin{tabular}{cccccc}
\toprule
\sc{Model} & \sc{Size} & \sc{sMNIST} & \sc{pMNIST} & \sc{sCIFAR10} & \sc{npCIFAR10} \\
 \midrule
 DilRNN \citep{chang2017dilated} & 44\sc{k} & 98.0 & 96.1 & - & -\\
  IndRNN \citep{li2018independently} & 83\sc{k} & 99.0 & 96.0& - & - \\
TCN \citep{bai2018empirical} &70\sc{k}& 99.0 & 97.2  & - & - \\
  r-LSTM \citep{trinh2018learning} & 0.5\sc{m} & 98.4 & 95.2 & 72.2 & -\\
 Self-Att. \citep{trinh2018learning} &0.5\sc{m} & 98.9 & 97.9 & 62.2 & -\\
 TrellisNet \citep{bai2018trellis}& 8\sc{m} & 99.20 & 98.13 & 73.42 & - \\
 URLSTM \citep{gu2020improving} & - & 99.28 & 96.96 & 71.00 & - \\
  URGRU + Zoneout \citep{gu2020improving} & - & 99.27 & 96.51 & \textbf{74.40} & - \\
  HiPPO \citep{gu2020hippo} & 0.5\sc{m} & - & \textbf{98.30} & - & - \\
  Lipschitz RNN \citep{erichson2020lipschitz} & 158\sc{k} & 99.4 & 97.3 & 64.2 & 59.0 \\
  coRNN \citep{rusch2020coupled} & 134\sc{k} & \textbf{99.4} & 97.3 & - & 59.0 \\
  UnICORNN \citep{rusch2021unicornn} & 135\sc{k} & - & 98.4 & - & \textbf{62.4} \\
  pLMU \citep{chilkuri2021parallelizing} & 165\sc{k} & - & 98.49 & - & -\\
\midrule
CKCNN-2 & 98\sc{k} & 99.31 & 98.00 & 62.25 & 60.5\\
CKCNN-2-Big & 1\sc{m} & 99.32 & 98.54 & 63.74 & 62.2 \\
CKTCN-2 & 105\sc{k} & 99.44 & 98.40 & 68.28 & 66.26 \\
CKTCN-2 & 106\sc{k} & 99.52 & 98.38 & 69.26 & 67.37 \\
CKTCN-2 & 105\sc{k} & \textbf{99.55} &\textbf{ 98.57} & \textbf{74.58} & \textbf{67.52} \\
\midrule
FlexTCN-2 & 108\sc{k} & \textbf{99.60} & \textbf{98.61} & \textbf{78.99} &  \textbf{67.11}\\
FlexTCN-4 &  241\sc{k} & \textbf{99.60} & \textbf{98.72} & \textbf{80.26} & \textbf{67.42}\\
FlexTCN-6 & 375\sc{k} & \textbf{99.62} &  \textbf{98.63} & \textbf{80.82} & \textbf{69.87} \\
\midrule
FlexTCN-6 & 343\sc{k} & 99.03 & 95.36 & 69.24 & 57.27 \\
FlexTCN-6 & 370\sc{k} & 99.49 & 97.97 & 74.79 & 67.35 \\
FlexTCN-6 & 373\sc{k} &  99.50 & 98.37 & 78.36 & 67.56 \\
FlexTCN-6 & 375\sc{k} & \textbf{99.62} &  \textbf{98.63} & \textbf{80.82} & \textbf{69.87} \\
\bottomrule
\end{tabular}}
\end{small}
\vspace{-4mm}
\end{table}

\textbf{Network specifications.} Here, we specify our networks for all our classification experiments. We parameterize all our convolutional kernels as the superposition of a 3-layer MAGNet and a learnable anisotropic Gaussian mask. We construct two network instances for sequential and image datasets respectively: FlexTCNs and FlexNets. Both are constructed by taking the structure of a baseline network --TCN \citep{bai2018empirical} or CIFARResNet \citep{he2016deep}--, removing all internal pooling layers, and replacing convolutional kernels by FlexConvs. The FlexNet architecture is shown in Fig.~\ref{fig:flexnet-architecture} and varies only in the number of channels and blocks, e.g., FlexNet-16 has 7 blocks. Akin to \cite{romero2021ckconv} we utilize the Fourier theorem to speed up convolutions with large kernels.



\textbf{Mask initialization.} We initialize the FlexConv masks to be small. Preliminary experiments show this leads to better performance, faster execution, and faster training convergence. For sequences, the mask center is initialized at the last kernel position to prioritize the last information seen.

\textbf{Time series and sequential data.} First we evaluate FlexTCNs on sequential classification datasets, for which long-term dependencies play an important role. 
We validate our approach on intrinsic discrete data: \textit{sequential MNIST}, \textit{permuted MNIST} \citep{le2015simple}, \textit{sequential CIFAR10} \citep{chang2017dilated}, \textit{noise-padded CIFAR10} \citep{chang2019antisymmetricrnn}, as well as time-series data: \textit{CharacterTrajectories} (CT) \citep{bagnall2018uea}, \textit{SpeechCommands} \citep{warden2018speech} with raw waveform (SC\_raw) and MFCC input representations (SC).

Our results are summarized in Tables~\ref{tab:smnist}~and~\ref{tab:time-series}. FlexTCNs with two residual blocks obtain state-of-the-art results on all tasks considered. In addition, depth further improves performance. FlexTCN-6 improves the current state-of-the-art on sCIFAR10 and npCIFAR10 by more than 6\%. On the difficult SC\_raw dataset --with sequences of length 16000--, FlexTCN-6 outperform the previous state-of-the-art by 20.07\%: a remarkable improvement.

\begin{table}
\RawFloats
\centering
\begin{minipage}{0.48 \textwidth}
\centering
\caption{Test accuracy on CT, SC and SC\_raw}
\label{tab:time-series}
\vspace{-2mm}
\begin{small}
\scalebox{0.75}{
\begin{tabular}{ccccc}
\toprule
\sc{Model} & \sc{Size} & \sc{CT} & \sc{SC} & \sc{SC\_raw} \\
\midrule
GRU-ODE & 89\sc{k} & 96.2 & 44.8 & 10.0 \\
GRU- & 89\sc{k} & 97.8 & 20.0 & 10.0 \\
GRU-D & 89\sc{k} & 95.9 & 23.9 & 10.0 \\
ODE-RNN & 89\sc{k} & 97.1 & 93.2 & 10.0 \\
NCDE  & 89\sc{k} & 98.8 & 88.5 & 10.0 \\
\midrule
CKCNN & 100\sc{k} &\textbf{ 99.53 }& 95.27 & 71.66 \\
CKTCN & & - & 95.65 & 74.90 \\
CKTCN &  & - & 96.66 &  78.10 \\
CKTCN & 105\sc{k} &  \textbf{99.53} & \textbf{97.01} & \textbf{80.69} \\
\midrule
FlexTCN-2 & 105\sc{sk} & \textbf{99.53} & \textbf{97.10} & \textbf{88.03}  \\
FlexTCN-4 & 239\sc{k} & \textbf{99.53} & \textbf{97.73} & \textbf{90.45}   \\
FlexTCN-6 & 373\sc{k} & \textbf{99.53} & \textbf{97.67} & \textbf{91.73} \\
\midrule
FlexTCN-6 & 370\sc{k} & - & 95.83 & 85.73\\
FlexTCN-6 & 342\sc{k} & - & 97.62 & 91.02 \\
FlexTCN-6 & 373\sc{k} & - & 97.35 & 91.50 \\
FlexTCN-6 & 373\sc{k} & - & \textbf{97.67} & \textbf{91.73} \\
\bottomrule
\end{tabular}}
\end{small}
\end{minipage}\hfill
\begin{minipage}{0.50 \textwidth}
\centering
\caption{Results on CIFAR-10. Results from *original works and  single run.}
\label{tab:cifar-10}
\vspace{-2mm}
\begin{small}
\scalebox{0.75}{
\begin{tabular}{cccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} & \sc{CIFAR-10} & \sc{Time} \\
    & & \sc{Acc.} & \sc{(sec/epoch)}\\ \midrule
    CIFARResNet-44 & 0.66\sc{m} & 92.9*\!\dagger & 22 \\
    DCN- & 0.47\sc{m} & 89.7  0.3* & - \\
    N-Jet-CIFARResNet32 & 0.52\sc{m} & 92.3  0.3* & - \\
    N-Jet-ALLCNN & 1.07\sc{m} & 92.5  0.1* & - \\ \midrule
    FlexNet-16 w/ conv. () & 0.17\sc{m} & 89.5  0.3 & 41   \\
    FlexNet-16 w/ conv. () & 20.0\sc{m} & 78.0  0.3 & 242  \\
    FlexNet-16 w/ N-Jet & 0.70\sc{m} & 91.7  0.1 & 409  \\ \midrule
CKCNN-16 & 0.63\sc{m} & 72.1  0.2 & 68 \\ CKCNN-16 & 0.67\sc{m} &  86.8  0.6  & 102 \\ FlexNet-16 & 0.63\sc{m} & 89.0  0.3  & 89 \\ FlexNet-16 & 0.67\sc{m} & 91.9  0.2 & 161 \\ \midrule FlexNet-16 + anis. Gauss. & 0.67\sc{m} & 92.0  0.1 & 147 \\
    FlexNet-16 + Gabor init. & 0.67\sc{m} & 92.0  0.2 & 150 \\
    \midrule
    FlexNet-16 & 0.67\sc{m} & 92.2  0.1 & 127 \\
 \bottomrule
\end{tabular}}
\end{small}
\end{minipage}
\vspace{-8mm}
\end{table}

Furthermore, we conduct ablation studies by changing the parameterization of \mlppsi, and switching off the learnable kernel size ("CKTCNs") and considering global kernel sizes instead. CKTCNs and FlexTCNs with MAGNet kernels outperform corresponding models with all other kernel parameterizations: SIRENs \citep{sitzmann2020implicit}, MGNs and MFNs \citep{fathony2021multiplicative}. Moreover, we see a consistent improvement with respect to CKCNNs \citep{romero2021ckconv} by using learnable kernel sizes. This shows that both MAGNets and learnable kernel sizes contribute to the performance of FlexTCNs.
Note that in 1D, MAGNets are equivalent to MGNs. However, MAGNets consistently perform better than MGNs. This improvement in accuracy is a result of our MAGNet initialization.


\textbf{Image classification.}
Next, we evaluate FlexNets for image classification on CIFAR-10 \citep{krizhevsky2009learning}.  Additional experiments on Imagenet-32, MNIST and STL-10 can be found in Appx.~\ref{sec:appx-experiments}.

Table~\ref{tab:cifar-10} shows our results on CIFAR-10. 
FlexNets are competitive with pooling-based methods such as CIFARResNet 
\citep{he2016deep} and outperform learnable kernel size method DCNs \citep{tomen2021deep}.
In addition, we compare using N-Jet layers of order three (as in \citet{pintea2021resolution}) in FlexNets against using MAGNet kernels. We observe that N-Jet layers lead to worse performance, and are significantly slower than FlexConv layers with MAGNet kernels. The low accuracy of N-Jet layers is likely to be linked to the fact that FlexNets do not use pooling. Consequently, N-Jets are forced to learn large kernels with high-frequencies, which we show N-Jets struggle learning~in~Sec.~\ref{sec:type1-experiment}.

To illustrate the effect of learning kernel sizes, we also compare FlexNets against FlexNets with large and small discrete convolutional kernels (Tab.~\ref{tab:cifar-10}).
Using small kernel sizes is parameter efficient, but is not competitive with FlexNets. Large discrete kernels on the other hand require a copious amount of parameters and lead to significantly worse performance. These results indicate that the best solution is somewhere in the middle and varying kernel sizes can~learn~the~optimal~kernel~size~for~the~task~at~hand.


Similar to the sequential case, we conduct ablation studies on image data with learnable, non-learnable kernel sizes and different kernel parameterizations. Table~\ref{tab:cifar-10} shows that FlexNets outperform CKCNNs with corresponding kernel parameterizations. In addition, a clear difference in performance is apparent for MAGNets with respect to other parameterizations. These results corroborate that both MAGNets and FlexConvs contribute to the performance of FlexNets. Moreover, Tab.~\ref{tab:cifar-10} illustrates the effect of the two contributions of MAGNet over MGN: anisotropic Gabor filters, and our improved initialization. Our results in image data are in unison with our previous results for sequential data (Tabs.~\ref{tab:smnist},~\ref{tab:time-series}) and illustrate the value of the proposed improvements in MAGNets.
\vspace{-2mm}
\subsection{Alias-free FlexNets}
\label{sec:crossresexperiments}
\vspace{-1mm}
\begin{figure}[t]
        \centering
    \includegraphics[width=\textwidth]{images/cifar-10-crossres-rebuttal.pdf}
    \vspace{-6mm}
    \caption{Alias-free FlexNet-16 on CIFAR-10. We report change in accuracy between source and target resolutions, directly after upsampling (left) and after fine-tuning (right) (means over five runs).
    \vspace{-5mm}}
    \vspace{-2mm}
    \label{fig:c10-crossres}
\end{figure}

\textbf{Regularizing the FlexConv mask.} Though including  in the frequency analysis of MAGNets is crucial for the accuracy of the derivation, including the FlexConv mask in aliasing regularization is undesirable, as it steers the model to learn large kernels in order to minimize the loss (see Eq.~\ref{eq:regularizeflexconv}). However, excluding the mask from regularization could compromise the ability of FlexNet to generalize to higher resolutions. Here, we experiment with this trade-off.

\newlength{\oldintextsep}
\setlength{\oldintextsep}{\intextsep}

\setlength\intextsep{0pt}
\begin{wraptable}{r}{7.4cm}
\centering
\caption{Alias-free FlexNets on CIFAR-10.}
\label{tab:crossres}
\vspace{-5mm}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{cccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} & \multicolumn{2}{c}{\sc{CIFAR-10 Acc.}} \\
    & & 16 px &  32 px \\ \midrule CIFARResNet-44 & 0.66\sc{m} & 85.8  0.2 & -31.6  1.3 \\ \midrule
FlexNet-16 w/ conv. () & 0.17\sc{m} & 85.3  0.2 & -21.2  1.0 \\ FlexNet-16 w/ conv. () & 20.0\sc{m} & 67.7  0.6 & -57.1  1.6 \\ FlexNet-16 w/ N-Jets & 0.70\sc{m} & \textbf{86.4}  0.2 & -5.5  1.3 \\ \midrule CKCNN-16 & 0.63\sc{m} & 45.9  1.0 & -15.8  1.2 \\
    FlexNet-16 & 0.63\sc{m} & 70.4  0.8 & -50.0  16.9 \\ \midrule
    FlexNet-16 w/o reg. & 0.67\sc{m} & \textbf{86.4}  0.4 & -34.4  14.3 \\ \midrule FlexNet-16 w/ reg.  & 0.67\sc{m} & \textbf{86.5}  0.1 & -3.8  2.0 \\ FlexNet-16 w/ reg.  & 0.67\sc{m} & 85.1  0.3 & \textbf{-3.3}  0.3 \\ \bottomrule
\end{tabular}}
\end{center}
\vspace{-2mm}
\end{wraptable}

Figure~\ref{fig:c10-crossres} shows accuracy change between ten source and target resolution combinations on CIFAR-10, both for including and excluding the FlexConv mask in the aliasing regularization. We train at the source resolution for 100 epochs, before testing the model at the target resolution with the upsampling described in Sec.~\ref{sec:crtraining}. Next, we adjust  to the target resolution, and finetune each model for 100 epochs at the target resolution.

We find that regularizing just  yields a trade-off. It increases the accuracy difference between low and high resolution inference, but also increases the fine-tune accuracy at the target resolution.We therefore choose to, by default, regularize  only.


Results of our alias-free FlexNet training on CIFAR-10 are in Table~\ref{tab:crossres}. We observe that the performance of a FlexNet trained without aliasing regularization largely breaks down when the dataset is upscaled. 
However, with our aliasing regularization most of the performance is retained. 

Comparatively, FlexNet retains more of the source resolution performance than FlexNets with N-Jet layers, while baselines degrade drastically at the target resolution. Fig.~\ref{fig:app-cifar10kernelfrequencies} shows the effect of aliasing regularization on the frequency components of FlexConv.

\textbf{Training at lower resolutions saves compute.} We can train alias-free FlexNets at lower resolutions. To verify that this saves compute, we time the first 32 batches of training a FlexNet-7 on CIFAR-10. We compare against training on  images (downsampled before training). On 16x16 images, each batch takes 179ms ( 7ms). On 32x32 images, each batch takes 222ms ( 9ms). Therefore, we save 24\% training time when training FlexNets alias-free at half the native CIFAR-10 resolution.
\vspace{-2mm}
\section{Discussion}
\label{sec:discussion}
\vspace{-2mm}
\textbf{Learned kernel sizes match conventional priors.} Commonly, CNNs use architectures of small kernels and pooling layers. This allows convolutions to build a progressively growing receptive field. With learnable kernel sizes, FlexNet could learn a different prior over receptive fields, e.g., large kernels first, and small kernels next. However, FlexNets learn to increase kernel sizes progressively (Fig.~\ref{fig:c10-kernels}), and match the network design that has been popular since AlexNet \citep{krizhevsky_imagenet_2012}.

\textbf{Mask initialization as a prior for feature importance.} The initial values of the FlexConv mask can be used to prioritize information at particular input regions. For instance, initializing the center of mask on the first element of sequential FlexConvs can be used to prioritize information from the far past. This prior is advantageous for tasks such as npCIFAR10. We observe that using this prior on npCIFAR10 leads to much faster convergence and better results (68.33\% acc. w/ FlexTCN-2).

\textbf{MAGNet regularization as prior induction.} MAGNets allow for analytic control of the properties of the resulting representations. We use this property to generate alias-free kernels. However, other desiderata could be induced, e.g., smoothness, for the construction of implicit neural representations. 
\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{images/kernel_sizes_flexnet.pdf}
    \vspace{-8mm}
    \caption{Learned FlexConv masks for FlexNets with 3, 5 and 7 residual blocks. FlexNets learn very small kernels at shallow layers, which become larger as a function of depth.
    \vspace{-4mm}}
    \label{fig:c10-kernels}
\end{figure}

\textbf{Benefits of cropping and the influence of {\btt PyTorch}.} Dynamic cropping adjust the computational cost of the convolutions on the fly. For a signal of size  and a cropped kernel size , this incurs in savings from  to  relative to using global kernel sizes~(~to~~in~2D).
We test this theoretical speed up in a controlled environment for the Speech Commands and CIFAR-10 datasets. Cropping reduces the per-epoch run time by a factor of 11.8 and 5.5 for Speech Commands and CIFAR-10, respectively. Interestingly, however, both run times become similar if the flag {\btt torch.backends.cudnn.benchmark} is activated, with global kernel sizes being sometimes faster. This is because this flag tells {\btt PyTorch} to optimize the convolution algorithms used under the hood, and some of these CUDA algorithms seem to be faster than our masking strategy on {\btt Python}.
\vspace{-2mm}
\section{Limitations}
\label{sec:limitations}
\vspace{-2mm}
\textbf{Dynamic kernel sizes: computation and memory cost of convolutions with large kernels.} Performing convolutions with large convolutional kernels is a compute-intensive operation. FlexConvs are initialized with small kernel sizes and their inference cost is relatively small at the start of training. However, despite the cropping operations used to improve computational efficiency (Figs.~\ref{fig:flexconv},~\ref{fig:capacity_tradeoff}, Tab.~\ref{tab:cifar-10}), the inference time may increase to up to double as the learned masks increase in size. At the cost of more memory, convolutions can be sped up by performing them in the frequency domain. However, we observe that this does not bring gains for the image data considered because FFT convolutions are faster only for very large convolutional kernels (in the order of hundreds of pixels).



\textbf{Remaining accuracy drop in alias-free FlexNets.} Some drop in accuracy is still observed when using alias-free FlexNets at a higher test resolutions (Tab.~\ref{tab:crossres}). Although more evidence is needed, this may be caused by aliasing effects introduced by  \citep{vasconcelos2021impact}, or changes in the activation statistics of the feature maps passed to global average pooling \citep{Touvron2019FixingTT}.
\vspace{-2mm}
\section{Conclusion}
\vspace{-2mm}
We propose FlexConv, a convolutional operation able to learn high bandwidth convolutional kernels\break of varying size during training at a fixed parameter cost. We demonstrate that FlexConvs are able to model long-term dependencies without the need of pooling, and shallow pooling-free FlexNets achieve state-of-the-art performance on several sequential datasets, match performance of recent works with learned kernel sizes with less compute, and are competitive with much deeper ResNets on image benchmark datasets. In addition, we show that our alias-free convolutional kernels allow FlexNets to be deployed at higher resolutions than seen during training with minimal precision loss.


\textbf{Future work.} MAGNets give control over the bandwidth of the kernel. We anticipate that this control has more uses, such as fighting sub-sampling aliasing \citep{zhang2019making,Kayhan_2020_CVPR,karras2021alias}. With the ability to upscale FlexNets to different input image sizes comes the possibility of transfer learning representations between previously incompatible datasets, such as CIFAR-10 and Imagenet.
In a similar vein, the automatic adaptation of FlexConv to the kernel sizes required for the task at hand may make it possible to generalize the FlexNet architecture across different tasks and datasets. Neural architecture search \citep{zoph2016neural} could see benefits from narrowing the search space to exclude kernel size and pooling layers. In addition, we envisage additional improvements from structural developments of FlexConvs such as attentive FlexNets.




\section*{Reproducibility Statement}

We hope to inspire others to use and reproduce our work. We publish the source code of this work, for which the link is provided in Sec.~\ref{sec:classification}. Sec.~\ref{sec:experiments} and Appx.~\ref{sec:appx-flexnet} detail FlexNet, its hyperparameters and optimization procedure. The full derivation of the aliasing regularization objective is included in Appx.~\ref{sec:magnetanalysis}. We report means over multiple runs for many experiments, to ensure the reported results are fair and reproducible, and do not rely on tuning of the random seed. All datasets used in our experiments are publicly available. If any questions remain, we welcome one and all to contact the corresponding author.

\section*{Acknowledgments}
We thank Nergis Tmen for her valuable insights regarding signal processing principles for FlexConv, and Silvia-Laura Pintea for explanations and access to code of her work \cite{pintea2021resolution}.  We thank Yerlan Idelbayev for the use of the \href{https://github.com/akamaster/pytorch_resnet_cifar10}{CIFARResNet code}.

This work is co-supported by the \href{https://www.qualcomm.com/research/research/university-relations/innovation-fellowship/2021-europe}{Qualcomm Innovation Fellowship} granted to David W. Romero. David W. Romero sincerely thanks Qualcomm for his support. David W. Romero is financed as part of the Efficient Deep Learning (EDL) programme (grant number P16-25), partly funded by the Dutch Research Council (NWO). Robert-Jan Bruintjes is financed by the Dutch Research Council (NWO) (project VI.Vidi.192.100). All authors sincerely thank everyone involved in funding this work.

This work was partially carried out on the Dutch national infrastructure with the support of SURF Cooperative. We used Weights \& Biases \citep{wandb} for experiment tracking and visualizations.

\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\newpage
\appendix



\begin{figure}
    \centering
     \begin{subfigure}[c]{0.24\textwidth}
\centering
         \includegraphics[width=\textwidth]{images/example_kernel_raw.pdf}
         \caption{ output}
\label{fig:flexconvexample-raw}
     \end{subfigure}
\begin{subfigure}[c]{0.24\textwidth}
\centering
         \includegraphics[width=\textwidth]{images/example_mask.pdf}
\caption{ }
         \label{fig:flexconvexample-mask}
     \end{subfigure}
     \begin{subfigure}[c]{0.24\textwidth}
\centering
         \includegraphics[width=\textwidth]{images/example_masked_kernel.pdf}
\caption{
          (a)  (b)}
         \label{fig:flexconvexample-maskedkernel}
     \end{subfigure}
     \begin{subfigure}[c]{0.24\textwidth}
\centering
         \includegraphics[width=\textwidth]{images/example_kernel.pdf}
\caption{After cropping}
         \label{fig:flexconvexample-kernel}
     \end{subfigure}
    \caption{Example kernels, generated step by step. FlexConv samples a kernel from   (a), which is attenuated by an anistropic Gaussian envelope with learned parameters  (b), creating (c) which is cropped to contain only values of  (d).
    \vspace{-2mm}}
    \label{fig:app-flexconvexample}
\end{figure}



\begin{figure}
    \centering
\begin{subfigure}[c]{0.98\textwidth}
     \vspace{2.5mm}
         \centering
         \includegraphics[width=\textwidth]{images/c10-cres-16x32-noreg-kernels-3.pdf}
\label{fig:c10-cres-noreg-kernels-1}
         \vspace{-3mm}
         \caption{No regularization, block 3 of 7.}
     \end{subfigure}
\begin{subfigure}[c]{0.98\textwidth}
     \vspace{2.5mm}
         \centering
         \includegraphics[width=\textwidth]{images/c10-cres-16x32-gabortog-kernels-4.pdf}
\label{fig:c10-cres-gabor-kernels-1}
         \vspace{-3mm}
         \caption{Regularizing , block 4 of 7.}
     \end{subfigure}
\begin{subfigure}[c]{0.98\textwidth}
     \vspace{2.5mm}
         \centering
         \includegraphics[width=\textwidth]{images/c10-cres-16x32-gnmtog-kernels-4.pdf}
         \label{fig:c10-cres-gabor-kernels-1}
         \vspace{-3mm}
         \caption{Regularizing , block 4 of 7.}
     \end{subfigure}
    \caption{Example kernels from FlexNet-16 models trained (i) without regularization, (ii) with aliasing regularization of , (iii) with aliasing regularization of . In the columns, from left to right: (i) original kernel at , (ii) FFT of the original kernel, (iii) kernel inferred at , to find aliasing effects, (iiii) FFT of the  kernel, with the solid line showing the Nyquist frequency of the  kernel, and the red dotted line showing the maximum frequency component as computed by our analysis. For  the maximum frequency matches almost exactly with the Nyquist frequency, showing that our aliasing regularization works. For , the maximum frequency is slightly higher than the Nyquist frequency, as the FlexConv mask is not included in the frequency term derivation. This is reflected in the slightly worse resolution generalization results reported in Sec.~\ref{sec:crossresexperiments}. Furthermore, some aliasing effects are still apparent for the aliasing regularized models, as discussed in Sec.~\ref{sec:limitations}.
    \vspace{-2mm}}
    \label{fig:app-cifar10kernelfrequencies}
\end{figure}







\section{Alias-free FlexConv regularization}
\label{sec:regularizingflexconv}
In this section we provide the complete derivation and analysis for our FlexConv regularization against aliasing. First, we derive the analytic maximum frequency component of a FlexConv kernel. Next, we compute the Nyquist frequency of a FlexConv kernel, and subsequently show how to combine the previous results into a regularization term to train alias-free FlexConvs.

\subsection{Analyzing the frequency spectrum of FlexConv}
\label{sec:magnetanalysis}

In order to make FlexConv alias-free (Sec.~\ref{sec:crtraining}), we need to compute the maximum frequency component of the kernels generated by a MAGNet, so that we can regularize it during training. In this section we analytically derive this maximum frequency component from the parameters of the MAGNet.

Recall that MAGNets generate a kernel  through of a succession of anisotropic Gabor filters and linear layers (Sec.~\ref{sec:magnets}, Eqs.~\ref{eq:mfn}--\ref{eq:anisotropicgaussian}):



To analyse the maximum frequency component , we analyse the frequency components of the Gabor filters used in MAGNet, and retain their maximum. We then plug the found frequency component into the analysis of \citet{fathony2021multiplicative} to show how the frequency responses of Gabor filters and linear layers interact in MFNs. Finally, we add the effect of the FlexConv Gaussian mask to our analysis to obtain the maximum frequency component ot the final FlexConv kernel .

\textbf{Sine term in Gabor filters.} In a Gabor filter, the sine term is multiplied with a Gaussian envelope. The frequency (in radians) of a sine function of the form  is given by . We divide by  to convert the frequency units to Hertz, for compatibility with the rest of the analysis. For 2D inputs, the maximum frequency component of the sine function correspond to the largest frequency in the two input dimensions:

The sine terms in MAGNets have multiple output channels: . Effectively, we compute the sine term independently for each channel:

\textbf{Gaussian term in Gabor filters.} In a Gabor filter, a Gaussian envelope modulates a sine term. Let us assume for now that the Gaussian envelope is isotropic, rather than anisotropic as in MAGNets, and has single-channel output. By applying the convolution theorem, the sine term is equivalently convolved with the Fourier transform of the Gaussian envelope in the frequency domain. Since the Fourier transform of a Gaussian envelope is another Gaussian envelope, the application of a Gaussian envelope amounts to blurring with a Gaussian kernel in the frequency domain. The size of the envelope in the Fourier domain  can be derived from the standard deviation of the Guassian envelope in the spatial domain  as follows:

Gaussian blurs induce impulse signals to have a long tail. Consequently, we must define a cutoff point for this tail in terms of standard deviations to derive the maximum added frequency induced by the blur. We describe the cutoff point as . Typical choices for  are known as the \textit{empirical}, or the "68-95-99.7" rule \citep{hald2007moivre}. We choose a standard of two standard deviations, i.e., , which covers 95\% of the mass of the Gaussian envelope.

For an isotropic Gabor filter with , the maximum frequency of its Gaussian envelope  is:

\textbf{Anisotropic envelopes.} Our analysis so far assumes an isotropic Gaussian envelope in the Gabor filter. However, we need to account for the anisotropic Gaussian envelopes in MAGNets. Anisotropic filters have not one but two  parameters: . The smallest of these will contribute most to , as it will blur the most, so it is sufficient to compute  only using the smallest of the two  terms:

The other assumption we made before was to work with single-channel outputs. MAGNets however use multi-channel outputs with independent Gaussian terms. The maximum frequency of multi-channel Gaussian envelopes is given by:

where the subscript  indexes the channels of the multi-channel Gaussian envelopes.


\textbf{Maximum frequency component of anisotropic Gabor filters.} Finally, the maximum frequency component of the -th channel of an anisotropic Gabor filter  is given by:

Figure~\ref{fig:gabor-example} illustrates the frequency spectrum of an example Gabor filter.

\begin{figure}[t]
    \vspace{-2.5mm}
    \centering
    \includegraphics[width=1.0\textwidth]{images/magnet-analysis-gabor-example.pdf}
    \caption{Decomposition of  a Gabor filter and its frequency spectrum. Top row: a decomposition of a Gabor filter (right) into its Gaussian term (left) and its sine term (center). Bottom row: frequency responses for each respective filter. The Fourier transform of a Gaussian envelope is a Gaussian envelope (blue circles show  for ). The Fourier transform of a sine pattern is a collection of symmetrical impulse signals (red box shows the Nyquist frequency). The Gaussian envelope blurs the frequency response of the sine term (purple boxes show the frequency response for ).
    \vspace{-2mm}}
    \label{fig:gabor-example}
\end{figure}

\textbf{Maximum frequency component of a MAGNet.} \citet{fathony2021multiplicative} characterize the expansion of each term of the isotropic Gabor layers in MFNs in the final MFN output. In Eq.~25, \citet{fathony2021multiplicative} demonstrate that the MFN representation contains a set of sine frequencies  given by:

Here, the indexes  range over all possible indices of each hidden unit of each layer of an MFN, and  range over all  possible binary signs. In other words, \citet{fathony2021multiplicative} demonstrate that the representation of an MFN at a particular layer contains an exponential combination of all possible positive and negative combinations of the frequencies of the sine terms in each hidden unit at each layer in the MFN up to the current layer.

The original analysis uses these terms to argue that MFNs model exponentially many terms through a linear amount of layers. For our purpose of computing the frequency response of the MAGNet generated kernel, we can plug our derivation of the frequencies of the Gabor filter  into  to compute the frequency spectrum of the generated kernel:

As stated before, we are only interested in the maximum frequency in the frequency spectrum. We can therefore simplify Eq.~\ref{eq:spectrum_magnet} in two ways. First, we simplify over MAGNet layers by taking the maximum value of the spectrum, which is the sum over all layers using only the positive binary signs in  (Eq.~\ref{eq:simplifysigns}). Next, we simplify over channel indices by retaining only the channel index that results in the highest frequency (Eq.~\ref{eq:simplifychannels}). The maximum frequency of a MAGNet is shown in Eq.~\ref{eq:magnetfreq}: 

\textbf{Effect of the Gaussian mask in the frequency components of a FlexConv.} FlexConvs attenuate the MAGNet output with a Gaussian mask. The Gaussian mask (Eq.~\ref{eq:gaussianmask}) works analogously to the Gaussian envelope term in the Gabor filter: it blurs the frequency components of the generated kernel with standard deviation . Therefore, we can reuse our derivation for the Gaussian envelope of the Gabor filter (Eq.~\ref{eq:freqgaussian}). The maximum frequency component of a FlexConv kernel is given by:


\textbf{Visualization of regularized kernels.} Fig.~\ref{fig:app-cifar10kernelfrequencies} shows example kernels from FlexNets trained with aliasing regularization. The frequency domain plots confirm the accuracy of our frequency component regularization.

\subsection{Regularizing the frequency response of FlexConv}
\label{sec:magnetreg}

\textbf{Nyquist frequency of a FlexConv kernel.} Given the sampling rate  of the kernel, we can compute its Nyquist frequency  as:
To compute the sampling rate, we note that the kernel coordinates input to our MAGNet stretch over a  domain. For a kernel of length , we therefore sample one point in every  units.

Knowing the sampling rate in terms of the kernel size allows us to express the Nyquist frequency in terms of the (pre-masked) kernel size:

Note that the kernel size in a FlexConv is initialized to be equal to the resolution of the data, if it is odd. For even resolutions, it corresponds to the resolution of the data plus one.

\textbf{Constructing the regularization term.} We train FlexConv with a regularization term on the frequency response of the generated kernel to ensure that aliasing effects do not distort the performance of the model when it is inferred at a higher resolution. This section details the implementation of the regularization function.

From the parameters of each FlexConv module, we compute  according to Eq.~\ref{eq:flexconvfreq}. For the amount of standard deviations to use in determining  (Eq.~\ref{eq:freqgaussian}) we use . From the kernel size  of the FlexConv module we compute  according to Eq.~\ref{eq:flexconvnyquist}. We then apply an L2 regularizer over the amount that  exceeds :



We weight  by  when adding it to our loss function.

\textbf{Improved implementation.} Eq.~\ref{eq:regularizeflexconv} contains a sum over the  layers of the MAGNet. In practice, we prefer to regularize each layer  separately, so that the gradients of the regularization of different layers are not dependent on each other. We therefore implement the anti-aliasing regularization by regularizing each MAGNet layer independently, and spreading the  term from the gaussian mask uniformly over all MAGNet layers:



In the code, we refer to this method as the {\btt together} method, versus the {\btt summed} method of Eq.~\ref{eq:regularizeflexconv}. In preliminary experiments, we observed improved performance of anti-aliasing training when using the {\btt together} method. All of our experiments anti-aliasing experiments therefore use the {\btt together} setting.













\section{Dataset Description}
\label{sec:datasets}

\subsection{Image Fitting Datasets}
\textbf{Kodak dataset.} The Kodak dataset \citep{kodak1991} consists of 24 natural images of size . This dataset is a popular benchmark used for compression and image fitting methods.

\subsection{Sequential Datasets}
\textbf{Sequential and Permuted MNIST.} The sequential MNIST dataset (sMNIST) \citep{le2015simple}takes the  images from the original MNIST dataset \citep{lecun1998gradient}, and presents them as a sequence of 784 pixels. The goal of this task is to perform digit classification given the representation of the last sequence element of a sequential model. Consequently, good predictions require the model to preserve long-term dependencies up to 784 steps in the past.

The permuted MNIST dataset (pMNIST) additionally changes the order of all the sMNIST sequences by a random permutation. Consequently, models can no longer rely on local features to construct good feature representations. As a result, the classification problem becomes more difficult, and the importance of long-term dependencies more pronounced.

\textbf{Sequential and Noise-Padded CIFAR10.} The sequential CIFAR10 dataset (sCIFAR10) \citep{chang2017dilated} takes the  images from the original CIFAR10 dataset \citep{krizhevsky2009learning} and presents them as a sequence of 1,024 pixels. The goal of this task is to perform image classification given the representation of the last sequence element of a sequential model. This task is more difficult than sMNIST, as a larger memory horizon is required to solve the task and more complex structures and intra-class variations are present in the data \citep{bai2018trellis}. 

The noise-padded CIFAR10 dataset (npCIFAR10) \citep{chang2019antisymmetricrnn} flattens the images from the original CIFAR10 dataset \citep{krizhevsky2009learning} along their rows to create a sequence of length 32, and 96 channels (32 rows  3 channels). Next, these sequences are concatenated with 968 entries of noise to form the final sequences of length 1000. As for sCIFAR10, the goal of the task is to perform image classification given the representation of the last sequence element of a sequential model. 

\textbf{CharacterTrajectories.} The CharacterTrajectories dataset is part of the UEA time series classification archive \citep{bagnall2018uea}. It consists of 2858 time series of length 182 and 3 channels representing the  positions, and the tip force of a pen while writing Latin alphabet characters in a single stroke. The goal is to classify out of 20 classes the written character using the time series data. 

\textbf{Speech Commands.} The Speech Commands dataset \citep{warden2018speech} consists of 105,809 one-second audio recordings of 35 spoken words sampled at 16. Following \citet{kidger2020neural}, we extract 34975 recordings from ten spoken words to construct a balanced classification problem. We refer to this dataset as \textbf{SpeechCommands\_raw}, or \textbf{SC\_raw} for short. Furhtermore, we utilize the preprocessing steps of \citet{kidger2020neural} and extract mel-frequency cepstrum coefficients from the raw data. The resulting dataset, abreviated \textbf{SC}, consists of time series of length 101, and 20 channels.

\subsection{Image Benchmark Datasets}\label{appx:image_datsets}

\textbf{MNIST.} The MNIST hadwritten digits datset \citep{lecun-mnisthandwrittendigit-2010} consists of 70,000 gray-scale handwritten digits of size , divided into a training and test sets of 60,000 and 10,000 images, respectively. The goal of the task is to classify these digits as one of the ten possible digits .

\textbf{CIFAR-10} The CIFAR-10 dataset \citep{krizhevsky2009learning} consists of 60,000 natural images from 10 classes of size , divided into training and test sets of 50,000 and 10,000 images, respectively.

\textbf{STL-10.} The STL-10 dataset \citep{coates2011analysis} is a subset of the ImageNet dataset \citep{krizhevsky_imagenet_2012} consisting of 5,000 natural images from 10 classes of size , divided into trainint and test sets of 4,500 and 500 images, respectively.

\textbf{ImageNet-.} The Imagenet- \citep{ChrabaszczLH17} dataset is derived from the ImageNet dataset \cite{ILSVRC15} by downsampling all samples to a resolution . The dataset contains 1000 classes with 1,281,167 training samples and 50,000 validation samples.

\section{Additional Experiments}
\label{sec:appx-experiments}
\begin{table}
\centering
\caption{Average PSNR for fitting of images in the Kodak dataset. Both our improved initialization scheme, as well as the inclusion of anisotropic Gabor functions lead to better reconstructions.}
\label{tab:kodak-results}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{cccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{\# Params}} & \sc{Improved} &  \multirow{2}{*}{\sc{PSNR}} \\
    & & \sc{Init}\\
    \midrule
    SIREN & 7.14\sc{k} & - & 25.665 \\
    MFN & 7.40{\sc{k}}& - & 23.276\\
    \multirow{2}{*}{MFN} & \multirow{2}{*}{7.11{\sc{k}}} & \xmark & 25.361 \\
     & & \cmark &  \textbf{25.606} \\ 
     \midrule
    \multirow{2}{*}{MAGNet} & \multirow{2}{*}{7.36{\sc{k}}} & \xmark & 25.791 \\ 
    & & \cmark & \textbf{\underline{25.893}} \\
  \bottomrule
\end{tabular}}
\end{center}
\vspace{-2mm}
\end{table}




\subsection{Image Classification}

\begin{table}\centering
\caption{Full results on CIFAR-10. We report results over three runs per setting. CIFARResNet-44 w/ CKConv is a CIFARResNet-44 where all convolutional layers are replaced with CKConvs with . CIFARResNet-44 w/ FlexConv is a CIFARResNet-44 where all convolutional layers are replaced with FlexConv with learned kernel size, except for the shortcut connections of the strided convolutional layers, which are pointwise convolutions. *Results are taken from the respective original works instead of reproduced. \dagger Results are from single run.}
\label{tab:full-cifar-10}
\begin{center}
\scalebox{0.7}{
\begin{tabular}{ccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} & \sc{CIFAR-10} \\
    & & \sc{Acc.} \\ \midrule
    DCN- \citep{tomen2021deep} & 0.47\sc{m} & 89.7  0.3* \\
    N-Jet-CIFARResNet32 \citep{pintea2021resolution} & 0.52\sc{m} & 92.3  0.3* \\
    N-Jet-ALLCNN \citep{pintea2021resolution} & 1.07\sc{m} & 92.5  0.1* \\ \midrule
    CIFARResNet-44 \citep{he2016deep} & 0.66\sc{m} & 92.9*\!\dagger \\
    CIFARResNet-44 \citep{he2016deep} (our reproduction) & 0.66\sc{m} & 90.9  0.2 \\\midrule
    CIFARResNet-44 w/ CKConv () & 2.58\sc{m} & 86.1  0.9 \\
    CIFARResNet-44 w/ FlexConv & 2.58\sc{m} & 81.6  0.8 \\ \midrule
    FlexNet-7 w/ conv. () & 0.17\sc{m} & 89.5  0.3   \\
    FlexNet-7 w/ conv. () & 20.0\sc{m} & 78.0  0.3  \\
    FlexNet-7 w/ N-Jet \citep{pintea2021resolution} & 0.70\sc{m} & 91.7  0.1  \\ \midrule
    \midrule
    CKCNN-3 & 0.26\sc{m} & 72.4* \\ CKCNN-3 & 0.27\sc{m} & 83.8* \\ CKCNN-3 & 0.28\sc{m} & 85.6* \\ CKCNN-3 & 0.28\sc{m} & 86.2* \\ CKCNN-7 & 0.63\sc{m} & 71.7* \\ CKCNN-7 & 0.63\sc{m} & 84.6* \\ CKCNN-7 & 0.67\sc{m} & 87.7*  \\ CKCNN-7 & 0.67\sc{m} & 85.9* \\ \midrule
    FlexNet-7 & 0.63\sc{m} & 88.9* \\ FlexNet-7 & 0.66\sc{m} & 91.6* \\ FlexNet-7 & 0.67\sc{m} & 92.0* \\ \midrule
    FlexNet-3 & 0.27\sc{m} & 90.4  0.2 \\
    FlexNet-5 & 0.44\sc{m} & 91.0  0.5 \\
    FlexNet-7 & 0.67\sc{m} & 92.2  0.1 \\
 \bottomrule
\end{tabular}}
\end{center}
\end{table} 
\begin{table}
\vspace{0mm}
\centering
\caption{Results on ImageNet-32. *Results are taken from the respective original works instead of reproduced. \dagger Results are from a single run.}
\label{tab:imagenet-32}
\begin{center}
\scalebox{0.7}{
\begin{tabular}{cccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} &  \multicolumn{2}{c}{\sc{ImageNet-32}} \\
    & & \sc{Top-1} & \sc{Top-5} \\ \midrule
    CIFARResNet-32 & 0.53\sc{m} & 26.41  0.13 & 49.37  0.15 \\ 
    WRN-28-1 & 0.44\sc{m} & 32.03*\!\dagger & 57.51*\!\dagger \\ \midrule
    FlexNet-5 & 0.44\sc{m} & 24.9  0.4 & 47.7  0.6 \\
  \bottomrule
\end{tabular}}
\end{center}
\vspace{-5mm}
\end{table} 
\begin{table}
\centering
\caption{Results for alias-free FlexNets on CIFAR-10 and ImageNet-.  denotes difference in accuracy. 
}
\label{tab:crossres-imagenet}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{cccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} &  \multicolumn{2}{c}{\sc{ImageNet-k Top-1}} \\
    & &  &   \\ \midrule CIFARResNet-32 & 0.52\sc{m} & 16.1  0.0 & -11.6  0.4 \\ \midrule FlexNet-5 w/ N-Jets & 0.46\sc{m} & 15.7  0.1 & -1.9  0.4 \\ \midrule FlexNet-5 & 0.44\sc{m} & 14.9  0.1 & -1.9  1.7 \\ \bottomrule
\end{tabular}}
\end{center}
\end{table} 
\textbf{CIFAR-10.} Tab.~\ref{tab:full-cifar-10} shows all results for our CIFAR-10 experiments, including more ablations.

\textbf{ImageNet-32.} Results for the ImageNet-32 experiment are shown in Table~\ref{tab:imagenet-32}. FlexNets are slightly worse than CIFARResNet-32 \citep{he2016deep} with slightly less parameters. However, the results reported by \citet{ChrabaszczLH17} for Wide ResNets \citep{zagoruyko2016wide} outperform FlexNets by a significant margin.

\textbf{Alias-free ImageNet-32.} We report results for alias-free FlexNets on ImageNet- \citep{ChrabaszczLH17} in Table~\ref{tab:crossres-imagenet}, to verify the results of alias-free training at a larger scale. We find that FlexConv and N-Jet both mostly retain classification accuracy between source and target resolution, while CIFARResNet-32 degrades drastically.

\textbf{MNIST and STL-10.} We additionally report results on MNIST (Tab.~\ref{tab:mnist}) and STL-10 (Tab.~\ref{tab:stl10}. We choose these dataset for the difference in image sizes of the training data. On MNIST, though performance on MNIST is quite saturated, we are competitive with state of the art methods. On STL-10 we are significantly worse than the baseline CIFARResNet from \citep{luo2020extended}, though with significantly less parameters. We were not able to prepare a more relevant baseline for this experiment.

\begin{table}
\centering
\caption{Results on MNIST. We train each model with three different seeds and report mean and standard deviation. *Results are taken from the respective original works instead of reproduced. \dagger Results are from single run.}
\label{tab:mnist}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{ccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} & \sc{MNIST} \\
    & & \sc{Acc.} \\ \midrule
Efficient-CapsNet \citep{mazzia2021efficient} & 0.16\sc{m} & \textbf{99.8}*\!\dagger \\ Network in Network \citep{lin2013network} & N/A & 99.6*\!\dagger \\ VGG-5 (results from \citet{kabir2020spinalnet}) & 3.65\sc{m} & 99.7*\!\dagger \\ \midrule FlexNet-16 & 0.67\sc{m} & 99.7  0.0  \\
 \bottomrule
\end{tabular}}
\end{center}
\end{table}

\begin{table}
\centering
\caption{Results on STL-10. We train each model with three different seeds and report mean and standard deviation. *Results are taken from \citet{luo2020extended}. \dagger Results are from single run.}
\label{tab:stl10}
\begin{center}
\scalebox{0.75}{
\begin{tabular}{ccc}
\toprule
    \multirow{2}{*}{\sc{Model}} & \multirow{2}{*}{\sc{Size}} & \sc{STL-10} \\
    & & \sc{Acc.} \\ \midrule
    CIFARResNet-18 & 11.2\sc{m} & 81.0*\!\dagger \\ 
FlexNet-16 & 0.67\sc{m} & 68.6  0.7 \\
 \bottomrule
\end{tabular}}
\end{center}
\end{table}

\section{Experimental Details}

\subsection{FlexNet}
\label{sec:appx-flexnet}

\begin{figure}[t]
    \centering
    \includegraphics[width=.95\textwidth]{images/flexconv_net_figure.pdf}
    \vspace{-5mm}
    \caption{FlexNet architecture. FlexNet- consists of  FlexBlocks, where each FlexBlock is a residual block of FlexConvs.}
    \label{fig:flexnet-architecture}
    \vspace{-5mm}
\end{figure}

We propose an image classification architecture named \textit{FlexNet} (Fig.~\ref{fig:flexnet-architecture}), consisting of a stack of FlexConv blocks followed by a global average pooling layer and a linear layer. FlexNets are named "FlexNet-" where  indicates the amount of layers in the architecture.

\textbf{FlexBlock.} Each FlexBlock consists of two FlexConvs with BatchNorm \citep{ioffe2015batch} and dropout \citep{srivastava14a} () as well as a residual connection. The width of a block  is determined by scaling a base amount  by progressively increasing factors: . The default configuration of FlexNet uses . In FlexNet-N-Jet models, we scale  to match the amount of parameters of the FlexNet in the comparison.

\textbf{FlexConv initialization.} We initialize the FlexConv mask variances small, at . For initializing MAGNet, we initialize the Gaussian envelopes as discussed in Sec.~\ref{sec:magnets}. We initialize the linear layer weights by the same Gamma distribution as used for the enveloped, modulated by a scaling factor of . We found that this value of the scaling factor, rather than a higher one, helped in reducing the performance of alias-free models. We initialize the bias of the linear layers by .

\textbf{CIFAR-10.} In FlexNet-16 models for CIFAR-10 we use  to approximate the parameter count of CIFARResNets in the experiment.

\subsection{Optimization}
\label{sec:flexnet-optimization}

We use Adam \citep{kingma2014adam} to optimize FlexNet. Unless otherwise specified, we use a learning rate of  with a cosine annealing scheme \citep{loshchilov2016sgdr} with five warmup epochs. We use a different learning rate of  the regular learning rate for the FlexConv Gaussian mask parameters. We do not use weight decay, unless otherwise specified.

\textbf{Kodak.} We overfit on each image of the dataset for 20,000 iterations. To this end, we use a learning rate of 0.01 without any learning rate scheme. We observe that SIRENs diverge with this learning rate and thus, reduce the learning rate to 0.001 for these models.

\textbf{CIFAR-10.} We train for 350 epochs with a batch size of 64. We use the data augmentation from \citet{he2016deep} when training CIFAR-10: a four pixel padding, followed by a random 32 pixel crop and a random horizontal flip.

\textbf{ImageNet-32.} We train for 350 epochs with a batch size of 2048. We use the same data augmentation as used for CIFAR-10. We do use a weight decay of  for ImageNet-32 training.

\textbf{Sequential and Permuted MNIST.} We train for 200 epochs with a batch size of 64 and a learning rate of 0.01. We use a weight decay of .

\textbf{Sequential and Noise-Padded CIFAR-10.} For sequential CIFAR-10, we train for 200 epochs with a batch size of 64, a learning rate of 0.001 and a weight decay of . For noise-padded CIFAR-10, we train for 300 epochs with a batch size of 32, a learning rate of 0.01 and no weight decay.

\textbf{Speech Commands and CharTrajectories.} We train for 300 epochs with a batch size of 32 and a learning rate of 0.001. For CharTrajectories, we use a weight decay of .

\subsection{Rotated Gaussian masks}
\label{sec:negative-steerable-gaussians}

MAGNets use anisotropic Gaussian terms in the Gabor filters, which yields improvements in descriptive power and convergence speed (Sec.~\ref{sec:magnets}). For the same reason, we explore making the anisotropic FlexConv Gaussian mask steerable, by including an additional vector of learnable angle parameters  that rotates the Gaussian masks. Although preliminary experiments show rotated masks lead to slight additional improvements, the computational overhead required to rotate the masks is large. Consequently, we do not consider rotated Gaussian masks in our final experiments.







\end{document}