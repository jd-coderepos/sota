
\documentclass[runningheads]{llncs}

\usepackage{rotating}
\usepackage{graphics}
\usepackage{latexsym}
\usepackage[dvips]{epsfig}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{url}

\def\boxit#1{\vbox{\hrule\hbox{\vrule\kern4pt
  \vbox{\kern1pt#1\kern1pt}
\kern2pt\vrule}\hrule}}

\def\qed{\rule{1.5mm}{3mm}}

\newcommand\nc{\newcommand}

\newtheorem{cor}[theorem]{Corollary}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{conj}[theorem]{Conjecture}
\newtheorem{ques}[theorem]{Question}
\newtheorem{prob}[theorem]{Problem}
\newtheorem{fact}[theorem]{Fact}

\nc{\crl}[2]{\begin{corollary}\label{crl:#1} #2 \end{corollary}}
\nc{\dfn}[2]{\begin{definition}\label{def:#1} #2 \end{definition}}
\nc{\lem}[2]{\begin{lemma}\label{lem:#1} #2 \end{lemma}}
\nc{\prp}[2]{\begin{proposition}\label{prp:#1} #2
\end{proposition}}
\nc{\thm}[2]{\begin{theorem}\label{thm:#1} #2\end{theorem}}
\nc{\fac}[2]{\begin{lemma}\label{fact:#1} #2 \end{lemma}}
\nc{\pro}[2]{\begin{prob}\label{#1} #2 \end{prob}}

\nc{\eqn}[2]{}

\nc{\fig}[4]{\begin{figure}[ht]
\begin{center}
\includegraphics[width=#2\textwidth]{#4}
\end{center}
\caption{#3}\label{fig:#1}
\end{figure}}



\nc{\tbl}[3]{\begin{table}[hbt] #3 \caption{#2} \label{tab:#1}
\end{table}}

\nc{\refc}[1]{Corollary~\ref{crl:#1}}
\nc{\refd}[1]{Definition~\ref{def:#1}}
\nc{\reff}[1]{Fig.~\ref{fig:#1}}
\nc{\refl}[1]{Lemma~\ref{lem:#1}}
\nc{\refp}[1]{Proposition~\ref{prp:#1}}
\nc{\reft}[1]{Theorem~\ref{thm:#1}} \nc{\refe}[1]{(\ref{eqn:#1})}
\nc{\reftb}[1]{Table~\ref{tab:#1}}

\nc{\reffc}[1]{Fact~\ref{fact:#1}}


\nc{\pf}[1]{ \noindent \emph{Proof.} #1
 \hfill \qed\par}


\newenvironment{FRAME}{\begin{trivlist}\item[]
\hrule
\hbox to \linewidth\bgroup
\advance\linewidth by -0pt
\hsize=\linewidth
\vrule\hfill
\vbox\bgroup
\vskip5pt
\def\thempfootnote{\arabic{mpfootnote}}\begin{minipage}{\linewidth}}{\end{minipage}\vskip5pt
\egroup\hfill\vrule
\egroup\hrule
\end{trivlist}}


\begin{document}



\title{An Exact Algorithm for TSP in Degree- Graphs
via Circuit Procedure and Amortization on Connectivity Structure
\thanks{Supported in part by Grant
60903007 of NSFC, China.}
}

\author{Mingyu Xiao\inst{1} \and
Hiroshi Nagamochi\inst{2}}


 \institute{
 School of Computer Science and Engineering,
University of Electronic Science and Technology of China, China,
 \email{myxiao@gmail.com}
 \and
 Department of Applied Mathematics and Physics,
  Graduate School of Informatics, Kyoto University, Japan,
 \email{nag@amp.i.kyoto-u.ac.jp}}


\titlerunning{An Exact Algorithm for TSP in Degree- Graphs}


\authorrunning{}



\toctitle{TSP in Degree- Graphs} \tocauthor{}
\maketitle

\begin{abstract}
The paper presents an -time and polynomial-space algorithm for the traveling salesman problem
 in an -vertex graph with maximum degree .
This improves the previous time bounds of
 by Iwama and Nakashima and  by Eppstein.
Our algorithm is a simple branch-and-search algorithm.
The only branch rule is designed on a cut-circuit structure of a graph induced by unprocessed edges.
To improve a time bound by a simple analysis on measure and conquer,
we introduce an amortization scheme over the cut-circuit structure
by defining the measure of an instance
to be the sum  of not only weights of vertices but also
weights of connected components of the induced graph.

\vspace{5mm}\noindent {\bf Key words.} Traveling Salesman Problem, Exact Exponential Algorithm, Graph Algorithm, Connectivity, Measure and Conquer
\end{abstract}


\section{Introduction}
The traveling salesman problem (TSP) is one of the most famous and intensively studied problems in computational mathematics. Many algorithmic methods have been investigated to beat this challenge of finding the shortest route visiting each member of a collection of  locations and returning to the starting point.
 The first -time dynamic programming algorithm for TSP is back to early 1960s.
 However, in the last half of a century no one can break the barrier of  in the base of the running time.
To make steps toward the long-standing and major open problem in exact exponential algorithms,
TSP in special classes of graphs, especially degree bounded graphs, have also been intensively studied.
Eppstein~\cite{Eppstein:TSP3} showed that TSP in degree- graphs (a graph with maximum degree  is called a degree- graph) can be solved in  time and polynomial space, and TSP in degree- graphs can be solved in  time and polynomial space. Iwama and Nakashima~\cite{Iwama:TSP3} refined Eppstein's algorithm for degree- graphs and improved the result to  by showing that the worst case in Eppstein's algorithm will not always happen. Gebauer~\cite{Gebauer:TSP4} designed an -time exponential-space algorithm for TSP in degree- graphs,
which is improved to   time and polynomial space by
Xiao and Nagamochi~\cite{XN:tsp4}.
Bjorklund \emph{et al.}~\cite{Bjorklund:TSPbounded} also showed TSP in degree bounded graph can be solved in  time, where  depends on the degree bound only. There is a Monte Carlo algorithm to decide a graph is Hamiltonian or not in  time~\cite{Bjorklund:Hamiltonicity}. For planar TSP and Euclidean TSP, there are sub-exponential algorithms based on small separators~\cite{Dorn:Planar}.

In this paper, we present an improved deterministic algorithm for TSP in degree- graphs, which runs in  time and polynomial space. The algorithm is simple and contains only
one branch rule that is designed on a cut-circuit structure of a graph induced by unprocessed edges.
We will apply the measure and conquer method to analyze the running time. Note that our algorithm for TSP
in degree-4 graphs in~\cite{XN:tsp4} is obtained by successfully applying the measure and conquer method to TSP for the first time. However, direct application of measure and conquer to TSP in degree-3 graphs may only lead to an -time algorithm. To effectively analyze our algorithm, we use an amortization scheme over the cut-circuit structures by setting weights to both vertices and connected components of the induced graph.







\section{Preliminaries}\label{sec:prelim}

In this paper, a graph means an undirected edge-weighted graph with maximum degree 3,
which possibly has multiple edges, but no self-loops.
Let  be a graph with an edge weight.
For a subset  of vertices and a subset  of edges,
the subgraphs induced by  and  are denoted by  and  respectively. We also use   to denote the total weight of edges in .
For any graph , the sets of vertices
and edges in  are denoted as  and  respectively.
A graph consisting of a single vertex is called {\em trivial}.
A \emph{cycle} of length  (also denoted as {\em -cycle}) is a graph with  vertices  and  edges  ( and ). An edge  () between two vertices in the cycle but different from the  edges in it
is called a {\em chord} of the cycle.
Two vertices in a graph are
{\em -edge-connected} if there are -edge-disjoint paths between them. A graph is {\em -edge-connected} if every pair of vertices in it are -edge-connected.
We treat a trivial graph as a -edge-connected graph for any .
A Hamiltonian cycle is a cycle through every vertex. Given a graph with an edge weight,
the \emph{traveling salesman problem} (TSP) is to find a Hamiltonian cycle of minimum total weight in the edges.

\subsection{Forced TSP}
In some branch-and-search algorithms for TSP, we may branch on an edge in the graph by including it to the solution
or excluding it from the solution. In this way, we need to maintain a set of edges that must be used in the solution.
We introduce the \emph{forced traveling salesman problem} as follows. An instance is a pair  of an edge-weighted undirected graph
 and
a subset  of edges, called {\em forced edges}.
A Hamiltonian cycle of  is called a {\em tour}
if it passes though all the forced edges in . The objective of the problem is to compute a tour of minimum weight in
the given instance . An instance is called {\em infeasible} if no tour exists. A vertex is called \emph{forced} if there is a forced edge incident on it. For convenience, we say that the \emph{sign} of an edge  is 1 if  is a forced edge and  if  is an unforced edge. We use  to denote the sign of .


\subsection{-graphs and -components}
We consider an instance . Let  denote the set of unforced edges.
A subgraph  of  is called a \emph{-graph} if  is a trivial graph or  is
induced by a subset  of unforced edges (i.e., ). A maximal connected -graph is called a \emph{-component}.
Note that each connected component in the graph  is a -component.

For a vertex subset  (or a subgraph ) of ,
let  denote the set of edges in 
between  and ,
and denote  
and . Edge set  is also called a \emph{cut} of the graph.
We say that an edge is \emph{incident} on  if the edge is in .
The {\em degree}  of a vertex  is defined to be
.
We also denote 
and .
A -graph  is {\em -pendent} if .
A  -graph  is called  {\em even} (resp., {\em odd}) if   is even (resp., odd).
A -component is 0-pendent.

In this paper, we will always keep every -component 2-edge-connected.
For simplicity, we may regard a maximal path of
forced edges between two vertices  and 
as a single forced edge  in an instance , since we can assume that
  always implies  for any vertex .

\subsection{Circuits and blocks}
We consider a nontrivial -component  in an instance .
A {\em circuit}  in  is a maximal sequence
 of edges  
such that for each  ,
the next edge  is given
by a subgraph  of  such that
. See \reff{circuit} for an illustration.
We say that each subgraph  is a \emph{block} along  and vertices  and  are the {\em endpoints} of block .
By the maximality of , we know that any two vertices in each block  are 2-edge-connected in the induced subgraph . It is possible that a circuit in a 2-edge-connected graph  may contain only one edge . For this case, vertices  and  are connected by three edge-disjoint paths in  and the circuit is called \emph{trivial}, where the unique block is the -component .
Each nontrivial circuit contains at least two blocks, each of which is a 2-pendent subgraph of .
In our algorithm, we will consider only nontrivial circuits .
When  is 2-edge-connected, there are  different blocks along a nontrivial circuit , where   and  are in the same block  and .
A block  is called {\em trivial} if  and  for the only vertex  in it ( is of degree 3 in ).
A block  is called {\em reducible} if  and  for the only vertex  in it ( is of degree 2 in ).
A block  with  is either trivial or reducible in a  2-edge-connected graph.

\vspace{-0mm}\fig{circuit}{0.4}{A circuit in a 2-edge-connected graph }{circuit}\vspace{-0mm}
We state more properties on circuits and blocks.


\lem{circuits2}{In a degree- graph, let  be a 2-edge-connected -component and  be any circuit in it.
For each block  of ,  is not trivial or reducible if and only if the two
endpoints  and  of it are two different vertices of degree  in .}

\lem{circuits1}{Each edge in a -edge-connected -component  of a degree- graph is contained in exactly one circuit.
A partition of  into circuits can be obtained in linear time.}
\pf{
It is known that the set of all minimum cuts (a set of  edges in a -edge-connected multigraph
is called a minimum cut if the graph becomes disconnected by removing the  edges)
can be represented by a cactus structure
(cf. \cite{NI:book}).
In particular, when the size of a minimum cut is two, the cactus structure
of minimum cuts can be
obtained in linear time by contracting each 3-edge-connected component
(a maximal set of vertices every two of which are 3-connected in the given graph)
into a single vertex, and for each cycle  in the resulting graph,
a pair of any two edges in  corresponds to a minimum cut in the original graph \cite{NI92}.
In a 2-edge-connected -component , (i) an edge  forms a circuit  having only one block
if and only if  is not in any minimum cut of ; and (ii)
A circuit  with at least two edges in  corresponds to a cycle  in the cactus structure.
Based on the cactus structure, we can obtain
a partition of edge sets into circuits in linear time.
}

\subsection{Branch-and-search algorithms}
Our algorithm is a branch-and-search algorithm: we search the solution by iteratively branching on the current
instance into several smaller instances until the current instance becomes trivial (or polynomially solvable).
In this paradigm, we will get a search tree. In each leaf of the search tree, we can solve the problem directly.
The size of the search tree is the exponential part of the running time of the search algorithm.
Let  be a measure of the instance (for graph problems, the measure can be the number of vertices or edges in the graph and so on). Let  denote the maximum number of leaves in the search tree
generated by the algorithm for any instance with measure .
We shall determine an upper bound on  by evaluating all the branches.
When we branch on an instance  with  branches such that
the -th branch decreases the measure  of  by
at least , we obtain the following recurrence

Solving this recurrence, we get , where  is the largest
root of the function .
In this paper, we represent the above recurrence by a vector
 of measure decreases, called a {\em branch vector}
(cf. \cite{Fomin:book}).
In particular, when  for some ,
it may be written as
,
and a vector  is simply written as .
When we compare two branch vectors  
and  such that `` " or `` and
 for some ,"
we only consider branch vector  in analysis,
since a solution  from   is not
smaller than that from  (cf. \cite{Fomin:book}).
We say that   {\em covers}  in this case.


\section{Reductions based on small cuts}
For some special cases, we can reduce the instance directly without branching.
Most of out reduction rules are based on the structures of small cuts in the graph.
In fact, we will deal with cuts of size  and .

\subsection{Sufficient conditions for infeasibility}
The {\em parity condition} on an instance is:
(i)  every -component is even; and
(ii)  the number of odd blocks along every circuit is even.

\lem{infeasibility}{An instance  is infeasible if
 is not 2-edge-connected or it violates the parity condition.}
\pf{Since any tour is a 2-edge-connected spanning graph of ,
it cannot exist when  is not 2-edge-connected.
Since any tour is an Eulerian graph,
it cannot exist in any instance with an odd -component.
For a circuit which has an odd number of odd blocks,
we see that at least one odd block will be an odd -component
in any way of including/deleting edges in the circuit.}

\subsection{Eliminable, reducible and parallel edges}
The unique unforced edge incident on a 1-pendent -graph is \emph{eliminable}.
From parity condition (i), we can decide whether each eliminable edge need to be included to  or deleted from the graph
just by depending on the parity of .


For any subgraph  of  with ,
we call the unforced edges in  {\em reducible}.
From the connectivity condition and parity condition (i),
we see that all reducible edges need to be included to .
In particular, any edge  incident to a vertex  with 
(or with a neighbor  with multiple edges
of  and ) is reducible,
since  and 
 for  (or ).


If there are multiple edges with the same endpoints  and , we can reduce the instance in the following way
 preserving the optimality:
 If the graph has only two vertices  and , solve the problem directly; else if there are forced edges between  and , the problem is infeasible; and otherwise remove all unforced edges between  and  except one with the smallest weight.


\subsection{Reductions based on 3-cuts and 4-cuts}
\lem{3subgraph}{Let  be an instance where  is a graph with maximum degree 3.
For any subgraph  with , we can replace  with a single vertex  and update the
three edges incident on  preserving the optimality of the instance.}

\pf{
Denote   by  with  and .
We will replace  and  with a single vertex  and  three new edges  and .
 Let  denote the new graph. We only need to decide the weights and signs of edges  and  in  to satisfy the lemma.
Let  () denote the problem of finding a path  from  to  () of minimum total cost in  that passes through all vertices and forced edges in . We say that  \emph{infeasible} if it has no such path.
We consider the three problems  ().
There are four possible cases.
Case 1. None of the three problems is feasible: We can see that the original instance  is also infeasible. In , we let .
 Since the trivial -component  is odd, the new instance is infeasible
by \refl{infeasibility}.
Case 2. Only one of the three problems, say  (), is feasible: Let  be an optimal solution to . Then there is a solution  to   such that  (if  is feasible). Therefore, in , we let ,
,
,
  and .
Case 3. Exactly two of the three problems, say  and  (), are feasible:
Let  and  be an optimal solution to  and  respectively.
Then there is a solution  to  such that either  or . Therefore,
in , we let , , , ,
 and
.
Case 4. All of the three problems are feasible: Let ,  and  be an optimal solution to ,  and  respectively.
In , we let  and
 ().
Straightforward computation can verify that with these setting  will preserve the optimality.
}
\bigskip

Similar to \refl{3subgraph}, we can simplify a subgraph  with . However, there are
many cases needed to consider. In fact, in our algorithms, we only need to consider a special case.

We consider a subgraph  with  and .
We want to reduce .
Denote  by  with  and ,
where  .
We define  () to be instances of the problem of finding two disjoint paths  and  of minimum total cost in  such that all vertices and forced edges in   appear in exactly one of the two paths, and one of the two paths is from  to  and the other one is from  to  ().
We say that  \emph{infeasible} if it has no solution.

A subgraph  is \emph{-cut reducible} if , , and at least one of the three problems  and  defined above is infeasible.
We have the following lemma to reduce the -cut reducible subgraph.

\lem{4subgraph}{
Let  be an instance where  is a graph with maximum degree 3.
A -cut reducible subgraph  can be replaced with
   one of the following subgraphs  with four vertices and
 so that the optimality of the instance is preserved:\\
{\rm (i)} four single vertices  i.e., there is no solution to this instance;\\
{\rm (ii)}  a pair of forced edges; and \\
{\rm (iii)}  a 4-cycle with four unforced edges.
}
\pf{ We consider the three problems  (). Since at least one of them is infeasible, there are three possible cases.
Case 1. None of the three problems is feasible: We can see that the original instance  is also infeasible.
Then we can replace  with a graph containing only four vertices  and no edge.
Now  becomes a degree-1 vertex in the new graph and the new instance is infeasible.
Case 2. Only one of the three problems, say  (), is feasible: Let  be an
optimal solution to . Then there is a solution  to  such that . Therefore, we can replace  with a graph of four vertices  and
 two edges  and  in  preserving the optimality of the instance,
 where the costs of  and  are the costs of the two paths in .
Note that in the new instance after the replacement, the four vertices  become
degree-2 vertices and the two new edges  and  should be included into .
Case 3. Two of the three problems, say  and  (), are feasible: Let  and  be  optimal solutions to  and  respectively. Then there is a solution  to  such that    or . Therefore, we can replace  with a -cycle  preserving the optimality of the instance, where , the costs of  and  are the costs of the two paths in , and the costs of  and  are the costs of the two paths in .
}
\bigskip


\lem{reducecritical}{
Let  be an induced subgraph of a degree- graph  such that
 contains at most eight vertices of degree 3 in .
Then   is -cut reducible if
 , ,
and  contains at most two unforced  vertices.
}
\pf{We only need to show that
at least one of the three problem instances  and  (defined before \refl{4subgraph}) is infeasible.
Assume that no two edges in  meet at a same vertex in , since otherwise
only one of  and  is feasible.
Also assume that  has no multiple edges or induced triangles, since otherwise
 can be reduced to a smaller graph preserving its optimality.
Note that   contains an even number  of degree 3 vertices in .
Since  (i.e., ) implies the lemma, we consider the case of .
When ,  is either a 6-cycle with a chord or a graph obtained from
a 5-cycle with a chord by subdividing the chord with a new vertex.
In any case, we see that one of   and  is infeasible.
Let .
In this case, there are four vertices   which are not incident to any of the four edges
in , and two of them, say  and  are joined by
a forced edge  by the assumption on the number of unforced vertices in .
Then we see that there are three possible configurations for such an induced graph  with no
induced triangles, and a straightforward inspection shows that none of them admits
a set of three feasible instances  and .
}
\bigskip



\refl{3subgraph} and \refl{4subgraph} imply a way of simplifying some local structures of an instance. However, it is not easy to find solutions to problems  in the above two lemmas. In our algorithm, we only do this replacement for  containing no more than 10 vertices and then the corresponding problems  can be solved in constant time by a brute force search.

We define the operation of \emph{/-cut reduction}: If there a subgraph  of  with  such that   or  is -cut reducible, then we simplify the graph by replacing  with a graph according to \refl{3subgraph}  or \refl{4subgraph}. Note that a /-cut can be found in polynomial time if it exists and then this reduction operation can be implemented in polynomial time.

\subsection{A solvable case and reduced graphs}
A 3/4-cut reduction reduce the subgraph  to a trivial graph except for the last case of \refl{4subgraph} where  will become a 4-cycle.
Eppstein has identified a polynomially solvable case of forced TSP~\cite{Eppstein:TSP3}, which can deal with -components of 4-cycles.

\lem{solvable}{{\rm \cite{Eppstein:TSP3}}
If every -component is a component of a 4-cycle, then
a minimum cost tour of the instance can be found in polynomial time.
}

Based on this lemma, we do not need to deal with -components of 4-cycles in our algorithms.

\bigskip
All above reduction rules can be applied in polynomial time. An instance  is called a \emph{reduced} instance if
 is 2-edge-connected,  satisfies the parity condition, and
  has none of reducible edges, eliminable edges and multiple edges, and the 3/4-cut reduction cannot be applied on it anymore.
Note that a reduced instance has no triangle, otherwise 3-cut reduction would be applicable.
An instance is called {\em 2-edge-connected}
if
every -component in it is 2-edge-connected.
The initial instance  is assumed to be 2-edge-connected, otherwise
it is infeasible by \refl{infeasibility}.
In our algorithm, we will guarantee that the input instance is always 2-edge-connected,
and we branch on a reduced graph to search a solution.







\section{The circuit procedure}
The \emph{circuit procedure} is one of the most important operations in our algorithm.
The procedure will determinate each edge in a circuit to be included into  or to be deleted from the graph.
It will be widely used as the only branching operation in our algorithm.

\paragraph{Processing circuits:}
\emph{Determining} an unforced edge means either including it to  or deleting it from the graph.
 When an edge is determined, the other edges in the same circuit containing this edge can also be determined directly by reducing eliminable edges. We call the series of procedures applied to all edges in a circuit together as a \emph{circuit procedure}.
Thus, in the circuit procedure, after we start to process a circuit  either by including an edge  to 
 or by deleting  from the graph, the next edge  of  becomes an eliminable edge and we continue to determine 
either by deleting it  from the graph if block  is odd and 
 is included to  (or  is even and  is deleted);
or  by including it to  otherwise.
Circuit procedure is a fundamental operation
 to build up our proposed algorithm. Note that a circuit procedure determines only the edges in the circuit.
During the procedure, some unforced edges outside the circuit may become reducible  and so on,
 but we do not determine them in this execution.

 \lem{circuitprocess}{
Let  be a 2-edge-connected -component in an instance  and  be a circuit in . Let  be the resulting instance after applying circuit procedure on . Then\\
{\rm (i)} each block  of  becomes a 2-edge-connected -component in ; and \\
{\rm (ii)} any other -component  than  in  remains unchanged in .
}
\pf{Since  is 2-edge-connected, we know that each block  induces a 2-edge-connected subgraph
from  according to the definition of circuits.
Hence   will be a 2-edge-connected -component in .
 Then we get (i). Since  and  are vertex-disjoint and
only edges in  are determined, we see that (ii) holds.
}\bigskip


We call a circuit \emph{reducible} if it contains at least one reducible edge.
We can apply the circuit procedure on a reducible circuit directly starting by including a reducible edge to .
In our algorithm, we will deal with reducible edges
by processing a reducible circuit.
When the instance becomes a reduced instance, we may not be able to reduce the instance directly.
Then we search the solution by ``branching on a circuit."
\emph{Branching on a circuit  at edge } means branching on the current instance to generate
 two instances by applying the circuit procedure to  after including  to  and deleting  from the graph respectively.
Branching on a circuit is the only branching operation used in our algorithm.










\section{A simple algorithm based on circuit procedures}\label{simple_alg}
We first introduce a simple algorithm for forced TSP to show the effectiveness of the circuit procedures. Improved algorithms are given in the next sections.

The simple algorithm contains only two steps: First reduce the instance until it becomes a reduced one;
and then select a -component  that is neither trivial nor a 4-cycle and branch on a circuit  in  such that at least one block along  is trivial.
Note that there is always a circuit having a trivial block as long as the forced edge set  is not empty.

Here we use a traditional method to analyze the simple algorithm. It is natural to consider how many edges can be added to  in each operation of the algorithm. The size of  will not decrease by applying the reduction rules. Let  and  denote the maximum number of leaves in the search tree generated by the algorithm for any instance with measure .
We only need to consider the branching operation in the second step.

For convenience, we call a maximal sequence  of edges    a {\em chain} if all vertices  () are forced vertices. In the definition of the chain, we allow .
Observe that each chain is contained in the same circuit.
Since the selected circuit  has some trivial block, we know that  contains at least one chain  of size .
We distinguish two cases according to the size of  being even or odd.

Case 1.  is even: If all the blocks of  are trivial, then the -component  containing  is a cycle  of even length. Since  cannot be a -cycle, the length of cycle  is at least  (see \reff{ThreeCases}(a) for an illustration).
In each branch, after processing the circuit , we can include at least  edges to . This gives us branch vector
 \eqn{basic_1}{  (3;3).}
Next, we assume that   has a nontrivial block. We look at the worst case where  is of size 2 and
  has only one nontrivial block (see \reff{ThreeCases}(b) for an illustration). Now .
 Let , where .
We branch on the circuit at edge .
In the branch of deleting , we include  into  .
Furthermore, we can include the remaining two edges incident on  into  by
 simply applying reduction rules. In the other branch of including  into , we will delete  and include
 the other two edges incident on  into . We still can get branch vector \refe{basic_1}.
Note that when  is not of the worst case, it is not hard to verify that we may include more edges to  and we can get a branch vector covered by \refe{basic_1}. We omit the details here, since the detailed proof can also be derived from the analysis of the improved algorithm in the next sections.
\vspace{-0mm}\fig{ThreeCases}{1}{Three bottleneck cases in branching on a cirucuit :
(a)  is a 6-cycle; (b)  is a chain  of length 2;
(c)   is a chain  of length 3. }{ThreeCases}\vspace{-0mm}

 Case 2.  is odd: Now circuit  must contain  at least one nontrivial block, otherwise the instance violates the parity condition. We also look at the worst case where  is of size 3 (since ) and   has only one nontrivial block (see \reff{ThreeCases}(c) for an illustration). Let , where  and .
We branch on the circuit at edge .
In the branch of deleting , we will also delete   and include the following five edges to : , the remaining two edges incident on  and the remaining two edges incident on  (note that since the graph is reduced,  and  are not adjacent and then the five edges are different to each other). In the other branch of including  to , we will delete  and include  to . We can get branch vector
 \eqn{basic_3}{  (5;2).}
  When  is not of the worst case, we can reduce more edges and get \refe{basic_3} at least.

 Since  satisfies the two recurrences corresponding to \refe{basic_1} and \refe{basic_3}, we know that the simple algorithm can solve the TSP problem in an -vertex degree-3 graph in  time, which achieves the same running time bound of Eppstein's algorithm for TSP3 in~\cite{Eppstein:TSP3}.


\section{The measure and conquer method}\label{sec_MaC}
The measure and conquer method, first introduced by  Fomin, Grandoni and Kratsch~\cite{kn:fomin2}, is one of the most powerful tools to analyze exact algorithms.
It can obtain improved running time bound for many branching-and-search algorithms without making any modification to the algorithms. Currently, many best exact algorithms for NP-hard problems are based on this method.
In the measure and conquer method, we may
set a weight of vertices in the instance and use the sum  of the total weight in the graph as the measure
to evaluate the running time. In the algorithm, the measure  should satisfy the \emph{measure condition}: (i) when  the instance can be solved in polynomial time;
(ii) the measure  will never increase in each operation in the algorithm; and (iii) the measure will decrease in each of the subinstances generated by applying a branching rule. With these constraints, we may build recurrences for the branching operations.
Next, we introduce a way of applying the measure and conquer method to the above simple algorithm.

The graph has three different {\em vertex-weight}.
For each vertex , we set its vertex-weight 
to be

We will determine the best value of  such that the worst recurrence in our algorithm is best.
Let . For a subset of vertices (or a subgraph) , we also use  to denote the total vertex-weight in .


Now we analyze the simple algorithm presented in Section~\ref{simple_alg} by using this vertex-weight setting. Note that since we require that , the total vertex weight  in the graph is not greater than the number  of vertices in the graph. We can get a running time bound related to  if we get a running time bound related to .
Here we only examine the three bottleneck cases in \reff{ThreeCases}.

When we branch on a circuit of 6-cycle in \reff{ThreeCases}(a),  in  each branch,
all the six forced vertices will be reduced and then we can reduce  by .
We get the following branching vector:
\eqn{mq1}{[6w_{3'}]_2.}
When we branch on a circuit  of chain of length 2 in \reff{ThreeCases}(b), in the branch where  is included to ,  is deleted, and  and  are also included to  by reduction rules, where  and  are the two neighbors of  other than . Then we can reduce  by  from ,  from ,  from , and  from  and , where . The second branch can be analyzed in a similar manner. We get
\eqn{mq2}{[w_{3'}+\Delta_3+w_3+2\delta_1]_2=[2+2\delta_1]_2.}
When we branch on a circuit  of chain of length 3 in \reff{ThreeCases}(c), in the branch of including  to , we reduce  by  from  and  and  from  and . In the other branch, we can reduce  by  from  and ,  from  and , and  from , where  and  are the two neighbors of  other than  and  and  are the two neighbors of  other than . We get
\eqn{mq3}{(2;2w_3+2w_{3'}+4\delta_1).}
We can verify that under that above three constraints, the best value of  is . With this setting, we can see that \refe{mq1} and \refe{mq2} become \refe{basic_1}, and \refe{mq3} becomes \refe{basic_3}. This also tells us that the measure and conquer method cannot directly derive a better running time bound of the simple algorithm. In the next section, we present a new technique and show an improvement by combining the new technique with the traditional measure and conquer method.

\section{Amortization on connectivity structures}
To improve the time bound by the above simple analysis, we need to use more structural properties of the graph.
Note that for the bottleneck case of \reff{ThreeCases}(a), the above algorithm reduces all the vertices in this -component. It is impossible to improve by reducing more vertices (or edges) and so on. But we also reduce the number of -components by 1. This observation gives us an idea of an amortization scheme over the cut-circuit structure by setting a weight on each -component in the graph.

In this method, each vertex in the graph receives a nonnegative weight as shown in Section~\ref{sec_MaC}. We also set a  weight (which is possibly negative, but bounded from by a constant ) to each -component. Let  be the sum of all vertex weight and -component weight. We will use  to measure the size of the search tree generated by our algorithm.  The measure  will also satisfy the measure condition. Initially there is only one -component and  holds.
If we get a running time bound related to  for our algorithm, then we get a running time bound related to .

A simple idea is to set the same weight to each nontrivial -component.  It is possible to improve the previous best result by using this simple idea. However, to get further improvement, in this paper, we set several different component-weights. Our purpose is to distinguish some ``bad" -components, which will be characterized as  ``critical" -components.

An {\em extension} of a 6-cycle is obtained from a 6-cycle  and a 2-clique 
by joining them with two independent edges  and  ().
An extension of a 6-cycle always has exactly eight vertices.
A chord of an extension of a 6-cycle is an edge between two vertices in it but different from the eight edges
,  and .


A subgraph  of a -component in an instance  is \emph{-pendent critical}, if it is a 6-cycle or an extension of a 6-cycle with
 and 
(i.e.,  has no chord of unforced/forced edge). A -pendent critical -component is also simply called a \emph{critical graph} or \emph{critical -component}.
\reff{critical} illustrates two examples of critical graphs of extensions of a -cycle.
Branching on a critical -component may lead to a bottleneck recurrence in our algorithm.
So we set a different component-weight to this kind of components to get improvement.

\vspace{-0mm}\fig{critical}{0.8}{Extensions of a 6-cycle}{critical}\vspace{-0mm}

For each -component , we set its component-weight   to be

where we set  so that  holds for
every 4-cycle -component .

We also require that the vertex-weight and component-weight satisfy the following requirements
\eqn{requirment1}{2\Delta_3 \geq \gamma \geq \delta \geq \Delta_3 \geq {1\over 2} w_3,~ w_{3'}\geq {1\over 5}w_3 ~~\mathrm{and}~~\gamma-\delta\leq w_{3'}.}
Under these constraints, we still need to decide the values of  and  such that the time bound
derived by the worst recurrences in our algorithm will be minimized.
In \refe{requirment1},  is important, because it will be used to satisfy the measure condition (ii).
The other constraints in \refe{requirment1} are mainly used to simplify some arguments and they will not become the bottleneck in our analysis.
Next, we first describe our simple algorithm.

\section{The algorithm}
A block is called a \emph{normal block} if it is none of trivial, reducible and 2-pendent critical.
A normal block is \emph{minimal} if no subgraph of it is a normal block along any circuit.
Note that when  is not empty, each -component has at least one nontrivial circuit.
Our recursive algorithm for forced TSP  only contains two main steps:\\
{\bf 1.} First apply the reduction rules to a given
instance until it becomes a reduced one; and \\
{\bf 2.} Then take any -component  that is neither trivial nor a 4-cycle
(if no such -component , then the instance is polynomially solvable
by \refl{solvable}),
 and branch on a nontrivial circuit  in , where
 is chosen so that \\
(1) no normal block appears along 
(i.e.,  has only trivial and 2-pendent critical blocks)  if this kind of circuit exist;
 and \\
(2)  a minimal normal
 block  in  appears along   otherwise.

We  use  as the measure to analyze the size of the search tree in our algorithm.
It is easy to see that after applying the reduction rules on a 2-edge-connected instance,
 the resulting instance remains 2-edge-connected. By this observation and \refl{circuitprocess},
we can guarantee that  an input instance is always 2-edge-connected. Our analysis is based on this.

\subsection{Basic properties of the measure}
Before analyzing the time bound on our algorithm,
we first give basic properties of  the measure  .

We show that the measure will not increase after applying any reduction operation  in an 2-edge-connected instance.
Since an input instance is 2-edge-connected,  there is no eliminable edge.
In fact, we always deal with eliminable edges in circuit procedures.
For reducible edges, we deal with them during a process of a reducible circuit
(including the reducible edges to  and dealing with the resulting eliminable edges).
We will show that  never increases after processing a circuit.
The measure  will not increase after deleting any unforced parallel edge.
The following lemma also shows that  applying the /-cut reduction does not increase .

\lem{reductionM}{For a given instance, \\
{\rm (i)} applying the -cut reduction does not increase the measure ; and \\
{\rm (ii)} applying the -cut reduction on a -component  decreases the measure   by .}
\pf{It is easy to observe (i).
Next we prove (ii). In the case where the resulting graph consists of four single vertices or a pair of forced edges
after applying the -cut reduction,
the whole component  is eliminated, decreasing  by  and then the lemma holds.
Otherwise the resulting component, say  is a -cycle,
where  according to our setting on the component-weight of -cycles,
and  again decreases by .
 }\bigskip


\bigskip
Next we consider how much amount of measure decreases by processing a circuit.
We consider that the measure   becomes zero whenever
we find an instance infeasible by \refl{infeasibility}.
After processing a circuit
 in a -component ,
each block  along  becomes a new -component, which we denote by .
We define the {\em direct benefit}  from  to
be the decrease in vertex-weight of the endpoints  and  of 
minus the component-weight  in the new instance after the circuit procedure.
Immediately after the procedure, the measure  decreases
by .
After the circuit procedure, we see that
the vertex-weights of endpoints of each non-reducible and nontrivial block  decreases
by  and  (or  and ) respectively if   is even,
and
by  and  (or  and ) respectively if  is odd.
Summarizing these, the direct benefit  from a block  is given
by


By \refe{requirment1}, we have that  for any type of block , which implies that
the decrease  (where  is not a 4-cycle) is in fact nonnegative,
i.e.,    the measure  never increases by processing a circuit.

After processing a circuit , a reduction operation may be applicable to some -components 
 and we can decrease  more by reducing them. The \emph{indirect benefit}  from a block  is defined as the amount of  decreased by applying reduction rules on the -component  after processing the circuit. Since we have shown that  never increases by applying reduction rules, we know that   is always nonnegative. The \emph{total benefit} (\emph{benefit}, for short) from a block  is


\lem{circuit_reduce1}{After processing a circuit  in a -edge-connected -component  not necessary being reduced and applying reduction rules until the instance becomes a reduced one, the measure  decreases by

where  are the blocks along circuit .
}\bigskip

The indirect benefit from a block depends on the structure of the block.
In our algorithm, we hope that the indirect benefit is as large as possible.
Here we prove some lower bounds on it for some special cases.



\lem{further1}{Let  be a -component containing no induced triangle and  be a reducible circuit in it such that there is exactly one reducible block along . The measure  decreases by at least  by processing the reducible circuit  and applying reduction rules.
}
\pf{By assumption, the reducible circuit  has at least two blocks, one reducible block  and one non-reducible block .
(1) Assume that  every other block than   along  is trivial.
Then  should be a cycle of length  (if  is a 4-cycle, then there are three odd blocks along  and we find the instance infeasible by \refl{infeasibility}).
There are  trivial blocks along . After processing the circuit,   the whole component  will be eliminated decreasing 
by at least  (by \refe{requirment1}).
(2) Otherwise, i.e., there is a block  of more than one vertex ( is not trivial or reducible):
(2-i)   is deleted in the circuit procedure:
Then  decreases  by at least
 by (\ref{beta-1}).
Hence assume that  is included to  in (2).
(2-ii)  is not 2-pendent critical:
 Then the measure  decreases by at least .
The remaining case is that  is 2-pendent critical and  is included to .
(2-iii)  there are only two blocks  and  along :
By processing  the circuit , the two edges in  become forced edges.
Since they are incident on the single vertex  in ,
we can replace  and  with a single forced edge  and then  becomes
a 0-pendent 6-cycle or extension of a 6-cycle with only one forced chord .
After the circuit procedure of , we can apply 4-cut reduction to the 0-pendent 6-cycle  (by \refl{reducecritical})
 and then this decreases  by  (by \refl{reductionM}(ii)).
(2-iv)  there is a pair of  two trivial blocks  and  or a nontrivial and non-reducible block  along :  Now we can decrease  by at least  (by \refe{requirment1}).

In any case,  the measure  decreases by at least .
}


\lem{indirectB}{In the circuit procedure for a circuit  in a reduced instance, the indirect benefit from a block  along  satisfies

}

\pf{We will use  to denote the -component resulting from  after the circuit procession.
Case (i): Since  is odd,
only one edge in  is deleted (the other one is included to ) in the circuit procession. Then there is exactly one vertex of degree 2 in , which is the only reducible block along a circuit  in . Since the original instance is reduced and contains no triangle, we know that circuit  satisfies the condition in \refl{further1}. By processing  in , we can decrease  by at least  by \refl{further1}.
Then we get .
For case (ii),  if  is a -pendent cycle, we can reduce the whole -component  after the circuit
procedure, and then we have .
Otherwise   in (ii) is a -pendent critical graph and the 4-cut reduction can be applied to 
 by  \refl{reducecritical} since the two end vertices of edges in  will be of degree 2 in  
after  is deleted.
Then we still have  by \refl{reductionM}(ii). Note that  (by the definition of ). We get
.
For Case (iii), we will get at least one reducible circuit  in . Note that  has some vertex of degree 2 and cannot be a critical graph.
Hence .
By processing the reducible circuit , we can decrease 
 by at least , where  are the blocks along .
The inequality in (iv) holds since we have proved that  will never increase after applying reduction rules.
 }




\section{The Analysis}Now we are ready to analyze our algorithm.
In the algorithm,   branching on a circuit  generates two instances  and .
By \refl{circuit_reduce1}, we get branch vector

where  ,  and   denote
the functions ,  and  evaluated in , 
for clarifying how branch vectors are derived in the subsequent analysis.
We consider this branch vector for different cases.
First we analyze the easy case where the chosen circuit  has no normal block.
Then  we analyze the somewhat complicated case
where there is a minimal normal block along .

\subsection{Circuits with only trivial and -pendent critical blocks}
In this subsection, we assume that the chosen circuit  in a -component  (not a 4-cycle)
has only trivial and -pendent critical blocks.
We consider the following three cases.

{\bf Case 1.} All blocks along  are trivial blocks: Now  should be a cycle of even length .
By (\ref{beta-1}) and \refl{circuit_reduce1}, we know that
in each branch we can decrease  by at least
 
Then we get branch vectors
 \eqn{6-cycle}{ [6w_{3'}+\gamma]_2 }
for  
and  for ,
 which is covered by \refe{6-cycle}.
Note that \refe{6-cycle} is tight for a circuit of 6-cycle in \reff{ThreeCases}(a).


{\bf Case 2.} There is only one 2-pendent critical block  along :
Since  is even, the number  of trivial blocks (odd blocks) along  is also even by the parity condition.
Note that if  and  is 2-pendent 6-cycle then  is a critical graph (an extension of a 6-cycle) and . Otherwise  is not critical and .
Then in the branch where  is deleted, the  decrease  of  is at least


In the branch where  is included to , the  decrease  of  is at least

This gives branch vector
 \eqn{6-cycle-extension}{
(\gamma+2w_3+6w_{3'}; \delta+2w_3-\gamma).
 }

{\bf Case 3.} There are at least two 2-pendent critical blocks  and  along :
If  is included to  in the branch where  is deleted,
then we can get branch vector
, which is covered by \refe{6-cycle}.
On the other hand, if  is also deleted in the branch where  is deleted, we get branch vector
\eqn{good2a}{(\delta+2(2\Delta_3-\gamma); \delta+2(2w_3+4w_{3'})).}


\subsection{Circuits with a minimal normal block}
In this subsection, we assume that the chosen circuit  in a -component 
has a minimal normal block . Now  always holds.
We distinguish several cases to analyze the branch vectors.


{\bf Case 1.} Block  is odd: Circuit   has another odd block .
By (\ref{beta-1}) we have  
  in each branch.
For , we have that
 and  by \refl{indirectB}.
In each branch,    decreases by at least
.
Therefore, we can get
branch vector
\eqn{even1}{  [4w_3-2w_{3'}]_2.}
Note that \refe{even1} is tight for a circuit of chain of length 2 in \reff{ThreeCases}(b).

\bigskip
Next, we assume that  is even.
In the branch where  is included to , we have that .
In the other branch, we have that .
By branching on , we get branch vector

where  (),  and .
We here evaluate  and .
If all blocks other than  along  are 2-pendent critical, then we have that  and .
Otherwise,  and .
We have the following two choices for :
\eqn{xi_bound}{
(\xi_1 , \xi_2) = (2\Delta_3-\gamma , 2w_3+4w_{3'}) \ \ \  {\rm and} \ \ \ (2w_{3'} , 2w_{3'}).
}
In what follows,   we derive some lower bounds on  and 
by examining the structure of .

 Let  ,
where  and  are in . Let  and  be the two resulting instances after branching and processing the circuit , where  corresponds to the branch where  is included to  and  corresponds to the branch where  is deleted. Let  and  (resp.,  and ) be the two unforced edges incident on  (resp., ) in . Note that  and  (resp.,  and ) will be in the same circuit  (resp., ) in , since  (resp., ) is a forced vertex now.
See \reff{normalblock} for illustrations of the structure of the edges incident to  and .
\vspace{-0mm}\fig{normalblock}{1}{Illustrations of block : (a) ;
(b)  and  and  are adjacent;
(c)  and  and  are not adjacent.}{normalblock}\vspace{-0mm}


{\bf Case 2.} Block  is even and  and  are two different circuits in 
(see \reff{normalblock}(a)):
Now  and  are two different circuits also  in .
In the branch where  is deleted, we have
  (by applying \refl{further1} to  and ).
Next we consider the other blocks along .

Case 2.1. There are at least two odd blocks  and  along :
By (\ref{beta-1}),  and  ().
Since , we get branch vector
\eqn{odd_chain3}{ (\delta+(2\Delta_3-\delta)+2w_{3'};\delta+(2w_3-\delta)+4\Delta_3+2w_{3'})=(2w_3; 6w_3-2w_{3'}).}

Case 2.2. There is no odd block along :
 Let  be the block along  containing vertex .
Then  is an even block
such that  is also included to  in the branch
 where  is included to .
Then .
If  is not a 2-pendent critical block, then ,  and  (by \refl{indirectB}), and we get branch vector
\eqn{new_1}{ (\delta+2(2\Delta_3-\delta); \delta+(2w_3-\delta)+ 4\Delta_3+2w_3)=(4\Delta_3-\delta; 4w_3+4\Delta_3).
}
Otherwise  is a 2-pendent critical block. Then 
and  (by (\ref{beta-1}) and \refl{indirectB}).
We get branch vector
, i.e.,
\eqn{new_2}{ (4\Delta_3-\gamma; 8w_3).
}

{\bf Case 3.} Block  is even and  in  (see \reff{normalblock}(b),(c)):
 First of all, we consider ,  and others.
We look at the circuit  in .
 Except blocks  and , there are some other blocks along .
Note that each block  along  should be a trivial or 2-pendent critical block since  is a minimal normal block.
We distinguish three cases by considering the number of critical blocks along .

Case 3.1.  is a 2-pendent cycle of length  (all blocks along  are trivial in ):
Then  is an even integer with  or    (since  is even and non-critical). When , in both branches, we have
.
Then we can branch with a branch vector   covered by \refe{6-cycle}.
Next we assume that .
Now we may  get only  and  instead of .
 But it holds that .
We get branch vector
\eqn{new_m1}{(\delta+(2\Delta_3-\delta)+\xi_1; \delta+(2w_3+6 w_{3'})+\xi_2).}



Case 3.2. There are only three blocks ,  and  along  in  ,
where  is a 2-pendent critical block:
Now  and  are adjacent (see \reff{normalblock}(b)). We assume that , , and .
We look at  wherein  and  are degree-2 vertices.
After including edges ,  and  to ,
 becomes a -cut reducible graph by \refl{reducecritical}.
Then  decreases by 
after applying the 4-cut reduction. Then we know that .
Therefore, we get branch vector

which is covered by \refe{new_m1}.

Case 3.3.  is not a 2-pendent cycle and there are more than three blocks along  in  :
Then there is a nontrivial and nonreducible block  along  in  , where
  is a 2-pendent critical block since  is a minimal normal block.
For this case, we only get the following branch vector by branching on :

\eqn{basic1}{ (2\Delta_3+\xi_1; 2w_3+\beta''_2(B_1)+\xi_2).
}
In fact, the branch vector \refe{basic1} in Case~3.3 can be the bottleneck in the analysis of our algorithm.
However, in , circuit  is a circuit with only trivial and 2-pendent critical blocks.
In our algorithm, circuit  will be one of the circuits for the next branching,
and it will never be destroyed until we branch on it.
In fact,  branching on  proves a  branch vector better than \refe{basic1}.
For the purpose of analysis, we derive a branch vector for the three branches, i.e.,
 the branching on  followed by  the branching on
 in  in the branch of including   into .


In Case~3.3, we see that:  either
()  has at least two trivial blocks  and  different from  and  (since the number of odd blocks is even); or () all blocks other than  and   are 2-pendent critical.

Case (): There is also a 2-pendent critical block  along  (since  is not a 2-pendent cycle). In , we can see that  (since  and  are trivial blocks). In  , by branching on , we can get branch vector 

By combining it with \refe{basic1} and taking , we get branch vector
\eqn{new_m2}{
(2\Delta_3 \!+\! \xi_1 \!\!+\! (\delta \!+\! 2w_3 \!+\! 2w_{3'} \!-\! \gamma);
2\Delta_3 \!+\! \xi_1 \!\!+\! (\delta \!+\! 2w_3 \!+\! 8w_{3'}\!);
2w_3 \!+\! \delta \!+\! 2w_{3'} \!+\! \xi_2).~~~~
}

Case (): There are at least two 2-pendent critical blocks  and  along  (since there are at least four blocks among ).
In , we may  get only .
In  , by branching on ,  at least we can get branch vector

By combining it with \refe{basic1} and taking , we get branch vector
\eqn{new_m3}{
(2\Delta_3 \!+\! \xi_1 \!+\! (\delta \!+\! 4w_3 \!-\! 2w_{3'} \!-\! 2\gamma);
2\Delta_3 \!+\! \xi_1 \!+\! (\delta \!+\! 4w_3 \!+\! 10w_{3'});
2w_3 \!+\! \delta \!+\! \xi_2).
}


Finally, by replacing  and   in \refe{new_m1}, \refe{new_m2} and \refe{new_m3} respectively
with the bounds in \refe{xi_bound}, we get the following six branch vectors
\eqn{new_3_1}{
(4\Delta_3-\gamma; \delta+4w_3+10 w_{3'}),}
\eqn{new_3_2}{
(2w_3; \delta+2w_3+8w_{3'}),
}
\eqn{new_3_3}{
(\delta+6w_3-2w_{3'}-2\gamma; \delta+6w_3+4w_{3'}-\gamma;
\delta+4w_3+6w_{3'}),
}
\eqn{new_3_4}{
(\delta+4w_3+2w_{3'}-\gamma;\delta+4w_3+8w_{3'};
\delta+2w_3+4w_{3'}),
}
\eqn{new_3_5}{
(\delta+8w_3-6w_{3'}-3\gamma;\delta+8w_3+6w_{3'}-\gamma;
\delta+4w_3+4w_{3'}),
}
and
\eqn{new_3_6}{
(\delta+6w_3-2w_{3'}-2\gamma;\delta+6w_3+10w_{3'};
\delta+2w_3+3w_{3'}).
}


\subsection{Overall analysis}

A quasiconvex program is obtained from \refe{requirment1} and 13 branch vectors
(from \refe{6-cycle} to \refe{new_2} and from \refe{new_3_1} to \refe{new_3_6})
in our analysis.
There is a general method to solve quasiconvex programs \cite{eQP}.
For our quasiconvex program, we observe a simple way to solve it.
We look at \refe{6-cycle} and \refe{even1}. Note that  under the constraint  gets the maximum value at the time when  and . We get  and . With this setting, we can verify that when , all branch vectors other than
\refe{6-cycle} and \refe{even1} in our quasiconvex program will not be the bottleneck.
We get a time bound  with  by setting
, and  for our problem.
The bottlenecks in the analysis are   \refe{6-cycle}, \refe{even1} and  in \refe{requirment1}.


\thm{result}{TSP in an -vertex graph  with maximum degree 3
can be solved  in  time and polynomial space.}

\section{Concluding Remarks}\label{sec:conclude}

In this paper, we have presented an improved exact algorithm for TSP
in  degree-3 graphs.
The basic operation in the algorithm is to process the edges
in a circuit by either
including an edge in the circuit to the solution or excluding
 it from the solution.
The algorithm is analyzed by using the measure and conquer method and
an amortization scheme over the cut-circuit structure of graphs,
wherein we introduce not only weights of vertices but also
weights of -components to define
the measure of an instance.

The idea of amortization schemes introducing weights on
components may yield better bounds for other exact algorithms
for graph problems if
how reduction/branching procedures change the system of
components  is successfully analyzed.


\begin{thebibliography}{99}


\bibitem{Bjorklund:Hamiltonicity}
Bjorklund, A.:
\newblock Determinant sums for undirected Hamiltonicity.
\newblock In: Proc. 51st Annual IEEE Symp. on Foundations of Computer Science (2010)  173-182

\bibitem{Bjorklund:TSPbounded}
Bjorklund, A., Husfeldt, T., Kasaki, P. and Koivisto, M.:
\newblock The travelling salesman problem in bounded degree graphs.
\newblock In: ICALP 2008, LNCS 5125 (2008) 198-209


\bibitem{Dorn:Planar}
Dorn, F., Penninkx, E., Bodlaender, H.~L., and Fomin, F.~V.:
\newblock Efficient exact algorithms on planar graphs: Exploiting sphere cut decompositions.
\newblock Algorithmica  58(3) (2010)  790-810

\bibitem{eQP}
Eppstein, D.:
Quasiconvex analysis of multivariate recurrence equations
for backtracking algorithms.
ACM Trans. on Algorithms  2(4) (2006) 492-509

\bibitem{Eppstein:TSP3}
Eppstein, D.:
\newblock The traveling salesman problem for cubic graphs.
\newblock J. Graph Algorithms and Applications 11(1) (2007)  61-81

\bibitem{kn:fomin2}
Fomin,~F., Grandoni, F., Kratsch, D.
Measure and Conquer: Domination - A Case Study,
{\em ICALP\/} Springer-Verlag LNCS~3580 (2005),
pp.~191--203.

\bibitem{Fomin:book}
Fomin, F. V.,  Kratsch, D.:
Exact Exponential Algorithms, Springer (2010)

\bibitem{Gebauer:TSP4}
Gebauer, H.:
\newblock Finding and enumerating Hamilton cycles in 4-regular graphs.
\newblock Theoretical Computer Science  412(35) (2011)  4579-4591

\bibitem{Iwama:TSP3}
Iwama, K. and Nakashima, T.:
\newblock An improved exact algorithm for cubic graph TSP.
\newblock In: COCOON 2007.
LNCS  4598
(2007) 108-117


\bibitem{NI92}
 Nagamochi, H., Ibaraki, T.:
A linear time algorithm for computing 3-edge-connected
 components in multigraphs,
 { J. of Japan Society for Industrial and Applied Mathematics},
 9(2) (1992) 163-180

\bibitem{NI:book}
 Nagamochi, H., Ibaraki, T.:
 Algorithmic Aspects of Graph Connectivities, Encyclopedia of Mathematics and Its Applications, Cambridge University Press (2008)

\bibitem{Woeginger:Exactalg}
Woeginger, G.~J.:
\newblock  Exact algorithms for NP-hard problems: A survey.
\newblock In: Combinatorial Optimization. LNCS 2570 (2003)  185-207


\bibitem{XN:tsp4}
  Xiao, M. and  Nagamochi, H.:
\newblock  An improved exact algorithm for TSP in degree- graphs.
\newblock In: COCOON 2012.
LNCS 7434 (2012) 74-85

\end{thebibliography}

\end{document}
