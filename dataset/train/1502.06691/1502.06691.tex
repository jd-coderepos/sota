\documentclass[11pt,letterpaper]{article}
\usepackage{times,mathptmx}
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\usepackage{fullpage}
\usepackage{amsmath,amsfonts,amssymb,amsthm,amscd}
\usepackage{tabularx,arydshln}
\usepackage{hyperref,cite}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\svs}{\vspace{0.7mm}}
\newcommand{\vs}{\vspace{1.5mm}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{assumption}[theorem]{Assumption}
\newcommand{\eqdef}{\stackrel{def}{=}}
\newcommand{\G}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\Adv}{\textbf{Adv}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\tb}[1]{\textbf{#1}}
\newcommand{\lb}{\linebreak[0]}
\newcommand{\db}{\displaybreak[0]}

\title{Sequential Aggregate Signatures with Short Public Keys\\ without
    Random Oracles\footnote{This paper is the combined and extended version
    of two papers \cite{LeeLY13s,LeeLY13m} that appeared in PKC 2013 and
    ACNS 2013, respectively.}}

\author{
    Kwangsu Lee\footnote{Korea University, Seoul, Korea.
        Email: \texttt{guspin@korea.ac.kr}.}
        \and
    Dong~Hoon Lee\footnote{Korea University, Seoul, Korea.
        Email: \texttt{donghlee@korea.ac.kr}.}
        \and
    Moti Yung\footnote{Google Inc. and Columbia University, NY, USA.
        Email: \texttt{moti@cs.columbia.edu}.}
}

\date{}

\begin{document}

\maketitle

\begin{abstract}
The notion of aggregate signature has been motivated by applications and it
enables any user to compress different signatures signed by different
signers on different messages into a short signature. Sequential aggregate
signature, in turn, is a special kind of aggregate signature that only
allows a signer to add his signature into an aggregate signature in
sequential order. This latter scheme has applications in diversified
settings such as in reducing bandwidth of certificate chains and in secure
routing protocols. Lu, Ostrovsky, Sahai, Shacham, and Waters (EUROCRYPT
2006) presented the first sequential aggregate signature scheme in the
standard model. The size of their public key, however, is quite large
(i.e., the number of group elements is proportional to the security
parameter), and therefore, they suggested as an open problem the
construction of such a scheme with short keys.

In this paper, we propose the first sequential aggregate signature schemes
with short public keys (i.e., a constant number of group elements) in prime
order (asymmetric) bilinear groups that are secure under static assumptions
in the standard model. Furthermore, our schemes employ a constant number of
pairing operations per message signing and message verification operation.
Technically, we start with a public-key signature scheme based on the
recent dual system encryption technique of Lewko and Waters (TCC 2010).
This technique cannot directly provide an aggregate signature scheme since,
as we observed, additional elements should be published in a public key to
support aggregation. Thus, our constructions are careful augmentation
techniques for the dual system technique to allow it to support sequential
aggregate signature schemes. We also propose a multi-signature scheme with
short public parameters in the standard model.
\end{abstract}

\vs \noindent {\bf Keywords:} Public-key signature, Aggregate signature,
Sequential aggregate signature, Dual system encryption, Bilinear maps.

\newpage
\tableofcontents
\newpage

\section{Introduction}

Aggregate signature is a relatively new type of public-key signature (PKS)
that enables any user to combine  signatures signed by  different
signers on  different messages into a short signature. The concept of
public-key aggregate signature (PKAS) was introduced by Boneh, Gentry, Lynn,
and Shacham \cite{BonehGLS03}, and they proposed an efficient PKAS scheme in
the random oracle model using bilinear groups. After that, numerous PKAS
schemes were proposed using bilinear groups \cite{GentryR06,LuOSSW06,
LuOSSW13,BoldyrevaGOY07,BoldyrevaGOY10,AhnGH10,GerbushLOW12} or using
trapdoor permutations \cite{LysyanskayaMRS04,BellareNN07,Neven08}.

One application of aggregate signature is the certificate chains of the
public-key infrastructure (PKI) \cite{BonehGLS03}. The PKI system has a tree
structure, and a certificate for a user consists of a certificate chain from
a root node to a leaf node, each node in the chain signing its predecessor.
If the signatures in the certificate chain are replaced with a single
aggregate signature, then bandwidth for signature transfer can be
significantly saved. Another application is to the secure routing protocol of
the Internet protocol \cite{BonehGLS03}. If each router that participates in
the routing protocol uses a PKAS scheme instead of a PKS scheme, then the
communication overload of signature transfer can be dramatically reduced.
Furthermore, aggregate signatures have other applications such as reducing
bandwidth in sensor networks or ad-hoc networks, as well as in software
authentication in the presence of software update \cite{AhnGH10}.

\subsection{Previous Methods}

Aggregate signature schemes are categorized as {\it full} aggregate
signature, {\it synchronized} aggregate signature, and {\it sequential}
aggregate signature depending on the type of signature aggregation. They have
also been applied to regular signatures in the PKI model and to ID-based
signatures (with a trusted key server).

The first type of aggregate signature is \textit{full aggregate signature},
which enables any user to freely aggregate different signatures of different
signers. This full aggregate signature is the most flexible aggregate
signature since it does not require any restriction on the aggregation step
(though restriction may be needed at times for certain applications).
However, there is only one full aggregate signature scheme, proposed by Boneh
et al. \cite{BonehGLS03}\footnote{Subsequent to our work, Hohenberger et al.
\cite{HohenbergerSW13} proposed an identity-based aggregate signature scheme
that supports full aggregation based on the recently introduced candidate
multilinear maps of Garg et al. \cite{GargGH13}.}. Since this scheme is based
on the short signature scheme of Boneh et al. \cite{BonehLS01}, the signature
length it provides is also very short. However, the security of the scheme
has just been proven in the idealized random oracle model and the number of
pairing operations in the aggregate signature verification algorithm is
proportional to the number of signers in the aggregate signature.

The second type of aggregate signature is \textit{synchronized aggregate
signature}, which enables any user to combine different signatures with the
same synchronizing information into a single signature. The synchronized
aggregate signature has one drawback: all signers should share the same
synchronizing information (such as a time clock or another shared value).
Gentry and Ramzan \cite{GentryR06} introduced the concept of synchronized
aggregate signature. They proposed an identity-based synchronized aggregate
signature scheme using bilinear groups, and they proved its security in the
random oracle model. We note that identity-based aggregate signature (IBAS)
is an ID-based scheme and thus relies on a trusted server knowing all private
keys (i.e., its trust structure is different from that in regular PKI).
However, it also has a notable advantage in that it is not required to
retrieve the public keys of signers in the verification algorithm since an
identity string plays the role of a public key (this lack of public key is
indicated in our comparison table as public key of no size!). Recently, Ahn
et al. \cite{AhnGH10} presented a public-key synchronized aggregate signature
scheme without relying on random oracles.

The third type of aggregate signature is \textit{sequential aggregate
signature} (SAS), which enables each signer to aggregate his signature to a
previously aggregated signature in a sequential order. The sequential
aggregate signature has the obvious limitation of signers being ordered to
aggregate their signatures in contrast to the full aggregate signature and
the synchronized aggregate signature. However, it has an advantage in that it
is not required to share synchronized information among signers in contrast
to the synchronized aggregate signature, and many natural applications lead
themselves to this setting. The concept of sequential aggregate signature was
introduced by Lysyanskaya, Micali, Reyzin, and Shacham
\cite{LysyanskayaMRS04}, and they proposed a public-key sequential aggregate
signature scheme using the certified trapdoor permutations in the random
oracle model. Boldyreva et al. \cite{BoldyrevaGOY07} presented an
identity-based sequential aggregate signature scheme in the random oracle
model using an interactive assumption, but it was shown by Hwang et al.
\cite{HwangLY09} that their construction is not secure. After that, Boldyreva
et al. \cite{BoldyrevaGOY10} proposed a new identity-based sequential
aggregate signature by modifying their previous construction and proved its
security in the generic group model. Recently, Gerbush et al.
\cite{GerbushLOW12} showed that the modified IBAS scheme of Boldyreva et al.
\cite{BoldyrevaGOY10} is secure under static assumptions using the dual form
signatures framework.

The first sequential aggregate signature scheme without random oracle
idealization was proposed by Lu et al. \cite{LuOSSW06,LuOSSW13}. They
converted the PKS scheme of Waters \cite{Waters05} to the PKAS scheme and
proved its security under the well known CDH assumption. However, their
scheme has a drawback since the number of group elements in a public key is
proportional to the security parameter (for a security of  they need
 elements, or about  elements in a larger group); so they left as an
open question how to design a scheme with shorter public keys. Schr{\"o}der
proposed a PKAS scheme with short public keys relying on the
Camenisch-Lysyanskaya signature scheme \cite{Schroder11}; however the
scheme's security is proven under an interactive assumption (which,
typically, is a relaxation used when designs based on static assumptions are
hard to find).\footnote{Gerbush et al. \cite{GerbushLOW12} showed that a
modified Camenisch-Lysyanskaya signature scheme in composite order groups is
secure under static assumptions. However, it is unclear whether the
construction of Schr{\"o}der can be directly applied to this modified
Camenisch-Lysyanskaya signature scheme. The reason is that aggregating
 and  subgroups is hard and a private key element
 cannot be generated by the key generation
algorithm of an aggregate signature scheme. Additionally, our work and
findings are independent of the work of Gerbush et al.} Therefore, the
construction of an SAS scheme with short public keys without relaxations such
as random oracles or interactive assumptions was left as an open question.

\begin{table*}[t]
\caption{Comparison of aggregate signature schemes} \label{tab:pkas-compare}
\vs \small \addtolength{\tabcolsep}{0.6pt}
\renewcommand{\arraystretch}{1.2}
    \begin{tabularx}{6.50in}{lcccccccl}
    \hline
    Scheme                  & Type & ROM & KOSK & PK Size & AS Size
                            & Sign Time & Verify Time & Assumption \\
    \hline
    BGLS \cite{BonehGLS03}  & Full & Yes & No &  & 
                            & E & P& CDH \\
    \cdashline{2-9}
    GR \cite{GentryR06}     & IB, Sync & Yes & No & -- & 
                            & E & P + E & CDH \\
    AGH \cite{AhnGH10}      & Sync & Yes & Yes &  & 
                            & E & P + E & CDH \\
    AGH \cite{AhnGH10}      & Sync & No  & Yes &  & 
                            & E & P + E & CDH \\
    \cdashline{2-9}
    LMRS \cite{LysyanskayaMRS04} & Seq & Yes & No &  & 
                            & E & E & cert TDP \\
    Neven \cite{Neven08}    & Seq & Yes & No &  & 
                            & E + M & M & uncert CFP \\
    BGOY \cite{BoldyrevaGOY10} & IB, Seq  & Yes & No & -- & 
                            & P + E & P + E & Interactive \\
    GLOW \cite{GerbushLOW12} & IB, Seq  & Yes & No & -- & 
                            & P + E & P + E & Static \\
    \cdashline{3-9}
    LOSSW \cite{LuOSSW06}   & Seq & No & Yes &  & 
                            & P + M & P + M & CDH \\
    Schr\"oder \cite{Schroder11} & Seq  & No & Yes &  & 
                            & P + E & P + E & Interactive \\
    Ours                    & Seq  & No & Yes &  & 
                            & P + E & P + E & Static \\
    Ours                    & Seq  & No & Yes &  & 
                            & P + E & P + E & Static \\
    \hline
    \multicolumn{9}{l}{ROM = random oracle model, KOSK = certified-key model,
    IB = identity based} \\
    \multicolumn{9}{l}{ = security parameter,
     = the bit size of elements for pairing and factoring,  =
    the number of signers} \\
    \multicolumn{9}{l}{P = pairing computation, E = exponentiation,
    M = multiplication}
    \end{tabularx}
\end{table*}

\subsection{Our Contributions}

Challenged by the above question, the motivation of our research is to
construct an efficient SAS scheme secure in the standard model (i.e., without
employing assumptions such as random oracle or interactive assumptions as
part of the proof) with short public keys (e.g., a constant number of group
elements). To achieve this goal, we use the PKS scheme derived from the
identity-based encryption (IBE) scheme, which adopts the innovative dual
system encryption techniques of Waters \cite{Waters09,LewkoW10}. That is, an
IBE scheme is first converted to a PKS scheme by the clever observation of
Naor \cite{BonehF01}. The PKS schemes that adopt the dual system encryption
techniques are the scheme of Waters \cite{Waters09}, which includes a random
tag in a signature, and the scheme of Lewko and Waters \cite{LewkoW10}, which
does not include a random tag in a signature. The scheme of Waters is not
appropriate to aggregate signatures since the random tags in signatures
cannot be compressed into a single value. The scheme of Lewko and Waters in
composite order groups is easily converted to an aggregate signature scheme
if an element in  is moved from a private key to a public key, but
it is inefficient because of composite order groups.\footnote{We can safely
move the element in  from a private key to a public key since it is
always given in assumptions. Lewko obtained a prime order IBE scheme by
translating the Lewko-Waters composite order IBE scheme using the dual
pairing vector spaces \cite{Lewko12}. One may consider to construct an
aggregate signature scheme using this IBE scheme. However, it is not easy to
aggregate individual signatures since the dual orthonormal basis vectors of
each users are randomly generated.}

Therefore, we start the construction from the IBE scheme of Lewko and Waters
(LW-IBE) \cite{LewkoW10} in the prime order (asymmetric) bilinear groups.
However, this LW-PKS scheme, which is directly derived from the LW-IBE
scheme, is not easily converted to an SAS scheme (as far as we see). The
reason is that we need a PKS scheme that supports multi-users and public
re-randomization to construct an SAS scheme by using the randomness reuse
technique of Lu et al. \cite{LuOSSW06}, but the LW-PKS scheme does not
support these two properties. Technically speaking, this directly converted
LW-PKS scheme does not support multi-users and public re-randomization since
group elements  cannot be published in a public key. To
resolve this problem, we devised two independent solutions. Our first
solution for this problem is to randomize the verification algorithm of the
LW-PKS scheme and publish  in the public key. That is, the
verification components are additionally multiplied by  to prevent the verification of invalid
signatures. Our second solution for this problem is to randomize the group
elements of the public key. That it, we publish  in the public key instead of .

Here we first construct two PKS schemes in prime order (asymmetric) bilinear
groups that support multi-users and public re-randomization by applying our
two solutions to the LW-PKS scheme, and we prove their security by using the
dual system encryption technique. Next, we convert the modified PKS schemes
to SAS schemes with short public keys by using the randomness reuse
technique, and then we prove their security based on the traditional static
assumptions without random oracles. Additionally, we present an efficient
multi-signature scheme based on our modified PKS scheme. Table
\ref{tab:pkas-compare} gives the comparison of past aggregate signature
schemes with ours.

\subsection{Additional Related Work}

There are some works on aggregate signature schemes that allow signers to
communicate with each other or schemes that compress only partial elements of
a signature in the aggregate algorithm \cite{BellareN07,BagherzandiJ10,
Herranz06,BrogleGR12}. Generally, communication resources of computer systems
are very expensive compared with computation resources. Thus, it is preferred
to perform several expensive computational operations rather than one single
communication exchange. Additionally, a signature scheme with added
communications does not correspond to a pure PKS scheme, but corresponds more
to a multi-party protocol. In addition, PKS schemes that compress just
partial elements of signatures cannot be considered aggregate signature
schemes since the total size of signatures is still proportional to the
number of signers.

Another research area related to aggregate signature is multi-signature
\cite{ItakuraN83,Boldyreva03,LuOSSW06}. Multi-signature is a special type of
aggregate signature in which all signers generate signatures on the same
message, and then any user can combine these signatures into a single
signature. Aggregate message authentication code (AMAC) is the symmetric key
analogue of aggregate signature: Katz and Lindell \cite{KatzL08} introduced
the concept of AMAC and showed that it is possible to construct an AMAC
scheme based on any message authentication code scheme.

\section{Preliminaries}

In this section, we define asymmetric bilinear groups and introduce the
complexity assumptions for our schemes. The description of LW-IBE and LW-PKS
schemes is given in Appendix \ref{sec:lw-ibe}.

\subsection{Asymmetric Bilinear Groups}

Let  and  be multiplicative cyclic groups of prime
order . Let  and  be generators of  and ,
respectively. The bilinear map 
has the following properties:
\begin{enumerate}
\item Bilinearity:  and
    , .
\item Non-degeneracy: , that is,  is a
    generator of .
\end{enumerate}
We say that  are bilinear groups with no efficiently
computable isomorphisms if the group operations in  and 
as well as the bilinear map  are all efficiently computable, but there are
no efficiently computable isomorphisms between  and .

\subsection{Complexity Assumptions}

We employ four assumptions in prime order bilinear groups. The SXDH and DBDH
assumptions have been used extensively, while the LW1 and LW2 assumptions
were introduced by Lewko and Waters \cite{LewkoW10}.

\begin{assumption}[Symmetric eXternal Diffie-Hellman, SXDH]
Let  be a description of the asymmetric bilinear
group of prime order . Let  be generators of 
respectively. The assumption is that if the challenge values
    
are given, no PPT algorithm  can distinguish 
from  with more than a negligible advantage. The
advantage of  is defined as  where the probability is
taken over the random choice of .
\end{assumption}

\begin{assumption}[LW1]
Let  be a description of the asymmetric bilinear
group of prime order  with the security parameter . Let  be generators of  respectively. The assumption is that
if the challenge values
    
are given, no PPT algorithm  can distinguish  from  with more than a negligible advantage. The
advantage of  is defined as  where the probability is
taken over the random choice of .
\end{assumption}

\begin{assumption}[LW2]
Let  be a description of the asymmetric bilinear
group of prime order . Let  be generators of 
respectively. The assumption is that if the challenge values
    
are given, no PPT algorithm  can distinguish  from
 with more than a negligible advantage. The advantage of
 is defined as  where the probability is taken over
the random choice of .
\end{assumption}

\begin{assumption}[Decisional Bilinear Diffie-Hellman, DBDH]
Let  be a description of the asymmetric bilinear
group of prime order . Let  be generators of 
respectively. The assumption is that if the challenge values
    
are given, no PPT algorithm  can distinguish  from  with more than a
negligible advantage. The advantage of  is defined as
 where the probability is taken over the random choice of .
\end{assumption}

The LW1 and LW2 assumptions are falsifiable since they are not interactive
(or even -type) assumptions and they obviously hold in the generic
bilinear group model since the target polynomial in  is independent of
given polynomials in .

\section{Public-Key Signature} \label{sec:pks}

In this section, we propose two PKS schemes with short public keys and prove
their security under static assumptions.

\subsection{Definitions}

The concept of PKS was introduced by Diffie and Hellman \cite{DiffieH76}. In
PKS, a signer first generates a public key and a private key, and then he
publishes the public key. The signer generates a signature on a message by
using his private key. A verifier can check the validity of the signer's
signature on the message by using the signer's public key. A PKS scheme is
formally defined as follows:

\begin{definition}[Public-Key Signature]
A public key signature (PKS) scheme consists of three PPT algorithms
\tb{KeyGen}, \tb{Sign}, and \tb{Verify}, which are defined as follows:
\begin{description}
\item . The key generation algorithm takes as
    input the security parameters  and outputs a public key
     and a private key .

\item . The signing algorithm takes as input a message
     and a private key  and outputs a signature .

\item . The verification algorithm takes as
    input a signature , a message , and a public key  and
    outputs either  or , depending on the validity of the signature.
\end{description}
The correctness requirement is that for any  output by \tb{KeyGen}
and any , we have . We can relax this notion to require that the verification is
correct with overwhelming probability over all the randomness of the
experiment.
\end{definition}

The security model of PKS is defined as existential unforgeability under a
chosen message attack (EUF-CMA), and this was formally defined by Goldwasser
et al. \cite{GoldwasserMR88}. In this security model, an adversary adaptively
requests a polynomial number of signatures on messages through the signing
oracle, and he finally outputs a forged signature on a message . If the
message  was not queried to the signing oracle and the forged signature
is valid, then the adversary wins this game. The security of PKS is formally
defined as follows:

\begin{definition}[Security]
The security notion of existential unforgeability under a chosen message
attack is defined in terms of the following experiment between a challenger
 and a PPT adversary :
\begin{enumerate}
\item \tb{Setup}:  first generates a key pair  by running
    \tb{KeyGen}, and gives  to .

\item \tb{Signature Query}: Then , adaptively and polynomially
    many times, requests a signature query on a message  under the
    challenge public key , and receives a signature 
    generated by running \tb{Sign}.

\item \tb{Output}: Finally,  outputs a forged signature
     on a message .  then outputs  if the
    forged signature satisfies the following two conditions, or outputs
     otherwise: 1)  and 2) 
    was not queried by  to the signing oracle.
\end{enumerate}
The advantage of  is defined as  where the probability is taken over all the randomness of the
experiment. A PKS scheme is existentially unforgeable under a chosen message
attack if all PPT adversaries have at most a negligible advantage in the
above experiment (for a large enough security parameter).
\end{definition}

\subsection{Construction} \label{sec:pks-prime}

We construct PKS schemes with a short public key that will be augmented to
support \textit{multi-users} and \textit{public re-randomization}. To
construct a PKS scheme with a short public key, we may convert the LW-IBE
scheme \cite{LewkoW10} in prime order groups to the LW-PKS scheme in prime
order groups by using the transformation of Naor \cite{BonehF01}. However,
this directly converted LW-PKS scheme does not support multi-users and public
re-randomization since it is necessary to publish additional public key
components: Specifically, we need to publish an element  for multi-users
and elements  for public re-randomization. Note that  are already in the public key, but  are not. One
may try to publish  in the public key, but a technical difficulty
arises in this case in that the simulator of the security proof can easily
distinguish from the normal verification algorithm to the semi-functional
one, without using an adversary. Thus the simulator of Lewko and Waters sets
the CDH value into the elements  to prevent the simulator from
creating these elements.

To solve this problem, we devise two independent solutions. The first
solution allows a PKS scheme to safely publish elements  in the
public key for multi-users and public re-randomization. The main idea is to
additionally randomize the verification components using  in the verification algorithm. If a valid
signature is given in the verification algorithm, then the additionally added
randomization elements  are
canceled. Otherwise, the added randomization components prevent the
verification of an invalid signature. Therefore, the simulator of the
security proof cannot detect the changes of the verification algorithm even
if  are published, since the additional elements  prevent the signature verification.

Our second solution for this problem is to publish randomized components  that are additionally multiplied with
random elements rather than directly publishing . In this case, the
simulator can create these elements since the random exponents  can be used to cancel out the CDH value embedded in the elements . Additionally, the simulator cannot detect the changes of verification
components for the forged signature because of the added elements . This solution does not increase the number of group
elements in the signatures, rather it increases the number of public keys
since additional elements  should be published.

\subsubsection{Our PKS1 Scheme}

Our first PKS scheme in prime order bilinear groups is described as follows:

\begin{description}
\item [\textbf{PKS1.KeyGen}():] This algorithm first generates
    the asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it chooses random exponents
     and sets . It
    selects random exponents  and sets . It outputs a private key 
    and a public key as
    

\item [\textbf{PKS1.Sign}():] This algorithm takes as input a
    message  where  and a private key . It selects random exponents  and outputs
    a signature as
    

\item [\textbf{PKS1.Verify}():] This algorithm takes as
    input a signature  on a message  under a public
    key . It first chooses random exponents  and
    computes verification components as
    
    Next, it verifies that . If
    this equation holds, then it outputs . Otherwise, it outputs .
\end{description}

We note that the inner product of  and  is zero since , and the inner product of  and  is zero since . Using these facts,
the correctness of PKS is easily obtained from the equation
    

\subsubsection{Our PKS2 Scheme}

Our second PKS scheme in prime order bilinear groups is described as follows:

\begin{description}
\item [\tb{PKS2.KeyGen}():] This algorithm first generates the
    asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it selects random exponents  and sets . It also selects
    random exponents  and sets . It outputs a private key 
    and a public key by selecting random values  as
    

\item [\tb{PKS2.Sign}():] This algorithm takes as input a message  and a private key  with . It
    selects random exponents  and outputs a signature
    as
    

\item [\tb{PKS2.Verify}():] This algorithm takes as input a
    signature  on a message  under a public key .
    It chooses a random exponent  and computes verification
    components as
    
    Next, it verifies that . If
    this equation holds, then it outputs . Otherwise, it outputs .
\end{description}

We note that the inner product of  and 
is zero since . Using this fact, the correctness
of PKS is easily obtained from the following equation
    

\subsection{Security Analysis}

We prove the security of our PKS schemes without random oracles under static
assumptions. To prove the security, we use the dual system encryption
technique of Lewko and Waters \cite{LewkoW10}. The dual system encryption
technique was originally developed to prove the full-model security of IBE
and its extensions, but it also can be used to prove the security of PKS by
using the transformation of Naor \cite{BonehF01}. Note that Gerbush et al.
\cite{GerbushLOW12} developed the dual form signature technique that is a
variation of the dual system encryption technique to prove the security of
their PKS schemes.

\subsubsection{Analysis of PKS1}

\begin{theorem} \label{thm:pks1-prime}
The above \tb{PKS1} scheme is existentially unforgeable under a chosen
message attack if the SXDH, LW2, DBDH assumptions hold. That is, for any PPT
adversary , there exist PPT algorithms 
such that
    
where  is the maximum number of signature queries of .
\end{theorem}

\begin{proof}
To use the dual system encryption technique of Lewko and Waters
\cite{LewkoW10}, we first describe a semi-functional signing algorithm and a
semi-functional verification algorithm. They are not used in a real system;
rather, they are used in the security proof.
When comparing our proof to that of Lewko and Waters, we employ a different
assumption since we have published additional elements  used in
aggregation (in fact, direct adaptation of the earlier technique will break
the assumption and thus the proof). A crucial idea in our proof is that we
have added elements  in the public
key that are used in randomization of the verification algorithm. In the
security proof when moving from normal to semi-functional verification, it is
the randomization elements  that
are expanded to the semi-functional space; this enables deriving
semi-functional verification as part of the security proof under our
assumption, without being affected by the publication of the additional
public key elements used for aggregation.

For the semi-functional signing and verification, we set  where  is a random exponent in .

\begin{description}
\item [\textbf{PKS1.SignSF}.] The semi-functional signing algorithm first
    creates a normal signature using the private key. Let  be the normal signature of a message  with random
    exponents . It selects random exponents  and outputs a semi-functional signature as
    

\item [\textbf{PKS1.VerifySF}.] The semi-functional verification algorithm
    first creates normal verification components using the public key. Let
     be the normal verification components
    with random exponents . It chooses random
    exponents  and computes semi-functional verification
    components as
    
    Next, it verifies that . If
    this equation holds, then it outputs 1. Otherwise, it outputs 0.
\end{description}

\noindent Note that if the semi-functional verification algorithm verifies a
semi-functional signature, then the left part of the above verification
equation contains an additional random element . If , then the semi-functional verification algorithm
succeeds. In this case, we say that the signature is \textit{nominally}
semi-functional.

The security proof uses a sequence of games ,
and : The first game  will be the original security game
and the last game  will be a game such that an adversary 
has no advantage. Formally, the hybrid games are defined as follows:

\begin{description}
\item [\textbf{Game} .] This game is the original security game.
    In this game, the signatures that are given to  are normal and
    the challenger use the normal verification algorithm \textbf{Verify} to
    check the validity of the forged signature of .

\item [\textbf{Game} .] We first modify the original game to a
    new game . This game is almost identical to  except
    that the challenger uses the semi-functional verification algorithm
    \textbf{VerifySF} to check the validity of the forged signature of
    .

\item [\textbf{Game} .] Next, we change  to a new game
    . This game is the same as the  except that the
    signatures that are given to  will be semi-functional. At this
    moment, the signatures are semi-functional and the challenger uses the
    semi-functional verification algorithm \textbf{VerifySF} to check the
    validity of the forged signature. Suppose that  makes at most
     signature queries. For the security proof, we define a sequence of
    hybrid games 
    where . In , a normal signature
    is given to  for all -th signature queries such that , and a semi-functional signature is given to  for all -th
    signature queries such that . It is obvious that
     is equal to .

\item [\textbf{Game} .] Finally, we define a new game .
    This game differs from  in that the challenger always rejects
    the forged signature of . Therefore, the advantage of this game
    is zero since  cannot win this game.
\end{description}

For the security proof, we show the indistinguishability of each hybrid game.
We informally describe the meaning of each indistinguishability as follows:
\begin{itemize}
\item Indistinguishability of  and : This property
    shows that  cannot forge a semi-functional signature if it is
    only given normal signatures. That is, if  forges a
    semi-functional signature, then it can distinguish  from
    .

\item Indistinguishability of  and : This property
    shows that the probability of  forging a normal signature is
    almost the same when the signatures given to the adversary are changed
    from a normal type to a semi-functional type. That is, if the
    probability of  forging a normal signature is different in
     and , then  can distinguish the two games.

\item Indistinguishability of  and : This property
    shows that  cannot forge a normal signature if it is only given
    semi-functional signatures. That is, if  forges a normal
    signature, then it can distinguish  from .
\end{itemize}

The security (unforgeability) of our PKS scheme follows from a hybrid
argument. We first consider an adversary  attacking our PKS scheme in
the original security game . By the indistinguishability of
 and , we have that  can forge a normal signature
with a non-negligible  probability, but it can forge a
semi-functional signature with only a negligible probability. Now we should
show that the  probability of  forging a normal signature
is also negligible. By the indistinguishability of  and ,
we have that the  probability of  forging a normal
signature is almost the same when the signatures given to  are
changed from a normal type to a semi-functional type. Finally, by the
indistinguishability of  and , we have that  can
forge a normal signature with only a negligible probability. Summing up, we
obtain that the probability of  forging a semi-functional signature
is negligible (from the indistinguishability of  and )
and the probability of  forging a normal signature is also negligible
(from the indistinguishability of  and ).

Let  be the advantage of  in  for
. Let  be the advantage of 
in  for . It is clear that
    ,
    ,
    , and
    .
From the following three Lemmas, we prove that it is hard for  to
distinguish  from  under the given assumptions.
Therefore, we have that
    
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks1-prime-1}
If the SXDH assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Before proving this lemma, we introduce the parallel-SXDH assumption as
follows: Let  be a description of the asymmetric
bilinear group of prime order . Let  be generators of  respectively. The assumption is stated as following: given a
challenge tuple
     and ,
it is hard to decide whether  or  with random choices of . It is easy to prove by simple hybrid arguments that if there
exists an adversary that breaks the parallel-SXDH assumption, then it can
break the SXDH assumption. Alternatively, we can tightly prove the reduction
using the random self-reducibility of the Decisional Diffie-Hellman
assumption.

Suppose there exists an adversary  that distinguishes between
 and  with non-negligible advantage. Simulator 
that solves the parallel-SXDH assumption using  is given: a challenge
tuple
     and
     where
     or
    .
Then  that interacts with  is described as follows:
 first chooses random exponents , then it sets .
It selects random exponents  and sets
    .
It implicitly sets  and publishes a
public key  as
    
It sets a private key . Additionally, it sets  for the semi-functional signature and verification. 
adaptively requests a signature for a message . To response this sign
query,  creates a normal signature by calling \textbf{PKS1.Sign}
since it knows the private key. Note that it cannot create a semi-functional
signature since it does not know . Finally,  outputs a forged
signature  on a message  from
. To verify the forged signature,  first chooses a random
exponent  and computes verification components by implicitly
setting  as
    
Next, it verifies that
    .
If this equation holds, then it outputs 0. Otherwise, it outputs 1.

\vs To finish this proof, we show that the distribution of the simulation is
correct. We first show that the distribution using  is the same as . The public key
is correctly distributed since the random blinding values  are
used. The signatures is correctly distributed since it uses the signing
algorithm. The verification components are correctly distributed as
    
We next show that the distribution of the simulation using  is the same as
. We only consider the distribution of the verification components
since  is only used in the verification components. The difference between
 and  is that  additionally has . Thus  that have  in the simulation
additionally have  respectively. If we
implicitly set , then the verification
components for the forged signature are semi-functional since  are
randomly chosen.
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks1-prime-2}
If the LW2 assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Suppose there exists an adversary  that distinguishes between
 and  with non-negligible advantage. A
simulator  that solves the LW2 assumption using  is given:
a challenge tuple
     and 
where  or . Then  that
interacts with  is described as follows:  first selects
random exponents  and sets
    .
It implicitly sets  and
publishes a public key  as
    
Additionally, it sets  for the semi-functional
signature and verification.  adaptively requests a signature for a
message . If this is a -th signature query, then  handles
this query as follows:
\begin{itemize}
\item {Case } : It creates a semi-functional signature by calling
    \textbf{PKS1.SignSF} since it knows the tuple  for the semi-functional signature.

\item {Case } : It selects random exponents  and creates a signature by implicitly setting  as
    

\item {Case } : It creates a normal signature by calling
    \textbf{PKS1.Sign} since it knows  of the private key. Note
    that  are not required.
\end{itemize}

\noindent Finally,  outputs a forged signature  on a message . To verify the forged
signature,  first chooses random exponents 
and computes semi-functional verification components by implicitly setting
    
as
    
Next, it verifies that
    .
If this equation holds, then it outputs 0. Otherwise, it outputs 1.

\vs To finish the proof, we should show that the distribution of the
simulation is correct. We first show that the distribution of the simulation
using  is the same as . The public key is
correctly distributed since the random blinding values 
are used. The -th signature is correctly distributed as
    
The semi-functional verification components are correctly distributed as
    
The simulator can create the semi-functional verification components with
only fixed  since  enable the cancellation of
. Even though the simulator uses the fixed , the
distribution of  is correct since  are information theoretically
hidden to .
We next show that the distribution of the simulation using  is the same as . We only consider the distribution of
the -th signature since  is only used in the -th signature. The only
difference between  and  is that  additionally has . The
signature components , 
that have  in the simulation additionally have , , , ,  respectively. If we implicitly set
, then the distribution of the -th signature is the
same as  except that the -th signature is nominally
semi-functional.

Finally, we show that the adversary cannot distinguish the nominally
semi-functional signature from the semi-functional signature. The main idea
of this is that the adversary cannot request a signature for the forgery
message  in the security model. Suppose there exists an unbounded
adversary, then the adversary can gather  from the -th
signature and  from the forged signature. It is easy to show
that  and  look random to the unbounded adversary since  is a pair-wise independent function and  are information
theoretically hidden to the adversary.
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks1-prime-3}
If the DBDH assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Suppose there exists an adversary  that distinguish  from
 with non-negligible advantage. A simulator  that solves
the DBDH assumption using  is given: a challenge tuple
    
    and  where  or .
Then  that interacts with  is described as follows:
 first chooses random exponents ,  and sets . It selects random
exponents  and sets
    .
It implicitly sets  and publishes a public key  as
    
Additionally, it sets  for the semi-functional
signature and semi-functional verification.  adaptively requests a
signature for a message . To respond to this query,  selects
random exponents  and creates a
semi-functional signature by implicitly setting  as
    
The simulator can only create a semi-functional signature since 
enables the cancellation of . Finally,  outputs a forged
signature  on a message . To
verify the forged signature,  first chooses random exponents  and computes semi-functional verification
components by implicitly setting
    
as
    
Next, it verifies that
    
If this equation holds, then it outputs . Otherwise, it outputs .

\vs To finish the proof, we first show that the distribution of the
simulation using  is the same as . The
public key is correctly distributed since the random blinding values  are used. The semi-functional signature is correctly distributed as
    
The semi-functional verification components are correctly distributed as
    
We next show that the distribution of the simulation using  is almost the same as . It is obvious that the
signature verification for the forged signature always fails if  is used except with  probability since  is a random value
in .
This completes our proof.
\end{proof}

\subsubsection{Analysis of PKS2}

\begin{theorem} \label{thm:pks2-prime}
The above \tb{PKS2} scheme is existentially unforgeable under a chosen
message attack if the LW1, LW2, DBDH assumptions hold. That is, for any PPT
adversary , there exist PPT algorithms 
such that
    
where  is the maximum number of signature queries of .
\end{theorem}

\begin{proof}
Before proving the security, we first define two additional algorithms for
semi-functional types. For the semi-functionality, we set  where  is a random exponent in .

\begin{description}
\item [\tb{PKS2.SignSF}.] The semi-functional signing algorithm first
    creates a normal signature using the private key. Let  be the normal signature of a message  with random
    exponents . It selects random exponents  and outputs a semi-functional signature as
    

\item [\tb{PKS2.VerifySF}.] The semi-functional verification algorithm
    first creates normal verification components using the public key. Let
     be the normal verification components
    with a random exponent . It chooses random exponents  and computes semi-functional verification components as
    
    Next, it verifies that . If
    this equation holds, then it outputs 1. Otherwise, it outputs 0.
\end{description}
If the semi-functional verification algorithm is used to verify a
semi-functional signature, then an additional random element  is left in the left part of the above
verification equation. If , then the semi-functional verification
algorithm succeeds. In this case, we say that the signature is
\textit{nominally} semi-functional.

The security proof uses a sequence of games ,
and . The definition of these games is the same as that of Theorem
\ref{thm:pks1-prime}.
From the following three lemmas, we prove that it is hard for  to
distinguish  from  under the given assumptions.
Therefore, we have that
    
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks2-prime-1}
If the LW1 assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Suppose there exists an adversary  that distinguishes between
 and  with non-negligible advantage. A simulator
 that solves the LW1 assumption using  is given: a
challenge tuple
     and 
    where  or .
Then  that interacts with  is described as follows:
 first chooses random exponents ,
random values . It computes  by implicitly
setting . It implicitly sets  and publishes a
public key  by selecting random values  as
    
It implicitly sets , but it cannot create these elements since  is
not given. Additionally, it sets  for the
semi-functional signature and verification.
 adaptively requests a signature for a message . To response this
sign query,  first selects random exponents . It implicitly sets
    
and creates a normal signature as
    
Finally,  outputs a forged signature  on a message  from . To verify the forged signature,
 first chooses a random exponent  and computes
verification components by implicitly setting  as
    
Next, it verifies that
    .
If this equation holds, then it outputs 0. Otherwise, it outputs 1.

\vs To finish this proof, we show that the distribution of the simulation is
correct. We first show that the distribution using 
is the same as . The public key is correctly distributed as
    
The simulator cannot create  since  is not given in the
assumption, but it can create  since
 can be used to cancel out . The signature is
correctly distributed as
    
It can create a normal signature since  enable the cancellation of
, but it cannot create a semi-functional signature since  is
not given. The verification components are correctly distributed as
    
We next show that the distribution of the simulation using  is the same as . We only consider the
distribution of the verification components since  is only used in the
verification components. The difference between  and  is that 
additionally has . Thus 
that have  in the simulation additionally have  respectively. If we implicitly set ,
then the verification components of the forged signature are semi-functional
since  and  are information-theoretically hidden to the adversary.
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks2-prime-2}
If the LW2 assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Suppose there exists an adversary  that distinguishes between
 and  with non-negligible advantage. A
simulator  that solves the LW2 assumption using  is given:
a challenge tuple
     and 
where  or . Then  that
interacts with  is described as follows:  first selects
random exponents . It
computes
    
by implicitly setting . It
implicitly sets  and publishes a public key  by
selecting random values  as
    
Additionally, it sets  for the semi-functional
signature and verification.  adaptively requests a signature for a
message . If this is a -th signature query, then  handles
this query as follows:
\begin{itemize}
\item {Case } : It creates a semi-functional signature by calling
    \tb{PKS2.SignSF} since it knows the tuple  for the
    semi-functional signature.

\item {Case } : It selects random exponents  and creates a signature by implicitly setting  as
    

\item {Case } : It creates a normal signature by calling
    \tb{PKS2.Sign} since it knows the private key.
\end{itemize}

\noindent Finally,  outputs a forged signature  on a message . To verify the forged
signature,  first chooses a random exponent  and
computes semi-functional verification components by implicitly setting
    
as
    
Next, it verifies that
    .
If this equation holds, then it outputs 0. Otherwise, it outputs 1.

\vs To finish the proof, we should show that the distribution of the
simulation is correct. We first show that the distribution of the simulation
using  is the same as . The public key is
correctly distributed since the random blinding values  are
used. The -th signature is correctly distributed as
    
The semi-functional verification components are correctly distributed as
    
The simulator can create the semi-functional verification components with
only fixed  since  enable the cancellation of
. Even though it uses the fixed , the distribution of
 is correct since  are information theoretically hidden to
.
We next show that the distribution of the simulation using  is the same as . We only consider the distribution of
the -th signature since  is only used in the -th signature. The only
difference between  and  is that  additionally has . The
signature components ,  that have  in
the simulation additionally have , ,
,  respectively. If we implicitly set , then the distribution of the -th signature is the same as
 except that the -th signature is nominally semi-functional.

Finally, we show that  cannot distinguish the nominally
semi-functional signature from the semi-functional signature. The main idea
of this is that  cannot request a signature for the forgery message
 in the security model. Suppose there exists an unbounded adversary,
then he can gather  from the -th signature and  from the forged signature. It is easy to show that  look random
to the unbounded adversary since  is a pair-wise independent
function and  are information theoretically hidden to the adversary.
This completes our proof.
\end{proof}

\begin{lemma} \label{lem:pks2-prime-3}
If the DBDH assumption holds, then no polynomial-time adversary can
distinguish between  and  with non-negligible advantage.
That is, for any adversary , there exists a PPT algorithm 
such that
    .
\end{lemma}

\begin{proof}
Suppose there exists an adversary  that distinguish  from
 with non-negligible advantage. A simulator  that solves
the DBDH assumption using  is given: a challenge tuple
    
    and  where  or .
Then  that interacts with  is described as follows:
 first chooses random exponents  and a random element . It computes
    .
It implicitly sets  and
publishes a public key  by selecting random values  as
    
Additionally, it sets  for the semi-functional
signature and semi-functional verification.  adaptively requests a
signature for a message . To respond to this query,  selects
random exponents  and creates a
semi-functional signature by implicitly setting  as
    
It can only create a semi-functional signature since  enables the
cancellation of . Finally,  outputs a forged signature
 on a message . To verify the
forged signature,  first chooses random exponents  and computes semi-functional verification components by
implicitly setting
    
as
    
Next, it verifies that  If
this equation holds, then it outputs . Otherwise, it outputs .

\vs To finish the proof, we first show that the distribution of the
simulation using  is the same as . The
public key is correctly distributed since the random values  are used. The semi-functional signature is correctly distributed as
    
The simulator can only create a semi-functional signature since  enables the cancellation of . The semi-functional
verification components are correctly distributed as
    
We next show that the distribution of the simulation using  is almost the same as . It is obvious that the
signature verification for the forged signature always fails if  is used except with  probability since  is a random value
in .
This completes our proof.
\end{proof}

\section{Sequential Aggregate Signature} \label{sec:sas}

In this section, we propose two SAS schemes with short public keys and prove
their security based on that of our PKS schemes.

\subsection{Definitions} \label{sec:sas-def}

The concept of SAS was introduced by Lysyanskaya et al.
\cite{LysyanskayaMRS04}. In SAS, all signers first generate public keys and
private keys, and then publishes their public keys. To generate a sequential
aggregate signature, a signer may receive an aggregate-so-far from a previous
signer, and creates a new aggregate signature by adding his signature to the
aggregate-so-far in sequential order. After that, the signer may send the
aggregate signature to a next signer. A verifier can check the validity of
the aggregate signature by using the pubic keys of all signers in the
aggregate signature. An SAS scheme is formally defined as follows:

\begin{definition}[Sequential Aggregate Signature]
A sequential aggregate signature (SAS) scheme consists of four PPT algorithms
\tb{Setup}, \tb{KeyGen}, \tb{AggSign}, and \tb{AggVerify}, which are defined
as follows:
\begin{description}
\item . The setup algorithm takes as input a
    security parameter  and outputs public parameters .

\item . The key generation algorithm takes as input the
    public parameters , and outputs a public key  and a private key
    .

\item . The aggregate
    signing algorithm takes as input an aggregate-so-far  on messages
     under public keys , a message , and a private key , and outputs a
    new aggregate signature .

\item . The aggregate verification
    algorithm takes as input an aggregate signature  on messages
     under public keys , and outputs either  or  depending on the validity
    of the sequential aggregate signature.
\end{description}
The correctness requirement is that for each  output by \tb{Setup}, for
all  output by \tb{KeyGen}, any , we have that  where  is a valid aggregate-so-far signature on
messages  under public keys .
\end{definition}

A trivial SAS scheme can be constructed from a PKS scheme by concatenating
each signer's signature in sequential order, but the size of aggregate
signature is proportional to the size of signers. Therefore, a non-trivial
SAS scheme should satisfy the signature compactness property that requires
the size of aggregate signature to be independent of the size of signers.

The security model of SAS was defined by Lysyanskaya et al.
\cite{LysyanskayaMRS04}, but we follow the security model of Lu et al.
\cite{LuOSSW06} that requires for an adversary to register the key-pairs of
other signers except the target signer, namely the knowledge of secret key
(KOSK) setting or the proof of knowledge (POK) setting. In this security
model, an adversary first given the public key of a target signer. After
that, the adversary adaptively requests a certification for a public key by
registering the key-pair of other signer, and he adaptively requests a
sequential aggregate signature by providing a previous aggregate signature to
the signing oracle. Finally, the adversary outputs a forged sequential
aggregate signature on messages under public keys. If the forged sequential
signature satisfies the conditions of the security model, then the adversary
wins the security game. The security model of SAS is formally defined as
follows:

\begin{definition}[Security]
The security notion of existential unforgeability under a chosen message
attack is defined in terms of the following experiment between a challenger
 and a PPT adversary :
\begin{enumerate}
\item \tb{Setup}:  first initializes a certification list  as
    empty. Next, it runs \tb{Setup} to obtain public parameters  and
    \tb{KeyGen} to obtain a key pair , and gives  to .

\item \tb{Certification Query}:  adaptively requests the
    certification of a public key by providing a key pair . Then
     adds the key pair  to  if the key pair is a valid
    one.

\item \tb{Signature Query}:  adaptively requests a sequential
    aggregate signature (by providing an aggregate-so-far  on messages
     under public keys ), on a message  to sign
    under the challenge public key , and receives a sequential
    aggregate signature .

\item \tb{Output}: Finally (after a sequence of the above queries),
     outputs a forged sequential aggregate signature  on
    messages  under public keys .  outputs
     if the forged signature satisfies the following three conditions,
    or outputs  otherwise: 1) , 2) The challenge public key  must exists in
     and each public key in  except the challenge
    public key must be in , and 3) The corresponding message  in
     of the challenge public key  must not have been
    queried by  to the sequential aggregate signing oracle.
\end{enumerate}
The advantage of  is defined as  where the probability is taken over all the randomness of the
experiment. An SAS scheme is existentially unforgeable under a chosen message
attack if all PPT adversaries have at most a negligible advantage in the
above experiment.
\end{definition}

\subsection{Construction}

To construct an SAS scheme from a PKS scheme, the PKS scheme should support
multi-users by sharing some elements among all signers and the randomness of
signatures should be sequentially aggregated to a single value. We can employ
the randomness reuse technique of Lu et al. \cite{LuOSSW06} to aggregate the
randomness of signatures. To apply the randomness reuse technique, we should
re-randomize the aggregate signature to prevent a forgery attack. Thus we
build on the PKS schemes of the previous section that support multi-users and
public re-randomization to construct SAS schemes.

\subsubsection{Our SAS1 Scheme}

Our first SAS scheme in prime order bilinear groups is described as follows:

\begin{description}
\item [\textbf{SAS1.Setup}():] This algorithm first generates
    the asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it chooses random exponents
     and sets . It
    also sets . It
    publishes public parameters as
    

\item [\textbf{SAS1.KeyGen}():] This algorithm takes as input the
    public parameters . It selects random exponents  and computes . It outputs
    a private key  and a public key as
    

\item [\textbf{SAS1.AggSign}():] This
    algorithm takes as input an aggregate-so-far  on messages  under
    public keys  where , a message  where ,
    a private key  with 
    and . It first checks the validity of  by calling
    . If  is not
    valid, then it halts. If the public key  of  does already exist
    in , then it halts. Next, it creates temporal aggregate
    components by using the randomness of the previous aggregate-so-far as
    
    Finally, it selects random exponents  for
    re-randomization and outputs an aggregate signature as
    

\item [\textbf{SAS1.AggVerify}():] This algorithm
    takes as input a sequential aggregate signature  on messages
     under public keys  where . It first
    checks that any public key does not appear twice in  and
    that any public key in  has been certified. If these checks
    fail, then it outputs 0. If , then it outputs 1 if , 0 otherwise. It chooses random exponents  and
    computes verification components as
    
    Next, it verifies that . If this equation holds, then it outputs . Otherwise, it
    outputs .
\end{description}

The aggregate signature  is a valid sequential aggregate signature on
messages  under public keys  with randomness
    
where  are random values in . The sequential aggregate
signature has the following form
    

\subsubsection{Our SAS2 Scheme}

Our second SAS scheme in prime order bilinear groups is described as follows:

\begin{description}
\item [\tb{SAS2.Setup}():] This algorithm first generates the
    asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it selects random exponents  and sets , . It publishes public parameters by
    selecting a random value  as
    

\item [\tb{SAS2.KeyGen}():] This algorithm takes as input the public
    parameters . It selects random exponents 
    and sets . It outputs a
    private key  and a public key by selecting random
    values  as
    

\item [\tb{SAS2.AggSign}():] This
    algorithm takes as input an aggregate-so-far  on messages  under
    public keys  where , a message , a private
    key  with  and
    . It first checks the validity of  by calling
    . If  is not
    valid, then it halts. If the public key  of  does already exist
    in , then it halts. Next, it creates temporal aggregate
    components by using the randomness of the previous aggregate-so-far as
    
    Finally it selects random exponents  for
    re-randomization and outputs an aggregate signature as
    

\item [\tb{SAS2.AggVerify}():] This algorithm
    takes as input a sequential aggregate signature  on messages
     under public keys  where . It
    first checks that any public key does not appear twice in 
    and that any public key in  has been certified. If these
    checks fail, then it outputs 0. If , then it outputs 1 if , 0 otherwise. It chooses a random exponent  and computes verification components as
    
    Next, it verifies that . If this equation holds, then it outputs . Otherwise, it
    outputs .
\end{description}

Let  be the randomness of an aggregate-so-far. If we
implicitly sets , then the aggregate signature is correctly distributed as
    

\subsection{Security Analysis}

\begin{theorem} \label{thm:sas1-prime}
The above \tb{SAS1} scheme is existentially unforgeable under a chosen
message attack if the \tb{PKS1} scheme is existentially unforgeable under a
chosen message attack. That is, for any PPT adversary  for the above
\tb{SAS1} scheme, there exists a PPT algorithm  for the \tb{PKS1}
scheme such that
    .
\end{theorem}

\begin{proof}
Our overall proof strategy for this part follows Lu et al. \cite{LuOSSW06}
and adapts it to our setting. The proof uses two properties: the fact that
the aggregated signature result is independent of the order of aggregation,
and the fact that the simulator of the SAS system possesses the private keys
of all but the target PKS.

Suppose there exists an adversary  that forges the above \tb{SAS1}
scheme with non-negligible advantage . A simulator  that
forges the \tb{PKS1} scheme is first given: a challenge public key
    .
Then  that interacts with  is described as follows:
 first constructs
    
and
    
from . Next, it initializes a certification list  as an empty
one and gives  and  to .
 may adaptively requests certification queries or sequential
aggregate signature queries. If  requests the certification of a
public key by providing a public key 
and its private key , then  checks the
private key and adds the key pair  to .
If  requests a sequential aggregate signature by providing an
aggregate-so-far  on messages  under
public keys , and a message  to
sign under the challenge private key of , then  proceeds the
aggregate signature query as follows:
\begin{enumerate}
\item It first checks that the signature  is valid and that each
    public key in  exits in .

\item It queries its signing oracle that simulates  on
    the message  for the challenge public key  and obtains a
    signature .

\item For each , it constructs an aggregate signature on
    message  using  since it knows the private
    key that corresponds to . The result signature is an aggregate
    signature for messages  under public keys  since this scheme does not check the order of aggregation. It
    gives the result signature  to .
\end{enumerate}
Finally,  outputs a forged aggregate signature  on messages  under
public keys  for some . Without loss
of generality, we assume that .  proceeds as follows:
\begin{enumerate}
\item  first checks the validity of  by calling
    . Additionally, the forged signature should
    not be trivial: the challenge public key  must be in
    , and the message  must not be queried by  to
    the signature query oracle.

\item For each , it parses  from , and it retrieves the private key  of  from . It then computes
    

\item It outputs  as a non-trivial
    forgery of the PKS scheme since it did not make a signing query on
    .
\end{enumerate}

To finish the proof, we first show that the distribution of the simulation is
correct. It is obvious that the public parameters and the public key are
correctly distributed. The sequential aggregate signatures is correctly
distributed since this scheme does not check the order of aggregation.
Finally, we can show that the result signature  of the simulator is a valid signature for the \tb{PKS1} scheme on
the message  under the public key  since it satisfies the
following equation:
    
where  and . This completes our proof.
\end{proof}

\begin{theorem} \label{thm:sas2-prime}
The above \tb{SAS2} scheme is existentially unforgeable under a chosen
message attack if the \tb{PKS2} scheme is existentially unforgeable under a
chosen message attack. That is, for any PPT adversary  for the above
\tb{SAS2} scheme, there exists a PPT algorithm  for the \tb{PKS2}
scheme such that
    .
\end{theorem}

\begin{proof}
Suppose there exists an adversary  that forges the above \tb{SAS2}
scheme with non-negligible advantage . A simulator  that
forges the \tb{PKS2} scheme is first given: a challenge public key
    .
Then  that interacts with  is described as follows:
 first constructs
    
by computing  and
    
from . Next, it initializes a certification list  as an empty
one and gives  and  to .
 may adaptively requests certification queries or sequential
aggregate signature queries. If  requests the certification of a
public key by providing a public key  and its private key , then 
checks the private key and adds the key pair  to .
If  requests a sequential aggregate signature by providing an
aggregate-so-far  on messages  under
public keys , and a message  to
sign under the challenge private key of , then  proceeds the
aggregate signature query as follows:
\begin{enumerate}
\item It first checks that the signature  is valid and that each
    public key in  exits in .

\item It queries its signing oracle that simulates  on
    the message  for the challenge public key  and obtains a
    signature .

\item For each , it constructs an aggregate signature on
    message  using  since it knows the private
    key that corresponds to . The result signature is an aggregate
    signature for messages  under public keys  since this scheme does not check the order of aggregation.
    It gives the result signature  to .
\end{enumerate}
Finally,  outputs a forged aggregate signature  on messages  under
public keys  for some . Without loss
of generality, we assume that .  proceeds as follows:
\begin{enumerate}
\item  first checks the validity of  by using
    . Additionally, the forged signature should not
    be trivial: the challenge public key  must be in ,
    and the message  must not be queried by  to the
    signature query oracle.

\item For each , it parses  from , and it retrieves the private
    key  of  from . It then
    computes
    

\item It outputs  as a non-trivial
    forgery of the PKS scheme since it did not make a signing query on
    .
\end{enumerate}

The public parameters and the public key are correctly distributed, and the
sequential aggregate signatures are also correctly distributed since this
scheme does not check the order of aggregation. The result signature  of the simulator is a valid PKS signature on
the message  under the public key  since it satisfies the
following equation:
    
where  and . This completes our proof.
\end{proof}

\subsection{Discussions}

\noindent \textbf{Multiple Messages}. The SAS schemes of this paper only
allow a signer to sign once in the aggregate algorithm. To support multiple
signing per one signer, we can use the method of Lu et al. \cite{LuOSSW06}.
The basic idea of Lu et al. is to apply a collision resistant hash function
 to a message  before performing the signing algorithm. If a signer
wants to add a signature on a message  into the aggregate signature, he
first removes his previous signature on  from the aggregate signature
using his private key, and then he adds the new signature on the
 to the aggregate signature.

\section{Multi-Signature} \label{sec:ms}

In this section, we propose an efficient multi-signature (MS) scheme with
short public parameters and prove its security without random oracles.

\subsection{Definitions}

Multi-Signature (MS) can be regarded as a special kind of PKAS in which
different signatures generated by different signers on the same message are
combined as a short multi-signature. Thus MS consists of four algorithms of
PKS and additional two algorithms \tb{Combine} and \tb{MultiVerify} for
combining a multi-signature and verifying a multi-signature. In MS, each
signer generates a public key and a private key, and he can generate an
individual signature on a message by using his private key. To generate a
multi-signature, anyone can combine individual signatures of different
signers on the same message. A verifier can check the validity of the
multi-signature by using the public keys of signers. An MS scheme is formally
defined as follows:

\begin{definition}[Multi-Signature]
A multi-signature (MS) scheme consists of six PPT algorithms \tb{Setup},
\tb{KeyGen}, \tb{Sign}, \tb{Verify}, \tb{Combine}, and \tb{MultVerify}, which
are defined as follows:
\begin{description}
\item \tb{Setup}(): The setup algorithm takes as input a
    security parameter , and outputs public parameters .

\item \tb{KeyGen}(): The key generation algorithm takes as input the
    public parameters , and outputs a public key  and a private key
    .

\item \tb{Sign}(): The signing algorithm takes as input a message
    , and a private key . It outputs a signature .

\item \tb{Verify}(): The verification algorithm takes as
    input a signature  on a message  under a public key ,
    and outputs either  or  depending on the validity of the
    signature.

\item \tb{Combine}(): The combining algorithm
    takes as input signatures  on a message  under public
    keys , and outputs a multi-signature
    .

\item \tb{MultVerify}(): The multi-verification algorithm
    takes as input a multi-signature  on a message  under public
    keys , and outputs either  or 
    depending on the validity of the multi-signature.
\end{description}
The correctness requirement is that for each  output by
, for all  output by , and
any , we have that  and for
each  on message  under public keys ,
.
\end{definition}

The security model of MS was defined by Micali et al. \cite{MicaliOR01}, but
we follow the security model of Boldyreva \cite{Boldyreva03} that requires
for an adversary to register the key-pairs of other signers except the target
signer, namely the knowledge of secret key (KOSK) setting or the proof of
knowledge (POK) setting. In this security model, an adversary is first given
the public key of a target signer. After that, the adversary adaptively
requests the certification of a public key by registering the key-pair of
other signer, and he adaptively requests a signature for the target signer on
a message. Finally, the adversary outputs a forged multi-signature on a
message  under public keys. If the forged multi-signature satisfies the
conditions of the security model, then the adversary wins the security game.
The security model of MS is formally defined as follows:

\begin{definition}[Security]
The security notion of existential unforgeability under a chosen message
attack is defined in terms of the following experiment between a challenger
 and a PPT adversary :
\begin{enumerate}
\item \tb{Setup}:  first initialize the certification list  as
    empty. Next, it runs \tb{Setup} to obtain public parameters  and
    \tb{KeyGen} to obtain a key pair , and gives  to
    .

\item \tb{Certification Query}:  adaptively requests the
    certification of a public key by providing a key pair .
     adds the key pair  to  if the private key is a
    valid one.

\item \tb{Signature Query}:  adaptively requests a signature by
    providing a message  to sign under the challenge public key ,
    and receives a signature .

\item \tb{Output}: Finally,  outputs a forged multi-signature
     on a message  under public keys . 
    outputs  if the forged signature satisfies the following three
    conditions, or outputs  otherwise: 1) , 2) The challenge public key  must exists in
     and each public key in  except the challenge
    public key must be in , and 3) The message  must not have been
    queried by  to the signing oracle.
\end{enumerate}
The advantage of  is defined as  where the probability is taken over all the randomness of the experiment.
An MS scheme is existentially unforgeable under a chosen message attack if
all PPT adversaries have at most a negligible advantage in the above
experiment.
\end{definition}

\subsection{Construction}

To construct an MS scheme with short public parameters, we may use our PKS
schemes that support multi-users and public re-randomization. To aggregate
the randomness of signatures, we cannot use the technique of Lu et al.
\cite{LuOSSW06} since the randomness should be freely aggregated in MS.
Instead we aggregate the randomness of signatures by using the fact that each
signer generates a signature on the same message in MS. That is, if group
elements  that are related to message hashing are shared among all
signers, then the randomness of each signer can be easily aggregated since
the random exponent in a public key and the randomness of a signature are
placed in different positions. Thus our two PKS schemes can be used to build
MS schemes since  in PKS1 or 
in PKS2 are published in a public key. Note that it is not required for a
signer to publicly re-randomize a multi-signature since each signer selects
an independent random value.

To reduce the size of multi-signatures, we use our PKS2 scheme for this MS
scheme. Our MS scheme based on the PKS2 scheme is described as follows:

\begin{description}
\item [\tb{MS.Setup}():] This algorithm first generates the
    asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it selects random exponents  and sets , . It selects random exponents  and computes . It publishes public parameters by selecting random values
     as
    

\item [\tb{MS.KeyGen}():] This algorithm takes as input the public
    parameters . It selects a random exponent  and
    computes . Then it outputs a private key  and a public key as .

\item [\tb{MS.Sign}():] This algorithm takes as input a message  and a private key . It selects random exponents
     and outputs a signature as
    

\item [\tb{MS.Verify}():] This algorithm takes as input a
    signature  on a message  under a public key . It chooses
    a random exponent  and computes verification components as
    
    Next, it verifies that . If
    this equation holds, then it outputs . Otherwise, it outputs .

\item [\tb{MS.Combine}():] This algorithm
    takes as input signatures  on a message  under public keys  where . It first checks the validity of
    each signature  by calling
    . If any signature is invalid, then
    it halts. It then outputs a multi-signature for a message  as
    

\item [\tb{MS.MultVerify}():] This algorithm takes as
    input a multi-signature  on a message  under public keys
     where . It chooses
    a random exponent  and computes verification components as
    
    Next, it verifies that . If this equation holds, then it outputs . Otherwise, it
    outputs .
\end{description}

\subsection{Security Analysis}

\begin{theorem} \label{thm:ms-prime}
The above \tb{MS} scheme is existentially unforgeable under a chosen message
attack if the \tb{PKS2} scheme is existentially unforgeable under a chosen
message attack. That is, for any PPT adversary  for the above \tb{MS}
scheme, there exists a PPT algorithm  for the \tb{PKS2} scheme such
that
    .
\end{theorem}

\begin{proof}
Suppose there exists an adversary  that forges the above \tb{MS}
scheme with a non-negligible advantage . A simulator  that
forges the \tb{PKS2} scheme is given: a challenge public key . Then
 that interacts with  is described as follows:
 first constructs  by computing  and  from . Next, it initialize a
certification list  as an empty one and gives  and  to
.
 may adaptively request certification queries or signature queries.
If  requests the certification of a public key by providing a public
key  and its private key , then 
checks the key pair and adds  to .
If  requests a signature by providing a message  to sign under the
challenge private key of , then  queries its signing oracle
that simulates  on the message  for the challenge public
key , and gives the signature to .
Finally,  outputs a forged multi-signature  on a message  under public keys  for some . Without loss of generality, we assume
that .  proceeds as follows:
\begin{enumerate}
\item  first check the validity of  by calling
    . Additionally, the forged signature should not be
    trivial: the challenge public key  must be in , and
    the message  must not be queried by  to the signing oracle.

\item For each , it parses  from
    , and it retrieves the private key 
    of  from . It then computes
    

\item It outputs  as a non-trivial
    forgery of the PKS scheme since it did not make a signing query on
    .
\end{enumerate}

To finish the proof, we first show that the distribution of the simulation is
correct. It is obvious that the public parameters, the public key, and the
signatures are correctly distributed. Next we show that the output signature
 of the simulator is a valid signature
for the \tb{PKS2} scheme on the message  under the public key 
since it satisfies the following equation
    
This completes our proof.
\end{proof}

\subsection{Discussions}

\tb{Removing the Proof of Knowledge.} In our MS scheme, an adversary should
prove that he knows the private key of other signer by using a zero-knowledge
proof system. Ristenpart and Yilek \cite{RistenpartY07} showed that some MS
schemes can be proven in the proof of possession (POP) setting instead of the
POK setting. Our MS scheme also can be proven in the POP setting by using
their technique. That is, if our MS scheme is incorporated with a POP scheme
that uses a different hash function, and the adversary submits a signature on
the private key of other signer as the proof of possession, then the security
of our scheme is also achieved. In the security proof, a simulator cannot
extract the private key element  from the signature of the POP
scheme, but he can extract other values  and these values are enough for the security proof.

\section{Conclusion}

In this paper, we first proposed two PKS schemes with short public keys that
support multi-users and public re-randomization based on the LW-IBE scheme.
Next, we proposed two SAS schemes with short public keys without random
oracles and with no relaxation of assumptions (i.e., employing neither random
oracles nor interactive assumptions) based on our two PKS schemes. The
proposed SAS schemes are the first of this kind that have short (a constant
number of group elements) size public keys and a constant number of pairing
operations per message in the verification algorithm. We also proposed an MS
scheme with short public parameters based on our PKS scheme and proved its
security without random oracles.

There are many interesting open problems. The first one is to construct an
SAS scheme with short public keys that is secure under standard assumptions
without random oracles. A possible approach is to build an SAS scheme based
on the practical PKS scheme of B{\"{o}}hl et al. \cite{BohlHJKSS13} that is
secure under the standard assumption. The second one is to build an SAS
scheme with short public keys that supports lazy verification and has the
constant size of aggregate signatures. Brogle et al. \cite{BrogleGR12}
proposed an SAS scheme with lazy verification, but the size of aggregate
signatures in their SAS scheme is not constant.


\bibliographystyle{plain}
\bibliography{sas-short-pkey-merge}

\appendix

\section{Lewko-Waters IBE} \label{sec:lw-ibe}

In this section, we describe the IBE scheme of Lewko and Waters (LW-IBE)
\cite{LewkoW10} in prime order bilinear groups and the PKS scheme (LW-PKS)
that is derived from the LW-IBE scheme.

\subsection{The LW-IBE Scheme}

The LW-IBE scheme in prime order bilinear groups is described as follows:

\begin{description}
\item [\textbf{IBE.Setup}():] This algorithm first generates the
    asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it chooses random exponents
     and sets .
    It selects random exponents  and sets . It outputs a master
    key  and public parameters as
    

\item [\textbf{IBE.GenKey}():] This algorithm takes as input an
    identity  where  and the master key .
    It selects random exponents  and outputs a
    private key as
    

\item [\textbf{IBE.Encrypt}():] This algorithm takes as input a
    message , an identity , and the public parameters .
    It first chooses a random exponent  and outputs a
    ciphertext as
    

\item [\textbf{IBE.Decrypt}():] This algorithm takes as
    input a ciphertext , a private key , and the public
    parameters . If the identities of the ciphertext and the private
    key are equal, then it computes
    
\end{description}

\subsection{The LW-PKS Scheme}

To derive a LW-PKS scheme from the LW-IBE scheme, we apply the transformation
of Naor \cite{BonehF01}. Additionally, we represent the signature in 
instead of  to reduce the size of signatures. The LW-PKS scheme in
prime order bilinear groups is described as follows:

\begin{description}
\item [\textbf{PKS.KeyGen}():] This algorithm first generates
    the asymmetric bilinear groups  of prime order  of bit
    size . It chooses random elements  and
    . Next, it chooses random exponents  and sets . It selects
    random exponents  and sets . It outputs a private key  and a
    public key as
    

\item [\textbf{PKS.Sign}():] This algorithm takes as input a message
     where  and a private key . It selects
    random exponents  and outputs a signature as
    

\item [\textbf{PKS.Verify}():] This algorithm takes as input
    a signature  on a message  under a public key
    . It first chooses a random exponent  and computes
    verification components as
    
    Next, it verifies that . If
    this equation holds, then it outputs . Otherwise, it outputs .
\end{description}

We can safely move the elements  from the private key to the
public key since these elements are always constructed in the security proof
of the LW-IBE scheme. However, this LW-PKS scheme does not support multi-user
setting and public re-randomization since the elements  are not
given in the public key.

\end{document}
