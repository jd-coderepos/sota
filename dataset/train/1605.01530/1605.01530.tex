\documentclass[a4paper,USenglish]{lipics}
\def\longVersion{}
\usepackage{microtype}
  \usepackage{article}
  \usepackage{rev}

  \usepackage[inline]{enumitem}
  \setlist[itemize]{noitemsep,topsep=0pt}

  \usepackage{booktabs}

  \usepackage{dcolumn}
  \newcolumntype{d}[1]{D{.}{.}{#1} }

  \allowdisplaybreaks[4]

  \usepackage[numbers]{natbib}

  \usepackage{hyperref}

\titlerunning{Derived-term Automata for Extended Weighted Rational Expressions}
\title{Derived-term Automata for\newline
  Extended Weighted Rational Expressions}
\author{Akim Demaille {\scriptsize (\SvnDate \SvnRev)}}
\affil{LRDE, EPITA, \texttt{akim@lrde.epita.fr}}
\EventShortName{}

\begin{document}
\maketitle

\ifthenelse{\boolean{long}}{\tableofcontents}

\begin{abstract}
  We present an algorithm to build an automaton from a rational expression.
  This approach introduces support for extended weighted expressions.
  Inspired by derived-term based algorithms, its core relies on a different
  construct, \emph{rational expansions}.  We introduce an inductive
  algorithm to compute the expansion of an expression from which the
  automaton follows.  This algorithm is independent of the size of the
  alphabet, and actually even supports infinite alphabets.  It can easily be
  accommodated to generate deterministic (weighted) automata.  These
  constructs are implemented in \vcsn, a free-software platform dedicated to
  weighted automata and rational expressions.
\end{abstract}

\section{Introduction}

Foundational to Automata Theory, the Kleene Theorem (and its weighted
extension, the Kleene--Sch\"utzenberger Theorem) states the equivalence of
\dfn{recognizability} ---accepted by an automaton--- and \dfn{rationality}
---defined by a \dfn{rational}, or \dfn{regular}, expression.  Numerous
constructive proofs (read \emph{algorithms}) have been proposed to go from
rational expressions to automata, and vice versa.  This paper focuses on
building an automaton from an expression.

In 1961 \citet{glushkov.61.rms} provides an algorithm to build a
nondeterministic automaton (without spontaneous transitions) now often
called the standard (or position, or Glushkov) automaton.
Earlier (1960), \citet{mcnaughton.60.itec} proposed the same construct for
\emph{extended} rational expressions (i.e., including intersection and
complement operators), but performed the now usual subset-automaton
construction on-the-fly, thus yielding a deterministic automaton.
A key ingredient of these algorithms is that they build an automaton whose
states represent positions in the rational expression, and computations on
these automata actually represent ``executions'' of the rational expression.

\ifthenelse{\boolean{long}}{Similarly, in}{In} 1964
\citet{brzozowski.64.jacm} shows that \emph{extended} expressions can be
used directly as acceptors: transitions are ``performed'' by computing the
left-quotient of the current expression by the current letter.  With a
proper equivalence relation between expressions (namely ACI: associativity,
commutativity, and idempotence of the addition), Brzozowski shows that there
is a finite number of equivalence classes of such quotients, called
\dfn{derivatives}.  This leads to a very natural construction of a
\emph{deterministic} automaton whose states are these derivatives.  A rather
discreet sentence (last line of p.~484) introduces the concept of
``expansion'', which is not further developed.

In 1996 \citet{antimirov.1996.tcs} introduces a novel idea: do not apply ACI
equivalence globally; rather, when computing the derivative of an expression
which is a sum, split it in a set of ``partial derivatives'' (or ``derived
terms'') --- which amounts to limiting ACI to the sums that are at the root
of the expression.  A key feature of the built automaton is that it is
non-deterministic; as a result the worst-case size of resulting automaton is
linear in the size of the expression, instead of exponential with
Brzozowski's construct.  Antimirov also suggests \emph{not} to rely on
derivation in implementations, but on so called ``linear forms'', which are
closely related to Brzozowski's expansions; derivation is used only to prove
correctness.

In 2005 \citet{lombardy.2005.tcs} generalize the computation of the
derivation and derived-term automaton to support weights.  Since, as is
well-known, not all weighted non deterministic automata can be determinized,
their construct relies on a generalization of Antimirov's derived-term that
generates a \emph{non-deterministic} automaton.  In their formalization,
Antimirov's sets of derived terms naturally turn into \emph{weighted} sets
---each term is associated with a weight--- that they name
\emph{polynomials} (of expressions).  However, linear forms completely
disappear, and the construction of the derived-term automaton relies on
derivatives.  Independently, and with completely different foundations,
\citet{rutten.1999.icalp, rutten.2003.tcs} proposes a similar construction.

In 2011, \citet{caron.2011.lata.2} complete Antimirov's construct to support
extended expressions.  This is at the price of a new definition of
derivatives: sets of sets of expressions, interpreted as disjunctions of
conjunctions of expressions.

\smallskip

The contributions of this paper are threefold.  Firstly, we introduce
``expansions'', which generalize Brzozowski's expansions and Antimirov's
linear forms to support weighted expressions; they bind together the
derivatives, the constant terms and the ``firsts'' of an expression.  They
make the computation of the derived-term automaton independent of the size
of the alphabet, and actually completely eliminate the need for the alphabet
to be finite.  Secondly, we provide support for extended weighted rational
expressions, which generalizes both \citet{lombardy.2005.tcs} and
\citet{caron.2011.lata.2}. And thirdly, we introduce a variation of this
algorithm to build \emph{deterministic} (weighted) automata.

We first settle the notations in \cref{sec:notations}, provide an algorithm
to compute the expansion of an expression in \cref{sec:expr-to-expa}, which
is used in \cref{sec:expaton} to propose an alternative construction of the
derived-term automaton.  In \cref{sec:related} we expose related work and
conclude in \cref{sec:conc}.

\smallskip

Interested readers may experiment with the concepts introduced here using
\vcsn.  \vcsn is a free-software platform dedicated to weighted automata and
rational expressions \citep{demaille.13.ciaa}.  It supports both derivations
and expansions, as exposed in this paper, and the corresponding
constructions of the derived-term automaton\footnote{\label{foot:url}See the
  interactive
  environment, \url{http://vcsn-sandbox.lrde.epita.fr}, or its documentation,\\
  \url{http://vcsn.lrde.epita.fr/dload/2.2/notebooks/expression.derived_term.html}.}.



\section{Notations}
\label{sec:notations}

\newcommand{\OB}[2]{\overbrace{#2}^{\text{#1}}}
\newcommand{\POB}[2]{\OB{\makebox[0pt]{#1}}{\vphantom{\bra{2}}#2}}
\newcommand{\UB}[2]{\underbrace{#2}_{\text{#1}}}
\newcommand{\PUB}[2]{\UB{\makebox[0pt]{#1}}{\vphantom{\bra{2}}#2}}

Our purpose is to define, compute, and use \emph{rational expansions}.  They
intend to be to the differentiation (derivation) of rational expressions
what differential forms are to the differentiation of functions.  Defining
expansions requires several concepts, defined bottom-up in this section.
The following figure should help understanding these different entities, how
they relate to each other, and where we are heading to: given a weighted
rational expression  (weights are written in angle
brackets), compute its expansion:
\vspace{-.8\baselineskip}

It is helpful to think of expansions as a normal form for expressions.

\subsection{Rational Series}

Series are to weighted automata what languages are to Boolean automata.  Not
all languages are rational (denoted by an expression), and similarly, not
all series are rational (denoted by a weighted expression).  We follow
\citet{sakarovitch.09.eat}.

Let  be a (finite) alphabet, and  a
semiring whose (possibly non commutative) multiplication will be denoted by
implicit concatenation.  A (formal power) \dfn{series} over  with
\dfn{weights} (or \dfn{multiplicities}) in  is any map from  to
.  The weight of a word  in a series  is denoted .  The
\dfn{support} of a series  is the language of words that have a non-zero
weight in .  The \dfn{empty} series, , is denoted ;
for any word  (including ),  denotes the series
m = u.  Equipped with
the pointwise addition () and the
Cauchy product
()
as multiplication, the set of these series forms a semiring denoted
.

The \dfn{constant term} of a series , denoted , is ,
the weight of the empty word.  A series  is \dfn{proper} if
. The \dfn{proper part} of , denoted , is the
proper series which coincides with  on non empty words:
.

The \dfn{star} of a series is an infinite sum: .
To ensure semantic soundness, we suppose that  is a
\dfn{topological semiring}, i.e., it is equipped with a topology, and both
addition and multiplication are continuous.  Besides, it is supposed to be
\dfn{strong}, i.e., the product of two summable families is summable.  This
ensures that , equipped with the product topology derived from the
topology on , is also a strong topological semiring.

\begin{Proposition}
  \label{prop:dev}
  Let  be a strong topological semiring. Let ,
 is defined iff  is defined and then
  .
\end{Proposition}
\begin{proof}
  By \citep[Prop.~2.6, p.~396]{sakarovitch.09.eat}  is defined iff
   is defined and then
  .  The
  result then follows directly from :
  .
\end{proof}

Rational languages are closed under intersection.  Series support a natural
generalization of intersection, the Hadamard product, which we name
\dfn{conjunction} and denote .  The conjunction of series  and  is
defined as .

Rational languages are also closed under complement, but generalizing this
concept to series is more debatable.  In the sequel, we will rely on the
following definition: `` is the characteristic series of the complement
of the support of .''  More precisely,  where
 if ,  otherwise.

\begin{Proposition}
  \label{prop:series}
  For series  with , for
  , and weights :
  
\end{Proposition}

\subsection{Extended Weighted Rational Expressions}
\label{sec:expr}
\begin{Definition}[Extended Weighted Rational Expression]
  A \dfn{rational (or regular) expression}  is a term built from the
  following grammar, where  is a letter, and  a weight:
  .
\end{Definition}

Since the product of  does not need to be commutative there are two
exterior products:  and .
The \dfn{size} (aka \dfn{length}) of an expression , , is
its number of symbols, excluding parentheses; its \dfn{width} (aka
\dfn{literal length}), , is the number of occurrences of
letters.

Rational expressions are syntactic objects; they provide a finite notations
for (some) series, which are semantic objects.
\begin{Definition}[Series Denoted by an Expression]
  Let  be an expression.  The series denoted by , noted
  , is defined by induction on :
  
\end{Definition}
An expression is \dfn{valid} if it denotes a series.  More specifically,
this requires that  is well defined for each subexpression of
the form , i.e., that the constant term of  is
\emph{starrable} in  (\cref{prop:dev}).  This definition, which involves
series (semantics) to define a property of expressions (syntax), will be
made effective (syntactic) with the appropriate definition of the constant
term  \emph{of an expression } (\cref{def:ctder}).

\begin{longenv}
\begin{Example}[{\citep[Example~1]{lombardy.2005.tcs}}]
  \label{ex:e2}
  Expressions  have weights in
  .   is valid: its stars are on expressions that denote proper
  series.   is valid, as the constant term of  is
  , whose star is defined:
  2. .
\end{Example}
\end{longenv}

Two expressions  and  are \dfn{equivalent} iff
.  Some expressions are ``trivially equivalent''; any
candidate expression will be rewritten via the following \dfn{trivial
  identities}.  Any subexpression of a form listed to the left of a
`' is rewritten as indicated on the right.

where  stands for a rational expression, ~is a letter,
 denote two different labels, 
are weights, and  denotes either , or
 in which case  in the right-hand side of .
The choice of these identities is beyond the scope of this paper (see
\cite{sakarovitch.09.eat}), however note that, with the exception of the
last line, they are limited to trivial properties; in particular
\dfn{linearity} (``weighted ACI'': associativity, commutativity, and
) is not
enforced.  In practice, additional identities help reducing the number of
derived terms \citep{owens.2009.jfp}, hence the final automaton size.  The
last two rules, about complement, will be discussed in \cref{sec:compl};
they are disabled when  has zero divisors.

\begin{Example}
  \label{ex:ab}
  Conjunction and complement can be combined to define new operators which
  are convenient syntactic sugar.  For instance,
   allows to define a
  left-biased  operator:  if
  ,  otherwise.  The following example
  mocks Lex-like scanners: identifiers are non-empty sequences of letters of
   that are not reserved keywords.  The expression
  , with weights in
  , maps the ``keyword''  to 2, and ``identifiers'' to 3.
  Once desugared and simplified by the trivial identities, we have
  .
\end{Example}


\subsection{Rational Polynomials}
\label{sec:poly}

At the core of the idea of ``partial derivatives'' introduced by
\citet{antimirov.1996.tcs}, is that of \emph{sets} of rational expressions,
later generalized in \emph{weighted sets} by \citet{lombardy.2005.tcs},
i.e., functions (partial, with finite domain) from the set of rational
expressions into .  It proves useful to view such
structures as ``polynomials of rational expressions''.  In essence, they
capture the linearity of addition.

\begin{Definition}[Rational Polynomial]
  A \dfn{polynomial} (of rational expressions) is a finite (left) linear
  combination of rational expressions.  Syntactically it is represented by a
  term built from the grammar
  
  where  denote \emph{non-null} weights, and
   denote \emph{non-null} expressions.  Expressions may not appear
  more than once in a polynomial.  A \dfn{monomial} is a pair
  .
\end{Definition}

We use specific symbols ( and ) to clearly separate the outer
polynomial layer from the inner expression layer.
A polynomial  of rational expressions can be ``projected'' as a
rational expression  by mapping its sum and left-multiplication
by a weight onto the corresponding operators on rational expressions.  This
operation is performed on a canonical form of the polynomial (expressions
are sorted in a well defined order).  Polynomials denote series:
.

\begin{Example}\label{ex:e1}
  Let .  Polynomial
  `' has two monomials:
  `' and `'.  It denotes the (left) quotient of
   by , and
  `' the quotient by
  .
\end{Example}

Let 
be a polynomial,  a weight (possibly null) and  an expression
(possibly null), we introduce the following operations:

Trivial identities might simplify the result, e.g.,
.

Note the asymmetry between left and right exterior products.  The addition
of polynomials is commutative, multiplication by zero (be it an expression
or a weight) evaluates to the null polynomial, and the left-multiplication
by a weight is distributive.





\begin{Lemma}
  \label{lem:poly:ops}
  \\
  .
\end{Lemma}
\begin{proof}
  The first three are trivial.  The case of  follows from
  \cref{eq:series:and:distrib}. Complement follows from its definition:
  .
\end{proof}

\subsection{Rational Expansions}
\label{sec:expa}



\begin{Definition}[Rational Expansion]
  A \dfn{rational expansion}  is a term built from the grammar
  
  where  is a weight (possibly null),  letters
  (occurring at most once), and  non-null polynomials.  We name 
  the \dfn{constant term},
   the \dfn{proper
    part}, and  (possibly empty) the \dfn{firsts}.
\end{Definition}
To ease reading, polynomials are written in square brackets.  Contrary to
expressions and polynomials, there is no specific term for the empty
expansion: it is represented by , the null weight.  Except for
this case, null constant terms are left implicit.  Besides their support for
weights, expansions differ from Antimirov's linear forms in that they
integrate the constant term, which gives them a flavor of series.  Given an
expansion , we denote by  (or ) its constant
term, by  its firsts, by  its proper part, and by  (or
) the polynomial corresponding to  in .  Expansions will
thus be written:
.



An expansion whose polynomials are monomials is said to be
\dfn{deterministic}.  An expansion  can be ``projected'' as a rational
expression  by mapping weights, letters and polynomials to their
corresponding rational expressions, and / to the
sum/concatenation of rational expressions.  Again, this is performed on a
canonical form of the expansion: letters and polynomials are sorted.
Expansions also denote series: .  An
expansion  is said to be \dfn{equivalent} to an expression  iff
.

\begin{Example}[\cref{ex:e1} continued]
  \label{ex:e1:xpn}
  Expansion
  
  has  as constant term, and maps the letter 
  (resp.\ ) to the polynomial  (resp.\
  ).   can be proved to be equivalent to
  .
\end{Example}

Let  be expansions,  a weight, and  an expression (all
possibly null):

Since by definition expansions never map to null polynomials, some firsts
might be smaller that suggested by these equations.  For instance in
 the sum of  and
 is , and
 is
 since .  Note that  is a
deterministic expansion.

The following lemma is simple to establish: lift semantic equivalences,
such as those of \cref{prop:series}, to syntax, using \cref{lem:poly:ops}.
\begin{Lemma}
  \label{lem:xpn:semantics}
  \\
  .
\end{Lemma}

\subsection{Weighted Automata}

\begin{Definition}[Automaton]
  A \dfn{weighted automaton}  is a tuple 
  where:
  \begin{itemize}
  \item  (the set of labels) is an alphabet (usually finite),
    \ifthenelse{\boolean{long}}{\item}{and}  (the set of weights) is a
    semiring,
  \item  is a set of states,\ifthen{\boolean{long}}{\item}  and 
    are the \dfn{initial} and \dfn{final} functions from  into ,
  \item  is a (partial) function from  into
    ;

    its domain represents the \dfn{transitions}:
    .
  \end{itemize}
\end{Definition}
An automaton is \dfn{locally finite} if each state has a finite number of
outgoing transitions ( is
finite).  A \dfn{finite automaton} has a finite number of states.
A \dfn{path}  in an automaton is a sequence of transitions
 where the source
of each is the destination of the previous one; its \dfn{label} is the word
, its \dfn{weight} is
.
The \dfn{evaluation} of word  by a locally finite automaton ,
, is the (finite) sum of the weights of all the paths labeled by
, or  if there are no such path.  The \dfn{behavior} of such an
automaton  is the series .  A
state  is \dfn{initial} if .  A state  is
\dfn{accessible} if there is a path from an initial state to .  The \dfn{accessible} part
of an automaton  is the subautomaton whose states are the accessible
states of .  The size of a finite automaton, , is its
number of states.



We are interested, given an expression , by an algorithm to compute an
automaton  such that 
(\cref{sec:expaton}).  To this end, we first introduce a simple recursive
procedure to compute \emph{the} expansion of an expression.

\section{Computing Expansions of Expressions}
\label{sec:expr-to-expa}


\subsection{Expansion of a Rational Expression}
\label{sec:expa-of-expr}
\begin{Definition}[Expansion of a Rational Expression]
  \label{def:expa-of-expr}
  The \dfn{expansion of a rational expression} , written , is
  the expansion defined inductively as follows:
  
  where  are
  the constant term/proper part of .
\end{Definition}

The right-hand sides are indeed expansions.  The computation trivially
terminates: induction is performed on strictly smaller subexpressions.
These formulas are enough to compute the expansion of an expression; there
is no secondary process for the firsts --- indeed
 suffices and every other case
simply propagates or assembles the firsts --- or the constant terms.  Of
course, in an implementation, a single recursive call to  is
performed for \cref{eq:epn:mul,eq:epn:star}, from which  and
 are obtained.  So for instance \cref{eq:epn:star} should rather
be written:
.  Besides, existing expressions should be referenced to, not
duplicated: in the previous piece of code,  is not built again, the
input argument is reused.

\begin{Proposition}
  The expansion of a rational expression is equivalent to the expression.
\end{Proposition}
\begin{proof}
  We prove that  by induction on the expression.
  The equivalence is straightforward for
  \cref{eq:epn:cst,eq:epn:add}.
The case of multiplication, \cref{eq:epn:mul}, follows from:
  
  It might seem more natural to exchange the two terms (i.e.,
  ), but an
  implementation first computes  and then computes 
  \emph{only if} .
The case of Kleene star, \cref{eq:epn:star}, follows from \cref{prop:dev}.
  The case of conjunction is straightforward:
\ifthen{\boolean{long}}{
  
}{
  
}
\end{proof}


\subsection{Connection with Derivatives}

We reproduce here the definition of constant terms and derivatives from
Lombardy et al \citep[p.~148 and Def.~2]{lombardy.2005.tcs}, with our
notations and added support for extended expressions.

\begin{Definition}[Constant Term and Derivative]
  \label{def:ctder}
  
  where \cref{eq:der:star} applies iff  is defined in .
\end{Definition}

The reader is invited to compare \cref{def:expa-of-expr} and
\cref{def:ctder}, which does not even include the computation of the firsts.

\begin{Proposition}\label{prop:expa:der}
  For any rational expression , , and
  .
\end{Proposition}

\begin{proof}
  A straightforward induction on .  The cases of constants and letters
  are immediate consequences of \cref{eq:der:cst,eq:der:label} on the one
  hand, and \cref{eq:epn:cst} on the other hand.
  \Cref{eq:epn:add,eq:der:add} both express straightforward ``linearity''.
  Multiplication (concatenation) is again barely a change of notation
  between \cref{eq:epn:mul} and \cref{eq:der:mul}, and likewise for the
  Kleene star (\cref{eq:epn:star,eq:der:star}).  Conjunction,
  \cref{eq:der:and}, follows from \cref{eq:epn:and,eq:epn:and:epn}, and
  complement, \cref{eq:der:compl}, from \cref{eq:epn:compl} and
  \cref{eq:epn:compl:epn}.
\end{proof}

\Cref{prop:expa:der} states that expansions, like Antimirov's linear forms,
offer a different means to compute the expression derivatives.  However
expansions seem to better capture the essence of the process, where the
computations of constant terms are tightly coupled with that of the
derivations.  The formulas are more concise.  Expansions are also ``more
complete'' than derivations, viz., the expansion of an expression can be
seen as a normal-form of this expression:  and
.  Expansions are more efficient to perform
effective calculations, such building an automaton (\cref{sec:perfs}), while
derivatives are used to prove the correctness (\cref{thm:expaton}).

\section{Expansion-Based Derived-Term Automaton}
\label{sec:expaton}
\vspace{-1ex}
\begin{Definition}[Derived-Term Automaton]
  \label{def:expaton}
  The \dfn{derived-term automaton} of an expression  is the accessible
  part of the automaton 
  defined as follows:
  \begin{itemize}
  \item  is the set of rational expressions on alphabet  with weights
    in ,
  \item
    ,
  \item ,  iff .
  \end{itemize}
\end{Definition}
The resulting automaton is locally finite, and not necessarily
deterministic\ifthen{\boolean{long}}{: given a state  and
   one of its firsts, the ``destinations'' are all the
  expressions of }.

\begin{Example}[\cref{ex:e1,ex:e1:xpn} continued]
  \label{ex:e1:end}
\ifthenelse{\boolean{long}}{
  Given ,  follows.
  \renewcommand{\UB}[2]{#2}
  \abovedisplayskip=\abovedisplayshortskip
  }
{We have .  is:}

  \centerline{\includegraphics[scale=.8]{e1}}
\end{Example}

It is straightforward to extract an algorithm from \cref{def:expaton}, using
a work-list of states whose outgoing transitions to compute.  This approach
admits a natural lazy implementation: the whole automaton is not computed at
once, but rather, states and transitions are computed on-the-fly, on demand,
for instance when evaluating a word.

\begin{theorem}
  \label{thm:expaton}Any (valid) expression  and its expansion-based derived-term
  automaton  denote the same series, i.e.,
  .
\end{theorem}

The smallness of the derived-term automaton for basic operators
(
\citep[Theorem~2]{lombardy.2005.tcs}) no longer applies with extended
operators.  Let  and  be coprime integers,
 has width ; it is
easy to see that .  It is also a classical result
that the minimal (trim) automaton to recognize the language of
 has  states; so
, but  (the
additional state is the sink state needed to get a \emph{complete}
deterministic automaton before complement).  Actually, when complement is
used on infinite semiring, it is not even guaranteed that the automaton is
finite (\cref{sec:compl}).

\begin{proof}[Sketch of proof of \cref{thm:expaton}, see \cref{app:proof:expaton}]
  This result is proved as \citep[Theorem~4]{lombardy.2005.tcs}: it requires
  several lemmas whose proofs are simple, but long.

  First define the derivation with respect to a word as the repetition of
  derivation with respect to a letter, and prove that
  .

  Second, prove that the set of derivatives of an expression  with
  respect to words is generated by , a set of expressions, called
  \dfn{derived terms}.  The states of the derived-term automaton are not any
  expressions, they are derived terms (and  itself), so the finiteness
  of  implies that of the automaton.

   admits a simple inductive computation \citep[Definition
  3]{lombardy.2005.tcs}, to which we add:
  
  If  features no complement,  is trivially finite.  Equation
  \Cref{eq:d:compl} is related to \emph{determinized} expansions
  (\cref{sec:determ}): in essence it dubs (complements of) all potential
  derivatives of  into derived-terms (comparable to going from
  Antimirov's partial derivatives to Brzozowski's derivatives).  On infinite
  semirings,  is infinite (more about this in \cref{sec:compl}).
  However, on finite semirings, such as , it is finite, albeit
  potentially large.

  Finally, prove that  for all words
  .
\end{proof}

\begin{longenv}
  \begin{Example}[\cref{ex:e2} continued]
    To compute the expansion of , one has:
    \newcommand{\dterm}[1]{\fcolorbox{black}{lip}{}}
    

    \label{ex:e2:aut}
    The derived terms of  are  and :
    

    The derived-term automaton of  is therefore:

    \centerline{\includegraphics[scale=.8]{e2}}
  \end{Example}
  \vspace{-10mm}
\end{longenv}

\subsection{Deterministic Automata}
\label{sec:determ}
The exposed approach can be used to generate \emph{deterministic} automata
by \emph{determinizing} the expansions:
.
The  operator ``consolidates'' a polynomial into an
expression that ensures this determinism.  For instance the expansion
, which would yield two
transitions labeled by , one to  and the other to , is determinized
into , yielding a single transition, to .

It is well known that some nondeterministic \emph{weighted} automata have no
deterministic equivalent, in which case determinization loops.  Our
construct is subject to the same condition.  The expression
 on the alphabet  admits an
infinite number of derivatives:
.  Therefore
our construction of \emph{deterministic} automata would not terminate: the
automaton is locally finite but infinite (and there is no finite
deterministic automaton equivalent to ).  However, a lazy
implementation as available in \vcsn{}\cref{foot:url} would uncover the
automaton on demand, for instance when evaluating a word.

\smallskip
\centerline{\includegraphics[scale=.8]{lazy}}

To improve determinizability, when  features a left-division, we apply
the usual technique used in weighted determinization implementations:
normalize the results to keep a unique representative of colinear
polynomials.  Concretely, when determinizing expansions, polynomials are
first normalized:

where, for a polynomial , and a
weight ,
,
and the weight  denotes some ``norm'' of (the coefficients of)
.  For instance  can be the GCD of the  (so that the
coefficients are coprime), or, in the case of a field, the first non null
 (so that the first non null coefficient is ), or the sum of the
 provided it's not null (so that the sum of the coefficients is
), etc.

\begin{Example}[\cref{ex:e1,ex:e1:xpn,ex:e1:end} cont.]
  \label{ex:e1:det}
  The deterministic derived-term automaton of  using
  GCD-normalization is:
  \
    d(\Ed_3)
    &= a \odot [\Lmul{2}{b} \oplus \Lmul{3}{\paren{b^{c} \AND (a+b)^*}}]
      \oplus b \odot [\Lmul{3}{(a+b)^*}]
  -1ex]
  \centerline{\includegraphics[scale=.8]{scanner-ab}}
\end{Example}
\vspace{-10mm}

\subsection{Complexity and Performances}
\label{sec:perfs}
We focus on basic expressions.  Obviously, ,
and we know .

The complexity of Antimirov's algorithm is 
\citep{champarnaud.2002.tcs}: for each of the  states, we
may generate at most  partial derivatives, each one to
compare to the  derived-terms.  That's
 comparisons to perform on objects of size
.

However, hash tables allow to avoid these costly comparisons.  For each of
the  states, we may generate at most 
partial derivatives and number them via a hash table.  Computing an
expansion builds an object of size , however using
references instead of deep copies allows to stay linear, so the complexity
is .

\smallskip
To build the derived-term automaton using derivation, one loops over the
alphabet for each derived term.  This incurs a performance penalty with
large alphabets.
The following table reports the duration of the process, in milliseconds,
for  (right associative) by
\vcsn\footnote{\vcsn 2.2 as of 2016-01-29, compiled with Clang 3.6 with
  options \texttt{-O3 -DNDEBUG}, and run on a Mac OS X 10.11.3, Intel Core
  i7 2.9GHz, 8GB of RAM.  Best run out of five.}, depending on , for two
alphabet sizes: 2 and 254 (\vcsn reserves two \texttt{chars}).

\smallskip
\noindent
\newcommand{\T}[1]{\multicolumn{1}{c}{~~~~~#1~~~}}
\begin{tabular}{l@{~~~}d{2}d{2}d{1}d{1}d{0}d{0}d{0}}
{}             & \T{5} & \T{10} & \T{50} & \T{100} & \T{500} & \T{1000} & \T{5000} \\
  \cmidrule{2-8}
  derivation 2   & 0.08  & 0.12   & 0.80   & 2.5     & 55      & 210      & 4,735    \\
  derivation 254 & 1.12  & 2.15   & 15.56  & 39.2    & 694     & 2,448    & 59,019   \\
  expansion 2    & 0.08  & 0.10   & 0.55   & 1.2     & 20      & 70       & 1,617    \\
  expansion 254  & 0.08  & 0.11   & 0.49   & 1.2     & 19      & 70       & 1,619    \\
\end{tabular}
\vspace*{.2\baselineskip}

Even on a two-letter alphabet, the expansion-based algorithm performs better
than the derivation-based one. (To put things in perspective, the
construction of the standard automaton for  takes ms.)


One can optimize the derivation-based algorithm by computing the firsts
globally \citep{owens.2009.jfp} or locally, on-the-fly, and then derivating
on this set.  However, on sums such as  (where  are
distinct letters) the expansion requires a single traversal () whereas
one still needs  derivations, a  process.
Besides, the derivation-based algorithm computes the constant term of an
expression several times: to check whether the current state is final, to
compute the derivation of products and stars, and to compute the firsts of
products.  To fix this issue, these repeated computations can be cached.

Addressing both concerns (iteration over the alphabet, repeated computation
of the constant term) for the derivation-based algorithm requires three
tightly entangled algorithms (constant term, derivation, first).
Expansions, on the other hand, keep them together, in a single construct,
computed in a single traversal of the expression.




\section{Related Work}
\label{sec:related}
Compared to \citet{brzozowski.64.jacm} we introduced \emph{weighted}
expansions, and their direct computation, making them the core computation
of the algorithm.  This was partly done for basic Boolean expressions by
\citet{antimirov.1996.tcs} as ``linear forms''.

Aside from our support for weighted expressions, our approach of extended
operators is comparable to that of \citet{caron.2011.lata.2}, but, we
believe, using a simpler framework.  Basically, their sets of sets of
expressions correspond to polynomials of conjunctions: their
 is our .
Using our framework, the automaton of Fig.~3 \citep{caron.2011.lata.2} has
one state less, since  and  both are
.  Actually, the main point of sets of sets of expressions is
captured by our \emph{distributive} definition of the conjunction of
polynomials, \cref{eq:poly:ops:andcompl}, which matches that of their
\raisebox{1pt}{\scalebox{.7}{\circled{}}} operator\begin{longenv}
  ; indeed what they call the ``natural extension''
  \citep[Sect.~3.1]{caron.2011.lata.2} would correspond to
  
\end{longenv}
.  Additional properties, such as associativity of , can be enabled
via additional trivial identities.  Like us, their
\raisebox{1pt}{\scalebox{.7}{\circled{}}} operator ensures that
complemented expressions generate deterministic automata.

For basic (weighted) expressions, completely different approaches build the
derived-term automaton with a quadratic complexity
\citep{allauzen.2006.mfcs.2, champarnaud.2007.dlt.2}.  However, the
expansion-based algorithm features some unique properties.  It supports a
simple and natural on-the-fly implementation.  It provides insight on the
built automata by labeling states with the language/series they denote
(e.g., \vcsn renders derived-term automata as in \ifthenelse{\boolean{long}}
{\cref{ex:e1:end,ex:e1:det,ex:e2:aut,ex:ab:aut}}
{\cref{ex:e1:end,ex:e1:det,ex:ab:aut}}).  It is a flexible framework in
which new operators can be easily supported (e.g., the shuffle and
infiltration operators in \vcsn).  It supports the direct construction of
deterministic automata.  And it copes easily with alternative derivation
schemes, such as the ``broken derived-terms'' \citep{lombardy.04.latin,
  lombardy.2005.tcs, lombardy.2010.rairo, angrand.2010.jalc}.

\section{Conclusion}
\label{sec:conc}
The construction of the derived-term automaton from a weighted rational
expression is a powerful technique: states have a natural interpretation
(they are identified by their future: the series they compute), extended
rational expressions are easily supported, determinism can be requested, and
it even offers a natural lazy, on-the-fly, implementation to handle infinite
automata.

To build the derived-term automaton, we generalized Brzozowski's expansions
to weighted expressions, and an inductive algorithm to compute the expansion
of a rational expression.  The formulas on which this algorithm is built
reunite as a unique entity three facets that were kept separated in previous
works: constant term, firsts, and derivatives.  This results in a simpler
set of equations, and an implementation whose complexity is independent of
the size of the alphabet and even applies when it is infinite (e.g., when
labels are strings, integers, etc.).  Building the derived-term automaton
using expansions is straightforward.  Derivatives are only a technical tool
to prove the correctness of the derived-terms.  We have also shown that
using proper techniques, the complexity of the algorithm is much better that
previously reported.

The computation of expansions and derivations are implemented in
\vcsn{}\cref{foot:url}, together with their automaton construction
procedures (possibly lazy, possibly deterministic).  Our implementation
actually prototypes support for additional operators on rational expressions
(e.g., shuffle and infiltration).  Our future work is focused on these
operators.

\subparagraph*{Acknowledgments} Interactions with A.~Duret-Lutz,
S.~Lombardy, L.~Saiu and J.~Sakarovitch resulted in this work.  Anonymous
reviewers made very helpful comments.

\bibliographystyle{myabbrvnat}
\bibliography{article,share/bib/acronyms,share/bib/lrde,share/bib/comp.lang.c++,share/bib/comp.compilers.automata}

\appendix
\section{Appendix}
\label{sec:appendix}

\begin{proof}[Proof of \cref{lem:xpn:semantics}]
  Most operators are trivial, we focus here on the extended operators.
  

  
\end{proof}

\begin{Example}[\cref{ex:ab:xpn} detailed]
  \label{ex:ab:xpn:detailed}
  We have:
  
  
  therefore:
  
  and finally
  
\end{Example}

\section{Appendix: Proof of \cref{thm:expaton}}
\label{app:proof:expaton}

Proving this theorem requires several auxiliary results.  None of them is
needed in an implementation: \cref{def:expa-of-expr} is all that is needed
to build the derived-term automaton.

The path, paved by \citet{lombardy.2005.tcs}, is as follows.  First, define
derivation with respect to a word, and show that it is a syntactic
``implementation'' of left-quotient of a series by a word
(\cref{sec:der:word}).  Then define (syntactically) the set of derived
terms, and show that they generate all the word derivatives
(\cref{sec:der-terms}).  Finally show that computations in the derived-term
automaton correspond to computing the left-quotient of the denoted series
(\cref{sec:dt-aut}).

This is also the path followed by the rather terse proof of
\citet[Proposition~4]{caron.2011.lata.2}, but filling the gaps.

\subsection{Derivation by Words}
\label{sec:der:word}
\begin{Definition}[Derivation of a Polynomial]
  
\end{Definition}

\begin{Lemma}\label{lem:der:poly}
  \abovedisplayskip=\abovedisplayshortskip
  
\end{Lemma}

\begin{proof}
  Let
  .
  

  

  
\end{proof}

Derivation wrt a single-letter word is defined as the derivation wrt that
letter.  Derivation wrt to a longer word is the result of repeated
derivations wrt letters.
\begin{Definition}[Derivation wrt a Word]
  .
\end{Definition}

\begin{Lemma}
  \label{lem:der:words}
  
\end{Lemma}

Explicit formulas exist for derivation with respect to a word.
\begin{Lemma}[Direct Computations of Derivation wrt a Word]
  \abovedisplayskip=\abovedisplayshortskip
  \label{lem:der:word}
  
\end{Lemma}

\begin{proof}
  The proof is the same as that of \citep[Prop.~3]{lombardy.2005.tcs}, with
  additional cases for conjunction and complement.

  For conjunction:
  

  For complement:
  
\end{proof}

The following lemma makes explicit the connection between the (syntactic)
derivation, and the semantics of an expression.

\begin{Lemma}[{\citep[Prop.~4]{lombardy.2005.tcs}}]
  \label{lem:sem:der:word}
  .
\end{Lemma}

\begin{proof}
  For conjunction:
  

  For complement:
  
\end{proof}


The previous lemma allows to show the connection between the (syntactic)
derivation, and the (semantical) left-quotient of a series.
\begin{theorem}[{\citep[Theorem~1]{lombardy.2005.tcs}}]
  \label{thm:sem:derivative}
  .
\end{theorem}
\begin{proof}
  For any word ,
  
\end{proof}

\subsection{Derived Terms}
\label{sec:der-terms}
\begin{Definition}[Derived Terms]
  \label{def:dts}
  Given an expression , its \dfn{derived terms} is the set 
  defined as follows:
  
  \noindent where in the last equation, the  are sorted.  Besides,
  depending on the features of , the coefficients may be normalized so
  that colinear combinations are represented only once.  For instance if
   has no zero divisor, one may divide by the GCD of the  (so that
  the  are coprime), or, in the case of a field, by the first non null
   (so that the first non null coefficient is ), or by the sum of
  the  provided it's not null (so that the sum of the coefficients is
  ), etc.
\end{Definition}

\begin{theorem}
  If  is finite, or if  has no complement, then  is finite.
\end{theorem}

\begin{proof}
  This is a direct consequence from \cref{def:dts}: finiteness propagates
  during the induction.  The only danger is the case of complement, whose
  finiteness ensues from a very crude criterion: there exists a finite
  number of combinations.
\end{proof}


We prove that the set of derived terms is closed by derivation.  The
insightful reader can see automata dawning: the derived terms are the
states, and the coefficients are the weights of the transitions.
\begin{Lemma}
  \label{lem:dt:closed:letter}
  We denote  by .

  Let  be an expression,  be its
  derived terms.  There exists  coefficients  and
   coefficients  such that
  
\end{Lemma}

\begin{proof}
  We follow \citep[proof of Theorem~2]{lombardy.2005.tcs}, to which we add
  the following cases.  We note:
  

  Consider :
  
  which is indeed a linear combination of derived terms of ,
  since
   by definition \cref{def:dts}.

  Likewise,
  
  is a linear combination of elements of .

  Consider :
  
  which is a member of .  Note in this case, we expect the 
  to be sorted in the same order as the one used by .

  Besides:
  
  which is a member of .
\end{proof}

The following result, similar to \citep[Theorem~3]{lombardy.2005.tcs}, shows
that any word derivative of an expression is a linear combination of its
derived terms.
\begin{theorem}
  \label{thm:k}
  Let  be an expression,  be its
  derived terms, and  any word.  There exist coefficients
   in  such that:
  
\end{theorem}

\begin{proof}
  The result is proved by induction.

  The base case is established by \cref{lem:dt:closed:letter}.
  
  \noindent
  i.e.,
  
\end{proof}

\subsection{Derived-term Automaton}
\label{sec:dt-aut}
In order to prove the final result, we express automata in a different way
\citep[Sect.~5]{lombardy.2005.tcs}.

\begin{Definition}[Representations of a Finite Weighted Automaton]
  The \dfn{matrix representation} of a (finite weighted) automaton is the
  sextuplet  where:
  \begin{itemize}
  \item  is an alphabet
  \item  (the set of weights) is a semiring,
  \item  is a finite set of states,
  \item  (resp. ) is a row (resp. column) vector of dimension  with
    entries in ,
  \item  is a square matrix whose entries are linear combinations of
    letters of  with coefficients in .
  \end{itemize}

  \medskip

  The \emph{-representation} of an automaton is the triple
   where  is a morphism from  to
   such that .
\end{Definition}

One can then prove that, for every word :


Put together, the definition of derivation and constant terms
(\cref{def:ctder}), their connection with expansions (\cref{prop:expa:der}),
the definition of , the expansion-based derived-term automaton of
 (\cref{def:expaton}), and finally \cref{lem:dt:closed:letter}, show
that  admits the following -representation:


\noindent
where the coefficients  were defined in
\cref{lem:dt:closed:letter}.  The  are the derived-terms of , to
which we add  if , in which case
, and  for
all .

We prove by induction that:


\begin{proof}
  The base case:
  

  Then the induction:
  
\end{proof}

We can now finally prove that .  Let :


The case of the empty word follows from the definition of  and :
.
\end{document}
