\pdfoutput=1
\documentclass{article}









\usepackage[nonatbib,preprint]{neurips_2020}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{subfig}
\usepackage{caption}
\usepackage{enumitem}
\captionsetup[table]{font=small}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{cancel}



\newcommand{\crossmark}{\textit{\sffamily x}}

\newcommand{\best}[1]{{\color{red}\textbf{#1}}}
\newcommand{\good}[1]{{\color{violet}#1}}

\newcommand{\xb}[1]{{\color{red}[XB: #1]}}
\definecolor{darkgreen}{rgb}{0.0, 0.56, 0.0}
\newcommand{\cj}[1]{{\color{darkgreen}[CJ: #1]}}
\newcommand{\vijay}[1]{{\color{violet}[VD: #1]}}
\newcommand{\tl}[1]{{\color{blue}[TL: #1]}}







\title{Benchmarking Graph Neural Networks}








\author{Vijay Prakash Dwivedi\thanks{Equal contribution} \\
  \texttt{vijaypra001@e.ntu.edu.sg} \\
  \And
  Chaitanya K. Joshi\footnotemark[1] \\
  \texttt{chaitanya.joshi@ntu.edu.sg} \\
  \AND
  Thomas Laurent \\
  \texttt{tlaurent@lmu.edu} \\
  \And
  Yoshua Bengio \\
  \texttt{yoshua.bengio@mila.quebec} \\
  \And
  Xavier Bresson \\
  \texttt{xbresson@ntu.edu.sg} \\
  \AND
  {\normalfont  School of Computer Science and Engineering, Nanyang Technological University, Singapore} \\
   Department of Mathematics, Loyola Marymount University \\ 
   Mila, University of Montr\'eal \hspace{0.1cm}  CIFAR
}







\begin{document}


\maketitle



\begin{abstract}
Graph neural networks (GNNs) have become the standard toolkit for analyzing and learning from data on graphs. As the field grows, it becomes critical to identify key architectures and validate new ideas that generalize to larger, more complex datasets. Unfortunately, it has been increasingly difficult to gauge the effectiveness  of new models in the absence of a standardized benchmark with consistent experimental settings. In this paper, we introduce a reproducible GNN benchmarking framework\footnote{\small{\url{https://github.com/graphdeeplearning/benchmarking-gnns}}},
with the facility for researchers to add new models conveniently for arbitrary datasets. We demonstrate the usefulness of our framework by presenting a principled investigation into the recent Weisfeiler-Lehman GNNs (WL-GNNs) compared to message passing-based graph convolutional networks (GCNs) for a variety of graph tasks, i.e. graph regression/classification and node/link prediction, with medium-scale datasets.





\end{abstract}






\section{Introduction}
In the last few years, graph neural networks (GNNs) have seen a great surge of interest with promising methods being developed for myriad of domains including chemistry~\cite{duvenaud2015convolutional,gilmer2017neural}, physics~\cite{cranmer2019learning,sanchez2020learning}, social sciences~\cite{kipf2017semi,monti2019fake}, knowledge graphs~\cite{schlichtkrull2018modeling,chami2020low}, recommendation~\cite{monti2017geometric,ying2018graph}, and neuroscience~\cite{griffa2017transient}. 
Historically, three classes of GNNs have been developed. The first models \cite{art:ScarselliGoriTsoiHagenbuchnerMonfardini09,bruna2013spectral,NIPS2016_6081,NIPS2016_6398,kipf2017semi,hamilton2017inductive} aimed at extending the original convolutional neural networks~\cite{lecun1995convolutional,lecun1998gradient} to graphs. 
The second class enhanced the original models with {anisotropic} operations on graphs~\cite{perona1990scale}, such as attention and gating mechanisms~\cite{battaglia2016interaction,marcheggiani2017encoding,Monti_2017,velickovic2018graph,bresson2017residual}.
The recent third class has introduced GNNs that improve upon theoretical limitations of previous models \cite{xu2018how,morris2019weisfeiler,maron2019provably,chen2019equivalence,murphy2019relational,srinivasan2019equivalence}. 
Specifically, the first two classes can only differentiate
simple non-isomorphic graphs and cannot separate automorphic nodes.
Developing powerful and theoretically expressive GNN architectures is a key concern towards practical applications and real-world adoption of graph machine learning.
However, tracking recent progress has been challenging as most models are evaluated on small 
datasets such as Cora, Citeseer and TU, which are inappropriate to differentiate complex, simple and graph-agnostic architectures \cite{Hoang2019RevisitingGN,chen2019powerful}, and do not have consensus on a unifying experimental setting~\cite{errica2019fair,hu2020ogb}.














Consequently, our motivation is to benchmark GNNs to identify and quantify what types of architectures, first principles or mechanisms are universal, generalizable, and scalable when we move to larger and more challenging datasets. Benchmarking provides a strong paradigm to answer these fundamental questions. It has proved to be beneficial for driving progress, identifying essential ideas, and solving domain-specific problems in several areas of science~\cite{weber2019essential}. 
Recently, the famous 2012 ImageNet challenge~\cite{imagenet_cvpr09} has provided a benchmark dataset that has triggered the deep learning revolution \cite{DBLP:conf/nips/KrizhevskySH12,10.1145/3065384}. Nevertheless, designing successful benchmarks is highly challenging as it requires both a coding framework with a rigorous experimental setting for fair comparisons, all while being reproducible, as well as using appropriate datasets that can statistically separate model performance. 
The lack of benchmarks has been a major issue in GNN literature as the aforementioned requirements have not been rigorously enforced.



A major contribution of this work is to design a benchmark infrastructure that can fairly evaluate GNN architectures on medium-scale datasets. Specifically, the coding infrastructure can be used to implement new GNNs from the most popular and theoretically designed classes of GNNs, and compare their performance in a rigorous manner. 
For nomenclature, we refer to the popular message-passing GNNs as graph convolutional networks (GCNs) and the theoretically expressive GNNs as Weisfeiler-Lehman GNNs (WL-GNNs), see Section \ref{sec:gnns}.
The main findings of our extensive numerical experiments are presented in Section \ref{sec:eval}, and summarized below:\vspace{-0.2cm}
\begin{itemize}[leftmargin=*]
    \item Message-passing GCNs \cite{kipf2017semi,hamilton2017inductive,Monti_2017,velickovic2018graph,bresson2017residual} are able to better leverage the basic building blocks of deep learning such as batching, residual connections and normalization, outperforming theoretically designed WL-GNNs \cite{xu2018how,maron2019provably,chen2019equivalence} on the 7 datasets considered in this paper.\vspace{-0.0cm}
\item Theoretically designed WL-GNNs such as \cite{maron2019provably,chen2019equivalence} are prohibitive in terms of time/space complexity and not amenable to batched training, suggesting 
    the need for additional developments for these models to be competitive with GCNs on practical tasks.\vspace{-0.0cm}
    In contrast, GCNs rely on sparse matrix computations, which are computationally and memory efficient.
    \item Overall, anisotropic GCNs which leverage attention \cite{velickovic2018graph} and gating \cite{bresson2017residual} mechanisms perform consistently across graph, node and edge-level tasks, improving over isotropic GCNs on 5
out of 7 datasets.
Additionally, for link prediction tasks, learning features for edges as joint representations of incident nodes during message passing significantly boosts performance. Their consistent results suggest further analysis on the expressivity of anisotropic models.\vspace{-0.0cm}
    \item Graph positional encodings with Laplacian eigenvectors \cite{belkin2003laplacian} are an elegant approach to overcome the theoretical limitation of low structural
expressivity of GCNs~\cite{murphy2019relational,srinivasan2019equivalence}, and boost performance on 3 out of 4 datasets without positional information.\vspace{-0.2cm}
\end{itemize} 
Our benchmarking framework and medium-scale datasets are open-sourced via GitHub to enable researchers to seamlessly explore new ideas in graph representation learning and track the progress of GNN architectures. 




















\section{Proposed GNN Benchmarking Framework}

\subsection{Coding Infrastructure}

Designing successful benchmarks requires a modular coding framework which is experimentally rigorous and reproducible for fair comparisons.
However, recent literature on GNNs does not have a consensus on training, validation and test splits as well as evaluation protocols, making it unfair to compare the performance of new ideas and architectures~\cite{errica2019fair}. 
Additionally, different hyper-parameters, loss functions and learning rate schedules make it difficult to identify new advances in architectures.
It is also unclear how to perform good data splits on graphs beyond randomizes splits, which are known to provide over-optimistic predictions \cite{lohr2009sampling}.
A unifying experimental setting is much needed given the heterogeneity in GNN evaluation procedures.

Our benchmarking infrastructure builds upon PyTorch~\cite{paszke2019pytorch} and DGL~\cite{wang2019dgl}, and has been developed with the following fundamental objectives:
(a) Ease-of-use and modularity, enabling new users to experiment and study the building blocks of GNNs;
(b) Experimental rigour and fairness for all models being benchmarked; and
(c) Being future-proof and comprehensive for tracking the progress of graph machine learning tasks and new GNNs.
At a high level, our benchmark unifies independent components for:
(i) Data pipelines; 
(ii) GNN layers and models; 
(iii) Training and evaluation functions;
(iv) Network and hyperparameter configurations; and 
(v) Scripts for reproducibility. 
We believe that a standardized framework can be of immense help to the community, enabling researchers to explore new ideas at any stage of the pipeline without setting up everything else. 
We direct readers to the \texttt{README} user manual included in our GitHub repository for detailed instructions on using the coding infrastructure.








\subsection{Graph Neural Networks}
\label{sec:gnns}
We benchmark two broad classes of GNNs. Firstly, we consider the widely used message passing-based graph convolutional networks (GCNs), which update node representations from one layer to the other according to the formula: .
Note that the update equation is {\it local}, only depending on the neighborhood  of node , and {\it independent of graph size}, making the space/time complexity  reducing to  for sparse graphs.
Thus, GCNs are highly parallelizable on GPUs and are implemented via sparse matrix multiplications in modern graph machine learning frameworks~\cite{wang2019dgl,fey2019fast}.
GCNs draw parallels to ConvNets for computer vision \cite{lecun1998gradient} by considering a convolution operation with shared weights across the graph domain.
We instantiate a class of {\it isotropic} GCNs when the node update equation treats every “edge direction” equally, \textit{i.e.} each neighbor contributes equally to the update of the central node by receiving the same weight value:

where  is a non-linear point-wise activation like ReLU. 
Popular isotropic GCNs include vanilla GCNs--Graph Convolutional Networks \cite{NIPS2016_6398,kipf2017semi} and GraphSage \cite{hamilton2017inductive}. 
On the other hand, when the update equation treats every edge direction differently, 
we instantiate {\it anisotropic} GCNs:

where   and  is a parameterized function whose weights are learned during training. The  can be scalars or vectors. In the latter case the multiplication between the term  and the term   should be understood as element-wise multiplication. 
MoNet--Gaussian Mixture Model Networks \cite{Monti_2017}, GatedGCN--Graph Convolutional Networks \cite{bresson2017residual}, and GAT--Graph Attention Networks \cite{velickovic2018graph} propose edge weights based on GMMs, gating mechanism and sparse attention for computing , respectively. 

The second class we investigate is the recent {\it Weisfeiler-Lehman} GNNs based on the WL test \cite{weisfeiler1968reduction}.  Authors in \cite{xu2018how} introduced GIN--Graph Isomorphism Network, a provable -WL GNN, which can distinguish two non-isomorphic graphs w.r.t. the -WL test.
Higher -WL isomorphic tests lead to more discriminative -WL GNNs in \cite{morris2019weisfeiler,maron2019provably}. However, -WL GNNs require the use of tensors of rank , which is intractable in practice for . As a result, \cite{maron2019provably} proposed a model, namely -WL GNNs, that uses rank-2 tensors while being -WL provable. This -WL model improves the space/time complexities of \cite{morris2019weisfeiler} from  to  respectively. The layer update equation 
of -WL GNNs is defined as:

where  are 2-layer MLPs applied to the feature dimension. Authors in \cite{chen2019equivalence} proposed RingGNNs, which also use rank-2 tensors and achieve higher learning capacity than -WL GNNs.
The layer update equation  
of RingGNN is:

and . This model uses the equivariant linear layer  defined in \cite{maron2018invariant} as , where  is the set of all basis functions for all linear equivariant functions from  and  are the basis for the bias terms. 
RingGNNs have the same space/time complexities as 3-WL GNNs. 
We refer the readers to the supplementary material for detailed formulations of these models.

All GCNs can be upgraded with basic building blocks of deep networks, \textit{i.e.} residual connections~\cite{He_2016_CVPR,li2019deepgcns} and batch normalization~\cite{ioffe2015batch}.
We discuss batch normalization and residual connections for WL-GNNs in Section \ref{sec:eval}.













\subsection{Datasets}
\label{sec:datasets}


{\bf Issues with Prevalent Datasets. } 
New ideas in the field of GNNs have mostly been evaluated on the realistic but small scale Cora~\cite{mccallum2000automating}, Citeseer~\cite{getoor2005link} and TU datasets~\cite{KKMMN2016tudata}.
For example, Cora is a single graph of 2.7K nodes, TU-IMDB has 1.5K graphs with 13 nodes on average and TU-MUTAG has 188 molecules with 18 nodes.
Although small datasets are useful as sanity checks for new ideas, they can become a liability in the long run as new GNN models will be designed to overfit the small test sets instead of searching for more generalizable architectures. 
As mentioned previously, another major issue with prevalent datasets is the lack of reproducibility of experimental results. 
Most published papers do not use the same train-validation-test split~\cite{errica2019fair}. 
Besides, even for the same split, the performance of GNNs present a large standard deviation on a regular 10-fold cross-validation due to the small size, see supplementary material.







At the same time, collecting representative, realistic and large scale graph datasets presents several challenges.
It is unclear what theoretical tools can define the quality of a dataset or validate its statistical representativeness for a given task.
Additionally, there are several arbitrary choices when preparing graphs, such as node and edge features. For example, e-commerce product features can be given by a specialized bag-of-words, or computed from word embeddings from the title as well as description. Finally, it is unclear how to classify dataset size/scale as
the appropriate size may depend on the complexity of the task as well as the dimensionality and statistics of underlying data.
Very large graph datasets also present a computational challenge and require extensive GPU resources to be studied~\cite{chiang2019cluster,rossi2020sign}. 
The recent Open Graph Benchmark (OGB) project~\cite{hu2020ogb} is a much needed initiative in the community to tackle these challenges. 
OGB offers a collection of medium-scale real-world graph machine learning datasets and evaluation protocols, with an emphasis on out-of-distribution generalization performance through meaningful data splits.







{\bf Proposed Datasets. } In our benchmark, we define {\it appropriate datasets} as those that are able to statistically separate the performance of GNNs. 
It is important to note that small datasets like Cora, Citeseer and TU datasets do not fulfil this requirement, as all GNNs perform almost statistically the same. Table~\ref{tab:data_summary} presents a summary of 7 medium-scale datasets and one small-scale dataset included in our benchmarking framework.
We cover the four most fundamental supervised graph machine learning tasks~\cite{chami2020machine}: graph regression (ZINC), graph classification (MNIST, CIFAR10, CSL), node classification (PATTERN, CLUSTER), and link prediction (TSP, COLLAB), coming from the domains of chemistry, mathematical modelling, computer vision, combinatorial optimization, and social networks. 
Four datasets (PATTERN, CLUSTER, TSP, CSL) are artificially generated, two datasets (MNIST, CIFAR10) are semi-artificial, and two (ZINC, COLLAB) are real-world datasets.
The dataset sizes in terms of total number of nodes vary between 0.27M to 7M.

\begin{table}[!t]
  \begin{center}
    \caption{Summary statistics of datasets included in the proposed benchmark.
    }
    \vspace{5pt}
    \label{tab:data_summary}
    \scalebox{0.68}{
    \begin{tabular}{llcccc}
    \toprule
    \textbf{\hspace{1cm} Domain \& Construction \hspace{1cm}} & \textbf{Dataset} & \textbf{\#Graphs} & \textbf{\#Nodes} & \textbf{Total \#Nodes} & \textbf{Task}  \\
      \midrule
      \midrule
      \multirow{1}{*}{\textbf{Chemistry}: Real-world molecular graphs}
      & ZINC & 12K & 9-37 & 277,864 & Graph Regression \\
      \midrule
      \multirow{2}[-2]{3in}{\textbf{Mathematical Modelling}: Artificial graphs generated from Stochastic Block Models} 
      & PATTERN & 14K  & 44-188 & 1,664,491 & \multirow{2}{*}{Node Classification} \\
      & CLUSTER & 12K  & 41-190 & 1,406,436 & \\
      \midrule
      \multirow{3}[-3]{2.5in}{\textbf{Computer Vision}: Graphs constructed with SLIC super-pixels of images} 
      & MNIST & 70K & 40-75 & 4,939,668 & \multirow{2}{*}{Graph Classification} \\
      & CIFAR10 & 60K  & 85-150 & 7,058,005 & \\
      \midrule
      \multirow{2}[-2]{3in}{\textbf{Combinatorial Optimization}: Uniformly generated artificial Euclidean graphs}
      & \multirow{2}{*}{TSP} & \multirow{2}{*}{12K} & \multirow{2}{*}{50-500} & \multirow{2}{*}{3,309,140} & \multirow{2}{*}{Edge Classification} \\
      & & & \\
      \midrule
      \multirow{1}{*}{\textbf{Social Networks}: Real-world citation graph}
      & \multirow{1}{*}{COLLAB} & \multirow{1}{*}{1} & \multirow{1}{*}{235,868} & \multirow{1}{*}{235,868} & Edge Classification \\
      \midrule
      \multirow{1}{*}{\textbf{Circular Skip Links}: Isomorphic graphs with same degree}
      & \multirow{1}{*}{CSL} & \multirow{1}{*}{150} & \multirow{1}{*}{41} & \multirow{1}{*}{6,150} & Graph Classification \\
      \bottomrule
    \end{tabular}
    }
  \end{center}
\end{table} 


{\bf Relevance. } 
\textbf{ZINC}~\cite{irwin2012zinc} is one of the most popular real-world molecular dataset of 250K graphs, out of which we randomly select 12K for efficiency.
We consider the task of graph property regression for contrained solubility, an important chemical property for designing generative GNNs for molecules~\cite{jin2018junction,you2018graph}. 
\textbf{PATTERN} and \textbf{CLUSTER} are node classification tasks generated with Stochastic Block Models~\cite{abbe2017community}, which are widely used to model communities in social networks by modulating the intra- and extra-communities connections, thereby controlling the difficulty of the task. 
PATTERN tests the fundamental graph task of recognizing specific predetermined subgraphs (as proposed in  \cite{art:ScarselliGoriTsoiHagenbuchnerMonfardini09}) and CLUSTER aims at identifying community clusters in a semi-supervised setting~\cite{kipf2017semi}. 
All SBM graphs are augmented with node features to simulate user attributes such that the tasks are more natural and not purely structural clustering tasks. 
\textbf{MNIST}~\cite{lecun1998gradient} and \textbf{CIFAR10}~\cite{krizhevsky2009learning} are classical image classification datasets converted into graphs using so called super-pixels~\cite{achanta2012slic} and assigning each node's features as the super-pixel coordinates and intensity. 
These datasets are sanity-checks, as we expect most GNNs to perform close to 100\% for MNIST and well enough for CIFAR10. 
\textbf{TSP}, based on the classical \textit{Travelling Salesman Problem}, tests link prediction on 2D Euclidean graphs to identify edges belonging to the optimal TSP solution given by the Concorde solver~\cite{applegate2006concorde}.  
TSP is the most intensely studied NP-Hard combinatorial problem with a growing body of literature on leveraging GNNs to learn better solvers~\cite{khalil2017learning,joshi2019efficient,bengio2018machine}. 
\textbf{COLLAB} is a link prediction dataset proposed by OGB~\cite{hu2020ogb} corresponding to a collaboration network between scientists indexed by Microsoft Academic Graph~\cite{wang2020microsoft}. 
The task is to predict future author collaboration relationships given past collaboration links. Lastly, \textbf{CSL} is a synthetic dataset introduced in \cite{murphy2019relational} to test the expressivity of GNNs. In particular, graphs are isomorphic if they have the same degree and the task is to classify non-isomorphic graphs. 

Finally, it is worth noting that our benchmarking infrastructure is complementary to the OGB initiative, and is well-suited to integrate current and future OGB dataset and evaluation protocols, as demonstrated by the inclusion of the COLLAB dataset.

















\section{Experimental Setting}
\label{sec:expsetup}





{\bf Data splitting.} ZINC has 10K train/1K validation/1K and 1K test graphs. For MNIST and CIFAR10, the statistics are respectively 55K train/5K validation/10K test, and 45K train/5K validation/10K test. The 5K samples for the validation set in both MNIST and CIFAR10 are sampled randomly from the respective train sets. 
The numbers of SBM graphs are 10K train/2K validation/2K test for PATTERN and 10K train/1K validation/1K test for CLUSTER. Similarly, TSP has 10K train/1K validation and 1K test graphs. 
COLLAB is a single large temporal graph of size 235K nodes with train/validation/test edge splits provided by OGB. 
Finally, CSL has 150 graphs and we follow 5-fold cross validation with stratified sampling to ensure class distribution remains the same across the splits. 
See supplementary for more details on generation and preparation of the datasets.



{\bf Training.} We use the Adam optimizer \cite{kingma2014adam} with the same learning rate decay strategy for all models. An initial learning rate is selected in  
which is reduced by half if the validation loss does not improve after a fixed number of epochs, either 5 or 10. We do not set a maximum number of epochs -- the training is stopped either when the learning rate has reached the small value of ,
or the computational time reaches 12 hours. We run each experiment with 4 different seeds and report the statistics of the 4 results. More details are provided in the supplementary.

{\bf Task-based network layer.} The node representations generated by the final layer of GCNs, or the dense tensor obtained at the final layer of the higher order WL-GNNs, are passed to a network suffix which is usually a downstream MLP
of 3 layers. 
For GIN, RingGNN, and 3WL-GNN, we follow the original instructions of network suffixes to consider feature outputs from each layer of the network, similar to that of Jumping Knowledge Networks \cite{xu2018representation}. 
See supplementary material for more details.

{\bf Parameter budgets.} Our goal is not to find the optimal set of hyperparameters for a specific GNN model (which is computationally expensive), but to compare and benchmark the model and/or their building blocks within a budget of parameters and a maximal computational time. Therefore, we decide on using two parameter budgets: (1)~100k parameters for each GNNs for all the tasks, and (2)~500k parameters for GNNs for which we investigate scaling a model to larger parameters and deeper layers. 
The number of hidden layers and hidden dimensions are selected accordingly to match these budgets, the details of which are in the supplementary material.






\section{Benchmarking GNNs}
\label{sec:eval}








\begin{table}[t!]
    \centering
    \caption{
    Benchmarking results for MP-GCNs and WL-GNNs across 7 medium-scale graph classification/regression and node/link prediction datasets.
    Results are averaged over 4 runs with 4 different seeds. \best{Red}: the best model, \good{Violet}: good models. 
    }
    \vspace{3pt}
    \scalebox{0.5}{
    \begin{tabular}{rr|ccccc|ccccc}
        \toprule
        & & \multicolumn{10}{c}{\textbf{NODE CLASSIFICATION}} \\
        & & \multicolumn{5}{c}{\textbf{PATTERN}} & \multicolumn{5}{c}{\textbf{CLUSTER}}\\
        \textbf{Model} & \textbf{} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} \\
        \midrule
        \midrule
        MLP & 4 & 105263 & 50.5190.000 & 50.4870.014 & 42.25 & 8.95s/0.11hr & 106015 & 20.9730.004 & 20.9380.002 & 42.25 & 5.83s/0.07hr\\
        \midrule
        GCN & 4 & 100923 & 63.8800.074 & 65.1260.135 & 105.00 & 118.85s/3.51hr & 101655 & 53.4452.029 & 54.0412.197 & 70.00 & 65.72s/1.30hr\\
        & 16 & 500823 & 71.8920.334 & 78.4091.592 & 81.50 & 492.19s/11.31hr & 501687 & 68.4980.976 & 71.7292.212 & 79.75 & 270.28s/6.08hr\\
        GraphSage & 4 & 101739 & 50.5160.001 & 50.4730.014 & 43.75 & 93.41s/1.17hr & 102187 & 50.4540.145 & 54.3740.203 & 64.00 & 53.56s/0.97hr\\
        & 16 & 502842 & 50.4920.001 & 50.4870.005 & 46.50 & 391.19s/5.19hr & 503350 & 63.8440.110 & 86.7100.167 & 57.75 & 225.61s/3.70hr\\
        \midrule
MoNet & 4 & 103775 & \good{85.4820.037} & 85.5690.044 & 89.75 & 35.71s/0.90hr & 104227 & 58.0640.131 & 58.4540.183 & 76.25 & 24.29s/0.52hr\\
& 16 & 511487 & \good{85.5820.038} & 85.7200.068 & 81.75 & 68.49s/1.58hr & 511999 & 66.4070.540 & 67.7270.649 & 77.75 & 47.82s/1.05hr\\
        GAT & 4 & 109936 & 75.8241.823 & 77.8831.632 & 96.00 & 20.92s/0.57hr & 110700 & 57.7320.323 & 58.3310.342 & 67.25 & 14.17s/0.27hr\\
        & 16 & 526990 & 78.2710.186 & 90.2120.476 & 53.50 & 50.33s/0.77hr & 527874 & \good{70.5870.447} & 76.0741.362 & 73.50 & 35.94s/0.75hr\\
        GatedGCN & 4 & 104003 & 84.4800.122 & 84.4740.155 & 78.75 & 139.01s/3.09hr & 104355 & 60.4040.419 & 61.6180.536 & 94.50 & 79.97s/2.13hr\\
        & 16 & 502223 & \good{85.5680.088} & 86.0070.123 & 65.25 & 644.71s/11.91hr & 502615 & \good{73.8400.326} & 87.8800.908 & 60.00 & 400.07s/6.81hr\\
        GatedGCN-PE & 16 & 502457 & \best{86.5080.085} & 86.8010.133 & 65.75 & 647.94s/12.08hr & 504253 & \best{76.0820.196} & 88.9190.720 & 57.75 & 399.66s/6.58hr \\
        \midrule
        GIN & 4 & 100884 & \good{85.5900.011} & 85.8520.030 & 93.00 & 15.24s/0.40hr & 103544 & 58.3840.236 & 59.4800.337 & 74.75 & 10.71s/0.23hr\\
        & 16 & 508574 & 85.3870.136 & 85.6640.116 & 86.75 & 25.14s/0.62hr & 517570 & 64.7161.553 & 65.9731.816 & 80.75 & 20.67s/0.47hr\\
        RingGNN & 2 & 105206 & \good{86.2450.013} & 86.1180.034 & 75.00 & 573.37s/12.17hr & 104746 & 42.41820.063 & 42.52020.212 & 74.50 & 428.24s/8.79hr\\
        & 2 & 504766 & \good{86.2440.025} & 86.1050.021 & 72.00 & 595.97s/12.15hr & 524202 & 22.3400.000 & 22.3040.000 & 43.25 & 501.84s/6.22hr\\
        & 8 & 505749 & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & 514380 & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged}\\
        3WLGNN & 3 & 103572 & \good{85.6610.353} & 85.6080.337 & 95.00 & 304.79s/7.88hr & 105552 & 57.1306.539 & 57.4046.597 & 116.00 & 219.51s/6.52hr\\
        & 3 & 502872 & \good{85.3410.207} & 85.2700.198 & 81.75 & 424.23s/9.56hr & 507252 & 55.4897.863 & 55.7368.024 & 66.00 & 319.98s/5.79hr \\
        & 8 & 581716 & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & 586788 & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged} & \textrm{Diverged}\\
        \midrule
        \midrule
        & & \multicolumn{10}{c}{\textbf{GRAPH CLASSIFICATION}} \\
        & & \multicolumn{5}{c}{\textbf{MNIST}} & \multicolumn{5}{c}{\textbf{CIFAR10}}\\
        \textbf{Model} & \textbf{} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} \\
        \midrule
        \midrule
        MLP & 4 & 104044 & 95.3400.138 & 97.4320.470 & 232.25 & 22.74s/1.48hr & 104380 & 56.3400.181 & 65.1131.685 & 185.25 & 29.48s/1.53hr\\
        \midrule
        GCN & 4 & 101365 & 90.7050.218 & 97.1960.223 & 127.50 & 83.41s/2.99hr & 101657 & 55.7100.381 & 69.5231.948 & 142.50 & 109.70s/4.39hr\\
        GraphSage & 4 & 104337 & \best{97.3120.097} & 100.0000.000 & 98.25 & 113.12s/3.13hr & 104517 & \good{65.7670.308} & 99.7190.062 & 93.50 & 124.61s/3.29hr\\
        \midrule
MoNet & 4 & 104049 & 90.8050.032 & 96.6090.440 & 146.25 & 93.19s/3.82hr & 104229 & 54.6550.518 & 65.9112.515 & 141.50 & 97.13s/3.85hr\\
        GAT & 4 & 110400 & 95.5350.205 & 99.9940.008 & 104.75 & 42.26s/1.25hr & 110704 & 64.2230.455 & 89.1140.499 & 103.75 & 55.27s/1.62hr\\
        GatedGCN & 4 & 104217 & \best{97.3400.143} & 100.0000.000 & 96.25 & 128.79s/3.50hr & 104357 & \best{67.3120.311} & 94.5531.018 & 97.00 & 154.15s/4.22hr\\
\midrule
        GIN & 4 & 105434 & \good{96.4850.252} & 100.0000.000 & 128.00 & 39.22s/1.41hr & 105654 & 55.2551.527 & 79.4129.700 & 141.50 & 52.12s/2.07hr\\
        RingGNN & 2 & 105398 & 11.3500.000 & 11.2350.000 & 14.00 & 2945.69s/12.77hr & 105165 & 19.30016.108 & 19.55616.397 & 13.50 & 3112.96s/13.00hr\\
        & 2 & 505182 & 91.8600.449 & 92.1690.505 & 16.25 & 2575.99s/12.63hr & 504949 & 39.16517.114 & 40.20917.790 & 13.75 & 2998.24s/12.60hr \\
        & 8 & 506357 & Diverged & Diverged & Diverged & Diverged & 510439 & Diverged & Diverged & Diverged & Diverged\\
        3WLGNN & 3 & 108024 & 95.0750.961 & 95.8301.338 & 27.75 & 1523.20s/12.40hr & 108516 & 59.1751.593 & 63.7512.697 & 28.50 & 1506.29s/12.60hr \\
        & 3 & 501690 & 95.0020.419 & 95.6920.677 & 26.25 & 1608.73s/12.42hr & 502770 & 58.0432.512 & 61.5743.575 & 20.00 & 2091.22s/12.55hr\\
        & 8 & 500816 & Diverged & Diverged & Diverged & Diverged & 501584 & Diverged & Diverged & Diverged & Diverged \\
        \midrule
        \midrule
        & & \multicolumn{10}{c}{\textbf{LINK PREDICTION}} \\
        & & \multicolumn{5}{c}{\textbf{TSP}} & \multicolumn{5}{c}{\textbf{COLLAB}}\\
        \multirow{2}{*}{\textbf{Model}} & \multirow{2}{*}{\textbf{}} & \multirow{2}{*}{\textbf{\#Param}} & \multirow{2}{*}{\textbf{Test F1s.d.}} & \multirow{2}{*}{\textbf{Train F1s.d.}} & \multirow{2}{*}{\textbf{\#Epoch}} & \multirow{2}{*}{\textbf{Epoch/Total}} & \textbf{\#Param} & \multirow{2}{*}{\textbf{Test Hitss.d.}} & \multirow{2}{*}{\textbf{Train Hitss.d.}} & \multirow{2}{*}{\textbf{\#Epoch}} & \multirow{2}{*}{\textbf{Epoch/Total}} \\
         & & & & & & &  & & & & \\
        \midrule
        \midrule
        MLP & 4 & 96956 & 0.5440.001 & 0.5440.001 & 164.25 & 50.15s/2.31hr & 39441 & 20.3502.168 & 29.8073.360 & 147.50 & 2.09s/0.09hr \\
        \midrule
        GCN & 4 & 95702 & 0.6300.001 & 0.6310.001 & 261.00 & 152.89s/11.15hr & 40479 & 50.4221.131 & 92.1120.991 & 122.50 & 351.05s/12.04hr \\
        GraphSage & 4 & 99263 & 0.6650.003 & 0.6690.003 & 266.00 & 157.26s/11.68hr & 39856 & \good{51.6180.690} & 99.9490.052 & 152.75 & 277.93s/11.87hr \\
        \midrule
MoNet & 4 & 99007 & 0.6410.002 & 0.6430.002 & 282.00 & 84.46s/6.65hr & 39751 & 36.1442.191 & 61.1563.973 & 167.50 & 26.69s/1.26hr \\
        GAT & 4 & 96182 & 0.6710.002 & 0.6730.002 & 328.25 & 68.23s/6.25hr & 42637 & \good{51.5010.962} & 97.8511.114 & 157.00 & 18.12s/0.80hr \\
        GatedGCN & 4 & 97858 & \good{0.7910.003} & 0.7930.003 & 159.00 & 218.20s/9.72hr & 40965 & \good{52.6351.168} & 96.1031.876 & 95.00 & 453.47s/12.09hr \\
        GatedGCN-PE & & \multicolumn{5}{c|}{-} & 41889 & \best{52.8491.345} & 96.1650.453 & 94.75 & 452.75s/12.08hr \\
        GatedGCN-E & 4 & 97858 & \good{0.8080.003} & 0.8110.003 & 197.00 & 218.51s/12.04hr & 40965 & 49.2121.560 & 88.7471.058 & 95.00 & 451.21s/12.03hr \\
        GatedGCN-E & 16 & 500770 & \best{0.8380.002} & 0.8500.001 & 53.00 & 807.23s/12.17hr & \multicolumn{5}{c}{-} \\
        \midrule
        GIN & 4 & 99002 & 0.6560.003 & 0.6600.003 & 273.50 & 72.73s/5.56hr & 39544 & 41.7302.284 & 70.5554.444 & 140.25 & 8.66s/0.34hr \\
        RingGNN & 2 & 106862 & 0.6430.024 & 0.6440.024 & 2.00 & 17850.52s/17.19hr & - & OOM & \multicolumn{3}{c}{ 
        \multirow{6}{2in}{RingGNN and 3WLGNN rely on dense tensors which leads to \textbf{OOM} on both GPU and CPU memory. 
        }} \\
        & 2 & 507938 & 0.7040.003 & 0.7050.003 & 3.00 & 12835.53s/16.08hr & - & OOM & \\
        & 8 & 506564 & Diverged & Diverged & Diverged & Diverged & - & OOM & \\
        3WLGNN & 3 & 106366 & 0.6940.073 & 0.6950.073 & 2.00 & 17468.81s/16.59hr & - & OOM & \\
        & 3 & 506681 & 0.2880.311 & 0.2900.312 & 2.00 & 17190.17s/16.51hr & - & OOM &\\
& 8 & 508832 & OOM & OOM & OOM & OOM & - & OOM & \\
        \midrule
        -NN Heuristic & & 2 & \multicolumn{4}{l|}{Test F1: 0.693} \\
        Matrix Fact. & 0 & \multicolumn{5}{c|}{-} & 60546561 & 44.2060.452 & 100.0000.000 & 254.33 & 2.66s/0.21hr \\
        \midrule
        \midrule
        & & \multicolumn{5}{c|}{\textbf{GRAPH REGRESSION -- ZINC}} &
        \multicolumn{5}{c}{
        \multirow{26}{4.2in}{
        \textbf{Evaluation Metrics:} (higher is better, except for ZINC)\\
        \vspace{-0.1cm}
        \begin{itemize}[leftmargin=*]
            \item CLUSTER, PATTERN use weighted accuracy w.r.t. the class sizes. \vspace{-0.05cm}
            \item MNIST, CIFAR10 use multi-label classification accuracy. \vspace{-0.05cm}
            \item TSP uses binary F1 score for the positive edges. \vspace{-0.05cm}
            \item COLLAB uses Hits@50 via the evaluator provided by OGB~\cite{hu2020ogb}. \vspace{-0.05cm}
            \item ZINC uses mean absolute regression error.\end{itemize}
        \vspace{0.05cm}
        \textbf{Notation:}\\
        \vspace{-0.1cm}
        \begin{itemize}[leftmargin=*]
            \item Models with the suffix \textbf{-E} use input edge features to initialize edge representations (ZINC: bond type, TSP: Euclidean distance, COLLAB: collaboration frequency and year).\vspace{-0.05cm}
            \item Models with the suffix \textbf{-PE} use Laplacian Eigenvectors as node positional encodings, with dimension 8 for ZINC, 2 for PATTERN and 20 for others.\vspace{-0.05cm}
            \item Results denoted by \textbf{Diverged} indicate unstable and divergent runs across all 4 seeds and initial learning rate values .\vspace{-0.05cm}
            \item Results denoted by \textbf{OOM} indicate runs which throw out of memory errors on our hardware configuration.\vspace{-0.05cm}
        \end{itemize}
        \vspace{0.05cm}
        \textbf{Extended training:}\\
        \vspace{-0.1cm}
        \begin{itemize}[leftmargin=*]
            \item For TSP, RingGNN/3WLGNN with 100K parameters achieved 0.7330.020 and 0.6490.051 respectively after 48hr of training.
        \end{itemize}
        } } \\
        \textbf{Model} & \textbf{} & \textbf{\#Param} & \textbf{Test MAEs.d.} & \textbf{Train MAEs.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} & \\
        \cline{1-7}
        \cline{1-7}
        MLP & 4 & 108975 & 0.7060.006 & 0.6440.005 & 116.75 & 1.01s/0.03hr \\
\cline{1-7}
        GCN & 4 & 103077 & 0.4590.006 & 0.3430.011 & 196.25 & 2.89s/0.16hr & \\
         & 16 & 505079 & 0.3670.011 & 0.1280.019 & 197.00 & 12.78s/0.71hr & \\
        GraphSage & 4 & 94977 & 0.4680.003 & 0.2510.004 & 147.25 & 3.74s/0.15hr & \\
         & 16 & 505341 & 0.3980.002 & 0.0810.009 & 145.50 & 16.61s/0.68hr & \\
\cline{1-7}
MoNet & 4 & 106002 & 0.3970.010 & 0.3180.016 & 188.25 & 1.97s/0.10hr \\
        & 16 & 504013 & 0.2920.006 & 0.0930.014 & 171.75 & 10.82s/0.52hr\\
        GAT & 4 & 102385 & 0.4750.007 & 0.3170.006 & 137.50 & 2.93s/0.11hr & \\
         & 16 & 531345 & 0.3840.007 & 0.0670.004 & 144.00 & 12.98s/0.53hr & \\
        GatedGCN & 4 & 105735 & 0.4350.011 & 0.2870.014 & 173.50 & 5.76s/0.28hr & \\
        GatedGCN-E & 4 & 105875 & 0.3750.003 & 0.2360.007 & 194.75 & 5.37s/0.29hr & \\
         & 16 & 504309 & \good{0.2820.015} & 0.0740.016 & 166.75 & 20.50s/0.96hr & \\
        GatedGCN-E-PE & 16 & 505011 & \best{0.2140.013} & 0.0670.019 & 185.00 & 10.70s/0.56hr \\
\cline{1-7}
        GIN & 4 & 103079 & 0.3870.015 & 0.3190.015 & 153.25 & 2.29s/0.10hr \\
         & 16 & 509549 & 0.5260.051 & 0.4440.039 & 147.00 & 10.22s/0.42hr \\
        RingGNN & 2 & 97978 & 0.5120.023 & 0.3830.020 & 90.25 & 327.65s/8.32hr  \\
        RingGNN-E & 2 & 104403 & 0.3630.026 & 0.2430.025 & 95.00 & 366.29s/9.76hr \\
         & 2 & 527283 & 0.3530.019 & 0.2360.019 & 79.75 & 293.94s/6.63hr \\
          & 8 & 510305 & Diverged & Diverged & Diverged & Diverged \\
        3WLGNN & 3 & 102150 & 0.4070.028 & 0.2720.037 & 111.25 & 286.23s/8.88hr  \\
        3WLGNN-E & 3 & 103098 & \good{0.2560.054} & 0.1400.044 & 117.25 & 334.69s/10.90hr \\
         & 3 & 507603 & 0.3030.068 & 0.1730.041 & 120.25 & 329.49s/11.08hr \\
         & 8 & 582824 & 0.3030.057 & 0.2460.043 & 52.50 & 811.27s/12.15hr \\
        \bottomrule
    \end{tabular}
    }
    \label{tab:results}
\end{table}
 

This section highlights the main take-home messages from the experiments in Tables~\ref{tab:results}, \ref{tab:csl} and \ref{tab:edge-analysis}, which evaluate the GNNs from Section \ref{sec:gnns} with the experimental setup described in Section \ref{sec:expsetup}. 








{\bf Graph-agnostic NNs perform poorly.} As a sanity check, we compare all GNNs to a simple graph-agnostic MLP baseline which updates each node independent of one-other, , and passes 
these features to the task-based layer. MLP presents consistently low scores across all datasets (Tables \ref{tab:results} and \ref{tab:csl}), 
which shows the necessity to use graph structure for these tasks. All proposed datasets used in our study are appropriate to statistically separate GNN performance, which has remained an issue with the widely used but small graph datasets \cite{errica2019fair,luzhnica2019graph}.








{\bf GCNs outperform WL-GNNs on the proposed datasets.} 
Although provably powerful in terms of graph isomorphism tests and invariant function approximation \cite{maron2019universality,chen2019equivalence,morris2019weisfeiler}, the recent 3WLGNNs and RingGNNs were not able to outperform GCNs for our medium-scale datasets, as shown in Table \ref{tab:results}. These new models are limited in terms of space/time complexities, with  respectively, not allowing them to scale to larger datasets. On the contrary, GCNs with linear complexity \textit{w.r.t.} the number of nodes for sparse graphs, can scale conveniently to 16 layers and show the best performance on all datasets. 
3WL-GNNs and RingGNNs face loss divergence and/or out-of-memory errors when trying to build deeper networks, see Table \ref{tab:results}.







{\bf Anisotropic mechanisms improve GCNs.} Among the models in the GCN class, the best results point towards the anisotropic models, particularly GAT and GatedGCN, which are based on sparse and dense attention mechanisms, respectively. 
For instance, results for ZINC, PATTERN, CLUSTER, MNIST and CIFAR in Table \ref{tab:results}
show that the performance of the 100K-parameter anisotropic GNNs (GAT, MoNet, GatedGCN) are consistently better than the isotropic models (GCN, GraphSage), except for GraphSage-MNIST and MoNet-CIFAR10.
Table \ref{tab:edge-analysis}, discussed later, dissects and demonstrates the importance of anisotropy for the link prediction tasks, TSP and COLLAB. 
Overall, our results suggest that understanding the expressive power of attention-based neighborhood aggregation functions is a meaningful avenue of research. 









{\bf Underlying challenges for training WL-GNNs.} 
We consistently observe a relatively high standard deviation in the performance of WL-GNNs (recall that we average across 4 runs using 4 different seeds). 
We attribute this fluctuation to the absence of universal training procedures like batching and batch normalization, as these GNNs operate on {\it dense} rank-2 tensors of variable sizes. 
On the other hand, GCNs running on {\it sparse} tensors better leverage batched training and normalization for stable and fast training.
Leading graph machine learning libraries represent batches of graphs as sparse block diagonal matrices, enabling batched training of GCNs through parallelized computation~\cite{jia2019redundancy}.

\vspace{-0.1cm}
Dense tensors are incompatible with the prevalent approach, disabling the use of batch normalization for WL-GNNs.
We experimented with layer normalization~\cite{ba2016layer} but without success.
We were also unable to train WL-GNNs on CPU memory for the single COLLAB graph.
Practical applications of the new WL-GNNs may require redesigning the best practices and common building blocks of deep learning, \textit{i.e.} batching of variable-sized data, normalization schemes, and residual connections.




{\bf 3WL-GNNs perform the best among their class.} Among the models in the WL-GNN class, 3WL-GNN provide better results than its similar counter-part RingGNN. The GIN model, while being less expressive, is able to scale better and provides overall good performance.


















































{\bf Laplacian eigenvectors as positional embeddings.} {\it Background.} In \cite{murphy2019relational,srinivasan2019equivalence}, it was pointed out that standard GCNs might perform poorly when dealing with graphs that exhibit some symmetries in their structures, such as node or edge isomorphism. To address this issue, authors in \cite{murphy2019relational} introduced a framework, called Graph Relational Pooling (GRP), that assigns to each node an identifier that depends on the index ordering. This approach can be computationally expensive as it requires to account for all  node permutations, thus requiring some sampling in practice. 



\vspace{-0.1cm}
{\it Proposition.} As in \cite{murphy2019relational}, we keep the overall GCN architecture and simply add positional features to each node before processing the graph through the GCN. The positional features should be chosen such that nodes which are far apart in the graph have different positional features whereas nodes which are nearby have similar positional features. In \cite{murphy2019relational}, authors used one-hot encoding of node indices. As an alternative, we propose to use the graph Laplacian eigenvectors \cite{belkin2003laplacian}, which have less ambiguities and which better describe the distance between nodes on the graph. Formally, Laplacian eigenvectors are spectral techniques that embed the graphs into the Euclidean space. These vectors form a meaningful local coordinate system, while preserving the global graph structure. Mathematically, they are defined via the factorization of the graph Laplacian matrix;
\vspace{-0.1cm}

where  is the   adjacency matrix,  is the degree matrix, and ,  correspond respectively to the eigenvalues and eigenvectors. Laplacian eigenvectors also represent a natural generalization of the Transformer \cite{vaswani2017attention} positional encodings (PE) for graphs as the eigenvectors of a discrete line (NLP graph) are the cosine and sinusoidal functions. The computational complexity , with  being the number of edges, can be improved with, \textit{e.g.} the Nystrom method \cite{fowlkes2004spectral}. The eigenvectors are defined up to the factor  (after being normalized to unit length), so the sign of eigenvectors will be randomly flipped during training. For the experiments, we use the  smallest non-trivial eigenvectors, where the  value is given in Table \ref{tab:results}. The smallest eigenvectors provide smooth encoding coordinates of neighboring nodes. See Section \ref{sec_PE} in the supplementary for a discussion about positional encodings.




\vspace{-0.1cm}
{\it Analysis.} First, we study the usefulness of these PE with CSL, a mathematical dataset introduced in \cite{murphy2019relational} to demonstrate the failure of GCNs to provide meaningful node representations for highly automorphic graphs. Table \ref{tab:csl} compares the GCNs using the Laplacian eigenvectors as PE and the WL-GNNs. The GCN models were the most accurate with 99\% of mean accuracy, while 3WL-GNN obtained 97\% and RingGNN 25\% with our experimental setting. Then, we study ZINC, PATTERN, CLUSTER and COLLAB with PE (note that MNIST, CIFAR10 and TSP do not need PE as the nodes in these graphs already have features describing their positions in ). We observe a boost of performance for ZINC and CLUSTER (it was expected as eigenvectors are good indicators of clusters \cite{von2007tutorial}), an improvement for PATTERN, and statistically the same result for COLLAB, see Table \ref{tab:results}. As a future work, we plan to compare with the recent technique \cite{you2019position} which uses GNNs to learn simultaneously node structural and positional encodings.



\begin{table}[t]
    \centering
    \caption{Results for the CSL dataset, with and without Laplacian Positional Encodings.
    Results are from 5-fold cross validation, run 20 times with different seeds. 
    \best{Red}: the best model, \good{Violet}: good models.}
    \vspace{3pt}
    \scalebox{0.6}{
    \begin{tabular}{rcc|ccc|ccc|cc}
        \toprule
        \multirow{2}{*}{\textbf{Model}} & \multirow{2}{*}{\textbf{}} & \multirow{2}{*}{\textbf{\#Param}} & \multicolumn{3}{c|}{\textbf{Test Accuracy}} & \multicolumn{3}{c|}{\textbf{Train Accuracy}} & \multirow{2}{*}{\textbf{\#Epoch}} & \textbf{Epoch/}  \\
        \cline{4-9}
        & & & \textbf{Means.d.} & \textbf{Max} & \textbf{Min} & \textbf{Means.d.} & \textbf{Max} & \textbf{Min} & & \textbf{Total} \\ 
        \midrule
        \midrule
        & & \multicolumn{9}{c}{\textbf{Node Positional Encoding with Laplacian Eigenmaps }} \\
        \midrule
        MLP & 4 & 101235 & 22.5676.089 & 46.667 & 10.000 & 30.3895.712 & 43.333 & 10.000 & 109.39 & 0.16s/0.03hr \\
        \midrule
        GCN & 4 & 103847 & \best{100.0000.000} & 100.000 & 100.000 & 100.0000.000 & 100.000 & 100.000 & 125.64 & 0.40s/0.07hr \\
        GraphSage & 4 & 105867 & \good{99.9330.467} & 100.000 & 96.667 & 100.0000.000 & 100.000 & 100.000 & 155.00 & 0.50s/0.11hr \\
        \midrule
MoNet & 4 & 105579 & \good{99.9670.332} & 100.000 & 96.667 & 100.0000.000 & 100.000 & 100.000 & 130.39 & 0.49s/0.09hr\\
        GAT & 4 & 101710 & \good{99.9330.467} & 100.000 & 96.667 & 100.0000.000 & 100.000 & 100.000 & 133.18 & 0.61s/0.12hr  \\
        GatedGCN & 4 & 105407 & \good{99.6001.083} & 100.000 & 96.667 & 100.0000.000 & 100.000 & 100.000 & 147.06 & 0.66s/0.14hr \\
        \midrule
        GIN & 4 & 107304 & \good{99.3331.333} & 100.000 & 96.667 & 100.0000.000 & 100.000 & 100.000 & 62.98 & 0.44s/0.04hr  \\
        RingGNN & 2 & 102726 & 17.2336.326 & 40.000 & 10.000 & 26.12214.382 & 58.889 & 10.000 & 122.75 & 2.93s/0.50hr \\
        & 2 & 505086 & 25.1677.399 & 46.667 & 10.000 & 54.53318.415 & 82.222 & 10.000 & 120.58 & 3.11s/0.51hr \\
        3WLGNN & 3 & 102054 & 30.5339.863 & 56.667 & 10.000 & 99.6441.684 & 100.000 & 88.889 & 74.66 & 2.33s/0.25hr   \\
        & 3 & 505347 & 30.5008.197 & 56.667 & 13.333 & 100.0000.000 & 100.000 & 100.000 & 66.64 & 2.38s/0.23hr \\
        \midrule
        & & \multicolumn{9}{c}{\textbf{No Node Positional Encoding}} \\
        \midrule
        MP-GNNs & 4 & 100K & 10.0000.000 & 10.000 & 10.000 & 10.0000.000 & 10.000 & 10.000 & - & - \\
        RingGNN & 2 & 101138 & 10.0000.000 & 10.000 & 10.000 & 10.0000.000 & 10.000 & 10.000 & 103.23 & 3.09s/0.45hr \\
        & 2 & 505325 & 10.0000.000 & 10.000 & 10.000 & 10.0000.000 & 10.000 & 10.000 & 90.04 & 3.28s/0.42hr \\
        3WLGNN & 3 & 102510 & 95.70014.850 & 100.000 & 30.000 & 95.70014.850 & 100.000 & 30.000 & 475.81 & 2.29s/1.51hr  \\
        & 3 & 506106 & 97.80010.916 & 100.000 & 30.000 & 97.80010.916 & 100.000 & 30.000 & 283.80 & 2.28s/0.90hr \\
        \bottomrule
    \end{tabular}
    }
    \label{tab:csl}
\end{table}


















\begin{table}[t]
    \centering
    \caption{Study of anisotropy and edge representations for link prediction on TSP and COLLAB. \best{Red}: the best model, \good{Violet}: good models.
    }
    \vspace{3pt}
    \scalebox{0.60}{
    \begin{tabular}{c|rcccccccc}
        \toprule
        \multicolumn{1}{c}{} & \textbf{Model} & \textbf{E.Feat.} & \textbf{E.Repr.} & \textbf{} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epochs} & \textbf{Epoch/Total} \\
        \midrule
        \midrule
        \parbox[t]{2mm}{\multirow{8}{*}{\rotatebox[origin=c]{90}{TSP}}} & \multirow{3}{*}{GatedGCN} & \crossmark & \crossmark & 4 & 99026 & 0.6460.002 & 0.6480.002 & 197.50 & 150.83s/8.34hr \\
         & & \checkmark & \crossmark & 4 & 98174 & 0.7570.009 & 0.7600.009 & 218.25 & 197.80s/12.06hr \\
         & & \checkmark & \checkmark & 4 & 97858 & \good{0.7910.003} & 0.7930.003 & 159.00 & 218.20s/9.72hr \\
        \cline{2-10}
         & GatedGCN-E & \checkmark & \checkmark & 4 & 97858 & \best{0.8080.003} & 0.8110.003 & 197.00 & 218.51s/12.04hr \\
        \cline{2-10}
         & \multirow{3}{*}{GAT} & \crossmark & \crossmark & 4 & 95462 & 0.6430.001 & 0.6440.001 & 132.75 & 325.22s/12.10hr \\
         & & \checkmark & \crossmark & 4 & 96182 & 0.6710.002 & 0.6730.002 & 328.25 & 68.23s/6.25hr \\
         & & \checkmark & \checkmark & 4 & 96762 & 0.7480.022 & 0.7490.022 & 93.00 & 462.22s/12.10hr \\
        \cline{2-10}
         & GAT-E & \checkmark & \checkmark & 4 & 96762 & \good{0.7820.006} & 0.7830.006 & 98.00 & 438.37s/12.11hr \\
        \midrule
        \parbox[t]{2mm}{\multirow{8}{*}{\rotatebox[origin=c]{90}{COLLAB}}} & \multirow{3}{*}{GatedGCN} & \crossmark & \crossmark & 3 & 26593 & 35.9891.549 & 60.5864.251 & 148.00 & 263.62s/10.90h \\
         & & \checkmark & \crossmark & 3 & 26715 & \good{50.6680.291} & 96.1280.576 & 172.00 & 384.39s/18.44hr \\
         & & \checkmark & \checkmark & 3 & 27055 & \best{51.5371.038} & 96.5241.704 & 188.67 & 376.67s/19.85hr \\
        \cline{2-10}
         & GatedGCN-E & \checkmark & \checkmark & 3 & 27055 & 47.2122.016 & 85.8010.984 & 156.67 & 377.04s/16.49hr \\
        \cline{2-10}
         & \multirow{3}{*}{GAT} & \crossmark & \crossmark & 3 & 28201 & 41.1410.701 & 70.3441.837 & 153.50 & 371.50s/15.97hr \\
         & & \checkmark & \crossmark & 3 & 28561 & \good{50.6620.687} & 96.0850.499 & 174.50 & 403.52s/19.69hr \\
         & & \checkmark & \checkmark & 3 & 26676 & \good{49.6740.105} & 92.6650.719 & 201.00 & 349.19s/19.59hr \\
        \cline{2-10}
         & GAT-E & \checkmark & \checkmark & 3 & 26676 & 44.9891.395 & 82.2304.941 & 120.67 & 328.29s/11.10hr \\
        \bottomrule
    \end{tabular}
    }
    \label{tab:edge-analysis}
\end{table}







{\bf Edge representations improve link prediction. } {\it Context.} 
The TSP and COLLAB edge classification tasks present an interesting empirical result for GCNs: Isotropic models (GCN, GraphSage) are consistently outperformed by their Anisotropic counterparts which use joint representations of adjacent nodes as edge features during aggregation (GAT, GatedGCN). In Table~\ref{tab:edge-analysis}, we systematically study the impact of anisotropy by instantiating three variants of GAT and GatedGCN:\\
(1) Isotropic aggregation (such as vanilla GCNs \cite{kipf2017semi}) with node updates of the form:
\vspace{-0.1cm}

(2) Anisotropy using edge features (such as GAT by default \cite{velickovic2018graph}) with node updates as:
\vspace{-0.1cm}

and (3) Anisotropy with edge features and explicit edge representations updated at each layer with node/edge updates as (such as in GatedGCN by default \cite{bresson2017residual}):
\vspace{-0.1cm}

GatedGCN-E and GAT-E in Table \ref{tab:edge-analysis} are models using input edge features from the datasets to initialize the edge representations . Detailed equations are available in supplementary material. 
As maintaining edge representations comes with a time and memory cost for the large COLLAB graph, all models use a reduced budget of 27K parameters to fit the GPU memory, and are allowed to train for a maximum of 24 hours for convergence. 

\vspace{-0.1cm}
{\it Analysis.} On both TSP and COLLAB, upgrading isotropic models with edge features significantly boosts performance given the same model parameters (\textit{e.g.} 0.75 vs. 0.64 F1 score on TSP,  50.6\% vs. 35.9\% Hits@50 on COLLAB for GatedGCN with edge features vs. the isotropic variant). 
Maintaining explicit edge representations across layers further improves F1 score for TSP, especially when initializing the edge representations with euclidean distances between nodes (\textit{e.g.} 0.78 vs. 0.67 F1 score for GAT-E vs. standard GAT).
On COLLAB, adding explicit edge representations and inputs degrades performance, suggesting that the features (collaboration frequency and year) are not useful for the link prediction task (\textit{e.g.} 47.2 vs. 51.5 Hits@50 for GatedGCN-E vs. GatedGCN).
As suggested by \cite{hu2020ogb}, it would be interesting to treat COLLAB as a multi-graph with temporal edges, motivating the development of task-specific anisotropic edge representations beyond generic attention and gating mechanisms.



































\section{Conclusion}
We introduce a new benchmarking framework to rigorously evaluate the performance of graph neural networks on medium-scale datasets, and demonstrate its usefulness for analyzing message-passing based and theoretically expressive GNNs.
As we make our code open-source, easy to use and reproducible, we hope the community will find this project useful to prototype the latest GNN architectures and track progress in graph representation learning.


































\section*{Broader Impact}











This paper proposes a reproducible benchmarking infrastructure that can fairly and rigorously evaluate graph neural network (GNN) architectures, and track progress in graph representation learning.
Our framework is likely to drive the development of general-purpose and theoretically driven GNN models which may be deployed in a variety of downstream applications. We briefly discuss positive use cases and possible negative outcomes in this section.










\textbf{Better GNN architectures. }
Graphs are met in a wide range of data-driven problems, and GNNs can be used to tackle them:
Social media and e-commerce platforms are using GNNs to improve content recommendation and advertising~\cite{ying2018graph,zhu2019aligraph}. 
GNNs are also driving improvements in content quality and inclusivity of these platforms, \textit{e.g.} monitoring hate speech or fake news spread~\cite{monti2019fake}. 
Similarly, real-time optimization problems which are modelled by interaction graphs make use of GNNs as their backbone, \textit{e.g.} scheduling of processor chips and power units in hardware systems~\cite{mao2019learning,dean20201}.
GNNs are also driving advancements for complex and high-impact problems in drug discovery~\cite{raghu2020survey}, circuit design~\cite{mirhoseini2020chip}, neuroscience~\cite{griffa2017transient}, and genomics~\cite{gainza2020deciphering}.







Conversely, the same architectures which lead to positive outcomes may also be used for malicious purposes, especially in social networks and e-commerce:
Models monitoring the spread of fake news could end up helping bad actors in designing adversarial strategies for spreading counterfeit content, or for manipulating behaviour based on network effects.
Increased personalization of social media and e-commerce platforms has raised important policy questions regarding the collection, ownership and storage of highly sensitive and personal user information.










\textbf{New benchmarking frameworks. }
The act of developing new benchmarks often sets precedence and drives the directions of research in particular communities~\cite{russakovsky2015imagenet,wang2019superglue,barbu2019objectnet}.
Thus, community-driven benchmarks must progress and evolve to reflect the best practices in the community.
Benchmark creators must be wary about not letting their frameworks be anchors which weigh a field down, and be open to suggestions and contributions by the broader community.

Collecting and preparing graph datasets also comes with many challenges and arbitrary choice~\cite{hu2020ogb}.
For example, the datasets used for benchmarking may push for research in favor of specific domains and applications, or contain biases which disadvantage particular communities.
We would encourage users of our benchmark to understand the limitations of current graph machine learning datasets and consider the negative outcomes arising from data-driven systems in real-world scenarios.
Ultimately, we believe that questions surrounding personal data and digital privacy are important considerations from both technical as well as public policy standpoints\footnote{\small \texttt{https://www.montrealdeclaration-responsibleai.com/}}.




















 

\section*{Acknowledgments}
XB is supported by NRF Fellowship NRFF2017-10.


\bibliography{neurips_2020}
\bibliographystyle{plain}

\newpage
\appendix

\section{Datasets and experimental details}
We now provide additional information related to the preparation of the datasets described in Section \ref{sec:datasets} of the proposed benchmarking framework, as well as the corresponding experimental setting for training and performance metrics.








\subsection{Node Classification with SBM Datasets}
The SBM datasets consider node-level tasks of graph pattern recognition \cite{art:ScarselliGoriTsoiHagenbuchnerMonfardini09} -- PATTERN and semi-supervised graph clustering -- CLUSTER. 
The graphs are generated with the Stochastic Block Model (SBM) \cite{abbe2017community}, which is widely used to model communities in social networks by modulating the intra- and extra-communities connections, thereby controlling the difficulty of the task.
A SBM is a random graph which assigns communities to each node as follows: any two vertices are connected with the probability  if they belong to the same community, or they are connected with the probability  if they belong to different communities (the value of  acts as the noise level).



PATTERN: The graph pattern recognition task, presented in \cite{art:ScarselliGoriTsoiHagenbuchnerMonfardini09}, aims at finding a fixed graph pattern  embedded in larger graphs  of variable sizes.
For all data, we generate graphs  with 5 communities with sizes randomly selected between . 
The SBM of each community is , and the node features on  are generated with a uniform random distribution with a vocabulary of size , \textit{i.e.} . 
We randomly generate  patterns  composed of  nodes with intra-probability  and extra-probability  (\textit{i.e.}, 50\% of nodes in  are connected to ). 
The node features for  are also generated as a random signal with values . 
The graphs are of sizes - nodes. 
The output node labels have value 1 if the node belongs to  and value 0 if it is in . 

CLUSTER: For the semi-supervised clustering task, we generate 6 SBM clusters with sizes randomly selected between  and probabilities . 
The graphs are of sizes - nodes. 
Each node can take an input feature value in . If the value is 1, the node belongs to class 0, value 2 corresponds to class 1, \dots, value 6 corresponds to class 5. 
Otherwise, if the value is 0, the class of the node is unknown and will be inferred by the GNN. 
There is only one labelled node that is randomly assigned to each community and most node features are set to 0.
The output node labels are defined as the community/cluster class labels.

{\bf Splitting.} The PATTERN dataset has  train/ validation/ test graphs and CLUSTER dataset has  train/ validation/ test graphs. We save the generated splits and use the same sets in all models for fair comparison.\\
{\bf Training.} As presented in the standard experimental protocol in Section \ref{sec:expsetup}, we use Adam optimizer with a learning rate decay strategy. For all GNNs, an initial learning rate is set to , the reduce factor is , the patience value is , and the stopping learning rate is . \\
{\bf Performance Measure.} The performance measure is the average node-level accuracy weighted with respect to the class sizes.


\subsection{Graph Classification with Super-pixel Datasets}
The super-pixels datasets test graph classification using the popular MNIST and CIFAR10 image classification datasets.
Our main motivation to use these datasets is as sanity-checks: we expect most GNNs to perform close to 100\% for MNIST and well enough for CIFAR10.

The original MNIST and CIFAR10 images are converted to graphs using super-pixels. Super-pixels represent small regions of homogeneous intensity in images, and can be extracted with the SLIC technique \cite{10.1109/TPAMI.2012.120}. 
We use SLIC super-pixels from \cite{knyazev2019understanding}\footnote{\small{\url{https://github.com/bknyaz/graph_attention_pool}}}. 
For each sample, we build a -nearest neighbor adjacency matrix with
 
where  are the 2-D coordinates of super-pixels , and  is the scale parameter defined as the averaged distance  of the  nearest neighbors for each node. We use  for both MNIST and CIFAR10, whereas the maximum number of super-pixels (nodes) are 75 and 150 for MNIST and CIFAR10, respectively. The resultant graphs are of sizes - nodes for MNIST and - nodes for CIFAR10. Figure \ref{fig:superpixel_graph} presents visualizations of the super-pixel graphs. 





{\bf Splitting.} We use the standard splits of MNIST and CIFAR10. MNIST has  train/ validation/ test graphs and CIFAR10 has  train/ validation/ test graphs. The  graphs for validation set are randomly sampled from the training set and the same splits are used for every GNN.\\
{\bf Training.} The learning decay rate strategy is adopted with an initial learning rate of , reduce factor , patience value , and the stopping learning rate  for all GNNs, except for 3WLGNN and RingGNN where we experienced a difficulty in training, leading us to slightly adjust their learning rate schedule hyperparameters. For both 3WLGNN and RingGNN, the patience value is changed to . For RingGNN, the initial learning rate is changed to  and the stopping learning rate is changed to .\\
{\bf Performance Measure.} The classification accuracy between the predicted and groundtruth label for each graph is the performance measure.




\begin{figure}[t]
\begin{tabular}{c c}
\subfloat[MNIST]{\includegraphics[width = 2.6in]{./images/mnist_sp_75.PNG}} &
\subfloat[CIFAR10]{\includegraphics[width = 2.6in]{./images/cifar10_sp_150.PNG}} \\
\end{tabular}
\caption{Sample images and their superpixel graphs. The graphs of SLIC superpixels (at most 75 nodes for MNIST and 150 nodes for CIFAR10) are  8-nearest neighbor graphs in the Euclidean space and node colors denote the mean pixel intensities.  }
\label{fig:superpixel_graph}
\end{figure}

\subsection{Edge Classification/Link Prediction with TSP Dataset}
Leveraging machine learning for solving NP-hard combinatorial optimization problems (COPs) has been the focus of intense research in recent years \cite{vinyals2015pointer,bengio2018machine}.
Recently proposed learning-driven solvers for COPs \cite{khalil2017learning,li2018combinatorial,kool2018attention} combine GNNs with classical search to predict approximate solutions directly from problem instances (represented as graphs).
Consider the intensively studied Travelling Salesman Problem (TSP), which asks the following question:
\textit{“Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?" }
Formally, given a 2D Euclidean graph, one needs to find an optimal sequence of
nodes, called a tour, with minimal total edge weights (tour length).
TSP's \textit{multi-scale} nature makes it a challenging graph task which requires reasoning about both local node neighborhoods as well as global graph structure.

For our experiments with TSP, we follow the learning-based approach to COPs described in \cite{li2018combinatorial,joshi2019efficient}, where a GNN is the backbone architecture for assigning probabilities to each edge as belonging/not belonging to the predicted solution set.
The probabilities are then converted into discrete decisions through graph search techniques.
Each instance is a graph of  node locations sampled uniformly in the unit square  and .
We generate problems of varying size and complexity by uniformly sampling the number of nodes  for each instance.

In order to isolate the impact of the backbone GNN architectures from the search component, we pose TSP as a binary edge classification task,
with the groundtruth value for each edge belonging to the TSP tour given by Concorde~\cite{applegate2006concorde}.
For scaling to large instances, we use sparse  nearest neighbor graphs instead of full graphs, following \cite{khalil2017learning}.
See Figure \ref{fig:tsp} for sample TSP instances of various sizes.

\begin{figure}[!t]
	\centering
	\subfloat[TSP50]{
      \includegraphics[width=0.27\textwidth]{images/TSP/tsp50.pdf}}
    \subfloat[TSP200]{
      \includegraphics[width=0.27\textwidth]{images/TSP/tsp200.pdf}}
    \subfloat[TSP500]{
      \includegraphics[width=0.27\textwidth]{images/TSP/tsp500.pdf}}
	\caption{Sample graphs from the TSP dataset. Nodes are colored blue and edges on the groundtruth TSP tours are colored red.
	}
	\label{fig:tsp}
\end{figure}

{\bf Splitting.} TSP has  train,  validation and  test graphs.\\
{\bf Training.} All GNNs use a consistent learning rate strategy: an initial learning rate is set to , the reduce factor is , the patience value is , and the stopping learning rate is .\\
{\bf Performance Measure.} Given the high class imbalance, \textit{i.e.}, only the edges in the TSP tour have positive label, we use the F1 score for the positive class as our performance measure. \\
{\bf Non-learnt Baseline.} In addition to reporting performance of GNNs, we compare with a simple -nearest neighbor heuristic baseline, defined as follows: Predict true for the edges corresponding to the k nearest neighbors of each node, and false for all other edges. 
We set  = 2 for optimal performance. 
Comparing GNNs to the non-learnt baseline tells us whether models learn something more sophisticated than identifying a node’s nearest neighbors.





\subsection{Link Prediction with COLLAB dataset}
COLLAB is a link prediction dataset proposed by OGB~\cite{hu2020ogb} corresponding to a collaboration network between approximately 235K scientists, indexed by Microsoft Academic Graph~\cite{wang2020microsoft}. 
Nodes represent scientists and edges denote collaborations between them.
For node features, OGB provides 128-dimensional vectors, obtained by averaging the word embeddings of a scientist's papers. 
The year and number of co-authored papers in a given year are concatenated to form edge features.
The graph can also be viewed as a dynamic multi-graph, since two nodes may have multiple temporal edges between if they collaborate over multiple years.

Through the introduction of the COLLAB dataset, we additionally want to demonstrate that our benchmarking infrastructure is complementary to the OGB initiative, and is well-suited to integrate current and future OGB dataset and evaluation protocols.

{\bf Splitting.} 
We use the realistic training, validation and test edge splits provided by OGB. 
Specifically, they use collaborations until 2017 as training edges, those in 2018 as validation edges, and those in 2019 as test edges. \\
{\bf Training.} All GNNs use a consistent learning rate strategy: an initial learning rate is set to , the reduce factor is , the patience value is , and the stopping learning rate is . \\
{\bf Performance Measure.} 
We use the evaluator provided by OGB, which aims to measure a model's ability to predict future collaboration relationships given past collaborations. 
Specifically, they rank each true collaboration among a set of 100,000 randomly-sampled negative collaborations, and count the ratio of positive edges that are ranked at K-place or above (Hits@K). 
They suggested using K = 10 through their preliminary experiments, but we found K = 50 to better for statistically separating the performance of GNNs. \\
{\bf Matrix Factorization Baseline.}
In addition to GNNs, we report performance for a simple matrix factorization baseline \cite{hu2020ogb}, which trains 256-dimensional embeddings for each of the 235K nodes.
Comparing GNNs to matrix factorization tells us whether models leverage node features in addition to graph structure, as matrix factorization can be thought of as feature-agnostic.



\subsection{Graph Regression with ZINC dataset}
We use a subset (12K) of ZINC molecular graphs (250K) dataset \cite{irwin2012zinc} to regress a molecular property known as the constrained solubility. 
For each molecular graph, the node features are the types of heavy atoms and the edge features are the types of bonds between them.

{\bf Splitting.} ZINC has  train,  validation and  test graphs.\\
{\bf Training.} For the learning rate strategy across all GNNs, an initial learning rate is set to , the reduce factor is , and the stopping learning rate is . The patience value is  for 3WLGNN and RingGNN, and  for all other GNNs.\\
{\bf Performance Measure.} The performance measure is the mean absolute error (MAE) between the predicted and the groundtruth constrained solubility for each molecular graph.


\subsection{Graph Classification and Isomorphism Testing with CSL dataset}

The Circular Skip Link dataset is a symmetric graph dataset introduced in \cite{murphy2019relational} to test the expressivity of GNNs. Each CSL graph is a 4-regular graph with edges connected to form a cycle and containing skip-links between nodes. Formally, it is denoted by  where  is the number of nodes and  is the isomorphism class which is the skip-link of the graph. We use the same dataset  with . The dataset is class-balanced with  graphs for every  resulting in a total of  graphs.

{\bf Splitting.} We perform a 5-fold cross validation split, following \cite{murphy2019relational}, which gives 5 sets of train, validation and test data indices in the ratio . We use stratified sampling to ensure that the class distribution remains the same across splits. The indices are saved and used across all experiments for fair comparisons.\\
{\bf Training.} For the learning rate strategy across all GNNs, an initial learning rate is set to , the reduce factor is , the patience value is , and the stopping learning rate is . We train on the 5-fold cross validation with 20 different seeds of initialization, following \cite{chen2019equivalence}.
\\
{\bf Performance Measure.} We use graph classification accuracy between the predicted labels and groundtruth labels as our performance measure. The model performance is evaluated on the test split of the 5 folds at every run, and following \cite{murphy2019relational, chen2019equivalence}, we report the maximum, minimum, average and the standard deviation of the 100 scores, \textit{i.e.}, 20 runs of 5-folds.


\begin{table}[h]
  \begin{center}
    \caption{Summary statistics of all datasets. 
Numbers in parentheses of Node features and Edge features are the dimensions.
}
    \vspace{3pt}
    \label{tab:data_stats}
    \scalebox{0.78}{
    \begin{tabular}{lccrrcc}
    \toprule
    \textbf{Dataset} & \textbf{\#Graphs} & \textbf{\#Classes} & \textbf{Avg. Nodes} & \textbf{Avg. Edges} & \textbf{Node feat. (dim)} & \textbf{Edge feat. (dim)}\\
    \midrule
    \midrule
    ZINC & 12000 & -- & 23.16 & 49.83 & Atom Type (28) & Bond Type (4)\\
    PATTERN & 14000 & 2 & 117.47 & 4749.15 & Node Attr (3) & N.A.\\
    CLUSTER & 12000 & 6 & 117.20 & 4301.72 & Node Attr (7) & N.A.\\
    MNIST & 70000 & 10 & 70.57 & 564.53 & Pixel+Coord (3) & Node Dist (1)\\
    CIFAR10 & 60000 & 10 & 117.63 & 941.07 & Pixel[RGB]+Coord (5) & Node Dist (1)\\
    TSP & 12000 & 2 & 275.76 & 6894.04 & Coord (2) & Node Dist (1) \\
    COLLAB & 1 & -- & 235868.00 & 2358104.00 & Word Embs (128) & Year \& Weight (2) \\
    CSL & 150 & 10 & 41.00 & 164.00 & N.A. & N.A.\\
    \midrule
    ENZYMES & 600 & 6 & 32.63 & 62.14 & Node Attr (18) & N.A.\\
    DD & 1178 & 2 & 284.32 & 715.66 & Node Label (89) & N.A.\\
    PROTEINS & 1113 & 2 & 39.06 & 72.82 & Node Attr (29) & N.A.\\
    \bottomrule
    \end{tabular}
    }
  \end{center}
\end{table}



\section{Graph Neural Networks}


This section formally describes our experimental pipeline, illustrated in Figure \ref{fig:pipeline_mpgcns} for \textbf{GCNs} and Figure \ref{fig:pipeline_wlgnns} for \textbf{WL-GNNs}. In Section \ref{sec:mpgcns}, we describe the components of the setup of the GCN class with   vanilla GCN \cite{kipf2017semi}, GraphSage \cite{hamilton2017inductive}, MoNet \cite{Monti_2017}, GAT \cite{velickovic2018graph}, and GatedGCN \cite{bresson2017residual}, 
including the input layers, the GNN layers and the task based MLP classifier layers. We also include the description of GIN \cite{xu2018how} in this section as this model can be interpreted as a GCN, although it was designed to differentiate non-isomorphic graphs.
In Section \ref{sec:wlgnns}, we present the  GNN layers and the task based MLP classifier layers for the class of WL-GNN models with Ring-GNNs \cite{chen2019equivalence} and 3WL-GNNs \cite{maron2019provably}.


\subsection{Message-Passing GCNs}
\label{sec:mpgcns}

\subsubsection{Input Layer}

Given a graph, we are given node features  for each node  and (optionally) edge features  for each edge connecting node  and node .
The input features  and  are embedded to -dimensional hidden features  and  via a simple linear projection before passing them to a graph neural network:

where ,  and . If the input node/edge features are one-hot vectors of discrete variables, then  biases  are not used. 


\begin{figure}[!t]
    \centering
    \includegraphics[width=0.99\textwidth]{images/gnn_pipeline_v3.pdf}
    \caption{A standard experimental pipeline for GCNs, which embeds the graph node and edge features,
    performs several GNN layers to compute convolutional features,
    and finally makes a prediction through a task-specific MLP layer.} 
    \label{fig:pipeline_mpgcns}
\end{figure}

\begin{figure}[!t]
    \centering
    \includegraphics[width=1.02\textwidth]{images/wlgnn_pipeline.pdf}
    \caption{A standard experimental pipeline for WL-GNNs, which inputs to a GNN a graph with all node and edge information (if available) represented by a dense tensor, performs several GNN layer computations over the dense tensor,
    and finally makes a prediction through a task-specific MLP layer.} 
    \label{fig:pipeline_wlgnns}
\end{figure}

\subsubsection{GCN layers}

Each GCN layer computes -dimensional representations for the nodes/edges of the graph through recursive neighborhood diffusion (or message passing), where each graph node gathers features from its neighbors to represent local graph structure.
Stacking  GCN layers allows the network to build node representations from the -hop neighborhood of each node.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.50\textwidth]{images/generic_gnn.pdf}
    \caption{A generic graph neural network layer. Figure adapted from \cite{bresson2017residual}.}
    \label{fig:generic-gnn}
\end{figure}

Let  denote the feature vector at layer  associated with node .
The updated features  at the next layer  are obtained by applying non-linear transformations to the central feature vector  and the feature vectors  for all nodes  in the neighborhood of node  (defined by the graph structure). 
This guarantees the transformation to build local reception fields, such as in standard ConvNets for computer vision, and be invariant to both graph size and vertex re-indexing.









Thus, the most generic version of a feature vector  at vertex  at the next layer in the GNN is:

where  denotes the set of neighboring nodes  pointed to node , which can be replaced by , the set of neighbors of node , if the graph is undirected. In other words, a GNN is defined by a mapping  taking as input a vector  (the feature vector of the center vertex) as well as an un-ordered set of vectors  (the feature vectors of all neighboring vertices), see Figure \ref{fig:generic-gnn}. 
The arbitrary choice of the mapping  defines an instantiation of a class of GNNs. 








\paragraph{\textit{Vanilla} Graph ConvNets (GCN) \cite{kipf2017semi}}
In the simplest formulation of GNNs, Graph ConvNets iteratively update node features via an isotropic averaging operation over the neighborhood node features, \textit{i.e.},

where  (a bias is also used, but omitted for clarity purpose),  is the in-degree of node ,
see Figure \ref{fig:gcn}.
Eq. \eqref{eqn:gcn} is called a \textit{convolution} as it is a linear approximation of a localized spectral convolution. Note that it is possible to add the central node features  in the update \eqref{eqn:gcn} by using self-loops or residual connections.



\begin{figure}[t!]
\centering
\begin{minipage}{.5\textwidth}
\centering
  \vspace{2.4mm}
  \includegraphics[width=0.5\columnwidth]{images/GNNs/fig-gcn.pdf}
  \vspace{2.4mm}
  \caption{GCN Layer}
  \label{fig:gcn}
\end{minipage}\begin{minipage}{.5\textwidth}
\centering
  \includegraphics[width=0.55\columnwidth]{images/GNNs/fig-graphsage.pdf}
  \caption{GraphSage Layer}
  \label{fig:graphsage}
\end{minipage}\end{figure}


\paragraph{GraphSage \cite{hamilton2017inductive}}

GraphSage improves upon the simple GCN model by explicitly incorporating each node's own features from the previous layer in its update equation:

where ,
see Figure \ref{fig:graphsage}. Observe that the transformation applied to the central node features  is different to the transformation carried out to the neighborhood features . The node features are then projected onto the -unit ball before being passed to the next layer:

The authors also define more sophisticated neighborhood aggregation functions, such as Max-pooling or LSTM aggregators:

where  and the  cell also uses learnable weights. In our experiments, we use the Max-pooling version of GraphSage, Eq.\eqref{eqn:graphsage-maxpool}.









    

\paragraph{Graph Attention Network (GAT) \cite{velickovic2018graph}}
GAT uses the attention mechanism of \cite{bahdanau2014neural} to introduce anisotropy in the neighborhood aggregation function. The network employs a multi-headed architecture to increase the learning capacity, similar to the Transformer \cite{vaswani2017attention}. The node update equation is given by:

where  are the  linear projection heads, and  are the attention coefficients for each head defined as:


where , see Figure \ref{fig:gat}. GAT learns a mean over each node's neighborhood features sparsely weighted by the importance of each neighbor. 







\begin{figure}[t!]
\centering
\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width=0.8\columnwidth]{images/GNNs/fig-gatv2.pdf}
\caption{GAT Layer}
  \label{fig:gat}
\end{minipage}\begin{minipage}{.5\textwidth}
\centering
\includegraphics[width=0.8\columnwidth]{images/GNNs/fig-monetv2.pdf}
\caption{MoNet Layer}
  \label{fig:monet}
\end{minipage}\end{figure}








\paragraph{MoNet \cite{Monti_2017}} The MoNet model introduces a general architecture to learn on graphs and manifolds using the Bayesian Gaussian Mixture Model (GMM) \cite{dempster1977maximum}. In the case of graphs, the node update equation is defined as:

where ,  are the (learnable) parameters of the GMM, see Figure \ref{fig:monet}.





\paragraph{Gated Graph ConvNet (GatedGCN) \cite{bresson2017residual}}

GatedGCN considers residual connections, batch normalization and edge gates to design another anisotropic variant of GCN. The authors propose to explicitly update edge features along with node features:  

where ,  is the Hadamard product, and the edge gates  are defined as:

where  is the sigmoid function,  is a small fixed constant for numerical stability, , see Figure \ref{fig:gatedgcn}. 
Note that the edge gates \eqref{eqn:gated-gcn-eta} can be regarded as a soft attention process, related to the standard sparse attention mechanism \cite{bahdanau2014neural}.
Different from other anisotropic GNNs, the GatedGCN architecture explicitly maintains edge features  at each layer, following \cite{bresson2019two,joshi2019efficient}.




\begin{figure}[t!]
\centering
\begin{minipage}{.5\textwidth}
\centering
  \includegraphics[width=0.85\columnwidth]{images/GNNs/fig-gatedgcn.pdf}
  \caption{GatedGCN Layer}
  \label{fig:gatedgcn}
\end{minipage}\begin{minipage}{.5\textwidth}
\centering
  \includegraphics[width=0.55\columnwidth]{images/GNNs/fig-gin.pdf}
  \caption{GIN Layer}
  \label{fig:gin}
\end{minipage}\end{figure}






\paragraph{Graph Isomorphism Networks (GIN) \cite{xu2018how}}
The GIN architecture is based the Weisfeiler-Lehman Isomorphism Test \cite{weisfeiler1968reduction} to study the expressive power of GNNs. 
The node update equation is defined as:

where  is a learnable constant, , BN denotes Batch Normalization. See Figure \ref{fig:gin} for illustration of the update equation.



\paragraph{Normalization and Residual Connections}
As a final note, we augment each message-passing GCN layer with batch normalization (BN) \cite{ioffe2015batch} and residual connections \cite{He_2016_CVPR}. 
As such, we consider a more specific class of GCNs than \eqref{eqn:generic-gnn}:

where  is a non-linear activation function and  is a specific message-passing GCN layer. 







\subsubsection{Task-based Layer}
\label{sec:mpgcns_task_network}
The final component of each network is a prediction layer to compute task-dependent outputs, which are given to a loss function to train the network parameters in an end-to-end manner. The input of the prediction layer is the result of the final message-passing GCN layer for each node of the graph (except GIN, which uses features from all intermediate layers). 



\paragraph{Graph classifier layer}
To perform graph classification, we first build a -dimensional graph-level vector representation  by averaging over all node features in the final GCN layer:

The graph features are then passed to a MLP, which outputs un-normalized logits/scores  for each class:

where  is the number of classes. 
Finally, we minimize the cross-entropy loss between the logits and groundtruth labels.



\paragraph{Graph regression layer}
For graph regression, we compute  using Eq.\eqref{eqn:graph-repres} and pass it to a MLP which gives the prediction score :

where .
The L1-loss between the predicted score and the groundtruth score is minimized during the training.



\paragraph{Node classifier layer}
For node classification, we independently pass each node's feature vector to a MLP for computing the un-normalized logits  for each class:

where . The cross-entropy loss weighted inversely by the class size is used during training.







\paragraph{Edge classifier layer}
To make a prediction for each graph edge , we first concatenate node features  and  from the final GNN layer. 
The concatenated edge features are then passed to a MLP for computing the un-normalized logits  for each class:

where . The standard cross-entropy loss between the logits and groundtruth labels is used.






\subsection{Weisfeiler-Lehman GNNs}
\label{sec:wlgnns}


\subsubsection{Input Tensor}


For a given graph with adjacency matrix , node features  and edge features , the input tensor to the RingGNN and 3WL-GNN networks is defined as 

where






\subsubsection{WL-GNN layers}
\begin{figure}[t!]
\centering
\begin{minipage}{.5\textwidth}
\centering
  \includegraphics[width=0.65\columnwidth]{images/GNNs/fig-3wlgnn.pdf}
  \caption{3WL-GNN Layer}
  \label{fig:3wlgnn}
\end{minipage}\begin{minipage}{.5\textwidth}
\centering
  \includegraphics[width=0.6\columnwidth]{images/GNNs/fig-ringgnn.pdf}
  \caption{RingGNN Layer}
  \label{fig:ringgnn}
\end{minipage}\end{figure}

\paragraph{3WL-GNNs \cite{maron2019provably}}
These networks introduced an architecture that can distinguish two non-isomorphic graphs with the 3-WL test. The layer update equation of 3WL-GNNs is defined as: 

where ,  and  are 2-layer MLPs applied along the feature dimension:

where . As , the MLP \eqref{eqn:mw} is implemented with a standard 2D-convolutional layer with  kernel size. Eventually, the matrix multiplication in \eqref{eqn:3wlgnn} is carried out along the first and second dimensions such that:

with complexity .






\paragraph{Ring-GNNs \cite{chen2019equivalence}}
These models proposed to improve the order-2 equivariant GNNs of \cite{maron2018invariant} with the multiplication of two equivariant linear layers. The layer update equation of Ring-GNNs is designed as: 

where , , and  are the equivariant linear layers defined as 

where  and  is the set of all basis functions for all linear equivariant functions from  (see Appendix A in \cite{maron2018invariant} for the complete list of these 15 operations) and  are the basis for the bias terms. Matrix multiplication in \eqref{eqn:ring-gnn} also implies a time complexity .








\subsubsection{Task-based network layers}


We describe the final network layers depending on the task at hand. The loss functions corresponding to the task are the same as the GCNs, and presented in Section \ref{sec:mpgcns_task_network}.


\paragraph{Graph classifier layer} 
We have followed the original author implementations in \cite{maron2019provably,maron2018invariant,chen2019equivalence} to design the classifier layer for 3WL-GNNs and Ring-GNNs. Similar to \cite{xu2018representation,xu2018how}, the classifier layer for Ring-GNNs uses features from all intermediate layers and then passes the features to a MLP:

where  is the number of classes.

For 3WL-GNNs, Eqn. \eqref{eqn:wlgnn_classif} is replaced by a diagonal and off-diagonal max pooling readout \cite{maron2019provably, maron2018invariant} at every layer:

and the final prediction score is defined as:

where ,  is the number of classes. 



\paragraph{Graph regression layer} 
Similar to the graph classifier layer with  for Ring-GNNs, and  for 3WL-GNNs.


\paragraph{Node classifier layer}
For node classification, the prediction in Ring-GNNs is done as follows:

where  is the number of classes. 

In 3WL-GNNs, the final prediction score is defined as:

where  is the number of classes. 


\paragraph{Edge classifier layer}
For link prediction, for both Ring-GNNs and 3WL-GNNs, the edge features are obtained by concatenating the node features such as:

where  is the number of classes. 























\section{Experiments on TU datasets}
\label{sec:TUs}
Apart from the proposed datasets in our benchmark (Section \ref{sec:expsetup}), we perform experiments on 3 TU datasets for graph classification -- ENZYMES, DD and PROTEINS.  
Our goal is to empirically highlight some of the challenges of using these conventional datasets for benchmarking GNNs. 

{\bf Splitting.} Since the 3 TU datasets that we use do not have standard splits, we perform a 10-fold cross validation split which gives 10 sets of train, validation and test data indices in the ratio . We use stratified sampling to ensure that the class distribution remains the same across splits. The indices are saved and used across all experiments for fair comparisons. There are  train/ validation/ test graphs for ENZYMES,  train/ validation/ test graphs for DD, and  train/ validation/ test graphs for PROTEINS datasets in each of the folds. \\
{\bf Training.} We use Adam optimizer with a similar learning rate strategy as used in our benchmark's experimental protocol. An initial learning rate is tuned from a range of  to  using grid search for every GNN models. The learning rate reduce factor is , the patience value is  and the stopping learning rate is .\\
{\bf Performance Measure.} We use classification accuracy between the predicted labels and groundtruth labels as our performance measure. The model performance is evaluated on the test split of the 10 folds for all TU datasets, and reported as the average and the standard deviation of the 10 scores.

Our numerical results on the TU datasets -- ENZYMES, DD and PROTEINS are presented in Table \ref{tab:tableTU}. We observe all NNs have similar statistical test performance as the standard deviation is quite large. We also report a second run of these experiments with the same experimental protocol, \textit{i.e.} the same 10-fold splitting and hyperparameters but different initialization (seed). 
We observe a change of model ranking, which we attribute to the small size of the datasets and the non-determinism of gradient descent optimizers. We also observe that, for DD and PROTEINS, the graph-agnostic MLP baselines perform as good as GNNs. 
Our observations reiterate how experiments on the small TU datasets are difficult to determine which GNNs are powerful and robust.  

\begin{table}[t]
    \centering
        \caption{Performance on the TU datasets with 10-fold cross validation (higher is better). Two runs of all the experiments using the same hyperparameters but different random seeds are shown separately to note the differences in ranking and variation for reproducibility. The top 3 performance scores are highlighted as \best{First}, \textcolor{blue}{\textbf{Second}}, \textbf{Third}.
    }
    \vspace{3pt}
    \scalebox{0.56}{
    \begin{tabular}{crcc|cccc|cccc}
        \toprule
        \multirow{2}{*}{\textbf{Dataset}} & \multirow{2}{*}{\textbf{Model}} & \multirow{2}{*}{\textbf{}} & \multirow{2}{*}{\textbf{\#Param}} & \multicolumn{4}{c|}{\textbf{seed 1}} & \multicolumn{4}{c}{\textbf{seed 2}} \\
        \cline{5-12}
        & & & & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epoch} & \textbf{Epoch/Total} \\ 
        \midrule
        \midrule
        \parbox[t]{2mm}{\multirow{9}{*}{\rotatebox[origin=c]{90}{ENZYMES}}} & MLP & 4 & 101481 & 55.8333.516 & 93.0627.551 & 332.30 & 0.18s/0.17hr & 53.8334.717 & 87.85410.765 & 327.80 & 0.19s/0.18hr \\
        \cline{2-12}
        & GCN & 4 & 103407 & \textcolor{blue}{\textbf{65.8334.610}} & 97.6883.064 & 343.00 & 0.69s/0.67hr & 64.8337.089 & 93.0424.982 & 334.30 & 0.74s/0.70hr\\
        & GraphSage & 4 & 105595 & 65.0004.944 & 100.0000.000 & 294.20 & 1.62s/1.34hr & \textbf{68.1675.449} & 100.0000.000 & 287.30 & 1.76s/1.42hr
 \\
        \cline{2-12}
        & MoNet & 4 & 105307 & 63.0008.090 & 95.2295.864 & 333.70 & 0.53s/0.49hr & 62.1674.833 & 93.5625.897 & 324.40 & 0.68s/0.62hr \\
        & GAT & 4 & 101274 & \best{68.5005.241} & 100.0000.000 & 299.30 & 0.70s/0.59hr & \textcolor{blue}{\textbf{68.5004.622}} & 100.0000.000 & 309.10 & 0.76s/0.66hr \\
        & GatedGCN & 4 & 103409 & \textbf{65.6674.899} & 99.9790.062 & 316.80 & 2.31s/2.05hr & \best{70.0004.944} & 99.9790.062 & 313.20 & 2.63s/2.30hr \\
        \cline{2-12}
        & GIN & 4 & 104864 & 65.3336.823 & 100.0000.000 & 402.10 & 0.53s/0.61hr & 67.6675.831 & 100.0000.000 & 404.90 & 0.60s/0.68hr \\
        & RingGNN & 2 & 103538 & 18.6671.795 & 20.1042.166 & 337.30 & 7.12s/6.71hr & 45.3334.522 & 56.7926.081 & 497.50 & 8.05s/11.16hr \\
& 3WLGNN & 3 & 104658 & 61.0006.799 & 98.8751.571 & 381.80 & 9.22s/9.83hr & 57.6679.522 & 96.7295.525 & 336.50 & 11.80s/11.09hr\\
\midrule
        \parbox[t]{2mm}{\multirow{9}{*}{\rotatebox[origin=c]{90}{DD}}} & MLP & 4 & 100447 & 72.2393.854 & 73.8161.015 & 371.80 & 6.36s/6.61hr & \textbf{72.4083.449} & 73.8800.623 & 349.60 & 1.13s/1.11hr\\
        \cline{2-12}
& GCN & 4 & 102293 & 72.7584.083 & 100.0000.000 & 266.70 & 3.56s/2.66hr & \textcolor{blue}{\textbf{73.1685.000}} & 100.0000.000 & 270.20 & 3.81s/2.88hr\\
& GraphSage & 4 & 102577 & \textcolor{blue}{\textbf{73.4333.429}} & 100.0000.000 & 267.20 & 11.50s/8.59hr & 71.9003.647 & 100.0000.000 & 265.50 & 6.60s/4.90hr \\
\cline{2-12}
& MoNet & 4 & 102305 & 71.7363.365 & 81.0032.593 & 252.60 & 3.30s/2.34hr & 71.4792.167 & 81.2682.295 & 253.50 & 2.83s/2.01hr \\
& GAT & 4 & 100132 & \best{75.9003.824} & 95.8512.575 & 201.30 & 6.31s/3.56hr & \best{74.1983.076} & 96.9641.544 & 220.10 & 2.84s/1.75hr\\
        & GatedGCN & 4 & 104165 & \textbf{72.9182.090} & 82.7962.242 & 300.70 & 12.05s/10.13hr & 71.9833.644 & 83.2433.716 & 323.60 & 8.78s/7.93hr\\
        \cline{2-12}
        & GIN & 4 & 103046 & 71.9103.873 & 99.8510.136 & 275.70 & 5.28s/4.08hr & 70.8832.702 & 99.8830.088 & 276.90 & 2.31s/1.79hr\\
        & RingGNN & 2 & 109857 & OOM & OOM & OOM & OOM & OOM & OOM & OOM & OOM\\
        & 3WLGNN & 3 & 104124 & OOM & OOM & OOM & OOM & OOM & OOM & OOM & OOM\\
        \midrule
        \parbox[t]{2mm}{\multirow{9}{*}{\rotatebox[origin=c]{90}{PROTEINS}}} & MLP & 4 & 100643 & 75.6442.681 & 79.8471.551 & 244.20 & 0.42s/0.29hr & 75.8232.915 & 79.4421.443 & 241.20 & 0.35s/0.24hr\\
        \cline{2-12}
        & GCN & 4 & 104865 & 76.0982.406 & 81.3872.451 & 350.90 & 1.55s/1.53hr & \textbf{75.9123.064} & 82.1402.706 & 349.60 & 1.46s/1.42hr \\
        & GraphSage & 4 & 101928 & 75.2892.419 & 85.8270.839 & 245.40 & 3.36s/2.30hr & 75.5591.907 & 85.1181.171 & 244.40 & 3.44s/2.35hr \\
        \cline{2-12}
        & MoNet & 4 & 103858 & \best{76.4522.898} & 78.2060.548 & 306.80 & 1.23s/1.06hr & \textcolor{blue}{\textbf{76.4532.892}} & 78.2730.695 & 289.50 & 1.26s/1.03hr\\
        & GAT & 4 & 102710 & \textbf{76.2772.410} & 83.1862.000 & 344.60 & 1.47s/1.42hr & 75.5573.443 & 84.2532.348 & 335.10 & 1.51s/1.41hr\\
        & GatedGCN & 4 & 104855 & \textcolor{blue}{\textbf{76.3632.904}} & 79.4310.695 & 293.80 & 5.03s/4.13hr & \best{76.7213.106} & 78.6890.692 & 272.80 & 4.78s/3.64hr \\
        \cline{2-12}
& GIN & 4 & 103854 & 74.1173.357 & 75.3511.267 & 420.90 & 1.02s/1.20hr & 71.2414.921 & 71.3732.835 & 362.00 & 1.04s/1.06hr\\
& RingGNN & 2 & 109036 & 67.5647.551 & 67.6074.401 & 150.40 & 28.61s/12.08hr & 56.0636.301 & 59.2895.560 & 222.70 & 19.08s/11.88hr \\
& 3WLGNN & 3 & 105366 & 61.7124.859 & 62.4274.548 & 211.40 & 12.82s/7.58hr & 64.6825.877 & 65.0345.253 & 200.40 & 13.05s/7.32hr \\
        \bottomrule
    \end{tabular}
    \label{tab:tableTU}
}
\end{table}












\section{Laplacian Positional Encodings}
\label{sec_PE}

Standard GCNs are not able to differentiate isomorphic nodes \cite{murphy2019relational,you2019position}. To overcome this issue, positional encoding (PE) of nodes was proposed. Ideally, PEs should be unique for each node, and nodes which are far apart in the graph should have different positional features whereas nodes which are nearby have similar positional features. Note that in a graph that has some symmetries, positional features cannot be assigned in a canonical way. For example, if node  and node  are structurally symmetric, and we have positional features  ,   that differentiate them, then it is also possible to arbitrary choose ,   since  and  are completely symmetric by definition. In other words, the PE is always arbitrary up to the number of symmetries in the graph. As a consequence, the network will have to learn to deal with these ambiguities during training. The simplest possible positional encodings is to give an (arbitrary) ordering to the nodes, among  possible orderings. During training, the orderings are uniformly sampled from the  possible choices in order for the network to learn to be independent to these arbitrary choices \cite{murphy2019relational}. 


We propose an alternative to reduce the sampling space, and therefore the amount of ambiguities to be resolved by the network. Laplacian eigenvectors are hybrid positional and structural encodings, as they are invariant by node re-parametrization. However, they are also limited by natural symmetries such as the arbitrary sign of eigenvectors (after being normalized to have unit length). The number of possible sign flips is , where  is the number of eigenvectors. In practice we choose , and therefore  is much smaller  (the number of possible ordering of the nodes). During the training, the eigenvectors will be uniformly sampled at random between the  possibilities. If we do not seek to learn the invariance w.r.t. all possible sign flips of eigenvectors, then we can remove the sign ambiguity of eigenvectors by taking the absolute value. This choice seriously degrades the expressivity power of the positional features. 


Numerical results for different positional encodings are reported in Table \ref{tab:PE_study}. For all results, we use the GatedGCN model \cite{bresson2017residual}. We study 5 types of positional encodings; {\it EigVecs-} corresponds to the smallest non-trivial  eigenvectors, {\it Rand sign(EigVecs)} randomly flips the sign of the  smallest non-trivial eigenvectors in each batch, {\it Abs(EigVecs)} takes the absolute value of the  eigenvectors, {\it Fixed node ordering} uses the original node ordering of  graphs, and {\it Rand node ordering} randomly permutes ordering of nodes in each batch. We observed that the best results are consistently produced with the Laplacian PEs with random sign flipping at training. For index PEs, randomly permuting the ordering of nodes also improves significantly the performances over keeping fixed the original node ordering. However, Laplacian PEs clearly outperform index PEs. 



\begin{table}[h!]
    \centering
    \caption{Study of positional encodings (PEs) with the GatedGCN model \cite{bresson2017residual}. Performance reported on the test sets of CSL, ZINC, PATTERN, CLUSTER and COLLAB (higher is better, except for ZINC). \best{Red}: the best model.  }
    \vspace{3pt}
    \scalebox{0.75}{
    \begin{tabular}{c|rcccccc}
        \toprule
        \multicolumn{1}{c}{} & \textbf{PE type} & \textbf{} & \textbf{\#Param} & \textbf{Test Acc.s.d.} & \textbf{Train Acc.s.d.} & \textbf{\#Epochs} & \textbf{Epoch/Total} \\
        \midrule
        \midrule
        \parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{CSL}}} & No PE & 4 & 104007 & 10.0000.000 & 10.0000.000 & 54.00 & 0.58s/0.05hr \\
         & EigVecs-20 & 4 & 105407 & 68.6337.143 & 99.8110.232 & 107.16 & 0.59s/0.09hr \\
         & Rand sign(EigVecs) & 4 & 105407 & \best{99.7670.394} & 99.6890.550 & 188.76 & 0.59s/0.16hr \\
         & Abs(EigVecs) & 4 & 105407 & 99.4331.133 & 100.0000.000 & 143.64 & 0.60s/0.12hr \\
         & Fixed node ordering & 4 & 106807 & 10.5334.469 & 76.05614.136 & 60.56 & 0.59s/0.05hr \\
         & Rand node ordering & 4 & 106807 & 11.1332.571 & 10.9442.106 & 91.60 & 0.60s/0.08hr \\
        \midrule
        \parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{PATTERN}}} & No PE & 16 & 502223 & 85.6050.105 & 85.9990.145 & 62.00 & 646.03s/11.36hr \\
         & EigVecs-2 & 16 & 505421 & 86.0290.085 & 86.9550.227 & 65.00 & 645.36s/11.94hr \\
         & Rand sign(EigVecs) & 16 & 502457 & \best{86.5080.085} & 86.8010.133 & 65.75 & 647.94s/12.08hr\\
         & Abs(EigVecs) & 16 & 505421 & 86.3930.037 & 87.0110.172 & 62.00 & 645.90s/11.41hr \\
         & Fixed node ordering & 16 & 516887 & 80.1330.202 & 98.4160.141 & 45.00 & 643.23s/8.27hr \\
         & Rand node ordering & 16 & 516887 & 85.7670.044 & 85.9980.063 & 64.50 & 645.09s/11.79hr \\
        \midrule
        \parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{CLUSTER}}} & No PE & 16 & 502615 & 73.6840.348 & 88.3561.577 & 61.50 & 399.44s/6.97hr \\
         & EigVecs-20 & 16 & 504253 & 75.5200.395 & 89.3321.297 & 49.75 & 400.50s/5.70hr \\
         & Rand sign(EigVecs) & 16 & 504253 & \best{76.0820.196} & 88.9190.720 & 57.75 & 399.66s/6.58hr \\
         & Abs(EigVecs) &  16 & 504253 & 73.7960.234 & 91.1251.248 & 58.75 & 398.97s/6.68hr \\
         & Fixed node ordering & 16 & 517435 & 69.2320.265 & 92.2980.712 & 51.00 & 400.40s/5.82hr \\
         & Rand node ordering & 16 & 517435 & 74.6560.314 & 82.9401.718 & 61.00 & 397.75s/6.88hr \\
         \midrule
        \parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{COLLAB}}} & No PE & 3 & 40965 & 52.6351.168 & 96.1031.876 & 95.00 & 453.47s/12.09hr \\
         & EigVecs-20 & 3 & 41889 & 52.3260.678 & 96.7001.296 & 95.00 & 452.40s/12.10hr \\
         & Rand sign(EigVecs) & 3 & 41889 & \best{52.8491.345} & 96.1650.453 & 94.75 & 452.75s/12.08hr \\
         & Abs(EigVecs) & 3 & 41889 & 51.4191.109 & 95.9841.157 & 95.00 & 451.36s/12.07hr \\
        \midrule
        \multicolumn{1}{c}{} & \textbf{PE type} & \textbf{} & \textbf{\#Param} & \textbf{Test MAEs.d.} & \textbf{Train MAEs.d.} & \textbf{\#Epochs} & \textbf{Epoch/Total} \\
        \midrule
        \parbox[t]{2mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{ZINC}}} & No PE & 16 & 504153 & 0.3540.012 & 0.0950.012 & 165.25 & 10.52s/0.49hr \\
         & EigVecs-8 & 16 & 505011 & 0.3190.010 & 0.0380.007 & 143.25 & 10.62s/0.43hr \\
         & Rand sign(EigVecs) & 16 & 505011 & \best{0.2140.013} & 0.0670.019 & 185.00 & 10.70s/0.56hr \\
         & Abs(EigVecs) & 16 & 505011 & \best{0.2140.009} & 0.0350.011 & 167.50 & 10.61s/0.50hr \\
         & Fixed node ordering & 16 & 507195 & 0.4310.007 & 0.0440.009 & 118.25 & 10.62s/0.35hr \\
         & Rand node ordering & 16 & 507195 & 0.3210.015 & 0.1770.015 & 184.75 & 10.55s/0.55hr \\
\bottomrule
    \end{tabular}
    }
    \label{tab:PE_study}
\end{table}















\section{Dissecting GNNs for Edge Representation Analysis}

In Section~\ref{sec:eval}, Table~\ref{tab:edge-analysis}, we systematically study the impact of anisotropy by instantiating three variants of GAT and GatedGCN:
(1)~Isotropic aggregation, such as
vanilla GCNs, Eq.\eqref{eqn:gcn-app}; 
(2)~Anisotropy using edge features, such as GAT by default, Eq.\eqref{eqn:gat}; and
(3)~Anisotropy with edge features and explicit edge representations updated at each layer, such as in GatedGCN by default, Eq.\eqref{eqn:gated-gcn-h}.
This section provides formal equations for each model variant.
(Note that there may be a multitude of approaches to instantiating anisotropic GNNs and using edge features~\cite{battaglia2016interaction,sanchez2018graph,brockschmidt2019gnn} besides the ones we consider.)


\subsection{GatedGCN}

\textbf{Isotropic}, similar to vanilla GCNs with sum aggregation:


\textbf{Anisotropic} with intermediate edge features computed as joint representations of adjacent node features at each layer:

where ,  is the Hadamard product, and  are the edge gates.
    
\textbf{Anisotropic} with edge features as well as explicit edge representations updated across layers in addition to node features, as in GatedGCN by default, Eq.\eqref{eqn:gated-gcn-h}:

where ,  is the Hadamard product, and  are the edge gates.
The input edge features from the datasets (\textit{e.g.} distances for TSP, collaboration year and frequency for COLLAB) can optionally be used to initialize the edge representations .

\subsection{GAT}

\textbf{Isotropic}, similar to multi-headed vanilla GCNs with sum aggregation:


\textbf{Anisotropic} with intermediate edge features computed as joint representations of adjacent node features at each layer, as in GAT by default, Eq.\eqref{eqn:gat}:

where  are the  linear projection heads and  are the attention coefficients for each head.


\textbf{Anisotropic} with edge features as well as explicit edge representations updated across layers in addition to node features:

where  are the  linear projection heads and  are the attention coefficients for each head.
The input edge features from the datasets can optionally be used to initialize the edge representations .


\subsection{GraphSage}

Interestingly, in Table~\ref{tab:results} for COLLAB, we found that the isotropic GraphSage with max aggregation performs close to GAT and GatedGCN models, both of which perform anisotropic mean aggregation.
On the other hand, models which use sum aggregation (GIN, MoNet) are unable to beat the simple matrix factorization baseline.
This result indicates that aggregation functions which are invariant to node degree (max and mean) provide a powerful inductive bias for COLLAB.

We instantiate two anisotropic variants of GraphSage, as described in the following paragraphs, and compare them to GAT and GatedGCN on COLLAB in Table~\ref{tab:edge-analysis-2}.
We find that upgrading max aggregators with edge features does not significantly boost performance. 
On the other hand, maintaining explicit edge representations across layers hurts the models, presumably due to using very small hidden dimensions.
(As previously mentioned, maintaining representations for both 235K nodes and 2.3M edges leads to significant GPU memory usage and requires using smaller hidden dimensions.)



\begin{table}[t!]
\centering
    \caption{Study of anisotropic edge features and representations for link prediction on COLLAB, including GraphSage models. \best{Red}: the best model, \good{Violet}: good models.
    }
    \vspace{3pt}
    \scalebox{0.65}{
    \begin{tabular}{rccccccccc}
        \toprule
         \multirow{2}{*}{\textbf{Model}} & \textbf{Edge} & \textbf{Edge} & \textbf{Aggregation} & \multirow{2}{*}{\textbf{}} & \multirow{2}{*}{\textbf{\#Param}} & \textbf{Test Acc.} & \textbf{Train Acc.} & \multirow{2}{*}{\textbf{\#Epoch}} & \textbf{Epoch/} \\
         & \textbf{Feat.} & \textbf{Repr.} & \textbf{Function} & & & \textbf{s.d}. & \textbf{s.d.} & & \textbf{Total} \\
         \midrule \midrule
        \multirow{3}{*}{GatedGCN} & \crossmark & \crossmark & Sum & 3 & 26593 & 35.9891.549 & 60.5864.251 & 148.00 & 263.62s/10.90h \\
         & \checkmark & \crossmark & Weighted Mean & 3 & 26715 & \good{50.6680.291} & 96.1280.576 & 172.00 & 384.39s/18.44hr \\
         & \checkmark & \checkmark & Weighted Mean & 3 & 27055 & \best{51.5371.038} & 96.5241.704 & 188.67 & 376.67s/19.85hr \\
        \midrule
         GatedGCN-E & \checkmark & \checkmark & Weighted Mean & 3 & 27055 & 47.2122.016 & 85.8010.984 & 156.67 & 377.04s/16.49hr \\
        \midrule
         \multirow{3}{*}{GAT} & \crossmark & \crossmark & Sum & 3 & 28201 & 41.1410.701 & 70.3441.837 & 153.50 & 371.50s/15.97hr \\
         & \checkmark & \crossmark & Weighted Mean & 3 & 28561 & \good{50.6620.687} & 96.0850.499 & 174.50 & 403.52s/19.69hr \\
         & \checkmark & \checkmark & Weighted Mean & 3 & 26676 & \good{49.6740.105} & 92.6650.719 & 201.00 & 349.19s/19.59hr \\
        \midrule
         GAT-E & \checkmark & \checkmark & Weighted Mean & 3 & 26676 & 44.9891.395 & 82.2304.941 & 120.67 & 328.29s/11.10hr \\
        \midrule
         \multirow{3}{*}{GraphSage} & \crossmark & \crossmark & Max & 3 & 26293 & \good{50.9081.122} & 98.6171.763 & 157.75 & 241.49s/10.62hr \\
         & \checkmark & \crossmark & Weighted Max & 3 & 26487 & \good{50.9970.875} & 99.1580.694 & 112.00 & 366.24s/11.46hr \\
         & \checkmark & \checkmark & Weighted Max & 3 & 26950 & 48.5301.919 & 90.9909.273 & 118.25 & 359.18s/11.88hr \\
        \midrule
         GraphSage-E & \checkmark & \checkmark & Weighted Max & 3 & 26950 & 47.3151.939 & 93.4755.884 & 120.00 & 359.10s/12.07hr \\
        \bottomrule
    \end{tabular}
    }
    \label{tab:edge-analysis-2}
\end{table}



\textbf{Isotropic}, as in GraphSage by default, Eq.\eqref{eqn:graphsage-maxpool}:

where .

\textbf{Anisotropic} with intermediate edge features computed as joint representations of adjacent node features at each layer:

where ,  is the Hadamard product, and  are the edge gates.

\textbf{Anisotropic} with edge features as well as explicit edge representations updated across layers in addition to node features:

where ,  is the Hadamard product, and  are the edge gates.
The input edge features from the datasets can optionally be used to initialize the edge representations .







\section{A Note on Graph Size Normalization}
Intuitively, batching graphs of variable sizes may lead to node representation at different scales, making it difficult to learn the optimal statistics  and  for BatchNorm across irregular batch sizes and variable graphs. 
A preliminary version of this work introduced a graph size normalization technique called GraphNorm, which normalizes the node features   w.r.t. the graph size, \textit{i.e.}, 

where  is the number of graph nodes. 
The GraphNorm layer is placed before the BatchNorm layer.

We would like to note that GraphNorm does not have any concrete theoretical basis as of now, and was proposed based on initially promising empirical results on datasets such as ZINC and CLUSTER.
Future work shall investigate more principled approaches towards designing normalization layers for graph structured data.












\section{Hardware Details}
Timing research code can be tricky due to differences of implementations and hardware acceleration.
Nonetheless, we take a practical view and report the average wall clock time per epoch and the total training time for each model.
All experiments were implemented in DGL/PyTorch. 
We run experiments for MNIST, CIFAR10, ZINC, TSP, COLLAB and TUs on an Intel Xeon CPU E5-2690 v4 server with 4 Nvidia 1080Ti GPUs, and for PATTERN and CLUSTER on an Intel Xeon Gold 6132 CPU with 4 Nvidia 2080Ti GPUs.
Each experiment was run on a single GPU and 4 experiments were run on the server at any given time (on different GPUs).
We run each experiment for a maximum of 12 hours.














































 


























































































    































































































































































































































































































































































 

\end{document}
