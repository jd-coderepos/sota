\documentclass{article}
\PassOptionsToPackage{sort}{natbib}

\clearpage{}

\usepackage[final]{neurips_2019}


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{amsmath}       \usepackage{amssymb}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{sidecap}

\bibliographystyle{plainnat}


\newcommand{\xvec}{\bm x}
\newcommand{\thetavec}{\boldsymbol{\theta}}
\newcommand{\yvec}{\bm y}
\newcommand{\Wmat}{\bm W}

\newcommand{\sumk}{\sum_{i=1}^K}
\newcommand{\pivec}{\boldsymbol{\pi}}
\newcommand{\muvec}{\boldsymbol{\mu}}
\newcommand{\svec}{\bm s}
\newcommand{\hvec}{\bm h}

\newcommand{\imgdim}{c \times h \times w}
\newcommand{\Rimg}{\mathbb{R}^{\imgdim}}
\newcommand{\Rlatent}{\mathbb{R}^{d}}
\newcommand{\xhat}{\hat{\xvec}}
\newcommand{\zvec}{\textbf{z}}
\newcommand{\ltwoloss}{L_2}
\newcommand{\Vmat}{\bm V}

\newcommand{\genc}{g_{enc}}
\newcommand{\garr}{g_{arr}}
\newcommand{\xtk}{x_{t+k}}
\newcommand{\ztk}{z_{t+k}}
\newcommand{\ct}{c_{t}}
\newcommand{\xt}{x_{t}}
\newcommand{\zt}{z_{t}}
\newcommand{\yt}{y_{t}}
\newcommand{\zj}{z_{j}}
\newcommand{\Wk}{W_{k}}
\newcommand{\fkxz}{f_{k}(\xtk, \zt)}
\newcommand{\fkxc}{f_{k}(\xtk, \ct)}
\newcommand{\fkzc}{f_{k}(\ztk, \ct)}
\newcommand{\loss}{\mathcal{L}_N}
\newcommand{\expectation}{\mathop{\mathbb{E}}}
\DeclareMathOperator{\gradblock}{GradientBlock}

\newcommand{\peter}[1]{\todo[backgroundcolor=Cyan!25,width=20]{#1}}

\linepenalty=1000\clearpage{}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{mathtools}
\usepackage{todonotes}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\usepackage{ulem}
\usepackage{authblk}
\usepackage[noabbrev,capitalise]{cleveref}
\usepackage{subfig}
\usepackage{floatrow}
\floatsetup[table]{capposition=top}
\title{Putting An End to End-to-End: \\ Gradient-Isolated Learning of Representations}


\author{
    Sindy L\"owe\thanks{equal contribution} \hspace*{2em}Peter O'Connor  \hspace*{2em}Bastiaan S. Veeling$^*$ \\
    AMLab \\
    University of Amsterdam\\
    \texttt{loewe.sindy@gmail.com, basveeling@gmail.com}\\
}
\begin{document}

\newcolumntype{Y}{>{\centering\arraybackslash}X}
\maketitle






\begin{abstract}
We propose a novel deep learning method for local self-supervised representation learning that does not require labels nor end-to-end backpropagation but exploits the natural order in data instead. Inspired by the observation that biological neural networks appear to learn without backpropagating a global error signal, we split a deep neural network into a stack of gradient-isolated modules. Each module is trained to maximally preserve the information of its inputs using the InfoNCE bound from \citet{oord2018representation}. Despite this greedy training, we demonstrate that each module improves upon the output of its predecessor, and that the representations created by the top module yield highly competitive results on downstream classification tasks in the audio and visual domain. The proposal enables optimizing modules asynchronously, allowing large-scale distributed training of very deep neural networks on unlabelled datasets. 




\end{abstract}



\section{Introduction}

Modern deep learning models are typically optimized using end-to-end backpropagation and a global, supervised loss function. Although empirically proven to be highly successful \citep{krizhevsky2012imagenet,szegedy2015going}, 
this approach is considered biologically implausible. For one, supervised learning requires large labeled datasets to ensure generalization. In contrast, children can learn to recognize a new category based on a handful of samples. Additionally, despite some evidence for top-down connections in the brain, there does not appear to be a global objective that is optimized by backpropagating error signals \citep{crick1989recent,marblestone2016toward}. Instead, the biological brain is highly modular and learns predominantly based on local information \citep{caporale2008spike}.

In addition to lacking a natural counterpart, the supervised training of neural networks with end-to-end backpropagation suffers from practical disadvantages as well. 
Supervised learning requires labeled inputs, which are expensive to obtain. As a result, it is not applicable to the majority of available data, and suffers from a higher risk of overfitting, as the number of parameters required for a deep model often exceeds the number of labeled datapoints at hand.
At the same time, end-to-end backpropagation creates a substantial memory overhead in a na\"ive implementation, as the entire computational graph, including all parameters, activations and gradients, needs to fit in a processing unit's working memory. Current approaches to prevent this require either the recomputation of intermediate outputs \citep{salimans2017gradient} or expensive reversible layers \citep{Jacobsen2018-ra}. This inhibits the application of deep learning models to high-dimensional input data that surpass current memory constraints. This problem is perpetuated as end-to-end training does not allow for an exact way of asynchronously optimizing individual layers \citep{jaderberg2017decoupled}. In a globally optimized network, every layer needs to wait for its predecessors to provide its inputs, as well as for its successors to provide gradients. This forward and backward locking of the network caused by the backpropagation algorithm impedes the efficiency of hardware accelerator design due to a lack of locality. 





In this paper, we introduce a novel learning approach, \textit{Greedy InfoMax} (GIM), that improves upon these problems. Drawing inspiration from biological constraints, we remove end-to-end backpropagation by dividing a deep architecture into gradient-isolated modules that we train using a greedy, self-supervised loss per module. Given unlabeled high-dimensional sequential or spatial data, we encode it iteratively, module by module. By using a loss that enforces the individual modules to maximally preserve the information of their inputs, we enable the stacked model to collectively create compact representations that can be used for downstream tasks. Our contributions are as follows:\footnote[1]{Our code is available at \href{https://github.com/loeweX/Greedy_InfoMax}{https://github.com/loeweX/Greedy\_InfoMax}.}
\begin{itemize}
	\item
	The proposed Greedy InfoMax algorithm achieves strong performance on audio and image classification tasks despite greedy self-supervised training. 

	\item
	This enables asynchronous, decoupled training of neural networks, allowing for training arbitrarily deep networks on larger-than-memory input data.
	
    \item We show that mutual information maximization is especially suited for layer-by-layer greedy optimization, and argue that this reduces the problem of vanishing gradients.
    






\end{itemize}

\begin{figure*}[t!]
\centering
\includegraphics[width=0.99\linewidth]{figures/architecture.pdf}
    \caption{The Greedy InfoMax Learning Approach. \textbf{(Left)} For the self-supervised learning of representations, we stack a number of modules through which the input is forward-propagated in the usual way, but gradients do not propagate backward. Instead, every module is trained greedily using a local loss. \textbf{(Right)} Every encoding module maps its inputs $z_t^{m-1}$ at time-step $t$ to $g_{enc}^m(\gradblock(\zt^{m-1})) = z_t^{m}$, which is used as the input for the following module. The InfoNCE objective is used for its greedy optimization. This loss is calculated by contrasting the predictions of a module for its future representations $\ztk^m$ against negative samples $z_j^m$, which enforces each module to maximally preserve the information of its inputs. We optionally employ an additional autoregressive module $g_{ar}$, which is not depicted here.}
    \label{fig:infomax}
\end{figure*} 

\section{Background}
\label{sec:CPC}
In order to create compact representations from data that are useful for downstream tasks, we assume that natural data exhibit so-called \textit{slow features} \citep{Wiskott2002-dn}. It is theorized that such features are highly effective for downstream tasks such as object detection or speech recognition. To illustrate: a patch of a few milliseconds of raw speech utterances shares information with neighboring patches such as the speaker identity, emotion, and phonemes, while it does not necessarily share these with random patches drawn from other utterances. Similarly, a small patch from a natural image shares many aspects with neighboring patches such as the depicted object or lighting conditions. 

Recent work \citep{oord2018representation,hjelm2018learning} has proposed how we can exploit this to learn representations that maximize the \textit{mutual information} shared among neighbors. In this work, we focus specifically on Contrastive Predictive Coding (CPC) \citep{oord2018representation}. This self-supervised end-to-end learning approach extracts useful representations from sequential inputs by maximizing the mutual information between the extracted representations of temporally nearby patches.

In order to achieve this, CPC first processes the sequential input signal $x$ using a deep encoding model $g_{enc}(x_t) = \zt$, and additionally produces a representation $c_t$ that aggregates the information of all patches up to time-step $t$ using an autoregressive model $g_{ar}(z_{0:t}) = c_t$. Then, the mutual information between the extracted representations $\ztk$ and $\ct$ of temporally nearby patches is maximized by employing a specifically designed global probabilistic loss: Following the principles of Noise Contrastive Estimation (NCE) \citep{gutmann2010noise}, CPC takes a bag $X=\{z_{t+k}, z_{j_1}, z_{j_2}, ... z_{j_{N-1}}\}$ for each delay $k$, with one ``positive sample'' $z_{t+k}$ which is the encoding of the input that follows $k$ time-steps after $c_t$, and $N-1$ ``negative samples'' $z_{j_n}$ which are uniformly drawn from all available encoded input sequences.

Each pair of encodings $(z_j, c_t)$ is scored using a function $f(\cdot)$ to predict how likely it is that the given $z_j$ is the positive sample $z_{t+k}$. In practice, \citet{oord2018representation} use a log-bilinear model $f_k(z_j, c_t) = \exp \left(z_j^T \Wk \ct\right)$
with a unique weight-matrix $\Wk$ for each $k$-steps-ahead prediction. The scores from $f(\cdot)$ are used to predict which sample in the bag $X$ is correct, leading to the InfoNCE loss:
\begin{align}\label{eq:infonce}
    \loss &= - \sum_k \expectation_X \left[ \log \frac{\fkzc}{\sum_{z_j \in X} f_k(z_j, \ct)} \right] .
\end{align}
This loss is used to optimize both the encoding model $g_{enc}$ and the auto-regressive model $g_{ar}$ to extract the features that are consistent over neighboring patches but which diverge between random pairs of patches. At the same time, the scoring model $f_k$ learns to use those features to correctly classify the matching pair. In practice, the loss is trained using stochastic gradient descent with mini-batches drawn from a large dataset of sequences, and negative samples drawn uniformly from all sequences in the minibatch. Note, that no min-max issues arise as found in adversarial training.

As a result of this configuration, one can derive that the optimal solution for $f$ is proportional to the following density ratio \citep{oord2018representation}:
\begin{align}
    \fkzc &\propto \frac{p(\ztk|\ct)}{p(\ztk)} . \label{eq:density_ratio}
\end{align}
This insight allows us to reformulate $-\loss$ as a lower bound on the mutual information $I(\ztk, \ct)$, as demonstrated in the appendix of \citet{oord2018representation} and proven by \citet{poolevariational}. Minimizing the loss $\loss$ thus optimizes the mutual information between consecutive patch representations $I(\ztk, \ct)$, which in itself lower bounds the mutual information $I(\xtk, \ct)$ between the future input $\xtk$ and the current representation $\ct$. \cite{hyvarinen2016unsupervised} show that a similar patch-contrastive setup leads to the extraction of a set of conditionally-independent components, such as Gabor-like filters found in the early biological vision system.


\paragraph{Layer-wise Information Preservation in Neuroscience}
\citet{linsker1988self} developed the InfoMax principle in 1988. It theorizes that the brain learns to process its perceptions by maximally preserving the information of the input activities in each layer. On top of this, neuroscience suggests that the brain predicts its future inputs and learns by minimizing this prediction error \citep{friston2010free}. Empirical evidence indicates, for example, that retinal cells carry significant mutual information between the current and the future state of their own activity \citep{palmer2015predictive}. \citet{rao1999predictive} indicate that this process may happen at each layer within the brain. Our proposal draws motivation from these theories, resulting in a method that learns to preserve the information between the input and the output of each layer by learning representations that are predictive of future inputs.
 \begin{figure}
    \centering
\includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_3_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_3_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_50_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_50_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_18_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_18_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_96_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_0_neuron_96_patch.png}
\\
        \vspace{.5em}


        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_18_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_18_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_43_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_43_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_51_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_51_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_63_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_1_neuron_63_patch.png}
\\
        \vspace{.5em}
\includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_3_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_3_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_12_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_12_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_31_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_31_patch.png}
        \hfill
        \includegraphics[trim=2 68 2 4,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_51_patch.png}
        \hspace{-4pt}
        \includegraphics[trim=2 4 2 68,clip,width=0.12\textwidth]{figures/GIM_gray/layer_2_neuron_51_patch.png}
\caption{Groups of 4 image patches that excite a specific neuron, at \textit{3} levels in the model (\textbf{rows}). Despite unsupervised greedy training, neurons appear to extract increasingly semantic features. Best viewed on screen.}
    \label{fig:activate}
\end{figure} 

\section{Greedy InfoMax} \label{sec:decouple}


In this paper, we pose the question if we can effectively optimize the mutual information between representations at each layer of a model in isolation, enjoying the many practical benefits that greedy training (decoupled, isolated training of parts of a model) provides. In doing so, we introduce a novel approach for self-supervised representation learning: Greedy InfoMax (GIM). As depicted on the left side of \cref{fig:infomax}, we take a conventional deep learning architecture and divide it by depth into a stack of $M$ modules. This decoupling can happen at the individual layer level or, for example, at the level of blocks found in residual networks \citep{he2016identity}. Rather than training this model end-to-end, we prevent gradients from flowing between modules and employ a local self-supervised loss instead, additionally reducing the issue of vanishing gradients.



As shown on the right side of \cref{fig:infomax}, each encoding module $g_{enc}^m$ within our architecture maps the output from the previous module $\zt^{m-1}$ to an encoding $\zt^m = g_{enc}^m(\gradblock(\zt^{m-1}))$. No gradients are flowing between modules, which is enforced using a gradient blocking operator defined as  $\gradblock(x) \triangleq x, \nabla\gradblock(x) \triangleq 0$. \citet{oord2018representation} propose to use the output of an autoregressive model $g_{ar}(z_{0:t}) = c_t$ to contrast against future predictions $\ztk$. However, our preliminary results showed that this did not improve results if applied at every module in the stack and optimizing it requires backpropagation through time, which is considered biologically implausible. Therefore, we train each module $g_{enc}^m$ using the following module-local InfoNCE loss: \begin{align}\label{eq:logbi2}
f_k^m(\ztk^m, \zt^m) &= \exp \left({\ztk^m}^T \Wk^m \zt^m\right) \\
    \loss^m &= - \sum_k \expectation_X \left[ \log \frac{f_k^m(\ztk^m, \zt^m)}{\sum_{z^m_j \in X} f_k^m(z_j^m, \zt^m)} \right] .\label{eq:infoncegreedy}
\end{align}
After convergence of all modules, the scoring functions $f_k^m(\cdot)$ can be discarded, leaving a conventional feed-forward neural network architecture that extracts features $z^M_t$ for downstream tasks:
\begin{align}
    z^M_t &= g_{enc}^M\left(g_{enc}^{M-1}\left(\cdots g_{enc}^{1}\left(x_t\right)\right)\right) .
\end{align}

For certain downstream tasks, a broad context is essential. For example, in speech recognition, the receptive field of $z_t^M$ might not carry enough information to distinguish phonetic structures. To provide this context, we reintroduce the autoregressive model $g_{ar}$ as an independent module that we optionally append to the stack of encoding modules, resulting in a context-aggregate representation $\ct^M = g_{ar}^M\left(\gradblock\left(z^{M-1}_{0:t}\right)\right)$. In practice, a GRU or PixelCNN-style model can serve in this role. We train this module independently using the following altered scoring function:
\begin{align}
f_k^M(\ztk^{M-1}, \ct^{M}) &= \exp \left(\gradblock\left({\ztk^{M-1}}\right)^T \Wk^M \ct^{M}\right).
\end{align}

\paragraph{Iterative Mutual Information Maximization}

Similarly to the InfoNCE loss in \cref{eq:infonce}, our module-local InfoNCE loss in \cref{eq:infoncegreedy} maximizes a lower bound on the mutual information $I(\ztk^m, \zt^m)$ between nearby patch representations, encouraging the extraction of slow features. 


Most importantly, it follows from \citet{oord2018representation}, that the module-local InfoNCE loss also maximizes the lower bound of the mutual information $I(\ztk^{m-1}, \zt^m)$ between the future input to a module and its current representation. This can be seen as a maximization of the mutual information between the input and the output of a module, subject to the constraint of temporal disparity. Thus, the InfoNCE loss can successfully enforce each module to maximally preserve the information of its inputs, while providing the necessary regularization \citep{krause2010discriminative,hu2017learning} for circumventing degenerate solutions. These factors contribute to ensuring that the greedily optimized modules provide meaningful inputs to their successors and that the network as a whole provides useful features for downstream tasks without the use of a global error signal. 

\paragraph{Practical Benefits}
Applying GIM to high-dimensional inputs, we can optimize each module in sequence to decrease the memory costs during training. In the most memory-constrained scenario, individual modules can be trained, frozen, and their outputs stored as a dataset for the next module, which effectively removes the depth of the network as a factor of the memory complexity.

Additionally, GIM allows for training models on larger-than-memory input data with architectures that would otherwise exceed memory limitations. Leveraging the conventional pooling and strided layers found in common network architectures, we can start with small patches of the input, greedily train the first module, extract the now compressed representation spanning larger windows of the input and train the following module using these.

Last but not least, GIM provides a highly flexible framework for the training of neural networks. It enables the training of individual parts of an architecture at varying update frequencies. When a higher level of abstraction is needed, GIM allows for adding new modules on top at any moment of the optimization process without having to fine-tune previous results.


%
 

\section{Experiments}

\begin{figure}[t]
\begin{floatrow}
\ttabbox[0.53\textwidth]{\small
    \begin{tabularx}{\linewidth}{p{4.6cm}Y}
    \toprule
    Method & Accuracy $(\%)$ \\
    \midrule
Deep InfoMax \citep{hjelm2018learning} & $78.2$ \\
Predsim \citep{nokland2019training} & $80.8$\\
    \midrule
Randomly initialized & $27.0$ \\ Supervised & $71.4$ \\Greedy Supervised & $65.2$ \\
        CPC & $80.5 \pm 3.1$ \\ \midrule
\textbf{Greedy InfoMax (GIM)} & $\mathbf{81.9} \pm 0.3 $ \\ \bottomrule
    \end{tabularx} 
}{\caption{STL-10 classification results on the test set. The GIM model outperforms the CPC model, despite a lack of end-to-end backpropagation and without the use of a global objective. ($\pm$ standard deviation over 4 training runs.)}\label{tab:stl10}
}
\ttabbox[0.43\textwidth]{\small
    \begin{tabularx}{\linewidth}{p{2.6cm}Y}
      \toprule
      Method & GPU memory (GB) \\
      \midrule
        Supervised & 6.3 \\
CPC & 7.7 \\
        \midrule
        GIM - all modules & 7.0 \\
        GIM - 1st module & \textbf{2.5} \\
    \bottomrule
    \end{tabularx} 
}{\caption{GPU memory consumption during training. All models consist of the ResNet-50 architecture and only differ in their training approach. GIM allows efficient greedy training.}\label{tab:memory}
}
\end{floatrow}
\end{figure}

We test the applicability of the GIM approach to the visual and audio domain. In both settings, a feature-extraction model is divided by depth into modules and trained without labels using GIM. The representations created by the final (frozen) module are then used as the input for a linear classifier, whose accuracy scores provide us with a proxy for the quality and generalizability of the representations created by the self-supervised model.

\subsection{Vision} \label{sec:vision}
To apply Greedy InfoMax to natural images, we impose a top-down ordering on 2D images. We follow \citet{oord2018representation,Henaff2019-nb} by extracting a grid of partly-overlapping patches from the image to restrict the receptive fields of the representations. For each patch $x_{i,j}$ in row $i$ and column $j$ of this grid, we predict up to K patches $x_{i+K,j}$ in the rows underneath, skipping the first overlapping patch $x_{i+1,j}$. Random contrastive samples are drawn with replacement from all samples available inside a batch, using 16 contrastive samples for each evaluation of the loss. No autoregressive module $g_{ar}$ is used for GIM in this regime.

\paragraph{Experimental Details} We focus on the STL-10 dataset \citep{coates2011analysis} which provides an additional unlabeled training dataset. For data augmentation, we take random $64 \times 64$ crops from the $96 \times 96$ images, flip horizontally with probability $0.5$ and convert to grayscale. We divide each image of $64 \times 64$ pixels into a total of $7 \times 7$ local patches, each of size $16 \times 16$ with 8 pixels overlap. The patches are encoded by a ResNet-50 v2 model \citep{he2016identity} without batch normalization \citep{ioffe2015batch}. We split the model into three gradient-isolated modules that we train in sync and with a constant learning rate. After convergence, a linear classifier is trained -- without finetuning the representations -- using a conventional softmax activation and cross-entropy loss. This linear classifier accepts the patch representations $z^M_{i,j}$ from the final module and first  average-pools these, resulting in a single vector representation $z^M$.  Remaining implementation details are presented in \cref{app:vision}.


\paragraph{Results} As shown in \cref{tab:stl10}, \textit{Greedy InfoMax (GIM)} outperforms its end-to-end trained \textit{CPC} counterpart, despite its unsupervised features being optimized greedily without any backpropagation between modules. An equivalent \textit{randomly initialized} feature extraction model exhibits poor performance, showing that GIM extracts useful features. Training the feature extraction model end-to-end and fully \textit{supervised} performs worse, likely due to the small size of the annotated dataset resulting in overfitting. Although this could potentially be circumvented through regularization techniques \citep{devries2017improved}, the self-supervised methods do not appear to require regularization as they benefit from the full unlabeled dataset. Using a \textit{greedy supervised} approach for training the feature model impedes performance, which suggests that mutual information maximization is unique in its direct applicability to greedy optimization.

In comparison with the recently proposed
\textit{Deep InfoMax} model from \citet{hjelm2018learning} which uses a slightly different end-to-end mutual information maximization approach, AlexNet \citep{krizhevsky2012imagenet} as their feature-extraction model and an additional hidden layer in the supervised classification model, GIM comes out favorably. Finally, we see that we outperform the state-of-the-art biologically inspired \textit{Predsim} model from \citet{nokland2019training}, which trains individual layers of a VGG like architecture \citep{simonyan2014very} using two supervised loss functions. 

In \cref{fig:activate}, we visualize patches that neurons in intermediate modules of the GIM model are sensitive to. This demonstrates that modules later in the model focus on increasingly abstract features. Overall, the results demonstrate that complicated visual tasks can be approached using greedy self-supervised optimization, which can utilize large-scale unlabeled datasets. 










\begin{figure*}[t]
    \centering
    \subfloat[][First Module\label{fig:first_mod}]{
        \includegraphics[width=0.32\textwidth]{figures/loss_curves_0.pdf}}
        \hfill
    \subfloat[][Second Module\label{fig:second_mod}]{
        \includegraphics[width=0.32\textwidth]{figures/loss_curves_1.pdf}}
        \hfill
    \subfloat[][Third Module\label{fig:third_mod}]{
        \includegraphics[width=0.32\textwidth]{figures/loss_curves_2.pdf}}
    \caption{Training curves for optimizing all modules \textit{simultaneously} (blue) or \textit{iteratively}, one at a time (red). While there is no difference in the training methods for the first module (\textbf{a}), later modules (\textbf{b, c}) start out with a lower loss and tend to overfit more when trained iteratively on top of already converged modules. }
    \label{fig:loss}
\end{figure*}


\paragraph{Asynchronous memory usage}
GIM provides a significant practical advantage arising from the greedy nature of optimization: modules can be trained in isolation given cached outputs from previous modules, effectively removing the depth of the network as a factor of the memory complexity. Measuring the allocated GPU memory of the previously studied models during training (\cref{tab:memory}), indicates that this theoretical benefit holds in practice as well. After splitting the architecture into three separately trainable modules, we can reduce the GPU memory consumption by a factor of 2.8 by training the modules asynchronously (\textit{GIM - 1st module}) compared to training them simultaneously (\textit{GIM - all modules}).

We evaluate whether training modules asynchronously influences the quality of the representations. Focusing on the extreme case, we optimize each module until convergence and fix its parameters, before we train the next module on top of it. This \textit{iteratively} trained model achieves an accuracy of $79.8\%$ on the image classification downstream task. Thus, the performance declines slightly in comparison to the \textit{simultaneously} trained model, as previously shown in \cref{tab:stl10} with $81.9\%$ accuracy. 

The training curves of the two models as shown in \cref{fig:loss} provide some insight into this decreased performance. The learning curves of the first module (\cref{fig:first_mod}) reflect that there is no difference in its training in the two models. Modules two and three (\cref{fig:second_mod,fig:third_mod}), however, reveal a crucial difference. The \textit{iteratively} trained modules show a larger divergence between the training and validation loss, indicating stronger overfitting. We tentatively attribute this to the regularizing effect from the initially noisy inputs received by the higher modules when training simultaneously. 




\subsection{Audio} 
\label{sec:InfoMaxResults}

\begin{table*}[t]
\caption[Speaker Identity and Phone Classification Results]{Results for classifying speaker identity and phone labels in the LibriSpeech dataset. All models use the same audio input sizes and the same architecture. Greedy InfoMax creates representations that are useful for audio classification tasks despite its greedy training and lack of a global objective.}
\label{tab:audio_results}
        \small
        \centering
        \begin{tabularx}{\textwidth}{p{5cm}YY}
            \toprule
            \makecell[l]{~ \\ Method \\ ~ } & \makecell{Phone \\Classification \\ Accuracy $(\%)$} & \makecell{Speaker \\Classification \\ Accuracy $(\%)$} \\
            \midrule
                Randomly initialized $^b$ & $27.6$ & $1.9$ \\
                MFCC features $^b$ & $39.7$ & $17.6$ \\
                Supervised & $77.7$ & $98.9$ \\ Greedy Supervised & $73.4$ & $98.7$ \\ CPC \citep{oord2018representation} \footnote{In the original implementation, \citet{oord2018representation} achieved $64.6\%$ for the phone and $97.4\%$ for the speaker classification task. $^b$Baseline results from \citet{oord2018representation}.}
& $64.9$ & $99.6$ \\
                \midrule
                Greedy InfoMax (GIM) & $62.5$ & $99.4$ \\ \bottomrule
        \end{tabularx} 
\end{table*}

We evaluate GIM in the audio domain on the sequence-global task of \textit{speaker} classification and the local task of \textit{phone} classification (distinct phonetic sounds that make up pronunciations of words). These two tasks are interesting for self-supervised representation learning as the former requires representations that discriminate speakers but are invariant to content, while the latter requires the opposite. Strong performance on both tasks thus suggests strong generalization and disentanglement.

\paragraph{Experimental Details}
We follow the setup of \citet{oord2018representation} unless specified otherwise and use a 100-hour subset of the publicly available LibriSpeech dataset \citep{panayotov2015librispeech}. It contains the utterances of 251 different speakers with aligned phone labels divided into 41 classes. These phone labels were provided by \citet{oord2018representation} who obtained them by force-aligning phone sequences using the Kaldi toolkit \citep{povey2011kaldi} and pre-trained models on Librispeech \citep{kaldi_model}.
We first train the self-supervised model consisting of five convolutional layers and one autoregressive module, a single-layer gated recurrent unit (GRU). After convergence, a linear multi-class classifier is trained on top of the context-aggregate representation $c^M$ without fine-tuning the representations. Remaining implementation details are presented in \cref{app:audio}. 

\paragraph{Results} 
Following \Cref{tab:audio_results}, we analyze the performance of models on phone and speaker classification accuracy. \textit{Randomly initialized} features perform poorly, demonstrating that both tasks require complex representations. The traditional, hand-engineered \textit{MFCC features} are commonly used in speech recognition systems \citep{ganchev2005comparative}, and improve over the random features, but provide limited linear separability on both tasks. On the speaker classification task, \textit{CPC} and \textit{GIM} outperform the \textit{supervised} baselines despite their feature models having been trained without labels, and GIM without end-to-end backpropagation. In this setting, both \textit{GIM} and \textit{Greedy Supervised}, where individual layers are trained greedily with a supervised loss function, achieve similar results to their respective end-to-end trained counterparts (\textit{CPC} and \textit{Supervised}). When classifying phones, \textit{CPC} does not reach the supervised performance ($64.9\%$ versus $77.7\%$). \textit{GIM} achieves $62.5\%$, while \textit{Greedy Supervised} accomplishes $73.4\%$. Thus, in contrast to the vision experiments (\cref{sec:vision}), we see similar differences in performance between the greedily trained models (\textit{GIM} and \textit{Greedy Supervised}) when compared to their respective end-to-end optimized counterparts (\textit{CPC} and \textit{Supervised}). 

Overall, the discrepancy between better-than-supervised performance on the speaker task and less-than-optimal performance on the phone task suggests that GIM and CPC are biased towards extracting sequence-global features.









\newfloatcommand{capbtabbox}{table}[][0.35\textwidth]
\begin{figure}
\begin{floatrow}
\capbtabbox{\small
\begin{tabularx}{\linewidth}{p{3cm}Y}\toprule
        Method & Accuracy $(\%)$  \\
        \midrule
        \multicolumn{2}{l}{\textbf{Speaker Classification}} \\
        Greedy InfoMax (GIM) & $99.4$ \\
GIM without BPTT & $99.2$ \\ GIM without $g_{ar}$ & $99.1$ \\
\midrule
        \multicolumn{2}{l}{\textbf{Phone Classification}} \\
        Greedy InfoMax (GIM) & $62.5$ \\
GIM without BPTT & $55.5$ \\
        GIM without $g_{ar}$ & $50.8$ \\ \bottomrule
    \end{tabularx}
    \vspace{2em}
}{\caption{Ablation studies on the LibriSpeech dataset for removing the biologically implausible and memory-heavy backpropagation through time.}\label{tab:ablation}
}\hfill
\ffigbox[0.59\textwidth]{\includegraphics[width=0.8\columnwidth]{figures/latent_accuracy.pdf}}{\vspace{-0.5em}
  \caption{Speaker Classification error rates on a log scale (lower is better) for intermediate representations (layers 1 to 5), as well as for the final representation created by the autoregressive layer (corresponding to the results in \cref{tab:audio_results}). 
}\label{fig:intermediate}
}
\end{floatrow}
\end{figure}



\paragraph{Ablation study}
The local greedy training enabled by GIM provides a step towards biologically plausible optimization and improves memory efficiency. However, the autoregressive module $g_{ar}$ aggregates  its inputs over multiple patches and employs Backpropagation Through Time (BPTT), which puts a damper on both benefits. In \cref{tab:ablation}, we present results on the performance of ablated models that restrict the flow of gradients through time. 

In order to limit the flow of gradients through time, we modify the autoregressive module. In general, the autoregressive module $g_{ar}$ takes the current input $z_t$, as well as the hidden state of the previous time-step $h_{t-1}$, in order to produce its output $c_t$, i.e. $c_t = g_{ar}(z_t, h_{t-1})$ (omitting the module-index $m$ here for brevity). In the standard GIM model, we block the flow of gradients to the previous module, such that $c_t = g_{ar}(\gradblock(z_t), h_{t-1})$. In the ablation \textit{GIM without BPTT}, we remove BPTT by blocking the flow of gradients between time-steps, such that $c_t = g_{ar}(\gradblock(z_t), \gradblock(h_{t-1}))$. For the ablation \textit{GIM without $g_{ar}$}, we remove the autoregressive module entirely. Here, the linear classifier is applied to the representation created by the last encoding module (i.e. $z_t$).

In \cref{tab:ablation}, we present the performance of the ablated models. Together, these two ablations indicate a crucial difference between the tested downstream tasks. For the phone classification task, we see a steady decline of the performance when we reduce the modeling of temporal dependencies, indicating their importance for solving this task. When classifying the speaker identity, reducing the modeling of temporal dependencies in the ablated models barely influences their performance.

Together with the image classification results from \cref{sec:vision}, where no autoregressive module was employed either, this indicates that the GIM approach performs best on downstream tasks where temporal or context dependencies do not need to be modeled by an autoregressive module. In these settings, GIM can outperform the CPC model, which makes use of end-to-end backpropagation, a global objective, and BPTT. 












\paragraph{Intermediate module representations}
The greedy layer-wise training of GIM allows us to train arbitrarily deep models without ever running into a memory constraint. We investigate how the created representations develop in each individual module by training a linear classifier on top of each module and measuring their performance on the speaker classification task. With results presented in \cref{fig:intermediate}, we first observe that each GIM module improves upon the representations of their predecessor. Interestingly, CPC exhibits similar performance in intermediate modules despite these modules relying solely on the error signal from the global loss function on the last module. This is in stark contrast with the supervised end-to-end model, whose intermediate layers lag behind their greedily trained counterparts. This suggests that, in contrast to the supervised loss, the InfoMax principle ``stacks well'', such that the greedy, iterative application of the InfoNCE loss performs similar to its global application.



















%
 

\section{Related Work}\label{sec:literature}
We have studied the effectiveness of the self-supervised CPC approach \citep{oord2018representation,Henaff2019-nb} when applied to gradient-isolated modules, freeing the method from end-to-end backpropagation. 
There are a number of optimization algorithms that eliminate the need for backpropagation altogether \citep{scellier2017equilibrium,lillicrap2016random,kohan2018error,balduzzi2015kickback,lee2015difference, ororbia2018conducting,xiao2018biologically}. In contrast to our method, these methods employ a global supervised loss function and focus on finding more biologically plausible ways to assign credit to neurons.



A recently published work by \cite{nokland2019training} likewise demonstrates that backpropagation-free layer-wise training is possible. Their similarity loss might be vaguely interpreted as another way of enforcing clustered representations. However, while our method achieves this entirely in a self-supervised fashion by clustering temporally or spatially nearby inputs, their similarity loss groups representations based on their class labels. Likewise, \citet{belilovsky2019greedy} showed that greedy layer-wise training with a supervised loss can scale to ImageNet. In an attempt to validate information bottleneck theory, \citet{elad2018effectiveness} develop a supervised, layer-wise training method that maximizes the mutual information between the outputs of a layer and the target whilst minimizing the mutual information between the inputs and outputs. In contrast to our proposal, these methods all rely on labeled data.

\citet{jaderberg2017decoupled} develop decoupled neural interfaces, which enjoy the same asynchronous training benefits as Greedy InfoMax (GIM), but achieve this by taking an end-to-end supervised loss and locally predicting its gradients. \citet{hinton2006fast, bengio2007greedy} focus on deep belief networks and propose a greedy layer-wise unsupervised pretraining method based on Restricted Boltzmann Machine principles, followed by optimizing globally using a supervised loss. \citet{lee2009unsupervised} use convolutional deep belief networks for unsupervised pretraining on the TIMIT audio dataset and then evaluate their performance by training supervised classifiers on top.  \citet{Gao2018-zv,Ver_Steeg2015-ce} explore total correlation explanation, which is related to mutual information maximization, and show that it can be applied for layer-by-layer training. 



Several recent works investigated the utilization of mutual information maximization in a representation learning setting \citep{mcallester2018information,oord2018representation,hjelm2018learning,belghazi2018mine}. \citet{poolevariational} analyse these recent works under a common framework and highlight that InfoNCE exhibits low variance at a cost of high bias and propose new lower bounds that allow for balancing this bias/variance trade-off. However, the analysis of these improved bounds in the context of inter-patch mutual information optimization remains in order, and thus we focus on the original CPC InfoNCE loss to bias the learned representations towards slow features \citep{Wiskott2002-dn}.

Outside the information-theoretic framework, context prediction methods have been explored for unsupervised representation learning. A prominent approach in language processing is Word2Vec \citep{Mikolov2013-zv}, in which a word is directly predicted given its context (continuous skip-gram). Likewise, \cite{Doersch2015-ku} study such an approach for the visual domain. Similarly, graph neural networks use contrastive principles to learn unsupervised node embeddings based on their neighbors \citep{Nickel2011-ri,Perozzi2014-tb,Nickel2015-ja,Kipf2016-ha,Velickovic2018-cb}. Noise contrastive estimation has also been explored for independent component analysis \citep{Hyvarinen2018-jp, hyvarinen2016unsupervised, Hyvarinen2017-td}. \cite{Schmidhuber1992-dx} proposes a method where individual features are minimized such that they cannot be predicted from other features, forcing them to extract independent factors that carry statistical information, at the risk of neurons latching onto local independent noise sources in the input.




 

\section{Conclusion}
We presented Greedy InfoMax, a novel self-supervised greedy learning approach. The relatively strong performance demonstrates that deep neural networks do not necessarily require end-to-end backpropagation of a supervised loss on perceptual tasks. Our proposal enables greedy self-supervised training, which makes the model less vulnerable to overfitting, reduces the vanishing gradient problem and enables memory-efficient asynchronous distributed training. While the biological plausibility of our proposal is limited by the use of negative samples and within-module backpropagation, the results provide evidence that the theorized self-organization in biological perceptual networks is at least feasible and effective in artificial networks, providing food for thought on the credit assignment discussion in perceptual networks \citep{bengio2015towards,linsker1988self}.











 
\subsubsection*{Acknowledgments}
We thank Jorn Peters, Marco Federici, Rudy Corona, Pascal Esser, Joop Pascha and the anonymous reviewers for their insightful comments. This research was supported by Philips Research and the NVIDIA GPU Grant.

\bibliographystyle{IEEEtranN}
\bibliography{bibliography}

\newpage
\appendix
\section{Experimental Setup}

We use PyTorch \citep{paszke2017automatic} for all our experiments.


\subsection{Vision Experiments}
\label{app:vision}
In our vision experiments, we employ the ResNet-50 v2 architecture \citep{he2016identity}, in which we remove the max-pooling layer and adjust the first convolutional layer in such a way that the size of the feature map stays constant. Thus, the first convolutional layer uses a kernel size of 5, a stride of 1 and a padding of 2. Additionally, we do not employ batch normalization \citep{ioffe2015batch}.

We train our model on 8 GPUs (GeForce 1080 Ti) each with a minibatch of 16 images. We train it for 300 epochs using Adam \citep{kingma2014adam} and a learning rate of 1.5e-4 and use the same random seed in all our experiments.

For the self-supervised training using the InfoNCE objective, we need to contrast the predictions of the model for its future representations against negative samples. We draw these samples uniformly at random from across the input batch that is being evaluated. Thus, the negative samples can contain samples from the same image at different patch locations, as well as from different images. We found that including the positive sample (i.e. the future representation that is currently to be predicted) in the negative samples did not have a negative effect on the final performance. For each evaluation of the InfoNCE loss, we use 16 negative samples and predict up to $k=5$ rows into the future. For contrasting patches against one another, we spatially mean-pool the representations of each patch.

Before applying the linear logistic regression classifier on the output of the third residual block, we spatially mean-pool the created representations of size $7 \times 7 \times 1024$ again. Thus, the final representation from which we learn to predict class labels is a 1024-dimensional vector. We use the Adam optimizer for the training of the linear logistic regression classifier and set its learning rate to 1e-3. We optimized this hyperparameter by splitting the labeled training set provided by the STL-10 dataset into a validation set consisting of $20\%$ of the images and a corresponding training set with the remaining images.

\subsection{Audio Experiments}\label{app:audio}

The detailed description of our employed architecture is given in \cref{tab:audio_arch}. We train our model on 4 GPUs (GeForce 1080 Ti) each with a minibatch of 8 examples. Our model is optimized with Adam and a learning rate of 2e-4 for 1000 epochs. We use the same random seed for all our experiments. Overall, our hyperparameters were chosen to be consistent with \citet{oord2018representation}.

\begin{table}[h!]
  \centering
\caption{General outline of our architecture for the audio experiments.} 
    \label{tab:audio_arch}
  	\begin{tabularx}{0.9\textwidth}{Y>{\centering\arraybackslash}p{4
  	cm}YYY}\toprule
      Layer & Output Size & \multicolumn{3}{c}{Parameters} \\
       & \small (Sequence Length $\times$ Channels) & Kernel & Stride & Padding \\
      \midrule
        Input & $20480 \times 1 $ & & & \\
        Conv1 & $4095 \footnote{\label{note1}For applying the InfoNCE objective on these layers, we randomly sample a time-window of size 128 to decrease the dimensionality.} \times 512$ & 10 & 5 & 2 \\
        Conv2 & $1023 \textsuperscript{\ref{note1}} \times 512$ & 8 & 4 & 2 \\
        Conv3 & $512 \textsuperscript{\ref{note1}} \times 512$ & 4 & 2 & 2 \\
        Conv4 & $257\textsuperscript{\ref{note1}} \times 512$ & 4 & 2 & 2 \\
        Conv5 & $128 \times 512$ & 1 & 2 & 1 \\
        GRU & $128 \times 256$ & - & - & - \\
     \bottomrule
  	\end{tabularx} 
\end{table}

Similarly to the vision experiments, we take the negative samples uniformly at random from across the batch that is currently evaluated. Again, this may include the positive sample. In our audio experiments, we use a total of 10 negative samples and predict up to $k=12$ time-steps into the future.



We train the linear logistic regression classifier using the representations of the top, autoregressive module without pooling. Again, we employ the Adam optimizer but select different learning rates than before. For this hyperparameter search, we split the training set provided by \citet{oord2018representation} into two random subsets using $25\%$ of the samples as a validation set. In the speaker classification experiment, we used a learning rate of 1e-3, while we set it to 1e-4 for the phone classification experiment.
















%
 
\end{document}
