\documentclass[envcountsame,numbook,smallextended]{svjour3}
\pdfoutput=1
\smartqed
\usepackage{amssymb,amsmath}
\usepackage{txfonts}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\hypersetup{colorlinks,allcolors=black}
\usepackage{microtype}
\usepackage{booktabs}
\usepackage[numbers,sort&compress]{natbib}
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\usepackage{tikz}
\newcommand{\shorten}[1]{}
\newcounter{mycounter}  
\newcommand{\reply}{ \\ \quad}   
\newenvironment{noindlist}
 {\begin{list}{(\roman{mycounter}) }{\usecounter{mycounter} \labelsep=0em \labelwidth=0em \leftmargin=0em \itemindent=\parindent \topsep=0em}}
 {\end{list}}

\pgfdeclarelayer{background}
\pgfsetlayers{background,main}


\usepackage{xcolor}
\usepackage{paralist}
\usepackage[textsize=scriptsize]{todonotes}
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\usepackage[sort&compress,noabbrev,capitalize]{cleveref}


\spnewtheorem{observation}[theorem]{Observation}{\bfseries}{\rmfamily}
\spnewtheorem{rrule}[theorem]{Reduction Rule}{\bfseries}{\rmfamily}
\spnewtheorem{construction}[theorem]{Construction}{\bfseries}{\rmfamily}
\Crefname{construction}{Construction}{Constructions}
\let\lemma\relax
\makeatletter\let\c@lemma\relax\makeatother
\spnewtheorem{lemma}[theorem]{Lemma}{\bfseries}{\rmfamily}
\Crefname{observation}{Observation}{Observations}
\Crefname{problem}{Problem}{Problems}
\Crefname{lemma}{Lemma}{Lemmas}
\Crefname{section}{Section}{Sections}
\Crefname{rrule}{Reduction Rule}{Reduction Rules}
\Crefname{figure}{Figure}{Figures}


\author{René van Bevern\thanks{René van Bevern is supported by grant 16-31-60007 mol\textunderscore{}a\textunderscore{}dk of the Russian Foundation for Basic Research.} \and 
Vincent Froese\and Christian~Komusiewicz\thanks{Christian Komusiewicz is supported by grant KO~3669/4-1 of Deutsche Forschungsgemeinschaft.}}

\date{\today{}}

\journalname{Theory of Computing Systems}

\institute{René van Bevern\at Novosibirsk State University, Novosibirsk, Russian Federation, \email{rvb@nsu.ru}
\at
Sobolev Institute of Mathematics, Siberian Branch of the Russian Academy of Sciences, Novosibirsk, Russian Federation
\and Vincent Froese\at Technische Universität Berlin, Germany, \email{vincent.froese@tu-berlin.de}
\and Christian Komusiewicz\at Friedrich-Schiller-Universität Jena, Germany, \email{christian.komusiewicz@uni-jena.de}}

\newcommand{\prob}[5]{\begingroup
  \par\medskip
  \noindent \textsc{#1}
  \par\noindent\hangindent=\parindent\textit{#2}  #3
  \par\noindent\hangindent=\parindent\textit{#4}  #5
  \par  \medskip
  \endgroup
}

\newcommand{\optprob}[3]{\prob{#1}{Instance:}{#2}{Task:}{#3}}

\crefname{property}{Property}{Properties}
\creflabelformat{property}{(#2#1#3)}
\crefname{corollary}{Corollary}{Corollaries}
\crefname{problem}{Problem}{Problems}
\newcommand{\decprob}[3]{\pagebreak[3]
  \begin{problem}[\boldmath#1]
    \begin{compactdesc}
        \item[\normalfont\it Input:] #2
        \item[\normalfont\it Question:] #3
    \end{compactdesc}
  \end{problem}
}

\newcommand{\abe}{\ensuremath{\Delta_E}}
\newcommand{\abv}{\ensuremath{\Delta_V}}
\newcommand{\occ}{\ensuremath{\alpha}}
\newcommand{\num}{\ensuremath{\gamma}}
\newcommand{\symdiff}{\triangle}
\newcommand{\true}{\ensuremath{\mathrm{true}}}
\newcommand{\false}{\ensuremath{\mathrm{false}}}
\newcommand{\ffed}{\textsc{-free Editing}}
\newcommand{\ffvd}{\textsc{-free Vertex Deletion}}
\newcommand{\ffedv}{\textsc{-free Editing with -Packing}}
\newcommand{\tffedv}{\textsc{-free Editing with Cost- Packing}}
\newcommand{\ffede}{\textsc{-free Editing with Edge-Disjoint Packing}}
\newcommand{\gfedv}[1]{\textsc{\ensuremath{#1}-free Editing with \ensuremath{#1}-Packing}}
\newcommand{\gfdev}[1]{\textsc{\ensuremath{#1}-free Deletion with \ensuremath{#1}-Packing}}
\newcommand{\gfede}[1]{\textsc{\ensuremath{#1}-free Editing with Edge-Disjoint \ensuremath{#1}-Packing}}
\newcommand{\gfdee}[1]{\textsc{\ensuremath{#1}-free Deletion with Edge-Disjoint \ensuremath{#1}-Packing}}
\newcommand{\gfedset}[1]{\ensuremath{#1}-free editing set}
\newcommand{\gfdeset}[1]{\ensuremath{#1}-free deletion set}
\newcommand{\packing}{\ensuremath{\mathcal H}}
\newcommand{\TAGP}{\textsc{Triangle Deletion with  Cost- Packing}}
\newcommand{\TATP}{\textsc{Triangle Deletion with  Triangle Packing}}
\newcommand{\TATPE}{\textsc{Triangle Deletion with Edge-Disjoint Triangle Packing}}
\newcommand{\CEGP}{\textsc{Cluster Editing with  Cost- Packing}}
\newcommand{\CEPP}{\textsc{Cluster Editing with  -Packing}}
\newcommand{\POITS}{\textsc{3-SAT}}
\newcommand{\realPOITS}{\textsc{Positive 1-in-3-SAT}}
\newcommand{\PLVD}{\textsc{\ensuremath{P_q}-free Vertex Deletion with  \ensuremath{P_q}-Packing}}
\newcommand{\FAST}{\textsc{Feedback Arc Set in Tournaments}}
\newcommand{\FASTTP}{\textsc{Feedback Arc Set in Tournaments with  Triangle Packing}}
\newcommand{\FASTGP}{\textsc{Feedback Arc Set in Tournaments with  Cost- Packing}}
\newcommand{\CEAE}{\textsc{Cluster Editing with Edge-Disjoint -Packing}}
\newcommand{\CEAV}{\textsc{Cluster Editing with  -Packing}}
\newcommand{\Time}{\ensuremath{\Gamma}}
\newcommand{\Wext}{\ensuremath{W_\text{ext}}}
\newcommand{\Wint}{\ensuremath{W_\text{int}}}
\title{Parameterizing edge modification problems\\above lower bounds\thanks{An extended abstract of this article appeared in Proceedings of the 11th International Computer Science Symposium in Russia, June 9–13, 2016, St.~Petersburg, Russian Federation~\citep{BFK16}.}}

\begin{document}

\maketitle
\pagestyle{plain}
\begin{abstract}
We study the parameterized complexity of a variant of the \ffed{} problem: Given a graph~ and a natural number~, is it possible to modify at most ~edges in~ so that the resulting graph contains no induced subgraph isomorphic to~?  In our variant, the input additionally contains a vertex-disjoint packing~ of induced subgraphs of~, which provides a lower bound~ on the number of edge modifications required to transform~ into an -free graph.  While earlier works used the number~ as parameter or structural parameters of the input graph~, we consider instead the parameter~, that is, the number of edge modifications above the lower bound~.  We develop a framework of generic data reduction rules to show fixed-parameter tractability with respect to~ for~\textsc{-Free Editing}, \textsc{Feedback Arc Set in Tournaments}, and \textsc{Cluster Editing} when the packing~ contains subgraphs with bounded solution size.  For~\textsc{-Free Editing}, we also prove NP-hardness in case of edge-disjoint packings of~s and~, while for \textsc{-Free Editing} and , NP-hardness for~ even holds for vertex-disjoint packings of~s.
In addition, we provide NP-hardness results for \ffvd{}, were the
  aim is to delete a minimum number of vertices to make the input
  graph -free.
\end{abstract}

\paragraph{Keywords.} NP-hard problem, fixed-parameter algorithm, subgraph packing, kernelization, graph-based clustering, feedback arc set, cluster editing
\section{Introduction}
Graph modification problems are a core topic
of algorithmic research~\cite{LY80,Cai96,Yan81}.
Given a graph~,
the aim is to transform~ by a minimum number of modifications
(like vertex deletions, edge deletions, or edge insertions)
into another graph~ fulfilling certain properties.
Particularly well-studied are \emph{hereditary} graph properties, which are closed under vertex deletions and are characterized by \emph{minimal forbidden induced subgraphs}: a graph fulfills such a property if and only if it does not contain a graph~ from a property-specific family~ of graphs as induced subgraph.  All nontrivial vertex deletion problems and many edge modification and deletion problems for establishing hereditary graph properties are NP-complete
\cite{LY80,Alon06,MK86,Yan81,ASS16}.  One approach to cope with the NP-hardness of these problems are \emph{fixed-parameter algorithms} that solve them in ~time for some exponential function~ depending only on some desirably small parameter~.   If the desired graph property has a finite forbidden induced subgraph characterization, then the corresponding vertex deletion, edge deletion, and edge modification problems are \emph{fixed-parameter tractable} parameterized by the number of modifications~, that is, solvable in ~time~\cite{Cai96}.

\paragraph{Parameterization above lower bounds.} When combined with data reduction and pruning rules, search-tree based fixed-parameter algorithms for the parameter~ of allowed modifications can yield competitive problem solvers~\cite{HH15,MNS12}.  Nevertheless, the number of modifications is often too large and smaller parameters are desirable.

A natural approach to obtain smaller parameters is ``parameterization above guaranteed values''~\cite{MR99,CPPW13,LNR+14,GP15}. The idea is to use a lower bound~ on the solution size and to use~ as parameter instead of~.
This idea has been applied successfully to \textsc{Vertex Cover}, the
problem of finding at most ~vertices such that
their deletion removes all edges (that is, all~s) from~. Since the size of a smallest vertex
cover is large in many input graphs, 
parameterizations above
the lower bounds ``size of a maximum
matching~ in the input graph'' and ``optimum value~ of the LP~relaxation of the standard ILP-formulation of \textsc{Vertex Cover}''
have been considered.
After a series of
improvements~\cite{RO09,CPPW13,LNR+14,GP15}, the current best running time
is~, where~~\cite{GP15}.

We extend this approach to edge modification problems, where the number~ of modifications tends to be even larger than for vertex deletion problems. For example, in the case of \textsc{Cluster Editing}, which asks to destroy induced paths on three vertices by edge modifications, the number of modifications is often larger than the number of vertices in the input graph~\cite{BBBT09}. Hence, parameterization above lower bounds
seems natural and even more relevant for edge modification problems. Somewhat surprisingly, this approach has not been considered so far.
We thus initiate research on parameterization above lower bounds in this context.
As a starting point, we focus on edge modification problems for graph properties that are characterized by one small forbidden induced subgraph~:

\decprob{\textsc{-free Editing}}{A graph~ and a natural number~.}{Is there an \emph{\gfedset{F}}~ of size at most~ such that~ does not contain~ as induced subgraph?}
In the context of a concrete variant of \ffed{}, we refer to an~\gfedset{F} as \emph{solution} and call a solution \emph{optimal} if it has minimum size.  

\paragraph{Lower bounds from packings of bounded-cost induced subgraphs.}
Following the approach of parameterizing \textsc{Vertex Cover} above the size of a maximum matching, we can parameterize \ffed{} above a lower bound obtained from packings of induced subgraphs containing~.

\begin{definition}
  A \emph{vertex-disjoint (or edge-disjoint) packing} of induced subgraphs of a graph~ is a set~ such that each~ is an induced subgraph of~ and such that the vertex sets (or edge sets) of the~ are mutually disjoint.
\end{definition}
While it is natural to consider packings of -graphs to obtain a lower bound on the solution size, a packing of other graphs that contain~ as induced subgraph might yield better lower bounds and thus a smaller parameter above this lower bound. For example, a~~contains several triangles and two edge deletions are necessary to make it triangle-free. Thus, if a graph~ has a vertex-disjoint packing of~~triangles and~~s, then at least~ edge deletions are necessary to make it triangle-free.\footnote{Bounds of this type are exploited, for example, in so-called cutting planes, which are used in speeding up the running time of ILP solvers. } Moreover, when allowing arbitrary graphs for the packing, the lower bounds provided by vertex-disjoint packings can be better than the lower bounds provided by edge-disjoint packings of~. A disjoint union of~~s, for example, has~ edge-disjoint triangles but also~ vertex-disjoint~s. Hence, the lower bound provided by packing vertex-disjoint~s is twice as large as the one provided by packing edge-disjoint triangles in this graph.


Motivated by this benefit of vertex-disjoint
packings of arbitrary graphs, we mainly consider lower bounds obtained
from vertex-disjoint packings, which we assume to receive as
input. Thus, we arrive at the following problem, where
~denotes the minimum size of an~\gfedset{F} for a graph~:
\decprob{\tffedv}{A graph~, a vertex-disjoint packing~ of induced subgraphs of~ such that~ for each , and a natural number~.}{Is there an \emph{\gfedset{F}}~ of size at most~ such that~ does not contain~ as induced subgraph?}
The special case of \tffedv{} where only -graphs are allowed in the packing is called \ffedv{}.

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[x=0.7cm,y=0.7cm]
    \tikzstyle{packing} = [fill,color=lightgray,line cap=round, line
    join=round, line width=16pt]
    \tikzstyle{deleted} = [dashed]

    \tikzstyle{vertex} = [color=black,fill=black,circle]

    \begin{scope}[rotate=30]
      \node[vertex] (x1) at (0:1) {};
      \node[vertex] (x2) at (120:1) {};
      \node[vertex] (x3) at (-120:1) {};
    \end{scope}

    \begin{scope}[shift={(-2.8,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (z1) at (0:1) {};
        \node[vertex] (z2) at (120:1) {};
    \end{scope}
  \end{scope}
  
    \begin{scope}[shift={(2.8,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (y1) at (0:1) {};
        \node[vertex] (y2) at (120:1) {};
        \node[vertex] (y3) at (-120:1) {};
      \end{scope}
    \end{scope}
    \draw (x1.center)--(x2.center);
    \draw [deleted] (z1.center)--(x2.center);
    \draw (z1.center)--(z2.center);
    \draw (z1.center)--(x3.center);
    \draw (z2.center)--(x2.center);
    \draw (x2.center)--(x3.center) {};
    \draw [deleted] (x3.center)--(x1.center) ;
    \draw (y1.center)--(y2.center);
    \draw (y1.center)--(y3.center);
    \draw [deleted](y3.center)--(y2.center);
    \draw (x3.center)--(y3.center);
    \draw (x3.center)--(y2.center);
    \draw (x1.center)--(y3.center);
    \draw (x1.center)--(y2.center);
    \begin{pgfonlayer}{background}
      \draw[packing] (x1.center)--(x2.center)--(x3.center)--cycle; \draw[packing] (y2.center)--(y3.center)--(y1.center)--cycle;
    \end{pgfonlayer}

    \begin{scope}[shift={(9,0)}]
    \begin{scope}[rotate=30]
      \node[vertex] (x1) at (0:1) {};
      \node[vertex] (x2) at (120:1) {};
      \node[vertex] (x3) at (-120:1) {};
    \end{scope}

    \begin{scope}[shift={(-2.8,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (z1) at (0:1) {};
        \node[vertex] (z2) at (120:1) {};
    \end{scope}
  \end{scope}
  
    \begin{scope}[shift={(2.8,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (y1) at (0:1) {};
        \node[vertex] (y2) at (120:1) {};
        \node[vertex] (y3) at (-120:1) {};
      \end{scope}
    \end{scope}
    \draw (x1.center)--(x2.center);
    \draw [deleted] (z1.center)--(x2.center);
    \draw (z1.center)--(z2.center);
    \draw (z1.center)--(x3.center);
    \draw (z2.center)--(x2.center);
    \draw (x2.center)--(x3.center) {};
    \draw [deleted] (x3.center)--(x1.center) ;
    \draw (y1.center)--(y2.center);
    \draw (y1.center)--(y3.center);
    \draw [deleted](y3.center)--(y2.center);
    \draw (x3.center)--(y3.center);
    \draw (x3.center)--(y2.center);
    \draw (x1.center)--(y3.center);
    \draw (x1.center)--(y2.center);
    \begin{pgfonlayer}{background}
      \draw[packing] (x2.center)--(z1.center)--(z2.center)--cycle; \draw[packing] (y2.center)--(x1.center)--(x3.center)--(y3.center)--cycle;
    \end{pgfonlayer}
    \end{scope}

  \end{tikzpicture}
  \caption{ An instance of \textsc{Triangle Deletion}. The packing
    graphs have gray background. Left: A vertex-disjoint packing of two triangles
    giving~. Right: A vertex-disjoint packing of a triangle and a~ giving~.
    The solution consists of the three dashed edges.}
\label{fig:packing-problem}
\end{figure}

\looseness=-1 From the packing~, we obtain the lower bound  on the size of an \gfedset{F}, which allows us to use the excess  over this lower bound as parameter, as illustrated in \cref{fig:packing-problem}. Since~ is a fixed graph, we can
compute the bound~ in~ time using the
generic algorithm~\cite{Cai96} mentioned in the introduction
for each~.
In the same time we can also verify whether the
cost- property is fulfilled.



Packings of forbidden induced subgraphs have been used in implementations of fixed-parameter algorithms to prune the corresponding search trees tremendously~\cite{HH15}. By showing fixed-parameter algorithms for parameters above these lower bounds, we hope to explain the fact that these packings help in obtaining fast algorithms.


\paragraph{Our Results.}We first state the negative results since they
justify the focus on concrete problems and, to a certain extent, also
the focus on parameterizing \emph{edge} modification problems above
lower bounds obtained from
\emph{vertex}-disjoint packings. We show that \gfedv{K_6} is NP-hard
for~. This proves, in particular, that a general
fixed-parameter tractability result as it is known for the
parameter~~\cite{Cai96} cannot be expected. Moreover, we show that,
if~ is a triangle and~ is an \emph{edge-disjoint} packing
of~ triangles in a graph~, then it is NP-hard to decide
whether~ has a triangle deletion set of size~ (that is,
). Thus, parameterization by~ is hopeless for this
packing lower bound. We also consider vertex deletion problems. For
these we show that extending the parameterization ``above maximum
matching'' for \textsc{Vertex Cover} to \textsc{-Hitting Set} in a
natural way leads to intractable problems. This is achieved by showing
that, for all~, \PLVD{} is NP-hard even if~.

  Our positive results are fixed-parameter algorithms and problem kernels (a notion for provably effective polynomial-time data reduction, see \cref{sec:prelim} for a formal definition) for three variants of~\tffedv{}.  Namely, these are the variants in which~~is a triangle (that is, a~) or a
path on three vertices (that is, a~). The first case is known as
\textsc{Triangle Deletion}, the second one as \textsc{Cluster
  Editing}.  We also consider the case in which the input is a
tournament graph and~ is a directed cycle on three vertices. This
is known as \textsc{Feedback Arc Set in Tournaments}.
Using a general approach described in \cref{sec:approach}, we obtain fixed-parameter algorithms for these variants of \tffedv{} parameterized by~ and~.  This implies fixed-parameter tractability for \ffedv{} parameterized by~.  Specifically, we obtain the following positive results:
\shorten{Applying this framework plus some problem-specific data reduction and
branching rules yields the following particular results:}
\begin{enumerate}[(i)]
\item For \textsc{Triangle Deletion}, we show an~-time algorithm and an~-vertex problem kernel for cost- packings.
\item For \textsc{Feedback Arc Set in Tournaments}, we show a
  -time algorithm and
  an~-vertex problem kernel for cost- packings.
\item For \textsc{Cluster Editing}, we show an~-time algorithm and an~-vertex kernel for cost- packings, and a~-time algorithm for -packings.
\end{enumerate}
For the kernelization results, we need to assume that 
to guarantee polynomial running time of the data reduction. 

\paragraph{Organization of this work.}
In \cref{sec:prelim}, we introduce basic graph-theoretic notation and formally define fixed-parameter algorithms and problem kernelization.  In \cref{sec:approach}, we present the general approach used in our algorithmic and data reduction results.  In \cref{sec:triangle-free}, we present our results regarding \textsc{Triangle Deletion}, in \cref{sec:fast} regarding \textsc{Feedback Arc Set in Tournaments}, and in \cref{sec:cluster-edit} regarding \textsc{Cluster Editing}.  \cref{sec:hardness} shows vertex and edge deletion problems that remain NP-hard for~, where ~is the number of modifications that are allowed in addition to a lower bound based on vertex-disjoint packings.  We conclude with some open questions in \cref{sec:conclusion}.

\section{Preliminaries}\label{sec:prelim}
In this section, we introduce basic graph-theoretic notation and formally define fixed-parameter algorithms and problem kernelization.
\paragraph{Notation.}
\label{sec:notation}
Unless stated otherwise, we consider undirected, simple, finite graphs~, with a \emph{vertex set}~ and an \emph{edge set}~.  Let~ denote the \emph{order} of the graph and~ its number of edges.  A~set~ is an \emph{edge modification set} for~. For an edge modification set~ for~, let~ denote the \emph{graph obtained by applying}~ to~.  If~, then~ is called an \emph{edge deletion set} and we write~ instead of~.  
The \emph{open neighborhood} of a vertex~ is defined as~. Also, for~, let~ denote the subgraph of~ \emph{induced by~}.
A \emph{directed graph (or digraph)}~ consists of a \emph{vertex set}~ and an \emph{arc set}~.  A \emph{tournament} on~ vertices is a directed graph~ with~ such that, for each pair of distinct vertices~ and~, either~ or~.




\paragraph{Fixed-parameter algorithms.} The idea in fixed-parameter algorithms is to accept the exponential running time that seems to be inevitable when exactly solving NP-hard problems, yet to confine it to some small problem-specific parameter.  A problem is \emph{fixed-parameter tractable} with respect to some parameter~ if there is a \emph{fixed-parameter algorithm} solving any instance of size~ in ~time.  We will also say that a problem is fixed-parameter tractable with respect to some combined parameter~``~and~'' or ``'' if it is fixed-parameter tractable parameterized by .

Fixed-parameter algorithms can efficiently solve instances in which the parameter~ is small, even if the input size~ is large.  All  vertex deletion, edge deletion, and edge modification problems for graph properties characterized by finite forbidden induced subgraphs are fixed-parameter tractable parameterized by the number of modifications~~\cite{Cai96}.

\paragraph{Problem kernelization.} An important technique in
fixed-parameter algorithmics is \emph{(problem) kernelization}
\citep{Kra14}---a formal approach of describing efficient and
correct data reduction.  A \emph{kernelization} is an algorithm
that given an instance  with parameter~, yields an instance 
with parameter~ in time polynomial in  such that ~is
a yes-instance if and only if ~is a yes-instance, and if both
 and  are bounded by some functions  and  in~,
respectively. The function~ is referred to as the \emph{size} of
the \emph{problem kernel}~. Kernelizations are commonly
described by giving a set of \emph{data reduction rules} which when
applied to an instance~ of a problem yield an instance~. We say
that a data reduction rule is \emph{correct} if~ and~ are equivalent.


All vertex deletion problems for establishing graph properties
characterized by a finite number of forbidden induced subgraphs have a
problem kernel of size polynomial in the parameter~ of allowed
modifications~\citep{Kra12}.  In contrast, many variants of~\ffed{} do
not admit a problem kernel whose size is polynomial
in~~\cite{KW13,GHPP13,CC15}. 

\section{General Approach}\label{sec:approach}

In this section, we describe the general approach of our
fixed-parameter algorithms. Recall that ~is the minimum
number of edge modifications required to transform a graph~ into
an~-free graph.  We present fixed-parameter algorithms for three
variants of \tffedv{} parameterized by the combination of~
and~,
where~. The idea behind the
algorithms is to arrive at a classic
win-win scenario~\cite{Fell03} where we can either apply data
reduction or show that the packing size~ is bounded.  This
will allow us to bound~ in~ for yes-instances and,
thus, to apply known fixed-parameter algorithms for the
parameter~ to obtain fixed-parameter tractability results
for~.

More precisely, we show that, for each induced
subgraph~ of~ in a given packing~, we face
essentially two situations. If there is an optimal solution for~
that is a subset of an optimal solution for~, then we can apply a data reduction rule. Otherwise, we find a
certificate witnessing that  itself needs to be solved
suboptimally or that a vertex pair containing exactly
one vertex from~ needs to be modified. We use the following terminology for these pairs. 
\begin{definition}[External vertex pairs and edges]A vertex pair~ is an \emph{external pair for a packing graph~} if exactly one of~ or~
  is in~, an edge is an \emph{external edge for~} if exactly one of its endpoints
  is in~. 
\end{definition}
Observe that every pair or edge is an external pair or edge for at most two packing graphs
since the packing graphs are vertex-disjoint. Therefore, the modification of an external vertex
pair can destroy at most two certificates.
This is the main fact used in the proof of the
following bound on~.



\begin{lemma}\label[lemma]{lem:gen-bound}
  Let~ be an instance of \tffedv{} and let ~be a
  size- solution that contains, for each~,
  \begin{enumerate}[(a)]
  \item\label{inside} at least  vertex pairs from~, or
  \item\label{outside} at least one external vertex pair~ for~.
  \end{enumerate}
  Then,  and thus, .
\end{lemma}
\begin{proof}
    Denote by~ the set of all graphs in~ that fulfill
  property~(\ref{inside}) and let .
  Let  denote the
  set containing the remaining packing graphs (fulfilling property~(\ref{outside})) and let .
  Thus, .
  Furthermore, let ~denote the lower bound obtained from the graphs in~ and let ~denote the part of the lower bound obtained by the remaining graphs.

  The packing graphs in~ cause~ edge modifications inside of them. Similarly, the packing graphs in~ cause at least~ edge modifications inside of them, and each packing graph~ additionally causes modification of at least one external vertex pair for~. Since every vertex pair is an external pair for at most two different packing graphs, at least~ edge modifications are caused by the graphs in~.  This implies that
  
Consequently,   .\qed
\end{proof}

\section{Triangle Deletion}
\label{sec:triangle-free}

In this section, we study \textsc{Triangle Deletion}, the problem of destroying all \emph{triangles}~(s) in a graph by at most ~edge deletions.  In \cref{sec:trdpos}, we apply our framework from \cref{sec:approach} to show that \textsc{Triangle Deletion} is fixed-parameter tractable parameterized above the lower bound given by a cost- packing.  In \cref{sec:trdneg}, we then show that parameterization above a lower bound given by edge-disjoint packings of triangles does not lead to fixed-parameter algorithms unless PNP.

\subsection{A fixed-parameter algorithm  for vertex-disjoint cost- packings}\label{sec:trdpos}
Before presenting our new fixed-parameter tractability results for \textsc{Triangle Deletion}, let us first summarize the known results concerning the (parameterized)
complexity of \textsc{Triangle Deletion}.
\textsc{Triangle Deletion} is NP-complete~\cite{Yan81}. It allows for a trivial reduction to \textsc{3-Hitting Set} since edge deletions do not create new triangles~\cite{GGHN04}. Combining this approach with the currently fastest known algorithms for \textsc{3-Hitting Set}~\cite{wahl07,Bev14} gives an algorithm for \textsc{Triangle Deletion} with running time~. Finally, \textsc{Triangle Deletion} admits a problem kernel with at most ~vertices~\cite{BKM09}.
We show that \TAGP{} is fixed-parameter tractable with respect to
the combination of~ and~.
More precisely, we obtain a kernelization and a search tree algorithm.
Both make crucial use of the following generic reduction rule for \TAGP.

\begin{rrule}\label[rrule]{rule:opt-graph}
  If there is an induced subgraph~ and a set~ of~ edges such that deleting~ destroys all triangles of~ that contain edges of~, then delete~ from~, ~from~ and decrease~ by~.
\end{rrule}
\begin{lemma}\label{lem:opt-graph-correct}
  \cref{rule:opt-graph} is correct. 
\end{lemma}
\begin{proof}
  Let~ be the instance
  to which \cref{rule:opt-graph} is applied and let  with  be the result. We show that~ is a yes-instance if and only if ~is.

  First, let~ be a solution of size at most~ for~. Let~ denote the set of edges of~ that destroy all triangles in~. By definition, .  Since~, only triangles containing at least one edge of~ are destroyed by deleting~. It follows that the set of triangles destroyed by~ is a subset of the triangles destroyed by~.  Hence,  has size at most~ and clearly is a solution for~ that contains all edges of~. Thus,  is a solution of size~ for  and  is a yes-instance.

  For the converse direction, let~ be a solution of size at most~ for~. Since~, it holds that every triangle contained in~ that does not contain any edge of~ is also a triangle in~.  Thus, ~is a set of edges whose deletion in~ destroys all triangles that do not contain any edge of~. Since~ destroys all triangles containing an edge of~, we have that~ is a solution for~.  Its size is~.\qed
\end{proof}

\noindent We now show that, if \cref{rule:opt-graph} is not applicable to~, then we can find a \emph{certificate} for this, which will allow us later to branch efficiently on the destruction of triangles:
\begin{definition}[Certificate]
  A \emph{certificate} for inapplicability of \cref{rule:opt-graph} to an induced subgraph~ is a set~ of triangles in~, each containing exactly one distinct edge of~, such that  or~ and~, where~ is the subgraph obtained from~ by deleting, for each triangle in~, its edge shared with~.
\end{definition}
\begin{lemma}\label[lemma]{lem:opt-graph-time}
  Let ~be the time needed to compute a triangle-free
  deletion set of size at most~ in a graph~ if it exists.

  In ~time, we can apply
  \cref{rule:opt-graph} to all~ and output a
  certificate~ if \cref{rule:opt-graph} is inapplicable to some~.
\end{lemma} 
\noindent
In the statement of the lemma,
we assume that
~is monotonically nondecreasing
in the size of~ and in~.
As described above,
currently 
is the best known bound for~.
\begin{proof}[of \cref{lem:opt-graph-time}]
  First, in~ time, we compute for all~ all triangles~ that contain exactly one edge~. These edges are labeled in each~.  Then, for each , in ~time we determine the size~ of an optimal triangle-free deletion set for~. Let ~denote the number of labeled edges of~.  

\emph{Case~1:~.} In this case, we return as certificate ~triangles of~, each containing a distinct of ~arbitrary labeled edges.  

\emph{Case~2:~.} Let~~denote the graph obtained from~ by deleting the labeled edges. All triangles of~ that contain at least one edge of~ either contain a labeled edge or they are contained in~. Thus, we now determine in~ time whether~ can be made triangle-free by ~edge deletions. If this is the case, then the rule applies and the set~ consists of the solution for~ plus the deleted labeled edges.  Otherwise, destroying all triangles that contain exactly one edge from~ leads to a solution which needs more than~~edge deletions and thus the rule does not apply. In this case, we return the certificate~ for this~. 

The overall running time now follows from the monotonicity of~,
from the fact that~, and from the fact that one pass
over~ is sufficient since deleting edges in each~ does
not produce new triangles and does not destroy triangles in
any~.  \qed\end{proof}

\noindent Observe that \cref{rule:opt-graph} never increases the parameter~ since we decrease both~ as well as the lower bound~ by~.
After application of \cref{rule:opt-graph}, we can upper-bound
the solution size~ in terms of~ and~, which allows us to transfer parameterized complexity results for the parameter~ to the combined parameter~.
\begin{lemma}\label[lemma]{lem:k-small-gen}
  Let~ be a yes-instance of~\TAGP{} such that \cref{rule:opt-graph} is inapplicable. Then, .
\end{lemma}
\begin{proof}
  Since ~is reduced with respect to \cref{rule:opt-graph}, for each graph~ in~, there is a set of edges between~ and  witnessing that every optimal solution for~ does not destroy all triangles containing at least one edge from~.  Consider any optimal solution~. For each graph~, there are two possibilities: Either at least~ edges inside~ are deleted by~, or at least one external edge of~ is deleted by~.  Therefore, ~fulfills the condition of \cref{lem:gen-bound} and thus~.
\qed\end{proof}

\begin{theorem}\label{thm:td-kern-general}
Let ~be the time used for computing a triangle-free deletion set of size at most~ in a graph~ if it exists. Then, \TAGP{}
  \begin{enumerate}[(i)]
  \item\label{td-searchtree} can be solved in~~time, and
  \item\label{td-kern} admits a problem kernel with at most~ vertices that can be computed in ~time.
  \end{enumerate}
\end{theorem}
\begin{proof}
  We first prove \eqref{td-kern}.  To this end, let  be the input instance.  First, compute in ~time an instance that is reduced with respect to \cref{rule:opt-graph}. Afterwards, by \cref{lem:k-small-gen}, we can reject if~.  Otherwise, we apply the known kernelization algorithm for \textsc{Triangle Deletion} to the instance~ (that is, without~). This kernelization produces in ~time a problem kernel~ with at most~ vertices and with~~\cite{BKM09}. Adding an empty packing gives an equivalent instance~ with parameter~ of \TAGP.

  It remains to prove \eqref{td-searchtree}.  To this end, first apply \cref{rule:opt-graph} exhaustively in ~time.  Now, consider a reduced instance. If~, then we can reject the instance. Otherwise, consider the following two cases.
  
  \emph{Case 1: .} If~ is triangle-free, then we are done. Otherwise, pick an arbitrary triangle in~ and add it to~.

  \emph{Case 2:  contains a graph~.} Since \cref{rule:opt-graph} does not apply to~, there is a certificate~ of~ triangles, each containing exactly one distinct edge of~ such that deleting the edges of these triangles contained in  produces a subgraph~ of~ that cannot be made triangle-free by~ edge deletions.  Thus, branch into the following~ cases: First, for each triangle~, create two cases, in each deleting a different one of the two edges of~ that are not in~. In the remaining case, delete the ~edges of~ and replace~ by~ in~.


  It remains to show the running time by bounding the search tree size. In Case~1, no branching is performed and the parameter is decreased by at least one. In Case~2, the parameter value is decreased by one in each branch: in the first~ cases, an edge that is not contained in any packing graph is deleted. Thus, ~decreases by one while ~remains unchanged. In the final case, the value of~ decreases by~ since this many edge deletions are performed. However, .  Hence, the lower bound~ decreases by at most~ and thus the parameter~ decreases by at least one.  Note that applying \cref{rule:opt-graph} never increases the parameter. Hence, the depth of the search tree is at most~.  \qed\end{proof} 

\begin{corollary}\label[corollary]{cor:triangle-abv-cost-t}
\TAGP{}
  \begin{enumerate}[(i)]
  \item\label{cor-td-searchtree} can be solved in~~time, and
  \item\label{cor-td-kern} admits a problem kernel with at most~ vertices that can be computed in~ time.
  \end{enumerate}
\end{corollary}
For the natural special case~, that is, for triangle packings, \cref{thm:td-kern-general}\eqref{cor-td-searchtree} immediately yields the following running time.
\begin{corollary}\label[corollary]{cor:triangle-abv}
  \TATP{} is solvable in ~time.
\end{corollary}

















\subsection{Hardness for edge-disjoint packing}\label{sec:trdneg}
\noindent We complement the positive results of \cref{thm:td-kern-general} by the following hardness result for the case of edge-disjoint triangle packings:
\begin{theorem}\label[theorem]{thm:girlanden}
  \textsc{Triangle Deletion} is NP-hard even for  if ~is an \emph{edge-disjoint} packing of triangles.
\end{theorem}

\noindent \cref{thm:girlanden} shows that parameterizing \textsc{Triangle Deletion} over a lower bound given by edge-disjoint packings cannot lead to fixed-parameter algorithms unless PNP.  We prove \cref{thm:girlanden} using a reduction from~\POITS{}.

\decprob{\POITS}
{\label[problem]{prob:poits}A Boolean formula  in conjunctive normal form over variables~ with at most three variables per clause.}
{Does  have a satisfying assignment?}
\begin{construction}\label[construction]{cons:girlanden}
  Given a Boolean formula~, we create a graph~ and an edge-disjoint packing~ of triangles such that ~can be made triangle-free by exactly ~edge deletions if and only if there is a satisfying assignment for~.
  We assume that each clause of~ contains exactly three pairwise distinct variables.  The construction is illustrated in \cref{fig:k3del-hard}.
\begin{figure}[t]
  \centering
  \includegraphics{ag-editing-1}
  \caption{Construction for a clause .  The triangles on a gray background are contained in the mutually edge-disjoint triangle packing~.  Deleting the dashed edges corresponds to setting~ and~ to false and ~to true, thus satisfying~.  Note that it is impossible to destroy triangle~ by ~edge deletions if we delete~, , and , which corresponds to the fact that clause~ cannot be satisfied by this variable assignment.}
\label{fig:k3del-hard}
\end{figure}
  
For each variable~ of~, create a triangle~ on the vertex set~ with two distinguished edges~ and~ and add~ to~.  For each clause~ of~, create a triangle~ on the vertex set~ with three edges~, , and~.  Connect the clause gadget~ to the variable gadgets as follows: If , then connect the edge  to the edge~ via two adjacent triangles~ and  sharing the edge~.  The triangle~ is added to~.  If , then connect the edge  to the edge~ via two adjacent triangles~ and  sharing the edge~.  The triangle~ is added to~.
\end{construction}

\begin{proof}[of \cref{thm:girlanden}]
  First, observe that \cref{cons:girlanden} introduces no edges between distinct clause gadgets or distinct variable gadgets.  Thus, under the assumption that each clause contains each variable at most once, the only triangles in the constructed graph are the~, the~, the~ and~ for all variables~ and the incident clauses~.


  Now, assume that ~allows for a satisfying assignment.  We construct a set of edges~ of size~ such that  is triangle-free.  For each variable~ that is true, add  to~.  For each variable~ that is false, add  to~.  By this choice, the triangle~ is destroyed in~ for each variable~.  Additionally,
  for each clause~ and its \emph{true} literals~, the triangle~ is destroyed. To destroy~, we add to~ the edge of~ shared with~, which also destroys the triangle~.
  For each clause~ containing a \emph{false} literal~, we destroy~ and simultaneously~ by adding to~ the edge of~ shared with~.

  Conversely, assume that there is a set~ of size~ such that  is triangle-free.  We construct a satisfying assignment for~.
  First, observe that, since the triangles in  are pairwise edge-disjoint, ~contains exactly one edge of each triangle in~.  Thus, of each triangle~, at most one of the two edges~ and~ is contained in~.
  The set~ contains at least one edge~ of each~.  This edge is shared with a triangle~.  Since  and, with~, ~already contains one edge of~, ~does not contain the edge shared between~ and~.  Since~, ~has to contain an edge of~ shared with another triangle in~.  If the clause~ contains~, then the only such edge is~ and we set~ to true.  If the clause~ contains~, then the only such edge is~ and we set~ to false.  In both cases, clause~ is satisfied.  Since at most one of~ and~ is in~, the value of each variable~ is well-defined.
\qed\end{proof}

\section{Feedback Arc Set in Tournaments}
\label{sec:fast}
 
In this section, we present a fixed-parameter algorithm and a problem kernel for \textsc{Feedback Arc Set in Tournaments} parameterized above lower bounds of cost- packings. 

In \textsc{Feedback Arc Set in Tournaments}, we are given a directed tournament graph~
as input and want to delete a minimum number of arcs to make the graph acyclic, that is, to destroy all directed cycles
in~. Due to a well-known observation, one can also view \textsc{Feedback Arc Set in Tournaments} as an arc \emph{reversal} problem: After deleting a minimum set of arcs to make the graph acyclic, adding the
arc~ for every deleted arc~ does not create any cycle. Since, in
tournaments, every pair of vertices is connected by exactly one arc, it follows that that
destroying cycles by edge deletions is equivalent to destroying them by arc
reversals. Altogether, we arrive at the following problem definition. 
\decprob{\FAST{} (\textsc{FAST})}
{An -vertex tournament~ and a natural number~.}
{Does~ have a \emph{feedback arc set}~, that is, a set~ such that reversing all arcs in~ yields an acyclic tournament, of size at most~?}
\textsc{FAST} is NP-complete~\cite{Alon06} but fixed-parameter
tractable with respect to~~\cite{RS06, DGHNT06, ALS09,Fei09,KS10,FP13}. The running
time of the current best fixed-parameter algorithm is~ where~~\cite{FP13}.
Moreover, a problem kernel with  vertices
for each \emph{constant}~ is known~\cite{BFGPPST11}
as well as a simpler~-vertex kernel~\cite{PPT16}.
It is well-known that a tournament is acyclic if
and only if it does not contain a \emph{directed triangle} (a cycle on 3
vertices). Hence, the problem is to find a set of arcs whose reversal
leaves no directed triangle in the tournament.

We show fixed-parameter tractability of FAST\textsc{ with Cost- Packing} parameterized by the combination of~ and~. Recall that , where~ is the size of a minimum feedback arc set for a directed graph~.
The approach is the same as for \textsc{Triangle Deletion} in \cref{sec:triangle-free}, that is, we upper-bound the solution size~ in~ and~ and apply the fixed-parameter algorithm for~ \cite{KS10}. Observe in this context that \cref{lem:gen-bound} is also correct if the input graphs are directed and if a solution contains arc reversals, since we observed arc reversals and deletions to be equivalent in the context of \textsc{FAST}.\footnote{For directed input graphs, we use the term \emph{external arc} instead of \emph{external edge}.}
We use the following reduction rule for \textsc{FAST} analogous to \cref{rule:opt-graph} for \textsc{Triangle Deletion}.

\begin{rrule}\label[rrule]{fast-general-rule}
  If there is a subtournament~ 
  and a feedback arc set~ of size~ such that
  reversing the arcs in~ leaves no directed triangles in~ containing arcs
  of~, then reverse the arcs in~, remove  from~, and decrease~ by~.
\end{rrule}



\noindent Although \cref{fast-general-rule} is strikingly similar to \cref{rule:opt-graph}, its correctness proof is significantly more involved.

\begin{lemma}\label[lemma]{fast-general-rule-time}
  \cref{fast-general-rule} is correct and, given the tournaments~ and~ it
  can be applied in~ time, where  and~ denotes the running time needed to compute a feedback arc set of size at most~ in~ if it exists.
\end{lemma}
\begin{proof}
  We first show correctness.
  Let~ be the instance
  created by \cref{fast-general-rule}
  from 
  by reversing a subset~ of arcs
  of a subtournament~ of~.
  If ~is a yes-instance,
  then so is~
  since ~is the graph~
  with the ~arcs in~ reversed
  and, thus,
  adding these arcs to a feedback arc set
  of size~ for~
  gives a feedback arc set of size~ for~.
  It remains to prove that
  if ~is a yes-instance,
  then so is~.
  To this end, we show that
  there is a minimum-size feedback arc set~
  for~ with~.
  
  Let~ be a minimum-size feedback arc set for~.
  This implies the existence
  of a linear ordering~
  of the vertices~
  such that there are~ \emph{backward arcs},
  that is,
  arcs~ such that~.
  Now, let~ be the ordering
  of the vertices of~
  corresponding to the local solution~ for~
  with ~backward arcs.
  Let~ denote the \emph{out-neighbors} in~ of a vertex~. Analogously,
  ~denotes 
  the set of \emph{in-neighbors}.
  By the assumption of the rule, for all~,
  
  holds since otherwise,
  after reversing the arcs in~,
  there exists a directed cycle containing an arc of~
  (because the arc~ is present).
  
  If the vertices of~ appear in~ in the same relative order as in~, then we have~ and we are done.
  Otherwise, we show that
  we can swap the positions of vertices of~ in~
  so that their relative order is the same as in~
  without increasing the number of backward arcs.


  First, note that the number of backward arcs
  between vertices in~
  does not change
  when only swapping positions of vertices in~.
  Also, by assumption,
  the number of backward arcs between vertices in~
  in any ordering is at least~,
  whereas it is exactly 
  when ordering them according to~.
  Thus,
  it remains to show that the number of backward arcs
  between vertices in~ and~
  is not increased.
  To this end,
  consider a series of \emph{swaps}
  of pairs of vertices~ and~ such that ,
  where  appears before~ in~,
  reordering the vertices in~ according to~.
  Let~ denote the set of all vertices that lie between~ and~ in~.
  Note that swapping~ and~ removes the backward arcs from~ to the vertices in~ and the backward arcs from vertices in~ to~, whereas it introduces new backward arcs from~ to~ and from~ to~.
  However, by the inclusions in~(1), it follows that the overall number of backward arcs does not increase in each swap.
  Hence, the overall number of backward arcs is not increased by repositioning the vertices in~
  according to~. It follows that there is an optimal solution containing~.
    
  It remains to show the running time.
  First,
  in ~time,
  we compute the size~
  of an optimal feedback arc set for~.
  Now,
  for each arc~,
  we check whether there is a vertex~
  that forms a directed triangle
  with~ and~.
  If~such a vertex exists,
  then we reverse the arc~.
  If this arc reversal introduces a new directed triangle
  with another vertex from~,
  then the rule does not apply.
  Overall, this procedure requires~ time.
  Let~~denote the set of arcs that are reversed in this process. Clearly, if~, then the rule does not apply. Otherwise, let ~denote the graph obtained from~ by reversing the arcs in~ and observe that each remaining directed triangle of~ that contains at least one arc of~ is contained in~.
  Thus, we now compute whether~ has a feedback arc set~ of size~ in~ time. If this is the case, then the rule applies
  and we set~ (note that~, since otherwise~, which is not possible by definition of~).
  Otherwise, removing all directed triangles that contain at least one arc from~ requires more than~ arc reversals and thus the rule does not apply.
\qed\end{proof}

\noindent Exhaustive application of \cref{fast-general-rule} allows us to show that~ holds for any yes-instance (analogous to \cref{lem:k-small-gen}).

\begin{lemma}\label[lemma]{fast-k-small-gen}
  Let~ be a yes-instance of \FASTGP{}
  such that \cref{fast-general-rule} cannot be applied
  to any tournament in~.
  Then, .
\end{lemma}

\begin{proof}
  Since \cref{fast-general-rule} cannot be applied
  to any tournament in~,
  for each tournament~ in~,
  there is a set of arcs
  between~ and~
  that witness that
  no optimal feedback arc set for~
  removes all directed triangles
  containing at least one arc from~.
  
  Now, for any optimal solution,
  there are two possibilities
  for each packing tournament~:
  \begin{enumerate}[(a)]
  \item\label{fast-inside} at least~ arcs in~ are reversed, or
  \item\label{fast-outside} at least one external arc of~ is reversed.
  \end{enumerate}
  Therefore, ~fulfills the condition
  of \cref{lem:gen-bound}
  and, thus,
  .
\qed\end{proof}



\noindent The bound on~ yields the following two fixed-parameter tractability results.

\begin{theorem}\label{fast-general-fpt}
  Let ~be the running time used for finding a minimum feedback arc set of size at most~ for a given tournament~ if it exists.  Then, \FASTGP{}
  \begin{enumerate}[(i)]
  \item\label{fvs-fpt} is solvable in  time, and
  \item\label{fvs-kern} admits a problem kernel with at most~ vertices computable in~ time.
  \end{enumerate}
\end{theorem}

\begin{proof}
  \eqref{fvs-fpt} Given , we first apply \cref{fast-general-rule} for each~.  This application can be performed in~ time by \cref{fast-general-rule-time} since~.
  One pass of this rule is sufficient
  to obtain an instance that is reduced:
  reversing arcs in some~
  does not remove any directed triangles
  containing arcs of any other~
  with .
  By \cref{fast-k-small-gen}, we can then reject the instance if~.  Otherwise, we can find a solution in~ time.

  \eqref{fvs-kern}
  First, we apply \cref{fast-general-rule}
  once for each~ in
  ~time.
  After one pass of this rule,
  the instance is reduced
  since reversing arcs in some~
  does not remove any directed triangles
  containing arcs of any other~
  with .
  Afterwards, by \cref{fast-k-small-gen}, we can reject if~.  Otherwise, we apply the kernelization algorithm for \textsc{FAST} by~\citet{PPT16} to the instance~ to obtain an equivalent instance~ with at most~ vertices and a solution size~. 
  Hence,
   is our problem kernel 
  with parameter~ of \FASTGP{}.  \qed\end{proof}

\noindent In \cref{fast-general-fpt}, we again assume that ~is monotonically nondecreasing in both the size of~ and in~.  As mentioned earlier,  is the currently best known running time for ~\cite{KS10}.

\begin{corollary}\label[corollary]{cor:fast-abv-cost-t}
  \FASTGP{}
  \begin{enumerate}[(i)]
  \item\label{fast-searchtree} can be solved in~~time, and
  \item\label{fast-kern} admits a problem kernel with at most~ vertices computable in~~time.
  \end{enumerate}
\end{corollary}

\section{Cluster Editing}
\label{sec:cluster-edit}
We finally apply our framework from \cref{sec:approach} to \textsc{Cluster Editing}, a well-studied edge modification problem in parameterized complexity~\cite{Boeck12,CM12,FKP+11,KU12}. \decprob{\textsc{Cluster Editing}}{A graph~ and a natural number~.}  {Is there an edge modification set~ of size at most~ such that~ is a cluster graph, that is, a disjoint union of cliques?}  A graph is a cluster graph if and only if it is~-free~\cite{SST04}. Thus, \textsc{Cluster Editing} is the problem of destroying all~s by few edge modifications. For brevity, we refer to the connected components of a cluster graph (which are cliques) and to their vertex sets as \emph{clusters}. The currently fastest algorithm for
\textsc{Cluster Editing} parameterized by the solution size~ runs in~ time~\cite{Boeck12}.
Assuming the
exponential-time hypothesis, \textsc{Cluster Editing} cannot be solved
in~ time~\cite{FKP+11,KU12}. \textsc{Cluster
  Editing} admits a problem kernel with at most~
vertices~\cite{CM12}.

First, in \cref{sec:cet}, we present a fixed-parameter algorithm and problem kernel for \textsc{Cluster Editing} parameterized above lower bounds given by cost- packings.  Then, in \cref{sec:p3p}, we present a faster fixed-parameter algorithm for lower bounds given by vertex-disjoint packings of~s.

\subsection{A fixed-parameter algorithm for vertex-disjoint cost- packings}
\label{sec:cet}
Several kernelizations for \textsc{Cluster Editing}
are based on the following observation:
If ~contains a clique
such that all vertices in this clique
have the same closed neighborhood,
then there is an optimal solution that
puts these vertices into the same cluster
\cite{PSS09,Guo09,CM12}.
This implies that the edges of this clique
are never deleted.
The following rule
is based on a generalization of this observation.
\begin{rrule}
  \label[rrule]{rule:opt-graph-ce}
  If ~contains an induced subgraph~
  having an optimal solution~ of size~
  such that,
  for all vertices~,
  \begin{itemize}
  \item
    
    if~ and~ are in the same cluster
    of~,
    and
  \item
    
    otherwise,
  \end{itemize}
  then replace~ by~, remove~ from~, and decrease~ by~.
\end{rrule} 
An example of \cref{rule:opt-graph-ce} is presented
in \cref{fig:opt-graph-ce}.
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[x=0.7cm,y=0.7cm]
    \tikzstyle{packing} = [fill,color=lightgray,line cap=round, line
    join=round, line width=16pt]
    \tikzstyle{deleted} = [dashed]
    \tikzstyle{inserted} = [very thick]
    \tikzstyle{vertex} = [color=black,fill=black,circle]
    \begin{scope}[rotate=30]
      \node[vertex] (x1) at (0:1) {};
      \node[vertex] (x2) at (120:1) {};
      \node[vertex] (x3) at (-120:1) {};
    \end{scope}

    \begin{scope}[shift={(-2.6,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (z1) at (0:1) {};
        \node[vertex] (z2) at (120:1) {};
      \end{scope}
    \end{scope}

    \begin{scope}[shift={(-4.5,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (w1) at (0:1) {};
        \node[vertex] (w2) at (120:1) {};
      \end{scope}
    \end{scope}
  
    \begin{scope}[shift={(1.8,0)}]
       \begin{scope}[rotate=-90]
         \node[vertex] (y1) at (0:1) {};
         \node[vertex] (y2) at (120:1) {};
         \end{scope}
    \end{scope}
    \draw (x1.center)--(x2.center);
    \draw (z1.center)--(z2.center);
    \draw (z1.center)--(x3.center);
    \draw (z2.center)--(x2.center);
    \draw (x3.center)--(x1.center) ;
    \draw (z1.center)--(w1.center);
    \draw (z1.center)--(w2.center);
    \draw (z2.center)--(w1.center);
    \draw (z2.center)--(w2.center);
    \draw (w1.center)--(w2.center);
    \draw (x3.center)--(y1.center);
    \draw (x2.center)--(y1.center);
    \draw (x1.center)--(y1.center);
    \draw (x3.center)--(y2.center);
    \draw (x2.center) to [bend left =30] (y2.center);
    \draw (x1.center)--(y2.center);
    \begin{pgfonlayer}{background}
       \draw[packing] (z2.center)--(x1.center)--(x3.center)--(z1.center)--cycle;
    \end{pgfonlayer}

    \begin{scope}[shift={(9,0)}]
    \begin{scope}[rotate=30]
      \node[vertex] (x1) at (0:1) {};
      \node[vertex] (x2) at (120:1) {};
      \node[vertex] (x3) at (-120:1) {};
    \end{scope}

    \begin{scope}[shift={(-2.6,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (z1) at (0:1) {};
        \node[vertex] (z2) at (120:1) {};
      \end{scope}
    \end{scope}

    \begin{scope}[shift={(-4.5,-0.5)}]
      \begin{scope}[rotate=-30]
        \node[vertex] (w1) at (0:1) {};
        \node[vertex] (w2) at (120:1) {};
      \end{scope}
    \end{scope}
  
    \begin{scope}[shift={(1.8,0)}]
       \begin{scope}[rotate=-90]
         \node[vertex] (y1) at (0:1) {};
         \node[vertex] (y2) at (120:1) {};
         \end{scope}
    \end{scope}
    \draw (x1.center)--(x2.center);
    \draw (z1.center)--(z2.center);
    \draw [deleted] (z1.center)--(x3.center);
    \draw [deleted] (z2.center)--(x2.center);
    \draw (x3.center)--(x1.center) ;
    \draw [inserted] (x3.center)--(x2.center) ;
    \draw (z1.center)--(w1.center);
    \draw (z1.center)--(w2.center);
    \draw (z2.center)--(w1.center);
    \draw (z2.center)--(w2.center);
    \draw (w1.center)--(w2.center);
    \draw (x3.center)--(y1.center);
    \draw (x2.center)--(y1.center);
    \draw (x1.center)--(y1.center);
    \draw (x3.center)--(y2.center);
    \draw (x2.center) to [bend left = 30] (y2.center);
    \draw (x1.center)--(y2.center);
    \begin{pgfonlayer}{background}
       \draw[packing] (z2.center)--(z1.center)--cycle;        \draw[packing] (x1.center)--(x2.center)--(x3.center)--cycle; 
    \end{pgfonlayer}

    \end{scope}

  \end{tikzpicture}
  \caption{An illustration of \cref{rule:opt-graph-ce}. Left: An
    induced subgraph~ (highlighted by the gray background)
    fulfilling the conditions of \cref{rule:opt-graph-ce}. Right: The
    result of applying \cref{rule:opt-graph-ce}. The two clusters
    in~ produced by the optimal solution for~ are highlighted
    by a gray background.  }
\label{fig:opt-graph-ce}
\end{figure}
\begin{lemma}\label[lemma]{lem:opt-cluster-correct}
  \cref{rule:opt-graph-ce} is correct.
\end{lemma}

\begin{proof}
  Let  be
  the instance obtained by applying 
  \cref{rule:opt-graph-ce} to~
  for some induced subgraph~ of~.
  If ~is a yes-instance, then so is~:
  adding the ~edges in~
  to any solution~ of size~
  for~
  gives a solution of size~
  for~
  since 
  and, thus,
  .
  It remains to prove that
  if ~is a yes-instance,
  then so is~.
  To this end, we show that
  ~has an optimal solution~
  such that~. 

  For convenience,
  let~ denote
  the set of vertices not in~.
  Let~ be any optimal solution for~,
  and denote by~
  the cluster graph produced by~.
  We show how to transform~
  into an optimal solution~.
  To this end,
  partition~ as follows:
  \begin{itemize}
  \item  containing
    all edge modifications outside of~,
  \item 
    containing the edge modifications between~ and the rest of~, and
  \item .
  \end{itemize}
  Moreover, let~ be the vertices of~
  that have at least one neighbor in~
  and let~.
  Consider the following equivalence relation~
  on~: two vertices~ are equivalent with respect to~ if and only
  if~.  For each vertex~, let ~denote the
  equivalence class of~ in~.
  


  Fix within each equivalence class~ of~ an
  arbitrary vertex that is incident to a minimum number of edge
  modifications in~ and, for each vertex~, denote this vertex
  by~.
  Furthermore, for each cluster~ of~
  containing some vertices of~ and some vertices
  of~, fix an arbitrary vertex of~ that has in~ a maximum
  number of neighbors in~; denote this vertex
  by~. Finally, call a vertex~~\emph{good} if there
  is a cluster~ such that~.
  Now consider the edge modification set~, where 
  Informally, the modifications in~ consider~ to
  determine how to treat all vertices in the equivalence
  class~. If, among the vertices of~,  has the most neighbors in its cluster
  in~, then all vertices of~ are treated
  like~. Otherwise, all edges between vertices in~
  and~ are deleted.

  We first show that~ is a solution, that is, ~is a
  cluster graph: First, ~is a cluster
  graph. Second,  and thus it is a cluster
  graph. Third, every vertex~ is contained in a cluster that is a subset of~ in~: In~, there are no edges between~ and~,~no edges between~ and~ are added by~, and by the first condition on~, no vertex of~ is in the same cluster of~ as a vertex from~. This implies that the connected component of each vertex~ is completely contained in~ and thus it is a clique since~ is a cluster graph. Finally, consider any equivalence class~ of~. By the
  condition of \cref{rule:opt-graph-ce}, ~is contained in a cluster in~.
 Now, if all vertices of~ are good, then there is a
  cluster~ in~ such that in~ all vertices of~ are
  adjacent to all vertices of~.
 Otherwise, no vertex of~
  is good and thus, no vertex of~ is adjacent to any
  vertex of~ in~. Finally, if a cluster~ of~ has neighbors in~, then these edges are only to the vertex
  set~. Thus, every vertex in~ has neighbors in at most
  one cluster of~. Altogether this shows that~ is a
  cluster graph.

  It remains to show that .
  First, ~is a subset of~ and of~. Second, 
  since~ is an optimal solution for~. Thus, it remains
  to show~. Since the vertices of~ are not incident to any edge modifications in~, we may prove this inequality by showing, for each
  vertex~, that~
  If~ is good, then the number of edge modifications incident
  with~ in~ is the same as the number of edge
  modifications incident with~ in~, because~
  and~ have the same neighborhood in~ by the condition of
  the rule. By the choice of~, this is at most as large as the
  number of edge modifications incident with~ in~ and the
  claim holds.
  
  Otherwise, all edges between~ and~ are deleted
  by~. Let~ denote the cluster in~
  containing~. Since~ is not good, there is a vertex~
  that is not in~ such that~ has at least as many neighbors
  in~ as~. By the condition of
  \cref{rule:opt-graph-ce} and since~, the
  neighborhoods of these two vertices in~ are disjoint, that
  is, . Since~
  has at least as many neighbors in~ as~, this means
  that~ Now, observe that ~contains an edge insertion between~
  and each nonneighbor of~ in~. Thus, at least~ edges between~ and~ are inserted by~. Moreover,~ contains an edge deletion between~ and each neighbor of~ in~.
  Altogether, this implies 
  Therefore, the number of edge modifications incident with~ in~ (this is exactly the number of edges  
  between~ and~) is at most as large as the number of edge modifications incident with~ in~.
  By the choice of~, this implies the claim.  \qed
\end{proof}
It remains to analyze the running time
for applying \cref{rule:opt-graph-ce}.

\begin{lemma}\label[lemma]{lem:opt-cluster}
  Let ~be the running time used
  for finding an optimal solution of size at most~
  in a graph~ if it exists.

  Then, in ~time,
  we can apply \cref{rule:opt-graph-ce}
  to all graphs in~.
\end{lemma}
Here, we assume that
~is monotonically nondecreasing in~
and polynomial in the size of~. Currently,
 is the best known bound
for ~\cite{Boeck12}.
\begin{proof} 
  We first show that the rule can be applied
  in ~time
  to an arbitrary graph~.
  For convenience, denote~.

  First, observe that a necessary condition for the rule is that, for each pair of
  vertices~ and~ in~, their neighborhoods in~ are the same or disjoint.
 This can be checked in
  ~time as follows.  First, build the bipartite graph with
  parts~ and~ and those edges between the vertex sets that are also edges of~
  (equivalently,  minus the edges with both endpoints in~ or both
  endpoints in~). This bipartite graph is a disjoint union of complete bipartite
  graphs if and only if above condition is fulfilled. Thus, we check in~ time,
  whether the graph is a disjoint union of complete bipartite graphs. If not, then the
  rule does not apply.
  Otherwise, in the created bipartite graph,
  we compute in ~time
  the groups of vertices of~ whose neighborhood is the same.
  Afterwards, we can check in ~time
  whether ~and~ have the same neighborhood in~ in~
  by checking whether they belong to the same group.
  We now compute the set~ of
  edge modifications that is already determined by the conditions of the rule: If~
  and~ are nonadjacent and have the same nonempty neighborhood in~, then the
  edge~ needs to be inserted and is thus added to~.  Similarly, if~
  and~ are adjacent and have different neighborhoods in~, then~ needs to be
  deleted and is thus added to~. Observe that if~ is a subset of an optimal
  solution~ for~, then~. Hence, at most~ edges are added
  to~. Since we already computed the groups of vertices that have the same or disjoint
  neighborhoods, we can thus compute~ in~ time.

  Let~ denote the vertices of~ that have at least one neighbor in~ and
  let~. Note that after applying~, that is,
  in~, the vertices of~ are in separate clusters:
  ~is a cluster graph and
  there are no edges between~ and~ in~.
  Thus, to determine whether~ can be extended
  to an optimal solution~ for~
  that fulfills the condition of the rule,
  we compute an optimal solution of~ in
  ~time.
  Since  and , this can be done in
  ~time. The size of the resulting solution~ is compared with the size of
  an optimal solution of~, which can also be computed in ~time.

  It remains to show that \cref{rule:opt-graph-ce}
  can be applied to all graphs
  within the claimed running time.
  For each graph~,
  we can check
  in ~time
  whether \cref{rule:opt-graph-ce} applies.
  If yes,  then we can apply the rule in ~time
  by modifying at most ~edges.
  Summing up over all graphs in~
  gives the claimed running time.
\qed\end{proof}


\noindent Observe that since~ is decreased by~, the parameter~ does not increase when \cref{rule:opt-graph-ce} is applied. As for the previous problems, applying the rule to each~ is sufficient for bounding~ in~ and~ and thus, for transferring known fixed-parameter tractability results for the parameter~ to the combined parameter~.

\begin{lemma}\label[lemma]{lem:ce-small-packing}
  Let~ be a yes-instance of~\CEGP{} such that
  \cref{rule:opt-graph-ce} does not apply to any~.  Then, .
\end{lemma}
\begin{proof}
  Since the instance is reduced
  with respect to \cref{rule:opt-graph-ce},
  for each~ in~ and
  each size- solution~ for~,
  either the vertices of some cluster
  have different neighborhoods in~
  or two vertices of two distinct clusters
  have a common neighbor outside of~. 

  Now,
  fix an arbitrary optimal solution~ for~.
  By the observation above,
  there are the following two possibilities
  for how ~modifies each~:
  \begin{enumerate}[(a)]
  \item\label{ce-inside} more than~ vertex pairs of~ are modified by~, or
  \item\label{ce-outside} at least one external vertex pair for~ is modified.
  \end{enumerate}
Therefore,  fulfills the condition of \cref{lem:gen-bound} and thus .
\qed\end{proof}



\begin{theorem}\label{thm:ce-time}
Let ~be the running time used for finding an optimal solution of size at most~ in a graph~ if it exists. Then,  \CEGP{}
\begin{enumerate}[(i)]
\item\label{ce1} is solvable in~ time and
\item\label{ce2} admits a problem kernel with at most~ vertices, which can be computed in~ time.
\end{enumerate}
\end{theorem}
\begin{proof}
  \eqref{ce2}
  First, apply \cref{rule:opt-graph-ce} exhaustively
  in~ time.
  Then,
  by \cref{lem:ce-small-packing},
  we can either return ``no''
  or have~.
  In the latter case,
  we apply a kernelization algorithm
  for \textsc{Cluster Editing} to the instance~
  (that is, without~),
  which produces, in ~time,
  a problem kernel~
  with at most~ vertices
  and with~~\cite{CM12}.
  Adding an empty packing gives
  an equivalent instance~
  with parameter~ of \CEGP.

  \eqref{ce1} First, apply the kernelization.
  Then, by \cref{lem:ce-small-packing},
  we can either return ``no''
  or have .
  We can now apply the algorithm
  for \textsc{Cluster Editing}
  that runs in ~time. \qed\end{proof} 
By plugging in the best known bound for~,
we obtain the following.
\begin{corollary}\label[corollary]{cor:ce-abv-cost-t}
\CEGP{} 
\begin{enumerate}[(i)]
  \item\label{cor-td-searchtree} can be solved in~~time, and
  \item\label{cor-td-kern} admits a problem kernel with at most~ vertices that can be computed in~ time.
  \end{enumerate}
\end{corollary}


\subsection{A Search Tree Algorithm for -Packings}
\label{sec:p3p}
For \CEPP,
the generic algorithm based on \cref{rule:opt-graph-ce}
(with )
using the currently best running time
for \textsc{Cluster Editing}
leads to a running time of~.
We now show an algorithm that runs
in ~time.
The algorithm is based on two special cases
of \cref{rule:opt-graph-ce},
one further reduction rule
and a corresponding branching algorithm.

The analysis of the search tree size is done by considering branching vectors and their corresponding branching number.  The components of a branching vector denote the decrease of the parameter in each recursive branch.  The branching number depends only on the branching vector, the largest branching number gives the base in the upper bound on the search tree size; for further details refer to the relevant monographs~\cite{FK10,Nie06}.

We use the following special cases of \cref{rule:opt-graph-ce}. In both cases, ~is a~; the correctness is directly implied by \cref{lem:opt-cluster}. In the first rule, adding an edge is a solution which fulfills the condition of \cref{rule:opt-graph-ce}. For convenience, we denote by~ a~ on the vertices~, , and~, where ~is the degree-two vertex.
\begin{rrule}\label[rrule]{rule:almost-twin}
  If~ contains a~~ such that , then
  insert~ and decrease~ by one.
\end{rrule}
In the second rule, deleting an edge gives such a solution.
\begin{rrule}\label[rrule]{rule:almost-twin2}
  If~ contains a~~ such that~ and~, then
  delete~ and decrease~ by one.
\end{rrule}
The third rule is crucial for showing an improved running time.
\begin{rrule}
  \label[rrule]{rule:clique-with-ends}
  If~ contains a clique~
  on at least three vertices such that
  \begin{itemize}
  \item
    every vertex in~ has
    at most one neighbor in~ and
  \item
    every vertex in~ has
    exactly one neighbor in~,
  \end{itemize}
  then delete all edges between~ and~
  and decrement~ by~.
\end{rrule}

\begin{lemma}
  \label[lemma]{lem:clique-rule-correct}
  \cref{rule:clique-with-ends} is correct
  and can be exhaustively applied
  in ~time.
\end{lemma}
\begin{proof}
  First, enumerate the set of all maximal cliques~
  on at least three vertices
  such that every vertex of~
  has at most one neighbor in~.
  This can be done in ~time \cite{KHMN09}.
  Note that every vertex is contained
  in at most one such clique.
  Now, by scanning
  through the adjacency lists of all vertices
  in an enumerated clique,
  we can identify a vertex that has
  more than one neighbor in the clique. If there is such a vertex, then the clique can be discarded.
  Otherwise, the clique fulfills the conditions
  of the rule and the rule can be applied.
  Thus, one application of the rule takes~ time.
  Since the rule decreases the number of vertices in~,
  it can be applied~ times.

  Since~ and~,
  one can construct ~s,
  each containing two vertices from~
  and one vertex from~,
  such that no two of them share more than one vertex.
  Thus, at least ~edge modifications are needed
  to destroy all~s
  that contain at least one vertex~.
  Deleting all ~edges between~ and~
  destroys all s that
  contain at least one vertex of~.
  Moreover, since these edge deletions cut~
  from the rest of the graph,
  one can safely combine
  any optimal solution for~
  with these~ edge deletions,
  which are necessary and sufficient
  to destroy all s that contain
  at least one vertex of~,
  to obtain an optimal solution
  that deletes all ~edges between~ and~.
\qed\end{proof}
The final rule simply removes isolated clusters from~. 
\begin{rrule}\label[rrule]{rule:isolated-clusters}  If~ contains a connected component~ that is a clique, then remove~ from~.
\end{rrule}

\noindent We can now show our improved algorithm for \CEPP{}.
\begin{theorem}
  \label{thm:ce-abv}
  \CEPP{} can be solved
  in ~time.
\end{theorem}
\begin{proof}
  We prove the theorem using a branching algorithm,
  which applies several branching rules.
  Herein, we assume
  that ~contains at least one~~.
  Otherwise,
  the graph is either~-free
  (in this case we are done)
  or we can add a~ to~,
  which increases~ by one and thus
  reduces the parameter.
  Furthermore, we assume
  that \cref{rule:almost-twin,rule:almost-twin2,rule:clique-with-ends,rule:isolated-clusters}
  do not apply.
  First, we take care of~s
  that do not share an edge with a packing~.
  
  \emph{Branching Rule~1: If there is an induced~
    that contains at most one vertex
    of each  in~, then
  branch into the three cases
  to destroy this~.}

  None of the cases destroys a~ of~.
  Thus, the parameter is decreased by one in each case;
  the branching number is 3.

  The three further rules deal with packing~s .

  \emph{Branching Rule~2: If there is a vertex~ that is adjacent to~ and~ but not
    to~, then branch into four cases: delete~; delete~;
    add~; or delete~ and~ and add~.}
  
  In each of the first three branches, ~is reduced by one without
  destroying any~ of~. If none of the first three cases
  applies, then~, , and~ are in the same cluster (no edge
  deletions between~ or~ and~) and~ is not in this
  cluster.
  This makes the three edge modifications
  in~ necessary.
  Thus, ~is reduced by three and~ is
  reduced by one in this case.
  The resulting branching vector is~,
  which gives the branching number~.

  \emph{Branching Rule~3: If there are vertices~ and~ such that
    \begin{itemize}
    \item  is adjacent to~ and~, and
    \item  is adjacent to exactly one vertex
      of~, 
    \end{itemize}
    then branch into four cases: delete~; delete~; delete the edge
    between~ and its neighbor in~; or add the edge between~ and its
    nonneighbor in~.
  }

  In each case, an edge is modified without destroying
  any~ of~. If none of the first three cases applies,
  then~, and  are in the same cluster,
  which means that the missing edge
  between~ and either~ or~
  has to be added.
  Since the parameter is reduced by one in each branch, the branching
  number is~.
 
  \emph{Branching Rule~4: If there is a vertex~ that is adjacent to~ and not
    adjacent to~ and~, then branch into four cases:
  delete~; add~; add~;
  or delete~ and~.}

  If none of the first three cases applies,
  then any cluster containing~
  contains neither~ nor~,
  thus the branching is correct.
  The parameter is reduced by one in each
  branch, as the last branch destroys a  of~ but
  reduces~ by two. Thus, the branching number is~.

  These are the only branching rules that are performed. We now show, by a case
  distinction, the following: If none of the branching rules and reduction rules applies,
  then the remaining graph has maximum degree two and we can solve the problem in
  polynomial time.

  \emph{Case I:  contains a~  such that~ and~ have a common
    neighbor~.} Since Branching~Rule~2 does not apply,  is also a
  neighbor of~. Since Branching~Rule~3 does not apply, we have that every other vertex~ that is adjacent to~ is also adjacent to~ and vice versa. Similarly, every other vertex~ that is adjacent to~ is also adjacent to~. Thus,~, ,
  and~ have the same neighbors in~. 
This contradicts our assumption that
\cref{rule:almost-twin} does not apply.

  \emph{Case II:  contains a~  such that
     has degree at least three.}
  Since Branching~Rule~4 does not apply,
  each vertex~ is a neighbor
  of~ or~ and,
  since Case~I does not apply,
  it is not a neighbor of both.
  Moreover, since Branching~Rule~3 does not apply,
  ~can have common neighbors with at most one
  of~ and~.
  Thus, without
  loss of generality,  and~ have the same neighborhood
  in~ and~ and~ have no common neighbors.
  This contradicts our assumption that 
  \cref{rule:almost-twin2} does not apply.

  \emph{Case III:  contains a~  such that~ has degree at least three.}  
  Consider~ and~ from~.
  Since Case~II does not apply,  and~ are not middle vertices
  of a  in~.
  Moreover, since Case~I does not apply, 
   and~ are not from the same~ of~.
  Consequently, if ~is a~, then Branching Rule~1 applies.
  This implies that ~is a clique~ of size at least three.
  We now show the following claim, which contradicts our assumption
  that \cref{rule:clique-with-ends} does not apply.
  \begin{quote}
    \emph{Claim:} Each vertex of~ has at most one neighbor in~ and every
    vertex in~ has at most one neighbor in~.
  \end{quote}
  First, observe that no vertices from~ are middle vertices of a~
  in~. Thus, ~contains at most one vertex~ from each~ of~
  and this vertex~ is not a middle vertex. For each such~ from a packing~
  , the same conditions apply as to~, thus~ is a
  clique~. This implies~: Since  is a
  clique, ~is adjacent to every vertex in~ and since
   is a clique,~~is adjacent to every vertex in . Summarizing, each vertex from~ that is in a~ of  has exactly
  one neighbor outside of~, this neighbor is a middle vertex of the packing~
  containing~. These middle vertices have only one neighbor in~ since they have
  degree two and~ contains only one vertex from each packing~.

  Now let~ denote a vertex of~ that is not contained in any~ of~. We
  show that~, which implies the claim. Since the middle vertices of each~
  of~ have no neighbors outside of this~ and since Branching~Rule~2 does not apply,
  we have that~ is adjacent to at most one vertex of each packing~. Thus,
   is a clique~ as otherwise, Branching~Rule~1 applies. Again,  as
   being a clique implies that~ is adjacent to every vertex
  in~ and  being a clique implies that~ is adjacent to
  every vertex in .
 


  \emph{Case IV: otherwise.}
  We show that every vertex has degree at most two.
  This is true for the middle vertices of~s in~
  as Case~II does not apply.
  This also holds for the endpoints of~s in~
  as Case~III does not apply.
  We now argue that every other vertex~ cannot have two neighbors. 

The vertex~ has at least one
  neighbor~ from some~  of~: ~is contained in at least one~
  because the instance is reduced with respect to \cref{rule:isolated-clusters} and
  this~ contains at least two vertices of some~ of the packing because Branching~Rule~1
  does not apply.  If~ has a further
  neighbor~, then~ (since Case II does not apply) and~ since (Case~I) does not apply.
  Consequently, , , and~ form a triangle (since Branching~Rule~1 does not
  apply). 
  Thus, ~has two neighbors outside of his~ of~,
  which means that Case~III applies.

  Thus, ~has maximum degree two and does not contain isolated triangles because the instance is reduced with respect to \cref{rule:isolated-clusters}. In this case, an optimal solution
  can be obtained by computing a maximum matching~ and then
  deleting all edges of~ that are not in~.
 
  Altogether,
  the above considerations imply
  a search tree algorithm
  with search tree size~. 
  After an initial kernelization, which,
  due to \cref{cor:ce-abv-cost-t}, runs in ~time
  for~, the instance has~ vertices.
  Thus, the steps at each search tree node
  including the reduction rules
  can be performed in~~time.
  \qed
\end{proof}

\section{Hardness Results for Edge Deletion and Vertex Deletion Problems}
\label{sec:hardness}
In this section, we show edge modification problems and vertex deletion problems that are NP-hard even for small forbidden induced subgraphs and if~, where  is a vertex-disjoint packing of forbidden induced subgraphs.  We also show that algorithms for \textsc{Vertex Cover} parameterized above lower bounds do not generalize to -\textsc{Hitting Set}---the natural generalization of \textsc{Vertex Cover} to hypergraphs.
\subsection{Hard edge deletion problems}
\begin{theorem}\label{k6 hard}
For every fixed , \gfdev{K_q} is NP-hard for~.
\end{theorem}
\noindent We prove \cref{k6 hard} by giving a reduction from \POITS{} (\cref{prob:poits}).

\begin{construction}\label[construction]{k6 reduction}
  Let  be a Boolean formula
  with variables~
  and clauses~.
  We assume that each clause~ contains exactly three pairwise distinct variables.
  We create a graph~ and a vertex-disjoint -packing~ as follows.
  
  For each variable~, add a clique  on~ vertices to~ that has two distinguished disjoint edges~ and~.  For each clause~ with literals , and , add a clique  on~ vertices to~ that has three distinguished and pairwise disjoint edges~, and~ (which exist since~).  Finally, if , then identify the edge~ with~ and if , then identify the edge~ with~.
  The packing~ consists of all~ introduced for the variables~ of~.
\end{construction}









\begin{lemma}\label[lemma]{only generated cliques}
  Let ~be the graph output by \cref{k6 reduction} and let ~be
  an induced  in~. Then, ~is either one of the~ or one of the~.
\end{lemma}

\begin{proof}
  First, note that the~ are pairwise vertex-disjoint since \cref{k6 reduction} only identifies edges of~s with edges of~s and no edge in any~ is identified with edges in different~.
  For any~ and~, the vertices in~
  are nonadjacent to those in~.  Similarly,
  for  and~, the vertices in~ are
  nonadjacent to those in~ for~.  Thus, every
  clique in~ is entirely contained in one of the~ or~.\qed\end{proof}

\noindent \cref{only generated cliques} allows us to prove \cref{k6 hard}.

\begin{proof}[of \cref{k6 hard}]
  We show that  is satisfiable if and only if~ can be made -free by~~edge deletions (that is, ).

  First, assume that there is an assignment that satisfies~.  We construct a \gfdeset{K_q}~ for~ as follows: if the variable~ is set to true, then put~ into~.  If the variable~ is set to false, then add~ to~.  Thus, for each~, we add exactly one edge to~.  Since~~consists of the~, we have .  Moreover, since each clause~ contains a true literal, at least one edge of each~ is contained in~.  Thus,  is -free, since, by \cref{only generated cliques}, the only s in~ are the~ and~ and, for each of them, ~contains at least one edge.

  Now, assume that ~can be made -free by deleting a set~ of ~edges.  Then, ~deletes exactly one edge of each~ and at least one edge of each~.
  We can assume without loss of generality that~ contains either the edge~ or~ for each~ since deleting one of these edges instead of another edge in~ always yields a solution by \cref{k6 reduction}.
  Thus, the deletion set~ corresponds to a satisfying assignment for~.
\qed\end{proof}







\subsection{Hard vertex deletion problems}
\label{sec:vertex-del}
In this section,
we show NP-hardness of the problem
of destroying all induced paths~ on ~vertices
by at most~ vertex deletions
if a packing~ vertex-disjoint induced~s
in the input graph~ is provided as input.

\decprob{\PLVD}{A graph~, a vertex-disjoint packing~ of induced s, and a natural number~.}{Is there a vertex set~ of size at most~ such that~ does not contain~ as induced subgraph?}


\begin{theorem}\label{thm:pl-hard}
 For every fixed~, \PLVD{} is NP-hard even if~.
\end{theorem}

\noindent The reduction is from \textsc{-SAT}:

\begin{construction}\label[construction]{Pl construction}
  Let  be a Boolean formula
  with variables 
  and clauses~.
  We assume that each clause~
  contains exactly ~pairwise distinct variables.
  We construct a graph~
  and a maximal vertex-disjoint packing~ of~s
  as follows; an illustration of the construction is given in Figure~\ref{fig:pq-cons}.

\begin{figure}[t]\centering
  
  \begin{tikzpicture}[x=0.9cm,y=0.9cm]
    \tikzstyle{packing} = [color=lightgray,line cap=round, line
    join=round, line width=15pt]
    \tikzstyle{deleted} = [dashed]
    \tikzstyle{inserted} = [very thick]
    \tikzstyle{vertex} = [color=black,fill=black,circle]
    \begin{scope}[rotate=30]
      \node[vertex,label=left:] (x1) at (-50:3) {};
      \node[vertex,label=left:] (x2) at (-30:3) {};
      \node[vertex,label=left:] (x3) at (-10:3) {};
      \node[vertex,label=below left:] (x4) at (10:3) {};
      \node[vertex,label=below left:] (x5) at (30:3) {};
      \node[vertex,label=left :] (x6) at (50:3) {};
      \node[vertex] (a11) at (-50:4) {};
      \node[vertex] (a21) at (-30:4) {};
      \node[vertex] (a41) at (10:4) {};
      \node[vertex] (a51) at (30:4) {};
      \node[vertex] (a61) at (50:4) {};
    \end{scope}

    \begin{scope}[shift={(10,0)}, rotate=150]
      \node[vertex] (y1) at (-50:3) {};
      \node[vertex] (y2) at (-30:3) {};
      \node[vertex,label=below right:] (y3) at (-10:3) {};
      \node[vertex] (y4) at (10:3) {};
      \node[vertex] (y5) at (30:3) {};
      \node[vertex] (y6) at (50:3) {};
      \node[vertex] (b11) at (-50:4) {};
      \node[vertex] (b21) at (-30:4) {};
      \node[vertex] (b41) at (10:4) {};
      \node[vertex] (b51) at (30:4) {};
      \node[vertex] (b61) at (50:4) {};
    \end{scope}

    \begin{scope}[shift={(5,8)}, rotate=-90]
      \node[vertex] (z1) at (-50:3) {};
      \node[vertex] (z2) at (-30:3) {};
      \node[vertex] (z3) at (-10:3) {};
      \node[vertex,label=below right:] (z4) at (10:3) {};
      \node[vertex] (z5) at (30:3) {};
      \node[vertex] (z6) at (50:3) {};
      \node[vertex] (c11) at (-50:4) {};
      \node[vertex] (c21) at (-30:4) {};
      \node[vertex] (c31) at (-10:4) {};
      \node[vertex] (c51) at (30:4) {};
      \node[vertex] (c61) at (50:4) {};
    \end{scope}

    \foreach \s[evaluate=\s as \sp using int(\s+1)] in {1,...,5}
    {      
      \draw (x\s)--(x\sp.center);
      \draw (y\s)--(y\sp.center);
      \draw (z\s)--(z\sp.center);
    }
    
    \foreach \s in {1,2,4,5,6}
      {      
        \draw (x\s)--(a\s1);
        \draw (y\s)--(b\s1);
      }

      \foreach \s in {1,2,3,5,6}
      {      
        \draw (z\s)--(c\s1);
      }

    \draw (x3) edge[very thick,out=40,in=170] (y3); 
    \draw (y3) edge[very thick,out=160,in=280] (z4);


    \begin{pgfonlayer}{background}
        \draw[packing] (a11.center)--(x1.center)--(x2.center);
        \draw[packing] (a41.center)--(x4.center)--(x3.center);
        \draw[packing] (a51.center)--(x5.center)--(x6.center);
        \draw[packing] (b11.center)--(y1.center)--(y2.center);
        \draw[packing] (b41.center)--(y4.center)--(y3.center);
        \draw[packing] (b51.center)--(y5.center)--(y6.center);
        \draw[packing] (c11.center)--(z1.center)--(z2.center);
        \draw[packing] (c31.center)--(z3.center)--(z4.center);
        \draw[packing] (c51.center)--(z5.center)--(z6.center);
    \end{pgfonlayer}


  \end{tikzpicture}

  \caption{An illustration of Construction~\ref{Pl construction} for~. The figure shows parts of the variable cycles for three variables~ that occur in the clause~. The packing~s are highlighted by a gray background.}
  \label{fig:pq-cons}

\end{figure}  


  First,
  we introduce variable gadgets,
  which will ensure that a solution to~\PLVD{}
  corresponds to an assignment of~.
  In the following,
  let ~denote
  the number of occurrences of~ and~
  in clauses of~.
  For each variable~, add~ vertices:
   and~,
  where~.
  Call~ a \emph{true vertex}
  and~ a \emph{false vertex}.
  Create an induced cycle on the true and false vertices
  by adding the edge set
  
  Call this cycle the \emph{variable cycle} of~.
  
  Then, for each even~,
  attach to~ an induced~, that is,
  make one of its degree-one vertices adjacent to~.
  Then, again for each even~,
  attach to~ an induced~
  in the same fashion.
  These paths are called
  the \emph{attachment paths} of the th segment
  of the variable cycle of~.
  
  Now, for each variable~,
  assign to each clause~ containing~ or~
  a unique number~.
  Consider the number~.
  We will use vertex~ or~
  to build the clause gadget for clause~.
  If~ contains the literal~, then attach an
  induced~ to~.
  Otherwise,
  attach an induced~ to~.
  As above,
  call the path the \emph{attachment path}
  of the~th segment of the cycle.
  Now, let~
  if ~contains~,
  and let 
  if ~contains~.
  Call these vertices the \emph{literal vertices} of clause~,
  denoted~.
  The construction of~ is completed as follows. For each~ add an arbitrary set of edges to~ such that~ is an induced~.
  The -packing~ contains
  one (arbitrary) attachment path
  plus the two segment vertices
  from each segment
  of each variable cycle.
\end{construction}



\begin{proof}[of \cref{thm:pl-hard}]
  Let  be the graph output by \cref{Pl construction} and let~ be
  the -packing.
We show that  has a satisfying assignment if and only if  can be made
  -free by exactly~ vertex deletions (that is, ).

  Assume that~ has a satisfying assignment.
  For each true variable~ in this assignment,
  delete all true vertices in its variable gadget,
  that is,  for .
  For each false variable~ in this assignment,
  delete all false vertices in its variable gadget,
  that is,  for .
  Denote this vertex set by~ and observe that .
  Moreover,
  observe that each vertex on the variable cycle for~
  is either deleted
  or both of its neighbors on the cycle are deleted.
  Every~ in~
  contains at least one vertex from a variable cycle
  as the attachment paths are too short to induce~s. Thus, to show~-freeness of~ it is sufficient to show that no vertex from a variable cycle is in a~.

  Consider an undeleted vertex in the variable cycle for~.
  Assume, without loss of generality,
  that this is a true vertex~.
  If~ is even, then~ is not in a~
  as its neighbors on the cycle are deleted
  and its only other neighbor is in an attachment path.
  If~ is odd and the
  clause~ corresponding to the~th segment of the cycle
  contains~, then the only neighbor of~ in~
  is in an attachment path. It remains to show that~ is not
  in a~ if~ contains~. The only neighbors
  of~ in~ are in~.
  Observe that~ is an induced~
  and that,
  in~,
  every vertex on this path is deleted
  or its neighbors in~ are deleted.
  Hence, the connected
  component of~ containing~
  is an induced subgraph
  of~. Since the assignment is satisfying, at least one
  vertex of~ is deleted. Thus, this connected component has at
  most~ vertices and does not contain a~.
 
  Conversely,
  let~ be a size- vertex set
  such that~ is~-free.
  First, observe that,
  without loss of generality,
  for each variable cycle
  either all true or all false vertices are deleted:
  No vertex in an attachment path~ is deleted
  since it is always as good to delete
  the vertex in the variable cycle
  that has a neighbor in~.
  Hence, at least one vertex of each segment is deleted
  since, otherwise,
  one of the~'s in~ is not destroyed.
  This already requires ~vertex deletions
  and thus \emph{exactly} one vertex for each segment
  of each variable cycle
  is deleted.
  Finally, by construction,
  every adjacent pair of vertices in the variable cycle
  forms a~ with some attachment path.
  Therefore, one of the two vertices is deleted,
  which implies that either every even or every odd vertex
  of the cycle is deleted. 

  Hence, the vertex deletions in the variable cycle
  define a truth assignment~ to~:
  If all true vertices of the variable cycle of~ are deleted, 
  then set~;
  otherwise, set~.
  This assignment is satisfying:
  Since ~is -free, for each clause~,
  at least one vertex  of~ is deleted.
  Without loss of generality,
  let~, that is,
  ~contains the literal~.
  Then,  and thus ~satisfies clause~.
\qed\end{proof}

\noindent \cref{thm:pl-hard} easily transfers to a hardness result for the generalization of \textsc{Vertex Cover} to -uniform hypergraphs:

\decprob{\boldmath-\textsc{Uniform Hitting
    Set with Packing}} {A hypergraph~ with  for
  all~, a set~ of pairwise
  vertex-disjoint hyperedges, and an integer~.}{Is there a vertex
  set~ of size at most~ such that~?}

\noindent An instance  of \PLVD{} can easily be transformed into an equivalent instance~ of -\textsc{Uniform Hitting Set with Packing} by taking the hypergraph~ on the same vertex set as~ having a hyperedge~ if and only if  is a~.  The packing~ and~ stay unchanged, and so does~.  Thus, we obtain the following result:

\begin{corollary}\label[corollary]{cor:hs}
  For every~, -\textsc{Uniform Hitting Set with Packing} is NP-hard even if~.
\end{corollary}
  
\noindent \cref{cor:hs} shows that the known above-guarantee fixed-parameter algorithms for \textsc{Vertex Cover}~\cite{RO09,CPPW13,LNR+14,GP15} do not generalize to -\textsc{Uniform Hitting Set}.

\section{Conclusion}
\label{sec:conclusion}
It is open to extend our framework to further problems. The
most natural candidates appear to be problems where the forbidden induced subgraph has four vertices. Examples are \textsc{Cograph Editing}~\cite{LWGC12} which is
the problem of destroying all induced~s, \textsc{-free
  Editing}, \textsc{Claw-free Editing}, and \textsc{Diamond-free Deletion}~\cite{FGKNU11,SS15}. Another direction could be to investigate edge completion problems that allow for subexponential-time algorithms~\cite{DFPV15}. In the case of
vertex-deletion problems, \textsc{Triangle Vertex Deletion} appears to
be the most natural open case. Furthermore, it would be nice to obtain
more general theorems separating the tractable from the hard cases for
this parameterization.
For \textsc{Cluster Editing} and \textsc{Triangle Deletion} improved
running times \shorten{by better search trees} are desirable. Maybe more
importantly, it is open to determine the complexity of \textsc{Cluster
  Editing} and \textsc{Feedback Arc Set in Tournaments} parameterized
above the size of \emph{edge-disjoint} packings of forbidden
induced subgraphs.
Finally,  our framework offers an interesting tradeoff between
running time and power of generic data reduction rules. Exploring such
tradeoffs seems to be a rewarding topic for the future. The generic
rules presented in this work can be easily implemented, which asks for
subsequent experiments to evaluate their effectiveness.
\bibliographystyle{spbasic}
\bibliography{ag-editing}

\end{document}
