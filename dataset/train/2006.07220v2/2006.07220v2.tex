\documentclass{article}

\PassOptionsToPackage{sort, numbers}{natbib}








\usepackage[final]{neurips_2020}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{gensymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{isomath}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{etoolbox}
\usepackage{siunitx}
\usepackage{todonotes}
\usepackage{bbm}
\usepackage{bm}

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}


\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\clearpage{}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vsigma{{\bm{\sigma}}}
\def\vtheta{{\bm{\theta}}}
\def\vtau{{\bm{\tau}}}
\def\vphi{{\bm{\phi}}}
\def\valpha{{\bm{\alpha}}}
\def\veps{{\bm{\epsilon}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}
\newcommand{\penc}{q_{\valpha}}
\newcommand{\pdec}{p_{\vtheta}}

\newcommand{\laplace}{\mathrm{Laplace}} \newcommand{\lap}{\mathcal{L}}

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\newcommand{\RN}{\mathbb{R}}
\newcommand{\ST}{\mathcal{S}}
\newcommand{\AC}{\mathcal{A}}
\newcommand{\GS}{\mathcal{G}}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak\clearpage{}


\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=cyan,
    citecolor=black,
}



\title{On Second Order Behaviour\\in Augmented Neural ODEs}

\author{Alexander Norcliffe \\
  Department of Physics \\
  University of Cambridge \\
  \texttt{alex.norcliffe98@gmail.com}
\And
  Cristian Bodnar\thanks{corresponding authors} , Ben Day\footnotemark[1] , Nikola Simidjievski, Pietro Li\`o \\
  Department of Computer Science and Technology \\
  University of Cambridge \\
  \texttt{\{cb2015, bjd39, ns779, pl219\}@cam.ac.uk}
}




\begin{document}

\maketitle

\begin{abstract}
Neural Ordinary Differential Equations (NODEs) are a new class of models that transform data continuously through infinite-depth architectures. The continuous nature of NODEs has made them particularly suitable for learning the dynamics of complex physical systems. While previous work has mostly been focused on first order ODEs, the dynamics of many systems, especially in classical physics, are governed by second order laws. In this work, we consider Second Order Neural ODEs (SONODEs). We show how the adjoint sensitivity method can be extended to SONODEs and prove that the optimisation of a first order coupled ODE is equivalent and computationally more efficient. Furthermore, we extend the theoretical understanding of the broader class of Augmented NODEs (ANODEs) by showing they can also learn higher order dynamics with a minimal number of augmented dimensions, but at the cost of interpretability. This indicates that the advantages of ANODEs go beyond the extra space offered by the augmented dimensions, as originally thought. Finally, we compare SONODEs and ANODEs on synthetic and real dynamical systems and demonstrate that the inductive biases of the former generally result in faster training and better performance.  
\end{abstract}


\section{Introduction}
Residual Networks (ResNets) \cite{he2015deep} have been an essential tool for scaling the capabilities of neural networks to extreme depths. It has been observed that the skip layers that these networks employ can be seen as an Euler discretisation of a continuous transformation \citep{lu2017finite, Haber_2017, ruthotto2019deep}. Neural Ordinary Differential Equations (NODEs) \citep{chen2018neural} are a new class of models that consider the limit of this discretisation step, naturally giving rise to an ODE that can be optimised via black-box ODE solvers. Their continuous depth makes them particularly suitable for learning and modelling the unknown dynamics of complex systems, which often cannot be described analytically. 

Since the introduction of NODEs, many variants have been proposed~\citep{jia2019neural, Tzen2019NeuralSD, dupont2019augmented, Zhang2019ANODEV2AC, yldz2019ode2vae, poli2019graph, massaroli2020dissecting}. While a few of these models use second order dynamics \citep{yldz2019ode2vae, poli2019graph, massaroli2020dissecting}, no in-depth study on second order behaviour in Neural ODEs exists even though most dynamical systems that arise in science, such as Newton's equations of motion and oscillators, are governed by second order laws. To fill this void, we take a deeper look at Second Order Neural ODEs (SONODEs) and the broader class of models formed by Augmented Neural ODEs (ANODEs). Unlike previous approaches, which mainly focus on classification tasks, we use low-dimensional physical systems, often with known analytic solutions, as our main arena of investigation. As we will show, the simplicity of these systems is useful in analysing the properties of these models.

To summarise our contributions, we begin by studying more closely the optimisation of SONODEs by generalising the adjoint sensitivity method to second order models. We continue by analysing how some of the properties of ANODEs extend to SONODEs and show that the latter can often find simpler solutions for the problems we consider. Our analysis also extends to ANODEs and demonstrates that they are capable of learning higher-order dynamics, sometimes with just a few additional dimensions. However, the way they do so has deeper implications for their functional loss landscape and their interpretability as a scientific tool. Finally, we compare SONODEs and ANODEs on real and synthetic second order dynamical systems. Our results reveal that the inductive biases in SONODEs are beneficial in this setting. Our code is available online at \url{https://github.com/a-norcliffe/sonode}.

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/g1d.pdf}
    \vskip -0.1in
    \caption{Three learnt trajectories from the compact parity experiment ( from the original \citep{dupont2019augmented}). NODEs are not able to learn the mapping, ANODE(1) is able to learn it, SONODEs learn the simplest trajectory.}\label{fig: g1d}
\end{figure}

\section{Background}

As discussed in the introduction, Neural ODEs (NODEs) can be seen as a continuous variant of ResNet models \cite{he2015deep}, whose hidden state evolves continuously according to a differential equation

whose velocity is described by a neural network  with parameters  and initial position given by the points of a dataset . As shown by \citet{chen2018neural}, the gradients can be computed through an abstract adjoint state , once its dynamics are known.  

Our investigations are mainly focused on Augmented Neural ODEs (ANODEs)~\citep{dupont2019augmented}, which append states  to the ODE: 

We note that, unlike the original formulation, we allow for the initial values of the augmented dimensions  to be learned as a function of  by a neural network  with parameters . For the remainder of the paper, we use the ANODE() notation to signify the use of  augmented dimensions. 

We are almost exclusively concerned with the problem of learning and modelling the behaviour of dynamical systems, given  sample points , ), from a fixed set of its trajectories at multiple time steps included in the set . For such tasks, we use the mean squared error (MSE) between these points and the corresponding predicted location over all time steps for training the models. For the few toy classification tasks we include, we optimise only for the linear separability of the final positions via the cross-entropy loss function.

\section{Second Order Neural Ordinary Differential Equations}
\label{sec: sonode}

We consider Second Order Neural ODEs (SONODEs), whose initial position , initial velocity , and acceleration  are given by

where  is a neural network with parameters . Alternatively, SONODEs can be seen as a system of coupled first-order neural ODEs with state :


This formulation makes clear that SONODEs are a type of ANODE with constraints on the structure of , and offers a way to reuse NODE's first order adjoint method \citep{chen2018neural} for training, as in previous work \citep{yldz2019ode2vae, massaroli2020dissecting}. However, a pair of questions remain about the optimisation of SONODEs: firstly, what is the ODE that the second order adjoint follows? And, consequently, how does the second order adjoint sensitivity method compare with first order adjoint-based optimisation? To address these questions, we show how the adjoint sensitivity method can be generalised to SONODEs.

\begin{proposition}
\label{prop: second_order_adjoint}
The adjoint state  of SONODEs follows the second order ODE

\end{proposition}

The proof and boundary conditions for this ODE is given in Appendix~\ref{app: adjoint_method}. As an additional contribution, we include an alternative proof to those of \citet{chen2018neural} and \citet{pontryagin2018mathematical} for the first order adjoint. Given that the dynamics of the abstract adjoint vector are known, its state at all times  can be used to train the parameters  using the integral

where  denotes the loss function and  is the timestamp of interest. The gradient with respect to the parameters of the initial velocity network, , can be found in Appendix \ref{app: adjoint_method}. To answer the second question, we compare this gradient against that obtained through the adjoint of the first order coupled ODE from Equation (\ref{eq:sonode_coupled}). 

\begin{proposition}
\label{prop: adjoints_are_equivalent}
The gradient of  computed through the adjoint of the coupled ODE from (\ref{eq:sonode_coupled}) and the gradient from (\ref{eq:sonode_grad}) are equivalent. However, the latter requires at least as many matrix multiplications as the former. 
\end{proposition}

This result motivates the use of the first order coupled ODE as it presents computational advantages. The proof in Appendix~\ref{app: adjoint_method} shows that this is due to the dynamics of the adjoint from the coupled ODE, which contain entangled representations of the adjoint. This is in contrast to the disentangled representation in Equation (\ref{eqn: second_order_adjoint_maint_text_ode}), where the adjoint state and velocity are separated. It is the entangled representation that permits the faster computation of the gradients for the coupled ODE. We will see in Section \ref{sec: anodes_interpretability} that entangled representations in ANODEs are a reoccurring phenomenon, and their effects are not always beneficial, as in this case. We use the first order ODE optimisation for the remainder of our experiments.

\section{Properties of SONODEs}
\label{sec: node_problems}

In this section, we analyse certain properties of SONODEs and illustrate them with toy examples.

\subsection{Generalised parity problem}

It is known that unique trajectories in NODEs cannot cross at the same time \citep{dupont2019augmented, massaroli2020dissecting}. We extend this to higher order Initial Value Problems (IVP). Proofs are presented in Appendix \ref{app: ode_proofs}.

\begin{proposition}
\label{prop: no_crossing_different}
For a k-th order IVP, if the k-th derivative of  is Lipschitz continuous and has no explicit time dependence, then unique phase space trajectories cannot intersect at an angle. Similarly, a single phase space trajectory cannot intersect itself at an angle.
\end{proposition}

While this shows SONODE trajectories cannot cross in phase space, they can cross in real space if they have different velocities. To illustrate this, we introduce a generalised parity problem, an extension to  dimensions of the  function from \citet{dupont2019augmented}, which maps . We remark that SONODEs should be able to learn a parity flip in any number of dimensions, with a trivial solution

This is equivalent to all points moving in straight lines through the origin to . We first visualise the learnt transformation in the one dimensional case (Figure \ref{fig: g1d}), for points initialised at . SONODEs learn the simplest trajectories for this problem.

\begin{wrapfigure}{li}{0.4\textwidth}
\centering
    \includegraphics[width=0.4\textwidth]{figures/parity_problem_single.pdf}
    \vspace{-10pt}
    \caption{The logarithm of the loss in each dimension for the generalised parity problem. SONODE has the lowest loss, while the NODE loss generally oscillates between dimensions as predicted.}
    \label{fig: parity_multi_dimensions}
\end{wrapfigure}

For higher dimensions, we first remark that NODEs are able to produce parity flips for even dimensions by pairing off the dimensions and performing a  rotation in each pair. This solution does not apply to odd-dimensional cases because there is always an unpaired dimension that is not rotated.
In addition to the dimensional-parity effect, as volume increases exponentially with the dimensionality, the density exponentially decreases (given the number of points in the dataset remains constant). This makes it easier to manipulate the points without trajectories crossing, and so, it is expected that the problem will become easier for NODEs as dimensionality increases.

In Figure \ref{fig: parity_multi_dimensions}, we investigate parity flips in higher dimensions, using 50 training points and 10 test points, randomly generated between -1 and 1 in each dimension. For NODEs, as predicted, the loss oscillates over dimensions and, for odd dimensions, the loss decreases with the number of dimensions. ANODEs perform better than NODES, especially in odd dimensions, where it can rotate the unpaired dimension through the additional space. SONODEs have the lowest loss in every generalisation, which can be associated with the existence of the trivial solution in any number of dimensions, given by Equation (\ref{eqn: sonode_parity_solution}).

\subsubsection{Nested n-spheres}
\begin{figure}[b]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/g.pdf}
    \caption{The trajectories learnt by NODEs, ANODEs and SONODEs for the nested-n-spheres problem in 2D. NODEs preserves the topology so the blue region cannot escape the red region. ANODEs, as expected, use the third dimension to separate the two regions. For SONODEs the points pass through each other in real space.}
    \label{fig: g}
\end{figure}

\citet{dupont2019augmented} prove that a transformation under NODEs has to be a homeomorphism, preserving the topology of the input space, and as such, they cannot learn certain transformations. Similarly to ANODEs, SONODEs avoid this problem.

\begin{proposition}
SONODEs are not restricted to homeomorphic transformations in real space.
\end{proposition}

The proof can be found in Appendix \ref{app: sonode_not_homeomorphism}. To illustrate this, we perform an experiment on the nested n-spheres problem \citep{dupont2019augmented}, (the name is taken from \cite{massaroli2020dissecting}, originally called  function \cite{dupont2019augmented}), where the elements of the blue class are surrounded by the elements of the red class (Figure \ref{fig: g}) such that a homeomorphic transformation in that space cannot linearly separate the two classes. As expected, only ANODEs and SONODEs can learn a mapping.

\section{Second order behaviour in SONODEs and ANODEs}
\label{sec: anodes_learn_2nd_order}

Previously, the benefits of ANODEs were attributed only to the extra space they have in which to move \citep{dupont2019augmented}. However, in this section, we show that coupled first order ODEs, such as ANODEs, are also able to represent higher-order order behaviour. Additionally, we study the functional forms ANODEs can use to learn this. Unless stated we consider ANODEs in their original formulation where .

\subsection{How do ANODEs learn second order dynamics?}
\label{sec: how_anodes_learn_2nd}
Consider a SONODE as in Equation (\ref{eq:sonode_acc_form}). Similarly to the coupled ODE from Equation (\ref{eq:sonode_coupled}), ANODEs can represent this if the state, , is augmented such that  has the same dimensionality as :

where  differentiates to the acceleration and, because , the initial velocity is added to it to obtain the correct dynamics. Generalising this, it is clear to see how ANODEs can also learn -th order ODEs, by splitting up the augmented part  into  vectors with the same dimensionality as . However, if ANODEs were to learn higher order dynamics this way,  is required as an input, just as in data-controlled neural ODEs \cite{massaroli2020dissecting}. To show this is not usually the case, we let ANODE(1) learn two 1D functions at the same time with a shared ODE, using the same set of parameters, but different initial conditions. Specifically, we consider two damped harmonic oscillators

where  can be zero so that there is no decay. 

SONODEs can learn these using the functional form


\begin{wrapfigure}{li}{0.4\textwidth}
\begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.4\textwidth]
    {figures/not_mixed_double_func_theory.pdf}
\vspace{-10pt}
    \caption{ANODE(1) learning two functions using the same parameters, for  and . The real trajectories are going through their sampled data points. Augmented trajectories are plotted over their theoretical trajectories given by Equation (\ref{eqn: anode_learning_double_func}) for .}
    \vspace{-30pt}
    \label{fig: anodes_double_func}
    \end{center}
\end{wrapfigure}

It is not immediately obvious how ANODEs could solve this, especially if they follow Equation (\ref{eqn: anode_learn_2nd_order}), where  is needed as an input to determine . However, Figure \ref{fig: anodes_double_func} shows that ANODEs are able to fit the two functions in the same training session. We observe that ANODEs approximate a solution of the form:

Using , this gives the correct ODE and initial conditions in Equation (\ref{eqn: sonode_double_func}), for all finite, non-zero .

We remark that the state  and the augmented dimension  are entangled in the velocity of the state and . This example gives an intuition about the way ANODEs can learn second order behaviour through an ODE as in Equation (\ref{eqn: anode_learning_double_func}). We now formalise this intuition and give a general expression: \newline

\begin{proposition}
\label{prop: anode_general_form}
The general form ANODEs learn second order behaviour is given by:

\end{proposition}

This result is derived in Appendix \ref{app: anode_learn_second_order}. It shows that SONODEs and ANODEs learn second order dynamics in different ways. ANODEs learn an abstract function  that at  is equal to the initial velocity, and another function  that couples to  giving it the right acceleration. In contrast, SONODEs are constrained to learn the acceleration and initial velocity directly. This also leads to several useful properties that we investigate next. 

\subsection{Minimal augmentation}

The first property we analyse is called \textit{minimal augmentation}. It refers to the fact that ANODEs can learn second order dynamics even when the number of extra dimensions is less than the dimensionality of the real space.

\begin{corollary}
When the system from Proposition \ref{prop: anode_general_form} is overdetermined (i.e. ) and has a solution, the Moore-Penrose left pseudo-inverse produces that solution, given by . If no solution exists,  is the best least-squares approximation.  
\end{corollary}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/anode1_2dfunc.pdf}
    \vspace{-10pt}
    \caption{ANODE(1) learning a 2D second order function. ANODE(1) is able to learn the function, showing that it does not necessarily need double the dimensions to learn second order.}
    \label{fig: anode_1_2dfunc}
\end{figure}

In effect, ANODE is learning a system of linear equations parametrised by deep neural networks. To learn second order dynamics with minimal augmentation, it must learn an overdetermined linear system allowing a solution. Depending on the form of , it is possible that an  with explicit  dependence that produces a degenerate system like this could be learned. In turn, this would allow a complementary  to be learned. In fact, systems like this can naturally arise when the dynamics are latent and lower-dimensional and many of the observed dimensions become redundant. For instance, two spatial dimensions suffice for a pendulum moving in a plane of the 3D space.    

However, even if an overdetermined system allowing a solution could not be learned due to the additional constraints acting on , the left Moore-Penrose pseudo-inverse from Proposition \ref{prop: anode_general_form} would still produce a  that is a best least-squares approximation. If the matrix  has full rank, then the left inverse is given by . In general, the closer dim gets to dim, the better this approximation will be. 

To demonstrate minimal augmentation, we consider a two dimensional second order ODE, whose starting conditions and respective 's and 's were chosen randomly such that

ANODE(1) is able to learn this function as shown in Figure \ref{fig: anode_1_2dfunc}. Moreover, the augmented dimension trajectory differs greatly from the velocity of the ODE in either of the two spatial dimensions.

\subsection{Interpretability of ANODEs}
\label{sec: anodes_interpretability}

The result from Proposition \ref{prop: anode_general_form} also raises the issue of how \textit{interpretable} ANODEs are. For example, when investigating the dynamics of physical systems it is useful to know the force equation. This is straightforward with SONODEs, which directly learn the acceleration as a function of position, velocity and time. However, ANODEs learn the dynamics through an abstract alternative ODE where the state and augmented dimensions are entangled. This is similar to the widely studied problem of entangled representations~\citep{Higgins2017betaVAELB, Mathieu2019DisentanglingDI, bengio2012representation}. 

We then train both ANODE(2) and SONODE to learn the dynamics of the ODE from Equation (\ref{eq:2d_function}), and provide them both with the correct initial velocity. Figure \ref{fig: interpretability} shows the results for two different runs for both models. Though ANODE(2) is able to learn the true trajectory in real space, the augmented trajectories differ greatly from the true velocity of the underlying ODE. In contrast, SONODE learns the correct velocity for both runs. This simple experiment confirms that ANODEs might not be a suitable investigative tool for scientific applications, where the physical interpretability of the results is important.

\subsection{The functional loss landscape}
The functional forms the two models converge to in  Figure \ref{fig: interpretability} are not a coincidence. Proposition \ref{prop: anode_general_form} also has deeper implications for the ANODE's \textit{(functional) loss landscape} when learning second order dynamics. Please refer to Appendix \ref{app: anode_learn_second_order} for the proofs of the following results.  

\begin{proposition}
\label{prop: anode_infinity}
There are an infinity of (non-trivial) functional forms ANODEs can learn that model the true second order dynamics in real space.
\end{proposition}

This means that there is an infinite number of functions ANODEs can approximate and obtain a zero loss. This suggests that an infinite number of global minima, representing different functions, may exist in the loss landscape of ANODEs. In contrast, we show that the second order constraints imposed on SONODE enforce that any global minima in its loss landscape approximate the same function --- the acceleration and, in some cases, the initial velocity. 

\begin{proposition}
\label{prop: sonode_unique}
There is a unique functional form SONODEs can learn that models the true second order dynamics in real space.
\end{proposition}

\begin{figure}
\centering
    \includegraphics[width=\textwidth]{figures/interpretability.pdf}
    \vspace{-8pt}
    \caption{ANODEs and SONODEs successfully learn the trajectory in real space of a 2D ODE for two different random initialisations. However, the augmented trajectories of ANODE are in both cases widely different from the true velocity of the ODE. In contrast, SONODE converges in both cases to the true ODE.}
    \vspace{-10pt}
    \label{fig: interpretability}
\end{figure}

 This is confirmed by our experiment from the previous section, where ANODE always converges to another augmented trajectory for each random initialisation (only two shown in the Figure \ref{fig: interpretability}), while SONODE always converges to the correct underlying ODE. 


\section{Experiments on second order dynamics}
\label{sec: experiments}

\begin{wrapfigure}{l}{0.35\textwidth}
    \begin{center}
    \vspace{-15pt}
    \includegraphics[width=0.34\textwidth]{figures/damped_oscillators_loss.pdf}
    \caption{NODE, ANODE(1) and SONODE training on harmonic oscillators. SONODEs already have the second order behaviour built in as an architectural choice, so they are able to learn the dynamics in fewer iterations.}
    \vspace{-45pt}
    \label{fig: damped_oscillators_loss}
    \end{center}
\end{wrapfigure}

To test our above predictions, we perform an extensive comparison of ANODE and SONODE on a set of more challenging real and synthetic modelling tasks. These experiments provide further evidence for the described theoretical findings. Additional experimental details regarding the models and additional results are given in Appendix \ref{app: experimental_setup}. 





\subsection{Synthetic harmonic oscillators and noise robustness} \label{sec:synthetic}

\paragraph{Harmonic oscillator} The most obvious application of SONODEs is on dynamical data from classical physics. This was tested by looking at a damped harmonic oscillator  with
 and  on 30 random pairs of initial positions and velocities. These were each evolved for 10 seconds, using one hundred evenly spaced time stamps. The loss depended on both position and velocity explicitly, therefore the models used the state  with the option of augmentation for ANODEs. NODEs and ANODEs learnt a general , whereas SONODEs are given  and only learn . SONODEs leverage their inductive bias and converge faster than the other models. Note that, all models were able to reduce the loss to approximately zero, as shown in Figure \ref{fig: damped_oscillators_loss}.

\paragraph{Noise robustness} We tested the models' abilities to learn a sine curve in varying noise regimes. The models were trained on fifty training points in the first ten seconds of , and then tested with ten points in the next five seconds. The train points had noise added to them, drawn from a normal distribution  for different standard deviations ). The results presented in Figure \ref{fig: noise_robustness} show that SONODEs are more robust to noise. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.98\textwidth]{figures/test_loss_with_noise.pdf}
    \vspace{-10pt}
    \caption{How SONODEs and ANODEs perform learning a sine curve in different noise regimes. The dotted line separates training and testing regimes. SONODEs are able to extrapolate better than ANODEs because they are forced to learn second order dynamics, and therefore are less likely to overfit the training points.}
    \label{fig: noise_robustness}
\end{figure}


\subsection{Experiments on real-world dynamical systems}
\label{sec: planes}

\paragraph{Airplane vibrations} The dataset \cite{noel2017f} concerns real vibrations measurements of an airplane. A shaker was attached underneath the right wing, producing an acceleration . Additional accelerations at different points were measured including , which was examined in this experiment, the acceleration on the right wing, next to a non-linear interface of interest. This is a higher order system, therefore it pertains to be a challenging modelling task. The results presented in Figure \ref{fig: f16} show that while both methods can model the dynamics reasonably well, ANODEs perform marginally better. We conjecture that this is due to ANODEs not being restricted to second order behaviour, allowing them to partially access higher order dynamics. We test this conjecture in Appendix \ref{app: plane_part_2}. 


\begin{figure}[h]
\centering
    \includegraphics[width=0.98\textwidth]{figures/f16.pdf}
    \vspace{-10pt}
    \caption{ANODE(1) and SONODE on the Airplane Vibrations dataset. ANODEs are able to perform slightly better than SONODEs because they are able to access higher order dynamics. The models were trained on the first 1000 timestamps and then extrapolated to the next 4000.}
\label{fig: f16}
\end{figure}



\paragraph{Silverbox oscillator} The Silverbox dataset \cite{6669201} is an electronic circuit resembling a Duffing Oscillator, with input voltage  and measured output . The non-linear model Silverbox represents is . To account for this, all models included a  term. 
The results can be seen in Figure \ref{fig: silverbox}. On this second order system, SONODEs extrapolate better than ANODEs and are able to capture the increase in the amplitude of the signal exceptionally well. 

\begin{figure}[h]
\centering
    \includegraphics[width=0.98\textwidth]{figures/silverbox.pdf}
    \vspace{-10pt}
    \caption{ANODE(1) and SONODE on the Silverbox dataset. SONODEs are able to reduce the loss faster and to a lower value than ANODEs, as expected when second order behaviour is built in. The models were trained on the first 1000 timestamps and extrapolated to the next 4000.}
    \vspace{-10pt}
    \label{fig: silverbox}
\end{figure}


\section{Discussion and related work}

\paragraph{SONODEs vs ANODEs} SONODEs can be seen as a special case of ANODEs, whose phase space dynamics are restricted to model second order behaviour. We believe that for tasks where the trajectory is unimportant, and performance depends only on the endpoints (such as classification), ANODEs might perform better because they are unconstrained in how they use their capacity (see Appendix \ref{app: mnist}). In contrast, we expect SONODEs to outperform ANODEs both in terms of accuracy and convergence rate on time series data whose underlying dynamics is assumed (or known) to be second order. In this setting, SONODEs have a unique functional solution and fewer local minima compared to ANODEs. At the same time, they have higher parameter efficiency since  requires no parameters, so all parameters are in the acceleration. Finally, we expect SONODEs to be more appropriate for application in the natural sciences, where second order dynamics are common and it is useful to recover the force equation. 

\paragraph{Second Order Models} Concurrent to our work, SONODEs have been briefly evaluated on MNIST by \citet{massaroli2020dissecting} as part of a wider study on Neural ODEs. In contrast, our study is focused on the theoretical understanding of second order behaviour. At the same time, our investigations are largely based on learning the dynamics of physical systems rather than classification tasks. Second order models have also been considered in Graph Differential Equations~\citep{poli2019graph} and ODEVAE \citep{yldz2019ode2vae}. 

\paragraph{Physics Based Models} In the same way SONODEs assert Newtonian mechanics, other models have been made to use physical laws, guaranteeing physically plausible results, in discrete and continuous cases. \citet{lutter2019deep} apply Lagrangian mechanics to cyber-physical systems, while \citet{greydanus2019hamiltonian} and \citet{zhong2019symplectic} use Hamiltonian mechanics to learn dynamical data. 

\section{Conclusion}

In this paper, we took a closer look at how Neural ODEs (NODEs) can learn second order dynamics. In particular, we considered Second Order NODEs (SONODEs), a model constructed with this inductive bias in mind, and the more general class of Augmented Neural ODEs (ANODEs). We began by shedding light on the optimisation of SONODEs by generalising the adjoint sensitivity method from NODEs and comparing it with the training procedure of the equivalent coupled ODE. We also studied the theoretical properties of SONODEs and how they manifest in modelling toy problems.

We showed that, despite lacking the physics-based inductive biases of SONODEs, ANODEs are flexible enough to learn second order dynamics in practice. However, we also demonstrated, analytically and empirically, that they do this by learning to approximate an abstract coupled ODE where the state and augmented dimensions become entangled in the velocity. We proved that this has implications for interpretability in scientific applications as well as the `shape' of the loss landscape. Our experiments on synthetic and real second order dynamical systems validate these concerns and reveal that the inductive biases of SONODE are generally beneficial in this setting. Although this work investigates second order dynamics, the underlying principles of SONODEs can be readily extended to higher orders (a proof-of-principle is given in Appendix~\ref{app: plane_part_2}). This, in turn, allows for modelling richer and more complex behaviour, while retaining the benefits of faster training and better modelling performance.



\clearpage

\section*{Broader Impact}
Neural ODEs are relatively new models and we are yet to see their full potential. We anticipate NODEs will see particular success in time-series data, which have a wide variety of real-world applications. Examples given by \citet{jia2019neural} include the evolution of individuals' medical records and earthquake monitoring. \citet{poli2019graph} look at traffic forecasting and \citet{greydanus2019hamiltonian} show how a Neural ODE inspired by Hamiltonian mechanics can be applied to classical physics. Our work concerns Second Order Neural ODEs which can also be applied to classical physics, where Newton's second law describes the forces on an object. 

Our theoretical work was concerned with demonstrating how best to use the adjoint method on SONODEs, and showing how the coupled ODE perspective of ANODEs leads to them being able to learn second order behaviour. Naturally, any impacts from this work will come from the applications of SONODEs.

We directly investigated two potential real-world applications of SONODEs. The Silverbox dataset, an electronic implementation of a damped spring with a non-linear spring constant. This naturally applies to circuits with oscillators, and damped elements, opening new directions to monitor circuits and signals. The dynamics can also be encountered in mechanical systems, including car suspension, which could be used to improve car safety. Note that, in our experiments, we also investigated the task of modelling the vibration dynamics of an aeroplane, which might lead to better and optimal aeroplane designs. Though contributions to civil mechanical engineering such as these have parallel applications in the design of weapons, it is not the case that our investigation expands technological capabilities in such a way as to enable new forms of warfare or to significantly improve current technologies (at this stage.)

As stated, Neural ODEs are relatively new, and we are yet to see their full potential. We anticipate more applications to time series data in the future, which have many positive and negative applications, though at most we should think of our contribution as incremental in this regard and covered by existing institutions and norms.

\begin{ack}



We would like to thank C\u{a}t\u{a}lina Cangea, Jacob Deasy and Duo Wang for their helpful comments. We would like to also thank the reviewers for their constructive feedback and efforts towards improving our paper. The authors declare no competing interests.

\end{ack}



\bibliographystyle{plainnat}
\bibliography{references}

\newpage
\appendix


\section{Phase Space Trajectory Proofs}
\label{app: ode_proofs}
Here we present the proofs for the propositions from Section \ref{sec: node_problems}, concerning a -th order initial value problem.

\begin{lemma}
\label{lem: no_kink}
For a k-th order IVP, where the k-th derivative is Lipschitz continuous, a solution cannot have discontinuities in the time derivative of its phase space trajectory.
\end{lemma}

\begin{proof}
Consider the phase space trajectory . Let  be the k-th time derivative of . Then the time derivative of  is
5pt]
\displaystyle \frac{d\mathbf{x}}{dt}\\
...\\
\displaystyle \frac{d^{k-1}\mathbf{x}}{dt^{k-1}}\\
\end{bmatrix}
=
\begin{bmatrix}
\displaystyle \frac{d\mathbf{x}}{dt}\
If for one set of finite arguments, ,  is also finite, then because the gradients of  are all bounded (due to Lipschitz continuity), for any other finite arguments, ,  will remain finite. Now consider , its time derivative is , which is finite for all finite . Therefore, , can't have discontinuities with a finite derivative, and also must be finite for finite . Now consider , its time derivative is finite for all finite , and therefore it can't have discontinuities and also must be finite for all finite . This line of argument continues up to . The state  and all of its time derivatives up to the -th have no discontinuities and are finite. Therefore as long as the initial conditions  are finite, there can be no discontinuities in the time derivative of the phase space trajectory at finite time.
\end{proof}



\textbf{Proposition \ref{prop: no_crossing_different}.} \textit{For a k-th order IVP, if the k-th derivative of  is Lipschitz continuous and has no explicit time dependence, then unique phase space trajectories cannot intersect at an angle. Similarly, a single phase space trajectory cannot intersect itself at an angle.}



\begin{proof}
Consider two trajectories  and  that have different initial conditions  and . Assume the trajectories cross at a point in phase space at an angle, . If they intersect at an angle, then evolving the two states by a small time , and using the Lipschitz continuity of , meaning that the trajectories cannot have kinks in them (as shown in Lemma \ref{lem: no_kink}), . However, if they are at the same point in phase space, then they must have the same k-th order derivative, . All other derivatives are equal, so by evolving the states by the same small time , . There is a contradiction  and therefore the assumption is wrong, unique trajectories cannot cross at an angle in phase space when  is Lipschitz continuous and has no  dependence.

Now consider the single trajectory . Assume it intersects itself at an angle, at  and . Now consider two particles on this trajectory, starting at  and  such that . These two particles have different initial conditions and cross at an angle. However, the above shows that cannot happen. Therefore, the assumption that  can intersect itself at an angle must be wrong. Trajectories cannot intersect themselves in phase space at an angle.
\end{proof}


Trajectories can, however, feed into each other representing the same particle path at different times. Single phase space trajectories can feed into themselves representing periodic motion. This requires a Lipschitz continuous , and for there to be no explicit time dependence. If there was time dependence then two trajectories can cross at different times, and a trajectory can self intersect. Effectively an additional dimension is added to phase space, which is time. The propositions above would still hold because  which is Lipschitz continuous. Therefore, with time included as a phase space dimension, intersections in space are only forbidden if they occur at the same time.


\section{Adjoint Sensitivity Method}
\label{app: adjoint_method}

We present a proof to both the first and second order Adjoint method, using a Lagrangian style approach \citep{stanford_adjoint_derivation, Gholaminejad_2019}. We also prove that when the underlying ODE is second order, using the first order method on a concatenated state, , produces the same results as the second order method but does so more efficiently. All parameters, , are time-dependent.

\subsection{First Order Adjoint Method}

Let L denote a scalar loss function, , the gradient with respect to a parameter  is


The vector  is found using backpropagation. For dynamical data the loss will depend on multiple time stamps, there is also a sum over timestamps, . Therefore  is needed.  follows

subject to


where  is the data going into the network and is constant. The functions  and  describe the ODE and the initial conditions. Here we allow  to first go through the transformation, . This maintains generality and allows NODEs to be used as a component of a larger model. For example,  could go through a ResNet before the NODE, and then through a softmax classifier at the end (which is accounted for in the term ). Introduce the new variable 


These are equivalent because  and  are both zero. This means the matrices,  and , can be chosen freely (as long as they are well behaved, finite etc.), to make the computation easier. The gradients of  with respect to the parameters are


Differentiating  with respect to a general parameter 


Integrating by parts


Substituting this in and using , gives


Using the freedom of choice of , let it follow the ODE


Where  is the identity matrix. Then the first term and second integral in Equation (\ref{eqn: dFdthet}) become zero, yielding


Now using the freedom of choice of , let it obey the equation


This makes the first term in Equation (\ref{eqn: dFdthet2}) zero. This gives the final form of 


Subbing into Equation (\ref{eqn: dxdtheta}) and using the fact that  has no  dependence and  has no  dependence


This leads to the gradients of the loss


Subject to the ODE for 


Now introduce the adjoint state 


Using the fact that  is constant with respect to time, the adjoint equations are obtained by applying the definition of the adjoint in Equation (\ref{eqn: introduce_adj}), to the gradients in Equation (\ref{eqn: dLdtheta2}), and multiplying the ODE in Equation (\ref{eqn: ode_lambda_first}) by the constant 

Where the adjoint  follows the ODE


The gradients are found by integrating the adjoint state, , and the real state, , backwards in time, which requires no intermediate values to be stored, using constant memory, a major benefit over traditional backpropagation.


These are the same equations that were derived by \citet{chen2018neural}, however this includes the addition of letting  giving the corresponding gradient, . Additionally, the derivation used by \citet{chen2018neural} is simpler but does not present an obvious way to extend the adjoint method to second order ODEs, which this derivation method can do, as shown next.

\subsection{Second Order Adjoint}

Using the same derivation method, but with a second order differential equation, a second order adjoint method is derived, according to the proposition from the main text:

\textbf{Proposition \ref{prop: second_order_adjoint}.}\textit{
The adjoint state  of SONODEs follows the second order ODE

and the gradients of the loss with respect to the parameters of the acceleration,  are 

}

\begin{proof}
In general, the loss function, , depends on  and 


The gradients from the positional part and the velocity part are found separately and added. Firstly the position

Subject to the second order ODE


Following the same procedure as in first order, but including the initial condition for the velocity as well


As before, the vectors, ,  and  are zero, which gives freedom to choose the matrices ,  and  to make the calculation easier. The gradients of  with respect to the parameters  are


Differentiating  from equation \ref{eqn: F_second_order} with respect to a general parameter


Integrating by parts




Subbing these into Equation (\ref{eqn: dFdtheta_second_order_1})


Using the freedom to choose , let it follow the second order ODE


This makes the first term and first integral in Equation (\ref{eqn: dF_dtheta_second_order_2}) zero, yielding 


Now using the freedom of choice in  and 


This makes the second and third terms in Equation (\ref{eqn: dFdtheta_second_order_3}) zero, yielding


These give the final gradients of  with respect to the parameters, by subbing the results for ,  and  above into Equation (\ref{eqn: dxdtheta_second__order_1}), using the fact that ,  and  only depend on the parameters ,  and  respectively


As before, introduce the adjoint state :


Using the fact that  is constant with respect to time, all the results above, and the ODE and initial conditions for  in Equation (\ref{eqn: lambda_ode_second_order}) can be multiplied by , to get the gradients  in terms of 


Subject to the second order ODE for 


Where after differentiating with the product rule the ODE in Equation (\ref{eqn: d2adjdt2_position}) becomes


Where doing the full time derivative gives



Where the fact that  has been used. This is only when the loss depends on the position. The same method is used to look at the velocity part in Equation (\ref{eqn: dLdthet_second_order_1})


Where


The general method is to take this expression and add zeros, in the form of ,  and  multiplied by the ODE and initial conditions, ,  and . Then differentiate with respect to a general parameter  and integrate by parts to get any integrals containing  or  in terms of . Then choose the ODE for  to remove any  terms in the integral, and the initial conditions of  to remove the boundary terms at . Then  and  are chosen to remove the boundary terms at . After doing this the gradients of  with respect to the parameters are


Subject to the second order ODE for 


Now introduce the state 


Which allows the gradients of the loss with respect to the parameters to be written as


Where  follows the second order ODE and initial conditions



Now adding the gradients from the  dependence and the  dependence together. It can be seen that the gradients are the same in Equations (\ref{eqn: gradients_second_order_positional}) and (\ref{eqn: gradients_second_order_velocity}), but just swapping  and . Additionally, it can be seen from the ODEs for  and  in Equations (\ref{eqn: d2adjdt2_position_product_rule}) and (\ref{eqn: d2adjdt2_velocity}), that they are governed by the same, linear, second order ODE, with different initial conditions. Therefore the gradients, , can be written in terms of a new adjoint state, 


Where  follows the second order ODE with initial conditions


The full derivative, , is given by Equation (\ref{eqn: full_time_derivative_f(a)}). The ODE can also be written compactly as


Just as in the first order method, a sum over times stamps  may be required. This matches and extends on the gradients and ODE given by proposition \ref{prop: second_order_adjoint}.
\end{proof}

\subsection{Equivalence between the two Adjoint methods}

When acting on a concatenated state, , the first order adjoint method will produce the same gradients as the second order adjoint method. However, it is more computationally efficient to use the first order method. This is also given in the main text as the following proposition:

\textbf{Proposition \ref{prop: adjoints_are_equivalent}.}\textit{
The gradient of  computed through the adjoint of the coupled ODE from (\ref{eq:sonode_coupled}) and the gradient from (\ref{eq:sonode_grad}) are equivalent. However, the latter requires at least as many matrix multiplications as the former. }

Intuitively, the first order method will produce the same gradients because second order dynamics can be thought of as two coupled first order ODEs, where the first order dynamics happen in phase space. However, this provides no information about computational efficiency. We prove the equivalence and compare the computational efficiencies below.

\begin{proof}
The first order formulation of second order dynamics can be written as


When using index notation,  and  are concatenated to make . For  and , the index, i, ranges from 1 to , whereas for  it ranges from 1 to 2 accounting for the concatenation. This is represented below


It also extends to  and , where ,  and  also have the index range from 1 to , but the index of  goes from 1 to 2 just like for .




Using the first order adjoint method, Equations (\ref{eqn: first_order_adjoint_method_grads}) and (\ref{eqn: first_order_adjoint_method_ode}), and using index notation with repeated indices summed over, the gradients are


Where the adjoint follows the ODE



Where just like in , the index, i, ranges from 1 to 2 in the adjoint . When writing the sum over the index explicitly


Now split up the adjoint state, , into two equally sized vectors,  and , where their indices only range from 1 to , like , , ,  and .


Using Equations (\ref{eqn: z_as_x_v}), (\ref{eqn: z_dot_as_v_f}), (\ref{eqn: z0_as_s_g}) and (\ref{eqn: a_as_aa_ab}), and subbing them into Equation (\ref{eqn: explicit_sum_for_a_gradient}), the derivative can be written as


Relabelling the indices in the second sum 


Looking at specific values of i:







Relabelling the first index 


Noting that, 
, the time derivatives can be written in vector matrix notation as




Differentiating Equation (\ref{eqn: ab_dot})


This matches the ODE for the second order method in Equation (\ref{eqn: compact_ode_second_order_adjoint}). Now applying the initial conditions, using index notation again


For 


For 


Applying these initial conditions in  and  to Equation (\ref{eqn: ab_dot})


By looking at the ODE and initial conditions, it is clear  is equivalent to the second order adjoint, in Equation (\ref{eqn: adjoint_ode_initial_conditions_second_order_final}). Now looking at the gradients, and including an explicit sum over the index



The first term is zero because  has no explicit  dependence. The second term, after relabelling and using summation convention becomes


Where  has been used, as they are both the parameters for the acceleration. This matches the result for gradients of parameters in the acceleration term , when using the second order adjoint method, because  is the adjoint.

Looking at the gradients related to the initial conditions


After going through the previous process of separating out the sums from  and , then relabelling the indices on , this becomes


Using the expression for  by rearranging Equation (\ref{eqn: ab_dot}), this can be written as


The parameters  contain both  and . Looking at  first, where  has no dependence


where  can be written as a partial derivative, because  and  have no dependence on  at all. This expression is equivalent to  found using the second order adjoint method. Now looking at the parameters , these parameters are in  explicitly and , implicitly through . Subbing  into Equation (\ref{eqn: tilde_theta_s_grads}) gives



Using the fact that , this is the same result for  found using the second order adjoint method: 



All of the gradients match, so the first order adjoint method acting on  will produce the same gradients as the second order adjoint method acting on . Given by Equation (\ref{eqn: gradients_from_second_order_method_final}).

Looking at the efficiencies of each method and how they would be implemented. Both methods would integrate the state  forward in time, with . Both methods then integrate  and the adjoint backwards, in the same way. The difference is how the adjoint is represented. In first order it is represented as  where  is the adjoint, in second order it is represented as  where  is the adjoint.

The time derivatives and initial conditions for the first order adjoint representation are


The time derivatives and intial conditions for the second order adjoint representation are


Where


Looking at Equations (\ref{eq: first_order_adjoint_final}) and (\ref{eq: second_order_adjoint_final}), the second order method has the additional term, , in the ODE, and the additional term,  in the initial conditions. The first order method acting on the concatenated state, , requires equal or fewer matrix multiplications than the second order method acting on , to find the gradients at each step and the initial conditions. This is in the general case, but also for all specific cases, it is as efficient or more efficient. The same is also true for calculating the final gradients. 
\end{proof}

The reason for the difference in efficiencies is the state, , is the adjoint, and the state, , contains a lot of the complex information about the adjoint. It is an entangled representation of the adjoint, contrasting with the disentangled second order representation . This is similar to how ANODEs can learn an entangled representation of second order ODEs and SONODEs learn the disentangled representation, seen in Section \ref{sec: anodes_interpretability}. However, entangled representations are more useful here, because they do not need to be interpretable, they just need to produce the gradients, and the entangled representation can do this more efficiently.

This analysis provides useful information on the inner workings of the adjoint method. It shows a second order specific method does exist, but the first order method acting on a state  will produce the same gradients more efficiently, due to how it represents the complexity. This was specific to second order ODEs, however, the first order adjoint will work on any system of ODEs, because any motion can be thought of as being first order motion in phase space. Additionally, the first order method may be the most efficient adjoint method. The complexity going from the first order to the second order was seen based on the calculation, so this is only likely to get worse as the system of ODEs becomes more complicated.

\section{Second Order ODEs are not Homeomorphisms}
\label{app: sonode_not_homeomorphism}

One of the conditions for a transformation to be a homeomorphism is for the transformation to be bijective (one-to-one and onto). In real space, a transformation that evolves according to a second order ODE does not have to be one-to-one. This is demonstrated using a one-dimensional counter-example



If  and 


So the transformation in real space is not always one-to-one, and therefore, not always a homeomorphism. 

\section{ANODEs learning 2nd Order}
\label{app: anode_learn_second_order}

Here we present the proofs for the propositions from Section \ref{sec: anodes_learn_2nd_order}

\subsection{Functional Form Proofs}


\textbf{Proposition \ref{prop: anode_general_form}.}\textit{The general form ANODEs learn second order behaviour is given by:
}

\begin{proof}
Let  be the state vector . The time derivatives can be written as

Let  follow the second order ODE, . Differentiating  with respect to time

Using  and 


Rearranging for G

\end{proof}

In order for the solution of  to exist, the matrix  must be invertible. Either the dimension of  matches ,  and , so that  is square, or  has a left inverse. Crucially,  must have explicit  dependence, or the inverse does not exist. Intuitively, in order for real space to couple to augmented space, there must be explicit dependence.

Using the equation for , there is a gauge symmetry in the system, which proves proposition \ref{prop: anode_infinity}.

\textbf{Proposition \ref{prop: anode_infinity}.} \textit{ANODEs can learn an infinity of (non-trivial) functional forms to learn the true dynamics of a second order ODE in real space.}

\begin{proof}
Assume a solution for  and  has been found such that,  and . If an arbitrary function of , , is added to , where 

The initial velocity is still the same. The dynamics are preserved if there is a corresponding change in 

The proof can end here, however this can be simplified.  has no explicit  or  dependence, so this equation simplifies to

The term  can be Taylor expanded (assuming convergence)



Which gives the corresponding change in 

\end{proof}

This demonstrates that there are infinite functional forms that ANODEs can learn. This only considered perturbing functions . More complex functions can be added that have  or  dependence, which lead to a more complex change in . By contrast, we now show SONODEs have a unique functional form.

\textbf{Proposition \ref{prop: sonode_unique}.} \textit{SONODEs learn to approximate a unique functional form to learn the true dynamics of a second order ODE in real space.}

\begin{proof}
Consider a dynamical system


For these problems we let the loss only depend on the position, if it depends on position and velocity there would be more restrictions. So if it is true when loss only depends on the position, it is also true when it depends on both position and velocity.

Assume that there is another system, that has the same position as a function of time


Where . Because the initial conditions are given the position and velocity are defined at all times, and therefore position, velocity and acceleration can all be written as explicit functions of time. , . This allows for the acceleration to be written as a function of  only,  for all . The same applies for the second system, ,  and 


For all , , therefore, for any time increment, , . Taking the full time derivative of  and 



Using these two equations and the fact that , it is inferred that  for all . Taking the full time derivative of  and 



Using these two equation and the fact that  for all , it is also inferred that  for all .

Using these three facts, ,  and . It must also be true that . Therefore the assumption that  is incorrect, there can only be one functional form for .

Additionally, using  for all , the initial velocities must also be the same.

\end{proof}

\subsection{ANODEs Learning Two Functions}

In Section \ref{sec: how_anodes_learn_2nd}, it was shown that ANODEs were able to learn two functions at the same time

using the solution


This is a specific case of the general formulation given by Equation (\ref{eqn: anode_learn_2nd_order}). When the problem is generalised to have mixed amounts of sine and cosine in each function


ANODEs are still able to learn these functions, shown in the first plot of Figure~\ref{fig: anode_3_funcs}. As shown previously, if 
 gets the addition, , then the ODE is preserved if  also gets the addition , given by Equation (\ref{eqn: g_gauge_change}). This gauge change preserves the ODE, but gives a new expression for the initial velocity


which can be written in matrix-vector notation as

There are two equations and two unknowns,  and , so this is possible to solve, and for ANODEs to learn.\footnote{There are trivial cases where this would be impossible. For example if the two functions were , they would have the same initial position, but different initial velocities. Corresponding to the matrix in Equation (\ref{eqn: matrix-vector}) having zero determinant.} To test this even further we added a third function to be learnt. ANODEs were able to do this, shown in the second plot of Figure~\ref{fig: anode_3_funcs}.\footnote{The figure also shows that when trajectories cross in real space they do not in augmented space, and when they cross in augmented space they do not in real space, supporting Proposition \ref{prop: no_crossing_different}.} 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/triple_func.pdf}
    \caption{ANODE(1) learning two functions and three functions, with a shared ODE, but different initial conditions. The real trajectories are seen going through their sampled data points, and the corresponding augmented trajectories are also plotted. ANODE(1) is able to learn the trajectories.}
    \label{fig: anode_3_funcs}
\end{figure}







\section{Experimental Setup and Additional Results}
\label{app: experimental_setup}

We anticipate two main uses for SONODEs. One is using an experiment in a controlled environment, where the aim is to find values such as the coefficient of friction. The other use is when data is observed, and the aim is to extrapolate in time, but the experiment is not controlled, for example, observing weather. We would expect for the former, a simple model with only a single linear layer would be useful, to find those coefficients, and for the latter, a deeper model may be more appropriate. Additionally, Neural ODEs may be used in classification or other tasks that only involve the start and endpoints of the flow. For all of these tasks we used  and , and accelerations that were not time-dependent. For tasks depending on the start and endpoint only, a deeper neural network is more useful for the acceleration.

For all experiments, except the MNIST experiment, we optimise using Adam with a learning rate of 0.01. We also train on the complete datasets and do not minibatch. All the experiments were repeated 3 times to obtain a mean and standard deviation. Depending on the task at hand, we used two different architectures for NODEs, ANODEs and SONODEs. The first is a simple linear model, one weight matrix and bias without activations. This architecture, in the case of NODEs, ANODEs and SONODEs, was used on Silverbox, Airplane Vibrations and Van-Der-Pol Oscillator, with the aim of extracting coefficients from the models, for these tasks we also allowed ANODEs to learn the initial augmented position. The second architecture is a fully connected network with two hidden layers of size 20, it uses ELU activations in  and tanh activations in the initial conditions. ELU and tanh were used because they allow for negative values in the ODE \cite{massaroli2020dissecting}.  

When considering ANODEs, they are in a higher-dimensional space than the problem, and the result must be projected down to the lower dimensions. This projection was not learnt as a linear layer, instead, the components were directly selected, using an identity for the real dimensions, and zero for the augmented dimensions. This was done because a final (or initial) learnt linear layer would hide the advantages of certain models. For example, the parity problem can be solved easily if NODEs are given a final linear layer, do not move the points and then multiply by -1. For this reason, no models used a linear layer at the end of the flow. Equally, they do not initialise with a linear layer as they again hide advantages. For example, the nested n-spheres problem, NODEs can solve this with an initial linear layer, if they were to go into a higher-dimensional space the points may already be linearly separated, as shown by \citet{massaroli2020dissecting}.


\subsection{Van Der Pol Oscillator}

ANODEs and SONODEs were tested on a forced Van Der Pol (VDP) Oscillator that exhibits a chaotic behaviour. More specfically, the parameters and equations of the particular VDP oscillator are:


\begin{figure}[ht]
\centering
    \vspace{-7pt}
    \includegraphics[width=\textwidth]{figures/vdp.pdf}
    \vspace{-10pt}
    \caption{ANODE(1) and SONODE learning a Van-Der-Pol Oscillator. ANODEs are able to converge to a lower training loss, however they diverge when extrapolating. The models were trained on the first 70 points and extrapolated to 200.}
    \label{fig: vdp}
\end{figure}

As shown in Figure \ref{fig: vdp}, while ANODEs achieve a lower training loss than SONODEs, their test loss is much greater. We conjecture that, in the case of ANODEs, this is a case of overfitting. SONODEs, on the other hand, can better approximate the dynamics, therefore they exhibit better predictive performance. Note that, neither model can learn the VDP oscillator particularly well, which may be attributed to chaotic behaviour of the system at hand. 


\subsection{Third Order NODEs on Airplane Vibrations}
\label{app: plane_part_2}
We test Third Order Neural ODEs (TONODEs) on the Airplane Vibrations task from section \ref{sec: planes}. The results are in Figure \ref{fig: plane_part_2}.


\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/plane_vibrations2.pdf}
    \caption{Repeating the Airplane Vibrations task with third order NODEs (TONODEs). We see that, in this case, TONODEs are not as successful at modelling these dynamics as SONODEs and ANODEs, having a larger error both on the training data and the extrapolation.}
    \label{fig: plane_part_2}
\end{figure}

We see that TONODEs vastly underperform compared to ANODEs and SONODEs. In each of the 3 repetitions of the experiment, the different initialisation found the best solution to be at zero. Therefore, whilst the loss stays constant, the error remains large. We hypothesise that despite theoretically being able to perform at least as well as SONODEs, TONODEs avoid exponentially growing at any point by exponentially decaying towards zero. It is likely that by rescaling the time to be between 0 and 1, TONODE would approach a more accurate solution.

\subsection{First Order Dynamics and Interpolation}

SONODEs contain a subset of models that is NODEs. Consider first order dynamics that is approximated by the NODE

Carrying out the full time derivative of Equation (\ref{eq: node_interp}):


Which yields the SONODE equivalent of the learnt dynamics:


Additionally, it was shown in Equation (\ref{eq:sonode_coupled}) that SONODEs are a specific case of ANODEs that learn the initial augmented position. Therefore, anything that NODEs can learn, SONODEs should also be able to learn, and anything SONODEs can learn, ANODEs should be able to learn. To demonstrate that SONODEs and ANODEs can also learn first order dynamics, we task them with learning an exponential with no noise, . All models, as expected, are able to learn the function, as shown in Figure \ref{fig: interp}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/interpolation.pdf}
    \caption{The different models learning an exponential, simple first order dynamics, and interpolating between two observation sections. As expected, all models are able to learn the function.}
    \label{fig: interp}
\end{figure}


\subsection{Performance on MNIST}

\label{app: mnist}
NODEs, SONODEs and ANODEs were tested on MNIST \cite{lecun1998gradient} to investigate their ability on classification tasks. The networks used convolutional layers, which in the case of SONODEs were used for both the acceleration and the initial velocity. ANODEs were augmented with one additional channel as is suggested by \citet{dupont2019augmented}. The models used a training batch size of 128 and test batch size of 1000, as well as group normalisation. SGD optimiser was used with a learning rate of 0.1 and momentum 0.9. The cross-entropy loss was used. The experiment was repeated 3 times with random initialisations to obtain a mean and standard deviation. The results are given in table \ref{tab: mnist} and Figure~\ref{fig: mnist}.

\begin{table}[h!]
    \centering
    \caption{Results for the MNIST experiments at convergence. SONODE converges to a higher test accuracy than NODEs with a lower NFE. ANODEs converge to the same higher test accuracy with a higher NFE, but with a lower parameter count than SONODEs.}
    \label{tab: mnist}
    \begin{tabular}{l cc}
    \toprule
        Model &  Test Accuracy & NFE\\
    \midrule
    NODE  & 0.9961  0.0004 & 26.2  0.0\\
    SONODE  &  \textbf{0.9963  0.0001} & \textbf{20.1  0.0}\\
    ANODE & \textbf{0.9963  0.0001} & 32.2  0.0 \\ 
    \bottomrule
    \end{tabular}
\end{table}

In terms of test accuracy, SONODEs and ANODEs perform marginally better than NODEs. ANODEs can achieve the same accuracy with fewer parameters than SONODEs because the dynamics are not limited to second order and it is only the final state that is of concern in classification. However, SONODEs are able to achieve the same accuracy with a lower number of function evaluations (NFE). NFE denotes how many function evaluations are made by the ODE solver, and represents the complexity of the learnt solution. It is a continuous analogue of the depth of a discrete layered network. In the case of NODEs and ANODEs, the NFE gradually increases meaning that the complexity of the flow also increases. However, in the case of SONODEs, the NFE stays constant, suggesting that the initial velocity was associated with larger gradients (otherwise we would expect NFE to increase for SONODEs with training).


\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/mnist.pdf}
    \caption{Comparing the performance of SONODEs and NODEs on the MNIST dataset. SONODEs converge to the same training accuracy and a higher test accuracy with a lower NFE than NODEs. NODEs had 208266 parameters, SONODEs had 283658 and ANODEs had 210626. Additional parameters were associated with the initial velocity, or the augmented channel.}
    \label{fig: mnist}
\end{figure}



\end{document}
