
\documentclass{article} \usepackage[dvipsnames,table]{xcolor}
\usepackage{iclr2021_conference,epsfig,comment,booktabs,graphicx,tabulary,multirow,xspace,rotating,url,makecell,amssymb,soul,setspace,pifont,makebox,subfloat,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvi{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage[caption=false]{subfig}
\definecolor{lightgray}{gray}{0.4}
\definecolor{verylightgray}{gray}{0.9}
\usepackage{natbib}
\usepackage[colorlinks,citecolor=gray]{hyperref}

\newcommand{\xinlei}[1]{\textcolor{orange}{XC: #1}}
\newcommand{\vedanuj}[1]{{\color{blue}[VG: #1]}}
\newcommand{\kien}[1]{\textcolor{cyan}{DK: #1}} \newcommand{\graytext}[1]{\textcolor{gray}{#1}}
\newcommand{\tbd}[1]{\textcolor{gray}{\st{#1}}}
\newcommand{\ours}[0]{MoVie\xspace}
\newcommand{\trainset}[0]{\texttt{trainval}\xspace}
\newcommand{\trainonly}[0]{\texttt{train}\xspace}
\newcommand{\cmark}{\color{lightgray}\ding{51}}\newcommand{\xmark}{\color{lightgray}\ding{55}}\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1pt}}
\newcolumntype{a}{>{\columncolor{verylightgray}}c}
\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand\hshline{\noalign{\global\savewidth\arrayrulewidth
  \global\arrayrulewidth 0.6pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\footnotesize}
\makeatletter\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}
  {.5em \@plus1ex \@minus.2ex}{-.5em}{\normalfont\normalsize\bfseries}}\makeatother
\def\x{\xspace}
\newcommand{\bgamma}{\mathbf{\gamma}}
\newcommand{\bbeta}{\mathbf{\beta}}
\newcommand{\app}{\raise.17ex\hbox{}}
\newcommand{\fc}{\texttt{FC}\xspace}
\renewcommand{\dbltopfraction}{1}
\renewcommand{\bottomfraction}{0}
\renewcommand{\textfraction}{0}
\renewcommand{\dblfloatpagefraction}{0.95}
\setcounter{dbltopnumber}{5}

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother


\title{MoVie: Revisiting Modulated Convolutions for Visual Counting and Beyond}

\author{Duy-Kien Nguyen, Vedanuj Goswami, Xinlei Chen \\
Facebook AI Research (FAIR)
}


\iclrfinalcopy
\begin{document}

\maketitle

\begin{abstract}
This paper focuses on visual counting, which aims to predict the number of occurrences given a natural image and a query (\eg a question or a category). Unlike most prior works that use explicit, symbolic models which can be computationally expensive and limited in generalization, we propose a simple and effective alternative by revisiting modulated convolutions that fuse the query and the image locally. Following the design of residual bottleneck, we call our method \emph{\ours}, short for \emph{Mo}dulated con\emph{V}olut\emph{i}onal bottl\emph{e}necks. Notably, \ours reasons implicitly and holistically and only needs a single forward-pass during inference. Nevertheless, \ours showcases strong performance for counting: 1) advancing the state-of-the-art on counting-specific VQA tasks while being more efficient; 2) outperforming prior-art on difficult benchmarks like COCO for common object counting; 3) helped us secure the \emph{first} place of 2020 VQA challenge when integrated as a module for `number' related questions in generic VQA models. Finally, we show evidence that modulated convolutions such as \ours can serve as a general mechanism for reasoning tasks beyond counting. 
\end{abstract}


\section{Introduction\label{sec:intro}}

We focus on visual counting: given a natural image and a query, it aims to predict the correct number of occurrences in the image corresponding to that query. The query is generic, which can be a natural language question (\eg `how many kids are on the sofa') or a category name (\eg `car'). Since visual counting requires open-ended query grounding and multiple steps of visual reasoning~\cite{zhang2018learning}, it is a unique testbed to evaluate a machine's ability to understand multi-modal data.

Mimicking how humans count, most existing counting modules~\cite{trott2018interpretable} adopt an intuition-driven reasoning procedure, which performs counting iteratively by mapping candidate image regions to symbols and count them explicitly based on relationships (Fig.~\ref{fig:teaser}, top-left). While interpretable, modeling regions and relations repeatedly can be expensive in computation~\cite{jiang2020defense}. And more importantly, counting is merely a single visual reasoning task -- if we consider the full spectrum of reasoning tasks (\eg logical inference, spatial configuration), it is probably infeasible to manually design specialized modules for every one of them (Fig.~\ref{fig:teaser}, bottom-left).

In this paper, we aim to establish a simple and effective alternative for visual counting without explicit, symbolic reasoning. Our work is built on two research frontiers. First, on the synthetic CLEVR dataset~\cite{johnson2017clevr}, it was shown that using queries to directly modulate convolutions can lead to major improvements in the ConvNet's reasoning power (\eg achieving near-perfect 94\% accuracy on counting)~\cite{perez2018film}. However, it was difficult to transfer this finding to natural images, partially due to the dominance of bottom-up attention features that represent images with sets of regions~\cite{anderson2018bottom}. Interestingly, recent analysis discovered that plain convolutional feature maps can be as powerful as region features~\cite{jiang2020defense}, which becomes a second step-stone for our approach to compare fairly against region-based counting modules.

Motivated by fusing multi-modalities \emph{locally} for counting, the central idea behind our approach is to revisit convolutions modulated by query representations. Following ResNet~\cite{he2016deep}, we choose bottleneck as our basic building block, with each bottleneck being modulated once. Multiple bottlenecks are stacked together to form our final module. Therefore, we call our method \textbf{\ours}: \textbf{Mo}dulated con\textbf{V}olut\textbf{i}onal bottl\textbf{e}necks. Inference for \ours is performed by a simple, feed-forward pass holistically on the feature map, and reasoning is done implicitly (Fig.~\ref{fig:teaser}, top-right).

\ours demonstrates strong performance. First, it improves the state-of-the-art on several VQA-based counting benchmarks (HowMany-QA~\cite{trott2018interpretable} and TallyQA~\cite{acharya2019tallyqa}), while being more efficient. It also works well on counting common objects, significantly outperforming all previous approaches on challenging datasets like COCO~\cite{lin2014microsoft}. Furthermore, we show \ours can be easily plugged into generic VQA models and improve the `number' category on VQA 2.0~\cite{goyal2017making} -- and with the help of \ours, we won the \textbf{first} place of 2020 VQA challenge. To better understand this implicit model, we present detailed ablative analysis and visualizations of \ours, and notably find it improves upon its predecessor FiLM~\cite{perez2018film} across all the counting benchmarks we experimented, with a similar computation cost.

Finally, we validate the feasibility of \ours for reasoning tasks beyond counting (Fig.~\ref{fig:teaser}, bottom-right) by its near-perfect accuracy on CLEVR and competitive results on GQA~\cite{hudson2019gqa}. These evidences suggest that modulated convolutions such as \ours can potentially serve as a general mechanism for visual reasoning. Code will be made available. 

\begin{figure}[t]
\centering
\includegraphics[width=0.97\linewidth]{fig/teaser_xinlei_v0.pdf}
\caption{\label{fig:teaser} We study visual counting. Different from previous works that perform explicit, symbolic counting (left), we propose an implicit, holistic counter, \ours, that directly modulates convolutions (right) and can outperform state-of-the-art methods on multiple benchmarks. Its simple design also allows potential generalization beyond counting to other visual reasoning tasks (bottom).}
\end{figure}


\section{Related Work\label{sec:related}}

Here we discuss related works to the counting module, see works related to the task in appendix.

\paragraph{Explicit counting/reasoning modules.} \cite{trott2018interpretable} was among the first to treat counting differently from other types of questions, and cast the task as a sequential decision making problem optimized by reinforcement learning. A similar argument for distinction was presented in~\cite{zhang2018learning}, which took a step further by showing their fully-differentiable method can be attached to generic VQA models as a module. However, the idea of modular design for VQA was not new -- notably, several seminal works~\cite{andreas2016neural,hu2017learning} have described learnable procedures to construct networks for visual reasoning, with reusable modules optimized for particular capabilities (\eg count, compare). Our work differs from such works in philosophy, as they put more emphasis (and likely bias) on interpretation whereas we seek data-driven, general-purpose components for visual reasoning.

\paragraph{Implicit reasoning modules.} Besides modulated convolutions~\cite{perez2018film,de2017modulating}, another notable work is Relation Network~\cite{santoro2017simple}, which learns to represent pair-wise relationships between features from different locations through simple MLPs, and showcases super-human performance on CLEVR. The counter from TallyQA~\cite{acharya2019tallyqa} followed this idea and built two such networks -- one among foreground regions, and one between foreground and background. However, their counter is still based on regions, and neither generalization as a VQA module nor to other counting/reasoning tasks is shown.

Because existing VQA benchmarks like VQA 2.0 also include counting questions, generic VQA models~\cite{fukui2016multimodal,yu2019deep} without explicit counters also fall within the scope of `implicit' ones when it comes to counting. However, a key distinction of \ours is that we fuse multi-modal information \emph{locally}, which will be covered in detail in Sec.~\ref{sec:architecture} next.

\section{Counting with Modulations\label{sec:approach}}

\subsection{Modulated ConvNet\label{sec:architecture}}

\paragraph{Motivation.} Why choosing modulated convolutions for counting? Apart from empirical evidence on synthetic dataset~\cite{perez2018film}, we believe the fundamental motivation lies in the convolution operation itself. Since ConvNets operate on feature maps with \emph{spatial} dimensions (height and width), the extra modulation -- in our case the query representation -- is expected to be applied densely to all locations of the map in a fully-convolutional manner. This likely suits visual counting well for at least two reasons. First, counting (like object detection) is a \emph{translation-equivariant} problem: given a fixed-sized local window, the outcome changes as the input location changes. Therefore, a \emph{local} fusion scheme like modulated convolutions is more preferred compared to existing fusion schemes~\cite{fukui2016multimodal,yu2017multi}, which are typically applied after visual features are pooled into a single \emph{global} vector. Second, counting requires exhaustive search over all possible locations, which puts the dominating bottom-up attention features~\cite{anderson2018bottom} that sparsely sample image regions at a disadvantage in \emph{recall}, compared to convolutional features that output responses for each and every location.  

\begin{figure}[t]
\centering
\includegraphics[width=0.97\linewidth]{fig/arch_xinlei_v0.pdf}
\caption{\label{fig:architecture}\textbf{Overview of \ours} which can be placed on top of any convolutional features. The module consists of several modulated convolutional bottlenecks. Each bottleneck is a simple modified version of the residual bottleneck, with an additional modulation block before the first convolution. The output of the module is average pooled and fed into a two-layer MLP for the final answer.}
\end{figure}


\paragraph{Pipeline and module.} In Fig.~\ref{fig:architecture} (a) we show the overall pipeline. The output convolutional features from a standard ConvNet (\eg ResNet) are fed into the \ours module at the top.\footnote{In fact, the module can be placed in earlier stages, or even be split across different stages. However, we didn't find it help much but incurs extra computation overhead that computes convolutional features \emph{twice} if used as a module for generic VQA models. That's why we stick to the top.} The module consists of four modulated convolutional bottlenecks (Fig.~\ref{fig:architecture} (b)). Each bottleneck receives the query as an extra input to modulate the feature map and outputs another same-sized feature map. The final output after several stages of local fusion is average pooled and fed into a two-layer MLP classifier (with ReLU) to predict the answer. Note that we do \emph{not} apply fusion between query and the global pooled vector: all the interactions between query and image occur in modulated bottlenecks \emph{locally}.

\paragraph{Bottleneck.} As depicted in Fig.~\ref{fig:architecture} (c), \ours closely follows the original ResNet bottleneck design, which is both lightweight and effective for learning visual representations~\cite{he2016deep}. The only change is that: before the first 1{\x}1 convolution layer, we insert a modulation block that takes the query representation as a side information to modulate the feature maps, which we detail next.

\paragraph{Modulation.} We start with \emph{F}eature-w\emph{i}se \emph{L}inear \emph{M}odulation (FiLM)~\cite{perez2018film} and introduce notations. Since the modulation operation is the same across all feature vectors, we simplify by just focusing on one single vector  on the feature map, where  is the channel size. FiLM modulates  with linear transformations per channel and the output  is:

where  is element-wise multiplication,  is element-wise addition (same as normal vector addition). Intuitively,  scales the feature vector and  does shifting. Both  and  are conditioned on the query representation  through \fc weights . 

One crucial detail that stabilizes FiLM training is to predict the \emph{difference}  rather than  itself, where  and  is an all-one vector. This essentially creates a residual connection, as:

We can then view  as a residual function for modulation, conditioned jointly on  and  and will be added back to . This perspective creates opportunities for us to explore other, potentially better forms of  for counting.

The modulation block for \ours is shown in Fig.~\ref{fig:architecture} (d). The modulation function is defined as:  where  is 
a learnable weight matrix that can be easily converted to a 1{\x}1 convolution in the network. Intuitively, instead of using the output of  directly, this weight matrix learns to output  inner products between  and  weighted individually by each column in . Such increased richness allows the model to potentially capture more intricate relationships. Our final formulation for \ours is: 

Note that we also removed  and thus saved the need for . Compared to FiLM, the parameter count of \ours can be \emph{fewer}, depending on the relative size of channel  and query dimension . 
\paragraph{Scale robustness.} One concern on using convolutional feature maps directly for counting is on its sensitiveness to input image \emph{scales}, as ConvNets are fundamentally not scale-invariant. Region-based counting models~\cite{trott2018interpretable,zhang2018learning} tend to be more robust to scale changes, as their features are computed on fixed-shaped (\eg 7{\x}7) features regardless of the sizes of the corresponding bounding boxes in pixels~\cite{ren2015faster}. We find two implementation details helpful to remedy this issue. First is to always keep the input size fixed. Given an image, we resize and pad it to a global maximum size, rather than maximum size within the batch (which can vary based on aspect-ratios of sampled images). Second, we employ multi-scale training, by uniformly sampling the target image size from a pre-defined set (\eg shorter size 800 pixels). Note that input size and image size can be decoupled, and the gap is filled by zero-padding.

\paragraph{Query representation.} We consider two types of queries: questions~\cite{trott2018interpretable} or class names~\cite{chattopadhyay2017counting}. We map either into a single vector , see appendix for details.

\subsection{\ours as a Counting Module\label{sec:counter}}
An important property of a question-based visual counter is to see if it can be integrated as a \emph{module} for generic VQA models~\cite{zhang2018learning}. At a high-level, state-of-the-art VQA models~\cite{jiang2018pythia,yu2019deep} follow a common paradigm: Obtain an image representation  and a question representation , then apply a fusion scheme (\eg~\cite{fukui2016multimodal}) to produce the final answer . A VQA loss  against ground truth  is computed to train the model (Fig.~\ref{fig:fusion} (a)).

While a na\"{i}ve approach that directly appends pooled features  from \ours to  (Fig.~\ref{fig:fusion} (b)) likely suffers from feature co-adaptation~\cite{hinton2012improving}, we follow a three-branch training scheme~\cite{wang2019makes,qi2020imvotenet} by adding two \emph{auxiliary}, training-only branches: One trains the original VQA model just with , and the other trains a normal \ours with  and MLP. All three branches are assigned an equal loss weight. The fusion parameters for  and the joint branch  are not shared. This setup forces the network to learn powerful representations within  and , as they have to separately minimize the VQA loss. During testing, we only use the joint branch, leading to significant improvements especially on `number' related questions for VQA \emph{without} sacrificing inference speed (Fig.~\ref{fig:fusion} (c)).

\begin{figure}[t]
\centering
\includegraphics[width=0.97\linewidth]{fig/fusion.pdf}
\caption{\label{fig:fusion}\textbf{\ours as a counting module} for VQA. (a) A high-level overview of the current VQA systems, image  and question  are fused to predict the answer . (b) A na\"{i}ve approach to include \ours as a counting module: directly add pooled features  (with one \fc to match dimensions) to . (c) Our final design to train with two auxiliary losses on  and , while during testing only using the joint branch . Shaded areas are used for both train and test; white areas are train-only.}
\end{figure}


\section{Experiments}
We conduct a series of experiments to validate the effectiveness of \ours. By default, we use Adam~\cite{kingma2015adam} optimizer, with batch size 128 and base learning rate ; momentum 0.9 and 0.98. We start training by linearly warming up learning rate from  for 3 epochs~\cite{yu2019deep}. The rate is decayed by 0.1{\x} after 10 epochs and we finish training after 13 epochs.  

\subsection{Visual Counting\label{sec:exp:count}}

For visual counting, we have two tasks: open-ended counting with question queries where we ablated our design choices, and counting common object with class queries.

\paragraph{Open-ended counting benchmarks.} Two datasets are used to counting with question queries. First is HowMany-QA~\cite{trott2018interpretable} where the {\em train} set questions are extracted from VQA 2.0 {\em train} and Visual Genome (VG)~\cite{krishna2017visual}. The {\em val} and {\em test} sets are taken from VQA 2.0 {\em val} set. Each ground-truth answer is a number between 0 to 20. Extending HowMany-QA, the TallyQA~\cite{acharya2019tallyqa} dataset augments the {\em train} set by adding synthetic counting questions automatically generated from COCO annotations. They also split the \emph{test} set into two parts: \emph{test-simple} and \emph{test-complex}, based on whether the question requires advanced reasoning capability. The answers range between 0 and 15. For both datasets, accuracy (ACC, higher-better) and standard RMSE (lower-better)~\cite{acharya2019tallyqa} are metrics used for evaluation.

\begin{table}[t]
\centering
\subfloat[\label{tab:analysis:bottleneck_design}{\bf \ours} \vs FiLM. : residual connection.]
{
\tablestyle{8pt}{1.1}
\begin{tabular}{c|c|c|c|c}
Design &  &  & ACC  & RMSE  \\
\shline
 & \cmark & \cmark & 57.1 & 2.67 \\
 & \xmark & \cmark & 58.4 & 2.60 \\
\hshline
\multirow{3}{*}{\makecell{\\variants}} & \cmark & \xmark & 58.2 & 2.63 \\
& \xmark & \xmark & 57.9 & 2.64 \\
& \cmark & \cmark & 58.5 & 2.63 \\
\end{tabular}
}
\hspace*{0.2in}\subfloat[{\bf Number} of modulated bottlenecks.\label{tab:analysis:num_bottleneck}]
{
\tablestyle{8pt}{1.1}
\begin{tabular}{c|c|c}
\# bottlenecks &  ACC  & RMSE  \\
\shline
1 & 57.2 & 2.65 \\
2 & 58.0 & 2.63 \\
3 & 58.2 & 2.62 \\
4 & 58.4 & 2.60 \\
5 & 58.5 & 2.63 \\
\end{tabular}
}
\\
\subfloat[{\bf Fixed} \vs batch-dependent input size. \label{tab:analysis:padding}]
{
\tablestyle{4pt}{1.1}
\begin{tabular}{c|c|c|c}
Fixed input size & Test size & ACC  & RMSE  \\
\shline
\multirow{3}{*}{\xmark} & 400 & 22.1 & 4.70 \\
& 600 & 36.0 & 3.16 \\
& 800 & 56.2 & 2.68 \\
\hline
\multirow{3}{*}{\cmark} & 400 & 53.9 & 2.92 \\
& 600 & 57.3 & 2.69 \\
& 800 & 58.4 & 2.60 \\
\end{tabular}
}
\hspace*{0.2in}\subfloat[{\bf Multi-scale} \vs single-scale training.\label{tab:analysis:scale}]
{
\tablestyle{4pt}{1.1}
\begin{tabular}{c|c|c|c}
Train size & Test size & ACC  & RMSE  \\
\shline
\multirow{3}{*}{800} & 400 & 53.9 & 2.92 \\
& 600 & 57.3 & 2.69 \\
& 800 & 58.4 & 2.60 \\
\hline
\multirow{3}{*}{\{400,600,800\}} & 400 & 56.5 & 2.78 \\
& 600 & 58.8 & 2.66 \\
& 800 & 58.8 & 2.59 \\
\end{tabular}
}
\smallskip
\caption{\label{tab:analysis}\textbf{Ablative analysis} on HowMany-QA \emph{val} set. \ours modulation design outperforms FiLM under fair comparisons; both fixing input size and multi-scale training improve robustness to scales.}
\end{table}


We first conduct ablative analysis on HowMany-QA for important design choices in \ours. Here, we use fixed ResNet-50 features pre-trained on VG~\cite{jiang2020defense}, and train \ours on HowMany-QA \emph{train}, evaluate on \emph{val}. The results are summarized in Tab.~\ref{tab:analysis}.

\paragraph{Modulation design.} In Tab.~\ref{tab:analysis:bottleneck_design}, we compare \ours design with FiLM~\cite{perez2018film}: All other settings (\eg the number of bottlenecks) are fixed and only  is replaced with  in our module (see Eq.~\ref{eqn:film} and \ref{eqn:movie}). We also experimented other variants of  by switching on/off  and the residual connection (). The results indicate that: 1) The added linear mapping () is helpful for counting -- all \ours variants outperform original FiLM; 2) the residual connection also plays a role and benefits accuracy; 3) With  and ,  is less essential for counting performance. 

\paragraph{Number of bottlenecks.} We then varied the number of modulated bottlenecks, with results shown in Table \ref{tab:analysis:num_bottleneck}. We find the performance saturates around 4, but stacking multiple bottlenecks is useful compared to using a single one. We observe the same trend with FiLM but with weaker performance.

\paragraph{Scale robustness.} The last two tables \ref{tab:analysis:padding} and \ref{tab:analysis:scale} ablate our strategy to deal with input scale changes. In Tab.~\ref{tab:analysis:padding} we set a single scale (800 pixels shorter side) for training, and vary the scales during testing. If we only pad images to the largest size \emph{within} the batch, scale mismatch drastically degenerate the performance (top 3 rows). By padding the image to the maximum fixed input size, it substantially improves the robustness to scales (bottom 3 rows). Tab.~\ref{tab:analysis:scale} additionally adds multi-scale training, showing it further helps scale robustness. We use both strategies for the rest of the paper.

\begin{table}[t]
\tablestyle{2pt}{1.3}
\begin{tabular}{l|c|c|c|cc|cc|cc}
\multirow{2}{*}{Method} & \multirow{2}{*}{Backbone} & \multirow{2}{*}{\makecell{\#params\G)}} & \multicolumn{2}{c|}{HowMany-QA} & \multicolumn{2}{c|}{TallyQA-Simple} & \multicolumn{2}{c}{TallyQA-Complex} \\
& & & & ACC  & RMSE  & ACC  & RMSE  & ACC  & RMSE  \\
\shline
MUTAN~\citeyearpar{ben2017mutan} & R-152 & 60.2 & - & 45.5 & 2.93 & 56.5 & 1.51 & 49.1 & 1.59 \\
Count module~\citeyearpar{zhang2018learning} & R-101 & 44.6 & - & 54.7 & 2.59 & 70.5 & 1.15 & 50.9 & 1.58 \\
IRLC~\citeyearpar{trott2018interpretable} & R-101 & 44.6 & - & 56.1 & 2.45 & - & - & - & - \\
\hshline
TallyQA~\citeyearpar{acharya2019tallyqa} & R-101+152 & 104.8 & 1883.5 & 60.3 & 2.35 & 71.8 & 1.13 & 56.2 & {\bf 1.43} \\
TallyQA (FG-Only) & R-101 & 44.6 & 1790.9 & - & - & 69.4 & 1.18 & 51.8 & 1.50 \\
\hshline
\ours & R-50 & 25.6 & 176.1 & 61.2 & 2.36 & 70.8 & 1.09 & 54.1 & 1.52 \\
\ours & X-101 & 88.8 & 706.3 & {\bf 64.0} & {\bf 2.30} & {\bf 74.9} & {\bf 1.00} & {\bf 56.8} & {\bf 1.43} \\
\end{tabular}
\smallskip
\caption{{\bf Open-ended counting} on Howmany-QA and TallyQA {\em test} set. \ours outperforms prior arts with lower parameter counts and FLOPs. X: ResNeXt~\cite{xie2017aggregated}.}
\label{tab:vqa_count}
\end{table}


\begin{figure}[t]

\centering
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_9/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_9/img_attn_comp.png}
        \end{minipage}
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_9/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_9/img_attn.png}
        \end{minipage}
    \end{minipage}
    
    \centering
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    
\centering
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_8/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_8/img_attn.png}
        \end{minipage}
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_8/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/correct/vis_8/img_attn_comp.png}
        \end{minipage}
    \end{minipage}
    
    \centering
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    
\centering
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_6/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_6/img_attn.png}
        \end{minipage}
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_9/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_9/img_attn.png}
        \end{minipage}
    \end{minipage}
    
    \centering
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    
\centering
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_8/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_8/img_attn.png}
        \end{minipage}
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_5/img.png}
        \end{minipage}
        \begin{minipage}{0.47\linewidth}
            \centering
            \includegraphics[width=\linewidth]{fig/incorrect/vis_5/img_attn.png}
        \end{minipage}
    \end{minipage}
    
    \centering
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
    \begin{minipage}[t]{0.47\linewidth}
        \centering
        
    \end{minipage}
\caption{Visualizations of attention maps on images and questions for several complex examples in TallyQA. First two rows show successful cases, and last two shows four failure ones. Best viewed in color on a computer screen. See text for detailed explanations. \label{fig:visualization}}
\end{figure}


\paragraph{Open-ended counting results.} We report {\em test} set on counting questions for both HowMany-QA and TallyQA in Tab.~\ref{tab:vqa_count}. Even with ResNet-50, \ours already achieves strong results, \eg outperforming previous work on HowMany-QA in accuracy and TallyQA (FG-Only). With a ResNeXt-101 backbone~\cite{xie2017aggregated}, we can surpass all the previous models by a large margin \eg \app4\% in absolute accuracy on HowMany-QA. The same also holds on TallyQA, where we achieve better performance for both simple and complex questions. Note we also have lower parameter counts and FLOPs.

\paragraph{Visualization.} We visualize the activation maps produced by the last modulated bottleneck for several complex questions in TallyQA (Fig.~\ref{fig:visualization}). Specifically, we compute the normalized -norm map per-location on the feature map~\cite{malinowski2018learning}. The attention on the question is also visualized by using attention weights~\cite{nguyen2018improved} from the question encoder. First two rows give successful examples. On the left, \ours is able to focus on the relevant portions of the image to produce the correct count number, and can extract key words from the question. We further modified the questions to be more general (right), and even with a larger number to count, \ours can give the right answers. Four failure cases are shown in the last two rows, where the model either fails to predict the correct answer, or produces wrong attention maps to begin with.

\begin{table}[t]
\tablestyle{6pt}{1.2}
\begin{tabular}{l|c|cc|cc}
Method & \makecell{Instance\\supervision} & RMSE  & RMSE-nz  & rel-RMSE  & rel-RMSE-nz  \\
\shline
LC-ResFCN~\citeyearpar{laradji2018blobs} & \cmark & 0.38 & 2.20 & 0.19 & 0.99 \\
glance-noft-2L~\citeyearpar{chattopadhyay2017counting} & \xmark & 0.42 & 2.25 & 0.23 & 0.91 \\
CountSeg~\citeyearpar{cholakkal2019object} & \xmark & 0.34 & 1.89 & {\bf 0.18} & 0.84 \\
Faster R-CNN~\citeyearpar{wu2019detectron2} & \cmark & 0.35 & 1.88 & {\bf 0.18} & 0.80 \\
\hshline
\ours & \xmark & {\bf 0.30} & {\bf 1.49} & 0.19 & {\bf 0.67} \\
\end{tabular}
\smallskip
\caption{{\bf Common object counting} on COCO \emph{test} with various RMSE metrics. \ours outperforms prior state-of-the-arts without instance-level supervision.}
\label{tab:coco_counting}
\end{table}


\paragraph{Common object counting.} Second, we apply \ours to common object counting, where the query is an object category. Following standard practice, we choose ResNet-50 pre-trained on ImageNet~\cite{deng2009imagenet} as backbone which is also fine-tuned. Due to the skewed distribution between zero and non-zero answers, we perform balanced sampling during training. 

Results on COCO~\cite{lin2014microsoft} are summarized in Tab.~\ref{tab:coco_counting}, where we compared against not only the state-of-the-art counting approach CountSeg~\cite{cholakkal2019object}, but also the latest improved version of Faster R-CNN. In addition to RMSE, three variants are introduced in~\cite{chattopadhyay2017counting} with different focuses. \ours outperforms all the methods on three metrics and comes as a close second for the remaining one \emph{without} using any instance-level supervision. For more details and results on Pascal VOC~\cite{everingham2015pascal}, see appendix.

\subsection{Visual Question Answering\label{sec:exp:vqa}}

\begin{table}[t]
\tablestyle{4pt}{1.1}
\begin{tabular}{l|c|cac|c}
Method & Test set & Yes/No  & Number  & Other  & Overall  \\
\shline
\ours & \multirow{4}{*}{\emph{val}} & 82.48 & 49.26 & 54.77 & 64.46 \\
MCAN-Small~\citeyearpar{yu2019deep} & & 83.59 & 46.71 & 57.34 & 65.81 \\
MCAN-Small + \ours (na\"{i}ve fusion) & & 83.25 & 49.36 & 57.18 & 65.95 \\
MCAN-Small + \ours & & 84.01 & 50.45 & 57.87 & 66.72 \\
\hshline
MCAN-Large + X-101~\citeyearpar{jiang2020defense} & \multirow{2}{*}{\emph{test-dev}} & 88.46 & 55.68 & 62.85 & 72.59 \\
MCAN-Large + X-101 + \ours & & 88.39 & 57.05 & 63.28 & 72.91  \\
\end{tabular}
\smallskip
\caption{Top: We study different ways to incorporate \ours as a {\bf counting module} for generic VQA models. Bottom: we show consistent improvement especially for `number' questions on \emph{test-dev}.}
\label{tab:vqa_val}
\end{table}


Next, we explore \ours as a counting module for generic VQA models. We use choose MCAN~\cite{yu2019deep}, the 2019 VQA challenge winner, as our target model (see appendix for Pythia~\cite{jiang2018pythia}, the 2018 winner). For fair comparisons, we only use single-scale training, and adopt the learning rate schedule from MCAN to train \ours using fixed ResNet-50 features.

The top section of Tab.~\ref{tab:vqa_val} shows our analysis of different designs to incorporate \ours into MCAN-Small (Sec.~\ref{sec:counter}). We train all models on VQA 2.0 {\em train} and report the breakdown scores on {\em val}. Trained individually, \ours outperforms MCAN in `number' questions by a decent margin, but lags behind in other questions. Directly adding features from \ours (na\"{i}ve fusion) shows limited improvement, while our final three-branch fusion scheme is much more effective: increasing accuracy on all types with a strong emphasis on `number' while keeping added cost minimum (see appendix).

In the bottom section of Tab.~\ref{tab:vqa_val}, we further verified the effectiveness of \ours and the fusion scheme on the {\em test-dev} split of VQA 2.0, switching the base VQA model to MCAN-Large, the backbone to ResNeXt-101, and using more data (VQA 2.0 {\em train}+{\em val} and VG) for training. We find \ours consistently strengthens the counting ability. Thanks to \ours, our entry won the \textbf{first} place of 2020 VQA challenge, achieving a \emph{test-std} score of 76.29 and \emph{test-challenge} 76.36. 

\begin{table}[t]
\tablestyle{3.5pt}{1.1}
\begin{tabular}{l|cccc|c|c}
Method & CNN+LSTM & BottomUp \citeyearpar{anderson2018bottom} & MAC \citeyearpar{hudson2018compositional} & NSM* \citeyearpar{hudson2019learning} & \ours & Humans \\
\shline
Overall  & 46.6 & 49.7 & 54.1 & 63.2 & 57.1 & 89.3 \\
Binary  & 63.3 & 66.6 & 71.2 & 78.9 & 73.5 & 91.2 \\
Open  & 31.8 & 34.8 & 38.9 & 49.3 & 42.7 & 87.4 \\
\end{tabular}
\smallskip
\caption{{\bf Reasoning} on GQA {\em test} set to show the generalization of \ours beyond counting (*: uses scene-graph supervision~\cite{krishna2017visual}). We also report 97.42\% on CLEVR \emph{test} set.} 
\label{tab:gqa}
\end{table}


\subsection{Beyond Counting\label{sec:exp:beyond}}

Finally, to explore the capability of our model beyond counting, we evaluate \ours on the CLEVR dataset~\cite{johnson2017clevr}. We train our model with a ImageNet pre-trained ResNet-101 for 45 epochs, and report a (near-perfect) \emph{test} set accuracy of 97.42\% -- similar to the observation made in FiLM. This suggests it is the general idea of modulated convolutions that helped achieving strong performance on CLEVR, rather than specific forms presented in~\cite{perez2018film}.

Since CLEVR is synthetic, we also initiate an exploration of \ours on the recent natural-image reasoning dataset, GQA~\cite{hudson2019gqa}. We use ResNeXt-101 from VG and report competitive results in Tab.~\ref{tab:gqa} \emph{without} using extra supervisions like scene-graph~\cite{krishna2017visual}. Despite simpler architecture compared to models like MAC~\cite{hudson2018compositional}, we demonstrate better overall accuracy with a larger gain on open questions. 

\section{Conclusion}
In this paper, we propose a simple and effective model named \ours for visual counting by revisiting modulated convolutions that fuse queries to images locally. Different from previous works that perform explicit, symbolic reasoning, counting is done implicitly and holistically in \ours and only needs a single forward-pass during inference. We significantly outperform state-of-the-arts on \emph{three} major benchmarks in visual counting, namely HowMany-QA, Tally-QA and COCO; and show that \ours can be easily incorporated as a module for general VQA models like MCAN to improve accuracy on `number' related questions on VQA 2.0. The strong performance helped us secure the first place in the 2020 VQA challenge. Finally, we show \ours can be directly extended to perform well on datasets like CLEVR and GQA, suggesting modulated convolutions as a general mechanism can be useful for other reasoning tasks beyond counting.

\appendix

\section{Related Work for Counting Tasks\label{sec:related2}}
\paragraph{Specialized counting.} Counting for specialized objects has a number of practical applications~\cite{marsden2018people}, including but are not limited to cell counting~\cite{xie2018microscopy}, crowd counting~\cite{sindagi2017survey}, vehicle counting~\cite{onoro2016towards}, wild-life counting~\cite{arteta2016counting}, \etc. While less general, they are important computer vision applications to respective domains, \eg medical and surveillance. Standard convolution filters are used extensively in state-of-the-art models~\cite{cheng2019learning} to produce density maps that approximate the target count number in a local neighborhood. However, such models are designed to deal exclusively with a \emph{single} category of interest, and usually require point-level supervision~\cite{sindagi2017survey} in addition to the ground-truth overall count number for training. 

Another line of work on specialized counting is psychology-inspired~\cite{cutini2012subitizing}, which focuses on the phenomenon coined `subitizing'~\cite{kaufman1949discrimination}, that humans and animals can immediately tell the number of salient objects in a scene using holistic cues~\cite{zhang2015salient}. It is specialized because the number of objects is usually limited to be small (\eg up to 4~\cite{zhang2015salient}).

\paragraph{General visual counting.} Lifting the restrictions of counting one category or a few items at a time, more general task settings for counting have been introduced. Generalizing to multiple semantic classes and more instances, common object counting~\cite{chattopadhyay2017counting} as a task has been explored with a variety of strategies such as detection~\cite{ren2015faster}, ensembling~\cite{galton1907one}, or segmentation~\cite{laradji2018blobs}. The most recent development in this direction~\cite{cholakkal2019object} also adopts a density map based approach, achieving state-of-the-art with weak, image-level supervision alone. Even more general is the setting of open-ended counting, where the counting target is expressed in natural language questions~\cite{acharya2019tallyqa}. This allows more advanced `reasoning' task to be formulated involving objects, attributes, relationships, and more. Our module is designed for these general counting tasks, with the modulation coming from either a question or a class embedding.

\section{Implementation Details\label{sec:detail}}
In our experiments, query representations  have two types: questions and categories. 

\paragraph{Question representation.} We use LSTM and Self Attention (SA) layers~\cite{vaswani2017attention} for question encoding~\cite{yu2019deep}. It was shown in Natural Language Processing (NLP) research that adding SA layers helps to produce informative and discriminative language representations~\cite{devlin2019bert}; and we also empirically observe better results ( improvement in accuracy and  reduction in RMSE according to our analysis on HowMany-QA~\cite{trott2018interpretable} \emph{val} set). Specifically, a question (or sentence in NLP) consisting of  words is first converted into a sequence  of  300-dim GloVe word embeddings \cite{pennington2014glove}, which are then fed into a one-directional LSTM followed by a stacked of 4 layers of self attention:



where ,  is the  dimensional embedding for each word in the question after the -th SA layer. We cap all the questions to the same length  as in common practice and pad all-zero vectors to shorter questions~\cite{nguyen2018improved}.

Our design for the self-attention layer closely follows~\cite{vaswani2017attention} and uses multi-head attentions ( heads) with each head having  dimensions and attend with a separate set of keys, queries, and values. Layer normalization and feed-forward network are included without position embeddings.

Given the final , to get the conditional vector , we resort to a summary attention mechanism~\cite{nguyen2018improved}. A two-layer 512-dim MLP with ReLU non-linearity is applied to compute an attention score  for each word representation . We normalize all scores by soft-max to derive attention weights  and then compute an aggregated representation  via a weighted summation over .

\paragraph{Object detection based counting.} We train a Faster R-CNN~\cite{ren2015faster} with feature pyramid networks~\cite{lin2017feature} using the latest implementation on Detectron2~\cite{wu2019detectron2}. For fair comparison, we also use a ResNet-50 backbone~\cite{he2016deep} pre-trained on ImageNet, the same for our counting module. The detector is trained on the \emph{train2014} split of COCO images, which is referred as the \emph{train} set for common object counting~\cite{chattopadhyay2017counting}. We train the network for 90K iterations, reducing learning rate by 0.1\x at 60K and 80K iterations -- starting from a base learning rate of 0.02. The batch size is set to 16. Both left-right flipping and scale augmentation (randomly sampling shorter-side from \{640, 672, 704, 736, 768, 800\}) are used. The reference AP~\cite{ren2015faster} on COCO \emph{val2017} split is 37.1. We directly convert the testing output of the detector to the per-category counting numbers.

\section{Definition of RMSE Variants\label{sec:metrics}}

Besides accuracy and RMSE,\footnote{\url{https://en.wikipedia.org/wiki/Root-mean-square_deviation}} object counting~\cite{chattopadhyay2017counting} additionally proposed several variants of RMSE to evaluate a system's counting ability. For convenience, we also include them here. The standard RMSE is defined as:

where  is ground-truth,  is prediction, and  is the number of examples. Focusing more on non-zero counts, RMSE-nz tries to evaluate a model's counting ability on harder examples where the answer is at least one:

where  is the number of examples where ground-truth is non-zero. To penalize the mistakes when the count number is small (as making a mistake of 1 when the ground-truth is 2 is more serious than when the ground-truth is 100), rel-RMSE is proposed as:

And finally, rel-RMSE-nz is used to calculate the relative RMSE for non-zero examples -- both challenging and aligned with human perception.


\begin{table}[t]
\tablestyle{5pt}{1.2}
\begin{tabular}{l|c|cc|cc}
Method & \makecell{Instance\\supervision} & RMSE  & RMSE-nz  & rel-RMSE  & rel-RMSE-nz  \\
\shline
LC-ResFCN~\citeyearpar{laradji2018blobs} & \cmark & 0.31 & 1.20 & {\bf 0.17} & 0.61 \\
LC-PSPNet~\citeyearpar{laradji2018blobs} & \cmark & 0.35 & 1.32 & 0.20 & 0.70 \\
glance-noft-2L~\citeyearpar{chattopadhyay2017counting} & \xmark & 0.50 & 1.83 & 0.27 & 0.73 \\
CountSeg~\citeyearpar{cholakkal2019object} & \xmark & {\bf 0.29} & {\bf 1.14} & {\bf 0.17} & 0.61 \\
\hshline
\ours & \xmark & 0.36 & 1.37 & 0.18 & {\bf 0.56} \\
\end{tabular}
\smallskip
\caption{{\bf Common object counting} on VOC \emph{test} set with various RMSE metrics.}
\label{tab:pascal_counting}
\end{table}


\section{Common Objects Counting on VOC\label{sec:results}}

As mentioned in Sec.~\ref{sec:exp:count} of the main paper, we present the performance of \ours on {\em test} split of Pascal VOC counting dataset in Tab.~\ref{tab:pascal_counting}. Different from COCO, the VOC dataset is much smaller with 20 object categories~\cite{everingham2015pascal}. We can see that \ours achieves comparable results to the state-of-the-art method, CountSeg~\cite{cholakkal2019object} in two relative metrics (rel-RMSE and rel-RMSE-nz) and falls behind in RMSE and RMSE-nz. In contrast, as shown in Tab.~\ref{tab:coco_counting}, \ours outperforms CountSeg on COCO with a significant margin on three RMSE metrics. The performance difference in two datasets suggests that \ours scales better than CountSeg in terms of dataset size and number of categories. Moreover, the maintained advantage on relative metrics indicates the output of \ours is better aligned with human perception~\cite{chattopadhyay2017counting}.

\begin{table}[t]
\tablestyle{3pt}{1.1}
\begin{tabular}{l|cccc}
 & \# Train params (M) & \# Test params (M) & Train mem (G) & Train speed (s/iter) \\
\shline
MCAN-Large \citeyearpar{yu2019deep} & 218.2 & 218.2 & 10.5 & 0.84  \\
MCAN-Large + \ours & 260.2 & 241.2 & 11.7 & 0.89 \\
\end{tabular}
\smallskip
\caption{Adding MoVie as a module to MCAN. Training speed is \app 5\% slower, and the additional parameters during testing is minimal (\app 10\%) as it uses the joint branch only.}
\label{tab:mm_resource}
\end{table}


\section{Counting module for VQA architectures}

As mentioned in \ref{sec:counter}, we integrate \ours into VQA models as a counting module. Naturally, such an integration leads to changes in model size, training speed \etc. We report the added computational costs in Tab.~\ref{tab:mm_resource} for our three-branch fusion scheme into MCAN. We see the training speed is only \app 5\% slower, and the additional parameters used during testing is kept minimal (\app 10\%). Note that since the integration of \ours mainly benefits `number' questions, it is different from general model size increase. 

Similar to MCAN, we also conducted experiments incorporating \ours to Pythia~\cite{jiang2018pythia}, the 2018 VQA challenge winner, where we trained using the VQA 2.0 \emph{train}+\emph{val}, and evaluated on \emph{test-dev} using the server. We observe even more significant improvements on Pythia for `number' related questions (Tab.~\ref{tab:vqa_test_pythia}). \ours also improves the performance of the network in all other categories, verifying that our \ours generalizes to multiple VQA architectures.

\begin{table}[t]
\tablestyle{8pt}{1.1}
\begin{tabular}{l|c|cac|c}
Method & Test set & Yes/No  & Number  & Other  & Overall  \\
\shline
MCAN-Large + X-101~\citeyearpar{jiang2020defense} & \multirow{2}{*}{\emph{test-dev}} & 88.46 & 55.68 & 62.85 & 72.59 \\
MCAN-Large + X-101 + \ours & & 88.39 & 57.05 & 63.28 & 72.91  \\
\hshline
Pythia + X-101~\citeyearpar{jiang2018pythia} & \multirow{2}{*}{\emph{test-dev}} & 84.13 & 45.98 & 58.76 & 67.76 \\
Pythia + X-101 + \ours & & 85.15 & 53.25 & 59.31 & 69.26 \\
\end{tabular}
\smallskip
\caption{{\bf VQA accuracy} of Pythia with and without \ours on VQA 2.0 {\em test-dev} set.}
\label{tab:vqa_test_pythia}
\end{table}


\section{Visualization of Where \ours Helps\label{sec:analysis}}

\begin{figure}[t]
\centering
\includegraphics[width=1\linewidth]{fig/visualization.pdf}
\caption{Visualization of where \ours helps MCAN for different question types on VQA 2.0 \emph{val} set. We compute the probability by assigning each question to \ours based on similarity scores (see Sec.~\ref{sec:analysis} for detailed explanations). The top contributed question types are counting related, confirming that state-of-the-art VQA models that perform global fusion are not ideally designed for counting, and the value of \ours with local fusion. Best viewed on a computer screen with zoom.}
\label{fig:two_branch}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{fig/visualization_pythia.pdf}
\caption{Similar to Fig.~\ref{fig:two_branch} but with Pythia. Best viewed on a computer screen with zoom.}
\label{fig:two_branch_pythia}
\end{figure}


When \ours is used as a counting module for generic VQA tasks, we fuse features pooled from \ours and the features used by state-of-the-art VQA models (\eg MCAN~\cite{yu2019deep}) to jointly predict the answer. Then a natural question arise: where does \ours help? To answer this question, we want visualize how important \ours and the original VQA features contribute to the final answer produced by the joint model. We conduct this study for each of the 55 question types listed in the VQA 2.0 dataset~\cite{antol2015vqa} for better insights. 

Specifically, suppose a fused representation in the joint branch is denoted as , where  is from the VQA model,  is from \ours, and  is the function consisting of layers applied after the features are summed up. We can compute two variants of this representation : one \emph{without} : , and one \emph{without} : . The similarity score is then computed between two pairs via dot-product:  and . Given one question, we assign a score of 1 to \ours if , and otherwise 0. The scores within each question type are then averaged, and produces the probability of how \ours is chosen over the base VQA model for that particular question type.

We take two models as examples. One is MCAN-Small~\cite{yu2019deep} + \ours (three-branch), and the other one replaces MCAN-Small with Pythia~\cite{jiang2018pythia}. The visualizations are shown in Fig.~\ref{fig:two_branch} and Fig.~\ref{fig:two_branch_pythia}, respectively. We sort the question types based on how much \ours has contributed, \ie the `probability'. Some observations:
\begin{itemize}
    \item \ours shows significant contribution in the counting questions for both MCAN and Pythia: the top three question types are consistently `how many people are in', `how many people are', and `how many', this evidence strongly suggests that existing models that fuse features \emph{globally} between vision and language are not well suited for counting questions, and confirms the value of incorporating \ours (that performs fusion \emph{locally}) as a counting module for generic VQA models;
    \item The `Yes/No' questions are likely benefited from \ours as well, since the contribution of \ours spreads in several question types belong to that category (\eg `are', `are they', `do', \etc) -- this maybe because counting also includes `verification-of-existing' questions such as `are there people wearing hats in the image';
    \item For Pythia, we also find it likely helps `color' related questions (\eg `what color are the', `what color', \etc) and some other types -- this strengthens our exploration that our model contributes beyond counting capability.
\end{itemize}

\bibliographystyle{iclr2021_conference}
\bibliography{count}

\end{document}
