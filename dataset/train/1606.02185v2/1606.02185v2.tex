\documentclass{article} \usepackage{iclr2017_conference,times}
\usepackage{hyperref}
\usepackage{algorithm, algorithmic}
\usepackage{url}
\usepackage{amsmath, amssymb}
\usepackage{tikz}
\usetikzlibrary{bayesnet}
\usepackage{wrapfig}
\usepackage{capt-of}

\title{Towards a Neural Statistician}


\author{Harrison Edwards\\
  School of Informatics\\
  University of Edinburgh\\
  Edinburgh, UK \\
  \texttt{H.L.Edwards@sms.ed.ac.uk} \\
  \And Amos Storkey \\
  School of Informatics\\
  University of Edinburgh\\
  Edinburgh, UK \\
  \texttt{A.Storkey@ed.ac.uk} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\KL}[2]{D_{KL} \left (#1 \| #2 \right )}
\newcommand{\iid}{i.i.d }
\iclrfinalcopy \renewcommand{\baselinestretch}{0.95}

\begin{document}


\maketitle

\begin{abstract}
An \emph{efficient} learner is one who reuses what they already know to tackle a new problem. For a \emph{machine} learner, this means understanding the similarities amongst datasets. In order to do this, one must take seriously the idea of working with datasets, rather than datapoints, as the key objects to model. Towards this goal, we demonstrate an extension of a variational autoencoder that can learn a method for computing representations, or \emph{statistics}, of datasets in an unsupervised fashion. The network is trained to produce statistics that encapsulate a generative model for each dataset. Hence the network enables efficient learning from new datasets for both unsupervised and supervised tasks. We show that we are able to learn statistics that can be used for: clustering datasets, transferring generative models to new datasets, selecting representative samples of datasets and classifying previously unseen classes. We refer to our model as a \emph{neural statistician}, and by this we mean a neural network that can learn to compute summary statistics of datasets without supervision.
\end{abstract}

\section{Introduction}

\label{introduction}
The machine learning community is well-practised at learning representations of \emph{data-points} and \emph{sequences}. A middle-ground between these two is representing, or summarizing, \emph{datasets} - unordered collections of vectors, such as photos of a particular person, recordings of a given speaker or a document as a bag-of-words. Where these sets take the form of \iid samples from some distribution, such summaries are called \emph{statistics}. We explore the idea of using neural networks to learn statistics and we refer to our approach as a \emph{neural statistician}.

The key result of our approach is a \emph{statistic network} that takes as input a set of vectors and outputs a vector of summary statistics specifying a generative model of that set - a mean and variance specifying a Gaussian distribution in a latent space we term the context. The advantages of our approach are that it is:
\begin{itemize}
\item \emph{Unsupervised}: It provides principled and unsupervised way to learn summary statistics as the output of a variational encoder of a generative model.
\item \emph{Data efficient}: If one has a large number of small but related datasets, modelling the datasets jointly enables us to gain statistical strength.
\item \emph{Parameter Efficient}: By using summary statistics instead of say categorical labellings of each dataset, we decouple the number of parameters of the model from the number of datasets.
\item \emph{Capable of few-shot learning}: If the datasets correspond to examples from different classes, \emph{class embeddings} (summary statistics associated with examples from a class), allow us to handle new classes at test time.
\end{itemize}


\section{Problem Statement}
\vspace{-0.5em}
We are given datasets $D_i$ for $i \in \mathcal{I}$. Each dataset $D_i = \{x_1, \dots, x_{k_i} \}$ consists of a number of \iid samples from an associated distribution $p_i$ over $\mathbb{R}^n$. The task can be split into learning and inference components. The learning component is to produce a generative model $\hat{p}_i$ for each dataset $D_i$. We assume there is a common underlying generative process $p$ such that $p_i = p(\cdot | c_i)$ for $c_i \in \mathbb{R}^l$ drawn from $p(c)$. We refer to $c$ as the \emph{context}. The inference component is to give an approximate posterior over the context $q(c| D)$ for a given dataset produced by a \emph{statistic network}.

\vspace{-0.5em}
\section{Neural Statistician}

In order to exploit the assumption of a hierarchical generative process over datasets we will use a `parameter-transfer approach'
\citep[see][]{transfer_survey} to extend the variational autoencoder model of  \citet{variational_autoencoder}. 

\begin{center}
\begin{tabular}{c}
\begin{tikzpicture}[line width=1pt]
\node[obs]                               (x) {$x$};
  \node[latent, left=of x] (z) {$\mathbf{z}$};
  \node[latent, above=of z] (c) {$\mathbf{c}$};
\edge {z}{x};
  \edge {c}{z};

\plate {inner}{(x)(z)}{};
  \plate [inner sep=0.3cm]{outer}{(x)(z)(c)}{};
  \label{fig:basic_model}
\end{tikzpicture}
\hspace{0.1cm}
\resizebox{0.281\textwidth}{!}{\begin{tikzpicture}[line width=1.2pt]
\node[latent] (c) {$\mathbf{c}$};
\node[latent, below=of c, xshift=1cm] (z1) {$\mathbf{z_3}$};
\node[obs, below=of z1]                          (x) {$x$};
\node[latent, right=of z1] (z2){$\mathbf{z_2}$};
\node[latent, right=of z2] (z3){$\mathbf{z_1}$};
\edge {z1,z2,z3,c}{x};
  \edge {c}{z1,z2,z3};
  \edge {z1}{z2};
  \edge {z2}{z3};

\plate {}{(x)(z1)(z2)(z3)}{};
  \plate [inner sep=0.3cm]{}{(x)(z1)(z2)(z3)(c)}{};

  \end{tikzpicture}
  }
  \hspace{0.1cm}
  \resizebox{0.233\textwidth}{!}{\begin{tikzpicture}[line width=1.2pt]
\node[latent] (c) {$\mathbf{v}$};
\node[latent, left=of c] (mu) {$\mu_c$};
\node[latent, right=of c] (sigma2) {$\sigma^2_c$};
\node[latent, above=of c] (e2){$e_2$};
\node[latent, left=of e2] (e1){$e_1$};
\node[latent, right=of e2] (e3){$e_3$};
\node[obs, above=of e1] (x1){$x_1$};
\node[obs, above=of e2] (x2){$x_2$};
\node[obs, above=of e3] (x3){$x_3$};
\edge {e1,e2,e3}{c};
  \edge {c}{mu};
  \edge {c}{sigma2}
  \edge {x1}{e1};
  \edge {x2}{e2};
  \edge {x3}{e3};

\plate {}{(x1)(x2)(x3)(e1)(e2)(e3)(c)(mu)(sigma2)}{};
  \end{tikzpicture}
   }




  \end{tabular}
  \captionof{figure}{\emph{Left}: basic hierarchical model, where the plate encodes the fact that the context variable $c$ is shared across each item in a given dataset. \emph{Center}: full neural statistician model with three latent layers $z_1,z_2,z_3$. Each collection of incoming edges to a node is implemented as a neural network, the input of which is the concatenation of the edges' sources, the output of which is a parameterization of a distribution over the random variable represented by that node. \emph{Right}: The statistic network, which combines the data via an exchangeable statistic layer. \label{fig:graphical_models}}
\end{center}
\subsection{Variational Autoencoder}
The variational autoencoder is a latent variable model $p(x|z;\theta)$ (often called the decoder) with parameters $\theta$. For each observed $x$, a corresponding latent variable $z$ is drawn from $p(z)$ so that
\begin{equation}
    p(x) = \int p(x|z ; \theta) p(z) \, dz .
\end{equation}
The generative parameters $\theta$ are learned by introducing a recognition network (also called an encoder) $q(z | x ;\phi)$ with parameters $\phi$. The recognition network gives an approximate posterior over the latent variables that can then be used to give the standard variational lower bound \citep{saul_variational} on the single-datum log-likelihood. I.e. $\log P(x|\theta) \ge \mathcal{L}_x$, where
\begin{equation}
    \mathcal{L}_x = \mathbb{E}_{q(z | x, \phi)} \left [ \log p(x | z; \theta) \right ] - \KL{q(z | x ; \phi)}{p(z)}.
\end{equation}
Likewise the full-data log likelihood is lower bounded by the sum of the $\mathcal{L}_x$ terms over the whole dataset. We can then optimize this lower bound with respect to $\phi$ and $\theta$ using the reparameterization trick introduced by \citet{variational_autoencoder} and  \citet{reparam_paper} to get a Monte-Carlo estimate of the gradient.


\subsection{Basic Model}
We extend the variational autoencoder to the model depicted on the left in Figure \ref{fig:graphical_models}. This includes a latent variable $c$, the context, that varies between different datasets but is constant, a priori, for items within the same dataset. Now, the likelihood of the parameters $\theta$ for one single particular dataset $D$ is given by
\begin{equation}
    p(D) = \int p(c) \left [ \prod_{x \in D} \int p(x|z; \theta) p(z | c ; \theta) \, dz \right ] dc.
\end{equation}
The prior $p(c)$ is chosen to be a spherical Gaussian with zero mean and unit variance. The conditional $p(z | c ; \theta)$ is Gaussian with diagonal covariance, where all the mean and variance parameters depend on $c$ through a neural network. Similarly the observation model $p(x|z;\theta)$ will be a simple likelihood function appropriate to the data modality with dependence on $z$ parameterized by a neural network. For example, with real valued data, a diagonal Gaussian likelihood could be used where the mean and log variance of $x$ are created from $z$ via a neural network.

We use approximate inference networks $q(z |x, c;\phi)$, $q(c | D ; \phi)$, with parameters collected into $\phi$, to once again enable the calculation and optimization of a variational lower bound on the log-likelihood. The single dataset log likelihood lower bound is given by
\begin{multline}
      \mathcal{L}_D = \mathbb{E}_{q(c | D;\phi)} \left [ \sum_{x \in d} \mathbb{E}_{q(z|c,x ;\phi)} \left [  \log p(x|z ;\theta) \right ]  -\KL{q(z | c,x ;\phi)}{p(z | c ; \theta)} \right ]  \\ - \KL{q(c | D ; \phi)}{p(c)}.
\end{multline}
As with the generative distributions, the likelihood forms for $q(z |x, c;\phi)$ and $q(c | D ; \phi)$ are diagonal Gaussian distributions, where all the mean and log variance parameters in each distribution are produced by a neural network taking the conditioning variables as inputs. Note that $q(c | D; \phi)$ accepts as input a \emph{dataset} $D$ and we refer to this as the statistic network. We describe this in Subsection \ref{statistic_network}. 

The full-data variational bound is given by summing the variational bound for each dataset in our collection of datasets. It is by learning the difference of the within-dataset and between-dataset distributions that we are able to discover an appropriate statistic network.

\subsection{Full Model}

The basic model works well for modelling simple datasets, but struggles when the datasets have complex internal structure. To increase the sophistication of the model we use multiple stochastic layers $z_1, \dots, z_k$ and introduce skip-connections for both the inference and generative networks. The generative model is shown graphically in Figure \ref{fig:graphical_models} in the center. The probability of a dataset $D$ is then given by

\begin{equation}
    p(D) = \int p(c) \prod_{x \in D} \int p(x|c,z_{1:L}; \theta) p(z_L | c ; \theta) \prod_{i=1}^{L-1}p(z_{i} | z_{i+1},c ; \theta)\, dz_{1:L} \, dc
\end{equation}
where the $p(z_i | z_{i+1}, c, \theta)$ are again Gaussian distributions where the mean and log variance are given as the output of neural networks. The generative process for the full model is described in Algorithm \ref{alg:sampling}.

The full approximate posterior factorizes analogously as 

\begin{equation}
    q(c,z_{1:L} | D; \phi) = q(c | D; \phi) \prod_{x \in D} q(z_L | x,c; \phi) \prod_{i=1}^{L-1} q(z_{i} | z_{i+1},x,c;\phi).
\end{equation}

For convenience we give the variational lower bound as sum of a three parts, a reconstruction term $R_D$, a context divergence $C_D$ and a latent divergence $L_D$:
\begin{align}
\label{var_lower_bound}
    \mathcal{L}_D &= R_D + C_D + L_D \mbox{ with }\\
    R_D & = \mathbb{E}_{q(c | D;\phi)} 
    \sum_{x \in D} 
    \mathbb{E}_{q(z_{1:L}|c,x ;\phi)} 
    \log p(x|z_{1:L},c ;\theta) \\
    C_D &= \KL{q(c | D ; \phi)}{p(c)}\\
    L_D &= \mathbb{E}_{q(c, z_{1:L} | D ;\phi)} \left [ \sum_{x \in D} \KL{q(z_L | c,x ; \phi)}{p(z_L | c ; \theta)} \right. \nonumber \\ 
    & 
    \mbox{\hspace{4cm}}\left. +\sum_{i=1}^{L-1}
    \KL{q(z_i | z_{i+1},c,x ; \phi)}{p(z_i | z_{i+1},c ; \theta)}
    \right ].
\end{align}

The skip-connections $p(z_i | z_{i+1}, c; \theta)$ and $q(z_i | z_{i+1},x ;\phi)$ allow the context to specify a more precise distribution  for each latent variable by explaining-away more generic aspects of the dataset at each stochastic layer. This architecture was inspired by recent work on probabilistic ladder networks in \citet{prob_ladder}. Complementing these are the skip-connections from each latent variable to the observation $p(x | z_{1:L},c ; \theta)$, the intuition here is that each stochastic layer can focus on representing a certain level of abstraction, since its information does not need to be copied into the next layer, a similar approach was used in \citet{auxiliary_ladder}.

Once again, note that we are maximizing the lower bound to the log likelihood over many datasets $D$: we want to maximize the expectation of $\mathcal{L}_D$ over all datasets. We do this optimization using stochastic gradient descent. In contrast to a variational autoencoder where a minibatch would consist of a subsample of \emph{datapoints} from the dataset, we use minibatches consisting of a subsample of \emph{datasets} - tensors of shape \texttt{(batch size, sample size, number of features)}.
\subsection{Statistic Network}
\label{statistic_network}
In addition to the standard inference networks we require a \emph{statistic network} $q(c | D ; \phi)$  to give an approximate posterior over the context $c$ given a dataset $D = \{x_1, \dots , x_k \}$ . This inference network must capture the exchangeability of the data in $D$.

We use a feedforward neural network consisting of three main elements:
\begin{itemize}
\item An instance encoder $E$ that takes each individual datapoint $x_i $ to a vector $e_i = E(x_i)$.
\item An exchangeable instance pooling layer that collapses the matrix $(e_1, \dots, e_k)$ to a single pre-statistic vector $v$. Examples include elementwise means, sums, products, geometric means and maximum. We use the sample mean for all experiments.
\item A final post-pooling network that takes $v$ to a parameterization of a diagonal Gaussian.
\end{itemize}
The graphical model for this is given at the right of Figure \ref{fig:graphical_models}.

We note that the humble sample mean already gives the statistic network a great deal of representational power due to the fact that the instance encoder can learn a representation where averaging makes sense. For example since the instance encoder can approximate a polynomial on a compact domain, and so can the post-pooling network, a statistic network can approximate any moment of a distribution.
\vspace{-1em}
\section{Related Work}
Due to the general nature of the problem considered, our work touches on many different topics which we now attempt to summarize.
\vspace{-0.5em}
\paragraph{Topic models and graphical models} The form of the graphical model in Figure \ref{fig:graphical_models} on the left is equivalent to that of a standard topic model. In contrast to traditional topic models we do not use discrete latent variables, or restrict to discrete data. Work such as that by \cite{topic_model} has extended topic models in various directions, but importantly we use flexible conditional distributions and dependency structures parameterized by deep neural networks. Recent work has explored neural networks for document models \citep[see e.g.][]{neural_variational_text} but has been limited to modelling datapoints with little internal structure. Along related lines are `structured variational autoencoders' \citep[see][]{structured_vae}, where they treat the general problem of integrating graphical models with variational autoencoders.

\paragraph{Transfer learning} There is a considerable literature on transfer learning, for a survey see \citet{transfer_survey}. There they discuss `parameter-transfer' approaches whereby parameters or priors are shared across datasets, and our work fits into that paradigm. For examples see \citet{informative_vector_machine} where share they priors between Gaussian processes, and \citet{multitask_svm} where they take an SVM-like approach to share kernels.

\paragraph{One-shot Learning} Learning quickly from small amounts of data is a topic of great interest. \citet{omniglot} use Bayesian program induction for one-shot generation and classification, and \cite{siamese_one_shot} train a Siamese (\cite{siamese_if_you_please}) convolutional network for one-shot image classification. We note the relation to the recent work \citep{one_shot_generative} in which the authors use a \emph{conditional} recurrent variational autoencoder capable of one-shot generalization by taking as extra input a conditioning data point. The important differences here are that we \emph{jointly} model datasets and datapoints and consider datasets of any size. Recent approaches to one-shot classification are matching networks \citep{matching} (which was concurrent with the initial preprint of this work), and related previous work \citep{mann}. The former can be considered a kind of differentiable nearest neighbour classifier, and the latter augments their network with memory to store information about the classification problem. Both are trained end-to-end for the classification problem, whereas the present work is a general approach to learning representations of datasets. Probably the closest previous work is by \cite{one_shot_boltzmann} where the authors learn a topic model over the activations of a DBM for one-shot learning. Compared with their work we use modern architectures and easier to train VAEs, in particular we have fast and amortized feedforward inference for test (and training) datasets, avoiding the need for MCMC.

\paragraph{Multiple-Instance Learning}
There is previous work on classifying sets in multiple-instance learning, for a useful survey see \citet{classification_with_sets}. Typical approaches involve adapting kernel based methods such as \emph{support measure machines} \citep{support_measure_machines}, \emph{support distribution machines} \citep{support_distribution_machines} and \emph{multiple-instance-kernels} \citep{multiple_instance_kernels}. We do not consider applications to multiple-instance learning type problems here, but it may be fruitful to do so in the future.

\paragraph{Set2Seq} In very related work, \citet{set2seq} explore architectures for mapping sets to sequences. There they use an LSTM to repeatedly compute weighted-averages of the datapoints and use this to tackle problems such as sorting a list of numbers. The main difference between their work and ours is that they primarily consider supervised problems, whereas we present a general unsupervised method for learning representations of sets of \iid instances. In future work we may also explore recurrently computing statistics.

\paragraph{ABC}
There has also been work on learning summary statistics for Approximate Bayesian Computation by either learning to predict the parameters generating a sample as a supervised problem, or by using kernel embeddings as infinite dimensional summary statistics. See the work by \citet{kernel_bayes} for an example of kernel-based approaches. More recently \citet{deep_summary_statistics} used deep neural networks to predict the parameters generating the data. The crucial differences are that their problem is supervised, they do not leverage any exchangeability properties the data may have, nor can it deal with varying sample sizes.
\vspace{-0.5em}
\section{Experimental Results}
Given an input set $x_1, \dots x_k$ we can use the statistic network to calculate an approximate posterior over contexts $q(c|x_1, \dots, x_k; \phi)$. Under the generative model, each context $c$ specifies a conditional model $p(x | c ;\theta)$. To get samples from the model corresponding to the most likely posterior value of $c$, we set $c$ to the mean of the approximate posterior and then sample directly from the conditional distributions. This is described in Algorithm \ref{alg:cond_sampling}. We use this process in our experiments to show samples. In all experiments, we use the Adam optimization algorithm \citep{adam} to optimize the parameters of the generative models and variational approximations. Batch normalization \citep{batchnorm} is implemented for convolutional layers and we always use a batch size of $16$. We primarily use the Theano \citep{theano} framework with the Lasagne \citep{lasagne} library, but the final experiments with face data were done using Tensorflow \citep{tensorflow}. In all cases experiments were terminated after a given number of epochs when training appeared to have sufficiently converged ($300$ epochs for omniglot, youtube and spatial MNIST examples, and $50$ epochs for the synthetic experiment).

\subsection{Simple 1-D Distributions}
In our first experiment we wanted to know if the neural statistician will learn to cluster synthetic $1$-D datasets by distribution family. We generated a collection of synthetic $1$-D datasets each containing $200$ samples. Datasets consist of samples from either an Exponential, Gaussian, Uniform or Laplacian distribution with equal probability. Means and variances are sampled from $U[-1,1]$ and $U[0.5,2]$ respectively. The training data contains $10K$ sets.

 The architecture for this experiment contains a single stochastic layer with $32$ units for $z$ and $3$ units for $c$, . The model $p(x | z,c ; \theta)$ and variational approximation $q(z | x,c ; \phi)$ are each a diagonal Gaussian distribution with all mean and log variance parameters given by a network composed of three dense layers with ReLU activations and $128$ units. The statistic network determining the mean and log variance parameters of posterior over context variables is composed of three dense layers before and after pooling, each with $128$ units with Rectified Linear Unit (ReLU) activations.
 
Figure \ref{fig:synthetic_data}  shows  3-D scatter plots of the summary statistics learned. Notice that the different families of distribution cluster. It is interesting to observe that the Exponential cluster is differently orientated to the others, perhaps reflecting the fact that it is the only non-symmetric distribution. We also see that between the Gaussian and Laplacian clusters there is an area of ambiguity which is as one might expect. We also see that within each cluster the mean and variance are mapped to orthogonal directions.
\begin{figure}
\centering
\begin{minipage}{0.4\textwidth}
\hspace{-2em}
\includegraphics[width=1\linewidth]{synthetic_dist.png}
\vspace{0.4em}
\end{minipage}

\begin{minipage}{0.4\textwidth}
\includegraphics[width=1\linewidth]{synthetic_mean.png}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\vspace{-0.9em}
\includegraphics[width=1\linewidth]{synthetic_var.png}
\end{minipage}
\caption{Three different views of the same data. Each point is the mean of the approximate posterior over the context $q(c | D ;\phi)$ where $c \in \mathbb{R}^3$. Each point is a summary statistic for a single dataset with 200 samples. Top plot shows points colored by distribution family, left plot colored by the mean and right plot colored by the variance. The plots have been rotated to illustrative angles. \label{fig:synthetic_data}}
\end{figure}


\subsection{Spatial MNIST}
\begin{wrapfigure}{R}{0.32\linewidth}
\centering
\includegraphics[width=0.6\linewidth]{joint_mnist_sample.png}
\caption{An \emph{image} from MNIST on the left, transformed to a \emph{set} of  $50$ $(x,y)$ coordinates, shown as a scatter plot on the right. \label{fig:spatial_mnist_sampling}}

\end{wrapfigure}
Building on the previous experiments we investigate 2-D datasets that have complex structure, but the datapoints contain little information by themselves, making it a good test of the statistic network. We created a dataset called \emph{spatial MNIST}. In spatial MNIST each image from MNIST \citep{mnist} is turned into a dataset by interpreting the normalized pixel intensities as a probability density and sampling \emph{coordinate values}. An example is shown in Figure \ref{fig:spatial_mnist_sampling}. This creates two-dimensional spatial datasets. We used a sample size of $50$. Note that since the pixel coordinates are discrete, it is necessary to dequantize them by adding uniform noise $u \sim U[0,1]$ to the coordinates if one models them as real numbers, else you can get arbitrarily high densities (see \citet{note_evaluation_generative} for a discussion of this point).

The generative architecture for this experiment contains $3$ stochastic $z$ layers, each with $2$ units, and a single $c$ layer with $64$ units. The means and log variances of the Gaussian likelihood for $p(x|z_{1:3},c ;\theta)$, and each subnetwork for $z$ in both the encoder and decoder contained $3$ dense layers with $256$ ReLU units each. The statistic network also contained 3 dense layers pre-pooling and 3 dense layers post pooling with 256 ReLU units.

In addition to being able to sample from the model conditioned on a set of inputs, we can also summarize a dataset by choosing a subset $S \subseteq D$ to minimise the KL divergence of $q(C | D ;\phi)$ from $q(C | S; \phi)$. We do this greedily by iteratively discarding points from the full sample. Pseudocode for this process is given in Algorithm \ref{alg:subsample}.
The results are shown in Figure \ref{fig:spatial_mnist_examples}. We see that the model is capable of handling complex arrangements of datapoints. We also see that it can select sensible subsets of a dataset as a summary. 
\begin{figure}
\centering
\includegraphics[width=\linewidth]{spatial_mnist_summary_and_sample.png}
\vspace{-1.5em}
\caption{Conditioned samples from spatial MNIST data. Blue and red digits are the input sets, black digits above correspond to samples given the input. Red points correspond to a $6$-sample summary of the dataset \label{fig:spatial_mnist_examples}}
\end{figure}


\subsection{Omniglot}
Next we work with the OMNIGLOT data \citep{omniglot}. This contains 1628 classes of handwritten characters but with just 20 examples per class. This makes it an excellent test-bed for transfer / few-shot learning. We constructed datasets by splitting each class into datasets of size 5. We train on datasets drawn from 1200 classes and reserve the remaining classes to test few-shot sampling and classification. We created new classes by rotating and reflecting characters. We resized the images to $28 \times 28$. We sampled a binarization of each image for each epoch. We also randomly applied the dilation operator from computer vision as further data augmentation since we observed that the stroke widths are quite uniform in the OMNIGLOT data, whereas there is substantial variation in MNIST, this augmentation improved the visual quality of the few-shot MNIST samples considerably and increased the few-shot classification accuracy by about $3$ percent. Finally we used `sample dropout' whereby a random subset of each dataset was removed from the pooling in the statistic network, and then included the number of samples remaining  as an extra feature. This was beneficial since it reduced overfitting and also allowed the statistic network to learn to adjust the approximate posterior over $c$ based on the number of samples.

We used a single stochastic layer with 16 units for $z$, and $512$ units for $c$. We used a shared convolutional encoder between the inference and statistic networks and a deconvolutional decoder network. Full details of the networks are given in Appendix \ref{appendixb:omniglot}. The decoder used a Bernoulli likelihood. 

In Figure \ref{fig:small_shot} we show two examples of few-shot learning by conditioning on samples of \emph{unseen} characters from OMNIGLOT, and conditioning on samples of digits from MNIST. The  samples are mostly of a high-quality, and this shows that the neural statistician can generalize even to new datasets. 

\begin{figure}
\begin{minipage}{0.5\textwidth}
\centering
\includegraphics[scale=0.5]{small_shot_mnist.png}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\centering
\includegraphics[scale=0.5]{best_cond_5_shot_omniglot.png}
\end{minipage}
\caption{Few-shot learning \emph{Left}: Few-shot learning from OMNIGLOT to MNIST. Left rows are input sets, right rows are samples given the inputs. \emph{Right}: Few-shot learning from with OMNIGLOT data to unseen classes. Left rows are input sets, right rows are samples given the inputs. Black-white inversion is applied for ease of viewing. \label{fig:small_shot}}
\vspace{-1em}
\end{figure}

As a further test we considered few-shot classification of both unseen OMNIGLOT characters and MNIST digits. Given a sets of labelled examples of each class $D_0, \dots, D_9$ (for MNIST say), we computed the approximate posteriors $q(C | D_i ; \phi )$ using the statistic network. Then for each test image $x$ we also computed the posterior $q(C | x ; \phi)$ and classified it according to the training dataset $D_i$ minimizing the KL divergence \emph{from} the test context \emph{to} the training context. This process is described in Algorithm \ref{alg:fewshot}. We tried this with either 1 or 5 labelled examples per class and either $5$ or $20$ classes. For each trial we randomly select $K$ classes, randomly select training examples for each class, and test on the remaining examples. This process is repeated 100 times and the results averaged. The results are shown in Table \ref{table:small_shot_classification}. We compare to a number of results reported in \citet{matching} including \citet{mann}  and \citet{siamese_one_shot}. Overall we see that the neural statistician model can be used as a strong classifier, particularly for the $5$-way tasks, but performs worse than matching networks for the $20$-way tasks. One important advantage that matching networks have is that, whilst each class is processed independently in our model, the representation in matching networks is conditioned on all of the classes in the few-shot problem. This means that it can exaggerate differences between similar classes, which are more likely to appear in a 20-way problem than a 5-way problem.
\vspace{-1em}
\begin{table}[!hb]
    \centering
    \begin{tabular}{  l  l  l |  l l l l}
    \multicolumn{3}{c|}{\bf{Task}} & \multicolumn{4}{c}{\bf{Method}} \\
\bf{Test Dataset} & \bf{K Shot} & \bf{K Way}  &\bf{Siamese} & \bf{MANN} & \bf{Matching} & \bf{Ours}  \\ \hline
    MNIST    & 1  & 10  & 70   & -    & 72   & \bf{78.6} \\ 
    MNIST    & 5  & 10  & -    & -    &  -   & 93.2 \\ 
    OMNIGLOT & 1  & 5   & 97.3 & 82.8 & \bf{98.1} & \bf{98.1} \\ 
    OMNIGLOT & 5  & 5   & 98.4 & 94.9 & 98.9 & \bf{99.5} \\ 
    OMNIGLOT & 1  & 20  & 88.1 & -    & \bf{93.8} & 93.2 \\  
    OMNIGLOT & 5  & 20  & 97.0 & -    & \bf{98.7} & 98.1 \\
    \end{tabular}
\caption{The table shows the classification accuracies of various few-shot learning tasks. Models are trained on OMNIGLOT data and tested on either unseen OMNIGLOT classes or MNIST with varying numbers of samples per class (K-shot) with varying numbers of classes (K-way). Comparisons are to \cite{matching} (Matching), \cite{mann} (MANN) and \cite{siamese_one_shot} (Siamese). 5-shot MNIST results are included for completeness.}
\label{table:small_shot_classification}
\end{table}

\subsection{Youtube Faces}

\begin{figure}[!hb]
\centering
\begin{minipage}{0.3\textwidth}
\includegraphics[width=1\linewidth]{input_faces_rgb.png}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\includegraphics[width=1\linewidth]{output_faces_rgb.png}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\includegraphics[width=1\linewidth]{rgb_uncond_samples.png}
\end{minipage}
\caption{Few-shot learning for face data. Samples are from model trained on Youtube Faces Database. \emph{Left}: Each row shows an input set of size 5. \emph{Center}: Each row shows 5 samples from the model corresponding to the input set on the left. \emph{Right}: Imagined new faces generated by sampling contexts from the prior. Each row consists of 5 samples from the model given a particular sampled context. \label{fig:table_faces}}
\end{figure}
Finally, we provide a proof of concept for generating faces of a particular person. We use the Youtube Faces Database from \citet{youtube_faces}. It contains $3,245$ videos of $1,595$ different people. We use the aligned and cropped to face version, resized to $64 \times 64$. The validation and test sets contain $100$ unique people each, and there is no overlap of persons between data splits. The sets were created by sampling frames randomly without replacement from each video, we use a set size of $5$ frames. We resample the sets for the training data each epoch.

Our architecture for this problem is based on one presented in \cite{discgen}. We used a single stochastic layer with $500$ dimensional latent $c$ and $16$ dimensional $z$ variable. The statistic network and the inference network $q(z | x,c ; \phi)$ share a common convolutional encoder, and the deocder uses deconvolutional layers. For full details see Appendix \ref{appendixb:faces}. The likelihood function is a Gaussian, but where the variance parameters are shared across all datapoints, this was found to make training faster and more stable.

The results are shown in Figure \ref{fig:table_faces}. Whilst there is room for improvement, we see that it is possible to specify a complex distribution on-the-fly with a set of photos of a previously unseen person. The samples conditioned on an input set have a reasonable likeness of the input faces. We also show the ability of the model to generate new datasets and see that the samples have a consistent identity and varied poses. 
\vspace{-1em}
\section{Conclusion}
We have demonstrated a highly flexible model on a variety of tasks. Going forward our approach will naturally benefit from advances in generative models as we can simply upgrade our base generative model, and so future work will pursue this. Compared with some other approaches in the literature for few-shot learning, our requirement for supervision is weaker: we only ask at training time that we are given datasets, but we do not need labels for the datasets, nor even information on whether two datasets represent the same or different classes. It would be interesting then to explore application areas where only this weaker form of supervision is available. There are two important limitations to this work, firstly that the method is dataset hungry: it will likely not learn useful representations of datasets given only a small number of them. Secondly at test time the few-shot fit of the generative model will not be greatly improved by using larger datasets unless the model was also trained on similarly large datasets. The latter limitation seems like a promising future research direction - bridging the gap between fast adaptation and slow training. 
\subsubsection*{Acknowledgments}
This work was supported in part by the EPSRC Centre for Doctoral Training in Data Science, funded by the UK Engineering and Physical Sciences Research Council (grant EP/L016427/1) and the University of Edinburgh.

\bibliography{main_bib}
\bibliographystyle{iclr2017_conference}
\appendix
\section{Appendix A: Pseudocode}
\label{appendix_pseudocode}
\begin{algorithm}[H]
    \caption{Sampling a dataset of size $k$}
    \label{alg:sampling}
    \begin{algorithmic}
        \STATE sample $c \sim p(c)$
        \FOR{$i=1$ {\bfseries to} $k$}
            \STATE sample $z_{i,L} \sim p(z_{L} |c; \theta)$
            \FOR{$j=L-1$ {\bfseries to} $1$}
               \STATE sample $z_{i,j} \sim p(z_{j} | z_{i,j+1},c; \theta)$
            \ENDFOR
            \STATE sample $x_{i} \sim p( x | z_{i,1}, \dots, z_{i,L}, c; \theta)$
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
    \begin{algorithm}[H]
    \caption{Sampling a dataset of size $k$ conditioned on a dataset of size $m$} 
    \label{alg:cond_sampling}
    \begin{algorithmic}
        \STATE $\mu_c, \sigma^2_c \gets q(c | x_1, \dots, x_m ; \phi)$ \COMMENT{Calculate approximate posterior over $c$ using statistic network.}
        \STATE $c \gets \mu_c$ \COMMENT{Set $c$ to be the mean of the approximate posterior.}
        \FOR{$i=1$ {\bfseries to} $k$}
            \STATE sample $z_{i,L} \sim p(z_{L} |c;\theta)$
            \FOR{$j=L-1$ {\bfseries to} $1$}
               \STATE sample $z_{i,j} \sim p(z_{j} | z_{i,j+1},c; \theta)$
            \ENDFOR
            \STATE sample $x_{i} \sim p( x | z_{i,1}, \dots, z_{i,L}, c; \theta)$
        \ENDFOR
    \end{algorithmic}
\end{algorithm}
    \begin{algorithm}[H]
    \caption{Selecting a representative sample of size $k$} 
    \label{alg:subsample}
    \begin{algorithmic}
        \STATE $S \gets \{x_1, \dots, x_m\}$
        \STATE $I \gets \{1, \dots, m \}$
        \STATE $S_I = \{x_i \in S : i \in I  \}$
        \STATE $N_{S_I} \gets q(c | S_I ; \phi)$ \COMMENT{Calculate approximate posterior over $c$ using statistic network.}
        \FOR{$i=1$ {\bfseries to} $k$}
            \STATE $t \gets argmin_{j \in I} \KL{N_S}{N_{S_{I - j}}}$
            \STATE $I \gets I - t$

        \ENDFOR
    \end{algorithmic}
\end{algorithm}

    \begin{algorithm}[H]
    \caption{$K$-way few-shot classification} 
    \label{alg:fewshot}
    \begin{algorithmic}
       \STATE $D_0, \dots, D_K \gets \text{sets of labelled examples for each class}$
        \STATE $x \gets \text{datapoint to be classified}$
        \STATE $N_x \gets q(c | x ; \phi)$
        \COMMENT{approximate posterior over $c$ given query point}

        \FOR{$i=1$ {\bfseries to} $K$}
        \STATE $N_i \gets q(c | D_i; \phi)$
        \ENDFOR
        \STATE $\hat{y} \gets argmin_{i} \KL{N_i}{N_x}$
    \end{algorithmic}
\end{algorithm}
\section{Appendix B: Further Experimental Details}
\label{appendix:experimental_details}
\subsection{Omniglot}
\label{appendixb:omniglot}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Shared encoder} $x \to h$ \\ \hline
    $2 \times$ \{ \emph{conv2d} $64$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $64$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations \\
    
    $2 \times$ \{\emph{conv2d} $128$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $128$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations  \\
    
    $2 \times$ \{ \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations
\label{table:omniglot_common_encoder}
    \end{tabular}
\end{table}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Statistic network} $q(c | D;  \phi): h_1, \dots, h_k \to \mu_c, \sigma^2_c$ \\ \hline
    \emph{fully-connected} layer with $256$ units and ELU activations \\
    \emph{sample-dropout} and \emph{concatenation} with number of samples \\
    \emph{average pooling} within each dataset\\
    $2 \times$ \{\emph{fully-connected} layer with $256$ units and ELU activations \} \\
    \emph{fully-connected} linear layers to $\mu_c$ and $\log \sigma^2_c$
\label{table:omniglot_statistic_network}
    \end{tabular}
\end{table}

\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Inference network} $q(z | x,c ; \phi): h,c \to \mu_z, \sigma^2_z$ \\ \hline
    \emph{concatenate} $c$ and $h$ \\
    $3 \times$ \{\emph{fully-connected} layer with $256$ units and ELU activations \}\\
    \emph{fully-connected} linear layers to $\mu_z$ and $\log \sigma^2_z$
\label{table:omniglot_inference_network}
    \end{tabular}
\end{table}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Latent decoder network} $p(z | c; \theta):$ $c \to \mu_z, \sigma^2_z$ \\ \hline
    $3 \times$ \{\emph{fully-connected} layer with $256$ units and ELU activations \}\\
    \emph{fully-connected} linear layers to $\mu_z$ and $\log \sigma^2_z$
\label{table:omniglot_latent_decoder_network}
    \end{tabular}   
\end{table}

\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Observation decoder network} $p(x | c, z ; \theta):$ $c,z \to \mu_x$ \\ \hline
    \emph{concatenate} $z$ and $c$ \\
    \emph{fully-connected} linear layers with $4 \cdot 4 \cdot 256$ units \\
    $2 \times$ \{ \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $256$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\
     $2 \times$ \{ \emph{conv2d} $128$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $128$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\   
    $2 \times$ \{ \emph{conv2d} $64$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $64$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\
    \emph{conv2d} $1$ feature map with $1 \times 1$ kernels, sigmoid activations
\label{table:omniglot_observation_decoder_network}
    \end{tabular}   
\end{table}

\subsection{Youtube faces}
\label{appendixb:faces}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Shared encoder} $x \to h$ \\ \hline
    $2 \times$ \{ \emph{conv2d} $32$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $32$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations \\
    
    $2 \times$ \{\emph{conv2d} $64$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $64$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations  \\
    
    $2 \times$ \{ \emph{conv2d} $128$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $128$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations \\
    
    $2 \times$ \{ \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels, stride $2$ and ELU activations
\label{table:faces_common_encoder}
    \end{tabular}
\end{table}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Statistic network} $q(c | D, \phi): h_1, \dots, h_k \to \mu_c, \sigma^2_c$ \\ \hline
    \emph{fully-connected} layer with $1000$ units and ELU activations \\
    \emph{average pooling} within each dataset\\
    \emph{fully-connected} linear layers to $\mu_c$ and $\log \sigma^2_c$
\label{table:faces_statistic_network}
    \end{tabular}
\end{table}

\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Inference network} $q(z | x,c, \phi): h,c \to \mu_z, \sigma^2_z$ \\ \hline
    \emph{concatenate} $c$ and $h$ \\
    \emph{fully-connected} layer with $1000$ units and ELU activations\\
    \emph{fully-connected} linear layers to $\mu_z$ and $\log \sigma^2_z$
\label{table:faces_inference_network}
    \end{tabular}
\end{table}
\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Latent decoder network} $p(z | c,; \theta):$ $c \to \mu_z, \sigma^2_z$ \\ \hline
    \emph{fully-connected} layer with $1000$ units and ELU activations\\
    \emph{fully-connected} linear layers to $\mu_z$ and $\log \sigma^2_z$
\label{table:faces_latent_decoder_network}
    \end{tabular}   
\end{table}

\begin{table}[H]

    \begin{tabular}{  l}
    \bf{Observation decoder network} $p(x | c, z ; \theta):$ $c,z \to \mu_x$ \\ \hline
    \emph{concatenate} $z$ and $c$ \\
    \emph{fully-connected} layer with $1000$ units and ELU activations \\
    \emph{fully-connected} linear layer with $8 \cdot 8 \cdot 256$ units \\
    $2 \times$ \{ \emph{conv2d} $256$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $256$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\
     $2 \times$ \{ \emph{conv2d} $128$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $128$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\   
    $2 \times$ \{ \emph{conv2d} $64$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $64$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\
     $2 \times$ \{ \emph{conv2d} $32$ feature maps with $3 \times 3$ kernels and ELU activations \} \\
    \emph{deconv2d} $32$ feature maps with $2 \times 2$ kernels, stride 2, ELU activations \\  
    \emph{conv2d} $3$ feature maps with $1 \times 1$ kernels, sigmoid activations
\label{table:faces_observation_decoder_network}
    \end{tabular}   
\end{table}
\end{document}
