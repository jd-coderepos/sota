
\documentclass[fleqn]{llncs}
\usepackage{version}
\usepackage{hp}

\pagestyle{plain}
\raggedbottom

\title{Autosolvability of Halting Problem Instances \\
       for Instruction Sequences}
\author{J.A. Bergstra \and C.A. Middelburg }
\institute{Informatics Institute, Faculty of Science,
           University of Amsterdam, \\
           Science Park~107, 1098~XG Amsterdam, the Netherlands \\
           \email{J.A.Bergstra@uva.nl,C.A.Middelburg@uva.nl}}

\begin{document}
\maketitle

\begin{abstract}
We position Turing's result regarding the undecidability of the halting
problem as a result about programs rather than machines.
The mere requirement that a program of a certain kind must solve the
halting problem for all programs of that kind leads to a contradiction
in the case of a recent unsolvability result regarding the halting
problem for programs.
In this paper, we investigate this autosolvability requirement in a
setting in which programs take the form of instruction sequences.
\begin{keywords}
halting problem, instruction sequence, autosolvability,
functional unit.
\end{keywords}
\begin{classcode}
F.1.1, F.4.1.
\end{classcode}
\end{abstract}

\section{Introduction}
\label{sect-intro}

The halting problem is frequently paraphrased as follows: the halting
problem is the problem to determine, given a program and an input to the
program, whether execution of the program on that input will eventually
terminate.
To indicate that this problem might be undecidable, it is often
mentioned that an interpreter, which is a program that simulates the
execution of programs that it is given as input, cannot solve the
halting problem because the interpreter will not terminate if its input
program does not terminate.
However, Turing's result regarding the undecidability of the halting
problem is a result about Turing machines rather than programs.
It says that there does not exist a single Turing machine that, given
the description of an arbitrary Turing machine and input, will determine
whether the computation of that Turing machine applied to that input
eventually halts (see e.g.~\cite{Tur37a}).

Our objective is to position Turing's result regarding the
undecidability of the halting problem as a result about programs rather
than machines.
In the case of the unsolvability result regarding the halting problem
for programs presented in~\cite{BP04a}, the mere requirement that a
program of a certain kind must solve the halting problem for all
programs of that kind leads to a contradiction.
In this paper, we pay closer attention to this autosolvability
requirement.
Like in~\cite{BP04a}, we carry out our investigation in a setting in
which programs take the form of instruction sequences.
The instruction set concerned includes instructions whose processing
needs a device that resembles the tape of a Turing machine.

The work presented in this paper belongs to a line of research in which
program algebra~\cite{BL02a} is the setting used for investigating
issues in which instruction sequences are involved.
The starting-point of program algebra is the perception of a program as
a single-pass instruction sequence, i.e.\ a finite or infinite sequence
of instructions of which each instruction is executed at most once and
can be dropped after it has been executed or jumped over.
Moreover, basic thread algebra~\cite{BL02a} is the setting used for
modelling the behaviours exhibited by instruction sequences under
execution.\footnote
{In~\cite{BL02a}, basic thread algebra is introduced under the name
 basic polarized process algebra.
}
In this paper, we use a program notation rooted in program algebra,
instead of program algebra itself.
The program notation in question was first presented in~\cite{BM09l}.
In that paper, the concept of a functional unit is introduced and
studied.
Here, we will model the devices that resemble the tape of a Turing
machine by a functional unit.

This paper is organized as follows.
First, we give a survey of the program notation used in this paper
(Section~\ref{sect-PGLBbt}) and define its semantics using basic thread
algebra (Section~\ref{sect-BTAbt}).
Next, we extend basic thread algebra with operators that are related to
the processing of instructions by services (Section~\ref{sect-TAbt}) and
introduce those operator in the setting of the program notation used
(Section~\ref{sect-PGLBbt-add}).
Then, we introduce the concept of a functional unit
(Section~\ref{sect-func-unit}) and define autosolvability and related
notions in terms of functional units related to Turing machine tapes
(Section~\ref{sect-func-unit-sbs}).
After that, we discuss the weakness of interpreters when it comes to
solving the halting problem (Section~\ref{sect-interpreters}) and give
positive and negative results concerning the autosolvability of the
halting problem (Section~\ref{sect-autosolvability}).
Finally, we make some concluding remarks (Section~\ref{sect-concl}).

\section{\PGLB\ with Boolean Termination}
\label{sect-PGLBbt}

In this section, we give a survey of the program notation \PGLBbt.
This program notation is a variant of the program notation \PGLB, which
belongs to a hierarchy of program notations rooted in program algebra
(see~\cite{BL02a}).
\PGLBbt\ is \PGLB\ with the Boolean termination instructions 
and  from~\cite{BM09k} instead of the termination instruction
.
\PGLB\ and \PGLBbt\ are close to existing assembly languages and have
relative jump instructions.

In \PGLBbt, it is assumed that fixed but arbitrary non-empty finite set
 of \emph{basic instructions} has been given.
The intuition is that the execution of a basic instruction may modify a
state and produces  or  at its completion.

\PGLBbt\ has the following primitive instructions:
\begin{itemize}
\item
for each , a \emph{plain basic instruction} ;
\item
for each , a \emph{positive test instruction} ;
\item
for each , a \emph{negative test instruction} ;
\item
for each , a \emph{forward jump instruction}
;
\item
for each , a \emph{backward jump instruction}
;
\item
a \emph{positive termination instruction} ;
\item
a \emph{negative termination instruction} .
\end{itemize}
\PGLBbt\ instruction sequences have the form , where  are primitive instructions of \PGLBbt.

On execution of a \PGLBbt\ instruction sequence, these primitive
instructions have the following effects:
\begin{itemize}
\item
the effect of a positive test instruction  is that basic
instruction  is executed and execution proceeds with the next
primitive instruction if  is produced and otherwise the next
primitive instruction is skipped and execution proceeds with the
primitive instruction following the skipped one -- if there is no
primitive instructions to proceed with, deadlock occurs;
\item
the effect of a negative test instruction  is the same as the
effect of , but with the role of the value produced reversed;
\item
the effect of a plain basic instruction  is the same as the effect of
,\linebreak[2] but execution always proceeds as if  is
produced;
\item
the effect of a forward jump instruction  is that execution
proceeds with the -th next primitive instruction -- if  equals 
or there is no primitive instructions to proceed with, deadlock occurs;
\item
the effect of a backward jump instruction  is that execution
proceeds with\linebreak[2] the -th previous primitive instruction --
if  equals  or there is no primitive\linebreak[2] instructions to
proceed with, deadlock occurs;
\item
the effect of the positive termination instruction  is that
execution terminates and in doing so delivers the Boolean value ;
\item
the effect of the negative termination instruction  is that
execution terminates and in doing so delivers the Boolean value
.
\end{itemize}

\section{Thread Extraction}
\label{sect-BTAbt}

In this section, we make precise in the setting of \BTAbt\ (Basic Thread
Algebra with Boolean termination) which behaviours are exhibited on
execution by \PGLBbt\ instruction sequences.
We start by reviewing \BTAbt.

In \BTAbt, it is assumed that a fixed but arbitrary non-empty finite set
 of \emph{basic actions}, with , has been
given.
We write  for .
The members of  are referred to as \emph{actions}.

A thread is a behaviour which consists of performing actions in a
sequential fashion.
Upon each basic action performed, a reply from an execution environment
determines how it proceeds.
The possible replies are the Boolean values  (standing for true)
and  (standing for false).
Performing the action  will always lead to the reply .

\BTAbt\ has one sort: the sort  of \emph{threads}.
We make this sort explicit because we will extend \BTAbt\ with
additional sorts in Section~\ref{sect-TAbt}.
To build terms of sort , \BTAbt\ has the following constants and
operators:
\begin{itemize}
\item
the \emph{deadlock} constant ;
\item
the \emph{positive termination} constant ;
\item
the \emph{negative termination} constant ;
\item
for each , the binary \emph{postconditional composition}
operator .
\end{itemize}
We assume that there is a countably infinite set of variables of sort
 which includes .
Terms of sort  are built as usual.
We use infix notation for postconditional composition.
We introduce \emph{action prefixing} as an abbreviation: ,
where  is a term of sort , abbreviates .

The thread denoted by a closed term of the form  will
first perform , and then proceed as the thread denoted by 
if the reply from the execution environment is  and proceed as
the thread denoted by  if the reply from the execution environment is
.
The threads denoted by ,  and  will become
inactive, terminate with Boolean value  and terminate with
Boolean value , respectively.

\BTAbt\ has only one axiom.
This axiom is given in Table~\ref{axioms-BTAbt}.\begin{table}[!tb]
\caption{Axiom of \BTAbt}
\label{axioms-BTAbt}
\begin{eqntbl}
\begin{axcol}
\pcc{x}{\Tau}{y} = \pcc{x}{\Tau}{x}                     & \axiom{T1}
\end{axcol}
\end{eqntbl}
\end{table}

Each closed \BTAbt\ term of sort  denotes a thread that will
become inactive or terminate after it has performed finitely many
actions.
Infinite threads can be described by guarded recursion.
A \emph{guarded recursive specification} over \BTAbt\ is a set of
recursion equations , where  is a
set of variables of sort  and each  is a \BTAbt\ term of the
form , ,  or  with  and
 that contain only variables from .
We are only interested in models of \BTAbt\ in which guarded recursive
specifications have unique solutions.
Regular threads, i.e.\ threads that can only be in a finite number of
states, are solutions of finite guarded recursive specifications.

To reason about infinite threads, we assume the infinitary conditional
equation AIP (Approximation Induction Principle).
AIP is based on the view that two threads are identical if their
approximations up to any finite depth are identical.
The approximation up to depth  of a thread is obtained by cutting it
off after it has performed  actions.
In AIP, the approximation up to depth  is phrased in terms of the
unary \emph{projection} operator .
AIP and the axioms for the projection operators are given in
Table~\ref{axioms-AIP}.\begin{table}[!tb]
\caption{Approximation induction principle}
\label{axioms-AIP}
\begin{eqntbl}
\begin{axcol}
\AND{n \geq 0}{} \proj{n}{x} = \proj{n}{y} \Implies
                                                  x = y & \axiom{AIP} \\
\proj{0}{x} = \DeadEnd                                  & \axiom{P0} \\
\proj{n+1}{\StopP} = \StopP                             & \axiom{P1a} \\
\proj{n+1}{\StopN} = \StopN                             & \axiom{P1b} \\
\proj{n+1}{\DeadEnd} = \DeadEnd                         & \axiom{P2} \\
\proj{n+1}{\pcc{x}{a}{y}} =
                      \pcc{\proj{n}{x}}{a}{\proj{n}{y}} & \axiom{P3}
\end{axcol}
\end{eqntbl}
\end{table}
In this table,  stands for an arbitrary action from  and
 stands for an arbitrary natural number.

We can prove that the projections of solutions of guarded recursive
specifications over \BTAbt\ are representable by closed \BTAbt\ terms of
sort .
\begin{lemma}
\label{lemma-projections}
Let  be a guarded recursive specification over \BTAbt, and
let  be a variable occurring in .
Then, for all , there exists a closed \BTAbt\ term  of
sort  such that .
\end{lemma}
\begin{proof}
In the case of \BTA, this is proved in~\cite{BM06a} as part of the proof
of Theorem~1 from that paper.
The proof concerned goes through in the case of \BTAbt.
\qed
\end{proof}

The behaviours exhibited on execution by \PGLBbt\ instruction sequences
are considered to be regular threads, with the basic instructions taken
for basic actions.
The \emph{thread extraction} operation  defines, for each
\PGLBbt\ instruction sequence, the behaviour exhibited on execution by
that \PGLBbt\ instruction sequence.
The thread extraction operation is defined by
,
where  is defined by the equations given in
Table~\ref{axioms-thread-extr} (for  and )\begin{table}[!t]
\caption{Defining equations for thread extraction operation}
\label{axioms-thread-extr}
\begin{eqntbl}
\begin{aceqns}
\extr{i,u_1 \conc \ldots \conc u_k} & = & \DeadEnd
& \mif \mathrm{not}\; 1 \leq i \leq k \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
a \bapf \extr{i+1,u_1 \conc \ldots \conc u_k}
& \mif u_i = a \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\pcc{\extr{i+1,u_1 \conc \ldots \conc u_k}}{a}
    {\extr{i+2,u_1 \conc \ldots \conc u_k}}
& \mif u_i = +a \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\pcc{\extr{i+2,u_1 \conc \ldots \conc u_k}}{a}
    {\extr{i+1,u_1 \conc \ldots \conc u_k}}
& \mif u_i = -a \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\extr{i+l,u_1 \conc \ldots \conc u_k}
& \mif u_i = \fjmp{l} \\
\extr{i,u_1 \conc \ldots \conc u_k} & = &
\extr{i \monus l,u_1 \conc \ldots \conc u_k}
& \mif u_i = \bjmp{l} \\
\extr{i,u_1 \conc \ldots \conc u_k} & = & \StopP
& \mif u_i = \haltP \\
\extr{i,u_1 \conc \ldots \conc u_k} & = & \StopN
& \mif u_i = \haltN
\end{aceqns}
\end{eqntbl}
\end{table}
and the rule that  if
 is the beginning of an infinite jump chain.\footnote
{This rule can be formalized, cf.~\cite{BM07g}.}

\section{Interaction between Threads and Services}
\label{sect-TAbt}

A thread may perform a basic action for the purpose of requesting a
named service to process a method and to return a reply value at
completion of the processing of the method.
In this section, we extend \BTAbt\ such that this kind of interaction
between threads and services can be dealt with, resulting in \TAbt.
This involves the introduction of service families: collections of named
services.

It is assumed that a fixed but arbitrary set  of \emph{methods}
has been given.
Methods play the role of commands.
A service is able to process certain methods.
The processing of a method may involve a change of the service.
At completion of the processing of a method, the service produces a
reply value.
The set  of \emph{reply values} is the set
.

In \SFA, the algebraic theory of service families introduced below, the
following is assumed with respect to services:
\begin{itemize}
\item
a set  of services has been given together with:
\begin{itemize}
\item
for each ,
a total function ;
\item
for each ,
a total function ;
\end{itemize}
satisfying the condition that there exists a unique 
with  and  for all
;
\item
a signature  has been given that includes the following
sort:
\begin{itemize}
\item
the sort  of \emph{services};
\end{itemize}
and the following constant and operators:
\begin{itemize}
\item
the \emph{empty service} constant ;
\item
for each ,
the \emph{derived service} operator
;
\end{itemize}
\item
 and  are such that:
\begin{itemize}
\item
each service in  can be denoted by a closed term of sort
;
\item
the constant  denotes the unique  such
that  and  for all
;
\item
if closed term  denotes service , then  denotes
service .
\end{itemize}
\end{itemize}

When a request is made to service  to process method :
\begin{itemize}
\item
if , then  processes , produces the reply
, and next proceeds as ;
\item
if , then  rejects the request to process
method .
\end{itemize}
The unique service  such that  and
 for all  is called the \emph{empty}
service.
It is the service that is unable to process any method.

It is also assumed that a fixed but arbitrary non-empty finite set
 of \emph{foci} has been given.
Foci play the role of names of services in the service family offered by
an execution environment.
A service family is a set of named services where each name occurs only
once.

\SFA\ has the sorts, constants and operators in 
and in addition the following sort:
\begin{itemize}
\item
the sort  of \emph{service families};
\end{itemize}
and the following constant and operators:
\begin{itemize}
\item
the \emph{empty service family} constant ;
\item
for each , the unary \emph{singleton service family}
operator ;
\item
the binary \emph{service family composition} operator
;
\item
for each , the unary \emph{encapsulation} operator
.
\end{itemize}
We assume that there is a countably infinite set of variables of sort
 which includes .
Terms are built as usual in the many-sorted case
(see e.g.~\cite{ST99a,Wir90a}).\linebreak[2]
We use prefix notation for the singleton service family operators and
infix nota\-tion for the service family composition operator.

The service family denoted by  is the empty service family.
The service family denoted by a closed term of the form  consists
of one named service only, the service concerned is the service denoted
by , and the name of this service is .
The service family denoted by a closed term of the form 
consists of all named services that belong to either the service family
denoted by  or the service family denoted by .
In the case where a named service from the service family denoted by 
and a named service from the service family denoted by  have the same
name, they collapse to an empty service with the name concerned.
The service family denoted by a closed term of the form 
consists of all named services with a name not in  that belong to the
service family denoted by .

The axioms of \SFA\ are given in Table~\ref{axioms-SFA}.\begin{table}[!t]
\caption{Axioms of \SFA}
\label{axioms-SFA}
\begin{eqntbl}
\begin{axcol}
u \sfcomp \emptysf = u                                 & \axiom{SFC1} \\
u \sfcomp v = v \sfcomp u                              & \axiom{SFC2} \\
(u \sfcomp v) \sfcomp w = u \sfcomp (v \sfcomp w)      & \axiom{SFC3} \\
f.H \sfcomp f.H' = f.\emptyserv                        & \axiom{SFC4}
\end{axcol}
\qquad
\begin{saxcol}
\encap{F}(\emptysf) = \emptysf                       & & \axiom{SFE1} \\
\encap{F}(f.H) = \emptysf & \mif f \in F               & \axiom{SFE2} \\
\encap{F}(f.H) = f.H      & \mif f \notin F            & \axiom{SFE3} \\
\encap{F}(u \sfcomp v) =
\encap{F}(u) \sfcomp \encap{F}(v)                    & & \axiom{SFE4}
\end{saxcol}
\end{eqntbl}
\end{table}
In this table,  stands for an arbitrary focus from  and 
and  stand for arbitrary closed terms of sort .
The axioms of \SFA\ simply formalize the informal explanation given above.

Below we will introduce two operators related to the interaction between
threads and services.
They are called the apply operator and the reply operator.
The apply operator is concerned with the effects of threads on service
families and therefore produces service families.
The reply operator is concerned with the effects of service families on
the Boolean values that threads deliver at their termination.
The reply operator does not only produce Boolean values: it produces a
special value in cases where no termination takes place.

For the set  of basic actions, we take the set
.
Both operators mentioned above relate to the processing of methods by
services from a service family in pursuance of basic actions performed
by a thread.
The service involved in the processing of a method is the service whose
name is the focus of the basic action in question.

\TAbt\ has the sorts, constants and operators of both \BTAbt\ and \SFA,
and in addition the following sort:
\begin{itemize}
\item
the sort  of \emph{replies};
\end{itemize}
and the following constants and operators:
\begin{itemize}
\item
the \emph{reply} constants ;
\item
the binary \emph{apply} operator
;
\item
the binary \emph{reply} operator
.
\end{itemize}
We use infix notation for the apply and reply operators.

The service family denoted by a closed term of the form 
and the reply denoted by a closed term of the form  are
the service family and reply, respectively, that result from processing
the method of each basic action with a focus of the service family
denoted by  that the thread denoted by  performs, where the
processing is done by the service in that service family with the focus
of the basic action as its name.
When the method of a basic action performed by a thread is processed by
a service, the service changes in accordance with the method concerned,
and affects the thread as follows: the two ways to proceed reduce to one
on the basis of the reply value produced by the service.
The reply is the Boolean value that the thread denoted by  delivers
at termination if it terminates and the value  (standing for
divergent) if it does not terminate.

The axioms of \TAbt\ are the axioms of \BTAbt, the axioms of \SFA, and
the axioms given in Tables~\ref{axioms-apply} and~\ref{axioms-reply}.\begin{table}[!t]
\caption{Axioms for apply operator}
\label{axioms-apply}
\begin{eqntbl}
\begin{saxcol}
\StopP \sfapply u = u                                  & & \axiom{A1} \\
\StopN \sfapply u = u                                  & & \axiom{A2} \\
\DeadEnd \sfapply u = \emptysf                         & & \axiom{A3} \\
(\Tau \bapf x) \sfapply u = x \sfapply u               & & \axiom{A4} \\
(\pcc{x}{f.m}{y}) \sfapply \encap{\set{f}}(u) = \emptysf
                                                       & & \axiom{A5} \\
(\pcc{x}{f.m}{y}) \sfapply (f.H \sfcomp \encap{\set{f}}(u)) =
x \sfapply (f.\derive{m}H \sfcomp \encap{\set{f}}(u))
                           & \mif \sreply{m}(H) = \True  & \axiom{A6} \\
(\pcc{x}{f.m}{y}) \sfapply (f.H \sfcomp \encap{\set{f}}(u)) =
y \sfapply (f.\derive{m}H \sfcomp \encap{\set{f}}(u))
                           & \mif \sreply{m}(H) = \False & \axiom{A7} \\
(\pcc{x}{f.m}{y}) \sfapply (f.H \sfcomp \encap{\set{f}}(u)) = \emptysf
                           & \mif \sreply{m}(H) = \Div   & \axiom{A8} \\
\AND{n \geq 0}{} \proj{n}{x} \sfapply u = \proj{n}{y} \sfapply v
                 \Implies x \sfapply u = y  \sfapply v & & \axiom{A9}
\end{saxcol}
\end{eqntbl}
\end{table}\begin{table}[!t]
\caption{Axioms for reply operator}
\label{axioms-reply}
\begin{eqntbl}
\begin{saxcol}
\StopP \sfreply u = \True                              & & \axiom{R1} \\
\StopN \sfreply u = \False                             & & \axiom{R2} \\
\DeadEnd \sfreply u = \Div                             & & \axiom{R3} \\
(\Tau \bapf x) \sfreply u = x \sfreply u               & & \axiom{R4} \\
(\pcc{x}{f.m}{y}) \sfreply \encap{\set{f}}(u) = \Div   & & \axiom{R5} \\
(\pcc{x}{f.m}{y}) \sfreply (f.H \sfcomp \encap{\set{f}}(u)) =
x \sfreply (f.\derive{m}H \sfcomp \encap{\set{f}}(u))
                           & \mif \sreply{m}(H) = \True  & \axiom{R6} \\
(\pcc{x}{f.m}{y}) \sfreply (f.H \sfcomp \encap{\set{f}}(u)) =
y \sfreply (f.\derive{m}H \sfcomp \encap{\set{f}}(u))
                           & \mif \sreply{m}(H) = \False & \axiom{R7} \\
(\pcc{x}{f.m}{y}) \sfreply (f.H \sfcomp \encap{\set{f}}(u)) = \Div
                           & \mif \sreply{m}(H) = \Div   & \axiom{R8} \\
\AND{n \geq 0}{} \proj{n}{x} \sfreply u = \proj{n}{y} \sfreply v
                 \Implies x \sfreply u = y  \sfreply v & & \axiom{R9}
\end{saxcol}
\end{eqntbl}
\end{table}
In these tables,  stands for an arbitrary focus from , 
stands for an arbitrary method from ,  stands for an arbitrary
term of sort , and  stands for an arbitrary natural number.
The axioms simply formalize the informal explanation given above and in
addition stipulate what is the result of apply and reply if
inappropriate foci or methods are involved.
Axioms A9 and R9 allow for reasoning about infinite threads in the
contexts of apply and reply, respectively.

Let  and  be \TAbt\ terms of sort  and ,
respectively.
Then  \emph{converges on} , written , is inductively
defined by the following clauses:
\begin{itemize}
\item
 and ;
\item
if , then ;
\item
if  and
, then
;
\item
if  and
, then
;
\item
if , then .
\end{itemize}
Moreover,  \emph{diverges on} , written , is defined
by  iff not .

In the case where , either the processing of methods does
not halt or inappropriate foci or methods are involved.
In that case, there is nothing that we intend to denote by a term of the
form  or .
We propose to comply with the following \emph{relevant use conventions}:
\begin{itemize}
\item
 is only used if it is known that ;
\item
 is only used if it is known that .
\end{itemize}
The condition found in the first convention is justified by the fact
that in the intended model of \TAbt, for definable threads ,
 if  (see~\cite{BM09k}).
We do not have  only if .
For instance,  whereas
.

\section{Interaction between Programs and Services}
\label{sect-PGLBbt-add}

In this paper, the apply operator and reply operator are primarily
intended to be used in the setting of \PGLBbt.
In this section, we introduce the apply operator and reply operator in
the setting of \PGLBbt.
We also introduce notations for two simple transformations of \PGLBbt\
instruction sequences that affect only their termination behaviour on
execution and the Boolean value yielded at termination in the case of
termination.
These notations will be used in Sections~\ref{sect-interpreters}
and~\ref{sect-autosolvability}.

We introduce the apply operator and reply operator in the setting of
\PGAbt\ by defining:
\begin{ldispl}
x \sfapply u = \extr{x} \sfapply u\;, \quad
x \sfreply u = \extr{x} \sfreply u
\end{ldispl}
for all \PGLBbt\ instruction sequences .
Similarly, we introduce convergence in the setting of \PGAbt\ by
defining:
\begin{ldispl}
x \cvg u = \extr{x} \cvg u
\end{ldispl}
for all \PGLBbt\ instruction sequences .

The following proposition states that convergence corresponds with
termination.
\begin{proposition}
\label{prop-cvg-sfreply}
Let  be a \PGLBbt\ instruction sequence.
Then  iff  or .
\end{proposition}
\begin{proof}
By the definition of , the last clause of the inductive
definition of , axiom R9, and Lemma~\ref{lemma-projections} it is
sufficient to prove  iff  or
 for each closed \BTAbt\ term  of sort .
This is easy by induction on the structure of .
\qed
\end{proof}

In Sections~\ref{sect-interpreters} and~\ref{sect-autosolvability}, we
will make use of two simple transformations of \PGLBbt\ instruction
sequences.
Here, we introduce notations for those transformations.

Let  be a \PGLBbt\ instruction sequence.
Then we write  for  with each occurrence of 
replaced by  and each occurrence of  replaced by
, and we write  for  with each occurrence of
 replaced by .
In the following proposition, the most important properties relating to
these transformations are stated.
\begin{proposition}
\label{prop-swap-f2d}
Let  be a \PGLBbt\ instruction sequence.
Then:
\begin{enumerate}
\item
if  then  and
;
\item
if  then  and
.
\end{enumerate}
\end{proposition}
\begin{proof}
Let  be a closed \BTAbt\ term of sort .
Then we write  for  with each occurrence of 
replaced by  and each occurrence of  replaced by
, and we write  for  with each occurrence of
 replaced by .
It is easy to prove by induction on  that
 and
 for all .
By this result, axiom R9, and Lemma~\ref{lemma-projections} it is
sufficient to prove the following for each closed \BTAbt\ term  of
sort :
\begin{enumerate}
\item[]
if  then  and
;
\item[]
if  then  and
.
\end{enumerate}
This is easy by induction on the structure of .
\qed
\end{proof}

\section{Functional Units}
\label{sect-func-unit}

In this section, we introduce the concept of a functional unit and
related concepts.
The concept of a functional unit was first introduced in~\cite{BM09l}.

It is assumed that a non-empty set  of \emph{states} has been
given.
As before, it is assumed that a non-empty finite set  of methods
has been given.
However, in the setting of functional units, methods serve as names of
operations on a state space.
For that reason, the members of  will henceforth be called
\emph{method names}.

A \emph{method operation} on  is a total function from  to
.
A \emph{partial method operation} on  is a partial function from
 to .
We write  for the set of all method operations on .
We write  and , where , for the unique
functions  and ,
respectively, such that  for all .

A \emph{functional unit} for  is a finite subset  of
 such that \mbox{} and
 implies .
We write  for the set of all functional units for .
We write , where , for the set
.
We write , where  and , for
the unique  such that .

We look upon the set , where , as the
interface of .
It looks to be convenient to have a notation for the restriction of a
functional unit to a subset of its interface.
We write , where  and
, for the functional unit
.

Let .
Then an \emph{extension} of  is an  such that
.

The following is a simple illustration of the use of functional units.
An unbounded counter can be modelled by a functional unit for 
with method operations for set to zero, increment by one, decrement by
one, and test on zero.

According to the definition of a functional unit,
.
By that we have a unique functional unit with an empty interface, which
is not very interesting in itself.
However, when considering services that behave according to functional
units,  is exactly the functional unit according to which the
empty service  (the service that is not able to process any
method) behaves.

The method names attached to method operations in functional units
should not be confused with the names used to denote specific method
operations in describing functional units.
Therefore, we will comply with the convention to use names beginning
with a lower-case letter in the former case and names beginning with an
upper-case letter in the latter case.

We will use \PGLBbt\ instruction sequences to derive partial method
operations from the method operations of a functional unit.
We write , where , for the set of all \PGLBbt\
instruction sequences, taking the set  as the
set  of basic instructions.

The derivation of partial method operations from the method operations
of a functional unit involves services whose processing of methods
amounts to replies and service changes according to corresponding method
operations of the functional unit concerned.
These services can be viewed as the behaviours of a machine, on which
the processing in question takes place, in its different states.
We take the set  as the set  of services.
We write , where  and , for the
service .
The functions  and  are defined as follows:
\begin{ldispl}
\begin{aeqns}
\effect{m}(\cH(s)) & = &
\Biggl\{
\begin{array}[c]{@{}l@{\;\;}l@{}}
\cH(m_\cH^e(s))            & \mif m \in \IF(\cH) \\
{\emptyset}(s')            & \mif m \notin \IF(\cH)\;,
\end{array}
\beqnsep
\sreply{m}(\cH(s))  & = &
\Biggl\{
\begin{array}[c]{@{}l@{\;\;}l@{}}
m_\cH^r(s) \phantom{\cH()} & \mif m \in \IF(\cH) \\
\Div                       & \mif m \notin \IF(\cH)\;,
\end{array}
\end{aeqns}
\end{ldispl}
where  is a fixed but arbitrary state in .
We assume that each  can be denoted by a closed
term of sort .
In this connection, we use the following notational convention: for each
, we write  for an arbitrary
closed term of sort  that denotes .
The ambiguity thus introduced could be obviated by decorating 
wherever it stands for a closed term.
However, in this paper, it is always immediately clear from the context
whether it stands for a closed term.
Moreover, we believe that the decorations are more often than not
distracting.
Therefore, we leave it to the reader to make the decorations mentally
wherever appropriate.

Let , and let .
Then an instruction sequence  produces a partial method
operation  as follows:
\begin{ldispl}
\begin{aceqns}
\moextr{x}{\cH}(s) & = &
\tup{\moextr{x}{\cH}^r(s),\moextr{x}{\cH}^e(s)}
 & \mif \moextr{x}{\cH}^r(s) = \True \Or
        \moextr{x}{\cH}^r(s) = \False\;, \\
\moextr{x}{\cH}(s) & \mathrm{is} & \mathrm{undefined}
 & \mif \moextr{x}{\cH}^r(s) = \Div\;,
\end{aceqns}
\end{ldispl}
where
\begin{ldispl}
\begin{aeqns}
\moextr{x}{\cH}^r(s) & = & x \sfreply f.\cterm{\cH(s)}\;, \\
\moextr{x}{\cH}^e(s) & = &
\mathrm{the\;unique}\; s' \in S\; \mathrm{such\;that}\;
 x \sfapply f.\cterm{\cH(s)} = f.\cterm{\cH(s')}\;.
\end{aeqns}
\end{ldispl}
If  is total, then it is called a
\emph{derived method operation} of .

The binary relation  on  is defined by
 iff for all ,  is a derived
method operation of .
The binary relation  on  is defined by
 iff  and .
In~\cite{BM09l}, it is proved that  is a quasi-order relation
and  is an equivalence relation.

\section{Functional Units Relating to Turing Machine Tapes}
\label{sect-func-unit-sbs}

In this section, we define some notions that have a bearing on the
halting problem in the setting of \PGLBbt\ and functional units.
The notions in question are defined in terms of functional units for the
following state space:
\begin{ldispl}
\SBS = \set{v \pebble w \where v,w \in \seqof{\set{0,1,\sep}}}\;.
\end{ldispl}

The states from  resemble the possible contents of the tape of a
Turing machine whose tape alphabet is .
Consider a state .
Then  corresponds to the content of the tape to the left of the
position of the tape head and  corresponds to the content of the tape
from the position of the tape head to the right -- the indefinite
numbers of padding blanks at both ends are left out.
The colon serves as a seperator of bit sequences.
This is for instance useful if the input of a program consists of
another program and an input to the latter program, both encoded as a
bit sequences.

A method operation  is \emph{recursive} if there exist
recursive functions  such that
 for all
,
where  is a bijection and
 is inductively defined by 
and .
A functional unit  is \emph{recursive} if, for each
,  is recursive.

In the sequel, we will comply with the relevant use conventions
introduced at the end of Section~\ref{sect-TAbt}.

It is assumed that, for each , an injective function
from  to  has been given that yields
for each , an encoding of  as a bit sequence.
We use the notation  to denote the encoding of  as a bit
sequence.

Let , and let .
Then:
\begin{itemize}
\item
 produces a
\emph{solution of the halting problem} for  with respect to
 if:
\begin{ldispl}
x \cvg f.\cterm{\cH(v)}\; \mathrm{for\; all}\; v \in \SBS\;, \\
x \sfreply f.\cterm{\cH(\pebble \ol{y} \sep v)} = \True \Iff
y \cvg f.\cterm{\cH(\pebble v)}\; \mathrm{for\; all}\;
y \in \Lf{I}\; \mathrm{and}\; v \in \seqof{\set{0,1,\sep}}\;;
\end{ldispl}
\item
 produces a
\emph{reflexive solution of the halting problem} for  with
respect to  if  produces a solution of the halting problem for
 with respect to  and ;
\item
the halting problem for  with respect to  is
\emph{autosolvable} if there exists an  such that
 produces a reflexive solution of the halting problem for 
with respect to ;
\item
the halting problem for  with respect to  is
\emph{potentially autosolvable} if there exist an extension  of
 and the halting problem for  with respect to
 is autosolvable;
\item
the halting problem for  with respect to  is
\emph{potentially recursively autosolvable} if there exist an extension
 of  and the halting problem for  with
respect to  is autosolvable and  is recursive.
\end{itemize}
These definitions make clear that each combination of an
 and an  gives rise to a
\emph{halting problem instance}.

In Section~\ref{sect-interpreters} and~\ref{sect-autosolvability}, we
will make use of a method operation  for duplicating
bit sequences.
This method operation is defined as follows:
\begin{ldispl}
\begin{aceqns}
\Dup(v \pebble w) & = & \Dup(\pebble v w)\;, \\
\Dup(\pebble v)   & = & \tup{\True,\pebble v \sep v}
 & \mif v \in \seqof{\set{0,1}}\;, \\
\Dup(\pebble v \sep w) & = & \tup{\True,\pebble v \sep v \sep w}
 & \mif v \in \seqof{\set{0,1}}\;.
\end{aceqns}
\end{ldispl}

\begin{proposition}
\label{prop-dup}
Let  be such that ,
let  be such that ,
let , and
let  and  be such
that  or  for some .
Then
.
\end{proposition}
\begin{proof}
This follows immediately from the definition of  and the axioms
for~.
\qed
\end{proof}

By the use of foci and the introduction of apply and reply operators on
service families, we make it possible to deal with cases that remind of
multi-tape Turing machines, Turing machines that has random access
memory, etc.
However, in this paper, we will only consider the case that reminds of
single-tape Turing machines.
This means that we will use only one focus () and only
singleton service families.

\section{Interpreters}
\label{sect-interpreters}

It is often mentioned that an interpreter, which is a program for
simulating the execution of programs that it is given as input, cannot
solve the halting problem because the execution of the interpreter will
not terminate if the execution of its input program does not terminate.
In this section, we have a look upon the termination behaviour of
interpreters in the setting of \PGLBbt\ and functional units.

Let , let , and
let .
Then  is an \emph{interpreter} for  with respect
to  if for all  and :
\begin{ldispl}
y \cvg f.\cterm{\cH(\pebble v)} \Implies
x \cvg f.\cterm{\cH(\pebble \ol{y} \sep v)}\;, \\
x \sfapply f.\cterm{\cH(\pebble \ol{y} \sep v)} =
y \sfapply f.\cterm{\cH(\pebble v)}\; \mathrm{and}\;
x \sfreply f.\cterm{\cH(\pebble \ol{y} \sep v)} =
y \sfreply f.\cterm{\cH(\pebble v)}\;.
\end{ldispl}
Moreover,  is a \emph{reflexive interpreter} for 
with respect to  if  is an interpreter for  with respect
to  and .

The following theorem states that a reflexive interpreter that always
terminates is impossible in the presence of the method operation .
\begin{theorem}
\label{theorem-interpreter}
Let  be such that ,
let  be such that , and
let  be a reflexive interpreter for  with
respect to .
Then there exist an  and a 
such that .
\end{theorem}
\begin{proof}
Assume the contrary.
Take .
By the assumption, .
By Propositions~\ref{prop-cvg-sfreply} and~\ref{prop-swap-f2d}, it
follows that 
and
.
By Propositions~\ref{prop-cvg-sfreply} and~\ref{prop-dup}, it follows
that  and
.
Since , we have
 and
.
Because  is a reflexive interpreter, this implies
 and
.
This is a contradiction.
\qed
\end{proof}
In the proof of Theorem~\ref{theorem-interpreter}, the presence of the
method operation  is essential.
It is easy to see that the theorem goes through for all functional units
for  of which  is a derived method operation.
An example of such a functional unit is the one whose method operations
correspond to the basic steps that can be performed on the tape of a
Turing machine.

For each , , and ,
we have .
This leads us to the following corollary of
Theorem~\ref{theorem-interpreter}.
\begin{corollary}
\label{corollary-interpreter}
For all  with  and
 with , there does not exist an
 such that  is a reflexive
interpreter for  with respect to .
\end{corollary}

\section{Autosolvability of the Halting Problem}
\label{sect-autosolvability}

Because a reflexive interpreter that always terminates is impossible in
the presence of the method operation , we must conclude that
solving the halting problem by means of a reflexive interpreter is out
of the question in the presence of the method operation .
The question arises whether the proviso ``by means of a reflexive
interpreter'' can be dropped.
In this section, we answer this question in the affirmative.
Before we present this negative result concerning autosolvability of the
halting problem, we present a positive result.

Let .
Then we say that  \emph{increases the number of colons} if for some
 the number of colons in  is greater than the number
of colons in .

\begin{theorem}
\label{theorem-autosolv}
Let  be such that no method operation of 
increases the number of colons.
Then there exist an extension  of ,
an , and an  such that
 produces a reflexive solution of the halting problem for 
with respect to .
\end{theorem}
\begin{proof}
Let  be such that .
Take .
Take , where
 is defined by induction on the number of
colons in the argument of  as follows:
\begin{ldispl}
\begin{aceqns}
\Halting(v \pebble w) & = & \Halting(\pebble v w)\;, \\
\Halting(\pebble v)   & = & \tup{\False,\pebble}
 & \mif v \in \seqof{\set{0,1}}\;, \\
\Halting(\pebble v \sep w) & = & \tup{\False,\pebble}
 & \mif v \in \seqof{\set{0,1}} \And
        \Forall{x \in \Lf{I'}}{v \neq \ol{x}}\;, \\
\Halting(\pebble \ol{x} \sep w) & = & \tup{\False,\pebble}
 & \mif x \in \Lf{I'} \And x \dvg f.\cterm{\cH'(w)}\;, \\
\Halting(\pebble \ol{x} \sep w) & = & \tup{\True,\pebble}
 & \mif x \in \Lf{I'} \And x \cvg f.\cterm{\cH'(w)}\;.
\end{aceqns}
\end{ldispl}
Then  produces a reflexive
solution of the halting problem for  with respect to .
\qed
\end{proof}
Theorem~\ref{theorem-autosolv} tells us that there exist functional
units  with the property that the halting problem is
potentially autosolvable for  with respect to .
Thus, we know that there exist functional units  with
the property that the halting problem is autosolvable for
 with respect to~.

There exists an  for which  as defined in
the proof of Theorem~\ref{theorem-autosolv} is computable, and hence
recursive.
\begin{theorem}
\label{theorem-comput}
Let  and
, where
 is as defined in the proof
of Theorem~\ref{theorem-autosolv}.
Then,  is computable.
\end{theorem}
\begin{proof}
It is sufficient to prove for an arbitrary  that,
for all ,  is decidable.
We will prove this by induction on the number of colons in .

The basis step.
Because the number of colons in  equals ,
.
It follows that ,
where  is  with each occurrence of  and
 replaced by  and each occurrence of
 replaced by .
Because  is finite,  is decidable.
Hence,  is decidable.

The inductive step.
Because the number of colons in  is greater than , either
 or
.
It follows that , where
 is  with:
\begin{itemize}
\item
each occurrence of  and  replaced by
 if the occurrence leads to the first application of
 and , and by  otherwise;
\item
each occurrence of  replaced by
 if the occurrence leads to the first application of
 and , and by  otherwise.
\end{itemize}
An occurrence of ,  or
 in  leads to the first application of 
iff , where  is its position in .
Because  is finite, it is decidable whether an occurrence of
,  or  leads to the
first processing of .
Moreover, by the induction hypothesis, it is decidable whether
.
Because  is finite, it follows that  is decidable.
Hence,  is decidable.
\qed
\end{proof}
Theorems~\ref{theorem-autosolv} and~\ref{theorem-comput} together tell
us that there exists a functional unit , viz.\
, with the property that the halting problem is potentially
recursively autosolvable for  with respect to .

There exist functional units in  of which all recursive
 that do not increase the number of colons are derived
method operations.
A witness is the functional unit whose method operations correspond to
the basic steps that can be performed on the tape of a Turing machine.
Let  be such that all recursive 
that do not increase the number of colons are derived method operations
of .
Then the halting problem is potentially autosolvable for 
with respect to .
However, the halting problem is not potentially recursively autosolvable
for  with respect to  because otherwise the halting
problem would be decidable.

The following theorem tells us essentially that potential
autosolvability of the halting problem is precluded in the presence of
the method operation .
\begin{theorem}
\label{theorem-non-autosolv}
Let  be such that , and
let  be such that .
Then there does not exist an  such that 
produces a reflexive solution of the halting problem for  with
respect to .
\end{theorem}
\begin{proof}
Assume the contrary.
Let  be such that  produces a re\-flexive
solution of the halting problem for  with respect to , and
let .
Then .
By Propositions~\ref{prop-cvg-sfreply} and~\ref{prop-swap-f2d}, it
fol\-lows that 
and either
 or
.

In the case where
,
we have by Proposition~\ref{prop-swap-f2d} that
(i)~ and
(ii)~.
By Proposition~\ref{prop-dup}, it follows from~(i) that
.
Since , we have
.
On the other hand, because  produces a reflexive solution, it follows
from~(ii) that .
By Proposition~\ref{prop-cvg-sfreply}, this contradicts with
.

In the case where
,
we have by Proposition~\ref{prop-swap-f2d} that
(i)~ and
(ii)~.
By Proposition~\ref{prop-dup}, it follows from~(i) that
.
Since , we have
.
On the other hand, because  produces a reflexive solution, it follows
from~(ii) that .
By Proposition~\ref{prop-cvg-sfreply}, this contradicts with
.
\qed
\end{proof}

Below, we will give an alternative proof of
Theorem~\ref{theorem-non-autosolv}.
A case distinction is needed in both proofs, but in the alternative
proof it concerns a minor issue.
The issue in question is covered by the following lemma.
\begin{lemma}
\label{lemma-non-autosolv}
Let , let ,
let  be such that  produces a reflexive solution
of the halting problem for  with respect to ,
let , and let .
Then
 implies
.
\end{lemma}
\begin{proof}
By Proposition~\ref{prop-cvg-sfreply}, it follows from
 that either
 or
.

In the case where , we have
by Propositions~\ref{prop-cvg-sfreply} and~\ref{prop-swap-f2d} that
 and so
.

In the case where , we have
by Propositions~\ref{prop-cvg-sfreply} and~\ref{prop-swap-f2d} that
 and so
.
\qed
\end{proof}

\begin{trivlist}
\item
\emph{Another proof of Theorem~\ref{theorem-non-autosolv}.}
Assume the contrary.
Let  be such that  produces a reflexive solution
of the halting problem for  with re\-spect to , and
let .
Then .
By Propo\-sitions~\ref{prop-cvg-sfreply}, \ref{prop-swap-f2d}
and~\ref{prop-dup}, it follows that
.
By Lemma~\ref{lemma-non-autosolv}, it follows that
.
By Proposition~\ref{prop-swap-f2d}, it follows that
.
On the other hand, by Propo\-sition~\ref{prop-dup}, we have that
.
This contradicts with
.
\qed
\end{trivlist}

Let .
By Theorem~\ref{theorem-non-autosolv}, the halting problem for
 with respect to  is not (potentially)
autosolvable.
However, it is decidable.
\begin{theorem}
\label{theorem-decidable}
Let .
Then the halting problem for  with respect to  is
decidable.
\end{theorem}
\begin{proof}
Let , and let  be  with each occurrence of
 and  replaced by  and each occurrence
of  replaced by .
For all , .
Therefore,  for all .
Because  is finite,  is decidable.
\qed
\end{proof}
Both proofs of Theorem~\ref{theorem-non-autosolv} given above are
diagonalization proofs in disguise.
Theorem~\ref{theorem-decidable} indicates that diagonalization and
decidability are independent so to speak.


\section{Concluding Remarks}
\label{sect-concl}

We have extended and strengthened the results regarding the halting
problem for programs given in~\cite{BP04a} in a setting which looks to
be more adequate to describe and analyse issues regarding the halting
problem for programs.

It happens that decidability depends on the halting problem instance
considered.
This is different in the case of the on-line halting problem for
programs, i.e.\ the problem to forecast during its execution whether a
program will eventually terminate (see~\cite{BP04a}).

An interesting option for future work is to investigate the bounded
halting problem for programs, i.e.\ the problem to determine, given a
program and an input to the program, whether execution of the program on
that input will terminate after the execution of no more than a fixed
number of basic instructions.

\bibliographystyle{splncs03}
\bibliography{TA}


\end{document}
