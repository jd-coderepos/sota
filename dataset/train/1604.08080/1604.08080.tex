\subsection{Atomic Commands and Proof Outline for \jywrite}
\label{sc:atoms-write}

\begin{figure}[t]

  \caption{\label{proof:write} Proof outline for .}
\end{figure}
 
We start with the \jywrite\ method, whose proof outline is given in
Figure~\ref{proof:write}. The key insight here is that we need to
stablish the freshness of the write in the order, \ie the  assertion, immediately after the event was
commited to memory, and then keep track of the evolution of its status
in ---determined by its color---down until we finish and
transfer the write to the thread's self history . Before we go
over the steps of the proof, we introduce the spec of each of its
atomic commands.

\gad{Should line numbers refer to Figure~\ref{fig:fcsl-snapshot} or to
  Figure~\ref{proof:write}. Right now, we use
  Figure~~\ref{fig:fcsl-snapshot}'s line numbers, because I wrote the
  atomics first and I was introducing the PO figure later. But, I've
  changed that now... So maybe we should use the ones from the PO
  everyhwre}.





On line~\lineWrtWrt~in Figure~\ref{fig:fcsl-snapshot},
 atomically commits the
write event and executes the  auxiliary method
described in Section~\ref{sc:implementation}, and summarized in
Figure~\ref{fig:writeauxcode}. The precondition states that
 is safe to run in the state of a recently initiated
writer thread. The postcondition states that the new write event has
being processed, and thus the writer state is now 
where, from the defintion of  in
Figure~\ref{fig:writeauxcode}, we know  is a fresh timestamp in the
history . By Invariant~\ref{inv:joint-hist}, we also know
that  is in .



The stability of the writer state assertions , , and so on, as well as any scanner state assertions
for \jyscan's atomics, are guaranteed by the fact we enforce there is
at most one thread executing \jyscan, and at most one thread executing
a call to \jywrite~on each of the pointers.


The assertion  holds trivially since we have not
made any changes to . All there is left to show is that , that is, that the position of the fresh
write event  is fixed in  with regard to events that
have terminated before the call to to the atomic command and also with
regard to those which have been marked by a scanner \ie, those in the
 set. By Lemma~\ref{lem:ghosts-mono}, we have
that  and . By the definition of  in
Figure~\ref{fig:writeauxcode}, we have that , thus we now that it will be on the
right of  with regard to any previously existing timestamp in
the domain of the global history ---\ie .

We consider the first case, where . Then, by
Invariant~\ref{inv:dom-tau} and monotonicity we have that . Since , we have that  and thus, by freshness we conclude that
. In the latter case, if , then we have that  and, again, since , by
Definition~\ref{def-jleq},  and thus we
conclude that .



Finally, it should be noticed that the post-condition does not make
any mention to the write event being commited to memory, other than
having recorded the write event in the writer state , which is
the last of  in . Then, by
Invariant~\ref{inv:last-key}, we know the value must have being
commited to memory--- the invariant could not have been satisfied by
 otherwise.









In line~\lineWrtChk~(Figure~\ref{fig:fcsl-snapshot}),  reads the value of the scanner
bit  and depending on it being true or false, \aux{checkS} changes
the writer state accordingly (Figure\ref{fig:writeauxcode}). The value
of the scanner bit  is returned as a result of the
computation. The precondition of \esc{checkS} states that we have an
active ongoing write event, which has already been registered: . The postcondition here just reflects that
depending on the returned value, the writer states changes to indicate
the value has to be been forwarded, or alternativeley, the writer will
finish without writing to its forwarding pointer.









In line~\lineWrtFwd~(Figure~\ref{fig:fcsl-snapshot}), provided the
previous command returned {\tt true}--- \ie  ---  writes the value
from the new event to the forwarding pointer  and executes
the auxiliary method ~(Figure~\ref{fig:writeauxcode})
which, if the scanner bits  and  are set, will paint the
entry  and mark the write event as {\it done} and
thus ready to be transfered to the self history by
. Again, here the specs do not need to mention the
effect on physical heap, as the latter is captured by the invariants
of the auxiliary state, Invariant~\ref{inv:readFP} in particular.








In line~\lineWrtFnz~(Figure~\ref{fig:fcsl-snapshot}),  finalizes the write event in process,
tranfering  from  to  and recording the
ending time of the event in , as per the definition of
 in Figure~\ref{fig:writeauxcode}. Also, we marked the
writer thread as finished.


Finally, Figure~\ref{proof:write} presents the proof outline for the
\jywrite\ command. Again, we favour the use of logical variables
instead of VDM notation, and we right away bind the initial values of
 and  to  and . Also, in line~2, we have
succeded to acquire the lock for the {\it writer thread}  and
therefore we recover the thread invariant for p--- omitted throughout
the paper on purpose---that states that we are given a {\it clean
  writer state } after acquiring the mutex: . In line~4,
we can already stablish that new write event  will be sorted in
 after all terminated and scanned events prior to the
call to \jywrite: . This assertion is carried down until the
end by monotonicity reasoning (Lemma~\ref{lem:ghosts-mono},
item~\ref{lem:stableorder-mono}). The rest of the proof outline for
write it is not interesting, as it will only alter internal auxiliary
state that will provide ongoing or future scans with information
regarding this write event. In line~5, we read the bit  and if we
read  we will forward the value on the forwarding pointer
. In any case, in line~8 we are in a 
state, either by the effect of forwarding, or by skipping through the
else branch. Thus we are ready to be finish in line~10, we get that
the active write has been {\it finalized}, \ie it has been moved to
the private self history .

\subsection{Atomic Commands and Proof Outline for \jywrite}
\label{sc:atoms-write}

\def\botLGY{{\ensuremath{\mathsf{fwdLastGY}}}}
\def\histLGY{{\ensuremath{\mathsf{lastGYHist}}}}
\def\greenH{{\ensuremath{\mathsf{green\_prefix}}}}
\newcommand{\spz}{S_z}

\begin{figure}[!htp]

  \caption{\label{proof:scan} Proof outline for .}
\end{figure}
 
The proof outline for \jyscan\ is given in
Figure~\ref{proof:scan}. There are two key insights to the proof: the
first is that after we have cleared the forwarding pointers through
lines~5--7, all events prior to the the call to  will have
been painted green and therefore, a subset of . The other observation comes from the fact that when we
read the values of the pointers  and , through lines~9--11, and
also when we read the forwarding pointers  and  throug
lines~15--17, the write events that registered those values are either
the last green or yellow timestamp of each subhistory  and
. As we showed before in Section~\ref{sc:implementation}, this
is the precondition of the  auxiliary code function, and
fundamental to its preservation of the auxiliary state Invariants (see
Appendix~\ref{sc:relink-lemmas} in~\cite{CoqFiles}).

In order to go over the details of each step of the proof, we need to
present first the specs for the atomic commands. To that end, we need
to introduce some abbreviation for auxiliary assertions and establish
their stability. Again, the proof of the stability statements has
being carried out in our Coq source files~\cite{CoqFiles}. We
introduce the following abbreviations of the last green or yellow
assertion introduced above~\eqref{eq:lgVy}:


\begin{lemma}[Stability of Assertions II]\label{lem:menvs-scan}
The following assertions are stable under interference from
environment steps:
\begin{enumerate}
 \item \label{lem:menvs:green-phist} For all  and
    such that ,  is stable.

 \item\label{lem:menvs:green-subhist} For all history  such that ,  is stable.

 \item \label{lem:menvs:some-lgVy} For all , if  and  then  is stable.

 \item \label{lem:menvs:none-lgVy} For all ,
    is stable.
\end{enumerate}
Moreover, we will abuse notation to refer with primed notation names,
\eg , to the unfolding of their definitions with primed
ghost projection variables.
\end{lemma}



\gad{Again, because I changed the position of the PO figures during
  the writeup, I'm switching back here to use line references w.r.t
  Figure~\ref{fig:fcsl-snapshot} rather than using the line numbers
  from the proof outline in Figure~\ref{fig:proof-scan}. This might be
  confusing!}





The scanner method starts by writing to the scan control bit  on
line~\lineScanSetsS\ in Figure~\ref{fig:fcsl-snapshot}. Here we use
auxiliary code , with a  parameter, and the
effect is just to mark the scan process active: . Again,
the post-condition does not mention the contents of the pointer  in
the physical heap, but the values of  and  are tied by
Invariant~\ref{inv:scan-state}. Then, through
lines~\lineScanClearsX--\lineScanClearsY~the scanner method clears the
forwarding pointer by writing  to  as well as painting
the sub-history  green, by iterated use of the following
atomic command:



Here, the notation  , stands for:

At first glance, the spec of this atomic command looks a bit akward,
as we would have expected it to just assert that the the domain of the
subhistory  is green, by the effect of the 
auxiliary code described before
(Figure~\ref{fig:scanauxcode}). Instead, we encounter this universal
quantification that reminds us of a Hoare Logic loop invariant. In
fact, what we have is \emph{indeed} an array iteration---see Jayanti's
original formulation of the algorithm
in~\cite{Jayanti+STOC05}---unfolded to the two forwarding pointers
 and . Then, since at the second iteration in
line~\lineScanClearsY\ we want to keep the knlowedge than the history
 has already been painted green, we need to add this to the
precondition. Notice that, once we have stablished that each
subhistory  is green, the assertion remains stable by
Lemma~\ref{lem:menvs-scan}. Moreover, it should also be noticed that
the postcondition asserts that all write events in  are green
in , and thus fixed in . But it \emph{does not}
imply that all elements in  are green. Even when we know that
the atomic effect of  is to paint the full subhistory
 green, the latter assertion would not be stable: by the
semantics of FCSL assertions~\cite{NanevskiLSD+ESOP14} there could be
a new write event --- but ---, which
by the definition of ~(Figure~\ref{fig:writeauxcode})
will be {\sf yellow} in . Thus we can only assert that all the
elements in  prior to the call to the atomic command will be
painted {\sf green}.



On lines~\lineScanReadsX--\lineScanReadsY~the scanner method reads
from the main memory, by iterated use of the following atomic command:
3pt] ~~ \logvar{h}
  \!\begin{array}[t]{l}
     \tsPre{\{\, \histS = \hempty \wedge
       \sss = \sOn \wedge \spp = \TT \wedge
       h \subseteq \hist \wedge
       \C(\dom{h}) = \mathsf{green}\}}\ A\
The precondition states that we have already painted a prefix of the
full history  green, therefore we have already marked all
previous write events as visible. One of the key insights of our proof
is that when we read here from the pointer , we do so from the last
green or yellow write event of . This means that the value
read was either already fixed in --- and therefore
\jyscan\ should not miss it--- or its status was yet to be resolved
and might require further relinking. When we read atomically from 
we assert this fact, as a consequence of
Lemma~\ref{lemma:first-read}. However, the assertion might not be
valid in line~\lineScanRelinks, when the hypothesis will actually be
used. We recognize, however, that in order for the scanner to return
the value  in the snapshot, it should read  from  in
lines~\lineScanReadsFX--\lineScanReadsFY---notice the \emph{prophetic
  nature} of this observation--- and, therefore, we add this guard to
the assertion in the postcondition.



In line~\lineScanUnsetsS\ the scanner method unsets the bit . The
specification looks demanding but, appart from recording the timestamp
at which the scanner was unset---\ie its linearization point---the
atomic command is just merely carrying down the collected information
about the green prefix  and the fact that the read values------were given by the last green or yellow timestamps------ of their respective histories, downwards to the point in the
algorithm were the decisions about the stable order  are
being made (line~\lineScanRelinks). We must, however, still prove that
these assertions hold after the atomic steps. Since the auxiliary
code function  does not change the color of the
timestamps, they are trivially valid.



Through lines~\lineScanReadsFX--\lineScanReadsFY, the \jyscan method
reads from the forwarding pointers  and . The pre-condition
states the the previous values read through
lines~\lineScanReadsX--\lineScanReadsY are the last green or yellow of
the subhistory , provided that the forwarding pointer
 is still --- \ie it did not change since the scanner
cleared it through lines~\lineScanClearsX--\lineScanClearsY. When the
 reads from read from , by
Invariant~\ref{inv:readFP}, we now that if , there exits
 s.t. , and  is the last green or
yellow write event of . In which case we return it, thus
already selecting which timestamp will be returned by \jyscan. In the
case \jyscan\ reads , we instantiate  with . It is
important that we make the decision of choosing the write event that
the scanner will return now, even though the scanner willnot make this
choice until lines~\lineScanChoosesRX--\lineScanChoosesRY: if we delay
this choice, a pending concurrent write to  whose next execution
would be line~\lineWrtFwd and therefore has lost the race for
 with the scanner could still be scheduled before \jyscan's
line~\lineScanRelinks and invalidate the 
assertion.


Finally, the \jyscan\ method executes  on
line~\lineScanRelinks, returning the selected snapshot  and
relinking the events so that the  justifies the choice
of snapshots. From the precondition, we now that there is a subhistory
 which has been completely painted green, and thus
permanently fixed in , and also that the write events
for the snapshot are the last greens or yellows of their respective
subhistories  and . In order to justify that the final
state satisfies the postcondition, we state an intermediate collection
of results that we have proven in our Coq development~\cite{CoqFiles}.

\gad{I need the following property back in somewhere before: It should
  be added to  properties, Lemma~\ref{lem:scanned}, or on
  its own at the end of Section~\ref{auxiliaries}. I has originally
  put it in the specs file, but I'm not sure where it should go now.}

\begin{proposition}[ inversion]\label{lem:eval-inversion} 
  If  then:
  
\end{proposition}

\begin{theorem}[Scan returns the maximal green prefix]\label{lem:relink-prefix}
 Given a state which statisfies 's precondition, and let
  denote the ghost
 projection of the STS state after , then:
 \begin{enumerate}
 \item\label{lem:relink-lgVy} For all ,  is the
   last green write event of , ie\ .
 \item\label{lem:relink-green} Let , then ,
   \ie every timestamp in the prefix of the logical order up to the
   scanned event returned by \jyscan\ is .
 \end{enumerate}
\end{theorem}

\begin{proof}
We have proven this collection of results in Coq, so we give only some
high level details here. For item~\ref{lem:relink-lgVy}, consider that
one effect of  is to paint  and  green, also
by the definition of  and its properties (see
Appendix~\ref{sc:relink-lemmas} in~\cite{CoqFiles}), we have that
 and  therefore we conclude. The
second item follows from proving that , the first item and the
RedZone Invariant, Invariant~\ref{inv:redzone}.
\end{proof}

\begin{corollary}[ Post-Condition]\label{lem:relink-scanned} 
  Let , then the state
  satisfies the post-conditions of relink atomic command:
  \begin{enumerate}
  \item \label{lem:relink-scanned} 
    the timestamp that determines the snapshot is a valid scan event.
  \item \label{lem:relink-eval} 
    the snapshot is produced by inspection of the scan event in the
    history.
  \item \label{lem:relink-hist}  every write event before the execution
    of the atomic is fixed in the stable order before .
  \end{enumerate}
\end{corollary}

Then, the post-condition is satisfied by the existance of  and
Corollary~\ref{kem:relink-scanned}.

Finally, in Figure~\ref{proof:scan} we present the proof outline for
\jyscan. As we have claimed above, the first important observation
comes on line~8, when after clearing each of the forwarding pointers
we have stablished that the history prior to the call to \jyscan,
bound to  since the beginning, is . This allows us
to prove later on, that the effect of \jyscan is to try to grow the
 set. Then in lines~10--13, we read from the
main memory and establish that the write events  and  that
commited  and  to memory are the last yellow or
green at that moment, and will continue to be so provided the
corresponding forwarding pointer remains . On line~13, the
\jyscan\ sets the scan bit  to false, thus preventing any further
updates to the forwarding pointers. Through lines~13-16,
\jyscan\ reads from the forwarding pointers to check whether it can
recatch missed write events. In any case, the decission of the
timestamps of the snapshots is made in advance---after line~18 we
assert that  and
---to prevent
writer threads loosing the race for  and  to interfe with
the validity of our assertions. Then after reconciling which of the
read values constitute the snapshot--- which also will be the
arguments pased to ---, we finalize by executing the
main auxiliary procedure of the algorithm,  which will
resolve the order of the events, correcting the logical order if need
be to justify the correctness of the returned snapshot.


