\documentclass[a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,thmtools}
\usepackage{amssymb}
\usepackage[numbers, compress]{natbib}
\usepackage[cmintegrals]{newtxmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{euscript}
\usepackage{units}
\usepackage{enumerate}
\usepackage{xcolor}
\usepackage{todonotes}
\usepackage{booktabs}
\usepackage{comment}

\usepackage[bookmarks=true,hidelinks]{hyperref}
\usepackage{bbm}
\usepackage{multirow}

\usepackage{mathtools}
\usepackage{subcaption} 
\usepackage{graphicx}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepackage{float}
\usepackage{algpseudocode}
\usepackage{bbold}
\usepackage{microtype}
\usepackage{rotating}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{hyperref}

\textwidth=16cm \oddsidemargin=0cm \evensidemargin=0cm \textheight=23cm \voffset=-1cm
\renewcommand{\thefootnote}{\textbf{\arabic{footnote}}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{maintheorem}[theorem]{Main Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}

\DeclareMathOperator{\diag}{diag}


\makeatletter


\newcommand{\theHalgorithm}{\arabic{algorithm}}
\newcommand{\by}{{\bf y}}
\newcommand{\bz}{{\bf z}}
\newcommand{\bM}{{\bf M}}
\newcommand{\bP}{{\bf P}}
\newcommand{\bS}{{\bf S}}
\newcommand{\bw}{{\bf w}}
\newcommand{\bu}{{\bf u}}
\newcommand{\bb}{{\bf b}}
\newcommand{\bV}{{\bf V}}
\newcommand{\bx}{{\bf x}}
\newcommand{\bA}{{\bf A}}
\newcommand{\bX}{{\bf X}}
\newcommand{\bB}{{\bf B}}
\newcommand{\bC}{{\bf C}}
\newcommand{\bc}{{\bf c}}
\newcommand{\bo}{{\bf \omega}}
\newcommand{\ep}{\epsilon}
\newcommand{\ord}{{\mathcal O}}
\newcommand{\R}{{\mathbb R}}
\newcommand{\Dt}{{\Delta t}}
\newcommand{\ind}{\mathrm{I}}
\newcommand{\fref}[1] {Fig.~\ref{#1}}
\newcommand{\Tref}[1]{Table~\ref{#1}}
\newcommand{\E}{\EuScript{E}}

\newcommand{\byli}{{\bf y}^{\ell,i}}
\newcommand{\bzli}{{\bf z}^{\ell,i}}
\newcommand{\cli}{\hat{\sigma}({\bf c}^{\ell,i})}
\newcommand{\Ali}{{\bf A}^{\ell,i}}
\newcommand{\sli}{\sigma({\bf A}^{\ell,i}_{n-1})}
\newcommand{\bwli}{{\bf w}^{\ell,i}}
\newcommand{\cLi}{\hat{\sigma}({\bf c}^{L,i})}
\newcommand{\ALi}{{\bf A}^{L,i}}
\newcommand{\bwLi}{{\bf w}^{L,i}}

\newcommand{\bD}{{\bf D}}
\newcommand{\bE}{{\bf E}}

\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}

\begin{document}

\date{}

\title{UnICORNN: A recurrent model for learning \textit{very} long time dependencies}

\author{T. Konstantin Rusch \thanks{Seminar for Applied Mathematics (SAM), D-MATH \newline
  ETH Z\"urich, R\"amistrasse 101, 
  Z\"urich-8092, Switzerland} \and Siddhartha Mishra \samethanks}


\maketitle
\begin{abstract}
The design of recurrent neural networks (RNNs) to accurately process sequential inputs with long-time dependencies is very challenging on account of the exploding and vanishing gradient problem. To overcome this, we propose a novel RNN architecture which is based on a structure preserving discretization of a Hamiltonian system of second-order ordinary differential equations that models networks of oscillators. The resulting RNN is fast, invertible (in time), memory efficient and we derive rigorous bounds on the hidden state gradients to prove the mitigation of the exploding and vanishing gradient problem. A suite of experiments are presented to demonstrate that the proposed RNN provides state of the art performance on a variety of learning tasks with (very) long time-dependencies.
\end{abstract}
\section{Introduction}
Recurrent Neural Networks (RNNs) have been very successful in solving a diverse set of learning tasks involving sequential inputs \cite{DLnat}. These include text and speech recognition, time-series analysis and natural language processing. However, the well-known \emph{Exploding and Vanishing Gradient Problem} (EVGP) \cite{vanish_grad} and references therein, impedes the efficiency of RNNs on tasks that require processing (very) long sequential inputs.  The EVGP arises from the fact that the backpropagation through time (BPTT) algorithm for training RNNs entails computing products of hidden state gradients over a large number of steps and this product can either be exponentially small or large as the number of recurrent interactions increases. 

Different approaches to solve the EVGP has been suggested in recent years. These include the use of gating mechanisms, such as in LSTMs \cite{lstm} and GRUs \cite{gru}, where the additive structure of the gates mitigates the vanishing gradient problem. However, gradients might still explode, impeding the efficiency of LSTMs and GRUs on problems with very long time dependencies (LTDs) \cite{indrnn}. The EVGP can also be mitigated by constraining the structure of the recurrent weight matrices, for instance requiring them to be orthogonal or unitary \citep{orthornn,urnn,eurnn,nnRNN}. Constraining recurrent weight matrices may lead to a loss of expressivity of the resulting RNN, reducing its efficiency in handling realistic learning tasks \cite{nnRNN}. Finally, restricting weights of the RNN to lie within some prespecified bounds might lead to control over the norms of the recurrent weight matrices and alleviate the EVGP. Such an approach has been suggested in the context of \emph{independent neurons} in each layer in \cite{indrnn}, and using a coupled system of damped oscillators in \cite{coRNN}, among others. However, ensuring that weights remain within a pre-defined range during training might be difficult. Furthermore, \emph{weight clipping} could also reduce expressivity of the resulting RNN. 

In addition to EVGP, the learning of sequential tasks with very long time dependencies can require significant computational resources, for training and evaluating the RNN. Moreover, as the BPTT training algorithms entail storing all hidden states at every time step, the overall memory requirements can be prohibitive. Thus, \emph{the design of a fast and memory efficient RNN architecture that can mitigate the EVGP is highly desirable for the effective use of RNNs in realistic learning tasks with very long time dependencies.} The main objective of this article is to propose, analyze and test such an architecture. 

The basis of our proposed RNN is the observation that a large class of dynamical systems in physics and engineering, the so-called \emph{Hamiltonian systems} \cite{arn1}, allow for very precise control on the underlying states. Moreover, the fact that the phase space volume is preserved by the trajectories of a Hamiltonian system, makes such systems \emph{invertible} and allows one to significantly reduce the storage requirements. Furthermore, if the resulting hidden state gradients also evolve according to a Hamiltonian dynamical system, one can obtain precise bounds on the hidden state gradients and alleviate the EVGP. We combine and extend these ideas into an RNN architecture that will allow us to prove rigorous bounds on the hidden states and their gradients, mitigating the EVGP. Moreover, our RNN architecture results in a fast implementation that attains state of the art performance on a variety of learning tasks with very long time dependencies. 
\section{The proposed RNN}
Our proposed RNN is based on the time-discretization of the following system of \emph{second-order ordinary differential equations} (ODEs),

Here,  is the (continuous) time variable,  is the time-dependent \emph{input signal},  is the \emph{hidden state} of the RNN with  is a weight vector,  a weight matrix,
 is the bias vector and  is a control parameter. The operation  is the Hadamard product and the function  is the \emph{activation function} and is applied component wise. For the rest of this paper, we set .

By introducing the auxiliary variable , we can rewrite the second order ODE \eqref{eq:ode1} as a first order ODE system:


Assuming that , for all , it is easy to see that the ODE system \eqref{eq:ode} is a \emph{Hamiltonian system},

with the \emph{time-dependent Hamiltonian},

with  denoting the Euclidean norm of the vector  and  the corresponding inner product.

The next step is to find a discretization of the ODE system \eqref{eq:ode}. Given that it is highly desirable to ensure that the discretization respects the Hamiltonian structure of the underlying continuous ODE, the simplest such \emph{structure preserving discretization} is the \emph{symplectic Euler} method \cite{ss1,HLW1}. Applying the symplectic Euler method to the ODE \eqref{eq:ode} results in the following discrete dynamical system,

for . Here,  is the time-step and , with , is the input signal. It is common to initialize with . 

We see from the structure of the discrete dynamical system \eqref{eq:hRNN} that there is \emph{no interaction} between the neurons in the hidden layer of \eqref{eq:hRNN}. Such an RNN will have very limited expressivity. Hence, we \emph{stack} more hidden layers to propose the following deep or \emph{multilayer} RNN,

Here  are hidden states and  are weights and biases, corresponding to layer . We set  in the multilayer RNN \eqref{eq:ucrn}. 

Observe that we use the same step-size  for every layer, while multiplying a trainable parameter vector  to the time step. The action of  is modulated with the sigmoidal activation function , which ensures that the time-step  is multiplied by a value between  and . We remark that the presence of this trainable vector  allows us to incorporate \emph{multi-scale behavior} in the proposed RNN, as the effective time-step is learned during training and can be significantly different from the nominal time-step . It is essential to point out that including this multi-scale time stepping is only possible, as each neuron (within the same hidden layer) is independent of the others and can be integrated with a different effective time step. Finally, we also share the control hyperparameter  across the different layers, which results in a memory unit of  layers with a total of only  hyperparameters. 
\subsection{Motivation and background}
The ODE system \eqref{eq:ode} is a model for a nonlinear system of uncoupled driven oscillators \cite{GHbook}. To see this, we denote  as the displacement and  as the velocity. Then, the dynamics of the -th oscillator is determined by the frequency  and also by the \emph{forcing} or \emph{driving} term in the second equation of \eqref{eq:ode}, where the forcing acts through the input signal  and is modulated by the weight  and bias . Finally, the weight  modulates the frequency  and allows each neuron to oscillate with its own frequency, rather than the common frequency  of the system. The structure of  implies that each neuron is independent of the others. A key element of the oscillator system \eqref{eq:ode} is the absence of any damping or friction term. This allows the system to possess a Hamiltonian structure, with desirable long time behavior. Thus, we term the resulting RNN \eqref{eq:ucrn}, based on the ODE system \eqref{eq:ode} as \textbf{Un}damped \textbf{I}ndependent \textbf{C}ontrolled \textbf{O}scillatory \textbf{RNN} or \textbf{UnICORNN}. We remark that networks of oscillators are very common in science and engineering \cite{GHbook,stgz2} with prominent examples being pendulums in mechanics, electrical circuits in engineering, business cycles in economics and functional brain circuits such as cortical columns in neurobiology. 
\subsection{Comparison with related work.}
UnICORNN lies firmly in the class of ODE-based or ODE-inspired RNNs, which have received considerable amount of attention in the machine learning literature in recent years. Neural ODEs, first proposed in \cite{neuralODE}, are a prominent example of using ODEs to construct neural networks. In this architecture, the continuous ODE serves as the learning model and gradients are computed from a sensitivity equation, which allows one to trade accuracy with computing time. Moreover, it is argued that these neural ODEs are invertible and hence, memory efficient. However, it is unclear if a general neural ODE, without any additional structure, can be invertible. Other RNN architectures that are based on discretized ODEs include those proposed in \cite{E} and \cite{anti}, where the authors proposed an \emph{anti-symmetric} RNN, based on the discretization of a stable ODE resulting from a skew-symmetric hidden weight matrix, thus constraining the gradient dynamics.

Our proposed RNN \eqref{eq:ucrn} is inspired by two recent RNN architectures. The first one is \emph{coRNN}, proposed recently in \cite{coRNN}, where the underlying RNN architecture was also based on the use of a network of oscillators. As long as a constraint on the underlying weights was satisfied, coRNN was shown to mitigate the EVGP. In contrast to coRNN, our proposed RNN does not use a \emph{damping} term. Moreover, each neuron, for any hidden layer, in UnICORNN \eqref{eq:ucrn} is independent. This is very different from coRNN where all the neurons were coupled together. Finally, UnICORNN is a multi-layer architecture whereas coRNN used a single hidden layer. These innovations allow us to admit a Hamiltonian structure for UnICORNN and facilitate a fast and memory efficient implementation. 

Our proposed architecture was also partly inspired by \emph{IndRNN}, proposed in \cite{indrnn,deep_indrnn}, where the neurons in each hidden layers were independent of each other and interactions between neurons were mediated by stacking multiple RNN layers, with output of each hidden layer passed on to the next hidden layer, leading to a deep RNN. We clearly use this construction of independent neurons in each layer and stacking multiple layers in UnICORNN \eqref{eq:ucrn}. However in contrast to IndRNN, our proposed RNN is based on a discretized Hamiltonian system and we will not require any constraints on the weights to mitigate the EVGP.

Finally, we would like to point out that discrete Hamiltonian systems have already been used to design RNNs, for instance in \cite{hnn} and also in \cite{srnn}, where a symplectic time-integrator for a Hamiltonian system was proposed as the RNN architecture. However, these approaches are based on underlying time-independent Hamiltonians and are only relevant for mechanical systems as they cannot process time-dependent inputs, which arise in most realistic learning tasks. Moreover, as these methods enforce exact conservation of the Hamiltonian in time, they are not suitable for learning long-time dependencies, see \cite{inv_lstm} for a discussion and experiment on that issue. Although we use a Hamiltonian system as the basis of our proposed RNN \eqref{eq:ucrn}, our underlying Hamiltonian \eqref{eq:hamil} is time-dependent and the resulting RNN can readily process any time-dependent input signal. 
\subsection{On the Memory Efficiency of UnICORNN}
As mentioned in the introduction, the standard BPTT training algorithm for RNNs requires one to store all the hidden states at every time step. To see this, we observe that for a standard multi-layer RNN with  layers and a mini-batch size of  (for any mini-batch stochastic gradient descent algorithm), the storage (in terms of floats) scales as , with input and hidden sequences of length . This memory requirement can be very high. Note that we have ignored the storage of trainable weights and biases for the RNN in the above calculation.

On the other hand, as argued before, our proposed RNN is a symplectic Euler discretization for a Hamiltonian system. Hence, it is invertible. In fact, one can explicitly write the \emph{inverse} of UnICORNN \eqref{eq:ucrn} as,

Thus, one can recover all the hidden states in a given hidden layer, only from the \emph{stored} hidden state at the final time step, for that layer. Moreover, only the input signal needs to be stored as the other hidden states can be reconstructed from the formula \eqref{eq:inv_ucrn}. Hence, a straightforward calculation shows that the storage for UnICORNN scales as . As , we conclude that UnICORNN allows for a significant saving in terms of storage, when compared to a standard RNN. 
\section{Rigorous Analysis of UnICORNN}
\paragraph{Properties of the ODE \eqref{eq:ode}.}
In order to investigate the EVGP for the proposed RNN \eqref{eq:ucrn}, we will first explore the dynamics of the gradients of hidden states  (solutions of the ODE \eqref{eq:ode}) with respect to the trainable parameters  and . Denote any scalar parameter as  and , then differentiating the ODE \eqref{eq:ode} with respect to  results in the ODE,

where  is the pre-activation and the coefficient  is given by  if ,   if  and  if , with all other entries of the vector  being zero.

It is easy to check that the ODE system \eqref{eq:hsg} is a \emph{Hamiltonian system} of form \eqref{eq:ham1}, with the following time-dependent Hamiltonian;

Thus, by the well-known Liouville's theorem \cite{ss1}, we know that the phase space volume of \eqref{eq:hsg} is preserved. Hence, this system cannot have any asymptotically stable fixed points. This implies that  cannot be a stable fixed point for the hidden state gradients . Thus, we can expect that the hidden state gradients with respect to the system of oscillators \eqref{eq:ode} do not remain near zero.     

On the other hand, as the Hamiltonian \eqref{eq:hsgHam} for the hidden state gradient system \eqref{eq:hsg} is time-dependent, we cannot directly infer that the gradients satisfy an upper bound. However, we prove (in Appendix {\bf C.2}) the following bounds,
\begin{proposition}
\label{prop:n2}
Let  be the solutions of the ODE system \eqref{eq:hsg} for hidden state gradients, at any time . Then for  and for all , the hidden state gradients are bounded by,

with , and for some constant  that only depends on the dimension  and on the constant  that bounds the input .
\end{proposition}
A similar upper bound for  is given in Appendix {\bf C}.
\paragraph{On the Exploding Gradient Problem for UnICORNN.} We train the RNN \eqref{eq:ucrn} to minimize the loss function,

with  being the underlying ground truth (training data). Note that the loss function \eqref{eq:lf1} only involves the output at the last hidden layer (we set the affine output layer to identity for the sake of simplicity). During training, we compute gradients of the loss function \eqref{eq:lf1} with respect to the trainable weights and biases , for all , i.e.,
 
Given the upper bounds \eqref{eq:nbd3} on the hidden state gradients for the underlying ODE \eqref{eq:ode}, it is reasonable to expect that the gradient \eqref{eq:grad1} is bounded. This is indeed the case and we have the following proposition,
\begin{proposition}
\label{prop:3}
Let  in the RNN \eqref{eq:ucrn} and let , for , be the hidden states generated by the RNN \eqref{eq:ucrn}. Then, the gradient of the loss function  \eqref{eq:lf1} with respect to any parameter  is bounded as,

with , be a bound on the underlying training data and other quantities in \eqref{eq:gbd} defined as,

\end{proposition}
This proposition, proved in Appendix {\bf D.2}, demonstrates that as long as the weights  are bounded, there is a uniform bound on the hidden state gradients and the \emph{exploding gradient problem} is mitigated for UnICORNN.
\paragraph{On the Vanishing Gradient Problem for UnICORNN.}
By applying the chain rule repeatedly to each term on the right-hand-side of \eqref{eq:grad1}, we obtain 

Here, the notation  refers to taking the partial derivative of  with respect to the parameter , while keeping the other arguments constant.  The quantity  denotes the contribution from the -recurrent step at the -th hidden layer of the deep RNN \eqref{eq:ucrn} to the overall hidden state gradient at the step . The vanishing gradient problem \citep{vanish_grad} arises if , defined in \eqref{eq:grad2},  exponentially fast in , for  (long-term dependencies). In that case, the RNN does not have long-term memory, as the contribution of the -th hidden state at the -th layer to error at time step  is infinitesimally small.

We have established that the hidden state gradients for the underlying continuous ODE \eqref{eq:ode} do not vanish. As we use a symplectic Euler discretization, the phase space volume for the discrete dynamical system \eqref{eq:hRNN} is also conserved \cite{ss1,HLW1}. Hence, one can expect that the gradients of the multilayer RNN \eqref{eq:ucrn} do not vanish. However, these heuristic considerations need to be formalized. Observe that the vanishing gradient problem for RNNs focuses on the possible smallness of contributions of the gradient over a large number of recurrent steps. As this behavior of the gradient is independent of the number of layers, we focus on the vanishing gradient problem for a single hidden layer here, while presenting the multilayer results in Appendix {\bf D.4}. Also, for the sake of definiteness, we set the scalar parameter  for some . Similar results also hold for any other . We have following representation formula (proved in Appendix {\bf D.3}) for the hidden state gradients,
\begin{proposition}
\label{prop:4}
Let  be the hidden states generated by the RNN \eqref{eq:ucrn}.  Then the gradient for long-term dependencies, i.e. , satisfies the representation formula,

\end{proposition}
It is clear from the representation formula \eqref{eq:glb} that there is no -dependence for the gradient. In particular, as long as all the weights are of , the leading-order term in \eqref{eq:glb} is . Hence, the gradient can be small but is independent of the recurrent step . Thus, we claim that the \emph{vanishing gradient problem}, with respect to recurrent connections, is mitigated for UnICORNN \eqref{eq:ucrn}.  
\section{Experiments}
The details of the training procedure
for each experiment can be found in Appendix {\bf A}. Code to replicate the experiments can be found at
\href{https://github.com/tk-rusch/unicornn}{\textbf{https://github.com/tk-rusch/unicornn}}.
\paragraph{Implementation}
The structure of UnICORNN \eqref{eq:ucrn} enables us to achieve a very fast implementation. First, the transformation of the input (i.e.  for all ), which is the most computationally expensive part of UnICORNN, does not have a sequential structure and can thus be computed in parallel over time. Second, as the underlying ODEs of the UnICORNN are uncoupled for each neuron, the remaining recurrent part of UnICORNN is solved independently for each component. Hence, inspired by the implementation of Simple Recurrent Units (SRU) \citep{sru} and IndRNN, we present in Appendix {\bf B}, the details of an efficient CUDA implementation, where the input transformation is computed in parallel and the dynamical system corresponding to each component of \eqref{eq:ucrn} is an independent CUDA thread. 

We benchmark the training speed of UnICORNN with  layers, against the fastest available RNN implementations, namely the cuDNN implementation \citep{cudnn_lstm} of LSTM (with 1 hidden layer), SRU and IndRNN (both with  layers and with batch normalization). \fref{fig:speed} shows the computational time (measured on a GeForce RTX 2080 Ti GPU) of the combined forward and backward pass for each network, averaged over  batches with each of size , for two different sequence lengths, i.e. . We can see that while the cuDNN LSTM is relatively slow, the SRU, IndRNN and the UnICORNN perform similarly fast. Moreover, we also observe that UnICORNN is about  times faster per combined forward and backward pass, when compared to recently developed RNNs such as expRNN \cite{exprnn} and coRNN \cite{coRNN}. We thus conclude that the UnICORNN is among the fastest available RNN architectures.
\begin{figure}[ht!]
\centering
\begin{minipage}[t]{0.49\textwidth}	
\includegraphics[width=1.\textwidth]{figures/speed.pdf}
\caption{Measured computing time for the combined forward and backward pass for the UnICORNN as well as for three of the fastest available RNN implementations.}
\label{fig:speed}
\end{minipage}\hspace{0.01\textwidth}
\begin{minipage}[t]{.49\textwidth}
\includegraphics[width=1.\textwidth]{figures/eigenworms_ltd.pdf}
\caption{Test accuracy (mean and standard deviation) for the UnICORNN on EigenWorms for two types of sub-sampling approaches, i.e. using the last entries of the sequences as well as using a random subset of the entries. Both are shown for increasing number of entries used in each corresponding sub-sampling routine.}
\label{fig:worms}
\end{minipage}
\end{figure}
\paragraph{Permuted sequential MNIST}
A well-established benchmark for testing RNNs on input sequences with long time-dependencies is the permuted sequential MNIST (psMNIST) task \citep{seq_mnist}. Based on the classical MNIST data set \citep{mnist}, the flattened grey-scale matrices are randomly permuted (based on a fixed random permutation) and processed sequentially by the RNN. This makes the learning task more challenging than sequential MNIST, where one only flattens the MNIST matrices without permuting them. In order to make different methods comparable, we use the same fixed seed for the random permutation, as in \cite{exprnn,dtriv,scornn}. \Tref{tab:psmnist} shows the results for UnICORNN with  layers, together with other recently proposed RNNs, which were explicitly designed to learn LTDs as well as two gated baselines. We see that UnICORNN clearly outperforms the other methods.

\begin{table}[h!]
  \caption{Test accuracies on permuted sequential MNIST together with number of hidden units as well as total number of parameters for each network. All other results are taken from the corresponding original publication, cited in the main text, except that we are using the results of \cite{GRU_results} for GRU and of \cite{scornn} for LSTM.}
  \label{tab:psmnist}
  \centering
  \begin{tabular}{llll}
    \toprule
    \cmidrule(r){1-4}
    { Model} &  test accuracy & \# units & { \# params} \\
    \midrule
LSTM & 92.9\% & 256 & 270k\\
GRU & 94.1\% & 256 & 200k\\
expRNN & 96.6\%  & 512 & 127k\\
coRNN  & 97.3\% & 256 & 134k \\
IndRNN (=6)  & 96.0\% & 128 & 86k\\
dense-IndRNN (=6) & 97.2\% & 128 & 257k \\
\textbf{UnICORNN} (=3) & 97.8\% & 128 & 35k\\
\textbf{UnICORNN} (=3) & \textbf{98.4}\% & 256 & 135k\\
    \bottomrule
  \end{tabular}
\end{table}

\paragraph{Noise padded CIFAR-10} 
A more challenging test for the ability of RNNs to learn LTDs is provided by the recently proposed noise padded CIFAR-10 experiment \citep{anti}. In it, the CIFAR-10 data points \citep{cifar} are fed to the RNN row-wise and flattened along the channels resulting in sequences of length 32. To test long term memory, entries of uniform random numbers are added such that the resulting sequences have a length of 1000, i.e. the last 968 entries of each sequences are only noise to distract the RNNs. \Tref{tab:cifar} shows the result of the UnICORNN with  layers together with the results of other recently proposed RNNs, namely for the LSTM, anti.sym. RNN and gated anti.sym. RNN \citep{anti}, Lipschitz RNN \citep{lip_rnn}, Incremental RNN \citep{inc_rnn}, FastRNN \citep{fastrnn} and coRNN \cite{coRNN}. We conclude that the proposed RNN readily outperforms all other methods on this experiment.
\begin{table}[h!]
  \caption{Test accuracies on noise padded CIFAR-10 together with number of hidden units as well as total number of parameters for each network. All other results are taken from literature, specified in the main text.}
  \label{tab:cifar}
  \centering
  \begin{tabular}{llll}
    \toprule
    \cmidrule(r){1-4}
    { Model} &  test accuracy & \# units & { \# params} \\
    \midrule
LSTM & 11.6\% & 128 & 64k\\
Incremental RNN& 54.5\% & 128 & 12k\\
Lipschitz RNN & 55.8\%  & 256 & 158k\\
FastRNN & 45.8\% & 128 & 16k\\
anti.sym. RNN & 48.3\% & 256 & 36k\\
gated anti.sym. RNN & 54.7\% & 256 & 37k \\
coRNN & 59.0\% & 128 & 46k \\
\textbf{UnICORNN} (=3) & \textbf{62.4}\% & 128 & 47k\\
    \bottomrule
  \end{tabular}
\end{table}

\paragraph{EigenWorms}
The EigenWorms data set \cite{eigenworms} is a collecting of 259 very long sequences, i.e. length of 17984, describing the motion of a worm. The task is, based on the 6-dimensional motion sequences, to classify a worm as either wild-type or one of four mutant types. We use the same train/valid/test split as in \cite{log_ode}, i.e. //. As the length of the input sequences is extremely long for this test case, we benchmark UnICORNN against three sub-sampling based baselines. These include the results of \cite{log_ode}, which is based on signature sub-sampling routine for neural controlled differential equations. Additionally after a hyperparameter fine-tuning procedure, we perform a random sub-sampling as well as truncated back-propagation through time (BPTT) routine using LSTMs, where the random sub-sampling is based on  randomly selected time points of the sequences as well as the BPTT is truncated after the last  time points of the sequences. Furthermore, we compare UnICORNN with three leading RNN architectures for solving LTD tasks, namely expRNN, IndRNN and coRNN, which are all applied to the full-length sequences. The results, presented in \Tref{tab:worms}, show that while sub-sampling approaches yield moderate test accuracies, expRNN as well as the IndRNN yield very poor accuracies. In contrast, coRNN performs very well. However, the best results are obtained for UnICORNN as it reaches a test accuracy of more than , while at the same time yielding a relatively low standard deviation, further underlining the robustness of the proposed RNN.
\begin{table}[h!]
\caption{Test accuracies on EigenWorms using  re-trainings of each best performing network (based on the validation set) together with number of hidden units as well as total number of parameters for each network.}
\label{tab:worms}
\centering
\begin{tabular}{llll}
\toprule
\cmidrule(r){1-4}
{ Model} &  test accuracy & \# units & { \# params} \\
\midrule
t-BPTT LSTM & 57.9\%7.0\% &32 & 5.3k\\
sub-samp. LSTM &  69.2\%8.3\% &32 & 5.3k\\
sign.-NCDE & 77.8\%5.9\% & 32 & 35k\\
\midrule
expRNN & 40.0\%10.1\% & 64 & 2.8k \\
IndRNN (=2) & 49.7\%4.8\% & 32 & 1.6k \\
coRNN & 86.7\%3.0\%&32 & 2.4k \\
\textbf{UnICORNN} (=2) & \textbf{90.3}\%\textbf{3.0}\% & 32 & 1.5k\\
    \bottomrule
  \end{tabular}
\end{table}

\par As this data set has only recently been proposed as a test for RNNs in learning LTDs, it is unclear if the input sequences truly exhibit very long time-dependencies. To investigate this further, we train UnICORNN on a subset of the entries of the sequences. To this end, we consider using only the last entries as well as using a random subset of the entries. \fref{fig:worms} shows the distributional results (10 re-trainings of the best performing UnICORNN) for the number of entries used in each sub-sampling routine, ranging from only using  entries to using the full sequences for training. We can see that in order to reach a test accuracy of  when training on the last entries of the sequences, at least the last 10k entries are needed. Moreover, for both sub-sampling methods the test accuracy increases monotonically as the number of entries for training is increased. On the other hand, using a random subset of the entries increases the test accuracy significantly when compared to using only the last entries of the sequences. This indicates that the important entries of the sequences, i.e. information needed in order to classify them correctly, are uniformly distributed throughout the full sequence. We thus conclude that the EigenWorms data set indeed exhibits \emph{very} long time-dependencies.

\paragraph{Healthcare application: Vital signs prediction}
We apply UnICORNN on two real-world data sets in health care, aiming to predict the vital signs of a patient, based on PPG and ECG signals. The data sets are part of the TSR archive \cite{ai_healthcare} and are based on clinical data from the Beth Israel Deaconess Medical Center. The PPG and ECG signals are sampled with a frequency of Hz for  minutes each. The resulting two-dimensional sequences have a length of . The goal is to predict a patient's respiratory rate (RR) and heart rate (HR) based on these signals. We compare UnICORNN to 3 leading RNN architectures for solving LTDs, i.e. expRNN, IndRNN and coRNN. Additionally, we present two baselines using the LSTM as well as the recently proposed sub-sampling method of computing signatures for neural controlled differential equations (NCDE) \cite{log_ode}. Following \cite{log_ode}, we split the  sequences in a training set, validation set and testing set, using a 70\%/15\%/15\% split. \Tref{tab:medical} shows the distributional results of all networks using 5 re-trainings of the best performing RNN. We observe that while the LSTM does not reach a low  testing error in both experiments, the other RNNs approximate the vital signs reasonably well. However, UnICORNN clearly outperforms all other methods on both benchmarks. We emphasize that UnICORNN significantly outperforms all other state-of-the-art methods on estimating the RR, which is of major importance in modern healthcare applications for monitoring hospital in-patients as well as for mobile health applications, as special invasive equipment (for instance capnometry or measurement of gas flow) is normally needed to do so \cite{rr}.
\begin{table}[h!]
  \caption{ test error on vital sign prediction using  re-trainings of each best performing network (based on the validation set), where the respiratory rate (RR) and heart rate (HR) is estimated based on PPG and ECG data.}
  \label{tab:medical}
  \centering
  \begin{tabular}{lll}
    \toprule
    \cmidrule(r){1-3}
    Model & RR & HR \\
    \midrule
sign.-NCDE & 1.510.08 &  2.970.45  \\
LSTM  & 2.280.25 & 10.72.0  \\
expRNN & 1.570.16 & 1.870.19 \\
IndRNN (=3) & 1.470.09 & 2.10.2 \\
coRNN & 1.450.23 & 1.710.1 \\
\textbf{UnICORNN} (=3) &  \textbf{1.06}\textbf{0.03} & \textbf{1.39}\textbf{0.09}\\
    \bottomrule
  \end{tabular}
\end{table}

\paragraph{Sentiment analysis: IMDB}
As a final experiment, we test the proposed UnICORNN on the widely used NLP benchmark data set IMDB \citep{imdb}, which consists of 50k online movie reviews with 25k reviews used for training and 25k reviews used for testing. This denotes a classical sentiment analysis task, where the model has to decide whether a movie review is positive or negative. We use 30\% of the training set (i.e. 7.5k reviews) as the validation set and restrict the dictionary to 25k words. We choose an embedding size of 100 and initialize it with the pretrained 100d GloVe \cite{glove} vectors.
\begin{table}[h!]
  \caption{Test accuracies on IMDB together with number of hidden units as well as total number of parameters (without embedding) for each network. All other results are taken from literature, specified in the main text.}
  \label{tab:imdb}
  \centering
  \begin{tabular}{llll}
    \toprule
    \cmidrule(r){1-4}
    { Model} &  test accuracy & \# units & { \# params} \\
    \midrule
LSTM&  86.8\% & 128 & 220k\\
skip LSTM & 86.6\% & 128 & 220k \\
GRU & 85.2\% & 128 & 99k\\
ReLU GRU & 84.8\% & 128 & 99k \\
skip GRU & 86.6\% & 128 & 165k\\
coRNN & 87.4 \% &128 & 46k \\
\textbf{UnICORNN} (=2) & \textbf{88.4}\% & 128 & 30k\\
    \bottomrule
  \end{tabular}
\end{table}

\Tref{tab:imdb} shows the results for UnICORNN with 2 layers together with other recently proposed RNN architectures and gated baselines (which are known to perform very well on these tasks). The result of ReLU GRU is taken from \cite{imdb_gru}, of coRNN from \cite{coRNN} and all other results are taken from \cite{imdb_base}. We can see that UnICORNN outperforms the other methods while requiring significantly less parameters. We thus conclude, that the UnICORNN can also be successfully applied to problems, which do not necessarily exhibit long term-dependencies.
\section{Discussion}
The design of RNNs that can accurately handle sequential inputs with long-time dependencies is very challenging. This is largely on account of the exploding and vanishing gradient problem (EVGP). Moreover, there is a significant increase in both computational time as well as memory requirements when LTD tasks have to be processed. Our main aim in this article was to present a novel RNN architecture which is fast, memory efficient, \emph{invertible} and mitigates the EVGP. To this end, we proposed UnICORNN \eqref{eq:ucrn}, an RNN based on the symplectic Euler discretization of a Hamiltonian system of second-order ODEs \eqref{eq:ode} modeling a network of independent, undamped, controlled and driven oscillators. In order to gain expressivity, we stack layers of RNNs and also endow this construction with a multi-scale feature by training the effective time step in \eqref{eq:ucrn}. 

Given the Hamiltonian structure of our continuous and discrete dynamical system, invertibility and volume preservation in phase space are guaranteed. Invertibility enables the proposed RNN to be memory efficient. The independence of neurons within each hidden layer allows us to build a highly efficient CUDA implementation of UnICORNN that is as fast as the fastest available RNN architectures. Motivated by the fact that the underlying ODE \eqref{eq:ode1} as well as the ODE \eqref{eq:hsg}, governing the evolution of hidden state gradient possess a time-dependent Hamiltonian, we prove rigorous upper bounds \eqref{eq:gbd} on the gradients and show that the exploding gradient problem is mitigated for UnICORNN. Moreover, we derive an explicit representation formula \eqref{eq:glb} for the gradients of \eqref{eq:ucrn}, which shows that the vanishing gradient problem is also mitigated. Finally, we have tested UnICORNN on a suite of benchmarks that includes both synthetic as well as realistic learning tasks, designed to test the ability of an RNN to deal with long-time dependencies. In all the experiments, UnICORNN was able to show state of the art performance. 

It is instructive to compare UnICORNN with two recently proposed RNN architectures, with which it shares some essential features. First, the use of coupled oscillators to design RNNs was already explored in the case of coRNN \cite{coRNN}. In contrast to coRNN, neurons in UnICORNN are independent (uncoupled) and as there is no damping, UnICORNN possesses a Hamiltonian structure. This paves the way for invertibility as well as for mitigating the EVGP without any assumptions on the weights whereas the mitigation of EVGP with coRNN was conditional on restrictions on weights. Finally, UnICORNN provides even better performance on benchmarks than coRNN, while being significantly faster. While we also use independent neurons in each hidden layer and stack RNN layers together as in IndRNN \cite{indrnn}, our design principle is completely different as it is based on Hamiltonian ODEs. Consequently, we do not impose weight restrictions, which are necessary for IndRNN to mitigate the EVGP. Moreover, in contrast to IndRNNs, our architecture is invertible and hence, memory efficient. 

This work can be extended in different directions. First, UnICORNN is a very flexible architecture in terms of stacking layers of RNNs together. We have used a fully connected stacking in \eqref{eq:ucrn} but other possibilities can be readily explored. See Appendix {\bf D.5} for a discussion on the use of residual connections in stacking layers of UnICORNN. Second, the invertibility of UnICORNN can be leveraged in the context of normalizing flows \cite{nf}, where the objective is to parametrize a flow such that the resulting Jacobian is readily computable. Finally, our focus in this article was on testing UnICORNN on learning tasks with long-time dependencies. Given that the underlying ODE \eqref{eq:ode} models oscillators, one can envisage that UnICORNN will be very competitive with respect to processing different time series data that arise in healthcare AI such as EEG and EMG data, as well as seismic time series from the geosciences. 


\section*{Acknowledgements.} The research of TKR and SM was partially supported by European Research Council Consolidator grant ERCCoG 770880: COMANFLO.
\bibliographystyle{abbrvnat}
\bibliography{refs}

\appendix
\newpage
\begin{center}
{\bf Supplementary Material for:}\\
UnICORNN: A recurrent model for learning \textit{very} long time dependencies
\end{center}
\section{Training details}
All experiments were run on GPU, namely NVIDIA GeForce GTX 1080 Ti and NVIDIA GeForce RTX 2080 Ti. The hidden weights  of the UnICORNN are initialized according to  , while all biases are set to zero. The trained vector  is initialized according to . The input weights  are initialized according to the Kaiming uniform initialization \citep{kaiming} based on the input dimension mode and the negative slope of the rectifier set to .

The hyperparameters of the UnICORNN are selected using a random search algorithm based on a validation set. The hyperparameters of the best performing UnICORNN can be seen in \Tref{tab:nets}. The value for  and  is shared across all layers, except for the IMDB task and EigenWorms task, where we use a different  value for the first layer and the corresponding  value in \Tref{tab:nets} for all subsequent layers, i.e. we use  for IMDB and  for EigenWorms in the first layer. 
Additionally, the dropout column corresponds to variational dropout \citep{gal}, which is applied after each consecutive layer. Note that for the IMDB task also an embedding dropout with  is used.

We train the UnICORNN for a total of 50 epochs on the IMDB task and for a total of 250 epochs on the EigenWorms task. Moreover, we train UnICORNN for 650 epochs on psMNIST, after which we decrease the learning rate by a factor of 10 and proceed training for 3 times the amount of epochs used before reducing the learning rate. On all other tasks, UnICORNN is trained for 250 epochs, after which we decrease the learning rate by a factor of 10 and proceed training for additional 250 epochs.
The resulting best performing networks are selected \emph{based on a validation set}.

\begin{table}[h!]
  \caption{Hyperparameters of the best performing UnICORNN architecture (based on a validation set) for each experiment.}
  \label{tab:nets}
  \centering
  \begin{tabular}{llllll}
    \toprule
    \cmidrule(r){1-6}
    Experiment & learning rate & dropout & batch size &  &  \\
    \midrule
    noise padded CIFAR-10 &  &  &  &  & \\
    psMNIST (\#units = 128) &  &  & &  & \\
    psMNIST (\#units = 256) &  &  &  &  &  \\
    IMDB &  &  &  &  & \\
    EigenWorms  &  &  &  &  &  \\
    Healthcare: RR  &  &  &  &  &  \\
    Healthcare: HR  &   &  &  &  &  \\
    

    \bottomrule
  \end{tabular}
\end{table}



\section{Implementation details}
As already described in the implementation details of the main paper, we can speed up the computation of the forward and backward pass, by parallelizing the input transformation and computing the recurrent part for each independent dimension in an independent CUDA thread. While the forward/backward pass for the input transformation is simply that of an affine transformation, we discuss only the recurrent part. Since we compute the gradients of each dimension of the UnICORNN independently and add them up afterwards to get the full gradient, we will simplify to the following one-dimensional system:


where  is the transformed input corresponding to the respective dimension .

Since we wish to train the UnICORNN on some given objective

where  is some loss function taking the hidden states  as inputs, for instance mean-square distance of (possibly transformed) hidden states  to some ground truth. During training, we compute gradients of the loss function \eqref{eq:td1} with respect to the following quantities , i.e.


We can work out a recursion formula to compute the gradients in \eqref{eq:td_grad1}. We will exemplarily provide the formula for the gradient with respect to the hidden weight . The computation of the gradients with respect to the other quantities follow similarly. 
Thus

with initial values  and .
The gradient can then be computed as

Note that this recursive formula is a direct formulation of the back-propagation through time algorithm \citep{bptt} for the UnICORNN. 

We can verify formula \eqref{eq:td_grad2}-\eqref{eq:td_grad3} by explicitly calculating the gradient in \eqref{eq:td_grad1}:


Iterating the same reformulation yields the desired formula \eqref{eq:td_grad2}-\eqref{eq:td_grad3}.
\section{Bounds on the ODE (2) of the main text.}
Rewriting the ODE (2) of the main text as,

together with the initial data .
\subsection{Energy bounds.}
We have the following energy bounds on the solutions of the ODE \eqref{eq:ode_SM},
\begin{proposition}
\label{prop:n1}
Let  be the solutions of the ODE system \eqref{eq:ode_SM} at any time  and the initial data for \eqref{eq:ode_SM} is given by,

Then for , the solutions of \eqref{eq:ode_SM} are bounded by,

and for , the solutions of \eqref{eq:ode_SM} are bounded by,

Here , denotes the Euclidean norm of the vector  and , the corresponding inner product.
\end{proposition}
\begin{proof}
To prove the bound \eqref{eq:nbd1}, we take an inner product of the first equation in \eqref{eq:ode_SM} with  and an inner product of the second equation in \eqref{eq:ode_SM} with  and add the result to obtain,

Applying the Gr\"onwall's inequality to the above differential inequality directly leads to,

as  and \eqref{eq:nbd1} follows as a direct consequence.

To proof \eqref{eq:nbd2}, we set  in \eqref{eq:ode_SM} and take an inner product of the first equation in \eqref{eq:ode_SM} with  and an inner product of the second equation in \eqref{eq:ode_SM} with  and add the result to obtain,

    The bound \eqref{eq:nbd2} follows as a direct consequence of the Gr\"onwall's inequality.
\end{proof}
\subsection{Hidden state gradients and Proof of proposition 3.1 of main text.}
We recall that the ODE (8) in the main text for the hidden state gradients with respect to any trainable parameter  is,

with the coefficient  given by,

Note that only the -th entry of  is non-zero and all the remaining entries are zero. It is clear from the bounds \eqref{eq:nbd1} and \eqref{eq:nbd2} that as long as we consider bounded inputs i.e., , for some constants  and for all time , the coefficient  is bounded in the following sense,

for some constant  that only depends on the dimension  and on the constant  that bounds the input.



We restate Proposition 3.1 of the main text that provides an upper bound on the hidden state gradients,
\begin{proposition}
\label{prop:n2_SM}
Let  be the solutions of the ODE system \eqref{eq:hsg_SM} for hidden state gradients, at any time . Then for  and for all , the hidden state gradients are bounded by,

with .

For , the hidden state gradients are bounded by,

with .
\end{proposition}
\begin{proof}
To prove the bound \eqref{eq:nbd3_SM}, we take an inner product of the first equation in \eqref{eq:hsg_SM} with  and an inner product of the second equation in \eqref{eq:ode_SM} with  and add the result to obtain,

Applying the Gr\"onwall's inequality to the above differential inequality directly leads to the bound,

This bound in turn, readily implies \eqref{eq:nbd3_SM}. The proof of the bound \eqref{eq:nbd4} is completely analogous. 
\end{proof}
\section{Rigorous bounds on UnICORNN}
We rewrite UnICORNN (Eqn. (6) in the main text) in the following form: for all  and for all 

Here, we have denoted the -th component of a vector  as .

We follow standard practice and set , for all . 
\subsection{Energy Bounds.}
We have the following bounds on the discrete hidden states, 
\begin{proposition}
\label{prop:31}
Let  be the hidden states at the -th time level  for UnICORNN \eqref{eq:ucrn_SM}, then under the assumption that the time step  and , these hidden states are bounded as,

with the constant 

If  and , the hidden states satisfy the bound,

\end{proposition}
\begin{proof}
We fix  and multiply the first equation in \eqref{eq:ucrn_SM} with  and use the elementary identity 

to obtain

Next, we multiply the second equation in \eqref{eq:ucrn_SM} with  and use the elementary identity 

to obtain

Adding \eqref{eq:pf31} and \eqref{eq:pf32} and using Cauchy's inequality yields,

where the last inequality follows from the fact that  and .
Using the elementary inequality,

and substituting for  from the second equation of \eqref{eq:ucrn_SM} in the last inequality leads to,

Denoting  and 

yields the following inequality,

Using the Taylor expansion for the exponential and the definition of , it is straightforward to check that,

Thus, we have from \eqref{eq:pf33} that,

Iterating \eqref{eq:pf34} -times and using the fact that the initial data is such that  we obtain,

as . The bound \eqref{eq:hsbd} follows directly from the definition of .


The proof of \eqref{eq:hsbd1} follows analogously. 
\end{proof}
\subsection{On the exploding gradient problem for UnICORNN and Proof of proposition 3.2 of the main text.}
We train the RNN \eqref{eq:ucrn_SM} to minimize the loss function,

with  being the underlying ground truth (training data). Note that the loss function \eqref{eq:lf1_SM} only involves the output at the last hidden layer (we set the affine output layer to identity for the sake of simplicity). During training, we compute gradients of the loss function \eqref{eq:lf1_SM} with respect to the trainable weights and biases , for all  i.e.
 
We have the following bound on the gradient \eqref{eq:grad1_SM},
\begin{proposition}
\label{prop:3_SM}
Let  in the RNN \eqref{eq:ucrn_SM} and let , for , be the hidden states generated by the RNN \eqref{eq:ucrn_SM}. Then, the gradient of the loss function  \eqref{eq:lf1_SM} with respect to any parameter  is bounded as,

with , be a bound on the underlying training data and other quantities in \eqref{eq:gbd_SM} defined as,

\end{proposition}
\begin{proof}
For any  and , let  be the augmented hidden state vector defined by,

For any , we can apply the chain rule repeatedly to obtain the following extension of the formula of \cite{vanish_grad} to a deep RNN,

Here, the notation  refers to taking the partial derivative of  with respect to the parameter , while keeping the other arguments constant. 

We remark that the quantity  denotes the contribution from the -recurrent step at the -th hidden layer of the deep RNN \eqref{eq:ucrn_SM} to the overall hidden state gradient at the step . 

It is straightforward to calculate that,


Repeated application of the chain and product rules yields,

For any , a straightforward calculation using the form of the RNN \eqref{eq:ucrn_SM} leads to the following representation formula for the matrix :

with the block matrices  given by,

Similarly for any , the matrix   can be readily computed as,

with entries given by,

A direct calculation with \eqref{eq:mat2} leads to,

Using the definition of the  norm of a matrix, we use \eqref{eq:mat4} to the derive the following bound from \eqref{eq:mat1},

with 
 defined in \eqref{eq:gbddef_SM}.

As , it is easy to see that,

Combining \eqref{eq:mat5} and \eqref{eq:mat6} , we obtain from \eqref{eq:grad3}

where the last inequality follows from the fact that  and the definition of  in \eqref{eq:gbddef_SM}.

Next, we observe that for any 

For any , a direct calculation with the RNN \eqref{eq:ucrn_SM} yields,

Next, we have to compute explicitly  and  in order to complete the expressions \eqref{eq:p2}. To this end, we need to consider explicit forms of the parameter  and obtain, 

If , for some  and , then,


If , for some  and , then,


If , for some  and , then,

If for any  and , then,


Similarly, if  or , for some  and , or If , for some  and , then

On the other hand, if for any  and , then

For any , by substituting \eqref{eq:p3} to \eqref{eq:p8} into \eqref{eq:p2} and doing some simple algebra with norms, leads to the following inequalities,

and,

for any .

By the definition of  of a vector and some straightforward calculations with \eqref{eq:p10} yields,

From the energy bounds \eqref{eq:hsbd}, we can directly bound the above inequality further as,


By \eqref{eq:1gd} and the definition of  as well as the bound \eqref{eq:hsbd} on the hidden states, it is straightforward to obtain that,

From the definition in \eqref{eq:grad2_SM} and the identity \eqref{eq:grad2_SM}, we have

Substituting \eqref{eq:pe1}, \eqref{eq:p12} and \eqref{eq:mat5} into \eqref{eq:pe2} yields,

with  and  defined in \eqref{eq:gbddef_SM}.

Therefore, from the fact that  and \eqref{eq:grad2_SM}, we obtain

By the definition of the loss function \eqref{eq:lf1_SM} and the fact that the right-hand-side of \eqref{eq:pe5} is independent of  leads to the desired bound \eqref{eq:gbd_SM}. 







\end{proof}
\subsection{On the Vanishing gradient problem for UnICORNN and Proof of Proposition 3.3 of the main text.}
By applying the chain rule repeatedly to the each term on the right-hand-side of \eqref{eq:grad1_SM}, we obtain 

Here, the notation  refers to taking the partial derivative of  with respect to the parameter , while keeping the other arguments constant.  The quantity  denotes the contribution from the -recurrent step at the -th hidden layer of the deep RNN \eqref{eq:ucrn_SM} to the overall hidden state gradient at the step . The vanishing gradient problem \citep{vanish_grad} arises if , defined in \eqref{eq:grad2_SM_vanish},  exponentially fast in , for  (long-term dependencies). In that case, the RNN does not have long-term memory, as the contribution of the -th hidden state at the -th layer to error at time step  is infinitesimally small. 

As argued in the main text, the vanishing gradient problem for RNNs focuses on the possible smallness of contributions of the gradient over a large number of recurrent steps. As this behavior of the gradient is independent of the number of layers, we start with a result on the vanishing gradient problem for a single hidden layer here. Also, for the sake of definiteness, we set the scalar parameter  for some . Similar results also hold for any other . Moreover, we introduce the following \emph{order}-notation,



We restate Proposition 3.3 of the main text,
\begin{proposition}
\label{prop:4_SM}
Let  be the hidden states generated by the RNN \eqref{eq:ucrn_SM}. Then the gradient for long-term dependencies, i.e. , satisfies the representation formula,

\end{proposition}
\begin{proof}
Following the definition \eqref{eq:grad2_SM_vanish} and as  and , we have,

We will explicitly compute all three expressions on the right-hand-side of \eqref{eq:1l_p41}. To start with, using \eqref{eq:p1}, \eqref{eq:p2} and \eqref{eq:p3}, we obtain,

Using the product rule \eqref{eq:grad3} we have,

Observing from the expressions \eqref{eq:mat1} and \eqref{eq:mat2} and using the \emph{order}-notation \eqref{eq:ord}, we obtain that,

with  is the  Identity matrix and the matrix  defined by,

with the block matrices  given by,

By a straightforward calculation and the use of induction, we claim that 

with 

with the block matrices  given by,

By the assumption that  and using the fact that , we have that,

Hence, the non-zero entries in the block matrices can be . Therefore, the product formula \eqref{eq:p47} is modified to,

    with the  matrix  defined as,
    
and,

Thus by taking the product of \eqref{eq:p51} with \eqref{eq:p42}, we obtain that,

with  are the off-diagonal entries of the corresponding block matrix, defined in \eqref{eq:p53}. Note that the  remainder term arises from the -dependence in \eqref{eq:p42}.  

From \eqref{eq:1gd}, we have that,

 Therefore, taking the products of \eqref{eq:p61} and \eqref{eq:p54} and substituting the explicit expressions in \eqref{eq:p42}, we obtain the desired identity \eqref{eq:glb_SM}. 
 \end{proof}
 \subsection{On the vanishing gradient problem for the multilayer version of UnICORNN.}
 The explicit representation formula \eqref{eq:glb_SM} holds for 1 hidden layer in \eqref{eq:ucrn_SM}. What happens when additional hidden layers are stacked together as in UnICORNN \eqref{eq:ucrn_SM}? To answer this question, we consider the concrete case of  layers as this is the largest number of layers that we have used in the context of UnICORNN with fully connected stacked layers. As before, we set the scalar parameter  for some . Similar results also hold for any other . We have the following representation formula for the gradient in this case,
 \begin{proposition}
\label{prop:5}
Let  be the hidden states generated by the RNN \eqref{eq:ucrn_SM}.  the gradient for long-term dependencies satisfies the representation formula,

 with the coefficients given by,
 
\end{proposition}
\begin{proof}
Following the definition \eqref{eq:grad2_SM_vanish} and as  and , we have,

We will explicitly compute all three expressions on the right-hand-side of \eqref{eq:p41}.

In \eqref{eq:p42}, we have already explicitly computed the right most expression in the RHS of \eqref{eq:p41}. 
Using the product rule \eqref{eq:grad3} we have,

Note that we have already obtained an explicit representation formula for  in \eqref{eq:p51}. 

Next we consider the matrices  and . By the representation formula \eqref{eq:mat3}, we have the following decomposition for any ,

with,

and

It is straightforward to see from \eqref{eq:p57} and \eqref{eq:p56} that,

and the entries of the  matrix  are given by,

while the entries of the  matrix  are given by


Hence we have,

Taking the matrix-vector product of \eqref{eq:p59} with \eqref{eq:p54}, we obtain

where the last identify follows from the fact that .

 Therefore, taking the products of \eqref{eq:p61} and \eqref{eq:p600}, we obtain the desired identity \eqref{eq:glb1}. 
 




\end{proof}
An inspection of the representation formula \eqref{eq:glb1} shows that as long as the weights are  and from the energy bounds \eqref{eq:nbd3_SM}, we know that , the gradient 
where the additional  stems from the -term in \eqref{eq:p42}. Thus the gradient does not depend on the recurrent step . Hence, there is no vanishing gradient problem with respect to the number of recurrent connections, even in the multi-layer case. 

However, it is clear from the representation formulas \eqref{eq:glb_SM} and \eqref{eq:glb1}, as well as the proof of proposition \ref{prop:5} that for -hidden layers in UnICORNN \eqref{eq:ucrn_SM}, we have,

Thus, the gradient can become very small if too many layers are stacked together. This is not at all surprising as such a behavior occurs even if there are no recurrent connections in UnICORNN \eqref{eq:ucrn_SM}. In that case, we simply have a fully connected deep neural network and it is well-known that the gradient can vanish as the number of layers increases, making it harder to train deep networks. 
\subsection{Residual stacking of layers in UnICORNN.}
\label{resnet_grad}
Given the above considerations, it makes imminent sense to modify the fully-connected stacking of layers in UnICORNN \eqref{eq:ucrn_SM} if a moderately large number of layers () are used. It is natural to modify the fully-connected stacking with a residual stacking, see \cite{deep_indrnn}. We use the following form of residual stacking,

where the input  corresponds to a residual connection skipping  layers, i.e.

The number of skipped layers is  and  is a trainable matrix. 

The main advantages of using a residual staking such as \eqref{eq:ucrn_res} is to alleviate the vanishing gradient problem that arises from stacking multiple layers together and obtain a better scaling of the gradient than \eqref{eq:scl}. To see this, we can readily follow the proof of proposition \ref{prop:5}, in particular the product,

with,

Here  is the largest natural number less than or equal to .

Given the additive structure in the product of gradients and using induction over matrix products as in \eqref{eq:p70} and \eqref{eq:p58}, we can compute that,

    
By choosing  large enough, we clearly obtain that . Hence by repeating the arguments of the proof of proposition \ref{prop:5}, we obtain that to leading order, the gradient of the residual stacked version of UnICORNN scales like,

Note that \eqref{eq:scl_res} is far more favorable scaling for the gradient than the scaling \eqref{eq:scl} for a fully connected stacking. As a concrete example, let us consider  i.e., a network of  stacked layers of UniCORNN. From \eqref{eq:scl}, we see that the gradient scales like  in this case. Even for a very moderate values of , this gradient will be very small and will ensure that the first layer will have very little, if any, influence on the loss function gradients. On the other hand, for the same number of layers , let us consider the residual stacking \eqref{eq:ucrn_res} with  skipped connections. In this case  and one directly concludes from \eqref{eq:scl_res} that the gradient scales like , which is significantly larger than the gradient for the fully connected version of UnICORNN. In fact, it is exactly the same as the gradient scaling for fully connected UnICORNN \eqref{eq:ucrn_SM} with  hidden layers \eqref{eq:glb1}. Thus, introducing skipped connections enabled the gradient to behave like a shallower fully-connected network, while possibly showing the expressivity of a deeper network.  


\section{Further experimental results}
As we compare the results of the UnICORNN to the results of other recent RNN architecture, where only the best results of each RNN were published for the psMNIST, noise padded CIFAR-10 and IMDB task, we as well show the best (based on a validation set) obtained results for the UnICORNN in the main paper. However, distributional results, i.e. statistics of several re-trainings of the best performing UnICORNN based on different random initialization of the trainable parameters, provide additional insights into the performance. \Tref{tab:distr_results} shows the mean and standard deviation of 10 re-trainings of the best performing UnICORNN for the psMNIST, noise padded CIFAR-10 and IMDB task. We can see that in all experiments the standard deviation of the re-trainings are relatively low, which underlines the robustness of our presented results. 

\begin{table}[h!]
  \caption{Distributional information (mean and standard deviation) on the results for the classification experiment presented in the paper, where only the best results is shown, based on 10 re-trainings of the best performing UnICORNN using different random seeds.}
  \label{tab:distr_results}
  \centering
  \begin{tabular}{lllll}
    \toprule
    \cmidrule(r){1-3}
    Experiment & Mean & Standard deviation \\
        \midrule
    psMNIST (128 units) & 97.7\% &  0.09\%\\
    psMNIST (256 units) & 98.2\% & 0.22\% \\
    Noise padded CIFAR-10 & 61.5\% & 0.52\%\\
    IMDB & 88.1\% & 0.19\% \\
    \bottomrule
  \end{tabular}
\end{table}

As emphasized in the main paper and in the last section, naively stacking of many layers for the UnICORNN might result in a vanishing gradient for the deep multi-layer model, due to the vanishing gradient problem of stacking many (not necessarily recurrent) layers. Following section \ref{resnet_grad}, one can use skipped residual connections and we see that the estimate on the gradients scale preferably when using residual connections compared to a naively stacking, when using many layers. To test this also numerically, we train a standard UnICORNN \eqref{eq:ucrn_SM} as well as a residual UnICORNN (res-UnICORNN) \eqref{eq:ucrn_res}, with  skipping layers, on the noise padded CIFAR-10 task.  
\fref{fig:cifar} shows the test accuracy (mean and standard deviation) of the best resulting model for different number of network layers , for the standard UnICORNN and res-UnICORNN. We can see that while both models seem to perform comparably for using only few layers, i.e. , the res-UnICORNN with  skipping connections outperforms the standard UnICORNN when using more layers, i.e. . In particular, we can see that the standard UnICORNN is not able to significantly improve the test accuracy when using more layers, while the res-UnICORNN seems to obtain higher test accuracies when using more layers. 

Moreover, \fref{fig:cifar} also shows the test accuracy for a UnICORNN with an untrained time-step vector , resulting in a UnICORNN without the multi-scale property generated by the time-step. We can see that the UnICORNN without the multi-scale feature is inferior in performance, to the standard UnICORNN as well as its residual counterpart.   

\begin{figure}[ht!]
\centering
\begin{minipage}[t]{.48\textwidth}
\includegraphics[width=1.\textwidth]{figures/noisy_cifar.pdf}
\caption{Test accuracies (mean and standard deviation of 10 re-trainings of the best performing model) of the standard UnICORNN, res-UnICORNN and UnICORNN without multi-scale behavior on the noise padded CIFAR-10 experiment for different number of layers .}
\label{fig:cifar}
\end{minipage}\hspace{0.01\textwidth}
\begin{minipage}[t]{.48\textwidth}
\includegraphics[width=1.\textwidth]{figures/weights.pdf}
\caption{Norms (mean and standard deviation of 10 re-trainings) of the hidden weights , for , of the UnICORNN during training.}
\label{fig:weights}
\end{minipage}
\end{figure}

Finally, we recall that the estimate \eqref{eq:gbd_SM} on the gradients for UnICORNN \eqref{eq:ucrn_SM} needs the weights to be bounded, see \eqref{eq:gbddef_SM}. One always initializes the training with bounded weights. However, it might happen that the weights explode during training. To check this issue, in  \fref{fig:weights}, we plot the mean and standard deviation of the norms of the hidden weights  for  during training based on 10 re-trainings of the best performing UnICORNN on the noise padded CIFAR-10 experiment. We can see that none of the norms of the weights explode during training. In fact the weight norms seem to saturate, mostly on account of reducing the learning rate after 250 epochs. Thus, the upper bound \eqref{eq:gbd_SM} can be explicitly computed and it is finite, even after training has concluded. 

\end{document}