

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts














\usepackage{cite}



\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
\usepackage[dvips]{graphicx}
\DeclareGraphicsExtensions{.eps}
\fi



\usepackage[cmex10]{amsmath}
\interdisplaylinepenalty=2500



\usepackage{array}









\usepackage{fixltx2e}








\usepackage{url}






\hyphenation{op-tical net-works semi-conduc-tor}

\def\E{{\cal{E}}}
\def\para#1{{\bf{#1}}}

\begin{document}
\title{A First Practical Fully Homomorphic Crypto-Processor Design\-1ex]
          (cached)& ( 0.9\%)   &          \\
 store     instructions  & 0.9\%      &  0.0\%   \-1ex]
          (stalls)& (22.1\%)   &  ( 3.8\%)\-1ex]
         (refills)& ( 2.7\%)   &  ( 1.1\%)\\
\hline
           total  &54.8\%      & 45.2\%   \\
\hline
\end{tabular}

\medskip
\begin{tabular}{|r|r||r|r|}
\hline
\multicolumn{4}{|c|}{Branch Prediction Buffer}       \\
\hline
      hits   &10328     ( 55\%)& misses   &8219  ( 44\%) \\
\hline
      right  &8335      ( 44\%)& right    &6495  ( 35\%) \\
      wrong  &1993      ( 10\%)& wrong    &1724  ( ~9\%) \\
\hline
\hline
\multicolumn{4}{|c|}{User Data Cache}    \\
\hline
read  hits &2942 (99\%)& misses &0 (~0\%)   \\
write hits &2933 (99\%)& misses &9 (~0\%)   \\
\hline
\end{tabular}
\end{table}

Table~\ref{t:1} displays the performance statistics summary from the 
modified instruction set add test (`is-add-test') of the or1ksim
testsuite.  The statically compiled executable contains 185628 machine
code instructions, which occupy 742512 bytes in the 769454 byte
executable, the rest being comprised of the executable file headers,
symbol table, etc.  Table~\ref{t:1} shows that when this test was run
(successfully) to completion, 222006 instructions were executed, so
there are few loops and subroutines (the code is largely built using
assembler macros) in 315640 cycles.  If one reckons with a 1GHz clock,
then the speed was just over 700Kips (instructions per second) overall.

In supervisor mode, pipeline occupation is just under 90\%, at 892Kips
for a 1GHz clock (wait states, cycles in which the pipeline fails to
complete an instruction, comprise 4.9\% of the 45.2\% total), which one
may take as a baseline for a single pipeline superscalar design.  In
user mode pipeline occupation is only 54.9\%, as measured by numbers of
non-wait states, for 549Kips with a 1GHz clock.  Measured against
supervisor mode, that is 61.6\% of the unencrypted speed.

The wait states are caused by real data hazards in the pipeline.  Most
(84\%) are due to a load instruction feeding directly to an arithmetic
instruction.  The stall occurs because the data address for the load
instruction is only calculated in execute stage, so the data cannot
at that time already be available to the instruction sitting in read
stage just behind.

The data indicates that a dual pipeline might be beneficial, perhaps
enabling speed over 70\% of unencrypted running.





















\section{Conclusion}
A superscalar pipeline design for an encrypted processor has been
described here, with performance measured at 60-70\% of unencrypted
processing while embedding a 10-cycle (Rijndael) 64-bit encryption.
Registers, memory and busses contain encrypted data in this
`pseudo-homomorphic' design.

















\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,icics2016}





\end{document}
