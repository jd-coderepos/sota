\documentclass[final]{siamltex}

\usepackage{epsfig, amsmath, amssymb}\newcommand{\mtp}{minimum -sum problem}
\newcommand{\keyw}[1]{{\bf #1}}
\newcommand{\GETS}{\leftarrow}

\title{A fast multigrid algorithm for energy minimization under planar
density constraints}

\author{Dorit Ron \thanks{The Weizmann Institute of Science, dorit.ron@weizmann.ac.il} \and Ilya Safro
\thanks{Argonne National Laboratory, safro@mcs.anl.gov} \and  Achi Brandt
\thanks{The Weizmann Institute of Science} }

\begin{document}

\maketitle
\begin{abstract}
The two-dimensional layout optimization problem reinforced by the
efficient space utilization demand has a wide spectrum of
practical applications. Formulating the problem as a nonlinear
minimization problem under planar equality and/or inequality
density constraints, we present a linear time multigrid algorithm
for solving correction to this problem. The method is demonstrated
on various graph drawing (visualization) instances.



\end{abstract}
\begin{keywords}
Multigrid methods; Optimization, Inequality constraints, Models,
numerical methods; Layout problems
\end{keywords}

\begin{AMS}
65M55, 80M50, 65C20
\end{AMS}

\pagestyle{myheadings}
\thispagestyle{plain}
\markboth{D. Ron AND I. Safro AND A. Brandt}{A multigrid approach for constrained optimization}

\bibliographystyle{plain}





\newcommand{\solution}{\par\noindent{\bf Solution:}\quad}
\newcommand{\minla}{Minimum Linear Arrangement problem }



\newcommand{\genr}{\mathfrak{E}}
\newcommand{\geqd}{\mathfrak{eqd}}


\newcommand{\eqd}{\mathfrak{eqd}}
\newcommand{\gr}{\mathcal{G}}
\newcommand{\nar}{\mathfrak{a}}
\newcommand{\wnd}{\mathcal{W}}
\newcommand{\pgr}{\mathcal{P}(\mathcal{G})}
\newcommand{\sgr}{\mathcal{S}(\mathcal{G})}
\newcommand{\bgr}{\mathcal{B}(\mathcal{G})}
\newcommand{\bwn}{\overline{\mathcal{B}}(\mathcal{W})}
\newcommand{\bpwn}{\mathcal{B}(\mathcal{W})}
\newcommand{\bugr}{\mathcal{B}_u(\mathcal{G})}
\newcommand{\bvgr}{\mathcal{B}_v(\mathcal{G})}
\newcommand{\ar}{\mathcal{A}}
\newcommand{\ineigh}{\mathcal{P}_i}
\newcommand{\jneigh}{\mathcal{P}_j}
\newcommand{\sar}{\Upsilon}
\newcommand{\mar}{\upsilon}
\newcommand{\mdl}[1]{\text{(mod }#1\text{)}}\newcommand{\Lag}{\mathfrak{L}}
\newcommand{\bu}{{\bf u}}
\newcommand{\bU}{{\bf U}}
\newcommand{\bpgr}{\bold{\mathcal{P}}_{\bu}}
\newcommand{\bpgrw}{\bold{\mathcal{P}}_{\bu_{\wnd}}}
\newcommand{\bpw}{\bold{\mathcal{P}}_{\wnd}}





\section{Introduction}\label{sIntro}
\par The optimization problem addressed
in this paper is to find an optimal layout of a set of
two-dimensional objects such that (a) the total length of the
given connections between these objects will be minimal, (b) the
overlapping between objects will be as little as possible, and, (c)
the two-dimensional space will be well used. This class of
problems can be modelled by a graph in which every vertex has a
predefined shape and area and each edge has a predefined weight.
While the first two conditions are straightforward, the third
requirement can be made concrete in different ways. To see its usefulness, consider for example, the problem of
drawing the "snake"-like graph shown in Figure \ref{snake}(a).
Most graph drawing algorithms would draw it as a line or a chord.
In that case, when the number of nodes is big, the space is
used very inefficiently, and the size of the nodes must
decrease.
One possible
efficient space utilization for the graph "snake" is presented in
Figure \ref{snake}(b).\begin{figure}[h]\label{snake}
\vbox{\center\includegraphics[width=10cm]{snake.pdf}}
\caption{Possible ways to draw the "snake"-like graph: (a) when
the drawing area is not used, the size of the nodes must
decrease; and (b) a clearer picture is obtained when the space is
used efficiently. }
\end{figure}
\par In many theoretical and industrial fields, this class of problems
is often addressed and actually poses a computational bottleneck.
In this work we present a multilevel solver for a model that
describes the core part of those applications, namely, the problem
of minimizing a quadratic energy functional under planar
constraints that bound the allowed amount of material (total
areas of objects) in various subdomains of the entire domain under
consideration.
\par Given an initial arrangement, the main contribution of this
work is to enable a {\it fast} rearrangement of the entities under
consideration into a more evenly distributed state over the entire
defined domain. This process is done by introducing a sequence of
finer and finer grids over the domain and demanding at each scale
{\it equidensity}, that is, meeting equality or inequality
constraints at each grid square, stating how much material it may
(at most) contain. Since many variables are involved and since the
needed updates may be large, we introduce a new set of {\it
displacement} variables attached to the introduced grid points,
which enables {\it collective} moves of many original variables at
a time, at different scales including large displacements. The use
of such multiscale moves has two main purposes: to enable processing in various scales and to {\it efficiently} solve the (large) system of equations of energy
minimization under equidensity demands. The system of equations of
the finer scales, when many unknowns are involved, is solved by a
combination of well-known multigrid techniques (see
\cite{Brandt:1977:MLAa,vlsicad,mgbooktrott}), namely, the {\it
Correction Scheme} for the energy minimization part and the {\it
Full Approximation Scheme} for the inequality equidensity
constraints defined over the grid's squares. We assume here that
the minimization energy functional has a quadratic form, but other
functionals can be used via quadratization. The entire algorithm
solves the nonlinear minimization problem by applying successive
steps of corrections, each using a linearized system of
equations.

\par Clearly, for each specific
application, one has to tune the general algorithm to respect the
particular task at hand.
We have chosen here to demonstrate the performance of our solver
on some instances of the graph visualization problem showing the
efficient use of the given domain. Let us review a few
applications that have motivated our research.
\par {\bf Graph visualization} addresses the problem of constructing a geometric representation of graphs
and has important applications to many technologies. There are
many different demands for graph visualization problems, such as
draw a graph with a minimum number of edge crossings, or a minimum
total edge length, or a predefined angular resolution (for a
complete survey, see \cite{gd-book}). The ability to achieve a
compact picture (without overlapping) is of great importance,
since area-efficient drawings are essential in practical
visualization applications where screen space is one of the most
valuable commodities. One of the most popular strategies that does
address these questions is the force directed method
\cite{eades1984} which has a quadratic running time if all
pairwise vertex forces are taken into account. There are several
successful multilevel algorithms \cite{DBLP:conf/gd/2000}
developed to improve the method's complexity. However, reducing
the running time in these models usually means a loss of
information regarding those forces.
\par {\bf Representation of higraphs}. Higraphs, a combination and extension of graphs and Euler/Venn diagrams,
were defined by Harel in \cite{harel88}. Higraphs extend the basic
structure of graphs and hypergraphs to allow vertices to describe
inclusion relationships. Adjacency of such vertices is used to
denote set-theoretic Cartesian products. Higraphs have been shown
to be useful for the expression of many different semantics and
underlie many visual languages, such as statecharts and object
model diagrams. The well-known force-directed method has been
extended to enable handling the visualization of higraphs
\cite{harelinger}. For small higraphs it has indeed yielded
nice results; but because of its high complexity, it poses efficiency
challenges when used for larger higraphs.
\par {\bf Facility location problem}. In this class of problems the goal is to locate a number
of facilities within a minimized distance from the clients. In many industrial versions of the problem
there exist additional demands such as the minimization of the routing between the facilities and various
space constraints (e.g., the factory planning problem) while given a total area on which the facilities and
clients could be located (for a complete survey, see \cite{dreznerfacility}).
\par {\bf Wireless networks and coverage problems} have a broad range of applications in the military,
surveillance, environment monitoring, and healthcare fields. In
these problems, having a limited number of resources (like antenna
or sensor), one has to cover the area on which many demand points
are distributed and have to be serviced. In many practical
applications there are predefined connections between these
resources that can be modeled as a graph
\cite{meguerdichian01coverage, cardei-energyefficient,
citeulike:717044}.
\par {\bf The placement problem}. The electronics industry has achieved a phenomenal growth over the past
two decades, mainly due to the rapid advances in integration technologies and large-scale systems design - in short,
due to the advent of VLSI. The number of applications of integrated circuits in high-performance computing,
telecommunications, and consumer electronics has been rising steadily, and at a very fast pace. Typically,
the required computational power of these applications is the driving force for the fast development of this field.
The global placement is one of the most challenging problems during VLSI layout synthesis. In this application
the modules must be placed in such a way that the chip can be processed at the detailed placement stage and
then routed efficiently under many different constraints. This should be accomplished in a reasonable computation
time even for circuits with millions of modules since it is one of the bottlenecks of the design process.
For a most recent survey of the placement techniques see \cite{vlsi2007book}.
\par The paper is organized as follows. The problem definition is described in Section \ref{prob-def}.
The multilevel formulation and solver are presented in Section
\ref{ml-formulation}. Examples of graph drawing layout corrections
are demonstrated in Section \ref{sExamples}.

\section{Problem definition}\label{prob-def}
\par Given a weighted undirected graph , let  be the (rectangular)
area of vertex (node) , ,
and  the non-negative weight of the edge  between
nodes  and  ( if ). Also, assume a twodimensional {\it initial} layout is given; that is, the center of
mass of node  is considered to be located at  within a given rectangular domain. The purpose of
the optimization problem we consider is to modify the initial
assignment  by 
so as to minimize the quadratic functional

subject to some {\it equidensity} demands on the area distribution
of the nodes within the given rectangle. To apply such
constraints, we discretize the domain by a standard grid 
consisting of a set of squares , where each square  is of area  and  and  are the mesh
sizes of  in the  and  directions, respectively (see
Figure \ref{chipgrid}). Denote by  the total area of the
vertices overlapping with the square ; that is,  is
the sum over all the nodes coinsiding with , each contributing
the (possibly partial) area that overlaps with  (see Figure
\ref{partarea2}).
\begin{figure}[h]
\vbox{\center\includegraphics[width=6.5cm]{chip.pdf}}
\caption{Example of a grid  with  grid points and 
squares.
The grid points and squares are labeled by  and bold numbers,
respectively.}\label{chipgrid}
\end{figure}
\begin{figure}[h]
\vbox{\center\includegraphics[width=5cm]{partialarea2.pdf}}
\caption{Example of  for square 6. The total area of vertices
overlapping with square 6 is dashed.} \label{partarea2}
\end{figure}

\par The {\it planar} constraints (i.e., the constraints that are distributed over the 2D plane,
where each constraint defines a demand regarding some bounded
area) can then simply state how much area is required to be in
every square; that is, for each square  the constraint
is either , or , where  is
the amount of nodes area desired or allowed for square .
\par The constrained optimization problem with equality or inequality formulation can thus be summarized by the
following


\section{The multilevel formulation and solver}\label{ml-formulation}
\par The aim of the current work is to provide a {\it fast} first-order
correction to the given approximate solution; that is, we are
looking for such a displacement that would in some optimal sense
(to be defined below) improve the planar equidensity demands
and/or decrease . (Note that unconstrained
minimization of  will bring all nodes to overlap at
a single point, and thus we may often observe an {\it increase} in
 upon removing some of the initial overlap.)
\par To enable a direct use of the multigrid paradigm, and motivated by the
need to perform {\it collective} moves of nodes (as explained in
the introduction), we have actually reformulated the problem
(\ref{first-probform}) as described in Section \ref{sProbRef}. The
multilevel solver of the (reformulated) system
(\ref{full-ineq-problem}) below is introduced in Section
\ref{sMultSolver2}. This system of equations actually has to be
solved for a {\it sequence} of different grid sizes to enhance the
overall equidensity for a variety of scales as presented in
Section \ref{sExternalCycle}.

\subsection{Formulation of the correction problem}\label{sProbRef}
\par We have first introduced two new sets of variables  and  that correspond to {\it displacements}
 in the horizontal
 and vertical directions, respectively. These variables are located at the {\it grid points} 
which are sequentially counted from  to  as shown in Figure \ref{chipgrid}.
 Each point  is associated with two variables  and  that influence the
 displacements
 of all the nodes located in the (up to four) squares intersecting at .
 For example, the horizontal update of (the center of mass of) node ,
 depicted in Figure \ref{chipgrid}, is obtained
 from points  and :

where  and , are
the standard bilinear interpolation coefficients (their sum equals
1). The vertical coordinate  is updated from the 
variables using the {\it same} coefficients.
\par For a node  denote the
set of four closest points in  (the corners of the square
its center of mass is located at) by .
The new quadratic energy functional we
would like to minimize for  and  given a current layout
 of  (i.e., the coordinates of node 
are initialized with  is

where  are the bilinear interpolation
coefficients.
\par The reformulation of the equidensity constraint in
terms of the displacement variables relies on the rule of
conservation of areas. The initial total amount of vertex areas at
each square equals the current actual amount of areas dictated by
. To estimate the amount of areas flowing
inside and outside a given square induced by the  and 
displacements, we assume the nodes are evenly distributed inside
the squares. Under this assumption it is easier to estimate the
amount of area being transferred between two adjacent squares as
explained below. Consider, for example, a square . Denote by
 the total area of nodes overlapping with its
{\it right (left, top, bottom) neighbor} square. Let
 be the  values at the {\it right-top
(right-bottom, left-top, left-bottom)} corner of  as shown in
Figure \ref{circul-fig}. To estimate the amount of areas entering
 from the right we first calculate the average area (per
squared unit) in {\it both} squares: .
We have to multiply this by the actual entering area (of nodes),
which is a rectangle of height , the length of the border
between the two squares, and width, which is the average of the 
displacement at the middle of that border, namely,
. Thus the overall contribution of area from
the right is approximated by

A similar term is calculated at the left, and with  instead of
 also at the top and bottom. Note that if the assumed direction
of flow is wrong the resulting displacement will just turn out to
be negative.
\par The entire constraint for a square  stating that the net flow of areas into the square
 should be equal to or be smaller than some demand  minus the current area in , is given below:

Next, to enforce the natural boundary conditions on  and ,
namely, to forbid flows across the external boundaries, we simply
nullify all corresponding  on the right and left boundary
points , and  on the bottom and top boundary points
.
Then the entire constrained optimization problem in terms of 
and  and the initial approximation  is
given by

We will simplify the formulation of (\ref{full2var-problem}) by
the concatenation of the two vectors  and  into one
. We
will also omit the boundary conditions by directly replacing all
variables in  by , and so, from
now on, we will refer to  as

where  run over all the indices in ,  is a constant and ,
 are the coefficients calculated directly from the previous
definition (\ref{min-func}) of . Similarly rewrite
each  in (\ref{ed-constraint}) as

where .
\par Denote by ,  the Lagrange multiplier corresponding to the equidensity constraint
of square .
If all the constraints are equality ones, the
Lagrangian minimization functional is

So, we are looking for a critical point of the Lagrangian function, which is expressed by the system of linear
equations

There are at least two factors that may cause (\ref{lag-matrix})
to be singular. First, the rank of  is
always less than its size by at least 1. This arises from the
equations of equidensity constraints in (\ref{lag-matrix}): their
sum always equals zero. The reason is that under the
boundary constraints the total amount of in-flows is always equal
to the total amount of out-flows.
\begin{figure}[h]
\vbox{\center\includegraphics[width=6.5cm]{circulation2.pdf}}
\caption{The horizontal direction flows of area considered for the
square  (colored by gray) in the equidensity constraint
(\ref{ed-constraint}).}\label{circul-fig}
\end{figure}
In fact, the second summand in (\ref{lagmin})
can be replaced by

for any  without changing the minimization of  since

Thus, important are not the values of  but only their
{\it differences}, and the singularity can be treated by an
additional constraint, say, , where  (the introduction of  is necessary for
the recursion of the multilevel solver; see Section
\ref{sCoarsening-scheme}). The additional term in
 is , where 
is a ``pseudo-Lagrange'' multiplier. The following proposition
(with ) motivates the non-singularity of  with .
\begin{proposition}
Given a symmetric  matrix , for which , let  be an orthgonal basis of the null space of
, that is, . Then the following block matrix  is
nonsingular

where  is an  matrix of rank .
\end{proposition}
\vspace{3mm}
\begin{proof}
Let  be any vector in . Denote by  the
first  components of  and by  the last  components,
that is, . We will prove that if
, then . The vector  can be written in the following
block form:

Multiplying  by  from the left implies that
, and hence  and .
Substituting the last relation into each of the last  rows of
 implies  and thus  for 
yielding . Since  and  we may conclude that
 as needed.
\end{proof}



\par The second kind of singularity in (\ref{lag-matrix}) may appear from possible empty squares. This
can be treated by adding a summand to (\ref{lagmin}) that
minimizes the total sum of all corrections , that is,  adds a -term to the diagonal of
, where  is small enough to cause only
negligible change in a solution. This will prevent the inclusion
of zero-rows in , while possibly also bounding the
size of each correction in the solver below.
\par To summarize, the pseudo-Lagrangian functional  for our correction problem with equality
constraint is

leading to the following system of equations

\par Since in real world situations the total area is usually {\it bigger}
than the total area of all the vertices, the redefined
minimization problem
under {\it inequality} constraints will generally have the form

\subsection{Multilevel solver for problem (\ref{full-ineq-problem})}\label{sMultSolver2}
\par To solve the constrained minimization problem (\ref{full-ineq-problem}), we use
multigrid techniques: standard geometric coarsening, linear
interpolation, Correction Scheme for the energy minimization and
the Full Approximation Scheme for the equidensity inequality
constraints; all are presented in Section
\ref{sCoarsening-scheme}. In addition, we have developed a fast
window minimization relaxation as explained in Section
\ref{sRelax}. The multilevel cycle is schematically summarized in
Section \ref{sMultilevel-cycle} in Algorithm {\bf
2D-layout-correction}.

\subsubsection{Coarsening scheme}\label{sCoarsening-scheme}
When the geometry of the problem is known we can choose a coarser
grid by the usual elimination of every other line, as shown in
Figure \ref{geomgridcors}. The correction computed at the coarse
grid points will be interpolated and added to the fine grid
current approximation. Let us introduce the notation
distinguishing between fine and coarse level variables and
functions. By lowercase and uppercase letters we will refer to the
variables, indexes, and coefficients of the fine (, ,
, etc.) and the coarse (, , , etc.) levels,
respectively. The subscripts  and  will be used to describe
the energy  and  and
pseudo-Lagrangian  and  functions at the fine
and the coarse levels, respectively.
\begin{figure}
\vbox{\center\includegraphics[width=10cm]{geomgridconstr.pdf}}
\caption{Geometric coarsening. The equidensity constraints of
every four similarly patterned squares at the fine level form one
equidensity constraint at the coarse level.}\label{geomgridcors}
\end{figure}
\par Thus, the minimization part of the pseudo-Lagrangian (\ref{pseudo-Lag})
at the fine level is

(Note that we have omitted the  term from the following
derivation since it is merely an artificial added term.) Given a
current approximation  of the fine level solution
 and a correction function  calculated at the coarse
level variables ,  will be corrected by

where the notation  means that the sum is running
over all coarse gridpoints  from which standard bilinear
interpolation is made to the fine gridpoint .
\par Expressing the fine level energy
functional  in terms of the coarse variables by substituting
(\ref{equU}) into (\ref{eqEf}) yields

where ,
 and  is a constant. Thus, the coarse level energy
functional will be of the same structure as the fine level one,
namely,

\par For each fine square  the equidensity constraint  is
given by (\ref{eqd-with-a-and-b}).
The coarse equidensity constraints are constructed by merging
 fine squares into one coarse square .
The expression "" will refer to running over the four fine
squares  that form the coarse square  (see Figure
\ref{geomgridcors}). The -th planar equidensity constraint  of
the coarse level (in the case of equality constraints only) is
obtained again by the substitution of (\ref{equU}):

where  and
. Similarly (in
the case of equality constraints), the additional
-constraint over all squares at the coarse level as
inherited from the fine level is , where
.
\par To complete the description of the coarse equations, we still need to transfer the equidensity {\it
inequality}
constraints.
For this purpose we will use the Full Approximation Scheme (FAS),
which is the general multigrid strategy applied to nonlinear
problems (see \cite{Brandt:1977:MLAa,vlsicad,mgbooktrott}). In
fact, there is no need for the FAS for the equality equidensity
constraints since it is a linear problem that can be solved by the
regular Correction Scheme (CS). The FAS-like coarsening rules are
needed and applied only on the set of equations derived from the
equidensity inequalities. Thus, our scheme is a combination of the
correction scheme for the energy equations derived from
(\ref{eqEf}) and (\ref{equU}) and FAS-like rules for the
equidensity equations.
\par To derive these equations we need to calculate the
{\it residuals} for both the fine and coarse grids. If  is
the pseudo-Lagrangian of the fine level system defined by

where  is given by (\ref{eqEf}), then the
-th residual of , where
 is the current value of the Lagrange
multiplier , is

Thus, the residual corresponding to the variable  of
 (where  is the coarse level system
of equations analogous to (\ref{eqLf})) is

where
 are as in (\ref{equU}); that is, the fine-to-coarse
transfer is the adjoint of our coarse-to-fine interpolation. The
residual of the -th equidensity constraint is

where  runs over all fine squares and  is the
current value of . Therefore, the coarse equidensity
residual of square  is

Finally the residual of the -constraint is


Denote by  the linear part of the -th equation in
the system 

From the FAS rule for the -th coarse equation stating that
 the current approximation of , we can
derive the -th  equation

where  is given by (\ref{RI}),  and
.
Similarly, the -th square coarse equation for the equality
(inequality) constraint is

where  is given by (\ref{RS}).
The last equation for the -constraint is

Note that equations (\ref{eqCoarseQL}) to (\ref{eqCoarseEta}) are
the coarse grid equations analog to the system
(\ref{full-ineq-problem-in-q-l-a-b}). (A  term may
be added to (\ref{eqCoarseQL}) for stability if needed.) The
correction received from the coarse level for the  variables
is given by (\ref{equU}) and for the Lagrange multipliers
 by

\subsubsection{Relaxation}\label{sRelax}
\par In our multigrid solver, as usual, the relaxation process is employed
as the smoother of the error of the approximation, before the
construction of the coarse level system and immediately
after interpolation from the coarse level. For this purpose we
have developed the {\it Window relaxation} procedure,
which extracts from the entire system small subproblems of
 squares and solves each separately, as explained
below. The running time of the entire relaxation process strongly
depends on the algorithm for solving one window. There exist many
 versions of well-known algorithms for the quadratic
minimization problem under linear inequality constraints (for a
survey see \cite{avriel}). However, since each window need be
solved only to a first approximation (because of the iterative nature
of the overall algorithm), in order to keep the running time low,
we have implemented a simple algorithm for approximately solving
each single window, as presented in {\bf SingleWindowSolver}.
\par Let
m\times m be a window of squares.
To solve the quadratic minimization problem in , we
fix at their current position all  {\it outside} , as
well as all those that are on the boundary of  and
represent movement {\it perpendicular} to the boundary.
The minimization is done under the set of equidensity constraints
for the squares .
The solution process for each single window is a simplified
version of the {\it active set method} and is iterative. At
each iteration , for a given  we first extract the
set (denoted by ) of squares for which the respective
inequality equidensity constraints are violated or almost
violated:

where  is positive and sufficiently small but not too
small to make  numerically unstable (we have used
(the square's area)). Then the inequality
constraints of  are set to equalities ignoring the other
inequality constraints.
Let  be the set of all displacement indexes inside 
(including those on the boundary of  directing {\it
parallel} to it).
For every  we associate a correction variable
 and we reformulate the pseudo-Lagrangian for  as a
functional of the  variables as follows:

where  is the current value of  and the
 term is added for stability with . Solving
 we obtain the corrections
 for , which confine the
respective active set variables to the boundary of the equality
constraints manifold. However, while accepting this correction we
may violate other inequality constraints that were already
satisfied at the previous iteration . Let us call this set of
new unsatisfied constraints . One way to overcome
this problem is to accept only a {\it partial} correction , , where  is the {\it smallest}
number that brings some constraint from  to
equality. Accepting the correction  does not
violate any constraint from . At this point we
accept this partial correction and continue to the next iteration
, excluding from the redefined  the set of satisfied (by
equality) constraints from  with negative Lagrange
multipliers . \vspace{6mm}

\begin{tabbing}
  \quad \=\quad \=quad \=quad \=quad         \kill
  {\bf SingleWindowSolver}(, )\\
  \keyw{begin}\\
  \>  \\
  \> \keyw{Repeat} until "optimal enough" (explained at the end of Section \ref{sExamples})\\
  \>\> \keyw{If} \\
  \>\>\>the violated equidensity constraints\\
  \>\> \keyw{Else}\\
  \>\>\>the violated equidensity constraints\\
            ~~~~~~~~~~~~~~~~~~~~those from iteration  which satisfy equality and have \\
  \>\> \keyw{Solve}  and extract the smallest \\
  \>\> \keyw{Accept} the correction \\
  \>\> \\\keyw{end}\\
\end{tabbing}
\par To achieve corrections for all variables, we will cover by these windows the
entire area in red-black order \cite{mgbooktrott}. For
computational reasons we have chosen to apply this relaxation for
very small windows (of size  squares). To minimize the
effects of the boundary constraints in the windows and to enforce
the equidensity constraints over different super-squares, we scan the
entire domain two more times: once with
half-window size shift in the horizontal direction and once in the
vertical. Thus the overall relaxation process covers the domain
three times.

\subsubsection{The multilevel cycle}\label{sMultilevel-cycle}
\par Having defined the window relaxation, the interpolation, and
the coarsening scheme, the multilevel cycle naturally follows.
Starting from the given approximation ,
discretize the domain by a standard grid on which the 
variables are initially defined. Construct the system of equations
(\ref{full-ineq-problem-in-q-l-a-b}), and solve for the 
variables as follows. After applying  window relaxation
sweeps, define the coarser level equations for the coarser grid,
apply  window relaxation sweeps there, and continue to a
still coarser level. This process is recursively repeated until a small
enough problem is obtained. Solve this coarsest problem directly,
and start the uncoarsening stage by interpolating the solution of
the coarse level to the finer levels followed by  window
relaxation sweeps on the finer level. Repeat until the correction
to the original problem is obtained. This entire multilevel cycle,
usually referred to as the {\it V-cycle}, is summarized in
procedure {\bf V-cycle-correction} below, where the superscript
index refers to the level number. (We have used ).
\vspace{6mm}
\begin{tabbing}
  \quad \=\quad \=quad \=quad \=quad         \kill
  {\bf V-cycle-correction}(, , , , )\\
  \keyw{begin}\\
  \> \keyw{If}  is a small enough grid\\
  \>\> \keyw{Solve} the problem exactly\\
  \> \keyw{Else}\\
  \>\> \keyw{Set} \\
  \>\> \keyw{Apply}  {\it Window relaxation} sweeps\\
  \>\> \keyw{Construct}  the coarse level grid\\
  \>\> \keyw{Define}  to be the set of equidensity constraints\\
  \>\> \keyw{Initialize} the system of equations  given by (\ref{eqCoarseQL})-(\ref{eqCoarseEta})\\
  \>\> \keyw{Initialize}  and \\
  \>\> \keyw{V-cycle-correction}(, , , , \\
\>\> \keyw{Interpolate} from level  to level  using (\ref{equU}) and (\ref{eqLambdaInterpolation})\\
    \>\> \keyw{Apply}  {\it Windows relaxation} sweeps\\
   \keyw{Return} \\
\end{tabbing}

\subsection{The Full MultiGrid external driving routine}\label{sExternalCycle}
\par The solution of (\ref{full-ineq-problem-in-q-l-a-b}) is primarily dependent on the chosen grid size.
To enforce equidensity at all scales, it can be used within the
Full MultiGrid (FMG) framework. This is done by using a {\it
sequence} of increasing grid sizes (progressively finer
meshsizes), while employing a small number of V-cycles for each
grid size. We emphasize that the original problem
(\ref{full-problem}) is highly nonlinear, while the system of
equations with corrections in term of the displacement  is
linearized around the current solution .
Therefore, only a small correction should actually be taken from
the  displacements when these  are
being updated. Then, a new linear system can be formulated around
the new solution to obtain a new correction, and so forth. Thus, by small
steps of corrections we solve the original nonlinear problem via
the corrections calculated from the linear system of equidensity
constraints. For instance, we have tried to employ grids of sizes:
2, 4, 8, ... up to a grid with number of squares comparable to the
number of nodes in the graph. For each grid size the corresponding
set of equations (in terms of the displacement ) is solved
either directly (for small enough grids) or by employing the
V-cycles described in Section \ref{sMultilevel-cycle}. In either
cases the obtained solution  is interpolated back to the
 variables, introducing the desired correction to the
original variables of the problem. Various driving routines can be
actually used: each chosen grid size may be solved more than once
(e.g., use grids 2, 2, 4, 4, 8,...); the entire sequence of grids
may be repeated (e.g., 2, 2, 4, 4, 8,... , 2, 2, 4, 4, 8,...),
and so on. (see Section \ref{sExamples} for examples). These parameters
should in fact be optimized for each application according to the
concrete needs of the model.
\par The entire algorithm for the two-dimensional layout correction
is summarized below in Algorithm {\bf 2D-layout-correction}, where
the superscript 0 refers to the current chosen grid size.
\vspace{3mm}
\begin{tabbing}
  \quad \=\quad \=quad \=quad \=quad         \kill
  {\bf 2D-layout-correction}(graph , current layout )\\
  \keyw{begin}\\
  \> \keyw{Apply} for a sequence of grid sizes\\
  \>\> \keyw{Construct and initialize } , \\
  \>\> \keyw{Define}  to be the set of equidensity constraints\\
  \>\> \keyw{Initialize} the system of equations \\
  \>\> \keyw{V-cycle-correction}(, , , , )\\
  \>\> \keyw{Update }  from \\
   \keyw{Return} \\
\end{tabbing}



\section{Examples of graph drawing layout correction}\label{sExamples}
\par As previously mentioned, the graph drawing problem is of interest
for many applications. Therefore, we have chosen to demonstrate
the abilities of our algorithm for this problem. In this section
we will present several results of the two-dimensional layout
correction algorithm using inequality constraints. The set of
examples is shown in Figures \ref{figtest} and \ref{figm64add} to
 \ref{figvoltest-tree}, each organized in two columns. The initial and
 final layouts of the graph are shown in the same row, in the left and
 the right columns, respectively.
Note that finalizing the "nice graph" representation of these
examples is beyond the scope of this work. The various
"beautifying" procedures used by different applications may, of
course, be used at the end of our cycles to enhance the
visualization results.

\par The first example consists
 of a mesh graph with three holes (Figure \ref{figtest}, row (a)).
 It is intended to demonstrate that the empty space stays empty and
 the energy is thus kept low. More complicated examples are shown
 in Figure \ref{figtest}, rows (b) and (c). The initial optimal positions
 of the mesh's vertices were randomly changed by independent shifts
 in different directions within a distance :

where  is the length of a square on the initially taken 32x32
grid, such that the mesh size of the graph is actually . Let
us call these meshes  and , respectively. While the
correction of  looks really nice, two switched vertices at
the right-hand side of  demonstrate a weak point in our
algorithm that certainly must be improved by a local "beautifying"
procedure, which in general depends on the real application. The
initial layout (c1) is more complicated than (b1), while the
desired final layouts are similar.
\par A typical example of the energy behavior is presented
in Figures \ref{vc-conv}-\ref{wrb-conv}. These figures refer to
the mesh example in Figure \ref{figtest}-(c). The general energy
minimization progress is shown in Figure \ref{vc-conv}. In this
example the driving routine alternates between two grid size
V-cycles: each odd V-cycle solves the correction problem for the
16x16 grid, while even V-cycles improve the previous iterations
with the grid 32x32.
Figures \ref{wr-conv} and \ref{wrb-conv} show the
energy behavior of the Window relaxations (without V-cycles) for
16x16 grid iterations and alternately 16x16 and 32x32 grid sizes,
respectively. Clearly, the V-cycle algorithm is more powerful in
minimizing the energy than just employing the Window relaxations.
\par A more complicated example is shown in Figure
\ref{figm64add} in which the 64x64 mesh graph randomly perturbed
by vertex shifts (up to  of a 64x64 grid), compressed at the
left bottom corner and augmented by 50 randomly chosen edges
 (Figure \ref{figm64add}-(a)). The final result of the
 algorithm is presented in Figure  \ref{figm64add}-(b), where
  all vertices are placed almost at their optimal locations (note the different scales of the two figures).
 We have
  used 2-FMG cycles with 2 V-cycles at each level as the main driving routine.
  Such a driving routine works with the following
  grid sizes: 2, 2, 4, 4, 8, 8, ..., 128, 128, 2, 2, 4, 4, and so forth. After these 2-FMG cycles
  the total energy was very close to its real minimum and
  additional iterations have only slightly corrected the layout.  The next experiment consists of the 64x64 compressed
mesh with three holes. The initial and final layouts are
 presented in Figures \ref{figm64hole}-(a) and \ref{figm64hole}-(b), respectively.
\par Two additional examples demonstrate the layout corrections
for graphs whose vertices have nonequal volumes (see Figures \ref{figvoltest}
and \ref{figvoltest-tree}). In both cases the initial layout
of these graphs was random.
\par In spite of the promising results presented above,
the algorithm has not yet been optimized. However, it is already
clear that several parameters must for efficiency be kept very
small. For example: (1) the number of {\it Window relaxation}
iterations should be fixed between 1 and 3; (2) "optimal enough"
in {\bf SingleWindowSolver} means less than 6 iterations and (3)
the size of  in {\bf SingleWindowSolver} is very robust,
that is, the same results can be obtained with sizes x, x,
and x. We have used only x as it runs the fastest.




\begin{figure}
\begin{center}

\end{center}
\caption{Examples of the 2D-layout of graphs with equal vertices.}
\label{figtest}
\end{figure}

\begin{figure}
\vbox{\center\includegraphics[width=7cm]{vcycles.pdf}}
\caption{Energy behavior of the mesh at Figure \ref{figtest}-(c),
when employing complete V-cycles with  and  alternately.}\label{vc-conv}
\end{figure}
\begin{figure}
\vbox{\center\includegraphics[width=7cm]{win16.pdf}}
\caption{Energy behavior of Window relaxation iterations
( grid) of the mesh at Figure
\ref{figtest}-(c).}\label{wr-conv}
\end{figure}
\begin{figure}
\vbox{\center\includegraphics[width=7cm]{win16-32.pdf}}
\caption{Energy behavior of Window relaxation iterations
( and  grids) of the mesh at Figure
\ref{figtest}-(c).}\label{wrb-conv}
\end{figure}




\begin{figure}
\begin{center}

 \end{center}
  \caption{Example of the layout of the  mesh with additional random edges
  (note the different scales of the two figures):
  (a) starting from a compressed and perturbed configuration at the bottom-left corner,
  (b) the resulting picture using V-cycles.}
  \label{figm64add}
\end{figure}
\begin{figure}
\begin{center}

 \end{center}
  \caption{Example of the  mesh with three holes layout
  (note the different scales of the two figures):
  (a) starting from a compressed and perturbed configuration at the bottom-left corner, (b) the resulting picture using V-cycles.}
  \label{figm64hole}
\end{figure}


\begin{figure}
  \centerline{
    \mbox{\includegraphics[width=4.00in]{pet19_start.pdf}}
    \mbox{\includegraphics[width=3.00in]{pet19_5.pdf}}
  }
  \caption{Example of the 2D-layout of a graph with nonequal volumes.}
  \label{figvoltest}
\end{figure}
\begin{figure}
  \centerline{
    \mbox{\includegraphics[width=3.00in]{bt5_start.pdf}}
    \mbox{\includegraphics[width=3.00in]{bt5_1.pdf}}
  }
  \caption{An example of the 2D-layout of a 5-level binary tree with non-equal vertices.}
  \label{figvoltest-tree}
\end{figure}
\section{Conclusions}\label{future-work}

\par We have presented a linear time multilevel algorithm
for solving correction to the nonlinear minimization problem
under planar (in)equality constraints. By introducing a sequence
of grids over the domain and a new set of global displacement
variables defined at those grid points, we formulated the
minimization problem under planar equidensity constraints and
solved the resulting system of equations by multigrid techniques.
This approach enabled fast collective corrections for the optimization
objective components. We believe that this formulation can open a
new direction for the development of fast algorithms for efficient
space utilization goals. Among many possible motivating
applications
\cite{gd-book,eades1984,harel88,harelinger,dreznerfacility,meguerdichian01coverage,
cardei-energyefficient, citeulike:717044,vlsi2007book} we focused
on the demonstration of the method on the graph visualization
problem with efficient space utilization demand.
\par We recommend this multilevel method as a general practical
tool in solving, possibly together with other tools, the
nonlinear optimization problem under planar (in)equality
constraints.


\section{Acknowledgments}
\par This work was supported in part by the Office of Advanced Scientific Computing Research, Office of Science, U.S. Department of Energy, under Contract DE-AC02-06CH11357.
\bibliography{mybib}
\hspace*{1.5in}{\scriptsize\framebox{\parbox{2.4in}{
The submitted manuscript has been created in part by UChicago Argonne, LLC, Operator of Argonne National Laboratory ("Argonne").  Argonne, a U.S. Department of Energy Office of Science laboratory, is operated under Contract No. DE-AC02-06CH11357.  The U.S. Government retains for itself, and others acting on its behalf, a paid-up nonexclusive, irrevocable worldwide license in said article to reproduce, prepare derivative works, distribute copies to the public, and perform publicly and display publicly, by or on behalf of the Government.
}}}

\end{document}
