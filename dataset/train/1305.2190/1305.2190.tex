\documentclass[conference]{IEEEtran}
\pdfoutput=1
\usepackage[utf8x]{inputenc}

\usepackage[cmex10]{amsmath}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}

\usepackage[caption=false,font=footnotesize]{subfig}

\usepackage{epsfig}





\def\argmax{\mathop{\rm arg\,max}}
\def\argmin{\mathop{\rm arg\,min}}


\pagestyle{headings}
\newtheorem{theorem}{Theorem}[section]
\newcommand{\bTheorem}{ \begin{theorem}  }
\newcommand{\eTheorem}{ \end{theorem}    }

\newcommand{\bProof}{ \noindent {\bf Proof:} }
\newcommand{\eProof}{\hspace*{.1in} \hfill \begin{picture}(6,6)
\thicklines \put(0,0){\line(0,7){7}} \put(1,0){\line(0,7){7}}
\put(1.5,0){\line(0,7){7}} \put(2,0){\line(0,7){7}}
\put(3,0){\line(0,7){7}} \put(4.5,0){\line(0,7){7}}
\put(4,0){\line(0,7){7}} \put(5,0){\line(0,7){7}}
\end{picture} }

\def\binom#1#2{{#1\choose#2}}
\def\tenrm{\fontsize{10}{12}\normalfont\rmfamily\selectfont}
\def\BibTeX{{\rmfamily B\kern-.05em{\scshape i\kern-.025em b}\kern-.08em \TeX}}

\newcommand{\bEq}{     }

\newtheorem{proposition}{Proposition}[section]
\newcommand{\bProposition}{ \begin{proposition}  }
\newcommand{\eProposition}{ \end{proposition}    }

\newtheorem{Definition}{Definition}[section]
\newcommand{\bDefinition}{ \begin{Definition} }
\newcommand{\eDefinition}{ \end{Definition} }
\newcommand{\bDef}{ \begin{Definition} }
\newcommand{\eDef}{ \end{Definition} }

\newtheorem{lemma}{Lemma}[section]
\newcommand{\bLemma}{ \begin{lemma}  }
\newcommand{\eLemma}{ \end{lemma}    }

\newtheorem{Remark}{Remark}[section]
\newcommand{\bRemark}{ \begin{Remark} \rm }
\newcommand{\eRemark}{ \end{Remark}    }

\def\bA{\mathbf{A}}
\def\bB{\mathbf{B}}
\def\bC{\mathbf{C}}
\def\bD{\mathbf{D}}
\def\bE{\mathbf{E}}
\def\bF{\mathbf{F}}
\def\bG{\mathbf{G}}
\def\bH{\mathbf{H}}
\def\bI{\mathbf{I}}
\def\bJ{\mathbf{J}}
\def\bK{\mathbf{K}}
\def\bL{\mathbf{L}}
\def\bM{\mathbf{M}}
\def\bN{\mathbf{N}}
\def\bO{\mathbf{O}}
\def\bP{\mathbf{P}}
\def\bQ{\mathbf{Q}}
\def\bR{\mathbf{R}}
\def\bS{\mathbf{S}}
\def\bT{\mathbf{T}}
\def\bU{\mathbf{U}}
\def\bV{\mathbf{V}}
\def\bW{\mathbf{W}}
\def\bX{\mathbf{X}}
\def\bY{\mathbf{Y}}
\def\bZ{\mathbf{Z}}




\def\cA{\mathcal{A}}
\def\cB{\mathcal{B}}
\def\cC{\mathcal{C}}
\def\cD{\mathcal{D}}
\def\cE{\mathcal{E}}
\def\cF{\mathcal{F}}
\def\cG{\mathcal{G}}
\def\cH{\mathcal{H}}
\def\cI{\mathcal{I}}
\def\cJ{\mathcal{J}}
\def\cK{\mathcal{K}}
\def\cL{\mathcal{L}}
\def\cM{\mathcal{M}}
\def\cN{\mathcal{N}}
\def\cO{\mathcal{O}}
\def\cP{\mathcal{P}}
\def\cQ{\mathcal{Q}}
\def\cR{\mathcal{R}}
\def\cS{\mathcal{S}}
\def\cT{\mathcal{T}}
\def\cU{\mathcal{U}}
\def\cV{\mathcal{V}}
\def\cW{\mathcal{W}}
\def\cX{\mathcal{X}}
\def\cY{\mathcal{Y}}
\def\cZ{\mathcal{Z}}

\def\reals{\mathbf{R}}  \def\mN{\mathbf{N}}  \def\mS{\mathbf{S}}  \def\mC{\mathbf{C}}  \def\mQ{\mathbf{Q}}  \def\ints{\mathbf{Z}}  


\def\BibTeX{{\rmfamily B\kern-.05em{\scshape i\kern-.025em b}\kern-.08em \TeX}}





\title{Scalable Routing Easy as PIE: a Practical Isometric Embedding Protocol\\{\large Technical Report}}
\author{\IEEEauthorblockN{Julien Herzen}
 \IEEEauthorblockA{EPFL, Lausanne, Switzerland\\
julien.herzen@epfl.ch}
\and
\IEEEauthorblockN{Cedric Westphal}
\IEEEauthorblockA{Docomo Innovations, Palo Alto, CA\\
cwestphal@docomoinnovations.com}

\and
\IEEEauthorblockN{Patrick Thiran}
\IEEEauthorblockA{EPFL, Lausanne, Switzerland\\
patrick.thiran@epfl.ch
}
}

\begin{document}

\maketitle

\begin{abstract}
\footnote{This work has been previously published in~\cite{herzen:pie}. The present document contains an additional optional mechanism, presented in Section~\ref{sec:asym}, to further improve performance by using route asymmetry. It also contains new simulation results.}
We present PIE, a scalable routing scheme that achieves 100\% packet delivery and low path stretch. It is easy to implement in a distributed fashion and works well when costs are associated to links. Scalability is achieved by using virtual coordinates in a space of concise dimensionality, which enables greedy routing based only on local knowledge. PIE is a general routing scheme, meaning that it works on any graph. We focus however on the Internet, where routing scalability is an urgent concern. We show analytically and by using simulation that the scheme scales extremely well on Internet-like graphs.
In addition, its geometric nature allows it to react efficiently to topological changes or failures by finding new paths in the network at no cost, yielding better delivery ratios than standard  
algorithms. The proposed routing scheme needs an amount of memory polylogarithmic in the size of the network and requires only local communication between the nodes. Although each node constructs its coordinates and routes packets locally, the path stretch remains extremely low, even lower than for centralized or less scalable state-of-the-art algorithms: PIE always finds short paths and often enough finds the shortest paths.
\end{abstract}

\section{Introduction}
In the Internet, the tremendous growth of the number of destinations translates into a
corresponding growth of the routing tables. The Internet Architecture Board recently recognized the scalability of routing as being \emph{``the most important problem facing the Internet today''}~\cite{iab}.
The core routers need an excessive amount of resource and power to store, maintain and perform lookups in huge routing tables. The amount of traffic exchanged between the routers is proportional to the size of these tables, and the complexity of managing some state for every destination in the network
results in convergence problems and instabilities.
The arrival of IPv6, along with new trends 
such as ubiquitous and mobile computing, 
is likely to make the number of potential destinations explode, thus exacerbating this fundamental scalability issue.
In addition, there are some other contexts where the scalability of routing can be an important concern, such as large sensor networks in which the nodes have only a very limited amount of memory.


There is a fundamental relationship between the size of the state required by a routing algorithm and the quality of the routes that it can find. It is well-known that to accomplish shortest path routing on any network of  nodes, the routing table of each node needs to grow as . Indeed, if we denote by {\em path stretch} the ratio of the path length achieved by a routing protocol, divided by the shortest possible path on the graph, then it is known that any protocol that would keep the path stretch in the worst case strictly below three, would require a  bit state at each node as well~\cite{gavoille97}.
As a direct consequence, if we want to significantly reduce the state required by routing algorithms in the future, we should consider algorithms that \emph{may} inflate the path lengths.






One potential avenue is to design practical protocols that create, for all the nodes of the network topology, some virtual coordinates in a metric space such that the relative position of the nodes can be expressed as a function of their distance. Greedy forwarding consists in forwarding a packet to a node's neighbor closest to the destination. As this forwarding depends only on the distances between the neighbors of a node and the destination, it is a purely local mechanism. Further, the routing table consists only of the coordinates of a node's neighbors: This information scales as the maximum degree of the graph times the size of the coordinates. These are typically of the order of , making these so called {\em geographic} (or {\em geometric}) routing schemes very scalable ( bits are already required to merely name each node in the network). In addition, as the routing decision is a simple comparison of the relative distance between a set of neighbors and a destination, the forwarding decisions are fast and easy to implement.

In his famous 1967 \emph{small-world} experiment~\cite{milgram67smallworld}, Milgram observes that human beings have the ability to efficiently route messages among themselves without having a full view of the topology; by just forwarding the messages to their acquaintances that they think are \emph{the closest to the final destination}. To some extent, the Internet and a large category of random graphs exhibit similar small-world properties~\cite{pastor-satorras04}. It is therefore natural to ask whether a more formal and explicit notion of distance can be obtained in the context of computer networks, that fits well the structure of such graphs.



Let  denote the graph defined by the topology of the communication network.  represents the set of nodes (routers) and  denotes the set of bi-directional links connecting these nodes. Also, consider an embedding space , that is the metric space  equipped with the distance .

For each node , define its set of neighbors , namely: . We recall the definition of a greedy embedding \cite{papadimitriou:conjecture}:

\bDef A greedy embedding is a mapping  such that :

\eDef
\vspace{0.2cm}
Applied to routing, this simply states that, if the node  is trying to send or relay a packet to the destination , it will always find a neighbor  such that  is closer to  than  is, and thus that delivering the packet to  brings it closer to, and eventually at, its destination. Most geographical coordinate systems, including some virtual coordinate embeddings, 
do not produce greedy embeddings 
and require mechanisms to recover from local minima. 




There is much theoretical work (some of which we describe in Section~\ref{sec:rw}) that considers whether a topology can be greedily embedded in a space , and under which conditions. Most of this work focuses on providing guarantees, and does not lend itself to implementation, as a full view of the topology is essential to most results.
As a consequence, to our knowledge there exists no routing scheme that is practical, scalable (i.e., requiring an amount of memory polylogarithmic in ), achieves close to optimal path stretch and guarantees the success of routing. Our intent is to present such a scheme.

























\textbf{Outline: }
In the next section, we summarize the related work. In Section~\ref{sec:pie}, we present PIE and the embedding protocol. In Section~\ref{sec:analysis}, we provide an analysis of PIE. 
In Section~\ref{sec:perfeval}, we present an evaluation of the performances of PIE. We discuss practical relevance for Internet routing in Section~\ref{sec:discussion} and we finally conclude in Section~\ref{sec:conclusion}.

\section{Related Work}
\label{sec:rw}
The idea of using coordinates for routing has been introduced in the context of wireless ad-hoc networks. In particular, the idea of using virtual coordinates (instead of the actual physical positions of the nodes) has been proposed as a mean to perform greedy routing without the need for a GPS receiver. \cite{rao:geographic, Dabek:vivaldi} and many others build practical schemes to create synthetic coordinates from the underlying topology. These are distributed methods, and can be implemented. However, they do not apply to all graph topologies (typically only on planar graphs) and cannot guarantee the success of greedy forwarding; the packets can be trapped in local minima.




Solutions such as \emph{face routing} have been proposed to guarantee the success of geographic routing when local minima are present, see for instance~\cite{goafr}.
These methods apply greedy routing by default and use a recovery mechanism when the packet is trapped in a local minimum. These deterministic recovery mechanisms only guarantee success of routing when the dimensionality of the underlying space is no more than two~\cite{durocher:3d}. In addition, backtracking out of local minima significantly inflates paths lengths and induce high congestion~\cite{subramanian:optimal}.



In order to obtain greedy embeddings, it is therefore appealing to consider spaces of more than two dimensions. The fundamental tradeoff is to find a space of concise dimensionality (to guarantee scalability) that suits the embedding of a graph in a way that preserves the distances among the vertices (for routing performances). There is an ample body of theoretical work on graph embedding onto low-dimensional spaces (see~\cite{matousek} and references therein). Maymounkov~\cite{maymounkov:greedy} shows that  is the minimal dimension for a Euclidean space to construct a greedy embedding of an arbitrary graph. The author also demonstrates that it is enough for trees, but his theoretical result, unfortunately, cannot be translated into a practical algorithm.

For some categories of graphs, it is possible to perform the embedding in a two dimensional Euclidean space. Indeed, Papadimitriou et al.~\cite{papadimitriou:conjecture} famously conjectured that such a space could embed any planar triangulation, and~\cite{moitra:greedy} confirms the conjecture. However,  bits are required to differentiate the points in the coordinate space.

Kleinberg~\cite{kleinberg:hyperbolic} and Cvetkovski et al.~\cite{Crovella:hyperbolic} consider hyperbolic spaces of 2 dimensions and~\cite{kleinberg:hyperbolic} demonstrates how to greedily embed any tree. However, here again the schemes results in coordinates of size  bits, and do not produce a significant gain in scalability. 
Very recently, Papadopoulos et al.~\cite{papadopoulos10} observed that uniform repartition of nodes onto a hyperbolic plane produces scale-free (Internet-like) graphs, and that the corresponding coordinates in the hyperbolic plane have desirable properties for greedy routing in these graphs. The reverse procedure has been used in~\cite{Krioukov:sustaining} to find the hyperbolic coordinates of the Internet ASs that fit the actual AS topology as well as possible. Although this work gives precious insights to understand the relations between scale-free graphs and the hyperbolic space, 
it yields an embedding that
is not greedy and it does not provide 100\% packet delivery: routing may fail. PIE pursues similar goals but takes a different approach,
it does not try to fit the coordinates to a predetermined space, but lets the embedding space be determined by the topology, using only local communications between the nodes.


\cite{Pei:greedy} constructs a fully distributed practical embedding by projecting an -dimensional graph topology onto a  dimension Euclidean space using the Johnson-Lindenstrauss lemma. Despite attempting to preserve the relative
distance between points, this method is \emph{quasi}-greedy and introduces some distortion in the embedded topology, which creates local minima. It therefore requires a recovery mechanism that significantly increases the path stretch.





Gupta et al.~\cite{gupta} and Flury et al.~\cite{greedy:flury} find a bounded stretch
of  with  coordinates for planar graphs~\cite{gupta} and
combinatorial unit disk graphs~\cite{greedy:flury}. For arbitrary graphs,
the scheme of~\cite{greedy:flury} also provides a stretch of .
However, these algorithms require a full, centralized
knowledge of the topology in input.



The idea of trading off path stretch for routing table size is the core component of the work on {\em compact routing} (see for instance~\cite{krioukov:sigcomm}). In~\cite{thorup:compact},
Thorup et al.
show that it is possible to guarantee a path stretch no larger than three with routing tables of size . Such compact routing schemes have been successfully implemented in practice~\cite{mao:S4,singla2010}. We explore a different point in the tradeoff space, specifically, we relax the worst-case path stretch guarantee in order to provide polylogarithmic scalability, which is obviously needed to sustain any exponential growth of the Internet. We show in our evaluations that the relaxation of this guarantee does not disadvantage PIE in any way: it achieves significantly lower stretch than compact routing, and never higher than three.



\cite{Chen:compact} adapts the scheme of Thorup et al.\ for power-law graphs and obtains better scalability for the routing state, although still a fractional power of .

\cite{brady} proposes a specialized scheme for power-law graphs, which provides polylogarithmic scalability, as PIE does. However, their method here again requires the complete topology graph in input and does not translate to a distributed protocol to build the routing tables.
In addition, it relies on \emph{tree routing}, that is, it uses only links that are spanned by some pre-constructed trees and neglect the others. PIE also constructs trees, but its geometric nature allows it to use all the links of the graph. We show in Section~\ref{sec:perfeval} that PIE finds shorter routes.









Distributed Hash Tables (DHTs) have been used to improve the scalability of routing as well (for instance, VRR~\cite{caesar:VRR}). However, such DHTs map to source routes that require  bits to be stored on many topologies, and  in the worst case. \cite{ghaffari:delaunay} and references therein use Delaunay triangulations to enable greedy forwarding with bounded stretch. However, unlike our work, they assume that the nodes exist in a Euclidean space. We assume nodes in an arbitrary connectivity graph. In particular, it has been shown that Euclidean spaces are not well suited to represent Internet nodes~\cite{lee:euclidean}.

\begin{table}[htb]
    \centering
        \begin{tabular}{|l|c|c|c|c|c|}
        \hline
        & \cite{brady} & \cite{thorup:compact,mao:S4,singla2010} & \cite{Krioukov:sustaining} & \cite{Pei:greedy} & PIE\\
        \hline
	polylogarithmic scalability & \checkmark &  & \checkmark & \checkmark & \checkmark\\
	100\% success rate & \checkmark & \checkmark &  & \checkmark & \checkmark\\
	no recovery mechanism & \checkmark & \checkmark & \checkmark &  & \checkmark\\
	distributed protocol &  & \checkmark & \checkmark & \checkmark & \checkmark\\
	\hline
        \end{tabular}
	\caption{Comparison of PIE with related state-of-the-art.}
	\label{table:soa}
\end{table}
\vspace {-2em}

\section{Description of PIE}
\label{sec:pie}

\subsection{Model and Background}
\label{sec:bm}
We consider a weighted graph  associated with a function  assigning a cost to each edge of .  defines the usual (weighted) shortest path distance in , that we denote by . If  is an embedding of  into a metric space ,  is said to have distortion  if: 
 
An embedding with distortion 1 is said to be isometric.

We are interested in situations where the host metric space is a standard -dimensional metric space , where , equipped with a -norm such that 

for all . We denote by  such a space, and thus  denotes the usual -dimensional Euclidean space.




As there is exactly one path between any two nodes in a tree, an isometric embedding of a tree is also greedy.
Further, it is known (see Linial et al.\ \cite{linial}, Theorem 5.3) that a tree can be isometrically embedded in . Given these two pieces of information, we could imagine a routing scheme that first extracts a tree  spanning the connection graph , embeds it isometrically in  and uses the resulting greedy embedding of  to perform greedy routing. However, this approach would not work in practice, for two main reasons: 
First, the isometric tree embedding algorithm proposed in \cite{linial} requires a full, centralized knowledge of the tree, as it recursively divides it in balanced subtrees. Second, routing over a tree is clearly inefficient because a significant number of links may not be taken into account, possibly leading to poor performance in terms of path stretch and congestion.

In the following, we address these two problems. 
By relaxing the \emph{deterministic} guarantee on the dimensionality, we are able to devise a different, simple, isometric embedding algorithm that does not need global knowledge of the topology and is easy to implement in a distributed scenario. As shown in Section~\ref{sec:analysis}, the guarantee on the dimensionality becomes  \emph{with probability one} (almost surely), on the relevant categories of random graphs.

The second problem due to tree routing is addressed by constructing multiple trees with different locality levels. In such a scenario, not all the trees would span the whole graph, but most would span only a local portion of it, according to their locality level. However, the union of all the trees at each locality level would cover the whole graph. As such, each node is covered by one tree for each locality level, that is, by  trees in total if we choose  locality levels.

Here are the high level steps of PIE:

\begin{itemize}
 \item Extract several (rooted) trees with different locality levels from the graph, with at least one spanning the whole graph.
 \item Embed each of these trees in a separate coordinate system.
 \item When forwarding a packet, choose a tree on which to perform greedy routing and send the packet to the neighbor that provides the best progress towards the destination in this coordinate system.
\end{itemize}

In the next section, we present the distributed greedy embedding algorithm in detail, using one spanning tree. The extension to several trees is explained in Section \ref{sec:multipleTrees}.

\subsection{Isometric Tree Embedding}
\label{sec:embedding}

Let  denote a rooted spanning tree of . We explain here how to embed , and we provide later two distributed algorithms that (i) extract  out of  and (ii) embed .


Let  be a node of the tree . At the beginning of the algorithm,  is set to be the root of the tree, and the coordinate \{\texttt{0}\} is assigned to it.
Let us denote by  the set of children of  that consists of the nodes , where  is the cardinality of .

For each child , compute a binary representation of its index . We denote by  such a representation, where .

Let  be the set formed by  along with all its descendants in . The algorithm appends  new coordinates  to all the vertices  in  as follows:

. After that, each node in  plays the role of , and the algorithm repeats the same procedure.
This way of assigning the coordinates goes from the root to the leaves in one pass and can be implemented in a way that induces only local communication between a node and its neighbors. In particular, at each step, the node  is higher in the tree than the nodes that receive the new coordinates, and Eq.\ (\ref{eq:coordAssign2}) does not need to be evaluated for all the vertices in  at the same time. Each node can simply infer them based on the coordinates of its parent in the tree. Therefore, each node  needs only to transmit its own coordinates along with the binary map  to each of its children .

The binary map  can be any variable length binary representation of  obtained with a prefix-free code. In particular, such a map of length  can be obtained using a Huffman code to represent the  children of  when they are equiprobable.

The scheme can be slightly improved if we note that if a node  is not the root and  (i.e., it has only one child), assigning a new coordinate to all the descendants of  would have no effect on their relative distance under the -norm. In this case, the binary map does not need to be sent. A step-by-step example of the embedding is shown in Figure \ref{fig:example}.

The greedy forwarding procedure is straightforward: When forwarding a packet, a node considers all its neighbors that are closer to the destination and chooses the one that minimizes the overall path length (i.e., taking into account the cost of the link to go to this neighbor). Specifically, a node  forwarding a packet to a destination  chooses the node that satisfies:

Note that this forwarding procedure considers \emph{all} the neighbors in , and not only the neighbors in . This enables shortcuts off the tree.
Indeed,
we prove in Section~\ref{sec:analysis} that this embedding of  yields a greedy embedding of . Therefore, this forwarding procedure always returns a next-hop closer to the destination (except if  is already the destination).

\begin{figure}
\vspace{0.1in}
\centering
\subfloat[]{\includegraphics[width=.85\linewidth]{figures/simpleTree.pdf}}\hfil
\subfloat[]{\includegraphics[width=.85\linewidth]{figures/simpleTree_step2.pdf}}\hfil
\subfloat[]{\includegraphics[width=.85\linewidth]{figures/simpleTree_step3.pdf}}
\caption{Example of isometric embedding from the root to the leaves. (a) shows the tree to embed. 
The vertices are named  to . The root is the node . We assume that all the edges have a weight of 1, except the edge () that has a weight of 4. (b) After having picked the coordinate \{\texttt{0}\}, the root sends the binary map (here represented by \texttt{+} and \texttt{-}) corresponding to each of its children. In (c), the nodes  and  play the role of  and send their coordinates to each of their children, along with the corresponding binary maps. Note that the node  has 3 children, resulting in a map of 2 bits for two of them and one bit for the last one. The algorithm does not require all the nodes to have the same number of coordinates, the -norm is simply applied on the first common coordinates. For example, if one wants to compute the distance between the node  and the node , the coordinates to use are \{\texttt{-2:1}\} and \{\texttt{5:-4}\}. As , the distance is .}
\vspace{-1.2em}
\label{fig:example}
\end{figure}


\textbf{Algorithm Specification: }
The overall algorithm proceeds in two steps. First, a spanning tree is extracted from the graph and then the virtual coordinates are computed based on this tree. We specify these two steps in the form of two distinct modules, the \texttt{tree\_maintainer} and the \texttt{coordinates\_maintainer}. The \texttt{tree\_maintainer} implements a distributed spanning tree construction by using the well-known STP protocol \cite{perlman:stp}. Recall that in this protocol, each node chooses an ID and the node with the largest ID eventually becomes the root of the whole spanning tree. 
During our experiments on power-law graphs, we observed slightly better routing performances when the root was the highest degree node. We thus choose the ID to be the degree of the node (plus a small random salt to break ties if needed).
 
The STP protocol has been augmented with a straightforward improvement, in order for each node to learn who its children are when it receives messages from its neighbors. The \texttt{coordinates\_maintainer} acts separately but uses the \texttt{tree\_maintainer} in order to access the list of children.
In realistic scenarios, the topology may of course 
change over time and the links may be asynchronous. Therefore, these two modules typically act on a periodic basis in order to accommodate possible changes in the tree. The pseudo-codes corresponding to the distributed versions of the \texttt{tree\_maintainer} and \texttt{coordinates\_maintainer} are shown in Algorithms \ref{alg:simpleTreeMaint} and \ref{alg:coordMaint}, respectively. 
We use the following conventions for the pseudo-code:
\begin{itemize}
\item  denotes the field  of the element .
\item  denotes the element at index  of the data structure  (the indexes start at ).
\item .length denotes the number of elements in the data structure .
\item treeMsg and coordMsg are the two message types used by the \texttt{tree\_maintainer} and the \texttt{coordinates\_maintainer}, respectively. When they are constructed, they receive as arguments the values of the fields that they will carry.
\end{itemize}
The other notations should be clear from the context.


\begin{algorithm}[t]
\begin{algorithmic}
\begin{small}


\State \textbf{Init}:

	\State 
	\State  (+ random salt in  to break ties)
	\State 
	\State 

\vspace{0.06in}

\State \textbf{Periodically}:
	\State send treeMsg() to each neighbor of 

\vspace{0.06in}

\State \textbf{Upon reception of} treeMsg  from neighbor :
	\State  \Comment{cost from  to }
	\If{ or  and }
		\State 
		\State 
		\State 
	\EndIf
	\If{ and }
		\State .add()

	\EndIf
	\If{ and }
		\State .remove()
	\EndIf

\vspace{0.06in}

\Procedure {GetChildren}{}
	\State return 
\EndProcedure
\end{small}
\end{algorithmic}
\caption{\texttt{tree\_maintainer} at node }
\label{alg:simpleTreeMaint}
\end{algorithm}



\begin{algorithm}
\caption{\texttt{coordinates\_maintainer} at node }
\begin{algorithmic}
\begin{small}
\State \textbf{Init}:
	\State  \vspace{0.06in}

\State \textbf{Periodically}:
	\State  \texttt{tree\_maintainer}.\Call{getChildren}{}
	\If {change in childhood}
		\State \Call{NotifyChildren}{}
	\EndIf

\vspace{0.06in}

\Procedure {NotifyChildren}{}
	\State  number of children
	\If {}
		\State send coordMsg() to 
	\EndIf
	\If {}
		\For{ to }
			\State  prefix-free binary representation of 
\State send coordMsg() to 
		\EndFor
	\EndIf
\EndProcedure

\vspace{0.06in}

\State \textbf{Upon reception of} coordMsg  from parent :
	\State  \Comment{cost from  to }
	\State .length
	\For{ to }
		\If {}
			\State 
		\Else
			\State 
		\EndIf
	\EndFor

	\For{ to .length}
		\If {}
			\State 
		\EndIf
		\If {}
			\State 
		\EndIf
	\EndFor
	\If{ changed}
		\State \Call{NotifyChildren}{}
	\EndIf
\end{small}
\end{algorithmic}
\label{alg:coordMaint}

\end{algorithm}

\subsection{Extension to Several Trees}
\label{sec:multipleTrees}
This embedding is a significant improvement over tree routing. It can still be improved by using multiple trees. Building only one tree spanning the graph takes into account exactly  links when computing the coordinates and it ignores all the other links.  This can lead to some sub-optimal routing decisions when the shortest path between two nodes contains a link that is not included in the spanning tree.

We now describe how to use several trees so that any given link has a high probability of being spanned by one of the trees. 
An obvious solution would be to construct multiple spanning trees. However, in order to keep a small overall number of coordinates, each node has to belong to a small number of trees. If all these trees span the whole graph and have randomly chosen roots, it is likely that some of these roots will be close to each other; this would lead to similar, redundant trees, with little or no performance gain.

Instead, we propose to partition the graph  times: 
The first partition divides the graph in two pieces, the second partition divides the graph in four pieces and, more generally, the -th partition divides the graph in  pieces. Each of these  partitions defines what we denote a \emph{locality level}.
For the locality level , each of the corresponding  pieces of the graph is spanned by one tree and we denote these  trees the trees \emph{of level} .
Note that there is only one tree of level  and that it spans the whole graph.
Of course, computing such exact partitions for each of the  locality levels would require a global knowledge of the graph.


In order to keep a distributed solution, we slightly modify the procedure and adopt the following election process: For each locality level , each node elects itself as the root of a tree of level  with a probability of , independently of the other nodes. We have therefore an \emph{expected} number of  trees of level , for all . Each of the trees is then constructed in a similar way as described in the previous section; for every locality level , each node chooses to belong to the tree of level  whose root is the closest (breaking ties arbitrarily). Each node maintains therefore  independent sets of coordinates, corresponding to the  trees (of levels  to ) to which it belongs. We will see in Section~\ref{sec:perfeval} that taking  leads to substantial performance gain and makes the performances of the scheme to scale with the size of the network.



The only necessary condition to route all the packets successfully is that all the nodes have at least one of their  sets of coordinates in common (i.e., that they belong to at least one common tree). This condition 
can be trivially satisfied by ensuring that at least one node deterministically becomes the root of a tree of level . 
This node can be for instance the one having the largest ID, as in the single-tree case.
Now, when evaluating the distance between two nodes, one just chooses the -norm that is minimized over the trees that the two nodes have in common.
We denote by  the coordinates of node  in the tree of level  to which it belongs. In addition, we denote by  a tree of level  to which both the node  and the node  belong.
When a node  wants to transmit a packet to a destination , it chooses the node that satisfies:

This forwarding procedure needs to be able to uniquely identify the trees. This can easily be done using the identifier of the root, of size .
Figure \ref{fig:example2} shows an example of our embedding using several trees.

The intuition now is that a large number of small trees having a high locality level provides fine-grained coordinates for local paths, while larger trees of lower levels provide coarse-grained coordinates for the longer routes and tie everything together, much like in a divide-and-conquer strategy.


\textbf{Algorithm Specification: }
The distributed implementation simply consists in a generalization of the \texttt{tree\_maintainer} and the \texttt{coordinates\_maintainer} to use  independent trees, as described above.



\begin{figure}[t]
\vspace{0.1in}
\centering
\subfloat[]{\includegraphics[width=.75\linewidth]{figures/ex2_2.pdf}}\hfil
\subfloat[]{\includegraphics[width=.75\linewidth]{figures/ex2_3.pdf}\label{fig:example2b}
}
\caption{Example of an embedding using several trees. We assume for  clarity that all the edges have a cost equal to one. (a) shows a tree of level  that spans the whole graph (with solid edges) and a corresponding set of coordinates at each node. (b) shows two trees of level , each with solid edges, along with the corresponding coordinates, which we denote by "red" and "green". We are interested in the case where a source  wants to send a message to a destination .  will compare the coordinates in the trees that its neighbors have in common with . Here, the neighbors of  are  and  and they both have the level 0 and the "green" level 1 sets of coordinates in common with .  will find that  is at distance 4 of  using the level 0 coordinates, and at distance 3 using the "green" coordinates. Similarly,  is at distance 5 with the level 0 coordinates and 1 with the "green" ones. Therefore,  will forward the packet to , which is the optimal choice here. Note that if only the tree of level 0 was present,  would have forwarded the packet to . The "green" tree provides a valuable shortcut in this situation.}
\vspace{-1.5em}
\label{fig:example2}
\end{figure}



\subsection{Source-aided Geometric Routing}
\label{sec:asym}
The routes found by PIE are not necessarily symmetric: When a source  sends a packet to a destination , the set of edges chosen by the forwarding procedure may be different than if the packet were sent by  to . To see this, consider again the example of Figure~\ref{fig:example2b}. The path from  to  goes through , whereas the path from  to  goes through  and is one hop longer.
Let  denote the path found by PIE when routing from  to .
It consists in the sequence of nodes through which any packet from  to  is routed using the geometric coordinates, including  and  themselves.
Similarly, let  denote the path from  to .
For a path , its length can be written as , where  is the -th element of the path  and  is the link weight function. Note that the fact that the routes found by PIE are not necessarily symmetric implies that  is not necessarily equal to . This motivates the following \emph{optional source-routing extension} of PIE in order to use the shortest of both routes.

Assume that two nodes  and  are engaged in a bi-directional communication, which involves packets sent by  to  as well as packets sent by  to , as would for instance happen with a TCP connection.
Assume also, without loss of generality, that  sends the first packet.
Our approach relies on identifying the bifurcations between  and  when the first packet in each direction is sent.
Consider an intermediate node  of the return path , and let  be the node that precedes  in  (see Figure~\ref{fig:ex-asym}). The first packet sent by  to  goes through  and then through . When  receives this packet, it checks whether  would be the next hop for the destination  using the virtual coordinates. If this is not the case, there is a bifurcation and the ID of  is added to the packet's header. The first two packets in each direction are also used to measure  and .

\begin{figure}
\centering
\includegraphics[width=.60\linewidth]{figures/ex-route-asym.pdf}\caption{Illustration of route asymmetry.}
\label{fig:ex-asym}
\end{figure}

When  receives the first packet back from , it compares the length of the two paths. If , the reverse path is shorter and  stores the bifurcation(s) -- namely, a sequence of node IDs -- from the header of the packet that it just received from . These bifurcations are then added to each packet that  sends to . Now, when receiving a packet from  to , each intermediate node in  checks if one of its neighbors belongs to the bifurcation set indicated in the packet. If a neighbor belongs to the set, the packet is forwarded to this node. Otherwise, the virtual coordinates are used. The complete procedure at the intermediate nodes is described in Algorithm~\ref{alg:fwdProcedure} and the procedure at the source  is described in Algorithm~\ref{alg:sendProcedure}.

In the pseudo-code, a packet  may contain a bifurcation set . This set is built during the first bi-directional exchange, and it may be used by the source  if the reverse path is shorter than the direct one. The variables  and  are used to measure  and , respectively. 

Note that identifying the first packet in each direction only requires only one additional bit in the header. Storing the set of bifurcations may require more memory. However, we observe in Section~\ref{sec:perfeval} that the number of node IDs that compose the bifurcation set is below  on average, at most , and essentially constant with the network size.



\begin{algorithm}[t]
\caption{Forwarding procedure at node }
\begin{algorithmic}
\begin{small}
	\State \textbf{Upon reception of first packet  with source  and destination :}
	\State Let  be the predecessor of  in 
\State 
	\If { does not satisfy Expression (\ref{eq:forwardcost2}) for destination }
		\State 
	\EndIf
	\If {}
		\State Store 
		\If { \texttt{null}}
			\State Store 
		\EndIf
		\State Store 
	\EndIf
	
	\vspace{0.06in}
	
	\State \textbf{When forwarding a subsequent packet  from  to :}
	\If {}
		\State Forward to the (first) node in 
	\Else
		\State Forward using Expression (\ref{eq:forwardcost2})
	\EndIf
\end{small}
\end{algorithmic}
\label{alg:fwdProcedure}
\end{algorithm}

\begin{algorithm}[t]
\caption{Packet emission procedure at source  for destination }
\begin{algorithmic}
\begin{small}
	\State \textbf{When sending the first packet  to :}
	\State set 
	\If { is known}
		\State set 
	\Else
		\State set \texttt{null}
	\EndIf
	
	\vspace{0.06in}
	
	\State \textbf{When sending a subsequent packet :}
	\If {}
		\State set 
	\EndIf
	
\end{small}
\end{algorithmic}
\label{alg:sendProcedure}
\end{algorithm}










\section{Analysis}
\label{sec:analysis}

In this section, we derive some simple facts about the scalability and performance of PIE when applied on Internet-like graphs. For simplicity, we consider only the embedding of a single spanning tree  on an unweighted graph (that is, using the hop count metric). Extensions of the results to multiple trees and weighted graphs are immediate in most cases. 

\subsection{Internet-like graphs}


Let us write  for the diameter of a graph . For a node , we write  for the number of coordinates assigned to  by the single tree embedding procedure of PIE. Let us also denote by  the highest such number, i.e., .

It has been pointed out by several research groups
(see ~\cite{faloutsos99, mahadevan06})
that the connectivity graph of the Internet exhibits a power law node-degree distribution, both at the router and at the AS levels. In these graphs, the proportion of nodes having degree  is proportional to  for some constant . For the Internet,  has consistently been estimated in the range ~\cite{pastor-satorras04}. Such a degree distribution (in particular when ) leads to very particular structural properties, among which the fact that the graphs typically exhibit extremely small distances between the vertices 
(with ~\cite{Chung02theaverage}),  
hence the \emph{small-world} denomination. In the following, we denote by  the realization of an -nodes random graph such that the expected degree sequence  follows a power law with exponent  and an edge between two nodes  and  is created independently with probability proportional to ~\cite{Chung02theaverage}.
Some authors use the term \emph{scale-free} for such graphs. As this term is not defined unambiguously and may imply some other properties that we do not need here~\cite{li:scalefree}, we only use the term \emph{power law graph}.

\subsection{Success Ratio}

\bTheorem
For any connected graph , the embedding of  produced by PIE ensures the success of routing.
\eTheorem
\bProof
We need to show that PIE produces a greedy embedding.
As  is a subgraph of  that contains all the vertices of , it is clear that a greedy embedding of  is also a greedy embedding of . In addition, an isometric embedding of  is a greedy embedding of . It suffices therefore to show that PIE produces an isometric embedding of . 
For any node , write  its coordinates. For any two nodes , write  their least common ancestor in . 
Every node above  in  assigns the same coordinates to  and .  assigns coordinates with magnitude  to  and  to  in Eq.~(\ref{eq:coordAssign2}), with at least two of these coordinates, say  and , having opposite signs. Therefore,  s.t. , because  is the least common ancestor of  and . Moreover, as every node below  in  assigns coordinates with a magnitude strictly smaller than  to  and  to , .
\eProof
\subsection{Scalability}
\label{sec:analysis:scal}
We give a probabilistic upper bound on the number of coordinates that are required to describe the position of the nodes in large graphs. 


\bTheorem
\label{th:scal}
Let  be an -nodes realization of a power law graph with . We have:

almost surely.
\eTheorem
\bProof
Let  denote the root of . For any node , let  be the set of all the nodes above  in the unique path from  to  in . For each node , the embedding algorithm assigns  new coordinates to , where  denotes the degree of the node  (see Eq.~(\ref{eq:coordAssign2})). Obviously, we have that , where  is the maximum node degree in . In addition, as  is the union of the shortest paths from  to all the other nodes in , we have . We can therefore write the upper bound . We have:
\begin{itemize}
 \item ,
 \item  a.s. (\cite{Chung02theaverage} Theorem 4).
\end{itemize}
Relation (\ref{eq:scal}) follows.
\eProof



This means that, with probability one, PIE embeds  (and thus ) in .
If we consider the multi-tree case, each node belongs to  trees and thus PIE almost surely embeds  in .
Note that this bound holds for any graph with diameter . In particular, it holds for more classic random graphs (see for example~\cite{lu:diameter}).

\subsection{Performance}
As a node ``knows'' all of its neighbors, the algorithm finds all the 1-hop routes with stretch . Therefore, a route between a source  and a destination  may exhibit a stretch larger than  only if .

As the embedding is greedy, the longest possible route that the routing procedure can find has length . 
Therefore, the worst possible stretch is . Using Theorem 4 in~\cite{Chung02theaverage}, we have just shown the following:

\bTheorem
Consider  an -nodes power law graph with . 
The worst case stretch over all node pairs in  of a route found by PIE is  a.s.
\eTheorem

Note that this is a worst-case bound when only one tree is used.
We observe in the next section that both the average and the maximum stretch do not vary with .



\subsection{Protocol Overhead}
We provide a few key observations related to the protocol overhead:
\begin{itemize}
 \item Maintaining a tree requires that each node maintains a shortest path to that tree's root. If  trees are used,  such shortest paths need to be maintained.
 \item As a comparison, shortest paths algorithms typically rely on distributed protocols that are extremely similar to the spanning tree construction, building  spanning trees, one rooted at each node.
 \item All the control messages used by PIE have a size polylogarithmic in .
 \item More than network overhead, the re-computation of the routing table is perhaps the biggest burden of traditional algorithms. PIE only manipulates extremely small (polylogarithmic) routing state and removes this issue.
 \item For any pro-active routing protocol used in a dynamic topology, there exists a necessary tradeoff between the frequency with which control messages are sent, and the ability of the algorithm to successfully bring packets at destination at any time. We observe in the next section that, due to its geometrical nature, PIE is significantly more resilient to network failures than standard algorithms, and requires to re-compute its state less often.
\end{itemize}













\section{Evaluation}
\label{sec:perfeval}

\subsection{Settings}
We evaluate the behavior of PIE by using simulations on several topologies. 
We wrote our own simulator that we optimized to simulate routing on large graphs. We performed extensive simulations of PIE on several Internet-like graphs~\cite{shavitt:dimes, bu02, barabasi:scaling, bianconi:fit, inet}, on which the results were very similar. To spare space and to be able to explore more of the parameter space, we display results only for the two following topologies:
\begin{itemize}
 \item DIMES~\cite{shavitt:dimes} is a collaborative project that uses thousands of end-host agents to reproduce the topology of the Internet as accurately as possible. We use the AS-level dataset of March 2010. We consider all the links as symmetrical and remove the nodes that are not part of the main component, yielding a topology graph of 26,424 AS nodes. We measured  to be about  for this graph.


\item GLP (Generalized Linear Preference)~\cite{bu02} is a preferential attachment model that builds on the well-known scheme of Barab\'{a}si et al.~\cite{barabasi:scaling}.
This model allows us to tune  while producing graphs that 
exhibit some given properties such as characteristic path length, clustering 
coefficient or distribution of the highest degrees. The main benefit, of such a synthetic model over a fixed snapshot of the current Internet, is that it allows to generate larger graphs of varying size in order to study the scalability of PIE.

\end{itemize}


We consider weighted and unweighted graphs. The weights are drawn uniformly in [1,10], which can for instance be thought of as a function of a financial cost and a link capacity, and are comparable to the ISP's link weights range. Such a cost function naturally produces a large amount of violations of the triangle inequality in the graph, which are known to induce much distortion in Euclidean embeddings~\cite{lee:euclidean}.
For each setting, the statistics have been obtained by simulating routes between  distinct, randomly chosen source-destination pairs, over 10 independent experiments using different seeds.


\subsection{Results}



\subsubsection{Performance}
Figure~\ref{fig:perfDimes1} shows the CDFs of the path stretchs obtained on the DIMES topology, and Figure~\ref{fig:perfDimes2} shows the average stretch as a function of the number of locality levels. On both figures, the results are shown both with and without the source-routing extension introduced in Section~\ref{sec:asym}. Even when this extension is not used, the results are excellent: when only two trees are used, more than \% of the routes have stretch below . For , the average stretch is below  and, on the unweighted graph, \% or more of the routes found by PIE are the shortest. For , the average stretch is below . 
The maximum stretch observed over all the simulations on the unweighted graph was , which is indeed better than the best possible upper bound of  for compact routing schemes.
The source-routing extension further reduces the stretch: with this mechanism enabled, the average stretch is below  for both the weighted and unweighted graphs with . Unless otherwise specified, we present the remaining results \emph{without} the source-routing extension.






Figure~\ref{fig:perfGLP1} shows the evolution of the average stretch when the network grows, on unweighted GLP graphs with . Here and in the following experiments, the number of levels is \footnote{The exact function that we use is  (this function yields  for the values of  that we consider).}. Figure~\ref{fig:perfGLP2} shows the proportion of shortest paths found by PIE. It appears clearly that the good quality of the routes found by PIE scales perfectly with the size of the network: the average stretch always stays below 1.06 and the proportion of shortest routes above \%. The stretch even appears to slightly decrease with , this comes from our choice for the computation of .





\begin{figure*}
\centering
\begin{tabular}{c c}
PIE & PIE aided by source-routing\0.1em]
\includegraphics[width=.475\linewidth]{figures/cdf-without-best.pdf} &
\includegraphics[width=.475\linewidth]{figures/cdf-with-best.pdf}\\
\end{tabular}
\vspace{-1em}
\caption{DIMES topology. Empirical CDFs of the path stretchs for several values of  (the number of levels), with and without costs attributed to links. Left: results for PIE alone. Right: results for PIE aided by the optional source-routing mechanism.}
\vspace{-1.2em}
\label{fig:perfDimes1}
\end{figure*}

\begin{figure}
\centering
\vspace{0.03in}
\includegraphics[width=.94\linewidth]{figures/avgVsLevels.pdf}\vspace{-0.7em}
\caption{DIMES topology. Stretch as a function of the number of levels , with and without the optional source-routing ("s-r") mechanism. The mean and -th percentile are shown.}
\vspace{-1.2em}
\label{fig:perfDimes2}
\end{figure}

\begin{figure}
\centering
\vspace{0.03in}
\includegraphics[width=.94\linewidth]{figures/avgStretch.pdf}\vspace{-0.7em}
\caption{GLP topology. No source routing. Average stretch as a function of , for . For each value of , the -th percentile of the stretch was  or less.}
\vspace{-1.2em}
\label{fig:perfGLP1}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.94\linewidth]{figures/propShortest.pdf}\vspace{-0.7em}
\caption{GLP topology. No source routing. Proportion of shortest paths among all the paths found by PIE, as a function of , for .}
\vspace{-1.2em}
\label{fig:perfGLP2}
\end{figure}

\subsubsection{Scalability}
Figure~\ref{fig:scalGLP} shows the total number of coordinates required at each node by all the trees in the last scenario.
Also plotted is a (shifted) fit with a function  (note the logarithmic scale of the -axis). As predicted in Section~\ref{sec:analysis:scal}, the embedding of  trees by PIE produces  coordinates, hence meeting the scalability promises.

For the optional source-routing extension, Figure~\ref{fig:bif} shows the average and maximum number of bifurcations that need to be included in the packets' headers. We compute the average only over the routes that do benefit from using such a bifurcation set (it would be lower otherwise). 
Both the average and maximum sizes remain very low -- always  node IDs or less -- and, importantly, they do not grow with the network size. This essentially means that the source-routing extension only incurs a constant overhead in the packets' headers, and the benefits provided in term of routing stretch do not incur a scalability penalty.



\begin{figure}[t]
\centering
\includegraphics[width=.94\linewidth]{figures/dimensionality.pdf}\vspace{-1em}
\caption{GLP topology. Scalability of the total number of coordinates. The mininimum, maximum and average number of coordinates per node are shown. The curve above is a (shifted) plot of .}
\label{fig:scalGLP}
\end{figure}

\begin{figure}[t]
\centering
\includegraphics[width=.94\linewidth]{figures/bifurcation-scal.pdf}\vspace{-1em}
\caption{GLP topology. Size of the bifurcation set used for the optional source-routing mechanism. The average and maximum over  routes are shown.}
\vspace{-1.1em}
\label{fig:bif}
\end{figure}

\subsubsection{Resilience to Network Failures}

We consider a scenario in which some randomly chosen nodes fail. If a node has failed, its neighbors cannot send messages to it anymore. We evaluate the success ratio of the routing procedure, after some proportion of the nodes has failed, but before the algorithm has had time to react and adapt the routing tables.

Figure~\ref{fig:failuresDimes} shows the proportion of successful routes (success ratio) as a function of the percentage of nodes that have failed, on the unweighted DIMES topology. PIE maintains a significantly higher number of successful paths than traditional shortest paths algorithms. This is explained by considering the greedy nature of the forwarding procedure of PIE: forwarding to \emph{any} neighbor that is closer to the destination provides
route diversity gain, while schemes producing -to- mappings between destinations and next hops (including compact routing schemes), do not benefit from this route diversity.

When only one tree is used, PIE consistently reduces the number of routing failures by at least 20\%, and this proportion jumps to 50\% when .
Even in the extremely unlikely scenario where 10\% of the Internet fails, PIE could manage to maintain a high success ratio, about 90\%.
One direct consequence is that, for a given success ratio, PIE does not need to recompute its state as often as standard algorithms.


\begin{figure}
\centering
\includegraphics[width=.94\linewidth]{figures/hitratiosWithFailures.pdf}\vspace{-1em}
\caption{DIMES topology. Proportion of successful routes as a function of the percentage of failed nodes, for several values of .}
\vspace{-1.3em}
\label{fig:failuresDimes}
\end{figure}

\subsubsection{Comparison with the State of the Art}
We compare PIE with the \emph{general} compact routing scheme~\cite{thorup:compact} (that we denote by TZ). In addition we also compare it with the \emph{specialized} compact routing scheme~\cite{brady}, that is especially targeted for power law graphs (that we denote by BC). It is proposed in~\cite{brady} to combine TZ and BC in order to obtain a new scheme (that we denote by TZ+BC), which uses the best of the routes found by TZ and BC taken together. We recall that TZ achieves only  scalability for the routing table size, and BC requires a complete knowledge of the graph at all the nodes and is not translated in a distributed protocol. TZ+BC accumulates these two fundamental issues.

The authors of~\cite{brady} publicly provide the graphs that they used to obtain their simulation results with .
We can therefore run PIE (with and without the optional source-routing extension proposed in Section~\ref{sec:asym}) on these exact same graphs and compare the results. This is shown on Figure~\ref{fig:comp}. Critically, PIE performs significantly better than its less scalable, respectively centralized, counterparts. It even finds similar or better routes than the best routes found by TZ and BC taken together.

\begin{figure}
\centering
\includegraphics[width=.94\linewidth]{figures/comp-stretch_m_6.pdf}\vspace{-1em}
\caption{Comparison of the mean stretch obtained by PIE,~\cite{thorup:compact} (TZ) and~\cite{brady} (BC).
The values plotted for BC and TZ come from~\cite{brady}, as do the graphs used for the simulations. In this scenario, the number of nodes is , but the main connected components of the graphs have size .}
\vspace{-1.2em}
\label{fig:comp}
\end{figure}

\section{Discussion}
\label{sec:discussion}
While we demonstrate the scalability of our routing method from a
theoretical point of view and provide the corresponding distributed protocol,
translating this protocol to a deployment environment requires a couple
more steps.
In a single administrative domain, its deployment would be
easy, as ASs run their own routing protocol internally. Since some ASs
are relatively large, they would benefit from the scalability of our
scheme.
Similarly, our protocol would be practical over large overlay
networks, where the weights would be dependent on the target that the
overlay aims to achieve (for instance, minimize delay between overlay nodes).

For the wider Internet, the issue becomes to integrate our protocol
with BGP.
The simplest integration would be to build tree(s) of level  between the ASs and trees of higher levels within the ASs. Internally, the ease of geometric routing would prevail. Externally, BGP tables and the existing IP nomenclature could be kept. Such an approach would already benefit from the lightweight geometric coordinates for forwarding, but would still require  memory.




The best integration would thus be to modify BGP so as to fully take
advantage of PIE. While this is beyond the scope of this paper, we
contend that it is possible to achieve. As a simple example, consider four
ASs, AS1 through AS4, with AS1 and AS4 both being connected through
both AS2 and AS3. Assume that BGP is configured so as to prevent AS3
from being used as a transit AS between AS1 and AS4. Assume further
that, rather than using STP to create and propagate the coordinates,
we now use a BGP-like mechanism.

When AS3 receives the eBGP message from AS1 to create routing
coordinates, it propagates it internally, but not through its eBGP
connection to AS4. On the other hand, AS2 does according to its BGP
policy. Thus, traffic from AS1 to AS4 will see AS2 as in between them in the metric space,
and AS3 as in a wrong direction and routing will naturally go through
AS2. The weights between ASs can be built upon the BGP attributes
as well.
The fact that PIE adapts well to arbitrary link costs
provides good support to use it for traffic engineering.

This basic example shows that there is enough expressiveness in
creating the coordinates of PIE to satisfy some basic policy
mechanisms.

\section{Conclusion}
\label{sec:conclusion}


We have presented and evaluated PIE, a distributed protocol that produces a greedy embedding. It does so by isometrically embedding trees in non-Euclidean spaces of dimension . Each node in the graph belongs to  trees.
The greediness of the embedding allows the forwarding procedure to take any available shortcut off the trees while avoiding loops and guaranteeing the success of routing.
PIE typically relaxes the \emph{deterministic} guarantees provided by classic compact routing schemes, in order to be written as a distributed protocol. The bottomline of the good features of PIE is that these guarantees are now \emph{probabilistic}, satisfied \emph{with probability one} on the relevant categories of large graphs.


We have proved that PIE achieves a success ratio of 100\% on any graph, that it provides polylogarithmic scalability, and we have given a logarithmic upper bound on the path stretch. We have used large-scale simulation on synthetic and real-world topologies to observe that the stretch is independent of  and that it remains extremely low, typically lower than for centralized or less scalable state-of-the-art algorithms. In addition, we have proposed an optional source-aided routing mechanism that provides significant stretch improvement with no scalability penalty.



PIE comes in a clean-slate perspective. We briefly discussed the challenges related to any replacement of the existing protocols and gave indications that such a geometric scheme could be used with traffic engineering and policy routing, making this a direction worth exploring for future work.


We can draw a few orthogonal considerations from the good stretch performance obtained by PIE. It is 
a direct indicator of the self-similar tree-like structure of the Internet,
and it shows that the embedding has low distortion. It would thus probably suit well distance estimation tasks in the Internet, 
as it is required by many overlay and peer-to-peer applications.


\bibliographystyle{IEEEtran}
\bibliography{geobib}

\end{document}
