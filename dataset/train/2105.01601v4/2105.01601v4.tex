\begin{abstract}
Convolutional Neural Networks (CNNs) are the go-to model for computer vision.
Recently, attention-based networks, such as the Vision Transformer, have also become popular.
In this paper we show that while convolutions and attention are both sufficient for good performance, neither of them are necessary.
We present \emph{\fullname{}}, an architecture based exclusively on multi-layer perceptrons (MLPs).
\fullname{} contains two types of layers: one with MLPs applied independently to image patches (i.e.\,``mixing'' the per-location features), and one with MLPs applied across patches (i.e.\,``mixing'' spatial information).
When trained on large datasets, or with modern regularization schemes, \fullname{} attains competitive scores on image classification benchmarks, with  pre-training and inference cost comparable to state-of-the-art models.
We hope that these results spark further research beyond the realms of well established CNNs and Transformers.\footnote{\fullname{} code will be available at 
\codeurl{}
}
\end{abstract}

\section{Introduction}

As the history of computer vision demonstrates, the availability of larger datasets coupled with increased computational capacity often leads to a paradigm shift.
While Convolutional Neural Networks (CNNs) have been the de-facto standard for computer vision, recently Vision Transformers~\citep{Dosovitskiy2021} (ViT), an alternative based on self-attention layers, attained state-of-the-art performance.
ViT continues the long-lasting trend of removing hand-crafted visual features and inductive biases from models and relies further on learning from raw data.

We propose the \emph{\fullname{}} architecture (or ``\name{}'' for short), a competitive but conceptually and technically simple alternative, that does not use convolutions or self-attention.
Instead, \name{}'s architecture is based entirely on multi-layer perceptrons (MLPs) that are repeatedly applied across either spatial locations or feature channels.
\name{} relies only on basic matrix multiplication routines, changes to data layout (reshapes and transpositions), and scalar nonlinearities.
 
Figure~\ref{fig:architecture} depicts the macro-structure of \name{}. 
It accepts a sequence of linearly projected image patches (also referred to as \emph{tokens}) shaped as a ``patches\,\,channels'' table as an input, and maintains this dimensionality.
\name{} makes use of two types of MLP layers:  \emph{channel-mixing MLPs} and \emph{token-mixing MLPs}. 
The channel-mixing MLPs allow communication between different channels; they operate on each token independently and take individual rows of the table as inputs.
The token-mixing MLPs allow communication between different spatial locations (tokens); they operate on each channel independently and take individual columns of the table as inputs.
These two types of layers are interleaved to enable interaction of both input dimensions.

In the extreme case, our architecture can be seen as a very special CNN, which uses 11 convolutions for \emph{channel mixing}, and single-channel depth-wise convolutions of a full receptive field and parameter sharing for \emph{token mixing}.
However, the converse is not true as typical CNNs are not special cases of \name{}. Furthermore, a convolution is more complex than the plain matrix multiplication in MLPs as it requires an additional costly reduction to matrix multiplication and/or specialized implementation. 

Despite its simplicity, \name{} attains competitive results.
When pre-trained on large datasets (i.e.,  100M images), it reaches near state-of-the-art performance, previously claimed by CNNs and Transformers, in terms of the accuracy/cost trade-off.
This includes 87.94\% top-1 validation accuracy on ILSVRC2012 ``ImageNet''~\citep{deng2009-imagenet}.
When pre-trained on data of more modest scale (i.e., 1--10M images), coupled with modern regularization techniques~\cite{deit,rw2019timm}, \name{} also achieves strong performance.
However, similar to ViT, it falls slightly short of specialized CNN architectures.

\section{\name{} Architecture}
\label{sec:architecture}
\begin{figure}[tb]
    \centering
    \includegraphics[width=.85\linewidth]{pics/Mixer.pdf}
    \caption{
     \fullname{} consists of per-patch linear embeddings, \name{} layers, and a classifier head.
     \name{} layers contain one token-mixing MLP and one channel-mixing MLP, each consisting of two fully-connected layers and a GELU nonlinearity.
     Other components include: skip-connections, dropout, and layer norm on the channels.
    }
    \vspace{-.2cm}
  \label{fig:architecture}
\end{figure}


Modern deep vision architectures consist of layers that mix features (i) at a given spatial location, (ii) between different spatial locations, or both at once.
In CNNs, (ii) is implemented with  convolutions (for ) and pooling.
Neurons in deeper layers have a larger receptive field~\citep{araujo2019computing,luo2017understanding}.
At the same time, 11 convolutions also perform (i), and larger kernels perform both (i) and (ii).
In~Vision Transformers and other attention-based architectures, self-attention layers allow both (i) and (ii) and the MLP-blocks perform (i).
The idea behind the \name{} architecture is to clearly separate the per-location (\emph{channel-mixing}) operations (i) and cross-location (\emph{token-mixing}) operations (ii).
Both operations are implemented with MLPs.
Figure~\ref{fig:architecture} summarizes the architecture. 

\name{} takes as input a sequence of  non-overlapping image patches, each one projected to a desired \emph{hidden dimension} .
This results in a two-dimensional real-valued input table, .
If the original input image has resolution ,
and each patch has resolution ,
then the number of patches is .
All patches are linearly projected with the \emph{same} projection matrix.
\name{} consists of multiple layers of identical size, and each layer consists of two MLP blocks.
The first one is the \emph{token-mixing} MLP: it acts on columns of  (i.e.\,it is applied to a transposed input table ), maps , and is shared across all columns.
The second one is the \emph{channel-mixing} MLP: it acts on rows of , maps , and is shared across all rows.
Each MLP block contains two fully-connected layers and a nonlinearity applied independently to each row of its input data tensor. 
\name{} layers can be written as follows (omitting layer indices):

Here  is an element-wise nonlinearity (GELU~\cite{hendrycks2016gelu}).
 and  are tunable hidden widths in the token-mixing and channel-mixing MLPs, respectively.
Note that  is selected independently of the number of input patches.
Therefore, the computational complexity of the network is linear in the number of input patches, unlike ViT whose complexity is quadratic.
Since  is independent of the patch size, the overall complexity is linear in the number of pixels in the image, as for a typical CNN.

As mentioned above, the \emph{same} channel-mixing MLP (token-mixing MLP) is applied to every row (column) of~.
Tying the parameters of the channel-mixing MLPs (within each layer) is a natural choice---it provides positional invariance, a prominent feature of convolutions.
However, tying  parameters across channels is much less common.
For example, separable convolutions \cite{chollet2017xception,Sifre2014phd}, used in some CNNs, apply convolutions to each channel independently of the other channels.
However, in separable convolutions, a different convolutional
kernel is applied to each channel unlike the token-mixing MLPs in \name{} that share the same kernel (of full receptive field) for all of the channels.
The parameter tying prevents the architecture from growing too fast when increasing the hidden dimension  or the sequence length  and leads to significant memory savings.
Surprisingly, this choice does not affect the empirical performance, see Supplementary~\ref{appendix:did-not-work}.

Each layer in \name{} (except for the initial patch projection layer) takes an input of the same size.
This ``isotropic'' design is most similar to Transformers, or deep RNNs in other domains, that also use a fixed width.
This is unlike most CNNs, which have a \emph{pyramidal} structure: deeper layers have a lower resolution input, but more channels.
Note that while these are the typical designs, other combinations exist, such as isotropic ResNets~\citep{Sandler2019} and pyramidal ViTs~\citep{wang2021pyramid}.

Aside from the MLP layers, \name{} uses other standard architectural components: skip-con\-nec\-tions~\cite{he2016deep} and layer normalization~\cite{ba2016layer}.
Unlike ViTs, \name{} does not use position embeddings because the token-mixing MLPs are sensitive to the order of the input tokens.
Finally, \name{} uses a standard classification head with the global average pooling layer followed by a linear classifier. 
Overall, the architecture can be written compactly in JAX/Flax, the code is given in Supplementary~\ref{appendix:sec:code}.


\section{Experiments}
\label{sec:experiments}
We evaluate the performance of \fullname{} models, pre-trained with medium- to large-scale datasets,
on a range of small and mid-sized downstream classification tasks.
We are interested in three primary quantities:
(1)~Accuracy on the downstream task;
(2)~\emph{Total} computational cost of pre-training, which is important when training the model from scratch on the upstream dataset;
(3)~Test-time throughput, which is important to the practitioner.
Our goal is not to demonstrate state-of-the-art results, but to show that, remarkably, a simple MLP-based model is competitive with today's best convolutional and attention-based models.

{\bf Downstream tasks\;\;}
We use popular downstream tasks such as ILSVRC2012 ``ImageNet'' (1.3M training examples, 1k classes) with the original validation labels~\citep{deng2009-imagenet} and cleaned-up ReaL labels~\citep{beyer2020-imagenet},
CIFAR-10/100 (50k examples, 10/100 classes)~\citep{Krizhevsky2009-cifar},
Oxford-IIIT Pets (3.7k examples, 36 classes)~\citep{parkhi2012-pets},
and Oxford Flowers-102 (2k examples, 102 classes)~\citep{Nilsback2008-flowers}.
We also use the Visual Task Adaptation Benchmark (VTAB-1k), which consists of 19 diverse datasets, each with 1k training examples~\citep{vtab}.

{\bf Pre-training\;\;}
We follow the standard transfer learning setup: pre-training followed by fine-tuning on the downstream tasks.
We pre-train our models on two public datasets: 
ILSVRC2021~ImageNet, and ImageNet-21k, a superset of ILSVRC2012 that contains 21k classes and 14M images~\cite{deng2009-imagenet}.
To assess performance at 
larger scale, we also train on JFT-300M, a proprietary dataset with 300M examples and 18k classes~\citep{sun2017-jft}.
We de-duplicate all pre-training datasets with respect to the test sets of the downstream tasks as done in~\citet{Dosovitskiy2021,kolesnikov2020-bit}.
We pre-train all models at resolution 224
using Adam with , ,
linear learning rate warmup of 10k steps and linear decay,
batch size 4\,096,
weight decay,
and gradient clipping at global norm 1.
For JFT-300M, we pre-process images by applying the cropping technique from~\citet{szegedy15inception} in addition to random horizontal flipping.
For ImageNet and ImageNet-21k, we employ additional data augmentation and regularization techniques. In particular, we use RandAugment~\cite{cubuk2020rand}, mixup~\cite{zhang2018mixup}, dropout~\cite{srivastava14dropout}, and stochastic depth~\cite{huang2016deep}. 
This set of techniques was inspired by the \emph{timm library}~\cite{rw2019timm} and~\citet{touvron2019}. 
More details on these hyperparameters are provided in Supplementary~\ref{appendix:sec:reg}.

{\bf Fine-tuning\;\;}
We fine-tune using momentum SGD, batch size 512,
gradient clipping at global norm~1,
and a cosine learning rate schedule with a linear warmup. 
We do not use weight decay when fine-tuning.
Following common practice \cite{kolesnikov2020-bit,touvron2019}, we also fine-tune at higher resolutions with respect to those used during pre-training.
Since we keep the patch resolution fixed, this increases the number of input patches (say from  to ) and thus requires modifying the shape of \name{}'s token-mixing MLP blocks.
Formally, the input in Eq.\,\eqref{eq:channel-wise-mlp} is left-multiplied by a weight matrix  and this operation has to be adjusted when changing the input dimension .
For this, we increase the hidden layer width from  to  in proportion to the number of patches and initialize the (now larger) weight matrix  with a block-diagonal matrix containing copies of  on its diagonal. 
This particular scheme only allows for  with .
See Supplementary~\ref{appendix:sec:fine-tuning} for further details.
On the VTAB-1k benchmark we follow the BiT-HyperRule~\cite{kolesnikov2020-bit} and fine-tune \name{} models at resolution 224 and 448 on the datasets with small and large input images respectively.

{\bf Metrics\;\;}
We evaluate the trade-off between the model's
computational cost and quality.
For the former we compute two metrics:
(1)~Total pre-training time on TPU-v3 accelerators, which combines three relevant factors: the theoretical FLOPs for each training setup, the computational efficiency on the relevant training hardware, and the data efficiency.
(2)~Throughput in images/sec/core on TPU-v3. Since models of different sizes may benefit from different batch sizes, we sweep the batch sizes
and report the highest throughput for each model.
For model quality, we focus on top-1 downstream accuracy after fine-tuning.
On two occasions (Figure~\ref{fig:compute-frontier}, right and Figure~\ref{fig:input-pp-ablation}), where fine-tuning all of the models is too costly, we report the few-shot accuracies obtained by solving the -regularized linear regression problem between the frozen learned representations of images and the labels.

\newcommand{\pf}{\phantom{5}}

\begin{table}[tb]
  \caption{Specifications of the \name{} architectures.
  The ``B'', ``L'', and ``H'' (base, large, and huge) model scales follow~\citet{Dosovitskiy2021}.
  A brief notation ``B/16'' means the model of base scale with patches of resolution 1616.
  The number of parameters is reported for an input resolution of 224 and does not include the weights of the classifier head.
  }
  \medskip
  \label{table:architecture-configs}
  \centering
  \small
  \begin{tabular}{@{}lccccccc@{}}
    \toprule
    Specification & S/32 & S/16 & B/32 & B/16 & L/32 & L/16 & H/14\\
    \cmidrule{1-8}
    Number of layers & 8 & 8 & 12 & 12 & 24 & 24 & 32\\
    Patch resolution  & 3232 & 1616 & 3232 & 1616 & 3232 & 1616 & 1414\\
    Hidden size  & 512 & 512 & 768 & 768 & 1024 & 1024 & 1280\\
    Sequence length  & 49 & 196 & 49 & 196 & 49 & 196 & 256\\
    MLP dimension  & 2048 & 2048 & 3072 & 3072 & 4096 & 4096 & 5120\\
    MLP dimension  & 256 & 256 & 384 & 384 & 512 & 512 & 640\\
    Parameters (M) & 19 & 18 & 60 & 59 & 206 & 207 & 431\\
    \bottomrule
  \end{tabular}
  \vspace{-.2cm} \end{table}

{\bf Models\;\;}
We compare various configurations of \name{}, summarized in Table~\ref{table:architecture-configs}, to the most recent, state-of-the-art, CNNs and attention-based models.
In all the figures and tables, 
the MLP-based \name{} models are marked with pink~(\MDot{}),
convolution-based models with yellow~(\CDot{}), 
and attention-based models with blue~(\ADot{}).
The Vision Transformers (ViTs) have model scales and patch resolutions similar to \name{}.
HaloNets are attention-based models that use a ResNet-like structure with local self-attention layers instead of 33 convolutions~\citep{vaswani2021scaling}.
We focus on the particularly efficient ``HaloNet-H4 (base 128, Conv-12)'' model, which is a hybrid variant of the wider HaloNet-H4 architecture with some of the self-attention layers replaced by convolutions.
Note, we mark HaloNets with both attention and convolutions with blue~(\ADot{}).
Big Transfer (BiT)~\citep{kolesnikov2020-bit} models are ResNets optimized for transfer learning.
NFNets~\citep{brock2021high} are normalizer-free ResNets with several optimizations for ImageNet classification.
We consider the NFNet-F4+ model variant.
We consider MPL~\citep{pham2020meta} and ALIGN~\citep{jia2021scaling} for EfficientNet architectures. MPL is pre-trained at very large-scale on JFT-300M images, using meta-pseudo labelling from ImageNet instead of the original labels. We compare to the EfficientNet-B6-Wide model variant. ALIGN pre-train image encoder and language encoder on noisy web image text pairs in a contrastive way. We compare to their best EfficientNet-L2 image encoder.

\begin{table}[tb]
  \caption{
  Transfer performance, inference throughput, and training cost. 
  The rows are sorted by inference throughput (fifth column).
  \name{} has comparable transfer accuracy to state-of-the-art models with similar cost.
  The \name{} models are fine-tuned at resolution 448. \name{} performance numbers are averaged over three fine-tuning runs and standard deviations are smaller than .
  }
  \medskip
  \label{table:main-results-sota}
  \centering
  \small
  \resizebox{.8\textwidth}{!}{
  \begin{tabular}{@{}p{2.6cm}cccccc@{}}
    \toprule
    & ImNet & ReaL & Avg 5 & VTAB-1k & Throughput & TPUv3\\
    & top-1 & top-1 & top-1 & 19 tasks & {\small img/sec/core} & {\small core-days}\\
    \midrule \multicolumn{7}{c}{Pre-trained on ImageNet-21k (public)}\\
    \cmidrule{1-7}
    \ADot{} HaloNet \cite{vaswani2021scaling}  & 85.8\pf & --- & --- & --- & 120 & 0.10k\\
    \MDot{} \name{}-L/16  & 84.15 & 87.86 & 93.91 & 74.95 & 105 & 0.41k\\
    \ADot{} ViT-L/16 \cite{Dosovitskiy2021} & 85.30 & 88.62 & 94.39 & 72.72 & \pf32 & 0.18k\\
    \CDot{} BiT-R152x4 \cite{kolesnikov2020-bit} & 85.39 & --- & 94.04 & 70.64 & \pf26 & 0.94k\\
    \midrule \multicolumn{7}{c}{Pre-trained on JFT-300M (proprietary)}\\
    \cmidrule{1-7}
    \CDot{} NFNet-F4+ \cite{brock2021high} & 89.2\pf & --- & --- & --- & \pf46 & 1.86k\\
    \MDot{} \name{}-H/14  & 87.94 & 90.18 & 95.71 & 75.33 & \pf40 & 1.01k\\
    \CDot{} BiT-R152x4 \cite{kolesnikov2020-bit} & 87.54 & 90.54 & 95.33 & 76.29 & \pf26 & 9.9{0}k\\
    \ADot{} ViT-H/14 \cite{Dosovitskiy2021}  & 88.55 & 90.72 & 95.97 & 77.63 & \pf15 & 2.30k\\
    \midrule \multicolumn{7}{c}{Pre-trained on unlabelled or weakly labelled data (proprietary)}\\
    \cmidrule{1-7}
    \CDot{} MPL \cite{pham2020meta} & 90.0\pf & 91.12 & --- & --- & --- & \hspace{-1ex}20.48k\\
    \CDot{} ALIGN \cite{jia2021scaling} & 88.64 & --- & --- & 79.99 & 15 & \hspace{-1ex}14.82k\\
    \bottomrule
\end{tabular}}
  \vspace{-.2cm}
\end{table}


\subsection{Main results}
\label{subsec:main-results}

Table~\ref{table:main-results-sota} presents comparison of the largest \name{} models to state-of-the-art models from the literature.
``ImNet'' and ``ReaL'' columns refer to the original ImageNet validation~\citep{deng2009-imagenet} and cleaned-up ReaL~\citep{beyer2020-imagenet} labels.
``Avg.\,5'' stands for the average performance across all five downstream tasks (ImageNet, CIFAR-10, CIFAR-100, Pets, Flowers).
Figure~\ref{fig:main-sota-and-jft-fractions}~(left) visualizes the accuracy-compute~frontier.
When pre-trained on ImageNet-21k with additional regularization, \name{} achieves an overall strong performance (84.15\% top-1 on ImageNet), although slightly inferior to other models\footnote{
In Table~\ref{table:main-results-sota} we consider the highest accuracy models in each class for each pre-training dataset.
These all use the large resolutions (448 and above).
However, fine-tuning at smaller resolution can lead to substantial improvements in the test-time throughput, with often only a small accuracy penalty.
For instance, when pre-training on ImageNet-21k,
the \name{}-L/16 model fine-tuned at 224 resolution achieves 82.84\% ImageNet top-1 accuracy at throughput 420 img/sec/core;
the ViT-L/16 model fine-tuned at 384 resolution achieves 85.15\% at 80 img/sec/core \cite{Dosovitskiy2021};
and HaloNet fine-tuned at 384 resolution achieves 85.5\% at 258 img/sec/core \cite{vaswani2021scaling}.
}.
Regularization in this scenario is necessary and \name{} overfits without it, which is consistent with similar observations for ViT \cite{Dosovitskiy2021}.
The same conclusion holds when training \name{} from random initialization on ImageNet (see Section~\ref{sec:model-scale}):
Mixer-B/16 attains a reasonable score of 76.4\% at resolution 224, but tends to overfit.
This score is similar to a vanilla ResNet50, but behind state-of-the-art CNNs/hybrids for the ImageNet ``from scratch'' setting, e.g.\,84.7\% BotNet~\cite{srinivas2021bottleneck} and 86.5\%
NFNet~\cite{brock2021high}.

When the size of the upstream dataset increases, \name{}'s performance improves significantly.
In~particular, \name{}-H/14 achieves 87.94\% top-1 accuracy on ImageNet, which is 0.5\% better than BiT-ResNet152x4 and only 0.5\% lower than ViT-H/14.
Remarkably, \name{}-H/14 runs 2.5 times faster than ViT-H/14 and almost twice as fast as BiT. 
Overall, Figure~\ref{fig:main-sota-and-jft-fractions}~(left) supports our main claim that in terms of the accuracy-compute trade-off \name{} is competitive with more conventional neural network architectures. The figure also demonstrates a clear correlation between the total pre-training cost and the downstream accuracy, even across architecture classes.

BiT-ResNet152x4 in the table are pre-trained using SGD with momentum and a long schedule.
Since Adam tends to converge faster, we complete the picture in Figure~\ref{fig:main-sota-and-jft-fractions}~(left) with the BiT-R200x3 model from \citet{Dosovitskiy2021} pre-trained on JFT-300M using Adam.
This ResNet has a slightly lower accuracy, but considerably lower pre-training compute.
Finally, the results of smaller ViT-L/16 and \name{}-L/16 models are also reported in this figure.

\begin{figure}[tb]
\centering
\begin{subfigure}{.328\textwidth}
  \centering \includegraphics[width=0.965\linewidth]{pics/sota_frontier.pdf}
\end{subfigure}\begin{subfigure}{.51\textwidth}
  \centering
  \includegraphics[width=1.0\linewidth]{pics/data_frac_5shot.pdf}
\end{subfigure}
\caption{
  {\bf Left:}~ImageNet accuracy/training cost Pareto frontier (dashed line) for the SOTA models 
  in
  Table~\ref{table:main-results-sota}.
  Models are pre-trained on ImageNet-21k, or JFT (labelled, or pseudo-labelled for MPL), or 
  web image text pairs.
  \name{} is as good as these extremely performant ResNets, ViTs, and hybrid models,
  and sits on frontier with HaloNet, ViT, NFNet, and MPL.
  {\bf Right:}~\name{} (solid) catches or exceeds BiT (dotted) and ViT (dashed) as the data size grows.
  Every point on a curve uses the same pre-training compute; they correspond to pre-training on 3\%, 10\%, 30\%, and 100\% of JFT-300M for 233, 70, 23, and 7 epochs, respectively.
  Additional points at 3B correspond to pre-training on an even larger JFT-3B dataset for the same number of total steps.
  \name{} improves more rapidly with data than ResNets, or even ViT.
  The gap between large \name{} and ViT models shrinks.
}
\vspace{-.1cm}
\label{fig:main-sota-and-jft-fractions}
\end{figure}

\begin{figure}[tb]
    \centering
    \includegraphics[width=.9\linewidth]{pics/finetune_vs_compute.pdf}
  \caption{
  The role of the model scale.
  ImageNet validation top-1 accuracy vs.\ total pre-training compute~({\bf left}) and throughput~({\bf right}) of ViT, BiT, and \name{} models at various scales.
  All models are pre-trained on JFT-300M and fine-tuned at resolution 224, which is lower than in Figure~\ref{fig:main-sota-and-jft-fractions}~(left).}
  \label{fig:compute-frontier}
  \vspace{-.4cm}
\end{figure}

\subsection{The role of the model scale}
\label{sec:model-scale}
The results outlined in the previous section focus on (large) models at the upper end of the compute spectrum.
We now turn our attention to smaller \name{} models.

We may scale the model in two independent ways: 
(1)~Increasing the model size (number of layers, hidden dimension, MLP widths) when pre-training;
(2)~Increasing the input image resolution when fine-tuning.
While the former affects both pre-training compute and test-time throughput, the latter only affects the throughput.
Unless stated otherwise, we fine-tune at resolution 224.

\begin{table}[tb]
  \caption{
  Performance of \name{} and other models from the literature across various model and pre-training dataset scales.
  ``Avg.\,5'' denotes the average performance across five downstream tasks.
  \name{} and ViT models are averaged over three fine-tuning runs, standard deviations are smaller than~.
  ()~Extrapolated from the numbers reported for the same models pre-trained on JFT-300M without extra regularization.
  (\Telefon) Numbers provided by authors of~\citet{Dosovitskiy2021} through personal communication.
  Rows are sorted by throughput.
  }
  \medskip
  \label{table:main-results-appendix}
  \centering
  \small
  \resizebox{.8\textwidth}{!}{
\begin{tabular}{@{}lccccc@{\;}S[table-number-alignment=right,group-digits=false,mode=text]@{\;}S[table-number-alignment=left,mode=text]@{}}
    \toprule
    & Image & Pre-Train & ImNet & ReaL & Avg.\,5 & {Throughput} & {TPUv3}\\
    & size & Epochs & top-1& top-1 & top-1 & {(img/sec/core)} & {~core-days~}\\
    \midrule \multicolumn{8}{c}{Pre-trained on ImageNet (with extra regularization)}\\
    \cmidrule{1-8}
    \MDot{} \name{}-B/16 & 224 & 300 & 76.44 & 82.36 & 88.33 & 1384 & 0.01k\\
    \ADot{} ViT-B/16 (\small{\Telefon}) & 224 & 300 & 79.67 & 84.97 & 90.79 & 861 & 0.02k\\
    \MDot{} \name{}-L/16 & 224 & 300 & 71.76 & 77.08 & 87.25 & 419 & 0.04k\\
    \ADot{} ViT-L/16 (\small{\Telefon})  & 224 & 300 & 76.11 & 80.93 & 89.66 & 280 & 0.05k\\
    \midrule \multicolumn{8}{c}{Pre-trained on ImageNet-21k (with extra regularization)}\\
    \cmidrule{1-8}
    \MDot{} \name{}-B/16 & 224 & 300 & 80.64 & 85.80 & 92.50 & 1384 & 0.15k\\
    \ADot{} ViT-B/16 (\small{\Telefon}) & 224 & 300 & 84.59 & 88.93 & 94.16 & 861 & 0.18k\\
    \MDot{} \name{}-L/16 & 224 & 300 & 82.89 & 87.54 & 93.63 & 419 & 0.41k\\
    \ADot{} ViT-L/16 (\small{\Telefon}) & 224 & 300 & 84.46 & 88.35 & 94.49 & 280 & 0.55k\\
    \MDot{} \name{}-L/16 & 448 & 300 & 83.91 & 87.75 & 93.86 & 105 & 0.41k\\
    \midrule \multicolumn{8}{c}{Pre-trained on JFT-300M}\\
    \cmidrule{1-8}
    \MDot{} \name{}-S/32 & 224 & \pf5 & 68.70 & 75.83 & 87.13 & 11489 & 0.01k\\
    \MDot{} \name{}-B/32 & 224 & \pf7 & 75.53 & 81.94 & 90.99 & 4208 & 0.05k\\
    \MDot{} \name{}-S/16 & 224 & \pf5 & 73.83 & 80.60 & 89.50 & 3994 & 0.03k\\
    \CDot{} BiT-R50x1  & 224 & \pf7 & 73.69 & 81.92 & --- & 2159 & 0.08k\\
    \MDot{} \name{}-B/16 & 224 & \pf7 & 80.00 & 85.56 & 92.60 & 1384 & 0.08k\\
    \MDot{} \name{}-L/32 & 224 & \pf7 & 80.67 & 85.62 & 93.24 & 1314 & 0.12k\\
    \CDot{} BiT-R152x1 & 224 & \pf7 & 79.12 & 86.12 & --- & 932 & 0.14k\\
    \CDot{} BiT-R50x2 & 224 & \pf7 & 78.92 & 86.06 & --- & 890 & 0.14k\\
    \CDot{} BiT-R152x2 & 224 & 14 & 83.34 & 88.90 & --- & 356 & 0.58k\\
    \MDot{} \name{}-L/16 & 224 & \pf7 & 84.05 & 88.14 & 94.51 & 419 & 0.23k\\
    \MDot{} \name{}-L/16 & 224 & 14 & 84.82 & 88.48 & 94.77 & 419 & 0.45k\\
    \ADot{} ViT-L/16 & 224 & 14 & 85.63 & 89.16 & 95.21 & 280 & 0.65k\\
    \MDot{} \name{}-H/14 & 224 & 14 & 86.32 & 89.14 & 95.49 & 194 & 1.01k\\
    \CDot{} BiT-R200x3 & 224 & 14 & 84.73 & 89.58 & --- & 141 & 1.78k\\
    \MDot{} \name{}-L/16 & 448 & 14 & 86.78 & 89.72 & 95.13 & 105 & 0.45k\\
    \ADot{} ViT-H/14 & 224 & 14 & 86.65 & 89.56 & 95.57 & 87 & 2.30k\\
\ADot{} ViT-L/16 \cite{Dosovitskiy2021} & 512 & 14 & 87.76 & 90.54 & 95.63 & 32 & 0.65k\\
\bottomrule
  \end{tabular}}
  \vspace{-.4cm}
\end{table}

We compare various configurations of \name{} (see Table~\ref{table:architecture-configs}) to ViT models of similar scales and BiT models pre-trained with Adam. The results are summarized in Table~\ref{table:main-results-appendix} and Figure~\ref{fig:compute-frontier}.
When trained from scratch on ImageNet, \name{}-B/16 achieves a reasonable top-1 accuracy of 76.44\%. This is 3\% behind the ViT-B/16 model. The training curves (not reported) reveal that both models achieve very similar values of the training loss.
In other words, \name{}-B/16 overfits more than ViT-B/16.
For the \name{}-L/16 and ViT-L/16 models this difference is even more pronounced.

As the pre-training dataset grows, \name{}'s performance steadily improves.
Remarkably, \name{}-H/14 pre-trained on JFT-300M and fine-tuned at 224 resolution is only 0.3\% behind ViT-H/14 on ImageNet whilst running 2.2 times faster.
Figure~\ref{fig:compute-frontier} clearly demonstrates that although \name{} is slightly below the frontier on the lower end of model scales, it sits confidently on the frontier at the high end. 

\subsection{The role of the pre-training dataset size}

The results presented thus far demonstrate that pre-training on larger datasets significantly improves \name{}'s performance. Here, we study this effect in more detail.

To study \name{}'s ability to make use of the growing number of training examples we pre-train \name{}-B/32, \name{}-L/32, and \name{}-L/16 models on random subsets of JFT-300M containing 3\%, 10\%, 30\% and 100\% of all the training examples for 233, 70, 23, and 7 epochs. Thus, every model is pre-trained for the same number of total steps.
We also pre-train \name{}-L/16 model on an even larger JFT-3B dataset \cite{vitg} containing roughly 3B images with 30k classes for the same number of total steps. While not strictly comparable, this allows us to further extrapolate the effect of scale.
We use the linear 5-shot top-1 accuracy on ImageNet as a proxy for transfer quality.
For every pre-training run we perform early stopping based on the best upstream validation performance.
Results are reported in Figure~\ref{fig:main-sota-and-jft-fractions}~(right), where we also include ViT-B/32, ViT-L/32, ViT-L/16, and BiT-R152x2 models. 

When pre-trained on the smallest subset of JFT-300M, all \name{} models strongly overfit. 
BiT models also overfit, but to a lesser extent, possibly due to the strong inductive biases associated with the convolutions.
As the dataset increases, the performance of both \name{}-L/32 and \name{}-L/16 grows faster than BiT; \name{}-L/16 keeps improving, while the BiT model plateaus.

The same conclusions hold for ViT, consistent with \citet{Dosovitskiy2021}. However, the relative improvement of larger \name{} models are even more pronounced.
The performance gap between \name{}-L/16 and ViT-L/16 shrinks with data scale.
It appears that \name{} benefits from the growing
dataset size even more than ViT. 
One could speculate and explain it again with the difference in inductive biases:
self-attention layers in ViT lead to certain properties of the learned functions that are \emph{less compatible} with the true underlying distribution than those discovered with \name{} architecture.

\begin{figure}[tb]
\centering
\includegraphics[width=.27\linewidth]{pics/imagenet_original.pdf}
\includegraphics[width=.27\linewidth]{pics/imagenet_shuffled_patches_16x16.pdf}
\includegraphics[width=.27\linewidth]{pics/imagenet_shuffled_global_16x16.pdf}\vspace{.15cm}\\
\includegraphics[width=.8\linewidth]{pics/shuffle.pdf}
\vspace{-.2cm}
\caption{
    {\bf Top:} 
    Input examples from ImageNet before permuting the contents (left);
    after shuffling the  patches and pixels within the patches (center);
    after shuffling pixels globally (right).
    {\bf Bottom:}  
    \name{}-B/16 (left) and ResNet50x1 (right) trained with three corresponding input pipelines.
}
\label{fig:input-pp-ablation}
\end{figure}

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.3\linewidth]{pics/weightvisualization_b16_block0.pdf}
    \hspace{.1cm}
    \includegraphics[width=0.3\linewidth]{pics/weightvisualization_b16_block1.pdf}
    \hspace{.1cm}
    \includegraphics[width=0.3\linewidth]{pics/weightvisualization_b16_block2.pdf} 
    \caption{
     Hidden units in the first ({\bf left}), second ({\bf center}), and third ({\bf right}) token-mixing MLPs of a \name{}-B/16 model trained on JFT-300M.
     Each unit has  weights, one for each of the  incoming patches. 
     We pair the units to highlight the emergence of kernels of opposing phase.
     Pairs are sorted 
     by filter frequency.
     In contrast to the kernels of convolutional filters, where each weight corresponds to one pixel in the input image, one weight in any plot from the left column corresponds to a particular  patch of the input image. 
     Complete plots in Supplementary~\ref{appendix:sec:weightvisualizations}.
    }
  \label{fig:weight-plots}
  \vspace{-.4cm}
\end{figure}

\subsection{Invariance to input permutations}
In this section, we study the difference between inductive biases of \name{} and CNN architectures.
Specifically, we train \name{}-B/16 and ResNet50x1 models on JFT-300M following the pre-training setup described in Section~\ref{sec:experiments} and using one of two different input transformations:
(1)~Shuffle the order of 1616 patches and permute pixels within each patch with a shared permutation;
(2)~Permute the pixels globally in the entire image.
Same permutation is used across all images.
We report the linear 5-shot top-1 accuracy of the trained models on ImageNet in Figure~\ref{fig:input-pp-ablation}~(bottom).
Some original images along with their two transformed versions appear in Figure~\ref{fig:input-pp-ablation}~(top).
As could be expected, \name{} is invariant to the order of patches and pixels within the patches (the blue and green curves match perfectly).
On the other hand, ResNet's strong inductive bias relies on a particular order of pixels within an image and its performance drops significantly when the patches are permuted.
Remarkably, when globally permuting the pixels, \name{}'s performance drops much less (45\% drop) compared to the ResNet (75\% drop).

\subsection{Visualization}
It is commonly observed that the first layers of CNNs tend to learn Gabor-like detectors that act on pixels in local regions of the image.
In contrast, \name{} allows for global information exchange in the token-mixing MLPs, which begs the question whether it processes information in a similar fashion.
Figure~\ref{fig:weight-plots} shows hidden units of the first three token-mixing MLPs of \name{} trained on JFT-300M. 
Recall that the token-mixing MLPs allow global communication between different spatial locations. 
Some of the learned features operate on the entire image, while others operate on smaller regions. 
Deeper layers appear to have no clearly identifiable structure. 
Similar to CNNs, we observe many pairs of 
feature detectors with opposite phases~\cite{shang2016crelu}.
The structure of learned units depends on the hyperparameters.
Plots for the first embedding layer appear in Figure~\ref{appendix:fig:embedding-plots} of Supplementary~\ref{appendix:sec:weightvisualizations}.

\section{Related work}

\fullname{} is a new architecture for computer vision that differs from previous successful architectures because it uses neither convolutional nor self-attention layers. Nevertheless, the design choices can be traced back to ideas from the literature on  CNNs~\cite{KrizhevskyNIPS12,LeCun1989BackpropagationAT} and Transformers~\cite{vaswani2017}.

CNNs have been the de-facto standard in computer vision since the AlexNet model~\cite{KrizhevskyNIPS12} surpassed prevailing approaches based on hand-crafted image features~\cite{pinz2006object}.
Many works focused on improving the design of CNNs. 
\citet{simonyan2014very} demonstrated that one can train state-of-the-art models using only convolutions with small 33 kernels.
\citet{he2016deep} introduced skip-connections together with the batch normalization~\cite{ioffe2015batch}, which enabled training of very deep neural networks 
and further improved performance.
A prominent line of research has investigated the benefits of using sparse convolutions, such as grouped~\cite{Xie2016} or depth-wise~\cite{chollet2017xception,howard2017mobilenets} variants. 
In a similar spirit to our token-mixing MLPs, \citet{wu2019lightcnn} share parameters in the depth-wise convolutions for natural language processing.
\citet{hu2018squeeze} and \citet{wang2018-nonlocalnn} propose to augment convolutional networks with non-local operations to partially alleviate the constraint of local processing from CNNs.
\name{} takes the idea of using convolutions with small kernels to the extreme: by reducing the kernel size to 11 it 
turns convolutions into standard dense matrix multiplications applied independently to each spatial location (channel-mixing MLPs).
This 
alone does not allow aggregation of spatial information and to compensate we apply dense matrix multiplications that are applied to every feature across all spatial locations (token-mixing MLPs). 
In \name{}, matrix multiplications are applied row-wise or column-wise on the ``patchesfeatures'' input table, which is also closely related to the work on sparse convolutions. 
\name{} uses skip-connections~\cite{he2016deep} and normalization layers~\cite{ba2016layer,ioffe2015batch}.

In computer vision, self-attention based Transformer architectures were initially applied for generative modeling~\cite{child2019-sparsetransformers,parmar18-imagetransformer}.
Their value for image recognition was demonstrated later, albeit in combination with a convolution-like locality bias~\cite{ramachandran19-sasa}, or on 
low-resolution images~\cite{cordonnier2020-sacnn}.
\citet{Dosovitskiy2021} introduced ViT, a pure transformer model that has fewer locality biases, but scales well to large data. 
ViT achieves state-of-the-art performance on popular vision benchmarks while retaining the robustness 
of CNNs~\cite{bhojanapalli2021understanding}. 
\citet{deit} trained ViT effectively on smaller datasets using extensive regularization.
\name{} borrows design choices from recent transformer-based architectures.
The design of \name{}'s MLP-blocks originates in~\citet{vaswani2017}.
Converting images to a sequence of patches and directly processing embeddings of these patches originates in~\citet{Dosovitskiy2021}.

Many recent works strive to design more effective architectures for vision. 
\citet{srinivas2021bottleneck} replace 33 convolutions in ResNets by self-attention layers.
\citet{ramachandran19-sasa}, \citet{tay20synthesizer}, \citet{li2021involution}, and \citet{bello2021lambdanetworks} design networks
with new attention-like mechanisms. 
\name{} can be seen as a step in an orthogonal direction, without reliance on locality bias and attention mechanisms.

The work of \citet{lin2016mlp} is closely related.
It attains reasonable performance on CIFAR-10 using fully connected networks, heavy data augmentation, and pre-training with an auto-encoder.
\citet{neyshabur2020towards} devises custom regularization and optimization algorithms and trains a fully-connected network, attaining impressive performance on small-scale
tasks.
Instead we rely on token and channel-mixing MLPs, use standard regularization and optimization techniques, and scale to large data effectively. 

Traditionally, networks evaluated on ImageNet~\citep{deng2009-imagenet} are trained from random initialization using Inception-style pre-processing~\citep{inception}.
For smaller datasets, transfer of ImageNet models is popular.
However, modern state-of-the-art models typically use either weights pre-trained on larger datasets, or more recent data-augmentation and training strategies.
For example, \citet{Dosovitskiy2021,kolesnikov2020-bit,mahajan2018,pham2020meta,xie2020-noisystudent} all advance state-of-the-art in image classification using large-scale pre-training.
Examples of improvements due to augmentation or regularization changes include \citet{autoaugment}, who attain excellent classification performance with learned data augmentation, and \citet{bello2021revisiting}, who show that canonical ResNets are still near state-of-the-art, if one uses recent training and augmentation strategies.

\section{Conclusions}
We describe a very simple architecture for vision.
Our experiments demonstrate that it is as good as existing state-of-the-art methods in terms of the trade-off between accuracy and computational resources required for training and inference.
We believe these results open many questions.
On the practical side, it may be useful to study the features learned by the model and identify the main differences (if any) from those learned by CNNs and Transformers.
On the theoretical side, we would like to understand the inductive biases hidden in these various features and eventually their role in generalization.
Most of all, we hope that our results spark further research, beyond the realms of established models based on convolutions and self-attention.
It would be particularly interesting to see whether such a design works in NLP or other domains.

\begin{ack}
The work was performed in the Brain teams in Berlin and Z\"urich.
We thank
Josip Djolonga for feedback on the initial version of the paper; 
Preetum Nakkiran for proposing to train \fullname{} on input images with shuffled pixels;
Olivier Bousquet, Yann Dauphin, and Dirk Weissenborn for useful discussions.
\end{ack}