\def\year{2019}\relax
\documentclass[letterpaper]{article} \usepackage{aaai19}  \usepackage{times}  \usepackage{helvet}  \usepackage{courier}  \usepackage{url}  \usepackage{graphicx}  \usepackage{booktabs} \usepackage{xcolor}
\usepackage{color}
\usepackage{colortbl}
\usepackage{soul}
\usepackage{amsfonts}
\usepackage[small]{caption}
\usepackage{balance} 
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[flushleft]{threeparttable}
\usepackage{tablefootnote}
\usepackage{enumitem}
\usepackage{graphics}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{comment}
\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\newcommand*{\affaddr}[1]{#1} \newcommand*{\affmark}[1][*]{\textsuperscript{#1}}
\newcommand*{\email}[1]{\texttt{#1}}
\usepackage{array}
\usepackage{float}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\renewcommand{\algorithmcfname}{ALGORITHM}
\frenchspacing  \setlength{\pdfpagewidth}{8.5in}  \setlength{\pdfpageheight}{11in}  \pdfinfo{
/Title (ATP: Directed Graph Embedding with Asymmetric Transitivity Preservation)
/Author (Jiankai Sun, Bortik Bandyopadhyay,Armin Bashizade,Jiongqian Liang, P. Sadayappan, and Srinivasan Parthasarathy )}
\setcounter{secnumdepth}{0}  
 \begin{document}
\title{ATP: Directed Graph Embedding with Asymmetric Transitivity Preservation}
\author{\small Jiankai Sun,
Bortik Bandyopadhyay, Armin Bashizade, Jiongqian Liang, P. Sadayappan, and Srinivasan Parthasarathy\\
\affaddr{\small  Department of Computer Science and Engineering, The Ohio State University, USA}\\
\email{\footnotesize \{sun.1306,bandyopadhyay.14,bashizade.1,liang.420,sadayappan.1\}.osu.edu,srini@cse.ohio-state.edu}\\
}
\maketitle
\begin{abstract}
Directed graphs have been widely used in Community Question Answering services (CQAs) to model asymmetric relationships among different types of nodes in CQA graphs, e.g., question, answer, user. Asymmetric transitivity is an essential property of directed graphs, since it can play an important role in downstream graph inference and analysis. Question difficulty and user expertise follow the characteristic of asymmetric transitivity. 
Maintaining such properties, while reducing the graph to a lower dimensional vector embedding space, has been the focus of much recent research. 
In this paper, we tackle the challenge of directed graph embedding with asymmetric transitivity preservation and then leverage the proposed embedding method to solve a fundamental task in CQAs: how to appropriately route and assign newly posted questions to users with the suitable expertise and interest in CQAs. The technique incorporates graph hierarchy and reachability information naturally by relying on a non-linear transformation that operates on the core reachability and implicit hierarchy within such graphs. Subsequently, the methodology levers a factorization-based approach to generate two embedding vectors for each node within the graph, to capture the asymmetric transitivity. Extensive experiments show that our framework consistently and significantly outperforms the state-of-the-art baselines on three diverse real-world tasks: link prediction, and question difficulty estimation and expert finding in online forums like Stack Exchange. Particularly, our framework can support inductive embedding learning for newly posted questions (unseen nodes during training), and therefore can properly route and assign these kinds of questions to experts in CQAs.
\end{abstract}



\section{Introduction}
\label{sec:introduction}

Community Question Answering services (CQAs) such as Stack Exchange and Yahoo! Answers are examples of social media sites, with their usage being examples of an important type of computer supported cooperative work in practice. In recent years, the usage of CQAs
has seen a dramatic increase in both the frequency of questions posted and general user activity.
This, in turn, has given rise to several interesting problems ranging from expertise estimation to question difficulty estimation, and from automated question routing to incentive mechanism design on such CQAs ~\cite{Fang2016QuestionAnswering,QDEE2018}. Previous work~\cite{wang2014,QDEE2018} proposed to assign a scalar value to represent question difficulty (and user expertise). However, question difficulty and user expertise can vary in different topics. In Stack Exchange sites, users are required to use tags (a tag is a word or phrase) to describe the topic(s) of the question \footnote{\url{https://stackoverflow.com/help/tagging}}. Each question can be assigned multi-tags to represent its most relevant topics. For example, in our experiments, the average number of tags per question is $2.82$ and $2.96$ in Stack Exchange site Apple and Physics respectively. Hence a solely scalar value to represent question difficulty level or user expertise is not thorough.

Some graph embedding methods~\cite{Fang2016QuestionAnswering,zhaoexpert2016,zhao2017community} are then proposed to address the above limitation. 
The problem of graph embedding seeks to represent vertices of a graph in a low-dimensional vector space in which meaningful semantic, relational and structural information conveyed by the graph can be accurately captured ~\cite{Ma2018WSDM}. Recently, one has seen a surge of interest in developing such methods including ones for learning such representations for directed graphs (while preserving important properties) ~\cite{Ou2016KDDAsymmetric}, which is the focus of our research. A property of singular importance within a directed graph is asymmetric transitivity, which plays a very important role in tasks of graph inference and analysis ~\cite{Ou2016KDDAsymmetric}. Question difficulty and user expertise follow the characteristic of asymmetric transitivity. For example, given a question $q_1$ is easier than $q_2$ and $q_2$ is easier than $q_3$, we can infer that $q_1$ is easier than $q_3$ easily. It happens to estimating user expertise too. We can infer that $u_1$ has more expertise than $u_3$ based on the fact that $u_1$ has more expertise than $u_2$ and $u_2$ has more expertise than $u_3$ in a specific domain. In this paper, we tackle the challenge of directed graph embedding with asymmetric transitivity preservation and then leverage the proposed embedding method to solve a fundamental task in CQAs: how to appropriately route and assign newly posted questions to users with the suitable expertise and interest in CQAs. 

HOPE ~\cite{Ou2016KDDAsymmetric}, one of the state-of-art directed graph embedding methods, relies on high-order proximity features (e.g. Adamic Adar (AA), Katz Index (KI), Common Neighbors (CN)) to approximate asymmetric transitivity. Zhou et al. ~\cite{Zhou2017ScalableGE} proposed a random walk based graph embedding method named as APP which can implicitly preserve the Rooted PageRank (RPR), another higher-order proximity feature,  in the embedding space.
However, cycles in directed graphs are very common, and these cycles can undermine the performance of embedding strategies such as HOPE and APP, and hence severely limit the capability of the learned embedding vectors in graph inference and analysis. Figure~\ref{fig:inferring_graph_hierarchy} illustrates the limitation of using high order proximities for preserving asymmetric transitivity. 


\begin{figure}[t!]
    \centering
    \includegraphics[width=0.475\textwidth]{Graph_Hierarchy_Illustration}\caption{\small Illustration of the limitation of using high order proximities for preserving asymmetric transitivity due to the existence of cycles in the graph: the KI proximity from $B$ to $E$ (inner product between the source vector $u_B^s$ and the target vector $u_E^t$, generated by HOPE) represented as $KI(B,E)$ is $0.0041$, which is smaller than the KI proximity from $E$ to $B$ (inner product between the source vector $u_E^s$ and the target vector $u_B^t$) represented as $KI(E,B) = 0.0067$. HOPE will predict the edge direction is from $E$ to $B$, which is opposite to the real edge $(B,E)$. A similar problem occurs with RPR too, since $RPR(B,E)=0.2129$, which is smaller than $RPR(E,B) = 0.2446$. Due to the existence of cycles among node $B$, $C$, $D$, and $E$, CN and AA are the same for node pair $(B,E)$ and $(E,B)$. The AA proximity predicted by HOPE are $AA(B,E) = AA(E,B) = 0.5$, and CN proximity are $CN(B,E) = CN(E,B) =0$. Hence neither AA or CN can make a confident prediction for the transitivity between $B$ and $E$. However, with using our framework ATP, we can address above limitation. For example, ATP can predict $ATP(B,E) = 1.48$ and $ATP(E,B) = 8.18e^{-10}$, which strongly indicates that the edge direction is from $B$ to $E$.}
    \label{fig:inferring_graph_hierarchy}
\end{figure}



A strong hierarchical structure in the context of directed networks can help explain complex interactions in many real-world phenomena~\cite{tatti2015}, including asymmetric transitivity. Each node can be assigned a ranking score to represent where it stands in the entire network. The relationship among nodes in such a scenario is fully transitive. For example, if a node $i$ has a lower hierarchy than $j$, and $j$ has a lower hierarchy than $k$, we then can infer that $i$ must have a lower hierarchy than $k$. In graphs with strong hierarchical structure, edges are expected to flow from lower hierarchies to higher hierarchies ~\cite{Gupte2011agony,tatti2015}. However, when transitivity is being predicted leveraging the graph hierarchy alone, without incorporating the inherent graph reachability property, it can sometimes lead to false positive predictions. For example, a lower hierarchy node in a subgraph may not reach a higher hierarchy node in another subgraph which has no connection with the previous subgraph. To redress such problems, one may want to explicitly account for graph reachability as discussed next.

Transitive closure (TC) of a directed graph is a methodology (usually housed in a simple data structure) that makes it possible to answer reachability questions. The TC of a graph $G = (V,E)$ is a graph $G^{+} = (V,E^{+})$ such that for all $v$, $w$ in $V$ there is an edge $(v,w)$ in $E^{+}$ if and only if there is a non-null path from $v$ to $w$ in $G$. However, computing TC for large directed graphs with cycles is expensive, while computing TC of directed acyclic graphs (DAGs) is practical ~\cite{SIMON1988325}. To leverage the above intuition, we propose to first remove a subset of cycle edges which violate the graph hierarchy to reduce a directed graph to a DAG and then leverage the TC of the reduced DAG to represent graph reachability. We examined several strategies for breaking cycles while preserving the graph hierarchy as much as possible~\cite{trueskill2007,tatti2015}, and found an ensemble approach proposed by Jiankai et al. ~\cite{Sun2017} coupling some of these approaches can meet our requirements. Another benefit of breaking cycles is that the reduced DAG has a very strict hierarchy, and each vertex can be assigned a ranking score effectively and efficiently. 



A key challenge now is how to incorporate graph hierarchy and reachability in a unified framework to preserve the asymmetric transitivity in the embedding space. To this end, we build an asymmetric matrix $\boldsymbol{M}$, which is a non-linear transformation of a diagonal matrix $\boldsymbol{D}$ and an adjacency matrix $\boldsymbol{A}$. Here, $\boldsymbol{A}$ is the adjacency matrix of the transitive closure of the reduced DAG which implicitly contains graph reachability information, and $\boldsymbol{D}$ is a diagonal matrix storing the nodes' hierarchical ranking score along the diagonal entries of a square matrix. Then a factorization based method is applied to $\boldsymbol{M}$ to generate approximate embeddings. In our experiments, an efficient non-negative matrix factorization (NMF)~\cite{Cheng2017LRA} using Cyclic Coordinate Descent(CCD) ~\cite{Nisa2017} with appropriate regularization is leveraged to generate the embedding. Two embedding vectors, source and target vector, are learned for each node to capture the asymmetric transitivity. Through the time complexity analysis of all procedures in our proposed {\bf A}symmetric {\bf T}ransitivity {\bf P}reserving graph embedding framework ({\bf ATP}), we demonstrate that ATP can be applied to large directed graphs efficiently. 

We also conducted extensive experiments to verify the usefulness and generality of the learned embedding in various tasks such as link prediction, and question difficulty estimation and expert finding in online CQAs such as Stack Exchange sites. Particularly, ATP can support inductive embedding learning for newly posted questions (unseen nodes during training), and therefore can route and assign these kinds of questions to approximate experts in CQAs, which tackles a fundamental challenge in crowdsourcing. \looseness=-1

\begin{comment}
Specifically, we make the following contributions in the paper:

\begin{itemize}[leftmargin=0.4cm]
    \item We propose a novel approach which can incorporate graph hierarchy and reachability in a unified framework to do directed graph embedding with preserving the asymmetric transitivity in the embedding space. 
    \item We propose to break cycles firstly to remove noisy edges in the original directed graph and then we can easily infer graph hierarchy by using our modified topological sorting algorithm.
    \item To be more efficient, we propose to compute the TC of the reduced DAG instead of the original directed graph to incorporate the graph reachability.
    \item Extensive experiments have been conducted to verify the usefulness and generality of our learned embedding in two applications: link prediction and question difficulty estimation and routing in CQAs.
    \item Our framework can support inductive embedding learning, and therefore can route and assign newly posted questions to approximate experts in CQAs, which tackles a fundamental challenge in CQAs.
\end{itemize}
\end{comment}



















\section{Related Works}
\label{sec:relatedWork}


\begin{comment}
In this section, we introduce some related works of graph embedding. We start from talking about the input of graph embedding, and then introducing some graph embedding approaches.


\subsection{CQA Graphs as Inputs for Graph Embedding}

One important category of input for graph embedding is the heterogeneous graph built from CQA sites. Intuitively, there are different types of nodes in a CQA graph, e.g., question, answer, user. Existing CQA graph embedding methods can be distinguished from each other in terms of links they exploited~\cite{Cai2017Graph}. To address the biased estimator raised by using the absolute votes of users' past question-answering activities in existing models, Zhao et al. and Fang et al. \cite{Fang2016QuestionAnswering,zhao2017community,zhaoexpert2016} proposed to use the relative quality rank to model the performance of users for answering the questions. For example Zhao et al. ~\cite{zhao2017community} exploited the relative number of up-votes in the form of quintuple $(i,j,k,o,p)$, meaning that the $j$-th answer provided by the $k$-th user, obtains more up-votes than the $o$-th answer provided by the $p$-th user for the $i$-th question. The relative quality of question-answer pairs are integrated in their proposed asymmetric multi-faceted ranking network, which can rank the answers to the given question and select the answer with the highest score as the best answer. Above approaches use the answer information, which is unavailable in the cold question routing problem considered in this paper (finding matching experts before answers are written) -- a fundamental challenge in CQAs: how to appropriately route and assign newly posted questions to users with the suitable expertise and interest in CQAs. Our framework ATP can generate quality embedding for new vertices (cold questions) unseen during training, therefore supporting inductive learning in nature. Therefore ATP can route and assign these kinds of questions to approximate experts in online CQAs. 



\subsection{Graph Embedding Approaches} 
\end{comment}

Graph embedding approaches fall into three broad categories classified by Goyal et al. \cite{goyal2017graph}: (1) Factorization based, (2) Random Walk based \cite{kdd14deepwalk,TADW,Gao2018BBN}, and (3) Deep Learning based \cite{Pan2016,Dong2017MSR,SEANO}. Our proposed ATP is factorization based,
and hence we focus on discussing about factorization based techniques in this section. 

Factorization based graph embedding usually solves the graph embedding problem in two steps as follows: (1) represent the connections between nodes in the form of a matrix, and (2) factorize the matrix to get a set of node embedding~\cite{Cai2017Graph,goyal2017graph}. Based on how we construct the input matrix, matrix factorization based approaches are categorized into two types: One is to factorize graph Laplacian, and the other is to directly factorize the node proximity matrix \cite{Cai2017Graph}. The node proximity is preserved by minimizing the loss during the factorizing the node proximity matrix. 

It has been recently shown that many popular random walk based approaches such as DeepWalk ~\cite{kdd14deepwalk}, LINE ~\cite{Tang2015Line}, and node2vec ~\cite{grovernode2vec} can be unified into the matrix factorization framework with closed forms ~\cite{Tang2017EMasMF}. However, these methods ignore the asymmetric nature of the path sampling procedure and train the model symmetrically, which restricts their applications. Since node pairs from two hop away will be regarded as negative labels, LINE can only preserve symmetric second-order proximity when applied to directed graphs~\cite{Zhou2017ScalableGE}.



Higher order proximity is considered by many traditional similarity measurements, and has been shown to be effective in many real world tasks. HOPE ~\cite{Ou2016KDDAsymmetric} proposed to use high-order proximities (AA, CN, RPR, and KI) to approximate asymmetric transitivity. Theoretical analysis shows that APP implicitly preserves the RPR~\cite{Zhou2017ScalableGE}. However cycles in directed graphs as shown in Figure~\ref{fig:inferring_graph_hierarchy} can hurt the performance of asymmetric transitivity preserving for HOPE and APP, and hence severely limit the capability of the learned embedding vectors in graph inference and analysis.







\section{Our Framework ATP}
\label{sec:methodolody}

We now describe the \textbf{4-step work-flow of ATP framework}, which is illustrated in Figure-\ref{fig:atp_framework} with a toy example, and then present the computational complexity of our methodology. In the \textbf{first step}  (Section 3.1: Breaking Cycles), an input directed graph $G$ is reduced to a DAG $G'$ by removing a small set of cycle edges which violate the graph hierarchy. 
Then in the \textbf{second step} (Section 3.2: Inferring Graph Hierarchy), each node is assigned a ranking score efficiently based on the hierarchical structure of $G'$. 
The \textbf{third step} (Section 3.3: Incorporating Hierarchy and Reachability) involves the construction of the proposed novel objective matrix $\boldsymbol{M}$ to incorporate both graph hierarchy and reachability information.
Nodes' hierarchical information can be represented using a diagonal matrix $\boldsymbol{D}$, while the transitive closure of $G'$ is represented by $\boldsymbol{A}$.
These two matrices ($\boldsymbol{A}$ and $\boldsymbol{D}$) are used to build the matrix $\boldsymbol{M}$ using a non-linear transformation which can preserve hierarchical rankings between local nodes much better than an ordinary linear model.
The \textbf{final step} (Section 3.4: Generating Asymmetric Transitivity Preserving Graph Embedding from $\boldsymbol{M}$) involves the efficient application of NMF on $\boldsymbol{M}$ to produce two matrices $\boldsymbol{S}$ and $\boldsymbol{T}$, which can be interpreted as asymmetric transitivity preserving source vectors and target vectors of all the nodes in the graph.\looseness=-1




\begin{figure*}[!ht]
    \centering
    \small
    \includegraphics[width=0.95\textwidth]{ATP_Illustration_Framework}
   \caption{\small Illustration of {\bf A}symmetric {\bf T}ransitivity {\bf P}reserving ({\bf ATP}) graph embedding framework} 
    \label{fig:atp_framework}
\end{figure*}




\subsection{Breaking Cycles}
\label{sec:breaking_cycles}

Reducing a directed graph $G = (V,E)$ to a DAG $G' = (V,E')$ has two obvious advantages: 1) making it possible for us to compute the transitive closure of $G'$; 2) inferring the hierarchy of $G'$ becomes easier, since a DAG has a very strict hierarchy. \looseness=-1

We examined several strategies for breaking cycles while preserving the graph hierarchy as much as possible, and found an ensemble approach {\em H\_Voting}  proposed by Jiankai  et al. ~\cite{Sun2017} can meet our requirements. {\em H\_Voting} selects the edge with the highest voting score for removal in a fast, scalable, and fully automated way. The voting score of each edge is determined by the severity of their violation, which means that edges that respect the hierarchy receive a score of $0$ and score increase linearly as the hierarchy violation becomes more severe. The corresponding hierarchy is inferred by ensembling TrueSkill~\cite{trueskill2007} and Social Agony~\cite{Gupte2011agony,tatti2015}. Figure~\ref{fig:inferring_graph_hierarchy} illustrates that edges (C,B), (D,B), (E,C) and (E,D) are removed  by {\em H\_Voting} to break cycles. Empirically, it has been shown that {\em H\_Voting}, can accurately identify the edges to be removed, even in noisy and large-scale real-world graphs. The time complexity of breaking cycles is $O(E^2)$ in the worst case, which happens in directed complete graphs \footnote{Every pair of distinct vertices is connected by a pair of unique edges (one in each direction).}.\looseness=-1

\begin{comment}
Sun et al. ~\cite{Sun2017} proposed $6$ different heuristic strategies of breaking cycles to reduce $G$ to $G'$,  while maintaining the graph hierarchy as much as possible, inferred by a range of features such as TrueSkill (TS)~\cite{trueskill2007}  and Social Agony (SA)~\cite{tatti2015}. {\em H\_Voting} is used as the voting scheme to ensemble the above $6$ strategies for breaking cycles in a graph.
{\em H\_Voting} selects the edge with the highest voting score for removal in a fast, scalable, and fully automated way. For example, Figure~\ref{fig:inferring_graph_hierarchy} illustrates that edges (C,B), (D,B), (E,C) and (E,D) are removed  by {\em H\_Voting} to break cycles. We also examined two other voting strategies - {\em SA\_Voting} and {\em TS\_Voting}, which ensembles $3$ Social Agony and $3$ TrueSkill based strategies respectively in our experiments. Empirically, it has been shown that voting based approaches, especially {\em SA\_Voting}, can accurately identify the edges to be removed, even in noisy and large-scale real-world graphs. The time complexity of breaking cycles is $O(E^2)$ in the worst case, which happens in directed complete graphs \footnote{Every pair of distinct vertices is connected by a pair of unique edges (one in each direction).}.\looseness=-1


\end{comment}

\subsection{Inferring Graph Hierarchy}
\label{sec:inferring_graph_hierarchy}

Given that the graph has been converted to a DAG using the previous step, graph hierarchy can be inferred based on this reduced DAG. Given a graph $G = (V,E)$, inferring graph hierarchy means that we have to construct a function $r: V \rightarrow \mathbb{Z}$, which maps each vertex to an integer, representing corresponding vertex's hierarchy in $G$. The computed graph hierarchy is fully transitive and can be used to infer the asymmetric transitivity in $G$.
One straightforward way to compute a ranking score for each vertex is to use topological sorting. However, topological sorting is non-deterministic. Hence we modify topological sorting algorithm by assigning a ranking score to each vertex in a DAG recursively following the steps below: Step 1) assign the current ranking score $o$ \footnote{Ranking score $o$ is initialized to $1$.} to all nodes with zero in-degree; Step 2) update the target graph by removing all zero in-degree nodes and their corresponding out-going edges; Step 3) update the current ranking score $o$ by increasing $1$.



Figure~\ref{fig:inferring_graph_hierarchy} shows each node's ranking score inferred by the above procedures. For example, node $A$'s in-degree in the reduced DAG is $0$ while its hierarchy is represented as $r(A) = 1$. The time complexity of above procedure is the same as topological sorting, which is $O(|V|+|E|)$.\looseness=-1




















\subsection{Incorporating Hierarchy and Reachability}
\label{sec:build_matrix}

The hierarchical ranking score inferred by the methodology in Section 3.2 reflects where a node stands in the entire network, and it is fully transitive. However, the sole assumption that edges are from lower to higher hierarchy nodes fails to incorporate the inherent graph reachability property, and hence is prone to generating many false positive predictions during down-stream analysis tasks (eg: link prediction using the generated node embeddings).
Thus the key challenge is to combine both graph hierarchy and reachability inside a unified framework, which we discuss next.\looseness=-1



TC can be thought of as constructing a data structure that makes it possible to answer reachability questions. Instead of computing TC of the original directed graph $G$, we compute the TC of the reduced DAG $G'$ and represent it as its adjacency matrix $\boldsymbol{A} \in \mathbb{R}^{|V| \times |V|}$. If node $i$ can reach $j$ in $G'$, then the corresponding element $A_{i,j} = 1$, otherwise $A_{i,j} = 0$.
$\boldsymbol{A}$ contains the information of graph reachability, but it treats the hierarchical difference between any reachable node pairs the same (equal to $1$). To emphasize the impact of these non-zero elements in $\boldsymbol{A}$ and leverage graph hierarchy, a simple way is to replace each non-zero element by corresponding node pair's hierarchical difference, which is equivalent to applying a linear function to transform $\boldsymbol{A}$ to $\boldsymbol{L} \in \mathbb{R}^{|V| \times |V|}$. For each non-zero element $A_{i,j} = 1$ in $\boldsymbol{A}$, its corresponding $L_{i,j}$ in $\boldsymbol{L}$ is $\Delta_{i,j} = r(j) - r(i)$ and $\Delta_{i,j} \geq 1$.  \looseness=-1 


Suppose $\boldsymbol{D} \in \mathbb{R}^{|V| \times |V|}$ is a diagonal matrix, where each non-zero element in the diagonal is $D_{i,i} = r(i)$. Then we have:


\begin{equation}
    \boldsymbol{L} = \boldsymbol{AD} - \boldsymbol{DA}
    \label{eq:linear}
\end{equation}

Empirically, the maximum value of $\Delta$ in $\boldsymbol{L}$ is much larger than the minimum value (which is $1$). The high (and varying) range of values in $\Delta$ will unfavourably amplify the effect of large hierarchical difference values while damping the effects of smaller values, thereby negatively impacts the transitivity preserving property in local sub-graphs.
To overcome this limitation, we seek to reduce the absolute values of $\Delta$ to smaller ones, while preserving its important monotonic property.
We observe that a simple yet popular harmonic series, which is a non-linear and non-decreasing function, can satisfy our requirements very well and can be used to build the proximity matrix $\boldsymbol{M} \in \mathbb{R}^{|V| \times |V|}$.
Each non-zero entry $L_{i,j} \in \boldsymbol{L}$ is transformed to $M_{i,j} =  1+\frac{1}{2}+...+\frac{1}{\Delta_{i,j}}$ in $\boldsymbol{M}$. Since a harmonic number $h(\Delta_{i,j}) = \sum_{k=1}^{\Delta_{i,j}} \frac{1}{k}$ can be approximated by $(\gamma + log(\Delta_{i,j}))$~\footnote{$\gamma$ is the Euler-Mascheroni constant, log is the Natural logarithm}, without loss of generality, we represent each non-zero element $M_{i,j} = c + log(e + \Delta_{i,j})$, where $c$ is a constant, and $e$ is the  mathematical constant satisfying $log(e + \Delta) > 0$.
Figure~\ref{fig:atp_framework} provides an example of computing $\boldsymbol{M}$, where $c = 0$.
After this non-linear transformation, the gap of hierarchical rankings between local nodes can be noticed and well preserved compared to the linear model. Thus, the final matrix $\boldsymbol{M}$ incorporating both graph hierarchy and reachability, 
is computed as:\looseness=-1

\begin{equation}
    \boldsymbol{M} =  c \boldsymbol{A} + log(e\boldsymbol{A} + \boldsymbol{L}) = c\boldsymbol{A} + log(e\boldsymbol{A} + \boldsymbol{AD} -\boldsymbol{DA})
\end{equation}\looseness=-1

Constructing the adjacency matrix $\boldsymbol{A}$ is equivalent to computing the transitive closure of $G'$, which has a worst-case time complexity of $O(|V|^2loglog(|V|))$~\cite{SIMON1988325}.
The time complexity of computing  $\boldsymbol{L}$ with Equation \ref{eq:linear} is equal to the number of non-zero elements in $\boldsymbol{A}$, which is $O(|V|^2)$ in the worst case. Hence, the time complexity of constructing $\boldsymbol{M}$ is $O(|V|^2loglog(|V|))$ in the worst case. 

\subsection{Generating Asymmetric Transitivity Preserving Graph Embedding from $\boldsymbol{M}$}
\label{sec:mf}
We have discussed how to build the non-negative proximity matrix $\boldsymbol{M}$, which is a function of the adjacency matrix of the transitive closure of the reduced DAG and a diagonal matrix which contains graph hierarchy. In this section, we propose to use factorization models to generate asymmetric transitivity preserving embedding for the given directed graph. 



The most straightforward way is to apply NMF on $\boldsymbol{M}$ to generate asymmetric transitivity preserving embedding for the given directed graph.
NMF of the $(|V| \times |V|)$ matrix $\boldsymbol{M}$ generates a low-rank approximation of it: $\boldsymbol{M} \approx \boldsymbol{ST}$, where $\boldsymbol{S} \in \mathbb{R}^{|V| \times k}$ and $\boldsymbol{T} \in \mathbb{R}^{k \times |V|}$, as shown in Figure~\ref{fig:atp_framework}.
Each row in $\boldsymbol{S}$ represents a node's out-reach (source) vector, and each column in $\boldsymbol{T}$ represents a node's in-reach (target) vector. $k$ is the dimension size of the source/target embedding space. NMF step is a core part in generating the embedding and we apply a multi-core GPU version of NMF using CCD GPUCCD++~\cite{Nisa2017} with appropriate regularization to generate the embedding for large graphs efficiently. The time complexity per iteration of GPUCCD++ is $O(k|V|^2)$  in the worst case. 

To predict whether there is a directed path from node $i$ to node $j$, we check the value of $\sigma (\langle \vec{s}_i , \vec{t}_j \rangle)$, where $\sigma$ is the sigmoid function, $\vec{s}_i$ is node $i$'s source vector and $\vec{t}_j$ is node $j$'s target vector respectively. If $\sigma (\langle \vec{s}_i , \vec{t}_j \rangle) > \alpha$, there is a predicted path from $i$ to $j$. $\alpha$ is a threshold with range in $[0.5,1)$. We set $\alpha = 0.5$ in our experiments, which we empirically found to work well.


\begin{comment}
\subsubsection{Generating Graph Embedding via FM}
\label{sec:atp_fm}

Rendle~\cite{Rendle2012libFM,Rendle2010FM} proposed FMs to handle sparse problems caused by one-hot encoding of user IDs and item IDs in recommender systems. The reason of FMs being able to handle sparse settings is that FMs can model all nested interactions up to order $d$ between variables in an input instance using factorized interaction parameters \cite{Rendle2012libFM,Rendle2010FM}. Table~\ref{tab:fm_illustration} shows how we process matrix $\boldsymbol{M}$ so that it can be fed into FM. Each training instance of FM consists of a feature vector $\vec{x}$ and its corresponding output $y$. Each non-zero element $M_{s,t}$ of $\boldsymbol{M} \in \mathbb{R}^{|V| \times |V|}$ is corresponding to an input instance $(\vec{x}^{(i)}, y^{(i)})$. The dimension of $\vec{x}^{(i)}$ is $2|V|$, where the first $|V|$ dimensions represent one-hot encoding of the source node $s$ (id), and the next $|V|$ dimensions represent one-hot encoding of the target node $t$ (id). $\vec{x}^{(i)}$'s corresponding output $y^{(i)}$ is $M_{s,t}$. Since there are only $2$ ones in each $\vec{x}$, a $2$-way ($d=2$) FM is enough to model the interactions between source and target nodes. 

\input{tables/FactorizationMachine.tex}

The prediction function of a $2$-way FM works as follows:

\begin{equation} \label{eq:fm-order2}
\hat{y}(\vec{x}) = w_0 + \sum_{i = 1}^{2|V|} w_ix_i + \sum_{i=1}^{2|V|} \sum_{j = i +1}^{2|V|} x_ix_j <\vec{f}_i,\vec{f}_j>
\end{equation}

where the model parameters that have to be estimated are:

\begin{equation}
w_0 \in \mathbb{R}, \vec{w} \in \mathbb{R}^{2|V|}, \boldsymbol{F} \in \mathbb{R}^{{2|V|} \times k}
\end{equation}

And $<\cdot,\cdot>$ is the dot product of two vectors of size $k$:

\begin{equation}
<\vec{f}_i,\vec{f}_j> = \sum_{l=1}^k f_{i,l}f_{j,l}
\end{equation}

where a row $\vec{f}_i \in \boldsymbol{F}$ describes the $i$-th variable with $k \in \mathbb{N}_0^+$ factors. $k$ represents the dimensionality of the factorization. The first $|V|$ rows of $\boldsymbol{F}$ represent nodes' out-reach (source) vectors ($\boldsymbol{S}$), and the last $|V|$ row of $\boldsymbol{F}$ represent nodes' in-reach (target) vectors ($\boldsymbol{T}$). $w_0$ and $\vec{w}_s$, and $w_0$ and $\vec{w}_{s+|V|}$ are node $s$'s biased term of being a source node and a target node respectively. Here FM is exactly the same as a (biased) matrix factorization as we have described in section ~\ref{sec:atp_nmf}. The model parameters ($w_0$, $\vec{w}$, and $\boldsymbol{F}$) can be learned efficiently by gradient descent methods as follows:

\begin{equation}
\frac{\partial}{\partial \theta}\hat{y}(\vec{x}) = \begin{cases} 1, & \mbox{if $\theta$ is $w_0$} \\ 
x_i, & \mbox{if $\theta$ is $w_i$} \\
x_i\sum_{j=1}^{2|V|} f_{j,l}x_j - f_{i,l}x_i^2, & \mbox{if $\theta$ is $f_{i,l}$} 
\end{cases}
\label{eq:differential}
\end{equation}

In general, each gradient can be computed in constant time $O(1)$. And all parameter updates for a case $(\vec{x},y)$ can be done in $O(k|V|)$~\cite{Rendle2010FM}.
\end{comment}






\subsection{Complexity Analysis}
\label{sec:complexityAnalysis}

In this section, we analyze the complexity of the whole framework of ATP, given a directed graph $G=(V,E)$ as input. Fundamental procedures of ATP are breaking cycles, inferring graph hierarchy, constructing $\boldsymbol{M}$, and factorization of $\boldsymbol{M}$. In the worst case, their corresponding time complexity is $O(|E|^2)$, $O(|E|+|V|)$, $O(|V|^2loglog(|V|))$, and $O(|V|^2k)$ per iteration (NMF) respectively. By combining them, the time complexity of ATP is $O(|E|^2)$ in the worst case ($G$ is a directed complete graph). The bound is very pessimistic in practice, and the bottleneck part (breaking cycles) can be parallelized since it can perform on each SCC independently to remove cycle edges. 



\section{Experiments and Analyses}
\label{sec:experiments}

We apply our graph embedding framework ATP to three diverse tasks: link prediction, and  question difficulty estimation and expert finding in CQAs.

\subsection{Link Prediction}
\label{sec:link_prediction}

In link prediction, we would like to predict these missing edges given a network with a certain fraction of edges removed. 
The labeled dataset of edges (or node pairs) consists of positive and negative examples. Given a random edge $e$, if the removal of this edge will not disconnect the residual network, $e$ will be selected as a positive example. We select $r = 10\%$ edges as positive examples. To generate negative examples, we randomly select an equal number of node pairs from the network which have no edges connecting them \footnote{Each node pair $(u,v)$ in negative samples satisfies the condition that $v$ can reach $u$, but $u$ cannot reach $v$ in the network.}. Hence $2r$ edges and node pairs are selected for evaluation.



Datasets used for evaluation are Wiki-Vote\footnote{\url{https://snap.stanford.edu/data/wiki-Vote.html}}, GNU\footnote{\url{https://snap.stanford.edu/data/p2p-Gnutella31.html}},  Cit-HepPH\footnote{\url{https://snap.stanford.edu/data/cit-HepPh.html}}, which were used in prior work \cite{Lai2017Prune}. GNM-30K is a random directed graph generated with cycles ($30K$ nodes and $155K$ edges).



Following existing literature \cite{grovernode2vec,ijcai2017-fastNetworkEmbedding,Tran2018}, we use Area Under Curve (AUC) to evaluate the link prediction performance. We compare our method with the most recent work for asymmetric proximity preserving.

\begin{itemize}[leftmargin=0.4cm,noitemsep]
    \item \textbf{ATP and its variants}: ATP-Constant ($\boldsymbol{M}$ = $\boldsymbol{A}$), ATP-Linear ($\boldsymbol{M}$ = $\boldsymbol{L}$), ATP-Harmonic, and ATP-log (By default ATP refers to ATP-log). ATP-Harmonic, and ATP-log transforms $\boldsymbol{L}$ to $\boldsymbol{M}$ by harmonic and log function respectively.  
    \item \textbf{HOPE}\cite{Ou2016KDDAsymmetric}: 
As the time complexity of computation of RPR is too high, we only report performances of HOPE-AA, HOPE-CN, and HOPE-KI here. \item \textbf{SVDM}: SVD-Harmonic and SVD-log use the same way to build $\boldsymbol{M}$ as ATP-Harmonic and ATP-log respectively. However, unlike ATP, SVD-Harmonic and SVD-log performs Singular Value Decomposition (SVD) as used in HOPE on $\boldsymbol{M}$ and selects the largest $k$ singular values and corresponding singular vectors to construct the embedding. 
\item \textbf{LINE} \cite{Tang2015Line}: It is worth mentioning that LINE can only preserve symmetric second-order proximity when applied to a directed graph. In our experimental settings, vertex vectors are considered as source vectors, and context vectors are used as target vectors.  
\end{itemize}


\subsubsection{Performance Analysis} 

We can conclude from the performance as shown in Table~\ref{tab:hge_hope_comparison} that: 

\begin{table}
\centering
\small
\caption{Comparisons between ATP and the state-of-the-art methods on link prediction, evaluated by AUC}
\setlength\tabcolsep{2.75pt} \begin{tabular}{@{}c|c|cccc@{}} \toprule
 & AUC & Wiki-Vote & Cit-HepPH & GNU &  GNM-30K\\ \midrule
LINE & 2-nd order & 0.4423 & 0.3310 & 0.4748 &  0.4109 \\ \midrule
  & AA & 0.7672 & 0.7385 & 0.5565 & 0.5747\\
 HOPE & CN & 0.7860 & 0.7570 & 0.5736 & 0.5836\\
 & AI & 0.7784 & 0.7440 & 0.6159 &  0.5784\\ \midrule 
SVDM & Harmonic  & 0.8200 & 0.7522 & 0.8166  & 0.6255\\ 
    & log       &  0.8215	& 0.7929	& 0.8162	& 0.6248 \\ \midrule 
& Constant & 0.9123 & 0.7939 & 0.8684 &  0.7845\\
 & Linear & 0.9462 & 0.8682 & 0.8893 &  0.8530\\
 {\bf ATP} &{\bf log} & {\bf 0.9481} & {\bf 0.8916} & {\bf 0.9314}  & {\bf 0.8789}\\ 
& Harmonic & 0.9478 & 0.8892 & 0.9288  & 0.8777\\
 \bottomrule
\end{tabular}
\label{tab:hge_hope_comparison}
\end{table}

\begin{itemize}[leftmargin=0.4cm,noitemsep]
    \item Since Harmonic numbers can be approximated by log functions, log and Harmonic transformation can achieve similar performance in both ATP and SVDM. By default, we use log function as our non-linear transformation. It is noticeable that ATP performs better than SVDM. In average, ATP improves over SVDM by $22.01\%$ among all datasets (from $12.45\%$ to $40.67\%$), which shows the advantage of leveraging NMF to perform transitivity preserving graph embedding. 
    
    \item ATP and SVDM perform better than HOPE. In average, SVDM improves over HOPE-KI by $13.72\%$ among all datasets, and ATP improves over HOPE-KI from $19.84\%$ to $51.97\%$. The only difference between SVDM and HOPE is the technique used to build $\boldsymbol{M}$. The results demonstrate the advantage of incorporating graph reachability and hierarchy to construct $\boldsymbol{M}$, in comparison to building a higher order proximity matrix based on AA, CN, and KI.
    
    \item Both ATP-Harmonic and ATP-log perform better than ATP-Linear and ATP-Constant as expected, and ATP-Linear performs better than ATP-Constant. For example, ATP-log improves over ATP-Constant by $8.51\%$ in average among all datasets. ATP-log improves over ATP-Linear by $4.74\%$ on the largest dataset GNU. It shows the efficacy of applying non-linear transformation to $\boldsymbol{M}$.

    
\end{itemize}




\begin{comment}
\subsubsection{Impacts of different approaches to break cycles}

As we have shown in the previous section that breaking cycles can be viewed as a generic pre-processing step, we now investigate the impacts of different approaches to break cycles on asymmetric transitivity preserving graph embedding. We follow the same work-flow as ATP, except the way to break cycles. {\em H\_Voting} used by ATP and another $8$ methods described in Section~\ref{sec:breaking_cycles} to break cycles have been conducted to test their performance on the task of link prediction. The performance on two largest real networks GNU and Cit-HepPh are shown in Figure~\ref{fig:hge_breaking_cycles}.

An interesting observation is that SA based approaches are more robust and stable than TS based approaches in our experiments since TS infers the graph hierarchy from a local view and tends to be sensitive to noisy edges in a graph. More specifically, TS tends to overfit -- requiring significant updates for ranking scores when it internally accounts for such noisy edges. 

 \begin{figure*}[ht]
    \centering
    \hspace{-0.1in}
    \begin{subfigure}[b]{0.5\textwidth}
            \includegraphics[width=\linewidth]{pics/hge_breaking_cycles}
            \caption{\scriptsize Different Approaches to break cycles}
            \label{fig:hge_breaking_cycles}
    \end{subfigure}\hspace{0.01in}
    \begin{subfigure}[b]{0.5\textwidth}
            \includegraphics[width=\linewidth]{pics/hge_sa_performance}
            \caption{\scriptsize Different Approaches to build $\boldsymbol{M}$}
            \label{fig:hge_sa_performance}
    \end{subfigure}        
    \caption{\small a) Performance of different approaches to break cycles; b) Performance of different approaches to build $\boldsymbol{M}$}
\end{figure*}




\subsubsection{Advantages of incorporating the graph reachability}

In this section, we would like to explore the impacts of using different ways to infer the graph hierarchy and advantages of incorporating the graph reachability. Several ATP variants using different ways to compute non-zero elements in $\boldsymbol{M}$ \footnote{The matrix factorization technique GPUCCD++ \cite{Nisa2017}, used in our paper, can support matrices with negative values} are proposed to make comparisons. SA-linear-Adj, SA-log-Adj, and H-log-Adj do not leverage graph reachability information, while their corresponding comparison partners SA-linear, SA-log, and ATP incorporates both graph hierarchy and reachability.  Detailed definitions are as follows:

\begin{itemize}[leftmargin=0.4cm,noitemsep]
    \item \textbf{SA-linear-Adj}: SA, a state-of-the-art method proposed to infer graph hierarchy by Gupte et al. \cite{Gupte2011agony} is applied to the target directed graph $G = (V,E)$ to infer the ranking score $sa(i), \forall i \in V$. Each non-zero element in $\boldsymbol{M}$  is defined as $M_{i,j} = \Delta_{i,j}^{sa}$,  $\forall (i,j) \in E$, where $\Delta_{i,j}^{sa} = sa(j) - sa(i)$.
    \item \textbf{SA-linear}: Each non-zero element in $\boldsymbol{M}$ is defined as $M_{i,j} = \Delta_{i,j}^{sa}$, $ \forall (i,j) \in E^+$, where $E^+$ is the edges set of the transitive closure of DAG $G'$ reduced from $G$.
    \item \textbf{SA-log-Adj}: $\forall (i,j) \in E$, $M_{i,j} = I(\Delta_{i,j}^{sa}) \cdot log( e + |\Delta_{i,j}^{sa}|)$, where $I(x) = 1$ if $x > 0$, else $I(x) = -1$.
    \item \textbf{SA-log}: $\forall (i,j) \in E^+$, $M_{i,j} = I(\Delta_{i,j}^{sa}) \cdot log( e + |\Delta_{i,j}^{sa}|)$.
    \item \textbf{H-log-Adj}: $\forall (i,j) \in E$, $M_{i,j} = I(\Delta_{i,j}) \cdot log( e + |\Delta_{i,j}|)$, where $\Delta_{i,j}$ is computed based on the ranking score inferred by our proposed method as described in Section~\ref{sec:inferring_graph_hierarchy}.
\end{itemize}

 The two largest real datasets GNU and Cit-HepPh are used to conduct the experiments, and the results are shown in Figure \ref{fig:hge_sa_performance}.  We can conclude that:

\begin{itemize}[leftmargin=0.4cm,noitemsep]
    
    \item Leveraging higher order graph reachability to build $\boldsymbol{M}$ can be beneficial for preserving the asymmetric transitivity in comparison with using first order neighbors ({\em Adj}) (without accounting for reachability), since we can observe that ATP $\succ$ H-log-Adj, SA-linear $\succ$ SA-linear-Adj, and SA-log $\succ$ SA-log-Adj. For example, SA-linear improves over SA-linear-Adj by $3.1\%$ on Cit-HepPh.

    \item $log$ transformation is a better choice for leveraging graph hierarchy and reachability than linear transformation, since SA-log $\succ$ SA-linear, and SA-log-Adj $\succ$ SA-linear-Adj. For example, SA-log-Adj improves over SA-linear-Adj by $4.31\%$ on GNU. This observation is consistent with the results as shown in Table~\ref{tab:hge_hope_comparison}.

    \item We can observe that ATP $\succ$ SA-log, which shows the effectiveness of using our proposed method in Section~\ref{sec:inferring_graph_hierarchy} to infer graph hierarchy. It is worth mentioning that all the $6$ graph hierarchy based methods perform better than HOPE, indicating that nodes' hierarchy is better proximity for asymmetric transitivity preservation than high order measures proposed by HOPE.
\end{itemize}
\end{comment}





\subsection{Question Difficulty Estimation and Expert Finding in CQAs}
\label{sec:question_routing_cqas}

In this section, we start by discussing how to apply ATP to estimate question difficulty and user expertise. We then show how to embed newly posted questions (unseen nodes in the training) inductively and identify best answerers for newly posted questions in CQAs.

\begin{table}[t!]
\small
\centering
\caption{Statistics of Stack Exchange Sites} 
\setlength\tabcolsep{1pt} \begin{tabular}{c|cccccccc}
Stack Exchange Sites 　　　&  Apple  & Gaming & Physics & Scifi  & Unix\\ \hline
\# nodes in Graph   　　　& 133K  & 117K & 127K & 59K &   167K\\
\# edges in Graph  　　　 & 161K   & 190K & 188K & 97K &   249K\\
\# questions with bounty  & 1,834  　 & 1,562 & 1,922 　　　& 980 &   1,614 \\
\# cold questions  for evaluation  & 234 & 313 & 196 & 279        & 297 \\ 
\bottomrule
\end{tabular}
\label{tab:statistics_stack_exchange}
\end{table}


\subsubsection{Question Difficulty and User Expertise Estimation in CQAs}

We first talk about how to apply our graph embedding technique into question difficulty and user expertise estimation, which is a central part of automated question routing in CQAs. We select $5$ large and popular sites from Stack Exchange \footnote{We used the data dump which is released on June 12, 2017 and is available online at \url{https://archive.org/details/stackexchange}} for evaluation. More details about the Stack Exchange sites can be found in the Table~\ref{tab:statistics_stack_exchange}. For each Stack Exchange site, ATP uses the same competition graph as the input as QDEE~\cite{QDEE2018} which assigns solely scalar value to represent question difficulty level and user expertise. In this section, we will show the advantages of learning latent representations for question difficulty (question nodes) and user expertise (user nodes) by leveraging ATP. 









 Following the same setting as QDEE~\cite{QDEE2018}, questions which were provided non-zero bounty scores are selected as our ground truth for evaluation, and pairwise accuracy (\textit{Acc})\footnote{$\textrm{Acc =} \frac{\textrm{\# correctly predicted question pairs}}{\textrm{\# all question pairs}}$}, as used by previous studies \cite{wang2014,QDEE2018}, are used to measure the effectiveness of different estimation techniques. Higher accuracy indicates better performance of the technique. The number of questions with bounty used for evaluation is shown in Table~\ref{tab:statistics_stack_exchange}. We evaluate ATP and other state-of-the-art methods such as {\bf TrueSkill} ~\cite{wang2014}, {\bf Number-Of-Answers}~\cite{yang2014sparrows}, {\bf Time-First-Answer},  {\bf Time-Best-Answer}~\cite{Huna2016} and {\bf QDEE}~\cite{QDEE2018} on the task of question difficulty estimation. 

Question difficulty estimation performance is shown in Figure~\ref{fig:hge_performance_qde}.
We can conclude that { ATP} performs the best on almost all of the Stack Exchange sites. For example, { ATP} improves over { TrueSkill}, { Number-of-Answer}, and { QDEE} on average by $6.56\%$, $5.92\%$, and $5.06\%$ respectively in $5$ Stack Exchange sites. { TrueSkill} suffers from the data sparsity problem. Each question has only one in-edge (from questioner) and one out-edge (to the best answerer), which limits the accuracy of { TrueSkill}. { ATP} can leverage graph reachability and hence each question can have interactions with other questions and users, which can overcome the data sparseness. 

\begin{figure}[t!]
    \centering
    \small
    \includegraphics[width=0.485\textwidth]{hge_performance_QDE}
    \caption{Pairwise accuracy  of different approaches to estimate question difficulty} 
    \label{fig:hge_performance_qde}
\end{figure}


\subsubsection{Inductive Embedding Learning for Cold Question Routing in CQAs}

Usually, there are two types of questions in CQAs -- resolved (questions with answers) and newly posted questions (questions that have not received any answers). We refer to these newly posted questions as {\em cold questions}. The majority of approaches have focused on evaluating content quality after the fact (after questions have been resolved) \cite{Yang2013CQArank}. Yet, as the CQAs continue to grow, routing the cold questions to matching experts before answers have been provided has become a critical problem. For example, in Stack Overflow, about 4.8 million questions have not been answered \footnote{\url{https://stackoverflow.com/unanswered}}.

In this section, we show that ATP can generate quality embedding for new vertices (cold questions) unseen during training, therefore supporting inductive learning in nature. Our idea is to leverage Expertise Gain Assumption ({\em EGA}) ~\cite{QDEE2018} to bridge the gap between cold-start and well-resolved questions asked by the same user. Given a cold question $q^*$ asked by a user $u^*$, the most recent $k$ questions asked by the same user $u^*$ are $q_1,q_2,...,q_k$ and their associated embedding are available to us (they can be seen during training). We use the embedding of the question which has the highest difficulty level among $q_1,q_2,...,q_k$ to approximate $q^*$'s embedding. A question $q_{max}$ is considered to have the highest difficulty level if $\sigma (\langle \vec{s}_{q_i} , \vec{t}_{q_{max}} \rangle) > \sigma (\langle \vec{s}_{q_{max}},\vec{t}_{q_{i}} \rangle)$ for all $i \in [1,k]$ and $q_i \neq q_{max}$. Then $\vec{s}_{q^*} = \vec{s}_{q_{max}}$ and  $\vec{t}_{q^*} = \vec{t}_{q_{max}}$. We note that it is possible that the user posing the question is a new user (or one that has not posted a sufficient number of questions). In this case, $k$ well-resolved questions that are closest (i.e. cosine similarity) to $q^*$ in textual descriptions \footnote{Each question can be represented as a feature vector by LDA~\cite{Ji2012LDA}}, are picked as its nearest neighbors. The source and target embedding of $q^*$ is predicted as the averaged source and target embedding of its nearest neighbors respectively. 

Our task of cold question routing is to select the user who has the highest possibility to be selected as the best answerer for a newly posted question. Given the testing question set $\mathcal{Q}_t$, the predicted ranking list of all potential answerers for a test question $q^*$ is $R^{q^*}$ for all $q^* \in \mathcal{Q}_t$. The ranking score of a potential answerer $u$ for the cold question $q^*$ is computed as $\sigma (\langle \vec{s}_{q^*} , \vec{t}_u \rangle)$. The answerer who has the highest ranking score will be selected as the best answerer for $q^*$. 

We compare ATP with state-of-the-art methods ( {\bf BoW}~\cite{Figueroa2013LRE-BOW}, {\bf Doc2Vec} ~\cite{CQAWord2Vec}, 
{\bf LDA} ~\cite{Ji2012LDA}, {\bf CQARank}~\cite{Yang2013CQArank}), {\bf QDEE}~\cite{QDEE2018}, and {\bf ColdRoute}~\cite{ColdRoute}, based on several popular evaluation criteria such as Mean Reciprocal Rank ({\bf MRR}) ~\cite{Zhu2014}, {\bf Precision$@3$} ~\cite{zhao2017community,ColdRoute}, and {\bf Accuracy} ~\cite{zhao2017community,ColdRoute}. We followed the same settings proposed by Jiankai et al. ~\cite{ColdRoute} to select cold questions for evaluation. 

Table ~\ref{tab:ATP_ColdQuestion_Routing_Table} shows the performance of different approaches on the task of cold question routing, evaluated by MRR,  Precision$@3$ and Accuracy. Jiankai et al. ~\cite{ColdRoute} reported that ColdRoute performed consistently better than BoW, Doc2Vec and LDA. To save space, we omitted their performance Table ~\ref{tab:ATP_ColdQuestion_Routing_Table}. 
Based on the results, we can make the following observations:

\begin{itemize}[leftmargin=0.4cm]
    \item ATP performs the best overall evaluation metrics in almost all Stack Exchange sites. For example, ATP improves upon routing metric Accuracy over ColdRoute by $6.14\%$, since ColdRoute fails to take the interactions between questions (asked by the same asker) into consideration.
    ATP improves upon routing metric MRR over QDEE by $7.59\%$, which indicates that incorporating graph reachability and representing user expertise and question difficulty as a feature vector can help ATP identify matching experts for cold questions more accurately and robustly than the state-of-the-art methods. 
    \item ATP performs better than CQARank. The reason is that CQARank's Q$\&$A graph contain more noise than the competition graph used by ATP. The direction of edges in CQARank's Q$\&$A graph is from the asker to the answerer. The underlying assumption is that askers have lower expertise than corresponding answerers. However, Wang et al.~\cite{wang2014} shows that the expertise of the asker is not assumed to be lower than the expertise score of a non-best answerer, since such a user may just happen to see the question and responded that, rather than knowing the answer well. These kinds of answers do not show corresponding answerers' expertise are higher than the asker's expertise. The generated noise edges in CQARank's Q$\&$A graph can undermine CQARank's performance on experts finding for cold questions.
\end{itemize}




\begin{table}[t!]
\small
\centering
\setlength\tabcolsep{4pt} \caption{Comparisons between ATP and the state of the art methods on cold question routing in CQAs, evaluated by MRR, Precision$@3$ (P$@3$), and Accuracy.}
\begin{tabular}{@{}c|c|ccccc@{}}
 &  & Apple & Gaming & Physics & Scifi & Unix\\ \midrule
MRR & CQARank & 0.4914 & 0.4463 & 0.5315 & 0.4628 & 0.5258\\
 & QDEE & 0.5579 & 	0.6011 & 	0.524 & 	0.5895	 & 0.5158 \\
 & ColdRoute & 0.5365 &	\boldmath\textbf{0.6445} & 0.5288 & \boldmath\textbf{0.6462} &	0.54338 \\
 & \boldmath\textbf{ATP} & \boldmath\textbf{0.574} & 0.6242 & \boldmath\textbf{0.5814} & 0.6405 & \boldmath\textbf{0.5756}\\ \midrule


P@3 & CQARank & 0.5855 & 0.5144 & 0.699 & 0.552 & 0.67\\
 & QDEE &	0.7094 &	0.8019 &	0.6888 &	0.7455 &	0.6566 \\
 & ColdRoute & 	0.6581 & 	0.7796 & 	0.7194 & 	0.7741 & 	0.6869 \\
 & \boldmath\textbf{ATP} & \boldmath\textbf{0.7564} & \boldmath\textbf{0.8179} & \boldmath\textbf{0.7398} & \boldmath\textbf{0.8064} & \boldmath\textbf{0.7205} \\ \midrule 

Acc. & CQARank & 	0.5555 & 	0.4979 & 	0.6483 & 	0.5693 & 	0.6134\\
 & QDEE  & 	0.6852 & 	0.737 & 	0.6401	 & 0.711 & 	0.6218 \\
 & ColdRoute & 	0.6324 & 	0.7387 & 	0.6354	 & 0.7369 & 	0.6404\\
 & \boldmath\textbf{ATP} & 	\boldmath\textbf{0.7041} & 	\boldmath\textbf{0.7504} & 	\boldmath\textbf{0.6895} & 	\boldmath\textbf{0.7695}	 & \boldmath\textbf{0.6713}\\
  \bottomrule
 \end{tabular}
\label{tab:ATP_ColdQuestion_Routing_Table}
\end{table}



\begin{comment}
\begin{figure*}
        \centering
        \begin{subfigure}[b]{0.48\textwidth}
            \centering
            \includegraphics[width=\textwidth]{pics/ATP_ColdQuestion_Routing_MRR_EGA}
            \caption[MRR]{{\small MRR}}    
            \label{fig:mean and std of net14}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.48\textwidth}  
            \centering 
            \includegraphics[width=\textwidth]{pics/ATP_ColdQuestion_Routing_Accuracy_EGA}
            \caption[]{{\small Accuracy}}    
            \label{fig:mean and std of net24}
        \end{subfigure}
        \vskip\baselineskip
        \begin{subfigure}[b]{0.48\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{pics/ATP_ColdQuestion_Routing_P1_EGA}
            \caption[]{{\small Precision$@$1}}    
            \label{fig:mean and std of net34}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.48\textwidth}   
            \centering 
            \includegraphics[width=\textwidth]{pics/ATP_ColdQuestion_Routing_P3_EGA}
            \caption[]{{\small Precision$@$3}}    
            \label{fig:mean and std of net44}
        \end{subfigure}
        \caption[]
        {\small Cold Question Routing Performance of ATP on Competition Graphs w/wo EGA} 
        \label{fig:ATP_EGA_ColdStart_ExistingAsker}
\end{figure*}
\end{comment}



\section{Conclusion}
\label{sec:conclusion}

In this paper, we have proposed a novel asymmetric transitivity preserving directed graph embedding framework (ATP).
Our scalable embedding technique incorporates both graph hierarchy and reachability information by constructing a novel asymmetric matrix, which is a non-linear transformation of an adjacency matrix (graph reachability) and a diagonal matrix (graph hierarchy).
An efficient factorization based approach is used to generate two embedding vectors for each node to capture the asymmetric transitivity.

With incorporating graph hierarchy and reachability, ATP can perform better than the state-of-the-art in various tasks such as link prediction, and question difficulty estimation and cold question routing in CQAs. And we have proposed several approaches to combine both graph hierarchy and reachability inside a unified framework, and empirically the non-linear transformation works the best.  


As extension of current study, we plan to apply our model to other applications such as community detection in dynamic networks~\cite{wang2018spread} and exception-tolerant abduction ~\cite{Zhang2017AAAI} in attributed networks~\cite{SEANO}. We also would like to address the problem of routing newly posted questions (item cold-start) to newly registered users (user cold-start) in CQAs, with hoping to increase the expertise of the entire community.

 {\bf Acknowledgments} This work is supported by NSF grants CCF-1645599, IIS-1550302, and CNS-1513120, RI xxxxxx, and a grant from the Ohio Supercomputer Center (PAS0166). All content represents the opinion of the authors, which is not necessarily shared or endorsed by their sponsors.



\bibliographystyle{aaai}
\bibliography{sigproc}


\end{document}
