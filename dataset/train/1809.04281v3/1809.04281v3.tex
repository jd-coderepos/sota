\documentclass{article} \usepackage{iclr2019_conference,times}













\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 



\usepackage{savenotes}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{algpseudocode}
\usepackage{algorithm}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{multicol}


\usepackage{amsmath, amsthm, amssymb, bm}

\usepackage{xcolor}
\newcommand{\CHECK}[1]{\textbf{\textcolor{red}{#1}}}



\title{Music Transformer: \newline Generating music with long-term structure}









\author{Cheng-Zhi Anna Huang\thanks{Google AI Resident. Correspondence to: Cheng-Zhi Anna Huang <annahuang@google.com>} ~~
Ashish Vaswani ~~
Jakob Uszkoreit ~~
Noam Shazeer\\
\And
Ian Simon ~~
Curtis Hawthorne ~~
Andrew M. Dai ~~
Matthew D. Hoffman\\
\AND
Monica Dinculescu ~~
Douglas Eck\\\rule{0pt}{10pt}Google Brain \\
}





\iclrfinalcopy \begin{document}




\maketitle

\begin{abstract}
Music relies heavily on repetition to build structure and meaning.  Self-reference occurs on multiple timescales, from motifs to phrases to reusing of entire sections of music, such as in pieces with ABA structure.  The Transformer~\citep{vaswani2017attention}, a sequence model based on self-attention, has achieved compelling results in many generation tasks that require maintaining long-range coherence. This suggests that self-attention might also be well-suited to modeling music. In musical composition and performance, however, relative timing is critically important.
\iffalse
\CHECK{Existing approaches for representing relative positional information use pairwise distance to modulate attention~\citep{shaw2018self}.  Their approach for long sequences such as musical compositions since their memory complexity grow super quadratically with sequence length.
We propose an algorithm that reduces the intermediate memory requirements of the relative positional information to linear in the sequence length, allowing the overall memory to be only quadratic.}
\fi
Existing approaches for representing relative positional information in the Transformer modulate attention based on pairwise distance~\citep{shaw2018self}.  This is impractical for long sequences such as musical compositions since their memory complexity for intermediate relative information is quadratic in the sequence length.
We propose an algorithm that reduces their intermediate memory requirement to linear in the sequence length. 
This enables us to demonstrate that a Transformer with our modified relative attention mechanism can generate minute-long compositions (thousands of steps, four times the length modeled in~\citet{oore2018time}) with compelling structure, generate continuations that coherently elaborate on a given motif, and in a seq2seq setup generate accompaniments conditioned on melodies\footnote{Samples are available for listening at \newline \url{https://storage.googleapis.com/music-transformer/index.html}}. We evaluate the Transformer with our relative attention mechanism on two datasets, JSB Chorales and Piano-e-Competition, and obtain state-of-the-art results on the latter.


\end{abstract}

\section{Introduction}
A musical piece often consists of recurring elements at various levels, from motifs to phrases to sections such as verse-chorus. To generate a coherent piece, a model needs to reference elements that came before, sometimes in the distant past, repeating, varying, and further developing them to create contrast and surprise.
Intuitively, self-attention~\citep{parikh2016decomposable} appears to be a good match for this task. Self-attention over its own previous outputs allows an autoregressive model to access any part of the previously generated output at every step of generation. By contrast, recurrent neural networks have to learn to proactively store elements to be referenced in a fixed size state or memory, potentially making training much more difficult.
We believe that repeating self-attention in multiple, successive layers of a Transformer decoder~\citep{vaswani2017attention} helps capture the multiple levels at which self-referential phenomena exist in music.



In its original formulation, the Transformer relies on absolute position representations, using either positional sinusoids or learned position embeddings that are added to the per-position input representations. Recurrent and convolutional neural networks instead
model position in relative terms: RNNs through their recurrence over the positions in their input, and CNNs by applying kernels that effectively choose which parameters to apply based on the relative position of the covered input representations.

Music has multiple dimensions along which relative differences arguably matter more than their absolute values; the two most prominent are timing and pitch. To capture such pairwise relations between representations, \citet{shaw2018self} introduce a relation-aware version of self-attention which they use successfully to modulate self-attention by the distance between two positions. We extend this approach to capture relative timing and optionally also pitch, which yields improvement in both sample quality and perplexity for JSB Chorales. As opposed to the original Transformer, 
samples from a Transformer with our relative attention mechanism maintain the regular timing grid present in this dataset.
The model furthermore captures global timing, giving rise to regular phrases.


The original formulation of relative attention~\citep{shaw2018self} requires  memory where  is the sequence length and  is the dimension of the model's hidden state. This is prohibitive for long sequences such as those found in the Piano-e-Competition dataset of human-performed virtuosic, classical piano music. In Section~\ref{fast}, we show how to reduce the memory requirements to , making it practical to apply relative attention to long sequences.

The Piano-e-Competition dataset consists of MIDI recorded from performances of competition participants, bearing expressive dynamics and timing on the granularity of < 10 miliseconds. 
\iffalse
Discretizing time on a fixed grid will yield sequences that are too long.
\fi
Discretizing time on a fixed grid that would yield unnecessarily long sequences as not all events change on the same timescale.
We hence adopt a sparse, MIDI-like, event-based representation from~\citep{oore2018time}, allowing a minute of music with 10 milisecond resolution to be represented at lengths around 2K, as opposed to 6K to 18K on a fixed-grid representation with multiple performance attributes.
As position in sequence no longer corresponds to time, a priori it is not obvious that relative attention should work as well with such a representation.
However, we will show in Section~\ref{sec:pianoecompetition} that it does improve perplexity and sample quality over strong baselines.


We speculate that idiomatic piano gestures such as scales, arpeggios and other motifs all exhibit a certain grammar and recur periodically, hence knowing their relative positional distances makes it easier to model this regularity. 
This inductive bias towards learning relational information, as opposed to patterns based on absolute position, suggests that the Transformers with relative attention could generalize beyond the lengths it was trained on, which our experiments in Section~\ref{sec:priming} confirm.








































\subsection{Contributions}

\iffalse
In this work, we make two main contributions. We offer an algorithmic improvement to the relative self attention mechanism~\citep{shaw2018self}, that dramatically reduces it's memory consumption from  to .  First, we are able to improve the memory consumption of the relative attention mechanism proposed in \citep{shaw2018self}. By transforming between absolute and relative position based tensors, as further described in Section~\ref{fast}, we reduce memory usage of the relative-position based tensor instantiations from  to , where  is the length of the sequence, and  the hidden size of the model. 
\fi

\iffalse
We show the first successful use of Transformer in generating music that exhibits long-term structure, specifically sequences that capture at once a musical composition and an expressive performance of that composition on the piano.  
\fi
\iffalse
Our model achieves state-of-the-art perplexity on the Piano-e-Competition data set.
This is a challenging task as it requires modeling music composition and the expressive performance of that composition on the piano at once, ranging timescales at nearly 4 orders of magnitude from 0.01s to 60s, resulting in sequence lengths of around 2000 tokens. 
This is a significant improvement in addressing long-term structure over \citep{oore2018time} that used LSTM-RNNs to generate 15s (500 tokens) of music.
\fi
\iffalse
Our model achieves state-of-the-art perplexity on the Piano-e-Competition data set. The relative attention mechanism is essential to the model's quality. In listening tests (see Section~\ref{sec:listening})
samples from models with relative self-attention were perceived as more coherent than the baseline Transformer model from~\cite{vaswani2017attention}.  
\fi

\textbf{Domain contributions}\hspace{1em} We show the first successful use of Transformers in generating music that exhibits long-term structure.
Before our work, LSTMs were used at timescales of 15s (\textasciitilde500 tokens) on the Piano-e-Competition dataset (Oore et al., 2018).  Our work show that Transformers not only achieve state-of-the-art perplexity on modeling these complex expressive piano performances, but can also generate them at the scale of 60s (\textasciitilde2000 tokens) with remarkable internal consistency.
Our relative attention mechanism is essential to the model's quality.
In listening tests (see Section~\ref{sec:listening}),
samples from models with relative self-attention were perceived as more coherent than the baseline Transformer model from~\cite{vaswani2017attention}.  Relative attention not only enables Transformers to generate continuations that elaborate on a given motif, but also to generalize and generate in consistent fashion beyond the length it was trained on (see Section~\ref{sec:priming}). In a seq2seq setup, Transformers can generate accompaniments conditioned on melodies, enabling users to interact with the model.



\textbf{Algorithmic contributions}\hspace{1em} The space complexity of the relative self attention mechanism in its original formulation~\citep{shaw2018self} made it infeasible to train on sequences of sufficient length to capture long-range structure in longer musical compositions.
Addressing this we present a crucial algorithmic improvement to the relative self attention mechanism, dramatically reducing its memory requirements from  to . For example, we reduce the memory consumption per layer from  GB to  MB (per head from  GB to  MB) for a sequence of length  and hidden-state size  (per head , where number of heads is ) (see Table~\ref{table:complexity}), allowing us to use GPUs to train the relative self-attention Transformer on long sequences.












\section{Related work}
Sequence models have been the canonical choice for modeling music, from Hidden Markov Models to RNNs 
and Long Short Term Memory networks \citep[e.g., ][]{eck2002finding, liang2016bachbot,oore2018time}, 
to bidirectional LSTMs \citep[e.g., ][]{hadjeres2016deepbach}.
Successful application of sequential models to polyphonic music often requires serializing the musical score or performance into a single sequence, for example by interleaving different instruments or voices.  
Alternatively, a 2D pianoroll-like representation (see~\ref{sec:bach} for more details) can be decomposed into a sequence of multi-hot pitch vectors, and their joint probability distributions can be captured using Restricted Boltzmann Machines \citep{smolensky1986information,hinton2006fast}
or Neural Autoregressive Distribution Estimators 
\citep[NADE; ][]{larochelle2011neural}.
Pianorolls are also image-like and can be modeled by CNNs trained either as generative adversarial networks \citep[e.g., ][]{dong2017musegan} 
or as orderless NADEs~\citep{uria2014deep,uria2016neural}~\citep[e.g., ][]{huang2017coconet}.





\citet{lattner2016imposing} use self-similarity in style-transfer fashion, where the self-similarity structure of a piece serves as a template objective for gradient descent to impose similar repetition structure on an input score.
Self-attention can be seen as a generalization of self-similarity; the former maps the input through different projections to queries and keys, and the latter uses the same projection for both.

Dot-product self-attention is the mechanism at the core of the Transformer, and several recent works have focused on applying and improving it for image generation, speech, and summarization~\citep{parmar2018image,povey2018time,liu2018generatin}.
A key challenge encountered by each of these efforts is scaling attention computationally to long sequences. This is because the time and space complexity of self-attention grows quadratically in the sequence length. For relative self-attention~\citep{shaw2018self} this is particularly problematic as the space complexity also grows linearly in the dimension, or depth, of the per-position representations.










\section{Model}

\subsection{Data representation}
\label{sec:representation}
We take a language-modeling approach to training generative models for symbolic music.  Hence we represent music as a sequence of discrete tokens, with the vocabulary determined by the dataset.  Datasets in different genres call for different ways of serializing polyphonic music into a single stream and also discretizing time.

The JSB Chorale dataset consists of four-part scored choral music, which can be represented as a matrix where rows correspond to voices and columns to time discretized to sixteenth notes. The matrix's entries are integers that denote which pitch is being played.  This matrix can than be serialized in raster-scan fashion by first going down the rows and then moving right through the columns (see~\ref{sec:bach} for more details).
Compared to JSB Chorale, the piano performance data in the Piano-e-Competition dataset includes expressive timing information at much finer granularity and more voices.
For the Piano-e-Competition we therefore use the performance encoding proposed by~\citet{oore2018time} which consists of a vocabulary of 128 \texttt{NOTE\_ON} events, 128 \texttt{NOTE\_OFF}s, 100 \texttt{TIME\_SHIFT}s allowing for expressive timing at 10ms and 32 \texttt{VELOCITY} bins for expressive dynamics (see~\ref{sec:event-based} for more details).  








\subsection{Background: Self-attention in Transformer}

The Transformer decoder is a autoregressive generative model that uses primarily self-attention mechanisms, and learned or sinusoidal position information.  Each layer consists of a self-attention sub-layer followed by a feedforward sub-layer.

\iffalse
The Transformer decoder is an autoregressive generative model, using primarily self-attention mechanisms.  Positional sinusoids are added to the embeddings of the input sequence~\citep{vaswani2017attention}.  Each layer consists of two sub-layers, a self-attention sub-layer and a feedforward sub-layer.


\fi
The attention layer first transforms a sequence of  -dimensional vectors  into queries , keys , and values , where , , and  are each  square matrices. Each  query, key, and value matrix is then split into   parts or attention heads, indexed by , and with dimension , which allow the model to focus on different parts of the history. 
The scaled dot-product attention computes a  sequence of vector outputs for each head as
 
The attention outputs for each head are concatenated and linearly transformed to get , a  by  dimensional matrix. A upper triangular mask ensures that queries cannot attend to keys later in the sequence. For other details of the Transfomer model, such as residual connections and learning rates, the reader can refer~\cite{vaswani2017attention}.
\iffalse
More specifically, each input position  is represented as a  dimensional vector, which is then projected through different weight matrices to form a queries , keys  and values , as in Equation~\ref{eqn:projection}.


Multiple heads are typically used to allow the model to focus on different parts of the history.  These are supported by first splitting the queries, keys, and values into  parts on the depth  dimension. 

Equation~\ref{eqn:attention} shows how multi-head attention between the queries and keys are computed in tensor form using einsum-like notation, where  corresponds to the batch index,  to heads,  to indexing over the query length,  over the key length, and  corresponds to the hidden size of the model.  

For tasks akin to language modeling, the upper triangle on the last two dimensions  and  of the  is masked out as it corresponds to key positions that are in the future with respect to the queries.
The softmax is then performed over key positions, resulting in a weighted summary of .





\fi
The feedforward (FF) sub-layer then takes the output  from the previous attention sub-layer, and performs two layers of point-wise dense layers on the depth  dimension, as shown in Equation~\ref{eqn:dense}.   are weights and biases of those two layers.



\subsection{Relative positional self-attention} \label{subsec:relposatt}

As the Transformer model relies solely on positional sinusoids to represent timing information, \cite{shaw2018self} introduced relative position representations to allow attention to be informed by how far two positions are apart in a sequence.  This involves learning a separate relative position embedding  of shape , which has an embedding for each possible pairwise distance  between a query and key in position  and  respectively. The embeddings are ordered from distance  to , and are learned separately for each head. In~\cite{shaw2018self}, the relative embeddings interact with queries and give rise to a , an  dimensional logits matrix which modulates the attention probabilities for each head as:

We dropped head indices for clarity. Our work uses the same approach to infuse relative distance information in the attention computation, while significantly improving upon the memory footprint for computing .
For each head, \cite{shaw2018self} instantiate an intermediate tensor  of shape , containing the embeddings that correspond to the relative distances between all keys and queries.
 is then reshaped to an  tensor, and .\footnote{We assume that the batch size is  here. With a batch size of ,  would be reshaped to  and  would be computed with a batch matrix--matrix product.}
This incurs a total space complexity of , restricting its application to long sequences.

\iffalse
To use these embeddings, an intermediate tensor  of shape  is instantiated to gather for each  by  position, the embedding that corresponds to their relative distance  - .


 
Dropping head indices for clarity, the attention operation for each head is now

\fi



\subsection{Memory efficient implementation of relative position-based attention}
\label{fast}
We improve the implementation of relative attention by reducing its intermediate memory requirement from  to , with example lengths shown in Table~\ref{table:complexity}.  We observe that all of the terms we need from  are already available if we directly multiply  with , the relative position embedding.
After we compute , its  entry contains the dot product of the query in position  with the embedding of relative distance . However, each relative logit  in the matrix  from Equation~\ref{eqn:relative_dist} should be the dot product of the query in position  and the embedding of the relative distance , to match up with the indexing in .  We therefore need to ``skew''  so as to move the relative logits to their correct positions, as illustrated in Figure \ref{fig:global_skew} and detailed in the next section. 
The time complexity for both methods are ,
while in practice our method is 6x faster at length 650.


\begin{figure}[H]
\vskip -0.05in
\begin{center}
\centerline{\includegraphics[width=0.9\columnwidth]{attention_figures/relative_global_skew.png}}
\caption{Relative global attention: the bottom row describes our memory-efficient ``skewing'' algorithm, which does not require instantiating  (top row, which is .  Gray indicates masked or padded positions. Each color corresponds to a different relative distance.}
\label{fig:global_skew}
\end{center}
\vskip -0.2in
\end{figure}

\begin{table}[h]
  \caption{Comparing the overall relative memory complexity (intermediate relative embeddings ( or ) + relative logits ), the maximal training lengths that can fit in a GPU with 16GB memory assuming , and the memory usage per layer per head (in MB).}
  \label{table:complexity}
  \centering
  \begin{tabular}{lllllll}
    \toprule
    Implementation      & Relative memory  & Maximal  &   &  &  \\
    \midrule
    \cite{shaw2018self} &  & 650   & 108 + 1.7  & 1100 + 16 &  3100 + 49 \\
    Ours &                   & 3500  & 0.17 + 1.7   & 0.52 + 16 & 0.90 + 49 \\
\bottomrule
  \end{tabular}
\end{table}








\subsubsection{The ``skewing'' procedure}
Hence, we propose a ``skewing'' procedure to transform an absolute-by-relative  indexed matrix into an absolute-by-absolute  indexed matrix.  
The row indices  stay the same while the columns indices are shifted according to the following equation: . For example in Figure~\ref{fig:global_skew} the upper right green dot in position  of  after skewing has a column index of , resulting in a position of  in .

We outline the steps illustrated in Figure~\ref{fig:global_skew} below.
 




1. Pad a dummy column vector of length  before the leftmost column. 

2. Reshape the matrix to have shape . (This step assumes NumPy-style row-major ordering.)


3. Slice that matrix to retain only the last  rows and all the columns, resulting in a  matrix again, but now absolute-by-absolute indexed, which is the  that we need. 



\subsection{Relative local attention}
For very long sequences, the quadratic memory requirement of even baseline Transformer is impractical.  Local attention has been used for example in Wikipedia and image generation~\citep{liu2018generatin,parmar2018image} by chunking the input sequence into non-overlapping blocks.  Each block then attends to itself and the one before, as shown by the smaller thumbnail on the top right corner of Figure~\ref{fig:rel_local_skew}.  

To extend relative attention to the local case, we first note that the right block has the same configuration as in the global case (see Figure~\ref{fig:global_skew}) but much smaller: 
(where  is the number of blocks, and  be the resulting block length) as opposed to .  The left block is unmasked with relative indices running from -1 (top right) to - (bottom left).  Hence, the learned  for the local case has shape .

Similar to the global case, we first compute  and then use the following procedure to skew it to have the same indexing as , as illustrated in Figure~\ref{fig:rel_local_skew}. 

1. Pad a dummy column vector of length  after the rightmost column. 

2. Flatten the matrix and then pad with a dummy row of length . 


3. Reshape the matrix to have shape .


4. Slice that matrix to retain only the first  rows and last  columns, resulting in a  matrix. 




\begin{figure}[H]
\vskip -0.05in
\begin{center}
\centerline{\includegraphics[width=1.0\columnwidth]{attention_figures/relative_local_skew.png}}
\caption{Relative local attention: the thumbnail on the right shows the desired configuration for .  The ``skewing'' procedure is shown from left to right.}
\label{fig:rel_local_skew}
\end{center}
\vskip -0.2in
\end{figure}




\section{Experiments} \label{exp}


\subsection{J.S. Bach Chorales}

J.S. Bach chorales is a canonical dataset used for evaluating generative models for music~\footnote{J.S. Bach chorales dataset: \url{https://github.com/czhuang/JSB-Chorales-dataset}} 
\citep[e.g., ][]{allan2005harmonising,boulanger2012modeling,liang2016bachbot,hadjeres2016style,huang2017coconet}.  It consists of score-based four-part chorales.  We first discretize the scores onto a 16th-note grid, and then serialize it by iterating through all the voices within a time step and then advancing time (see~\ref{sec:bach} for more details).  As there is a direct correspondence between position in sequence and position on the  timing/instrument grid in a piece, adding relative position representations could make it easier to learn this grammar. 
We indeed see relative attention drastically improve negative log-likelihood (NLL) over baseline Transformer (Table~\ref{bach_nll}).  
This improvement is also reflected in sample quality.  The samples now maintain the necessary timing/instrument grid, always advancing four steps before advancing in time. 
As local timing is maintained, the model is able to capture timing on a more global level, giving rise to regular phrasing, as shown in Figure~\ref{fig:bach_sample}.





\begin{figure}[H]
\vskip -0.05in
\begin{center}
\centerline{\includegraphics[width=0.9\columnwidth]{attention_figures/bach_samples_wo_first_column_mark.pdf}}
\caption{Unconditioned samples from Transformer without (left) and with (right) relative self-attention. Green vertical boxes indicate the endings of (sub)phrases where cadences are held.}
\label{fig:bach_sample}
\end{center}
\vskip -0.2in
\end{figure}


In addition to relative attention, we also explored enhancing absolute timing through concatenating instead of adding the sinusoids to the input embeddings.  This allows the model to more directly learn its absolute positional mapping.  This further improves performance for both the baseline and relative transformer (Table~\ref{bach_nll}). 
We compare against {\sc Coconet} as it is one of the best-performing models that has also been evaluated on the 16-note grid using the canonical dataset split.
To directly compare, we re-evaluated {\sc Coconet} to obtain note-wise losses on the validation set~\footnote{Some earlier papers report frame-wise losses to compare to models such as RNN-RBM which model ``chords''.  Coconet can be evaluated under note-wise or frame-wise losses.}.
For the Transformer models (abbreviated as {\sc TF}), 
we implemented our attention mechanisms in the Tensor2Tensor framework~\citep{tensor2tensor}.  We use 8 heads, and keep the query, key (att) and value hidden size (hs) fixed within a config.
We tuned number of layers (L in \{4,5,6\}), attention hidden size (att in \{256, 512\}) and pointwise feedforward hidden size (ff in \{512, 1024\}).



\subsubsection{Generalizing relative attention to capture relational information}
A musical event bears multiple attributes, such as timing, pitch, instrument etc.  To capture more relational information, we extend relative attention to capture pairwise distances on additional attributes. We learn separate relative embeddings for timing  and also pitch .   has entries corresponding to how many sixteenth notes apart are two positions, while  embeds the pairwise pitch interval.
\iffalse
We call this relative music attention, where additional relative terms can be added to modulate attention (Equation~\ref{music_attention}). 
\fi
However this approach is not directly scalable beyond J.S. Bach Chorales because it involves explicitly gathering relative embeddings for  and , resulting in a memory complexity of  as in~\cite{shaw2018self}.  This is due to relative information being computed based on content as opposed to content-invariant information such as position in sequence.  
It was sufficient to add the extra timing signals to the first layer, perhaps because it is closest to the raw input content. Here, the relative logits are computed from three terms,  in contrast with other layers that only have one term, .

\iffalse

\fi


\subsection{Piano-e-Competition}
\label{sec:pianoecompetition}

We use the first 6 years of of Piano-e-Competition because these years have corresponding MIDI data released~\footnote{Piano-e-Competition dataset (competition history): \url{http://www.piano-e-competition.com/}}, resulting in about 1100 pieces, split 80/10/10. 
Each piece is MIDI data capturing a classical piano performance with expressive dynamics and timing, encoded with the MIDI-like representation described in Section~\ref{sec:event-based}.
We trained on random crops of 2000-token sequences and employed two kinds of data augmentation:  pitch transpositions uniformly sampled from  half-steps, and time stretches uniformly sampled from the set .

We compare to Magenta's PerformanceRNN (LSTM, which first used this dataset)~\citep{oore2018time} and LookBack RNN (LSTM with attention)~\citep{waite2016generating}. 
LookBack RNN uses an input representation that requires monophonic music with barlines which is information that is not present in performed polyphonic music data, hence we simply adopt their architecture. Table~\ref{performance_nll} shows that Transformer-based architectures fits this dataset better than LSTM-based models.  

\begin{savenotes}
\begin{table}[h]
  \caption{Note-wise validation NLL on J.S.Bach Chorales at 16th notes.  Relative attention, more timing and relational information improve performance.}
  \label{bach_nll}
  \centering
  \begin{tabular}{ll}
    \toprule
    Model variation     & Validation NLL      \\
    \midrule
    {\sc Coconet} (CNN, chronological, 64L, 128 3x3f) &   \\
    {\sc Coconet} (CNN, orderless, 64L, 128 3x3f) &  ~\footnote{{\sc Coconet} is an instance of OrderlessNADE, an ensemble over orderings.  The chronological loss evaluates the model as autoregressive, from left to right.  We can also evaluate the model as a mixture, by averaging its losses over multiple random orderings.  This is a lower bound on log-likelihood.  It is intractable to sample from exactly but can be approximated through Gibbs sampling.} \\
    \midrule
Transformer (TF) baseline~\citep{vaswani2017attention} (5L, 256hs, 256att, 1024ff, 8h) &  \\
TF baseline + concat positional sinusoids (cps) &  \\
    TF baseline + concat positional sinusoids, instrument labels (cpsi) &  \\
\midrule
    Relative Transformer~\citep{shaw2018self} (5L, 512hs, 512att, 512ff, 256r, 8h) &  \\
Relative Transformer + concat positional sinusoids, instrument labels (cpsi)  &  \\
Relative Transformer + cpsi + relative pitch and time&  \\
    \bottomrule
  \end{tabular}
\end{table}
\end{savenotes}

\begin{table}[h]
  \caption{Validation NLL for Piano-e-Competition dataset, with event-based representation with lengths .  Transformer with relative attention (with our efficient formulation) achieves state-of-the-art performance.}
  \label{performance_nll}
  \centering
  \begin{tabular}{ll}
    \toprule
    Model variation     & Validation NLL      \\
    \midrule
   {\sc Performance RNN} (LSTM) (3L, 1024hs)  &  \\ 
   LSTM with attention (3L, 1024hs, 1024att) & \\
   \midrule
    Transformer (TF) baseline (6L, 256hs, 512att, 2048fs, 1024r, 8h) &  \\
    TF with local attention~\citep{liu2018generatin} (8L, 1024fs, 512bs) &  \\
    TF with relative global attention (our efficient formulation) (6L, 2048fs, 1024r) & \textbf{1.835} \\
TF with relative local attention (ours) (6L, 1024fs, 2048r, 512bs) & \textbf{1.840}\\
\bottomrule
  \end{tabular}
\end{table}

We implemented our attention mechanisms in the Tensor2Tensor framework~\citep{tensor2tensor}, and used the default hyperparameters for training, with 0.1 learning rate, 0.1 dropout, and early stopping.
We compare four architectures, varying on two axes: global versus local, and regular versus relative attention. 
We found that reducing the query and key hidden size (att) to half the hidden size (hs) works well and use this relationship for all of the models, while tuning on number of layers (L) and filter size (fs). We use block size (bs) 512 for local attention. We set the maximum relative distance to consider to half the training sequence length for relative global attention, and to the full memory length (which is two blocks) for relative local attention.
Table~\ref{performance_nll} show that relative attention (global or local) outperforms regular self-attention (global or local). All else being equal, local and global attention perform similarly.  Each though local attention does not see all the history at once, it can build up a larger receptive field across layers.  This can be an advantage in the future for training on much longer sequences, as local attention requires much less memory.










\begin{figure}[H]
\vskip -0.1in
\begin{center}
\centerline{\includegraphics[width=1.05\columnwidth]{attention_figures/perf_samples2.pdf}}
\caption{Comparing how models continue a prime (top left).  Repeated motives and structure are seen in samples from Transformer with relative attention (top row), but less so from baseline Transformer (middle row) and PerformanceRNN (LSTM) (bottom row).}
\label{fig:perf_sample}
\end{center}
\vskip -0.2in
\end{figure}

\subsubsection{Qualitative priming experiments} \label{sec:priming}
When primed with an initial motif (Chopin's Ã‰tude Op. 10, No. 5)
shown in the top left corner of Figure~\ref{fig:perf_sample}, we see the models perform qualitatively differently. Transformer with relative attention elaborates the motif and creates phrases with clear contour which are repeated and varied.  Baseline Transformer uses the motif in a more uniform fashion, while LSTM uses the motif initially but soon drifts off to other material.   
Note that the generated samples are twice as long as the training sequences.  Relative attention was able to generalize to lengths longer than trained but baseline Transformer deteriorates beyond its training length. See Appendix~\ref{vis} for visualizations of how the our Relative Transformer attends to past motifs.












\subsubsection{Harmonization: Conditioning on melody}
\begin{table}[h]
\begin{minipage}[c]{0.60\columnwidth}
To explore the sequence-to-sequence setup of Transformers, we experimented with a conditioned generation task where the encoder takes in a given melody and the decoder has to realize the entire performance, i.e. melody plus accompaniment.  The melody is encoded as a sequence of tokens as in \citet{waite2016generating}, quantized to a 100ms grid, while the decoder uses the performance encoding described in Section~\ref{sec:representation} (and further illustrated in~\ref{sec:event-based}).  We use relative attention on the 
decoder side and show in Table~\ref{table:melody_nll} it also improves performance.
\end{minipage}
\hspace{0.3cm}
\begin{minipage}[c]{0.37\columnwidth}


\caption{Validation conditional NLL given groundtruth melody from Piano-e-Competition.}
\label{table:melody_nll}
\centering
\begin{tabular}{ll}
\toprule
Model variation     & NLL\\\midrule
Baseline Transformer &  \\
Relative Transformer (ours) &  \\
\bottomrule
\end{tabular}

\end{minipage}
\end{table}



\vskip -0.6in
\subsubsection{Human evaluations}
\label{sec:listening}
To compare the perceived sample quality of models trained on the Piano-e-Competition dataset, and their ability to generate a continuation for a priming sequence, we carried out a listening test study comparing the baseline Transformer, our Transformer with relative-attention, PerformanceRNN (LSTM), and the validation set. Participants were presented with two musical excerpts (from two different models that were given the same priming sequence) and asked to rate which one is more musical on a Likert scale.  For each model, we generated 10 samples each with a different prime, and compared them to three other models, resulting in 60 pairwise comparisons.  Each pair was rated by 3 different participants, yielding a total of 180 comparisons.   


Figure \ref{fig:listening_tests} shows the number of comparisons in which an excerpt from each model was selected as more musical.  The improvement in sample quality from using relative attention over the baseline Transformer model was statistically significant (see Appendix~\ref{appendix:listening} for the analysis), both in aggregate and between the pair.  
Even though in aggregate LSTMs performed better in the study than the Transformer, despite having higher perplexity, but when compared against each other head to head, the results were not statistically significant (see Table~\ref{table:listening_pairs} in Appendix~\ref{appendix:listening}). 
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.6\columnwidth]{attention_figures/listening_test.pdf}


\captionof{figure}{Number of wins for each model. Error bars show standard deviations of mean.}
\label{fig:listening_tests}
\end{center}
\end{figure}



\section{Conclusion}

In this work we demonstrated that the Transformer equipped with relative attention is very well-suited for generative modeling of symbolic music. The compelling long-term structure in the samples from our model leaves us enthusiastic about this direction of research. Moreover, the ability to expand upon a primer, in particular, suggests potential applications as creative tool.

The significant improvement from relative attention highlights a shortcoming of the original Transformer that might also limit its performance in other domains. Improving the Transformer's ability to capture periodicity at various time scales, for instance, or relations between scalar features akin to pitch could improve time-series models.
Our memory-efficient implementation enables the application of relative attention to much longer sequences such as long texts or even audio waveforms, which significantly broadens the range of problems to which it could be applied.



\section{Acknowledgement}
We thank many colleagues from the Transformer~\citep{vaswani2017attention} and Tensor2Tensor~\citep{tensor2tensor} papers for helping us along the way: Lukasz Kaiser, Ryan Sepassi, Niki Parmar and Llion Jones.  Many thanks to Magenta and friends for their support throughout and for many insightful discussions: Jesse Engel, Adam Roberts, Fred Bertsch, Erich Elsen, Sander Dieleman, Sageev Oore, Carey Radebaugh, Natasha Jaques, Daphne Ippolito, Sherol Chan, Vida Vakilotojar, Dustin Tran, Ben Poole and Tim Cooijmans. 









\bibliographystyle{iclr2019_conference}
\bibliography{iclr2019_conference}

\newpage
\appendix
\section{Domain-specific representations}
\label{domain}
Adapting sequence models for music requires making decisions on how to serialize a polyphonic texture.  The data type, whether score or performance, makes certain representations more natural for encoding all the information needed while still resulting in reasonable sequence lengths.  

















\subsection{Serialized instrument/time grid (J.S.Bach Chorales)}
\label{sec:bach}
The first dataset, J.S. Bach Chorales, consists of four-part score-based choral music.  The time resolution is sixteenth notes, making it possible to use a serialized grid-like representation.  Figure~\ref{figure:bach} shows how a pianoroll (left) can be represented as a grid (right), following~\citep{huang2017coconet}.  The rows show the MIDI pitch number of each of the four voices, from top to bottom being soprano (), alto (), tenor () and bass (), while the columns is discretized time, advancing in sixteenth notes.  Here longer notes such as quarter notes are broken down into multiple repetitions.  
To serialize the grid into a sequence, we interleave the parts by first iterating through all the voices at time step 1, and then move to the next column, and then iterate again from top to bottom, and so on.  The resulting sequence is , where the subscript gives the time step.  After serialization, the most common sequence length is 1024.  Each token is represented as onehot in pitch.














\begin{figure}[h]
    \centering
    \begin{subfigure}{.5\textwidth}
      \centering
      \includegraphics[width=\columnwidth]{attention_figures/bach_example.png}
    \end{subfigure}\hspace{0.1in}
    \begin{subfigure}{.25\textwidth}
          \footnotesize
          \texttt{S: 67, 67, 67, 67 \\
                  A: 62, 62, 62, 62 \\
                  T: 59, 59, 57, 57 \\
                  B: 43, 43, 45, 45 }
\end{subfigure}
  \caption{The opening measure of BWV 428 is visualized as a pianoroll (left, where the x-axis is discretized time and y-axis is MIDI pitch number), and encoded in grid representation with sixteenth note resolution (right). The soprano and alto voices have quarter notes at pitches G4 (67) and D4 (62), the tenor has eighth notes at pitches B3 (59) and A3 (57), and the bass has eighth notes at pitches A2 (45) and G2 (43).}
\label{figure:bach}
\end{figure}

\subsection{MIDI-like event-based (Piano-e-Competition)}
\label{sec:event-based}
The second dataset, Piano-e-Competition, consists of polyphonic piano performances with expressive timing and dynamics. The time resolution here is on the millisecond level, so a grid representation would result in sequences that are too long.  Instead, the polyphonic performance is serialized into a sequence of one hot encoded events as proposed in~\citep{oore2018time}.



First, the input MIDI files are preprocessed to extend note durations based on sustain pedal control events. The sustain pedal is considered to be down whenever a sustain control change is encountered with a value ; the sustain pedal is then considered up after a control change with a value . Within a period where the sustain pedal is down, the duration of each note is extended to either the beginning of the next note of the same pitch or the end of the sustain period, whichever happens first. If the original duration extends beyond the time when the sustain pedal is down, that original duration is used.

Next, the MIDI note events are converted into a sequence from the following set of vocabulary: 128 \verb|NOTE_ON| events for starting a note of with one of the 128 MIDI pitches, 128 \verb|NOTE_OFF| events for ending a note with one of the 128 MIDI pitches, 100 \verb|TIME_SHIFT| events representing forward time shifts in 10ms increments from 10ms to 1s, and 32 \verb|SET_VELOCITY| events representing the velocity for future \verb|NOTE_ON| events in the form of the 128 possible MIDI velocities quantized into 32 bins.  An example performance encoding is illustrated in Figure \ref{figure:performance}.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.4\textwidth}
      \centering
      \includegraphics[width=\columnwidth]{attention_figures/performance_example.png}
    \end{subfigure}\hspace{0.03in}
    \begin{subfigure}{.57\textwidth}
\scriptsize
        \texttt{SET\_VELOCITY<80>, NOTE\_ON<60> \\
            TIME\_SHIFT<500>, NOTE\_ON<64> \\
            TIME\_SHIFT<500>, NOTE\_ON<67> \\
            TIME\_SHIFT<1000>, NOTE\_OFF<60>, NOTE\_OFF<64>, NOTE\_OFF<67> \\
            TIME\_SHIFT<500>, SET\_VELOCITY<100>, NOTE\_ON<65> \\
            TIME\_SHIFT<500>, NOTE\_OFF<65>}
        
    \end{subfigure}
    
    
  \caption{A snippet of a piano performance visualized as a pianoroll (left) and encoded as performance events (right, serialized from left to right and then down the rows). A C Major chord is arpeggiated with the sustain pedal active. At the 2-second mark, the pedal is released, ending all of the notes. At the 3-second mark, an F is played for .5 seconds. The C chord is played at velocity 80 and the F is played at velocity 100.}
\label{figure:performance}
\end{figure}


\section{Supplement of listening test}
\label{appendix:listening}
\subsection{Study procedure}
Participants were presented with two musical excerpts that shared a common priming sequence. For each excerpt, the priming sequence was played, followed by 2.5 seconds of silence, followed by the priming sequence again and a continuation of that sequence. The continuations were either sampled from one of the models or extracted from our validation set.   We evaluated all possible pairs in the space of data and model samples, except from the same model. 
Each continuation had a length of 512 events using the encoding described in Section~\ref{sec:event-based}.  This corresponds to the length the models were trained on to remove the deteriorating effect that happens with baseline Transformer when asked to generate beyond the length it was trained on.  
Participants were asked which excerpt they thought was more musical on a Likert scale of 1 to 5.  The pair is laid out left versus right, with 1 indicating the left is much more musical, 2 the left is slightly more musical, 3 being a tie, 4 being the right is slightly more musical, and 5 the right is much more musical. 
For each model, we generated 10 samples each with a different prime, and compared them to three other models, resulting in 60 pairwise comparisons.  Each pair was rated by 3 different participants, yielding a total of 180 comparisons. 



















\subsection{Analysis}
\label{sec:listening_analysis}
A Kruskal-Wallis H test of the ratings showed that there was a statistically significant difference between the models: e-14. 
Table~\ref{table:listening_pairs} show a post-hoc analysis on the comparisons within each pair, using the Wilcoxon signed-rank test for matched samples.  
Table~\ref{table:listening_aggregates} shows a post-hoc analysis of how well each model performed when compared to all pairs, and compares each model's aggregate against each other, using the Mannâ€“Whitney U test for independent samples.  We use a Bonferroni correction on both to correct for multiple comparisons.
The win and loss counts bucket scores 4, 5 and scores 1, 2 respectively, while the tieing score is 3.

Both within pairs and between aggregates, participants rated samples from our relative Transformer as more musical than the baseline Transformer with . 

For within pairs, we did not observe a consistent statistically significant difference between the other model pairs, baseline transformer versus LSTM and LSTM versus relative Transformer.  

When comparing between aggregates, LSTM was overall perceived as more musical than baseline Transformer.  Relative Transformer came a bit close to outperforming LSTM with .  When we listen to the samples from the two, they do sound qualitatively different.   Relative Transformer often exhibits much more structure (as shown in Figure~\ref{fig:perf_sample}), but the effects were probably less pronounced in the listening test because we used samples around 10s to 15s, which is half the length of those shown in Figure~\ref{fig:perf_sample} to prevent the baseline Transformer from deteriorating.  This weakens the comparison on long-term structure.  


When compared to real music from the validation set, we see that in aggregates, real music was better than LSTM and baseline Transformer.  There was no statistical significant difference between real music and relative Transformer.  This is probably again due to the samples being too short as real music is definitely still better.


\begin{table}[h]
  \caption{A post-hoc comparison of each pair on their pairwise comparisons with each other, using the Wilcoxon signed-rank test for matched samples.  value less than 0.01/6=0.0016 yields a statistically significant difference and is marked by asterisk.}
  \label{table:listening_pairs}
  \centering
  \begin{tabular}{llrrrl}
    \toprule
    Pairs     & & wins & ties & losses &  value      \\
    \midrule
Our relative transformer & real music & 11 & 4 & 15 & 0.243\\
Our relative transformer & Baseline transformer & 23 & 1 & 6 &  0.0006*\\
Our relative transformer & LSTM  & 18 & 1 & 11 & 0.204 \\
Baseline transformer & LSTM & 5 & 3 & 22 & 0.006 \\
Baseline transformer & real music & 6 & 0 & 24 & 0.0004*  \\
LSTM & real music & 6 & 2 & 22 & 0.0014 \\
  
    \bottomrule
  \end{tabular}
\end{table}


\begin{table}[h]
  \caption{Comparing each pair on their aggregates (comparisons with all models) in (wins, ties, losses), using the Mannâ€“Whitney U test for independent samples.}
  \label{table:listening_aggregates}
  \centering
  \begin{tabular}{lrlrrl}
    \toprule
     Model     &  & Model &  &  value      \\
    \midrule
Our relative transformer & (52, 6, 32) &  real music & (61, 6, 23) & 0.020 \\
Our relative transformer & (52, 6, 32) & Baseline transformer & (17, 4, 69) & 1.26e-9*\\
Our relative transformer & (52, 6, 32) & LSTM  & (39, 6, 45) & 0.018\\
Baseline transformer & (17, 4, 69) & LSTM & (39, 6, 45) & 3.70e-5* \\
Baseline transformer & (17, 4, 69) & real music & (61, 6, 23) & 6.73e-14*\\
LSTM & (39, 6, 45) & real music & (61, 6, 23) & 4.06e-5*\\
  
    \bottomrule
  \end{tabular}
\end{table}





\newpage
\section{Visualizing softmax attention}
\label{vis}
One advantage of attention-based models is that we can visualize its attention distribution~\ref{eqn:relative_dist}.  This gives us a glimpse of how the model might be building up recurring structures and how far it is attending back.  
The pianorolls in the visualizations below is a sample generated from Transformer with relative attention.   
Each figure shows a query (the source of all the attention lines) and previous memories being attended to (the notes that are receiving more softmax probabiliy is highlighted in).  The coloring of the attention lines correspond to different heads and the width to the weight of the softmax probability.


\begin{figure}[H]
\vskip -0.1in
\begin{center}
\centerline{\includegraphics[width=1.0\columnwidth]{attention_figures/triangle_pop.png}}
\caption{This piece has a recurring triangular contour.  The query is at one of the latter peaks and it attends to all of the previous high notes on the peak, all the way to beginning of the piece.}
\label{fig:triangle}
\end{center}
\vskip -0.1in
\end{figure}

\begin{figure}[H]
\vskip -0.1in
\begin{center}
\centerline{\includegraphics[width=1.0\columnwidth]{attention_figures/left_hand.png}}
\caption{The query a note in the left-hand, and it attends to its immediate past neighbors and mostly to the earlier left hand chords, with most attention lines distributed in the lower half of the pianoroll.}
\label{fig:triangle}
\end{center}
\vskip -0.1in
\end{figure}


\section{Previous figures for the ``skewing'' procedure}
\label{previous_skew}
\begin{figure}[H]
\vskip -0.05in
\begin{center}
\centerline{\includegraphics[width=0.5\columnwidth]{attention_figures/skew_attention_steps.pdf}}
\caption{Relative global attention: Steps (from left to right) for ``skewing'' an absolute-by-relative   indexed matrix into absolute-by-absolute . Grey indicates self-attention masks or entries introduced by the skewing procedure.  Positions with relative distance zero are marked. Entries outlined by purple are removed in step 3.}
\label{fig:skew}
\end{center}
\vskip -0.2in
\end{figure}


\begin{figure}[H]
\vskip -0.05in
\begin{center}
\centerline{\includegraphics[width=0.9\columnwidth]{attention_figures/relative_local_steps_all_in.pdf}}
\caption{Relative local attention: Steps (from left to right) for ``skewing'' an  indexed matrix with  ranged relative indices  into  indexed.  Shapes are indicated above the boxes, while indices in the boxes give relative distances.}
\label{fig:local_skew}
\end{center}
\vskip -0.2in
\end{figure}

































\end{document}
