\documentclass{article} 

\newcommand{\final}{1}

\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage[justification=raggedright]{caption}	\usepackage{lscape}                                         


\usepackage[lined,ruled,linesnumbered]{algorithm2e}

\usepackage{booktabs}                   \usepackage{multirow}

\usepackage{paralist}
\usepackage{enumitem}

\usepackage{bm}                          \usepackage{epsfig}                      \usepackage{graphicx}                  \usepackage{times}
\usepackage{mathptmx}
\usepackage{mathtools}
\usepackage{amssymb,amsmath}   \usepackage{scrextend}
\usepackage{tablefootnote}


\usepackage{units}
\usepackage{color}

\usepackage{comment}

\usepackage{url}  \usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

\usepackage{xspace}
\usepackage[table]{xcolor}
\usepackage{setspace}

\usepackage{layout}


 

\renewcommand{\baselinestretch}{1}       



\def\etal{et~al.\_}			  \def\eg{e.g.,~}               \def\ie{i.e.,~}               \def\etc{etc}                 \def\cf{cf.~}                 \def\viz{viz.~}               \def\vs{vs.~}                 


\DeclareMathOperator*{\argmin}{\arg\!\min} 
\DeclareMathOperator*{\argmax}{\arg\!\max}

\newlength\paramargin
\newlength\figmargin
\newlength\secmargin
\newlength\figcapmargin

\setlength{\secmargin}{-2.0mm}
\setlength{\paramargin}{-2.0mm}
\setlength{\figmargin}{0.0mm}
\setlength{\figcapmargin}{0.0mm}

\newcommand{\red}{\textcolor{red}}
\newcommand{\blue}{\textcolor{blue}}

\newcommand{\mpage}[2]
{
\begin{minipage}{#1\linewidth}\centering
#2
\end{minipage}
}


\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\ssecref}[1]{Section~\ref{ssec:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}} 
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\eqnref}[1]{\eqref{eq:#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\prgref}[1]{Program~\ref{#1}}
\newcommand{\algref}[1]{Algorithm~\ref{#1}}
\newcommand{\clmref}[1]{Claim~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\newcommand{\ptyref}[1]{Property~\ref{#1}}

\long\def\ignorethis#1{}
\newcommand {\jiabin}[1]{{\color{blue}\textbf{Jia-Bin: }#1}\normalfont}
\newcommand {\weiyu}[1]{{\color{red}\textbf{Wei-Yu: }#1}\normalfont}
\newcommand {\yencheng}[1]{{\color{magenta}\textbf{Yen-Cheng: }#1}\normalfont}
\newcommand {\zsolt}[1]{{\color{purple}\textbf{Zsolt: }#1}\normalfont}
\newcommand {\weiyureb}[1]{{\color{black}\textbf{}#1}\normalfont}
\newcommand {\weiyucam}[1]{{\color{red}\textbf{}#1}\normalfont}


\ifthenelse{\equal{\final}{1}}
{
\renewcommand{\jiabin}[1]{}
\renewcommand{\weiyu}[1]{}
\renewcommand{\yencheng}[1]{}
\renewcommand{\zsolt}[1]{}
}
{}


\newcommand {\todo}{{\textbf{\color{red}[TO-DO]\_}}}
\def\newtext#1{\textcolor{blue}{#1}}
\def\modtext#1{\textcolor{red}{#1}}
\newcommand{\note}[1]{{\it\color{blue} #1}}

\newcommand{\tb}[1]{\textbf{#1}}
\newcommand{\mb}[1]{\mathbf{#1}}

\newcommand{\jbox}[2]{
  \fbox{\begin{minipage}{#1}\hfill\vspace{#2}\end{minipage}}}

\newcommand{\jblock}[2]{\begin{minipage}[t]{#1}\vspace{0cm}\centering #2\end{minipage}}
 

\def\xi{\mathbf{x}_i}
\def\yi{\mathbf{y}_i}

\def \Xb {\mathbf{X}_b}
\def \Xn {\mathbf{X}_n}
\def \tXb{\tilde{X}_b}
\def \S  {\mathbf{S}}
\def \Sb {\mathbf{S}_b}
\def \Sn {\mathbf{S}_n}
\def \Q  {\mathbf{Q}}
\def \Qb {\mathbf{Q}_b}

\def \Feat {f_\theta}
\def \Clf {C}
\def \M {M}

\def \miniI {\emph{mini}-ImageNet }

\def\Wb{\mathbf{W}_b}
\def\Wn{\mathbf{W}_n}
\def\W{\mathbf{W}}
\def\w{\mathbf{w}}
\def\wi{\mathbf{w}_i}
\def\wc{\mathbf{w}_c} \graphicspath{{figure}, {example}}
 


\usepackage{iclr2019_conference}





\title{A Closer Look at Few-shot Classification}


\author{Wei-Yu Chen \\
Carnegie Mellon University\\
\texttt{weiyuc@andrew.cmu.edu} \\
\And
Yen-Cheng Liu \& Zsolt Kira~~~~~~~~~~~~~~~~~~~~~~\\
Georgia Tech \\
\texttt{\{ycliu,zkira\}@gatech.edu} \\
\AND
Yu-Chiang Frank Wang \\
National Taiwan University\\
\texttt{ycwang@ntu.edu.tw} \\
\And
Jia-Bin Huang \\
Virginia Tech \\
\texttt{jbhuang@vt.edu} \\
}






\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle




\begin{abstract}
Few-shot classification aims to learn a classifier to recognize unseen classes during training with limited labeled examples.
While significant progress has been made, the growing complexity of network designs, meta-learning algorithms, and differences in implementation details make a fair comparison difficult.
In this paper, we present 
1) a consistent comparative analysis of several representative few-shot classification algorithms, with results showing that deeper backbones significantly reduce the performance differences among methods on datasets with limited domain differences,
2) a modified baseline method that surprisingly achieves competitive performance when compared with the state-of-the-art on both the \miniI and the CUB datasets, and
3) a new experimental setting for evaluating the cross-domain generalization ability for few-shot classification algorithms.
Our results reveal that reducing intra-class variation is an important factor when the feature backbone is shallow, but not as critical when using deeper backbones.
In a realistic cross-domain evaluation setting, we show that a baseline method with a standard fine-tuning practice compares favorably against other state-of-the-art few-shot learning algorithms. 
\end{abstract}



 
\section{Introduction}
\label{sec:intro}


Deep learning models have achieved state-of-the-art performance on visual recognition tasks such as image classification. The strong performance, however, heavily relies on training a network with abundant labeled instances with diverse visual variations (e.g., thousands of examples for each new class even with pre-training on large-scale dataset with base classes). The human annotation cost as well as the scarcity of data in some classes (e.g., rare species) significantly limit the applicability of current vision systems to learn new visual concepts efficiently. In contrast, the human visual systems can recognize new classes with extremely few labeled examples. It is thus of great interest to learn to generalize to new classes with a limited amount of labeled examples for each novel class.

The problem of learning to generalize to unseen classes during training, known as \emph{few-shot classification}, has attracted considerable attention~\cite{vinyals2016matching,snell2017prototypical,finn2017model,ravi2017optimization,sung2018learning,garcia2018few,qi2018low}. One promising direction to few-shot classification is the meta-learning paradigm where transferable knowledge is extracted and propagated from a collection of tasks to prevent overfitting and improve generalization. Examples include model initialization based methods~\cite{ravi2017optimization,finn2017model}, metric learning methods~\cite{vinyals2016matching,snell2017prototypical,sung2018learning}, and hallucination based methods~\cite{antoniou2018data,hariharan2017low,wang2018low}. Another line of work~\cite{gidaris2018dynamic,qi2018low} also demonstrates promising results by directly predicting the weights of the classifiers for novel classes. 

\vspace{\paramargin}
\paragraph{Limitations.} While many few-shot classification algorithms have reported improved performance over the state-of-the-art, there are two main challenges that prevent us from making a fair comparison and measuring the actual progress. First, the discrepancy of the implementation details among multiple few-shot learning algorithms obscures the relative performance gain. The performance of baseline approaches can also be significantly under-estimated (e.g., training without data augmentation). Second, while the current evaluation focuses on recognizing novel class with limited training examples, these novel classes are sampled from \emph{the same} dataset. The lack of domain shift between the base and novel classes makes the evaluation scenarios unrealistic. 



\vspace{\paramargin}
\paragraph{Our work.} In this paper, we present a detailed empirical study to shed new light on the few-shot classification problem. First, we conduct consistent comparative experiments to compare several representative few-shot classification methods on common ground. Our results show that using a deep backbone shrinks the performance gap between different methods in the setting of limited domain differences between base and novel classes. Second, by replacing the linear classifier with a distance-based classifier as used in~\cite{gidaris2018dynamic,qi2018low}, the baseline method is surprisingly competitive to current state-of-art meta-learning algorithms. Third, we introduce a practical evaluation setting where there exists domain shift between base and novel classes (e.g., sampling base classes from generic object categories and novel classes from fine-grained categories). Our results show that sophisticated few-shot learning algorithms do not provide performance improvement over the baseline under this setting. Through making the source code and model implementations with a consistent evaluation setting publicly available, we hope to foster future progress in the field.\footnote{\url{https://github.com/wyharveychen/CloserLookFewShot}}



\vspace{\paramargin}
\paragraph{Our contributions.}
\begin{enumerate}[leftmargin=*]
\item We provide a unified testbed for several different few-shot classification algorithms for a fair comparison. Our empirical evaluation results reveal that the use of a shallow backbone commonly used in existing work leads to favorable results for methods that explicitly reduce intra-class variation. Increasing the model capacity of the feature backbone reduces the performance gap between different methods when domain differences are limited.
\item We show that a baseline method with a distance-based classifier surprisingly achieves competitive performance with the state-of-the-art meta-learning methods on both \miniI and CUB datasets.
\item We investigate a practical evaluation setting where base and novel classes are sampled from \emph{different} domains. We show that current few-shot classification algorithms fail to address such domain shifts and are inferior even to the baseline method, highlighting the importance of learning to adapt to domain differences in few-shot learning.
\end{enumerate}













 







\section{Related Work}
\label{sec:related}



Given abundant training examples for the base classes, few-shot learning algorithms aim to learn to recognizing novel classes with a limited amount of labeled examples. Much efforts have been devoted to overcome the data efficiency issue. In the following, we discuss representative few-shot learning algorithms organized into three main categories: initialization based, metric learning based, and hallucination based methods.

\vspace{\paramargin}
\paragraph{Initialization based methods} tackle the few-shot learning problem by ``learning to fine-tune". One approach aims to learn \emph{good model initialization} (i.e., the parameters of a network) so that the classifiers for novel classes can be learned with a limited number of labeled examples and a small number of gradient update steps~\cite{finn2017model,finn2018probabilistic,nichol2018reptile,rusu2018meta}. Another line of work focuses on \emph{learning an optimizer}. Examples include the LSTM-based meta-learner for replacing the stochastic gradient decent optimizer~\cite{ravi2017optimization} and the weight-update mechanism with an external memory~\cite{munkhdalai2017meta}.
While these initialization based methods are capable of achieving rapid adaption with a limited number of training examples for novel classes, our experiments show that these methods have difficulty in handling domain shifts between base and novel classes.












\vspace{\paramargin}
\paragraph{Distance metric learning based methods} address the few-shot classification problem by ``learning to compare". The intuition is that if a model can determine the similarity of two images, it can classify an unseen input image with the labeled instances~\cite{koch2015siamese}.
To learn a sophisticated comparison models, meta-learning based methods make their prediction conditioned on distance or metric to few labeled instances during the training process. Examples of distance metrics include cosine similarity~\cite{vinyals2016matching}, Euclidean distance to class-mean representation~\cite{snell2017prototypical}, CNN-based relation module~\cite{sung2018learning}, ridge regression~\cite{bertinetto2019meta}, and graph neural network~\cite{garcia2018few}. In this paper, we compare the performance of three distance metric learning methods. Our results show that a simple baseline method with a distance-based classifier (without training over a collection of tasks/episodes as in meta-learning) achieves competitive performance with respect to other sophisticated algorithms.




Besides meta-learning methods, both \cite{gidaris2018dynamic} and \cite{qi2018low} develop a similar method to our Baseline++ (described later in \secref{baselineplus}).  
The method in \cite{gidaris2018dynamic} learns a weight generator to predict the novel class classifier using an attention-based mechanism (cosine similarity), and the \cite{qi2018low} directly use novel class features as their weights. Our Baseline++ can be viewed as a simplified architecture of these methods. Our focus, however, is to show that simply reducing intra-class variation in a baseline method using the base class data leads to competitive performance. 


\vspace{\paramargin}
\paragraph{Hallucination based methods} directly deal with data deficiency by ``learning to augment". This class of methods learns a generator from data in the base classes and use the learned generator to hallucinate new novel class data for data augmentation.
One type of generator aims at transferring appearance variations exhibited in the base classes. These generators either transfer variance in base class data to novel classes ~\cite{hariharan2017low}, or use GAN models \cite{antoniou2018data} to transfer the style. Another type of generators does not explicitly specify what to transfer, but directly integrate the generator into a meta-learning algorithm for improving the classification accuracy~\cite{wang2018low}.
Since hallucination based methods often work with other few-shot methods together (e.g. use hallucination based and metric learning based methods together) and lead to complicated comparison, we do not include these methods in our comparative study and leave it for future work.


















\vspace{\paramargin}
\paragraph{Domain adaptation} techniques aim to reduce the domain shifts between source and target domain \cite{pan2010survey,ganin2015unsupervised}, as well as novel tasks in a different domain~\cite{hsu2017learning}. Similar to domain adaptation, we also investigate the impact of domain difference on few-shot classification algorithms in \ssecref{adapt}. In contrast to most domain adaptation problems where a large amount of data is available in the target domain (either labeled or unlabeled), our problem setting differs because we only have very few examples in the new domain. Very recently, the method in \cite{dong2018domain} addresses the one-shot novel category domain adaptation problem, where in the testing stage both the domain \emph{and} the category to classify are changed. Similarly, our work highlights the limitations of existing few-shot classification algorithms problem in handling domain shift. To put these problem settings in context, we provided a detailed comparison of setting difference in the appendix A1.








 \vspace{\secmargin}
\section{Overview of Few-shot classification Algorithms}
\label{sec:method}
\begin{figure*}[t!]
\includegraphics[width=\linewidth]{./figure/baseline.pdf}
\caption{\textbf{Baseline and Baseline++ few-shot classification methods.} Both the baseline and baseline++ method train a feature extractor  and classifier  with base class data in the training stage
In the fine-tuning stage, we fix the network parameters  in the feature extractor  and train a new classifier  with the given labeled examples in novel classes. The baseline++ method differs from the baseline model in the use of cosine distances between the input feature and the weight vector for each class that aims to reduce intra-class variations.
}
\label{fig:baseline}
\end{figure*}
 
In this section, we first outline the details of the baseline model (\secref{baseline}) and its variant (\secref{baselineplus}), followed by describing representative meta-learning algorithms (\secref{meta-learning}) studied in our experiments.
Given abundant base class labeled data  and a small amount of novel class labeled data , the goal of few-shot classification algorithms is to train classifiers for novel classes (unseen during training) with few labeled examples.


\vspace{\secmargin}
\subsection{Baseline}
\label{sec:baseline}
Our baseline model follows the standard transfer learning procedure of network pre-training and fine-tuning. \figref{baseline} illustrates the overall procedure.
\vspace{\paramargin}
\paragraph{Training stage.} We train a feature extractor  (parametrized by the network parameters ) and the classifier  (parametrized by the weight matrix ) from scratch by minimizing a standard cross-entropy classification loss  using the training examples in the base classes . Here, we denote the dimension of the encoded feature as  and the number of output classes as . The classifier  consists of a linear layer  followed by a softmax function .

\zsolt{REMOVED: Note that the training procedure in our baseline model does not involve sampling mini-batches of classes and data points (episode) as in typical meta-learning algorithms.}

\vspace{\paramargin}
\paragraph{Fine-tuning stage.} To adapt the model to recognize novel classes in the fine-tuning stage, we fix the pre-trained network parameter  in our feature extractor  and train a new classifier  (parametrized by the weight matrix ) by minimizing  using the few labeled of examples (i.e., the support set) in the novel classes .







\vspace{\secmargin}
\subsection{Baseline++}
\label{sec:baselineplus}

In addition to the baseline model, we also implement a variant of the baseline model, denoted as Baseline++, which explicitly reduces intra-class variation among features during training. The importance of reducing intra-class variations of features has been highlighted in deep metric learning~\cite{hu2015deep} and few-shot classification methods~\cite{gidaris2018dynamic}. 


The training procedure of Baseline++ is the same as the original Baseline model except for the classifier design. As shown in \figref{baseline}, we still have a weight matrix  of the classifier in the training stage and a  in the fine-tuning stage in Baseline++.
The classifier design, however, is different from the linear classifier used in the Baseline. Take the weight matrix  as an example. We can write the weight matrix  as , where each class has a -dimensional weight vector. 
In the training stage, for an input feature  where , we compute its cosine similarity to each weight vector  and obtain the similarity scores  
for all classes, where . 
We can then obtain the prediction probability for each class by normalizing these similarity scores with a softmax function.
Here, the classifier makes a prediction based on the cosine distance between the input feature and the learned weight vectors representing each class. Consequently, training the model with this distance-based classifier explicitly reduce intra-class variations.
Intuitively, the learned weight vectors  can be interpreted as prototypes (similar to \cite{snell2017prototypical,vinyals2016matching}) for each class and the classification is based on the distance of the input feature to these learned prototypes. The softmax function prevents the learned weight vectors collapsing to zeros.



We clarify that the network design in Baseline++ is \emph{not} our contribution. The concept of distance-based classification has been extensively studied in~\cite{mensink2012metric} and recently has been revisited in the few-shot classification setting~\cite{gidaris2018dynamic,qi2018low}. 


\vspace{\secmargin}
\subsection{Meta-learning algorithms}
\label{sec:meta-learning}
\begin{figure*}[t]
\includegraphics[width=\linewidth]{./figure/meta_learning.pdf}
\caption{\textbf{Meta-learning few-shot classification algorithms.} The meta-learning classifier  is conditioned on the support set . (\emph{Top}) In the meta-train stage, the support set  and the query set  are first sampled from random  classes, and then train the parameters in  to minimize the -way prediction loss . In the meta-testing stage, the adapted classifier  can predict novel classes with the support set in the novel classes . (\emph{Bottom}) The design of  in different meta-learning algorithms.}
\label{fig:meta_learning}
\end{figure*} Here we describe the formulations of meta-learning methods used in our study. We consider three distance metric learning based methods (MatchingNet~\cite{vinyals2016matching}, ProtoNet~\cite{snell2017prototypical}, and RelationNet~\cite{sung2018learning}) and one initialization based method (MAML~\cite{finn2017model}). While meta-learning is not a clearly defined, \cite{vinyals2016matching} considers a few-shot classification method as meta-learning if the prediction is conditioned on a small support set , because it makes the training procedure explicitly learn to learn from a given small support set. 

As shown in \figref{meta_learning}, meta-learning algorithms consist of a meta-training and a meta-testing stage. In the meta-training stage, the algorithm first randomly select  classes, and sample small base support set  and a base query set  from data samples within these classes. The objective is to train a classification model  that minimizes -way prediction loss  of the samples in the query set . 
Here, the classifier  is conditioned on provided support set . 
By making prediction conditioned on the given support set, a meta-learning method can learn how to learn from limited labeled data through training from a collection of tasks (episodes). In the meta-testing stage, all novel class data  are considered as the support set for novel classes , and the classification model  can be adapted to predict novel classes with the new support set . 

Different meta-learning methods differ in their strategies to make prediction conditioned on support set (see \figref{meta_learning}). For both MatchingNet~\cite{vinyals2016matching} and ProtoNet~\cite{snell2017prototypical}, the prediction of the examples in a query set  is based on comparing the distance between the query feature and the support feature from each class. MatchingNet compares cosine distance between the query feature and each support feature, and computes average cosine distance for each class, while ProtoNet compares the Euclidean distance between query features and the class mean of support features. RelationNet~\cite{sung2018learning} shares a similar idea, but it replaces distance with a learn-able relation module. 
The MAML method~\cite{finn2017model} is an initialization based meta-learning algorithm, where each support set is used to adapt the initial model parameters using few gradient updates. As different support sets have different gradient updates, the adapted model is conditioned on the support set. Note that when the query set instances are predicted by the adapted model in the meta-training stage, the loss of the query set is used to update the initial model, not the adapted model.
%
 \vspace{\secmargin}
\section{Experimental Results}
\label{sec:results}



\vspace{\secmargin}
\subsection{Experimental setup}
\label{sec:setup}
\vspace{\paramargin}
\paragraph{Datasets and scenarios.}
We address the few-shot classification problem under three scenarios: 
1) generic object recognition, 
2) fine-grained image classification, and 
3) cross-domain adaptation.

For object recognition, we use the \miniI dataset commonly used in evaluating few-shot classification algorithms. The \miniI dataset consists of a subset of 100 classes from the ImageNet dataset~\cite{deng2009imagenet} and contains 600 images for each class. The dataset was first proposed by \cite{vinyals2016matching}, but recent works use the follow-up setting provided by \cite{ravi2017optimization}, which is composed of randomly selected 64 base, 16 validation, and 20 novel classes.

For fine-grained classification, we use CUB-200-2011 dataset~\cite{wah2011caltech} (referred to as the CUB hereafter). The CUB dataset contains 200 classes and 11,788 images in total. Following the evaluation protocol of \cite{hilliard2018few}, we randomly split the dataset into 100 base, 50 validation, and 50 novel classes. 

For the cross-domain scenario (\miniICUB), we use \miniI as our base class and the 50 validation and 50 novel class from CUB. Evaluating the cross-domain scenario allows us to understand the effects of domain shifts to existing few-shot classification approaches.


\vspace{\paramargin}
\paragraph{Implementation details.} In the training stage for the Baseline and the Baseline++ methods, we train 400 epochs with a batch size of 16. In the meta-training stage for meta-learning methods, we train 60,000 episodes for 1-shot and 40,000 episodes for 5-shot tasks. We use the validation set to select the training episodes with the best accuracy.\footnote{For example, the exact episodes for experiments on the mini-ImageNet in the 5-shot setting with a four-layer ConvNet are: ProtoNet: 24,600; MatchingNet: 35,300; RelationNet: 37,100; MAML: 36,700.}  In each episode, we sample  classes to form -way classification ( is 5 in both meta-training and meta-testing stages unless otherwise mentioned). For each class, we pick  labeled instances as our support set and 16 instances for the query set for a -shot task.

In the fine-tuning or meta-testing stage for all methods, we average the results over 600 experiments. In each experiment, we randomly sample 5 classes from novel classes, and in each class, we also pick  instances for the support set and 16 for the query set. For Baseline and Baseline++, we use the entire support set to train a new classifier for 100 iterations with a batch size of 4. For meta-learning methods, we obtain the classification model conditioned on the support set as in \secref{meta-learning}.

All methods are trained from scratch and use the Adam optimizer with initial learning rate . We apply standard data augmentation including random crop, left-right flip, and color jitter in both the training or meta-training stage. Some implementation details have been adjusted individually for each method. 
For Baseline++, we multiply the cosine similarity by a class-wise learnable scalar to adjust original value range [-1,1] to be more appropriate for subsequent softmax layer.
For MatchingNet, we use an FCE classification layer without fine-tuning in all experiments and also multiply cosine similarity by a constant scalar.
For RelationNet, we replace the L2 norm with a softmax layer to expedite training. 
For MAML, we use a first-order approximation in the gradient for memory efficiency. 
The approximation has been shown in the original paper and in our appendix to have nearly identical  performance as the full version. We choose the first-order approximation for its efficiency. 

\vspace{\secmargin}
\subsection{Evaluation using the Standard Setting}
\label{sec:standard}
\begin{table}[t]
\caption{\textbf{Validating our re-implementation.} 
We validate our few-shot classification implementation on the \miniI dataset using a Conv-4 backbone. We report the mean of 600 randomly generated test episodes as well as the 95\% confidence intervals. Our reproduced results to all few-shot methods do not fall behind by more than 2\% to the reported results in the literature. We attribute the slight discrepancy to different random seeds and minor implementation differences in each method. ``Baseline" denotes the results without applying data augmentation during training. ProtoNet indicates performing 30-way classification in 1-shot and 20-way in 5-shot during the meta-training stage.}
\label{tab:validation}
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{}            & \multicolumn{2}{c}{\textbf{1-shot}}  & \multicolumn{2}{c}{\textbf{5-shot}} \\
\small{\textbf{Method}}            & \textbf{Reported} & \textbf{Ours}    & \textbf{Reported} & \textbf{Ours}   \\ \midrule
\small{\textbf{Baseline}}    & \small{-}                 & \small{42.11  0.71} & \small{-}                 & \small{62.53 0.69} \\ 
\small{\textbf{Baseline}}\tablefootnote{\label{note2}Reported results are from ~\cite{ravi2017optimization} }   & \small{41.08  0.70}  & \small{36.35  0.64} & \small{51.04  0.65}  & \small{54.50 0.66} \\ \midrule
\small{\textbf{MatchingNet}\footref{note2}~\cite{vinyals2016matching}} & \small{43.56  0.84}  & \small{48.14  0.78} & \small{55.31 0.73}    & \small{63.48 0.66} \\
\small{\textbf{ProtoNet}}    & \small{-}                 & \small{44.42  0.84} & \small{-}                 & \small{64.24 0.72} \\
\small{\textbf{ProtoNet}~\cite{snell2017prototypical}} & \small{49.42  0.78}  & \small{47.74  0.84} & \small{68.20 0.66}   & \small{66.68 0.68} \\
\small{\textbf{MAML}~\cite{finn2017model}} & \small{48.07  1.75}  & \small{46.47  0.82} & \small{63.15 0.91}   & \small{62.71 0.71} \\
\small{\textbf{RelationNet}~\cite{sung2018learning}} & \small{50.44  0.82}  & \small{49.31  0.85}  & \small{65.32 0.70}   & \small{66.60 0.69} \\ \bottomrule
\end{tabular}
\end{table}
 
\begin{table}[t]
\centering
\caption{\textbf{Few-shot classification results for both the \miniI and \textit{CUB} datasets.} The  Baseline++ consistently improves the Baseline model by a large margin and is competitive with the state-of-the-art meta-learning methods. All experiments are from 5-way classification with a Conv-4 backbone and data augmentation. }
\label{tab:CUB_miniI}
\begin{tabular}{lcccc}
\toprule
\textbf{}             & \multicolumn{2}{c}{\textbf{CUB}}        & \multicolumn{2}{c}{\textbf{\miniI}}                \\
\small{\textbf{Method}}             & \textbf{1-shot}    & \textbf{5-shot}    & \textbf{1-shot}    & \textbf{5-shot}    \\ \midrule
\small{\textbf{Baseline}}                                 & \small{47.12  0.74}     & \small{64.16  0.71}      & \small{42.11  0.71}      & \small{62.53 0.69}    \\
\small{\textbf{Baseline++}}                               & \small{60.53  0.83}     & \small{79.34  0.61} & \small{48.24  0.75}      & \small{66.43 0.63}   \\ \midrule
\small{\textbf{MatchingNet}} \cite{vinyals2016matching}   & \small{60.52  0.88}     & \small{75.29  0.75}      & \small{48.14  0.78}      & \small{63.48 0.66}    \\
\small{\textbf{ProtoNet}} \cite{snell2017prototypical}    & \small{50.46  0.88}     & \small{76.39  0.64}      & \small{44.42  0.84}      & \small{64.24 0.72}    \\
\small{\textbf{MAML}}  \cite{finn2017model}               & \small{54.73  0.97}     & \small{75.75  0.76}      & \small{46.47  0.82}      & \small{62.71 0.71}    \\
\small{\textbf{RelationNet}} \cite{sung2018learning}      & \small{62.34  0.94}     & \small{77.84  0.68}      & \small{49.31  0.85} & \small{66.60 0.69}    \\ \bottomrule
\end{tabular}
\end{table}
 
We now conduct experiments on the most common setting in few-shot classification, 1-shot and 5-shot classification, i.e., 1 or 5 labeled instances are available from each novel class. We use a four-layer convolution backbone (Conv-4) with an input size of 84x84 as in \cite{snell2017prototypical} and perform 5-way classification for only novel classes during the fine-tuning or meta-testing stage.

To validate the correctness of our implementation, we first compare our results to the reported numbers for the \miniI dataset in \tabref{validation}. Note that we have a ProtoNet, as we use 5-way classification in the meta-training and meta-testing stages for all meta-learning methods as mentioned in \secref{setup}; however, the official reported results from ProtoNet uses 30-way for one shot and 20-way for five shot in the meta-training stage in spite of using 5-way in the meta-testing stage. We report this result for completeness.

From \tabref{validation}, we can observe that all of our re-implementation for meta-learning methods do not fall more than  behind reported performance\zsolt{Why only mention meta-learning? What about the others? From what I can see, this is true for all cases for lower performance except 1-shot Baseline\*. In some cases yours are higher by more than 2\% though.}\weiyu{just want to skip the lower performance in 1-shot Baseline\*...}\zsolt{any ideas on the cause of the lower performance in that case (Baseline\* 1-shot)}.\weiyu{Not sure... Let me recap the problem. The issue is that our Baseline* in 1-shot is 36 while the Reported Baseline* in 1-shot is 41. 
It would not affect our conclusion that the current Baseline is underestimated due to lack of data augmentation since
1) Our Baseline (42) is better than reported Baseline*(41), which is what other often use and compares.
2) Our Baseline (42) improves our Baseline* (36) with data augmentation in all cases.

It is just a tricky issue that we didn't reproduce "Baseline*" as well as reported, so it is not 100 correctly to say our reproduction do not fall more than 2 behind released statistics. That is why I include "meta-learning methods".}
\zsolt{Even though our Baseline is better than their reported Baseline\* theirs is without augmentation, so it's feasible it could get better if you could replicate it and add augmentation. When I asked why we need it in the table at all, you said "that is what others compare to". Does that mean others don't typically add augmentation? In any case, since we make the argument that the baseline is underestimated (higher than other state of art under some conditions) perhaps it's OK. I think we need to put something about this though (we don't want them to point it out in reviews) and change this sentence to "our reproduction for all few-shot methods". } These minor differences can be attributed to  our modifications of some implementation details to ensure a fair comparison among all methods, such as using the same optimizer for all methods. 


Moreover, our implementation of existing work also improves the performance of some of the methods. For example, our results show that the Baseline approach under 5-shot setting can be improved by a large margin since previous implementations of the Baseline do not include data augmentation in their training stage, thereby leads to over-fitting. While our Baseline is not as good as reported in 1-shot, our Baseline with augmentation still improves on it, and could be even higher if our reproduced Baseline matches the reported statistics. In either case, \tb{the performance of the Baseline method is severely underestimated}. We also improve the results of MatchingNet by adjusting the input score to the softmax layer to a more appropriate range as stated in \secref{setup}. On the other hand, while ProtoNet is not as good as ProtoNet, as mentioned in the original paper a more challenging setting in the meta-training stage leads to better accuracy.  We choose to use a consistent 5-way classification setting in subsequent experiments to have a fair comparison to other methods. This issue can be resolved by using a deeper backbone as shown in \secref{backbone}.

After validating our re-implementation, we now report the accuracy in \tabref{CUB_miniI}. Besides additionally reporting results on the CUB dataset, we also compare Baseline++ to other methods. Here, we find that Baseline++ improves the Baseline by a large margin and becomes competitive even when compared with other meta-learning methods. The results demonstrate that \tb{reducing intra-class variation is an important factor in the current few-shot classification problem setting.}

However, note that our current setting only uses a 4-layer backbone, while a deeper backbone can inherently reduce intra-class variation. Thus, we conduct experiments to investigate the effects of backbone depth in the next section.

\vspace{\secmargin}
\subsection{Effect of increasing the network depth}
\label{sec:backbone}







\begin{figure*}[t]

   \begin{picture}(0,110)
     \put(15,7){\includegraphics[width=3.3cm]{./figure/s_deep_back_cub_1_shot_redo.pdf}}
\put(105,10){\includegraphics[width=3.3cm]{./figure/s_deep_back_cub_5_shot_redo.pdf}}
    \put(200,10){\includegraphics[width=3.3cm]{./figure/s_deep_back_cub_5_shot.pdf}}
     \put(295,10){\includegraphics[width=3.3cm]{./figure/s_deep_back_mini_5_shot.pdf}}
     
     \put(30,110){\includegraphics[width=12.5cm]{./figure/deep_back_note.pdf}}
     \put(100,105){CUB}
     \put(55,95){1-shot}
     \put(145,95){5-shot}
     
     \put(270,105){\miniI}
     \put(240,95){ 1-shot}
     \put(335,95){ 5-shot}



   \end{picture}
\vspace{-5mm}
\caption{ \tb{Few-shot classification accuracy vs. backbone depth}. In the CUB dataset, gaps among different methods diminish as the backbone gets deeper. In \miniI 5-shot, some meta-learning methods are even beaten by Baseline with a deeper backbone. (Please refer to ~\figref{backbone} and~\tabref{backbone} for larger figure and detailed statistics.)}
\label{fig:backbone_sqz}
\end{figure*}






 In this section, we change the depth of the feature backbone to reduce intra-class variation for all methods. See appendix for statistics on how network depth correlates with intra-class variation.  
Starting from Conv-4, we gradually increase the feature backbone to Conv-6, ResNet-10, 18 and 34, where Conv-6 have two additional convolution blocks without pooling after Conv-4. ResNet-18 and 34 are the same as described in \cite{he2016deep} with an input size of 224224, while ResNet-10 is a simplified version of ResNet-18 where only one residual building block is used in each layer. The statistics of this experiment would also be helpful to other works to make a fair comparison under different feature backbones.  

Results of the CUB dataset shows a clearer tendency in \figref{backbone_sqz}. As the backbone gets deeper, the gap among different methods drastically reduces. Another observation is how ProtoNet improves rapidly as the backbone gets deeper. While using a consistent 5-way classification as discussed in \secref{standard} degrades the accuracy of ProtoNet with Conv-4, it works well with a deeper backbone. Thus, the two observations above demonstrate that \textbf{in the CUB dataset, the gap among existing methods would be reduced if their intra-class variation are all reduced by a deeper backbone.}
  
However, the result of \miniI in \figref{backbone_sqz} is much more complicated. In the 5-shot setting, both Baseline and Baseline++ achieve good performance with a deeper backbone, but some meta-learning methods become worse relative to them. Thus, other than intra-class variation, we can assume that the dataset is also important in few-shot classification. One difference between CUB and \miniI is their domain difference in base and novel classes since classes in \miniI have a larger divergence than CUB in a word-net hierarchy~\cite{miller1995wordnet}. To better understand the effect, below we discuss how domain differences between base and novel classes impact few-shot classification results. 




\vspace{\secmargin}
\subsection{Effect of domain differences between base and novel classes}
\label{sec:domaindiff}
To further dig into the issue of domain difference, we design scenarios that provide such domain shifts. Besides the fine-grained classification and object recognition scenarios, we propose a new \emph{cross-domain scenario}: \miniICUB as mentioned in ~\secref{setup}. 
We believe that this is practical scenario since collecting images from a general class may be relatively easy (e.g. due to increased availability) but collecting images from fine-grained classes might be more difficult. \\

We conduct the experiments with a ResNet-18 feature backbone. As shown in \tabref{cross_result}, the Baseline outperforms all meta-learning methods under this scenario. While meta-learning methods learn to learn from the support set during the meta-training stage, they are not able to adapt to novel classes that are too different since all of the base support sets are within the same dataset. A similar concept is also mentioned in \cite{vinyals2016matching}. In contrast, the Baseline simply replaces and trains a new classifier based on the few given novel class data, which allows it to quickly adapt to a novel class and is less affected by domain shift between the source and target domains. The Baseline also performs better than the Baseline++ method, possibly because additionally reducing intra-class variation compromises adaptability. In \figref{domain_difference}, we can further observe how Baseline accuracy becomes relatively higher as the domain difference gets larger. That is, \textbf{as the domain difference grows larger, the adaptation based on a few novel class instances becomes more important.} 



\begin{figure}[!t]
\begin{minipage}[b]{0.5\textwidth}
\begin{tabular}{lc}
\toprule
                 & \tb{\miniICUB}   \\ 
                 \midrule
\tb{Baseline}    & \tb{65.570.70} \\ 
\tb{Baseline++}  & 62.040.76 \\ \midrule
\tb{MatchingNet} & 53.070.74 \\ 
\tb{ProtoNet}    & 62.020.70 \\ 
\tb{MAML}        & 51.340.72 \\ 
\tb{RelationNet} & 57.710.73 \\ \bottomrule
\end{tabular}
\captionof{table}{\tb{5-shot accuracy under the cross-domain scenario with a ResNet-18 backbone.} Baseline outperforms all other methods under this scenario. }
\label{tab:cross_result}
\end{minipage}
\hfill
\begin{minipage}[b]{0.5\textwidth}
\includegraphics[width=\linewidth]{./figure/domain_difference_results.pdf}
\captionof{figure}{ \tb{5-shot accuracy in different scenarios with a ResNet-18 backbone.} The Baseline model performs relative well with larger domain differences.  
}
\label{fig:domain_difference}
\end{minipage}
\end{figure} \begin{figure*}[t]

   \begin{picture}(0,145)
     \put(35,5){\includegraphics[width=3.1cm]{./figure/da_cub.png}}
     \put(145,5){\includegraphics[width=3.1cm]{./figure/da_mini.png}}
     \put(260,5){\includegraphics[width=3.1cm]{./figure/da_cross.png}}
     
     \put(135,135){\includegraphics[width=6cm]{./figure/da_list.png}}
     \put(85,123){CUB}     
     \put(173,123){\miniI}
     \put(275,123){CUB\miniI}



   \end{picture}
\vspace{-5mm}
\caption{\tb{Meta-learning methods with further adaptation steps.} Further adaptation improves MatchingNet and MAML, but has less improvement to RelationNet, and could instead harm ProtoNet under the scenarios with little domain differences.All statistics are for 5-shot accuracy with ResNet-18 backbone. Note that different methods use different further adaptation strategies.}
\label{fig:adapt}
\end{figure*}
 


\vspace{\secmargin}
\subsection{Effect of further adaptation}
\label{ssec:adapt}
To further adapt meta-learning methods as in the Baseline method, an intuitive way is to fix the features and train a new softmax classifier. We apply this simple adaptation scheme to MatchingNet and ProtoNet. For MAML, it is not feasible to fix the feature as it is an initialization method. In contrast, since it updates the model with the support set for only a few iterations, we can adapt further by updating for as many iterations as is required to train a new classification layer, which is 100 updates as mentioned in \secref{setup}. For RelationNet, the features are convolution maps rather than the feature vectors, so we are not able to replace it with a softmax. As an alternative, we randomly split the few training data in novel class into 3 support and 2 query data to finetune the relation module for 100 epochs.


The results of further adaptation are shown in \figref{adapt}; we can observe that the performance of MatchingNet and MAML improves significantly after further adaptation, particularly in the \miniICUB scenario. The results demonstrate that lack of adaptation is the reason they fall behind the Baseline. However, changing the setting in the meta-testing stage can lead to inconsistency with the meta-training stage. The ProtoNet result shows that performance can degrade in scenarios with less domain difference. Thus, we believe that \emph{learning how to adapt} in the meta-training stage is important future direction.
In summary, as domain differences are likely to exist in many real-world applications, we consider that \tb{learning to learn adaptation in the meta-training stage would be an important direction for future meta-learning research in few-shot classification.} \vspace{\secmargin}
\section{Conclusions}
\label{sec:conclusions}  
In this paper, we have investigated the limits of the standard evaluation setting for few-shot classification. Through comparing methods on a common ground, our results show that the Baseline++ model is competitive to state of art under standard conditions, and the Baseline model achieves competitive performance with recent state-of-the-art meta-learning algorithms on both CUB and \miniI benchmark datasets when using a deeper feature backbone. 
Surprisingly, the Baseline compares favorably against all the evaluated meta-learning algorithms under a realistic scenario where there exists domain shift between the base and novel classes. 
By making our source code publicly available, we believe that community can benefit from the consistent comparative experiments and move forward to tackle the challenge of potential domain shifts in the context of few-shot learning. 
 \paragraph{Acknowledgement.} 

 This work was supported in part by NSF under Grant No. 1755785 . We gratefully acknowledge the support of NVIDIA Corporation with the donation of the Titan Xp GPU. 

\bibliographystyle{iclr2019_conference}
\bibliography{iclr2019_conference}

\newpage
\setcounter{table}{0}
\setcounter{figure}{0}
\renewcommand{\thetable}{A\arabic{table}}
\renewcommand{\thefigure}{A\arabic{figure}}
\renewcommand{\thesubsection}{A\arabic{subsection}}

\section*{Appendix}
\subsection{Relationship between domain adaptation and few-shot classification}
As mentioned in \secref{related}, here we discuss the relationship between \emph{domain adaptation} and \emph{few-shot classification} to clarify different experimental settings. As shown in \tabref{da_fewshot}, in general, domain adaptation aims at adapting source dataset knowledge to the \emph{same} class in target dataset.
On the other hand, the goal of few-shot classification is to learn from base classes to classify \emph{novel} classes in the same dataset.

Several recent work tackle the problem at the intersection of the two fields of study. For example, cross-task domain adaptation \cite{hsu2017learning} also discuss novel classes in the target dataset. In contrast, while \cite{motiian2017few} has ``few-shot" in the title, their evaluation setting focuses on classifying the same class in the target dataset. 

If base and novel classes are both drawn from the same dataset, minor domain shift exists between the base and novel classes, as we demonstrated in \secref{domaindiff}. To highlight the impact of domain shift, we further propose the  \miniICUB setting. The domain shift in few-shot classification is also discussed in \cite{dong2018domain}.

\begin{table}[h]
\caption{\tb{Relationship between domain adaptation and few-shot classification.} The two field-of-studies have overlapping in the development. Notation "*" indicates minor domain shifts exist between base and novel classes. }
\label{tab:da_fewshot}
\begin{tabular}{c|ccc}
\toprule
& Domain shift & Source to target dataset & Base to novel class 
\\\midrule \midrule
\begin{tabular}[c]{@{}c@{}}Domain adaptation \\ \cite{motiian2017few}\end{tabular}          & V            & V                       & -                   \\ \midrule
\begin{tabular}[c]{@{}c@{}}Cross-task domain adaptation  \\ \cite{hsu2017learning}\end{tabular}                          & V            & V                       & V                   \\ \midrule
\begin{tabular}[c]{@{}c@{}}Few-shot classification              \\ \color{green}{Ours (CUB, \miniI)}\end{tabular}                       & *            & -                       & V                   \\ \midrule
\begin{tabular}[c]{@{}c@{}}Cross-domain few-shot\\  \color{green}{Ours (\miniICUB)} \\ \cite{dong2018domain}\end{tabular} & V            & V                       & V   \\      \bottomrule
\end{tabular}
\end{table}




%
 
\subsection{Terminology difference}
Different meta-learning works use different terminology in their works. 
We highlight their differences in appendix \tabref{terminology} to clarify the inconsistency.
\begin{table}[h]
\centering
\caption{\tb{Different terminology used in other works.} Notation "-" indicates the term is the same as in this paper.}
\label{tab:terminology}
\begin{tabular}{ c c c c c c }
\toprule 
\small{Our terms}        & \begin{tabular}[c]{@{}c@{}}\small{MatchingNet}\\   \small{\citeauthor{vinyals2016matching}}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\small{ProtoNet}\\ \small{\citeauthor{snell2017prototypical}}\\     \end{tabular} & \begin{tabular}[c]{@{}c@{}}\small{MAML}\\  \small{\citeauthor{finn2017model}}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\small{Meta-learn LSTM}\\   \small{\citeauthor{ravi2017optimization}}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\small{Imaginary}\\   \small{\citeauthor{wang2018low}}\end{tabular} \\ 
\midrule\midrule
\small{meta-training stage} & \small{training}  & \small{training} & \small{-}                & \small{-}                 & \small{-}              \\ 
\small{meta-testing stage}  & \small{test}     & \small{test}      & \small{-}                 & \small{-}                  & \small{-}             \\ \midrule 
\small{base class}       & \small{training set}   & \small{training set}   & \small{task}             & \small{meta-training set} & \small{-}             \\ 
\small{novel class}      & \small{test set}       & \small{test set}       & \small{new task}         & \small{meta-testing set}     & \small{-}             \\ \midrule
\small{support set}      & \small{-}              & \small{- }             & \small{sample}           & \small{training dataset}  & \small{training data} \\ 
\small{query set}        & \small{batch}          & \small{-}              & \small{test time sample} & \small{test dataset}      & \small{test data}     \\ \bottomrule 
\end{tabular}
\end{table}


%
 
\subsection{Additional results on Omniglot and OmniglotEMNIST}
For completeness, here we also show the results under two additional scenarios in 4) character recognition 5) cross-domain character recognition.

For character recognition, we use the Omniglot dataset \cite{lake2011one} commonly used in evaluating few-shot classification algorithms. Omniglot contains 1,623 characters from 50 languages, and we follow the evaluation protocol of \cite{vinyals2016matching} to first augment the classes by rotations in 90, 180, 270 degrees, resulting in 6492 classes. We then follow \cite{snell2017prototypical} to split these classes into 4112 base, 688 validation, and 1692 novel classes. Unlike \cite{snell2017prototypical}, our validation classes are only used to monitor the performance during meta-training.

For cross-domain character recognition (OmniglotEMNIST), we follow the setting of \cite{dong2018domain} to use Omniglot without Latin characters and without rotation augmentation as base classes, so there are 1597 base classes. On the other hand, EMNIST dataset \cite{cohen2017emnist} contains 10-digits and upper and lower case alphabets in English, so there are 62 classes in total. We split these classes into 31 validation and 31 novel classes, and invert the white-on-black characters to black-on-white as in  Omniglot. 

We use a Conv-4 backbone with input size 28x28 for both settings. As Omniglot characters are black-and-white, center-aligned and rotation sensitive, we do not use data augmentation in this experiment. To reduce the risk of over-fitting, we use the validation set to select the epoch or episode with the best accuracy for all methods, including baseline and baseline++.\footnote{The exact epoch of baseline and baseline++ on Omniglot and OmniglotEMNIST is 5 epochs} 

As shown in \tabref{omni_cchar}, in both Omniglot and OmniglotEMNIST settings, meta-learning methods outperform baseline and baseline++ in 1-shot. However, all methods reach comparable performance in the 5-shot classification setting. We attribute this to the lack of data augmentation for the baseline and baseline++ methods as they tend to over-fit base classes. When sufficient examples in novel classes are available, the negative impact of over-fitting is reduced.

\begin{table}[h]
\centering
\caption{\textbf{Few-shot classification results for both the \textit{Omniglot} and \textit{OmniglotEMNIST}.} All experiments are from 5-way classification with a Conv-4 backbone and without data augmentation. }

\label{tab:omni_cchar}
\begin{tabular}{lcccc}
\toprule
\textbf{}             & \multicolumn{2}{c}{\textbf{Omniglot}}        & \multicolumn{2}{c}{\textbf{OmniglotEMNIST}}                \\
\small{\textbf{Method}}             & \textbf{1-shot}    & \textbf{5-shot}    & \textbf{1-shot}    & \textbf{5-shot}    \\ \midrule
\small{\textbf{Baseline    }}& \small{94.89  0.45} & \small{99.12  0.13} & \small{63.94  0.87} & \small{86.00  0.59} \\
\small{\textbf{Baseline++  }}& \small{95.41  0.39} & \small{99.38  0.10} & \small{64.74  0.82} & \small{87.31  0.58} \\ \midrule
\small{\textbf{MatchingNet }}& \small{97.78  0.30} & \small{99.37  0.11} & \small{72.71  0.79} & \small{87.60  0.56} \\
\small{\textbf{ProtoNet    }}& \small{98.01  0.30} & \small{99.15  0.12} & \small{70.43  0.80} & \small{87.04  0.55} \\
\small{\textbf{MAML        }}& \small{98.57  0.19} & \small{99.53  0.08} & \small{72.04  0.83} & \small{88.24  0.56} \\
\small{\textbf{RelationNet }}& \small{97.22  0.33} & \small{99.30  0.10} & \small{75.55  0.87} & \small{88.94  0.54} \\ \bottomrule
\end{tabular}
\vspace{-0.25cm}
\end{table}
 
\subsection{Baseline with 1-NN classifier}
Some prior work (\cite{vinyals2016matching}) apply a Baseline with 1-NN classifier in the test stage. We include our result as in \tabref{nearest_neighbor}. The result shows that using 1-NN classifier has better performance than that of using the softmax classifier in 1-shot setting, but softmax classifier performs better in 5-shot setting. We note that the number here are not directly comparable to results in \cite{vinyals2016matching} because we use a different \miniI as in \cite{ravi2017optimization}.
\begin{table}[h]
\centering
\caption{\tb{Baseline with softmax and 1-NN classifier in test stage.} We note that we use cosine distance in 1-NN.}
\label{tab:nearest_neighbor}
\begin{tabular}{ccccc}
\toprule
           & \multicolumn{2}{c}{\tb{1-shot}}              & \multicolumn{2}{c}{\tb{5-shot}}  \\
           & \tb{softmax}        & \tb{1-NN} & \tb{softmax}        & \tb{1-NN}\\
\midrule
\small{\tb{Baseline}}   & 42.110.71 & 44.180.69 & 62.530.69 & 56.680.67\\
\small{\tb{Baseline++}} & 48.240.75 & 49.570.73 & 66.430.63 & 61.930.65\\ \bottomrule      
\end{tabular}
\vspace{-1cm}
\end{table} 
\newpage
\subsection{MAML and MAML with first-order approximation}
As discussed in \secref{setup}, we use first-order approximation MAML to improve memory efficiency in all of our experiments. To demonstrate this design choice does not affect the accuracy, we compare their validation accuracy trends on Omniglot with 5-shot as in \figref{mamltrend}. We observe that while the full version MAML converge faster, both versions reach similar accuracy in the end.

This phenomena is consistent with the difference of first-order (e.g. gradient descent) and second-order methods (e.g. Newton) in convex optimization problems.
Second-order methods converge faster at the cost of memory, but they both converge to similar objective value.

\begin{figure*}[h]
\centering
\includegraphics[width=0.5\linewidth]{./figure/maml_trend.png}
\caption{\textbf{Validation accuracy trends of MAML and MAML with first order approximation.} Both versions converge to the same validation accuracy. The experimental results are on Omniglot with 5-shot with a Conv-4 backbone.}
\label{fig:mamltrend}
\end{figure*}
 
\subsection{Intra-class variation and backbone depth}
As mentioned in \secref{backbone}, here we demonstrate decreased intra-class variation as the network depth gets deeper as in \figref{DBindex}. We use the Davies-Bouldin index~\cite{davies1979cluster} to measure intra-class variation. The Davies-Bouldin index is a metric to evaluate the tightness in a cluster (or class, in our case). Our results show that both intra-class variation in the base and novel class feature decrease using deeper backbones. 

\begin{figure*}[h]

   \begin{picture}(0,170)
\put(20,10){\includegraphics[width=6.5cm]{./figure/db_base.pdf}}
     \put(205,10){\includegraphics[width=6.5cm]{./figure/db_novel.pdf}}
     \put(60,150){\includegraphics[width=10cm]{./figure/db_note.pdf}}

     \put(80,140){Base class feature}
     \put(265,140){Novel class feature}
     \put(0,40){\rotatebox{90}{Davies-Bouldin index}}
     \put(10,40){\rotatebox{90}{(Intra-class variation)}}
   \end{picture}
\caption{\tb{Intra-class variation decreases as backbone gets deeper.} Here we use Davies-Bouldin index to represent intra-class variation, which is a metric to evaluate the tightness in a cluster (or class, in our case). The statistics are Davies-Bouldin index for all base and novel class feature (extracted by feature extractor learned after training or meta-training stage) for CUB dataset under different backbone.}
\label{fig:DBindex}
\end{figure*} 

\subsection{Detailed statistics in effects of increasing backbone depth } 
Here we show a high-resolution version of \figref{backbone_sqz} in \figref{backbone} and show detailed statistics in \tabref{backbone} for easier comparison.

\begin{figure*}[h]

   \begin{picture}(0,225)
\put(25,115){\includegraphics[width=5.5cm]{./figure/deep_back_cub_1_shot_redo.pdf}}

     \put(210,115){\includegraphics[width=5.8cm]{./figure/deep_back_mini_1_shot.pdf}}
\put(25,0){\includegraphics[width=5.5cm]{./figure/deep_back_cub_5_shot_redo.pdf}}

\put(210,5){\includegraphics[width=5.8cm]{./figure/deep_back_mini_5_shot.pdf}}
     \put(30,220){\includegraphics[width=12cm]{./figure/deep_back_note.pdf}}
     \put(95,212){CUB}
     \put(260,212){\miniI}
     \put(5,160){\rotatebox{90}{1-shot}}
     \put(5,55){\rotatebox{90}{5-shot}}

   \end{picture}
\vspace{-5mm}
\caption{ \tb{Few-shot classification accuracy vs. backbone depth}. In the CUB dataset, gaps among different methods diminish as the backbone gets deeper. In \miniI 5-shot, some meta-learning methods are even beaten by Baseline with a deeper backbone.}
\label{fig:backbone}
\end{figure*}

\begin{table}[h]
\centering
\caption{\tb{Detailed statistics in \figref{backbone_sqz}.} We put exact value here for reference.}
\label{tab:backbone}
\begin{tabular}{c|cccccc}
\toprule
                             &                  & Conv-4         & Conv-6         & Resnet-10      & Resnet-18      & Resnet-34      \\ \midrule
\multirow{6}{*}{\begin{tabular}[c]{@{}c@{}}CUB\\   1-shot\end{tabular}} 
& \small{\tb{Baseline}}    & \small{47.120.74} & \small{55.770.86} & \small{63.340.91} & \small{65.510.87} & \small{67.960.89} \\
& \small{\tb{Baseline++}}  & \small{60.530.83} & \small{66.000.89} & \small{69.550.89} & \small{67.020.90} & \small{68.000.83} \\ 
& \small{\tb{MatchingNet}} & \small{60.520.88} & \small{66.470.93} & \small{71.290.87} & \small{73.490.89} & \small{73.490.89 } \\
& \small{\tb{ProtoNet}}    & \small{ 50.460.88 } & \small{ 66.361.00 } & \small{ 73.220.92 } & \small{ 72.990.88 } & \small{ 72.940.91 } \\
& \small{\tb{MAML}}        & \small{ 54.730.97 } & \small{ 66.261.05 } & \small{ 70.320.99 } & \small{ 68.421.07 } & \small{ 67.281.08 } \\
& \small{\tb{RelationNet}} & \small{ 62.340.94 } & \small{ 64.380.94 } & \small{ 70.470.99 } & \small{ 68.580.94 } & \small{ 69.720.98 } \\ \midrule 
\multirow{6}{*}{\begin{tabular}[c]{@{}c@{}}CUB\\   5-shot\end{tabular}} 
& \small{\tb{Baseline}}    & \small{64.160.71} & \small{73.070.71} & \small{81.270.57} & \small{82.850.55} & \small{84.270.53} \\
& \small{\tb{Baseline++}}  & \small{79.340.61} & \small{82.020.55} & \small{85.170.50} & \small{83.580.54} & \small{84.500.51} \\
& \small{\tb{MatchingNet}} & \small{75.290.75} & \small{77.920.65} & \small{83.470.58} & \small{84.450.58} & \small{86.510.52} \\
& \small{\tb{ProtoNet}}    & \small{76.390.64} & \small{82.030.59} & \small{85.010.52} & \small{86.640.51} & \small{87.860.47} \\
& \small{\tb{MAML}}        & \small{75.750.76} & \small{78.820.70} & \small{80.930.71} & \small{83.470.62} & \small{83.470.59} \\
& \small{\tb{RelationNet}} & \small{77.840.68} & \small{80.160.64} & \small{83.700.55} & \small{84.050.56} & \small{83.180.54}
\\ \midrule 
\multirow{6}{*}{\begin{tabular}[c]{@{}c@{}}\miniI\\   1-shot\end{tabular}} 
& \small{\tb{Baseline}}    & \small{42.110.71} & \small{45.820.74} & \small{52.370.79} & \small{51.750.80} & \small{49.820.73} \\
& \small{\tb{Baseline++}}  & \small{48.240.75} & \small{48.290.72} & \small{53.970.79} & \small{51.870.77} & \small{52.650.83} \\
& \small{\tb{MatchingNet}} & \small{48.140.78} & \small{50.470.86} & \small{54.490.81} & \small{52.910.88} & \small{53.200.78} \\
& \small{\tb{ProtoNet}}    & \small{44.420.84} & \small{50.370.83} & \small{51.980.84} & \small{54.160.82} & \small{53.900.83} \\
& \small{\tb{MAML}}        & \small{46.470.82} & \small{50.960.92} & \small{54.690.89} & \small{49.610.92} & \small{51.460.90} \\
& \small{\tb{RelationNet}} & \small{49.310.85} & \small{51.840.88} & \small{52.190.83} & \small{52.480.86} & \small{51.740.83} \\ \midrule 
\multirow{6}{*}{\begin{tabular}[c]{@{}c@{}}\miniI\\   5-shot\end{tabular}}
& \small{\tb{Baseline}}    & \small{62.530.69} & \small{66.420.67} & \small{74.690.64} & \small{74.270.63} & \small{73.450.65} \\
& \small{\tb{Baseline++}}  & \small{66.430.63} & \small{68.090.69} & \small{75.900.61} & \small{75.680.63} & \small{76.160.63} \\
& \small{\tb{MatchingNet}} & \small{63.480.66} & \small{63.190.70} & \small{68.820.65} & \small{68.880.69} & \small{68.320.66} \\
& \small{\tb{ProtoNet}}    & \small{64.240.72} & \small{67.330.67} & \small{72.640.64} & \small{73.680.65} & \small{74.650.64} \\
& \small{\tb{MAML}}        & \small{62.710.71} & \small{66.090.71} & \small{66.620.83} & \small{65.720.77} & \small{65.900.79} \\
& \small{\tb{RelationNet}} & \small{66.600.69} & \small{64.550.70} & \small{70.200.66} & \small{69.830.68} & \small{69.610.67} \\ \bottomrule
                                
\end{tabular}


\end{table} 

\newpage



\subsection{More-way in meta-testing stage} 
We experiment with a practical setting that handles different testing scenarios. Specifically, we conduct the experiments of 5-way meta-training and N-way meta-testing (where N = 5, 10, 20) to examine the effect of testing scenarios that are different from training.

As in \tabref{practical}, we compare the methods Baseline, Baseline++, MatchingNet, ProtoNet, and RelationNet. Note that we are unable to apply the MAML method as MAML learns the initialization for the classifier and can thus only be updated to classify the same number of classes. Our results show that for classification with a larger N-way in the meta-testing stage, the proposed Baseline++ compares favorably against other methods in both shallow or deeper backbone settings.

We attribute the results to two reasons. First, to perform well in a larger N-way classification setting, one needs to further reduce the intra-class variation to avoid misclassification. Thus, Baseline++ has better performance than Baseline in both backbone settings. Second, as meta-learning algorithms were trained to perform 5-way classification in the meta-training stage, the performance of these algorithms may drop significantly when increasing the N-way in the meta-testing stage because the tasks of 10-way or 20-way classification are harder than that of 5-way one. 

One may address this issue by performing a larger N-way classification in the meta-training stage (as suggested in \cite{snell2017prototypical}). However, it may encounter the issue of memory constraint. For example, to perform a 20-way classification with 5 support images and 15 query images in each class, we need to fit a batch size of 400 (20 x (5 + 15)) that must fit into the GPUs. Without special hardware parallelization, the large batch size may prevent us from training models with deeper backbones such as ResNet. 

\begin{table}[h]
\centering
\caption{\tb{5-way meta-training and N-way meta-testing experiment.} The experimental results are on mini-ImageNet with 5-shot. We could see Baseline++ compares favorably against other methods in both shallow or deeper backbone settings.}
\label{tab:practical}
\begin{tabular}{ccccccc}
\toprule
            &                & \tb{Conv-4}      &                &                & \tb{ResNet-18}   &                \\
\tb{N-way test} &\tb{5-way} &\tb{10-way}&\tb{20-way}&\tb{5-way} &\tb{10-way}&\tb{20-way}\\
\midrule
\small{\tb{Baseline}}    & \small{62.530.69} & \small{46.440.41} & \small{32.270.24} & \small{74.270.63} & \small{55.000.46} & \small{42.030.25} \\
\small{\tb{Baseline++}}  & \small{66.430.63} & \small{\tb{52.260.40}} & \small{\tb{38.030.24}} & \small{\tb{75.680.63}} & \small{\tb{63.400.44}} & \small{\tb{50.850.25}} \\
\midrule
\small{\tb{MatchingNet}} & \small{63.480.66} & \small{47.610.44} & \small{33.970.24} & \small{68.880.69} & \small{52.270.46} & \small{36.780.25} \\
\small{\tb{ProtoNet}}   & \small{64.240.68} & \small{48.770.45} & \small{34.580.23} & \small{73.680.65} & \small{59.220.44} & \small{44.960.26} \\
\small{\tb{RelationNet}} & \small{\tb{66.600.69}} & \small{47.770.43} & \small{33.720.22} & \small{69.830.68} & \small{53.880.48} & \small{39.170.25} \\

\bottomrule
\end{tabular}
\end{table}  
\end{document}
