\documentclass[twoside,reqno,11pt]{amsart}
\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem*{ex}{Example}

\numberwithin{equation}{section}

\newcommand{\symb}[1]{{\tt #1}}

\setcounter{topnumber}{1}
\renewcommand{\vec}[1]{\boldsymbol{\mathrm{#1}}}
\newcommand{\vtt}[1]{\begin{flushleft}\begin{shaded}{\bf VTT: #1}\end{shaded}\end{flushleft}}
\newcommand{\mvectdiff}[1]{ \nabla_#1 }

\newcommand {\grpart}[1]{\ensuremath{\left\langle #1 \right\rangle  }}
	
\newcommand {\version}[3]{\fbox{Version: #1 ; status: #2 ; #3}}

\newtheorem{lstlist}{Listing}

\usepackage{amsfonts, amsmath, amssymb,latexsym}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}
\usepackage{color}
\usepackage{listings}
\usepackage{color}
\usepackage{comment}
\usepackage{framed}
\usepackage{float}

\definecolor{labelcolor}{RGB}{100,0,0}
\definecolor{outputcolor}{RGB}{0,0,100}
\colorlet{shadecolor}{yellow!30}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.20 , 0.40, 1.0}

\floatstyle{plaintop}
\newfloat{listing}{thp}{lop}
\floatname{listing}{Listing}

\makeatletter
\renewcommand{\verbatim@font}{\footnotesize\ttfamily}
\makeatother

\begin{document}

\title[Clifford and Tensor Algebras in Maxima]{Sparse Representations of Clifford and Tensor algebras in Maxima}

\author{Dimiter Prodanov\textsuperscript{1}}

\address{
	Department of Environment, Health and Safety,
	Neuroscience Research Flanders,
	IMEC vzw, Leuven, Belgium
}
\email{dimiterpp@gmail.com; \, dimiter.prodanov@imec.be }

\author{Viktor T. Toth \textsuperscript{2}}
\address{Center for Research on Integrated Sensors Platforms
	Carleton University
    Ottawa, Ontario, Canada
}
\email{vttoth@vttoth.com}

\subjclass{Primary 08A70; 11E88; Secondary 94B27, 53A45, 15A69}

\keywords{computer algebra; geometric algebra; tensor calculus; Maxwell's equations}

\newcommand{\Addresses}{{\bigskip
		\footnotesize
		
	 \textsuperscript{1} Department of Environment, Health and Safety,
	 Neuroscience Research Flanders,
	 IMEC vzw, Leuven, Belgium
		
	\medskip
		
	\textsuperscript{2} Center for Research on Integrated Sensors Platforms
	Carleton University
	Ottawa, Ontario, Canada		
	}}
	
\begin{abstract}
Clifford algebras have broad applications in science and engineering. The use of Clifford algebras can be further promoted in these fields by availability of computational tools that automate tedious routine calculations.
We offer an extensive demonstration of the applications of Clifford algebras in electromagnetism using the geometric algebra  as a computational model in the Maxima computer algebra  system.
We compare the geometric algebra-based approach with conventional symbolic tensor calculations supported by Maxima, based on the \symb{itensor} package.
The Clifford algebra functionality of Maxima is distributed as two new packages  called  \symb{clifford} - for basic  simplification of Clifford products, outer products, scalar products and inverses; and \symb{cliffordan} - for applications of geometric calculus.
\end{abstract}

\maketitle

\Addresses


\section{Introduction}
\label{sec:intro}

While Computer Algebra Systems (CAS) cannot replace mathematical intuition, they can facilitate routine calculations and teaching.
This paper focuses on applications of two packages implementing abstract algebras in the popular open-source {\em Maxima} CAS:
the \symb{itensor} package implementing indicial tensor manipulation and a new package for Clifford algebra called \symb{clifford}, along with its companion package \symb{cliffordan}.
While an extensive overview of the Maxima system is not our objective, we offer some details that demonstrate the major advantages of Maxima over purely numerical systems, such as Matlab (Mathworks, Natick, MA, USA).

\subsection{System level functionality}
\label{sec:maxintro}

Maxima is derived from one of the first ever computer algebra systems, MACSYMA (Project MAC's SYmbolic MAnipulation System),  developed by the Mathlab group of the MIT Laboratory for Computer Science during the years 1969-1972.
Maxima is written entirely in Lisp and is distributed under open source license\footnote{Maxima is distributed under GNU General Public License and developed and supported by a group of volunteers}.
Maxima has its own programming language, which is particularly well-suited for handling symbolical mathematical expressions or mixed numerical-symbolical expressions.
In addition, the system supports 64-bit precision floating point and arbitrary precision arithmetics.
Maxima programs can be automatically translated and compiled to Lisp within the program environment itself.
Third-party Lisp programs can be also loaded and accessed from within the system.
The system also offers the possibility of running batch unit tests.

Maxima supports several primitive data types \cite{M2015}:
\textit{numbers} (rational, float and arbitrary precision);
\textit{strings} and \textit{symbols}.
In addition there are compound data types, such as \textit{lists},
 \textit{arrays}, \textit{matrices} and \textit{structs}.
There are also special symbolic constants, such as the Boolean constants \symb{true} and \symb{false} or the complex imaginary unit \symb{\%i}.


Several types of operators can be defined in Maxima.
An operator is a defined symbol that may be  \textit{unary} \symb{prefix}, \textit{unary} \symb{postfix}, \textit{binary} \symb{infix}, \textit{n-ary} \symb{matchfix}, or \symb{nofix} types.
For example, the inner and outer products defined in \symb{clifford} are of the \symb{binary infix} type.
The scripting language allows for defining new operators with specified precedence or redefining the precedence of existing operators.
Maxima distinguishes between two forms of applications of operators -- forms which are \symb{noun}s and forms which are \symb{verb}s.
The difference is that the \symb{verb} form of an operator evaluates its arguments and produces an output result, while the \symb{noun} form appears as an inert symbol in an expression, without being executed.
A \symb{verb} form can be mutated into a \symb{noun} form and vice-versa.
This allows for context-dependent evaluation, which is especially suited for symbolic processing.

\subsection{Expression representation and transformation in Maxima}
\label{sec:expr}

\begin{figure}[ht]
\includegraphics[width=0.4\linewidth]{lisp.eps}
\caption{\label{fig:lisp}Expression representation in Lisp. A general expression can be represented as a list with the first element being the operator  \symb{op} and the rest of the elements representing operator arguments. For instance, the expression \symb{op(a,b)} will be represented by the list \symb{(op a b)}, which is the ordered pair of the atom \symb{op}, and another list, \symb{(a b)}, which, in turn, is represented by another ordered pair.}
\end{figure}

\begin{figure}[ht]
\includegraphics[width=0.6\linewidth]{flowchart.eps}	
\caption{Expression simplification in Maxima.}
\label{fig:flowchart}
\end{figure}

\begin{listing}
\caption{\label{lst:definitions}Dot products and exponent simplification rules in   \symb{clifford}.}
{\color{labelcolor}\begin{verbatim}
if get('clifford,'version)=false then (
	tellsimp(aa[kk].aa[kk], signature[kk] ),
	tellsimpafter(aa[kk].aa[mm], dotsimp2(aa[kk].aa[mm])),
	tellsimpafter(bb.ee.cc, dotsimpc(bb.ee.cc)),
	tellsimpafter(aa[kk]^nn, powsimp(aa[kk]^nn)),
	tellsimpafter(aa[kk]^^nn, powsimp(aa[kk]^^nn))
);
\end{verbatim}}
\end{listing}

The manner in which Maxima represents expressions, function calls and index expressions using the Lisp language is particularly relevant for the \symb{itensor} and \symb{clifford} packages. In the underlying Lisp representation a Maxima \textit{expression} is a tree containing sequences of operators, numbers and symbols. Every Maxima expression is simultaneously also a \textit{lambda} construct and its value is the value of the last assigned member. This is a design feature inherited from Lisp. Maxima expressions are represented by underlying Lisp constructs. The core concept of the Lisp language is  the idea of a  \textit{list} representation of the language constructs. Or, to be more precise, the idea of an ordered pair, the first element of which is the head (or {\tt car}), the second element the tail (or \symb{cdr}) of the list  (see. Fig. \ref{fig:lisp}). List elements are themselves either \textit{lists} or   \textit{atoms}: e.g., a number, a symbol, or the empty list (\symb{nil}). This representation enables the possibility to define transformation rules. In such way a part of an expression can be matched against a pattern and transformed to another expression.

A very powerful feature of the system is the ability to define custom transformation rules. Various transformation rules can be associated with any given operator in Maxima. Maxima has an advanced pattern matching mechanism, which supports nesting of operators and simplification (see Fig. \ref{fig:flowchart}). The simplifier subroutine operates by descending the tree of an expression until it gets to atoms, and then simplifies the smallest pieces and backs out.

User-defined rules can be added to the built-in simplifier using one of two  commands: \symb{tellsimp} or \symb{tellsimpafter}. Rules in both sets are identified by the main operator. Rules specified using \symb{tellsimp} are applied  before the built-in simplification, while \symb{tellsimpafter} rules are applied after the built-in simplification.
The augmented simplification is then treated as built-in, so subsequent tellsimp rules are applied before those defined previously.
An example is given in Listing~\ref{lst:definitions} used in the implementation of \symb{clifford}.

This rule-based approach to computer algebra is particularly suitable to implement ``sparse'' representations of algebraic objects. For instance, a tensor object may be defined only in terms of its indices and the transformation rules that it obeys, without ever assigning values to tensor components. This is how tensors are implemented in the \symb{itensor} package of Maxima. Similarly, a multivector can be defined symbolically as a linear combination of basis vectors, without ever assigning those basis vectors any specific values or representing them by matrices.
This is the approach followed by the built-in \symb{atensor} package and the \symb{clifford} package that is described in the present paper.

\section{Tensor algebra representations in Maxima}
\label{sec:itensor}

Tensors are abstract objects that describe multilinear relations between geometric objects.
A coordinate-independent way to define tensors is by multilinear maps.
In this approach, a tensor  of type  is defined as a map that is linear in each of its arguments, by the equation

where  is a field,  is a (finite-dimensional) vector space over , while  is the corresponding dual space of co-vectors.

Maxima has two major packages for tensor manipulation. The \symb{ctensor} package implements component representation of tensors, with functionality that is especially tailored for applications in general relativity. The \symb{itensor} package treats tensors as opaque objects, manipulated via their indices. As such, \symb{itensor} is especially suited for computations where general covariance is maintained, including general relativity. The package has built-in support for the metric and curvature tensors, for covariant differentiation, for the Kronecker delta, and for utilizing the symmetry properties of tensors for algebraic simplification. All this is accomplished without the need to define tensor components.

The \symb{itensor} package also has facilities for tensor calculus, including functional differentiation with respect to tensor quantities. These facilities make it possible to use \symb{itensor} to investigate field theories that are formulated using a Lagrangian density functional. By way of a demonstrative example, let us consider the Lagrangian density for the Maxwell field (hereafter we assume that indices run from 1 through the number of dimensions , and we use the Einstein summation convention, ):

where  is the electromagnetic field tensor corresponding to the 4-potential .

The Euler-Lagrange equation that corresponds to this Lagrangian is written as


where  is the covariant derivative with respect to the coordinate .

For the sake of simplicity of discussion, we restrict the presentation to rectilinear coordinates of special relativity, such that the square root of metric determinant  can be assumed to be constant and removed from consideration, and covariant derivatives can be replaced with ordinary partial derivatives with respect to the coordinates, i.e., . Under these circumstances, the Euler-Lagrange equation becomes



The first term in this equation is trivial: , as follows directly from the definition of . As to the second term, we first note that


and that

thus

Therefore

where we used the common shorthand notation  for ordinary partial coordinate derivatives. Finally, we can now put everything together and obtain the explicit form of the Euler-Lagrange equation, which amounts to the definition of the 4-current:


\begin{ex}
In the following Maxima code snippets, input expressions in Maxima are sequentially labeled by \symb{\%i{\em N}}, while the output may be labeled by \symb{\%o{\em N}}, where {\em N} is a number, starting with 1, that is incremented by 1 for each new input line. Commands are grouped together between parentheses. Multiple commands can be entered by separating them with a comma. The semicolon or the dollar sign terminate a command line; the latter can be used if the suppression of output is desired (e.g., to avoid cluttering the terminal display with very large intermediate expressions.) For clarity of presentation the output labels are suppressed and the expressions are colored. Expressions are only minimally edited for improvement of readability.

To carry out the derivation (\ref{eq:MaxLag})--(\ref{eq:MaxTens}) using \symb{itensor} in Maxima, after loading the package and configuring the metric (see Listing~\ref{lst:tensor} in the Appendix), we define the tensor  in terms of its components and construct \footnote{The {\tt ishow} command is a built-in ``pretty print'' feature of {\tt itensor} to display tensor quantities}:
{\color{labelcolor}\begin{verbatim}
 ((+j([k],[])*A([l],[])*g([],[k,l]))F_{\mu\nu}F_{\mu\nu}F_{\mu\nu}F_{\mu\nu}\sqrt{-g}\lbrace e_1 \ldots e_n\rbrace\mathbb{K}10vC\ell(V, Q) Q(v)\mathbb{K}vv^2C\ell_{p,q,r} (\mathbb{K})p+q+r=np1q-1r0C\ell_{p,q,r} (\mathbb{R})Q(v) \neq 0A2^n P (V) \{1,e_1,...,e_n,e_1e_2,e_1e_3,...,e_1e_2...e_n\}abk01A\langle~\rangle_k A^\star  A^\sim C\ell_{p,q,r}k\bmod 4A^\sim++--A^\star+--+r \neq 0x\left\lbrace  e_1,   \ldots , e_n \right\rbrace x=\sum_{i=1}^n x^ke_ke_ke^k=e_k^{-1}\epsilon >0\cdot|C\ell_{0,2}cc = a + b\, e_1+c \, e_2+d \, e_1 \cdot e_2\mathbb{G}^3=C\ell_{3,0}c=\mu_0 =\epsilon_0 =1FJi\vec{E}\vec{B}x,y,z\ne 0G \left(x,y,z \right)CV(x,u,z)C= i\nabla_r  i V\vec{F}\vec{EE}\vec{BB}\mathbb{G}^3\vec{F}\vec{F} \mathbb{G}^3\mathbb{G}^3\mathcal{L}\left(q,\partial_x q \right) q \partial_x   qxq=AfFAA\mathcal{L}_{EM} = - \frac{1}{2} \left\langle F \, F^\star \right\rangle_0AEBjq\frac{1}{2}(E^2-B^2)J_0n2^nP(V)
remcomps(F);
decsym(F,0,2,[],[anti(all)]);
ishow(diff(L,A([m],[],n)))
load("cliffordan.mac")
clifford(e,3)
dependsv(A,[t,x,y,z])
r:cvect([x,y,z]);
/* The 4-potential with gauge freedom */
a:celem(A,[t,x,y,z])+mvectdiff(f,t+r);
dA:mvectdiff(a,t-r);
/* The electromagnetic field */
F:lambda([x],x-scalarpart(x)-grpart(x,4))(mvectdiff(a,t-r));
/* The Maxwell Lagrangian */
L:lambda([x],1/2*scalarpart(cliffsimpall(-x.cconjugate(x))))(F);
/* spatial field variable */
b:vectorpart(a);
/* The magnetic field */
B:factorby(cliffsimpall(-/* The electric field */
E:factorby(diff(b,t)-mvectdiff(scalarpart(a),r),makelist(asymbol[i],i,1,ndim));
/* The current density and charge density, which are conserved */
j:factorby(cliffsimpall(diff(E,t)-vvectdiff(q:svectdiff(E,r);
svectdiff(q+j,t-r);
/* Maxwell's equations */
cliffsimpall(-svectdiff(B,r);
/* Verifying the Lagrangian */
1/2*(E.E-B.B)-L,expand;
/* The Euler-Lagrange equation */
EL:EuLagEq2(L,t+r,[a,dA]);
bdecompose(EL);
EL+(q+j);
/* Introducing an external current */
dependsv(J,[t,x,y,z]);
A0:celem(A,[t,x,y,z]);
J0:celem(J,[t,x,y,z]);
EL:EuLagEq2(L+scalarpart(A0.J0),t+r,[a,dA]);
bdecompose(EL);
EL+q+j-J0,expand;
\end{verbatim}}
\end{listing}

\clearpage

\end{document}
